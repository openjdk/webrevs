{"files":[{"patch":"@@ -67,1 +67,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -73,1 +73,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -80,1 +80,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -86,1 +86,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -92,2 +92,2 @@\n-            debian-version: sid\n-            tolerate-sysroot-errors: true\n+            debian-version: trixie\n+            tolerate-sysroot-errors: false\n","filename":".github\/workflows\/build-cross-compile.yml","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -128,1 +128,2 @@\n-if [ -d \"$TOPLEVEL_DIR\/.git\" ] ; then\n+# Git worktrees use a '.git' file rather than directory, so test both.\n+if [ -d \"$TOPLEVEL_DIR\/.git\" -o -f \"$TOPLEVEL_DIR\/.git\" ] ; then\n","filename":"bin\/idea.sh","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1454,4 +1454,4 @@\n-<pre><code>bash configure --with-devkit=&lt;devkit-path&gt; --openjdk-target=ppc64-linux-gnu &amp;&amp; make<\/code><\/pre>\n-<p>will configure and build the JDK for Linux\/ppc64 assuming that\n-<code>&lt;devkit-path&gt;<\/code> points to a Linux\/x86_64 to Linux\/ppc64\n-devkit.<\/p>\n+<pre><code>bash configure --with-devkit=&lt;devkit-path&gt; --openjdk-target=ppc64le-linux-gnu &amp;&amp; make<\/code><\/pre>\n+<p>will configure and build the JDK for Linux\/ppc64le assuming that\n+<code>&lt;devkit-path&gt;<\/code> points to a Linux\/x86_64 to\n+Linux\/ppc64le devkit.<\/p>\n@@ -1484,1 +1484,1 @@\n-<td>ppc64-linux-gnu<\/td>\n+<td>ppc64le-linux-gnu<\/td>\n@@ -1487,1 +1487,1 @@\n-<td>ppc64le-linux-gnu<\/td>\n+<td>riscv64-linux-gnu<\/td>\n","filename":"doc\/building.html","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1261,1 +1261,1 @@\n-bash configure --with-devkit=<devkit-path> --openjdk-target=ppc64-linux-gnu && make\n+bash configure --with-devkit=<devkit-path> --openjdk-target=ppc64le-linux-gnu && make\n@@ -1264,2 +1264,2 @@\n-will configure and build the JDK for Linux\/ppc64 assuming that `<devkit-path>`\n-points to a Linux\/x86_64 to Linux\/ppc64 devkit.\n+will configure and build the JDK for Linux\/ppc64le assuming that `<devkit-path>`\n+points to a Linux\/x86_64 to Linux\/ppc64le devkit.\n@@ -1284,1 +1284,0 @@\n-| ppc64-linux-gnu          |\n@@ -1286,0 +1285,1 @@\n+| riscv64-linux-gnu        |\n","filename":"doc\/building.md","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+<li><a href=\"#avoid-implicit-conversions-to-bool\"\n+id=\"toc-avoid-implicit-conversions-to-bool\">Avoid implicit conversions\n+to bool<\/a><\/li>\n@@ -75,0 +78,3 @@\n+<li><a href=\"#non-type-template-parameter-values\"\n+id=\"toc-non-type-template-parameter-values\">Non-type template parameter\n+values<\/a><\/li>\n@@ -80,0 +86,2 @@\n+<li><a href=\"#inline-variables\" id=\"toc-inline-variables\">Inline\n+Variables<\/a><\/li>\n@@ -85,0 +93,2 @@\n+<li><a href=\"#mandatory-copy-elision\"\n+id=\"toc-mandatory-copy-elision\">Mandatory Copy Elision<\/a><\/li>\n@@ -91,0 +101,8 @@\n+<li><a href=\"#enhanced-selection-statements\"\n+id=\"toc-enhanced-selection-statements\">Enhanced selection\n+statements<\/a><\/li>\n+<li><a href=\"#expression-evaluation-order\"\n+id=\"toc-expression-evaluation-order\">Expression Evaluation\n+Order<\/a><\/li>\n+<li><a href=\"#compatibility-with-c11\"\n+id=\"toc-compatibility-with-c11\">Compatibility with C11<\/a><\/li>\n@@ -94,0 +112,1 @@\n+<\/ul><\/li>\n@@ -95,0 +114,10 @@\n+Features<\/a>\n+<ul>\n+<li><a href=\"#structured-bindings\"\n+id=\"toc-structured-bindings\">Structured Bindings<\/a><\/li>\n+<li><a href=\"#file-system-library\" id=\"toc-file-system-library\">File\n+System Library<\/a><\/li>\n+<li><a href=\"#aggregate-extensions\"\n+id=\"toc-aggregate-extensions\">Aggregate Extensions<\/a><\/li>\n+<li><a href=\"#additional-excluded-features\"\n+id=\"toc-additional-excluded-features\">Additional Excluded\n@@ -96,0 +125,1 @@\n+<\/ul><\/li>\n@@ -97,0 +127,19 @@\n+Features<\/a>\n+<ul>\n+<li><a href=\"#stdoptional\"\n+id=\"toc-stdoptional\">std::optional&lt;&gt;<\/a><\/li>\n+<li><a href=\"#stdbyte\" id=\"toc-stdbyte\">std::byte<\/a><\/li>\n+<li><a href=\"#string-views\" id=\"toc-string-views\">String Views<\/a><\/li>\n+<li><a href=\"#substring-and-subsequence-searching\"\n+id=\"toc-substring-and-subsequence-searching\">Substring and Subsequence\n+Searching<\/a><\/li>\n+<li><a href=\"#new-and-delete-with-over-aligned-data\"\n+id=\"toc-new-and-delete-with-over-aligned-data\"><code>new<\/code> and\n+<code>delete<\/code> with Over-Aligned Data<\/a><\/li>\n+<li><a href=\"#stdto_chars-and-stdfrom_chars\"\n+id=\"toc-stdto_chars-and-stdfrom_chars\"><code>std::to_chars()<\/code> and\n+<code>std::from_chars<\/code><\/a><\/li>\n+<li><a href=\"#stdlaunder\"\n+id=\"toc-stdlaunder\"><code>std::launder()<\/code><\/a><\/li>\n+<li><a href=\"#additional-undecided-features\"\n+id=\"toc-additional-undecided-features\">Additional Undecided\n@@ -212,0 +261,10 @@\n+<h4 id=\"conventions-for-lock-free-code\">Conventions for Lock-free\n+Code<\/h4>\n+<p>Sometimes variables are accessed concurrently without appropriate\n+synchronization context, such as a held mutex or at a safepoint. In such\n+cases the variable should be declared <code>volatile<\/code> and it\n+should NOT be accessed as a normal C++ lvalue. Rather, access should be\n+performed via functions from <code>Atomic<\/code>, such as\n+<code>Atomic::load<\/code>, <code>Atomic::store<\/code>, etc.<\/p>\n+<p>This special formulation makes it more clear to maintainers that the\n+variable is accessed concurrently in a lock-free manner.<\/p>\n@@ -411,7 +470,2 @@\n-<h3 id=\"miscellaneous\">Miscellaneous<\/h3>\n-<ul>\n-<li><p>Use the <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/raii\"\n-title=\"Resource Acquisition Is Initialization\">Resource Acquisition Is\n-Initialization<\/a> (RAII) design pattern to manage bracketed critical\n-sections. See class <code>ResourceMark<\/code> for an example.<\/p><\/li>\n-<li><p>Avoid implicit conversions to <code>bool<\/code>.<\/p>\n+<h3 id=\"avoid-implicit-conversions-to-bool\">Avoid implicit conversions\n+to bool<\/h3>\n@@ -424,3 +478,11 @@\n-<li>Do not use declarations in <em>condition<\/em> forms, i.e. don't use\n-<code>if (T v = value) { ... }<\/code>.<\/li>\n-<\/ul><\/li>\n+<li>Do not use non-boolean declarations in <em>condition<\/em> forms,\n+i.e. don't use <code>if (T v = value) { ... }<\/code>. But see <a\n+href=\"#enhanced-selection-statements\">Enhanced selection\n+statements<\/a>.<\/li>\n+<\/ul>\n+<h3 id=\"miscellaneous\">Miscellaneous<\/h3>\n+<ul>\n+<li><p>Use the <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/raii\"\n+title=\"Resource Acquisition Is Initialization\">Resource Acquisition Is\n+Initialization<\/a> (RAII) design pattern to manage bracketed critical\n+sections. See class <code>ResourceMark<\/code> for an example.<\/p><\/li>\n@@ -438,1 +500,1 @@\n-More recently, support for C++14 is provided, though again, HotSpot only\n+More recently, support for C++17 is provided, though again, HotSpot only\n@@ -444,4 +506,4 @@\n-C++11 and C++14 may be explicitly permitted or explicitly excluded, and\n-discussed accordingly here. There is a third category, undecided\n-features, about which HotSpot developers have not yet reached a\n-consensus, or perhaps have not discussed at all. Use of these features\n+C++11, C++14, and C++17 may be explicitly permitted or explicitly\n+excluded, and discussed accordingly here. There is a third category,\n+undecided features, about which HotSpot developers have not yet reached\n+a consensus, or perhaps have not discussed at all. Use of these features\n@@ -456,3 +518,3 @@\n-<p>Lists of new features for C++11 and C++14, along with links to their\n-descriptions, can be found in the online documentation for some of the\n-compilers and libraries. The C++14 Standard is the definitive\n+<p>Lists of new features for C++11, C++14, and C++17, along with links\n+to their descriptions, can be found in the online documentation for some\n+of the compilers and libraries. The C++17 Standard is the definitive\n@@ -655,0 +717,5 @@\n+<li><p><code>auto<\/code> for non-type template parameters (<a\n+href=\"http:\/\/wg21.link\/p0127r2\">p0127r2<\/a>)<br> <code>auto<\/code> may\n+be used as a placeholder for the type of a non-type template parameter.\n+The type is deduced from the value provided in a template\n+instantiation.<\/p><\/li>\n@@ -659,0 +726,17 @@\n+<li><p>Class template argument deduction (<a\n+href=\"http:\/\/wg21.link\/n3602\">n3602<\/a>, <a\n+href=\"http:\/\/wg21.link\/p0091r3\">p0091r3<\/a>)<br> The template arguments\n+of a class template may be deduced from the arguments to a constructor.\n+This is similar to ordinary function argument deduction, though partial\n+deduction with only <em>some<\/em> template arguments explicitly provided\n+is not permitted for class template argument deduction. Deduction guides\n+may be used to provide additional control over the deduction. As with\n+<code>auto<\/code> variable declarations, excessive use can make code\n+harder to understand, because explicit type information is lacking. But\n+it can also remove the need to be explicit about types that are either\n+obvious, or that are very hard to write. For example, these allow the\n+addition of a scope-guard mechanism with nice syntax; something like\n+this<\/p><\/li>\n+<\/ul>\n+<pre><code>  ScopeGuard guard{[&amp;]{ ... cleanup code ... }};<\/code><\/pre>\n+<ul>\n@@ -661,0 +745,5 @@\n+<li><p><code>decltype(auto)<\/code> should be avoided, whether for\n+variables, for non-type template parameters, or for function return\n+types. There are subtle and complex differences between this placeholder\n+type and <code>auto<\/code>. Any use would need very careful\n+explanation.<\/p><\/li>\n@@ -685,0 +774,9 @@\n+<h3 id=\"non-type-template-parameter-values\">Non-type template parameter\n+values<\/h3>\n+<p>C++17 extended the arguments permitted for non-type template\n+parameters (<a href=\"http:\/\/wg21.link\/n4268\">n4268<\/a>). The kinds of\n+values (the parameter types) aren't changed. However, the values can now\n+be the result of arbitrary constant expressions (with a few restrictions\n+on the result), rather than a much more limited and restrictive set of\n+expressions. In particular, the argument for a pointer or reference type\n+parameter can now be the result of a constexpr function.<\/p>\n@@ -798,0 +896,28 @@\n+<h3 id=\"inline-variables\">Inline Variables<\/h3>\n+<p>Variables with static storage duration may be declared\n+<code>inline<\/code> (<a href=\"https:\/\/wg21.link\/p0386r2\">p0386r2<\/a>).\n+This has similar effects as for declaring a function inline: it can be\n+defined, identically, in multiple translation units, must be defined in\n+every translation unit in which it is <a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/definition\"\n+title=\"One Definition Rule\">ODR used<\/a>, and the behavior of the\n+program is as if there is exactly one variable.<\/p>\n+<p>Declaring a variable inline allows the complete definition to be in a\n+header file, rather than having a declaration in a header and the\n+definition in a .cpp file. The guidance on <a\n+href=\"#initializing-variables-with-static-storage-duration\">initialization<\/a>\n+of such variables still applies. Inline variables with dynamic\n+initializations can make initialization order problems worse. The few\n+ordering constraints that exist for non-inline variables don't apply, as\n+there isn't a single program-designated translation unit containing the\n+definition.<\/p>\n+<p>A <code>constexpr<\/code> static data member is implicitly\n+<code>inline<\/code>. As a consequence, an <a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/definition\"\n+title=\"One Definition Rule\">ODR use<\/a> of such a variable doesn't\n+require a definition in some .cpp file. (This is a change from\n+pre-C++17. Beginning with C++17, such a definition is considered a\n+duplicate definition, and is deprecated.)<\/p>\n+<p>Declaring a <code>thread_local<\/code> variable <code>inline<\/code> is\n+forbidden for HotSpot code. <a href=\"#thread_local\">The use of\n+<code>thread_local<\/code><\/a> is already heavily restricted.<\/p>\n@@ -849,0 +975,39 @@\n+<h3 id=\"mandatory-copy-elision\">Mandatory Copy Elision<\/h3>\n+<p><a href=\"https:\/\/en.wikipedia.org\/wiki\/Copy_elision\">Copy elision<\/a>\n+(or <a\n+href=\"https:\/\/cn.cppreference.com\/w\/cpp\/language\/copy_elision.html\">here<\/a>)\n+is a compiler optimization used to avoid potentially expensive copies in\n+certain situations. It is critical to making practical the performance\n+of return by value or pass by value. It is also unusual in not following\n+the as-if rule for optimizations - copy elision can be applied even if\n+doing so bypasses side-effects of copying\/moving the object. The C++\n+standard explicitly permits this.<\/p>\n+<p>However, because it's an optional optimization, the relevant\n+copy\/move constructor must be available and accessible, in case the\n+compiler chooses to not apply the optimization even in a situation where\n+permitted.<\/p>\n+<p>C++17 changed some cases of copy elision so that there is never a\n+copy\/move in these cases (<a\n+href=\"http:\/\/wg21.link\/p0135r1\">p0135r1<\/a>). The interesting cases\n+involve a function that returns an unnamed temporary object, and\n+constructors. In such cases the object being initialized from the\n+temporary is always direct initialized, with no copy\/move ever involved;\n+see <a href=\"https:\/\/en.wikipedia.org\/wiki\/Copy_elision#RVO\"\n+title=\"Return Value Optimization\">RVO<\/a> and more specifically <a\n+href=\"https:\/\/cn.cppreference.com\/w\/cpp\/language\/copy_elision.html\"\n+title=\"Unnamed Return Value Optimization\">URVO<\/a>.<\/p>\n+<p>Since this is now standard behavior it can't be avoided in the\n+covered situations. This could change the behavior of code that relied\n+on side effects by constructors, but that's both uncommon and was\n+already problematic because of the previous optional copy elision. But\n+HotSpot code can, and should, explicitly take advantage of this newly\n+required behavior where it makes sense to do so.<\/p>\n+<p>For example, it may be beneficial to delay construction of the result\n+of a function until the return statement, rather than having a local\n+variable that is modified into the desired state and then returned.\n+(Though <a href=\"https:\/\/en.wikipedia.org\/wiki\/Copy_elision#NRVO\"\n+title=\"Named Return Value Optimization\">NRVO<\/a> may apply in that\n+case.)<\/p>\n+<p>It is also now possible to define a factory function for a class that\n+is neither movable nor copyable, if it can be written in a way that\n+makes use of this feature.<\/p>\n@@ -921,0 +1086,7 @@\n+<p>A lambda is a constexpr function if either the parameter declaration\n+clause is followed by <code>constexpr<\/code>, or it satisfies the\n+requirements for a constexpr function (<a\n+href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2016\/p0170r1.pdf\">p0170r1<\/a>).\n+Thus, using a lambda to package up some computation doesn't incur\n+unnecessary overhead or prevent use in a context required to be\n+compile-time evaluated (such as an array size).<\/p>\n@@ -968,0 +1140,12 @@\n+<li><p>By-value capture of <code>this<\/code> (using a capture list like\n+<code>[*this]<\/code> (<a\n+href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2016\/p0018r3.html\">p0018r3<\/a>))\n+is also not permitted. One of the motivating use-cases is when the\n+lifetime of the lambda exceeds the lifetime of the object for the\n+containing member function. That is, we have an upward lambda that is\n+capturing <code>this<\/code> of the enclosing method. But again, that\n+use-case doesn't apply if only downward lambdas are used. Another\n+use-case is when we simply want the lambda to be operating on a copy of\n+<code>this<\/code> for some reason. This is sufficiently uncommon that it\n+can be handled by manual copying, so readers don't need to understand\n+this rare syntax.<\/p><\/li>\n@@ -977,2 +1161,1 @@\n-<\/ul>\n-<p>The use of <code>mutable<\/code> lambda expressions is forbidden\n+<li><p>The use of <code>mutable<\/code> lambda expressions is forbidden\n@@ -984,1 +1167,3 @@\n-HotSpot developers to understand this relatively obscure feature.<\/p>\n+HotSpot developers to understand this relatively obscure\n+feature.<\/p><\/li>\n+<\/ul>\n@@ -1102,17 +1287,6 @@\n-revisions (<a\n-href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2015\/p0136r1.html\"\n-title=\"p0136r1\">p0136r1<\/a> opens with a list of 8 Core Issues). Since\n-HotSpot doesn't support use of C++17, use of inherited constructors\n-could run into those problems. Such uses might also change behavior in a\n-future HotSpot update to use C++17 or later, potentially in subtle ways\n-that could lead to hard to diagnose problems. Because of this, HotSpot\n-code must not use inherited constructors.<\/p>\n-<p>Note that gcc7 provides the <code>-fnew-inheriting-ctors<\/code>\n-option to use the <a\n-href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2015\/p0136r1.html\"\n-title=\"p0136r1\">p0136r1<\/a> semantics. This is enabled by default when\n-using C++17 or later. It is also enabled by default for\n-<code>fabi-version=11<\/code> (introduced by gcc7) or higher when using\n-C++11\/14, as the change is considered a Defect Report that applies to\n-those versions. Earlier versions of gcc don't have that option, and\n-other supported compilers may not have anything similar.<\/p>\n+revisions (<a href=\"http:\/wg21.link\/p0136r1\" title=\"p0136r1\">p0136r1<\/a>\n+opens with a list of 8 Core Issues). Although those issues have been\n+addressed, the benefits from this feature are small compared to the\n+complexity. Because of this, HotSpot code must not use inherited\n+constructors.<\/p>\n+<p><a href=\"http:\/\/wg21.link\/p0195r0\">p0195r0<\/a><\/p>\n@@ -1134,0 +1308,2 @@\n+<p><a href=\"http:\/\/wg21.link\/p0068r0\">p0068r0<\/a> is the initial\n+proposal for the attributes added by C++17.)<\/p>\n@@ -1137,0 +1313,6 @@\n+<li><code>[[nodiscard]]<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0189r1\">p0189r1<\/a>)<\/li>\n+<li><code>[[maybe_unused]]<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0212r1\">p0212r1<\/a>)<\/li>\n+<li><code>[[fallthrough]]<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0188\">p0188r1<\/a>)<\/li>\n@@ -1144,0 +1326,17 @@\n+<p>Direct use of non-standard (and presumably scoped) attributes in\n+shared code is also forbidden. Using such would depend on the C++17\n+feature that an attribute not recognized by the implementation is\n+ignored (<a href=\"http:\/\/wg21.link\/p0283r2\">p0283r2<\/a>). If such an\n+attribute is needed in shared code, the well-established technique of\n+providing an <code>ATTRIBUTE_XXX<\/code> macro with per-compiler\n+definitions (sometimes empty) should be used. Compilers may warn about\n+unrecognized attributes (whether by name or by location), in order to\n+report typos or misuse. Disabling such warnings globally would not be\n+desirable.<\/p>\n+<p>The use of <code>using<\/code> directives in attribute lists is also\n+forbidden. (<a href=\"http:\/\/wg21.link\/p0028r0\">p0028r0<\/a>) (<a\n+href=\"http:\/\/wg21.link\/p0028r4\">p0028r4<\/a>) We don't generally use\n+scoped attributes in attribute lists with other attributes. Rather, uses\n+of scoped attributes (which are implementation defined) are generally\n+hidden behind a portability macro that includes the surrounding\n+brackets.<\/p>\n@@ -1193,0 +1392,4 @@\n+<p>The exception specification is part of the type of a function (<a\n+href=\"http:\/\/wg21.link\/p0012r1\">p0012r1<\/a>. This likely has little\n+impact on HotSpot code, since the use of <code>noexcept<\/code> is\n+expected to be rare.<\/p>\n@@ -1196,0 +1399,59 @@\n+<h3 id=\"enhanced-selection-statements\">Enhanced selection\n+statements<\/h3>\n+<p>C++17 modified the <em>condition<\/em> part of <code>if<\/code> and\n+<code>switch<\/code> statements, permitting an <em>init-statement<\/em> to\n+be included (<a href=\"http:\/\/wg21.link\/p0305r1\">p0305r1<\/a>).<\/p>\n+<p>Use of this feature is permitted. (However, complex uses may\n+interfere with readability.) Limiting the scope of a variable involved\n+in the condition, while also making the value available to the\n+statement's body, can improve readability. The alternative method of\n+scope-limiting by introducing a nested scope isn't very popular and is\n+rarely used.<\/p>\n+<p>This new syntax is in addition to the <em>condition<\/em> being a\n+declaration with a <em>brace-or-equal-initializer<\/em>. For an\n+<code>if<\/code> statement this new sytax gains that benefit without\n+violating the long-standing guidance against using <a\n+href=\"#avoid-implicit-conversions-to-bool\">implicit conversions to\n+<code>bool<\/code><\/a>, which still stands.<\/p>\n+<p>For example, uses of Unified Logging sometimes explicitly check\n+whether a <code>LogTarget<\/code> is enabled. Instead of<\/p>\n+<pre><code>  LogTarget(...) lt;\n+  if (lt.is_enabled()) {\n+    LogStream log(lt);\n+    ... use log ...\n+  }\n+  ... lt is accessible but probably not needed here ...<\/code><\/pre>\n+<p>using this feature one could write<\/p>\n+<pre><code>  if (LogTarget(...) lt; lt.is_enabled()) {\n+    LogStream log(lt);\n+    ... use log ...\n+  }<\/code><\/pre>\n+<p>C++17 also added compile-time <code>if<\/code> statements (<a\n+href=\"http:\/\/wg21.link\/p0292r2\">p0292r2<\/a>). Use of\n+<code>if constexpr<\/code> is permitted. This feature can replace and\n+(sometimes vastly) simplify many uses of <a\n+href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/sfinae\"\n+title=\"Substitution Failure Is Not An Error\">SFINAE<\/a>. The same\n+declaration and initialization guidance for the <em>condition<\/em> part\n+apply here as for ordinary <code>if<\/code> statements.<\/p>\n+<h3 id=\"expression-evaluation-order\">Expression Evaluation Order<\/h3>\n+<p>C++17 tightened up the evaluation order for some kinds of\n+subexpressions (<a href=\"http:\/\/wg21.link\/p0138r2\">p0138r2<\/a>). Note,\n+however, that the Alternate Evaluation Order for Function Calls\n+alternative in that paper was adopted, rather than the strict left to\n+right order of evaluation for function call arguments that was proposed\n+in the main body of the paper.<\/p>\n+<p>The primary purpose of this change seems to be to make certain kinds\n+of call chaining well defined. That's not a style widely used in\n+HotSpot. In general it is better to continue to avoid questions in this\n+area by isolating operations with side effects from other statements. In\n+particular, continue to avoid modifying a value in an expression where\n+it is also used.<\/p>\n+<h3 id=\"compatibility-with-c11\">Compatibility with C11<\/h3>\n+<p>C++17 refers to C11 rather than C99. This means that C11 libraries\n+and functions may be used in HotSpot. There may be limitations because\n+of differing levels of compatibility among various compilers and\n+versions of those compilers.<\/p>\n+<p>Note that the C parts of the JDK have been built with C11 selected\n+for some time (<a\n+href=\"https:\/\/bugs.openjdk.org\/browse\/JDK-8292008\">JDK-8292008<\/a>).<\/p>\n@@ -1211,2 +1473,4 @@\n-<li><p>Static assertions (<a\n-href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2004\/n1720.html\">n1720<\/a>)<\/p><\/li>\n+<li><p>Static assertions (<a href=\"http:\/\/wg21.link\/n1720\">n1720<\/a>)\n+(<a href=\"http:\/\/wg21.link\/n3928\">n3928<\/a>)<br> Both the original\n+(C++11) two-argument form and the new (C++17) single-argument form are\n+permitted.<\/p><\/li>\n@@ -1254,0 +1518,29 @@\n+<li><p>Preprocessor Condition <code>__has_include<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0061r0\">p0061r0<\/a>) (<a\n+href=\"http:\/\/wg21.link\/p0061r1\">p0061r1<\/a>)<\/p><\/li>\n+<li><p>Hexadecimal Floating-Point Literals (<a\n+href=\"http:\/\/wg21.link\/p0245r1\">p0245r1<\/a>)<\/p><\/li>\n+<li><p>Construction Rules for <code>enum class<\/code> Values (<a\n+href=\"http:\/\/wg21.link\/p0138r2\">p0138r2<\/a>)<\/p><\/li>\n+<li><p>Allow <code>typename<\/code> in template template parameter (<a\n+href=\"http:\/\/wg21.link\/n4051\">n4051<\/a>) — template template parameters\n+are barely used (if at all) in HotSpot, but there's no reason to\n+artificially disallow this syntactic regularization in any such\n+uses.<\/p><\/li>\n+<\/ul>\n+<h2 id=\"excluded-features\">Excluded Features<\/h2>\n+<h3 id=\"structured-bindings\">Structured Bindings<\/h3>\n+<p>The use of structured bindings <a\n+href=\"http:\/\/wg21.link\/p0217r3\">p0217r3<\/a> is forbidden. Preferred\n+approaches for handling functions with multiple return values\n+include<\/p>\n+<ul>\n+<li><p>Return a named class\/struct intended for that purpose, with named\n+and typed members\/accessors.<\/p><\/li>\n+<li><p>Return a value along with out parameters (usually pointers,\n+sometimes references).<\/p><\/li>\n+<li><p>Designate a sentinel \"failure\" value in the normal return value\n+type, with some out of band location for additional information. For\n+example, this is the model typically used with <code>errno<\/code>, where\n+a function returns a normal result, or -1 to indicate an error, with\n+additional error information in <code>errno<\/code>.<\/p><\/li>\n@@ -1255,1 +1548,26 @@\n-<h3 id=\"excluded-features\">Excluded Features<\/h3>\n+<p>There is a strong preference for names and explicit types, as opposed\n+to offsets and implicit types. For example, there are folks who strongly\n+dislike that some of the Standard Library functions return\n+<code>std::pair<\/code> because <code>first<\/code> and\n+<code>second<\/code> members don't carry any useful information.<\/p>\n+<h3 id=\"file-system-library\">File System Library<\/h3>\n+<p>The use of the File System library is forbidden. HotSpot doesn't do\n+very much with files, and already has adequate mechanisms for its needs.\n+Rewriting in terms of this new library doesn't provide any obviously\n+significant benefits. Having a mix of the existing usage and uses of\n+this new library would be confusing.<\/p>\n+<p><a href=\"http:\/\/wg21.link\/n4100\">n4100<\/a> <a\n+href=\"http:\/\/wg21.link\/p0218r0\">p0218r0<\/a> <a\n+href=\"http:\/\/wg21.link\/p0219r1\">p0219r1<\/a> <a\n+href=\"http:\/\/wg21.link\/p0317r1\">p0317r1<\/a> <a\n+href=\"http:\/\/wg21.link\/p0392r0\">p0392r0<\/a> <a\n+href=\"http:\/\/wg21.link\/p0430r2\">p0430r2<\/a> <a\n+href=\"http:\/\/wg21.link\/p0492r2\">p0492r2<\/a> <a\n+href=\"http:\/\/wg21.link\/p1164r1\">p1164r1<\/a><\/p>\n+<h3 id=\"aggregate-extensions\">Aggregate Extensions<\/h3>\n+<p>Aggregates with base classes are forbidden. C++17 allows aggregate\n+initialization for classes with base classes (<a\n+href=\"https:\/\/wg21.link\/p0017r1\">p0017r1<\/a>). HotSpot makes very little\n+use of aggregate classes, preferring explicit constructors even for very\n+simple classes.<\/p>\n+<h3 id=\"additional-excluded-features\">Additional Excluded Features<\/h3>\n@@ -1288,3 +1606,4 @@\n-explicit) conversion operators. (Note that conversion to\n-<code>bool<\/code> isn't needed in HotSpot code because of the \"no\n-implicit boolean\" guideline.)<\/p><\/li>\n+explicit) conversion operators. Conversion to <code>bool<\/code>\n+operators aren't needed because of the <a\n+href=\"#avoid-implicit-conversions-to-bool\">no implicit boolean<\/a>\n+guideline.)<\/p><\/li>\n@@ -1292,0 +1611,56 @@\n+<li><p>Attributes for namespaces and enumerators (<a\n+href=\"http:\/\/wg21.link\/n4266\">n4266<\/a> — The only applicable attribute\n+is <a href=\"#attributes\"><code>[[deprecated]]<\/code><\/a>, which is\n+forbidden.<\/p><\/li>\n+<li><p>Variadic <code>using<\/code> declarations (<a\n+href=\"http:\/\/wg21.link\/p0195r2\">p0195r2<\/a>)<\/p><\/li>\n+<li><p><code>std::variant&lt;&gt;<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0088r3\">p0088r3<\/a>) — Even if more of the C++\n+Standard Library is permitted, this class will remain forbidded. Invalid\n+accesses are indicated by throwing exceptions.<\/p><\/li>\n+<li><p><code>std::any<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0220r1\">p0220r1<\/a>) — Even if more of the C++\n+Standard Library is permitted, this class will remain forbidden. It may\n+require allocation, and always uses the standard allocator. It requires\n+<a href=\"https:\/\/en.wikipedia.org\/wiki\/Run-time_type_information\"\n+title=\"Runtime Type Information\">RTTI<\/a>.<\/p><\/li>\n+<li><p><code>std::as_const()<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0007r1\">p0007r1<\/a>) — If sufficiently useful,\n+HotSpot could add such a function. It would likely be added to\n+globalDefinitions.hpp, where there are already some similar small\n+utilities.<\/p><\/li>\n+<li><p><code>std::clamp()<\/code> (<a\n+href=\"http:\/\/wg21.link\/p002501\">p002501<\/a>) — This function is already\n+provided in globalDefinitions.hpp.<\/p><\/li>\n+<li><p>Parallel STL Algorithms (<a\n+href=\"http:\/\/wg21.link\/p0024r2\">p0024r2<\/a>) — Even if more of the C++\n+Standard Library is permitted, these will remain forbidden. They are\n+built on the standard C++ threading mechanisms. HotSpot doesn't use\n+those mechanisms, instead providing and using its own.<\/p><\/li>\n+<li><p>Cache Line Sizes <a href=\"http:\/\/wg21.link\/p0154r1\">p0154r1<\/a> —\n+HotSpot has its own mechanisms for this, using values like\n+<code>DEFAULT_CACHE_LINE_SIZE<\/code>. The platform-specific\n+implementation of the HotSpot mechanisms might use these library\n+functions, but there is no reason to move away from the current\n+approach. Quoting from <a href=\"https:\/\/www.cppstd17.com\"\n+title=\"C++17: The Complete Guide\">JOSUTTIS<\/a>: \"... if you know better,\n+use specific values, but using these values is better than any assumed\n+fixed size for code supporting multiple platforms.\"<\/p><\/li>\n+<li><p><code>register<\/code> storage class removal <a\n+href=\"http:\/\/wg21.link\/p0001r1\">p0001r1<\/a> — The <code>register<\/code>\n+storage class has been removed. <code>register<\/code> is still a\n+keyword, so still can't be used for normal purposes. Also, this doesn't\n+affect the use of <code>register<\/code> for gcc-style extended asm code;\n+that's a different syntactic element with a different meaning.<\/p><\/li>\n+<li><p>Value of <code>__cplusplus<\/code> — Testing whether\n+<code>__cplusplus<\/code> is defined or not is permitted, and indeed\n+required. But the value should not need to be examined. The value is\n+changed with each revision of the Standard. But we build HotSpot and\n+(most of) the rest of the JDK with a specifically selected version of\n+the Standard. The value of <code>__cplusplus<\/code> should be known and\n+unchanging until we change the project's build configuration again. So\n+examining the value shouldn't ever be necessary.<\/p><\/li>\n+<li><p>Removal of <code>++<\/code> for <code>bool<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0003r1\">p0003r1<\/a>)<\/p><\/li>\n+<li><p>Removal of trigraphs (<a\n+href=\"http:\/\/wg21.link\/n4086\">n4086<\/a>)<\/p><\/li>\n@@ -1293,1 +1668,1 @@\n-<h3 id=\"undecided-features\">Undecided Features<\/h3>\n+<h2 id=\"undecided-features\">Undecided Features<\/h2>\n@@ -1296,0 +1671,138 @@\n+<p>Some features are undecided (so implicitly forbidden) because we\n+don't expect to use them at all. This might be reconsidered if someone\n+finds a good use case.<\/p>\n+<p>Some Standard Library features are undecided (so implicitly\n+forbidden) because, while this Style Guide forbids the use of such, they\n+may be sufficiently useful that we want to permit them anyway. Doing so\n+may require some idiomatic mechanism for addressing things like\n+<code>assert<\/code> incompatibility, incompatibility with HotSpot's\n+<code>FORBID_C_FUNCTION<\/code> mechanism, and the like.<\/p>\n+<h3 id=\"stdoptional\">std::optional&lt;&gt;<\/h3>\n+<p>It is undecided whether to permit the use of\n+<code>std::optional&lt;&gt;<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0220r1\">p0220r1<\/a>). It may be sufficiently\n+useful that it should be permitted despite the usual prohibition against\n+using Standard Library facilities. Use of the <code>value()<\/code>\n+member function must be forbidden, as it reports an invalid access by\n+throwing an exception.<\/p>\n+<h3 id=\"stdbyte\">std::byte<\/h3>\n+<p>It is undecided whether to permit the use of the\n+<code>std::byte<\/code> type (<a\n+href=\"http:\/\/wg21.link\/p0298r3\">p0298r3<\/a>). It may be sufficiently\n+useful that it should be permitted despite the usual prohibition against\n+using Standard Library facilities.<\/p>\n+<p>It has been suggested that changing the HotSpot <code>address<\/code>\n+type to use <code>std::byte<\/code> has some benefits. That is,\n+replace<\/p>\n+<pre><code>typedef u_char*       address;\n+typedef const u_char* const_address;<\/code><\/pre>\n+<pre><code>using address       = std::byte*;\n+using const_address = const std::byte*;<\/code><\/pre>\n+<p>in globalDefinitions.hpp.<\/p>\n+<p>A specific benefit that was mentioned is that it might improve the\n+horrible way that gdb handles our current definition of the\n+<code>address<\/code> type.<\/p>\n+<pre><code>#include &lt;cstddef&gt;\n+\n+typedef unsigned char* address;\n+typedef std::byte* address_b;\n+\n+int main() {\n+\n+  char* mem;\n+\n+  address addr = (address)mem;\n+  address_b addr_b = (address_b)mem;\n+\n+  return 0;\n+}<\/code><\/pre>\n+<pre><code>(gdb) p addr\n+$1 = (address) 0x7ffff7fe4fa0 &lt;dl_main&gt; &quot;\\363\\017\\036\\372Uf\\017\\357\\300H\\211\\345AWI\\211\\377AVAUATSH\\201\\354\\210\\002&quot;\n+(gdb) p addr_b\n+$2 = (address_b) 0x7ffff7fe4fa0 &lt;dl_main&gt;<\/code><\/pre>\n+<p>This needs to be explored. Some folks have said they will do so.<\/p>\n+<h3 id=\"string-views\">String Views<\/h3>\n+<p>It is undecided whether to permit the use of\n+<code>std::string_view<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0220r1\">p0220r1<\/a>).<\/p>\n+<p>HotSpot doesn't use <code>std::string<\/code>, but uses\n+<code>char*<\/code> strings a lot. Wrapping such in a\n+<code>std::string_view<\/code> to enable the use of various algorithms\n+could be useful. But since HotSpot also doesn't permit use of\n+<code>&lt;algorithm&gt;<\/code> and the like, that only gets the limited\n+set of algorithms provided by the view class directly.<\/p>\n+<p>There is also the issue of <code>NUL<\/code> termination; string views\n+are not necessarily <code>NUL<\/code> terminated. Moreover, if one goes\n+to the work of making one that is <code>NUL<\/code> terminated, that\n+terminator is included in the size.<\/p>\n+<p>There are other caveats. Permitting use of string views would require\n+discussion of those.<\/p>\n+<h3 id=\"substring-and-subsequence-searching\">Substring and Subsequence\n+Searching<\/h3>\n+<p>In addition to simple substring searching, the Standard Library now\n+includes Boyer-Moore and Boyer-Moore-Horspool searchers, in case someone\n+wants to search really large texts. That seems an unlikely use-case for\n+HotSpot. See <a href=\"http:\/\/wg21.link\/p0220r1\">p0220r1<\/a>.<\/p>\n+<h3 id=\"new-and-delete-with-over-aligned-data\"><code>new<\/code> and\n+<code>delete<\/code> with Over-Aligned Data<\/h3>\n+<p>It is undecided whether to permit the use of dynamic allocation of\n+overaligned types (<a href=\"http:\/\/wg21.link\/n3396\">n3396<\/a>).<\/p>\n+<p>HotSpot currently only has a couple of over-aligned types that are\n+dynamically allocated. These are handled manually, not going through\n+<code>new<\/code> expressions, as that couldn't work before C++17.<\/p>\n+<p>One of the ways an over-aligned type might arise is by aligning a\n+data member. This might be done to avoid destructive interference for\n+concurrent accesses. But HotSpot uses a different approach, using\n+explicit padding. Again, this is in part because <code>new<\/code> and\n+<code>delete<\/code> of overaligned types didn't work. But we might\n+prefer to continue this approach.<\/p>\n+<p>We would need to add <code>operator new<\/code> overloads to\n+<code>CHeapObj&lt;&gt;<\/code> and possibly in other places in order to\n+support this. However, it has been suggested that implementing it\n+(efficiently) on top of NMT might be difficult. Note that\n+<code>posix_memalign<\/code> \/ <code>_aligned_malloc<\/code> don't help\n+here, because of NMT's use of malloc headers.<\/p>\n+<p>If we don't support it we may want to add <code>operator new<\/code>\n+overloads that are deleted, to prevent attempted uses.<\/p>\n+<p>Alignment usage in non-HotSpot parts of the OpenJDK:<\/p>\n+<ul>\n+<li><p><code>alignas<\/code> used once in harfbuzz, to align a\n+variable.<\/p><\/li>\n+<li><p>libpipewire has <code>#define SPA_ALIGNED<\/code> macro using gcc\n+<code>aligned<\/code> attribute, but doesn't use it.<\/p><\/li>\n+<li><p>libsleef has <code>#define ALIGNED<\/code> macro using gcc\n+<code>aligned<\/code> attribute. It is not used for class or member\n+declarations.<\/p><\/li>\n+<\/ul>\n+<h3 id=\"stdto_chars-and-stdfrom_chars\"><code>std::to_chars()<\/code> and\n+<code>std::from_chars<\/code><\/h3>\n+<p>It is undecided whether to permit the use of\n+<code>std::to_chars()<\/code> and <code>std::from_chars()<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0067r5\">p0067r5<\/a>).<\/p>\n+<p>These functions provide low-level conversions between character\n+sequences and numeric values. This seems like a good candidate for use\n+in HotSpot, potentially replacing various clumsy or less performant\n+alternatives. There is no memory allocation. Parsing failures are\n+indicated via error codes rather than exceptions. Various other nice for\n+HotSpot properties.<\/p>\n+<p>Note that the published C++17 Standard puts these in\n+<code>&lt;utility&gt;<\/code>, but a defect report moved them to\n+<code>&lt;charconv&gt;<\/code>. This also needs\n+<code>&lt;system_error&gt;<\/code>.<\/p>\n+<p>This would require upgrading the minimum gcc version to 11.1 for\n+floating point conversion support. The minimum Visual Studio version is\n+already sufficient. The minimum clang version requirement hasn't been\n+determined yet.<\/p>\n+<h3 id=\"stdlaunder\"><code>std::launder()<\/code><\/h3>\n+<p>It is undecided whether to permit the use of\n+<code>std::launder()<\/code> (<a\n+href=\"http:\/\/wg21.link\/p0137r1\">p0137r1<\/a>).<\/p>\n+<p>Change to permitted if we discover a place where we need it. Or maybe\n+we should just permit it, but hope we don't need it.<\/p>\n+<p>Also, C++20 revised the relevant part of Object Lifetime in a way\n+that seems more permissive and with less need of laundering. We don't\n+know if implementations of prior versions take advantage of the\n+difference.<\/p>\n+<p>See Object Lifetime: C++17 6.8\/8, C++20 6.7.3\/8<\/p>\n+<h3 id=\"additional-undecided-features\">Additional Undecided\n+Features<\/h3>\n@@ -1300,1 +1813,2 @@\n-href=\"https:\/\/isocpp.org\/files\/papers\/N3651.pdf\">n3651<\/a>)<\/p><\/li>\n+href=\"https:\/\/isocpp.org\/files\/papers\/N3651.pdf\">n3651<\/a>, <a\n+href=\"http:\/\/wg21.link\/p0127r2\">p0127r2<\/a>)<\/p><\/li>\n@@ -1304,0 +1818,21 @@\n+<li><p>Shorthand for nested namespaces (<a\n+href=\"http:\/\/wg21.link\/n4230\">n4230<\/a>) — HotSpot makes very little use\n+of namespaces, so this seemingly innocuous feature probably isn't useful\n+to us.<\/p><\/li>\n+<li><p>Direct list initialization with <code>auto<\/code> (<a\n+href=\"http:\/\/wg21.link\/n3681\">n3681<\/a>) — This change fixed some issues\n+with direct list initialization and <code>auto<\/code>. But we don't use\n+that feature much, if at all. And perhaps shouldn't be using\n+it.<\/p><\/li>\n+<li><p>UTF-8 Character Literals (<a\n+href=\"http:\/\/wg21.link\/n4267\">n4267<\/a>) — Do we have a use-case for\n+this?<\/p><\/li>\n+<li><p>Fold Expressions (<a href=\"http:\/\/wg21.link\/n4295\">n4295<\/a>) —\n+Provides a simple way to apply operators to a parameter pack. HotSpot\n+doesn't use variadic templates very much. That makes it questionable\n+that developers should need to know about this feature. But if someone\n+does come up with a good use-case, it's likely that the alternatives are\n+significantly worse, because pack manipulation without this can be\n+complicated.<\/p><\/li>\n+<li><p><code>std::invoke&lt;&gt;()<\/code> (<a\n+href=\"http:\/\/wg21.link\/n4169\">n4169<\/a>)<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":581,"deletions":46,"binary":false,"changes":627,"status":"modified"},{"patch":"@@ -138,0 +138,11 @@\n+#### Conventions for Lock-free Code\n+\n+Sometimes variables are accessed concurrently without appropriate synchronization\n+context, such as a held mutex or at a safepoint. In such cases the variable should\n+be declared `volatile` and it should NOT be accessed as a normal C++ lvalue. Rather,\n+access should be performed via functions from `Atomic`, such as `Atomic::load`,\n+`Atomic::store`, etc.\n+\n+This special formulation makes it more clear to maintainers that the variable is\n+accessed concurrently in a lock-free manner.\n+\n@@ -369,0 +380,10 @@\n+### Avoid implicit conversions to bool\n+\n+* Use `bool` for boolean values.\n+* Do not use ints or pointers as (implicit) booleans with `&&`, `||`,\n+`if`, `while`. Instead, compare explicitly, i.e. `if (x != 0)` or\n+`if (ptr != nullptr)`, etc.\n+* Do not use non-boolean declarations in _condition_ forms, i.e. don't use\n+`if (T v = value) { ... }`. But see\n+[Enhanced selection statements](#enhanced-selection-statements).\n+\n@@ -375,8 +396,0 @@\n-* Avoid implicit conversions to `bool`.\n-    * Use `bool` for boolean values.\n-    * Do not use ints or pointers as (implicit) booleans with `&&`, `||`,\n-      `if`, `while`. Instead, compare explicitly, i.e. `if (x != 0)` or\n-      `if (ptr != nullptr)`, etc.\n-    * Do not use declarations in _condition_ forms, i.e. don't use\n-      `if (T v = value) { ... }`.\n-\n@@ -394,1 +407,0 @@\n-\n@@ -398,1 +410,1 @@\n-More recently, support for C++14 is provided, though again,\n+More recently, support for C++17 is provided, though again,\n@@ -405,1 +417,1 @@\n-C++11 and C++14 may be explicitly permitted or explicitly excluded,\n+C++11, C++14, and C++17 may be explicitly permitted or explicitly excluded,\n@@ -420,1 +432,1 @@\n-Lists of new features for C++11 and C++14, along with links to their\n+Lists of new features for C++11, C++14, and C++17, along with links to their\n@@ -422,1 +434,1 @@\n-compilers and libraries.  The C++14 Standard is the definitive\n+compilers and libraries.  The C++17 Standard is the definitive\n@@ -627,0 +639,6 @@\n+* `auto` for non-type template parameters\n+([p0127r2](http:\/\/wg21.link\/p0127r2))<br>\n+`auto` may be used as a placeholder for the type of a non-type template\n+parameter. The type is deduced from the value provided in a template\n+instantiation.\n+\n@@ -632,0 +650,16 @@\n+* Class template argument deduction\n+([n3602](http:\/\/wg21.link\/n3602), [p0091r3](http:\/\/wg21.link\/p0091r3))<br>\n+The template arguments of a class template may be deduced from the arguments\n+to a constructor. This is similar to ordinary function argument deduction,\n+though partial deduction with only _some_ template arguments explicitly\n+provided is not permitted for class template argument deduction. Deduction\n+guides may be used to provide additional control over the deduction. As with\n+`auto` variable declarations, excessive use can make code harder to\n+understand, because explicit type information is lacking. But it can also\n+remove the need to be explicit about types that are either obvious, or that\n+are very hard to write. For example, these allow the addition of a scope-guard\n+mechanism with nice syntax; something like this\n+```\n+  ScopeGuard guard{[&]{ ... cleanup code ... }};\n+```\n+\n@@ -634,0 +668,5 @@\n+* `decltype(auto)` should be avoided, whether for variables, for non-type\n+template parameters, or for function return types. There are subtle and\n+complex differences between this placeholder type and `auto`. Any use would\n+need very careful explanation.\n+\n@@ -655,0 +694,10 @@\n+### Non-type template parameter values\n+\n+C++17 extended the arguments permitted for non-type template parameters\n+([n4268](http:\/\/wg21.link\/n4268)). The kinds of values (the parameter types)\n+aren't changed.  However, the values can now be the result of arbitrary\n+constant expressions (with a few restrictions on the result), rather than a\n+much more limited and restrictive set of expressions. In particular, the\n+argument for a pointer or reference type parameter can now be the result of a\n+constexpr function.\n+\n@@ -773,0 +822,26 @@\n+### Inline Variables\n+\n+Variables with static storage duration may be declared `inline`\n+([p0386r2](https:\/\/wg21.link\/p0386r2)). This has similar effects as for\n+declaring a function inline: it can be defined, identically, in multiple\n+translation units, must be defined in every translation unit in which it is\n+[ODR used][ODR], and the behavior of the program is as if there is exactly one\n+variable.\n+\n+Declaring a variable inline allows the complete definition to be in a header\n+file, rather than having a declaration in a header and the definition in a\n+.cpp file. The guidance on\n+[initialization](#initializing-variables-with-static-storage-duration) of such\n+variables still applies. Inline variables with dynamic initializations can\n+make initialization order problems worse. The few ordering constraints\n+that exist for non-inline variables don't apply, as there isn't a single\n+program-designated translation unit containing the definition.\n+\n+A `constexpr` static data member is implicitly `inline`. As a consequence, an\n+[ODR use][ODR] of such a variable doesn't require a definition in some .cpp\n+file. (This is a change from pre-C++17. Beginning with C++17, such a\n+definition is considered a duplicate definition, and is deprecated.)\n+\n+Declaring a `thread_local` variable `inline` is forbidden for HotSpot code.\n+[The use of `thread_local`](#thread_local) is already heavily restricted.\n+\n@@ -816,0 +891,47 @@\n+### Mandatory Copy Elision\n+\n+[Copy elision](https:\/\/en.wikipedia.org\/wiki\/Copy_elision)\n+(or [here](https:\/\/cn.cppreference.com\/w\/cpp\/language\/copy_elision.html))\n+is a compiler optimization used to avoid potentially expensive copies in\n+certain situations. It is critical to making practical the performance of\n+return by value or pass by value. It is also unusual in not following the\n+as-if rule for optimizations - copy elision can be applied even if doing so\n+bypasses side-effects of copying\/moving the object. The C++ standard\n+explicitly permits this.\n+\n+However, because it's an optional optimization, the relevant copy\/move\n+constructor must be available and accessible, in case the compiler chooses to\n+not apply the optimization even in a situation where permitted.\n+\n+C++17 changed some cases of copy elision so that there is never a copy\/move in\n+these cases ([p0135r1](http:\/\/wg21.link\/p0135r1)). The interesting cases\n+involve a function that returns an unnamed temporary object, and constructors.\n+In such cases the object being initialized from the temporary is always direct\n+initialized, with no copy\/move ever involved; see [RVO] and more specifically\n+[URVO].\n+\n+Since this is now standard behavior it can't be avoided in the covered\n+situations. This could change the behavior of code that relied on side effects\n+by constructors, but that's both uncommon and was already problematic because\n+of the previous optional copy elision. But HotSpot code can, and should,\n+explicitly take advantage of this newly required behavior where it makes sense\n+to do so.\n+\n+For example, it may be beneficial to delay construction of the result of a\n+function until the return statement, rather than having a local variable that\n+is modified into the desired state and then returned. (Though [NRVO] may apply\n+in that case.)\n+\n+It is also now possible to define a factory function for a class that is\n+neither movable nor copyable, if it can be written in a way that makes use of\n+this feature.\n+\n+[RVO]: https:\/\/en.wikipedia.org\/wiki\/Copy_elision#RVO\n+  \"Return Value Optimization\"\n+\n+[NRVO]: https:\/\/en.wikipedia.org\/wiki\/Copy_elision#NRVO\n+  \"Named Return Value Optimization\"\n+\n+[URVO]: https:\/\/cn.cppreference.com\/w\/cpp\/language\/copy_elision.html\n+  \"Unnamed Return Value Optimization\"\n+\n@@ -884,0 +1006,6 @@\n+A lambda is a constexpr function if either the parameter declaration clause is\n+followed by `constexpr`, or it satisfies the requirements for a constexpr\n+function ([p0170r1]). Thus, using a lambda to package up some computation\n+doesn't incur unnecessary overhead or prevent use in a context required to be\n+compile-time evaluated (such as an array size).\n+\n@@ -935,0 +1063,11 @@\n+* By-value capture of `this` (using a capture list like `[*this]` ([p0018r3]))\n+is also not permitted. One of the motivating use-cases is when the lifetime of\n+the lambda exceeds the lifetime of the object for the containing member\n+function. That is, we have an upward lambda that is capturing `this` of the\n+enclosing method. But again, that use-case doesn't apply if only downward\n+lambdas are used.\n+  Another use-case is when we simply want the lambda to be operating on a copy\n+of `this` for some reason. This is sufficiently uncommon that it can be\n+handled by manual copying, so readers don't need to understand this rare\n+syntax.\n+\n@@ -944,1 +1083,1 @@\n-The use of `mutable` lambda expressions is forbidden because there don't\n+* The use of `mutable` lambda expressions is forbidden because there don't\n@@ -1091,15 +1230,6 @@\n-a list of 8 Core Issues).  Since HotSpot doesn't support use of C++17, use of\n-inherited constructors could run into those problems. Such uses might also\n-change behavior in a future HotSpot update to use C++17 or later, potentially\n-in subtle ways that could lead to hard to diagnose problems.  Because of this,\n-HotSpot code must not use inherited constructors.\n-\n-Note that gcc7 provides the `-fnew-inheriting-ctors` option to use the\n-[p0136r1] semantics.  This is enabled by default when using C++17 or later.\n-It is also enabled by default for `fabi-version=11` (introduced by gcc7) or\n-higher when using C++11\/14, as the change is considered a Defect Report that\n-applies to those versions.  Earlier versions of gcc don't have that option,\n-and other supported compilers may not have anything similar.\n-\n-[p0136r1]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2015\/p0136r1.html\n-  \"p0136r1\"\n+a list of 8 Core Issues). Although those issues have been addressed, the\n+benefits from this feature are small compared to the complexity. Because of\n+this, HotSpot code must not use inherited constructors.\n+\n+[p0136r1]: http:\/wg21.link\/p0136r1 \"p0136r1\"\n+[p0195r0](http:\/\/wg21.link\/p0195r0)\n@@ -1124,0 +1254,3 @@\n+[p0068r0](http:\/\/wg21.link\/p0068r0) is the initial proposal for the attributes\n+added by C++17.)\n+\n@@ -1127,0 +1260,3 @@\n+* `[[nodiscard]]` ([p0189r1](http:\/\/wg21.link\/p0189r1))\n+* `[[maybe_unused]]` ([p0212r1](http:\/\/wg21.link\/p0212r1))\n+* `[[fallthrough]]` ([p0188r1](http:\/\/wg21.link\/p0188))\n@@ -1133,0 +1269,18 @@\n+Direct use of non-standard (and presumably scoped) attributes in shared code\n+is also forbidden. Using such would depend on the C++17 feature that an\n+attribute not recognized by the implementation is ignored\n+([p0283r2](http:\/\/wg21.link\/p0283r2)). If such an attribute is needed in\n+shared code, the well-established technique of providing an `ATTRIBUTE_XXX`\n+macro with per-compiler definitions (sometimes empty) should be\n+used. Compilers may warn about unrecognized attributes (whether by name or by\n+location), in order to report typos or misuse. Disabling such warnings\n+globally would not be desirable.\n+\n+The use of `using` directives in attribute lists is also forbidden.\n+([p0028r0](http:\/\/wg21.link\/p0028r0))\n+([p0028r4](http:\/\/wg21.link\/p0028r4))\n+We don't generally use scoped attributes in attribute lists with other\n+attributes. Rather, uses of scoped attributes (which are implementation\n+defined) are generally hidden behind a portability macro that includes the\n+surrounding brackets.\n+\n@@ -1181,0 +1335,4 @@\n+The exception specification is part of the type of a function\n+([p0012r1](http:\/\/wg21.link\/p0012r1). This likely has little impact on HotSpot\n+code, since the use of `noexcept` is expected to be rare.\n+\n@@ -1184,0 +1342,66 @@\n+### Enhanced selection statements\n+\n+C++17 modified the _condition_ part of `if` and `switch` statements, permitting\n+an _init-statement_ to be included\n+([p0305r1](http:\/\/wg21.link\/p0305r1)).\n+\n+Use of this feature is permitted. (However, complex uses may interfere with\n+readability.) Limiting the scope of a variable involved in the condition,\n+while also making the value available to the statement's body, can improve\n+readability. The alternative method of scope-limiting by introducing a nested\n+scope isn't very popular and is rarely used.\n+\n+This new syntax is in addition to the _condition_ being a declaration with a\n+_brace-or-equal-initializer_. For an `if` statement this new sytax gains that\n+benefit without violating the long-standing guidance against using\n+[implicit conversions to `bool`](#avoid-implicit-conversions-to-bool),\n+which still stands.\n+\n+For example, uses of Unified Logging sometimes explicitly check whether a\n+`LogTarget` is enabled.  Instead of\n+```\n+  LogTarget(...) lt;\n+  if (lt.is_enabled()) {\n+    LogStream log(lt);\n+    ... use log ...\n+  }\n+  ... lt is accessible but probably not needed here ...\n+```\n+using this feature one could write\n+```\n+  if (LogTarget(...) lt; lt.is_enabled()) {\n+    LogStream log(lt);\n+    ... use log ...\n+  }\n+```\n+\n+C++17 also added compile-time `if` statements\n+([p0292r2](http:\/\/wg21.link\/p0292r2)). Use of `if constexpr` is\n+permitted. This feature can replace and (sometimes vastly) simplify many uses\n+of [SFINAE]. The same declaration and initialization guidance for the\n+_condition_ part apply here as for ordinary `if` statements.\n+\n+### Expression Evaluation Order\n+\n+C++17 tightened up the evaluation order for some kinds of subexpressions\n+([p0138r2](http:\/\/wg21.link\/p0138r2)). Note, however, that the Alternate\n+Evaluation Order for Function Calls alternative in that paper was adopted,\n+rather than the strict left to right order of evaluation for function call\n+arguments that was proposed in the main body of the paper.\n+\n+The primary purpose of this change seems to be to make certain kinds of call\n+chaining well defined. That's not a style widely used in HotSpot. In general\n+it is better to continue to avoid questions in this area by isolating\n+operations with side effects from other statements. In particular, continue to\n+avoid modifying a value in an expression where it is also used.\n+\n+### Compatibility with C11\n+\n+C++17 refers to C11 rather than C99. This means that C11 libraries and\n+functions may be used in HotSpot. There may be limitations because of\n+differing levels of compatibility among various compilers and versions of\n+those compilers.\n+\n+Note that the C parts of the JDK have been built with C11 selected for some\n+time ([JDK-8292008](https:\/\/bugs.openjdk.org\/browse\/JDK-8292008)).\n+\n@@ -1201,1 +1425,4 @@\n-([n1720](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2004\/n1720.html))\n+([n1720](http:\/\/wg21.link\/n1720))\n+([n3928](http:\/\/wg21.link\/n3928))<br>\n+Both the original (C++11) two-argument form and the new (C++17)\n+single-argument form are permitted.\n@@ -1248,1 +1475,66 @@\n-### Excluded Features\n+* Preprocessor Condition `__has_include`\n+([p0061r0](http:\/\/wg21.link\/p0061r0))\n+([p0061r1](http:\/\/wg21.link\/p0061r1))\n+\n+* Hexadecimal Floating-Point Literals\n+([p0245r1](http:\/\/wg21.link\/p0245r1))\n+\n+* Construction Rules for `enum class` Values\n+([p0138r2](http:\/\/wg21.link\/p0138r2))\n+\n+* Allow `typename` in template template parameter\n+([n4051](http:\/\/wg21.link\/n4051)) &mdash; template template parameters are\n+barely used (if at all) in HotSpot, but there's no reason to artificially\n+disallow this syntactic regularization in any such uses.\n+\n+## Excluded Features\n+\n+### Structured Bindings\n+\n+The use of structured bindings [p0217r3](http:\/\/wg21.link\/p0217r3) is\n+forbidden.  Preferred approaches for handling functions with multiple return\n+values include\n+\n+* Return a named class\/struct intended for that purpose, with named and typed\n+members\/accessors.\n+\n+* Return a value along with out parameters (usually pointers, sometimes\n+references).\n+\n+* Designate a sentinel \"failure\" value in the normal return value type, with\n+some out of band location for additional information.  For example, this is\n+the model typically used with `errno`, where a function returns a normal\n+result, or -1 to indicate an error, with additional error information in\n+`errno`.\n+\n+There is a strong preference for names and explicit types, as opposed to\n+offsets and implicit types. For example, there are folks who strongly dislike\n+that some of the Standard Library functions return `std::pair` because `first`\n+and `second` members don't carry any useful information.\n+\n+### File System Library\n+\n+The use of the File System library is forbidden. HotSpot doesn't do very much\n+with files, and already has adequate mechanisms for its needs. Rewriting in\n+terms of this new library doesn't provide any obviously significant\n+benefits. Having a mix of the existing usage and uses of this new library\n+would be confusing.\n+\n+[n4100](http:\/\/wg21.link\/n4100)\n+[p0218r0](http:\/\/wg21.link\/p0218r0)\n+[p0219r1](http:\/\/wg21.link\/p0219r1)\n+[p0317r1](http:\/\/wg21.link\/p0317r1)\n+[p0392r0](http:\/\/wg21.link\/p0392r0)\n+[p0430r2](http:\/\/wg21.link\/p0430r2)\n+[p0492r2](http:\/\/wg21.link\/p0492r2)\n+[p1164r1](http:\/\/wg21.link\/p1164r1)\n+\n+### Aggregate Extensions\n+\n+Aggregates with base classes are forbidden. C++17 allows aggregate\n+initialization for classes with base classes\n+([p0017r1](https:\/\/wg21.link\/p0017r1)). HotSpot makes very little use of\n+aggregate classes, preferring explicit constructors even for very simple\n+classes.\n+\n+### Additional Excluded Features\n@@ -1284,2 +1576,4 @@\n-conversion operators.  (Note that conversion to `bool` isn't needed\n-in HotSpot code because of the \"no implicit boolean\" guideline.)\n+conversion operators.  Conversion to `bool` operators aren't needed\n+because of the\n+[no implicit boolean](#avoid-implicit-conversions-to-bool)\n+guideline.)\n@@ -1289,1 +1583,67 @@\n-### Undecided Features\n+* Attributes for namespaces and enumerators\n+([n4266](http:\/\/wg21.link\/n4266) &mdash;\n+The only applicable attribute is [`[[deprecated]]`](#attributes), which is\n+forbidden.\n+\n+* Variadic `using` declarations\n+([p0195r2](http:\/\/wg21.link\/p0195r2))\n+\n+* `std::variant<>`\n+([p0088r3](http:\/\/wg21.link\/p0088r3)) &mdash;\n+Even if more of the C++ Standard Library is permitted, this class will remain\n+forbidded. Invalid accesses are indicated by throwing exceptions.\n+\n+* `std::any`\n+([p0220r1](http:\/\/wg21.link\/p0220r1)) &mdash;\n+Even if more of the C++ Standard Library is permitted, this class will remain\n+forbidden. It may require allocation, and always uses the standard\n+allocator. It requires [RTTI].\n+\n+* `std::as_const()`\n+([p0007r1](http:\/\/wg21.link\/p0007r1)) &mdash;\n+If sufficiently useful, HotSpot could add such a function. It would likely be\n+added to globalDefinitions.hpp, where there are already some similar small\n+utilities.\n+\n+* `std::clamp()`\n+([p002501](http:\/\/wg21.link\/p002501)) &mdash;\n+This function is already provided in globalDefinitions.hpp.\n+\n+* Parallel STL Algorithms\n+([p0024r2](http:\/\/wg21.link\/p0024r2)) &mdash;\n+Even if more of the C++ Standard Library is permitted, these will remain\n+forbidden. They are built on the standard C++ threading mechanisms. HotSpot\n+doesn't use those mechanisms, instead providing and using its own.\n+\n+* Cache Line Sizes\n+[p0154r1](http:\/\/wg21.link\/p0154r1) &mdash;\n+HotSpot has its own mechanisms for this, using values like\n+`DEFAULT_CACHE_LINE_SIZE`. The platform-specific implementation of the HotSpot\n+mechanisms might use these library functions, but there is no reason to move\n+away from the current approach. Quoting from [JOSUTTIS]: \"... if you know better,\n+use specific values, but using these values is better than any assumed fixed\n+size for code supporting multiple platforms.\"\n+\n+* `register` storage class removal\n+[p0001r1](http:\/\/wg21.link\/p0001r1) &mdash;\n+The `register` storage class has been removed. `register` is still a keyword,\n+so still can't be used for normal purposes. Also, this doesn't affect the use\n+of `register` for gcc-style extended asm code; that's a different syntactic\n+element with a different meaning.\n+\n+* Value of `__cplusplus` &mdash;\n+Testing whether `__cplusplus` is defined or not is permitted, and indeed\n+required. But the value should not need to be examined. The value is changed\n+with each revision of the Standard. But we build HotSpot and (most of) the\n+rest of the JDK with a specifically selected version of the Standard. The\n+value of `__cplusplus` should be known and unchanging until we change the\n+project's build configuration again. So examining the value shouldn't ever be\n+necessary.\n+\n+* Removal of `++` for `bool`\n+([p0003r1](http:\/\/wg21.link\/p0003r1))\n+\n+* Removal of trigraphs\n+([n4086](http:\/\/wg21.link\/n4086))\n+\n+## Undecided Features\n@@ -1294,0 +1654,158 @@\n+Some features are undecided (so implicitly forbidden) because we don't expect\n+to use them at all. This might be reconsidered if someone finds a good use\n+case.\n+\n+Some Standard Library features are undecided (so implicitly forbidden)\n+because, while this Style Guide forbids the use of such, they may be\n+sufficiently useful that we want to permit them anyway. Doing so may require\n+some idiomatic mechanism for addressing things like `assert` incompatibility,\n+incompatibility with HotSpot's `FORBID_C_FUNCTION` mechanism, and the like.\n+\n+### std::optional<>\n+\n+It is undecided whether to permit the use of `std::optional<>`\n+([p0220r1](http:\/\/wg21.link\/p0220r1)). It may be sufficiently useful that it\n+should be permitted despite the usual prohibition against using Standard\n+Library facilities. Use of the `value()` member function must be forbidden, as\n+it reports an invalid access by throwing an exception.\n+\n+### std::byte\n+\n+It is undecided whether to permit the use of the `std::byte` type\n+([p0298r3](http:\/\/wg21.link\/p0298r3)). It may be sufficiently useful that it\n+should be permitted despite the usual prohibition against using Standard\n+Library facilities.\n+\n+It has been suggested that changing the HotSpot `address` type to use\n+`std::byte` has some benefits. That is, replace\n+```\n+typedef u_char*       address;\n+typedef const u_char* const_address;\n+```\n+```\n+using address       = std::byte*;\n+using const_address = const std::byte*;\n+```\n+in globalDefinitions.hpp.\n+\n+A specific benefit that was mentioned is that it might improve the horrible\n+way that gdb handles our current definition of the `address` type.\n+```\n+#include <cstddef>\n+\n+typedef unsigned char* address;\n+typedef std::byte* address_b;\n+\n+int main() {\n+\n+  char* mem;\n+\n+  address addr = (address)mem;\n+  address_b addr_b = (address_b)mem;\n+\n+  return 0;\n+}\n+```\n+\n+```\n+(gdb) p addr\n+$1 = (address) 0x7ffff7fe4fa0 <dl_main> \"\\363\\017\\036\\372Uf\\017\\357\\300H\\211\\345AWI\\211\\377AVAUATSH\\201\\354\\210\\002\"\n+(gdb) p addr_b\n+$2 = (address_b) 0x7ffff7fe4fa0 <dl_main>\n+```\n+\n+This needs to be explored. Some folks have said they will do so.\n+\n+### String Views\n+\n+It is undecided whether to permit the use of `std::string_view`\n+([p0220r1](http:\/\/wg21.link\/p0220r1)).\n+\n+HotSpot doesn't use `std::string`, but uses `char*` strings a lot. Wrapping\n+such in a `std::string_view` to enable the use of various algorithms could be\n+useful. But since HotSpot also doesn't permit use of `<algorithm>` and the\n+like, that only gets the limited set of algorithms provided by the view class\n+directly.\n+\n+There is also the issue of `NUL` termination; string views are not necessarily\n+`NUL` terminated. Moreover, if one goes to the work of making one that is\n+`NUL` terminated, that terminator is included in the size.\n+\n+There are other caveats. Permitting use of string views would require\n+discussion of those.\n+\n+### Substring and Subsequence Searching\n+\n+In addition to simple substring searching, the Standard Library now includes\n+Boyer-Moore and Boyer-Moore-Horspool searchers, in case someone wants to\n+search really large texts. That seems an unlikely use-case for HotSpot.  See\n+[p0220r1](http:\/\/wg21.link\/p0220r1).\n+\n+### `new` and `delete` with Over-Aligned Data\n+\n+It is undecided whether to permit the use of dynamic allocation of overaligned\n+types ([n3396](http:\/\/wg21.link\/n3396)).\n+\n+HotSpot currently only has a couple of over-aligned types that are dynamically\n+allocated. These are handled manually, not going through `new` expressions, as\n+that couldn't work before C++17.\n+\n+One of the ways an over-aligned type might arise is by aligning a data member.\n+This might be done to avoid destructive interference for concurrent accesses.\n+But HotSpot uses a different approach, using explicit padding. Again, this is\n+in part because `new` and `delete` of overaligned types didn't work. But we\n+might prefer to continue this approach.\n+\n+We would need to add `operator new` overloads to `CHeapObj<>` and possibly in\n+other places in order to support this. However, it has been suggested that\n+implementing it (efficiently) on top of NMT might be difficult. Note that\n+`posix_memalign` \/ `_aligned_malloc` don't help here, because of NMT's use of\n+malloc headers.\n+\n+If we don't support it we may want to add `operator new` overloads that are\n+deleted, to prevent attempted uses.\n+\n+Alignment usage in non-HotSpot parts of the OpenJDK:\n+\n+* `alignas` used once in harfbuzz, to align a variable.\n+\n+* libpipewire has `#define SPA_ALIGNED` macro using gcc `aligned` attribute,\n+but doesn't use it.\n+\n+* libsleef has `#define ALIGNED` macro using gcc `aligned` attribute. It is\n+not used for class or member declarations.\n+\n+### `std::to_chars()` and `std::from_chars`\n+\n+It is undecided whether to permit the use of `std::to_chars()` and\n+`std::from_chars()` ([p0067r5](http:\/\/wg21.link\/p0067r5)).\n+\n+These functions provide low-level conversions between character sequences and\n+numeric values. This seems like a good candidate for use in HotSpot,\n+potentially replacing various clumsy or less performant alternatives. There is\n+no memory allocation. Parsing failures are indicated via error codes rather\n+than exceptions. Various other nice for HotSpot properties.\n+\n+Note that the published C++17 Standard puts these in `<utility>`, but a defect\n+report moved them to `<charconv>`. This also needs `<system_error>`.\n+\n+This would require upgrading the minimum gcc version to 11.1 for floating\n+point conversion support. The minimum Visual Studio version is already\n+sufficient.  The minimum clang version requirement hasn't been determined yet.\n+\n+### `std::launder()`\n+\n+It is undecided whether to permit the use of `std::launder()`\n+([p0137r1](http:\/\/wg21.link\/p0137r1)).\n+\n+Change to permitted if we discover a place where we need it. Or maybe we\n+should just permit it, but hope we don't need it.\n+\n+Also, C++20 revised the relevant part of Object Lifetime in a way that seems\n+more permissive and with less need of laundering. We don't know if\n+implementations of prior versions take advantage of the difference.\n+\n+See Object Lifetime: C++17 6.8\/8, C++20 6.7.3\/8\n+\n+### Additional Undecided Features\n+\n@@ -1298,1 +1816,2 @@\n-([n3651](https:\/\/isocpp.org\/files\/papers\/N3651.pdf))\n+([n3651](https:\/\/isocpp.org\/files\/papers\/N3651.pdf),\n+[p0127r2](http:\/\/wg21.link\/p0127r2))\n@@ -1305,0 +1824,27 @@\n+* Shorthand for nested namespaces\n+([n4230](http:\/\/wg21.link\/n4230)) &mdash;\n+HotSpot makes very little use of namespaces, so this seemingly innocuous\n+feature probably isn't useful to us.\n+\n+* Direct list initialization with `auto`\n+([n3681](http:\/\/wg21.link\/n3681)) &mdash;\n+This change fixed some issues with direct list initialization and `auto`. But\n+we don't use that feature much, if at all. And perhaps shouldn't be using it.\n+\n+* UTF-8 Character Literals\n+([n4267](http:\/\/wg21.link\/n4267)) &mdash;\n+Do we have a use-case for this?\n+\n+* Fold Expressions\n+([n4295](http:\/\/wg21.link\/n4295)) &mdash;\n+Provides a simple way to apply operators to a parameter pack. HotSpot doesn't\n+use variadic templates very much. That makes it questionable that developers\n+should need to know about this feature.  But if someone does come up with a\n+good use-case, it's likely that the alternatives are significantly worse,\n+because pack manipulation without this can be complicated.\n+\n+* `std::invoke<>()`\n+([n4169](http:\/\/wg21.link\/n4169))\n+\n+\n+\n@@ -1322,0 +1868,3 @@\n+\n+[JOSUTTIS]: https:\/\/www.cppstd17.com\n+  \"C++17: The Complete Guide\"\n","filename":"doc\/hotspot-style.md","additions":584,"deletions":35,"binary":false,"changes":619,"status":"modified"},{"patch":"@@ -14,3 +14,1 @@\n-    \/* The extra [class] is a hack that increases specificity enough to\n-       override a similar rule in reveal.js *\/\n-    ul.task-list[class]{list-style: none;}\n+    ul.task-list{list-style: none;}\n@@ -18,1 +16,0 @@\n-      font-size: inherit;\n","filename":"doc\/starting-next-release.html","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-<\/ul><\/li>\n@@ -77,3 +76,2 @@\n-id=\"toc-testing-ahead-of-time-optimizations\">### Testing Ahead-of-time\n-Optimizations<\/a>\n-<ul>\n+id=\"toc-testing-ahead-of-time-optimizations\">Testing Ahead-of-time\n+Optimizations<\/a><\/li>\n@@ -403,1 +401,2 @@\n-<p>Currently only applies to JTReg.<\/p>\n+<p>Currently only applies to <a href=\"#timeout_factor-1\">JTReg\n+-timeoutFactor<\/a>.<\/p>\n@@ -438,0 +437,3 @@\n+<h4 id=\"aot_jdk\">AOT_JDK<\/h4>\n+<p>See <a href=\"#testing-ahead-of-time-optimizations\">Testing\n+Ahead-of-time optimizations<\/a>.<\/p>\n@@ -446,2 +448,6 @@\n-<p>The timeout factor (<code>-timeoutFactor<\/code>).<\/p>\n-<p>Defaults to 4.<\/p>\n+<p>The <code>TIMEOUT_FACTOR<\/code> is forwarded to JTReg framework\n+itself (<code>-timeoutFactor<\/code>). Also, some test cases that\n+programmatically wait a certain amount of time will apply this factor.\n+If we run in forced compilation mode (<code>-Xcomp<\/code>), the build\n+system will automatically adjust this factor to compensate for less\n+performance. Defaults to 1.<\/p>\n@@ -460,0 +466,6 @@\n+<h4 id=\"jvmti_stress_agent\">JVMTI_STRESS_AGENT<\/h4>\n+<p>Executes JTReg tests with JVM TI stress agent. The stress agent is\n+the part of test library and located in\n+<code>test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp<\/code>. The\n+value of this argument is set as JVM TI agent options. This mode uses\n+ProblemList-jvmti-stress-agent.txt as an additional exclude list.<\/p>\n@@ -559,0 +571,6 @@\n+<h4 id=\"test_jdk\">TEST_JDK<\/h4>\n+<p>The path to the JDK that will be used to run the benchmarks.<\/p>\n+<p>Defaults to <code>build\/&lt;CONF-NAME&gt;\/jdk<\/code>.<\/p>\n+<h4 id=\"benchmarks_jar\">BENCHMARKS_JAR<\/h4>\n+<p>The path to the JAR containing the benchmarks.<\/p>\n+<p>Defaults to <code>test\/micro\/benchmarks.jar<\/code>.<\/p>\n@@ -604,2 +622,2 @@\n-<h2 id=\"testing-ahead-of-time-optimizations\">### Testing Ahead-of-time\n-Optimizations<\/h2>\n+<h3 id=\"testing-ahead-of-time-optimizations\">Testing Ahead-of-time\n+Optimizations<\/h3>\n","filename":"doc\/testing.html","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-Currently only applies to JTReg.\n+Currently only applies to [JTReg -timeoutFactor](#timeout_factor-1).\n@@ -370,0 +370,4 @@\n+#### AOT_JDK\n+\n+See [Testing Ahead-of-time optimizations](#testing-ahead-of-time-optimizations).\n+\n@@ -382,3 +386,5 @@\n-The timeout factor (`-timeoutFactor`).\n-\n-Defaults to 4.\n+The `TIMEOUT_FACTOR` is forwarded to JTReg framework itself\n+(`-timeoutFactor`). Also, some test cases that programmatically wait a\n+certain amount of time will apply this factor. If we run in forced\n+compilation mode (`-Xcomp`), the build system will automatically\n+adjust this factor to compensate for less performance. Defaults to 1.\n@@ -400,0 +406,7 @@\n+#### JVMTI_STRESS_AGENT\n+\n+Executes JTReg tests with JVM TI stress agent. The stress agent is the part of\n+test library and located in `test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp`.\n+The value of this argument is set as JVM TI agent options.\n+This mode uses ProblemList-jvmti-stress-agent.txt as an additional exclude list.\n+\n@@ -548,0 +561,12 @@\n+#### TEST_JDK\n+\n+The path to the JDK that will be used to run the benchmarks.\n+\n+Defaults to `build\/<CONF-NAME>\/jdk`.\n+\n+#### BENCHMARKS_JAR\n+\n+The path to the JAR containing the benchmarks.\n+\n+Defaults to `test\/micro\/benchmarks.jar`.\n+\n@@ -615,1 +640,1 @@\n--------------------------------------------------------------------------------\n+\n","filename":"doc\/testing.md","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+    TARGET_RELEASE := $(TARGET_RELEASE), \\\n","filename":"make\/CompileJavaModules.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -260,0 +260,1 @@\n+    WORKING_DIR := $(WORKSPACE_ROOT), \\\n","filename":"make\/CreateJmods.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -207,2 +207,3 @@\n-        TEST_MODE ASSERT VERBOSE RETAIN TEST_THREAD_FACTORY MAX_MEM RUN_PROBLEM_LISTS \\\n-        RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n+        TEST_MODE ASSERT VERBOSE RETAIN TEST_THREAD_FACTORY JVMTI_STRESS_AGENT \\\n+        MAX_MEM RUN_PROBLEM_LISTS RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT \\\n+        AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n@@ -879,0 +880,9 @@\n+  ifneq ($$(JTREG_JVMTI_STRESS_AGENT), )\n+    AGENT := $$(LIBRARY_PREFIX)JvmtiStressAgent$$(SHARED_LIBRARY_SUFFIX)=$$(JTREG_JVMTI_STRESS_AGENT)\n+    $1_JTREG_BASIC_OPTIONS += -javaoption:'-agentpath:$(TEST_IMAGE_DIR)\/hotspot\/jtreg\/native\/$$(AGENT)'\n+    $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$(wildcard \\\n+\t    $$(addprefix $$($1_TEST_ROOT)\/, ProblemList-jvmti-stress-agent.txt) \\\n+        ))\n+  endif\n+\n+\n@@ -939,1 +949,2 @@\n-  JTREG_AUTO_TIMEOUT_FACTOR := 4\n+  # Please reach consensus before changing this. It was not easy changing it to a `1`.\n+  JTREG_AUTO_TIMEOUT_FACTOR := 1\n@@ -1246,1 +1257,1 @@\n-      $(TR) -cs '[a-z][A-Z][0-9]\\n' '[_*1000]')) \\\n+      $(TR) -cs '[a-z][A-Z][0-9]\\n' '_')) \\\n@@ -1326,1 +1337,1 @@\n-\t      $(TR) -cs '[a-z][A-Z][0-9]\\n' '[_*1000]')) \\\n+\t      $(TR) -cs '[a-z][A-Z][0-9]\\n' '_')) \\\n@@ -1328,1 +1339,1 @@\n-\t  $(eval NAME_PATTERN := $(shell $(ECHO) $(test) | $(TR) -c '\\n' '[_*1000]')) \\\n+\t  $(eval NAME_PATTERN := $(shell $(ECHO) $(test) | $(TR) -c '\\n' '_')) \\\n","filename":"make\/RunTests.gmk","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -179,0 +179,16 @@\n+\n+# These settings are needed to run testing with jvmti agent\n+ifeq ($(OPENJDK_BUILD_OS), linux)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .so\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), windows)\n+  LIBRARY_PREFIX :=\n+  SHARED_LIBRARY_SUFFIX := .dll\n+endif\n+\n+ifeq ($(OPENJDK_BUILD_OS), macosx)\n+  LIBRARY_PREFIX := lib\n+  SHARED_LIBRARY_SUFFIX := .dylib\n+endif\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+TOOL_VARHANDLEGUARDMETHODGENERATOR = $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n+    build.tools.methodhandle.VarHandleGuardMethodGenerator\n+\n","filename":"make\/ToolsJdk.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    INCLUDES := compileproperties propertiesparser, \\\n+    INCLUDES := compileproperties flagsgenerator propertiesparser, \\\n","filename":"make\/ToolsLangtools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-    COMMAND := cd $(SLEEF_SOURCE_DIR) && $(CMAKE) -S . -B \\\n-        $(SLEEF_NATIVE_BUILD_DIR), \\\n+    WORKING_DIR := $(SLEEF_SOURCE_DIR), \\\n+    COMMAND := $(CMAKE) -S . -B $(SLEEF_NATIVE_BUILD_DIR), \\\n@@ -94,2 +94,2 @@\n-    COMMAND := cd $(SLEEF_SOURCE_DIR) && $(CMAKE) --build \\\n-        $(SLEEF_NATIVE_BUILD_DIR) -j, \\\n+    WORKING_DIR := $(SLEEF_SOURCE_DIR), \\\n+    COMMAND := $(CMAKE) --build $(SLEEF_NATIVE_BUILD_DIR) -j, \\\n@@ -104,2 +104,2 @@\n-    COMMAND := cd $(SLEEF_SOURCE_DIR) && $(CMAKE) -S . -B \\\n-        $(SLEEF_CROSS_BUILD_DIR) \\\n+    WORKING_DIR := $(SLEEF_SOURCE_DIR), \\\n+    COMMAND := $(CMAKE) -S . -B $(SLEEF_CROSS_BUILD_DIR) \\\n@@ -119,2 +119,2 @@\n-    COMMAND := cd $(SLEEF_SOURCE_DIR) && $(CMAKE) --build \\\n-        $(SLEEF_CROSS_BUILD_DIR) -j, \\\n+    WORKING_DIR := $(SLEEF_SOURCE_DIR), \\\n+    COMMAND := $(CMAKE) --build $(SLEEF_CROSS_BUILD_DIR) -j, \\\n","filename":"make\/UpdateSleefSource.gmk","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-  OLDEST_BOOT_JDK=`$ECHO $DEFAULT_ACCEPTABLE_BOOT_VERSIONS \\\n+  OLDEST_BOOT_JDK_VERSION=`$ECHO $DEFAULT_ACCEPTABLE_BOOT_VERSIONS \\\n@@ -400,3 +400,1 @@\n-  # -Xlint:-options is added to avoid \"warning: [options] system modules path not set in conjunction with -source\"\n-  BOOT_JDK_SOURCETARGET=\"-source $OLDEST_BOOT_JDK -target $OLDEST_BOOT_JDK -Xlint:-options\"\n-  AC_SUBST(BOOT_JDK_SOURCETARGET)\n+  AC_SUBST(OLDEST_BOOT_JDK_VERSION)\n","filename":"make\/autoconf\/boot-jdk.m4","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -224,0 +224,3 @@\n+# Setup static analyzer\n+JDKOPT_SETUP_STATIC_ANALYZER\n+\n","filename":"make\/autoconf\/configure.ac","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-    LANGSTD_CXXFLAGS=\"-std=c++14\"\n+    LANGSTD_CXXFLAGS=\"-std=c++17\"\n@@ -602,1 +602,1 @@\n-    LANGSTD_CXXFLAGS=\"-std:c++14\"\n+    LANGSTD_CXXFLAGS=\"-std:c++17\"\n@@ -604,1 +604,1 @@\n-    AC_MSG_ERROR([Cannot enable C++14 for this toolchain])\n+    AC_MSG_ERROR([Cannot enable C++17 for this toolchain])\n@@ -943,1 +943,1 @@\n-  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_CPU\" = \"xlinux\"; then\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then\n@@ -957,0 +957,11 @@\n+            # Switching the initialization mode with gcc from 'pattern' to 'zero'\n+            # avoids the use of unsupported `__builtin_clear_padding` for variable\n+            # length aggregates\n+            if test \"x$DEBUG_LEVEL\" != xrelease && test \"x$TOOLCHAIN_TYPE\" = xgcc ; then\n+              INIT_ZERO_FLAG=\"-ftrivial-auto-var-init=zero\"\n+              FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [$INIT_ZERO_FLAG],\n+                IF_TRUE: [\n+                  $2SVE_CFLAGS=\"${$2SVE_CFLAGS} $INIT_ZERO_FLAG\"\n+                ]\n+              )\n+            fi\n","filename":"make\/autoconf\/flags-cflags.m4","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,5 @@\n-    BASIC_ASFLAGS=\"-nologo -c\"\n+    if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+      BASIC_ASFLAGS=\"-nologo\"\n+    else\n+      BASIC_ASFLAGS=\"-nologo -c\"\n+    fi\n","filename":"make\/autoconf\/flags-other.m4","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -323,0 +323,3 @@\n+    if test \"x$OPENJDK_TARGET_CPU\" != xaarch64; then\n+      AS_NON_ASM_EXTENSION_OPTION=-Ta\n+    fi\n@@ -329,0 +332,1 @@\n+  AC_SUBST(AS_NON_ASM_EXTENSION_OPTION)\n","filename":"make\/autoconf\/flags.m4","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -482,0 +482,25 @@\n+################################################################################\n+#\n+# Static analyzer\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_STATIC_ANALYZER],\n+[\n+  UTIL_ARG_ENABLE(NAME: static-analyzer, DEFAULT: false, RESULT: STATIC_ANALYZER_ENABLED,\n+      DESC: [enable the GCC static analyzer],\n+      CHECK_AVAILABLE: [\n+        AC_MSG_CHECKING([if static analyzer is available])\n+        if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\"; then\n+          AC_MSG_RESULT([yes])\n+        else\n+          AC_MSG_RESULT([no])\n+          AVAILABLE=false\n+        fi\n+      ],\n+      IF_ENABLED: [\n+        STATIC_ANALYZER_CFLAGS=\"-fanalyzer -Wno-analyzer-fd-leak\"\n+        CFLAGS_JDKLIB=\"$CFLAGS_JDKLIB $STATIC_ANALYZER_CFLAGS\"\n+        CFLAGS_JDKEXE=\"$CFLAGS_JDKEXE $STATIC_ANALYZER_CFLAGS\"\n+      ])\n+  AC_SUBST(STATIC_ANALYZER_ENABLED)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -516,0 +516,4 @@\n+  if JVM_FEATURES_IS_ACTIVE(jfr) && ! JVM_FEATURES_IS_ACTIVE(services); then\n+    AC_MSG_ERROR([Specified JVM feature 'jfr' requires feature 'services' for variant '$variant'])\n+  fi\n+\n","filename":"make\/autoconf\/jvm-features.m4","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -396,3 +396,2 @@\n-# When compiling Java source to be run by the boot jdk\n-# use these extra flags, eg -source 6 -target 6\n-BOOT_JDK_SOURCETARGET := @BOOT_JDK_SOURCETARGET@\n+# The oldest supported boot jdk version\n+OLDEST_BOOT_JDK_VERSION := @OLDEST_BOOT_JDK_VERSION@\n@@ -496,0 +495,1 @@\n+AS_NON_ASM_EXTENSION_OPTION := @AS_NON_ASM_EXTENSION_OPTION@\n","filename":"make\/autoconf\/spec.gmk.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -658,2 +658,5 @@\n-    if test \"x$OPENJDK_TARGET_CPU_BITS\" = \"x64\"; then\n-      # On 64 bit windows, the assembler is \"ml64.exe\"\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+      # On Windows aarch64, the assembler is \"armasm64.exe\"\n+      UTIL_LOOKUP_TOOLCHAIN_PROGS(AS, armasm64)\n+    elif test \"x$OPENJDK_TARGET_CPU_BITS\" = \"x64\"; then\n+      # On Windows x64, the assembler is \"ml64.exe\"\n","filename":"make\/autoconf\/toolchain.m4","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+# Before execution, the current working directory is changed to SUPPORT_DIR.\n+# This can be overridden with WORKING_DIR.\n+#\n@@ -78,0 +81,1 @@\n+#   WORKING_DIR : Directory to cd to before executing the command\n@@ -136,0 +140,4 @@\n+  ifeq ($$($1_WORKING_DIR), )\n+    $1_WORKING_DIR := $$($1_SUPPORT_DIR)\n+  endif\n+\n@@ -150,1 +158,1 @@\n-\t$$(call MakeDir, $$($1_SUPPORT_DIR) $$($1_OUTPUT_DIR))\n+\t$$(call MakeDir, $$(call EncodeSpace, $$($1_WORKING_DIR)) $$(call EncodeSpace, $$($1_SUPPORT_DIR)) $$(call EncodeSpace, $$($1_OUTPUT_DIR)))\n@@ -152,1 +160,1 @@\n-\t    $$($1_PRE_COMMAND))\n+\t    cd $$($1_WORKING_DIR) && $$($1_PRE_COMMAND))\n@@ -157,1 +165,1 @@\n-\t    $$($1_COMMAND))\n+\t    cd $$($1_WORKING_DIR) && $$($1_COMMAND))\n@@ -171,1 +179,1 @@\n-\t$$(call MakeDir, $$(call EncodeSpace, $$($1_SUPPORT_DIR)) $$(call EncodeSpace, $$($1_OUTPUT_DIR)))\n+\t$$(call MakeDir, $$(call EncodeSpace, $$($1_WORKING_DIR)) $$(call EncodeSpace, $$($1_SUPPORT_DIR)) $$(call EncodeSpace, $$($1_OUTPUT_DIR)))\n@@ -173,1 +181,1 @@\n-\t    $$($1_COMMAND))\n+\t    cd $$($1_WORKING_DIR) && $$($1_COMMAND))\n@@ -185,1 +193,1 @@\n-\t    $$($1_POST_COMMAND))\n+\t    cd $$($1_WORKING_DIR) && $$($1_POST_COMMAND))\n","filename":"make\/common\/Execute.gmk","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,4 +41,9 @@\n-TARGET_RELEASE_BOOTJDK := $(BOOT_JDK_SOURCETARGET)\n-\n-# Create classes that can be used in (or be a part of) the new jdk we're building\n-TARGET_RELEASE_NEWJDK := -source $(JDK_SOURCE_TARGET_VERSION) -target $(JDK_SOURCE_TARGET_VERSION)\n+# -Xlint:-options is added to avoid the warning\n+# \"system modules path not set in conjunction with -source\"\n+TARGET_RELEASE_BOOTJDK := -source $(OLDEST_BOOT_JDK_VERSION) \\\n+    -target $(OLDEST_BOOT_JDK_VERSION) -Xlint:-options\n+\n+# Create classes that can be used in (or be a part of) the new jdk we're\n+# building\n+TARGET_RELEASE_NEWJDK := -source $(JDK_SOURCE_TARGET_VERSION) \\\n+    -target $(JDK_SOURCE_TARGET_VERSION)\n","filename":"make\/common\/JavaCompilation.gmk","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,4 +30,9 @@\n-# Hook to include the corresponding custom file, if present.\n-ifneq ($(NO_CUSTOM_EXTENSIONS), true)\n-  CUSTOM_POST_NAME := $(subst .gmk,-post.gmk, $(THIS_INCLUDE))\n-  $(eval $(call IncludeCustomExtension, $(CUSTOM_POST_NAME)))\n+ifneq ($(INCLUDE_GUARD_$(THIS_INCLUDE)), true)\n+  # This was the first time this file was included. Prevent future inclusion.\n+  INCLUDE_GUARD_$(THIS_INCLUDE) := true\n+\n+  # Hook to include the corresponding custom file, if present.\n+  ifneq ($(NO_CUSTOM_EXTENSIONS), true)\n+    CUSTOM_POST_NAME := $(subst .gmk,-post.gmk, $(THIS_INCLUDE))\n+    $(eval $(call IncludeCustomExtension, $(CUSTOM_POST_NAME)))\n+  endif\n","filename":"make\/common\/MakeIncludeEnd.gmk","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  INCLUDE_GUARD_$(THIS_INCLUDE) := true\n","filename":"make\/common\/MakeIncludeStart.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-\t        $(CC_OUT_OPTION)$$($1_OBJ) -Ta $$($1_SRC_FILE))) \\\n+\t        $(CC_OUT_OPTION)$$($1_OBJ) $(AS_NON_ASM_EXTENSION_OPTION) $$($1_SRC_FILE))) \\\n","filename":"make\/common\/native\/CompileFile.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-# make TARGETS=\"arm-linux-gnueabihf ppc64-linux-gnu\" BASE_OS=Fedora BASE_OS_VERSION=17\n+# make TARGETS=\"arm-linux-gnueabihf ppc64le-linux-gnu\" BASE_OS=Fedora BASE_OS_VERSION=17\n@@ -53,1 +53,1 @@\n-#    make TARGETS=\"arm-linux-gnueabihf,ppc64-linux-gnu\" BASE_OS=Fedora\n+#    make TARGETS=\"arm-linux-gnueabihf ppc64le-linux-gnu\" BASE_OS=Fedora\n","filename":"make\/devkit\/Makefile","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+  ifeq ($(filter aarch64 armhfp ppc64le riscv64 s390x x86_64, $(ARCH)), )\n+    $(error Only \"aarch64 armhfp ppc64le riscv64 s390x x86_64\" architectures are supported for Fedora, but \"$(ARCH)\" was requested)\n+  endif\n@@ -73,0 +76,3 @@\n+    ifeq ($(filter 38 39 40 41, $(BASE_OS_VERSION)), )\n+      $(error Only Fedora 38-41 are supported for \"$(ARCH)\", but Fedora $(BASE_OS_VERSION) was requested)\n+    endif\n@@ -75,2 +81,2 @@\n-    LATEST_ARCHIVED_OS_VERSION := 35\n-    ifeq ($(filter x86_64 armhfp, $(ARCH)), )\n+    LATEST_ARCHIVED_OS_VERSION := 36\n+    ifeq ($(filter aarch64 armhfp x86_64, $(ARCH)), )\n@@ -81,0 +87,5 @@\n+    ifeq ($(ARCH), armhfp)\n+      ifneq ($(BASE_OS_VERSION), 36)\n+        $(error Fedora 36 is the last release supporting \"armhfp\", but $(BASE_OS) was requested)\n+      endif\n+    endif\n@@ -467,1 +478,1 @@\n-ifneq ($(filter riscv64 ppc64 ppc64le s390x, $(ARCH)), )\n+ifneq ($(filter riscv64 ppc64le s390x, $(ARCH)), )\n","filename":"make\/devkit\/Tools.gmk","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    invalid-offsetof \\\n@@ -104,1 +105,2 @@\n-DISABLED_WARNINGS_clang := delete-non-abstract-non-virtual-dtor missing-braces \\\n+DISABLED_WARNINGS_clang := delete-non-abstract-non-virtual-dtor \\\n+    invalid-offsetof missing-braces \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-\t\t\"C_Cpp.default.cppStandard\": \"c++14\",\n+\t\t\"C_Cpp.default.cppStandard\": \"c++17\",\n","filename":"make\/ide\/vscode\/hotspot\/indexers\/ccls-settings.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-\t\t\"C_Cpp.default.cppStandard\": \"c++14\",\n+\t\t\"C_Cpp.default.cppStandard\": \"c++17\",\n","filename":"make\/ide\/vscode\/hotspot\/indexers\/clangd-settings.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-\t\t\"C_Cpp.default.cppStandard\": \"c++14\",\n+\t\t\"C_Cpp.default.cppStandard\": \"c++17\",\n","filename":"make\/ide\/vscode\/hotspot\/indexers\/cpptools-settings.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-\t\t\"C_Cpp.default.cppStandard\": \"c++14\",\n+\t\t\"C_Cpp.default.cppStandard\": \"c++17\",\n","filename":"make\/ide\/vscode\/hotspot\/indexers\/rtags-settings.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -15,0 +15,1 @@\n+\t\t\t\"oracle.oracle-java\",\n@@ -20,0 +21,4 @@\n+\n+\t\t\/\/ Java extension\n+\t\t\"jdk.project.jdkhome\": \"{{OUTPUTDIR}}\/jdk\",\n+\t\t\"jdk.java.onSave.organizeImports\": false, \/\/ prevents unnecessary changes\n","filename":"make\/ide\/vscode\/hotspot\/template-workspace.jsonc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+        \"NumberElements\/lenientMinusSigns\",\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/Bundle.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -847,0 +847,20 @@\n+        \/\/ Lenient parsing\n+        case \"parseLenients\":\n+            if (\"lenient\".equals(attributes.getValue(\"level\"))) {\n+                pushKeyContainer(qName, attributes, attributes.getValue(\"scope\"));\n+            } else {\n+                pushIgnoredContainer(qName);\n+            }\n+            break;\n+\n+        case \"parseLenient\":\n+            \/\/ Use only the lenient minus sign for now\n+            if (currentContainer instanceof KeyContainer kc\n+                && kc.getKey().equals(\"number\")\n+                && attributes.getValue(\"sample\").equals(\"-\")) {\n+                pushStringEntry(qName, attributes, currentNumberingSystem + \"NumberElements\/lenientMinusSigns\");\n+            } else {\n+                pushIgnoredContainer(qName);\n+            }\n+            break;\n+\n@@ -1153,0 +1173,8 @@\n+        case \"parseLenient\":\n+            if (currentContainer instanceof StringEntry se) {\n+                \/\/ Convert to a simple concatenation of lenient minuses\n+                \/\/ e.g. \"[\\-－﹣ ‐‑ ‒ – −⁻₋ ➖]\" -> \"-－﹣‐‑‒–−⁻₋➖\" for the root locale\n+                put(se.getKey(), se.getValue().replaceAll(\"[\\\\[\\\\]\\\\\\\\ ]\", \"\"));\n+            }\n+            break;\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/LDMLParseHandler.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,325 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package build.tools.methodhandle;\n+\n+import java.io.PrintWriter;\n+import java.lang.classfile.TypeKind;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Method;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A helper program to generate the VarHandleGuards class with a set of\n+ * static guard methods each of which corresponds to a particular shape and\n+ * performs a type check of the symbolic type descriptor with the VarHandle\n+ * type descriptor before linking\/invoking to the underlying operation as\n+ * characterized by the operation member name on the VarForm of the\n+ * VarHandle.\n+ * <p>\n+ * The generated class essentially encapsulates pre-compiled LambdaForms,\n+ * one for each method, for the most common set of method signatures.\n+ * This reduces static initialization costs, footprint costs, and circular\n+ * dependencies that may arise if a class is generated per LambdaForm.\n+ * <p>\n+ * A maximum of L*T*S methods will be generated where L is the number of\n+ * access modes kinds (or unique operation signatures) and T is the number\n+ * of variable types and S is the number of shapes (such as instance field,\n+ * static field, or array access).\n+ * If there are 4 unique operation signatures, 5 basic types (Object, int,\n+ * long, float, double), and 3 shapes then a maximum of 60 methods will be\n+ * generated.  However, the number is likely to be less since there may\n+ * be duplicate signatures.\n+ * <p>\n+ * Each method is annotated with @LambdaForm.Compiled to inform the runtime\n+ * that such methods should be treated as if a method of a class that is the\n+ * result of compiling a LambdaForm.  Annotation of such methods is\n+ * important for correct evaluation of certain assertions and method return\n+ * type profiling in HotSpot.\n+ *\n+ * @see java.lang.invoke.GenerateJLIClassesHelper\n+ *\/\n+public final class VarHandleGuardMethodGenerator {\n+\n+    static final String CLASS_HEADER = \"\"\"\n+            \/*\n+             * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+             * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+             *\n+             * This code is free software; you can redistribute it and\/or modify it\n+             * under the terms of the GNU General Public License version 2 only, as\n+             * published by the Free Software Foundation.  Oracle designates this\n+             * particular file as subject to the \"Classpath\" exception as provided\n+             * by Oracle in the LICENSE file that accompanied this code.\n+             *\n+             * This code is distributed in the hope that it will be useful, but WITHOUT\n+             * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+             * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+             * version 2 for more details (a copy is included in the LICENSE file that\n+             * accompanied this code).\n+             *\n+             * You should have received a copy of the GNU General Public License version\n+             * 2 along with this work; if not, write to the Free Software Foundation,\n+             * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+             *\n+             * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+             * or visit www.oracle.com if you need additional information or have any\n+             * questions.\n+             *\/\n+            package java.lang.invoke;\n+\n+            import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+            import jdk.internal.vm.annotation.ForceInline;\n+            import jdk.internal.vm.annotation.Hidden;\n+\n+            \/\/ This file is generated by build.tools.methodhandle.VarHandleGuardMethodGenerator.\n+            \/\/ Do not edit!\n+            @AOTSafeClassInitializer\n+            final class VarHandleGuards {\n+            \"\"\";\n+\n+    static final String GUARD_METHOD_SIG_TEMPLATE = \"<RETURN> <NAME>_<SIGNATURE>(<PARAMS>)\";\n+\n+    static final String GUARD_METHOD_TEMPLATE =\n+            \"\"\"\n+                    @ForceInline\n+                    @LambdaForm.Compiled\n+                    @Hidden\n+                    static final <METHOD> throws Throwable {\n+                        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+                        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+                            <RESULT_ERASED>MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);<RETURN_ERASED>\n+                        } else {\n+                            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+                            <RETURN>mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n+                        }\n+                    }\"\"\";\n+\n+    static final String GUARD_METHOD_TEMPLATE_V =\n+            \"\"\"\n+                    @ForceInline\n+                    @LambdaForm.Compiled\n+                    @Hidden\n+                    static final <METHOD> throws Throwable {\n+                        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+                        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+                            MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n+                        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+                            MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n+                        } else {\n+                            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+                            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n+                        }\n+                    }\"\"\";\n+\n+    \/\/ A template for deriving the operations\n+    \/\/ could be supported by annotating VarHandle directly with the\n+    \/\/ operation kind and shape\n+    interface VarHandleTemplate {\n+        Object get();\n+\n+        void set(Object value);\n+\n+        boolean compareAndSet(Object actualValue, Object expectedValue);\n+\n+        Object compareAndExchange(Object actualValue, Object expectedValue);\n+\n+        Object getAndUpdate(Object value);\n+    }\n+\n+    record HandleType(Class<?> receiver, Class<?>... intermediates) {\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        if (args.length != 1) {\n+            System.err.println(\"Usage: java VarHandleGuardMethodGenerator VarHandleGuards.java\");\n+            System.exit(1);\n+        }\n+\n+        Path outputFile = Path.of(args[0]);\n+\n+        try (PrintWriter pw = new PrintWriter(Files.newBufferedWriter(\n+                outputFile,\n+                StandardCharsets.UTF_8,\n+                StandardOpenOption.CREATE,\n+                StandardOpenOption.TRUNCATE_EXISTING))) {\n+            print(pw);\n+        }\n+    }\n+\n+    public static void print(PrintWriter pw) {\n+        pw.println(CLASS_HEADER);\n+\n+        \/\/ Declare the stream of shapes\n+        List<HandleType> hts = List.of(\n+                \/\/ Object->T\n+                new HandleType(Object.class),\n+\n+                \/\/ <static>->T\n+                new HandleType(null),\n+\n+                \/\/ Array[index]->T\n+                new HandleType(Object.class, int.class),\n+\n+                \/\/ MS[base]->T\n+                new HandleType(Object.class, long.class),\n+\n+                \/\/ MS[base][offset]->T\n+                new HandleType(Object.class, long.class, long.class)\n+        );\n+\n+        \/\/ The 5 JVM calling convention types\n+        List<Class<?>> basicTypes = List.of(Object.class, int.class, long.class, float.class, double.class);\n+\n+        Stream.of(VarHandleTemplate.class.getMethods()).<MethodType>\n+                        mapMulti((m, sink) -> {\n+                    for (var ht : hts) {\n+                        for (var bt : basicTypes) {\n+                            sink.accept(generateMethodType(m, ht.receiver, bt, ht.intermediates));\n+                        }\n+                    }\n+                }).\n+                distinct().\n+                map(VarHandleGuardMethodGenerator::generateMethod).\n+                forEach(pw::println);\n+\n+        pw.println(\"}\");\n+    }\n+\n+    static MethodType generateMethodType(Method m, Class<?> receiver, Class<?> value, Class<?>... intermediates) {\n+        Class<?> returnType = m.getReturnType() == Object.class\n+                ? value : m.getReturnType();\n+\n+        List<Class<?>> params = new ArrayList<>();\n+        if (receiver != null)\n+            params.add(receiver);\n+        Collections.addAll(params, intermediates);\n+        for (var p : m.getParameters()) {\n+            params.add(value);\n+        }\n+        return MethodType.methodType(returnType, params);\n+    }\n+\n+    static String generateMethod(MethodType mt) {\n+        Class<?> returnType = mt.returnType();\n+\n+        var params = new LinkedHashMap<String, String>();\n+        params.put(\"handle\", className(VarHandle.class));\n+        for (int i = 0; i < mt.parameterCount(); i++) {\n+            params.put(\"arg\" + i, className(mt.parameterType(i)));\n+        }\n+        params.put(\"ad\", \"VarHandle.AccessDescriptor\");\n+\n+        \/\/ Generate method signature line\n+        String RETURN = className(returnType);\n+        String NAME = \"guard\";\n+        String SIGNATURE = getSignature(mt);\n+        String PARAMS = params.entrySet().stream().\n+                map(e -> e.getValue() + \" \" + e.getKey()).\n+                collect(Collectors.joining(\", \"));\n+        String METHOD = GUARD_METHOD_SIG_TEMPLATE.\n+                replace(\"<RETURN>\", RETURN).\n+                replace(\"<NAME>\", NAME).\n+                replace(\"<SIGNATURE>\", SIGNATURE).\n+                replace(\"<PARAMS>\", PARAMS);\n+\n+        \/\/ Generate method\n+        params.remove(\"ad\");\n+\n+        List<String> LINK_TO_STATIC_ARGS = new ArrayList<>(params.keySet());\n+        LINK_TO_STATIC_ARGS.add(\"handle.vform.getMemberName(ad.mode)\");\n+\n+        List<String> LINK_TO_INVOKER_ARGS = new ArrayList<>(params.keySet());\n+        LINK_TO_INVOKER_ARGS.set(0, LINK_TO_INVOKER_ARGS.get(0) + \".asDirect()\");\n+\n+        RETURN = returnType == void.class\n+                ? \"\"\n+                : returnType == Object.class\n+                ? \"return \"\n+                : \"return (\" + returnType.getName() + \") \";\n+\n+        String RESULT_ERASED = returnType == void.class\n+                ? \"\"\n+                : returnType != Object.class\n+                ? \"return (\" + returnType.getName() + \") \"\n+                : \"Object r = \";\n+\n+        String RETURN_ERASED = returnType != Object.class\n+                ? \"\"\n+                : \"\\n        return ad.returnType.cast(r);\";\n+\n+        String template = returnType == void.class\n+                ? GUARD_METHOD_TEMPLATE_V\n+                : GUARD_METHOD_TEMPLATE;\n+        return template.\n+                replace(\"<METHOD>\", METHOD).\n+                replace(\"<NAME>\", NAME).\n+                replaceAll(\"<RETURN>\", RETURN).\n+                replace(\"<RESULT_ERASED>\", RESULT_ERASED).\n+                replace(\"<RETURN_ERASED>\", RETURN_ERASED).\n+                replaceAll(\"<LINK_TO_STATIC_ARGS>\", String.join(\", \", LINK_TO_STATIC_ARGS)).\n+                replace(\"<LINK_TO_INVOKER_ARGS>\", String.join(\", \", LINK_TO_INVOKER_ARGS))\n+                .indent(4);\n+    }\n+\n+    static String className(Class<?> c) {\n+        String n = c.getCanonicalName();\n+        if (n == null)\n+            throw new IllegalArgumentException(\"Not representable in source code: \" + c);\n+        if (!c.isPrimitive() && c.getPackageName().equals(\"java.lang\")) {\n+            n = n.substring(\"java.lang.\".length());\n+        } else if (c.getPackageName().equals(\"java.lang.invoke\")) {\n+            n = n.substring(\"java.lang.invoke.\".length());\n+        }\n+        return n;\n+    }\n+\n+    static String getSignature(MethodType m) {\n+        StringBuilder sb = new StringBuilder(m.parameterCount() + 1);\n+\n+        for (int i = 0; i < m.parameterCount(); i++) {\n+            Class<?> pt = m.parameterType(i);\n+            sb.append(getCharType(pt));\n+        }\n+\n+        sb.append('_').append(getCharType(m.returnType()));\n+\n+        return sb.toString();\n+    }\n+\n+    static char getCharType(Class<?> pt) {\n+        return TypeKind.from(pt).upperBound().descriptorString().charAt(0);\n+    }\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/methodhandle\/VarHandleGuardMethodGenerator.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package flagsgenerator;\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.Trees;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.ElementFilter;\n+import javax.tools.ToolProvider;\n+\n+public class FlagsGenerator {\n+    public static void main(String... args) throws IOException {\n+        var compiler = ToolProvider.getSystemJavaCompiler();\n+\n+        try (var fm = compiler.getStandardFileManager(null, null, null)) {\n+            JavacTask task = (JavacTask) compiler.getTask(null, null, d -> {}, null, null, fm.getJavaFileObjects(args[0]));\n+            Trees trees = Trees.instance(task);\n+            CompilationUnitTree cut = task.parse().iterator().next();\n+\n+            task.analyze();\n+\n+            TypeElement clazz = (TypeElement) trees.getElement(new TreePath(new TreePath(cut), cut.getTypeDecls().get(0)));\n+            Map<Integer, List<String>> flag2Names = new TreeMap<>();\n+            Map<FlagTarget, Map<Integer, List<String>>> target2FlagBit2Fields = new EnumMap<>(FlagTarget.class);\n+            Map<String, String> customToString = new HashMap<>();\n+            Set<String> noToString = new HashSet<>();\n+\n+            for (VariableElement field : ElementFilter.fieldsIn(clazz.getEnclosedElements())) {\n+                String flagName = field.getSimpleName().toString();\n+                for (AnnotationMirror am : field.getAnnotationMirrors()) {\n+                    switch (am.getAnnotationType().toString()) {\n+                        case \"com.sun.tools.javac.code.Flags.Use\" -> {\n+                            long flagValue = ((Number) field.getConstantValue()).longValue();\n+                            int flagBit = 63 - Long.numberOfLeadingZeros(flagValue);\n+\n+                            flag2Names.computeIfAbsent(flagBit, _ -> new ArrayList<>())\n+                                      .add(flagName);\n+\n+                            List<?> originalTargets = (List<?>) valueOfValueAttribute(am);\n+                            originalTargets.stream()\n+                                           .map(value -> FlagTarget.valueOf(value.toString()))\n+                                           .forEach(target -> target2FlagBit2Fields.computeIfAbsent(target, _ -> new HashMap<>())\n+                                                                                   .computeIfAbsent(flagBit, _ -> new ArrayList<>())\n+                                                                                   .add(flagName));\n+                        }\n+                        case \"com.sun.tools.javac.code.Flags.CustomToStringValue\" -> {\n+                            customToString.put(flagName, (String) valueOfValueAttribute(am));\n+                        }\n+                        case \"com.sun.tools.javac.code.Flags.NoToStringValue\" -> {\n+                            noToString.add(flagName);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/verify there are no flag overlaps:\n+            for (Entry<FlagTarget, Map<Integer, List<String>>> targetAndFlag : target2FlagBit2Fields.entrySet()) {\n+                for (Entry<Integer, List<String>> flagAndFields : targetAndFlag.getValue().entrySet()) {\n+                    if (flagAndFields.getValue().size() > 1) {\n+                        throw new AssertionError(\"duplicate flag for target: \" + targetAndFlag.getKey() +\n+                                                 \", flag: \" + flagAndFields.getKey() +\n+                                                 \", flags fields: \" + flagAndFields.getValue());\n+                    }\n+                }\n+            }\n+\n+            try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(Paths.get(args[1])))) {\n+                out.println(\"\"\"\n+                            package com.sun.tools.javac.code;\n+\n+                            public enum FlagsEnum {\n+                            \"\"\");\n+                for (Entry<Integer, List<String>> e : flag2Names.entrySet()) {\n+                    String constantName = e.getValue().stream().collect(Collectors.joining(\"_OR_\"));\n+                    String toString = e.getValue()\n+                                       .stream()\n+                                       .filter(n -> !noToString.contains(n))\n+                                       .map(n -> customToString.getOrDefault(n, n.toLowerCase(Locale.US)))\n+                                       .collect(Collectors.joining(\" or \"));\n+                    out.println(\"    \" + constantName + \"(1L<<\" + e.getKey() + \", \\\"\" + toString + \"\\\"),\");\n+                }\n+                out.println(\"\"\"\n+                                ;\n+\n+                                private final long value;\n+                                private final String toString;\n+                                private FlagsEnum(long value, String toString) {\n+                                    this.value = value;\n+                                    this.toString = toString;\n+                                }\n+                                public long value() {\n+                                    return value;\n+                                }\n+                                public String toString() {\n+                                    return toString;\n+                                }\n+                            }\n+                            \"\"\");\n+            }\n+        }\n+    }\n+\n+    private static Object valueOfValueAttribute(AnnotationMirror am) {\n+        return am.getElementValues()\n+                 .values()\n+                 .iterator()\n+                 .next()\n+                 .getValue();\n+    }\n+\n+    private enum FlagTarget {\n+        BLOCK,\n+        CLASS,\n+        METHOD,\n+        MODULE,\n+        PACKAGE,\n+        TYPE_VAR,\n+        VARIABLE;\n+    }\n+}\n","filename":"make\/langtools\/tools\/flagsgenerator\/FlagsGenerator.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-        FLAG(\"flag\", \"Flag\", \"com.sun.tools.javac.code.Flags\"),\n+        FLAG(\"flag\", \"FlagsEnum\", \"com.sun.tools.javac.code\"),\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/MessageType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -305,0 +305,12 @@\n+GENSRC_VARHANDLEGUARDS := $(VARHANDLES_GENSRC_DIR)\/VarHandleGuards.java\n+\n+$(GENSRC_VARHANDLEGUARDS): $(BUILD_TOOLS_JDK)\n+\t$(call LogInfo, Generating $@)\n+\t$(call MakeTargetDir)\n+\t$(TOOL_VARHANDLEGUARDMETHODGENERATOR) \\\n+\t    $(GENSRC_VARHANDLEGUARDS)\n+\n+TARGETS += $(GENSRC_VARHANDLEGUARDS)\n+\n+################################################################################\n+\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,5 +44,0 @@\n-################################################################################\n-#\n-# Compile properties files into enum-like classes using the propertiesparser tool\n-#\n-\n@@ -55,0 +50,5 @@\n+################################################################################\n+#\n+# Compile properties files into enum-like classes using the propertiesparser tool\n+#\n+\n@@ -79,0 +79,23 @@\n+#\n+# Generate FlagsEnum from Flags constants\n+#\n+\n+TOOL_FLAGSGENERATOR_CMD := $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/langtools_tools_classes \\\n+    flagsgenerator.FlagsGenerator\n+\n+FLAGS_SRC := \\\n+    $(MODULE_SRC)\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java\n+\n+FLAGS_OUT := \\\n+    $(SUPPORT_OUTPUTDIR)\/gensrc\/$(MODULE)\/com\/sun\/tools\/javac\/code\/FlagsEnum.java\n+\n+$(eval $(call SetupExecute, FLAGSGENERATOR, \\\n+    WARN := Generating FlagsEnum, \\\n+    DEPS := $(FLAGS_SRC) $(BUILD_TOOLS_LANGTOOLS), \\\n+    OUTPUT_FILE := $(FLAGS_OUT), \\\n+    COMMAND := $(TOOL_FLAGSGENERATOR_CMD) $(FLAGS_SRC) $(FLAGS_OUT), \\\n+))\n+\n+TARGETS += $(FLAGSGENERATOR)\n+\n+################################################################################\n","filename":"make\/modules\/jdk.compiler\/Gensrc.gmk","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK)\n+\n","filename":"make\/modules\/jdk.internal.vm.ci\/Java.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    LIBS_linux := $(LIBDL), \\\n+    LIBS_linux := $(LIBDL) $(LIBPTHREAD), \\\n@@ -100,1 +100,1 @@\n-      LIBS_linux := $(LIBDL), \\\n+      LIBS_linux := $(LIBDL) $(LIBPTHREAD), \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  echo \"-b     Specifies the base reference for change set lookup.\"\n@@ -66,1 +67,1 @@\n-  echo \"       as specified by -y.\"\n+  echo \"       as specified by -y. Overrides -b flag.\"\n@@ -72,0 +73,1 @@\n+base_reference=master\n@@ -74,1 +76,1 @@\n-while getopts \"c:fhy:\" option; do\n+while getopts \"b:c:fhy:\" option; do\n@@ -76,0 +78,3 @@\n+    b) # supplied base reference\n+      base_reference=${OPTARG}\n+      ;;\n@@ -114,1 +119,1 @@\n-    vcs_list_changesets=(git log --no-merges 'master..HEAD' --since=\"${year}-01-01T00:00:00Z\" --until=\"${year}-12-31T23:59:59Z\" --pretty=tformat:\"%H\")\n+    vcs_list_changesets=(git log --no-merges \"${base_reference}..HEAD\" --since=\"${year}-01-01T00:00:00Z\" --until=\"${year}-12-31T23:59:59Z\" --pretty=tformat:\"%H\")\n","filename":"make\/scripts\/update_copyright_year.sh","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+#!\/bin\/sh\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+# The output of this script may require some degree of human curation:\n+# - Redundant headers, e.g. both x.hpp, x.inline.hpp are included;\n+# - Headers relative to a non-default feature should be protected by an\n+#   appropriate 'if' clause to make sure all variants can build without \n+#   errors.\n+\n+# Time threshold for header compilation, if the time exceeds the\n+# threshold the header will be precompiled.\n+if [ -z \"$MIN_MS\" ]; then\n+  MIN_MS=100000\n+fi\n+\n+if [ -z \"$CLEAN\" ]; then\n+  CLEAN=true\n+elif [ \"$CLEAN\" != \"true\" ] && [ \"$CLEAN\" != \"false\" ]; then\n+  echo \"Expected either 'true' or 'false' for CLEAN\"\n+fi\n+\n+# CBA_PATH should point to a valid ClangBuildAnalyzer executable.\n+# Build steps:\n+# git clone --depth 1 git@github.com:aras-p\/ClangBuildAnalyzer.git\n+# cd ClangBuildAnalyzer\n+# make -f projects\/make\/Makefile\n+if [ -z \"$CBA_PATH\" ]; then\n+  CBA_PATH=\".\/ClangBuildAnalyzer\/build\/ClangBuildAnalyzer\"\n+fi\n+\n+set -eux\n+\n+PRECOMPILED_HPP=\"src\/hotspot\/share\/precompiled\/precompiled.hpp\"\n+CBA_CONFIG=\"ClangBuildAnalyzer.ini\"\n+TIMESTAMP=\"$(date +%Y%m%d-%H%M)\"\n+RUN_NAME=\"pch_update_$TIMESTAMP\"\n+CBA_OUTPUT=\"cba_out_$TIMESTAMP\"\n+\n+if [ \"$CLEAN\" = \"true\" ]; then\n+  trap 'rm -rf \"build\/'\"$RUN_NAME\"'\" \"$CBA_OUTPUT\" \"$CBA_CONFIG\"' EXIT\n+fi\n+\n+sh configure --with-toolchain-type=clang \\\n+             --with-conf-name=\"$RUN_NAME\" \\\n+             --disable-precompiled-headers \\\n+             --with-extra-cxxflags=\"-ftime-trace\" \\\n+             --with-extra-cflags=\"-ftime-trace\"\n+\n+make clean CONF_NAME=\"$RUN_NAME\"\n+make hotspot CONF_NAME=\"$RUN_NAME\"\n+\"$CBA_PATH\" --all \".\/build\/$RUN_NAME\/hotspot\/variant-server\/libjvm\/objs\" \\\n+  \"$CBA_OUTPUT\"\n+\n+# Preserve license and comments on top\n+cat \"$PRECOMPILED_HPP\" | awk '\/^#include\/ {exit} {print}' > \"$PRECOMPILED_HPP.tmp\"\n+\n+if [ ! -f \"$CBA_CONFIG\" ]; then\n+cat <<EOF > \"$CBA_CONFIG\"\n+[counts]\n+header=100\n+headerChain=0\n+template=0\n+function=0\n+fileCodegen=0\n+fileParse=0\n+\n+[misc]\n+onlyRootHeaders=true\n+EOF\n+fi\n+\n+\"$CBA_PATH\" --analyze \"$CBA_OUTPUT\" | \\\n+  grep \" ms: \" | \\\n+  # Keep the headers more expensive than ${1}ms\n+  awk -v x=\"$MIN_MS\" '$1 < x { exit } { print $3 }' | \\\n+  # Filter away non-hotspot headers\n+  grep hotspot\/share | \\\n+  awk -F \"hotspot\/share\/\" '{ printf \"#include \\\"%s\\\"\\n\", $2 }' \\\n+  >> \"$PRECOMPILED_HPP.tmp\"\n+mv \"$PRECOMPILED_HPP.tmp\" \"$PRECOMPILED_HPP\"\n+\n+java test\/hotspot\/jtreg\/sources\/SortIncludes.java --update \"$PRECOMPILED_HPP\"\n","filename":"make\/scripts\/update_pch.sh","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -925,2 +925,4 @@\n-        printConstructor2(out, event, empty);\n-        printCommitMethod(out, event, empty);\n+        if (!event.fields.isEmpty()) {\n+            printConstructor2(out, event, empty);\n+            printCommitMethod(out, event, empty);\n+        }\n","filename":"make\/src\/classes\/build\/tools\/jfr\/GenerateJfrFiles.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-      exelauncher.c libFDLeaker.c exeFDLeakTester.c\n+      exelauncher.c libFDLeaker.c exeFDLeakTester.c \\\n+      libChangeSignalDisposition.c exePrintSignalDisposition.c\n@@ -140,0 +141,1 @@\n+      LIBS := $(LIBPTHREAD), \\\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4415,1 +4415,1 @@\n-operand immI8_shift8()\n+operand immIDupV()\n@@ -4417,2 +4417,1 @@\n-  predicate((n->get_int() <= 127 && n->get_int() >= -128) ||\n-            (n->get_int() <= 32512 && n->get_int() >= -32768 && (n->get_int() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->get_int()));\n@@ -4427,1 +4426,1 @@\n-operand immL8_shift8()\n+operand immLDupV()\n@@ -4429,2 +4428,1 @@\n-  predicate((n->get_long() <= 127 && n->get_long() >= -128) ||\n-            (n->get_long() <= 32512 && n->get_long() >= -32768 && (n->get_long() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate(n->get_long()));\n@@ -4438,0 +4436,11 @@\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immHDupV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->geth()));\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -7080,3 +7089,0 @@\n-\/\/ The \"ldr\" instruction loads a 32-bit word from the constant pool into a\n-\/\/ 32-bit register but only the bottom half will be populated and the top\n-\/\/ 16 bits are zero.\n@@ -7085,3 +7091,3 @@\n-  format %{\n-    \"ldrs $dst, [$constantaddress]\\t# load from constant table: half float=$con\\n\\t\"\n-  %}\n+  format %{ \"mov    rscratch1, $con\\n\\t\"\n+            \"fmov   $dst, rscratch1\"\n+         %}\n@@ -7089,1 +7095,2 @@\n-    __ ldrs(as_FloatRegister($dst$$reg), $constantaddress($con));\n+    __ movw(rscratch1, (uint32_t)$con$$constant);\n+    __ fmovs($dst$$FloatRegister, rscratch1);\n@@ -7091,1 +7098,1 @@\n-  ins_pipe(fp_load_constant_s);\n+  ins_pipe(pipe_class_default);\n@@ -16284,32 +16291,0 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n-%{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastLock object box));\n-  effect(TEMP tmp, TEMP tmp2, TEMP tmp3);\n-\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"fastlock $object,$box\\t! kills $tmp,$tmp2,$tmp3\" %}\n-\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-instruct cmpFastUnlock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n-%{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastUnlock object box));\n-  effect(TEMP tmp, TEMP tmp2);\n-\n-  ins_cost(5 * INSN_COST);\n-  format %{ \"fastunlock $object,$box\\t! kills $tmp, $tmp2\" %}\n-\n-  ins_encode %{\n-    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n@@ -16318,1 +16293,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -16334,1 +16308,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":21,"deletions":48,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -4878,1 +4878,1 @@\n-instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+instruct replicateI_imm8_gt128b(vReg dst, immIDupV con) %{\n@@ -4901,1 +4901,1 @@\n-instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+instruct replicateL_imm8_gt128b(vReg dst, immLDupV con) %{\n@@ -4912,2 +4912,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -4915,1 +4916,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -4917,1 +4918,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -4919,6 +4919,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ for the operand - immHDupV\n+instruct replicateHF_imm8_gt128b(vReg dst, immHDupV con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3110,1 +3110,1 @@\n-instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+instruct replicateI_imm8_gt128b(vReg dst, immIDupV con) %{\n@@ -3133,1 +3133,1 @@\n-instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+instruct replicateL_imm8_gt128b(vReg dst, immLDupV con) %{\n@@ -3144,2 +3144,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -3147,1 +3148,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -3149,1 +3150,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -3151,6 +3151,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ for the operand - immHDupV\n+instruct replicateHF_imm8_gt128b(vReg dst, immHDupV con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -437,0 +437,5 @@\n+bool Assembler::operand_valid_for_sve_dup_immediate(int64_t imm) {\n+  return ((imm >= -128 && imm <= 127) ||\n+          (((imm & 0xff) == 0) && imm >= -32768 && imm <= 32512));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4327,0 +4327,1 @@\n+  static bool operand_valid_for_sve_dup_immediate(int64_t imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -413,5 +413,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(*stub->entry());\n-    } else {\n-      __ unlock_object(r5, r4, r0, r6, *stub->entry());\n-    }\n+    __ unlock_object(r5, r4, r0, r6, *stub->entry());\n@@ -2487,7 +2483,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj, -1);\n-    }\n-    __ b(*op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n@@ -2826,1 +2816,1 @@\n-  __ lea(dest->as_register_lo(), as_Address(addr->as_address_ptr()));\n+  __ lea(dest->as_pointer_register(), as_Address(addr->as_address_ptr()));\n@@ -3136,1 +3126,3 @@\n-  __ membar(__ AnyAny);\n+  if(!UseLSE) {\n+    __ membar(__ AnyAny);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -984,1 +984,1 @@\n-      LIR_Opr addr = new_pointer_register();\n+      LIR_Opr addr = new_register(T_ADDRESS);\n@@ -1061,1 +1061,1 @@\n-      LIR_Opr addr = new_pointer_register();\n+      LIR_Opr addr = new_register(T_ADDRESS);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-  const int aligned_mask = BytesPerWord -1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -75,49 +73,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(hdr, obj);\n-      ldrb(hdr, Address(hdr, Klass::misc_flags_offset()));\n-      tst(hdr, KlassFlags::_misc_is_value_based_class);\n-      br(Assembler::NE, slow_case);\n-    }\n-\n-    Label done;\n-    \/\/ Load object header\n-    ldr(hdr, Address(obj, hdr_offset));\n-    \/\/ and mark it as unlocked\n-    orr(hdr, hdr, markWord::unlocked_value);\n-    \/\/ save unlocked object header into the displaced header location on the stack\n-    str(hdr, Address(disp_hdr, 0));\n-    \/\/ test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header - if it is not the same, get the\n-    \/\/ object header instead\n-    lea(rscratch2, Address(obj, hdr_offset));\n-    cmpxchgptr(hdr, disp_hdr, rscratch2, rscratch1, done, \/*fallthough*\/nullptr);\n-    \/\/ if the object header was the same, we're done\n-    \/\/ if the object header was not the same, it is now in the hdr register\n-    \/\/ => test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (hdr & aligned_mask) == 0\n-    \/\/ 2) sp <= hdr\n-    \/\/ 3) hdr <= sp + page_size\n-    \/\/\n-    \/\/ these 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (hdr - sp) & (aligned_mask - page_size)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    mov(rscratch1, sp);\n-    sub(hdr, hdr, rscratch1);\n-    ands(hdr, hdr, aligned_mask - (int)os::vm_page_size());\n-    \/\/ for recursive locking, the result is zero => save it in the displaced header\n-    \/\/ location (null in the displaced hdr location indicates recursive locking)\n-    str(hdr, Address(disp_hdr, 0));\n-    \/\/ otherwise we don't care about the result and handle locking via runtime call\n-    cbnz(hdr, slow_case);\n-    \/\/ done\n-    bind(done);\n-    inc_held_monitor_count(rscratch1);\n-  }\n+  lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n+\n@@ -129,2 +80,0 @@\n-  const int aligned_mask = BytesPerWord -1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -132,9 +81,0 @@\n-  Label done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ load displaced header\n-    ldr(hdr, Address(disp_hdr, 0));\n-    \/\/ if the loaded hdr is null we had recursive locking\n-    \/\/ if we had recursive locking, we are done\n-    cbz(hdr, done);\n-  }\n@@ -146,18 +86,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object - if the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead\n-    \/\/ if the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call\n-    if (hdr_offset) {\n-      lea(rscratch1, Address(obj, hdr_offset));\n-      cmpxchgptr(disp_hdr, hdr, rscratch1, rscratch2, done, &slow_case);\n-    } else {\n-      cmpxchgptr(disp_hdr, hdr, obj, rscratch2, done, &slow_case);\n-    }\n-    \/\/ done\n-    bind(done);\n-    dec_held_monitor_count(rscratch1);\n-  }\n+  lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":3,"deletions":80,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -150,206 +150,0 @@\n-void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmpReg,\n-                                  Register tmp2Reg, Register tmp3Reg) {\n-  Register oop = objectReg;\n-  Register box = boxReg;\n-  Register disp_hdr = tmpReg;\n-  Register tmp = tmp2Reg;\n-  Label cont;\n-  Label object_has_monitor;\n-  Label count, no_count;\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_lock_lightweight\");\n-  assert_different_registers(oop, box, tmp, disp_hdr, rscratch2);\n-\n-  \/\/ Load markWord from object into displaced_header.\n-  ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(tmp, oop);\n-    ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n-    tst(tmp, KlassFlags::_misc_is_value_based_class);\n-    br(Assembler::NE, cont);\n-  }\n-\n-  \/\/ Check for existing monitor\n-  tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-    b(cont);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-    orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ Compare object markWord with an unlocked value (tmp) and if\n-    \/\/ equal exchange the stack address of our box with object markWord.\n-    \/\/ On failure disp_hdr contains the possibly locked markWord.\n-    cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-            \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-    br(Assembler::EQ, cont);\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object, will have now locked it will continue at label cont\n-\n-    \/\/ Check if the owner is self by comparing the value in the\n-    \/\/ markWord of object (disp_hdr) with the stack pointer.\n-    mov(rscratch1, sp);\n-    sub(disp_hdr, disp_hdr, rscratch1);\n-    mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-    \/\/ If condition is true we are cont and hence we can store 0 as the\n-    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-    ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-    str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    b(cont);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  ldr(rscratch2, Address(rthread, JavaThread::monitor_owner_id_offset()));\n-  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n-  cmpxchg(tmp, zr, rscratch2, Assembler::xword, \/*acquire*\/ true,\n-          \/*release*\/ true, \/*weak*\/ false, tmp3Reg); \/\/ Sets flags for result\n-\n-  \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-  \/\/ lock. The fast-path monitor unlock code checks for\n-  \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-  \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n-  mov(tmp, (address)markWord::unused_mark().value());\n-  str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-  br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n-\n-  cmp(tmp3Reg, rscratch2);\n-  br(Assembler::NE, cont); \/\/ Check for recursive locking\n-\n-  \/\/ Recursive lock case\n-  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n-  \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n-\n-  bind(cont);\n-  \/\/ flag == EQ indicates success\n-  \/\/ flag == NE indicates failure\n-  br(Assembler::NE, no_count);\n-\n-  bind(count);\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(rscratch1);\n-  }\n-\n-  bind(no_count);\n-}\n-\n-void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmpReg,\n-                                    Register tmp2Reg) {\n-  Register oop = objectReg;\n-  Register box = boxReg;\n-  Register disp_hdr = tmpReg;\n-  Register owner_addr = tmpReg;\n-  Register tmp = tmp2Reg;\n-  Label cont;\n-  Label object_has_monitor;\n-  Label count, no_count;\n-  Label unlocked;\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    cmp(disp_hdr, zr);\n-    br(Assembler::EQ, cont);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-  tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-    b(cont);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a light weight lock, this is is true if we\n-    \/\/ see the stack address of the basicLock in the markWord of the\n-    \/\/ object.\n-\n-    cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-            \/*release*\/ true, \/*weak*\/ false, tmp);\n-    b(cont);\n-  }\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-  ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-  Label notRecursive;\n-  cbz(disp_hdr, notRecursive);\n-\n-  \/\/ Recursive lock\n-  sub(disp_hdr, disp_hdr, 1u);\n-  str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-  cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n-  b(cont);\n-\n-  bind(notRecursive);\n-\n-  \/\/ Compute owner address.\n-  lea(owner_addr, Address(tmp, ObjectMonitor::owner_offset()));\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  stlr(zr, owner_addr);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  \/\/ StoreLoad achieves this.\n-  membar(StoreLoad);\n-\n-  \/\/ Check if the entry_list is empty.\n-  ldr(rscratch1, Address(tmp, ObjectMonitor::entry_list_offset()));\n-  cmp(rscratch1, zr);\n-  br(Assembler::EQ, cont);     \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  ldr(rscratch1, Address(tmp, ObjectMonitor::succ_offset()));\n-  cmp(rscratch1, zr);\n-  br(Assembler::NE, unlocked); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  str(tmp, Address(rthread, JavaThread::unlocked_inflated_monitor_offset()));\n-\n-  cmp(zr, rthread); \/\/ Set Flag to NE => slow path\n-  b(cont);\n-\n-  bind(unlocked);\n-  cmp(zr, zr); \/\/ Set Flag to EQ => fast path\n-\n-  \/\/ Intentional fall-through\n-\n-  bind(cont);\n-  \/\/ flag == EQ indicates success\n-  \/\/ flag == NE indicates failure\n-  br(Assembler::NE, no_count);\n-\n-  bind(count);\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(rscratch1);\n-  }\n-\n-  bind(no_count);\n-}\n-\n@@ -358,1 +152,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -515,1 +308,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":0,"deletions":208,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -54,3 +54,0 @@\n-  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n-  void fast_lock(Register object, Register box, Register tmp, Register tmp2, Register tmp3);\n-  void fast_unlock(Register object, Register box, Register tmp, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,3 +104,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : (intptr_t*)badAddressVal;\n@@ -195,0 +198,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t* fp_addr = sp - frame::sender_sp_offset;\n+  *fp_addr = badAddressVal;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -705,1 +705,1 @@\n-    snprintf(buf, sizeof buf, \"(bad)\");\n+    os::snprintf_checked(buf, sizeof buf, \"(bad)\");\n@@ -708,1 +708,1 @@\n-    snprintf(buf, sizeof buf, \"%d\", bci);\n+    os::snprintf_checked(buf, sizeof buf, \"%d\", bci);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -177,1 +177,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -756,1 +756,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -694,34 +694,0 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n-  } else {\n-    Label count, done;\n-\n-    const Register swap_reg = r0;\n-    const Register tmp = c_rarg2;\n-    const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n-    const Register tmp2 = c_rarg4;\n-    const Register tmp3 = c_rarg5;\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset +\n-                            BasicLock::displaced_header_offset_in_bytes();\n-\n-    Label slow_case;\n-\n-    \/\/ Load object pointer into obj_reg %c_rarg3\n-    ldr(obj_reg, Address(lock_reg, obj_offset));\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp, obj_reg);\n-        ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n-        tst(tmp, KlassFlags::_misc_is_value_based_class);\n-        br(Assembler::NE, slow_case);\n-      }\n@@ -729,55 +695,4 @@\n-      \/\/ Load (object->mark() | 1) into swap_reg\n-      ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      orr(swap_reg, rscratch1, 1);\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      str(swap_reg, Address(lock_reg, mark_offset));\n-\n-      assert(lock_offset == 0,\n-             \"displached header must be first word in BasicObjectLock\");\n-\n-      Label fail;\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n-\n-      \/\/ Fast check for recursive lock.\n-      \/\/\n-      \/\/ Can apply the optimization only if this is a stack lock\n-      \/\/ allocated in this thread. For efficiency, we can focus on\n-      \/\/ recently allocated stack locks (instead of reading the stack\n-      \/\/ base and checking whether 'mark' points inside the current\n-      \/\/ thread stack):\n-      \/\/  1) (mark & 7) == 0, and\n-      \/\/  2) sp <= mark < mark + os::pagesize()\n-      \/\/\n-      \/\/ Warning: sp + os::pagesize can overflow the stack base. We must\n-      \/\/ neither apply the optimization for an inflated lock allocated\n-      \/\/ just above the thread stack (this is why condition 1 matters)\n-      \/\/ nor apply the optimization if the stack lock is inside the stack\n-      \/\/ of another thread. The latter is avoided even in case of overflow\n-      \/\/ because we have guard pages at the end of all stacks. Hence, if\n-      \/\/ we go over the stack base and hit the stack of another thread,\n-      \/\/ this should not be in a writeable area that could contain a\n-      \/\/ stack lock allocated by that thread. As a consequence, a stack\n-      \/\/ lock less than page size away from sp is guaranteed to be\n-      \/\/ owned by the current thread.\n-      \/\/\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - sp) & (7 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 3 bits clear.\n-      \/\/ NOTE: the mark is in swap_reg %r0 as the result of cmpxchg\n-      \/\/ NOTE2: aarch64 does not like to subtract sp from rn so take a\n-      \/\/ copy\n-      mov(rscratch1, sp);\n-      sub(swap_reg, swap_reg, rscratch1);\n-      ands(swap_reg, swap_reg, (uint64_t)(7 - (int)os::vm_page_size()));\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      str(swap_reg, Address(lock_reg, mark_offset));\n-      br(Assembler::NE, slow_case);\n-\n-      bind(count);\n-      inc_held_monitor_count(rscratch1);\n-      b(done);\n-    }\n-    bind(slow_case);\n+  const Register tmp = c_rarg2;\n+  const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n+  const Register tmp2 = c_rarg4;\n+  const Register tmp3 = c_rarg5;\n@@ -785,4 +700,2 @@\n-    \/\/ Call the runtime routine for slow case\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n+  \/\/ Load object pointer into obj_reg %c_rarg3\n+  ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -790,2 +703,12 @@\n-    bind(done);\n-  }\n+  Label slow_case, done;\n+  lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n+  b(done);\n+\n+  bind(slow_case);\n+\n+  \/\/ Call the runtime routine for slow case\n+  call_VM_preemptable(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          lock_reg);\n+\n+  bind(done);\n@@ -810,20 +733,4 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n-  } else {\n-    Label count, done;\n-\n-    const Register swap_reg   = r0;\n-    const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n-    const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n-    const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n-\n-    save_bcp(); \/\/ Save in case of exception\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Convert from BasicObjectLock structure to object and BasicLock\n-      \/\/ structure Store the BasicLock address into %r0\n-      lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset()));\n-    }\n-\n-    \/\/ Load oop into obj_reg(%c_rarg3)\n-    ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n+  const Register swap_reg   = r0;\n+  const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n+  const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n+  const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n@@ -831,2 +738,1 @@\n-    \/\/ Free entry\n-    str(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n+  save_bcp(); \/\/ Save in case of exception\n@@ -834,8 +740,2 @@\n-    Label slow_case;\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load the old header from BasicLock structure\n-      ldr(header_reg, Address(swap_reg,\n-                              BasicLock::displaced_header_offset_in_bytes()));\n+  \/\/ Load oop into obj_reg(%c_rarg3)\n+  ldr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -843,2 +743,2 @@\n-      \/\/ Test for recursion\n-      cbz(header_reg, count);\n+  \/\/ Free entry\n+  str(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -846,7 +746,3 @@\n-      \/\/ Atomic swap back the old header\n-      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, rscratch1, count, &slow_case);\n-\n-      bind(count);\n-      dec_held_monitor_count(rscratch1);\n-      b(done);\n-    }\n+  Label slow_case, done;\n+  lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n+  b(done);\n@@ -854,7 +750,6 @@\n-    bind(slow_case);\n-    \/\/ Call the runtime routine for slow case.\n-    str(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n-    bind(done);\n-    restore_bcp();\n-  }\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case.\n+  str(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n+  bind(done);\n+  restore_bcp();\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":36,"deletions":141,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2262,1 +2262,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n@@ -2320,1 +2320,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n@@ -2433,1 +2433,1 @@\n-      snprintf(buffer, sizeof(buffer), \"0x%\" PRIX32, imm32);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX32, imm32);\n@@ -2905,1 +2905,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n@@ -2907,1 +2907,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n@@ -2909,1 +2909,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n@@ -3017,1 +3017,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n@@ -3019,1 +3019,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n@@ -3021,1 +3021,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n@@ -5923,1 +5923,1 @@\n-    snprintf(comment, sizeof comment, \"array_equals%c{\", kind);\n+    os::snprintf_checked(comment, sizeof comment, \"array_equals%c{\", kind);\n@@ -6121,1 +6121,1 @@\n-    snprintf(comment, sizeof comment, \"{string_equalsL\");\n+    os::snprintf_checked(comment, sizeof comment, \"{string_equalsL\");\n@@ -6269,1 +6269,1 @@\n-      snprintf(buf, sizeof buf, \"zero_words (count = %\" PRIu64 \") {\", cnt);\n+      os::snprintf_checked(buf, sizeof buf, \"zero_words (count = %\" PRIu64 \") {\", cnt);\n@@ -6424,4 +6424,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n@@ -7100,1 +7104,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -7160,1 +7163,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1724,1 +1724,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -1779,38 +1779,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(slow_path_lock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load (object->mark() | 1) into swap_reg %r0\n-      __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ orr(swap_reg, rscratch1, 1);\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      __ str(swap_reg, Address(lock_reg, mark_word_offset));\n-\n-      \/\/ src -> dest iff dest == r0 else r0 <- dest\n-      __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, count, \/*fallthrough*\/nullptr);\n-\n-      \/\/ Hmm should this move to the slow path code area???\n-\n-      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-      \/\/  1) (mark & 3) == 0, and\n-      \/\/  2) sp <= mark < mark + os::pagesize()\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 2 bits clear.\n-      \/\/ NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg\n-\n-      __ sub(swap_reg, sp, swap_reg);\n-      __ neg(swap_reg, swap_reg);\n-      __ ands(swap_reg, swap_reg, 3 - (int)os::vm_page_size());\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      __ str(swap_reg, Address(lock_reg, mark_word_offset));\n-      __ br(Assembler::NE, slow_path_lock);\n-\n-      __ bind(count);\n-      __ inc_held_monitor_count(rscratch1);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n-    }\n+    __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -1891,1 +1854,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -1920,12 +1883,0 @@\n-    Label done, not_recursive;\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Simple recursive lock?\n-      __ ldr(rscratch1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      __ cbnz(rscratch1, not_recursive);\n-      __ dec_held_monitor_count(rscratch1);\n-      __ b(done);\n-    }\n-\n-    __ bind(not_recursive);\n-\n@@ -1937,17 +1888,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(slow_path_unlock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ get address of the stack lock\n-      __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      \/\/  get old displaced header\n-      __ ldr(old_hdr, Address(r0, 0));\n-\n-      \/\/ Atomic swap old header if oop still contains the stack lock\n-      Label count;\n-      __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, count, &slow_path_unlock);\n-      __ bind(count);\n-      __ dec_held_monitor_count(rscratch1);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n-      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n-    }\n+    __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n@@ -1960,2 +1895,0 @@\n-\n-    __ bind(done);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":4,"deletions":71,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1481,16 +1481,11 @@\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Check preemption for Object.wait()\n-    Label not_preempted;\n-    __ ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n-    __ cbz(rscratch1, not_preempted);\n-    __ str(zr, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n-    __ br(rscratch1);\n-    __ bind(native_return);\n-    __ restore_after_resume(true \/* is_native *\/);\n-    \/\/ reload result_handler\n-    __ ldr(result_handler, Address(rfp, frame::interpreter_frame_result_handler_offset*wordSize));\n-    __ bind(not_preempted);\n-  } else {\n-    \/\/ any pc will do so just use this one for LM_LEGACY to keep code together.\n-    __ bind(native_return);\n-  }\n+  \/\/ Check preemption for Object.wait()\n+  Label not_preempted;\n+  __ ldr(rscratch1, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+  __ cbz(rscratch1, not_preempted);\n+  __ str(zr, Address(rthread, JavaThread::preempt_alternate_return_offset()));\n+  __ br(rscratch1);\n+  __ bind(native_return);\n+  __ restore_after_resume(true \/* is_native *\/);\n+  \/\/ reload result_handler\n+  __ ldr(result_handler, Address(rfp, frame::interpreter_frame_result_handler_offset*wordSize));\n+  __ bind(not_preempted);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -724,1 +724,1 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n@@ -726,1 +726,1 @@\n-  int desc_len = snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n+  int desc_len = os::snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n@@ -729,1 +729,1 @@\n-  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _cpu_info_string);\n+  os::snprintf_checked(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2429,7 +2429,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ b(*op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -180,1 +180,0 @@\n-  Label done, fast_lock, fast_lock_done;\n@@ -187,2 +186,1 @@\n-  const ByteSize obj_offset = BasicObjectLock::obj_offset();\n-  const int mark_offset = BasicLock::displaced_header_offset_in_bytes();\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"Required by atomic instructions\");\n@@ -191,1 +189,1 @@\n-  str(obj, Address(disp_hdr, obj_offset));\n+  str(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n@@ -202,47 +200,3 @@\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"Required by atomic instructions\");\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    Register t1 = disp_hdr; \/\/ Needs saving, probably\n-    Register t2 = hdr;      \/\/ blow\n-    Register t3 = Rtemp;    \/\/ blow\n-\n-    lightweight_lock(obj \/* obj *\/, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n-    \/\/ Success: fall through\n-\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    \/\/ On MP platforms the next load could return a 'stale' value if the memory location has been modified by another thread.\n-    \/\/ That would be acceptable as ether CAS or slow case path is taken in that case.\n-\n-    \/\/ Must be the first instruction here, because implicit null check relies on it\n-    ldr(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n-\n-    tst(hdr, markWord::unlocked_value);\n-    b(fast_lock, ne);\n-\n-    \/\/ Check for recursive locking\n-    \/\/ See comments in InterpreterMacroAssembler::lock_object for\n-    \/\/ explanations on the fast recursive locking check.\n-    \/\/ -1- test low 2 bits\n-    movs(tmp2, AsmOperand(hdr, lsl, 30));\n-    \/\/ -2- test (hdr - SP) if the low two bits are 0\n-    sub(tmp2, hdr, SP, eq);\n-    movs(tmp2, AsmOperand(tmp2, lsr, exact_log2(os::vm_page_size())), eq);\n-    \/\/ If still 'eq' then recursive locking OK\n-    \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8267042)\n-    str(tmp2, Address(disp_hdr, mark_offset));\n-    b(fast_lock_done, eq);\n-    \/\/ else need slow case\n-    b(slow_case);\n-\n-\n-    bind(fast_lock);\n-    \/\/ Save previous object header in BasicLock structure and update the header\n-    str(hdr, Address(disp_hdr, mark_offset));\n-\n-    cas_for_lock_acquire(hdr, disp_hdr, obj, tmp2, slow_case);\n-\n-    bind(fast_lock_done);\n-  }\n-  bind(done);\n+  Register t1 = disp_hdr; \/\/ Needs saving, probably\n+  Register t2 = hdr;      \/\/ blow\n+  Register t3 = Rtemp;    \/\/ blow\n@@ -250,0 +204,2 @@\n+  lightweight_lock(obj, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n+  \/\/ Success: fall through\n@@ -255,1 +211,0 @@\n-  Register tmp2 = Rtemp;\n@@ -258,5 +213,0 @@\n-  const ByteSize obj_offset = BasicObjectLock::obj_offset();\n-  const int mark_offset = BasicLock::displaced_header_offset_in_bytes();\n-\n-  Label done;\n-\n@@ -265,1 +215,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n+  ldr(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n@@ -267,1 +217,3 @@\n-    ldr(obj, Address(disp_hdr, obj_offset));\n+  Register t1 = disp_hdr; \/\/ Needs saving, probably\n+  Register t2 = hdr;      \/\/ blow\n+  Register t3 = Rtemp;    \/\/ blow\n@@ -269,22 +221,2 @@\n-    Register t1 = disp_hdr; \/\/ Needs saving, probably\n-    Register t2 = hdr;      \/\/ blow\n-    Register t3 = Rtemp;    \/\/ blow\n-\n-    lightweight_unlock(obj \/* object *\/, t1, t2, t3, 1 \/* savemask (save t1) *\/,\n-                       slow_case);\n-    \/\/ Success: Fall through\n-\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    \/\/ Load displaced header and object from the lock\n-    ldr(hdr, Address(disp_hdr, mark_offset));\n-    \/\/ If hdr is null, we've got recursive locking and there's nothing more to do\n-    cbz(hdr, done);\n-\n-    \/\/ load object\n-    ldr(obj, Address(disp_hdr, obj_offset));\n-\n-    \/\/ Restore the object header\n-    cas_for_lock_release(disp_hdr, hdr, obj, tmp2, slow_case);\n-  }\n-  bind(done);\n+  lightweight_unlock(obj, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n+  \/\/ Success: fall through\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":13,"deletions":81,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  Label fast_lock, done;\n+  Label done;\n@@ -93,36 +93,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    lightweight_lock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n-                     1 \/* savemask (save t1) *\/, done);\n-\n-    \/\/ Success: set Z\n-    cmp(Roop, Roop);\n-\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    Register Rmark      = Rscratch2;\n-\n-    ldr(Rmark, Address(Roop, oopDesc::mark_offset_in_bytes()));\n-    tst(Rmark, markWord::unlocked_value);\n-    b(fast_lock, ne);\n-\n-    \/\/ Check for recursive lock\n-    \/\/ See comments in InterpreterMacroAssembler::lock_object for\n-    \/\/ explanations on the fast recursive locking check.\n-    \/\/ -1- test low 2 bits\n-    movs(Rscratch, AsmOperand(Rmark, lsl, 30));\n-    \/\/ -2- test (hdr - SP) if the low two bits are 0\n-    sub(Rscratch, Rmark, SP, eq);\n-    movs(Rscratch, AsmOperand(Rscratch, lsr, exact_log2(os::vm_page_size())), eq);\n-    \/\/ If still 'eq' then recursive locking OK\n-    \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8153107)\n-    str(Rscratch, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    b(done);\n-\n-    bind(fast_lock);\n-    str(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    bool allow_fallthrough_on_failure = true;\n-    bool one_shot = true;\n-    cas_for_lock_acquire(Rmark, Rbox, Roop, Rscratch, done, allow_fallthrough_on_failure, one_shot);\n-  }\n+  lightweight_lock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n+                   1 \/* savemask (save t1) *\/, done);\n@@ -130,0 +96,1 @@\n+  cmp(Roop, Roop); \/\/ Success: set Z\n@@ -143,11 +110,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    lightweight_unlock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n-                       1 \/* savemask (save t1) *\/, done);\n-\n-    cmp(Roop, Roop); \/\/ Success: Set Z\n-    \/\/ Fall through\n-\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    Register Rmark      = Rscratch2;\n+  lightweight_unlock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n+                     1 \/* savemask (save t1) *\/, done);\n@@ -155,5 +113,2 @@\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ldr(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ If hdr is null, we've got recursive locking and there's nothing more to do\n-    cmp(Rmark, 0);\n-    b(done, eq);\n+  cmp(Roop, Roop); \/\/ Success: Set Z\n+  \/\/ Fall through\n@@ -161,5 +116,0 @@\n-    \/\/ Restore the object header\n-    bool allow_fallthrough_on_failure = true;\n-    bool one_shot = true;\n-    cas_for_lock_release(Rbox, Rmark, Roop, Rscratch, done, allow_fallthrough_on_failure, one_shot);\n-  }\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":8,"deletions":58,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -891,12 +891,3 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n-  } else {\n-    Label done;\n-\n-    const Register Robj = R2;\n-    const Register Rmark = R3;\n-    assert_different_registers(Robj, Rmark, Rlock, R0, Rtemp);\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n+  const Register Robj = R2;\n+  const Register Rmark = R3;\n+  assert_different_registers(Robj, Rmark, Rlock, R0, Rtemp);\n@@ -904,1 +895,1 @@\n-    Label already_locked, slow_case;\n+  Label done, slow_case;\n@@ -906,2 +897,2 @@\n-    \/\/ Load object pointer\n-    ldr(Robj, Address(Rlock, obj_offset));\n+  \/\/ Load object pointer\n+  ldr(Robj, Address(Rlock, BasicObjectLock::obj_offset()));\n@@ -909,6 +900,6 @@\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(R0, Robj);\n-      ldrb(R0, Address(R0, Klass::misc_flags_offset()));\n-      tst(R0, KlassFlags::_misc_is_value_based_class);\n-      b(slow_case, ne);\n-    }\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(R0, Robj);\n+    ldrb(R0, Address(R0, Klass::misc_flags_offset()));\n+    tst(R0, KlassFlags::_misc_is_value_based_class);\n+    b(slow_case, ne);\n+  }\n@@ -916,67 +907,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(Robj, R0 \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/, 0 \/* savemask *\/, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ On MP platforms the next load could return a 'stale' value if the memory location has been modified by another thread.\n-      \/\/ That would be acceptable as ether CAS or slow case path is taken in that case.\n-      \/\/ Exception to that is if the object is locked by the calling thread, then the recursive test will pass (guaranteed as\n-      \/\/ loads are satisfied from a store queue if performed on the same processor).\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"must be\");\n-      ldr(Rmark, Address(Robj, oopDesc::mark_offset_in_bytes()));\n-\n-      \/\/ Test if object is already locked\n-      tst(Rmark, markWord::unlocked_value);\n-      b(already_locked, eq);\n-\n-      \/\/ Save old object->mark() into BasicLock's displaced header\n-      str(Rmark, Address(Rlock, mark_offset));\n-\n-      cas_for_lock_acquire(Rmark, Rlock, Robj, Rtemp, slow_case);\n-\n-      b(done);\n-\n-      \/\/ If we got here that means the object is locked by ether calling thread or another thread.\n-      bind(already_locked);\n-      \/\/ Handling of locked objects: recursive locks and slow case.\n-\n-      \/\/ Fast check for recursive lock.\n-      \/\/\n-      \/\/ Can apply the optimization only if this is a stack lock\n-      \/\/ allocated in this thread. For efficiency, we can focus on\n-      \/\/ recently allocated stack locks (instead of reading the stack\n-      \/\/ base and checking whether 'mark' points inside the current\n-      \/\/ thread stack):\n-      \/\/  1) (mark & 3) == 0\n-      \/\/  2) SP <= mark < SP + os::pagesize()\n-      \/\/\n-      \/\/ Warning: SP + os::pagesize can overflow the stack base. We must\n-      \/\/ neither apply the optimization for an inflated lock allocated\n-      \/\/ just above the thread stack (this is why condition 1 matters)\n-      \/\/ nor apply the optimization if the stack lock is inside the stack\n-      \/\/ of another thread. The latter is avoided even in case of overflow\n-      \/\/ because we have guard pages at the end of all stacks. Hence, if\n-      \/\/ we go over the stack base and hit the stack of another thread,\n-      \/\/ this should not be in a writeable area that could contain a\n-      \/\/ stack lock allocated by that thread. As a consequence, a stack\n-      \/\/ lock less than page size away from SP is guaranteed to be\n-      \/\/ owned by the current thread.\n-      \/\/\n-      \/\/ Note: assuming SP is aligned, we can check the low bits of\n-      \/\/ (mark-SP) instead of the low bits of mark. In that case,\n-      \/\/ assuming page size is a power of 2, we can merge the two\n-      \/\/ conditions into a single test:\n-      \/\/ => ((mark - SP) & (3 - os::pagesize())) == 0\n-\n-      \/\/ (3 - os::pagesize()) cannot be encoded as an ARM immediate operand.\n-      \/\/ Check independently the low bits and the distance to SP.\n-      \/\/ -1- test low 2 bits\n-      movs(R0, AsmOperand(Rmark, lsl, 30));\n-      \/\/ -2- test (mark - SP) if the low two bits are 0\n-      sub(R0, Rmark, SP, eq);\n-      movs(R0, AsmOperand(R0, lsr, exact_log2(os::vm_page_size())), eq);\n-      \/\/ If still 'eq' then recursive locking OK: store 0 into lock record\n-      str(R0, Address(Rlock, mark_offset), eq);\n-\n-      b(done, eq);\n-    }\n+  lightweight_lock(Robj, R0 \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/, 0 \/* savemask *\/, slow_case);\n+  b(done);\n@@ -984,1 +910,1 @@\n-    bind(slow_case);\n+  bind(slow_case);\n@@ -986,4 +912,3 @@\n-    \/\/ Call the runtime routine for slow case\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n-    bind(done);\n-  }\n+  \/\/ Call the runtime routine for slow case\n+  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n+  bind(done);\n@@ -1000,12 +925,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), Rlock);\n-  } else {\n-    Label done, slow_case;\n-\n-    const Register Robj = R2;\n-    const Register Rmark = R3;\n-    assert_different_registers(Robj, Rmark, Rlock, Rtemp);\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n+  Label done, slow_case;\n@@ -1013,27 +927,3 @@\n-    const Register Rzero = zero_register(Rtemp);\n-\n-    \/\/ Load oop into Robj\n-    ldr(Robj, Address(Rlock, obj_offset));\n-\n-    \/\/ Free entry\n-    str(Rzero, Address(Rlock, obj_offset));\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-      \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n-      \/\/ must handle it.\n-      ldr(Rtemp, Address(Rthread, JavaThread::lock_stack_top_offset()));\n-      sub(Rtemp, Rtemp, oopSize);\n-      ldr(Rtemp, Address(Rthread, Rtemp));\n-      cmpoop(Rtemp, Robj);\n-      b(slow_case, ne);\n-\n-      lightweight_unlock(Robj \/* obj *\/, Rlock \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/,\n-                         1 \/* savemask (save t1) *\/, slow_case);\n-\n-      b(done);\n-\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      \/\/ Load the old header from BasicLock structure\n-      ldr(Rmark, Address(Rlock, mark_offset));\n+  const Register Robj = R2;\n+  const Register Rmark = R3;\n+  assert_different_registers(Robj, Rmark, Rlock, Rtemp);\n@@ -1041,2 +931,2 @@\n-      \/\/ Test for recursion (zero mark in BasicLock)\n-      cbz(Rmark, done);\n+  const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n+  const Register Rzero = zero_register(Rtemp);\n@@ -1044,1 +934,2 @@\n-      bool allow_fallthrough_on_failure = true;\n+  \/\/ Load oop into Robj\n+  ldr(Robj, Address(Rlock, obj_offset));\n@@ -1046,1 +937,2 @@\n-      cas_for_lock_release(Rlock, Rmark, Robj, Rtemp, slow_case, allow_fallthrough_on_failure);\n+  \/\/ Free entry\n+  str(Rzero, Address(Rlock, obj_offset));\n@@ -1048,1 +940,7 @@\n-      b(done, eq);\n+  \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n+  \/\/ must handle it.\n+  ldr(Rtemp, Address(Rthread, JavaThread::lock_stack_top_offset()));\n+  sub(Rtemp, Rtemp, oopSize);\n+  ldr(Rtemp, Address(Rthread, Rtemp));\n+  cmpoop(Rtemp, Robj);\n+  b(slow_case, ne);\n@@ -1050,2 +948,3 @@\n-    }\n-    bind(slow_case);\n+  lightweight_unlock(Robj \/* obj *\/, Rlock \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/,\n+                     1 \/* savemask (save t1) *\/, slow_case);\n+  b(done);\n@@ -1053,3 +952,4 @@\n-    \/\/ Call the runtime routine for slow case.\n-    str(Robj, Address(Rlock, obj_offset)); \/\/ restore obj\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), Rlock);\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case.\n+  str(Robj, Address(Rlock, obj_offset)); \/\/ restore obj\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), Rlock);\n@@ -1057,2 +957,1 @@\n-    bind(done);\n-  }\n+  bind(done);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":43,"deletions":144,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -842,1 +842,1 @@\n-    snprintf(buffer, sizeof(buffer), \"verify_oop at %d\", offset());\n+    os::snprintf_checked(buffer, sizeof(buffer), \"verify_oop at %d\", offset());\n@@ -1761,1 +1761,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -1819,1 +1818,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1142,4 +1142,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      log_trace(fastlock)(\"SharedRuntime lock fast\");\n-      __ lightweight_lock(sync_obj \/* object *\/, disp_hdr \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n-                          0x7 \/* savemask *\/, slow_lock);\n+    log_trace(fastlock)(\"SharedRuntime lock fast\");\n+    __ lightweight_lock(sync_obj \/* object *\/, disp_hdr \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+                        0x7 \/* savemask *\/, slow_lock);\n@@ -1147,30 +1146,0 @@\n-    } else if (LockingMode == LM_LEGACY) {\n-      const Register mark = tmp;\n-      \/\/ On MP platforms the next load could return a 'stale' value if the memory location has been modified by another thread.\n-      \/\/ That would be acceptable as either CAS or slow case path is taken in that case\n-\n-      __ ldr(mark, Address(sync_obj, oopDesc::mark_offset_in_bytes()));\n-      __ sub(disp_hdr, FP, lock_slot_fp_offset);\n-      __ tst(mark, markWord::unlocked_value);\n-      __ b(fast_lock, ne);\n-\n-      \/\/ Check for recursive lock\n-      \/\/ See comments in InterpreterMacroAssembler::lock_object for\n-      \/\/ explanations on the fast recursive locking check.\n-      \/\/ Check independently the low bits and the distance to SP\n-      \/\/ -1- test low 2 bits\n-      __ movs(Rtemp, AsmOperand(mark, lsl, 30));\n-      \/\/ -2- test (hdr - SP) if the low two bits are 0\n-      __ sub(Rtemp, mark, SP, eq);\n-      __ movs(Rtemp, AsmOperand(Rtemp, lsr, exact_log2(os::vm_page_size())), eq);\n-      \/\/ If still 'eq' then recursive locking OK\n-      \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8267042)\n-      __ str(Rtemp, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));\n-      __ b(lock_done, eq);\n-      __ b(slow_lock);\n-\n-      __ bind(fast_lock);\n-      __ str(mark, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      __ cas_for_lock_acquire(mark, disp_hdr, sync_obj, Rtemp, slow_lock);\n-    }\n@@ -1229,15 +1198,5 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      log_trace(fastlock)(\"SharedRuntime unlock fast\");\n-      __ lightweight_unlock(sync_obj, R2 \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n-                            7 \/* savemask *\/, slow_unlock);\n-      \/\/ Fall through\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ See C1_MacroAssembler::unlock_object() for more comments\n-      __ ldr(sync_obj, Address(sync_handle));\n-\n-      \/\/ See C1_MacroAssembler::unlock_object() for more comments\n-      __ ldr(R2, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));\n-      __ cbz(R2, unlock_done);\n-\n-      __ cas_for_lock_release(disp_hdr, R2, sync_obj, Rtemp, slow_unlock);\n-    }\n+    log_trace(fastlock)(\"SharedRuntime unlock fast\");\n+    __ lightweight_unlock(sync_obj, R2 \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+                          7 \/* savemask *\/, slow_unlock);\n+    \/\/ Fall through\n+\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -365,2 +365,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-\/\/   We're processing the *oldest* interpreter frame!\n+\/\/   We're processing the *youngest* interpreter frame on top of stack!\n@@ -134,2 +134,3 @@\n-    const int caller_abi_bytesize = (is_bottom_frame ? frame::top_ijava_frame_abi_size : frame::parent_ijava_frame_abi_size);\n-    intptr_t* l2 = caller->sp() + method->max_locals() - 1 + (caller_abi_bytesize \/ Interpreter::stackElementSize);\n+    \/\/ If the bottom frame's caller was thawed then it has frame::java_abi (aka parent_ijava_frame_abi).\n+    \/\/ With an ordinary i2c call it would keep the larger frame::top_ijava_frame_abi\n+    intptr_t* l2 = caller->sp() + method->max_locals() - 1 + (frame::parent_ijava_frame_abi_size \/ Interpreter::stackElementSize);\n","filename":"src\/hotspot\/cpu\/ppc\/abstractInterpreter_ppc.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -231,5 +231,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ b(*stub->entry());\n-    } else {\n-      __ unlock_object(R5, R6, R4, *stub->entry());\n-    }\n+    __ unlock_object(R5, R6, R4, *stub->entry());\n@@ -2621,19 +2617,6 @@\n-    if (LockingMode != LM_MONITOR) {\n-      assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n-      \/\/ Add debug info for NullPointerException only if one is possible.\n-      if (op->info() != nullptr) {\n-        if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n-          explicit_null_check(obj, op->info());\n-        } else {\n-          add_debug_info_for_null_check_here(op->info());\n-        }\n-      }\n-      __ lock_object(hdr, obj, lock, op->scratch_opr()->as_register(), *op->stub()->entry());\n-    } else {\n-      \/\/ always do slow locking\n-      \/\/ note: The slow locking code could be inlined here, however if we use\n-      \/\/       slow locking, speed doesn't matter anyway and this solution is\n-      \/\/       simpler and requires less duplicated code - additionally, the\n-      \/\/       slow locking code is the same in either case which simplifies\n-      \/\/       debugging.\n-      if (op->info() != nullptr) {\n+    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n+    \/\/ Add debug info for NullPointerException only if one is possible.\n+    if (op->info() != nullptr) {\n+      if (!os::zero_page_read_protected() || !ImplicitNullChecks) {\n+        explicit_null_check(obj, op->info());\n+      } else {\n@@ -2641,1 +2624,0 @@\n-        __ null_check(obj);\n@@ -2643,1 +2625,0 @@\n-      __ b(*op->stub()->entry());\n@@ -2645,0 +2626,1 @@\n+    __ lock_object(hdr, obj, lock, op->scratch_opr()->as_register(), *op->stub()->entry());\n@@ -2647,12 +2629,2 @@\n-    if (LockingMode != LM_MONITOR) {\n-      assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n-      __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n-    } else {\n-      \/\/ always do slow unlocking\n-      \/\/ note: The slow unlocking code could be inlined here, however if we use\n-      \/\/       slow unlocking, speed doesn't matter anyway and this solution is\n-      \/\/       simpler and requires less duplicated code - additionally, the\n-      \/\/       slow unlocking code is the same in either case which simplifies\n-      \/\/       debugging.\n-      __ b(*op->stub()->entry());\n-    }\n+    assert(BasicLock::displaced_header_offset_in_bytes() == 0, \"lock_reg must point to the displaced header\");\n+    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":10,"deletions":38,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -85,34 +85,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(Rscratch, Roop);\n-      lbz(Rscratch, in_bytes(Klass::misc_flags_offset()), Rscratch);\n-      testbitdi(CR0, R0, Rscratch, exact_log2(KlassFlags::_misc_is_value_based_class));\n-      bne(CR0, slow_int);\n-    }\n-\n-    \/\/ ... and mark it unlocked.\n-    ori(Rmark, Rmark, markWord::unlocked_value);\n-\n-    \/\/ Save unlocked object header into the displaced header location on the stack.\n-    std(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-\n-    \/\/ Compare object markWord with Rmark and if equal exchange Rscratch with object markWord.\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"cas must take a zero displacement\");\n-    cmpxchgd(\/*flag=*\/CR0,\n-             \/*current_value=*\/Rscratch,\n-             \/*compare_value=*\/Rmark,\n-             \/*exchange_value=*\/Rbox,\n-             \/*where=*\/Roop\/*+0==mark_offset_in_bytes*\/,\n-             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-             noreg,\n-             &cas_failed,\n-             \/*check without membar and ldarx first*\/true);\n-    \/\/ If compare\/exchange succeeded we found an unlocked object and we now have locked it\n-    \/\/ hence we are done.\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_lock(Rbox, Roop, Rmark, Rscratch, slow_int);\n@@ -124,10 +91,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    bind(cas_failed);\n-    \/\/ We did not find an unlocked object so see if this is a recursive case.\n-    sub(Rscratch, Rscratch, R1_SP);\n-    load_const_optimized(R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-    and_(R0\/*==0?*\/, Rscratch, R0);\n-    std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-    bne(CR0, slow_int);\n-  }\n-\n@@ -135,3 +92,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(Rmark \/*tmp*\/);\n-  }\n@@ -149,7 +103,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Test first if it is a fast recursive unlock.\n-    ld(Rmark, BasicLock::displaced_header_offset_in_bytes(), Rbox);\n-    cmpdi(CR0, Rmark, 0);\n-    beq(CR0, done);\n-  }\n-\n@@ -160,17 +107,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(Roop, Rmark, slow_int);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ Check if it is still a light weight lock, this is is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object.\n-    cmpxchgd(\/*flag=*\/CR0,\n-             \/*current_value=*\/R0,\n-             \/*compare_value=*\/Rbox,\n-             \/*exchange_value=*\/Rmark,\n-             \/*where=*\/Roop,\n-             MacroAssembler::MemBarRel,\n-             MacroAssembler::cmpxchgx_hint_release_lock(),\n-             noreg,\n-             &slow_int);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_unlock(Roop, Rmark, slow_int);\n@@ -183,3 +114,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(Rmark \/*tmp*\/);\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":74,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -337,0 +337,3 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, R16_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -969,1 +969,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), R0_pre_val, R16_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), R0_pre_val);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -949,39 +949,2 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-  } else {\n-    \/\/ template code (for LM_LEGACY):\n-    \/\/\n-    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-    \/\/   \/\/ We stored the monitor address into the object's mark word.\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-    \/\/ }\n-\n-    const Register header           = R7_ARG5;\n-    const Register object_mark_addr = R8_ARG6;\n-    const Register current_header   = R9_ARG7;\n-    const Register tmp              = R10_ARG8;\n-\n-    Label count_locking, done, slow_case, cas_failed;\n-\n-    assert_different_registers(header, object_mark_addr, current_header, tmp);\n-\n-    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(monitor, object, header, tmp, slow_case);\n-      b(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp, object);\n-        lbz(tmp, in_bytes(Klass::misc_flags_offset()), tmp);\n-        testbitdi(CR0, R0, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-        bne(CR0, slow_case);\n-      }\n+  const Register header           = R7_ARG5;\n+  const Register tmp              = R8_ARG6;\n@@ -989,56 +952,1 @@\n-      \/\/ Load markWord from object into header.\n-      ld(header, oopDesc::mark_offset_in_bytes(), object);\n-\n-      \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-      ori(header, header, markWord::unlocked_value);\n-\n-      \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-      const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-      const int mark_offset = lock_offset +\n-                              BasicLock::displaced_header_offset_in_bytes();\n-\n-      \/\/ Initialize the box (Must happen before we update the object mark!).\n-      std(header, mark_offset, monitor);\n-\n-      \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-\n-      \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-      \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-      \/\/ CmpxchgX sets CR0 to cmpX(current, displaced).\n-      cmpxchgd(\/*flag=*\/CR0,\n-               \/*current_value=*\/current_header,\n-               \/*compare_value=*\/header, \/*exchange_value=*\/monitor,\n-               \/*where=*\/object_mark_addr,\n-               MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-               MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-               noreg,\n-               &cas_failed,\n-               \/*check without membar and ldarx first*\/true);\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object and we have now locked it.\n-      b(count_locking);\n-      bind(cas_failed);\n-\n-      \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-      \/\/   \/\/ Simple recursive case.\n-      \/\/   monitor->lock()->set_displaced_header(nullptr);\n-\n-      \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-      \/\/ Check if owner is self by comparing the value in the markWord of object\n-      \/\/ (current_header) with the stack pointer.\n-      sub(current_header, current_header, R1_SP);\n-\n-      assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-      load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n-\n-      and_(R0\/*==0?*\/, current_header, tmp);\n-      \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-      \/\/ header indicating it is a recursive lock.\n-      bne(CR0, slow_case);\n-      std(R0\/*==0!*\/, mark_offset, monitor);\n-      b(count_locking);\n-    }\n+  Label done, slow_case;\n@@ -1046,18 +954,9 @@\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-\n-    \/\/ None of the above fast optimizations worked so we have to get into the\n-    \/\/ slow case of monitor enter.\n-    bind(slow_case);\n-    call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    \/\/ }\n-\n-    if (LockingMode == LM_LEGACY) {\n-      b(done);\n-      align(32, 12);\n-      bind(count_locking);\n-      inc_held_monitor_count(current_header \/*tmp*\/);\n-    }\n-    bind(done);\n-  }\n+  assert_different_registers(header, tmp);\n+\n+  lightweight_lock(monitor, object, header, tmp, slow_case);\n+  b(done);\n+\n+  bind(slow_case);\n+  call_VM_preemptable(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n+\n+  bind(done);\n@@ -1074,3 +973,3 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-  } else {\n+  const Register object           = R7_ARG5;\n+  const Register header           = R8_ARG6;\n+  const Register current_header   = R10_ARG8;\n@@ -1078,36 +977,2 @@\n-    \/\/ template code (for LM_LEGACY):\n-    \/\/\n-    \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-    \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-    \/\/   monitor->set_obj(nullptr);\n-    \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-    \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-    \/\/   monitor->set_obj(nullptr);\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorexit(monitor);\n-    \/\/ }\n-\n-    const Register object           = R7_ARG5;\n-    const Register header           = R8_ARG6;\n-    const Register object_mark_addr = R9_ARG7;\n-    const Register current_header   = R10_ARG8;\n-\n-    Label free_slot;\n-    Label slow_case;\n-\n-    assert_different_registers(object, header, object_mark_addr, current_header);\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Test first if we are in the fast recursive case.\n-      ld(header, in_bytes(BasicObjectLock::lock_offset()) +\n-                 BasicLock::displaced_header_offset_in_bytes(), monitor);\n-\n-      \/\/ If the displaced header is zero, we have a recursive unlock.\n-      cmpdi(CR0, header, 0);\n-      beq(CR0, free_slot); \/\/ recursive unlock\n-    }\n-\n-    \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-    \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-    \/\/   monitor->set_obj(nullptr);\n+  Label free_slot;\n+  Label slow_case;\n@@ -1115,1 +980,1 @@\n-    \/\/ If we still have a lightweight lock, unlock the object and be done.\n+  assert_different_registers(object, header, current_header);\n@@ -1117,2 +982,2 @@\n-    \/\/ The object address from the monitor is in object.\n-    ld(object, in_bytes(BasicObjectLock::obj_offset()), monitor);\n+  \/\/ The object address from the monitor is in object.\n+  ld(object, in_bytes(BasicObjectLock::obj_offset()), monitor);\n@@ -1120,19 +985,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(object, header, slow_case);\n-    } else {\n-      addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());\n-\n-      \/\/ We have the displaced header in displaced_header. If the lock is still\n-      \/\/ lightweight, it will contain the monitor address and we'll store the\n-      \/\/ displaced header back into the object's mark word.\n-      \/\/ CmpxchgX sets CR0 to cmpX(current, monitor).\n-      cmpxchgd(\/*flag=*\/CR0,\n-               \/*current_value=*\/current_header,\n-               \/*compare_value=*\/monitor, \/*exchange_value=*\/header,\n-               \/*where=*\/object_mark_addr,\n-               MacroAssembler::MemBarRel,\n-               MacroAssembler::cmpxchgx_hint_release_lock(),\n-               noreg,\n-               &slow_case);\n-    }\n-    b(free_slot);\n+  lightweight_unlock(object, header, slow_case);\n@@ -1140,3 +987,1 @@\n-    \/\/ } else {\n-    \/\/   \/\/ Slow path.\n-    \/\/   InterpreterRuntime::monitorexit(monitor);\n+  b(free_slot);\n@@ -1144,5 +989,2 @@\n-    \/\/ The lock has been converted into a heavy lock and hence\n-    \/\/ we need to get into the slow case.\n-    bind(slow_case);\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-    \/\/ }\n+  bind(slow_case);\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n@@ -1150,2 +992,2 @@\n-    Label done;\n-    b(done); \/\/ Monitor register may be overwritten! Runtime has already freed the slot.\n+  Label done;\n+  b(done); \/\/ Monitor register may be overwritten! Runtime has already freed the slot.\n@@ -1153,10 +995,6 @@\n-    \/\/ Exchange worked, do monitor->set_obj(nullptr);\n-    align(32, 12);\n-    bind(free_slot);\n-    li(R0, 0);\n-    std(R0, in_bytes(BasicObjectLock::obj_offset()), monitor);\n-    if (LockingMode == LM_LEGACY) {\n-      dec_held_monitor_count(current_header \/*tmp*\/);\n-    }\n-    bind(done);\n-  }\n+  \/\/ Do monitor->set_obj(nullptr);\n+  align(32, 12);\n+  bind(free_slot);\n+  li(R0, 0);\n+  std(R0, in_bytes(BasicObjectLock::obj_offset()), monitor);\n+  bind(done);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":32,"deletions":194,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2674,232 +2674,0 @@\n-void MacroAssembler::compiler_fast_lock_object(ConditionRegister flag, Register oop, Register box,\n-                                               Register temp, Register displaced_header, Register current_header) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n-  assert_different_registers(oop, box, temp, displaced_header, current_header);\n-  Label object_has_monitor;\n-  Label cas_failed;\n-  Label success, failure;\n-\n-  \/\/ Load markWord from object into displaced_header.\n-  ld(displaced_header, oopDesc::mark_offset_in_bytes(), oop);\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(temp, oop);\n-    lbz(temp, in_bytes(Klass::misc_flags_offset()), temp);\n-    testbitdi(flag, R0, temp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-    bne(flag, failure);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  andi_(temp, displaced_header, markWord::monitor_value);\n-  bne(CR0, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path.\n-    crandc(flag, Assembler::equal, flag, Assembler::equal);\n-    b(failure);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-    ori(displaced_header, displaced_header, markWord::unlocked_value);\n-\n-    \/\/ Load Compare Value application register.\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    std(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ Must fence, otherwise, preceding store(s) may float below cmpxchg.\n-    \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n-    cmpxchgd(\/*flag=*\/flag,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/displaced_header,\n-             \/*exchange_value=*\/box,\n-             \/*where=*\/oop,\n-             MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-             MacroAssembler::cmpxchgx_hint_acquire_lock(),\n-             noreg,\n-             &cas_failed,\n-             \/*check without membar and ldarx first*\/true);\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object and we have now locked it.\n-    b(success);\n-\n-    bind(cas_failed);\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if the owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    sub(current_header, current_header, R1_SP);\n-    load_const_optimized(temp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n-\n-    and_(R0\/*==0?*\/, current_header, temp);\n-    \/\/ If condition is true we are cont and hence we can store 0 as the\n-    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-    std(R0\/*==0, perhaps*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    if (flag != CR0) {\n-      mcrf(flag, CR0);\n-    }\n-    beq(CR0, success);\n-    b(failure);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  addi(temp, displaced_header, in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value);\n-  Register thread_id = displaced_header;\n-  ld(thread_id, in_bytes(JavaThread::monitor_owner_id_offset()), R16_thread);\n-  cmpxchgd(\/*flag=*\/flag,\n-           \/*current_value=*\/current_header,\n-           \/*compare_value=*\/(intptr_t)0,\n-           \/*exchange_value=*\/thread_id,\n-           \/*where=*\/temp,\n-           MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock());\n-\n-  \/\/ Store a non-null value into the box.\n-  std(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-  beq(flag, success);\n-\n-  \/\/ Check for recursive locking.\n-  cmpd(flag, current_header, thread_id);\n-  bne(flag, failure);\n-\n-  \/\/ Current thread already owns the lock. Just increment recursions.\n-  Register recursions = displaced_header;\n-  ld(recursions, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), temp);\n-  addi(recursions, recursions, 1);\n-  std(recursions, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), temp);\n-\n-  \/\/ flag == EQ indicates success, increment held monitor count if LM_LEGACY is enabled\n-  \/\/ flag == NE indicates failure\n-  bind(success);\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(temp);\n-  }\n-#ifdef ASSERT\n-  \/\/ Check that unlocked label is reached with flag == EQ.\n-  Label flag_correct;\n-  beq(flag, flag_correct);\n-  stop(\"compiler_fast_lock_object: Flag != EQ\");\n-#endif\n-  bind(failure);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag == NE.\n-  bne(flag, flag_correct);\n-  stop(\"compiler_fast_lock_object: Flag != NE\");\n-  bind(flag_correct);\n-#endif\n-}\n-\n-void MacroAssembler::compiler_fast_unlock_object(ConditionRegister flag, Register oop, Register box,\n-                                                 Register temp, Register displaced_header, Register current_header) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, temp, displaced_header, current_header);\n-  Label success, failure, object_has_monitor, not_recursive;\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ld(displaced_header, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    cmpdi(flag, displaced_header, 0);\n-    beq(flag, success);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  ld(current_header, oopDesc::mark_offset_in_bytes(), oop);\n-  andi_(R0, current_header, markWord::monitor_value);\n-  bne(CR0, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path.\n-    crandc(flag, Assembler::equal, flag, Assembler::equal);\n-    b(failure);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a light weight lock, this is is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object.\n-    \/\/ Cmpxchg sets flag to cmpd(current_header, box).\n-    cmpxchgd(\/*flag=*\/flag,\n-             \/*current_value=*\/current_header,\n-             \/*compare_value=*\/box,\n-             \/*exchange_value=*\/displaced_header,\n-             \/*where=*\/oop,\n-             MacroAssembler::MemBarRel,\n-             MacroAssembler::cmpxchgx_hint_release_lock(),\n-             noreg,\n-             &failure);\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-    b(success);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-  addi(current_header, current_header, -(int)markWord::monitor_value); \/\/ monitor\n-\n-  ld(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n-  addic_(displaced_header, displaced_header, -1);\n-  blt(CR0, not_recursive); \/\/ Not recursive if negative after decrement.\n-\n-  \/\/ Recursive unlock\n-  std(displaced_header, in_bytes(ObjectMonitor::recursions_offset()), current_header);\n-  if (flag == CR0) { \/\/ Otherwise, flag is already EQ, here.\n-    crorc(CR0, Assembler::equal, CR0, Assembler::equal); \/\/ Set CR0 EQ\n-  }\n-  b(success);\n-\n-  bind(not_recursive);\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  release();\n-  li(temp, 0);\n-  std(temp, in_bytes(ObjectMonitor::owner_offset()), current_header);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  \/\/ StoreLoad achieves this.\n-  membar(StoreLoad);\n-\n-  \/\/ Check if the entry_list is empty.\n-  ld(temp, in_bytes(ObjectMonitor::entry_list_offset()), current_header);\n-  cmpdi(flag, temp, 0);\n-  beq(flag, success);  \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  ld(temp, in_bytes(ObjectMonitor::succ_offset()), current_header);\n-  cmpdi(flag, temp, 0);\n-  \/\/ Invert equal bit\n-  crnand(flag, Assembler::equal, flag, Assembler::equal);\n-  beq(flag, success);  \/\/ If there is a successor we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try\n-  \/\/ to reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  std(current_header, in_bytes(JavaThread::unlocked_inflated_monitor_offset()), R16_thread);\n-  b(failure); \/\/ flag == NE\n-\n-  \/\/ flag == EQ indicates success, decrement held monitor count if LM_LEGACY is enabled\n-  \/\/ flag == NE indicates failure\n-  bind(success);\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(temp);\n-  }\n-#ifdef ASSERT\n-  \/\/ Check that unlocked label is reached with flag == EQ.\n-  Label flag_correct;\n-  beq(flag, flag_correct);\n-  stop(\"compiler_fast_unlock_object: Flag != EQ\");\n-#endif\n-  bind(failure);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag == NE.\n-  bne(flag, flag_correct);\n-  stop(\"compiler_fast_unlock_object: Flag != NE\");\n-  bind(flag_correct);\n-#endif\n-}\n-\n@@ -4772,32 +4540,0 @@\n-\/\/ Note: Must preserve CR0 EQ (invariant).\n-void MacroAssembler::inc_held_monitor_count(Register tmp) {\n-  assert(LockingMode == LM_LEGACY, \"\");\n-  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-#ifdef ASSERT\n-  Label ok;\n-  cmpdi(CR0, tmp, 0);\n-  bge_predict_taken(CR0, ok);\n-  stop(\"held monitor count is negativ at increment\");\n-  bind(ok);\n-  crorc(CR0, Assembler::equal, CR0, Assembler::equal); \/\/ Restore CR0 EQ\n-#endif\n-  addi(tmp, tmp, 1);\n-  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-}\n-\n-\/\/ Note: Must preserve CR0 EQ (invariant).\n-void MacroAssembler::dec_held_monitor_count(Register tmp) {\n-  assert(LockingMode == LM_LEGACY, \"\");\n-  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-#ifdef ASSERT\n-  Label ok;\n-  cmpdi(CR0, tmp, 0);\n-  bgt_predict_taken(CR0, ok);\n-  stop(\"held monitor count is <= 0 at decrement\");\n-  bind(ok);\n-  crorc(CR0, Assembler::equal, CR0, Assembler::equal); \/\/ Restore CR0 EQ\n-#endif\n-  addi(tmp, tmp, -1);\n-  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-}\n-\n@@ -4845,1 +4581,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -4902,1 +4637,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":0,"deletions":266,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -700,2 +700,0 @@\n-  void inc_held_monitor_count(Register tmp);\n-  void dec_held_monitor_count(Register tmp);\n@@ -718,6 +716,0 @@\n-  void compiler_fast_lock_object(ConditionRegister flag, Register oop, Register box,\n-                                 Register tmp1, Register tmp2, Register tmp3);\n-\n-  void compiler_fast_unlock_object(ConditionRegister flag, Register oop, Register box,\n-                                   Register tmp1, Register tmp2, Register tmp3);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -11576,32 +11576,0 @@\n-instruct cmpFastLock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set crx (FastLock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-\n-  format %{ \"FASTLOCK  $oop, $box, $tmp1, $tmp2\" %}\n-  ins_encode %{\n-    __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,\n-                                 $tmp1$$Register, $tmp2$$Register, \/*tmp3*\/ R0);\n-    \/\/ If locking was successful, crx should indicate 'EQ'.\n-    \/\/ The compiler generates a branch to the runtime call to\n-    \/\/ _complete_monitor_locking_Java for the case where crx is 'NE'.\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-instruct cmpFastUnlock(flagsRegCR0 crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set crx (FastUnlock oop box));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-\n-  format %{ \"FASTUNLOCK  $oop, $box, $tmp1, $tmp2\" %}\n-  ins_encode %{\n-    __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,\n-                                   $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n-    \/\/ If unlocking was successful, crx should indicate 'EQ'.\n-    \/\/ The compiler generates a branch to the runtime call to\n-    \/\/ _complete_monitor_unlocking_Java for the case where crx is 'NE'.\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n@@ -11609,1 +11577,1 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT && !UseObjectMonitorTable);\n+  predicate(!UseObjectMonitorTable);\n@@ -11625,1 +11593,1 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT && UseObjectMonitorTable);\n+  predicate(UseObjectMonitorTable);\n@@ -11641,1 +11609,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2449,8 +2449,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ fast_lock kills r_temp_1, r_temp_2, r_temp_3.\n-      Register r_temp_3_or_noreg = UseObjectMonitorTable ? r_temp_3 : noreg;\n-      __ compiler_fast_lock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3_or_noreg);\n-    } else {\n-      \/\/ fast_lock kills r_temp_1, r_temp_2, r_temp_3.\n-      __ compiler_fast_lock_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n-    }\n+    \/\/ fast_lock kills r_temp_1, r_temp_2, r_temp_3.\n+    Register r_temp_3_or_noreg = UseObjectMonitorTable ? r_temp_3 : noreg;\n+    __ compiler_fast_lock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3_or_noreg);\n@@ -2623,1 +2618,1 @@\n-    if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+    if (method->is_object_wait0()) {\n@@ -2675,5 +2670,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      __ compiler_fast_unlock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n-    } else {\n-      __ compiler_fast_unlock_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n-    }\n+    __ compiler_fast_unlock_lightweight_object(CR0, r_oop, r_box, r_temp_1, r_temp_2, r_temp_3);\n@@ -2720,1 +2711,1 @@\n-  bool maybe_preempted = LockingMode != LM_LEGACY && method->is_object_wait0();\n+  bool maybe_preempted = method->is_object_wait0();\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1365,1 +1365,1 @@\n-  bool support_vthread_preemption = Continuations::enabled() && LockingMode != LM_LEGACY;\n+  bool support_vthread_preemption = Continuations::enabled();\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -628,2 +628,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", cpu_info_string());\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1991,0 +1991,1 @@\n+  INSN(vnsrl_wi, 0b1010111, 0b011, 0b101100);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -342,5 +342,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ j(*stub->entry());\n-    } else {\n-      __ unlock_object(x15, x14, x10, x16, *stub->entry());\n-    }\n+    __ unlock_object(x15, x14, x10, x16, *stub->entry());\n@@ -1500,7 +1496,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj, -1);\n-    }\n-    __ j(*op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n@@ -1834,1 +1824,1 @@\n-  Register dst = dest->as_register_lo();\n+  Register dst = dest->as_pointer_register();\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -840,1 +840,1 @@\n-      LIR_Opr addr = new_pointer_register();\n+      LIR_Opr addr = new_register(T_ADDRESS);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,0 @@\n-  const int aligned_mask = BytesPerWord - 1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -64,50 +62,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(hdr, obj);\n-      lbu(hdr, Address(hdr, Klass::misc_flags_offset()));\n-      test_bit(temp, hdr, exact_log2(KlassFlags::_misc_is_value_based_class));\n-      bnez(temp, slow_case, \/* is_far *\/ true);\n-    }\n-\n-    Label done;\n-    \/\/ Load object header\n-    ld(hdr, Address(obj, hdr_offset));\n-    \/\/ and mark it as unlocked\n-    ori(hdr, hdr, markWord::unlocked_value);\n-    \/\/ save unlocked object header into the displaced header location on the stack\n-    sd(hdr, Address(disp_hdr, 0));\n-    \/\/ test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header - if it is not the same, get the\n-    \/\/ object header instead\n-    la(temp, Address(obj, hdr_offset));\n-    \/\/ if the object header was the same, we're done\n-    cmpxchgptr(hdr, disp_hdr, temp, t1, done, \/*fallthough*\/nullptr);\n-    \/\/ if the object header was not the same, it is now in the hdr register\n-    \/\/ => test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (hdr & aligned_mask) == 0\n-    \/\/ 2) sp <= hdr\n-    \/\/ 3) hdr <= sp + page_size\n-    \/\/\n-    \/\/ these 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (hdr -sp) & (aligned_mask - page_size)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    sub(hdr, hdr, sp);\n-    mv(temp, aligned_mask - (int)os::vm_page_size());\n-    andr(hdr, hdr, temp);\n-    \/\/ for recursive locking, the result is zero => save it in the displaced header\n-    \/\/ location (null in the displaced hdr location indicates recursive locking)\n-    sd(hdr, Address(disp_hdr, 0));\n-    \/\/ otherwise we don't care about the result and handle locking via runtime call\n-    bnez(hdr, slow_case, \/* is_far *\/ true);\n-\n-    \/\/ done\n-    bind(done);\n-    inc_held_monitor_count(t0);\n-  }\n+  lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n@@ -119,2 +68,0 @@\n-  const int aligned_mask = BytesPerWord - 1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -122,9 +69,0 @@\n-  Label done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ load displaced header\n-    ld(hdr, Address(disp_hdr, 0));\n-    \/\/ if the loaded hdr is null we had recursive locking\n-    \/\/ if we had recursive locking, we are done\n-    beqz(hdr, done);\n-  }\n@@ -136,19 +74,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(obj, hdr, temp, t1, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object - if the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead\n-    \/\/ if the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call\n-    if (hdr_offset) {\n-      la(temp, Address(obj, hdr_offset));\n-      cmpxchgptr(disp_hdr, hdr, temp, t1, done, &slow_case);\n-    } else {\n-      cmpxchgptr(disp_hdr, hdr, obj, t1, done, &slow_case);\n-    }\n-\n-    \/\/ done\n-    bind(done);\n-    dec_held_monitor_count(t0);\n-  }\n+  lightweight_unlock(obj, hdr, temp, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":82,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -46,228 +46,0 @@\n-void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg,\n-                                  Register tmp1Reg, Register tmp2Reg, Register tmp3Reg, Register tmp4Reg) {\n-  \/\/ Use cr register to indicate the fast_lock result: zero for success; non-zero for failure.\n-  Register flag = t1;\n-  Register oop = objectReg;\n-  Register box = boxReg;\n-  Register disp_hdr = tmp1Reg;\n-  Register tmp = tmp2Reg;\n-  Label object_has_monitor;\n-  \/\/ Finish fast lock successfully. MUST branch to with flag == 0\n-  Label locked;\n-  \/\/ Finish fast lock unsuccessfully. slow_path MUST branch to with flag != 0\n-  Label slow_path;\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_lock_lightweight\");\n-  assert_different_registers(oop, box, tmp, disp_hdr, flag, tmp3Reg, t0);\n-\n-  mv(flag, 1);\n-\n-  \/\/ Load markWord from object into displaced_header.\n-  ld(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(tmp, oop);\n-    lbu(tmp, Address(tmp, Klass::misc_flags_offset()));\n-    test_bit(tmp, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-    bnez(tmp, slow_path);\n-  }\n-\n-  \/\/ Check for existing monitor\n-  test_bit(tmp, disp_hdr, exact_log2(markWord::monitor_value));\n-  bnez(tmp, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    j(slow_path);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-    ori(tmp, disp_hdr, markWord::unlocked_value);\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ Compare object markWord with an unlocked value (tmp) and if\n-    \/\/ equal exchange the stack address of our box with object markWord.\n-    \/\/ On failure disp_hdr contains the possibly locked markWord.\n-    cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64,\n-            Assembler::aq, Assembler::rl, \/*result*\/disp_hdr);\n-    beq(disp_hdr, tmp, locked);\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object, will have now locked it will continue at label locked\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if the owner is self by comparing the value in the\n-    \/\/ markWord of object (disp_hdr) with the stack pointer.\n-    sub(disp_hdr, disp_hdr, sp);\n-    mv(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n-    \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto label\n-    \/\/ locked, hence we can store 0 as the displaced header in the box, which indicates that it\n-    \/\/ is a recursive lock.\n-    andr(tmp\/*==0?*\/, disp_hdr, tmp);\n-    sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    beqz(tmp, locked);\n-    j(slow_path);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value));\n-  Register tid = tmp4Reg;\n-  ld(tid, Address(xthread, JavaThread::monitor_owner_id_offset()));\n-  cmpxchg(\/*memory address*\/tmp, \/*expected value*\/zr, \/*new value*\/tid, Assembler::int64,\n-          Assembler::aq, Assembler::rl, \/*result*\/tmp3Reg); \/\/ cas succeeds if tmp3Reg == zr(expected)\n-\n-  \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-  \/\/ lock. The fast-path monitor unlock code checks for\n-  \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-  \/\/ relevant bit set, and also matches ObjectSynchronizer::slow_enter.\n-  mv(tmp, (address)markWord::unused_mark().value());\n-  sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-  beqz(tmp3Reg, locked); \/\/ CAS success means locking succeeded\n-\n-  bne(tmp3Reg, tid, slow_path); \/\/ Check for recursive locking\n-\n-  \/\/ Recursive lock case\n-  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1, tmp2Reg, tmp3Reg);\n-\n-  bind(locked);\n-  mv(flag, zr);\n-  if (LockingMode == LM_LEGACY) {\n-    inc_held_monitor_count(t0);\n-  }\n-\n-#ifdef ASSERT\n-  \/\/ Check that locked label is reached with flag == 0.\n-  Label flag_correct;\n-  beqz(flag, flag_correct);\n-  stop(\"Fast Lock Flag != 0\");\n-#endif\n-\n-  bind(slow_path);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag != 0.\n-  bnez(flag, flag_correct);\n-  stop(\"Fast Lock Flag == 0\");\n-  bind(flag_correct);\n-#endif\n-  \/\/ C2 uses the value of flag (0 vs !0) to determine the continuation.\n-}\n-\n-void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg,\n-                                    Register tmp1Reg, Register tmp2Reg) {\n-  \/\/ Use cr register to indicate the fast_unlock result: zero for success; non-zero for failure.\n-  Register flag = t1;\n-  Register oop = objectReg;\n-  Register box = boxReg;\n-  Register disp_hdr = tmp1Reg;\n-  Register owner_addr = tmp1Reg;\n-  Register tmp = tmp2Reg;\n-  Label object_has_monitor;\n-  \/\/ Finish fast lock successfully. MUST branch to with flag == 0\n-  Label unlocked;\n-  \/\/ Finish fast lock unsuccessfully. slow_path MUST branch to with flag != 0\n-  Label slow_path;\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, tmp, disp_hdr, flag, t0);\n-\n-  mv(flag, 1);\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    beqz(disp_hdr, unlocked);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  ld(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-  test_bit(t0, tmp, exact_log2(markWord::monitor_value));\n-  bnez(t0, object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    j(slow_path);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a light weight lock, this is true if we\n-    \/\/ see the stack address of the basicLock in the markWord of the\n-    \/\/ object.\n-\n-    cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64,\n-            Assembler::relaxed, Assembler::rl, \/*result*\/tmp);\n-    beq(box, tmp, unlocked); \/\/ box == tmp if cas succeeds\n-    j(slow_path);\n-  }\n-\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-  subi(tmp, tmp, (int)markWord::monitor_value); \/\/ monitor\n-  ld(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-  Label notRecursive;\n-  beqz(disp_hdr, notRecursive); \/\/ Will be 0 if not recursive.\n-\n-  \/\/ Recursive lock\n-  subi(disp_hdr, disp_hdr, 1);\n-  sd(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-  j(unlocked);\n-\n-  bind(notRecursive);\n-  \/\/ Compute owner address.\n-  la(owner_addr, Address(tmp, ObjectMonitor::owner_offset()));\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-  sd(zr, Address(owner_addr));\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  \/\/ StoreLoad achieves this.\n-  membar(StoreLoad);\n-\n-  \/\/ Check if the entry_list is empty.\n-  ld(t0, Address(tmp, ObjectMonitor::entry_list_offset()));\n-  beqz(t0, unlocked); \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  ld(t0, Address(tmp, ObjectMonitor::succ_offset()));\n-  bnez(t0, unlocked); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  sd(tmp, Address(xthread, JavaThread::unlocked_inflated_monitor_offset()));\n-\n-  mv(flag, 1);\n-  j(slow_path);\n-\n-  bind(unlocked);\n-  mv(flag, zr);\n-  if (LockingMode == LM_LEGACY) {\n-    dec_held_monitor_count(t0);\n-  }\n-\n-#ifdef ASSERT\n-  \/\/ Check that unlocked label is reached with flag == 0.\n-  Label flag_correct;\n-  beqz(flag, flag_correct);\n-  stop(\"Fast Lock Flag != 0\");\n-#endif\n-\n-  bind(slow_path);\n-#ifdef ASSERT\n-  \/\/ Check that slow_path label is reached with flag != 0.\n-  bnez(flag, flag_correct);\n-  stop(\"Fast Lock Flag == 0\");\n-  bind(flag_correct);\n-#endif\n-  \/\/ C2 uses the value of flag (0 vs !0) to determine the continuation.\n-}\n-\n@@ -279,1 +51,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -442,1 +213,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -2394,12 +2164,1 @@\n-  __ fmv_x_w(dst, src);\n-\n-  \/\/ preserve the payloads of non-canonical NaNs.\n-  __ srai(dst, dst, 13);\n-  \/\/ preserve the sign bit.\n-  __ srai(tmp, dst, 13);\n-  __ slli(tmp, tmp, 10);\n-  __ mv(t0, 0x3ff);\n-  __ orr(tmp, tmp, t0);\n-\n-  \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-  __ andr(dst, dst, tmp);\n+  __ float_to_float16_NaN(dst, src, t0, tmp);\n@@ -2413,1 +2172,1 @@\n-  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 130, float_to_float16_slow_path);\n+  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 64, float_to_float16_slow_path);\n@@ -2492,1 +2251,3 @@\n-  VectorRegister tmp = stub.data<2>();\n+  VectorRegister vtmp = stub.data<2>();\n+  assert_different_registers(dst, src, vtmp);\n+\n@@ -2495,0 +2256,1 @@\n+  \/\/ Active elements (NaNs) are marked in v0 mask register.\n@@ -2497,11 +2259,47 @@\n-  \/\/ preserve the payloads of non-canonical NaNs.\n-  __ vnsra_wi(dst, src, 13, Assembler::v0_t);\n-\n-  \/\/ preserve the sign bit.\n-  __ vnsra_wi(tmp, src, 26, Assembler::v0_t);\n-  __ vsll_vi(tmp, tmp, 10, Assembler::v0_t);\n-  __ mv(t0, 0x3ff);\n-  __ vor_vx(tmp, tmp, t0, Assembler::v0_t);\n-\n-  \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-  __ vand_vv(dst, dst, tmp, Assembler::v0_t);\n+  \/\/  Float (32 bits)\n+  \/\/    Bit:     31        30 to 23          22 to 0\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          | S |     Exponent     |      Mantissa (Fraction)    |\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          1 bit       8 bits                  23 bits\n+  \/\/\n+  \/\/  Float (16 bits)\n+  \/\/    Bit:    15        14 to 10         9 to 0\n+  \/\/          +---+----------------+------------------+\n+  \/\/          | S |    Exponent    |     Mantissa     |\n+  \/\/          +---+----------------+------------------+\n+  \/\/          1 bit      5 bits          10 bits\n+  const int fp_sign_bits = 1;\n+  const int fp32_bits = 32;\n+  const int fp32_mantissa_2nd_part_bits = 9;\n+  const int fp32_mantissa_3rd_part_bits = 4;\n+  const int fp16_exponent_bits = 5;\n+  const int fp16_mantissa_bits = 10;\n+\n+  \/\/ preserve the sign bit and exponent, clear mantissa.\n+  __ vnsra_wi(dst, src, fp32_bits - fp_sign_bits - fp16_exponent_bits, Assembler::v0_t);\n+  __ vsll_vi(dst, dst, fp16_mantissa_bits, Assembler::v0_t);\n+\n+  \/\/ Preserve high order bit of float NaN in the\n+  \/\/ binary16 result NaN (tenth bit); OR in remaining\n+  \/\/ bits into lower 9 bits of binary 16 significand.\n+  \/\/   | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+  \/\/   | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+  \/\/   | (doppel & 0x0000_000f));     \/\/  4 bits\n+  \/\/\n+  \/\/ Check j.l.Float.floatToFloat16 for more information.\n+  \/\/ 10 bits\n+  __ vnsrl_wi(vtmp, src, fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+  __ mv(t0, 0x3ff); \/\/ retain first part of mantissa in a float 32\n+  __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+  \/\/ 9 bits\n+  __ vnsrl_wi(vtmp, src, fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+  __ mv(t0, 0x1ff); \/\/ retain second part of mantissa in a float 32\n+  __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+  \/\/ 4 bits\n+  \/\/ Narrow shift is necessary to move data from 32 bits element to 16 bits element in vector register.\n+  __ vnsrl_wi(vtmp, src, 0, Assembler::v0_t);\n+  __ vand_vi(vtmp, vtmp, 0xf, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n@@ -2514,2 +2312,2 @@\n-void C2_MacroAssembler::float_to_float16_v(VectorRegister dst, VectorRegister src, VectorRegister vtmp,\n-                                           Register tmp, uint vector_length) {\n+void C2_MacroAssembler::float_to_float16_v(VectorRegister dst, VectorRegister src,\n+                                           VectorRegister vtmp, Register tmp, uint vector_length) {\n@@ -2519,1 +2317,1 @@\n-              (dst, src, vtmp, 28, float_to_float16_v_slow_path);\n+              (dst, src, vtmp, 56, float_to_float16_v_slow_path);\n@@ -2526,1 +2324,1 @@\n-  \/\/ replace v_fclass with vmseq_vv as performance optimization.\n+  \/\/ replace v_fclass with vmfne_vv as performance optimization.\n@@ -2826,4 +2624,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":65,"deletions":263,"binary":false,"changes":328,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,5 +52,0 @@\n-  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n-  void fast_lock(Register object, Register box,\n-                 Register tmp1, Register tmp2, Register tmp3, Register tmp4);\n-  void fast_unlock(Register object, Register box, Register tmp1, Register tmp2);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -197,0 +197,3 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -177,1 +177,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n@@ -705,1 +705,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), pre_val, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), pre_val);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -736,34 +736,0 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n-  } else {\n-    Label count, done;\n-\n-    const Register swap_reg = x10;\n-    const Register tmp = c_rarg2;\n-    const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n-    const Register tmp2 = c_rarg4;\n-    const Register tmp3 = c_rarg5;\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset +\n-                            BasicLock::displaced_header_offset_in_bytes();\n-\n-    Label slow_case;\n-\n-    \/\/ Load object pointer into obj_reg c_rarg3\n-    ld(obj_reg, Address(lock_reg, obj_offset));\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n-      j(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp, obj_reg);\n-        lbu(tmp, Address(tmp, Klass::misc_flags_offset()));\n-        test_bit(tmp, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n-        bnez(tmp, slow_case);\n-      }\n@@ -771,33 +737,4 @@\n-      \/\/ Load (object->mark() | 1) into swap_reg\n-      ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      ori(swap_reg, t0, 1);\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      sd(swap_reg, Address(lock_reg, mark_offset));\n-\n-      assert(lock_offset == 0,\n-             \"displached header must be first word in BasicObjectLock\");\n-\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, tmp, count, \/*fallthrough*\/nullptr);\n-\n-      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-      \/\/  1) (mark & 7) == 0, and\n-      \/\/  2) sp <= mark < mark + os::pagesize()\n-      \/\/\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - sp) & (7 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 3 bits clear.\n-      \/\/ NOTE: the oopMark is in swap_reg x10 as the result of cmpxchg\n-      sub(swap_reg, swap_reg, sp);\n-      mv(t0, (int64_t)(7 - (int)os::vm_page_size()));\n-      andr(swap_reg, swap_reg, t0);\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      sd(swap_reg, Address(lock_reg, mark_offset));\n-      bnez(swap_reg, slow_case);\n-\n-      bind(count);\n-      inc_held_monitor_count(t0);\n-      j(done);\n-    }\n+  const Register tmp = c_rarg2;\n+  const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n+  const Register tmp2 = c_rarg4;\n+  const Register tmp3 = c_rarg5;\n@@ -805,1 +742,2 @@\n-    bind(slow_case);\n+  \/\/ Load object pointer into obj_reg (c_rarg3)\n+  ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -807,4 +745,3 @@\n-    \/\/ Call the runtime routine for slow case\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n+  Label done, slow_case;\n+  lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n+  j(done);\n@@ -812,2 +749,7 @@\n-    bind(done);\n-  }\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case\n+  call_VM_preemptable(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          lock_reg);\n+\n+  bind(done);\n@@ -832,9 +774,4 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n-  } else {\n-    Label count, done;\n-\n-    const Register swap_reg   = x10;\n-    const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n-    const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n-    const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n+  const Register swap_reg   = x10;\n+  const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n+  const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n+  const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n@@ -842,1 +779,1 @@\n-    save_bcp(); \/\/ Save in case of exception\n+  save_bcp(); \/\/ Save in case of exception\n@@ -844,23 +781,2 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Convert from BasicObjectLock structure to object and BasicLock\n-      \/\/ structure Store the BasicLock address into x10\n-      la(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset()));\n-    }\n-\n-    \/\/ Load oop into obj_reg(c_rarg3)\n-    ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n-\n-    \/\/ Free entry\n-    sd(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n-\n-    Label slow_case;\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n-      j(done);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load the old header from BasicLock structure\n-      ld(header_reg, Address(swap_reg,\n-                             BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Test for recursion\n-      beqz(header_reg, count);\n+  \/\/ Load oop into obj_reg (c_rarg3)\n+  ld(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -868,2 +784,2 @@\n-      \/\/ Atomic swap back the old header\n-      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, tmp_reg, count, &slow_case);\n+  \/\/ Free entry\n+  sd(zr, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -871,4 +787,3 @@\n-      bind(count);\n-      dec_held_monitor_count(t0);\n-      j(done);\n-    }\n+  Label done, slow_case;\n+  lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n+  j(done);\n@@ -876,4 +791,4 @@\n-    bind(slow_case);\n-    \/\/ Call the runtime routine for slow case.\n-    sd(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case.\n+  sd(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset())); \/\/ restore obj\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n@@ -881,3 +796,2 @@\n-    bind(done);\n-    restore_bcp();\n-  }\n+  bind(done);\n+  restore_bcp();\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":34,"deletions":120,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2682,1 +2682,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, uimm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIx64, uimm64);\n@@ -5957,0 +5957,56 @@\n+\/\/ Helper routine processing the slow path of NaN when converting float to float16\n+void MacroAssembler::float_to_float16_NaN(Register dst, FloatRegister src,\n+                                          Register tmp1, Register tmp2) {\n+  fmv_x_w(dst, src);\n+\n+  \/\/  Float (32 bits)\n+  \/\/    Bit:     31        30 to 23          22 to 0\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          | S |     Exponent     |      Mantissa (Fraction)    |\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          1 bit       8 bits                  23 bits\n+  \/\/\n+  \/\/  Float (16 bits)\n+  \/\/    Bit:    15        14 to 10         9 to 0\n+  \/\/          +---+----------------+------------------+\n+  \/\/          | S |    Exponent    |     Mantissa     |\n+  \/\/          +---+----------------+------------------+\n+  \/\/          1 bit      5 bits          10 bits\n+  const int fp_sign_bits = 1;\n+  const int fp32_bits = 32;\n+  const int fp32_exponent_bits = 8;\n+  const int fp32_mantissa_1st_part_bits = 10;\n+  const int fp32_mantissa_2nd_part_bits = 9;\n+  const int fp32_mantissa_3rd_part_bits = 4;\n+  const int fp16_exponent_bits = 5;\n+  const int fp16_mantissa_bits = 10;\n+\n+  \/\/ preserve the sign bit and exponent, clear mantissa.\n+  srai(tmp2, dst, fp32_bits - fp_sign_bits - fp16_exponent_bits);\n+  slli(tmp2, tmp2, fp16_mantissa_bits);\n+\n+  \/\/ Preserve high order bit of float NaN in the\n+  \/\/ binary16 result NaN (tenth bit); OR in remaining\n+  \/\/ bits into lower 9 bits of binary 16 significand.\n+  \/\/   | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+  \/\/   | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+  \/\/   | (doppel & 0x0000_000f));     \/\/  4 bits\n+  \/\/\n+  \/\/ Check j.l.Float.floatToFloat16 for more information.\n+  \/\/ 10 bits\n+  int left_shift = fp_sign_bits + fp32_exponent_bits + 32;\n+  int right_shift = left_shift + fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits;\n+  slli(tmp1, dst, left_shift);\n+  srli(tmp1, tmp1, right_shift);\n+  orr(tmp2, tmp2, tmp1);\n+  \/\/ 9 bits\n+  left_shift += fp32_mantissa_1st_part_bits;\n+  right_shift = left_shift + fp32_mantissa_3rd_part_bits;\n+  slli(tmp1, dst, left_shift);\n+  srli(tmp1, tmp1, right_shift);\n+  orr(tmp2, tmp2, tmp1);\n+  \/\/ 4 bits\n+  andi(tmp1, dst, 0xf);\n+  orr(dst, tmp2, tmp1);\n+}\n+\n@@ -6424,1 +6480,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -6484,1 +6539,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":57,"deletions":3,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1434,0 +1434,3 @@\n+  \/\/ Helper routine processing the slow path of NaN when converting float to float16\n+  void float_to_float16_NaN(Register dst, FloatRegister src, Register tmp1, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -96,0 +96,46 @@\n+void MethodHandles::verify_method(MacroAssembler* _masm, Register method, vmIntrinsics::ID iid) {\n+  BLOCK_COMMENT(\"verify_method {\");\n+  __ verify_method_ptr(method);\n+  if (VerifyMethodHandles) {\n+    Label L_ok;\n+    assert_different_registers(method, t0, t1);\n+    const Register method_holder = t1;\n+    __ load_method_holder(method_holder, method);\n+\n+    switch (iid) {\n+      case vmIntrinsicID::_invokeBasic:\n+        \/\/ Require compiled LambdaForm class to be fully initialized.\n+        __ lbu(t0, Address(method_holder, InstanceKlass::init_state_offset()));\n+        __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+        __ mv(t1, InstanceKlass::fully_initialized);\n+        __ beq(t0, t1, L_ok);\n+        break;\n+      case vmIntrinsicID::_linkToStatic:\n+        __ clinit_barrier(method_holder, t0, &L_ok);\n+        break;\n+\n+      case vmIntrinsicID::_linkToVirtual:\n+      case vmIntrinsicID::_linkToSpecial:\n+      case vmIntrinsicID::_linkToInterface:\n+        \/\/ Class initialization check is too strong here. Just ensure that class initialization has been initiated.\n+        __ lbu(t0, Address(method_holder, InstanceKlass::init_state_offset()));\n+        __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+        __ mv(t1, InstanceKlass::being_initialized);\n+        __ bge(t0, t1, L_ok);\n+\n+        \/\/ init_state check failed, but it may be an abstract interface method\n+        __ lhu(t0, Address(method, Method::access_flags_offset()));\n+        __ test_bit(t1, t0, exact_log2(JVM_ACC_ABSTRACT));\n+        __ bnez(t1, L_ok);\n+        break;\n+\n+      default:\n+        fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n+    }\n+\n+    \/\/ Method holder init state check failed for a concrete method.\n+    __ stop(\"Method holder klass is not initialized\");\n+    __ BIND(L_ok);\n+  }\n+  BLOCK_COMMENT(\"} verify_method\");\n+}\n@@ -99,1 +145,1 @@\n-                                            bool for_compiler_entry) {\n+                                            bool for_compiler_entry, vmIntrinsics::ID iid) {\n@@ -103,1 +149,1 @@\n-  __ verify_method_ptr(method);\n+  verify_method(_masm, method, iid);\n@@ -161,1 +207,1 @@\n-  jump_from_method_handle(_masm, method_temp, temp2, for_compiler_entry);\n+  jump_from_method_handle(_masm, method_temp, temp2, for_compiler_entry, vmIntrinsics::_invokeBasic);\n@@ -440,2 +486,1 @@\n-    __ verify_method_ptr(xmethod);\n-    jump_from_method_handle(_masm, xmethod, temp1, for_compiler_entry);\n+    jump_from_method_handle(_masm, xmethod, temp1, for_compiler_entry, iid);\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":50,"deletions":5,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+  static void verify_method(MacroAssembler* _masm, Register method, vmIntrinsics::ID iid) NOT_DEBUG_RETURN;\n+\n@@ -52,1 +54,1 @@\n-                                      bool for_compiler_entry);\n+                                      bool for_compiler_entry, vmIntrinsics::ID iid);\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -8557,1 +8557,1 @@\n-  format %{ \"fmv.h.x $dst, $src\" %}\n+  format %{ \"fmv.h.x $dst, $src\\t# reinterpretS2HF\" %}\n@@ -8577,1 +8577,1 @@\n-  format %{ \"fmv.x.h $dst, $src\" %}\n+  format %{ \"fmv.x.h $dst, $src\\t# reinterpretHF2S\" %}\n@@ -11024,35 +11024,0 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box,\n-                     iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegPNoSp tmp4)\n-%{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastLock object box));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4);\n-\n-  ins_cost(10 * DEFAULT_COST);\n-  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3,$tmp4 #@cmpFastLock\" %}\n-\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register,\n-                 $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n-\/\/ using t1 as the 'flag' register to bridge the BoolNode producers and consumers\n-instruct cmpFastUnlock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n-%{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastUnlock object box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-\n-  ins_cost(10 * DEFAULT_COST);\n-  format %{ \"fastunlock $object,$box\\t! kills $tmp1, $tmp2, #@cmpFastUnlock\" %}\n-\n-  ins_encode %{\n-    __ fast_unlock($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n-  %}\n-\n-  ins_pipe(pipe_serial);\n-%}\n-\n@@ -11062,1 +11027,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -11077,0 +11041,1 @@\n+\/\/ using t1 as the 'flag' register to bridge the BoolNode producers and consumers\n@@ -11080,1 +11045,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":4,"deletions":40,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+        break;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1640,1 +1640,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -1682,2 +1682,0 @@\n-    Label count;\n-\n@@ -1696,36 +1694,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ j(slow_path_lock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load (object->mark() | 1) into swap_reg % x10\n-      __ ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ ori(swap_reg, t0, 1);\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n-\n-      \/\/ src -> dest if dest == x10 else x10 <- dest\n-      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, lock_tmp, count, \/*fallthrough*\/nullptr);\n-\n-      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-      \/\/  1) (mark & 3) == 0, and\n-      \/\/  2) sp <= mark < mark + os::pagesize()\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 2 bits clear.\n-      \/\/ NOTE: the oopMark is in swap_reg % 10 as the result of cmpxchg\n-\n-      __ sub(swap_reg, swap_reg, sp);\n-      __ mv(t0, 3 - (int)os::vm_page_size());\n-      __ andr(swap_reg, swap_reg, t0);\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n-      __ bnez(swap_reg, slow_path_lock);\n-\n-      __ bind(count);\n-      __ inc_held_monitor_count(t0);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n-    }\n+    __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -1792,1 +1755,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -1821,12 +1784,0 @@\n-    Label done, not_recursive;\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Simple recursive lock?\n-      __ ld(t0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      __ bnez(t0, not_recursive);\n-      __ dec_held_monitor_count(t0);\n-      __ j(done);\n-    }\n-\n-    __ bind(not_recursive);\n-\n@@ -1838,17 +1789,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ j(slow_path_unlock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ get address of the stack lock\n-      __ la(x10, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      \/\/  get old displaced header\n-      __ ld(old_hdr, Address(x10, 0));\n-\n-      \/\/ Atomic swap old header if oop still contains the stack lock\n-      Label count;\n-      __ cmpxchg_obj_header(x10, old_hdr, obj_reg, lock_tmp, count, &slow_path_unlock);\n-      __ bind(count);\n-      __ dec_held_monitor_count(t0);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n-      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n-    }\n+    __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n@@ -1861,2 +1796,0 @@\n-\n-    __ bind(done);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":4,"deletions":71,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -6360,12 +6360,2 @@\n-    __ fmv_x_w(dst, src);\n-\n-    \/\/ preserve the payloads of non-canonical NaNs.\n-    __ srai(dst, dst, 13);\n-    \/\/ preserve the sign bit.\n-    __ srai(t1, dst, 13);\n-    __ slli(t1, t1, 10);\n-    __ mv(t0, 0x3ff);\n-    __ orr(t1, t1, t0);\n-\n-    \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-    __ andr(dst, dst, t1);\n+\n+    __ float_to_float16_NaN(dst, src, t0, t1);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1256,16 +1256,11 @@\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Check preemption for Object.wait()\n-    Label not_preempted;\n-    __ ld(t1, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n-    __ beqz(t1, not_preempted);\n-    __ sd(zr, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n-    __ jr(t1);\n-    __ bind(native_return);\n-    __ restore_after_resume(true \/* is_native *\/);\n-    \/\/ reload result_handler\n-    __ ld(result_handler, Address(fp, frame::interpreter_frame_result_handler_offset * wordSize));\n-    __ bind(not_preempted);\n-  } else {\n-    \/\/ any pc will do so just use this one for LM_LEGACY to keep code together.\n-    __ bind(native_return);\n-  }\n+  \/\/ Check preemption for Object.wait()\n+  Label not_preempted;\n+  __ ld(t1, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+  __ beqz(t1, not_preempted);\n+  __ sd(zr, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+  __ jr(t1);\n+  __ bind(native_return);\n+  __ restore_after_resume(true \/* is_native *\/);\n+  \/\/ reload result_handler\n+  __ ld(result_handler, Address(fp, frame::interpreter_frame_result_handler_offset * wordSize));\n+  __ bind(not_preempted);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -496,2 +496,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"RISCV64\");\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", cpu_info_string());\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"RISCV64\");\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,5 +232,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ branch_optimized(Assembler::bcondAlways, *stub->entry());\n-    } else {\n-      __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n-    }\n+    __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n@@ -2717,7 +2713,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ branch_optimized(Assembler::bcondAlways, *op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -72,54 +70,1 @@\n-  assert(LockingMode != LM_MONITOR, \"LM_MONITOR is already handled, by emit_lock()\");\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(tmp, Roop);\n-      z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      branch_optimized(Assembler::bcondAllOne, slow_case);\n-    }\n-\n-    NearLabel done;\n-\n-    \/\/ Load object header.\n-    z_lg(Rmark, Address(Roop, hdr_offset));\n-\n-    \/\/ and mark it as unlocked.\n-    z_oill(Rmark, markWord::unlocked_value);\n-    \/\/ Save unlocked object header into the displaced header location on the stack.\n-    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ Test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header. If it is not the same, get the\n-    \/\/ object header instead.\n-    z_csg(Rmark, Rbox, hdr_offset, Roop);\n-    \/\/ If the object header was the same, we're done.\n-    branch_optimized(Assembler::bcondEqual, done);\n-    \/\/ If the object header was not the same, it is now in the Rmark register.\n-    \/\/ => Test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (Rmark & markWord::lock_mask_in_place) == 0\n-    \/\/ 2) rsp <= Rmark\n-    \/\/ 3) Rmark <= rsp + page_size\n-    \/\/\n-    \/\/ These 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (Rmark - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    z_sgr(Rmark, Z_SP);\n-\n-    load_const_optimized(Z_R0_scratch, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-    z_ngr(Rmark, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n-    \/\/ For recursive locking, the result is zero. => Save it in the displaced header\n-    \/\/ location (null in the displaced Rmark location indicates recursive locking).\n-    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ Otherwise we don't care about the result and handle locking via runtime call.\n-    branch_optimized(Assembler::bcondNotZero, slow_case);\n-    \/\/ done\n-    bind(done);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n@@ -129,2 +74,0 @@\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -133,9 +76,0 @@\n-  NearLabel done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Load displaced header.\n-    z_ltg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ If the loaded Rmark is null we had recursive locking, and we are done.\n-    z_bre(done);\n-  }\n-\n@@ -146,15 +80,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ Test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object. If the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead.\n-    z_csg(Rbox, Rmark, hdr_offset, Roop);\n-    \/\/ If the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call.\n-    branch_optimized(Assembler::bcondNotEqual, slow_case);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n-  \/\/ done\n-  bind(done);\n+  lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":82,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1011,22 +1011,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    return;\n-  }\n-\n-  \/\/ template code: (for LM_LEGACY)\n-  \/\/\n-  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-  \/\/   \/\/ We stored the monitor address into the object's mark word.\n-  \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-  \/\/   \/\/ Simple recursive case.\n-  \/\/   monitor->lock()->set_displaced_header(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -1034,2 +1012,0 @@\n-  const Register object_mark_addr = Z_ARG4;\n-  const Register current_header   = Z_ARG5;\n@@ -1040,61 +1016,1 @@\n-  \/\/ markWord header = obj->mark().set_unlocked();\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(monitor, object, header, tmp, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(tmp, object);\n-      z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      z_btrue(slow_case);\n-    }\n-\n-    \/\/ Load markWord from object into header.\n-    z_lg(header, hdr_offset, object);\n-\n-    \/\/ Set header to be (markWord of object | UNLOCK_VALUE).\n-    \/\/ This will not change anything if it was unlocked before.\n-    z_oill(header, markWord::unlocked_value);\n-\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n-    \/\/ Initialize the box (Must happen before we update the object mark!).\n-    z_stg(header, mark_offset, monitor);\n-\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-\n-    \/\/ not necessary, use offset in instruction directly.\n-    \/\/ add2reg(object_mark_addr, hdr_offset, object);\n-\n-    \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-    z_csg(header, monitor, hdr_offset, object);\n-    assert(current_header == header,\n-           \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-\n-    z_bre(done);\n-\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n-\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    z_sgr(current_header, Z_SP);\n-\n-    assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-\n-    \/\/ The prior sequence \"LGR, NGR, LTGR\" can be done better\n-    \/\/ (Z_R1 is temp and not used after here).\n-    load_const_optimized(Z_R0, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-    z_ngr(Z_R0, current_header); \/\/ AND sets CC (result eq\/ne 0)\n-\n-    \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-    \/\/ header indicating it is a recursive lock and be done.\n-    z_brne(slow_case);\n-    z_release();  \/\/ Member unnecessary on zarch AND because the above csg does a sync before and after.\n-    z_stg(Z_R0\/*==0!*\/, mark_offset, monitor);\n-  }\n+  lightweight_lock(monitor, object, header, tmp, slow_case);\n@@ -1102,3 +1018,0 @@\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n@@ -1106,2 +1019,0 @@\n-  \/\/ None of the above fast optimizations worked so we have to get into the\n-  \/\/ slow case of monitor enter.\n@@ -1112,2 +1023,0 @@\n-  \/\/ }\n-\n@@ -1125,22 +1034,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-    return;\n-  }\n-\n-\/\/ else {\n-  \/\/ template code: (for LM_LEGACY):\n-  \/\/\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -1162,8 +1049,0 @@\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-  const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n@@ -1171,5 +1050,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Test first if we are in the fast recursive case.\n-    MacroAssembler::load_and_test_long(header, Address(monitor, mark_offset));\n-    z_bre(done); \/\/ header == 0 -> goto done\n-  }\n@@ -1177,26 +1051,2 @@\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ If we still have a lightweight lock, unlock the object and be done.\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    lightweight_unlock(object, header, current_header, slow_case);\n-\n-    z_bru(done);\n-  } else {\n-    \/\/ The markword is expected to be at offset 0.\n-    \/\/ This is not required on s390, at least not here.\n-    assert(hdr_offset == 0, \"unlock_object: review code below\");\n-\n-    \/\/ We have the displaced header in header. If the lock is still\n-    \/\/ lightweight, it will contain the monitor address and we'll store the\n-    \/\/ displaced header back into the object's mark word.\n-    z_lgr(current_header, monitor);\n-    z_csg(current_header, header, hdr_offset, object);\n-    z_bre(done);\n-  }\n-\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n+  lightweight_unlock(object, header, current_header, slow_case);\n+  z_bru(done);\n@@ -1209,3 +1059,0 @@\n-\n-  \/\/ }\n-\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":3,"deletions":156,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -3769,205 +3769,0 @@\n-\/\/ \"The box\" is the space on the stack where we copy the object mark.\n-void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2) {\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n-  assert_different_registers(oop, box, temp1, temp2, Z_R0_scratch);\n-\n-  Register displacedHeader = temp1;\n-  Register currentHeader   = temp1;\n-  Register temp            = temp2;\n-\n-  NearLabel done, object_has_monitor;\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n-  BLOCK_COMMENT(\"compiler_fast_lock_object {\");\n-\n-  \/\/ Load markWord from oop into mark.\n-  z_lg(displacedHeader, hdr_offset, oop);\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(temp, oop);\n-    z_tm(Address(temp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-    z_brne(done);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n-  z_tmll(displacedHeader, markWord::monitor_value);\n-  z_brnaz(object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    \/\/ From loading the markWord, we know that oop != nullptr\n-    z_ltgr(oop, oop);\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set mark to markWord | markWord::unlocked_value.\n-    z_oill(displacedHeader, markWord::unlocked_value);\n-\n-    \/\/ Load Compare Value application register.\n-\n-    \/\/ Initialize the box (must happen before we update the object mark).\n-    z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ Compare object markWord with mark and if equal, exchange box with object markWork.\n-    \/\/ If the compare-and-swap succeeds, then we found an unlocked object and have now locked it.\n-    z_csg(displacedHeader, box, hdr_offset, oop);\n-    assert(currentHeader == displacedHeader, \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-    z_bre(done);\n-\n-    \/\/ We did not see an unlocked object\n-    \/\/ currentHeader contains what is currently stored in the oop's markWord.\n-    \/\/ We might have a recursive case. Verify by checking if the owner is self.\n-    \/\/ To do so, compare the value in the markWord (currentHeader) with the stack pointer.\n-    z_sgr(currentHeader, Z_SP);\n-    load_const_optimized(temp, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-\n-    z_ngr(currentHeader, temp);\n-\n-    \/\/ result zero: owner is self -> recursive lock. Indicate that by storing 0 in the box.\n-    \/\/ result not-zero: attempt failed. We don't hold the lock -> go for slow case.\n-\n-    z_stg(currentHeader\/*==0 or not 0*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    z_bru(done);\n-  }\n-\n-  bind(object_has_monitor);\n-\n-  Register zero = temp;\n-  Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  \/\/ If csg succeeds then CR=EQ, otherwise, register zero is filled\n-  \/\/ with the current owner.\n-  z_lghi(zero, 0);\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n-  z_csg(zero, Z_R0_scratch, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n-\n-  \/\/ Store a non-null value into the box.\n-  z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-  z_bre(done); \/\/ acquired the lock for the first time.\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n-  \/\/ Check if we are already the owner (recursive lock)\n-  z_cgr(Z_R0_scratch, zero); \/\/ owner is stored in zero by \"z_csg\" above\n-  z_brne(done); \/\/ not a recursive lock\n-\n-  \/\/ Current thread already owns the lock. Just increment recursion count.\n-  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n-  bind(done);\n-\n-  BLOCK_COMMENT(\"} compiler_fast_lock_object\");\n-  \/\/ If locking was successful, CR should indicate 'EQ'.\n-  \/\/ The compiler or the native wrapper generates a branch to the runtime call\n-  \/\/ _complete_monitor_locking_Java.\n-}\n-\n-void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2) {\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, temp1, temp2, Z_R0_scratch);\n-\n-  Register displacedHeader = temp1;\n-  Register currentHeader   = temp2;\n-  Register temp            = temp1;\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n-  Label done, object_has_monitor, not_recursive;\n-\n-  BLOCK_COMMENT(\"compiler_fast_unlock_object {\");\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    \/\/ if the displaced header is zero, we have a recursive unlock.\n-    load_and_test_long(displacedHeader, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    z_bre(done);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  z_lg(currentHeader, hdr_offset, oop);\n-  guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n-\n-  z_tmll(currentHeader, markWord::monitor_value);\n-  z_brnaz(object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    z_ltgr(oop, oop);\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a lightweight lock, this is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object\n-    \/\/ copy box to currentHeader such that csg does not kill it.\n-    z_lgr(currentHeader, box);\n-    z_csg(currentHeader, displacedHeader, hdr_offset, oop);\n-    z_bru(done); \/\/ csg sets CR as desired.\n-  }\n-\n-  \/\/ In case of LM_LIGHTWEIGHT, we may reach here with (temp & ObjectMonitor::ANONYMOUS_OWNER) != 0.\n-  \/\/ This is handled like owner thread mismatches: We take the slow path.\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n-  z_cg(Z_R0_scratch, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  z_brne(done);\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n-\n-  \/\/ Recursive inflated unlock\n-  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n-  z_bru(done);\n-\n-  bind(not_recursive);\n-\n-  NearLabel set_eq_unlocked;\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  z_release();\n-  z_lghi(temp, 0);\n-  z_stg(temp, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  z_fence();\n-\n-  \/\/ Check if the entry_list is empty.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(entry_list)));\n-  z_bre(done); \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)));\n-  z_brne(set_eq_unlocked); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  z_xilf(currentHeader, markWord::monitor_value);\n-  z_stg(currentHeader, Address(Z_thread, JavaThread::unlocked_inflated_monitor_offset()));\n-\n-  z_ltgr(oop, oop); \/\/ Set flag = NE\n-  z_bru(done);\n-\n-  bind(set_eq_unlocked);\n-  z_cr(temp, temp); \/\/ Set flag = EQ\n-\n-  bind(done);\n-\n-  BLOCK_COMMENT(\"} compiler_fast_unlock_object\");\n-  \/\/ flag == EQ indicates success\n-  \/\/ flag == NE indicates failure\n-}\n-\n@@ -6352,1 +6147,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -6418,1 +6212,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":0,"deletions":207,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -793,2 +793,0 @@\n-  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2);\n-  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -10164,22 +10164,0 @@\n-instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set pcc (FastLock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-  ins_cost(100);\n-  \/\/ TODO: s390 port size(VARIABLE_SIZE); \/\/ Uses load_const_optimized.\n-  format %{ \"FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n-  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n-instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set pcc (FastUnlock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-  ins_cost(100);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  format %{ \"FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n-  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n@@ -10187,1 +10165,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -10203,1 +10180,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1767,7 +1767,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-      __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    } else {\n-      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-      __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    }\n+    \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+    __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n@@ -1968,7 +1963,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-      __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    } else {\n-      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-      __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    }\n+    \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+    __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -167,9 +167,10 @@\n-      __ z_stmg(Z_R6, Z_R14, 16, Z_SP);\n-      __ z_std(Z_F8, 96, Z_SP);\n-      __ z_std(Z_F9, 104, Z_SP);\n-      __ z_std(Z_F10, 112, Z_SP);\n-      __ z_std(Z_F11, 120, Z_SP);\n-      __ z_std(Z_F12, 128, Z_SP);\n-      __ z_std(Z_F13, 136, Z_SP);\n-      __ z_std(Z_F14, 144, Z_SP);\n-      __ z_std(Z_F15, 152, Z_SP);\n+      __ save_return_pc();\n+      __ z_stmg(Z_R6, Z_R13, 16, Z_SP);\n+      __ z_std(Z_F8, 80, Z_SP);\n+      __ z_std(Z_F9, 88, Z_SP);\n+      __ z_std(Z_F10, 96, Z_SP);\n+      __ z_std(Z_F11, 104, Z_SP);\n+      __ z_std(Z_F12, 112, Z_SP);\n+      __ z_std(Z_F13, 120, Z_SP);\n+      __ z_std(Z_F14, 128, Z_SP);\n+      __ z_std(Z_F15, 136, Z_SP);\n@@ -340,9 +341,10 @@\n-      __ z_lmg(Z_R6, Z_R14, 16, Z_SP);\n-      __ z_ld(Z_F8, 96, Z_SP);\n-      __ z_ld(Z_F9, 104, Z_SP);\n-      __ z_ld(Z_F10, 112, Z_SP);\n-      __ z_ld(Z_F11, 120, Z_SP);\n-      __ z_ld(Z_F12, 128, Z_SP);\n-      __ z_ld(Z_F13, 136, Z_SP);\n-      __ z_ld(Z_F14, 144, Z_SP);\n-      __ z_ld(Z_F15, 152, Z_SP);\n+      __ restore_return_pc();\n+      __ z_lmg(Z_R6, Z_R13, 16, Z_SP);\n+      __ z_ld(Z_F8, 80, Z_SP);\n+      __ z_ld(Z_F9, 88, Z_SP);\n+      __ z_ld(Z_F10, 96, Z_SP);\n+      __ z_ld(Z_F11, 104, Z_SP);\n+      __ z_ld(Z_F12, 112, Z_SP);\n+      __ z_ld(Z_F13, 120, Z_SP);\n+      __ z_ld(Z_F14, 128, Z_SP);\n+      __ z_ld(Z_F15, 136, Z_SP);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+\/\/   z17:  2025-04\n@@ -72,5 +73,5 @@\n-static const char* z_gen[]      = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\",         \"G10\" };\n-static const char* z_machine[]  = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\",       \"3931\" };\n-static const char* z_name[]     = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\",        \"z16\" };\n-static const char* z_WDFM[]     = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"2024-12-31\", \"tbd\" };\n-static const char* z_EOS[]      = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"2023-12-31\", \"2024-12-31\", \"tbd\",        \"tbd\",        \"tbd\" };\n+static const char* z_gen[]      = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\",         \"G10\",         \"G11\" };\n+static const char* z_machine[]  = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\",       \"3931\",        \"9175\" };\n+static const char* z_name[]     = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\",        \"z16\",         \"z17\" };\n+static const char* z_WDFM[]     = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"2024-12-31\", \"tbd\",         \"tbd\" };\n+static const char* z_EOS[]      = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"2023-12-31\", \"2024-12-31\", \"tbd\",        \"tbd\",        \"tbd\",         \"tbd\" };\n@@ -88,1 +89,3 @@\n-                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh\"\n+                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh\",\n+                                   \"system-z, g11-z17, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, venh2,\"\n+                                       \"bear_enh, sort_enh, nnpa_assist, storage_key_removal, vpack_decimal_enh, concurrent_function\"\n@@ -342,0 +345,5 @@\n+  if (is_z17()) {\n+    model_ix = 11;\n+    ambiguity++;\n+  }\n+\n@@ -1544,2 +1552,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", cpu_info_string());\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-\/\/ --- FeatureBitString Bits 128..192 (DW[2]) ---\n+\/\/ --- FeatureBitString Bits 128..191 (DW[2]) ---\n@@ -121,1 +121,1 @@\n-\/\/ --- FeatureBitString Bits 193..200 (DW[3]) ---\n+\/\/ --- FeatureBitString Bits 192..255 (DW[3]) ---\n@@ -124,0 +124,1 @@\n+#define  ConcurrentFunFacilityMask      0x0040000000000000UL  \/\/ z17, Concurrent-functions facility, Bit: 201\n@@ -192,1 +193,2 @@\n-  static bool is_z16()  { return has_BEAR_Enh_Facility(); }\n+  static bool is_z16()  { return has_BEAR_Enh_Facility()      && !has_Concurrent_Fun_Facility(); }\n+  static bool is_z17()  { return has_Concurrent_Fun_Facility();}\n@@ -500,0 +502,1 @@\n+  static bool has_Concurrent_Fun_Facility()   { return  (_features[3] & ConcurrentFunFacilityMask)     == ConcurrentFunFacilityMask; }\n@@ -576,0 +579,1 @@\n+  static void set_has_Concurrent_Fun_Facility()   { _features[3] |= ConcurrentFunFacilityMask;}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -416,5 +416,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ jmp(*stub->entry());\n-    } else {\n-      __ unlock_object(rdi, rsi, rax, *stub->entry());\n-    }\n+    __ unlock_object(rdi, rsi, rax, *stub->entry());\n@@ -2736,7 +2732,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ jmp(*op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n@@ -2744,1 +2734,1 @@\n-    Register tmp = LockingMode == LM_LIGHTWEIGHT ? op->scratch_opr()->as_register() : noreg;\n+    Register tmp = op->scratch_opr()->as_register();\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-  LIR_Opr tmp = LockingMode == LM_LIGHTWEIGHT ? new_register(T_ADDRESS) : LIR_OprFact::illegalOpr;\n+  LIR_Opr tmp = new_register(T_ADDRESS);\n@@ -964,1 +964,1 @@\n-      LIR_Opr addr = new_pointer_register();\n+      LIR_Opr addr = new_register(T_ADDRESS);\n@@ -1103,1 +1103,1 @@\n-  LIR_Opr ptr_addr_a = new_pointer_register();\n+  LIR_Opr ptr_addr_a = new_register(T_ADDRESS);\n@@ -1106,1 +1106,1 @@\n-  LIR_Opr ptr_addr_b = new_pointer_register();\n+  LIR_Opr ptr_addr_b = new_register(T_ADDRESS);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-  const int aligned_mask = BytesPerWord -1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -58,48 +56,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(disp_hdr, obj, hdr, tmp, slow_case);\n-  } else  if (LockingMode == LM_LEGACY) {\n-    Label done;\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(hdr, obj, rscratch1);\n-      testb(Address(hdr, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      jcc(Assembler::notZero, slow_case);\n-    }\n-\n-    \/\/ Load object header\n-    movptr(hdr, Address(obj, hdr_offset));\n-    \/\/ and mark it as unlocked\n-    orptr(hdr, markWord::unlocked_value);\n-    \/\/ save unlocked object header into the displaced header location on the stack\n-    movptr(Address(disp_hdr, 0), hdr);\n-    \/\/ test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header - if it is not the same, get the\n-    \/\/ object header instead\n-    MacroAssembler::lock(); \/\/ must be immediately before cmpxchg!\n-    cmpxchgptr(disp_hdr, Address(obj, hdr_offset));\n-    \/\/ if the object header was the same, we're done\n-    jcc(Assembler::equal, done);\n-    \/\/ if the object header was not the same, it is now in the hdr register\n-    \/\/ => test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (hdr & aligned_mask) == 0\n-    \/\/ 2) rsp <= hdr\n-    \/\/ 3) hdr <= rsp + page_size\n-    \/\/\n-    \/\/ these 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (hdr - rsp) & (aligned_mask - page_size)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    subptr(hdr, rsp);\n-    andptr(hdr, aligned_mask - (int)os::vm_page_size());\n-    \/\/ for recursive locking, the result is zero => save it in the displaced header\n-    \/\/ location (null in the displaced hdr location indicates recursive locking)\n-    movptr(Address(disp_hdr, 0), hdr);\n-    \/\/ otherwise we don't care about the result and handle locking via runtime call\n-    jcc(Assembler::notZero, slow_case);\n-    \/\/ done\n-    bind(done);\n-    inc_held_monitor_count();\n-  }\n+  lightweight_lock(disp_hdr, obj, hdr, tmp, slow_case);\n@@ -111,2 +62,0 @@\n-  const int aligned_mask = BytesPerWord -1;\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n@@ -115,10 +64,0 @@\n-  Label done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ load displaced header\n-    movptr(hdr, Address(disp_hdr, 0));\n-    \/\/ if the loaded hdr is null we had recursive locking\n-    testptr(hdr, hdr);\n-    \/\/ if we had recursive locking, we are done\n-    jcc(Assembler::zero, done);\n-  }\n@@ -130,15 +69,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object - if the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead\n-    MacroAssembler::lock(); \/\/ must be immediately before cmpxchg!\n-    cmpxchgptr(hdr, Address(obj, hdr_offset));\n-    \/\/ if the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call\n-    jcc(Assembler::notEqual, slow_case);\n-    \/\/ done\n-    bind(done);\n-    dec_held_monitor_count();\n-  }\n+  lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":77,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -222,235 +222,3 @@\n-\/\/ box: on-stack box address (displaced header location) - KILLED\n-\/\/ rax,: tmp -- KILLED\n-\/\/ scr: tmp -- KILLED\n-void C2_MacroAssembler::fast_lock(Register objReg, Register boxReg, Register tmpReg,\n-                                 Register scrReg, Register cx1Reg, Register cx2Reg, Register thread,\n-                                 Metadata* method_data) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_lock_lightweight\");\n-  \/\/ Ensure the register assignments are disjoint\n-  assert(tmpReg == rax, \"\");\n-  assert(cx1Reg == noreg, \"\");\n-  assert(cx2Reg == noreg, \"\");\n-  assert_different_registers(objReg, boxReg, tmpReg, scrReg);\n-\n-  \/\/ Possible cases that we'll encounter in fast_lock\n-  \/\/ ------------------------------------------------\n-  \/\/ * Inflated\n-  \/\/    -- unlocked\n-  \/\/    -- Locked\n-  \/\/       = by self\n-  \/\/       = by other\n-  \/\/ * neutral\n-  \/\/ * stack-locked\n-  \/\/    -- by self\n-  \/\/       = sp-proximity test hits\n-  \/\/       = sp-proximity test generates false-negative\n-  \/\/    -- by other\n-  \/\/\n-\n-  Label IsInflated, DONE_LABEL, NO_COUNT, COUNT;\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(tmpReg, objReg, scrReg);\n-    testb(Address(tmpReg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-    jcc(Assembler::notZero, DONE_LABEL);\n-  }\n-\n-  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));          \/\/ [FETCH]\n-  testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral\n-  jcc(Assembler::notZero, IsInflated);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Clear ZF so that we take the slow path at the DONE label. objReg is known to be not 0.\n-    testptr(objReg, objReg);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Attempt stack-locking ...\n-    orptr (tmpReg, markWord::unlocked_value);\n-    movptr(Address(boxReg, 0), tmpReg);          \/\/ Anticipate successful CAS\n-    lock();\n-    cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      \/\/ Updates tmpReg\n-    jcc(Assembler::equal, COUNT);           \/\/ Success\n-\n-    \/\/ Recursive locking.\n-    \/\/ The object is stack-locked: markword contains stack pointer to BasicLock.\n-    \/\/ Locked by current thread if difference with current SP is less than one page.\n-    subptr(tmpReg, rsp);\n-    \/\/ Next instruction set ZFlag == 1 (Success) if difference is less then one page.\n-    andptr(tmpReg, (int32_t) (7 - (int)os::vm_page_size()) );\n-    movptr(Address(boxReg, 0), tmpReg);\n-  }\n-  jmp(DONE_LABEL);\n-\n-  bind(IsInflated);\n-  \/\/ The object is inflated. tmpReg contains pointer to ObjectMonitor* + markWord::monitor_value\n-\n-  \/\/ Unconditionally set box->_displaced_header = markWord::unused_mark().\n-  \/\/ Without cast to int32_t this style of movptr will destroy r10 which is typically obj.\n-  movptr(Address(boxReg, 0), checked_cast<int32_t>(markWord::unused_mark().value()));\n-\n-  \/\/ It's inflated and we use scrReg for ObjectMonitor* in this section.\n-  movptr(boxReg, Address(r15_thread, JavaThread::monitor_owner_id_offset()));\n-  movq(scrReg, tmpReg);\n-  xorq(tmpReg, tmpReg);\n-  lock();\n-  cmpxchgptr(boxReg, Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-\n-  \/\/ Propagate ICC.ZF from CAS above into DONE_LABEL.\n-  jccb(Assembler::equal, COUNT);    \/\/ CAS above succeeded; propagate ZF = 1 (success)\n-\n-  cmpptr(boxReg, rax);                \/\/ Check if we are already the owner (recursive lock)\n-  jccb(Assembler::notEqual, NO_COUNT);    \/\/ If not recursive, ZF = 0 at this point (fail)\n-  incq(Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  xorq(rax, rax); \/\/ Set ZF = 1 (success) for recursive lock, denoting locking success\n-  bind(DONE_LABEL);\n-\n-  \/\/ ZFlag == 1 count in fast path\n-  \/\/ ZFlag == 0 count in slow path\n-  jccb(Assembler::notZero, NO_COUNT); \/\/ jump if ZFlag == 0\n-\n-  bind(COUNT);\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Count monitors in fast path\n-    increment(Address(thread, JavaThread::held_monitor_count_offset()));\n-  }\n-  xorl(tmpReg, tmpReg); \/\/ Set ZF == 1\n-\n-  bind(NO_COUNT);\n-\n-  \/\/ At NO_COUNT the icc ZFlag is set as follows ...\n-  \/\/ fast_unlock uses the same protocol.\n-  \/\/ ZFlag == 1 -> Success\n-  \/\/ ZFlag == 0 -> Failure - force control through the slow path\n-}\n-\n-\/\/ obj: object to unlock\n-\/\/ box: box address (displaced header location), killed.  Must be EAX.\n-\/\/ tmp: killed, cannot be obj nor box.\n-\/\/\n-\/\/ Some commentary on balanced locking:\n-\/\/\n-\/\/ fast_lock and fast_unlock are emitted only for provably balanced lock sites.\n-\/\/ Methods that don't have provably balanced locking are forced to run in the\n-\/\/ interpreter - such methods won't be compiled to use fast_lock and fast_unlock.\n-\/\/ The interpreter provides two properties:\n-\/\/ I1:  At return-time the interpreter automatically and quietly unlocks any\n-\/\/      objects acquired the current activation (frame).  Recall that the\n-\/\/      interpreter maintains an on-stack list of locks currently held by\n-\/\/      a frame.\n-\/\/ I2:  If a method attempts to unlock an object that is not held by the\n-\/\/      the frame the interpreter throws IMSX.\n-\/\/\n-\/\/ Lets say A(), which has provably balanced locking, acquires O and then calls B().\n-\/\/ B() doesn't have provably balanced locking so it runs in the interpreter.\n-\/\/ Control returns to A() and A() unlocks O.  By I1 and I2, above, we know that O\n-\/\/ is still locked by A().\n-\/\/\n-\/\/ The only other source of unbalanced locking would be JNI.  The \"Java Native Interface:\n-\/\/ Programmer's Guide and Specification\" claims that an object locked by jni_monitorenter\n-\/\/ should not be unlocked by \"normal\" java-level locking and vice-versa.  The specification\n-\/\/ doesn't specify what will occur if a program engages in such mixed-mode locking, however.\n-\/\/ Arguably given that the spec legislates the JNI case as undefined our implementation\n-\/\/ could reasonably *avoid* checking owner in fast_unlock().\n-\/\/ In the interest of performance we elide m->Owner==Self check in unlock.\n-\/\/ A perfectly viable alternative is to elide the owner check except when\n-\/\/ Xcheck:jni is enabled.\n-\n-void C2_MacroAssembler::fast_unlock(Register objReg, Register boxReg, Register tmpReg) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"lightweight locking should use fast_unlock_lightweight\");\n-  assert(boxReg == rax, \"\");\n-  assert_different_registers(objReg, boxReg, tmpReg);\n-\n-  Label DONE_LABEL, Stacked, COUNT, NO_COUNT;\n-\n-  if (LockingMode == LM_LEGACY) {\n-    cmpptr(Address(boxReg, 0), NULL_WORD);                            \/\/ Examine the displaced header\n-    jcc   (Assembler::zero, COUNT);                                   \/\/ 0 indicates recursive stack-lock\n-  }\n-  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));   \/\/ Examine the object's markword\n-  if (LockingMode != LM_MONITOR) {\n-    testptr(tmpReg, markWord::monitor_value);                         \/\/ Inflated?\n-    jcc(Assembler::zero, Stacked);\n-  }\n-\n-  \/\/ It's inflated.\n-\n-  \/\/ Despite our balanced locking property we still check that m->_owner == Self\n-  \/\/ as java routines or native JNI code called by this thread might\n-  \/\/ have released the lock.\n-  \/\/\n-  \/\/ If there's no contention try a 1-0 exit.  That is, exit without\n-  \/\/ a costly MEMBAR or CAS.  See synchronizer.cpp for details on how\n-  \/\/ we detect and recover from the race that the 1-0 exit admits.\n-  \/\/\n-  \/\/ Conceptually fast_unlock() must execute a STST|LDST \"release\" barrier\n-  \/\/ before it STs null into _owner, releasing the lock.  Updates\n-  \/\/ to data protected by the critical section must be visible before\n-  \/\/ we drop the lock (and thus before any other thread could acquire\n-  \/\/ the lock and observe the fields protected by the lock).\n-  \/\/ IA32's memory-model is SPO, so STs are ordered with respect to\n-  \/\/ each other and there's no need for an explicit barrier (fence).\n-  \/\/ See also http:\/\/gee.cs.oswego.edu\/dl\/jmm\/cookbook.html.\n-  Label LSuccess, LNotRecursive;\n-\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 0);\n-  jccb(Assembler::equal, LNotRecursive);\n-\n-  \/\/ Recursive inflated unlock\n-  decrement(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  jmpb(LSuccess);\n-\n-  bind(LNotRecursive);\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  \/\/ StoreLoad achieves this.\n-  membar(StoreLoad);\n-\n-  \/\/ Check if the entry_list is empty.\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(entry_list)), NULL_WORD);\n-  jccb(Assembler::zero, LSuccess);    \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n-  jccb(Assembler::notZero, LSuccess); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  andptr(tmpReg, ~(int32_t)markWord::monitor_value);\n-  movptr(Address(r15_thread, JavaThread::unlocked_inflated_monitor_offset()), tmpReg);\n-\n-  orl   (boxReg, 1);                      \/\/ set ICC.ZF=0 to indicate failure\n-  jmpb  (DONE_LABEL);\n-\n-  bind  (LSuccess);\n-  testl (boxReg, 0);                      \/\/ set ICC.ZF=1 to indicate success\n-  jmpb  (DONE_LABEL);\n-\n-  if (LockingMode == LM_LEGACY) {\n-    bind  (Stacked);\n-    movptr(tmpReg, Address (boxReg, 0));      \/\/ re-fetch\n-    lock();\n-    cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Uses RAX which is box\n-    \/\/ Intentional fall-thru into DONE_LABEL\n-  }\n-\n-  bind(DONE_LABEL);\n-\n-  \/\/ ZFlag == 1 count in fast path\n-  \/\/ ZFlag == 0 count in slow path\n-  jccb(Assembler::notZero, NO_COUNT);\n-\n-  bind(COUNT);\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Count monitors in fast path\n-    decrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-  }\n-\n-  xorl(tmpReg, tmpReg); \/\/ Set ZF == 1\n-\n-  bind(NO_COUNT);\n-}\n-\n+\/\/ box: on-stack box address -- KILLED\n+\/\/ rax: tmp -- KILLED\n+\/\/ t  : tmp -- KILLED\n@@ -459,1 +227,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -619,0 +386,32 @@\n+\/\/ obj: object to lock\n+\/\/ rax: tmp -- KILLED\n+\/\/ t  : tmp - cannot be obj nor rax -- KILLED\n+\/\/\n+\/\/ Some commentary on balanced locking:\n+\/\/\n+\/\/ fast_lock and fast_unlock are emitted only for provably balanced lock sites.\n+\/\/ Methods that don't have provably balanced locking are forced to run in the\n+\/\/ interpreter - such methods won't be compiled to use fast_lock and fast_unlock.\n+\/\/ The interpreter provides two properties:\n+\/\/ I1:  At return-time the interpreter automatically and quietly unlocks any\n+\/\/      objects acquired in the current activation (frame).  Recall that the\n+\/\/      interpreter maintains an on-stack list of locks currently held by\n+\/\/      a frame.\n+\/\/ I2:  If a method attempts to unlock an object that is not held by the\n+\/\/      frame the interpreter throws IMSX.\n+\/\/\n+\/\/ Lets say A(), which has provably balanced locking, acquires O and then calls B().\n+\/\/ B() doesn't have provably balanced locking so it runs in the interpreter.\n+\/\/ Control returns to A() and A() unlocks O.  By I1 and I2, above, we know that O\n+\/\/ is still locked by A().\n+\/\/\n+\/\/ The only other source of unbalanced locking would be JNI.  The \"Java Native Interface\n+\/\/ Specification\" states that an object locked by JNI's MonitorEnter should not be\n+\/\/ unlocked by \"normal\" java-level locking and vice-versa.  The specification doesn't\n+\/\/ specify what will occur if a program engages in such mixed-mode locking, however.\n+\/\/ Arguably given that the spec legislates the JNI case as undefined our implementation\n+\/\/ could reasonably *avoid* checking owner in fast_unlock().\n+\/\/ In the interest of performance we elide m->Owner==Self check in unlock.\n+\/\/ A perfectly viable alternative is to elide the owner check except when\n+\/\/ Xcheck:jni is enabled.\n+\n@@ -620,1 +419,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":35,"deletions":237,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -37,6 +37,1 @@\n-  \/\/ See full description in macroAssembler_x86.cpp.\n-  void fast_lock(Register obj, Register box, Register tmp,\n-                 Register scr, Register cx1, Register cx2, Register thread,\n-                 Metadata* method_data);\n-  void fast_unlock(Register obj, Register box, Register tmp);\n-\n+  \/\/ See full description in c2_MacroAssembler_x86.cpp.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,3 +101,6 @@\n-    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n-    \/\/ had a safepoint in finalize_freeze, after constructing f.\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+    \/\/ For a compiled frame we need to re-read fp out of the frame because it may be an\n+    \/\/ oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ For stub\/native frames the value is not used while frozen, and will be constructed again\n+    \/\/ when thawing the frame (see ThawBase::new_stack_frame). We use a special bad address to\n+    \/\/ help with debugging, particularly when inspecting frames and identifying invalid accesses.\n+    fp = FKind::compiled ? *(intptr_t**)(f.sp() - frame::sender_sp_offset) : (intptr_t*)badAddressVal;\n@@ -186,0 +189,5 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  intptr_t* fp_addr = sp - frame::sender_sp_offset;\n+  *fp_addr = badAddressVal;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-    __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), 2);\n+    __ MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), 1);\n@@ -281,1 +281,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), c_rarg0, thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), c_rarg0);\n@@ -949,1 +949,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), rcx, thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), rcx);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1027,28 +1027,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n-  } else {\n-    Label count_locking, done, slow_case;\n-\n-    const Register swap_reg = rax; \/\/ Must use rax for cmpxchg instruction\n-    const Register tmp_reg = rbx;\n-    const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n-    const Register rklass_decode_tmp = rscratch1;\n-\n-    const int obj_offset = in_bytes(BasicObjectLock::obj_offset());\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset +\n-                            BasicLock::displaced_header_offset_in_bytes();\n-\n-    \/\/ Load object pointer into obj_reg\n-    movptr(obj_reg, Address(lock_reg, obj_offset));\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_lock(lock_reg, obj_reg, swap_reg, tmp_reg, slow_case);\n-    } else if (LockingMode == LM_LEGACY) {\n-      if (DiagnoseSyncOnValueBasedClasses != 0) {\n-        load_klass(tmp_reg, obj_reg, rklass_decode_tmp);\n-        testb(Address(tmp_reg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-        jcc(Assembler::notZero, slow_case);\n-      }\n+  Label done, slow_case;\n@@ -1056,56 +1029,3 @@\n-      \/\/ Load immediate 1 into swap_reg %rax\n-      movl(swap_reg, 1);\n-\n-      \/\/ Load (object->mark() | 1) into swap_reg %rax\n-      orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      movptr(Address(lock_reg, mark_offset), swap_reg);\n-\n-      assert(lock_offset == 0,\n-             \"displaced header must be first word in BasicObjectLock\");\n-\n-      lock();\n-      cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      jcc(Assembler::zero, count_locking);\n-\n-      const int zero_bits = 7;\n-\n-      \/\/ Fast check for recursive lock.\n-      \/\/\n-      \/\/ Can apply the optimization only if this is a stack lock\n-      \/\/ allocated in this thread. For efficiency, we can focus on\n-      \/\/ recently allocated stack locks (instead of reading the stack\n-      \/\/ base and checking whether 'mark' points inside the current\n-      \/\/ thread stack):\n-      \/\/  1) (mark & zero_bits) == 0, and\n-      \/\/  2) rsp <= mark < mark + os::pagesize()\n-      \/\/\n-      \/\/ Warning: rsp + os::pagesize can overflow the stack base. We must\n-      \/\/ neither apply the optimization for an inflated lock allocated\n-      \/\/ just above the thread stack (this is why condition 1 matters)\n-      \/\/ nor apply the optimization if the stack lock is inside the stack\n-      \/\/ of another thread. The latter is avoided even in case of overflow\n-      \/\/ because we have guard pages at the end of all stacks. Hence, if\n-      \/\/ we go over the stack base and hit the stack of another thread,\n-      \/\/ this should not be in a writeable area that could contain a\n-      \/\/ stack lock allocated by that thread. As a consequence, a stack\n-      \/\/ lock less than page size away from rsp is guaranteed to be\n-      \/\/ owned by the current thread.\n-      \/\/\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - rsp) & (zero_bits - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant bits clear.\n-      \/\/ NOTE: the mark is in swap_reg %rax as the result of cmpxchg\n-      subptr(swap_reg, rsp);\n-      andptr(swap_reg, zero_bits - (int)os::vm_page_size());\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      movptr(Address(lock_reg, mark_offset), swap_reg);\n-      jcc(Assembler::notZero, slow_case);\n-\n-      bind(count_locking);\n-      inc_held_monitor_count();\n-    }\n-    jmp(done);\n+  const Register swap_reg = rax; \/\/ Must use rax for cmpxchg instruction\n+  const Register tmp_reg = rbx;\n+  const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n@@ -1113,1 +1033,2 @@\n-    bind(slow_case);\n+  \/\/ Load object pointer into obj_reg\n+  movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -1115,6 +1036,10 @@\n-    \/\/ Call the runtime routine for slow case\n-    call_VM_preemptable(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            lock_reg);\n-    bind(done);\n-  }\n+  lightweight_lock(lock_reg, obj_reg, swap_reg, tmp_reg, slow_case);\n+  jmp(done);\n+\n+  bind(slow_case);\n+\n+  \/\/ Call the runtime routine for slow case\n+  call_VM_preemptable(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          lock_reg);\n+  bind(done);\n@@ -1139,4 +1064,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n-  } else {\n-    Label count_locking, done, slow_case;\n+  Label done, slow_case;\n@@ -1144,3 +1066,3 @@\n-    const Register swap_reg   = rax;  \/\/ Must use rax for cmpxchg instruction\n-    const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n-    const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n+  const Register swap_reg   = rax;  \/\/ Must use rax for cmpxchg instruction\n+  const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n+  const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n@@ -1148,7 +1070,1 @@\n-    save_bcp(); \/\/ Save in case of exception\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Convert from BasicObjectLock structure to object and BasicLock\n-      \/\/ structure Store the BasicLock address into %rax\n-      lea(swap_reg, Address(lock_reg, BasicObjectLock::lock_offset()));\n-    }\n+  save_bcp(); \/\/ Save in case of exception\n@@ -1156,2 +1072,2 @@\n-    \/\/ Load oop into obj_reg(%c_rarg3)\n-    movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n+  \/\/ Load oop into obj_reg(%c_rarg3)\n+  movptr(obj_reg, Address(lock_reg, BasicObjectLock::obj_offset()));\n@@ -1159,2 +1075,2 @@\n-    \/\/ Free entry\n-    movptr(Address(lock_reg, BasicObjectLock::obj_offset()), NULL_WORD);\n+  \/\/ Free entry\n+  movptr(Address(lock_reg, BasicObjectLock::obj_offset()), NULL_WORD);\n@@ -1162,24 +1078,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load the old header from BasicLock structure\n-      movptr(header_reg, Address(swap_reg,\n-                                 BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Test for recursion\n-      testptr(header_reg, header_reg);\n-\n-      \/\/ zero for recursive case\n-      jcc(Assembler::zero, count_locking);\n-\n-      \/\/ Atomic swap back the old header\n-      lock();\n-      cmpxchgptr(header_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-      \/\/ zero for simple unlock of a stack-lock case\n-      jcc(Assembler::notZero, slow_case);\n-\n-      bind(count_locking);\n-      dec_held_monitor_count();\n-    }\n-    jmp(done);\n+  lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n+  jmp(done);\n@@ -1187,4 +1081,4 @@\n-    bind(slow_case);\n-    \/\/ Call the runtime routine for slow case.\n-    movptr(Address(lock_reg, BasicObjectLock::obj_offset()), obj_reg); \/\/ restore obj\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n+  bind(slow_case);\n+  \/\/ Call the runtime routine for slow case.\n+  movptr(Address(lock_reg, BasicObjectLock::obj_offset()), obj_reg); \/\/ restore obj\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), lock_reg);\n@@ -1192,1 +1086,1 @@\n-    bind(done);\n+  bind(done);\n@@ -1194,2 +1088,1 @@\n-    restore_bcp();\n-  }\n+  restore_bcp();\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":33,"deletions":140,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -6030,26 +6030,40 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeISOArray(byte[] sa, int sp,\n-   \/\/byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = StringUTF16.getChar(sa, sp++);\n-   \/\/    if (c > '\\u00FF')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n-   \/\/\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n-   \/\/    byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = sa[sp++];\n-   \/\/    if (c >= '\\u0080')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n+\/\/ Encode given char[]\/byte[] to byte[] in ISO_8859_1 or ASCII\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/     int i = 0;\n+\/\/     for (; i < len; i++) {\n+\/\/         char c = sa[sp++];\n+\/\/         if (c > '\\u00FF')\n+\/\/             break;\n+\/\/         da[dp++] = (byte) c;\n+\/\/     }\n+\/\/     return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeISOArray0(\n+\/\/         byte[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = StringUTF16.getChar(sa, sp++);\n+\/\/     if (c > '\\u00FF')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeAsciiArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = sa[sp++];\n+\/\/     if (c >= '\\u0080')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":40,"deletions":26,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-        __ jccb(Assembler::equal, L_ok);\n+        __ jcc(Assembler::equal, L_ok);\n@@ -157,1 +157,1 @@\n-        __ jccb(Assembler::notZero, L_ok);\n+        __ jcc(Assembler::notZero, L_ok);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,11 +62,4 @@\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if (!UseObjectMonitorTable) {\n-      \/\/ check if monitor\n-      __ testptr(result, markWord::monitor_value);\n-      __ jcc(Assembler::notZero, slowCase);\n-    }\n-  } else {\n-    \/\/ check if locked\n-    __ testptr(result, markWord::unlocked_value);\n-    __ jcc(Assembler::zero, slowCase);\n+  if (!UseObjectMonitorTable) {\n+    \/\/ check if monitor\n+    __ testptr(result, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, slowCase);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2136,1 +2136,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -2177,1 +2177,0 @@\n-  const Register old_hdr  = r13;  \/\/ value of old header at unlock time\n@@ -2183,4 +2182,0 @@\n-    Label count_mon;\n-\n-    const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();\n-\n@@ -2197,41 +2192,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ jmp(slow_path_lock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Load immediate 1 into swap_reg %rax\n-      __ movl(swap_reg, 1);\n-\n-      \/\/ Load (object->mark() | 1) into swap_reg %rax\n-      __ orptr(swap_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-\n-      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-\n-      \/\/ src -> dest iff dest == rax else rax <- dest\n-      __ lock();\n-      __ cmpxchgptr(lock_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ jcc(Assembler::equal, count_mon);\n-\n-      \/\/ Hmm should this move to the slow path code area???\n-\n-      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-      \/\/  1) (mark & 3) == 0, and\n-      \/\/  2) rsp <= mark < mark + os::pagesize()\n-      \/\/ These 3 tests can be done by evaluating the following\n-      \/\/ expression: ((mark - rsp) & (3 - os::vm_page_size())),\n-      \/\/ assuming both stack pointer and pagesize have their\n-      \/\/ least significant 2 bits clear.\n-      \/\/ NOTE: the oopMark is in swap_reg %rax as the result of cmpxchg\n-\n-      __ subptr(swap_reg, rsp);\n-      __ andptr(swap_reg, 3 - (int)os::vm_page_size());\n-\n-      \/\/ Save the test result, for recursive case, the result is zero\n-      __ movptr(Address(lock_reg, mark_word_offset), swap_reg);\n-      __ jcc(Assembler::notEqual, slow_path_lock);\n-\n-      __ bind(count_mon);\n-      __ inc_held_monitor_count();\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_lock(lock_reg, obj_reg, swap_reg, rscratch1, slow_path_lock);\n-    }\n+    __ lightweight_lock(lock_reg, obj_reg, swap_reg, rscratch1, slow_path_lock);\n@@ -2325,1 +2280,1 @@\n-  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+  if (method->is_object_wait0()) {\n@@ -2357,10 +2312,0 @@\n-    if (LockingMode == LM_LEGACY) {\n-      Label not_recur;\n-      \/\/ Simple recursive lock?\n-      __ cmpptr(Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size), NULL_WORD);\n-      __ jcc(Assembler::notEqual, not_recur);\n-      __ dec_held_monitor_count();\n-      __ jmpb(fast_done);\n-      __ bind(not_recur);\n-    }\n-\n@@ -2372,17 +2317,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ jmp(slow_path_unlock);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ get address of the stack lock\n-      __ lea(rax, Address(rsp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-      \/\/  get old displaced header\n-      __ movptr(old_hdr, Address(rax, 0));\n-\n-      \/\/ Atomic swap old header if oop still contains the stack lock\n-      __ lock();\n-      __ cmpxchgptr(old_hdr, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-      __ jcc(Assembler::notEqual, slow_path_unlock);\n-      __ dec_held_monitor_count();\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n-    }\n+    __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":4,"deletions":75,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -4334,1 +4334,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_sort\" : \"avx2_sort\");\n+      os::snprintf_checked(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_sort\" : \"avx2_sort\");\n@@ -4337,1 +4337,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_partition\" : \"avx2_partition\");\n+      os::snprintf_checked(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_partition\" : \"avx2_partition\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1020,15 +1020,10 @@\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Check preemption for Object.wait()\n-    Label not_preempted;\n-    __ movptr(rscratch1, Address(r15_thread, JavaThread::preempt_alternate_return_offset()));\n-    __ cmpptr(rscratch1, NULL_WORD);\n-    __ jccb(Assembler::equal, not_preempted);\n-    __ movptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n-    __ jmp(rscratch1);\n-    __ bind(native_return);\n-    __ restore_after_resume(true \/* is_native *\/);\n-    __ bind(not_preempted);\n-  } else {\n-    \/\/ any pc will do so just use this one for LM_LEGACY to keep code together.\n-    __ bind(native_return);\n-  }\n+  \/\/ Check preemption for Object.wait()\n+  Label not_preempted;\n+  __ movptr(rscratch1, Address(r15_thread, JavaThread::preempt_alternate_return_offset()));\n+  __ cmpptr(rscratch1, NULL_WORD);\n+  __ jccb(Assembler::equal, not_preempted);\n+  __ movptr(Address(r15_thread, JavaThread::preempt_alternate_return_offset()), NULL_WORD);\n+  __ jmp(rscratch1);\n+  __ bind(native_return);\n+  __ restore_after_resume(true \/* is_native *\/);\n+  __ bind(not_preempted);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1102,2 +1102,6 @@\n-  ss.print(\"(%u cores per cpu, %u threads per core) family %d model %d stepping %d microcode 0x%x\",\n-           cores_per_cpu(), threads_per_core(),\n+  if (supports_hybrid()) {\n+    ss.print(\"(hybrid)\");\n+  } else {\n+    ss.print(\"(%u cores per cpu, %u threads per core)\", cores_per_cpu(), threads_per_core());\n+  }\n+  ss.print(\" family %d model %d stepping %d microcode 0x%x\",\n@@ -1664,1 +1668,1 @@\n-    if (MaxVectorSize < 32 || !VM_Version::supports_avx512vlbw()) {\n+    if (MaxVectorSize < 32 || (!EnableX86ECoreOpts && !VM_Version::supports_avx512vlbw())) {\n@@ -3046,0 +3050,2 @@\n+    if (sef_cpuid7_edx.bits.hybrid != 0)\n+      vm_features.set_feature(CPU_HYBRID);\n@@ -3145,1 +3151,4 @@\n-    result = (_cpuid_info.ext_cpuid8_ecx.bits.cores_per_cpu + 1);\n+    result = _cpuid_info.ext_cpuid8_ecx.bits.threads_per_cpu + 1;\n+    if (cpu_family() >= 0x17) { \/\/ Zen or later\n+      result \/= _cpuid_info.ext_cpuid1E_ebx.bits.threads_per_core + 1;\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -202,2 +202,2 @@\n-      uint32_t cores_per_cpu : 8,\n-                             : 24;\n+      uint32_t threads_per_cpu : 8,\n+                               : 24;\n@@ -279,1 +279,2 @@\n-                           : 5,\n+                     hybrid: 1,\n+                           : 4,\n@@ -447,1 +448,2 @@\n-    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n+    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/ \\\n+    decl(HYBRID,            \"hybrid\",            65) \/* Hybrid architecture *\/\n@@ -880,0 +882,1 @@\n+  static bool supports_hybrid()       { return _features.supports_feature(CPU_HYBRID); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -14076,25 +14076,0 @@\n-instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastLock object box));\n-  effect(TEMP tmp, TEMP scr, USE_KILL box);\n-  ins_cost(300);\n-  format %{ \"fastlock $object,$box\\t! kills $box,$tmp,$scr\" %}\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,\n-                 $scr$$Register, noreg, noreg, r15_thread, nullptr);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set cr (FastUnlock object box));\n-  effect(TEMP tmp, USE_KILL box);\n-  ins_cost(300);\n-  format %{ \"fastunlock $object,$box\\t! kills $box,$tmp\" %}\n-  ins_encode %{\n-    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -14102,1 +14077,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -14114,1 +14088,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+inline void FreezeBase::patch_pd_unused(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,2 +245,2 @@\n-    snprintf(fieldbuf, buflen, \"word[%d]\", offset);\n-    snprintf(valuebuf, buflen, PTR_FORMAT, *addr);\n+    os::snprintf_checked(fieldbuf, buflen, \"word[%d]\", offset);\n+    os::snprintf_checked(valuebuf, buflen, PTR_FORMAT, *addr);\n@@ -303,1 +303,1 @@\n-    snprintf(fieldbuf, buflen, \"local[%d]\", offset - 3);\n+    os::snprintf_checked(fieldbuf, buflen, \"local[%d]\", offset - 3);\n@@ -324,3 +324,3 @@\n-        snprintf(valuebuf, buflen, PTR_FORMAT \" (bci %d)\",\n-                 (intptr_t) istate->bcp(),\n-                 istate->method()->bci_from(istate->bcp()));\n+        os::snprintf_checked(valuebuf, buflen, PTR_FORMAT \" (bci %d)\",\n+                             (intptr_t) istate->bcp(),\n+                             istate->method()->bci_from(istate->bcp()));\n@@ -328,2 +328,2 @@\n-      snprintf(fieldbuf, buflen, \"%sistate->%s\",\n-               field[strlen(field) - 1] == ')' ? \"(\": \"\", field);\n+      os::snprintf_checked(fieldbuf, buflen, \"%sistate->%s\",\n+                           field[strlen(field) - 1] == ')' ? \"(\": \"\", field);\n@@ -361,1 +361,1 @@\n-          snprintf(fieldbuf, buflen, \"parameter[%d]%s\", param, desc);\n+          os::snprintf_checked(fieldbuf, buflen, \"parameter[%d]%s\", param, desc);\n@@ -367,1 +367,1 @@\n-            snprintf(fieldbuf, buflen, \"unboxed parameter[%d]\", i);\n+            os::snprintf_checked(fieldbuf, buflen, \"unboxed parameter[%d]\", i);\n@@ -399,1 +399,1 @@\n-      snprintf(fieldbuf, buflen, \"monitor[%d]->_obj\", index);\n+      os::snprintf_checked(fieldbuf, buflen, \"monitor[%d]->_obj\", index);\n@@ -401,1 +401,1 @@\n-      snprintf(fieldbuf, buflen, \"monitor[%d]->_lock\", index);\n+      os::snprintf_checked(fieldbuf, buflen, \"monitor[%d]->_lock\", index);\n@@ -408,3 +408,3 @@\n-    snprintf(fieldbuf, buflen, \"%s[%d]\",\n-             frame_index == 0 ? \"stack_word\" : \"local\",\n-             (int) (stack_base - addr - 1));\n+    os::snprintf_checked(fieldbuf, buflen, \"%s[%d]\",\n+                         frame_index == 0 ? \"stack_word\" : \"local\",\n+                         (int) (stack_base - addr - 1));\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  \/\/ foil any attempt to call the i2c, c2i or unverified c2i entries\n@@ -63,1 +64,0 @@\n-  return;\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  do_arch_blob(initial, 32)                                             \\\n+  do_arch_blob(initial, 0)                                              \\\n@@ -61,1 +61,1 @@\n-  do_arch_blob(final, 32)                                               \\\n+  do_arch_blob(final, 0)                                                \\\n","filename":"src\/hotspot\/cpu\/zero\/stubDeclarations_zero.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -334,20 +334,3 @@\n-    oop lockee = monitor->obj();\n-    bool success = false;\n-    if (LockingMode == LM_LEGACY) {\n-      markWord disp = lockee->mark().set_unlocked();\n-      monitor->lock()->set_displaced_header(disp);\n-      success = true;\n-      if (lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n-        \/\/ Is it simple recursive case?\n-        if (thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n-          monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-        } else {\n-          success = false;\n-        }\n-      }\n-    }\n-    if (!success) {\n-      CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n-          if (HAS_PENDING_EXCEPTION)\n-            goto unwind_and_return;\n-    }\n+    CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n+    if (HAS_PENDING_EXCEPTION)\n+      goto unwind_and_return;\n@@ -484,18 +467,1 @@\n-    bool success = false;\n-    if (LockingMode == LM_LEGACY) {\n-      BasicLock* lock = monitor->lock();\n-      oop rcvr = monitor->obj();\n-      monitor->set_obj(nullptr);\n-      success = true;\n-      markWord header = lock->displaced_header();\n-      if (header.to_pointer() != nullptr) { \/\/ Check for recursive lock\n-        markWord old_header = markWord::encode(lock);\n-        if (rcvr->cas_set_mark(header, old_header) != old_header) {\n-          monitor->set_obj(rcvr);\n-          success = false;\n-        }\n-      }\n-    }\n-    if (!success) {\n-      InterpreterRuntime::monitorexit(monitor);\n-    }\n+    InterpreterRuntime::monitorexit(monitor);\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":4,"deletions":38,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -212,2 +212,2 @@\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n+  int n = os::snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -215,1 +215,1 @@\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n+    n = os::snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n@@ -352,3 +352,2 @@\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n+  os::snprintf_checked(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -422,2 +421,2 @@\n-    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\",\n-             os::get_temp_directory(), os::current_process_id());\n+    os::snprintf_checked(fn, sizeof(fn), \"%s\/.attach_pid%d\",\n+                         os::get_temp_directory(), os::current_process_id());\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-julong    os::Aix::_physical_memory = 0;\n+size_t    os::Aix::_physical_memory = 0;\n@@ -257,2 +257,2 @@\n-julong os::free_memory() {\n-  return Aix::available_memory();\n+bool os::free_memory(size_t& value) {\n+  return Aix::available_memory(value);\n@@ -261,2 +261,2 @@\n-julong os::available_memory() {\n-  return Aix::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return Aix::available_memory(value);\n@@ -265,1 +265,1 @@\n-julong os::Aix::available_memory() {\n+bool os::Aix::available_memory(size_t& value) {\n@@ -268,1 +268,2 @@\n-    return mi.real_free;\n+    value = static_cast<size_t>(mi.real_free);\n+    return true;\n@@ -270,1 +271,1 @@\n-    return ULONG_MAX;\n+    return false;\n@@ -274,1 +275,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -277,1 +278,1 @@\n-    return -1;\n+    return false;\n@@ -279,1 +280,2 @@\n-  return (jlong)(memory_info.pgsp_total * 4 * K);\n+  value = static_cast<size_t>(memory_info.pgsp_total * 4 * K);\n+  return true;\n@@ -282,1 +284,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -285,1 +287,1 @@\n-    return -1;\n+    return false;\n@@ -287,1 +289,2 @@\n-  return (jlong)(memory_info.pgsp_free * 4 * K);\n+  value = static_cast<size_t>(memory_info.pgsp_free * 4 * K);\n+  return true;\n@@ -290,1 +293,1 @@\n-julong os::physical_memory() {\n+size_t os::physical_memory() {\n@@ -329,1 +332,1 @@\n-  _physical_memory = (julong) mi.real_total;\n+  _physical_memory = static_cast<size_t>(mi.real_total);\n@@ -1054,2 +1057,2 @@\n-      snprintf(ebuf, ebuflen - 1, \"%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s\",\n-               filename, ::getenv(\"LIBPATH\"), ::getenv(\"LD_LIBRARY_PATH\"), error_report);\n+      os::snprintf_checked(ebuf, ebuflen - 1, \"%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s\",\n+                           filename, ::getenv(\"LIBPATH\"), ::getenv(\"LD_LIBRARY_PATH\"), error_report);\n@@ -1080,1 +1083,1 @@\n-      os::snprintf(tmp_path + prefix_size, sizeof(old_extension), \"%s\", new_extension);\n+      os::snprintf_checked(tmp_path + prefix_size, sizeof(old_extension), \"%s\", new_extension);\n@@ -1097,1 +1100,1 @@\n-  snprintf(buf, buflen, \"%s %s\", name.release, name.version);\n+  os::snprintf_checked(buf, buflen, \"%s %s\", name.release, name.version);\n@@ -2196,1 +2199,1 @@\n-  trcVerbose(\"physical memory: %lu\", Aix::_physical_memory);\n+  trcVerbose(\"physical memory: %zu\", Aix::_physical_memory);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -57,3 +57,3 @@\n-  static julong available_memory();\n-  static julong free_memory();\n-  static julong physical_memory() { return _physical_memory; }\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -939,1 +939,1 @@\n-  snprintf(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n+  os::snprintf_checked(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n@@ -1157,1 +1157,1 @@\n-        snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+        os::snprintf_checked(ebuf, ebuflen - 1, \"%s\", error_report);\n@@ -1192,1 +1192,0 @@\n-\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-        snprintf(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n+        os::snprintf_checked(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-julong os::Bsd::_physical_memory = 0;\n+size_t os::Bsd::_physical_memory = 0;\n@@ -136,2 +136,2 @@\n-julong os::available_memory() {\n-  return Bsd::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return Bsd::available_memory(value);\n@@ -140,2 +140,2 @@\n-julong os::free_memory() {\n-  return Bsd::available_memory();\n+bool os::free_memory(size_t& value) {\n+  return Bsd::available_memory(value);\n@@ -147,2 +147,2 @@\n-julong os::Bsd::available_memory() {\n-  uint64_t available = physical_memory() >> 2;\n+bool os::Bsd::available_memory(size_t& value) {\n+  uint64_t available = static_cast<uint64_t>(physical_memory() >> 2);\n@@ -159,0 +159,2 @@\n+  } else {\n+    return false;\n@@ -161,1 +163,2 @@\n-  return available;\n+  value = static_cast<size_t>(available);\n+  return true;\n@@ -180,1 +183,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -185,1 +188,1 @@\n-    return -1;\n+    return false;\n@@ -187,1 +190,2 @@\n-  return (jlong)vmusage.xsu_total;\n+  value = static_cast<size_t>(vmusage.xsu_total);\n+  return true;\n@@ -189,1 +193,1 @@\n-  return -1;\n+  return false;\n@@ -193,1 +197,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -198,1 +202,1 @@\n-    return -1;\n+    return false;\n@@ -200,1 +204,2 @@\n-  return (jlong)vmusage.xsu_avail;\n+  value = static_cast<size_t>(vmusage.xsu_avail);\n+  return true;\n@@ -202,1 +207,1 @@\n-  return -1;\n+  return false;\n@@ -206,1 +211,1 @@\n-julong os::physical_memory() {\n+size_t os::physical_memory() {\n@@ -284,1 +289,1 @@\n-    _physical_memory = mem_val;\n+    _physical_memory = static_cast<size_t>(mem_val);\n@@ -295,1 +300,1 @@\n-    _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);\n+    _physical_memory = MIN2(_physical_memory, static_cast<size_t>(limits.rlim_cur));\n@@ -525,1 +530,1 @@\n-          user_home_dir, Arguments::get_java_home());\n+                       user_home_dir, Arguments::get_java_home());\n@@ -1245,1 +1250,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n@@ -1251,1 +1256,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n@@ -1258,3 +1263,3 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n-                 lib_arch.name, arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n+                           lib_arch.name, arch_array[running_arch_index].name);\n@@ -1262,4 +1267,4 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n-                 lib_arch.code,\n-                 arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n+                           lib_arch.code,\n+                           arch_array[running_arch_index].name);\n@@ -1367,1 +1372,1 @@\n-      snprintf(buf, buflen, \"%s %s, macOS %s\", os, release, osproductversion);\n+      os::snprintf_checked(buf, buflen, \"%s %s, macOS %s\", os, release, osproductversion);\n@@ -1369,1 +1374,1 @@\n-      snprintf(buf, buflen, \"%s %s, macOS %s (%s)\", os, release, osproductversion, build);\n+      os::snprintf_checked(buf, buflen, \"%s %s, macOS %s (%s)\", os, release, osproductversion, build);\n@@ -1373,1 +1378,1 @@\n-  snprintf(buf, buflen, \"%s %s\", os, release);\n+  os::snprintf_checked(buf, buflen, \"%s %s\", os, release);\n@@ -1450,1 +1455,1 @@\n-    snprintf(buf, buflen, \"\\\"%s\\\" %s (EMULATED) %d MHz\", model, machine, mhz);\n+    os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s (EMULATED) %d MHz\", model, machine, mhz);\n@@ -1452,1 +1457,1 @@\n-    NOT_AARCH64(snprintf(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz));\n+    NOT_AARCH64(os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz));\n@@ -1454,1 +1459,1 @@\n-    AARCH64_ONLY(snprintf(buf, buflen, \"\\\"%s\\\" %s\", model, machine));\n+    AARCH64_ONLY(os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s\", model, machine));\n@@ -1457,1 +1462,1 @@\n-  snprintf(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz);\n+  os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz);\n@@ -1467,5 +1472,7 @@\n-\n-  st->print(\", physical \" UINT64_FORMAT \"k\",\n-            os::physical_memory() >> 10);\n-  st->print(\"(\" UINT64_FORMAT \"k free)\",\n-            os::available_memory() >> 10);\n+  size_t phys_mem = os::physical_memory();\n+  st->print(\", physical %zuk\",\n+            phys_mem >> 10);\n+  size_t avail_mem = 0;\n+  (void)os::available_memory(avail_mem);\n+  st->print(\"(%zuk free)\",\n+            avail_mem >> 10);\n@@ -2159,1 +2166,1 @@\n-    snprintf(buf, sizeof(buf), \"Java: %s\", name);\n+    (void) os::snprintf(buf, sizeof(buf), \"Java: %s\", name);\n@@ -2493,1 +2500,1 @@\n-      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      os::snprintf_checked(ebuf, ebuflen - 1, \"%s\", error_report);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":50,"deletions":43,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -48,3 +48,3 @@\n-  static julong available_memory();\n-  static julong free_memory();\n-  static julong physical_memory() { return _physical_memory; }\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,4 +25,0 @@\n-#include <string.h>\n-#include <math.h>\n-#include <errno.h>\n-#include <sys\/vfs.h>\n@@ -30,0 +26,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -32,1 +29,0 @@\n-#include \"cgroupUtil_linux.hpp\"\n@@ -40,0 +36,5 @@\n+#include <errno.h>\n+#include <math.h>\n+#include <string.h>\n+#include <sys\/vfs.h>\n+\n@@ -673,2 +674,2 @@\n-  jlong phys_mem = os::Linux::physical_memory();\n-  log_trace(os, container)(\"total physical memory: \" JLONG_FORMAT, phys_mem);\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  log_trace(os, container)(\"total physical memory: \" JULONG_FORMAT, phys_mem);\n@@ -844,1 +845,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n@@ -850,1 +851,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n@@ -856,1 +857,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n@@ -897,1 +898,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/log.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"osContainer_linux.hpp\"\n@@ -30,1 +32,0 @@\n-#include \"logging\/log.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"osContainer_linux.hpp\"\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"os_linux.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"os_linux.hpp\"\n@@ -68,1 +68,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,4 +25,0 @@\n-#include <string.h>\n-#include <math.h>\n-#include <errno.h>\n-#include \"cgroupV1Subsystem_linux.hpp\"\n@@ -30,0 +26,1 @@\n+#include \"cgroupV1Subsystem_linux.hpp\"\n@@ -32,0 +29,1 @@\n+#include \"os_linux.hpp\"\n@@ -35,1 +33,4 @@\n-#include \"os_linux.hpp\"\n+\n+#include <errno.h>\n+#include <math.h>\n+#include <string.h>\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"runtime\/os.hpp\"\n-#include \"memory\/allocation.hpp\"\n@@ -32,0 +30,2 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cgroupV2Subsystem_linux.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"cgroupV2Subsystem_linux.hpp\"\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compilerThreadTimeout_linux.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"signals_posix.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <pthread.h>\n+\n+#ifdef ASSERT\n+void compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+  CompilerThread::current()->timeout()->compiler_signal_handler(signo, info, context);\n+}\n+\n+void CompilerThreadTimeoutLinux::compiler_signal_handler(int signo, siginfo_t* info, void* context) {\n+  switch (signo) {\n+    case TIMEOUT_SIGNAL: {\n+      CompileTask* task = CompilerThread::current()->task();\n+      const int SIZE = 512;\n+      char method_name_buf[SIZE];\n+      task->method()->name_and_sig_as_C_string(method_name_buf, SIZE);\n+      assert(false, \"compile task %d (%s) timed out after %zd ms\",\n+             task->compile_id(), method_name_buf, CompileTaskTimeout);\n+    }\n+    default: {\n+      assert(false, \"unexpected signal %d\", signo);\n+    }\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+void CompilerThreadTimeoutLinux::arm() {\n+#ifdef ASSERT\n+  if (CompileTaskTimeout == 0) {\n+    return;\n+  }\n+\n+  const intx sec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) \/ NANOSECS_PER_SEC;\n+  const intx nsec = (CompileTaskTimeout * NANOSECS_PER_MILLISEC) % NANOSECS_PER_SEC;\n+  const struct timespec ts = {.tv_sec = sec, .tv_nsec = nsec};\n+  const struct itimerspec its {.it_interval = ts, .it_value = ts};\n+\n+  \/\/ Start the timer.\n+  timer_settime(_timer, 0, &its, nullptr);\n+#endif \/\/ ASSERT\n+}\n+\n+void CompilerThreadTimeoutLinux::disarm() {\n+#ifdef ASSERT\n+  if (CompileTaskTimeout == 0) {\n+    return;\n+  }\n+\n+  \/\/ Reset the timer by setting it to zero.\n+  const struct itimerspec its {\n+    .it_interval = {.tv_sec = 0, .tv_nsec=0},\n+    .it_value = {.tv_sec = 0, .tv_nsec=0}\n+  };\n+  timer_settime(_timer, 0, &its, nullptr);\n+#endif \/\/ ASSERT\n+}\n+\n+bool CompilerThreadTimeoutLinux::init_timeout() {\n+#ifdef ASSERT\n+  if (CompileTaskTimeout == 0) {\n+    return true;\n+  }\n+\n+  JavaThread* thread = JavaThread::current();\n+\n+  \/\/ Create a POSIX timer sending SIGALRM to this thread only.\n+  struct sigevent sev;\n+  sev.sigev_value.sival_ptr = nullptr;\n+  sev.sigev_signo = TIMEOUT_SIGNAL;\n+  sev.sigev_notify = SIGEV_THREAD_ID;\n+#ifdef MUSL_LIBC\n+  sev.sigev_notify_thread_id = thread->osthread()->thread_id();\n+#else\n+  sev._sigev_un._tid = thread->osthread()->thread_id();\n+#endif \/\/ MUSL_LIBC\n+  clockid_t clock;\n+  int err = pthread_getcpuclockid(thread->osthread()->pthread_id(), &clock);\n+  if (err != 0) {\n+    return false;\n+  }\n+  err = timer_create(clock, &sev, &_timer);\n+  if (err != 0) {\n+    return false;\n+  }\n+\n+  \/\/ Install the signal handler and check that we do not have a conflicting handler.\n+  struct sigaction sigact, sigact_old;\n+  err = PosixSignals::install_sigaction_signal_handler(&sigact,\n+                                                       &sigact_old,\n+                                                       TIMEOUT_SIGNAL,\n+                                                       (sa_sigaction_t)::compiler_signal_handler);\n+  if (err != 0 || (sigact_old.sa_sigaction != sigact.sa_sigaction &&\n+      sigact_old.sa_handler != SIG_DFL && sigact_old.sa_handler != SIG_IGN)) {\n+    return false;\n+  }\n+#endif \/\/ ASSERT\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.cpp","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n+#define LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <csignal>\n+#include <ctime>\n+\n+class CompilerThreadTimeoutLinux : public CHeapObj<mtCompiler> {\n+#ifdef ASSERT\n+ public:\n+  static const int TIMEOUT_SIGNAL = SIGALRM;\n+  void compiler_signal_handler(int signo, siginfo_t* info, void* context);\n+ private:\n+  timer_t          _timer;\n+#endif \/\/ ASSERT\n+ public:\n+  CompilerThreadTimeoutLinux() DEBUG_ONLY(: _timer(nullptr)) {};\n+\n+  bool init_timeout();\n+  void arm();\n+  void disarm();\n+};\n+\n+#endif \/\/LINUX_COMPILER_THREAD_TIMEOUT_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -207,1 +207,1 @@\n-  snprintf(filename, sizeof(filename), \"%s%s\", name, ZLargePages::is_explicit() ? \".hugetlb\" : \"\");\n+  os::snprintf_checked(filename, sizeof(filename), \"%s%s\", name, ZLargePages::is_explicit() ? \".hugetlb\" : \"\");\n@@ -265,1 +265,1 @@\n-  snprintf(filename, sizeof(filename), \"%s\/%s.%d\", mountpoint.get(), name, os::current_process_id());\n+  os::snprintf_checked(filename, sizeof(filename), \"%s\/%s.%d\", mountpoint.get(), name, os::current_process_id());\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,0 +92,5 @@\n+  develop(intx, CompileTaskTimeout, 0,                                  \\\n+          \"Set the timeout for compile tasks' CPU time in milliseconds.\"\\\n+          \" 0 = no timeout (default)\")                                  \\\n+          range(0,1000000)                                              \\\n+                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,5 +25,1 @@\n-#include <string.h>\n-#include <math.h>\n-#include <errno.h>\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/os.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n@@ -33,1 +29,6 @@\n-#include \"cgroupSubsystem_linux.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+#include <errno.h>\n+#include <math.h>\n+#include <string.h>\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allStatic.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"memory\/allStatic.hpp\"\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"osContainer_linux.hpp\"\n@@ -84,1 +84,0 @@\n-\/\/ put OS-includes here\n@@ -86,8 +85,1 @@\n-# include <stdlib.h>\n-# include <sys\/types.h>\n-# include <sys\/mman.h>\n-# include <sys\/stat.h>\n-# include <sys\/select.h>\n-# include <sys\/sendfile.h>\n-# include <pthread.h>\n-# include <signal.h>\n+# include <dlfcn.h>\n@@ -96,0 +88,1 @@\n+# include <fcntl.h>\n@@ -97,1 +90,8 @@\n-# include <dlfcn.h>\n+# include <inttypes.h>\n+# include <link.h>\n+# include <linux\/elf-em.h>\n+# include <poll.h>\n+# include <pthread.h>\n+# include <pwd.h>\n+# include <signal.h>\n+# include <stdint.h>\n@@ -99,1 +99,6 @@\n-# include <unistd.h>\n+# include <stdlib.h>\n+# include <string.h>\n+# include <sys\/ioctl.h>\n+# include <sys\/ipc.h>\n+# include <sys\/mman.h>\n+# include <sys\/prctl.h>\n@@ -101,1 +106,3 @@\n-# include <pthread.h>\n+# include <sys\/select.h>\n+# include <sys\/sendfile.h>\n+# include <sys\/socket.h>\n@@ -103,0 +110,1 @@\n+# include <sys\/sysinfo.h>\n@@ -105,0 +113,1 @@\n+# include <sys\/types.h>\n@@ -106,5 +115,0 @@\n-# include <sys\/socket.h>\n-# include <pwd.h>\n-# include <poll.h>\n-# include <fcntl.h>\n-# include <string.h>\n@@ -112,8 +116,1 @@\n-# include <sys\/sysinfo.h>\n-# include <sys\/ipc.h>\n-# include <link.h>\n-# include <stdint.h>\n-# include <inttypes.h>\n-# include <sys\/ioctl.h>\n-# include <linux\/elf-em.h>\n-# include <sys\/prctl.h>\n+# include <unistd.h>\n@@ -160,1 +157,1 @@\n-julong os::Linux::_physical_memory = 0;\n+size_t os::Linux::_physical_memory = 0;\n@@ -235,2 +232,2 @@\n-julong os::available_memory() {\n-  return Linux::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return Linux::available_memory(value);\n@@ -239,1 +236,1 @@\n-julong os::Linux::available_memory() {\n+bool os::Linux::available_memory(size_t& value) {\n@@ -243,1 +240,2 @@\n-    return avail_mem;\n+    value = static_cast<size_t>(avail_mem);\n+    return true;\n@@ -258,1 +256,5 @@\n-    avail_mem = free_memory();\n+    size_t free_mem = 0;\n+    if (!free_memory(free_mem)) {\n+      return false;\n+    }\n+    avail_mem = static_cast<julong>(free_mem);\n@@ -261,1 +263,2 @@\n-  return avail_mem;\n+  value = static_cast<size_t>(avail_mem);\n+  return true;\n@@ -264,2 +267,2 @@\n-julong os::free_memory() {\n-  return Linux::free_memory();\n+bool os::free_memory(size_t& value) {\n+  return Linux::free_memory(value);\n@@ -268,1 +271,1 @@\n-julong os::Linux::free_memory() {\n+bool os::Linux::free_memory(size_t& value) {\n@@ -274,1 +277,2 @@\n-    return free_mem;\n+    value = static_cast<size_t>(free_mem);\n+    return true;\n@@ -277,1 +281,4 @@\n-  sysinfo(&si);\n+  int ret = sysinfo(&si);\n+  if (ret != 0) {\n+    return false;\n+  }\n@@ -280,1 +287,2 @@\n-  return free_mem;\n+  value = static_cast<size_t>(free_mem);\n+  return true;\n@@ -283,1 +291,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -285,2 +293,5 @@\n-    if (OSContainer::memory_limit_in_bytes() > 0) {\n-      return (jlong)(OSContainer::memory_and_swap_limit_in_bytes() - OSContainer::memory_limit_in_bytes());\n+    jlong memory_and_swap_limit_in_bytes = OSContainer::memory_and_swap_limit_in_bytes();\n+    jlong memory_limit_in_bytes = OSContainer::memory_limit_in_bytes();\n+    if (memory_limit_in_bytes > 0 && memory_and_swap_limit_in_bytes > 0) {\n+      value = static_cast<size_t>(memory_and_swap_limit_in_bytes - memory_limit_in_bytes);\n+      return true;\n@@ -288,1 +299,1 @@\n-  }\n+  } \/\/ fallback to the host swap space if the container did return the unbound value of -1\n@@ -292,1 +303,2 @@\n-    return -1;\n+    assert(false, \"sysinfo failed in total_swap_space(): %s\", os::strerror(errno));\n+    return false;\n@@ -294,1 +306,2 @@\n-  return  (jlong)(si.totalswap * si.mem_unit);\n+  value = static_cast<size_t>(si.totalswap * si.mem_unit);\n+  return true;\n@@ -297,1 +310,1 @@\n-static jlong host_free_swap() {\n+static bool host_free_swap_f(size_t& value) {\n@@ -301,1 +314,2 @@\n-    return -1;\n+    assert(false, \"sysinfo failed in host_free_swap_f(): %s\", os::strerror(errno));\n+    return false;\n@@ -303,1 +317,2 @@\n-  return (jlong)(si.freeswap * si.mem_unit);\n+  value = static_cast<size_t>(si.freeswap * si.mem_unit);\n+  return true;\n@@ -306,1 +321,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -309,2 +324,6 @@\n-  jlong host_free_swap_val = MIN2(os::total_swap_space(), host_free_swap());\n-  assert(host_free_swap_val >= 0, \"sysinfo failed?\");\n+  size_t total_swap_space = 0;\n+  size_t host_free_swap = 0;\n+  if (!os::total_swap_space(total_swap_space) || !host_free_swap_f(host_free_swap)) {\n+    return false;\n+  }\n+  size_t host_free_swap_val = MIN2(total_swap_space, host_free_swap);\n@@ -317,1 +336,2 @@\n-        return 0;\n+        value = 0;\n+        return true;\n@@ -325,1 +345,2 @@\n-          return free_swap >= 0 ? free_swap : 0;\n+          value = free_swap >= 0 ? static_cast<size_t>(free_swap) : 0;\n+          return true;\n@@ -331,1 +352,1 @@\n-                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: \" JLONG_FORMAT,\n+                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: %zu\",\n@@ -334,1 +355,2 @@\n-  return host_free_swap_val;\n+  value = host_free_swap_val;\n+  return true;\n@@ -337,2 +359,1 @@\n-julong os::physical_memory() {\n-  jlong phys_mem = 0;\n+size_t os::physical_memory() {\n@@ -343,1 +364,1 @@\n-      return mem_limit;\n+      return static_cast<size_t>(mem_limit);\n@@ -347,2 +368,2 @@\n-  phys_mem = Linux::physical_memory();\n-  log_trace(os)(\"total system memory: \" JLONG_FORMAT, phys_mem);\n+  size_t phys_mem = Linux::physical_memory();\n+  log_trace(os)(\"total system memory: %zu\", phys_mem);\n@@ -523,1 +544,1 @@\n-  _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);\n+  _physical_memory = static_cast<size_t>(sysconf(_SC_PHYS_PAGES)) * static_cast<size_t>(sysconf(_SC_PAGESIZE));\n@@ -1851,3 +1872,3 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load %s .so on a %s platform)\",\n-                 lib_arch.name, arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load %s .so on a %s platform)\",\n+                           lib_arch.name, arch_array[running_arch_index].name);\n@@ -1855,3 +1876,3 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load this .so (machine code=0x%x) on a %s platform)\",\n-                 lib_arch.code, arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load this .so (machine code=0x%x) on a %s platform)\",\n+                           lib_arch.code, arch_array[running_arch_index].name);\n@@ -1863,1 +1884,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: endianness mismatch)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: endianness mismatch)\");\n@@ -1869,1 +1890,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: invalid ELF file class)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: invalid ELF file class)\");\n@@ -1874,3 +1895,3 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-               \" (Possible cause: architecture word width mismatch, can't load %d-bit .so on a %d-bit platform)\",\n-               (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                         \" (Possible cause: architecture word width mismatch, can't load %d-bit .so on a %d-bit platform)\",\n+                         (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);\n@@ -2551,5 +2572,7 @@\n-\n-  st->print(\", physical \" UINT64_FORMAT \"k\",\n-            os::physical_memory() >> 10);\n-  st->print(\"(\" UINT64_FORMAT \"k free)\",\n-            os::available_memory() >> 10);\n+  size_t phys_mem = physical_memory();\n+  st->print(\", physical %zuk\",\n+            phys_mem >> 10);\n+  size_t avail_mem = 0;\n+  (void)os::available_memory(avail_mem);\n+  st->print(\"(%zuk free)\",\n+            avail_mem >> 10);\n@@ -2616,4 +2639,4 @@\n-      snprintf(hbuf_level, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/level\", i);\n-      snprintf(hbuf_type, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/type\", i);\n-      snprintf(hbuf_size, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/size\", i);\n-      snprintf(hbuf_coherency_line_size, 80, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/coherency_line_size\", i);\n+      os::snprintf_checked(hbuf_level, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/level\", i);\n+      os::snprintf_checked(hbuf_type, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/type\", i);\n+      os::snprintf_checked(hbuf_size, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/size\", i);\n+      os::snprintf_checked(hbuf_coherency_line_size, 80, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/coherency_line_size\", i);\n@@ -4220,1 +4243,1 @@\n-  snprintf(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n+  os::snprintf_checked(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n@@ -4800,1 +4823,1 @@\n-    snprintf(buf, sizeof(buf), \"%s\", name);\n+    (void) os::snprintf(buf, sizeof(buf), \"%s\", name);\n@@ -5011,1 +5034,1 @@\n-  snprintf(proc_name, 64, \"\/proc\/self\/task\/%d\/stat\", tid);\n+  os::snprintf_checked(proc_name, 64, \"\/proc\/self\/task\/%d\/stat\", tid);\n@@ -5397,1 +5420,1 @@\n-      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      os::snprintf_checked(ebuf, ebuflen - 1, \"%s\", error_report);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":108,"deletions":85,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -56,2 +56,2 @@\n-  static julong available_memory();\n-  static julong free_memory();\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n@@ -120,1 +120,1 @@\n-  static julong physical_memory() { return _physical_memory; }\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/os\/linux\/os_linux.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,3 +34,2 @@\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <unistd.h>\n+#include <dirent.h>\n+#include <dlfcn.h>\n@@ -38,0 +37,7 @@\n+#include <fcntl.h>\n+#include <ifaddrs.h>\n+#include <limits.h>\n+#include <pthread.h>\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n@@ -40,1 +46,0 @@\n-#include <sys\/types.h>\n@@ -42,7 +47,2 @@\n-#include <dirent.h>\n-#include <stdlib.h>\n-#include <dlfcn.h>\n-#include <pthread.h>\n-#include <limits.h>\n-#include <ifaddrs.h>\n-#include <fcntl.h>\n+#include <sys\/types.h>\n+#include <unistd.h>\n@@ -991,1 +991,1 @@\n-  snprintf(buf, sizeof(buf), \"\/sys\/class\/net\/%s\/statistics\/%s\", iface, counter);\n+  os::snprintf_checked(buf, sizeof(buf), \"\/sys\/class\/net\/%s\/statistics\/%s\", iface, counter);\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include <sys\/syscall.h>\n+\n@@ -31,0 +31,1 @@\n+#include <sys\/syscall.h>\n","filename":"src\/hotspot\/os\/linux\/waitBarrier_linux.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n+  int n = os::snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -201,1 +201,1 @@\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n+    n = os::snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n@@ -349,3 +349,2 @@\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n+  os::snprintf_checked(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -421,2 +420,2 @@\n-    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\", os::get_temp_directory(),\n-             os::current_process_id());\n+    os::snprintf_checked(fn, sizeof(fn), \"%s\/.attach_pid%d\", os::get_temp_directory(),\n+                         os::current_process_id());\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-    int n = snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n+    int n = os::snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-  snprintf(dirname, nbytes, \"%s\/%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf_checked(dirname, nbytes, \"%s\/%s_%s\", tmpdir, perfdir, user);\n@@ -664,1 +664,1 @@\n-  snprintf(name, nbytes, \"%s\/%d\", dirname, pid);\n+  os::snprintf_checked(name, nbytes, \"%s\/%d\", dirname, pid);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -120,1 +120,1 @@\n-        if (MetaspaceShared::is_in_shared_metaspace(fault_addr)) {\n+        if (AOTMetaspace::in_aot_cache(fault_addr)) {\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -851,2 +851,2 @@\n-julong os::available_memory() {\n-  return win32::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return win32::available_memory(value);\n@@ -855,2 +855,2 @@\n-julong os::free_memory() {\n-  return win32::available_memory();\n+bool os::free_memory(size_t& value) {\n+  return win32::available_memory(value);\n@@ -859,1 +859,1 @@\n-julong os::win32::available_memory() {\n+bool os::win32::available_memory(size_t& value) {\n@@ -864,3 +864,8 @@\n-  GlobalMemoryStatusEx(&ms);\n-\n-  return (julong)ms.ullAvailPhys;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res == TRUE) {\n+    value = static_cast<size_t>(ms.ullAvailPhys);\n+    return true;\n+  } else {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::win32::available_memory(): %lu\", ::GetLastError());\n+    return false;\n+  }\n@@ -869,1 +874,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -872,2 +877,8 @@\n-  GlobalMemoryStatusEx(&ms);\n-  return (jlong) ms.ullTotalPageFile;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res == TRUE) {\n+    value = static_cast<size_t>(ms.ullTotalPageFile);\n+    return true;\n+  } else {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::total_swap_space(): %lu\", ::GetLastError());\n+    return false;\n+  }\n@@ -876,1 +887,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -879,2 +890,8 @@\n-  GlobalMemoryStatusEx(&ms);\n-  return (jlong) ms.ullAvailPageFile;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res == TRUE) {\n+    value = static_cast<size_t>(ms.ullAvailPageFile);\n+    return true;\n+  } else {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::free_swap_space(): %lu\", ::GetLastError());\n+    return false;\n+  }\n@@ -883,1 +900,1 @@\n-julong os::physical_memory() {\n+size_t os::physical_memory() {\n@@ -1414,1 +1431,1 @@\n-    snprintf(name, MAX_PATH, \"<not available>\");\n+    os::snprintf_checked(name, MAX_PATH, \"<not available>\");\n@@ -1430,1 +1447,1 @@\n-      os::snprintf(buf, sizeof(buf), \"Attempt to unload dll failed (error code %d)\", (int) errcode);\n+      os::snprintf_checked(buf, sizeof(buf), \"Attempt to unload dll failed (error code %d)\", (int) errcode);\n@@ -1827,3 +1844,3 @@\n-    os::snprintf(ebuf, ebuflen - 1,\n-                 \"Can't load %s-bit .dll on a %s-bit platform\",\n-                 lib_arch_str, running_arch_str);\n+    os::snprintf_checked(ebuf, ebuflen - 1,\n+                         \"Can't load %s-bit .dll on a %s-bit platform\",\n+                         lib_arch_str, running_arch_str);\n@@ -1832,3 +1849,3 @@\n-    os::snprintf(ebuf, ebuflen - 1,\n-                 \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n-                 lib_arch, running_arch_str);\n+    os::snprintf_checked(ebuf, ebuflen - 1,\n+                         \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n+                         lib_arch, running_arch_str);\n@@ -3201,1 +3218,1 @@\n-  int n = snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n+  int n = os::snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n@@ -3951,1 +3968,1 @@\n-julong os::win32::_physical_memory           = 0;\n+size_t os::win32::_physical_memory           = 0;\n@@ -4181,2 +4198,5 @@\n-  GlobalMemoryStatusEx(&ms);\n-  _physical_memory = ms.ullTotalPhys;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res != TRUE) {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::win32::initialize_system_info(): %lu\", ::GetLastError());\n+  }\n+  _physical_memory = static_cast<size_t>(ms.ullTotalPhys);\n@@ -4683,2 +4703,2 @@\n-      errno = ::GetLastError();\n-      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%ld.\", errno);\n+      DWORD errcode = ::GetLastError();\n+      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%lu.\", errcode);\n@@ -4688,2 +4708,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%lu.\", errcode);\n@@ -4699,2 +4719,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%lu.\", errcode);\n@@ -4708,2 +4728,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%lu.\", errcode);\n@@ -4719,2 +4739,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%lu.\", errcode);\n@@ -4725,2 +4745,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%lu.\", errcode);\n@@ -4807,3 +4827,2 @@\n-      \/\/ it is a symbolic link, but we failed to resolve it,\n-      \/\/ errno has been set in the call to get_path_to_target(),\n-      \/\/ no need to overwrite it\n+      \/\/ it is a symbolic link, but we failed to resolve it\n+      errno = ENOENT;\n@@ -4820,2 +4839,7 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    if (errcode == ERROR_FILE_NOT_FOUND || errcode == ERROR_PATH_NOT_FOUND) {\n+      errno = ENOENT;\n+    } else {\n+      errno = 0;\n+    }\n+    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%lu.\", errcode);\n@@ -5021,3 +5045,2 @@\n-      \/\/ it is a symbolic link, but we failed to resolve it,\n-      \/\/ errno has been set in the call to get_path_to_target(),\n-      \/\/ no need to overwrite it\n+      \/\/ it is a symbolic link, but we failed to resolve it\n+      errno = ENOENT;\n@@ -5031,1 +5054,1 @@\n-  \/\/ if opening files failed, GetLastError should be called immediately after that\n+  \/\/ if opening files failed, errno has been set to indicate the problem\n@@ -5033,2 +5056,1 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"os::open() failed to _wopen: GetLastError->%ld.\", errno);\n+    log_debug(os)(\"os::open() failed to _wopen: errno->%s.\", strerror(errno));\n@@ -5102,1 +5124,2 @@\n-    errno = ::GetLastError();\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"os::dir_is_empty() failed to FindFirstFileW: GetLastError->%lu.\", errcode);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":74,"deletions":51,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -105,3 +105,3 @@\n-  static julong available_memory();\n-  static julong free_memory();\n-  static julong physical_memory() { return _physical_memory; }\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  os::snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf_checked(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n@@ -457,1 +457,1 @@\n-  os::snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n+  os::snprintf_checked(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n@@ -473,1 +473,1 @@\n-  os::snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n+  os::snprintf_checked(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -26,1 +27,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -54,1 +54,1 @@\n-        if (MetaspaceShared::is_in_shared_metaspace(fault_addr)) {\n+        if (AOTMetaspace::in_aot_cache(fault_addr)) {\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"cds\/metaspaceShared.hpp\"\n+#include \"cds\/aotMetaspace.hpp\"\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/javaThread_bsd_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -212,2 +212,10 @@\n-  Unimplemented();\n-  return nullptr;\n+  assert(ucVoid != nullptr, \"invariant\");\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  assert(os::Posix::ucontext_is_interpreter(uc), \"invariant\");\n+#if (FP_REG_NUM == 11)\n+  assert(Rbcp == R7, \"expected FP=R11, Rbcp=R7\");\n+  return (intptr_t*)uc->uc_mcontext.arm_r7;\n+#else\n+  assert(Rbcp == R11, \"expected FP=R7, Rbcp=R11\");\n+  return (intptr_t*)uc->uc_mcontext.arm_fp; \/\/ r11\n+#endif\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-    snprintf(buf, sizeof(buf)\/2, \"%s \", uarch);\n+    os::snprintf_checked(buf, sizeof(buf)\/2, \"%s \", uarch);\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -544,1 +544,1 @@\n-  typedef ResizeableResourceHashtable<address, Offsets, AnyObj::C_HEAP, mtCompiler> SharedTrampolineRequests;\n+  typedef ResizeableHashTable<address, Offsets, AnyObj::C_HEAP, mtCompiler> SharedTrampolineRequests;\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-  CodeStub* slow_path = new MonitorExitStub(lock, LockingMode != LM_MONITOR, monitor_no);\n+  CodeStub* slow_path = new MonitorExitStub(lock, true, monitor_no);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -781,3 +781,0 @@\n-  if (LockingMode == LM_MONITOR) {\n-    lock->set_obj(obj);\n-  }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -50,1 +50,1 @@\n-using ClassesTable = ResourceHashtable<Klass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n+using ClassesTable = HashTable<Klass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n@@ -204,1 +204,1 @@\n-      InstanceKlass* s = ik->java_super();\n+      InstanceKlass* s = ik->super();\n@@ -227,1 +227,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && ik->is_shared()) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && ik->in_aot_cache()) {\n@@ -239,1 +239,1 @@\n-    InstanceKlass* s = ik->java_super();\n+    InstanceKlass* s = ik->super();\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -48,1 +48,1 @@\n-  return mapinfo->region_at(MetaspaceShared::ac)->used_aligned();\n+  return mapinfo->region_at(AOTMetaspace::ac)->used_aligned();\n","filename":"src\/hotspot\/share\/cds\/aotCacheAccess.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    InstanceKlass* super = ik->java_super();\n+    InstanceKlass* super = ik->super();\n@@ -154,1 +154,1 @@\n-  InstanceKlass* s = ik->java_super();\n+  InstanceKlass* s = ik->super();\n@@ -215,1 +215,1 @@\n-    if (ik->is_shared() && CDSConfig::is_dumping_dynamic_archive()) {\n+    if (ik->in_aot_cache() && CDSConfig::is_dumping_dynamic_archive()) {\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -72,1 +72,1 @@\n-  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n+  using ClassesTable = HashTable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -244,6 +244,0 @@\n-#ifdef _WINDOWS\n-  } else if (errno == ERROR_FILE_NOT_FOUND || errno == ERROR_PATH_NOT_FOUND) {\n-    \/\/ On Windows, the errno could be ERROR_PATH_NOT_FOUND (3) in case the directory\n-    \/\/ path doesn't exist.\n-    type = FileType::NOT_EXIST;\n-#endif\n@@ -255,1 +249,1 @@\n-    MetaspaceShared::unrecoverable_loading_error();\n+    AOTMetaspace::unrecoverable_loading_error();\n@@ -1037,1 +1031,1 @@\n-        MetaspaceShared::unrecoverable_loading_error();\n+        AOTMetaspace::unrecoverable_loading_error();\n@@ -1040,1 +1034,1 @@\n-      MetaspaceShared::report_loading_error(\"%s%s\", mismatch_msg, hint_msg);\n+      AOTMetaspace::report_loading_error(\"%s%s\", mismatch_msg, hint_msg);\n","filename":"src\/hotspot\/share\/cds\/aotClassLocation.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    if (!ik->is_shared() && SystemDictionaryShared::is_excluded_class(ik)) {\n+    if (!ik->in_aot_cache() && SystemDictionaryShared::is_excluded_class(ik)) {\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -56,1 +56,1 @@\n-  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared> ;\n+  using ClassesTable = HashTable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared> ;\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-          MetaspaceShared::unrecoverable_loading_error();\n+          AOTMetaspace::unrecoverable_loading_error();\n@@ -297,1 +297,1 @@\n-      assert(ik->java_super()->is_loaded(), \"must be\");\n+      assert(ik->super()->is_loaded(), \"must be\");\n@@ -437,1 +437,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,930 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotMapLogger.hpp\"\n+#include \"cds\/archiveHeapWriter.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+bool AOTMapLogger::_is_logging_at_bootstrap;\n+bool AOTMapLogger::_is_runtime_logging;\n+intx AOTMapLogger::_buffer_to_requested_delta;\n+intx AOTMapLogger::_requested_to_mapped_metadata_delta;\n+size_t AOTMapLogger::_num_root_segments;\n+size_t AOTMapLogger::_num_obj_arrays_logged;\n+GrowableArrayCHeap<AOTMapLogger::FakeOop, mtClass>* AOTMapLogger::_roots;\n+ArchiveHeapInfo* AOTMapLogger::_dumptime_heap_info;\n+\n+class AOTMapLogger::RequestedMetadataAddr {\n+  address _raw_addr;\n+\n+public:\n+  RequestedMetadataAddr(address raw_addr) : _raw_addr(raw_addr) {}\n+\n+  address raw_addr() const { return _raw_addr; }\n+\n+  Klass* to_real_klass() const {\n+    if (_raw_addr == nullptr) {\n+      return nullptr;\n+    }\n+\n+    if (_is_runtime_logging) {\n+      return (Klass*)(_raw_addr + _requested_to_mapped_metadata_delta);\n+    } else {\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      address buffered_addr = builder->requested_to_buffered(_raw_addr);\n+      address klass = builder->get_source_addr(buffered_addr);\n+      return (Klass*)klass;\n+    }\n+  }\n+}; \/\/ AOTMapLogger::RequestedMetadataAddr\n+\n+void AOTMapLogger::ergo_initialize() {\n+  if (!CDSConfig::is_dumping_archive() && CDSConfig::is_using_archive() && log_is_enabled(Info, aot, map)) {\n+    _is_logging_at_bootstrap = true;\n+    if (FLAG_IS_DEFAULT(ArchiveRelocationMode)) {\n+      FLAG_SET_ERGO(ArchiveRelocationMode, 0);\n+    } else if (ArchiveRelocationMode != 0) {\n+      log_warning(aot, map)(\"Addresses in the AOT map may be incorrect for -XX:ArchiveRelocationMode=%d.\", ArchiveRelocationMode);\n+    }\n+  }\n+}\n+\n+void AOTMapLogger::dumptime_log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n+                                ArchiveHeapInfo* heap_info,\n+                                char* bitmap, size_t bitmap_size_in_bytes) {\n+  _is_runtime_logging = false;\n+  _buffer_to_requested_delta =  ArchiveBuilder::current()->buffer_to_requested_delta();\n+  _num_root_segments = mapinfo->heap_root_segments().count();\n+  _dumptime_heap_info = heap_info;\n+\n+  log_file_header(mapinfo);\n+\n+  DumpRegion* rw_region = &builder->_rw_region;\n+  DumpRegion* ro_region = &builder->_ro_region;\n+\n+  dumptime_log_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n+  dumptime_log_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n+\n+  address bitmap_end = address(bitmap + bitmap_size_in_bytes);\n+  log_region_range(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n+  log_as_hex((address)bitmap, bitmap_end, nullptr);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (heap_info->is_used()) {\n+    dumptime_log_heap_region(heap_info);\n+  }\n+#endif\n+\n+  log_info(aot, map)(\"[End of AOT cache map]\");\n+}\n+\n+\/\/ This class is used to find the location and type of all the\n+\/\/ archived metaspace objects.\n+class AOTMapLogger::RuntimeGatherArchivedMetaspaceObjs : public UniqueMetaspaceClosure {\n+  GrowableArrayCHeap<ArchivedObjInfo, mtClass> _objs;\n+\n+  static int compare_objs_by_addr(ArchivedObjInfo* a, ArchivedObjInfo* b) {\n+    intx diff = a->_src_addr - b->_src_addr;\n+    if (diff < 0) {\n+      return -1;\n+    } else if (diff == 0) {\n+      return 0;\n+    } else {\n+      return 1;\n+    }\n+  }\n+\n+public:\n+  GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs() { return &_objs; }\n+\n+  virtual bool do_unique_ref(Ref* ref, bool read_only) {\n+    ArchivedObjInfo info;\n+    info._src_addr = ref->obj();\n+    info._buffered_addr = ref->obj();\n+    info._requested_addr = ref->obj();\n+    info._bytes = ref->size() * BytesPerWord;\n+    info._type = ref->msotype();\n+    _objs.append(info);\n+\n+    return true; \/\/ keep iterating\n+  }\n+\n+  void finish() {\n+    UniqueMetaspaceClosure::finish();\n+    _objs.sort(compare_objs_by_addr);\n+  }\n+}; \/\/ AOTMapLogger::RuntimeGatherArchivedMetaspaceObjs\n+\n+void AOTMapLogger::runtime_log(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo) {\n+  _is_runtime_logging = true;\n+  _requested_to_mapped_metadata_delta = static_mapinfo->relocation_delta();\n+\n+  ResourceMark rm;\n+  RuntimeGatherArchivedMetaspaceObjs gatherer;\n+\n+  if (log_is_enabled(Debug, aot, map)) {\n+    \/\/ The metaspace objects in the AOT cache are stored as a stream of bytes. For space\n+    \/\/ saving, we don't store a complete index that tells us where one object ends and\n+    \/\/ another object starts. There's also no type information.\n+    \/\/\n+    \/\/ However, we can rebuild our index by iterating over all the objects using\n+    \/\/ MetaspaceClosure, starting from the dictionary of Klasses in SystemDictionaryShared.\n+    GrowableArray<Klass*> klasses;\n+    SystemDictionaryShared::get_all_archived_classes(\/*is_static*\/true, &klasses);\n+    if (dynamic_mapinfo != nullptr) {\n+      SystemDictionaryShared::get_all_archived_classes(\/*is_static*\/false, &klasses);\n+    }\n+\n+    for (int i = 0; i < klasses.length(); i++) {\n+      gatherer.push(klasses.adr_at(i));\n+    }\n+    gatherer.finish();\n+  }\n+\n+  runtime_log(static_mapinfo, gatherer.objs());\n+  if (dynamic_mapinfo != nullptr) {\n+    runtime_log(dynamic_mapinfo, gatherer.objs());\n+  }\n+}\n+\n+void AOTMapLogger::runtime_log(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs) {\n+  log_file_header(mapinfo);\n+\n+  runtime_log_metaspace_regions(mapinfo, objs);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (mapinfo->has_heap_region() && CDSConfig::is_loading_heap()) {\n+    _num_root_segments = mapinfo->heap_root_segments().count();\n+    runtime_log_heap_region(mapinfo);\n+  }\n+#endif\n+\n+  log_info(aot, map)(\"[End of map]\");\n+}\n+\n+void AOTMapLogger::dumptime_log_metaspace_region(const char* name, DumpRegion* region,\n+                                                 const ArchiveBuilder::SourceObjList* src_objs) {\n+  address region_base = address(region->base());\n+  address region_top  = address(region->top());\n+  log_region_range(name, region_base, region_top, region_base + _buffer_to_requested_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    GrowableArrayCHeap<ArchivedObjInfo, mtClass> objs;\n+    for (int i = 0; i < src_objs->objs()->length(); i++) {\n+      ArchiveBuilder::SourceObjInfo* src_info = src_objs->at(i);\n+      ArchivedObjInfo info;\n+      info._src_addr = src_info->source_addr();\n+      info._buffered_addr = src_info->buffered_addr();\n+      info._requested_addr = info._buffered_addr + _buffer_to_requested_delta;\n+      info._bytes = src_info->size_in_bytes();\n+      info._type = src_info->msotype();\n+      objs.append(info);\n+    }\n+\n+    log_metaspace_objects_impl(address(region->base()), address(region->end()), &objs, 0, objs.length());\n+  }\n+}\n+\n+void AOTMapLogger::runtime_log_metaspace_regions(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs) {\n+  FileMapRegion* rw = mapinfo->region_at(AOTMetaspace::rw);\n+  FileMapRegion* ro = mapinfo->region_at(AOTMetaspace::ro);\n+\n+  address rw_base = address(rw->mapped_base());\n+  address rw_end  = address(rw->mapped_end());\n+  address ro_base = address(ro->mapped_base());\n+  address ro_end  = address(ro->mapped_end());\n+\n+  int first_rw_index = -1;\n+  int first_ro_index = -1;\n+  int last_ro_index = -1;\n+\n+  if (log_is_enabled(Debug, aot, map)) {\n+    int i = 0;\n+    for (; i < objs->length(); i++) {\n+      address p = objs->at(i)._src_addr;\n+      if (p < rw_base) {\n+        \/\/ We are printing the dynamic archive but found an object in the static archive\n+        precond(!mapinfo->is_static());\n+        continue;\n+      }\n+      if (first_rw_index < 0) {\n+        first_rw_index = i;\n+        continue;\n+      }\n+      if (p < ro_base) {\n+        continue;\n+      }\n+      if (first_ro_index < 0) {\n+        first_ro_index = i;\n+        continue;\n+      }\n+      if (p < ro_end) {\n+        continue;\n+      } else {\n+        last_ro_index = i;\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (last_ro_index < 0) {\n+    last_ro_index = objs->length();\n+  }\n+\n+  log_region_range(\"rw\", rw_base, rw_end, rw_base - _requested_to_mapped_metadata_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    log_metaspace_objects_impl(rw_base, rw_end, objs, first_rw_index, first_ro_index);\n+  }\n+\n+  log_region_range(\"ro\", ro_base, ro_end, ro_base - _requested_to_mapped_metadata_delta);\n+  if (log_is_enabled(Debug, aot, map)) {\n+    log_metaspace_objects_impl(ro_base, ro_end, objs, first_ro_index, last_ro_index);\n+  }\n+}\n+\n+void AOTMapLogger::log_file_header(FileMapInfo* mapinfo) {\n+  const char* type;\n+  if (mapinfo->is_static()) {\n+    if (CDSConfig::new_aot_flags_used()) {\n+      type = \"AOT cache\";\n+    } else {\n+      type = \"Static CDS archive\";\n+    }\n+  } else {\n+    type = \"Dynamic CDS archive\";\n+  }\n+\n+  log_info(aot, map)(\"%s map for %s\", type, mapinfo->full_path());\n+\n+  address header = address(mapinfo->header());\n+  address header_end = header + mapinfo->header()->header_size();\n+\n+  log_region_range(\"header\", header, header_end, nullptr);\n+  LogStreamHandle(Info, aot, map) lsh;\n+  mapinfo->print(&lsh);\n+  log_as_hex(header, header_end, nullptr);\n+}\n+\n+\/\/ Log information about a region, whose address at dump time is [base .. top). At\n+\/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n+\/\/ region will be mapped at os-selected addresses (such as the bitmap region), or will\n+\/\/ be accessed with os::read (the header).\n+void AOTMapLogger::log_region_range(const char* name, address base, address top, address requested_base) {\n+  size_t size = top - base;\n+  base = requested_base;\n+  if (requested_base == nullptr) {\n+    top = (address)size;\n+  } else {\n+    top = requested_base + size;\n+  }\n+  log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n+                     name, p2i(base), p2i(top), size);\n+}\n+\n+#define _LOG_PREFIX PTR_FORMAT \": @@ %-17s %d\"\n+\n+void AOTMapLogger::log_metaspace_objects_impl(address region_base, address region_end, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs,\n+                                              int start_idx, int end_idx) {\n+  address last_obj_base = region_base;\n+  address last_obj_end  = region_base;\n+  Thread* current = Thread::current();\n+\n+  for (int i = start_idx; i < end_idx; i++) {\n+    ArchivedObjInfo& info = objs->at(i);\n+    address src = info._src_addr;\n+    address buffered_addr = info._buffered_addr;\n+    address requested_addr = info._requested_addr;\n+    int bytes = info._bytes;\n+    MetaspaceObj::Type type = info._type;\n+    const char* type_name = MetaspaceObj::type_name(type);\n+\n+    log_as_hex(last_obj_base, buffered_addr, last_obj_base + _buffer_to_requested_delta);\n+\n+    switch (type) {\n+    case MetaspaceObj::ClassType:\n+      log_klass((Klass*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstantPoolType:\n+      log_constant_pool((ConstantPool*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstantPoolCacheType:\n+      log_constant_pool_cache((ConstantPoolCache*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::ConstMethodType:\n+      log_const_method((ConstMethod*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::MethodType:\n+      log_method((Method*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceObj::SymbolType:\n+      log_symbol((Symbol*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    default:\n+      log_debug(aot, map)(_LOG_PREFIX, p2i(requested_addr), type_name, bytes);\n+      break;\n+    }\n+\n+    last_obj_base = buffered_addr;\n+    last_obj_end  = buffered_addr + bytes;\n+  }\n+\n+  log_as_hex(last_obj_base, last_obj_end, last_obj_base + _buffer_to_requested_delta);\n+  if (last_obj_end < region_end) {\n+    log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n+                        p2i(last_obj_end + _buffer_to_requested_delta),\n+                        size_t(region_end - last_obj_end));\n+    log_as_hex(last_obj_end, region_end, last_obj_end + _buffer_to_requested_delta);\n+  }\n+}\n+\n+void AOTMapLogger::log_constant_pool(ConstantPool* cp, address requested_addr,\n+                                     const char* type_name, int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      cp->pool_holder()->external_name());\n+}\n+\n+void AOTMapLogger::log_constant_pool_cache(ConstantPoolCache* cpc, address requested_addr,\n+                                           const char* type_name, int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      cpc->constant_pool()->pool_holder()->external_name());\n+}\n+\n+void AOTMapLogger::log_const_method(ConstMethod* cm, address requested_addr, const char* type_name,\n+                                    int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  cm->method()->external_name());\n+}\n+\n+void AOTMapLogger::log_klass(Klass* k, address requested_addr, const char* type_name,\n+                             int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes, k->external_name());\n+}\n+\n+void AOTMapLogger::log_method(Method* m, address requested_addr, const char* type_name,\n+                              int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,  m->external_name());\n+}\n+\n+void AOTMapLogger::log_symbol(Symbol* s, address requested_addr, const char* type_name,\n+                              int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      s->as_quoted_ascii());\n+}\n+\n+#undef _LOG_PREFIX\n+\n+\/\/ Log all the data [base...top). Pretend that the base address\n+\/\/ will be mapped to requested_base at run-time.\n+void AOTMapLogger::log_as_hex(address base, address top, address requested_base, bool is_heap) {\n+  assert(top >= base, \"must be\");\n+\n+  LogStreamHandle(Trace, aot, map) lsh;\n+  if (lsh.is_enabled()) {\n+    int unitsize = sizeof(address);\n+    if (is_heap && UseCompressedOops) {\n+      \/\/ This makes the compressed oop pointers easier to read, but\n+      \/\/ longs and doubles will be split into two words.\n+      unitsize = sizeof(narrowOop);\n+    }\n+    os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n+  }\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\/\/ FakeOop (and subclasses FakeMirror, FakeString, FakeObjArray, FakeTypeArray) are used to traverse\n+\/\/ and print the (image of) heap objects stored in the AOT cache. These objects are different than regular oops:\n+\/\/ - They do not reside inside the range of the heap.\n+\/\/ - For +UseCompressedOops: pointers may use a different narrowOop encoding: see FakeOop::read_oop_at(narrowOop*)\n+\/\/ - For -UseCompressedOops: pointers are not direct: see FakeOop::read_oop_at(oop*)\n+\/\/\n+\/\/ Hence, in general, we cannot use regular oop API (such as oopDesc::obj_field()) on these objects. There\n+\/\/ are a few rare case where regular oop API work, but these are all guarded with the raw_oop() method and\n+\/\/ should be used with care.\n+class AOTMapLogger::FakeOop {\n+  static int _requested_shift;\n+  static intx _buffer_to_requested_delta;\n+  static address _buffer_start;\n+  static address _buffer_end;\n+  static uint64_t _buffer_start_narrow_oop; \/\/ The encoded narrow oop for the objects at _buffer_start\n+\n+  address _buffer_addr;\n+\n+  static void assert_range(address buffer_addr) {\n+    assert(_buffer_start <= buffer_addr && buffer_addr < _buffer_end, \"range check\");\n+  }\n+\n+  address* field_addr(int field_offset) {\n+    return (address*)(_buffer_addr + field_offset);\n+  }\n+\n+protected:\n+  RequestedMetadataAddr metadata_field(int field_offset) {\n+    return RequestedMetadataAddr(*(address*)(field_addr(field_offset)));\n+  }\n+\n+  \/\/ Return an \"oop\" pointer so we can use APIs that accept regular oops. This\n+  \/\/ must be used with care, as only a limited number of APIs can work with oops that\n+  \/\/ live outside of the range of the heap.\n+  oop raw_oop() { return cast_to_oop(_buffer_addr); }\n+\n+public:\n+  static void init_globals(address requested_base, address requested_start, int requested_shift,\n+                           address buffer_start, address buffer_end) {\n+    _requested_shift = requested_shift;\n+    _buffer_to_requested_delta = requested_start - buffer_start;\n+    _buffer_start = buffer_start;\n+    _buffer_end = buffer_end;\n+\n+    precond(requested_start >= requested_base);\n+    if (UseCompressedOops) {\n+      _buffer_start_narrow_oop = (uint64_t)(pointer_delta(requested_start, requested_base, 1)) >> _requested_shift;\n+      assert(_buffer_start_narrow_oop < 0xffffffff, \"sanity\");\n+    } else {\n+      _buffer_start_narrow_oop = 0xdeadbeed;\n+    }\n+  }\n+\n+  FakeOop() : _buffer_addr(nullptr) {}\n+\n+  FakeOop(address buffer_addr) : _buffer_addr(buffer_addr) {\n+    if (_buffer_addr != nullptr) {\n+      assert_range(_buffer_addr);\n+    }\n+  }\n+\n+  FakeMirror& as_mirror();\n+  FakeObjArray& as_obj_array();\n+  FakeString& as_string();\n+  FakeTypeArray& as_type_array();\n+\n+  RequestedMetadataAddr klass() {\n+    address rk = (address)real_klass();\n+    if (_is_runtime_logging) {\n+      return RequestedMetadataAddr(rk - _requested_to_mapped_metadata_delta);\n+    } else {\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      return builder->to_requested(builder->get_buffered_addr(rk));\n+    }\n+  }\n+\n+  Klass* real_klass() {\n+    assert(UseCompressedClassPointers, \"heap archiving requires UseCompressedClassPointers\");\n+    if (_is_runtime_logging) {\n+      return raw_oop()->klass();\n+    } else {\n+      return ArchiveHeapWriter::real_klass_of_buffered_oop(_buffer_addr);\n+    }\n+  }\n+\n+  \/\/ in heap words\n+  size_t size() {\n+    if (_is_runtime_logging) {\n+      return raw_oop()->size_given_klass(real_klass());\n+    } else {\n+      return ArchiveHeapWriter::size_of_buffered_oop(_buffer_addr);\n+    }\n+  }\n+\n+  bool is_array() { return real_klass()->is_array_klass(); }\n+  bool is_null() { return _buffer_addr == nullptr; }\n+\n+  int array_length() {\n+    precond(is_array());\n+    return arrayOop(raw_oop())->length();\n+  }\n+\n+  address requested_addr() {\n+    return _buffer_addr + _buffer_to_requested_delta;\n+  }\n+\n+  uint32_t as_narrow_oop_value() {\n+    precond(UseCompressedOops);\n+    if (_buffer_addr == nullptr) {\n+      return 0;\n+    }\n+    uint64_t pd = (uint64_t)(pointer_delta(_buffer_addr, _buffer_start, 1));\n+    return checked_cast<uint32_t>(_buffer_start_narrow_oop + (pd >> _requested_shift));\n+  }\n+\n+  FakeOop read_oop_at(narrowOop* addr) { \/\/ +UseCompressedOops\n+    uint64_t n = (uint64_t)(*addr);\n+    if (n == 0) {\n+      return FakeOop(nullptr);\n+    } else {\n+      precond(n >= _buffer_start_narrow_oop);\n+      address value = _buffer_start + ((n - _buffer_start_narrow_oop) << _requested_shift);\n+      return FakeOop(value);\n+    }\n+  }\n+\n+  FakeOop read_oop_at(oop* addr) { \/\/ -UseCompressedOops\n+    address requested_value = cast_from_oop<address>(*addr);\n+    if (requested_value == nullptr) {\n+      return FakeOop(nullptr);\n+    } else {\n+      return FakeOop(requested_value - _buffer_to_requested_delta);\n+    }\n+  }\n+\n+  FakeOop obj_field(int field_offset) {\n+    if (UseCompressedOops) {\n+      return read_oop_at(raw_oop()->field_addr<narrowOop>(field_offset));\n+    } else {\n+      return read_oop_at(raw_oop()->field_addr<oop>(field_offset));\n+    }\n+  }\n+\n+  void print_non_oop_field(outputStream* st, fieldDescriptor* fd) {\n+    \/\/ fd->print_on_for() works for non-oop fields in fake oops\n+    precond(fd->field_type() != T_ARRAY && fd->field_type() != T_OBJECT);\n+    fd->print_on_for(st, raw_oop());\n+  }\n+}; \/\/ AOTMapLogger::FakeOop\n+\n+class AOTMapLogger::FakeMirror : public AOTMapLogger::FakeOop {\n+public:\n+  void print_class_signature_on(outputStream* st);\n+\n+  Klass* real_mirrored_klass() {\n+    RequestedMetadataAddr mirrored_klass = metadata_field(java_lang_Class::klass_offset());\n+    return mirrored_klass.to_real_klass();\n+  }\n+\n+  int static_oop_field_count() {\n+    return java_lang_Class::static_oop_field_count(raw_oop());\n+  }\n+}; \/\/ AOTMapLogger::FakeMirror\n+\n+class AOTMapLogger::FakeObjArray : public AOTMapLogger::FakeOop {\n+  objArrayOop raw_objArrayOop() {\n+    return (objArrayOop)raw_oop();\n+  }\n+\n+public:\n+  int length() {\n+    return raw_objArrayOop()->length();\n+  }\n+  FakeOop obj_at(int i) {\n+    if (UseCompressedOops) {\n+      return read_oop_at(raw_objArrayOop()->obj_at_addr<narrowOop>(i));\n+    } else {\n+      return read_oop_at(raw_objArrayOop()->obj_at_addr<oop>(i));\n+    }\n+  }\n+}; \/\/ AOTMapLogger::FakeObjArray\n+\n+class AOTMapLogger::FakeString : public AOTMapLogger::FakeOop {\n+public:\n+  bool is_latin1() {\n+    jbyte coder = raw_oop()->byte_field(java_lang_String::coder_offset());\n+    assert(CompactStrings || coder == java_lang_String::CODER_UTF16, \"Must be UTF16 without CompactStrings\");\n+    return coder == java_lang_String::CODER_LATIN1;\n+  }\n+\n+  FakeTypeArray value();\n+\n+  int length();\n+  void print_on(outputStream* st, int max_length = MaxStringPrintSize);\n+}; \/\/ AOTMapLogger::FakeString\n+\n+class AOTMapLogger::FakeTypeArray : public AOTMapLogger::FakeOop {\n+  typeArrayOop raw_typeArrayOop() {\n+    return (typeArrayOop)raw_oop();\n+  }\n+\n+public:\n+  void print_elements_on(outputStream* st) {\n+    TypeArrayKlass::cast(real_klass())->oop_print_elements_on(raw_typeArrayOop(), st);\n+  }\n+\n+  int length() { return raw_typeArrayOop()->length(); }\n+  jbyte byte_at(int i) { return raw_typeArrayOop()->byte_at(i); }\n+  jchar char_at(int i) { return raw_typeArrayOop()->char_at(i); }\n+}; \/\/ AOTMapLogger::FakeTypeArray\n+\n+AOTMapLogger::FakeMirror& AOTMapLogger::FakeOop::as_mirror() {\n+  precond(real_klass() == vmClasses::Class_klass());\n+  return (FakeMirror&)*this;\n+}\n+\n+AOTMapLogger::FakeObjArray& AOTMapLogger::FakeOop::as_obj_array() {\n+  precond(real_klass()->is_objArray_klass());\n+  return (FakeObjArray&)*this;\n+}\n+\n+AOTMapLogger::FakeTypeArray& AOTMapLogger::FakeOop::as_type_array() {\n+  precond(real_klass()->is_typeArray_klass());\n+  return (FakeTypeArray&)*this;\n+}\n+\n+AOTMapLogger::FakeString& AOTMapLogger::FakeOop::as_string() {\n+  precond(real_klass() == vmClasses::String_klass());\n+  return (FakeString&)*this;\n+}\n+\n+void AOTMapLogger::FakeMirror::print_class_signature_on(outputStream* st) {\n+  ResourceMark rm;\n+  RequestedMetadataAddr requested_klass = metadata_field(java_lang_Class::klass_offset());\n+  Klass* real_klass = requested_klass.to_real_klass();\n+\n+  if (real_klass == nullptr) {\n+    \/\/ This is a primitive mirror (Java expressions of int.class, long.class, void.class, etc);\n+    RequestedMetadataAddr requested_array_klass = metadata_field(java_lang_Class::array_klass_offset());\n+    Klass* real_array_klass = requested_array_klass.to_real_klass();\n+    if (real_array_klass == nullptr) {\n+      st->print(\" V\"); \/\/ The special mirror for void.class that doesn't have any representation in C++\n+    } else {\n+      precond(real_array_klass->is_typeArray_klass());\n+      st->print(\" %c\", real_array_klass->name()->char_at(1));\n+    }\n+  } else {\n+    const char* class_name = real_klass->name()->as_C_string();\n+    if (real_klass->is_instance_klass()) {\n+      st->print(\" L%s;\", class_name);\n+    } else {\n+      st->print(\" %s\", class_name);\n+    }\n+    if (real_klass->has_aot_initialized_mirror()) {\n+      st->print(\" (aot-inited)\");\n+    }\n+  }\n+}\n+\n+AOTMapLogger::FakeTypeArray AOTMapLogger::FakeString::value() {\n+  return obj_field(java_lang_String::value_offset()).as_type_array();\n+}\n+\n+int AOTMapLogger::FakeString::length() {\n+  FakeTypeArray v = value();\n+  if (v.is_null()) {\n+    return 0;\n+  }\n+  int arr_length = v.length();\n+  if (!is_latin1()) {\n+    assert((arr_length & 1) == 0, \"should be even for UTF16 string\");\n+    arr_length >>= 1; \/\/ convert number of bytes to number of elements\n+  }\n+  return arr_length;\n+}\n+\n+void AOTMapLogger::FakeString::print_on(outputStream* st, int max_length) {\n+  FakeTypeArray v = value();\n+  int length = this->length();\n+  bool is_latin1 = this->is_latin1();\n+  bool abridge = length > max_length;\n+\n+  st->print(\"\\\"\");\n+  for (int index = 0; index < length; index++) {\n+    \/\/ If we need to abridge and we've printed half the allowed characters\n+    \/\/ then jump to the tail of the string.\n+    if (abridge && index >= max_length \/ 2) {\n+      st->print(\" ... (%d characters ommitted) ... \", length - 2 * (max_length \/ 2));\n+      index = length - (max_length \/ 2);\n+      abridge = false; \/\/ only do this once\n+    }\n+    jchar c = (!is_latin1) ?  v.char_at(index) :\n+                             ((jchar) v.byte_at(index)) & 0xff;\n+    if (c < ' ') {\n+      st->print(\"\\\\x%02X\", c); \/\/ print control characters e.g. \\x0A\n+    } else {\n+      st->print(\"%c\", c);\n+    }\n+  }\n+  st->print(\"\\\"\");\n+\n+  if (length > max_length) {\n+    st->print(\" (abridged) \");\n+  }\n+}\n+\n+class AOTMapLogger::ArchivedFieldPrinter : public FieldClosure {\n+  FakeOop _fake_oop;\n+  outputStream* _st;\n+public:\n+  ArchivedFieldPrinter(FakeOop fake_oop, outputStream* st) : _fake_oop(fake_oop), _st(st) {}\n+\n+  void do_field(fieldDescriptor* fd) {\n+    _st->print(\" - \");\n+    BasicType ft = fd->field_type();\n+    switch (ft) {\n+    case T_ARRAY:\n+    case T_OBJECT:\n+      {\n+        fd->print_on(_st); \/\/ print just the name and offset\n+        FakeOop field_value = _fake_oop.obj_field(fd->offset());\n+        print_oop_info_cr(_st, field_value);\n+      }\n+      break;\n+    default:\n+      _fake_oop.print_non_oop_field(_st, fd); \/\/ name, offset, value\n+      _st->cr();\n+    }\n+  }\n+}; \/\/ AOTMapLogger::ArchivedFieldPrinter\n+\n+int AOTMapLogger::FakeOop::_requested_shift;\n+intx AOTMapLogger::FakeOop::_buffer_to_requested_delta;\n+address AOTMapLogger::FakeOop::_buffer_start;\n+address AOTMapLogger::FakeOop::_buffer_end;\n+uint64_t AOTMapLogger::FakeOop::_buffer_start_narrow_oop;\n+\n+void AOTMapLogger::dumptime_log_heap_region(ArchiveHeapInfo* heap_info) {\n+  MemRegion r = heap_info->buffer_region();\n+  address buffer_start = address(r.start()); \/\/ start of the current oop inside the buffer\n+  address buffer_end = address(r.end());\n+\n+  address requested_base = UseCompressedOops ? (address)CompressedOops::base() : (address)ArchiveHeapWriter::NOCOOPS_REQUESTED_BASE;\n+  address requested_start = UseCompressedOops ? ArchiveHeapWriter::buffered_addr_to_requested_addr(buffer_start) : requested_base;\n+  int requested_shift =  CompressedOops::shift();\n+\n+  FakeOop::init_globals(requested_base, requested_start, requested_shift, buffer_start, buffer_end);\n+\n+  log_region_range(\"heap\", buffer_start, buffer_end, requested_start);\n+  log_oops(buffer_start, buffer_end);\n+}\n+\n+void AOTMapLogger::runtime_log_heap_region(FileMapInfo* mapinfo) {\n+  ResourceMark rm;\n+  int heap_region_index = AOTMetaspace::hp;\n+  FileMapRegion* r = mapinfo->region_at(heap_region_index);\n+  size_t alignment = ObjectAlignmentInBytes;\n+\n+  \/\/ Allocate a buffer and read the image of the archived heap region. This buffer is outside\n+  \/\/ of the real Java heap, so we must use FakeOop to access the contents of the archived heap objects.\n+  char* buffer = resource_allocate_bytes(r->used() + alignment);\n+  address buffer_start = (address)align_up(buffer, alignment);\n+  address buffer_end = buffer_start + r->used();\n+  if (!mapinfo->read_region(heap_region_index, (char*)buffer_start, r->used(), \/* do_commit = *\/ false)) {\n+    log_error(aot)(\"Cannot read heap region; AOT map logging of heap objects failed\");\n+    return;\n+  }\n+\n+  address requested_base = UseCompressedOops ? (address)mapinfo->narrow_oop_base() : mapinfo->heap_region_requested_address();\n+  address requested_start = requested_base + r->mapping_offset();\n+  int requested_shift = mapinfo->narrow_oop_shift();\n+\n+  FakeOop::init_globals(requested_base, requested_start, requested_shift, buffer_start, buffer_end);\n+\n+  log_region_range(\"heap\", buffer_start, buffer_end, requested_start);\n+  log_oops(buffer_start, buffer_end);\n+}\n+\n+void AOTMapLogger::log_oops(address buffer_start, address buffer_end) {\n+  LogStreamHandle(Debug, aot, map) st;\n+  if (!st.is_enabled()) {\n+    return;\n+  }\n+\n+  _roots = new GrowableArrayCHeap<FakeOop, mtClass>();\n+  _num_obj_arrays_logged = 0;\n+\n+  for (address fop = buffer_start; fop < buffer_end; ) {\n+    FakeOop fake_oop(fop);\n+    st.print(PTR_FORMAT \": @@ Object \", p2i(fake_oop.requested_addr()));\n+    print_oop_info_cr(&st, fake_oop, \/*print_requested_addr=*\/false);\n+\n+    LogStreamHandle(Trace, aot, map, oops) trace_st;\n+    if (trace_st.is_enabled()) {\n+      print_oop_details(fake_oop, &trace_st);\n+    }\n+\n+    address next_fop = fop + fake_oop.size() * BytesPerWord;\n+    log_as_hex(fop, next_fop, fake_oop.requested_addr(), \/*is_heap=*\/true);\n+\n+    fop = next_fop;\n+  }\n+\n+  delete _roots;\n+}\n+\n+void AOTMapLogger::print_oop_info_cr(outputStream* st, FakeOop fake_oop, bool print_requested_addr) {\n+  if (fake_oop.is_null()) {\n+    st->print_cr(\"null\");\n+  } else {\n+    ResourceMark rm;\n+    Klass* real_klass = fake_oop.real_klass();\n+    address requested_addr = fake_oop.requested_addr();\n+    if (print_requested_addr) {\n+      st->print(PTR_FORMAT \" \", p2i(requested_addr));\n+    }\n+    if (UseCompressedOops) {\n+      st->print(\"(0x%08x) \", fake_oop.as_narrow_oop_value());\n+    }\n+    if (fake_oop.is_array()) {\n+      int array_len = fake_oop.array_length();\n+      st->print_cr(\"%s length: %d\", real_klass->external_name(), array_len);\n+    } else {\n+      st->print(\"%s\", real_klass->external_name());\n+\n+      if (real_klass == vmClasses::String_klass()) {\n+        st->print(\" \");\n+        fake_oop.as_string().print_on(st);\n+      } else if (real_klass == vmClasses::Class_klass()) {\n+        fake_oop.as_mirror().print_class_signature_on(st);\n+      }\n+\n+      st->cr();\n+    }\n+  }\n+}\n+\n+\/\/ Print the fields of instanceOops, or the elements of arrayOops\n+void AOTMapLogger::print_oop_details(FakeOop fake_oop, outputStream* st) {\n+  Klass* real_klass = fake_oop.real_klass();\n+\n+  st->print(\" - klass: \");\n+  real_klass->print_value_on(st);\n+  st->print(\" \" PTR_FORMAT, p2i(fake_oop.klass().raw_addr()));\n+  st->cr();\n+\n+  if (real_klass->is_typeArray_klass()) {\n+    fake_oop.as_type_array().print_elements_on(st);\n+  } else if (real_klass->is_objArray_klass()) {\n+    FakeObjArray fake_obj_array = fake_oop.as_obj_array();\n+    bool is_logging_root_segment = _num_obj_arrays_logged < _num_root_segments;\n+\n+    for (int i = 0; i < fake_obj_array.length(); i++) {\n+      FakeOop elm = fake_obj_array.obj_at(i);\n+      if (is_logging_root_segment) {\n+        st->print(\" root[%4d]: \", _roots->length());\n+        _roots->append(elm);\n+      } else {\n+        st->print(\" -%4d: \", i);\n+      }\n+      print_oop_info_cr(st, elm);\n+    }\n+    _num_obj_arrays_logged ++;\n+  } else {\n+    st->print_cr(\" - fields (%zu words):\", fake_oop.size());\n+\n+    ArchivedFieldPrinter print_field(fake_oop, st);\n+    InstanceKlass::cast(real_klass)->print_nonstatic_fields(&print_field);\n+\n+    if (real_klass == vmClasses::Class_klass()) {\n+      FakeMirror fake_mirror = fake_oop.as_mirror();\n+\n+      st->print(\" - signature: \");\n+      fake_mirror.print_class_signature_on(st);\n+      st->cr();\n+\n+      Klass* real_mirrored_klass = fake_mirror.real_mirrored_klass();\n+      if (real_mirrored_klass != nullptr && real_mirrored_klass->is_instance_klass()) {\n+        InstanceKlass* real_mirrored_ik = InstanceKlass::cast(real_mirrored_klass);\n+\n+        ConstantPoolCache* cp_cache = real_mirrored_ik->constants()->cache();\n+        if (!_is_runtime_logging) {\n+          cp_cache = ArchiveBuilder::current()->get_buffered_addr(cp_cache);\n+        }\n+        int rr_root_index = cp_cache->archived_references_index();\n+        st->print(\" - resolved_references: \");\n+        if (rr_root_index >= 0) {\n+          FakeOop resolved_references = _roots->at(rr_root_index);\n+          print_oop_info_cr(st, resolved_references);\n+        } else {\n+          st->print(\"null\");\n+        }\n+\n+        st->print_cr(\"- ---- static fields (%d):\", fake_mirror.static_oop_field_count());\n+        real_mirrored_ik->do_local_static_fields(&print_field);\n+      }\n+    }\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":930,"deletions":0,"binary":false,"changes":930,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTMAPLOGGER_HPP\n+#define SHARE_CDS_AOTMAPLOGGER_HPP\n+\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ArchiveHeapInfo;\n+class DumpRegion;\n+class FileMapInfo;\n+class outputStream;\n+\n+\/\/ Write detailed info to a mapfile to analyze contents of the AOT cache\/CDS archive.\n+\/\/ -Xlog:aot+map* can be used both when creating an AOT cache, or when using an AOT cache.\n+\/\/\n+\/\/ Creating cache:\n+\/\/     java -XX:AOTCacheOutput=app.aot -Xlog:aot+map*=trace -cp app.jar App\n+\/\/\n+\/\/ Using cache:\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace -cp app.jar App\n+\/\/\n+\/\/ You can also print the map of a cache without executing the application by using the\n+\/\/ --version flag:\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace --version\n+\/\/\n+\/\/ Because the output can be large, it's best to save it to a file\n+\/\/     java -XX:AOTCache=app.aot -Xlog:aot+map*=trace:file=aot.map:none:filesize=0 --version\n+class AOTMapLogger : AllStatic {\n+  struct ArchivedObjInfo {\n+    address _src_addr;\n+    address _buffered_addr;\n+    address _requested_addr;\n+    int _bytes;\n+    MetaspaceObj::Type _type;\n+  };\n+\n+  \/\/ FakeOop and subtypes\n+  class FakeOop;\n+  class   FakeMirror;\n+  class   FakeObjArray;\n+  class   FakeString;\n+  class   FakeTypeArray;\n+\n+  class RequestedMetadataAddr;\n+  class RuntimeGatherArchivedMetaspaceObjs;\n+\n+  static bool _is_logging_at_bootstrap;\n+  static bool _is_runtime_logging;\n+  static size_t _num_root_segments;\n+  static size_t _num_obj_arrays_logged;\n+  static GrowableArrayCHeap<FakeOop, mtClass>* _roots;\n+  static ArchiveHeapInfo* _dumptime_heap_info;\n+\n+  static intx _buffer_to_requested_delta;\n+  static intx _requested_to_mapped_metadata_delta;\n+\n+  static void runtime_log(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs);\n+  static void runtime_log_metaspace_regions(FileMapInfo* mapinfo, GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs);\n+  static void dumptime_log_metaspace_region(const char* name, DumpRegion* region,\n+                                            const ArchiveBuilder::SourceObjList* src_objs);\n+\n+  \/\/ Common code for dumptime\/runtime\n+  static void log_file_header(FileMapInfo* mapinfo);\n+  static void log_region_range(const char* name, address base, address top, address requested_base);\n+  static void log_metaspace_objects_impl(address region_base, address region_end,\n+                                         GrowableArrayCHeap<ArchivedObjInfo, mtClass>* objs, int start_idx, int end_idx);\n+  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false);\n+\n+  \/\/ Metaspace object: type-specific logging\n+  static void log_constant_pool(ConstantPool* cp, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_constant_pool_cache(ConstantPoolCache* cpc, address requested_addr,\n+                                      const char* type_name, int bytes, Thread* current);\n+  static void log_const_method(ConstMethod* cm, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_klass(Klass* k, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_method(Method* m, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_symbol(Symbol* s, address requested_addr, const char* type_name, int bytes, Thread* current);\n+\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  static void dumptime_log_heap_region(ArchiveHeapInfo* heap_info);\n+  static void runtime_log_heap_region(FileMapInfo* mapinfo);\n+\n+  static void print_oop_info_cr(outputStream* st, FakeOop fake_oop, bool print_requested_addr = true);\n+  static void print_oop_details(FakeOop fake_oop, outputStream* st);\n+  static void log_oops(address buf_start, address buf_end);\n+  class ArchivedFieldPrinter; \/\/ to be replaced by ArchivedFieldPrinter2\n+#endif\n+\n+public:\n+  static void ergo_initialize();\n+  static bool is_logging_at_bootstrap() { return _is_logging_at_bootstrap; }\n+\n+  static void dumptime_log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n+                           ArchiveHeapInfo* heap_info,\n+                           char* bitmap, size_t bitmap_size_in_bytes);\n+  static void runtime_log(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTMAPLOGGER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.hpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"cds\/aotMapLogger.hpp\"\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -49,1 +51,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -100,0 +101,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -102,1 +104,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -106,9 +107,9 @@\n-ReservedSpace MetaspaceShared::_symbol_rs;\n-VirtualSpace MetaspaceShared::_symbol_vs;\n-bool MetaspaceShared::_archive_loading_failed = false;\n-bool MetaspaceShared::_remapped_readwrite = false;\n-void* MetaspaceShared::_shared_metaspace_static_top = nullptr;\n-intx MetaspaceShared::_relocation_delta;\n-char* MetaspaceShared::_requested_base_address;\n-Array<Method*>* MetaspaceShared::_archived_method_handle_intrinsics = nullptr;\n-bool MetaspaceShared::_use_optimized_module_handling = true;\n+ReservedSpace AOTMetaspace::_symbol_rs;\n+VirtualSpace AOTMetaspace::_symbol_vs;\n+bool AOTMetaspace::_archive_loading_failed = false;\n+bool AOTMetaspace::_remapped_readwrite = false;\n+void* AOTMetaspace::_aot_metaspace_static_top = nullptr;\n+intx AOTMetaspace::_relocation_delta;\n+char* AOTMetaspace::_requested_base_address;\n+Array<Method*>* AOTMetaspace::_archived_method_handle_intrinsics = nullptr;\n+bool AOTMetaspace::_use_optimized_module_handling = true;\n@@ -123,1 +124,1 @@\n-\/\/ These regions are aligned with MetaspaceShared::core_region_alignment().\n+\/\/ These regions are aligned with AOTMetaspace::core_region_alignment().\n@@ -126,1 +127,1 @@\n-\/\/ [0] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are\n+\/\/ [0] All classes are loaded in AOTMetaspace::preload_classes(). All metadata are\n@@ -141,1 +142,1 @@\n-char* MetaspaceShared::symbol_space_alloc(size_t num_bytes) {\n+char* AOTMetaspace::symbol_space_alloc(size_t num_bytes) {\n@@ -154,1 +155,1 @@\n-size_t MetaspaceShared::core_region_alignment() {\n+size_t AOTMetaspace::core_region_alignment() {\n@@ -158,1 +159,1 @@\n-size_t MetaspaceShared::protection_zone_size() {\n+size_t AOTMetaspace::protection_zone_size() {\n@@ -181,1 +182,1 @@\n-  ResizeableResourceHashtable<InstanceKlass*, bool,\n+  ResizeableHashTable<InstanceKlass*, bool,\n@@ -193,2 +194,2 @@\n-    if (ik->java_super()) {\n-      dump(ik->java_super());\n+    if (ik->super()) {\n+      dump(ik->super());\n@@ -219,1 +220,1 @@\n-void MetaspaceShared::dump_loaded_classes(const char* file_name, TRAPS) {\n+void AOTMetaspace::dump_loaded_classes(const char* file_name, TRAPS) {\n@@ -247,1 +248,1 @@\n-  size_t alignment = MetaspaceShared::core_region_alignment();\n+  size_t alignment = AOTMetaspace::core_region_alignment();\n@@ -293,1 +294,1 @@\n-void MetaspaceShared::initialize_for_static_dump() {\n+void AOTMetaspace::initialize_for_static_dump() {\n@@ -320,1 +321,1 @@\n-    MetaspaceShared::unrecoverable_writing_error();\n+    AOTMetaspace::unrecoverable_writing_error();\n@@ -326,1 +327,1 @@\n-void MetaspaceShared::post_initialize(TRAPS) {\n+void AOTMetaspace::post_initialize(TRAPS) {\n@@ -328,0 +329,18 @@\n+    FileMapInfo *static_mapinfo = FileMapInfo::current_info();\n+    FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n+\n+    if (AOTMapLogger::is_logging_at_bootstrap()) {\n+      \/\/ The map logging needs to be done here, as it requires some stubs on Windows,\n+      \/\/ which are not generated until the end of init_globals().\n+      AOTMapLogger::runtime_log(static_mapinfo, dynamic_mapinfo);\n+    }\n+\n+    \/\/ Close any open file descriptors. However, mmap'ed pages will remain in memory.\n+    static_mapinfo->close();\n+    static_mapinfo->unmap_region(AOTMetaspace::bm);\n+\n+    if (dynamic_mapinfo != nullptr) {\n+      dynamic_mapinfo->close();\n+      dynamic_mapinfo->unmap_region(AOTMetaspace::bm);\n+    }\n+\n@@ -342,1 +361,1 @@\n-void MetaspaceShared::read_extra_data(JavaThread* current, const char* filename) {\n+void AOTMetaspace::read_extra_data(JavaThread* current, const char* filename) {\n@@ -356,1 +375,1 @@\n-      MetaspaceShared::unrecoverable_loading_error();\n+      AOTMetaspace::unrecoverable_loading_error();\n@@ -391,1 +410,1 @@\n-void MetaspaceShared::make_method_handle_intrinsics_shareable() {\n+void AOTMetaspace::make_method_handle_intrinsics_shareable() {\n@@ -400,1 +419,1 @@\n-void MetaspaceShared::write_method_handle_intrinsics() {\n+void AOTMetaspace::write_method_handle_intrinsics() {\n@@ -436,1 +455,1 @@\n-\/\/ of these xxx::serialize() functions inside MetaspaceShared::serialize(), which\n+\/\/ of these xxx::serialize() functions inside AOTMetaspace::serialize(), which\n@@ -442,1 +461,1 @@\n-\/\/ MetaspaceShared::early_serialize(). Such functions must not produce side effects that\n+\/\/ AOTMetaspace::early_serialize(). Such functions must not produce side effects that\n@@ -445,1 +464,1 @@\n-void MetaspaceShared::early_serialize(SerializeClosure* soc) {\n+void AOTMetaspace::early_serialize(SerializeClosure* soc) {\n@@ -452,1 +471,1 @@\n-void MetaspaceShared::serialize(SerializeClosure* soc) {\n+void AOTMetaspace::serialize(SerializeClosure* soc) {\n@@ -525,1 +544,1 @@\n-void MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {\n+void AOTMetaspace::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {\n@@ -601,1 +620,1 @@\n-  MetaspaceShared::early_serialize(&wc);\n+  AOTMetaspace::early_serialize(&wc);\n@@ -617,1 +636,1 @@\n-  MetaspaceShared::write_method_handle_intrinsics();\n+  AOTMetaspace::write_method_handle_intrinsics();\n@@ -630,1 +649,1 @@\n-  MetaspaceShared::serialize(&wc);\n+  AOTMetaspace::serialize(&wc);\n@@ -668,1 +687,1 @@\n-  MetaspaceShared::make_method_handle_intrinsics_shareable();\n+  AOTMetaspace::make_method_handle_intrinsics_shareable();\n@@ -696,1 +715,1 @@\n-  _map_info->populate_header(MetaspaceShared::core_region_alignment());\n+  _map_info->populate_header(AOTMetaspace::core_region_alignment());\n@@ -738,1 +757,1 @@\n-bool MetaspaceShared::may_be_eagerly_linked(InstanceKlass* ik) {\n+bool AOTMetaspace::may_be_eagerly_linked(InstanceKlass* ik) {\n@@ -757,1 +776,1 @@\n-void MetaspaceShared::link_shared_classes(TRAPS) {\n+void AOTMetaspace::link_shared_classes(TRAPS) {\n@@ -800,1 +819,1 @@\n-void MetaspaceShared::preload_and_dump(TRAPS) {\n+void AOTMetaspace::preload_and_dump(TRAPS) {\n@@ -816,1 +835,1 @@\n-      MetaspaceShared::writing_error();\n+      AOTMetaspace::writing_error();\n@@ -821,1 +840,1 @@\n-      MetaspaceShared::writing_error(err_msg(\"Unexpected exception, use -Xlog:aot%s,exceptions=trace for detail\",\n+      AOTMetaspace::writing_error(err_msg(\"Unexpected exception, use -Xlog:aot%s,exceptions=trace for detail\",\n@@ -848,1 +867,1 @@\n-void MetaspaceShared::adjust_heap_sizes_for_dumping() {\n+void AOTMetaspace::adjust_heap_sizes_for_dumping() {\n@@ -871,1 +890,1 @@\n-void MetaspaceShared::get_default_classlist(char* default_classlist, const size_t buf_size) {\n+void AOTMetaspace::get_default_classlist(char* default_classlist, const size_t buf_size) {\n@@ -877,1 +896,1 @@\n-void MetaspaceShared::preload_classes(TRAPS) {\n+void AOTMetaspace::preload_classes(TRAPS) {\n@@ -912,1 +931,1 @@\n-void MetaspaceShared::exercise_runtime_cds_code(TRAPS) {\n+void AOTMetaspace::exercise_runtime_cds_code(TRAPS) {\n@@ -921,1 +940,1 @@\n-void MetaspaceShared::preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) {\n+void AOTMetaspace::preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) {\n@@ -1042,2 +1061,2 @@\n-bool MetaspaceShared::write_static_archive(ArchiveBuilder* builder, FileMapInfo* map_info, ArchiveHeapInfo* heap_info) {\n-  \/\/ relocate the data so that it can be mapped to MetaspaceShared::requested_base_address()\n+bool AOTMetaspace::write_static_archive(ArchiveBuilder* builder, FileMapInfo* map_info, ArchiveHeapInfo* heap_info) {\n+  \/\/ relocate the data so that it can be mapped to AOTMetaspace::requested_base_address()\n@@ -1161,1 +1180,1 @@\n-void MetaspaceShared::fork_and_dump_final_static_archive(TRAPS) {\n+void AOTMetaspace::fork_and_dump_final_static_archive(TRAPS) {\n@@ -1187,1 +1206,1 @@\n-bool MetaspaceShared::try_link_class(JavaThread* current, InstanceKlass* ik) {\n+bool AOTMetaspace::try_link_class(JavaThread* current, InstanceKlass* ik) {\n@@ -1192,1 +1211,1 @@\n-  if (ik->is_shared() && !CDSConfig::is_dumping_final_static_archive()) {\n+  if (ik->in_aot_cache() && !CDSConfig::is_dumping_final_static_archive()) {\n@@ -1236,1 +1255,1 @@\n-void MetaspaceShared::set_shared_metaspace_range(void* base, void *static_top, void* top) {\n+void AOTMetaspace::set_aot_metaspace_range(void* base, void *static_top, void* top) {\n@@ -1238,2 +1257,2 @@\n-  _shared_metaspace_static_top = static_top;\n-  MetaspaceObj::set_shared_metaspace_range(base, top);\n+  _aot_metaspace_static_top = static_top;\n+  MetaspaceObj::set_aot_metaspace_range(base, top);\n@@ -1242,3 +1261,3 @@\n-bool MetaspaceShared::is_shared_dynamic(void* p) {\n-  if ((p < MetaspaceObj::shared_metaspace_top()) &&\n-      (p >= _shared_metaspace_static_top)) {\n+bool AOTMetaspace::in_aot_cache_dynamic_region(void* p) {\n+  if ((p < MetaspaceObj::aot_metaspace_top()) &&\n+      (p >= _aot_metaspace_static_top)) {\n@@ -1251,2 +1270,2 @@\n-bool MetaspaceShared::is_shared_static(void* p) {\n-  if (is_in_shared_metaspace(p) && !is_shared_dynamic(p)) {\n+bool AOTMetaspace::in_aot_cache_static_region(void* p) {\n+  if (in_aot_cache(p) && !in_aot_cache_dynamic_region(p)) {\n@@ -1264,1 +1283,1 @@\n-void MetaspaceShared::unrecoverable_loading_error(const char* message) {\n+void AOTMetaspace::unrecoverable_loading_error(const char* message) {\n@@ -1276,1 +1295,1 @@\n-void MetaspaceShared::report_loading_error(const char* format, ...) {\n+void AOTMetaspace::report_loading_error(const char* format, ...) {\n@@ -1309,1 +1328,1 @@\n-void MetaspaceShared::unrecoverable_writing_error(const char* message) {\n+void AOTMetaspace::unrecoverable_writing_error(const char* message) {\n@@ -1316,1 +1335,1 @@\n-void MetaspaceShared::writing_error(const char* message) {\n+void AOTMetaspace::writing_error(const char* message) {\n@@ -1323,1 +1342,1 @@\n-void MetaspaceShared::initialize_runtime_shared_and_meta_spaces() {\n+void AOTMetaspace::initialize_runtime_shared_and_meta_spaces() {\n@@ -1352,1 +1371,1 @@\n-    set_shared_metaspace_range(cds_base, static_mapinfo->mapped_end(), cds_end);\n+    set_aot_metaspace_range(cds_base, static_mapinfo->mapped_end(), cds_end);\n@@ -1360,1 +1379,1 @@\n-    set_shared_metaspace_range(nullptr, nullptr, nullptr);\n+    set_aot_metaspace_range(nullptr, nullptr, nullptr);\n@@ -1369,1 +1388,1 @@\n-      MetaspaceShared::unrecoverable_loading_error(\"Unable to use shared archive.\");\n+      AOTMetaspace::unrecoverable_loading_error(\"Unable to use shared archive.\");\n@@ -1372,1 +1391,1 @@\n-        MetaspaceShared::unrecoverable_loading_error(\"Unable to map shared spaces\");\n+        AOTMetaspace::unrecoverable_loading_error(\"Unable to map shared spaces\");\n@@ -1390,1 +1409,1 @@\n-      MetaspaceShared::unrecoverable_loading_error(\"Unable to map shared spaces\");\n+      AOTMetaspace::unrecoverable_loading_error(\"Unable to map shared spaces\");\n@@ -1394,1 +1413,1 @@\n-FileMapInfo* MetaspaceShared::open_static_archive() {\n+FileMapInfo* AOTMetaspace::open_static_archive() {\n@@ -1405,1 +1424,1 @@\n-FileMapInfo* MetaspaceShared::open_dynamic_archive() {\n+FileMapInfo* AOTMetaspace::open_dynamic_archive() {\n@@ -1418,1 +1437,1 @@\n-      MetaspaceShared::unrecoverable_loading_error(\"Failed to initialize dynamic archive\");\n+      AOTMetaspace::unrecoverable_loading_error(\"Failed to initialize dynamic archive\");\n@@ -1428,2 +1447,2 @@\n-MapArchiveResult MetaspaceShared::map_archives(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo,\n-                                               bool use_requested_addr) {\n+MapArchiveResult AOTMetaspace::map_archives(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo,\n+                                            bool use_requested_addr) {\n@@ -1450,1 +1469,1 @@\n-    \/\/ archives, or else it would mess up the simple comparison in MetaspaceObj::is_shared().\n+    \/\/ archives, or else it would mess up the simple comparison in MetaspaceObj::in_aot_cache().\n@@ -1501,1 +1520,1 @@\n-    if (MetaspaceShared::use_windows_memory_mapping()) {\n+    if (AOTMetaspace::use_windows_memory_mapping()) {\n@@ -1705,6 +1724,6 @@\n-char* MetaspaceShared::reserve_address_space_for_archives(FileMapInfo* static_mapinfo,\n-                                                          FileMapInfo* dynamic_mapinfo,\n-                                                          bool use_archive_base_addr,\n-                                                          ReservedSpace& total_space_rs,\n-                                                          ReservedSpace& archive_space_rs,\n-                                                          ReservedSpace& class_space_rs) {\n+char* AOTMetaspace::reserve_address_space_for_archives(FileMapInfo* static_mapinfo,\n+                                                       FileMapInfo* dynamic_mapinfo,\n+                                                       bool use_archive_base_addr,\n+                                                       ReservedSpace& total_space_rs,\n+                                                       ReservedSpace& archive_space_rs,\n+                                                       ReservedSpace& class_space_rs) {\n@@ -1863,3 +1882,3 @@\n-void MetaspaceShared::release_reserved_spaces(ReservedSpace& total_space_rs,\n-                                              ReservedSpace& archive_space_rs,\n-                                              ReservedSpace& class_space_rs) {\n+void AOTMetaspace::release_reserved_spaces(ReservedSpace& total_space_rs,\n+                                           ReservedSpace& archive_space_rs,\n+                                           ReservedSpace& class_space_rs) {\n@@ -1884,1 +1903,1 @@\n-static int archive_regions[]     = { MetaspaceShared::rw, MetaspaceShared::ro };\n+static int archive_regions[]     = { AOTMetaspace::rw, AOTMetaspace::ro };\n@@ -1887,1 +1906,1 @@\n-MapArchiveResult MetaspaceShared::map_archive(FileMapInfo* mapinfo, char* mapped_base_address, ReservedSpace rs) {\n+MapArchiveResult AOTMetaspace::map_archive(FileMapInfo* mapinfo, char* mapped_base_address, ReservedSpace rs) {\n@@ -1930,1 +1949,1 @@\n-void MetaspaceShared::unmap_archive(FileMapInfo* mapinfo) {\n+void AOTMetaspace::unmap_archive(FileMapInfo* mapinfo) {\n@@ -1934,1 +1953,1 @@\n-    mapinfo->unmap_region(MetaspaceShared::bm);\n+    mapinfo->unmap_region(AOTMetaspace::bm);\n@@ -1955,1 +1974,1 @@\n-void MetaspaceShared::initialize_shared_spaces() {\n+void AOTMetaspace::initialize_shared_spaces() {\n@@ -1957,0 +1976,1 @@\n+  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1972,6 +1992,0 @@\n-  \/\/ Close the mapinfo file\n-  static_mapinfo->close();\n-\n-  static_mapinfo->unmap_region(MetaspaceShared::bm);\n-\n-  FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();\n@@ -1983,2 +1997,0 @@\n-    dynamic_mapinfo->close();\n-    dynamic_mapinfo->unmap_region(MetaspaceShared::bm);\n@@ -2043,1 +2055,1 @@\n-bool MetaspaceShared::remap_shared_readonly_as_readwrite() {\n+bool AOTMetaspace::remap_shared_readonly_as_readwrite() {\n@@ -2063,1 +2075,1 @@\n-void MetaspaceShared::print_on(outputStream* st) {\n+void AOTMetaspace::print_on(outputStream* st) {\n@@ -2066,3 +2078,3 @@\n-    address base = (address)MetaspaceObj::shared_metaspace_base();\n-    address static_top = (address)_shared_metaspace_static_top;\n-    address top = (address)MetaspaceObj::shared_metaspace_top();\n+    address base = (address)MetaspaceObj::aot_metaspace_base();\n+    address static_top = (address)_aot_metaspace_static_top;\n+    address top = (address)MetaspaceObj::aot_metaspace_top();\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":117,"deletions":105,"binary":false,"changes":222,"previous_filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","status":"renamed"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SHARE_CDS_METASPACESHARED_HPP\n-#define SHARE_CDS_METASPACESHARED_HPP\n+#ifndef SHARE_CDS_AOTMETASPACE_HPP\n+#define SHARE_CDS_AOTMETASPACE_HPP\n@@ -52,1 +52,1 @@\n-class MetaspaceShared : AllStatic {\n+class AOTMetaspace : AllStatic {\n@@ -57,1 +57,1 @@\n-  static void* _shared_metaspace_static_top;\n+  static void* _aot_metaspace_static_top;\n@@ -66,2 +66,2 @@\n-    rw = 0,  \/\/ read-write shared space\n-    ro = 1,  \/\/ read-only shared space\n+    rw = 0,  \/\/ read-write\n+    ro = 1,  \/\/ read-only\n@@ -104,2 +104,2 @@\n-  static bool is_in_shared_metaspace(const void* p) {\n-    return MetaspaceObj::is_shared((const MetaspaceObj*)p);\n+  static bool in_aot_cache(const void* p) {\n+    return MetaspaceObj::in_aot_cache((const MetaspaceObj*)p);\n@@ -108,1 +108,1 @@\n-  static void set_shared_metaspace_range(void* base, void *static_top, void* top) NOT_CDS_RETURN;\n+  static void set_aot_metaspace_range(void* base, void *static_top, void* top) NOT_CDS_RETURN;\n@@ -110,2 +110,5 @@\n-  static bool is_shared_dynamic(void* p) NOT_CDS_RETURN_(false);\n-  static bool is_shared_static(void* p) NOT_CDS_RETURN_(false);\n+  \/\/ inside the metaspace of the AOT cache, or the static CDS archive\n+  static bool in_aot_cache_static_region(void* p) NOT_CDS_RETURN_(false);\n+\n+  \/\/ inside the metaspace of the dynamic static CDS archive\n+  static bool in_aot_cache_dynamic_region(void* p) NOT_CDS_RETURN_(false);\n@@ -202,1 +205,1 @@\n-#endif \/\/ SHARE_CDS_METASPACESHARED_HPP\n+#endif \/\/ SHARE_CDS_AOTMETASPACE_HPP\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.hpp","additions":15,"deletions":12,"binary":false,"changes":27,"previous_filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","status":"renamed"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -95,1 +95,1 @@\n-class KeepAliveObjectsTable : public ResourceHashtable<oop, bool,\n+class KeepAliveObjectsTable : public HashTable<oop, bool,\n@@ -212,1 +212,1 @@\n-      MetaspaceShared::unrecoverable_writing_error();\n+      AOTMetaspace::unrecoverable_writing_error();\n","filename":"src\/hotspot\/share\/cds\/aotReferenceObjSupport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"cds\/aotMapLogger.hpp\"\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -37,1 +39,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -63,1 +63,0 @@\n-#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -334,1 +333,1 @@\n-                                             MetaspaceShared::core_region_alignment(),\n+                                             AOTMetaspace::core_region_alignment(),\n@@ -339,1 +338,1 @@\n-    MetaspaceShared::unrecoverable_writing_error();\n+    AOTMetaspace::unrecoverable_writing_error();\n@@ -361,1 +360,1 @@\n-  _requested_static_archive_bottom = (address)MetaspaceShared::requested_base_address();\n+  _requested_static_archive_bottom = (address)AOTMetaspace::requested_base_address();\n@@ -369,2 +368,2 @@\n-    _mapped_static_archive_bottom = (address)MetaspaceObj::shared_metaspace_base();\n-    _mapped_static_archive_top  = (address)MetaspaceObj::shared_metaspace_top();\n+    _mapped_static_archive_bottom = (address)MetaspaceObj::aot_metaspace_base();\n+    _mapped_static_archive_top  = (address)MetaspaceObj::aot_metaspace_top();\n@@ -376,1 +375,1 @@\n-    my_archive_requested_bottom = align_up(_requested_static_archive_top, MetaspaceShared::core_region_alignment());\n+    my_archive_requested_bottom = align_up(_requested_static_archive_top, AOTMetaspace::core_region_alignment());\n@@ -391,1 +390,1 @@\n-    MetaspaceShared::unrecoverable_writing_error();\n+    AOTMetaspace::unrecoverable_writing_error();\n@@ -397,1 +396,1 @@\n-    _pz_region.allocate(MetaspaceShared::protection_zone_size());\n+    _pz_region.allocate(AOTMetaspace::protection_zone_size());\n@@ -544,1 +543,1 @@\n-    if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_shared_static(bottom)) {\n+    if (CDSConfig::is_dumping_dynamic_archive() && AOTMetaspace::in_aot_cache_static_region(bottom)) {\n@@ -557,1 +556,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(obj)) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && AOTMetaspace::in_aot_cache(obj)) {\n@@ -567,6 +566,1 @@\n-    if (CDSConfig::is_dumping_adapters()) {\n-      AdapterHandlerEntry* entry = (AdapterHandlerEntry*)ref->obj();\n-      return AdapterHandlerLibrary::is_abstract_method_adapter(entry) ? set_to_null : make_a_copy;\n-    } else {\n-      return set_to_null;\n-    }\n+    return CDSConfig::is_dumping_adapters() ? make_a_copy : set_to_null;\n@@ -751,7 +745,8 @@\n-  return (p != nullptr);\n-}\n-\n-bool ArchiveBuilder::has_been_buffered(address src_addr) const {\n-  if (RegeneratedClasses::has_been_regenerated(src_addr) ||\n-      _src_obj_table.get(src_addr) == nullptr ||\n-      get_buffered_addr(src_addr) == nullptr) {\n+  if (p == nullptr) {\n+    \/\/ This object has never been seen by ArchiveBuilder\n+    return false;\n+  }\n+  if (p->buffered_addr() == nullptr) {\n+    \/\/ ArchiveBuilder has seen this object, but decided not to archive it. So\n+    \/\/ Any reference to this object will be modified to nullptr inside the buffer.\n+    assert(p->follow_mode() == set_to_null, \"must be\");\n@@ -759,2 +754,0 @@\n-  } else {\n-    return true;\n@@ -762,0 +755,13 @@\n+\n+  DEBUG_ONLY({\n+    \/\/ This is a class\/method that belongs to one of the \"original\" classes that\n+    \/\/ have been regenerated by lambdaFormInvokers.cpp. We must have archived\n+    \/\/ the \"regenerated\" version of it.\n+    if (RegeneratedClasses::has_been_regenerated(src_addr)) {\n+      address regen_obj = RegeneratedClasses::get_regenerated_object(src_addr);\n+      precond(regen_obj != nullptr && regen_obj != src_addr);\n+      assert(has_been_archived(regen_obj), \"must be\");\n+      assert(get_buffered_addr(src_addr) == get_buffered_addr(regen_obj), \"must be\");\n+    }});\n+\n+  return true;\n@@ -939,1 +945,1 @@\n-      if (ik->is_generated_shared_class()) {\n+      if (ik->is_aot_generated_class()) {\n@@ -953,1 +959,1 @@\n-      MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread::current(), ik);\n+      AOTMetaspace::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread::current(), ik);\n@@ -1179,418 +1185,0 @@\n-\/\/ Write detailed info to a mapfile to analyze contents of the archive.\n-\/\/ static dump:\n-\/\/   java -Xshare:dump -Xlog:cds+map=trace:file=cds.map:none:filesize=0\n-\/\/ dynamic dump:\n-\/\/   java -cp MyApp.jar -XX:ArchiveClassesAtExit=MyApp.jsa \\\n-\/\/        -Xlog:cds+map=trace:file=cds.map:none:filesize=0 MyApp\n-\/\/\n-\/\/ We need to do some address translation because the buffers used at dump time may be mapped to\n-\/\/ a different location at runtime. At dump time, the buffers may be at arbitrary locations\n-\/\/ picked by the OS. At runtime, we try to map at a fixed location (SharedBaseAddress). For\n-\/\/ consistency, we log everything using runtime addresses.\n-class ArchiveBuilder::CDSMapLogger : AllStatic {\n-  static intx buffer_to_runtime_delta() {\n-    \/\/ Translate the buffers used by the RW\/RO regions to their eventual (requested) locations\n-    \/\/ at runtime.\n-    return ArchiveBuilder::current()->buffer_to_requested_delta();\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_region(const char* name, DumpRegion* region,\n-                                   const ArchiveBuilder::SourceObjList* src_objs) {\n-    address region_base = address(region->base());\n-    address region_top  = address(region->top());\n-    log_region(name, region_base, region_top, region_base + buffer_to_runtime_delta());\n-    log_metaspace_objects(region, src_objs);\n-  }\n-\n-#define _LOG_PREFIX PTR_FORMAT \": @@ %-17s %d\"\n-\n-  static void log_klass(Klass* k, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes, k->external_name());\n-  }\n-  static void log_method(Method* m, address runtime_dest, const char* type_name, int bytes, Thread* current) {\n-    ResourceMark rm(current);\n-    log_debug(aot, map)(_LOG_PREFIX \" %s\",\n-                        p2i(runtime_dest), type_name, bytes,  m->external_name());\n-  }\n-\n-  \/\/ rw\/ro regions only\n-  static void log_metaspace_objects(DumpRegion* region, const ArchiveBuilder::SourceObjList* src_objs) {\n-    address last_obj_base = address(region->base());\n-    address last_obj_end  = address(region->base());\n-    address region_end    = address(region->end());\n-    Thread* current = Thread::current();\n-    for (int i = 0; i < src_objs->objs()->length(); i++) {\n-      SourceObjInfo* src_info = src_objs->at(i);\n-      address src = src_info->source_addr();\n-      address dest = src_info->buffered_addr();\n-      log_as_hex(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n-      address runtime_dest = dest + buffer_to_runtime_delta();\n-      int bytes = src_info->size_in_bytes();\n-\n-      MetaspaceObj::Type type = src_info->msotype();\n-      const char* type_name = MetaspaceObj::type_name(type);\n-\n-      switch (type) {\n-      case MetaspaceObj::ClassType:\n-        log_klass((Klass*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolType:\n-        log_klass(((ConstantPool*)src)->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstantPoolCacheType:\n-        log_klass(((ConstantPoolCache*)src)->constant_pool()->pool_holder(),\n-                    runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::MethodType:\n-        log_method((Method*)src, runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::ConstMethodType:\n-        log_method(((ConstMethod*)src)->method(), runtime_dest, type_name, bytes, current);\n-        break;\n-      case MetaspaceObj::SymbolType:\n-        {\n-          ResourceMark rm(current);\n-          Symbol* s = (Symbol*)src;\n-          log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(runtime_dest), type_name, bytes,\n-                              s->as_quoted_ascii());\n-        }\n-        break;\n-      default:\n-        log_debug(aot, map)(_LOG_PREFIX, p2i(runtime_dest), type_name, bytes);\n-        break;\n-      }\n-\n-      last_obj_base = dest;\n-      last_obj_end  = dest + bytes;\n-    }\n-\n-    log_as_hex(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n-    if (last_obj_end < region_end) {\n-      log_debug(aot, map)(PTR_FORMAT \": @@ Misc data %zu bytes\",\n-                          p2i(last_obj_end + buffer_to_runtime_delta()),\n-                          size_t(region_end - last_obj_end));\n-      log_as_hex(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n-    }\n-  }\n-\n-#undef _LOG_PREFIX\n-\n-  \/\/ Log information about a region, whose address at dump time is [base .. top). At\n-  \/\/ runtime, this region will be mapped to requested_base. requested_base is nullptr if this\n-  \/\/ region will be mapped at os-selected addresses (such as the bitmap region), or will\n-  \/\/ be accessed with os::read (the header).\n-  \/\/\n-  \/\/ Note: across -Xshare:dump runs, base may be different, but requested_base should\n-  \/\/ be the same as the archive contents should be deterministic.\n-  static void log_region(const char* name, address base, address top, address requested_base) {\n-    size_t size = top - base;\n-    base = requested_base;\n-    if (requested_base == nullptr) {\n-      top = (address)size;\n-    } else {\n-      top = requested_base + size;\n-    }\n-    log_info(aot, map)(\"[%-18s \" PTR_FORMAT \" - \" PTR_FORMAT \" %9zu bytes]\",\n-                       name, p2i(base), p2i(top), size);\n-  }\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  static void log_heap_region(ArchiveHeapInfo* heap_info) {\n-    MemRegion r = heap_info->buffer_region();\n-    address start = address(r.start()); \/\/ start of the current oop inside the buffer\n-    address end = address(r.end());\n-    log_region(\"heap\", start, end, ArchiveHeapWriter::buffered_addr_to_requested_addr(start));\n-\n-    LogStreamHandle(Info, aot, map) st;\n-\n-    HeapRootSegments segments = heap_info->heap_root_segments();\n-    assert(segments.base_offset() == 0, \"Sanity\");\n-\n-    for (size_t seg_idx = 0; seg_idx < segments.count(); seg_idx++) {\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print_cr(PTR_FORMAT \": Heap roots segment [%d]\",\n-                  p2i(requested_start), segments.size_in_elems(seg_idx));\n-      start += segments.size_in_bytes(seg_idx);\n-    }\n-    log_heap_roots();\n-\n-    while (start < end) {\n-      size_t byte_size;\n-      oop source_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n-      st.print(PTR_FORMAT \": @@ Object \", p2i(requested_start));\n-\n-      if (source_oop != nullptr) {\n-        \/\/ This is a regular oop that got archived.\n-        \/\/ Don't print the requested addr again as we have just printed it at the beginning of the line.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffd27938: @@ Object (0xfffa4f27) java.util.HashMap\n-        print_oop_info_cr(&st, source_oop, \/*print_requested_addr=*\/false);\n-        byte_size = source_oop->size() * BytesPerWord;\n-      } else if ((byte_size = ArchiveHeapWriter::get_filler_size_at(start)) > 0) {\n-        \/\/ We have a filler oop, which also does not exist in BufferOffsetToSourceObjectTable.\n-        \/\/ Example:\n-        \/\/ 0x00000007ffc3ffd8: @@ Object filler 40 bytes\n-        st.print_cr(\"filler %zu bytes\", byte_size);\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-\n-      address oop_end = start + byte_size;\n-      log_as_hex(start, oop_end, requested_start, \/*is_heap=*\/true);\n-\n-      if (source_oop != nullptr) {\n-        log_oop_details(heap_info, source_oop, \/*buffered_addr=*\/start);\n-      }\n-      start = oop_end;\n-    }\n-  }\n-\n-  \/\/ ArchivedFieldPrinter is used to print the fields of archived objects. We can't\n-  \/\/ use _source_obj->print_on(), because we want to print the oop fields\n-  \/\/ in _source_obj with their requested addresses using print_oop_info_cr().\n-  class ArchivedFieldPrinter : public FieldClosure {\n-    ArchiveHeapInfo* _heap_info;\n-    outputStream* _st;\n-    oop _source_obj;\n-    address _buffered_addr;\n-  public:\n-    ArchivedFieldPrinter(ArchiveHeapInfo* heap_info, outputStream* st, oop src_obj, address buffered_addr) :\n-      _heap_info(heap_info), _st(st), _source_obj(src_obj), _buffered_addr(buffered_addr) {}\n-\n-    void do_field(fieldDescriptor* fd) {\n-      _st->print(\" - \");\n-      BasicType ft = fd->field_type();\n-      switch (ft) {\n-      case T_ARRAY:\n-      case T_OBJECT:\n-        {\n-          fd->print_on(_st); \/\/ print just the name and offset\n-          oop obj = _source_obj->obj_field(fd->offset());\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(_st, obj);\n-        }\n-        break;\n-      default:\n-        if (ArchiveHeapWriter::is_marked_as_native_pointer(_heap_info, _source_obj, fd->offset())) {\n-          print_as_native_pointer(fd);\n-        } else {\n-          fd->print_on_for(_st, cast_to_oop(_buffered_addr)); \/\/ name, offset, value\n-          _st->cr();\n-        }\n-      }\n-    }\n-\n-    void print_as_native_pointer(fieldDescriptor* fd) {\n-      LP64_ONLY(assert(fd->field_type() == T_LONG, \"must be\"));\n-      NOT_LP64 (assert(fd->field_type() == T_INT,  \"must be\"));\n-\n-      \/\/ We have a field that looks like an integer, but it's actually a pointer to a MetaspaceObj.\n-      address source_native_ptr = (address)\n-          LP64_ONLY(_source_obj->long_field(fd->offset()))\n-          NOT_LP64( _source_obj->int_field (fd->offset()));\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-\n-      \/\/ The value of the native pointer at runtime.\n-      address requested_native_ptr = builder->to_requested(builder->get_buffered_addr(source_native_ptr));\n-\n-      \/\/ The address of _source_obj at runtime\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(_source_obj);\n-      \/\/ The address of this field in the requested space\n-      assert(requested_obj != nullptr, \"Attempting to load field from null oop\");\n-      address requested_field_addr = cast_from_oop<address>(requested_obj) + fd->offset();\n-\n-      fd->print_on(_st);\n-      _st->print_cr(PTR_FORMAT \" (marked metadata pointer @\" PTR_FORMAT \" )\",\n-                    p2i(requested_native_ptr), p2i(requested_field_addr));\n-    }\n-  };\n-\n-  \/\/ Print the fields of instanceOops, or the elements of arrayOops\n-  static void log_oop_details(ArchiveHeapInfo* heap_info, oop source_oop, address buffered_addr) {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      Klass* source_klass = source_oop->klass();\n-      ArchiveBuilder* builder = ArchiveBuilder::current();\n-      Klass* requested_klass = builder->to_requested(builder->get_buffered_addr(source_klass));\n-\n-      st.print(\" - klass: \");\n-      source_klass->print_value_on(&st);\n-      st.print(\" \" PTR_FORMAT, p2i(requested_klass));\n-      st.cr();\n-\n-      if (source_oop->is_typeArray()) {\n-        TypeArrayKlass::cast(source_klass)->oop_print_elements_on(typeArrayOop(source_oop), &st);\n-      } else if (source_oop->is_objArray()) {\n-        objArrayOop source_obj_array = objArrayOop(source_oop);\n-        for (int i = 0; i < source_obj_array->length(); i++) {\n-          st.print(\" -%4d: \", i);\n-          oop obj = source_obj_array->obj_at(i);\n-          if (java_lang_Class::is_instance(obj)) {\n-            obj = HeapShared::scratch_java_mirror(obj);\n-          }\n-          print_oop_info_cr(&st, obj);\n-        }\n-      } else {\n-        st.print_cr(\" - fields (%zu words):\", source_oop->size());\n-        ArchivedFieldPrinter print_field(heap_info, &st, source_oop, buffered_addr);\n-        InstanceKlass::cast(source_klass)->print_nonstatic_fields(&print_field);\n-\n-        if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-          st.print(\" - signature: \");\n-          print_class_signature_for_mirror(&st, scratch_mirror);\n-          st.cr();\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            oop rr = HeapShared::scratch_resolved_references(InstanceKlass::cast(src_klass)->constants());\n-            st.print(\" - archived_resolved_references: \");\n-            print_oop_info_cr(&st, rr);\n-\n-            \/\/ We need to print the fields in the scratch_mirror, not the original mirror.\n-            \/\/ (if a class is not aot-initialized, static fields in its scratch mirror will be cleared).\n-            assert(scratch_mirror == HeapShared::scratch_java_mirror(src_klass->java_mirror()), \"sanity\");\n-            st.print_cr(\"- ---- static fields (%d):\", java_lang_Class::static_oop_field_count(scratch_mirror));\n-            InstanceKlass::cast(src_klass)->do_local_static_fields(&print_field);\n-          }\n-        }\n-      }\n-    }\n-  }\n-\n-  static void print_class_signature_for_mirror(outputStream* st, oop scratch_mirror) {\n-    assert(java_lang_Class::is_instance(scratch_mirror), \"sanity\");\n-    if (java_lang_Class::is_primitive(scratch_mirror)) {\n-      for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n-        BasicType bt = (BasicType)i;\n-        if (!is_reference_type(bt) && scratch_mirror == HeapShared::scratch_java_mirror(bt)) {\n-          oop orig_mirror = Universe::java_mirror(bt);\n-          java_lang_Class::print_signature(orig_mirror, st);\n-          return;\n-        }\n-      }\n-      ShouldNotReachHere();\n-    }\n-    java_lang_Class::print_signature(scratch_mirror, st);\n-  }\n-\n-  static void log_heap_roots() {\n-    LogStreamHandle(Trace, aot, map, oops) st;\n-    if (st.is_enabled()) {\n-      for (int i = 0; i < HeapShared::pending_roots()->length(); i++) {\n-        st.print(\"roots[%4d]: \", i);\n-        print_oop_info_cr(&st, HeapShared::pending_roots()->at(i));\n-      }\n-    }\n-  }\n-\n-  \/\/ Example output:\n-  \/\/ - The first number is the requested address (if print_requested_addr == true)\n-  \/\/ - The second number is the narrowOop version of the requested address (if UseCompressedOops == true)\n-  \/\/     0x00000007ffc7e840 (0xfff8fd08) java.lang.Class Ljava\/util\/Array;\n-  \/\/     0x00000007ffc000f8 (0xfff8001f) [B length: 11\n-  static void print_oop_info_cr(outputStream* st, oop source_oop, bool print_requested_addr = true) {\n-    if (source_oop == nullptr) {\n-      st->print_cr(\"null\");\n-    } else {\n-      ResourceMark rm;\n-      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(source_oop);\n-      if (print_requested_addr) {\n-        st->print(PTR_FORMAT \" \", p2i(requested_obj));\n-      }\n-      if (UseCompressedOops) {\n-        st->print(\"(0x%08x) \", CompressedOops::narrow_oop_value(requested_obj));\n-      }\n-      if (source_oop->is_array()) {\n-        int array_len = arrayOop(source_oop)->length();\n-        st->print_cr(\"%s length: %d\", source_oop->klass()->external_name(), array_len);\n-      } else {\n-        st->print(\"%s\", source_oop->klass()->external_name());\n-\n-        if (java_lang_String::is_instance(source_oop)) {\n-          st->print(\" \");\n-          java_lang_String::print(source_oop, st);\n-        } else if (java_lang_Class::is_instance(source_oop)) {\n-          oop scratch_mirror = source_oop;\n-\n-          st->print(\" \");\n-          print_class_signature_for_mirror(st, scratch_mirror);\n-\n-          Klass* src_klass = java_lang_Class::as_Klass(scratch_mirror);\n-          if (src_klass != nullptr && src_klass->is_instance_klass()) {\n-            InstanceKlass* buffered_klass =\n-              ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_klass));\n-            if (buffered_klass->has_aot_initialized_mirror()) {\n-              st->print(\" (aot-inited)\");\n-            }\n-          }\n-        }\n-        st->cr();\n-      }\n-    }\n-  }\n-#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n-\n-  \/\/ Log all the data [base...top). Pretend that the base address\n-  \/\/ will be mapped to requested_base at run-time.\n-  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false) {\n-    assert(top >= base, \"must be\");\n-\n-    LogStreamHandle(Trace, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      int unitsize = sizeof(address);\n-      if (is_heap && UseCompressedOops) {\n-        \/\/ This makes the compressed oop pointers easier to read, but\n-        \/\/ longs and doubles will be split into two words.\n-        unitsize = sizeof(narrowOop);\n-      }\n-      os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n-    }\n-  }\n-\n-  static void log_header(FileMapInfo* mapinfo) {\n-    LogStreamHandle(Info, aot, map) lsh;\n-    if (lsh.is_enabled()) {\n-      mapinfo->print(&lsh);\n-    }\n-  }\n-\n-public:\n-  static void log(ArchiveBuilder* builder, FileMapInfo* mapinfo,\n-                  ArchiveHeapInfo* heap_info,\n-                  char* bitmap, size_t bitmap_size_in_bytes) {\n-    log_info(aot, map)(\"%s CDS archive map for %s\", CDSConfig::is_dumping_static_archive() ? \"Static\" : \"Dynamic\", mapinfo->full_path());\n-\n-    address header = address(mapinfo->header());\n-    address header_end = header + mapinfo->header()->header_size();\n-    log_region(\"header\", header, header_end, nullptr);\n-    log_header(mapinfo);\n-    log_as_hex(header, header_end, nullptr);\n-\n-    DumpRegion* rw_region = &builder->_rw_region;\n-    DumpRegion* ro_region = &builder->_ro_region;\n-\n-    log_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n-    log_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n-\n-    address bitmap_end = address(bitmap + bitmap_size_in_bytes);\n-    log_region(\"bitmap\", address(bitmap), bitmap_end, nullptr);\n-    log_as_hex((address)bitmap, bitmap_end, nullptr);\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-    if (heap_info->is_used()) {\n-      log_heap_region(heap_info);\n-    }\n-#endif\n-\n-    log_info(aot, map)(\"[End of CDS archive map]\");\n-  }\n-}; \/\/ end ArchiveBuilder::CDSMapLogger\n-\n@@ -1603,2 +1191,2 @@\n-  \/\/ MetaspaceShared::n_regions (internal to hotspot).\n-  assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, \"sanity\");\n+  \/\/ AOTMetaspace::n_regions (internal to hotspot).\n+  assert(NUM_CDS_REGIONS == AOTMetaspace::n_regions, \"sanity\");\n@@ -1606,3 +1194,3 @@\n-  write_region(mapinfo, MetaspaceShared::rw, &_rw_region, \/*read_only=*\/false,\/*allow_exec=*\/false);\n-  write_region(mapinfo, MetaspaceShared::ro, &_ro_region, \/*read_only=*\/true, \/*allow_exec=*\/false);\n-  write_region(mapinfo, MetaspaceShared::ac, &_ac_region, \/*read_only=*\/false,\/*allow_exec=*\/false);\n+  write_region(mapinfo, AOTMetaspace::rw, &_rw_region, \/*read_only=*\/false,\/*allow_exec=*\/false);\n+  write_region(mapinfo, AOTMetaspace::ro, &_ro_region, \/*read_only=*\/true, \/*allow_exec=*\/false);\n+  write_region(mapinfo, AOTMetaspace::ac, &_ac_region, \/*read_only=*\/false,\/*allow_exec=*\/false);\n@@ -1623,1 +1211,1 @@\n-  mapinfo->set_requested_base((char*)MetaspaceShared::requested_base_address());\n+  mapinfo->set_requested_base((char*)AOTMetaspace::requested_base_address());\n@@ -1636,2 +1224,1 @@\n-    CDSMapLogger::log(this, mapinfo, heap_info,\n-                      bitmap, bitmap_size_in_bytes);\n+    AOTMapLogger::dumptime_log(this, mapinfo, heap_info, bitmap, bitmap_size_in_bytes);\n@@ -1655,2 +1242,2 @@\n-  const size_t bitmap_used = mapinfo->region_at(MetaspaceShared::bm)->used();\n-  const size_t bitmap_reserved = mapinfo->region_at(MetaspaceShared::bm)->used_aligned();\n+  const size_t bitmap_used = mapinfo->region_at(AOTMetaspace::bm)->used();\n+  const size_t bitmap_reserved = mapinfo->region_at(AOTMetaspace::bm)->used_aligned();\n@@ -1700,1 +1287,1 @@\n-  MetaspaceShared::unrecoverable_writing_error();\n+  AOTMetaspace::unrecoverable_writing_error();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":46,"deletions":459,"binary":false,"changes":505,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -96,0 +96,2 @@\n+  friend class AOTMapLogger;\n+\n@@ -183,0 +185,1 @@\n+    FollowMode follow_mode() const { return _follow_mode; }\n@@ -204,2 +207,0 @@\n-  class CDSMapLogger;\n-\n@@ -232,2 +233,2 @@\n-  ResizeableResourceHashtable<address, SourceObjInfo, AnyObj::C_HEAP, mtClassShared> _src_obj_table;\n-  ResizeableResourceHashtable<address, address, AnyObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n+  ResizeableHashTable<address, SourceObjInfo, AnyObj::C_HEAP, mtClassShared> _src_obj_table;\n+  ResizeableHashTable<address, address, AnyObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n@@ -318,0 +319,6 @@\n+  template <typename T> T requested_to_buffered(T obj) const {\n+    T b = (T)(address(obj) - _buffer_to_requested_delta);\n+    assert(is_in_buffer_space(b), \"must be\");\n+    return b;\n+  }\n+\n@@ -446,4 +453,2 @@\n-\n-  bool has_been_buffered(address src_addr) const;\n-  template <typename T> bool has_been_buffered(T src_addr) const {\n-    return has_been_buffered((address)src_addr);\n+  template <typename T> bool has_been_archived(T src_addr) const {\n+    return has_been_archived((address)src_addr);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -264,1 +264,1 @@\n-  FileMapRegion* r = mapinfo->region_at(MetaspaceShared::hp);\n+  FileMapRegion* r = mapinfo->region_at(AOTMetaspace::hp);\n@@ -272,1 +272,1 @@\n-  loaded_region->_region_index = MetaspaceShared::hp;\n+  loaded_region->_region_index = AOTMetaspace::hp;\n@@ -351,1 +351,1 @@\n-  ResourceHashtable<uintptr_t, bool>* _table;\n+  HashTable<uintptr_t, bool>* _table;\n@@ -354,1 +354,1 @@\n-  VerifyLoadedHeapEmbeddedPointers(ResourceHashtable<uintptr_t, bool>* table) : _table(table) {}\n+  VerifyLoadedHeapEmbeddedPointers(HashTable<uintptr_t, bool>* table) : _table(table) {}\n@@ -414,1 +414,1 @@\n-  ResourceHashtable<uintptr_t, bool> table;\n+  HashTable<uintptr_t, bool> table;\n@@ -450,1 +450,1 @@\n-    *p = (Metadata*)(address(*p) + MetaspaceShared::relocation_delta());\n+    *p = (Metadata*)(address(*p) + AOTMetaspace::relocation_delta());\n@@ -456,1 +456,1 @@\n-  if (MetaspaceShared::relocation_delta() == 0) {\n+  if (AOTMetaspace::relocation_delta() == 0) {\n@@ -460,1 +460,1 @@\n-  FileMapRegion* r = FileMapInfo::current_info()->region_at(MetaspaceShared::hp);\n+  FileMapRegion* r = FileMapInfo::current_info()->region_at(AOTMetaspace::hp);\n@@ -463,1 +463,1 @@\n-    BitMapView bm = FileMapInfo::current_info()->ptrmap_view(MetaspaceShared::hp);\n+    BitMapView bm = FileMapInfo::current_info()->ptrmap_view(AOTMetaspace::hp);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-typedef ResourceHashtable<\n+typedef HashTable<\n@@ -165,0 +165,38 @@\n+Klass* ArchiveHeapWriter::real_klass_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->klass();\n+  } else if (get_filler_size_at(buffered_addr) > 0) {\n+    return Universe::fillerArrayKlass();\n+  } else {\n+    \/\/ This is one of the root segments\n+    return Universe::objectArrayKlass();\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::size_of_buffered_oop(address buffered_addr) {\n+  oop p = buffered_addr_to_source_obj(buffered_addr);\n+  if (p != nullptr) {\n+    return p->size();\n+  }\n+\n+  size_t nbytes = get_filler_size_at(buffered_addr);\n+  if (nbytes > 0) {\n+    assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+    return nbytes \/ BytesPerWord;\n+  }\n+\n+  address hrs = buffer_bottom();\n+  for (size_t seg_idx = 0; seg_idx < _heap_root_segments.count(); seg_idx++) {\n+    nbytes = _heap_root_segments.size_in_bytes(seg_idx);\n+    if (hrs == buffered_addr) {\n+      assert((nbytes % BytesPerWord) == 0, \"should be aligned\");\n+      return nbytes \/ BytesPerWord;\n+    }\n+    hrs += nbytes;\n+  }\n+\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n@@ -712,21 +750,0 @@\n-\/\/ Do we have a jlong\/jint field that's actually a pointer to a MetaspaceObj?\n-bool ArchiveHeapWriter::is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset) {\n-  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n-  assert(p != nullptr, \"must be\");\n-\n-  \/\/ requested_field_addr = the address of this field in the requested space\n-  oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n-  Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n-  assert((Metadata**)_requested_bottom <= requested_field_addr && requested_field_addr < (Metadata**) _requested_top, \"range check\");\n-\n-  BitMap::idx_t idx = requested_field_addr - (Metadata**) _requested_bottom;\n-  \/\/ Leading zeros have been removed so some addresses may not be in the ptrmap\n-  size_t start_pos = FileMapInfo::current_info()->heap_ptrmap_start_pos();\n-  if (idx < start_pos) {\n-    return false;\n-  } else {\n-    idx -= start_pos;\n-  }\n-  return (idx < heap_info->ptrmap()->size()) && (heap_info->ptrmap()->at(idx) == true);\n-}\n-\n@@ -767,1 +784,1 @@\n-    guarantee(ArchiveBuilder::current()->has_been_buffered((address)native_ptr),\n+    guarantee(ArchiveBuilder::current()->has_been_archived((address)native_ptr),\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -155,1 +155,1 @@\n-  typedef ResizeableResourceHashtable<size_t, oop,\n+  typedef ResizeableHashTable<size_t, oop,\n@@ -239,1 +239,0 @@\n-  static bool is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset);\n@@ -243,1 +242,2 @@\n-\n+  static Klass* real_klass_of_buffered_oop(address buffered_addr);\n+  static size_t size_of_buffered_oop(address buffered_addr);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -120,1 +120,1 @@\n-    \/\/ MetaspaceShared::default_base_address()==0, we can't distinguish between a pointer\n+    \/\/ AOTMetaspace::default_base_address()==0, we can't distinguish between a pointer\n@@ -212,1 +212,1 @@\n-      MetaspaceShared::unrecoverable_writing_error();\n+      AOTMetaspace::unrecoverable_writing_error();\n@@ -239,1 +239,1 @@\n-    MetaspaceShared::unrecoverable_writing_error();\n+    AOTMetaspace::unrecoverable_writing_error();\n@@ -243,1 +243,1 @@\n-  if (_rs->base() == (char*)MetaspaceShared::symbol_rs_base()) {\n+  if (_rs->base() == (char*)AOTMetaspace::symbol_rs_base()) {\n@@ -301,1 +301,1 @@\n-    _end = (char*)align_up(_top, MetaspaceShared::core_region_alignment());\n+    _end = (char*)align_up(_top, AOTMetaspace::core_region_alignment());\n@@ -304,1 +304,1 @@\n-  _end = (char*)align_up(_top, MetaspaceShared::core_region_alignment());\n+  _end = (char*)align_up(_top, AOTMetaspace::core_region_alignment());\n@@ -386,2 +386,1 @@\n-  if (SystemDictionaryShared::is_excluded_class(src_ik)) {\n-    assert(!ArchiveBuilder::current()->has_been_buffered(src_ik), \"sanity\");\n+  if (!ArchiveBuilder::current()->has_been_archived(src_ik)) {\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-  \/\/ the range of the mapped CDS archive (e.g., Metaspace::is_in_shared_metaspace()).\n+  \/\/ the range of the mapped CDS archive (e.g., Metaspace::in_aot_cache()).\n@@ -290,1 +290,1 @@\n-    assert(Metaspace::is_in_shared_metaspace(p), \"must be\");\n+    assert(Metaspace::in_aot_cache(p), \"must be\");\n@@ -306,1 +306,1 @@\n-    assert(Metaspace::is_in_shared_metaspace(p), \"must be\");\n+    assert(Metaspace::in_aot_cache(p), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -83,1 +83,1 @@\n-        if (is_dynamic_dump && MetaspaceShared::is_in_shared_metaspace(ptr)) {\n+        if (is_dynamic_dump && AOTMetaspace::in_aot_cache(ptr)) {\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMapLogger.hpp\"\n@@ -107,0 +108,2 @@\n+\n+  AOTMapLogger::ergo_initialize();\n@@ -646,2 +649,11 @@\n-    if (is_dumping_preimage_static_archive() || is_dumping_final_static_archive()) {\n-      \/\/ Don't tweak execution mode\n+    if (is_dumping_preimage_static_archive()) {\n+      \/\/ Don't tweak execution mode during AOT training run\n+    } else if (is_dumping_final_static_archive()) {\n+      if (Arguments::mode() == Arguments::_comp) {\n+        \/\/ AOT assembly phase submits the non-blocking compilation requests\n+        \/\/ for methods collected during training run, then waits for all compilations\n+        \/\/ to complete. With -Xcomp, we block for each compilation request, which is\n+        \/\/ counter-productive. Switching back to mixed mode improves testing time\n+        \/\/ with AOT and -Xcomp.\n+        Arguments::set_mode_flags(Arguments::_mixed);\n+      }\n@@ -758,1 +770,1 @@\n-      MetaspaceShared::unrecoverable_loading_error();\n+      AOTMetaspace::unrecoverable_loading_error();\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-    MetaspaceShared::unrecoverable_writing_error();\n+    AOTMetaspace::unrecoverable_writing_error();\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -50,1 +50,1 @@\n-  ResourceHashtable<oop, StaticFieldInfo,\n+  HashTable<oop, StaticFieldInfo,\n@@ -82,1 +82,1 @@\n-  \/\/ For ResourceHashtable::iterate()\n+  \/\/ For HashTable::iterate()\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-  if (CDSConfig::is_using_full_module_graph() && ik->is_shared() && pkg_entry != nullptr) {\n-    assert(MetaspaceShared::is_in_shared_metaspace(pkg_entry), \"must be\");\n+  if (CDSConfig::is_using_full_module_graph() && ik->in_aot_cache() && pkg_entry != nullptr) {\n+    assert(AOTMetaspace::in_aot_cache(pkg_entry), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -188,1 +188,1 @@\n-    MetaspaceShared::try_link_class(THREAD, ik);\n+    AOTMetaspace::try_link_class(THREAD, ik);\n@@ -564,1 +564,1 @@\n-  if (k->java_super() != specified_super) {\n+  if (k->super() != specified_super) {\n@@ -567,1 +567,1 @@\n-          k->java_super()->external_name());\n+          k->super()->external_name());\n@@ -677,1 +677,1 @@\n-    MetaspaceShared::try_link_class(THREAD, ik);\n+    AOTMetaspace::try_link_class(THREAD, ik);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -80,1 +80,1 @@\n-  typedef ResizeableResourceHashtable<int, InstanceKlass*,\n+  typedef ResizeableHashTable<int, InstanceKlass*,\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-class ClassListWriter::IDTable : public ResourceHashtable<\n+class ClassListWriter::IDTable : public HashTable<\n@@ -113,1 +113,1 @@\n-    if (!k->is_shared()) {\n+    if (!k->in_aot_cache()) {\n@@ -142,1 +142,1 @@\n-    InstanceKlass* super = k->java_super();\n+    InstanceKlass* super = k->super();\n@@ -168,1 +168,1 @@\n-    InstanceKlass* super = k->java_super();\n+    InstanceKlass* super = k->super();\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -324,1 +324,1 @@\n-  assert(MetaspaceShared::is_in_shared_metaspace(m), \"must be\");\n+  assert(AOTMetaspace::in_aot_cache(m), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  assert(CDSConfig::is_dumping_final_static_archive() || !k->is_shared(), \"Do not call with shared classes\");\n+  assert(CDSConfig::is_dumping_final_static_archive() || !k->in_aot_cache(), \"Do not call with shared classes\");\n@@ -154,1 +154,1 @@\n-  assert(CDSConfig::is_dumping_final_static_archive() || !k->is_shared(), \"Do not call with shared classes\");\n+  assert(CDSConfig::is_dumping_final_static_archive() || !k->in_aot_cache(), \"Do not call with shared classes\");\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -234,1 +234,1 @@\n-    uintx delta = k->name() - MetaspaceShared::symbol_rs_base();\n+    uintx delta = k->name() - AOTMetaspace::symbol_rs_base();\n@@ -243,1 +243,1 @@\n-using DumpTimeSharedClassTableBaseType = ResourceHashtable<\n+using DumpTimeSharedClassTableBaseType = HashTable<\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -190,1 +190,1 @@\n-      assert(MetaspaceShared::is_shared_static((void*)k),\n+      assert(AOTMetaspace::in_aot_cache_static_region((void*)k),\n@@ -193,1 +193,1 @@\n-      while (ak != nullptr && ak->is_shared()) {\n+      while (ak != nullptr && ak->in_aot_cache()) {\n@@ -219,1 +219,1 @@\n-  for (int i = 0; i < MetaspaceShared::n_regions; i++) {\n+  for (int i = 0; i < AOTMetaspace::n_regions; i++) {\n@@ -256,1 +256,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(ik)) {\n+  if (AOTMetaspace::in_aot_cache(ik)) {\n@@ -279,1 +279,1 @@\n-  sort_methods(ik->java_super());\n+  sort_methods(ik->super());\n@@ -290,1 +290,1 @@\n-      assert(MetaspaceShared::is_in_shared_metaspace(name) || is_in_buffer_space(name), \"must be\");\n+      assert(AOTMetaspace::in_aot_cache(name) || is_in_buffer_space(name), \"must be\");\n@@ -296,1 +296,1 @@\n-      assert(MetaspaceShared::is_in_shared_metaspace(name) || is_in_buffer_space(name), \"must be\");\n+      assert(AOTMetaspace::in_aot_cache(name) || is_in_buffer_space(name), \"must be\");\n@@ -370,1 +370,1 @@\n-      if (MetaspaceShared::is_shared_static(elem)) {\n+      if (AOTMetaspace::in_aot_cache_static_region(elem)) {\n@@ -377,1 +377,1 @@\n-        assert(!MetaspaceShared::is_shared_static(oak),\n+        assert(!AOTMetaspace::in_aot_cache_static_region(oak),\n@@ -438,1 +438,1 @@\n-      assert(MetaspaceShared::is_shared_static((void*)elm), \"must be\");\n+      assert(AOTMetaspace::in_aot_cache_static_region((void*)elm), \"must be\");\n@@ -479,1 +479,1 @@\n-  MetaspaceShared::link_shared_classes(CHECK);\n+  AOTMetaspace::link_shared_classes(CHECK);\n@@ -535,1 +535,1 @@\n-  for (int i = 0; i < MetaspaceShared::n_regions; i++) {\n+  for (int i = 0; i < AOTMetaspace::n_regions; i++) {\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  int _base_region_crc[MetaspaceShared::n_regions];\n+  int _base_region_crc[AOTMetaspace::n_regions];\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -332,1 +332,1 @@\n-      MetaspaceShared::set_archive_loading_failed();\n+      AOTMetaspace::set_archive_loading_failed();\n@@ -341,1 +341,1 @@\n-    MetaspaceShared::report_loading_error(\"optimized module handling: disabled because extra module path(s) are specified\");\n+    AOTMetaspace::report_loading_error(\"optimized module handling: disabled because extra module path(s) are specified\");\n@@ -412,1 +412,1 @@\n-      MetaspaceShared::report_loading_error(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n+      AOTMetaspace::report_loading_error(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n@@ -697,1 +697,1 @@\n-  for (int i = 0; i < MetaspaceShared::n_regions; i++) {\n+  for (int i = 0; i < AOTMetaspace::n_regions; i++) {\n@@ -711,1 +711,1 @@\n-    MetaspaceShared::unrecoverable_loading_error();\n+    AOTMetaspace::unrecoverable_loading_error();\n@@ -766,1 +766,1 @@\n-    MetaspaceShared::writing_error();\n+    AOTMetaspace::writing_error();\n@@ -776,1 +776,1 @@\n-  header_bytes = align_up(header_bytes, MetaspaceShared::core_region_alignment());\n+  header_bytes = align_up(header_bytes, AOTMetaspace::core_region_alignment());\n@@ -791,1 +791,1 @@\n-  return align_up(used(), MetaspaceShared::core_region_alignment());\n+  return align_up(used(), AOTMetaspace::core_region_alignment());\n@@ -797,1 +797,1 @@\n-  _is_bitmap_region = (region_index == MetaspaceShared::bm);\n+  _is_bitmap_region = (region_index == AOTMetaspace::bm);\n@@ -893,1 +893,1 @@\n-  if (region == MetaspaceShared::bm) {\n+  if (region == AOTMetaspace::bm) {\n@@ -911,1 +911,1 @@\n-    char* requested_SharedBaseAddress = (char*)MetaspaceShared::requested_base_address();\n+    char* requested_SharedBaseAddress = (char*)AOTMetaspace::requested_base_address();\n@@ -987,1 +987,1 @@\n-  region_at(MetaspaceShared::rw)->init_ptrmap(0, rw_ptrmap->size());\n+  region_at(AOTMetaspace::rw)->init_ptrmap(0, rw_ptrmap->size());\n@@ -990,1 +990,1 @@\n-  region_at(MetaspaceShared::ro)->init_ptrmap(written, ro_ptrmap->size());\n+  region_at(AOTMetaspace::ro)->init_ptrmap(written, ro_ptrmap->size());\n@@ -994,1 +994,1 @@\n-    FileMapRegion* r = region_at(MetaspaceShared::hp);\n+    FileMapRegion* r = region_at(AOTMetaspace::hp);\n@@ -1003,1 +1003,1 @@\n-  write_region(MetaspaceShared::bm, (char*)buffer, size_in_bytes, \/*read_only=*\/true, \/*allow_exec=*\/false);\n+  write_region(AOTMetaspace::bm, (char*)buffer, size_in_bytes, \/*read_only=*\/true, \/*allow_exec=*\/false);\n@@ -1010,1 +1010,1 @@\n-  write_region(MetaspaceShared::hp, buffer_start, buffer_size, false, false);\n+  write_region(AOTMetaspace::hp, buffer_start, buffer_size, false, false);\n@@ -1025,1 +1025,1 @@\n-      MetaspaceShared::writing_error(\"Unable to write to AOT configuration file.\");\n+      AOTMetaspace::writing_error(\"Unable to write to AOT configuration file.\");\n@@ -1027,1 +1027,1 @@\n-      MetaspaceShared::writing_error(\"Unable to write to AOT cache.\");\n+      AOTMetaspace::writing_error(\"Unable to write to AOT cache.\");\n@@ -1029,1 +1029,1 @@\n-      MetaspaceShared::writing_error(\"Unable to write to shared archive.\");\n+      AOTMetaspace::writing_error(\"Unable to write to shared archive.\");\n@@ -1037,1 +1037,1 @@\n-                                  MetaspaceShared::core_region_alignment());\n+                                  AOTMetaspace::core_region_alignment());\n@@ -1045,1 +1045,1 @@\n-                                    MetaspaceShared::core_region_alignment());\n+                                    AOTMetaspace::core_region_alignment());\n@@ -1071,1 +1071,1 @@\n-      MetaspaceShared::unrecoverable_loading_error(\"Unable to close the shared archive file.\");\n+      AOTMetaspace::unrecoverable_loading_error(\"Unable to close the shared archive file.\");\n@@ -1096,1 +1096,1 @@\n-  int idx = MetaspaceShared::ro;\n+  int idx = AOTMetaspace::ro;\n@@ -1147,1 +1147,1 @@\n-        \/\/ regions, or else it would mess up the simple comparison in MetaspaceObj::is_shared().\n+        \/\/ regions, or else it would mess up the simple comparison in MetaspaceObj::in_aot_cache().\n@@ -1203,1 +1203,1 @@\n-  if (MetaspaceShared::use_windows_memory_mapping()) {\n+  if (AOTMetaspace::use_windows_memory_mapping()) {\n@@ -1215,1 +1215,1 @@\n-  if (MetaspaceShared::use_windows_memory_mapping() && rs.is_reserved()) {\n+  if (AOTMetaspace::use_windows_memory_mapping() && rs.is_reserved()) {\n@@ -1221,1 +1221,1 @@\n-      MetaspaceShared::report_loading_error(\"Failed to read %s shared space into reserved space at \" INTPTR_FORMAT,\n+      AOTMetaspace::report_loading_error(\"Failed to read %s shared space into reserved space at \" INTPTR_FORMAT,\n@@ -1230,1 +1230,1 @@\n-    \/\/ space (Posix). See also comment in MetaspaceShared::map_archives().\n+    \/\/ space (Posix). See also comment in AOTMetaspace::map_archives().\n@@ -1235,1 +1235,1 @@\n-      MetaspaceShared::report_loading_error(\"Unable to map %s shared space at \" INTPTR_FORMAT,\n+      AOTMetaspace::report_loading_error(\"Unable to map %s shared space at \" INTPTR_FORMAT,\n@@ -1261,1 +1261,1 @@\n-  FileMapRegion* r = region_at(MetaspaceShared::bm);\n+  FileMapRegion* r = region_at(AOTMetaspace::bm);\n@@ -1270,1 +1270,1 @@\n-    MetaspaceShared::report_loading_error(\"failed to map relocation bitmap\");\n+    AOTMetaspace::report_loading_error(\"failed to map relocation bitmap\");\n@@ -1286,2 +1286,2 @@\n-                MetaspaceShared::bm, p2i(r->mapped_base()), p2i(r->mapped_end()),\n-                shared_region_name[MetaspaceShared::bm]);\n+                AOTMetaspace::bm, p2i(r->mapped_base()), p2i(r->mapped_end()),\n+                shared_region_name[AOTMetaspace::bm]);\n@@ -1292,1 +1292,1 @@\n-  FileMapRegion* r = region_at(MetaspaceShared::ac);\n+  FileMapRegion* r = region_at(AOTMetaspace::ac);\n@@ -1299,3 +1299,3 @@\n-  if (MetaspaceShared::use_windows_memory_mapping()) {\n-    if (!read_region(MetaspaceShared::ac, requested_base, r->used_aligned(), \/* do_commit = *\/ true)) {\n-      MetaspaceShared::report_loading_error(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n+  if (AOTMetaspace::use_windows_memory_mapping()) {\n+    if (!read_region(AOTMetaspace::ac, requested_base, r->used_aligned(), \/* do_commit = *\/ true)) {\n+      AOTMetaspace::report_loading_error(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n@@ -1314,1 +1314,1 @@\n-    MetaspaceShared::report_loading_error(\"failed to map aot code region\");\n+    AOTMetaspace::report_loading_error(\"failed to map aot code region\");\n@@ -1321,2 +1321,2 @@\n-                  MetaspaceShared::ac, p2i(r->mapped_base()), p2i(r->mapped_end()),\n-                  shared_region_name[MetaspaceShared::ac]);\n+                  AOTMetaspace::ac, p2i(r->mapped_base()), p2i(r->mapped_end()),\n+                  shared_region_name[AOTMetaspace::ac]);\n@@ -1362,2 +1362,2 @@\n-    BitMapView rw_ptrmap = ptrmap_view(MetaspaceShared::rw);\n-    BitMapView ro_ptrmap = ptrmap_view(MetaspaceShared::ro);\n+    BitMapView rw_ptrmap = ptrmap_view(AOTMetaspace::rw);\n+    BitMapView ro_ptrmap = ptrmap_view(AOTMetaspace::ro);\n@@ -1401,1 +1401,1 @@\n-    \/\/ The MetaspaceShared::bm region will be unmapped in MetaspaceShared::initialize_shared_spaces().\n+    \/\/ The AOTMetaspace::bm region will be unmapped in AOTMetaspace::initialize_shared_spaces().\n@@ -1424,1 +1424,1 @@\n-    FileMapRegion* r = FileMapInfo::current_info()->region_at(MetaspaceShared::ro);\n+    FileMapRegion* r = FileMapInfo::current_info()->region_at(AOTMetaspace::ro);\n@@ -1428,1 +1428,1 @@\n-    FileMapRegion* r = FileMapInfo::dynamic_info()->region_at(MetaspaceShared::ro);\n+    FileMapRegion* r = FileMapInfo::dynamic_info()->region_at(AOTMetaspace::ro);\n@@ -1438,1 +1438,1 @@\n-  return (region_at(MetaspaceShared::hp)->used() > 0);\n+  return (region_at(AOTMetaspace::hp)->used() > 0);\n@@ -1446,1 +1446,1 @@\n-  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  FileMapRegion* r = region_at(AOTMetaspace::hp);\n@@ -1468,1 +1468,1 @@\n-        MetaspaceShared::report_loading_error(\"Cannot use CDS heap data. Selected GC not compatible -XX:-UseCompressedOops\");\n+        AOTMetaspace::report_loading_error(\"Cannot use CDS heap data. Selected GC not compatible -XX:-UseCompressedOops\");\n@@ -1470,1 +1470,1 @@\n-        MetaspaceShared::report_loading_error(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC, UseParallelGC, or UseShenandoahGC are required.\");\n+        AOTMetaspace::report_loading_error(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC, UseParallelGC, or UseShenandoahGC are required.\");\n@@ -1485,1 +1485,1 @@\n-      MetaspaceShared::unrecoverable_loading_error();\n+      AOTMetaspace::unrecoverable_loading_error();\n@@ -1578,1 +1578,1 @@\n-  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  FileMapRegion* r = region_at(AOTMetaspace::hp);\n@@ -1592,1 +1592,1 @@\n-  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  FileMapRegion* r = region_at(AOTMetaspace::hp);\n@@ -1646,1 +1646,1 @@\n-  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  FileMapRegion* r = region_at(AOTMetaspace::hp);\n@@ -1660,1 +1660,1 @@\n-    MetaspaceShared::report_loading_error(\"UseSharedSpaces: Unable to allocate java heap region for archive heap.\");\n+    AOTMetaspace::report_loading_error(\"UseSharedSpaces: Unable to allocate java heap region for archive heap.\");\n@@ -1671,1 +1671,1 @@\n-  if (MetaspaceShared::use_windows_memory_mapping() || UseLargePages) {\n+  if (AOTMetaspace::use_windows_memory_mapping() || UseLargePages) {\n@@ -1675,1 +1675,1 @@\n-    if (!read_region(MetaspaceShared::hp, addr,\n+    if (!read_region(AOTMetaspace::hp, addr,\n@@ -1690,1 +1690,1 @@\n-      MetaspaceShared::report_loading_error(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n+      AOTMetaspace::report_loading_error(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n@@ -1698,1 +1698,1 @@\n-      MetaspaceShared::report_loading_error(\"UseSharedSpaces: mapped heap region is corrupt\");\n+      AOTMetaspace::report_loading_error(\"UseSharedSpaces: mapped heap region is corrupt\");\n@@ -1722,1 +1722,1 @@\n-      MetaspaceShared::report_loading_error(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n+      AOTMetaspace::report_loading_error(\"CDS heap cannot be used because bitmap region cannot be mapped\");\n@@ -1737,1 +1737,1 @@\n-  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  FileMapRegion* r = region_at(AOTMetaspace::hp);\n@@ -1749,1 +1749,1 @@\n-  FileMapRegion* r = region_at(MetaspaceShared::hp);\n+  FileMapRegion* r = region_at(AOTMetaspace::hp);\n@@ -1752,1 +1752,1 @@\n-      (address)(region_at(MetaspaceShared::bm)->mapped_base()) + r->oopmap_offset(),\n+      (address)(region_at(AOTMetaspace::bm)->mapped_base()) + r->oopmap_offset(),\n@@ -1808,1 +1808,1 @@\n-    MetaspaceShared::unrecoverable_loading_error(\"Mark mismatch while restoring from shared file.\");\n+    AOTMetaspace::unrecoverable_loading_error(\"Mark mismatch while restoring from shared file.\");\n@@ -1835,1 +1835,1 @@\n-    MetaspaceShared::report_loading_error(\"CDS is disabled because early JVMTI ClassFileLoadHook is in use.\");\n+    AOTMetaspace::report_loading_error(\"CDS is disabled because early JVMTI ClassFileLoadHook is in use.\");\n@@ -1841,1 +1841,1 @@\n-      MetaspaceShared::report_loading_error(\"Loading static archive failed.\");\n+      AOTMetaspace::report_loading_error(\"Loading static archive failed.\");\n@@ -1844,1 +1844,1 @@\n-      MetaspaceShared::report_loading_error(\"Loading dynamic archive failed.\");\n+      AOTMetaspace::report_loading_error(\"Loading dynamic archive failed.\");\n@@ -1897,1 +1897,1 @@\n-  return region_at(MetaspaceShared::rw);\n+  return region_at(AOTMetaspace::rw);\n@@ -1901,1 +1901,1 @@\n-  return region_at(MetaspaceShared::ro);\n+  return region_at(AOTMetaspace::ro);\n@@ -1928,1 +1928,1 @@\n-    MetaspaceShared::report_loading_error(\"The %s's ObjectAlignmentInBytes of %d\"\n+    AOTMetaspace::report_loading_error(\"The %s's ObjectAlignmentInBytes of %d\"\n@@ -1934,1 +1934,1 @@\n-    MetaspaceShared::report_loading_error(\"The %s's CompactStrings setting (%s)\"\n+    AOTMetaspace::report_loading_error(\"The %s's CompactStrings setting (%s)\"\n@@ -1952,1 +1952,1 @@\n-    MetaspaceShared::report_loading_error(\"The %s's JIT compiler setting (%s)\"\n+    AOTMetaspace::report_loading_error(\"The %s's JIT compiler setting (%s)\"\n@@ -1959,1 +1959,1 @@\n-      MetaspaceShared::report_loading_error(\"The %s's TypeProfileLevel setting (%d)\"\n+      AOTMetaspace::report_loading_error(\"The %s's TypeProfileLevel setting (%d)\"\n@@ -1965,1 +1965,1 @@\n-      MetaspaceShared::report_loading_error(\"The %s's TypeProfileArgsLimit setting (%d)\"\n+      AOTMetaspace::report_loading_error(\"The %s's TypeProfileArgsLimit setting (%d)\"\n@@ -1971,1 +1971,1 @@\n-      MetaspaceShared::report_loading_error(\"The %s's TypeProfileParamsLimit setting (%d)\"\n+      AOTMetaspace::report_loading_error(\"The %s's TypeProfileParamsLimit setting (%d)\"\n@@ -1978,1 +1978,1 @@\n-      MetaspaceShared::report_loading_error(\"The %s's TypeProfileWidth setting (%d)\"\n+      AOTMetaspace::report_loading_error(\"The %s's TypeProfileWidth setting (%d)\"\n@@ -1985,1 +1985,1 @@\n-      MetaspaceShared::report_loading_error(\"The %s's BciProfileWidth setting (%d)\"\n+      AOTMetaspace::report_loading_error(\"The %s's BciProfileWidth setting (%d)\"\n@@ -1991,1 +1991,1 @@\n-      MetaspaceShared::report_loading_error(\"The %s's TypeProfileCasts setting (%s)\"\n+      AOTMetaspace::report_loading_error(\"The %s's TypeProfileCasts setting (%s)\"\n@@ -2000,1 +2000,1 @@\n-      MetaspaceShared::report_loading_error(\"The %s's ProfileTraps setting (%s)\"\n+      AOTMetaspace::report_loading_error(\"The %s's ProfileTraps setting (%s)\"\n@@ -2008,1 +2008,1 @@\n-      MetaspaceShared::report_loading_error(\"The %s's SpecTrapLimitExtraEntries setting (%d)\"\n+      AOTMetaspace::report_loading_error(\"The %s's SpecTrapLimitExtraEntries setting (%d)\"\n@@ -2021,1 +2021,1 @@\n-      MetaspaceShared::report_loading_error(\"%s has aot-linked classes. It cannot be used when the \"\n+      AOTMetaspace::report_loading_error(\"%s has aot-linked classes. It cannot be used when the \"\n@@ -2035,1 +2035,1 @@\n-    MetaspaceShared::report_loading_error(\"The %s's BytecodeVerificationLocal setting (%s)\"\n+    AOTMetaspace::report_loading_error(\"The %s's BytecodeVerificationLocal setting (%s)\"\n@@ -2059,1 +2059,1 @@\n-    MetaspaceShared::report_loading_error(\"The setting of the AllowArchivingWithJavaAgent is different \"\n+    AOTMetaspace::report_loading_error(\"The setting of the AllowArchivingWithJavaAgent is different \"\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":83,"deletions":83,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -74,1 +74,1 @@\n-  size_t used_aligned()             const; \/\/ aligned up to MetaspaceShared::core_region_alignment()\n+  size_t used_aligned()             const; \/\/ aligned up to AOTMetaspace::core_region_alignment()\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-          MetaspaceShared::unrecoverable_writing_error();\n+          AOTMetaspace::unrecoverable_writing_error();\n@@ -211,1 +211,1 @@\n-      MetaspaceShared::unrecoverable_writing_error(\"Unexpected exception, use -Xlog:aot,exceptions=trace for detail\");\n+      AOTMetaspace::unrecoverable_writing_error(\"Unexpected exception, use -Xlog:aot,exceptions=trace for detail\");\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -38,1 +39,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -186,1 +186,1 @@\n-    klass = klass->java_super();\n+    klass = klass->super();\n@@ -370,1 +370,1 @@\n-class MetaspaceObjToOopHandleTable: public ResourceHashtable<MetaspaceObj*, OopHandle,\n+class MetaspaceObjToOopHandleTable: public HashTable<MetaspaceObj*, OopHandle,\n@@ -876,1 +876,1 @@\n-  MetaspaceShared::unrecoverable_writing_error();\n+  AOTMetaspace::unrecoverable_writing_error();\n@@ -1223,1 +1223,1 @@\n-  if (!k->is_shared()) {\n+  if (!k->in_aot_cache()) {\n@@ -1277,1 +1277,1 @@\n-        if (!klass->is_shared()) {\n+        if (!klass->in_aot_cache()) {\n@@ -1512,1 +1512,1 @@\n-    MetaspaceShared::unrecoverable_writing_error();\n+    AOTMetaspace::unrecoverable_writing_error();\n@@ -1565,1 +1565,1 @@\n-      MetaspaceShared::unrecoverable_writing_error();\n+      AOTMetaspace::unrecoverable_writing_error();\n@@ -1595,1 +1595,1 @@\n-        MetaspaceShared::unrecoverable_writing_error();\n+        AOTMetaspace::unrecoverable_writing_error();\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -40,1 +40,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -205,1 +205,1 @@\n-  typedef ResizeableResourceHashtable<oop, CachedOopInfo,\n+  typedef ResizeableHashTable<oop, CachedOopInfo,\n@@ -212,1 +212,1 @@\n-    : public ResourceHashtable<Klass*, KlassSubGraphInfo,\n+    : public HashTable<Klass*, KlassSubGraphInfo,\n@@ -267,1 +267,1 @@\n-  typedef ResizeableResourceHashtable<oop, bool,\n+  typedef ResizeableHashTable<oop, bool,\n@@ -435,1 +435,1 @@\n-    CDS_JAVA_HEAP_ONLY(return (idx == MetaspaceShared::hp);)\n+    CDS_JAVA_HEAP_ONLY(return (idx == AOTMetaspace::hp);)\n@@ -471,1 +471,1 @@\n-  public ResizeableResourceHashtable<oop, bool,\n+  public ResizeableHashTable<oop, bool,\n@@ -478,1 +478,1 @@\n-    ResizeableResourceHashtable<oop, bool,\n+    ResizeableHashTable<oop, bool,\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -182,1 +182,1 @@\n-      if (!klass->is_shared() && klass->shared_classpath_index() < 0) {\n+      if (!klass->in_aot_cache() && klass->shared_classpath_index() < 0) {\n@@ -187,1 +187,1 @@\n-        klass->set_is_generated_shared_class();\n+        klass->set_is_aot_generated_class();\n@@ -222,1 +222,1 @@\n-  MetaspaceShared::try_link_class(THREAD, result);\n+  AOTMetaspace::try_link_class(THREAD, result);\n@@ -225,2 +225,2 @@\n-  result->set_is_generated_shared_class();\n-  if (!klass->is_shared()) {\n+  result->set_is_aot_generated_class();\n+  if (!klass->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -250,6 +250,6 @@\n-  if (!caller_ik->is_shared()     ||\n-      !invoked_name->is_shared()  ||\n-      !invoked_type->is_shared()  ||\n-      !method_type->is_shared()   ||\n-      (member_method != nullptr && !member_method->is_shared()) ||\n-      !instantiated_method_type->is_shared()) {\n+  if (!caller_ik->in_aot_cache()     ||\n+      !invoked_name->in_aot_cache()  ||\n+      !invoked_type->in_aot_cache()  ||\n+      !method_type->in_aot_cache()   ||\n+      (member_method != nullptr && !member_method->in_aot_cache()) ||\n+      !instantiated_method_type->in_aot_cache()) {\n@@ -328,1 +328,1 @@\n-  assert(shared_nest_host->is_shared(), \"nest host must be in CDS archive\");\n+  assert(shared_nest_host->in_aot_cache(), \"nest host must be in aot metaspace\");\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -33,1 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -252,1 +252,1 @@\n-  : public ResourceHashtable<LambdaProxyClassKey,\n+  : public HashTable<LambdaProxyClassKey,\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -37,1 +37,1 @@\n-using RegeneratedObjTable = ResourceHashtable<address, address, 15889, AnyObj::C_HEAP, mtClassShared>;\n+using RegeneratedObjTable = HashTable<address, address, 15889, AnyObj::C_HEAP, mtClassShared>;\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(this)) {\n+  if (AOTMetaspace::in_aot_cache(this)) {\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -254,1 +254,1 @@\n-    assert(klass->is_shared(), \"don't call for non-shared class\");\n+    assert(klass->in_aot_cache(), \"don't call for non-shared class\");\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-    os::vsnprintf(e, m - e, fmt, args);\n+    (void) os::vsnprintf(e, m - e, fmt, args);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1575,1 +1575,1 @@\n-      ik = ik->java_super();\n+      ik = ik->super();\n@@ -1594,1 +1594,1 @@\n-    ik = ik->java_super();\n+    ik = ik->super();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n-\n+#include \"utilities\/hashTable.hpp\"\n@@ -128,1 +127,1 @@\n-  typedef ResourceHashtable<BytecodeCPEntry, u2,\n+  typedef HashTable<BytecodeCPEntry, u2,\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -86,1 +87,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -785,1 +785,1 @@\n-using NameSigHashtable = ResourceHashtable<NameSigHash, int,\n+using NameSigHashtable = HashTable<NameSigHash, int,\n@@ -852,1 +852,1 @@\n-    ResourceHashtable<Symbol*, int>* interface_names = new ResourceHashtable<Symbol*, int>();\n+    HashTable<Symbol*, int>* interface_names = new HashTable<Symbol*, int>();\n@@ -2025,1 +2025,1 @@\n-  typedef ResourceHashtable<LocalVariableTableElement, LocalVariableTableElement*,\n+  typedef HashTable<LocalVariableTableElement, LocalVariableTableElement*,\n@@ -3806,4 +3806,4 @@\n-const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,\n-                                                        const int super_class_index,\n-                                                        const bool need_verify,\n-                                                        TRAPS) {\n+void ClassFileParser::check_super_class(ConstantPool* const cp,\n+                                        const int super_class_index,\n+                                        const bool need_verify,\n+                                        TRAPS) {\n@@ -3811,1 +3811,0 @@\n-  const InstanceKlass* super_klass = nullptr;\n@@ -3817,1 +3816,1 @@\n-                       CHECK_NULL);\n+                       CHECK);\n@@ -3822,1 +3821,2 @@\n-                       CHECK_NULL);\n+                       CHECK);\n+\n@@ -3825,8 +3825,0 @@\n-    bool is_array = false;\n-    if (cp->tag_at(super_class_index).is_klass()) {\n-      super_klass = InstanceKlass::cast(cp->resolved_klass_at(super_class_index));\n-      if (need_verify)\n-        is_array = super_klass->is_array_klass();\n-    } else if (need_verify) {\n-      is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n-    }\n@@ -3834,2 +3826,2 @@\n-      guarantee_property(!is_array,\n-                        \"Bad superclass name in class file %s\", CHECK_NULL);\n+      guarantee_property(cp->klass_name_at(super_class_index)->char_at(0) != JVM_SIGNATURE_ARRAY,\n+                        \"Bad superclass name in class file %s\", CHECK);\n@@ -3838,1 +3830,0 @@\n-  return super_klass;\n@@ -3960,1 +3951,1 @@\n-  const InstanceKlass* const super = ik->java_super();\n+  const InstanceKlass* const super = ik->super();\n@@ -4095,1 +4086,1 @@\n-  const Klass* const super = this_klass->super();\n+  const InstanceKlass* const super = this_klass->super();\n@@ -4098,2 +4089,0 @@\n-    const InstanceKlass* super_ik = InstanceKlass::cast(super);\n-\n@@ -4101,1 +4090,1 @@\n-      classfile_icce_error(\"class %s cannot inherit from final class %s\", super_ik, THREAD);\n+      classfile_icce_error(\"class %s cannot inherit from final class %s\", super, THREAD);\n@@ -4105,1 +4094,1 @@\n-    if (super_ik->is_sealed()) {\n+    if (super->is_sealed()) {\n@@ -4108,1 +4097,1 @@\n-      if (!super_ik->has_as_permitted_subclass(this_klass, ss)) {\n+      if (!super->has_as_permitted_subclass(this_klass, ss)) {\n@@ -4115,1 +4104,1 @@\n-      Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);\n+      Reflection::verify_class_access(this_klass, super, false);\n@@ -4119,1 +4108,1 @@\n-                                                      InstanceKlass::cast(super),\n+                                                      super,\n@@ -4215,1 +4204,1 @@\n-      const InstanceKlass* k = this_klass->java_super();\n+      const InstanceKlass* k = this_klass->super();\n@@ -4221,1 +4210,1 @@\n-          super_m = InstanceKlass::cast(k)->lookup_method(name, signature);\n+          super_m = k->lookup_method(name, signature);\n@@ -4247,1 +4236,1 @@\n-          k = super_m->method_holder()->java_super();\n+          k = super_m->method_holder()->super();\n@@ -4251,1 +4240,1 @@\n-        k = k->java_super();\n+        k = k->super();\n@@ -5297,1 +5286,1 @@\n-      if (ik->java_super() != nullptr) {\n+      if (ik->super() != nullptr) {\n@@ -5300,1 +5289,1 @@\n-                   ik->java_super()->external_name());\n+                   ik->super()->external_name());\n@@ -5672,4 +5661,4 @@\n-  _super_klass = parse_super_class(cp,\n-                                   _super_class_index,\n-                                   _need_verify,\n-                                   CHECK);\n+  check_super_class(cp,\n+                    _super_class_index,\n+                    _need_verify,\n+                    CHECK);\n@@ -5778,0 +5767,2 @@\n+    precond(_super_class_index == 0);\n+    precond(_super_klass == nullptr);\n@@ -5781,3 +5772,3 @@\n-  }\n-  \/\/ We check super class after class file is parsed and format is checked\n-  if (_super_class_index > 0 && nullptr == _super_klass) {\n+  } else {\n+    \/\/ Set _super_klass after class file is parsed and format is checked\n+    assert(_super_class_index > 0, \"any class other than Object must have a super class\");\n@@ -5794,0 +5785,1 @@\n+      \/\/ fast path to avoid lookup\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":36,"deletions":44,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -245,4 +245,4 @@\n-  const InstanceKlass* parse_super_class(ConstantPool* const cp,\n-                                         const int super_class_index,\n-                                         const bool need_verify,\n-                                         TRAPS);\n+  void check_super_class(ConstantPool* const cp,\n+                         const int super_class_index,\n+                         const bool need_verify,\n+                         TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-    } else if (k->is_shared() && k->is_objArray_klass()) {\n+    } else if (k->in_aot_cache() && k->is_objArray_klass()) {\n@@ -871,1 +871,1 @@\n-  if (!m->is_shared()) {\n+  if (!m->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n@@ -35,2 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n-\n+#include \"utilities\/hashTable.hpp\"\n@@ -108,1 +106,1 @@\n-  typedef ResourceHashtable<oop, ClassLoaderStats,\n+  typedef HashTable<oop, ClassLoaderStats,\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    InstanceKlass* next_super() { return _class->java_super(); }\n+    InstanceKlass* next_super() { return _class->super(); }\n@@ -639,1 +639,1 @@\n-  InstanceKlass* super = klass->java_super();\n+  InstanceKlass* super = klass->super();\n@@ -671,1 +671,1 @@\n-    super = super->java_super();\n+    super = super->super();\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-    ik = ik->super() == nullptr ? nullptr : InstanceKlass::cast(ik->super());\n+    ik = ik->super() == nullptr ? nullptr : ik->super();\n@@ -477,1 +477,1 @@\n-          ik = ik->java_super();\n+          ik = ik->super();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -942,1 +942,1 @@\n-  if (!k->is_shared()) {\n+  if (!k->in_aot_cache()) {\n@@ -980,1 +980,1 @@\n-  if (k->is_shared() && k->has_archived_mirror_index()) {\n+  if (k->in_aot_cache() && k->has_archived_mirror_index()) {\n@@ -1889,2 +1889,3 @@\n-         JavaThread::current()->thread_state() == _thread_in_vm,\n-         \"Java Thread is not running in vm\");\n+         JavaThread::current()->thread_state() == _thread_in_vm ||\n+         JavaThread::current() == java_lang_Thread::thread(java_thread),\n+         \"unsafe call to java_lang_Thread::get_thread_status()?\");\n@@ -1902,14 +1903,10 @@\n-oop java_lang_Thread::async_get_stack_trace(oop java_thread, TRAPS) {\n-  ThreadsListHandle tlh(JavaThread::current());\n-  JavaThread* thread;\n-  bool is_virtual = java_lang_VirtualThread::is_instance(java_thread);\n-  if (is_virtual) {\n-    oop carrier_thread = java_lang_VirtualThread::carrier_thread(java_thread);\n-    if (carrier_thread == nullptr) {\n-      return nullptr;\n-    }\n-    thread = java_lang_Thread::thread(carrier_thread);\n-  } else {\n-    thread = java_lang_Thread::thread(java_thread);\n-  }\n-  if (thread == nullptr) {\n+\/\/ Obtain stack trace for platform or mounted virtual thread.\n+\/\/ If jthread is a virtual thread and it has been unmounted (or remounted to different carrier) the method returns null.\n+\/\/ The caller (java.lang.VirtualThread) handles returned nulls via retry.\n+oop java_lang_Thread::async_get_stack_trace(jobject jthread, TRAPS) {\n+  ThreadsListHandle tlh(THREAD);\n+  JavaThread* java_thread = nullptr;\n+  oop thread_oop;\n+\n+  bool has_java_thread = tlh.cv_internal_thread_to_JavaThread(jthread, &java_thread, &thread_oop);\n+  if (!has_java_thread) {\n@@ -1921,1 +1918,1 @@\n-    const Handle _java_thread;\n+    const Handle _thread_h;\n@@ -1927,2 +1924,2 @@\n-    GetStackTraceHandshakeClosure(Handle java_thread) :\n-        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _java_thread(java_thread), _depth(0), _retry_handshake(false),\n+    GetStackTraceHandshakeClosure(Handle thread_h) :\n+        HandshakeClosure(\"GetStackTraceHandshakeClosure\"), _thread_h(thread_h), _depth(0), _retry_handshake(false),\n@@ -1950,1 +1947,1 @@\n-      JavaThread* thread = JavaThread::cast(th);\n+      JavaThread* java_thread = JavaThread::cast(th);\n@@ -1952,1 +1949,1 @@\n-      if (!thread->has_last_Java_frame()) {\n+      if (!java_thread->has_last_Java_frame()) {\n@@ -1957,5 +1954,6 @@\n-      if (java_lang_VirtualThread::is_instance(_java_thread())) {\n-        \/\/ if (thread->vthread() != _java_thread()) \/\/ We might be inside a System.executeOnCarrierThread\n-        const ContinuationEntry* ce = thread->vthread_continuation();\n-        if (ce == nullptr || ce->cont_oop(thread) != java_lang_VirtualThread::continuation(_java_thread())) {\n-          return; \/\/ not mounted\n+      if (java_lang_VirtualThread::is_instance(_thread_h())) {\n+        \/\/ Ensure _thread_h is still mounted to java_thread.\n+        const ContinuationEntry* ce = java_thread->vthread_continuation();\n+        if (ce == nullptr || ce->cont_oop(java_thread) != java_lang_VirtualThread::continuation(_thread_h())) {\n+          \/\/ Target thread has been unmounted.\n+          return;\n@@ -1964,1 +1962,1 @@\n-        carrier = (thread->vthread_continuation() != nullptr);\n+        carrier = (java_thread->vthread_continuation() != nullptr);\n@@ -1976,1 +1974,1 @@\n-      for (vframeStream vfst(thread, false, false, carrier); \/\/ we don't process frames as we don't care about oops\n+      for (vframeStream vfst(java_thread, false, false, carrier); \/\/ we don't process frames as we don't care about oops\n@@ -1997,1 +1995,1 @@\n-  GetStackTraceHandshakeClosure gsthc(Handle(THREAD, java_thread));\n+  GetStackTraceHandshakeClosure gsthc(Handle(THREAD, thread_oop));\n@@ -1999,1 +1997,1 @@\n-   Handshake::execute(&gsthc, &tlh, thread);\n+   Handshake::execute(&gsthc, &tlh, java_thread);\n@@ -2624,2 +2622,2 @@\n-  size_t buf_off = os::snprintf_checked(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n-\n+  int buf_off = os::snprintf(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n+  assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2629,1 +2627,2 @@\n-      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n+      buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n+      assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2631,1 +2630,2 @@\n-      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n+      buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n+      assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2646,1 +2646,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2649,1 +2650,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2652,1 +2654,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":43,"deletions":40,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -466,1 +466,1 @@\n-  static oop async_get_stack_trace(oop java_thread, TRAPS);\n+  static oop async_get_stack_trace(jobject jthread, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  assert(ik->is_shared(), \"expecting a shared class\");\n+  assert(ik->in_aot_cache(), \"expecting a shared class\");\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -150,1 +150,1 @@\n-using InternalLoaderConstraintTable = ResourceHashtable<SymbolHandle, ConstraintSet, 107, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n+using InternalLoaderConstraintTable = HashTable<SymbolHandle, ConstraintSet, 107, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -50,1 +51,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -406,1 +406,1 @@\n-typedef ResourceHashtable<\n+typedef HashTable<\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -236,1 +236,1 @@\n-  ResourceHashtable<SymbolHandle, ModuleEntry*, 109, AnyObj::C_HEAP, mtModule,\n+  HashTable<SymbolHandle, ModuleEntry*, 109, AnyObj::C_HEAP, mtModule,\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -604,1 +604,1 @@\n-      MetaspaceShared::report_loading_error(\"Mismatched values for property %s: %s specified during dump time but not during runtime\", _prop, _archived_value);\n+      AOTMetaspace::report_loading_error(\"Mismatched values for property %s: %s specified during dump time but not during runtime\", _prop, _archived_value);\n@@ -609,1 +609,1 @@\n-      MetaspaceShared::report_loading_error(\"Mismatched values for property %s: %s specified during runtime but not during dump time\", _prop, runtime_value);\n+      AOTMetaspace::report_loading_error(\"Mismatched values for property %s: %s specified during runtime but not during dump time\", _prop, runtime_value);\n@@ -612,1 +612,1 @@\n-      MetaspaceShared::report_loading_error(\"Mismatched values for property %s: runtime %s dump time %s\", _prop, runtime_value, _archived_value);\n+      AOTMetaspace::report_loading_error(\"Mismatched values for property %s: runtime %s dump time %s\", _prop, runtime_value, _archived_value);\n@@ -618,1 +618,1 @@\n-    MetaspaceShared::report_loading_error(\"Disabling optimized module handling\");\n+    AOTMetaspace::report_loading_error(\"Disabling optimized module handling\");\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -43,1 +44,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -215,1 +215,1 @@\n-typedef ResourceHashtable<\n+typedef HashTable<\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -236,1 +236,1 @@\n-  ResourceHashtable<SymbolHandle, PackageEntry*, 109, AnyObj::C_HEAP, mtModule,\n+  HashTable<SymbolHandle, PackageEntry*, 109, AnyObj::C_HEAP, mtModule,\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -52,1 +52,1 @@\n-using InternalPlaceholderTable = ResourceHashtable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, AnyObj::C_HEAP, mtClass,\n+using InternalPlaceholderTable = HashTable<PlaceholderKey, PlaceholderEntry, _placeholder_table_size, AnyObj::C_HEAP, mtClass,\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -56,1 +56,1 @@\n-using InternalResolutionErrorTable = ResourceHashtable<ResolutionErrorKey, ResolutionErrorEntry*, 107, AnyObj::C_HEAP, mtClass,\n+using InternalResolutionErrorTable = HashTable<ResolutionErrorKey, ResolutionErrorEntry*, 107, AnyObj::C_HEAP, mtClass,\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -813,1 +813,1 @@\n-  ResizeableResourceHashtable<oop, bool, AnyObj::C_HEAP, mtInternal,\n+  ResizeableHashTable<oop, bool, AnyObj::C_HEAP, mtInternal,\n@@ -996,1 +996,1 @@\n-      MetaspaceShared::unrecoverable_writing_error();\n+      AOTMetaspace::unrecoverable_writing_error();\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-      \/\/ We have allocated with MetaspaceShared::symbol_space_alloc(). No deallocation is needed.\n+      \/\/ We have allocated with AOTMetaspace::symbol_space_alloc(). No deallocation is needed.\n@@ -188,1 +188,1 @@\n-      void* p = (void*)MetaspaceShared::symbol_space_alloc(alloc_size);\n+      void* p = (void*)AOTMetaspace::symbol_space_alloc(alloc_size);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-using InvokeMethodIntrinsicTable = ResourceHashtable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n+using InvokeMethodIntrinsicTable = HashTable<InvokeMethodKey, Method*, 139, AnyObj::C_HEAP, mtClass,\n@@ -117,1 +117,1 @@\n-using InvokeMethodTypeTable = ResourceHashtable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n+using InvokeMethodTypeTable = HashTable<SymbolHandle, OopHandle, 139, AnyObj::C_HEAP, mtClass, SymbolHandle::compute_hash>;\n@@ -434,1 +434,1 @@\n-      InstanceKlass* superk = klassk->java_super();\n+      InstanceKlass* superk = klassk->super();\n@@ -1017,1 +1017,1 @@\n-  assert(super_type->is_shared(), \"must be\");\n+  assert(super_type->in_aot_cache(), \"must be\");\n@@ -1052,1 +1052,1 @@\n-    bool check_super = check_shared_class_super_type(ik, InstanceKlass::cast(ik->super()),\n+    bool check_super = check_shared_class_super_type(ik, ik->super(),\n@@ -1080,1 +1080,1 @@\n-  assert(ik->is_shared(), \"sanity\");\n+  assert(ik->in_aot_cache(), \"sanity\");\n@@ -1748,1 +1748,1 @@\n-        !klass_being_linked->is_shared()) {\n+        !klass_being_linked->in_aot_cache()) {\n@@ -2004,1 +2004,1 @@\n-  Array<Method*>* list = MetaspaceShared::archived_method_handle_intrinsics();\n+  Array<Method*>* list = AOTMetaspace::archived_method_handle_intrinsics();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -28,0 +29,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -40,1 +42,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -77,1 +78,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -207,1 +208,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(k)) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && AOTMetaspace::in_aot_cache(k)) {\n@@ -240,1 +241,1 @@\n-    k = k->java_super();\n+    k = k->super();\n@@ -252,1 +253,1 @@\n-      && k->is_shared()) {\n+      && k->in_aot_cache()) {\n@@ -302,1 +303,1 @@\n-      \/\/ Most loaded classes should have been speculatively linked by MetaspaceShared::link_class_for_cds().\n+      \/\/ Most loaded classes should have been speculatively linked by AOTMetaspace::link_class_for_cds().\n@@ -331,1 +332,1 @@\n-  InstanceKlass* super = k->java_super();\n+  InstanceKlass* super = k->super();\n@@ -448,1 +449,1 @@\n-class UnregisteredClassesTable : public ResourceHashtable<\n+class UnregisteredClassesTable : public HashTable<\n@@ -485,1 +486,1 @@\n-  precond(klass->is_shared());\n+  precond(klass->in_aot_cache());\n@@ -573,1 +574,1 @@\n-  if (k->java_super() != nullptr && has_been_redefined(k->java_super())) {\n+  if (k->super() != nullptr && has_been_redefined(k->super())) {\n@@ -667,1 +668,1 @@\n-    if (CDSConfig::is_dumping_dynamic_archive() && ik->is_shared()) {\n+    if (CDSConfig::is_dumping_dynamic_archive() && ik->in_aot_cache()) {\n@@ -693,1 +694,1 @@\n-      \/\/ already been linked in MetaspaceShared::link_class_for_cds().\n+      \/\/ already been linked in AOTMetaspace::link_class_for_cds().\n@@ -1020,1 +1021,1 @@\n-        if (MetaspaceObj::is_shared((const MetaspaceObj*)ptr)) {\n+        if (MetaspaceObj::in_aot_cache((const MetaspaceObj*)ptr)) {\n@@ -1108,1 +1109,1 @@\n-  if (!CDSConfig::is_using_archive() || !name->is_shared()) {\n+  if (!CDSConfig::is_using_archive() || !name->in_aot_cache()) {\n@@ -1126,1 +1127,1 @@\n-  if (!MetaspaceShared::is_shared_dynamic(name)) {\n+  if (!AOTMetaspace::in_aot_cache_dynamic_region(name)) {\n@@ -1148,1 +1149,1 @@\n-    if (record->klass()->is_generated_shared_class() && JvmtiExport::should_post_class_file_load_hook()) {\n+    if (record->klass()->is_aot_generated_class() && JvmtiExport::should_post_class_file_load_hook()) {\n@@ -1165,1 +1166,1 @@\n-  assert(k->is_shared(), \"Must be\");\n+  assert(k->in_aot_cache(), \"Must be\");\n@@ -1181,0 +1182,6 @@\n+void SystemDictionaryShared::get_all_archived_classes(bool is_static_archive, GrowableArray<Klass*>* classes) {\n+  get_archive(is_static_archive)->_builtin_dictionary.iterate([&] (const RunTimeClassInfo* record) {\n+      classes->append(record->klass());\n+    });\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+template <typename E> class GrowableArray;\n+\n@@ -128,1 +130,1 @@\n-      if (_klass->is_shared()) {\n+      if (_klass->in_aot_cache()) {\n@@ -272,0 +274,1 @@\n+  static void get_all_archived_classes(bool is_static_archive, GrowableArray<Klass*>* classes);\n@@ -297,1 +300,1 @@\n-    assert(MetaspaceObj::is_shared((const MetaspaceObj*)ptr), \"must be\");\n+    assert(MetaspaceObj::in_aot_cache((const MetaspaceObj*)ptr), \"must be\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-    !(klass->is_shared() && klass->is_rewritten()));\n+    !(klass->in_aot_cache() && klass->is_rewritten()));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -273,1 +273,1 @@\n-typedef ResourceHashtable<int, sig_as_verification_types*, 1007>\n+typedef HashTable<int, sig_as_verification_types*, 1007>\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    assert(Object_klass()->is_shared(), \"must be\");\n+    assert(Object_klass()->in_aot_cache(), \"must be\");\n@@ -207,1 +207,1 @@\n-      assert(k->is_shared(), \"must not be replaced by JVMTI class file load hook\");\n+      assert(k->in_aot_cache(), \"must not be replaced by JVMTI class file load hook\");\n@@ -222,1 +222,1 @@\n-  assert(klass->is_shared(), \"Must be shared class\");\n+  assert(klass->in_aot_cache(), \"Must be shared class\");\n@@ -228,1 +228,1 @@\n-  Klass* super = klass->super();\n+  InstanceKlass* super = klass->super();\n@@ -231,1 +231,1 @@\n-    resolve_shared_class(InstanceKlass::cast(super), loader_data, domain, CHECK);\n+    resolve_shared_class(super, loader_data, domain, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_name(     countPositives_name,                       \"countPositives0\")                                           \\\n@@ -423,1 +423,1 @@\n-   do_name(     encodeISOArray_name,                             \"implEncodeISOArray\")                                  \\\n+   do_name(     encodeISOArray_name,                             \"encodeISOArray0\")                                     \\\n@@ -429,1 +429,1 @@\n-   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n+   do_name(     encodeAsciiArray_name,                           \"encodeAsciiArray0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -99,1 +99,1 @@\n-\/\/ MetaspaceShared::open_static_archive() which is calles\n+\/\/ AOTMetaspace::open_static_archive() which is calles\n@@ -168,1 +168,1 @@\n-\/\/ It is called from MetaspaceShared::initialize_shared_spaces()\n+\/\/ It is called from AOTMetaspace::initialize_shared_spaces()\n@@ -1372,1 +1372,1 @@\n-  SET_ADDRESS(_extrs, ShenandoahRuntime::write_ref_field_pre);\n+  SET_ADDRESS(_extrs, ShenandoahRuntime::write_barrier_pre);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -453,2 +453,4 @@\n-    assert(entry_offset[i] > 0 && entry_offset[i] < cb->insts()->size(),\n-           \"invalid entry offset 0x%x\", entry_offset[i]);\n+    \/\/ The entry is within the adapter blob or unset.\n+    assert((entry_offset[i] > 0 && entry_offset[i] < cb->insts()->size()) ||\n+           (entry_offset[i] == -1),\n+           \"invalid entry offset[%d] = 0x%x\", i, entry_offset[i]);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1188,1 +1188,1 @@\n-  typedef ResourceHashtable<DependencySignature, int, 11027,\n+  typedef HashTable<DependencySignature, int, 11027,\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -742,1 +742,1 @@\n-              os::snprintf(new_blob_name, size, \"%s jvmci_name=%s\", blob_name, jvmci_name);\n+              os::snprintf_checked(new_blob_name, size, \"%s jvmci_name=%s\", blob_name, jvmci_name);\n","filename":"src\/hotspot\/share\/code\/codeHeapState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-      os::snprintf(tmp, sizeof(tmp), \"%9zu (%+zd)\", e._bytes.cur, e._bytes.end_delta());\n+      os::snprintf_checked(tmp, sizeof(tmp), \"%9zu (%+zd)\", e._bytes.cur, e._bytes.end_delta());\n@@ -164,1 +164,1 @@\n-      os::snprintf(tmp, sizeof(tmp), \"%6u (%+d)\", e._live_nodes.cur, e._live_nodes.end_delta());\n+      os::snprintf_checked(tmp, sizeof(tmp), \"%6u (%+d)\", e._live_nodes.cur, e._live_nodes.end_delta());\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-void CompilationPolicy::replay_training_at_init_impl(InstanceKlass* klass, TRAPS) {\n+void CompilationPolicy::replay_training_at_init_impl(InstanceKlass* klass, JavaThread* current) {\n@@ -153,1 +153,1 @@\n-          if (ctd->init_deps_left() == 0) {\n+          if (ctd->init_deps_left_acquire() == 0) {\n@@ -156,2 +156,2 @@\n-              const methodHandle mh(THREAD, const_cast<Method*>(mtd->holder()));\n-              CompilationPolicy::maybe_compile_early(mh, THREAD);\n+              const methodHandle mh(current, const_cast<Method*>(mtd->holder()));\n+              CompilationPolicy::maybe_compile_early(mh, current);\n@@ -166,1 +166,1 @@\n-void CompilationPolicy::replay_training_at_init(InstanceKlass* klass, TRAPS) {\n+void CompilationPolicy::replay_training_at_init(InstanceKlass* klass, JavaThread* current) {\n@@ -168,2 +168,2 @@\n-  if (TrainingData::have_data() && klass->is_shared()) {\n-    _training_replay_queue.push(klass, TrainingReplayQueue_lock, THREAD);\n+  if (TrainingData::have_data() && klass->in_aot_cache()) {\n+    _training_replay_queue.push(klass, TrainingReplayQueue_lock, current);\n@@ -184,1 +184,1 @@\n-void CompilationPolicy::replay_training_at_init_loop(TRAPS) {\n+void CompilationPolicy::replay_training_at_init_loop(JavaThread* current) {\n@@ -186,1 +186,1 @@\n-    InstanceKlass* ik = _training_replay_queue.pop(TrainingReplayQueue_lock, THREAD);\n+    InstanceKlass* ik = _training_replay_queue.pop(TrainingReplayQueue_lock, current);\n@@ -188,1 +188,1 @@\n-      replay_training_at_init_impl(ik, THREAD);\n+      replay_training_at_init_impl(ik, current);\n@@ -407,1 +407,1 @@\n-void CompilationPolicy::print_counters(const char* prefix, Method* m) {\n+void CompilationPolicy::print_counters_on(outputStream* st, const char* prefix, Method* m) {\n@@ -419,6 +419,5 @@\n-  tty->print(\" %stotal=%d,%d %smdo=%d(%d),%d(%d)\", prefix,\n-      invocation_count, backedge_count, prefix,\n-      mdo_invocations, mdo_invocations_start,\n-      mdo_backedges, mdo_backedges_start);\n-  tty->print(\" %smax levels=%d,%d\", prefix,\n-      m->highest_comp_level(), m->highest_osr_comp_level());\n+  st->print(\" %stotal=%d,%d %smdo=%d(%d),%d(%d)\", prefix,\n+    invocation_count, backedge_count, prefix,\n+    mdo_invocations, mdo_invocations_start,\n+    mdo_backedges, mdo_backedges_start);\n+  st->print(\" %smax levels=%d,%d\", prefix, m->highest_comp_level(), m->highest_osr_comp_level());\n@@ -427,1 +426,1 @@\n-void CompilationPolicy::print_training_data(const char* prefix, Method* method) {\n+void CompilationPolicy::print_training_data_on(outputStream* st,  const char* prefix, Method* method) {\n@@ -429,1 +428,1 @@\n-  tty->print(\" %smtd: \", prefix);\n+  st->print(\" %smtd: \", prefix);\n@@ -432,1 +431,1 @@\n-    tty->print(\"null\");\n+    st->print(\"null\");\n@@ -435,1 +434,1 @@\n-    tty->print(\"mdo=\");\n+    st->print(\"mdo=\");\n@@ -437,1 +436,1 @@\n-      tty->print(\"null\");\n+      st->print(\"null\");\n@@ -443,1 +442,1 @@\n-      tty->print(\"%d(%d), %d(%d)\", mdo_invocations, mdo_invocations_start, mdo_backedges, mdo_backedges_start);\n+      st->print(\"%d(%d), %d(%d)\", mdo_invocations, mdo_invocations_start, mdo_backedges, mdo_backedges_start);\n@@ -446,1 +445,1 @@\n-    tty->print(\", deps=\");\n+    st->print(\", deps=\");\n@@ -448,1 +447,1 @@\n-      tty->print(\"null\");\n+      st->print(\"null\");\n@@ -450,1 +449,1 @@\n-      tty->print(\"%d\", ctd->init_deps_left());\n+      st->print(\"%d\", ctd->init_deps_left_acquire());\n@@ -456,1 +455,1 @@\n-void CompilationPolicy::print_event(EventType type, Method* m, Method* im, int bci, CompLevel level) {\n+void CompilationPolicy::print_event_on(outputStream *st, EventType type, Method* m, Method* im, int bci, CompLevel level) {\n@@ -459,2 +458,1 @@\n-  ttyLocker tty_lock;\n-  tty->print(\"%lf: [\", os::elapsedTime());\n+  st->print(\"%lf: [\", os::elapsedTime());\n@@ -464,1 +462,1 @@\n-    tty->print(\"call\");\n+    st->print(\"call\");\n@@ -467,1 +465,1 @@\n-    tty->print(\"loop\");\n+    st->print(\"loop\");\n@@ -470,1 +468,1 @@\n-    tty->print(\"compile\");\n+    st->print(\"compile\");\n@@ -473,1 +471,1 @@\n-    tty->print(\"force-compile\");\n+    st->print(\"force-compile\");\n@@ -476,1 +474,1 @@\n-    tty->print(\"remove-from-queue\");\n+    st->print(\"remove-from-queue\");\n@@ -479,1 +477,1 @@\n-    tty->print(\"update-in-queue\");\n+    st->print(\"update-in-queue\");\n@@ -482,1 +480,1 @@\n-    tty->print(\"reprofile\");\n+    st->print(\"reprofile\");\n@@ -485,1 +483,1 @@\n-    tty->print(\"make-not-entrant\");\n+    st->print(\"make-not-entrant\");\n@@ -488,1 +486,1 @@\n-    tty->print(\"unknown\");\n+    st->print(\"unknown\");\n@@ -491,1 +489,1 @@\n-  tty->print(\" level=%d \", level);\n+  st->print(\" level=%d \", level);\n@@ -495,1 +493,1 @@\n-  tty->print(\"[%s\", method_name);\n+  st->print(\"[%s\", method_name);\n@@ -498,1 +496,1 @@\n-    tty->print(\" [%s]] \", inlinee_name);\n+    st->print(\" [%s]] \", inlinee_name);\n@@ -500,3 +498,3 @@\n-  else tty->print(\"] \");\n-  tty->print(\"@%d queues=%d,%d\", bci, CompileBroker::queue_size(CompLevel_full_profile),\n-                                      CompileBroker::queue_size(CompLevel_full_optimization));\n+  else st->print(\"] \");\n+  st->print(\"@%d queues=%d,%d\", bci, CompileBroker::queue_size(CompLevel_full_profile),\n+                                     CompileBroker::queue_size(CompLevel_full_optimization));\n@@ -504,3 +502,3 @@\n-  tty->print(\" rate=\");\n-  if (m->prev_time() == 0) tty->print(\"n\/a\");\n-  else tty->print(\"%f\", m->rate());\n+  st->print(\" rate=\");\n+  if (m->prev_time() == 0) st->print(\"n\/a\");\n+  else st->print(\"%f\", m->rate());\n@@ -508,2 +506,2 @@\n-  tty->print(\" k=%.2lf,%.2lf\", threshold_scale(CompLevel_full_profile, Tier3LoadFeedback),\n-                               threshold_scale(CompLevel_full_optimization, Tier4LoadFeedback));\n+  st->print(\" k=%.2lf,%.2lf\", threshold_scale(CompLevel_full_profile, Tier3LoadFeedback),\n+                              threshold_scale(CompLevel_full_optimization, Tier4LoadFeedback));\n@@ -512,1 +510,1 @@\n-    print_counters(\"\", m);\n+    print_counters_on(st, \"\", m);\n@@ -514,1 +512,1 @@\n-      print_counters(\"inlinee \", im);\n+      print_counters_on(st, \"inlinee \", im);\n@@ -516,1 +514,1 @@\n-    tty->print(\" compilable=\");\n+    st->print(\" compilable=\");\n@@ -519,1 +517,1 @@\n-      tty->print(\"c1\");\n+      st->print(\"c1\");\n@@ -523,2 +521,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c1-osr\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c1-osr\");\n@@ -528,2 +526,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c2\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c2\");\n@@ -533,2 +531,2 @@\n-      if (need_comma) tty->print(\",\");\n-      tty->print(\"c2-osr\");\n+      if (need_comma) st->print(\",\");\n+      st->print(\"c2-osr\");\n@@ -536,1 +534,1 @@\n-    tty->print(\" status=\");\n+    st->print(\" status=\");\n@@ -538,3 +536,4 @@\n-      tty->print(\"in-queue\");\n-    } else tty->print(\"idle\");\n-    print_training_data(\"\", m);\n+      st->print(\"in-queue\");\n+    } else st->print(\"idle\");\n+\n+    print_training_data_on(st, \"\", m);\n@@ -542,1 +541,1 @@\n-      print_training_data(\"inlinee \", im);\n+      print_training_data_on(st, \"inlinee \", im);\n@@ -545,1 +544,9 @@\n-  tty->print_cr(\"]\");\n+  st->print_cr(\"]\");\n+\n+}\n+\n+void CompilationPolicy::print_event(EventType type, Method* m, Method* im, int bci, CompLevel level) {\n+  stringStream s;\n+  print_event_on(&s, type, m, im, bci, level);\n+  ResourceMark rm;\n+  tty->print(\"%s\", s.as_string());\n@@ -1168,1 +1175,1 @@\n-  if (SkipTier2IfPossible && ctd->init_deps_left() == 0) {\n+  if (SkipTier2IfPossible && ctd->init_deps_left_acquire() == 0) {\n@@ -1196,1 +1203,1 @@\n-  if (ctd != nullptr && ctd->init_deps_left() == 0) {\n+  if (ctd != nullptr && ctd->init_deps_left_acquire() == 0) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":74,"deletions":67,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-  void push(T* value, Monitor* lock, TRAPS) {\n-    MonitorLocker locker(THREAD, lock);\n+  void push(T* value, Monitor* lock, JavaThread* current) {\n+    MonitorLocker locker(current, lock);\n@@ -85,3 +85,3 @@\n-  T* pop(Monitor* lock, TRAPS) {\n-    MonitorLocker locker(THREAD, lock);\n-    while(is_empty_unlocked() && !CompileBroker::is_compilation_disabled_forever()) {\n+  T* pop(Monitor* lock, JavaThread* current) {\n+    MonitorLocker locker(current, lock);\n+    while (is_empty_unlocked() && !CompileBroker::is_compilation_disabled_forever()) {\n@@ -94,6 +94,3 @@\n-  T* try_pop(Monitor* lock, TRAPS) {\n-    MonitorLocker locker(THREAD, lock);\n-    T* value = nullptr;\n-    if (!is_empty_unlocked()) {\n-      value = pop_unlocked();\n-    }\n+  T* try_pop(Monitor* lock, JavaThread* current) {\n+    MonitorLocker locker(current, lock);\n+    T* value = pop_unlocked();\n@@ -102,1 +99,0 @@\n-\n@@ -290,2 +286,2 @@\n-  static void print_counters(const char* prefix, Method* m);\n-  static void print_training_data(const char* prefix, Method* method);\n+  static void print_counters_on(outputStream* st, const char* prefix, Method* m);\n+  static void print_training_data_on(outputStream* st, const char* prefix, Method* method);\n@@ -321,0 +317,1 @@\n+  static void print_event_on(outputStream *st, EventType type, Method* m, Method* im, int bci, CompLevel level);\n@@ -344,1 +341,1 @@\n-  static void replay_training_at_init_impl(InstanceKlass* klass, TRAPS);\n+  static void replay_training_at_init_impl(InstanceKlass* klass, JavaThread* current);\n@@ -354,2 +351,2 @@\n-  static void replay_training_at_init(InstanceKlass* klass, TRAPS);\n-  static void replay_training_at_init_loop(TRAPS);\n+  static void replay_training_at_init(InstanceKlass* klass, JavaThread* current);\n+  static void replay_training_at_init_loop(JavaThread* current);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+  thread->timeout()->arm();\n@@ -231,0 +232,1 @@\n+  thread->timeout()->disarm();\n@@ -374,0 +376,1 @@\n+    CompileTask* next = current->next();\n@@ -382,1 +385,1 @@\n-    current = current->next();\n+    current = next;\n@@ -482,0 +485,1 @@\n+        task->set_next(nullptr);\n@@ -507,0 +511,2 @@\n+  task->set_next(nullptr);\n+  task->set_prev(nullptr);\n@@ -1058,1 +1064,3 @@\n-  julong free_memory = os::free_memory();\n+  size_t free_memory = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::free_memory(free_memory);\n@@ -1731,6 +1739,9 @@\n-  if (!task->is_complete() && is_compilation_disabled_forever()) {\n-    \/\/ Task is not complete, and we are exiting for compilation shutdown.\n-    \/\/ The task can still be executed by some compiler thread, therefore\n-    \/\/ we cannot delete it. This will leave task allocated, which leaks it.\n-    \/\/ At this (degraded) point, it is less risky to abandon the task,\n-    \/\/ rather than attempting a more complicated deletion protocol.\n+  if (!task->is_complete()) {\n+    \/\/ Task is not complete, likely because we are exiting for compilation\n+    \/\/ shutdown. The task can still be reached through the queue, or executed\n+    \/\/ by some compiler thread. There is no coordination with either MCQ lock\n+    \/\/ holders or compilers, therefore we cannot delete the task.\n+    \/\/\n+    \/\/ This will leave task allocated, which leaks it. At this (degraded) point,\n+    \/\/ it is less risky to abandon the task, rather than attempting a more\n+    \/\/ complicated deletion protocol.\n@@ -1742,0 +1753,2 @@\n+    assert(task->next() == nullptr && task->prev() == nullptr,\n+           \"Completed task should not be in the queue\");\n@@ -1920,0 +1933,4 @@\n+  if (!thread->init_compilation_timeout()) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+  _prev = nullptr;\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-  CompileTask*         _next, *_prev;\n+  CompileTask*         _next;\n+  CompileTask*         _prev;\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -624,0 +624,5 @@\n+  if (UseAutoVectorizationSpeculativeAliasingChecks && !LoopMultiversioning && !UseAutoVectorizationPredicate) {\n+    warning(\"Disabling UseAutoVectorizationSpeculativeAliasingChecks, because neither of the following is enabled:\"\n+            \"  LoopMultiversioning UseAutoVectorizationPredicate\");\n+    UseAutoVectorizationSpeculativeAliasingChecks = false;\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  _timeout = nullptr;\n@@ -52,0 +53,1 @@\n+  delete _timeout;\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -29,0 +31,5 @@\n+#include \"utilities\/macros.hpp\"\n+\n+#ifdef LINUX\n+#include \"compilerThreadTimeout_linux.hpp\"\n+#endif \/\/LINUX\n@@ -41,0 +48,10 @@\n+#ifndef LINUX\n+class CompilerThreadTimeoutGeneric : public CHeapObj<mtCompiler> {\n+ public:\n+  CompilerThreadTimeoutGeneric() {};\n+  void arm() {};\n+  void disarm() {};\n+  bool init_timeout() { return true; };\n+};\n+#endif \/\/ !LINUX\n+\n@@ -45,0 +62,7 @@\n+\n+#ifdef LINUX\n+  typedef CompilerThreadTimeoutLinux Timeout;\n+#else \/\/ LINUX\n+  typedef CompilerThreadTimeoutGeneric Timeout;\n+#endif \/\/ LINUX\n+\n@@ -60,0 +84,1 @@\n+  Timeout*              _timeout;\n@@ -116,1 +141,7 @@\n-#endif\n+#endif \/\/ !PRODUCT\n+\n+  Timeout* timeout() const { return _timeout; };\n+  bool init_compilation_timeout() {\n+    _timeout = new Timeout();\n+    return _timeout->init_timeout();\n+  };\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -43,1 +44,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -192,1 +193,1 @@\n-  typedef ResourceHashtable<\n+  typedef HashTable<\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -264,2 +263,1 @@\n-HeapWord* EpsilonHeap::mem_allocate(size_t size, bool *gc_overhead_limit_was_exceeded) {\n-  *gc_overhead_limit_was_exceeded = false;\n+HeapWord* EpsilonHeap::mem_allocate(size_t size) {\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+  HeapWord* mem_allocate(size_t size) override;\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -76,0 +77,2 @@\n+    _gc_cpu_time_at_pause_end_ms(),\n+    _concurrent_gc_cpu_time_ms(),\n@@ -91,2 +94,2 @@\n-    _long_term_pause_time_ratio(0.0),\n-    _short_term_pause_time_ratio(0.0) {\n+    _long_term_gc_time_ratio(0.0),\n+    _short_term_gc_time_ratio(0.0) {\n@@ -152,0 +155,4 @@\n+double G1Analytics::gc_cpu_time_ms() const {\n+  return (double)CPUTimeUsage::GC::gc_threads() \/ NANOSECS_PER_MILLISEC;\n+}\n+\n@@ -160,1 +167,9 @@\n-void G1Analytics::compute_pause_time_ratios(double end_time_sec, double pause_time_ms) {\n+void G1Analytics::update_gc_time_ratios(double end_time_sec, double pause_time_ms) {\n+  \/\/ This estimates the wall-clock time \"lost\" by application mutator threads due to concurrent GC\n+  \/\/ activity. We do not account for contention on other shared resources such as memory bandwidth and\n+  \/\/ caches, therefore underestimate the impact of the concurrent GC activity on mutator threads.\n+  uint num_cpus = (uint)os::active_processor_count();\n+  double concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms \/ num_cpus;\n+\n+  double gc_time_ms = pause_time_ms + concurrent_gc_impact_time;\n+\n@@ -162,3 +177,4 @@\n-  double gc_pause_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + pause_time_ms;\n-  _long_term_pause_time_ratio = gc_pause_time_ms \/ long_interval_ms;\n-  _long_term_pause_time_ratio = clamp(_long_term_pause_time_ratio, 0.0, 1.0);\n+  double long_term_gc_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + gc_time_ms;\n+\n+  _long_term_gc_time_ratio = long_term_gc_time_ms \/ long_interval_ms;\n+  _long_term_gc_time_ratio = clamp(_long_term_gc_time_ratio, 0.0, 1.0);\n@@ -167,2 +183,6 @@\n-  _short_term_pause_time_ratio = pause_time_ms \/ short_interval_ms;\n-  _short_term_pause_time_ratio = clamp(_short_term_pause_time_ratio, 0.0, 1.0);\n+\n+  assert(short_interval_ms != 0.0, \"short_interval_ms should not be zero, calculated from %f and %f\", end_time_sec,  most_recent_gc_end_time_sec());\n+  _short_term_gc_time_ratio = gc_time_ms \/ short_interval_ms;\n+  _short_term_gc_time_ratio = clamp(_short_term_gc_time_ratio, 0.0, 1.0);\n+\n+  update_recent_gc_times(end_time_sec, gc_time_ms);\n@@ -308,2 +328,2 @@\n-                                         double pause_time_ms) {\n-  _recent_gc_times_ms.add(pause_time_ms);\n+                                         double gc_time_ms) {\n+  _recent_gc_times_ms.add(gc_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -47,1 +47,9 @@\n-  double        _prev_collection_pause_end_ms;\n+  double       _prev_collection_pause_end_ms;\n+\n+  \/\/ Records the total GC CPU time (in ms) at the end of the last GC pause.\n+  \/\/ Used as a baseline to calculate CPU time spent in GC threads between pauses.\n+  double _gc_cpu_time_at_pause_end_ms;\n+\n+  \/\/ CPU time (ms) spent by GC threads between the end of the last pause\n+  \/\/ and the start of the current pause; calculated at start of a GC pause.\n+  double _concurrent_gc_cpu_time_ms;\n@@ -78,4 +86,4 @@\n-  \/\/ Cached values for long and short term pause time ratios. See\n-  \/\/ compute_pause_time_ratios() for how they are computed.\n-  double _long_term_pause_time_ratio;\n-  double _short_term_pause_time_ratio;\n+  \/\/ Cached values for long and short term gc time ratios. See\n+  \/\/ update_gc_time_ratios() for how they are computed.\n+  double _long_term_gc_time_ratio;\n+  double _short_term_gc_time_ratio;\n@@ -105,2 +113,2 @@\n-  double long_term_pause_time_ratio() const {\n-    return _long_term_pause_time_ratio;\n+  double long_term_gc_time_ratio() const {\n+    return _long_term_gc_time_ratio;\n@@ -109,2 +117,2 @@\n-  double short_term_pause_time_ratio() const {\n-    return _short_term_pause_time_ratio;\n+  double short_term_gc_time_ratio() const {\n+    return _short_term_gc_time_ratio;\n@@ -125,0 +133,14 @@\n+  void set_gc_cpu_time_at_pause_end_ms(double ms) {\n+    _gc_cpu_time_at_pause_end_ms = ms;\n+  }\n+\n+  double gc_cpu_time_at_pause_end_ms() const {\n+    return _gc_cpu_time_at_pause_end_ms;\n+  }\n+\n+  void set_concurrent_gc_cpu_time_ms(double ms) {\n+    _concurrent_gc_cpu_time_ms = ms;\n+  }\n+\n+  double gc_cpu_time_ms() const;\n+\n@@ -176,2 +198,2 @@\n-  void update_recent_gc_times(double end_time_sec, double elapsed_ms);\n-  void compute_pause_time_ratios(double end_time_sec, double pause_time_ms);\n+  void update_recent_gc_times(double end_time_sec, double gc_time_ms);\n+  void update_gc_time_ratios(double end_time_sec, double pause_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  assert(oopDesc::is_oop(pre_val, true), \"Error\");\n+  assert(oopDesc::is_oop(pre_val), \"Error\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  assert(oopDesc::is_oop(orig, true \/* ignore mark word *\/), \"Error\");\n+  assert(oopDesc::is_oop(orig), \"Error\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSetRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -786,1 +786,1 @@\n-    assert(!r->rem_set()->is_added_to_cset_group() ||\n+    assert(!r->rem_set()->has_cset_group() ||\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -398,2 +399,1 @@\n-G1CollectedHeap::mem_allocate(size_t word_size,\n-                              bool*  gc_overhead_limit_was_exceeded) {\n+G1CollectedHeap::mem_allocate(size_t word_size) {\n@@ -802,0 +802,1 @@\n+  finish_codecache_marking_cycle();\n@@ -1490,0 +1491,2 @@\n+  start_new_collection_set();\n+\n@@ -2440,0 +2443,6 @@\n+  \/\/ Clear current young cset group to allow adding.\n+  \/\/ It is fine to clear it this late - evacuation does not add any remembered sets\n+  \/\/ by itself, but only marks cards.\n+  \/\/ The regions had their association to this group already removed earlier.\n+  young_regions_cset_group()->clear();\n+\n@@ -2797,1 +2806,1 @@\n-  young_regions_cset_group()->clear();\n+  young_regions_cset_group()->clear(true \/* uninstall_group_cardset *\/);\n@@ -3082,0 +3091,2 @@\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  bs_nm->disarm(nm);\n@@ -3162,1 +3173,1 @@\n-  collection_set()->prepare_groups_for_scan();\n+  collection_set()->prepare_for_scan();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -445,2 +445,1 @@\n-  HeapWord* mem_allocate(size_t word_size,\n-                         bool*  gc_overhead_limit_was_exceeded) override;\n+  HeapWord* mem_allocate(size_t word_size) override;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,9 @@\n-#include \"utilities\/quickSort.hpp\"\n+\n+uint G1CollectionSet::groups_cur_length() const {\n+  assert(_inc_build_state == CSetBuildType::Inactive, \"must be\");\n+  return _groups.length();\n+}\n+\n+uint G1CollectionSet::groups_increment_length() const {\n+  return groups_cur_length() - _groups_inc_part_start;\n+}\n@@ -53,6 +61,4 @@\n-  _collection_set_regions(nullptr),\n-  _collection_set_cur_length(0),\n-  _collection_set_max_length(0),\n-  _collection_set_groups(),\n-  _selected_groups_cur_length(0),\n-  _selected_groups_inc_part_start(0),\n+  _regions(nullptr),\n+  _regions_max_length(0),\n+  _regions_cur_length(0),\n+  _groups(),\n@@ -63,2 +69,3 @@\n-  _inc_build_state(Inactive),\n-  _inc_part_start(0) {\n+  DEBUG_ONLY(_inc_build_state(CSetBuildType::Inactive) COMMA)\n+  _regions_inc_part_start(0),\n+  _groups_inc_part_start(0) {\n@@ -68,1 +75,1 @@\n-  FREE_C_HEAP_ARRAY(uint, _collection_set_regions);\n+  FREE_C_HEAP_ARRAY(uint, _regions);\n@@ -79,2 +86,2 @@\n-  assert((size_t)young_region_length() == _collection_set_cur_length,\n-         \"Young region length %u should match collection set length %u\", young_region_length(), _collection_set_cur_length);\n+  assert((size_t)young_region_length() == _regions_cur_length,\n+         \"Young region length %u should match collection set length %u\", young_region_length(), _regions_cur_length);\n@@ -88,3 +95,3 @@\n-  guarantee(_collection_set_regions == nullptr, \"Must only initialize once.\");\n-  _collection_set_max_length = max_region_length;\n-  _collection_set_regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);\n+  guarantee(_regions == nullptr, \"Must only initialize once.\");\n+  _regions_max_length = max_region_length;\n+  _regions = NEW_C_HEAP_ARRAY(uint, max_region_length, mtGC);\n@@ -100,2 +107,2 @@\n-void G1CollectionSet::prepare_groups_for_scan () {\n-  collection_set_groups()->prepare_for_scan();\n+void G1CollectionSet::prepare_for_scan () {\n+  _groups.prepare_for_scan();\n@@ -107,1 +114,1 @@\n-  assert(_inc_build_state == Active,\n+  assert(_inc_build_state == CSetBuildType::Active,\n@@ -111,1 +118,1 @@\n-  assert(!hr->rem_set()->is_added_to_cset_group(), \"Should have already uninstalled group remset\");\n+  assert(!hr->rem_set()->has_cset_group(), \"Should have already uninstalled group remset\");\n@@ -116,2 +123,2 @@\n-  assert(_collection_set_cur_length < _collection_set_max_length, \"Collection set now larger than maximum size.\");\n-  _collection_set_regions[_collection_set_cur_length++] = hr->hrm_index();\n+  assert(_regions_cur_length < _regions_max_length, \"Collection set now larger than maximum size.\");\n+  _regions[_regions_cur_length++] = hr->hrm_index();\n@@ -124,2 +131,3 @@\n-  assert(_collection_set_cur_length == 0, \"Collection set must be empty before starting a new collection set.\");\n-  assert(_inc_build_state == Inactive, \"Precondition\");\n+  assert(_regions_cur_length == 0, \"Collection set must be empty before starting a new collection set.\");\n+  assert(groups_cur_length() == 0, \"Collection set groups must be empty before starting a new collection set.\");\n+  assert(_optional_groups.length() == 0, \"Collection set optional gorups must be empty before starting a new collection set.\");\n@@ -127,1 +135,1 @@\n-  update_incremental_marker();\n+  continue_incremental_building();\n@@ -130,3 +138,11 @@\n-void G1CollectionSet::finalize_incremental_building() {\n-  assert(_inc_build_state == Active, \"Precondition\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");\n+void G1CollectionSet::continue_incremental_building() {\n+  assert(_inc_build_state == CSetBuildType::Inactive, \"Precondition\");\n+\n+  _regions_inc_part_start = _regions_cur_length;\n+  _groups_inc_part_start = groups_cur_length();\n+\n+  DEBUG_ONLY(_inc_build_state = CSetBuildType::Active;)\n+}\n+\n+void G1CollectionSet::stop_incremental_building() {\n+  DEBUG_ONLY(_inc_build_state = CSetBuildType::Inactive;)\n@@ -137,2 +153,2 @@\n-  _collection_set_cur_length = 0;\n-  _collection_set_groups.clear();\n+  _regions_cur_length = 0;\n+  _groups.clear();\n@@ -142,1 +158,1 @@\n-  size_t len = _collection_set_cur_length;\n+  size_t len = _regions_cur_length;\n@@ -146,1 +162,1 @@\n-    G1HeapRegion* r = _g1h->region_at(_collection_set_regions[i]);\n+    G1HeapRegion* r = _g1h->region_at(_regions[i]);\n@@ -173,1 +189,1 @@\n-  iterate_part_from(cl, hr_claimer, _inc_part_start, increment_length(), worker_id);\n+  iterate_part_from(cl, hr_claimer, _regions_inc_part_start, regions_cur_length(), worker_id);\n@@ -183,1 +199,1 @@\n-                                  &_collection_set_regions[offset],\n+                                  &_regions[offset],\n@@ -190,1 +206,1 @@\n-  assert(_inc_build_state == Active, \"Precondition\");\n+  assert(_inc_build_state == CSetBuildType::Active, \"Precondition\");\n@@ -196,3 +212,3 @@\n-  assert(_collection_set_cur_length < (UINT_MAX - 1),\n-         \"Collection set is too large with %u entries\", _collection_set_cur_length);\n-  hr->set_young_index_in_cset(_collection_set_cur_length + 1);\n+  assert(_regions_cur_length < (UINT_MAX - 1),\n+         \"Collection set is too large with %u entries\", _regions_cur_length);\n+  hr->set_young_index_in_cset(_regions_cur_length + 1);\n@@ -200,2 +216,2 @@\n-  assert(_collection_set_cur_length < _collection_set_max_length, \"Collection set larger than maximum allowed.\");\n-  _collection_set_regions[_collection_set_cur_length] = hr->hrm_index();\n+  assert(_regions_cur_length < _regions_max_length, \"Collection set larger than maximum allowed.\");\n+  _regions[_regions_cur_length] = hr->hrm_index();\n@@ -205,1 +221,1 @@\n-  _collection_set_cur_length++;\n+  _regions_cur_length++;\n@@ -287,1 +303,2 @@\n-  Ticks start_time = Ticks::now();\n+  assert(_inc_build_state == CSetBuildType::Active, \"Precondition\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");\n@@ -289,1 +306,1 @@\n-  finalize_incremental_building();\n+  Ticks start_time = Ticks::now();\n@@ -309,1 +326,4 @@\n-  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, _g1h->young_regions_cardset()->occupied());\n+  size_t num_young_cards = _g1h->young_regions_cardset()->occupied();\n+  _policy->record_card_rs_length(num_young_cards);\n+\n+  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, num_young_cards);\n@@ -329,4 +349,0 @@\n-static int compare_region_idx(const uint a, const uint b) {\n-  return static_cast<int>(a-b);\n-}\n-\n@@ -346,3 +362,0 @@\n-  _selected_groups_cur_length = 0;\n-  _selected_groups_inc_part_start = 0;\n-\n@@ -366,3 +379,0 @@\n-  _selected_groups_cur_length = collection_set_groups()->length();\n-  stop_incremental_building();\n-\n@@ -371,2 +381,0 @@\n-\n-  QuickSort::sort(_collection_set_regions, _collection_set_cur_length, compare_region_idx);\n@@ -597,1 +605,0 @@\n-  uint num_groups_selected = 0;\n@@ -613,1 +620,0 @@\n-    num_groups_selected++;\n@@ -619,1 +625,2 @@\n-  log_debug(gc, ergo, cset) (\"Completed with groups, selected %u\", num_regions_selected);\n+  log_debug(gc, ergo, cset)(\"Completed with groups, selected %u region in %u groups\",\n+                            num_regions_selected, selected.length());\n@@ -621,1 +628,1 @@\n-  if (num_groups_selected > 0) {\n+  if (selected.length() > 0) {\n@@ -628,1 +635,1 @@\n-uint G1CollectionSet::select_optional_collection_set_regions(double time_remaining_ms) {\n+uint G1CollectionSet::select_optional_groups(double time_remaining_ms) {\n@@ -663,1 +670,1 @@\n-  _collection_set_groups.append(gr);\n+  _groups.append(gr);\n@@ -673,0 +680,3 @@\n+  assert(_regions_inc_part_start == 0, \"must be\");\n+  assert(_groups_inc_part_start == 0, \"must be\");\n+\n@@ -675,0 +685,2 @@\n+\n+  stop_incremental_building();\n@@ -678,1 +690,1 @@\n-  update_incremental_marker();\n+  continue_incremental_building();\n@@ -680,1 +692,1 @@\n-  uint num_regions_selected = select_optional_collection_set_regions(remaining_pause_time);\n+  uint num_regions_selected = select_optional_groups(remaining_pause_time);\n@@ -682,1 +694,0 @@\n-  _selected_groups_cur_length = collection_set_groups()->length();\n@@ -744,1 +755,1 @@\n-  G1VerifyYoungCSetIndicesClosure cl(_collection_set_cur_length);\n+  G1VerifyYoungCSetIndicesClosure cl(_regions_cur_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":76,"deletions":65,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-\/\/ The set of regions that are evacuated during an evacuation pause.\n+\/\/ The set of regions and candidate groups that were evacuated during an\n+\/\/ evacuation pause.\n@@ -46,2 +47,2 @@\n-\/\/ At the end of a collection, before freeing the collection set, this set\n-\/\/ contains all regions that were evacuated during this collection:\n+\/\/ At the end of a collection, before freeing it, this set contains all regions\n+\/\/ and collection set groups that were evacuated during this collection:\n@@ -53,4 +54,3 @@\n-\/\/ This set is built incrementally at mutator time as regions are retired, and\n-\/\/ if this had been a mixed gc, some additional (during gc) incrementally added\n-\/\/ old regions from the collection set candidates built during the concurrent\n-\/\/ cycle.\n+\/\/ This set is initially built at mutator time as regions are retired. If the\n+\/\/ collection is a mixed gc, it contains some additional (during the pause)\n+\/\/ incrementally added old regions from the collection set candidates.\n@@ -132,0 +132,1 @@\n+\/\/ Candidate groups are kept in sync with the contents of the collection set regions.\n@@ -140,2 +141,3 @@\n-  \/\/ All entries in _collection_set_regions below _collection_set_cur_length are\n-  \/\/ assumed to be part of the collection set.\n+  \/\/\n+  \/\/ All regions in _regions below _regions_cur_length are assumed to be part of the\n+  \/\/ collection set.\n@@ -143,5 +145,8 @@\n-  \/\/ concurrent readers. This means we are good with using storestore and loadload\n-  \/\/ barriers on the writer and reader respectively only.\n-  uint* _collection_set_regions;\n-  volatile uint _collection_set_cur_length;\n-  uint _collection_set_max_length;\n+  \/\/ concurrent readers. This means synchronization using storestore and loadload\n+  \/\/ barriers on the writer and reader respectively only are sufficient.\n+  \/\/\n+  \/\/ This corresponds to the regions referenced by the candidate groups further below.\n+  uint* _regions;\n+  uint _regions_max_length;\n+\n+  volatile uint _regions_cur_length;\n@@ -150,1 +155,1 @@\n-  G1CSetCandidateGroupList _collection_set_groups;\n+  G1CSetCandidateGroupList _groups;\n@@ -152,4 +157,1 @@\n-  \/\/ Groups are added to the collection set in increments when performing optional evacuations.\n-  \/\/ We use the value below to track these increments.\n-  uint _selected_groups_cur_length;\n-  uint _selected_groups_inc_part_start;\n+  uint groups_cur_length() const;\n@@ -162,1 +164,2 @@\n-  \/\/ will be collected only if there is enough time. We call these optional (old) regions.\n+  \/\/ will be collected only if there is enough time. We call these optional (old)\n+  \/\/ groups. Regions are reachable via this list as well.\n@@ -165,1 +168,2 @@\n-  enum CSetBuildType {\n+#ifdef ASSERT\n+  enum class CSetBuildType {\n@@ -171,1 +175,5 @@\n-  size_t _inc_part_start;\n+#endif\n+  \/\/ Index into the _regions indicating the start of the current collection set increment.\n+  size_t _regions_inc_part_start;\n+  \/\/ Index into the _groups indicating the start of the current collection set increment.\n+  uint _groups_inc_part_start;\n@@ -178,1 +186,0 @@\n-  \/\/ Update the incremental collection set information when adding a region.\n@@ -181,1 +188,1 @@\n-  \/\/ Add the given old region to the head of the current collection set.\n+  \/\/ Add the given old region to the current collection set.\n@@ -194,4 +201,4 @@\n-  \/\/ Select regions for evacuation from the optional candidates given the remaining time\n-  \/\/ and return the number  of actually selected regions.\n-  uint select_optional_collection_set_regions(double time_remaining_ms);\n-  double select_candidates_from_optional_groups(double time_remaining_ms, uint& num_regions_selected);\n+  \/\/ Select groups for evacuation from the optional candidates given the remaining time\n+  \/\/ and return the number of actually selected regions.\n+  uint select_optional_groups(double time_remaining_ms);\n+  double select_candidates_from_optional_groups(double time_remaining_ms, uint& num_groups_selected);\n@@ -201,1 +208,1 @@\n-  \/\/ will take.\n+  \/\/ will take. Returns the time remaining from the given target pause time.\n@@ -203,3 +210,0 @@\n-  \/\/ Perform any final calculations on the incremental collection set fields before we\n-  \/\/ can use them.\n-  void finalize_incremental_building();\n@@ -226,0 +230,1 @@\n+  \/\/ Drop all collection set candidates (only the candidates).\n@@ -231,4 +236,1 @@\n-  G1CSetCandidateGroupList* collection_set_groups() { return &_collection_set_groups; }\n-  const G1CSetCandidateGroupList* collection_set_groups() const { return &_collection_set_groups; }\n-\n-  void prepare_groups_for_scan();\n+  void prepare_for_scan();\n@@ -239,2 +241,3 @@\n-  uint region_length() const       { return young_region_length() +\n-                                            initial_old_region_length(); }\n+  \/\/ Total length of the initial collection set in regions.\n+  uint initial_region_length() const { return young_region_length() +\n+                                              initial_old_region_length(); }\n@@ -244,1 +247,1 @@\n-  uint eden_region_length() const     { return _eden_region_length; }\n+  uint eden_region_length() const { return _eden_region_length; }\n@@ -246,1 +249,1 @@\n-  uint initial_old_region_length() const      { return _initial_old_region_length; }\n+  uint initial_old_region_length() const { return _initial_old_region_length; }\n@@ -261,6 +264,2 @@\n-  \/\/ Start a new collection set increment.\n-  void update_incremental_marker() {\n-    _inc_build_state = Active;\n-    _inc_part_start = _collection_set_cur_length;\n-    _selected_groups_inc_part_start = _selected_groups_cur_length;\n-  }\n+  \/\/ Start a new collection set increment, continuing the incremental building.\n+  void continue_incremental_building();\n@@ -268,1 +267,1 @@\n-  void stop_incremental_building() { _inc_build_state = Inactive; }\n+  void stop_incremental_building();\n@@ -275,1 +274,1 @@\n-  size_t increment_length() const { return _collection_set_cur_length - _inc_part_start; }\n+  size_t regions_cur_length() const { return _regions_cur_length - _regions_inc_part_start; }\n@@ -277,1 +276,1 @@\n-  size_t cur_length() const { return _collection_set_cur_length; }\n+  size_t cur_length() const { return _regions_cur_length; }\n@@ -279,1 +278,1 @@\n-  uint collection_groups_increment_length() const { return _selected_groups_cur_length - _selected_groups_inc_part_start; }\n+  uint groups_increment_length() const;\n@@ -282,1 +281,1 @@\n-  \/\/ the given G1HeapRegionClosure on all of them.\n+  \/\/ the given G1HeapRegionClosure on all of the regions.\n@@ -290,1 +289,1 @@\n-  \/\/ Finalize the initial collection set consisting of all young regions potentially a\n+  \/\/ Finalize the initial collection set consisting of all young regions and potentially a\n@@ -294,0 +293,1 @@\n+  \/\/ Returns whether there still were some optional regions.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-  uint length = collection_groups_increment_length();\n-  uint offset =  _selected_groups_inc_part_start;\n+  uint length = groups_increment_length();\n+  uint offset =  _groups_inc_part_start;\n@@ -44,1 +44,1 @@\n-    G1HeapRegionRemSet::iterate_for_merge(collection_set_groups()->at(offset + cur_pos)->card_set(), cl);\n+    G1HeapRegionRemSet::iterate_for_merge(_groups.at(offset + cur_pos)->card_set(), cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,6 +47,1 @@\n-  add(c);\n-}\n-\n-void G1CSetCandidateGroup::add(G1CollectionSetCandidateInfo& hr_info) {\n-  G1HeapRegion* hr = hr_info._r;\n-  _candidates.append(hr_info);\n+  _candidates.append(c);\n@@ -66,1 +61,2 @@\n-size_t G1CSetCandidateGroup::liveness() const {\n+double G1CSetCandidateGroup::liveness_percent() const {\n+  assert(length() > 0, \"must be\");\n@@ -68,2 +64,1 @@\n-\n-  return (size_t) ceil(((capacity - _reclaimable_bytes) * 100.0) \/ capacity);\n+  return ((capacity - _reclaimable_bytes) * 100.0) \/ capacity;\n@@ -137,25 +132,0 @@\n-int G1CollectionSetCandidateInfo::compare_region_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n-  \/\/ Make sure that null entries are moved to the end.\n-  if (ci1->_r == nullptr) {\n-    if (ci2->_r == nullptr) {\n-      return 0;\n-    } else {\n-      return 1;\n-    }\n-  } else if (ci2->_r == nullptr) {\n-    return -1;\n-  }\n-\n-  G1Policy* p = G1CollectedHeap::heap()->policy();\n-  double gc_efficiency1 = p->predict_gc_efficiency(ci1->_r);\n-  double gc_efficiency2 = p->predict_gc_efficiency(ci2->_r);\n-\n-  if (gc_efficiency1 > gc_efficiency2) {\n-    return -1;\n-  } else if (gc_efficiency1 < gc_efficiency2) {\n-    return 1;\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -283,3 +253,3 @@\n-void G1CollectionSetCandidates::set_candidates_from_marking(G1CollectionSetCandidateInfo* candidate_infos,\n-                                                            uint num_infos) {\n-  if (num_infos == 0) {\n+void G1CollectionSetCandidates::set_candidates_from_marking(G1HeapRegion** candidates,\n+                                                            uint num_candidates) {\n+  if (num_candidates == 0) {\n@@ -298,1 +268,1 @@\n-  uint group_limit = p->calc_min_old_cset_length(num_infos);\n+  uint group_limit = p->calc_min_old_cset_length(num_candidates);\n@@ -307,2 +277,2 @@\n-  for (uint i = 0; i < num_infos; i++) {\n-    G1HeapRegion* r = candidate_infos[i]._r;\n+  for (uint i = 0; i < num_candidates; i++) {\n+    G1HeapRegion* r = candidates[i];\n@@ -322,1 +292,1 @@\n-    current->add(candidate_infos[i]);\n+    current->add(r);\n@@ -328,1 +298,1 @@\n-  assert(_from_marking_groups.num_regions() == num_infos, \"Must be!\");\n+  assert(_from_marking_groups.num_regions() == num_candidates, \"Must be!\");\n@@ -330,2 +300,2 @@\n-  log_debug(gc, ergo, cset) (\"Finished creating %u collection groups from %u regions\", _from_marking_groups.length(), num_infos);\n-  _last_marking_candidates_length = num_infos;\n+  log_debug(gc, ergo, cset) (\"Finished creating %u collection groups from %u regions\", _from_marking_groups.length(), num_candidates);\n+  _last_marking_candidates_length = num_candidates;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":14,"deletions":44,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-\n-  static int compare_region_gc_efficiency(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n@@ -94,1 +92,0 @@\n-  void add(G1CollectionSetCandidateInfo& hr_info);\n@@ -105,1 +102,1 @@\n-  size_t liveness() const;\n+  double liveness_percent() const;\n@@ -238,1 +235,1 @@\n-  \/\/ Merge collection set candidates from marking into the current marking list\n+  \/\/ Merge collection set candidates from marking into the current marking candidates\n@@ -240,2 +237,2 @@\n-  void set_candidates_from_marking(G1CollectionSetCandidateInfo* candidate_infos,\n-                                   uint num_infos);\n+  void set_candidates_from_marking(G1HeapRegion** candidates,\n+                                   uint num_candidates);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,2 +34,3 @@\n-\/\/ whether they should be a collection set candidate, calculate their efficiency,\n-\/\/ sort and put them into the candidates.\n+\/\/ whether they should be a collection set candidate. Calculate their efficiency,\n+\/\/ sort, and put them into the collection set candidates.\n+\/\/\n@@ -40,3 +41,0 @@\n-\n-  using CandidateInfo = G1CollectionSetCandidateInfo;\n-\n@@ -50,1 +48,0 @@\n-\n@@ -54,1 +51,1 @@\n-    CandidateInfo* _data;\n+    G1HeapRegion** _data;\n@@ -58,0 +55,27 @@\n+    static int compare_region_gc_efficiency(G1HeapRegion** rr1, G1HeapRegion** rr2) {\n+      G1HeapRegion* r1 = *rr1;\n+      G1HeapRegion* r2 = *rr2;\n+      \/\/ Make sure that null entries are moved to the end.\n+      if (r1 == nullptr) {\n+        if (r2 == nullptr) {\n+          return 0;\n+        } else {\n+          return 1;\n+        }\n+      } else if (r2 == nullptr) {\n+        return -1;\n+      }\n+\n+      G1Policy* p = G1CollectedHeap::heap()->policy();\n+      double gc_efficiency1 = p->predict_gc_efficiency(r1);\n+      double gc_efficiency2 = p->predict_gc_efficiency(r2);\n+\n+      if (gc_efficiency1 > gc_efficiency2) {\n+        return -1;\n+      } else if (gc_efficiency1 < gc_efficiency2) {\n+        return 1;\n+      } else {\n+        return 0;\n+      }\n+    }\n+\n@@ -71,1 +95,1 @@\n-      _data(NEW_C_HEAP_ARRAY(CandidateInfo, _max_size, mtGC)),\n+      _data(NEW_C_HEAP_ARRAY(G1HeapRegion*, _max_size, mtGC)),\n@@ -74,1 +98,1 @@\n-        _data[i] = CandidateInfo();\n+        _data[i] = nullptr;\n@@ -79,1 +103,1 @@\n-      FREE_C_HEAP_ARRAY(CandidateInfo, _data);\n+      FREE_C_HEAP_ARRAY(G1HeapRegion*, _data);\n@@ -95,2 +119,2 @@\n-      assert(_data[idx]._r == nullptr, \"Value must not have been set.\");\n-      _data[idx] = CandidateInfo(hr);\n+      assert(_data[idx] == nullptr, \"Value must not have been set.\");\n+      _data[idx] = hr;\n@@ -104,1 +128,1 @@\n-        assert(_data[i]._r == nullptr, \"must be\");\n+        assert(_data[i] == nullptr, \"must be\");\n@@ -106,1 +130,1 @@\n-      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)G1CollectionSetCandidateInfo::compare_region_gc_efficiency);\n+      qsort(_data, _cur_claim_idx, sizeof(_data[0]), (_sort_Fn)compare_region_gc_efficiency);\n@@ -108,1 +132,1 @@\n-        assert(_data[i]._r == nullptr, \"must be\");\n+        assert(_data[i] == nullptr, \"must be\");\n@@ -112,1 +136,1 @@\n-    CandidateInfo* array() const { return _data; }\n+    G1HeapRegion** array() const { return _data; }\n@@ -196,1 +220,1 @@\n-  void prune(CandidateInfo* data) {\n+  void prune(G1HeapRegion** data) {\n@@ -214,1 +238,1 @@\n-      G1HeapRegion* r = data[num_candidates - num_pruned - 1]._r;\n+      G1HeapRegion* r = data[num_candidates - num_pruned - 1];\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":42,"deletions":18,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-public:\n@@ -46,0 +45,1 @@\n+public:\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1965,1 +1965,2 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at a safepoint\");\n+  assert(SafepointSynchronize::is_at_safepoint() || !is_init_completed(),\n+         \"should be at a safepoint or initializing\");\n@@ -2984,0 +2985,1 @@\n+#define G1PPRL_GID_LIVENESS_FORMAT    \"  %9.2f\"\n@@ -3055,1 +3057,1 @@\n-  if (r->rem_set()->is_added_to_cset_group()) {\n+  if (r->rem_set()->has_cset_group()) {\n@@ -3117,1 +3119,1 @@\n-                          G1PPRL_BYTE_FORMAT\n+                          G1PPRL_GID_LIVENESS_FORMAT\n@@ -3122,2 +3124,2 @@\n-                          group->gc_efficiency(),\n-                          group->liveness(),\n+                          group->length() > 0 ? group->gc_efficiency() : 0.0,\n+                          group->length() > 0 ? group->liveness_percent() : 0.0,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -227,2 +227,0 @@\n-\n-  G1CollectedHeap::finish_codecache_marking_cycle();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-  _young_index_in_cset(-1),\n+  _young_index_in_cset(InvalidCSetIndex),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -499,1 +499,1 @@\n-  uint  young_index_in_cset() const { return _young_index_in_cset; }\n+  uint young_index_in_cset() const { return _young_index_in_cset; }\n@@ -502,1 +502,1 @@\n-    assert(index != UINT_MAX, \"just checking\");\n+    assert(index != InvalidCSetIndex, \"just checking\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,1 +353,1 @@\n-    assert(oopDesc::is_oop(obj, true), \"Not an oop at \" PTR_FORMAT, p2i(cur));\n+    assert(oopDesc::is_oop(obj), \"Not an oop at \" PTR_FORMAT, p2i(cur));\n@@ -421,1 +421,1 @@\n-    assert(oopDesc::is_oop(obj, true), \"Not an oop at \" PTR_FORMAT, p2i(cur));\n+    assert(oopDesc::is_oop(obj), \"Not an oop at \" PTR_FORMAT, p2i(cur));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  assert(!is_added_to_cset_group(), \"Still assigned to a CSet group\");\n+  assert(!has_cset_group(), \"Still assigned to a CSet group\");\n@@ -79,1 +79,1 @@\n-  if (is_added_to_cset_group()) {\n+  if (has_cset_group()) {\n@@ -93,1 +93,1 @@\n-  if (is_added_to_cset_group()) {\n+  if (has_cset_group()) {\n@@ -99,1 +99,1 @@\n-  assert(is_added_to_cset_group(), \"pre-condition\");\n+  assert(has_cset_group(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    assert(is_added_to_cset_group(), \"pre-condition\");\n+    assert(has_cset_group(), \"pre-condition\");\n@@ -65,1 +65,1 @@\n-    assert(is_added_to_cset_group(), \"pre-condition\");\n+    assert(has_cset_group(), \"pre-condition\");\n@@ -74,1 +74,1 @@\n-    return !is_added_to_cset_group() || card_set()->is_empty();\n+    return !has_cset_group() || card_set()->is_empty();\n@@ -86,1 +86,1 @@\n-  bool is_added_to_cset_group() const {\n+  bool has_cset_group() const {\n@@ -99,1 +99,1 @@\n-    assert(is_added_to_cset_group(), \"pre-condition\");\n+    assert(has_cset_group(), \"pre-condition\");\n@@ -121,1 +121,1 @@\n-    assert(is_added_to_cset_group(), \"pre-condition\");\n+    assert(has_cset_group(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-  assert(is_added_to_cset_group(), \"pre-condition\");\n+  assert(has_cset_group(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -220,2 +220,2 @@\n-  const double long_term_gc_cpu_usage = _analytics->long_term_pause_time_ratio();\n-  const double short_term_gc_cpu_usage = _analytics->short_term_pause_time_ratio();\n+  const double long_term_gc_cpu_usage = _analytics->long_term_gc_time_ratio();\n+  const double short_term_gc_cpu_usage = _analytics->short_term_gc_time_ratio();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,0 +238,2 @@\n+  bool is_in_full_gc() const { return G1CollectedHeap::heap()->collector_state()->in_full_gc(); }\n+\n@@ -249,1 +251,1 @@\n-    guarantee(!r->is_young() || r->rem_set()->is_complete(), \"Remembered set for Young region %u must be complete, is %s\", r->hrm_index(), r->rem_set()->get_state_str());\n+    guarantee(is_in_full_gc() || !r->is_young() || r->rem_set()->is_complete(), \"Remembered set for Young region %u must be complete outside full gc, is %s\", r->hrm_index(), r->rem_set()->get_state_str());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-  Prefetch::write(obj->mark_addr(), 0);\n-  Prefetch::read(obj->mark_addr(), (HeapWordSize*2));\n+  Prefetch::write(obj->base_addr(), oopDesc::mark_offset_in_bytes());\n+  Prefetch::read(obj->base_addr(), oopDesc::mark_offset_in_bytes() + (HeapWordSize*2));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,4 +100,0 @@\n-\n-  \/\/ We immediately start allocating regions placing them in the collection set.\n-  \/\/ Initialize the collection set info.\n-  _collection_set->start_incremental_building();\n@@ -511,1 +507,0 @@\n-  const GrowableArray<G1HeapRegion*>* survivor_regions = _g1h->survivor()->regions();\n@@ -513,4 +508,2 @@\n-  for (GrowableArrayIterator<G1HeapRegion*> it = survivor_regions->begin();\n-       it != survivor_regions->end();\n-       ++it) {\n-    survivor_regions_evac_time += predict_region_copy_time_ms(*it, _g1h->collector_state()->in_young_only_phase());\n+  for (G1HeapRegion* r : _g1h->survivor()->regions()) {\n+    survivor_regions_evac_time += predict_region_copy_time_ms(r, _g1h->collector_state()->in_young_only_phase());\n@@ -674,0 +667,6 @@\n+\n+  double prev_gc_cpu_pause_end_ms = _analytics->gc_cpu_time_at_pause_end_ms();\n+  double cur_gc_cpu_time_ms = _analytics->gc_cpu_time_ms();\n+\n+  double concurrent_gc_cpu_time_ms = cur_gc_cpu_time_ms - prev_gc_cpu_pause_end_ms;\n+  _analytics->set_concurrent_gc_cpu_time_ms(concurrent_gc_cpu_time_ms);\n@@ -1356,2 +1355,1 @@\n-  _analytics->compute_pause_time_ratios(end_time_sec, pause_time_ms);\n-  _analytics->update_recent_gc_times(end_time_sec, pause_time_ms);\n+  _analytics->update_gc_time_ratios(end_time_sec, pause_time_ms);\n@@ -1380,0 +1378,3 @@\n+\n+  double elapsed_gc_cpu_time = _analytics->gc_cpu_time_ms();\n+  _analytics->set_gc_cpu_time_at_pause_end_ms(elapsed_gc_cpu_time);\n@@ -1464,5 +1465,2 @@\n-  for (GrowableArrayIterator<G1HeapRegion*> it = survivors->regions()->begin();\n-       it != survivors->regions()->end();\n-       ++it) {\n-    G1HeapRegion* curr = *it;\n-    set_region_survivor(curr);\n+  for (G1HeapRegion* r : survivors->regions()) {\n+    set_region_survivor(r);\n@@ -1473,1 +1471,1 @@\n-    _collection_set->add_survivor_regions(curr);\n+    _collection_set->add_survivor_regions(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -132,2 +132,2 @@\n-  void record_card_rs_length(size_t card_rs_length) {\n-    _card_rs_length = card_rs_length;\n+  void record_card_rs_length(size_t num_cards) {\n+    _card_rs_length = num_cards;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1429,1 +1429,1 @@\n-  size_t const increment_length = g1h->collection_set()->increment_length();\n+  size_t const increment_length = g1h->collection_set()->regions_cur_length();\n@@ -1443,10 +1443,0 @@\n-  {\n-    size_t young_rs_length = g1h->young_regions_cardset()->occupied();\n-    \/\/ We only use young_rs_length statistics to estimate young regions length.\n-    g1h->policy()->record_card_rs_length(young_rs_length);\n-\n-    \/\/ Clear current young only collection set. Survivor regions will be added\n-    \/\/ to the set during evacuation.\n-    g1h->young_regions_cset_group()->clear();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-    if (hrrs->is_added_to_cset_group() && hrrs->cset_group()->length() == 1) {\n+    if (hrrs->has_cset_group() && hrrs->cset_group()->length() == 1) {\n@@ -271,4 +271,1 @@\n-  void do_cset_groups() {\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-    G1CSetCandidateGroup* young_only_cset_group = g1h->young_regions_cset_group();\n-\n+  void accumulate_stats_for_group(G1CSetCandidateGroup* group, G1PerRegionTypeRemSetCounters* gen_counter) {\n@@ -276,12 +273,14 @@\n-    \/\/ during region iteration.\n-    if (young_only_cset_group->length() > 1) {\n-      G1CardSet* young_only_card_set = young_only_cset_group->card_set();\n-      size_t rs_mem_sz = young_only_card_set->mem_size();\n-      size_t rs_unused_mem_sz = young_only_card_set->unused_mem_size();\n-      size_t occupied_cards = young_only_card_set->occupied();\n-\n-      _max_group_cardset_mem_sz = rs_mem_sz;\n-      _max_cardset_mem_sz_group = young_only_cset_group;\n-\n-      \/\/ Only update cardset details\n-      _young.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n+    \/\/ during region iteration. Skip these.\n+    if (group->length() > 1) {\n+      G1CardSet* card_set = group->card_set();\n+\n+      size_t rs_mem_sz = card_set->mem_size();\n+      size_t rs_unused_mem_sz = card_set->unused_mem_size();\n+      size_t occupied_cards = card_set->occupied();\n+\n+      if (rs_mem_sz > _max_group_cardset_mem_sz) {\n+        _max_group_cardset_mem_sz = rs_mem_sz;\n+        _max_cardset_mem_sz_group = group;\n+      }\n+\n+      gen_counter->add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n@@ -290,0 +289,1 @@\n+  }\n@@ -291,0 +291,2 @@\n+  void do_cset_groups() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n@@ -292,12 +294,1 @@\n-    G1PerRegionTypeRemSetCounters* current = &_old;\n-    for (G1CSetCandidateGroup* group : g1h->policy()->candidates()->from_marking_groups()) {\n-      if (group->length() > 1) {\n-        G1CardSet* group_card_set = group->card_set();\n-        size_t rs_mem_sz = group_card_set->mem_size();\n-        size_t rs_unused_mem_sz = group_card_set->unused_mem_size();\n-        size_t occupied_cards = group_card_set->occupied();\n-\n-        if (rs_mem_sz > _max_group_cardset_mem_sz) {\n-          _max_group_cardset_mem_sz = rs_mem_sz;\n-          _max_cardset_mem_sz_group = group;\n-        }\n+    accumulate_stats_for_group(g1h->young_regions_cset_group(), &_young);\n@@ -305,4 +296,8 @@\n-        \/\/ Only update cardset details\n-        _old.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n-        _all.add(rs_unused_mem_sz, rs_mem_sz, occupied_cards, 0, 0, false);\n-      }\n+    G1CollectionSetCandidates* candidates = g1h->policy()->candidates();\n+    for (G1CSetCandidateGroup* group : candidates->from_marking_groups()) {\n+      accumulate_stats_for_group(group, &_old);\n+    }\n+    \/\/ Skip gathering statistics for retained regions. Just verify that they have\n+    \/\/ the expected amount of regions.\n+    for (G1CSetCandidateGroup* group : candidates->retained_groups()) {\n+      assert(group->length() == 1, \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":28,"deletions":33,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-    if (r->rem_set()->is_added_to_cset_group() &&\n+    if (r->rem_set()->has_cset_group() &&\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  assert(oopDesc::is_oop(cast_to_oop(entry), true \/* ignore mark word *\/),\n+  assert(oopDesc::is_oop(cast_to_oop(entry)),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-  _regions(new (mtGC) GrowableArray<G1HeapRegion*>(8, mtGC)),\n+  _regions(8, mtGC),\n@@ -37,1 +37,1 @@\n-  _regions->append(hr);\n+  _regions.append(hr);\n@@ -42,1 +42,1 @@\n-  return (uint)_regions->length();\n+  return (uint)_regions.length();\n@@ -50,5 +50,2 @@\n-  for (GrowableArrayIterator<G1HeapRegion*> it = _regions->begin();\n-       it != _regions->end();\n-       ++it) {\n-    G1HeapRegion* hr = *it;\n-    hr->set_eden_pre_gc();\n+  for (G1HeapRegion* r : _regions) {\n+    r->set_eden_pre_gc();\n@@ -60,1 +57,1 @@\n-  _regions->clear();\n+  _regions.clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -35,0 +36,1 @@\n+\/\/ Set of current survivor regions.\n@@ -36,4 +38,3 @@\n-private:\n-  GrowableArray<G1HeapRegion*>* _regions;\n-  volatile size_t             _used_bytes;\n-  G1RegionsOnNodes            _regions_on_node;\n+  GrowableArray<G1HeapRegion*> _regions;\n+  volatile size_t _used_bytes;\n+  G1RegionsOnNodes _regions_on_node;\n@@ -53,1 +54,1 @@\n-  const GrowableArray<G1HeapRegion*>* regions() const {\n+  const GrowableArray<G1HeapRegion*>& regions() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -84,6 +84,6 @@\n-      snprintf(evacuation_failed_string,\n-               ARRAY_SIZE(evacuation_failed_string),\n-               \" (Evacuation Failure: %s%s%s)\",\n-               _collector->evacuation_alloc_failed() ? \"Allocation\" : \"\",\n-               _collector->evacuation_alloc_failed() && _collector->evacuation_pinned() ? \" \/ \" : \"\",\n-               _collector->evacuation_pinned() ? \"Pinned\" : \"\");\n+      os::snprintf_checked(evacuation_failed_string,\n+                           ARRAY_SIZE(evacuation_failed_string),\n+                           \" (Evacuation Failure: %s%s%s)\",\n+                           _collector->evacuation_alloc_failed() ? \"Allocation\" : \"\",\n+                           _collector->evacuation_alloc_failed() && _collector->evacuation_pinned() ? \" \/ \" : \"\",\n+                           _collector->evacuation_pinned() ? \"Pinned\" : \"\");\n@@ -91,6 +91,6 @@\n-    snprintf(_young_gc_name_data,\n-             MaxYoungGCNameLength,\n-             \"Pause Young (%s) (%s)%s\",\n-             G1GCPauseTypeHelper::to_string(_pause_type),\n-             GCCause::to_string(_pause_cause),\n-             evacuation_failed_string);\n+    os::snprintf_checked(_young_gc_name_data,\n+                         MaxYoungGCNameLength,\n+                         \"Pause Young (%s) (%s)%s\",\n+                         G1GCPauseTypeHelper::to_string(_pause_type),\n+                         GCCause::to_string(_pause_cause),\n+                         evacuation_failed_string);\n@@ -274,1 +274,1 @@\n-  evacuation_info->set_collection_set_regions(collection_set()->region_length() +\n+  evacuation_info->set_collection_set_regions(collection_set()->initial_region_length() +\n@@ -522,1 +522,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -890,1 +890,1 @@\n-  double worker_cost() const override { return G1CollectedHeap::heap()->collection_set()->region_length(); }\n+  double worker_cost() const override { return G1CollectedHeap::heap()->collection_set()->initial_region_length(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -105,2 +106,1 @@\n-                                          max_gc_pause_sec,\n-                                          GCTimeRatio);\n+                                          max_gc_pause_sec);\n@@ -269,2 +269,1 @@\n-HeapWord* ParallelScavengeHeap::mem_allocate(size_t size,\n-                                             bool* gc_overhead_limit_was_exceeded) {\n+HeapWord* ParallelScavengeHeap::mem_allocate(size_t size) {\n@@ -276,1 +275,1 @@\n-  return mem_allocate_work(size, is_tlab, gc_overhead_limit_was_exceeded);\n+  return mem_allocate_work(size, is_tlab);\n@@ -279,4 +278,3 @@\n-HeapWord* ParallelScavengeHeap::mem_allocate_work(size_t size,\n-                                                  bool is_tlab,\n-                                                  bool* gc_overhead_limit_was_exceeded) {\n-  {\n+HeapWord* ParallelScavengeHeap::mem_allocate_work(size_t size, bool is_tlab) {\n+  for (uint loop_count = 0; \/* empty *\/; ++loop_count) {\n+    \/\/ Try young-gen first.\n@@ -287,1 +285,0 @@\n-  }\n@@ -289,2 +286,9 @@\n-  uint loop_count = 0;\n-  uint gc_count = 0;\n+    \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n+    if (!is_tlab) {\n+      if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n+        result = old_gen()->cas_allocate_noexpand(size);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+    }\n@@ -292,1 +296,0 @@\n-  while (true) {\n@@ -304,0 +307,1 @@\n+    uint gc_count;\n@@ -307,15 +311,0 @@\n-\n-      HeapWord* result = young_gen()->allocate(size);\n-      if (result != nullptr) {\n-        return result;\n-      }\n-\n-      \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n-      if (!is_tlab) {\n-        if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n-          result = old_gen()->cas_allocate_noexpand(size);\n-          if (result != nullptr) {\n-            return result;\n-          }\n-        }\n-      }\n@@ -328,3 +317,0 @@\n-      \/\/ Did the VM operation execute? If so, return the result directly.\n-      \/\/ This prevents us from looping until time out on requests that can\n-      \/\/ not be satisfied.\n@@ -333,1 +319,0 @@\n-\n@@ -336,4 +321,0 @@\n-      \/\/ Was the gc-overhead reached inside the safepoint? If so, this mutator should return null as well for global consistency.\n-      if (_gc_overhead_counter >= GCOverheadLimitThreshold) {\n-        return nullptr;\n-      }\n@@ -342,1 +323,6 @@\n-    loop_count++;\n+    \/\/ Was the gc-overhead reached inside the safepoint? If so, this mutator\n+    \/\/ should return null as well for global consistency.\n+    if (_gc_overhead_counter >= GCOverheadLimitThreshold) {\n+      return nullptr;\n+    }\n+\n@@ -345,2 +331,1 @@\n-      log_warning(gc)(\"ParallelScavengeHeap::mem_allocate retries %d times\", loop_count);\n-      log_warning(gc)(\"\\tsize=%zu\", size);\n+      log_warning(gc)(\"ParallelScavengeHeap::mem_allocate retries %d times, size=%zu\", loop_count, size);\n@@ -457,1 +442,0 @@\n-  bool dummy;\n@@ -459,2 +443,1 @@\n-                                       true \/* is_tlab *\/,\n-                                       &dummy);\n+                                       true \/* is_tlab *\/);\n@@ -864,0 +847,2 @@\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  bs_nm->disarm(nm);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":27,"deletions":42,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -105,3 +105,1 @@\n-  HeapWord* mem_allocate_work(size_t size,\n-                              bool is_tlab,\n-                              bool* gc_overhead_limit_was_exceeded);\n+  HeapWord* mem_allocate_work(size_t size, bool is_tlab);\n@@ -195,6 +193,2 @@\n-  \/\/ Memory allocation.   \"gc_time_limit_was_exceeded\" will\n-  \/\/ be set to true if the adaptive size policy determine that\n-  \/\/ an excessive amount of time is being spent doing collections\n-  \/\/ and caused a null to be returned.  If a null is not returned,\n-  \/\/ \"gc_time_limit_was_exceeded\" has an undefined meaning.\n-  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+  \/\/ Memory allocation.\n+  HeapWord* mem_allocate(size_t size) override;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,4 +39,2 @@\n-                                           double gc_pause_goal_sec,\n-                                           uint gc_cost_ratio) :\n-     AdaptiveSizePolicy(gc_pause_goal_sec,\n-                        gc_cost_ratio),\n+                                           double gc_pause_goal_sec) :\n+     AdaptiveSizePolicy(gc_pause_goal_sec),\n@@ -76,0 +74,10 @@\n+\/\/ The throughput goal is implemented as\n+\/\/      _throughput_goal = 1 - (1 \/ (1 + gc_cost_ratio))\n+\/\/ gc_cost_ratio is the ratio\n+\/\/      application cost \/ gc cost\n+\/\/ For example a gc_cost_ratio of 4 translates into a\n+\/\/ throughput goal of .80\n+static double calculate_throughput_goal(double gc_cost_ratio) {\n+  return 1.0 - (1.0 \/ (1.0 + gc_cost_ratio));\n+}\n+\n@@ -81,1 +89,5 @@\n-  if (mutator_time_percent() < _throughput_goal) {\n+  \/\/ Get a local copy and use it inside gc-pause in case the global var gets updated externally.\n+  const uint local_GCTimeRatio = Atomic::load(&GCTimeRatio);\n+  const double throughput_goal = calculate_throughput_goal(local_GCTimeRatio);\n+\n+  if (mutator_time_percent() < throughput_goal) {\n@@ -83,1 +95,1 @@\n-    const double expected_gc_distance = _trimmed_minor_gc_time_seconds.last() * GCTimeRatio;\n+    const double expected_gc_distance = _trimmed_minor_gc_time_seconds.last() * local_GCTimeRatio;\n@@ -93,1 +105,1 @@\n-      mutator_time_percent(), _throughput_goal, (new_eden - cur_eden)\/K);\n+      mutator_time_percent(), throughput_goal, (new_eden - cur_eden)\/K);\n@@ -121,1 +133,1 @@\n-    const double gc_distance_target = MAX3(minor_gc_time_conservative_estimate() * GCTimeRatio,\n+    const double gc_distance_target = MAX3(minor_gc_time_conservative_estimate() * local_GCTimeRatio,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-                       double gc_pause_goal_sec,\n-                       uint gc_time_ratio);\n+                       double gc_pause_goal_sec);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  \/\/ Invoked by mutators and GC-workers.\n+  \/\/ Used by GC-workers during GC or for CDS at startup.\n@@ -123,1 +123,0 @@\n-    assert_locked_or_safepoint(Heap_lock);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -972,0 +972,1 @@\n+  assert(ref_processor() != nullptr, \"Sanity\");\n@@ -976,9 +977,0 @@\n-  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs);\n-}\n-\n-\/\/ This method contains no policy. You should probably\n-\/\/ be calling invoke() instead.\n-bool PSParallelCompact::invoke_no_policy(bool clear_all_soft_refs) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-  assert(ref_processor() != nullptr, \"Sanity\");\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -765,1 +765,0 @@\n-  static bool invoke_no_policy(bool clear_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -116,0 +116,7 @@\n+  inline HeapWord* allocate_in_young_gen(Klass* klass,\n+                                         size_t obj_size,\n+                                         uint age);\n+  inline HeapWord* allocate_in_old_gen(Klass* klass,\n+                                       size_t obj_size,\n+                                       uint age);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    Prefetch::write(obj->mark_addr(), 0);\n+    Prefetch::write(obj->base_addr(), oopDesc::mark_offset_in_bytes());\n@@ -156,0 +156,74 @@\n+inline HeapWord* PSPromotionManager::allocate_in_young_gen(Klass* klass,\n+                                                           size_t obj_size,\n+                                                           uint age) {\n+  HeapWord* result = _young_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_young_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (YoungPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = young_space()->cas_allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _young_lab.flush();\n+\n+    HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n+    if (lab_base != nullptr) {\n+      _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n+      \/\/ Try the young lab allocation again.\n+      result = _young_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, &_young_lab);\n+    } else {\n+      _young_gen_is_full = true;\n+    }\n+  }\n+  if (result == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n+    _young_gen_has_alloc_failure = true;\n+  }\n+  return result;\n+}\n+\n+inline HeapWord* PSPromotionManager::allocate_in_old_gen(Klass* klass,\n+                                                         size_t obj_size,\n+                                                         uint age) {\n+#ifndef PRODUCT\n+  if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    return nullptr;\n+  }\n+#endif  \/\/ #ifndef PRODUCT\n+\n+  HeapWord* result = _old_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_old_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (OldPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = old_gen()->allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _old_lab.flush();\n+\n+    HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n+    if (lab_base != nullptr) {\n+      _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n+      \/\/ Try the old lab allocation again.\n+      result = _old_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, &_old_lab);\n+    }\n+  }\n+  if (result == nullptr) {\n+    _old_gen_is_full = true;\n+  }\n+  return result;\n+}\n+\n@@ -189,25 +263,1 @@\n-      new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-      if (new_obj == nullptr && !_young_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (YoungPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(young_space()->cas_allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, false, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _young_lab.flush();\n-\n-          HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n-          if (lab_base != nullptr) {\n-            _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n-            \/\/ Try the young lab allocation again.\n-            new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, false, &_young_lab);\n-          } else {\n-            _young_gen_is_full = true;\n-          }\n-        }\n-        if (new_obj == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n-          _young_gen_has_alloc_failure = true;\n-        }\n-      }\n+      new_obj = cast_to_oop(allocate_in_young_gen(klass, new_obj_size, age));\n@@ -219,2 +269,2 @@\n-#ifndef PRODUCT\n-    if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    new_obj = cast_to_oop(allocate_in_old_gen(klass, new_obj_size, age));\n+    if (new_obj == nullptr) {\n@@ -223,3 +273,0 @@\n-#endif  \/\/ #ifndef PRODUCT\n-\n-    new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n@@ -227,33 +274,0 @@\n-\n-    if (new_obj == nullptr) {\n-      if (!_old_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (OldPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(old_gen()->allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, true, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _old_lab.flush();\n-\n-          HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n-          if(lab_base != nullptr) {\n-            _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n-            \/\/ Try the old lab allocation again.\n-            new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, true, &_old_lab);\n-          }\n-        }\n-      }\n-\n-      \/\/ This is the promotion failed test, and code handling.\n-      \/\/ The code belongs here for two reasons. It is slightly\n-      \/\/ different than the code below, and cannot share the\n-      \/\/ CAS testing code. Keeping the code here also minimizes\n-      \/\/ the impact on the common case fast path code.\n-\n-      if (new_obj == nullptr) {\n-        _old_gen_is_full = true;\n-        return oop_promotion_failed(o, test_mark);\n-      }\n-    }\n@@ -290,1 +304,1 @@\n-    \/\/ So, the is->objArray() test would be very infrequent.\n+    \/\/ So, the objArray test would be very infrequent.\n@@ -292,1 +306,1 @@\n-        new_obj->is_objArray() &&\n+        klass->is_objArray_klass() &&\n@@ -299,2 +313,1 @@\n-      if (StringDedup::is_enabled() &&\n-          java_lang_String::is_instance(new_obj) &&\n+      if (StringDedup::is_enabled_string(klass) &&\n@@ -308,1 +321,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":82,"deletions":70,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -270,1 +270,0 @@\n-  _pretenure_size_threshold_words = PretenureSizeThreshold >> LogHeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-  \/\/ Size of object to pretenure in words; command line provides bytes\n-  size_t      _pretenure_size_threshold_words;\n@@ -188,18 +186,0 @@\n-  \/\/ Allocation support\n-  bool should_allocate(size_t word_size, bool is_tlab) {\n-    assert(UseTLAB || !is_tlab, \"Should not allocate tlab\");\n-    assert(word_size != 0, \"precondition\");\n-\n-    size_t overflow_limit    = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n-\n-    const bool overflows     = word_size >= overflow_limit;\n-    const bool check_too_big = _pretenure_size_threshold_words > 0;\n-    const bool not_too_big   = word_size < _pretenure_size_threshold_words;\n-    const bool size_ok       = is_tlab || !check_too_big || not_too_big;\n-\n-    bool result = !overflows &&\n-                  size_ok;\n-\n-    return result;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -69,1 +70,0 @@\n-#include \"runtime\/handles.hpp\"\n@@ -284,9 +284,0 @@\n-\/\/ Return true if any of the following is true:\n-\/\/ . the allocation won't fit into the current young gen heap\n-\/\/ . heap memory is tight\n-bool SerialHeap::should_try_older_generation_allocation(size_t word_size) const {\n-  size_t young_capacity = _young_gen->capacity_before_gc();\n-  return    (word_size > heap_word_size(young_capacity))\n-         || _is_heap_almost_full;\n-}\n-\n@@ -294,4 +285,2 @@\n-  HeapWord* result = nullptr;\n-  if (_old_gen->should_allocate(size, is_tlab)) {\n-    result = _old_gen->expand_and_allocate(size);\n-  }\n+  HeapWord* result = _young_gen->allocate(size);\n+\n@@ -299,4 +288,1 @@\n-    if (_young_gen->should_allocate(size, is_tlab)) {\n-      \/\/ Young-gen is not expanded.\n-      result = _young_gen->allocate(size);\n-    }\n+    result = _old_gen->expand_and_allocate(size);\n@@ -304,0 +290,1 @@\n+\n@@ -311,9 +298,13 @@\n-  \/\/ Loop until the allocation is satisfied, or unsatisfied after GC.\n-  for (uint try_count = 1; \/* return or throw *\/; try_count += 1) {\n-    \/\/ First allocation attempt is lock-free.\n-    DefNewGeneration *young = _young_gen;\n-    if (young->should_allocate(size, is_tlab)) {\n-      result = young->par_allocate(size);\n-      if (result != nullptr) {\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n+  for (uint try_count = 1; \/* break *\/; try_count++) {\n+    result = _young_gen->par_allocate(size);\n+    if (result != nullptr) {\n+      break;\n+    }\n+    \/\/ Try old-gen allocation for non-TLAB.\n+    if (!is_tlab) {\n+      \/\/ If it's too large for young-gen or heap is too full.\n+      if (size > heap_word_size(_young_gen->capacity_before_gc()) || _is_heap_almost_full) {\n+        result = _old_gen->par_allocate(size);\n+        if (result != nullptr) {\n+          break;\n+        }\n@@ -325,12 +316,0 @@\n-      log_trace(gc, alloc)(\"SerialHeap::mem_allocate_work: attempting locked slow path allocation\");\n-      \/\/ Note that only large objects get a shot at being\n-      \/\/ allocated in later generations.\n-      bool first_only = !should_try_older_generation_allocation(size);\n-\n-      result = attempt_allocation(size, is_tlab, first_only);\n-      if (result != nullptr) {\n-        assert(is_in_reserved(result), \"result not in heap\");\n-        return result;\n-      }\n-\n-      \/\/ Read the gc count while the heap lock is held.\n@@ -344,4 +323,1 @@\n-\n-      assert(result == nullptr || is_in_reserved(result),\n-             \"result not in heap\");\n-      return result;\n+      break;\n@@ -357,13 +333,0 @@\n-}\n-\n-HeapWord* SerialHeap::attempt_allocation(size_t size,\n-                                         bool is_tlab,\n-                                         bool first_only) {\n-  HeapWord* res = nullptr;\n-\n-  if (_young_gen->should_allocate(size, is_tlab)) {\n-    res = _young_gen->allocate(size);\n-    if (res != nullptr || first_only) {\n-      return res;\n-    }\n-  }\n@@ -371,5 +334,2 @@\n-  if (_old_gen->should_allocate(size, is_tlab)) {\n-    res = _old_gen->allocate(size);\n-  }\n-\n-  return res;\n+  assert(result == nullptr || is_in_reserved(result), \"postcondition\");\n+  return result;\n@@ -378,2 +338,1 @@\n-HeapWord* SerialHeap::mem_allocate(size_t size,\n-                                   bool* gc_overhead_limit_was_exceeded) {\n+HeapWord* SerialHeap::mem_allocate(size_t size) {\n@@ -450,0 +409,2 @@\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  bs_nm->disarm(nm);\n@@ -474,1 +435,1 @@\n-  bool should_run_young_gc = _young_gen->should_allocate(size, is_tlab);\n+  bool should_run_young_gc = is_tlab || size <= _young_gen->eden()->capacity();\n@@ -477,6 +438,1 @@\n-  result = attempt_allocation(size, is_tlab, false \/*first_only*\/);\n-  if (result != nullptr) {\n-    return result;\n-  }\n-\n-  \/\/ OK, collection failed, try expansion.\n+  \/\/ Just finished a GC, try to satisfy this allocation, using expansion if needed.\n@@ -499,4 +455,0 @@\n-  result = attempt_allocation(size, is_tlab, false \/* first_only *\/);\n-  if (result != nullptr) {\n-    return result;\n-  }\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":26,"deletions":74,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -105,5 +105,0 @@\n-  \/\/ Helper functions for allocation\n-  HeapWord* attempt_allocation(size_t size,\n-                               bool   is_tlab,\n-                               bool   first_only);\n-\n@@ -141,1 +136,1 @@\n-  HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded) override;\n+  HeapWord* mem_allocate(size_t size) override;\n@@ -232,4 +227,0 @@\n-  \/\/ Return true if an allocation should be attempted in the older generation\n-  \/\/ if it fails in the younger generation.  Return false, otherwise.\n-  bool should_try_older_generation_allocation(size_t word_size) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+  \/\/ Multi-threaded version.\n+  inline HeapWord* par_allocate(size_t word_size);\n@@ -136,9 +138,0 @@\n-  bool should_allocate(size_t word_size, bool is_tlab) {\n-    bool result = false;\n-    size_t overflow_limit = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n-    if (!is_tlab) {\n-      result = (word_size > 0) && (word_size < overflow_limit);\n-    }\n-    return result;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,0 +60,8 @@\n+HeapWord* TenuredGeneration::par_allocate(size_t word_size) {\n+  HeapWord* res = _the_space->par_allocate(word_size);\n+  if (res != nullptr) {\n+    _bts->update_for_block(res, res + word_size);\n+  }\n+  return res;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,10 +34,1 @@\n-\/\/ The throughput goal is implemented as\n-\/\/      _throughput_goal = 1 - ( 1 \/ (1 + gc_cost_ratio))\n-\/\/ gc_cost_ratio is the ratio\n-\/\/      application cost \/ gc cost\n-\/\/ For example a gc_cost_ratio of 4 translates into a\n-\/\/ throughput goal of .80\n-\n-AdaptiveSizePolicy::AdaptiveSizePolicy(double gc_pause_goal_sec,\n-                                       uint gc_cost_ratio) :\n-  _throughput_goal(1.0 - double(1.0 \/ (1.0 + (double) gc_cost_ratio))),\n+AdaptiveSizePolicy::AdaptiveSizePolicy(double gc_pause_goal_sec) :\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,4 +50,0 @@\n-  \/\/ Goal for the fraction of the total time during which application\n-  \/\/ threads run\n-  const double _throughput_goal;\n-\n@@ -173,2 +169,1 @@\n-  AdaptiveSizePolicy(double gc_pause_goal_sec,\n-                     uint gc_cost_ratio);\n+  AdaptiveSizePolicy(double gc_pause_goal_sec);\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-      assert(oopDesc::is_oop(old_obj, true), \"Not an oop\");\n+      assert(oopDesc::is_oop(old_obj), \"Not an oop\");\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -204,28 +203,0 @@\n-class CPUTimeThreadClosure : public ThreadClosure {\n-private:\n-  jlong _cpu_time = 0;\n-\n-public:\n-  virtual void do_thread(Thread* thread) {\n-    jlong cpu_time = os::thread_cpu_time(thread);\n-    if (cpu_time != -1) {\n-      _cpu_time += cpu_time;\n-    }\n-  }\n-  jlong cpu_time() { return _cpu_time; };\n-};\n-\n-double CollectedHeap::elapsed_gc_cpu_time() const {\n-  double string_dedup_cpu_time = UseStringDeduplication ?\n-    os::thread_cpu_time((Thread*)StringDedup::_processor->_thread) : 0;\n-\n-  if (string_dedup_cpu_time == -1) {\n-    string_dedup_cpu_time = 0;\n-  }\n-\n-  CPUTimeThreadClosure cl;\n-  gc_threads_do(&cl);\n-\n-  return (double)(cl.cpu_time() + _vmthread_cpu_time + string_dedup_cpu_time) \/ NANOSECS_PER_SEC;\n-}\n-\n@@ -636,24 +607,0 @@\n-void CollectedHeap::log_gc_cpu_time() const {\n-  LogTarget(Info, gc, cpu) out;\n-  if (os::is_thread_cpu_time_supported() && out.is_enabled()) {\n-    double process_cpu_time = os::elapsed_process_cpu_time();\n-    double gc_cpu_time = elapsed_gc_cpu_time();\n-\n-    if (process_cpu_time == -1 || gc_cpu_time == -1) {\n-      log_warning(gc, cpu)(\"Could not sample CPU time\");\n-      return;\n-    }\n-\n-    double usage;\n-    if (gc_cpu_time > process_cpu_time ||\n-        process_cpu_time == 0 || gc_cpu_time == 0) {\n-      \/\/ This can happen e.g. for short running processes with\n-      \/\/ low CPU utilization\n-      usage = 0;\n-    } else {\n-      usage = 100 * gc_cpu_time \/ process_cpu_time;\n-    }\n-    out.print(\"GC CPU usage: %.2f%% (Process: %.4fs GC: %.4fs)\", usage, process_cpu_time, gc_cpu_time);\n-  }\n-}\n-\n@@ -663,3 +610,0 @@\n-  \/\/ Log GC CPU usage.\n-  log_gc_cpu_time();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":56,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -92,0 +93,1 @@\n+  friend class CPUTimeUsage::GC;\n@@ -163,2 +165,1 @@\n-  virtual HeapWord* mem_allocate(size_t size,\n-                                 bool* gc_overhead_limit_was_exceeded) = 0;\n+  virtual HeapWord* mem_allocate(size_t size) = 0;\n@@ -432,2 +433,0 @@\n-  void log_gc_cpu_time() const;\n-\n@@ -466,2 +465,0 @@\n-  double elapsed_gc_cpu_time() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -65,3 +65,2 @@\n-  julong memory = os::physical_memory();\n-  log_info_p(gc, init)(\"Memory: \" JULONG_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(memory), proper_unit_for_byte_size(memory));\n+  size_t memory = os::physical_memory();\n+  log_info_p(gc, init)(\"Memory: \" PROPERFMT, PROPERFMTARGS(memory));\n","filename":"src\/hotspot\/share\/gc\/shared\/gcInitLogger.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,5 +65,0 @@\n-VM_GC_Operation::~VM_GC_Operation() {\n-  CollectedHeap* ch = Universe::heap();\n-  ch->soft_ref_policy()->set_all_soft_refs_clear(false);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-                  uint full_gc_count_before = 0,\n-                  bool full = false) : VM_Heap_Sync_Operation() {\n+                  uint full_gc_count_before,\n+                  bool full) : VM_Heap_Sync_Operation() {\n@@ -129,8 +129,0 @@\n-    \/\/ In ParallelScavengeHeap::mem_allocate() collections can be\n-    \/\/ executed within a loop and _all_soft_refs_clear can be set\n-    \/\/ true after they have been cleared by a collection and another\n-    \/\/ collection started so that _all_soft_refs_clear can be true\n-    \/\/ when this collection is started.  Don't assert that\n-    \/\/ _all_soft_refs_clear have to be false here even though\n-    \/\/ mutators have run.  Soft refs will be cleared again in this\n-    \/\/ collection.\n@@ -138,1 +130,0 @@\n-  ~VM_GC_Operation();\n@@ -159,2 +150,2 @@\n-                          uint full_gc_count_before = 0,\n-                          bool full = false) :\n+                          uint full_gc_count_before,\n+                          bool full) :\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -487,5 +487,0 @@\n-  product(size_t, PretenureSizeThreshold, 0,                                \\\n-          \"Maximum size in bytes of objects allocated in DefNew \"           \\\n-          \"generation; zero means no maximum\")                              \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  bool                _overhead_limit_exceeded;\n@@ -74,1 +73,0 @@\n-      _overhead_limit_exceeded(false),\n@@ -122,1 +120,1 @@\n-  const char* message = _overhead_limit_exceeded ? \"GC overhead limit exceeded\" : \"Java heap space\";\n+  const char* message = \"Java heap space\";\n@@ -136,4 +134,1 @@\n-    oop exception = _overhead_limit_exceeded ?\n-        Universe::out_of_memory_error_gc_overhead_limit() :\n-        Universe::out_of_memory_error_java_heap();\n-    THROW_OOP_(exception, true);\n+    THROW_OOP_(Universe::out_of_memory_error_java_heap(), true);\n@@ -241,1 +236,1 @@\n-  HeapWord* mem = Universe::heap()->mem_allocate(_word_size, &allocation._overhead_limit_exceeded);\n+  HeapWord* mem = Universe::heap()->mem_allocate(_word_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -823,1 +823,1 @@\n-  os::snprintf(name, sizeof(name), \"%s %s lock\", storage_name, kind);\n+  os::snprintf_checked(name, sizeof(name), \"%s %s lock\", storage_name, kind);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-    os::snprintf(buffer, SATB_PRINTER_BUFFER_SIZE, \"Enqueued: %d\", i);\n+    os::snprintf_checked(buffer, SATB_PRINTER_BUFFER_SIZE, \"Enqueued: %d\", i);\n@@ -324,1 +324,1 @@\n-      os::snprintf(_buffer, SATB_PRINTER_BUFFER_SIZE, \"Thread: %s\", t->name());\n+      (void) os::snprintf(_buffer, SATB_PRINTER_BUFFER_SIZE, \"Thread: %s\", t->name());\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n-\n@@ -36,7 +34,0 @@\n-  \/\/ Set to true by the GC if the just-completed gc cleared all\n-  \/\/ softrefs.  This is set to true whenever a gc clears all softrefs, and\n-  \/\/ set to false each time gc returns to the mutator.  For example, in the\n-  \/\/ ParallelScavengeHeap case the latter would be done toward the end of\n-  \/\/ mem_allocate() where it returns op.result()\n-  bool _all_soft_refs_clear;\n-\n@@ -45,2 +36,1 @@\n-    _should_clear_all_soft_refs(false),\n-    _all_soft_refs_clear(false) {}\n+    _should_clear_all_soft_refs(false) {}\n@@ -50,9 +40,0 @@\n-\n-  bool all_soft_refs_clear() { return _all_soft_refs_clear; }\n-  void set_all_soft_refs_clear(bool v) { _all_soft_refs_clear = v; }\n-\n-  \/\/ Called by the GC after Soft Refs have been cleared to indicate\n-  \/\/ that the request in _should_clear_all_soft_refs has been fulfilled.\n-  void cleared_all_soft_refs() {\n-    _all_soft_refs_clear = true;\n-  }\n","filename":"src\/hotspot\/share\/gc\/shared\/softRefPolicy.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -108,1 +109,0 @@\n-class CollectedHeap;\n@@ -119,1 +119,1 @@\n-  friend class CollectedHeap;\n+  friend class CPUTimeUsage::GC;\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedup.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -32,1 +33,0 @@\n-class CollectedHeap;\n@@ -46,1 +46,1 @@\n-  friend class CollectedHeap;\n+  friend class CPUTimeUsage::GC;\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -253,3 +253,2 @@\n-        const TypeFunc *tf = ShenandoahBarrierSetC2::write_ref_field_pre_Type();\n-        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), \"shenandoah_wb_pre\",\n-                          pre_val, tls);\n+        const TypeFunc *tf = ShenandoahBarrierSetC2::write_barrier_pre_Type();\n+        __ make_leaf_call(tf, CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre), \"shenandoah_wb_pre\", pre_val);\n@@ -273,1 +272,1 @@\n-         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre);\n+         call->as_CallLeaf()->entry_point() == CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_barrier_pre);\n@@ -523,2 +522,2 @@\n-const TypeFunc* ShenandoahBarrierSetC2::write_ref_field_pre_Type() {\n-  const Type **fields = TypeTuple::fields(2);\n+const TypeFunc* ShenandoahBarrierSetC2::write_barrier_pre_Type() {\n+  const Type **fields = TypeTuple::fields(1);\n@@ -526,2 +525,1 @@\n-  fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL; \/\/ thread\n-  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);\n@@ -1111,1 +1109,1 @@\n-    uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain()->cnt();\n+    uint cnt = ShenandoahBarrierSetC2::write_barrier_pre_Type()->domain()->cnt();\n@@ -1197,1 +1195,1 @@\n-        uint cnt = ShenandoahBarrierSetC2::write_ref_field_pre_Type()->domain()->cnt();\n+        uint cnt = ShenandoahBarrierSetC2::write_barrier_pre_Type()->domain()->cnt();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  static const TypeFunc* write_ref_field_pre_Type();\n+  static const TypeFunc* write_barrier_pre_Type();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -197,0 +197,7 @@\n+  \/\/ Gen shen does not support any ShenandoahGCHeuristics value except for the default \"adaptive\"\n+  if ((strcmp(ShenandoahGCMode, \"generational\") == 0)\n+      && strcmp(ShenandoahGCHeuristics, \"adaptive\") != 0) {\n+    log_warning(gc)(\"Ignoring -XX:ShenandoahGCHeuristics input: %s, because generational shenandoah only\"\n+      \" supports adaptive heuristics\", ShenandoahGCHeuristics);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -826,1 +826,0 @@\n-template<bool GENERATIONAL>\n@@ -836,3 +835,0 @@\n-    if (GENERATIONAL) {\n-      ShenandoahThreadLocalData::enable_plab_promotions(thread);\n-    }\n@@ -842,1 +838,0 @@\n-template<bool GENERATIONAL>\n@@ -854,5 +849,0 @@\n-    if (GENERATIONAL) {\n-      Thread* worker_thread = Thread::current();\n-      ShenandoahThreadLocalData::enable_plab_promotions(worker_thread);\n-    }\n-\n@@ -862,1 +852,1 @@\n-    ShenandoahConcurrentEvacThreadClosure<GENERATIONAL> thr_cl(&oops_cl);\n+    ShenandoahConcurrentEvacThreadClosure thr_cl(&oops_cl);\n@@ -868,1 +858,1 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  const ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -871,7 +861,2 @@\n-  if (heap->mode()->is_generational()) {\n-    ShenandoahConcurrentEvacUpdateThreadTask<true> task(heap->workers()->active_workers());\n-    heap->workers()->run_task(&task);\n-  } else {\n-    ShenandoahConcurrentEvacUpdateThreadTask<false> task(heap->workers()->active_workers());\n-    heap->workers()->run_task(&task);\n-  }\n+  ShenandoahConcurrentEvacUpdateThreadTask task(heap->workers()->active_workers());\n+  heap->workers()->run_task(&task);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"gc\/shared\/gc_globals.hpp\"\n@@ -1097,2 +1097,1 @@\n-HeapWord* ShenandoahHeap::mem_allocate(size_t size,\n-                                        bool*  gc_overhead_limit_was_exceeded) {\n+HeapWord* ShenandoahHeap::mem_allocate(size_t size) {\n@@ -1219,0 +1218,5 @@\n+\n+      \/\/ Re-enable promotions for the next evacuation phase.\n+      ShenandoahThreadLocalData::enable_plab_promotions(thread);\n+\n+      \/\/ Reset the fill size for next evacuation phase.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -707,1 +707,1 @@\n-  HeapWord* mem_allocate(size_t size, bool* what) override;\n+  HeapWord* mem_allocate(size_t size) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -315,5 +315,0 @@\n-  \/\/ The mark-word has been copied from the original object. It can not be\n-  \/\/ inflating, because inflation can not be interrupted by a safepoint,\n-  \/\/ and after a safepoint, a Java thread would first have to successfully\n-  \/\/ evacuate the object before it could inflate the monitor.\n-  assert(!w.is_being_inflated() || LockingMode == LM_LIGHTWEIGHT, \"must not inflate monitor before evacuation of object succeeds\");\n@@ -337,1 +332,0 @@\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"Must use LW locking, too\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-JRT_LEAF(void, ShenandoahRuntime::write_ref_field_pre(oopDesc * orig, JavaThread * thread))\n-  assert(thread == JavaThread::current(), \"pre-condition\");\n+JRT_LEAF(void, ShenandoahRuntime::write_barrier_pre(oopDesc* orig))\n@@ -46,0 +45,1 @@\n+  JavaThread* thread = JavaThread::current();\n@@ -51,4 +51,0 @@\n-void ShenandoahRuntime::write_barrier_pre(oopDesc* orig) {\n-  write_ref_field_pre(orig, JavaThread::current());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  static void write_ref_field_pre(oopDesc* orig, JavaThread* thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  _paced_time(0),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  double _paced_time;\n-\n@@ -240,12 +238,0 @@\n-  static void add_paced_time(Thread* thread, double v) {\n-    data(thread)->_paced_time += v;\n-  }\n-\n-  static double paced_time(Thread* thread) {\n-    return data(thread)->_paced_time;\n-  }\n-\n-  static void reset_paced_time(Thread* thread) {\n-    data(thread)->_paced_time = 0;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n-          \"Possible values are:\"                                            \\\n+          \"When -XX:ShenandoahGCMode is generational, the only supported \"  \\\n+          \"option is the default, adaptive. Possible values are:\"           \\\n@@ -147,1 +148,2 @@\n-          \" static -  trigger GC when free heap falls below the threshold;\" \\\n+          \" static - trigger GC when free heap falls below a specified \"    \\\n+          \"threshold;\"                                                      \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+\n+  template <typename Function, typename... Args>\n+  bool next_if(T* elem, Function predicate, Args&&... args);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,0 +164,14 @@\n+template <typename T, bool Parallel>\n+template <typename Function, typename... Args>\n+inline bool ZArrayIteratorImpl<T, Parallel>::next_if(T* elem, Function predicate, Args&&... args) {\n+  size_t index;\n+  while (next_index(&index)) {\n+    if (predicate(index_to_elem(index), args...)) {\n+      *elem = index_to_elem(index);\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-HeapWord* ZCollectedHeap::mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) {\n+HeapWord* ZCollectedHeap::mem_allocate(size_t size) {\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+  HeapWord* mem_allocate(size_t size) override;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -728,2 +728,2 @@\n-      \/\/ finishing, we don't want it to have fewer workers than the old generation.\n-      young_workers = MAX2(old_workers, young_workers);\n+      \/\/ finishing, we ideally don't want it to have fewer workers than the old generation.\n+      young_workers = clamp(MAX2(old_workers, young_workers), 1u, ZYoungGCThreads);\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+  const uint32_t         _partition_id;\n@@ -111,0 +112,2 @@\n+  uint32_t partition_id() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+    _partition_id(page->single_partition_id()),\n@@ -105,0 +106,4 @@\n+inline uint32_t ZForwarding::partition_id() const {\n+  return _partition_id;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -253,2 +253,2 @@\n-ZPage* ZHeap::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age) {\n-  ZPage* const page = _page_allocator.alloc_page(type, size, flags, age);\n+ZPage* ZHeap::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition) {\n+  ZPage* const page = _page_allocator.alloc_page(type, size, flags, age, preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age);\n+  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zNUMA.inline.hpp\"\n@@ -61,3 +62,5 @@\n-  \/\/ Calculate headroom needed to avoid in-place relocation. Each worker will try\n-  \/\/ to allocate a small page, and all workers will share a single medium page.\n-  return (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  \/\/ Calculate headroom needed to avoid in-place relocation. For each NUMA node,\n+  \/\/ each worker will try to allocate a small page, and all workers will share a\n+  \/\/ single medium page.\n+  const size_t per_numa_headroom = (ConcGCThreads * ZPageSizeSmall) + ZPageSizeMediumMax;\n+  return per_numa_headroom * ZNUMA::count();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeuristics.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-#include <utilities\/globalDefinitions.hpp>\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zIndexDistributor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-  log_info_p(gc, init)(\"Memory: \" JULONG_FORMAT \"M\", os::physical_memory() \/ M);\n+  const size_t memory = os::physical_memory();\n+  log_info_p(gc, init)(\"Memory: \" PROPERFMT, PROPERFMTARGS(memory));\n","filename":"src\/hotspot\/share\/gc\/z\/zLargePages.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-int ZMappedCache::EntryCompare::cmp(const IntrusiveRBNode* a, const IntrusiveRBNode* b) {\n+bool ZMappedCache::EntryCompare::less_than(const IntrusiveRBNode* a, const IntrusiveRBNode* b) {\n@@ -125,4 +125,1 @@\n-  if (vmem_a.end() < vmem_b.start()) { return -1; }\n-  if (vmem_b.end() < vmem_a.start()) { return 1; }\n-\n-  return 0; \/\/ Overlapping\n+  return vmem_a.end() < vmem_b.start();\n@@ -131,1 +128,1 @@\n-int ZMappedCache::EntryCompare::cmp(zoffset key, const IntrusiveRBNode* node) {\n+RBTreeOrdering ZMappedCache::EntryCompare::cmp(zoffset key, const IntrusiveRBNode* node) {\n@@ -134,2 +131,2 @@\n-  if (key < vmem.start()) { return -1; }\n-  if (key > vmem.end()) { return 1; }\n+  if (key < vmem.start()) { return RBTreeOrdering::LT; }\n+  if (key > vmem.end()) { return RBTreeOrdering::GT; }\n@@ -137,1 +134,1 @@\n-  return 0; \/\/ Containing\n+  return RBTreeOrdering::EQ; \/\/ Containing\n@@ -174,1 +171,1 @@\n-  if (_left_most == nullptr || EntryCompare::cmp(node, _left_most) < 0) {\n+  if (_left_most == nullptr || EntryCompare::less_than(node, _left_most)) {\n@@ -179,1 +176,1 @@\n-  if (_right_most == nullptr || EntryCompare::cmp(_right_most, node) < 0) {\n+  if (_right_most == nullptr || EntryCompare::less_than(_right_most, node)) {\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-    static int cmp(zoffset a, const IntrusiveRBNode* b);\n-    static int cmp(const IntrusiveRBNode*  a, const IntrusiveRBNode* b);\n+    static RBTreeOrdering cmp(zoffset a, const IntrusiveRBNode* b);\n+    static bool less_than(const IntrusiveRBNode*  a, const IntrusiveRBNode* b);\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  return ZHeap::heap()->alloc_page(type, size, flags, _age);\n+  return ZHeap::heap()->alloc_page(type, size, flags, _age, ZNUMA::id());\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,0 +160,1 @@\n+  assert(!is_multi_partition(), \"Don't fetch single partition id if page is multi-partition\");\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  const uint32_t             _initiating_numa_id;\n+  const uint32_t             _preferred_partition;\n@@ -423,1 +423,1 @@\n-  ZPageAllocation(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age)\n+  ZPageAllocation(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition)\n@@ -431,1 +431,1 @@\n-      _initiating_numa_id(ZNUMA::id()),\n+      _preferred_partition(preferred_partition),\n@@ -436,1 +436,3 @@\n-      _stall_result() {}\n+      _stall_result() {\n+    assert(_preferred_partition < ZNUMA::count(), \"Preferred partition out-of-bounds (0 <= %d < %d)\", _preferred_partition, ZNUMA::count());\n+  }\n@@ -477,2 +479,2 @@\n-  uint32_t initiating_numa_id() const {\n-    return _initiating_numa_id;\n+  uint32_t preferred_partition() const {\n+    return _preferred_partition;\n@@ -1093,1 +1095,2 @@\n-  assert(allocation->harvested() + allocation->committed_capacity() == freed, \"must have freed all\");\n+  assert(allocation->harvested() + allocation->committed_capacity() == freed, \"must have freed all\"\n+         \" %zu + %zu == %zu\", allocation->harvested(), allocation->committed_capacity(), freed);\n@@ -1400,1 +1403,1 @@\n-ZPage* ZPageAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age) {\n+ZPage* ZPageAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition) {\n@@ -1403,1 +1406,1 @@\n-  ZPageAllocation allocation(type, size, flags, age);\n+  ZPageAllocation allocation(type, size, flags, age, preferred_partition);\n@@ -1551,1 +1554,1 @@\n-  const uint32_t start_numa_id = allocation->initiating_numa_id();\n+  const uint32_t start_numa_id = allocation->preferred_partition();\n@@ -1563,1 +1566,1 @@\n-  if (!is_multi_partition_enabled() || sum_available() < allocation->size()) {\n+  if (!is_multi_partition_allowed(allocation)) {\n@@ -1581,1 +1584,1 @@\n-  const uint32_t start_node = allocation->initiating_numa_id();\n+  const uint32_t start_node = allocation->preferred_partition();\n@@ -1910,0 +1913,1 @@\n+  assert(allocation->partial_vmems()->is_empty(), \"Invariant for single partition commit failure\");\n@@ -1911,4 +1915,7 @@\n-  const size_t committed = allocation->committed_capacity();\n-  const ZVirtualMemory non_harvested_vmem = vmem.last_part(allocation->harvested());\n-  const ZVirtualMemory committed_vmem = non_harvested_vmem.first_part(committed);\n-  const ZVirtualMemory non_committed_vmem = non_harvested_vmem.last_part(committed);\n+  \/\/ For a single partition we have unmapped the harvested memory before we\n+  \/\/ started committing, and moved its physical memory association to the start\n+  \/\/ of the vmem. As such, the partial_vmems is empty. All the harvested and\n+  \/\/ partially successfully committed memory is mapped in the first part of vmem.\n+  const size_t harvested_and_committed_capacity = allocation->harvested() + allocation->committed_capacity();\n+  const ZVirtualMemory succeeded_vmem = vmem.first_part(harvested_and_committed_capacity);\n+  const ZVirtualMemory failed_vmem = vmem.last_part(harvested_and_committed_capacity);\n@@ -1916,1 +1923,1 @@\n-  if (committed_vmem.size() > 0) {\n+  if (succeeded_vmem.size() > 0) {\n@@ -1920,1 +1927,1 @@\n-    allocation->partial_vmems()->append(committed_vmem);\n+    allocation->partial_vmems()->append(succeeded_vmem);\n@@ -1925,2 +1932,2 @@\n-  partition.free_physical(non_committed_vmem);\n-  partition.free_virtual(non_committed_vmem);\n+  partition.free_physical(failed_vmem);\n+  partition.free_virtual(failed_vmem);\n@@ -1942,1 +1949,1 @@\n-    const ZVirtualMemory non_harvested_vmem = vmem.last_part(allocation->harvested());\n+    const ZVirtualMemory non_harvested_vmem = partial_vmem.last_part(allocation->harvested());\n@@ -2194,0 +2201,6 @@\n+bool ZPageAllocator::is_multi_partition_allowed(const ZPageAllocation* allocation) const {\n+  return is_multi_partition_enabled() &&\n+         allocation->type() == ZPageType::large &&\n+         allocation->size() <= sum_available();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":34,"deletions":21,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+  bool is_multi_partition_allowed(const ZPageAllocation* allocation) const;\n@@ -266,1 +267,1 @@\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age);\n+  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags, ZPageAge age, uint32_t preferred_partition);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -217,0 +217,9 @@\n+static size_t inject_commit_limit(const ZVirtualMemory& vmem) {\n+  \/\/ To facilitate easier interoperability with multi partition allocations we\n+  \/\/ divide by ZNUMA::count(). Users of ZFailLargerCommits need to be aware of\n+  \/\/ this when writing tests. In the future we could probe the VirtualMemoryManager\n+  \/\/ and condition this division on whether the vmem is in the multi partition\n+  \/\/ address space.\n+  return align_up(MIN2(ZFailLargerCommits \/ ZNUMA::count(), vmem.size()), ZGranuleSize);\n+}\n+\n@@ -219,1 +228,3 @@\n-  const size_t size = vmem.size();\n+  const size_t size = ZFailLargerCommits > 0\n+      ? inject_commit_limit(vmem)\n+      : vmem.size();\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemoryManager.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/z\/zNUMA.inline.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"gc\/z\/zValue.inline.hpp\"\n@@ -307,0 +309,25 @@\n+ZRelocationTargets::ZRelocationTargets()\n+  : _targets() {}\n+\n+ZPage* ZRelocationTargets::get(uint32_t partition_id, ZPageAge age) {\n+  return _targets.get(partition_id)[untype(age) - 1];\n+}\n+\n+void ZRelocationTargets::set(uint32_t partition_id, ZPageAge age, ZPage* page) {\n+  _targets.get(partition_id)[untype(age) - 1] = page;\n+}\n+\n+template <typename Function>\n+void ZRelocationTargets::apply_and_clear_targets(Function function) {\n+  ZPerNUMAIterator<TargetArray> iter(&_targets);\n+  for (TargetArray* targets; iter.next(&targets);) {\n+    for (size_t i = 0; i < ZNumRelocationAges; i++) {\n+      \/\/ Apply function\n+      function((*targets)[i]);\n+\n+      \/\/ Clear target\n+      (*targets)[i] = nullptr;\n+    }\n+  }\n+}\n+\n@@ -309,1 +336,5 @@\n-    _queue() {}\n+    _queue(),\n+    _iters(),\n+    _small_targets(),\n+    _medium_targets(),\n+    _shared_medium_targets() {}\n@@ -397,0 +428,1 @@\n+  const uint32_t preferred_partition = forwarding->partition_id();\n@@ -402,1 +434,1 @@\n-  return ZHeap::heap()->alloc_page(type, size, flags, age);\n+  return ZHeap::heap()->alloc_page(type, size, flags, age, preferred_partition);\n@@ -445,1 +477,1 @@\n-  void share_target_page(ZPage* page) {\n+  void share_target_page(ZPage* page, uint32_t partition_id) {\n@@ -470,5 +502,5 @@\n-  ZGeneration* const _generation;\n-  ZConditionLock     _lock;\n-  ZPage*             _shared[ZNumRelocationAges];\n-  bool               _in_place;\n-  volatile size_t    _in_place_count;\n+  ZGeneration* const  _generation;\n+  ZConditionLock      _lock;\n+  ZRelocationTargets* _shared_targets;\n+  bool                _in_place;\n+  volatile size_t     _in_place_count;\n@@ -477,1 +509,1 @@\n-  ZRelocateMediumAllocator(ZGeneration* generation)\n+  ZRelocateMediumAllocator(ZGeneration* generation, ZRelocationTargets* shared_targets)\n@@ -480,1 +512,1 @@\n-      _shared(),\n+      _shared_targets(shared_targets),\n@@ -485,3 +517,3 @@\n-    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n-      if (_shared[i] != nullptr) {\n-        retire_target_page(_generation, _shared[i]);\n+    _shared_targets->apply_and_clear_targets([&](ZPage* page) {\n+      if (page != nullptr) {\n+        retire_target_page(_generation, page);\n@@ -489,9 +521,1 @@\n-    }\n-  }\n-\n-  ZPage* shared(ZPageAge age) {\n-    return _shared[untype(age - 1)];\n-  }\n-\n-  void set_shared(ZPageAge age, ZPage* page) {\n-    _shared[untype(age - 1)] = page;\n+    });\n@@ -513,1 +537,2 @@\n-    if (shared(to_age) == target) {\n+    const uint32_t partition_id = forwarding->partition_id();\n+    if (_shared_targets->get(partition_id, to_age) == target) {\n@@ -515,1 +540,1 @@\n-      set_shared(to_age, to_page);\n+      _shared_targets->set(partition_id, to_age, to_page);\n@@ -527,1 +552,1 @@\n-    return shared(to_age);\n+    return _shared_targets->get(partition_id, to_age);\n@@ -530,1 +555,1 @@\n-  void share_target_page(ZPage* page) {\n+  void share_target_page(ZPage* page, uint32_t partition_id) {\n@@ -535,1 +560,1 @@\n-    assert(shared(age) == nullptr, \"Invalid state\");\n+    assert(_shared_targets->get(partition_id, age) == nullptr, \"Invalid state\");\n@@ -538,1 +563,1 @@\n-    set_shared(age, page);\n+    _shared_targets->set(partition_id, age, page);\n@@ -566,1 +591,1 @@\n-  ZPage*              _target[ZNumRelocationAges];\n+  ZRelocationTargets* _targets;\n@@ -572,9 +597,0 @@\n-\n-  ZPage* target(ZPageAge age) {\n-    return _target[untype(age - 1)];\n-  }\n-\n-  void set_target(ZPageAge age, ZPage* page) {\n-    _target[untype(age - 1)] = page;\n-  }\n-\n@@ -594,1 +610,1 @@\n-  zaddress try_relocate_object_inner(zaddress from_addr) {\n+  zaddress try_relocate_object_inner(zaddress from_addr, uint32_t partition_id) {\n@@ -598,1 +614,1 @@\n-    ZPage* const to_page = target(_forwarding->to_age());\n+    ZPage* const to_page = _targets->get(partition_id, _forwarding->to_age());\n@@ -809,2 +825,2 @@\n-  bool try_relocate_object(zaddress from_addr) {\n-    const zaddress to_addr = try_relocate_object_inner(from_addr);\n+  bool try_relocate_object(zaddress from_addr, uint32_t partition_id) {\n+    const zaddress to_addr = try_relocate_object_inner(from_addr, partition_id);\n@@ -891,7 +907,12 @@\n-    while (!try_relocate_object(addr)) {\n-      \/\/ Allocate a new target page, or if that fails, use the page being\n-      \/\/ relocated as the new target, which will cause it to be relocated\n-      \/\/ in-place.\n-      const ZPageAge to_age = _forwarding->to_age();\n-      ZPage* to_page = _allocator->alloc_and_retire_target_page(_forwarding, target(to_age));\n-      set_target(to_age, to_page);\n+    const ZPageAge to_age = _forwarding->to_age();\n+    const uint32_t partition_id = _forwarding->partition_id();\n+\n+    while (!try_relocate_object(addr, partition_id)) {\n+      \/\/ Failed to relocate object, try to allocate a new target page,\n+      \/\/ or if that fails, use the page being relocated as the new target,\n+      \/\/ which will cause it to be relocated in-place.\n+      ZPage* const target_page = _targets->get(partition_id, to_age);\n+      ZPage* to_page = _allocator->alloc_and_retire_target_page(_forwarding, target_page);\n+      _targets->set(partition_id, to_age, to_page);\n+\n+      \/\/ We got a new page, retry relocation\n@@ -906,1 +927,1 @@\n-      set_target(to_age, to_page);\n+      _targets->set(partition_id, to_age, to_page);\n@@ -911,1 +932,1 @@\n-  ZRelocateWork(Allocator* allocator, ZGeneration* generation)\n+  ZRelocateWork(Allocator* allocator, ZRelocationTargets* targets, ZGeneration* generation)\n@@ -914,1 +935,1 @@\n-      _target(),\n+      _targets(targets),\n@@ -920,3 +941,4 @@\n-    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n-      _allocator->free_target_page(_target[i]);\n-    }\n+    _targets->apply_and_clear_targets([&](ZPage* page) {\n+        _allocator->free_target_page(page);\n+    });\n+\n@@ -1015,2 +1037,3 @@\n-      ZPage* const target_page = target(_forwarding->to_age());\n-      _allocator->share_target_page(target_page);\n+      const uint32_t target_partition = _forwarding->partition_id();\n+      ZPage* const target_page = _targets->get(target_partition, _forwarding->to_age());\n+      _allocator->share_target_page(target_page, target_partition);\n@@ -1060,5 +1083,9 @@\n-  ZRelocationSetParallelIterator _iter;\n-  ZGeneration* const             _generation;\n-  ZRelocateQueue* const          _queue;\n-  ZRelocateSmallAllocator        _small_allocator;\n-  ZRelocateMediumAllocator       _medium_allocator;\n+  ZGeneration* const                        _generation;\n+  ZRelocateQueue* const                     _queue;\n+  ZPerNUMA<ZRelocationSetParallelIterator>* _iters;\n+  ZPerWorker<ZRelocationTargets>*           _small_targets;\n+  ZPerWorker<ZRelocationTargets>*           _medium_targets;\n+  ZRelocateSmallAllocator                   _small_allocator;\n+  ZRelocateMediumAllocator                  _medium_allocator;\n+  const size_t                              _total_forwardings;\n+  volatile size_t                           _numa_local_forwardings;\n@@ -1067,1 +1094,6 @@\n-  ZRelocateTask(ZRelocationSet* relocation_set, ZRelocateQueue* queue)\n+  ZRelocateTask(ZRelocationSet* relocation_set,\n+                ZRelocateQueue* queue,\n+                ZPerNUMA<ZRelocationSetParallelIterator>* iters,\n+                ZPerWorker<ZRelocationTargets>* small_targets,\n+                ZPerWorker<ZRelocationTargets>* medium_targets,\n+                ZRelocationTargets* shared_medium_targets)\n@@ -1069,1 +1101,0 @@\n-      _iter(relocation_set),\n@@ -1072,0 +1103,3 @@\n+      _iters(iters),\n+      _small_targets(small_targets),\n+      _medium_targets(medium_targets),\n@@ -1073,1 +1107,15 @@\n-      _medium_allocator(_generation) {}\n+      _medium_allocator(_generation, shared_medium_targets),\n+      _total_forwardings(relocation_set->nforwardings()),\n+      _numa_local_forwardings(0) {\n+\n+    for (uint32_t i = 0; i < ZNUMA::count(); i++) {\n+      ZRelocationSetParallelIterator* const iter = _iters->addr(i);\n+\n+      \/\/ Destruct the iterator from the previous GC-cycle, which is a temporary\n+      \/\/ iterator if this is the first GC-cycle.\n+      iter->~ZRelocationSetParallelIterator();\n+\n+      \/\/ In-place construct the iterator with the current relocation set\n+      ::new (iter) ZRelocationSetParallelIterator(relocation_set);\n+    }\n+  }\n@@ -1080,0 +1128,5 @@\n+\n+    if (ZNUMA::is_enabled()) {\n+      log_debug(gc, reloc, numa)(\"Forwardings relocated NUMA-locally: %zu \/ %zu (%.0f%%)\",\n+                                 _numa_local_forwardings, _total_forwardings, percent_of(_numa_local_forwardings, _total_forwardings));\n+    }\n@@ -1083,2 +1136,4 @@\n-    ZRelocateWork<ZRelocateSmallAllocator> small(&_small_allocator, _generation);\n-    ZRelocateWork<ZRelocateMediumAllocator> medium(&_medium_allocator, _generation);\n+    ZRelocateWork<ZRelocateSmallAllocator> small(&_small_allocator, _small_targets->addr(), _generation);\n+    ZRelocateWork<ZRelocateMediumAllocator> medium(&_medium_allocator, _medium_targets->addr(), _generation);\n+    const uint32_t num_nodes = ZNUMA::count();\n+    uint32_t numa_local_forwardings_worker = 0;\n@@ -1110,0 +1165,4 @@\n+    const auto check_numa_local = [&](ZForwarding* forwarding, uint32_t numa_id) {\n+      return forwarding->partition_id() == numa_id;\n+    };\n+\n@@ -1112,0 +1171,6 @@\n+      const uint32_t start_node = ZNUMA::id();\n+      uint32_t current_node = start_node;\n+\n+      for (uint32_t i = 0; i < num_nodes; i++) {\n+        if (_iters->get(current_node).next_if(&forwarding, check_numa_local, current_node)) {\n+          claim_and_do_forwarding(forwarding);\n@@ -1113,3 +1178,10 @@\n-      if (_iter.next(&forwarding)) {\n-        claim_and_do_forwarding(forwarding);\n-        return true;\n+          if (current_node == start_node) {\n+            \/\/ Track if this forwarding was relocated on the local NUMA node\n+            numa_local_forwardings_worker++;\n+          }\n+\n+          return true;\n+        }\n+\n+        \/\/ Check next node.\n+        current_node = (current_node + 1) % num_nodes;\n@@ -1141,0 +1213,4 @@\n+    if (ZNUMA::is_enabled()) {\n+      Atomic::add(&_numa_local_forwardings, numa_local_forwardings_worker, memory_order_relaxed);\n+    }\n+\n@@ -1221,1 +1297,1 @@\n-    ZRelocateTask relocate_task(relocation_set, &_queue);\n+    ZRelocateTask relocate_task(relocation_set, &_queue, &_iters, &_small_targets, &_medium_targets, &_shared_medium_targets);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":147,"deletions":71,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zValue.hpp\"\n@@ -77,0 +78,16 @@\n+class ZRelocationTargets {\n+private:\n+  using TargetArray = ZPage*[ZNumRelocationAges];\n+\n+  ZPerNUMA<TargetArray> _targets;\n+\n+public:\n+  ZRelocationTargets();\n+\n+  ZPage* get(uint32_t partition_id, ZPageAge age);\n+  void set(uint32_t partition_id, ZPageAge age, ZPage* page);\n+\n+  template <typename Function>\n+  void apply_and_clear_targets(Function function);\n+};\n+\n@@ -81,2 +98,6 @@\n-  ZGeneration* const _generation;\n-  ZRelocateQueue     _queue;\n+  ZGeneration* const                       _generation;\n+  ZRelocateQueue                           _queue;\n+  ZPerNUMA<ZRelocationSetParallelIterator> _iters;\n+  ZPerWorker<ZRelocationTargets>           _small_targets;\n+  ZPerWorker<ZRelocationTargets>           _medium_targets;\n+  ZRelocationTargets                       _shared_medium_targets;\n@@ -85,1 +106,0 @@\n-  void work(ZRelocationSetParallelIterator* iter);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+  size_t nforwardings() const;\n+\n@@ -67,0 +69,1 @@\n+  ZRelocationSetIteratorImpl();\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,8 @@\n+inline size_t ZRelocationSet::nforwardings() const {\n+  return _nforwardings;\n+}\n+\n+template <bool Parallel>\n+inline ZRelocationSetIteratorImpl<Parallel>::ZRelocationSetIteratorImpl()\n+  : ZArrayIteratorImpl<ZForwarding*, Parallel>(nullptr, 0) {}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.inline.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/z\/zBarrier.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zUncoloredRoot.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -55,1 +56,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -519,1 +519,1 @@\n-typedef ResourceHashtable<volatile zpointer*, bool, 1009, AnyObj::C_HEAP, mtGC> ZStoreBarrierBufferTable;\n+typedef HashTable<volatile zpointer*, bool, 1009, AnyObj::C_HEAP, mtGC> ZStoreBarrierBufferTable;\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,0 +121,5 @@\n+  develop(size_t, ZFailLargerCommits, 0,                                    \\\n+          \"Commits larger than ZFailLargerCommits will be truncated, \"      \\\n+          \"used to stress page allocation commit failure paths \"            \\\n+          \"(0: Disabled)\")                                                  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#define NUM_CDS_REGIONS 5 \/\/ this must be the same as MetaspaceShared::n_regions\n+#define NUM_CDS_REGIONS 5 \/\/ this must be the same as AOTMetaspace::n_regions\n@@ -75,1 +75,1 @@\n-                              \/\/ MetaspaceShared::protection_zone_size()) the lowest core region (rw for the\n+                              \/\/ AOTMetaspace::protection_zone_size()) the lowest core region (rw for the\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -602,10 +602,0 @@\n-\n-\/* Differs from JVM_GetClassModifiers in treatment of inner classes.\n-   This returns the access flags for the class as specified in the\n-   class file rather than searching the InnerClasses attribute (if\n-   present) to find the source-level access flags. Only the values of\n-   the low 13 bits (i.e., a mask of 0x1FFF) are guaranteed to be\n-   valid. *\/\n-JNIEXPORT jint JNICALL\n-JVM_GetClassAccessFlags(JNIEnv *env, jclass cls);\n-\n@@ -657,1 +647,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool);\n+(JNIEnv *env, jobject jcpool);\n@@ -660,1 +650,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -663,1 +653,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -666,1 +656,1 @@\n-(JNIEnv *env, jobject obj, jobject unused, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -669,1 +659,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -672,1 +662,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -675,1 +665,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -678,1 +668,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -681,1 +671,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -684,1 +674,1 @@\n-(JNIEnv *env, jobject obj, jobject unused, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -687,1 +677,1 @@\n-(JNIEnv *env, jobject obj, jobject unused, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -690,1 +680,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -693,1 +683,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -696,1 +686,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -699,1 +689,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -702,1 +692,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -705,1 +695,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n@@ -708,1 +698,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index);\n+(JNIEnv *env, jobject jcpool, jint index);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":18,"deletions":28,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"jni.h\"\n@@ -33,0 +32,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/include\/jvm_io.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n@@ -27,1 +26,1 @@\n-#include \"cds\/metaspaceShared.hpp\"\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -40,1 +39,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -42,0 +40,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"interpreter\/bytecodeStream.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"interpreter\/bytecodeStream.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeStream.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"interpreter\/bytecodes.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"interpreter\/bytecodes.hpp\"\n@@ -34,1 +34,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/signature.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/signature.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -30,1 +30,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -35,1 +34,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -37,0 +35,1 @@\n+#include \"oops\/methodData.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interpreter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"oops\/methodData.hpp\"\n@@ -51,0 +50,1 @@\n+#include \"oops\/methodData.hpp\"\n@@ -928,1 +928,1 @@\n-                           resolved_iklass->is_shared() ? \"is_shared\" : \"\",\n+                           resolved_iklass->in_aot_cache() ? \"in_aot_cache\" : \"\",\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -26,1 +27,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -127,1 +127,1 @@\n-    if (_pool->pool_holder()->is_shared()) {\n+    if (_pool->pool_holder()->in_aot_cache()) {\n@@ -570,2 +570,2 @@\n-  if (klass->is_shared()) {\n-    assert(!klass->is_rewritten(), \"rewritten shared classes cannot be rewritten again\");\n+  if (klass->in_aot_cache()) {\n+    assert(!klass->is_rewritten(), \"rewritten classes in the AOT cache cannot be rewritten again\");\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"interpreter\/interp_masm.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"interpreter\/zero\/bytecodeInterpreter.inline.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"interpreter\/zero\/bytecodeInterpreter.inline.hpp\"\n@@ -627,20 +627,1 @@\n-\n-        bool success = false;\n-        if (LockingMode == LM_LEGACY) {\n-           \/\/ Traditional fast locking.\n-          markWord displaced = rcvr->mark().set_unlocked();\n-          mon->lock()->set_displaced_header(displaced);\n-          success = true;\n-          if (rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n-            \/\/ Is it simple recursive case?\n-            if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-              mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-            } else {\n-              success = false;\n-            }\n-          }\n-        }\n-        if (!success) {\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n-        }\n-\n+        CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n@@ -728,20 +709,1 @@\n-\n-      bool success = false;\n-      if (LockingMode == LM_LEGACY) {\n-        \/\/ Traditional fast locking.\n-        markWord displaced = lockee->mark().set_unlocked();\n-        entry->lock()->set_displaced_header(displaced);\n-        success = true;\n-        if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-          \/\/ Is it simple recursive case?\n-          if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-            entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-          } else {\n-            success = false;\n-          }\n-        }\n-      }\n-      if (!success) {\n-        CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-      }\n-\n+      CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -1660,20 +1622,1 @@\n-\n-          bool success = false;\n-          if (LockingMode == LM_LEGACY) {\n-            \/\/ Traditional fast locking.\n-            markWord displaced = lockee->mark().set_unlocked();\n-            entry->lock()->set_displaced_header(displaced);\n-            success = true;\n-            if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-              \/\/ Is it simple recursive case?\n-              if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-                entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-              } else {\n-                success = false;\n-              }\n-            }\n-          }\n-          if (!success) {\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-          }\n-\n+          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -1697,19 +1640,1 @@\n-\n-            bool success = false;\n-            if (LockingMode == LM_LEGACY) {\n-              \/\/ If it isn't recursive we either must swap old header or call the runtime\n-              most_recent->set_obj(nullptr);\n-              success = true;\n-              markWord header = lock->displaced_header();\n-              if (header.to_pointer() != nullptr) {\n-                markWord old_header = markWord::encode(lock);\n-                if (lockee->cas_set_mark(header, old_header) != old_header) {\n-                  \/\/ restore object for the slow case\n-                  most_recent->set_obj(lockee);\n-                  success = false;\n-                }\n-              }\n-            }\n-            if (!success) {\n-              InterpreterRuntime::monitorexit(most_recent);\n-            }\n+            InterpreterRuntime::monitorexit(most_recent);\n@@ -3140,21 +3065,1 @@\n-          BasicLock* lock = end->lock();\n-\n-          bool success = false;\n-          if (LockingMode == LM_LEGACY) {\n-            markWord header = lock->displaced_header();\n-            end->set_obj(nullptr);\n-\n-            \/\/ If it isn't recursive we either must swap old header or call the runtime\n-            success = true;\n-            if (header.to_pointer() != nullptr) {\n-              markWord old_header = markWord::encode(lock);\n-              if (lockee->cas_set_mark(header, old_header) != old_header) {\n-                \/\/ restore object for the slow case\n-                end->set_obj(lockee);\n-                success = false;\n-              }\n-            }\n-          }\n-          if (!success) {\n-            InterpreterRuntime::monitorexit(end);\n-          }\n+          InterpreterRuntime::monitorexit(end);\n@@ -3207,1 +3112,1 @@\n-          } else if (LockingMode != LM_LEGACY) {\n+          } else {\n@@ -3213,20 +3118,0 @@\n-          } else {\n-            BasicLock* lock = base->lock();\n-            markWord header = lock->displaced_header();\n-            base->set_obj(nullptr);\n-\n-            \/\/ If it isn't recursive we either must swap old header or call the runtime\n-            bool dec_monitor_count = true;\n-            if (header.to_pointer() != nullptr) {\n-              markWord old_header = markWord::encode(lock);\n-              if (rcvr->cas_set_mark(header, old_header) != old_header) {\n-                \/\/ restore object for the slow case\n-                base->set_obj(rcvr);\n-                dec_monitor_count = false;\n-                InterpreterRuntime::monitorexit(base);\n-                if (THREAD->has_pending_exception()) {\n-                  if (!suppress_error) illegal_state_oop = Handle(THREAD, THREAD->pending_exception());\n-                  THREAD->clear_pending_exception();\n-                }\n-              }\n-            }\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":7,"deletions":122,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"bytecodeInterpreter_zero.inline.hpp\"\n@@ -45,2 +46,0 @@\n-# include \"bytecodeInterpreter_zero.inline.hpp\"\n-\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\/\/ # include \"interpreter\/interp_masm.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/zero\/zeroInterpreterGenerator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/jfr.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"jfr\/jfr.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrClassTransformer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-  InstanceKlass* const super = InstanceKlass::cast(ik->super());\n+  InstanceKlass* const super = ik->super();\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -32,2 +32,0 @@\n-#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n-#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -35,0 +33,1 @@\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -40,1 +39,0 @@\n-#include \"oops\/instanceKlass.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -45,1 +44,1 @@\n-#include \"runtime\/handles.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -47,0 +46,1 @@\n+#include \"runtime\/handles.inline.hpp\"\n@@ -55,1 +55,0 @@\n-#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n+#include \"jfr\/instrumentation\/jfrJvmtiAgent.hpp\"\n@@ -27,0 +29,3 @@\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/jni\/jfrJniMethodRegistration.hpp\"\n+#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -29,2 +34,0 @@\n-#include \"jfr\/recorder\/jfrEventSetting.hpp\"\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -33,0 +36,2 @@\n+#include \"jfr\/recorder\/jfrEventSetting.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -34,1 +39,0 @@\n-#include \"jfr\/recorder\/repository\/jfrRepository.hpp\"\n@@ -38,0 +42,1 @@\n+#include \"jfr\/recorder\/repository\/jfrRepository.hpp\"\n@@ -45,5 +50,0 @@\n-#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n-#include \"jfr\/jni\/jfrJniMethodRegistration.hpp\"\n-#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n-#include \"jfr\/instrumentation\/jfrJvmtiAgent.hpp\"\n-#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -55,1 +55,0 @@\n-#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n@@ -57,0 +56,1 @@\n+#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n@@ -70,1 +70,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -72,0 +71,1 @@\n+#include \"osContainer_linux.hpp\"\n@@ -415,1 +415,1 @@\n-  return os::Linux::physical_memory();\n+  return static_cast<jlong>(os::Linux::physical_memory());\n@@ -417,1 +417,1 @@\n-  return os::physical_memory();\n+  return static_cast<jlong>(os::physical_memory());\n@@ -426,1 +426,4 @@\n-  return os::total_swap_space();\n+  size_t total_swap_space = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::total_swap_space(total_swap_space);\n+  return static_cast<jlong>(total_swap_space);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/leakprofiler\/chains\/edgeStore.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"jfr\/leakprofiler\/chains\/edgeStore.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    ik = (const InstanceKlass*)ik->super();\n+    ik = ik->super();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -35,3 +34,0 @@\n-#include \"jfr\/leakprofiler\/chains\/rootSetClosure.hpp\"\n-#include \"jfr\/leakprofiler\/chains\/edgeStore.hpp\"\n-#include \"jfr\/leakprofiler\/chains\/objectSampleMarker.hpp\"\n@@ -39,0 +35,1 @@\n+#include \"jfr\/leakprofiler\/chains\/rootSetClosure.hpp\"\n@@ -41,0 +38,1 @@\n+#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/pathToGcRootsOperation.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -51,8 +51,0 @@\n-const unsigned int initial_size = 431;\n-\n-static JfrCHeapTraceIdSet* c_heap_allocate_set(int size = initial_size) {\n-  return new JfrCHeapTraceIdSet(size);\n-}\n-\n-static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n-\n@@ -69,8 +61,2 @@\n-static bool has_thread_exited(traceid tid) {\n-  assert(tid != 0, \"invariant\");\n-  if (unloaded_thread_id_set == nullptr) {\n-    return false;\n-  }\n-  ThreadIdExclusiveAccess lock;\n-  return unloaded_thread_id_set->contains(tid);\n-}\n+static const unsigned initial_set_size = 512;\n+static JfrCHeapTraceIdSet* unloaded_thread_id_set = nullptr;\n@@ -81,1 +67,1 @@\n-    unloaded_thread_id_set = c_heap_allocate_set();\n+    unloaded_thread_id_set = new (mtTracing) JfrCHeapTraceIdSet(initial_set_size);\n@@ -196,6 +182,0 @@\n-static JfrResourceAreaTraceIdSet* id_set = nullptr;\n-\n-static void prepare_for_resolution() {\n-  id_set = new JfrResourceAreaTraceIdSet(initial_size);\n-}\n-\n@@ -216,0 +196,2 @@\n+static JfrResourceAreaTraceIdSet* resolution_set = nullptr;\n+\n@@ -223,1 +205,1 @@\n-    prepare_for_resolution();\n+    resolution_set = new JfrResourceAreaTraceIdSet(initial_set_size);\n@@ -225,0 +207,1 @@\n+\n@@ -317,2 +300,2 @@\n-  assert(id_set != nullptr, \"invariant\");\n-  return !id_set->add(method_id);\n+  assert(resolution_set != nullptr, \"invariant\");\n+  return !resolution_set->add(method_id);\n@@ -359,1 +342,1 @@\n-  if (sample->is_virtual_thread() || has_thread_exited(sample->thread_id())) {\n+  if (sample->is_virtual_thread() || sample->thread_exited()) {\n@@ -375,1 +358,1 @@\n-  int _count;\n+  unsigned _count;\n@@ -381,1 +364,1 @@\n-  int count() const { return _count; }\n+  unsigned count() const { return _count; }\n@@ -397,2 +380,1 @@\n-  const int64_t count_offset = writer.reserve(sizeof(u4)); \/\/ Don't know how many yet\n-\n+  writer.write_count(_stacktrace_id_set->size());\n@@ -402,1 +384,0 @@\n-  writer.write_count(lpstw.count(), count_offset);\n@@ -425,0 +406,10 @@\n+static void check_if_thread_exited(const ObjectSample* sample) {\n+  assert(sample != nullptr, \"invariant\");\n+  if (sample->thread_exited() || unloaded_thread_id_set == nullptr) {\n+    return;\n+  }\n+  if (unloaded_thread_id_set->contains(sample->thread_id())) {\n+    sample->set_thread_exited();\n+  }\n+}\n+\n@@ -434,0 +425,1 @@\n+    check_if_thread_exited(sample);\n@@ -440,0 +432,7 @@\n+static void delete_unloaded_thread_id_set() {\n+  if (unloaded_thread_id_set != nullptr) {\n+    delete unloaded_thread_id_set;\n+    unloaded_thread_id_set = nullptr;\n+  }\n+}\n+\n@@ -445,0 +444,1 @@\n+  ThreadIdExclusiveAccess lock;\n@@ -446,0 +446,1 @@\n+  delete_unloaded_thread_id_set();\n@@ -448,3 +449,6 @@\n-static inline unsigned int set_size() {\n-  const unsigned int queue_size = static_cast<unsigned int>(JfrOptionSet::old_object_queue_size());\n-  return queue_size > initial_size ? queue_size : initial_size;\n+static inline unsigned stacktrace_id_set_size() {\n+  unsigned queue_size = static_cast<unsigned>(JfrOptionSet::old_object_queue_size());\n+  if (!is_power_of_2(queue_size)) {\n+    queue_size = next_power_of_2(queue_size);\n+  }\n+  return queue_size > initial_set_size ? queue_size : initial_set_size;\n@@ -459,1 +463,3 @@\n-    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(set_size());\n+    const unsigned stacktrace_set_size = stacktrace_id_set_size();\n+    assert(is_power_of_2(stacktrace_set_size), \"invariant\");\n+    _stacktrace_id_set = new JfrResourceAreaTraceIdSet(stacktrace_set_size);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allStatic.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"memory\/allStatic.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfrfiles\/jfrTypes.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"jfrfiles\/jfrTypes.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jfr\/leakprofiler\/utilities\/unifiedOopRef.inline.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"jfr\/leakprofiler\/utilities\/unifiedOopRef.inline.hpp\"\n@@ -34,1 +34,0 @@\n-#include \"prims\/jvmtiDeferredUpdates.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"jfr\/leakprofiler\/checkpoint\/eventEmitter.hpp\"\n@@ -26,0 +27,1 @@\n+#include \"jfr\/leakprofiler\/sampling\/objectSampler.hpp\"\n@@ -28,2 +30,0 @@\n-#include \"jfr\/leakprofiler\/checkpoint\/eventEmitter.hpp\"\n-#include \"jfr\/leakprofiler\/sampling\/objectSampler.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/leakProfiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  mutable bool _thread_exited;\n@@ -85,1 +86,2 @@\n-                   _virtual_thread(false) {}\n+                   _virtual_thread(false),\n+                   _thread_exited(false) {}\n@@ -228,0 +230,9 @@\n+  bool thread_exited() const {\n+    return _thread_exited;\n+  }\n+\n+  void set_thread_exited() const {\n+    assert(!_thread_exited, \"invariant\");\n+    _thread_exited = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n@@ -37,1 +37,0 @@\n-#include \"jfr\/utilities\/jfrSignal.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"jfr\/utilities\/jfrSignal.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/metadata\/jfrSerializer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,6 @@\n+       void baz(char* text) {\n+         EventText event;\n+         event.set_text(text);\n+         event.commit();\n+       }\n+\n@@ -45,0 +51,5 @@\n+       $ jfr view Text dump.jfr\n+       Time     Event Thread                             Text\n+       ======== ======================================== ==========================\n+       21:54:29 Attach Listener                          hello\n+       21:54:29 Attach Listener                          world\n@@ -46,1 +57,12 @@\n-       $ jfr print dump.jfr\n+       $ jfr query 'SELECT text, COUNT(text) FROM Text GROUP BY text ORDER BY text ASC' dump.jfr\n+\n+       Text                              Count\n+       =================== ===================\n+       hello                               622\n+       world                                37\n+\n+       $ jfr query 'SELECT COUNT(duration), AVG(duration), MEDIAN(duration), P90(duration),\n+                    P99(duration), P999(duration) FROM Duration' dump.jfr\n+\n+       The 'jfr query' command is only available in debug builds, but recordings with internal\n+       events can be generated by product builds.\n@@ -52,1 +74,2 @@\n-               System.out.println(e.getName() + \" \" + e.getDuration());\n+               EventType et = e.getEventType();\n+               System.out.println(et.getName() + \" \" + e.getDuration() + \" \" + e.getValue(\"text\"));\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"logging\/log.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"logging\/log.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrNetworkUtilization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+#include \"jfr\/periodic\/jfrNativeMemoryEvent.hpp\"\n+#include \"jfr\/periodic\/jfrNetworkUtilization.hpp\"\n@@ -44,2 +46,0 @@\n-#include \"jfr\/periodic\/jfrNativeMemoryEvent.hpp\"\n-#include \"jfr\/periodic\/jfrNetworkUtilization.hpp\"\n@@ -64,1 +64,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -66,0 +65,1 @@\n+#include \"runtime\/vmThread.hpp\"\n@@ -531,1 +531,1 @@\n-  u8 totalPhysicalMemory = os::physical_memory();\n+  u8 totalPhysicalMemory = static_cast<u8>(os::physical_memory());\n@@ -534,1 +534,4 @@\n-  event.set_usedSize(totalPhysicalMemory - os::available_memory());\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  event.set_usedSize(totalPhysicalMemory - static_cast<u8>(avail_mem));\n@@ -540,2 +543,8 @@\n-  event.set_totalSize(os::total_swap_space());\n-  event.set_freeSize(os::free_swap_space());\n+  size_t total_swap_space = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::total_swap_space(total_swap_space);\n+  event.set_totalSize(static_cast<s8>(total_swap_space));\n+  size_t free_swap_space = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::free_swap_space(free_swap_space);\n+  event.set_freeSize(static_cast<s8>(free_swap_space));\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"logging\/log.hpp\"\n@@ -30,1 +29,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n+#include \"logging\/log.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrThreadCPULoadEvent.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"jfr\/utilities\/jfrTime.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n@@ -44,2 +44,0 @@\n-#include \"utilities\/ticks.hpp\"\n-\n@@ -47,0 +45,1 @@\n+#include \"utilities\/ticks.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -29,1 +28,0 @@\n-#include \"jfr\/periodic\/sampling\/jfrThreadSampling.hpp\"\n@@ -31,0 +29,2 @@\n+#include \"jfr\/periodic\/sampling\/jfrThreadSampling.hpp\"\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n@@ -67,1 +67,1 @@\n-void JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n+size_t JfrMetadataEvent::write(JfrChunkWriter& chunkwriter) {\n@@ -71,1 +71,1 @@\n-    return;\n+    return 0;\n@@ -90,0 +90,1 @@\n+  return 1;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-  static void write(JfrChunkWriter& writer);\n+  static size_t write(JfrChunkWriter& writer);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrMetadataEvent.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrThreadState.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/jfrThreadState.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1051,2 +1051,0 @@\n-  KlassUsedPredicate _klass_used_predicate;\n-  MethodUsedPredicate _method_used_predicate;\n@@ -1058,2 +1056,0 @@\n-    _klass_used_predicate(current_epoch()),\n-    _method_used_predicate(current_epoch()),\n@@ -1063,1 +1059,1 @@\n-    if (_method_used_predicate(klass)) {\n+    if (klass->is_instance_klass()) {\n@@ -1078,1 +1074,1 @@\n-    return _klass_used_predicate(klass) ? _klass_cb(klass) : true;\n+    return _klass_cb(klass);\n@@ -1283,1 +1279,1 @@\n-    _artifacts = new JfrArtifactSet(class_unload);\n+    _artifacts = new JfrArtifactSet(class_unload, previous_epoch());\n@@ -1285,1 +1281,1 @@\n-    _artifacts->initialize(class_unload);\n+    _artifacts->initialize(class_unload, previous_epoch());\n@@ -1287,0 +1283,1 @@\n+  assert(current_epoch() || _leakp_writer != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,6 +32,10 @@\n-JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_table(nullptr),\n-                                                    _klass_list(nullptr),\n-                                                    _total_count(0),\n-                                                    _class_unload(class_unload) {\n-  initialize(class_unload);\n-  assert(_klass_list != nullptr, \"invariant\");\n+JfrArtifactSet::JfrArtifactSet(bool class_unload, bool previous_epoch) : _symbol_table(nullptr),\n+                                                                         _klass_set(nullptr),\n+                                                                         _klass_loader_set(nullptr),\n+                                                                         _klass_loader_leakp_set(nullptr),\n+                                                                         _total_count(0),\n+                                                                         _class_unload(class_unload) {\n+  initialize(class_unload, previous_epoch);\n+  assert(!previous_epoch || _klass_loader_leakp_set != nullptr, \"invariant\");\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  assert(_klass_set != nullptr, \"invariant\");\n@@ -40,2 +44,3 @@\n-static const size_t initial_klass_list_size = 4096;\n-const int initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_set_size = 4096;\n+static unsigned initial_klass_loader_set_size = 64;\n+static unsigned initial_klass_loader_leakp_set_size = 64;\n@@ -43,1 +48,1 @@\n-void JfrArtifactSet::initialize(bool class_unload) {\n+void JfrArtifactSet::initialize(bool class_unload, bool previous_epoch) {\n@@ -53,3 +58,5 @@\n-  _klass_loader_leakp_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_loader_set = new GrowableArray<const Klass*>(initial_klass_loader_set_size);\n-  _klass_list = new GrowableArray<const Klass*>(initial_klass_list_size);\n+  if (previous_epoch) {\n+    _klass_loader_leakp_set = new JfrKlassSet(initial_klass_loader_leakp_set_size);\n+  }\n+  _klass_loader_set = new JfrKlassSet(initial_klass_loader_set_size);\n+  _klass_set = new JfrKlassSet(initial_klass_set_size);\n@@ -96,5 +103,1 @@\n-  return _klass_list->is_nonempty();\n-}\n-\n-int JfrArtifactSet::entries() const {\n-  return _klass_list->length();\n+  return _klass_set->is_nonempty();\n@@ -102,2 +105,1 @@\n-\n-static inline bool not_in_set(GrowableArray<const Klass*>* set, const Klass* k) {\n+static inline bool not_in_set(JfrArtifactSet::JfrKlassSet* set, const Klass* k) {\n@@ -106,1 +108,1 @@\n-  return !JfrMutablePredicate<const Klass*, compare_klasses>::test(set, k);\n+  return set->add(k);\n@@ -119,2 +121,2 @@\n-  assert(_klass_list != nullptr, \"invariant\");\n-  _klass_list->append(k);\n+  assert(_klass_set != nullptr, \"invariant\");\n+  _klass_set->add(k);\n@@ -124,0 +126,4 @@\n+  assert(_klass_set != nullptr, \"invariant\");\n+  initial_klass_set_size = MAX2(initial_klass_set_size, _klass_set->table_size());\n+  assert(_klass_loader_set != nullptr, \"invariant\");\n+  initial_klass_loader_set_size = MAX2(initial_klass_loader_set_size, _klass_loader_set->table_size());\n@@ -130,0 +136,2 @@\n+  assert(_klass_loader_leakp_set != nullptr, \"invariant\");\n+  initial_klass_loader_leakp_set_size = MAX2(initial_klass_loader_leakp_set_size, _klass_loader_leakp_set->table_size());\n@@ -131,1 +139,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":30,"deletions":23,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"jfr\/utilities\/jfrSet.hpp\"\n@@ -34,3 +35,0 @@\n-template <typename T>\n-class GrowableArray;\n-\n@@ -138,21 +136,0 @@\n-class KlassUsedPredicate {\n-  bool _current_epoch;\n- public:\n-  KlassUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n-class MethodUsedPredicate {\n-  bool _current_epoch;\n-public:\n-  MethodUsedPredicate(bool current_epoch) : _current_epoch(current_epoch) {}\n-  bool operator()(const Klass* klass) {\n-    if (!klass->is_instance_klass()) {\n-      return false;\n-    }\n-    return _current_epoch ? USED_THIS_EPOCH(klass) : USED_PREVIOUS_EPOCH(klass);\n-  }\n-};\n-\n@@ -206,0 +183,26 @@\n+ public:\n+  class JfrArtifactSetConfig : public AllStatic {\n+   public:\n+    typedef const Klass* KEY_TYPE;\n+\n+    constexpr static AnyObj::allocation_type alloc_type() {\n+      return AnyObj::RESOURCE_AREA;\n+    }\n+\n+    constexpr static MemTag memory_tag() {\n+      return mtInternal;\n+    }\n+\n+    \/\/ Knuth multiplicative hashing.\n+    static uint32_t hash(const KEY_TYPE& k) {\n+      const uint32_t v = static_cast<uint32_t>(JfrTraceId::load_raw(k));\n+      return v * UINT32_C(2654435761);\n+    }\n+\n+    static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n+      return lhs == rhs;\n+    }\n+  };\n+\n+  typedef JfrSet<JfrArtifactSetConfig> JfrKlassSet;\n+\n@@ -208,3 +211,3 @@\n-  GrowableArray<const Klass*>* _klass_list;\n-  GrowableArray<const Klass*>* _klass_loader_set;\n-  GrowableArray<const Klass*>* _klass_loader_leakp_set;\n+  JfrKlassSet* _klass_set;\n+  JfrKlassSet* _klass_loader_set;\n+  JfrKlassSet* _klass_loader_leakp_set;\n@@ -215,1 +218,1 @@\n-  JfrArtifactSet(bool class_unload);\n+  JfrArtifactSet(bool class_unload, bool previous_epoch);\n@@ -219,1 +222,1 @@\n-  void initialize(bool class_unload);\n+  void initialize(bool class_unload, bool previous_epoch);\n@@ -234,1 +237,0 @@\n-  int entries() const;\n@@ -257,1 +259,1 @@\n-    if (iterate(functor, _klass_list)) {\n+    if (iterate(functor, _klass_set)) {\n@@ -264,6 +266,4 @@\n-  bool iterate(Functor& functor, GrowableArray<const Klass*>* list) const {\n-    assert(list != nullptr, \"invariant\");\n-    for (int i = 0; i < list->length(); ++i) {\n-      if (!functor(list->at(i))) {\n-        return false;\n-      }\n+  bool iterate(Functor& functor, JfrKlassSet* set) const {\n+    assert(set != nullptr, \"invariant\");\n+    if (set->is_nonempty()) {\n+      set->iterate(functor);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -31,0 +30,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrEventSetting.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -43,1 +43,0 @@\n-#include \"jfr\/recorder\/storage\/jfrStorage.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"jfr\/recorder\/storage\/jfrStorage.hpp\"\n@@ -52,1 +52,0 @@\n-#include \"runtime\/handles.inline.hpp\"\n@@ -54,0 +53,1 @@\n+#include \"runtime\/handles.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -29,0 +30,2 @@\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,3 +40,38 @@\n-static JfrEventThrottler* _disabled_cpu_time_sample_throttler = nullptr;\n-static JfrEventThrottler* _object_allocation_throttler = nullptr;\n-static JfrEventThrottler* _safepoint_latency_throttler = nullptr;\n+constexpr static const JfrEventId throttleble_events[] = {\n+    JfrCPUTimeSampleEvent, JfrObjectAllocationSampleEvent,  JfrSafepointLatencyEvent\n+};\n+constexpr static int num_throttled_events = sizeof(throttleble_events) \/ sizeof(throttleble_events[0]);\n+\n+\/\/ Throttler-by-ID lookup table\n+class ThrottlerLookupTable {\n+  static constexpr int max = (int)LAST_EVENT_ID;\n+  STATIC_ASSERT(max < 1000); \/\/ should this ever get unreasonably large, we rethink this table.\n+  JfrEventThrottler* _table[max];\n+public:\n+  ThrottlerLookupTable() { memset(_table, 0, sizeof(_table)); }\n+\n+  bool initialize() {\n+    for (int i = 0; i < num_throttled_events; i++) {\n+      const JfrEventId id = throttleble_events[i];\n+      JfrEventThrottler* p = JfrEventThrottler::create_throttler(id);\n+      _table[(int)id] = p;\n+      if (p == nullptr) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  void destroy() {\n+    for (int i = 0; i < max; i++) {\n+      delete _table[i];\n+      _table[i] = nullptr;\n+    }\n+  }\n+\n+  JfrEventThrottler* at(JfrEventId id) const {\n+    return _table[(int)id];\n+  }\n+};\n+\n+static ThrottlerLookupTable _throttler_table;\n@@ -52,7 +90,3 @@\n-  assert(_disabled_cpu_time_sample_throttler == nullptr, \"invariant\");\n-  _disabled_cpu_time_sample_throttler = new JfrEventThrottler(JfrCPUTimeSampleEvent);\n-  _disabled_cpu_time_sample_throttler->_disabled = true;\n-  assert(_object_allocation_throttler == nullptr, \"invariant\");\n-  _object_allocation_throttler = new JfrEventThrottler(JfrObjectAllocationSampleEvent);\n-  if (_object_allocation_throttler == nullptr || !_object_allocation_throttler->initialize()) {\n-    return false;\n+  bool rc = _throttler_table.initialize();\n+  if (rc) {\n+    _throttler_table.at(JfrCPUTimeSampleEvent)->_disabled = true; \/\/ CPU time sampler disabled\n@@ -60,3 +94,1 @@\n-  assert(_safepoint_latency_throttler == nullptr, \"invariant\");\n-  _safepoint_latency_throttler = new JfrEventThrottler(JfrSafepointLatencyEvent);\n-  return _safepoint_latency_throttler != nullptr && _safepoint_latency_throttler->initialize();\n+  return rc;\n@@ -66,6 +98,1 @@\n-  delete _disabled_cpu_time_sample_throttler;\n-  _disabled_cpu_time_sample_throttler = nullptr;\n-  delete _object_allocation_throttler;\n-  _object_allocation_throttler = nullptr;\n-  delete _safepoint_latency_throttler;\n-  _safepoint_latency_throttler = nullptr;\n+  _throttler_table.destroy();\n@@ -74,3 +101,0 @@\n-\/\/ There is currently only two throttler instances, one for the jdk.ObjectAllocationSample event\n-\/\/ and another for the SamplingLatency event.\n-\/\/ When introducing many more throttlers, consider adding a lookup map keyed by event id.\n@@ -78,14 +102,3 @@\n-  assert(_disabled_cpu_time_sample_throttler != nullptr, \"Disabled CPU time throttler has not been properly initialized\");\n-  assert(_object_allocation_throttler != nullptr, \"ObjectAllocation throttler has not been properly initialized\");\n-  assert(_safepoint_latency_throttler != nullptr, \"SafepointLatency throttler has not been properly initialized\");\n-  assert(event_id == JfrObjectAllocationSampleEvent || event_id == JfrSafepointLatencyEvent || event_id == JfrCPUTimeSampleEvent, \"Event type has an unconfigured throttler\");\n-  if (event_id == JfrObjectAllocationSampleEvent) {\n-    return _object_allocation_throttler;\n-  }\n-  if (event_id == JfrSafepointLatencyEvent) {\n-    return _safepoint_latency_throttler;\n-  }\n-  if (event_id == JfrCPUTimeSampleEvent) {\n-    return _disabled_cpu_time_sample_throttler;\n-  }\n-  return nullptr;\n+  JfrEventThrottler* const throttler = _throttler_table.at(event_id);\n+  assert(throttler != nullptr, \"Event type %d has an unconfigured throttler\", (int)event_id);\n+  return throttler;\n@@ -95,8 +108,10 @@\n-  if (event_id == JfrObjectAllocationSampleEvent) {\n-    assert(_object_allocation_throttler != nullptr, \"ObjectAllocation throttler has not been properly initialized\");\n-    _object_allocation_throttler->configure(sample_size, period_ms);\n-    return;\n-  }\n-  if (event_id == JfrSafepointLatencyEvent) {\n-    assert(_safepoint_latency_throttler != nullptr, \"SafepointLatency throttler has not been properly initialized\");\n-    _safepoint_latency_throttler->configure(sample_size, period_ms);\n+  JfrEventThrottler* const throttler = _throttler_table.at(event_id);\n+  assert(throttler != nullptr, \"Event type %d has an unconfigured throttler\", (int)event_id);\n+  throttler->configure(sample_size, period_ms);\n+}\n+\n+JfrEventThrottler* JfrEventThrottler::create_throttler(JfrEventId id) {\n+  JfrEventThrottler* p = new JfrEventThrottler(id);\n+  if (p != nullptr && p->initialize() == false) {\n+    delete p;\n+    p = nullptr;\n@@ -104,0 +119,1 @@\n+  return p;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":60,"deletions":44,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -31,0 +30,3 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n+\n+class ThrottlerLookupTable;\n@@ -34,0 +36,1 @@\n+  friend class ThrottlerLookupTable;\n@@ -46,0 +49,1 @@\n+  static JfrEventThrottler* create_throttler(JfrEventId event_id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfrfiles\/jfrEventClasses.hpp\"\n@@ -27,1 +26,0 @@\n-#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -29,0 +27,1 @@\n+#include \"jfr\/leakprofiler\/leakProfiler.hpp\"\n@@ -30,1 +29,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -33,0 +31,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -46,1 +45,0 @@\n-#include \"jfr\/writers\/jfrJavaEventWriter.hpp\"\n@@ -48,0 +46,2 @@\n+#include \"jfr\/writers\/jfrJavaEventWriter.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n@@ -370,0 +370,1 @@\n+  size_t _elements;\n@@ -371,1 +372,1 @@\n-  MetadataEvent(JfrChunkWriter& cw) : _cw(cw) {}\n+  MetadataEvent(JfrChunkWriter& cw) : _cw(cw), _elements(0) {}\n@@ -373,1 +374,1 @@\n-    JfrMetadataEvent::write(_cw);\n+    _elements = JfrMetadataEvent::write(_cw);\n@@ -376,1 +377,1 @@\n-  size_t elements() const { return 1; }\n+  size_t elements() const { return _elements; }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"utilities\/preserveException.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"utilities\/preserveException.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThreadLoop.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -30,0 +29,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/recorder\/storage\/jfrBuffer.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"jfr\/recorder\/storage\/jfrBuffer.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorageUtils.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPoolWriter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAdaptiveSampler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationElementIterator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -29,2 +28,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n-#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n@@ -33,0 +30,2 @@\n+#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -52,1 +52,0 @@\n-\/\/ for strstr\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jfr\/recorder\/storage\/jfrStorage.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"jfr\/recorder\/storage\/jfrStorage.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrFlush.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-static const int initial_size = 1009;\n+static const int initial_size = 1024;\n@@ -36,1 +36,1 @@\n-  return new JfrCHeapTraceIdSet(size);\n+  return new (mtTracing) JfrCHeapTraceIdSet(size);\n@@ -71,7 +71,0 @@\n-static bool is_nonempty_set(u1 epoch) {\n-  if (epoch == 0) {\n-    return _unload_set_epoch_0 != nullptr && _unload_set_epoch_0->is_nonempty();\n-  }\n-  return _unload_set_epoch_1 != nullptr && _unload_set_epoch_1->is_nonempty();\n-}\n-\n@@ -80,3 +73,1 @@\n-  if (is_nonempty_set(JfrTraceIdEpoch::previous())) {\n-    get_unload_set_previous_epoch()->clear();\n-  }\n+  get_unload_set_previous_epoch()->clear();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -45,1 +45,0 @@\n- \/\/ for strstr\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrResolution.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"jfrfiles\/jfrEventIds.hpp\"\n@@ -31,0 +29,2 @@\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n+#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrStackTraceMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"jni.h\"\n-#include \"memory\/iterator.hpp\"\n@@ -33,0 +31,2 @@\n+#include \"jni.h\"\n+#include \"memory\/iterator.hpp\"\n@@ -43,1 +43,1 @@\n-         bool (*EQUALS)(K const&, K const&)> class ResizeableResourceHashtable;\n+         bool (*EQUALS)(K const&, K const&)> class ResizeableHashTable;\n@@ -51,1 +51,1 @@\n-typedef ResizeableResourceHashtable<traceid, jclass,\n+typedef ResizeableHashTable<traceid, jclass,\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -30,0 +29,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -30,0 +29,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilterManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -32,0 +31,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrEpochQueue.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/utilities\/jfrAllocation.hpp\"\n@@ -30,1 +29,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -32,2 +31,2 @@\n-template <typename AllocPolicy = JfrCHeapObj, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n-class ConfigTraceID : public AllStatic {\n+template <typename K, AnyObj::allocation_type AllocType = AnyObj::C_HEAP, MemTag memtag = mtTracing>\n+class JfrSetConfig : public AllStatic {\n@@ -35,2 +34,1 @@\n-  typedef AllocPolicy STORAGE;\n-  typedef traceid TYPE;\n+  typedef K KEY_TYPE;\n@@ -47,3 +45,3 @@\n-  static uint32_t hash(const TYPE& id) {\n-    const uint32_t v = static_cast<uint32_t>(id);\n-    return v * UINT32_C(2654435761);\n+  static uint32_t hash(const KEY_TYPE& key) {\n+    const uint32_t k = static_cast<uint32_t>(key);\n+    return k * UINT32_C(2654435761);\n@@ -52,1 +50,1 @@\n-  static bool cmp(const TYPE& lhs, const TYPE& rhs) {\n+  static bool cmp(const KEY_TYPE& lhs, const KEY_TYPE& rhs) {\n@@ -57,2 +55,0 @@\n-constexpr static unsigned int MAX_TABLE_SIZE = 0x3fffffff;\n-\n@@ -60,7 +56,16 @@\n-class JfrSet : public CONFIG::STORAGE {\n- public:\n-  typedef typename CONFIG::TYPE TYPE;\n-  typedef ResizeableResourceHashtable<TYPE, TYPE, CONFIG::alloc_type(), CONFIG::memory_tag(), CONFIG::hash, CONFIG::cmp> HashMap;\n-\n-  constexpr static bool is_cheap() {\n-    return CONFIG::alloc_type() == AnyObj::C_HEAP;\n+class JfrSetStorage : public AnyObj {\n+  typedef typename CONFIG::KEY_TYPE K;\n+ protected:\n+  K* _table;\n+  unsigned _table_size;\n+  unsigned _elements;\n+\n+  static K* alloc_table(unsigned table_size) {\n+    K* table;\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(K, table_size, CONFIG::memory_tag());\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(K, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(K));\n+    return table;\n@@ -69,2 +74,4 @@\n-  JfrSet(unsigned int initial_size, unsigned int max_size = MAX_TABLE_SIZE) :\n-    _map(is_cheap() ? new (CONFIG::memory_tag()) HashMap(initial_size, max_size) : new HashMap(initial_size, max_size)) {}\n+  JfrSetStorage(unsigned table_size) :\n+    _table(alloc_table(table_size)),\n+    _table_size(table_size),\n+    _elements(0) {}\n@@ -72,3 +79,3 @@\n-  ~JfrSet() {\n-    if (is_cheap()) {\n-      delete _map;\n+  ~JfrSetStorage() {\n+    if (CONFIG::alloc_type() == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, _table);\n@@ -78,4 +85,10 @@\n-  bool add(const TYPE& k) {\n-    bool inserted;\n-    _map->put_if_absent(k, &inserted);\n-    return inserted;\n+ public:\n+  template <typename Functor>\n+  void iterate(Functor& functor) {\n+    assert(is_nonempty(), \"invariant\");\n+    for (unsigned i = 0; i < _table_size; ++i) {\n+      K k = _table[i];\n+      if (k != 0) {\n+        functor(k);\n+      }\n+    }\n@@ -84,2 +97,2 @@\n-  bool remove(const TYPE& k) {\n-    return _map->remove(k);\n+  unsigned table_size() const {\n+    return _table_size;\n@@ -88,2 +101,2 @@\n-  bool contains(const TYPE& k) const {\n-    return _map->contains(k);\n+  unsigned size() const {\n+    return _elements;\n@@ -92,2 +105,2 @@\n-  bool is_empty() const {\n-    return _map->number_of_entries() == 0;\n+  bool is_nonempty() const {\n+    return _elements > 0;\n@@ -96,2 +109,2 @@\n-  bool is_nonempty() const {\n-    return !is_empty();\n+  void clear() {\n+    memset(_table, 0, _table_size * sizeof(K));\n@@ -99,0 +112,1 @@\n+};\n@@ -100,2 +114,11 @@\n-  int size() const {\n-    return _map->number_of_entries();\n+template <typename CONFIG>\n+class JfrSet : public JfrSetStorage<CONFIG> {\n+  typedef typename CONFIG::KEY_TYPE K;\n+  static_assert(sizeof(K) > 1, \"invalid size of CONFIG::KEY_TYPE\");\n+ private:\n+  static const constexpr unsigned max_initial_size = 1 << 30;\n+  unsigned _table_mask;\n+  unsigned _resize_threshold; \/\/ 0.5 load factor\n+\n+  uint32_t slot_idx(const uint32_t hash) const {\n+    return hash & _table_mask;\n@@ -104,3 +127,23 @@\n-  void clear() {\n-    if (is_nonempty()) {\n-      _map->unlink(this);\n+  void resize() {\n+    assert(this->_elements == _resize_threshold, \"invariant\");\n+    K* const old_table = this->_table;\n+    assert(old_table != nullptr, \"invariant\");\n+    const unsigned old_table_size = this->table_size();\n+    guarantee(old_table_size <= max_initial_size, \"overflow\");\n+    this->_table_size = old_table_size << 1;\n+    this->_table = JfrSetStorage<CONFIG>::alloc_table(this->_table_size);\n+    _table_mask = this->_table_size - 1;\n+    _resize_threshold = old_table_size;\n+    for (unsigned i = 0; i < old_table_size; ++i) {\n+      const K k = old_table[i];\n+      if (k != 0) {\n+        uint32_t idx = slot_idx(CONFIG::hash(k));\n+        do {\n+          K v = this->_table[idx];\n+          if (v == 0) {\n+            this->_table[idx] = k;\n+            break;\n+          }\n+          idx = slot_idx(idx + 1);\n+        } while (true);\n+      }\n@@ -108,1 +151,5 @@\n-    assert(is_empty(), \"invariant\");\n+    if (CONFIG::alloc_type() == AnyObj::C_HEAP) {\n+      FREE_C_HEAP_ARRAY(K, old_table);\n+    }\n+    assert(_table_mask + 1 == this->_table_size, \"invariant\");\n+    assert(_resize_threshold << 1 == this->_table_size, \"invariant\");\n@@ -111,3 +158,18 @@\n-  \/\/ Callback for node deletion, used by clear().\n-  bool do_entry(const TYPE& k, const TYPE& v) {\n-    return true;\n+  K* find_slot(K const& k) const {\n+    uint32_t idx = slot_idx(CONFIG::hash(k));\n+    assert(idx < this->table_size(), \"invariant\");\n+    K* result = nullptr;\n+    while (true) {\n+      K v = this->_table[idx];\n+      if (v == 0) {\n+        result = &this->_table[idx];\n+        break;\n+      }\n+      if (CONFIG::cmp(v, k)) {\n+        result = reinterpret_cast<K*>(p2i(&this->_table[idx]) | 1);\n+        break;\n+      }\n+      idx = slot_idx(idx + 1);\n+    }\n+    assert(result != nullptr, \"invariant\");\n+    return result;\n@@ -116,2 +178,29 @@\n- private:\n-  HashMap* _map;\n+ public:\n+  JfrSet(unsigned size) :\n+    JfrSetStorage<CONFIG>(size),\n+    _table_mask(size - 1),\n+    _resize_threshold(size >> 1) {\n+    assert(size >= 2, \"invariant\");\n+    assert(size % 2 == 0, \"invariant\");\n+    assert(size <= max_initial_size, \"avoid overflow in resize\");\n+  }\n+\n+  bool contains(K const& k) const {\n+    K* const slot = find_slot(k);\n+    return p2i(slot) & 1;\n+  }\n+\n+  bool add(K const& k) {\n+    K* const slot = find_slot(k);\n+    if (p2i(slot) & 1) {\n+      \/\/ Already exists.\n+      return false;\n+    }\n+    assert(*slot == 0, \"invariant\");\n+    *slot = k;\n+    if (++this->_elements == _resize_threshold) {\n+      resize();\n+    }\n+    assert(this->_elements < _resize_threshold, \"invariant\");\n+    return true;\n+  }\n@@ -120,2 +209,2 @@\n-typedef JfrSet<ConfigTraceID<> > JfrCHeapTraceIdSet;\n-typedef JfrSet<ConfigTraceID<ResourceObj, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid> > JfrCHeapTraceIdSet;\n+typedef JfrSet<JfrSetConfig<traceid, AnyObj::RESOURCE_AREA> > JfrResourceAreaTraceIdSet;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSet.hpp","additions":138,"deletions":49,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n@@ -27,0 +26,1 @@\n+#include \"jfr\/utilities\/jfrTimeConverter.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTimeConverter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/orderAccess.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"runtime\/orderAccess.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTryLock.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n@@ -30,0 +29,2 @@\n+\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrStreamWriterHost.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2015,1 +2015,1 @@\n-    Klass* k = iklass->local_interfaces()->at(index);\n+    InstanceKlass* k = iklass->local_interfaces()->at(index);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -440,2 +440,2 @@\n-  ResourceHashtable<jlong, JVMCIObject> longs;\n-  ResourceHashtable<const char*, JVMCIObject,\n+  HashTable<jlong, JVMCIObject> longs;\n+  HashTable<const char*, JVMCIObject,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -937,1 +937,1 @@\n-  os::vsnprintf(msg, max_msg_size, format, ap);\n+  (void) os::vsnprintf(msg, max_msg_size, format, ap);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -568,2 +568,2 @@\n-  } else if (oopDesc::is_oop_or_null(obj, true) && (!as_string || !java_lang_String::is_instance(obj))) {\n-    if (oopDesc::is_oop_or_null(obj, true)) {\n+  } else if (oopDesc::is_oop_or_null(obj) && (!as_string || !java_lang_String::is_instance(obj))) {\n+    if (oopDesc::is_oop_or_null(obj)) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -344,1 +344,0 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _stack_locker,                                 BasicLock*)                            \\\n@@ -783,4 +782,0 @@\n-  declare_constant(LockingMode::LM_MONITOR)                               \\\n-  declare_constant(LockingMode::LM_LEGACY)                                \\\n-  declare_constant(LockingMode::LM_LIGHTWEIGHT)                           \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"logging\/logTagSet.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"logging\/logTagSet.hpp\"\n","filename":"src\/hotspot\/share\/logging\/log.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/os.inline.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -35,1 +35,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -69,1 +69,1 @@\n-  using AsyncLogMap = ResourceHashtable<LogFileStreamOutput*,\n+  using AsyncLogMap = HashTable<LogFileStreamOutput*,\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -29,0 +28,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"utilities\/stringUtils.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n","filename":"src\/hotspot\/share\/logging\/logTag.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -69,2 +68,2 @@\n-void* MetaspaceObj::_shared_metaspace_base = nullptr;\n-void* MetaspaceObj::_shared_metaspace_top  = nullptr;\n+void* MetaspaceObj::_aot_metaspace_base = nullptr;\n+void* MetaspaceObj::_aot_metaspace_top  = nullptr;\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  \/\/ When CDS is enabled, all shared metaspace objects are mapped\n+  \/\/ All metsapce objects in the AOT cache (CDS archive) are mapped\n@@ -266,5 +266,5 @@\n-  \/\/ two pointers to quickly determine if something is in the\n-  \/\/ shared metaspace.\n-  \/\/ When CDS is not enabled, both pointers are set to null.\n-  static void* _shared_metaspace_base;  \/\/ (inclusive) low address\n-  static void* _shared_metaspace_top;   \/\/ (exclusive) high address\n+  \/\/ two pointers to quickly determine if a MetaspaceObj is in the\n+  \/\/ AOT cache.\n+  \/\/ When AOT\/CDS is not enabled, both pointers are set to null.\n+  static void* _aot_metaspace_base;  \/\/ (inclusive) low address\n+  static void* _aot_metaspace_top;   \/\/ (exclusive) high address\n@@ -276,1 +276,1 @@\n-  \/\/ non-shared or shared metaspace.\n+  \/\/ regular- or aot metaspace.\n@@ -280,2 +280,2 @@\n-  static bool is_shared(const MetaspaceObj* p) {\n-    \/\/ If no shared metaspace regions are mapped, _shared_metaspace_{base,top} will\n+  static bool in_aot_cache(const MetaspaceObj* p) {\n+    \/\/ If no shared metaspace regions are mapped, _aot_metaspace_{base,top} will\n@@ -283,2 +283,2 @@\n-    return (((void*)p) < _shared_metaspace_top &&\n-            ((void*)p) >= _shared_metaspace_base);\n+    return (((void*)p) < _aot_metaspace_top &&\n+            ((void*)p) >= _aot_metaspace_base);\n@@ -286,1 +286,1 @@\n-  bool is_shared() const { return MetaspaceObj::is_shared(this); }\n+  bool in_aot_cache() const { return MetaspaceObj::in_aot_cache(this); }\n@@ -288,2 +288,2 @@\n-  static bool is_shared(const MetaspaceObj* p) { return false; }\n-  bool is_shared() const { return false; }\n+  static bool in_aot_cache(const MetaspaceObj* p) { return false; }\n+  bool in_aot_cache() const { return false; }\n@@ -294,3 +294,3 @@\n-  static void set_shared_metaspace_range(void* base, void* top) {\n-    _shared_metaspace_base = base;\n-    _shared_metaspace_top = top;\n+  static void set_aot_metaspace_range(void* base, void* top) {\n+    _aot_metaspace_base = base;\n+    _aot_metaspace_top = top;\n@@ -299,2 +299,2 @@\n-  static void* shared_metaspace_base() { return _shared_metaspace_base; }\n-  static void* shared_metaspace_top()  { return _shared_metaspace_top;  }\n+  static void* aot_metaspace_base() { return _aot_metaspace_base; }\n+  static void* aot_metaspace_top()  { return _aot_metaspace_top;  }\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/metaspaceUtils.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"memory\/metaspaceUtils.hpp\"\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -367,0 +367,1 @@\n+        assert(cie->klass()->is_instance_klass(), \"elements array contains only instance klasses\");\n@@ -405,1 +406,1 @@\n-  Klass* super = ((InstanceKlass*)cie->klass())->java_super();\n+  InstanceKlass* super = InstanceKlass::cast(cie->klass())->super();\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/annotations.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"oops\/annotations.hpp\"\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/klass.hpp\"\n+#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n@@ -38,1 +38,0 @@\n-#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"oops\/klass.hpp\"\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/memory\/memRegion.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+                                             size_t page_size,\n@@ -118,1 +119,1 @@\n-    return ReservedSpace(base, size, alignment, os::vm_page_size(), exec, false \/* special *\/);\n+    return ReservedSpace(base, size, alignment, page_size, exec, false \/* special *\/);\n@@ -191,1 +192,1 @@\n-  return reserve_memory(requested_address, size, alignment, executable, mem_tag);\n+  return reserve_memory(requested_address, size, alignment, page_size, executable, mem_tag);\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+                                      size_t page_size,\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+\n@@ -61,1 +62,1 @@\n-      assert(!data->is_shared(), \"cannot deallocate array in shared spaces\");\n+      assert(!data->in_aot_cache(), \"cannot deallocate array in aot metaspace spaces\");\n@@ -75,1 +76,1 @@\n-      assert(!md->is_shared(), \"cannot deallocate if in shared spaces\");\n+      assert(!md->in_aot_cache(), \"cannot deallocate if in aot metaspace spaces\");\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -724,1 +724,1 @@\n-    MetaspaceShared::initialize_for_static_dump();\n+    AOTMetaspace::initialize_for_static_dump();\n@@ -743,1 +743,1 @@\n-    MetaspaceShared::initialize_runtime_shared_and_meta_spaces();\n+    AOTMetaspace::initialize_runtime_shared_and_meta_spaces();\n@@ -856,1 +856,1 @@\n-      CDS_ONLY(MetaspaceShared::print_on(&ls);)\n+      CDS_ONLY(AOTMetaspace::print_on(&ls);)\n@@ -1039,2 +1039,2 @@\n-bool Metaspace::is_in_shared_metaspace(const void* ptr) {\n-  return MetaspaceShared::is_in_shared_metaspace(ptr);\n+bool Metaspace::in_aot_cache(const void* ptr) {\n+  return AOTMetaspace::in_aot_cache(ptr);\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-class MetaspaceShared;\n+class AOTMetaspace;\n@@ -46,1 +46,1 @@\n-  friend class MetaspaceShared;\n+  friend class AOTMetaspace;\n@@ -133,1 +133,1 @@\n-    return is_in_shared_metaspace(ptr) || \/\/ in cds\n+    return in_aot_cache(ptr) || \/\/ in cds\n@@ -145,1 +145,1 @@\n-  static bool is_in_shared_metaspace(const void* ptr);\n+  static bool in_aot_cache(const void* ptr);\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"memory\/metaspace\/chunklevel.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"memory\/metaspace\/chunklevel.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n+\n@@ -32,1 +32,0 @@\n-#include \"utilities\/ostream.hpp\"\n@@ -34,0 +33,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metablock.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    if (k->is_shared()) {\n+    if (k->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/memory\/metaspace\/printCLDMetaspaceInfoClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  \/\/ Print a 's' for shared classes\n-  _out->put(k->is_shared() ? 's': ' ');\n+  \/\/ Print a 's' for classes in the aot metaspace (used to be called shared classes)\n+  _out->put(k->in_aot_cache() ? 's': ' ');\n","filename":"src\/hotspot\/share\/memory\/metaspace\/printMetaspaceInfoKlassClosure.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"memory\/metaspace\/metaspaceContext.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"memory\/metaspace\/metaspaceContext.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n+\n@@ -377,1 +378,1 @@\n-  ResizeableResourceHashtable<address, bool, AnyObj::C_HEAP,\n+  ResizeableHashTable<address, bool, AnyObj::C_HEAP,\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-  assert(Universe::objectArrayKlass() != nullptr, \"Too early?\");\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/resourceArea.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -84,0 +84,1 @@\n+#include \"services\/cpuTimeUsage.hpp\"\n@@ -89,0 +90,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -879,1 +881,1 @@\n-  MetaspaceShared::adjust_heap_sizes_for_dumping();\n+  AOTMetaspace::adjust_heap_sizes_for_dumping();\n@@ -905,1 +907,1 @@\n-    MetaspaceShared::initialize_shared_spaces();\n+    AOTMetaspace::initialize_shared_spaces();\n@@ -1162,1 +1164,1 @@\n-  MetaspaceShared::post_initialize(CHECK_false);\n+  AOTMetaspace::post_initialize(CHECK_false);\n@@ -1303,0 +1305,57 @@\n+static void log_cpu_time() {\n+  LogTarget(Info, cpu) cpuLog;\n+  if (!cpuLog.is_enabled()) {\n+    return;\n+  }\n+\n+  const double process_cpu_time = os::elapsed_process_cpu_time();\n+  if (process_cpu_time == 0 || process_cpu_time == -1) {\n+    \/\/ 0 can happen e.g. for short running processes with\n+    \/\/ low CPU utilization\n+    return;\n+  }\n+\n+  const double gc_threads_cpu_time = (double) CPUTimeUsage::GC::gc_threads() \/ NANOSECS_PER_SEC;\n+  const double gc_vm_thread_cpu_time = (double) CPUTimeUsage::GC::vm_thread() \/ NANOSECS_PER_SEC;\n+  const double gc_string_dedup_cpu_time = (double) CPUTimeUsage::GC::stringdedup() \/ NANOSECS_PER_SEC;\n+  const double gc_cpu_time = (double) gc_threads_cpu_time + gc_vm_thread_cpu_time + gc_string_dedup_cpu_time;\n+\n+  const double elasped_time = os::elapsedTime();\n+  const bool has_error = CPUTimeUsage::Error::has_error();\n+\n+  if (gc_cpu_time < process_cpu_time) {\n+    cpuLog.print(\"=== CPU time Statistics =============================================================\");\n+    if (has_error) {\n+      cpuLog.print(\"WARNING: CPU time sampling reported errors, numbers may be unreliable\");\n+    }\n+    cpuLog.print(\"                                                                            CPUs\");\n+    cpuLog.print(\"                                                               s       %%  utilized\");\n+    cpuLog.print(\"   Process\");\n+    cpuLog.print(\"     Total                        %30.4f  %6.2f  %8.1f\", process_cpu_time, 100.0, process_cpu_time \/ elasped_time);\n+    cpuLog.print(\"     Garbage Collection           %30.4f  %6.2f  %8.1f\", gc_cpu_time, percent_of(gc_cpu_time, process_cpu_time), gc_cpu_time \/ elasped_time);\n+    cpuLog.print(\"       GC Threads                 %30.4f  %6.2f  %8.1f\", gc_threads_cpu_time, percent_of(gc_threads_cpu_time, process_cpu_time), gc_threads_cpu_time \/ elasped_time);\n+    cpuLog.print(\"       VM Thread                  %30.4f  %6.2f  %8.1f\", gc_vm_thread_cpu_time, percent_of(gc_vm_thread_cpu_time, process_cpu_time), gc_vm_thread_cpu_time \/ elasped_time);\n+\n+    if (UseStringDeduplication) {\n+      cpuLog.print(\"       String Deduplication       %30.4f  %6.2f  %8.1f\", gc_string_dedup_cpu_time, percent_of(gc_string_dedup_cpu_time, process_cpu_time), gc_string_dedup_cpu_time \/ elasped_time);\n+    }\n+    cpuLog.print(\"=====================================================================================\");\n+  }\n+}\n+\n+void Universe::before_exit() {\n+  log_cpu_time();\n+  heap()->before_exit();\n+\n+  \/\/ Print GC\/heap related information.\n+  Log(gc, exit) log;\n+  if (log.is_info()) {\n+    LogStream ls_info(log.info());\n+    Universe::print_on(&ls_info);\n+    if (log.is_trace()) {\n+      LogStream ls_trace(log.trace());\n+      MutexLocker mcld(ClassLoaderDataGraph_lock);\n+      ClassLoaderDataGraph::print_on(&ls_trace);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":63,"deletions":4,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  friend class MetaspaceShared;\n+  friend class AOTMetaspace;\n@@ -188,1 +188,5 @@\n-  static ObjArrayKlass* objectArrayKlass()       { return _objectArrayKlass; }\n+  static ObjArrayKlass* objectArrayKlass() {\n+    ObjArrayKlass* k = _objectArrayKlass;\n+    assert(k != nullptr, \"Object array klass should be initialized; too early?\");\n+    return k;\n+  }\n@@ -190,1 +194,5 @@\n-  static Klass* fillerArrayKlass()               { return _fillerArrayKlass; }\n+  static Klass* fillerArrayKlass() {\n+    Klass* k = _fillerArrayKlass;\n+    assert(k != nullptr, \"Filler array class should be initialized; too early?\");\n+    return k;\n+  }\n@@ -195,2 +203,3 @@\n-    assert(_typeArrayKlasses[t] != nullptr, \"domain check\");\n-    return _typeArrayKlasses[t];\n+    TypeArrayKlass* k = _typeArrayKlasses[t];\n+    assert(k != nullptr, \"Type array class should be initialized; too early?\");\n+    return k;\n@@ -299,0 +308,2 @@\n+  static void before_exit();\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/arrayWithFreeList.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/java.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -32,1 +32,0 @@\n-#include \"utilities\/parseInteger.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n@@ -64,1 +64,1 @@\n-  bool match_mode_flag(MallocLimitMode* out) {\n+  bool match_mode(MallocLimitMode* out) {\n@@ -80,1 +80,1 @@\n-  \/\/ Check if string at position matches a category name.\n+  \/\/ Check if string at position matches a MemTag name.\n@@ -82,1 +82,1 @@\n-  bool match_category(MemTag* out) {\n+  bool match_mem_tag(MemTag* out) {\n@@ -133,1 +133,1 @@\n-void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode flag) {\n+void MallocLimitSet::set_category_limit(MemTag mem_tag, size_t s, MallocLimitMode mode) {\n@@ -135,1 +135,1 @@\n-  _cat[i].sz = s; _cat[i].mode = flag;\n+  _mtag[i].sz = s; _mtag[i].mode = mode;\n@@ -147,1 +147,0 @@\n-  static const char* flagnames[] = { MODE_FATAL, MODE_OOM };\n@@ -153,1 +152,1 @@\n-      if (_cat[i].sz > 0) {\n+      if (_mtag[i].sz > 0) {\n@@ -156,1 +155,1 @@\n-                     PROPERFMTARGS(_cat[i].sz), mode_to_name(_cat[i].mode));\n+                     PROPERFMTARGS(_mtag[i].sz), mode_to_name(_mtag[i].mode));\n@@ -167,1 +166,1 @@\n-  \/\/ MallocLimit=<size>[:flag]\n+  \/\/ MallocLimit=<size>[:mode]\n@@ -169,2 +168,2 @@\n-  \/\/ Category-specific form:\n-  \/\/ MallocLimit=<category>:<size>[:flag][,<category>:<size>[:flag]...]\n+  \/\/ MemTag-specific form:\n+  \/\/ MallocLimit=<mem-tag>:<size>[:mode][,<mem-tag>:<size>[:mode]...]\n@@ -180,1 +179,1 @@\n-    \/\/ Match optional mode flag (e.g. 1g:oom)\n+    \/\/ Match optional mode  (e.g. 1g:oom)\n@@ -183,1 +182,1 @@\n-      BAIL_UNLESS(sst.match_mode_flag(&_glob.mode), \"Expected flag\");\n+      BAIL_UNLESS(sst.match_mode(&_glob.mode), \"Expected mode\");\n@@ -186,1 +185,1 @@\n-  \/\/ Category-specific form?\n+  \/\/ MemTag-specific form?\n@@ -191,2 +190,2 @@\n-      \/\/ Match category, followed by :\n-      BAIL_UNLESS(sst.match_category(&mem_tag), \"Expected category name\");\n+      \/\/ Match MemTag, followed by :\n+      BAIL_UNLESS(sst.match_mem_tag(&mem_tag), \"Expected category name\");\n@@ -195,1 +194,1 @@\n-      malloclimit* const modified_limit = &_cat[NMTUtil::tag_to_index(mem_tag)];\n+      malloclimit* const modified_limit = &_mtag[NMTUtil::tag_to_index(mem_tag)];\n@@ -200,1 +199,1 @@\n-      \/\/ Match optional flag\n+      \/\/ Match optional mode\n@@ -202,1 +201,1 @@\n-        BAIL_UNLESS(sst.match_mode_flag(&modified_limit->mode), \"Expected flag\");\n+        BAIL_UNLESS(sst.match_mode(&modified_limit->mode), \"Expected mode\");\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.cpp","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  malloclimit _cat[mt_number_of_tags]; \/\/ per-category limit\n+  malloclimit _mtag[mt_number_of_tags]; \/\/ per-memtag limit\n@@ -60,1 +60,1 @@\n-  const malloclimit* category_limit(MemTag mem_tag) const { return &_cat[(int)mem_tag]; }\n+  const malloclimit* mem_tag_limit(MemTag mem_tag) const { return &_mtag[(int)mem_tag]; }\n@@ -72,1 +72,1 @@\n-  static const malloclimit* category_limit(MemTag mem_tag) { return _limits.category_limit(mem_tag); }\n+  static const malloclimit* mem_tag_limit(MemTag mem_tag) { return _limits.mem_tag_limit(mem_tag); }\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -46,1 +47,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -210,0 +210,6 @@\n+  if (ZapCHeap) {\n+    \/\/ To do this zapping, we need to know the block size.\n+    \/\/ This is why we have to do it here, and not in os::free.\n+    memset(memblock, freeBlockPad, header->size());\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/mallocLimit.hpp\"\n@@ -31,0 +30,2 @@\n+\n+#include \"nmt\/mallocLimit.hpp\"\n@@ -52,2 +53,2 @@\n-      \/\/ Category Limit?\n-      l = MallocLimitHandler::category_limit(mem_tag);\n+      \/\/ MemTag Limit?\n+      l = MallocLimitHandler::mem_tag_limit(mem_tag);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -33,0 +32,2 @@\n+#include \"memory\/universe.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"nmt\/memMapPrinter.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memTag.hpp\"\n+#include \"nmt\/memoryFileTracker.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -32,2 +33,0 @@\n-#include \"nmt\/memoryFileTracker.hpp\"\n-#include \"nmt\/regionsTree.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"nmt\/nmtCommon.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"nmt\/nmtCommon.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"nmt\/memTracker.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"nmt\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"nmt\/vmatree.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"nmt\/vmatree.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -44,1 +44,1 @@\n-  mutable ResourceHashtable<address, const char*, 293, AnyObj::C_HEAP, mtNMT> _cache;\n+  mutable HashTable<address, const char*, 293, AnyObj::C_HEAP, mtNMT> _cache;\n","filename":"src\/hotspot\/share\/nmt\/nativeCallStackPrinter.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n-#include \"nmt\/regionsTree.hpp\"\n@@ -30,0 +28,1 @@\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/vmatree.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"nmt\/vmatree.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/memTag.hpp\"\n@@ -35,0 +34,1 @@\n+\n@@ -53,5 +53,4 @@\n-    static int cmp(position a, position b) {\n-      if (a < b) return -1;\n-      if (a == b) return 0;\n-      if (a > b) return 1;\n-      ShouldNotReachHere();\n+    static RBTreeOrdering cmp(position a, position b) {\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -26,1 +27,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -262,1 +262,1 @@\n-    if (MetaspaceShared::is_shared_dynamic((void*)k)) {\n+    if (AOTMetaspace::in_aot_cache_dynamic_region((void*)k)) {\n@@ -264,1 +264,1 @@\n-    } else if (MetaspaceShared::is_shared_static((void*)k)) {\n+    } else if (AOTMetaspace::in_aot_cache_static_region((void*)k)) {\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,4 +81,4 @@\n-  os::snprintf(tmp, sizeof(tmp), \"klass range: \" RANGE2FMT \",\"\n-      \" base \" PTR_FORMAT \", shift %d, lowest\/highest valid narrowKlass %u\/%u\",\n-      RANGE2FMTARGS(_klass_range_start, _klass_range_end),\n-      p2i(_base), _shift, _lowest_valid_narrow_klass_id, _highest_valid_narrow_klass_id);\n+  os::snprintf_checked(tmp, sizeof(tmp), \"klass range: \" RANGE2FMT \",\"\n+                       \" base \" PTR_FORMAT \", shift %d, lowest\/highest valid narrowKlass %u\/%u\",\n+                       RANGE2FMTARGS(_klass_range_start, _klass_range_end),\n+                       p2i(_base), _shift, _lowest_valid_narrow_klass_id, _highest_valid_narrow_klass_id);\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -386,2 +386,2 @@\n-  assert(on_stack(), \"should always be set for shared constant pools\");\n-  assert(is_shared(), \"should always be set for shared constant pools\");\n+  assert(on_stack(), \"should always be set for constant pools in AOT cache\");\n+  assert(in_aot_cache(), \"should always be set for constant pools in AOT cache\");\n@@ -431,1 +431,1 @@\n-  \/\/ Shared ConstantPools are in the RO region, so the _flags cannot be modified.\n+  \/\/ ConstantPools in AOT cache are in the RO region, so the _flags cannot be modified.\n@@ -433,1 +433,1 @@\n-  \/\/ class redefinition. Since shared ConstantPools cannot be deallocated anyway,\n+  \/\/ class redefinition. Since such ConstantPools cannot be deallocated anyway,\n@@ -435,1 +435,1 @@\n-  _flags |= (_on_stack | _is_shared);\n+  _flags |= (_on_stack | _in_aot_cache);\n@@ -2261,1 +2261,1 @@\n-      assert(!is_shared(), \"should always be set for shared constant pools\");\n+      assert(!in_aot_cache(), \"should always be set for constant pools in AOT cache\");\n@@ -2267,1 +2267,1 @@\n-    if (!is_shared()) {\n+    if (!in_aot_cache()) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -41,1 +42,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -148,1 +148,1 @@\n-    _is_shared            = 4,\n+    _in_aot_cache         = 4,\n@@ -215,1 +215,1 @@\n-    assert(!is_shared(), \"should never be called on shared ConstantPools\");\n+    assert(!in_aot_cache(), \"should never be called on ConstantPools in AOT cache\");\n@@ -251,2 +251,2 @@\n-  \/\/ Faster than MetaspaceObj::is_shared() - used by set_on_stack()\n-  bool is_shared() const                     { return (_flags & _is_shared) != 0; }\n+  \/\/ Shadows MetaspaceObj::in_aot_cache(). It's faster and is used by set_on_stack()\n+  bool in_aot_cache() const               { return (_flags & _in_aot_cache) != 0; }\n@@ -875,1 +875,1 @@\n-    ResourceHashtable<const Symbol*, u2, 256, AnyObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n+    HashTable<const Symbol*, u2, 256, AnyObj::C_HEAP, mtSymbol, Symbol::compute_hash> _table;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-  assert(!is_shared(), \"shared caches are not deallocated\");\n+  assert(!in_aot_cache(), \"objects in aot metaspace are not deallocated\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+  CDS_JAVA_HEAP_ONLY(int archived_references_index() { return _archived_references_index; })\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+  if (_resolved_indy_entries == nullptr) {\n+    return 0;\n+  }\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-        result = result->java_super();\n+        result = result->super();\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2153,1 +2153,1 @@\n-  os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);\n+  (void) os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);\n@@ -2156,1 +2156,1 @@\n-  os::snprintf(msg_buffer2, sizeof(msg_buffer2), \"%s in method %s\", msg_buffer, method()->name()->as_C_string());\n+  (void) os::snprintf(msg_buffer2, sizeof(msg_buffer2), \"%s in method %s\", msg_buffer, method()->name()->as_C_string());\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -564,1 +564,1 @@\n-      !methods->is_shared()) {\n+      !methods->in_aot_cache()) {\n@@ -578,1 +578,1 @@\n-                                          const Klass* super_klass,\n+                                          const InstanceKlass* super_klass,\n@@ -587,2 +587,2 @@\n-                    InstanceKlass::cast(super_klass)->transitive_interfaces();\n-    if (ti != sti && ti != nullptr && !ti->is_shared()) {\n+                    super_klass->transitive_interfaces();\n+    if (ti != sti && ti != nullptr && !ti->in_aot_cache()) {\n@@ -595,1 +595,1 @@\n-      local_interfaces != nullptr && !local_interfaces->is_shared()) {\n+      local_interfaces != nullptr && !local_interfaces->in_aot_cache()) {\n@@ -602,1 +602,1 @@\n-  if (record_components != nullptr && !record_components->is_shared()) {\n+  if (record_components != nullptr && !record_components->in_aot_cache()) {\n@@ -646,1 +646,1 @@\n-      !method_ordering()->is_shared()) {\n+      !method_ordering()->in_aot_cache()) {\n@@ -654,1 +654,1 @@\n-      !default_methods()->is_shared()) {\n+      !default_methods()->in_aot_cache()) {\n@@ -662,1 +662,1 @@\n-      !default_vtable_indices()->is_shared()) {\n+      !default_vtable_indices()->in_aot_cache()) {\n@@ -675,1 +675,1 @@\n-      !secondary_supers()->is_shared()) {\n+      !secondary_supers()->in_aot_cache()) {\n@@ -684,1 +684,1 @@\n-  if (fieldinfo_stream() != nullptr && !fieldinfo_stream()->is_shared()) {\n+  if (fieldinfo_stream() != nullptr && !fieldinfo_stream()->in_aot_cache()) {\n@@ -689,1 +689,1 @@\n-  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->is_shared()) {\n+  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->in_aot_cache()) {\n@@ -694,1 +694,1 @@\n-  if (fields_status() != nullptr && !fields_status()->is_shared()) {\n+  if (fields_status() != nullptr && !fields_status()->in_aot_cache()) {\n@@ -703,1 +703,1 @@\n-    if (!constants()->is_shared()) {\n+    if (!constants()->in_aot_cache()) {\n@@ -714,1 +714,1 @@\n-      !inner_classes()->is_shared()) {\n+      !inner_classes()->in_aot_cache()) {\n@@ -721,1 +721,1 @@\n-      !nest_members()->is_shared()) {\n+      !nest_members()->in_aot_cache()) {\n@@ -728,1 +728,1 @@\n-      !permitted_subclasses()->is_shared()) {\n+      !permitted_subclasses()->in_aot_cache()) {\n@@ -734,1 +734,1 @@\n-  if (annotations() != nullptr && !annotations()->is_shared()) {\n+  if (annotations() != nullptr && !annotations()->in_aot_cache()) {\n@@ -751,1 +751,1 @@\n-         java_super() == vmClasses::Record_klass();\n+         super() == vmClasses::Record_klass();\n@@ -766,1 +766,1 @@\n-  InstanceKlass* s = java_super();\n+  InstanceKlass* s = super();\n@@ -768,1 +768,1 @@\n-          (s != nullptr && s->java_super() == vmClasses::Enum_klass()));\n+          (s != nullptr && s->super() == vmClasses::Enum_klass()));\n@@ -832,1 +832,1 @@\n-  InstanceKlass* s = java_super();\n+  InstanceKlass* s = super();\n@@ -945,1 +945,1 @@\n-  Klass* super_klass = super();\n+  InstanceKlass* super_klass = super();\n@@ -960,2 +960,1 @@\n-    InstanceKlass* ik_super = InstanceKlass::cast(super_klass);\n-    ik_super->link_class_impl(CHECK_false);\n+    super_klass->link_class_impl(CHECK_false);\n@@ -998,1 +997,1 @@\n-        if (is_shared()) {\n+        if (in_aot_cache()) {\n@@ -1017,1 +1016,1 @@\n-      } else if (is_shared()) {\n+      } else if (in_aot_cache()) {\n@@ -1035,1 +1034,1 @@\n-      if (is_shared() && verified_at_dump_time() &&\n+      if (in_aot_cache() && verified_at_dump_time() &&\n@@ -1077,1 +1076,1 @@\n-    assert(is_shared(), \"rewriting an unshared class?\");\n+    assert(in_aot_cache(), \"rewriting an unshared class?\");\n@@ -1119,1 +1118,1 @@\n-using InitializationErrorTable = ResourceHashtable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>;\n+using InitializationErrorTable = HashTable<const InstanceKlass*, OopHandle, 107, AnyObj::C_HEAP, mtClass>;\n@@ -1469,1 +1468,1 @@\n-  InstanceKlass* super_ik = ik->java_super();\n+  InstanceKlass* super_ik = ik->super();\n@@ -1689,1 +1688,1 @@\n-    assert(is_shared(), \"must be\");\n+    assert(in_aot_cache(), \"must be\");\n@@ -1808,1 +1807,1 @@\n-    Klass* intf1 = local_interfaces()->at(i);\n+    InstanceKlass* intf1 = local_interfaces()->at(i);\n@@ -1811,1 +1810,1 @@\n-    if (InstanceKlass::cast(intf1)->find_local_field(name, sig, fd)) {\n+    if (intf1->find_local_field(name, sig, fd)) {\n@@ -1816,1 +1815,1 @@\n-    Klass* intf2 = InstanceKlass::cast(intf1)->find_interface_field(name, sig, fd);\n+    Klass* intf2 = intf1->find_interface_field(name, sig, fd);\n@@ -1835,2 +1834,2 @@\n-  { Klass* supr = super();\n-    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, fd);\n+  { InstanceKlass* supr = super();\n+    if (supr != nullptr) return supr->find_field(name, sig, fd);\n@@ -1855,2 +1854,2 @@\n-  { Klass* supr = super();\n-    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n+  { InstanceKlass* supr = super();\n+    if (supr != nullptr) return supr->find_field(name, sig, is_static, fd);\n@@ -1875,1 +1874,1 @@\n-  Klass* klass = const_cast<InstanceKlass*>(this);\n+  const InstanceKlass* klass = this;\n@@ -1877,1 +1876,1 @@\n-    if (InstanceKlass::cast(klass)->find_local_field_from_offset(offset, is_static, fd)) {\n+    if (klass->find_local_field_from_offset(offset, is_static, fd)) {\n@@ -1923,1 +1922,1 @@\n-  InstanceKlass* super = superklass();\n+  InstanceKlass* super = this->super();\n@@ -1940,1 +1939,1 @@\n-  InstanceKlass* super = superklass();\n+  InstanceKlass* super = this->super();\n@@ -2235,1 +2234,1 @@\n-  const Klass* klass = this;\n+  const InstanceKlass* klass = this;\n@@ -2237,5 +2236,5 @@\n-    Method* const method = InstanceKlass::cast(klass)->find_method_impl(name,\n-                                                                        signature,\n-                                                                        overpass_local_mode,\n-                                                                        StaticLookupMode::find,\n-                                                                        private_mode);\n+    Method* const method = klass->find_method_impl(name,\n+                                                   signature,\n+                                                   overpass_local_mode,\n+                                                   StaticLookupMode::find,\n+                                                   private_mode);\n@@ -2255,1 +2254,1 @@\n-  const Klass* klass = this;\n+  const InstanceKlass* klass = this;\n@@ -2257,1 +2256,1 @@\n-    if (InstanceKlass::cast(klass)->has_been_redefined()) {\n+    if (klass->has_been_redefined()) {\n@@ -2334,1 +2333,1 @@\n-    if (ik->is_shared()) buf[i++] = 'S';\n+    if (ik->in_aot_cache()) buf[i++] = 'S';\n@@ -2767,1 +2766,1 @@\n-             MetaspaceShared::is_in_shared_metaspace(_package_entry)) {\n+             AOTMetaspace::in_aot_cache(_package_entry)) {\n@@ -2849,1 +2848,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(this)) {\n+  if (AOTMetaspace::in_aot_cache(this)) {\n@@ -2857,1 +2856,1 @@\n-  if (java_super() != nullptr && !java_super()->can_be_verified_at_dumptime()) {\n+  if (super() != nullptr && !super()->can_be_verified_at_dumptime()) {\n@@ -3085,1 +3084,1 @@\n-  if (!is_shared()) {\n+  if (!in_aot_cache()) {\n@@ -3089,1 +3088,1 @@\n-  if (is_shared() && _package_entry != nullptr) {\n+  if (in_aot_cache() && _package_entry != nullptr) {\n@@ -3092,1 +3091,1 @@\n-      assert(MetaspaceShared::is_in_shared_metaspace(_package_entry), \"must be\");\n+      assert(AOTMetaspace::in_aot_cache(_package_entry), \"must be\");\n@@ -3974,2 +3973,2 @@\n-    assert(this->is_shared(), \"must be\");\n-    if (MetaspaceShared::is_shared_dynamic((void*)this)) {\n+    assert(this->in_aot_cache(), \"must be\");\n+    if (AOTMetaspace::in_aot_cache_dynamic_region((void*)this)) {\n@@ -3989,1 +3988,1 @@\n-                       p2i(this),  p2i(superklass()));\n+                       p2i(this),  p2i(super()));\n@@ -3997,1 +3996,1 @@\n-                           p2i(InstanceKlass::cast(local_interfaces()->at(i))));\n+                           p2i(local_interfaces()->at(i)));\n@@ -4210,1 +4209,0 @@\n-\n@@ -4215,1 +4213,1 @@\n-JNIid::JNIid(Klass* holder, int offset, JNIid* next) {\n+JNIid::JNIid(InstanceKlass* holder, int offset, JNIid* next) {\n@@ -4222,1 +4220,0 @@\n-\n@@ -4240,2 +4237,1 @@\n-\n-void JNIid::verify(Klass* holder) {\n+void JNIid::verify(InstanceKlass* holder) {\n@@ -4244,1 +4240,1 @@\n-  end_field_offset = first_field_offset + (InstanceKlass::cast(holder)->static_field_size() * wordSize);\n+  end_field_offset = first_field_offset + (holder->static_field_size() * wordSize);\n@@ -4261,1 +4257,1 @@\n-  bool good_state = is_shared() ? (_init_state <= state)\n+  bool good_state = in_aot_cache() ? (_init_state <= state)\n@@ -4362,1 +4358,1 @@\n-      if (pvcp->is_shared()) {\n+      if (pvcp->in_aot_cache()) {\n@@ -4474,1 +4470,1 @@\n-  if (cp_ref->is_shared()) {\n+  if (cp_ref->in_aot_cache()) {\n@@ -4557,1 +4553,1 @@\n-    _current = _current->superklass(); \/\/ backtrack; no more sibling subclasses left\n+    _current = _current->java_super(); \/\/ backtrack; no more sibling subclasses left\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":69,"deletions":73,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -767,8 +767,0 @@\n-  \/\/ Indicates presence of @AOTSafeClassInitializer. Also see AOTClassInitializer for more details.\n-  bool has_aot_safe_initializer() const { return _misc_flags.has_aot_safe_initializer(); }\n-  void set_has_aot_safe_initializer()   { _misc_flags.set_has_aot_safe_initializer(true); }\n-\n-  \/\/ Indicates @AOTRuntimeSetup private static void runtimeSetup() presence.\n-  bool is_runtime_setup_required() const { return _misc_flags.is_runtime_setup_required(); }\n-  void set_is_runtime_setup_required()   { _misc_flags.set_is_runtime_setup_required(true); }\n-\n@@ -921,0 +913,6 @@\n+  \/\/ This hides Klass::super(). The _super of an InstanceKlass is\n+  \/\/ always an InstanceKlass (or nullptr)\n+  InstanceKlass* super() const {\n+    return (Klass::super() == nullptr) ? nullptr : InstanceKlass::cast(Klass::super());\n+  }\n+\n@@ -922,1 +920,1 @@\n-    return (super() == nullptr) ? nullptr : cast(super());\n+    return InstanceKlass::super();\n@@ -991,1 +989,1 @@\n-                                    const Klass* super_klass,\n+                                    const InstanceKlass* super_klass,\n@@ -1208,1 +1206,1 @@\n-  Klass*             _holder;\n+  InstanceKlass*     _holder;\n@@ -1217,1 +1215,1 @@\n-  Klass* holder() const           { return _holder; }\n+  InstanceKlass* holder() const   { return _holder; }\n@@ -1221,1 +1219,1 @@\n-  JNIid(Klass* holder, int offset, JNIid* next);\n+  JNIid(InstanceKlass* holder, int offset, JNIid* next);\n@@ -1235,1 +1233,1 @@\n-  void verify(Klass* holder);\n+  void verify(InstanceKlass* holder);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -57,2 +57,0 @@\n-    flag(has_aot_safe_initializer           , 1 << 14) \/* has @AOTSafeClassInitializer annotation *\/ \\\n-    flag(is_runtime_setup_required          , 1 << 15) \/* has a runtimeSetup method to be called *\/ \\\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-      assert(klass->is_shared(), \"Must be\");\n+      assert(klass->in_aot_cache(), \"Must be\");\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,4 +167,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  CDS_ONLY(_shared_class_flags = 0;)\n+  CDS_ONLY(_aot_class_flags = 0;)\n@@ -614,6 +614,0 @@\n-\/\/ superklass links\n-InstanceKlass* Klass::superklass() const {\n-  assert(super() == nullptr || super()->is_instance_klass(), \"must be instance klass\");\n-  return _super == nullptr ? nullptr : InstanceKlass::cast(_super);\n-}\n-\n@@ -682,2 +676,2 @@\n-  \/\/ add ourselves to superklass' subklass list\n-  InstanceKlass* super = superklass();\n+  \/\/ add ourselves to super' subklass list\n+  InstanceKlass* super = java_super();\n@@ -686,1 +680,1 @@\n-          && (super->superklass() == nullptr || !is_interface())),\n+          && (super->java_super() == nullptr || !is_interface())),\n@@ -695,1 +689,1 @@\n-      \/\/ set our sibling to be the superklass' previous first subklass\n+      \/\/ set our sibling to be the super' previous first subklass\n@@ -814,1 +808,1 @@\n-  set_is_shared();\n+  set_in_aot_cache();\n@@ -867,1 +861,1 @@\n-  assert(is_shared(), \"must be set\");\n+  assert(in_aot_cache(), \"must be set\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -177,3 +177,3 @@\n-  u2     _shared_class_flags;\n-  enum CDSSharedClassFlags {\n-    _is_shared_class                       = 1 << 0,  \/\/ shadows MetaspaceObj::is_shared\n+  u2 _aot_class_flags;\n+  enum  {\n+    _in_aot_cache                          = 1 << 0,\n@@ -184,5 +184,7 @@\n-    \/\/ This class was not loaded from a classfile in the module image\n-    \/\/ or classpath.\n-    _is_generated_shared_class             = 1 << 5,\n-    \/\/ archived mirror already initialized by AOT-cache assembly: no further need to call <clinit>\n-    _has_aot_initialized_mirror            = 1 << 6,\n+    _is_aot_generated_class                = 1 << 5, \/\/ this class was not loaded from a classfile in the module image\n+                                                     \/\/ or classpath, but was generated during AOT cache assembly.\n+    _has_aot_initialized_mirror            = 1 << 6, \/\/ archived mirror already initialized by AOT cache assembly.\n+                                                     \/\/ no further need to call <clinit>\n+    _has_aot_safe_initializer              = 1 << 7, \/\/ has @AOTSafeClassInitializer annotation\n+    _is_runtime_setup_required             = 1 << 8, \/\/ has a runtimeSetup method to be called when\n+                                                     \/\/ this class is loaded from AOT cache\n@@ -220,1 +222,3 @@\n-  \/\/ If this is not what your code expects, you're probably looking for Klass::java_super().\n+  \/\/ If this is not what your code expects, you're probably looking for:\n+  \/\/ - Klass::java_super() - if you have a Klass*\n+  \/\/ - InstanceKlass::super() - if you have an InstanceKlass* ik, ik->super() returns InstanceKlass*.\n@@ -300,1 +304,0 @@\n-  InstanceKlass* superklass() const;\n@@ -327,1 +330,1 @@\n-    CDS_ONLY(_shared_class_flags |= _archived_lambda_proxy_is_available;)\n+    CDS_ONLY(_aot_class_flags |= _archived_lambda_proxy_is_available;)\n@@ -330,1 +333,1 @@\n-    CDS_ONLY(_shared_class_flags &= (u2)(~_archived_lambda_proxy_is_available);)\n+    CDS_ONLY(_aot_class_flags &= (u2)(~_archived_lambda_proxy_is_available);)\n@@ -333,1 +336,1 @@\n-    CDS_ONLY(return (_shared_class_flags & _archived_lambda_proxy_is_available) != 0;)\n+    CDS_ONLY(return (_aot_class_flags & _archived_lambda_proxy_is_available) != 0;)\n@@ -338,1 +341,1 @@\n-    CDS_ONLY(_shared_class_flags |= _has_value_based_class_annotation;)\n+    CDS_ONLY(_aot_class_flags |= _has_value_based_class_annotation;)\n@@ -341,1 +344,1 @@\n-    CDS_ONLY(_shared_class_flags &= (u2)(~_has_value_based_class_annotation);)\n+    CDS_ONLY(_aot_class_flags &= (u2)(~_has_value_based_class_annotation);)\n@@ -344,1 +347,1 @@\n-    CDS_ONLY(return (_shared_class_flags & _has_value_based_class_annotation) != 0;)\n+    CDS_ONLY(return (_aot_class_flags & _has_value_based_class_annotation) != 0;)\n@@ -349,1 +352,1 @@\n-    CDS_ONLY(_shared_class_flags |= _verified_at_dump_time;)\n+    CDS_ONLY(_aot_class_flags |= _verified_at_dump_time;)\n@@ -352,1 +355,1 @@\n-    CDS_ONLY(return (_shared_class_flags & _verified_at_dump_time) != 0;)\n+    CDS_ONLY(return (_aot_class_flags & _verified_at_dump_time) != 0;)\n@@ -357,1 +360,1 @@\n-    CDS_ONLY(_shared_class_flags |= _has_archived_enum_objs;)\n+    CDS_ONLY(_aot_class_flags |= _has_archived_enum_objs;)\n@@ -360,1 +363,1 @@\n-    CDS_ONLY(return (_shared_class_flags & _has_archived_enum_objs) != 0;)\n+    CDS_ONLY(return (_aot_class_flags & _has_archived_enum_objs) != 0;)\n@@ -364,2 +367,2 @@\n-  void set_is_generated_shared_class() {\n-    CDS_ONLY(_shared_class_flags |= _is_generated_shared_class;)\n+  void set_is_aot_generated_class() {\n+    CDS_ONLY(_aot_class_flags |= _is_aot_generated_class;)\n@@ -367,2 +370,2 @@\n-  bool is_generated_shared_class() const {\n-    CDS_ONLY(return (_shared_class_flags & _is_generated_shared_class) != 0;)\n+  bool is_aot_generated_class() const {\n+    CDS_ONLY(return (_aot_class_flags & _is_aot_generated_class) != 0;)\n@@ -373,1 +376,1 @@\n-    CDS_ONLY(_shared_class_flags |= _has_aot_initialized_mirror;)\n+    CDS_ONLY(_aot_class_flags |= _has_aot_initialized_mirror;)\n@@ -376,1 +379,1 @@\n-    CDS_ONLY(return (_shared_class_flags & _has_aot_initialized_mirror) != 0;)\n+    CDS_ONLY(return (_aot_class_flags & _has_aot_initialized_mirror) != 0;)\n@@ -380,2 +383,20 @@\n-  bool is_shared() const                { \/\/ shadows MetaspaceObj::is_shared)()\n-    CDS_ONLY(return (_shared_class_flags & _is_shared_class) != 0;)\n+  \/\/ Indicates presence of @AOTSafeClassInitializer. Also see AOTClassInitializer for more details.\n+  void set_has_aot_safe_initializer() {\n+    CDS_ONLY(_aot_class_flags |= _has_aot_safe_initializer;)\n+  }\n+  bool has_aot_safe_initializer() const {\n+    CDS_ONLY(return (_aot_class_flags & _has_aot_safe_initializer) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n+  \/\/ Indicates @AOTRuntimeSetup private static void runtimeSetup() presence.\n+  void set_is_runtime_setup_required() {\n+    CDS_ONLY(_aot_class_flags |= _is_runtime_setup_required;)\n+  }\n+  bool is_runtime_setup_required() const {\n+    CDS_ONLY(return (_aot_class_flags & _is_runtime_setup_required) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n+  bool in_aot_cache() const                { \/\/ shadows MetaspaceObj::in_aot_cache)()\n+    CDS_ONLY(return (_aot_class_flags & _in_aot_cache) != 0;)\n@@ -385,2 +406,2 @@\n-  void set_is_shared() {\n-    CDS_ONLY(_shared_class_flags |= _is_shared_class;)\n+  void set_in_aot_cache() {\n+    CDS_ONLY(_aot_class_flags |= _in_aot_cache;)\n@@ -612,1 +633,1 @@\n-    assert(is_shared(), \"use this for shared classes only\");\n+    assert(in_aot_cache(), \"use this for shared classes only\");\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":52,"deletions":31,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/metaspaceShared.hpp\"\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -53,1 +53,1 @@\n-  return _klass->is_shared() && !MetaspaceShared::remapped_readwrite() && _klass->verified_at_dump_time();\n+  return _klass->in_aot_cache() && !AOTMetaspace::remapped_readwrite() && _klass->verified_at_dump_time();\n@@ -68,1 +68,1 @@\n-    GrowableArray<Method*>* all_mirandas, const Klass* super,\n+    GrowableArray<Method*>* all_mirandas, const InstanceKlass* super,\n@@ -166,1 +166,1 @@\n-  bool is_shared = _klass->is_shared();\n+  bool in_aot_cache = _klass->in_aot_cache();\n@@ -181,1 +181,1 @@\n-    assert(!is_shared, \"sanity\");\n+    assert(!in_aot_cache, \"sanity\");\n@@ -349,1 +349,1 @@\n-    superk = superk->super() == nullptr ? nullptr : InstanceKlass::cast(superk->super());\n+    superk = superk->super();\n@@ -634,1 +634,1 @@\n-                                         const Klass* super,\n+                                         const InstanceKlass* super,\n@@ -686,1 +686,1 @@\n-  const Klass* k = super;\n+  const InstanceKlass* ik = super;\n@@ -691,1 +691,1 @@\n-  while (k != nullptr) {\n+  while (ik != nullptr) {\n@@ -693,1 +693,1 @@\n-    super_method = InstanceKlass::cast(k)->lookup_method(name, signature);\n+    super_method = ik->lookup_method(name, signature);\n@@ -725,1 +725,1 @@\n-      k = superk->super(); \/\/ haven't found an override match yet; continue to look\n+      ik = superk->super(); \/\/ haven't found an override match yet; continue to look\n@@ -744,3 +744,2 @@\n-  const InstanceKlass *sk = InstanceKlass::cast(super);\n-  if (sk->has_miranda_methods()) {\n-    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n+  if (super->has_miranda_methods()) {\n+    if (super->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n@@ -840,1 +839,1 @@\n-                             Array<Method*>* default_methods, const Klass* super,\n+                             Array<Method*>* default_methods, const InstanceKlass* super,\n@@ -869,6 +868,5 @@\n-  for (const Klass* cursuper = super; cursuper != nullptr; cursuper = cursuper->super())\n-  {\n-     Method* found_mth = InstanceKlass::cast(cursuper)->find_local_method(name, signature,\n-                                                                          Klass::OverpassLookupMode::find,\n-                                                                          Klass::StaticLookupMode::skip,\n-                                                                          Klass::PrivateLookupMode::skip);\n+  for (const InstanceKlass* cursuper = super; cursuper != nullptr; cursuper = cursuper->super()) {\n+     Method* found_mth = cursuper->find_local_method(name, signature,\n+                                                     Klass::OverpassLookupMode::find,\n+                                                     Klass::StaticLookupMode::skip,\n+                                                     Klass::PrivateLookupMode::skip);\n@@ -896,1 +894,1 @@\n-    Array<Method*>* default_methods, const Klass* super, bool is_interface) {\n+    Array<Method*>* default_methods, const InstanceKlass* super, bool is_interface) {\n@@ -916,1 +914,0 @@\n-        const InstanceKlass *sk = InstanceKlass::cast(super);\n@@ -918,1 +915,1 @@\n-        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n+        if (super->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n@@ -931,1 +928,1 @@\n-                               const Klass* super,\n+                               const InstanceKlass* super,\n@@ -1095,2 +1092,2 @@\n-  if (MetaspaceShared::is_in_shared_metaspace((void*)&_method) &&\n-     !MetaspaceShared::remapped_readwrite() &&\n+  if (AOTMetaspace::in_aot_cache((void*)&_method) &&\n+     !AOTMetaspace::remapped_readwrite() &&\n@@ -1281,1 +1278,1 @@\n-               m->is_shared(),\n+               m->in_aot_cache(),\n@@ -1577,2 +1574,1 @@\n-    InstanceKlass* sk = InstanceKlass::cast(super);\n-    klassVtable vt = sk->vtable();\n+    klassVtable vt = super->vtable();\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":26,"deletions":30,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                                                   const Klass* super,\n+                                                   const InstanceKlass* super,\n@@ -119,1 +119,1 @@\n-                                     const Klass* super,\n+                                     const InstanceKlass* super,\n@@ -138,1 +138,1 @@\n-                         Array<Method*>* default_methods, const Klass* super,\n+                         Array<Method*>* default_methods, const InstanceKlass* super,\n@@ -146,1 +146,1 @@\n-      const Klass* super,\n+      const InstanceKlass* super,\n@@ -151,1 +151,1 @@\n-      const Klass* super,\n+      const InstanceKlass* super,\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,12 +39,4 @@\n-  if (has_monitor()) {\n-    \/\/ Has an inflated monitor. Must be checked before has_locker().\n-    ObjectMonitor* monitor = this->monitor();\n-    return monitor->header();\n-  }\n-  if (has_locker()) {  \/\/ has a stack lock\n-    BasicLock* locker = this->locker();\n-    return locker->displaced_header();\n-  }\n-  \/\/ This should never happen:\n-  fatal(\"bad header=\" INTPTR_FORMAT, value());\n-  return markWord(value());\n+  \/\/ Make sure we have an inflated monitor.\n+  guarantee(has_monitor(), \"bad header=\" INTPTR_FORMAT, value());\n+  ObjectMonitor* monitor = this->monitor();\n+  return monitor->header();\n@@ -55,13 +47,4 @@\n-  if (has_monitor()) {\n-    \/\/ Has an inflated monitor. Must be checked before has_locker().\n-    ObjectMonitor* monitor = this->monitor();\n-    monitor->set_header(m);\n-    return;\n-  }\n-  if (has_locker()) {  \/\/ has a stack lock\n-    BasicLock* locker = this->locker();\n-    locker->set_displaced_header(m);\n-    return;\n-  }\n-  \/\/ This should never happen:\n-  fatal(\"bad header=\" INTPTR_FORMAT, value());\n+  \/\/ Make sure we have an inflated monitor.\n+  guarantee(has_monitor(), \"bad header=\" INTPTR_FORMAT, value());\n+  ObjectMonitor* monitor = this->monitor();\n+  monitor->set_header(m);\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":8,"deletions":25,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,8 +201,0 @@\n-  bool has_locker() const {\n-    assert(LockingMode == LM_LEGACY, \"should only be called with legacy stack locking\");\n-    return (value() & lock_mask_in_place) == locked_value;\n-  }\n-  BasicLock* locker() const {\n-    assert(has_locker(), \"check\");\n-    return (BasicLock*) value();\n-  }\n@@ -211,1 +203,0 @@\n-    assert(LockingMode == LM_LIGHTWEIGHT, \"should only be called with new lightweight locking\");\n@@ -230,5 +221,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      return !UseObjectMonitorTable && lockbits == monitor_value;\n-    }\n-    \/\/ monitor (0b10) | stack-locked (0b00)?\n-    return (lockbits & unlocked_value) == 0;\n+    return !UseObjectMonitorTable && lockbits == monitor_value;\n@@ -307,1 +294,0 @@\n-    NOT_LP64(assert(LockingMode != LM_LEGACY, \"incorrect with LM_LEGACY on 32 bit\");)\n@@ -312,1 +298,0 @@\n-    NOT_LP64(assert(LockingMode != LM_LEGACY, \"incorrect with LM_LEGACY on 32 bit\");)\n@@ -317,1 +302,0 @@\n-    NOT_LP64(assert(LockingMode != LM_LEGACY, \"incorrect with LM_LEGACY on 32 bit\");)\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -155,0 +155,3 @@\n+  if (is_abstract()) {\n+    return SharedRuntime::throw_AbstractMethodError_entry();\n+  }\n@@ -160,0 +163,3 @@\n+  if (is_abstract()) {\n+    return SharedRuntime::get_handle_wrong_method_abstract_stub();\n+  }\n@@ -443,1 +449,1 @@\n-  if (is_shared() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n+  if (in_aot_cache() && !AOTMetaspace::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n@@ -454,1 +460,1 @@\n-  if (is_shared() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n+  if (in_aot_cache() && !AOTMetaspace::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n@@ -1168,1 +1174,1 @@\n-    _from_compiled_entry    = nullptr;\n+    _from_compiled_entry = nullptr;\n@@ -1170,1 +1176,1 @@\n-    _from_compiled_entry    = adapter()->get_c2i_entry();\n+    _from_compiled_entry = adapter()->get_c2i_entry();\n@@ -1199,1 +1205,1 @@\n-  if (!CDSConfig::is_dumping_adapters() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n+  if (!CDSConfig::is_dumping_adapters()) {\n@@ -1248,1 +1254,1 @@\n-    if (adapter()->is_shared()) {\n+    if (adapter()->in_aot_cache()) {\n@@ -1280,1 +1286,3 @@\n-  if (_adapter == nullptr) {\n+  if (is_abstract()) {\n+    h_method->_from_compiled_entry = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+  } else if (_adapter == nullptr) {\n@@ -1283,0 +1291,1 @@\n+    h_method->_from_compiled_entry = adapter()->get_c2i_entry();\n@@ -1303,0 +1312,1 @@\n+  assert(!mh->is_abstract(), \"abstract methods do not have adapters\");\n@@ -1321,1 +1331,0 @@\n-  mh->_from_compiled_entry = adapter->get_c2i_entry();\n@@ -2169,1 +2178,1 @@\n-  } else if (m->is_shared()) {\n+  } else if (m->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+  friend class AOTMapLogger;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,16 +113,2 @@\n-bool oopDesc::is_oop(oop obj, bool ignore_mark_word) {\n-  if (!Universe::heap()->is_oop(obj)) {\n-    return false;\n-  }\n-\n-  \/\/ Header verification: the mark is typically non-zero. If we're\n-  \/\/ at a safepoint, it must not be zero, except when using the new lightweight locking.\n-  \/\/ Outside of a safepoint, the header could be changing (for example,\n-  \/\/ another thread could be inflating a lock on this object).\n-  if (ignore_mark_word) {\n-    return true;\n-  }\n-  if (obj->mark().value() != 0) {\n-    return true;\n-  }\n-  return LockingMode == LM_LIGHTWEIGHT || !SafepointSynchronize::is_at_safepoint();\n+bool oopDesc::is_oop(oop obj) {\n+  return Universe::heap()->is_oop(obj);\n@@ -132,2 +118,2 @@\n-bool oopDesc::is_oop_or_null(oop obj, bool ignore_mark_word) {\n-  return obj == nullptr ? true : is_oop(obj, ignore_mark_word);\n+bool oopDesc::is_oop_or_null(oop obj) {\n+  return obj == nullptr ? true : is_oop(obj);\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+  inline void* base_addr();\n+  inline const void* base_addr() const;\n+\n@@ -70,1 +73,0 @@\n-  inline markWord* mark_addr() const;\n@@ -262,2 +264,2 @@\n-  static bool is_oop(oop obj, bool ignore_mark_word = false);\n-  static bool is_oop_or_null(oop obj, bool ignore_mark_word = false);\n+  static bool is_oop(oop obj);\n+  static bool is_oop_or_null(oop obj);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+void* oopDesc::base_addr() { return this; }\n+const void* oopDesc::base_addr() const { return this; }\n+\n@@ -58,4 +61,0 @@\n-markWord* oopDesc::mark_addr() const {\n-  return (markWord*) &_mark;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,27 @@\n+  \/\/ Notes on copy constructor, copy assignment operator, and copy_from().\n+  \/\/ These are necessary for generating deterministic CDS archives.\n+  \/\/\n+  \/\/ We have some unused padding on 64-bit platforms (4 bytes at the tail end).\n+  \/\/\n+  \/\/ When ResolvedFieldEntries in a ConstantPoolCache are allocated from the metaspace,\n+  \/\/ their entire content (including the padding) is filled with zeros. They are\n+  \/\/ then initialized with initialize_resolved_entries_array() in cpCache.cpp from a\n+  \/\/ GrowableArray.\n+  \/\/\n+  \/\/ The GrowableArray is initialized in rewriter.cpp, using ResolvedFieldEntries that\n+  \/\/ are originally allocated from the C++ stack. Functions like GrowableArray::expand_to()\n+  \/\/ will also allocate ResolvedFieldEntries from the stack. These may have random bits\n+  \/\/ in the padding as the C++ compiler is allowed to leave the padding in uninitialized\n+  \/\/ states.\n+  \/\/\n+  \/\/ If we use the default copy constructor and\/or default copy assignment operator,\n+  \/\/ the random padding will be copied into the GrowableArray, from there\n+  \/\/ to the ConstantPoolCache, and eventually to the CDS archive. As a result, the\n+  \/\/ CDS archive will contain random bits, causing failures in\n+  \/\/ test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java (usually on Windows).\n+  \/\/\n+  \/\/ By using copy_from(), we can prevent the random padding from being copied,\n+  \/\/ ensuring that the ResolvedFieldEntries in a ConstantPoolCache (and thus the\n+  \/\/ CDS archive) will have all zeros in the padding.\n+\n+  \/\/ Copy constructor\n@@ -87,0 +114,1 @@\n+  \/\/ Copy assignment operator\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,3 @@\n+  \/\/ The copy_from() pattern in resolvedFieldEntry.hpp is not necessary\n+  \/\/ as we have no unused padding (on 32- or 64-bit platforms).\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedIndyEntry.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,2 @@\n+  \/\/ See comments in resolvedFieldEntry.hpp about copy_from and padding.\n+  \/\/ We have unused padding on debug builds.\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -86,1 +85,1 @@\n-  if (TrainingData::have_data()) {\n+  if (TrainingData::have_data() && !TrainingData::assembling_data()) {\n@@ -101,3 +100,15 @@\n-        mtd->verify();\n-      } else if (td->is_CompileTrainingData()) {\n-        td->as_CompileTrainingData()->verify();\n+        mtd->verify(\/*verify_dep_counter*\/true);\n+      }\n+    });\n+  }\n+  if (TrainingData::need_data()) {\n+    TrainingDataLocker l;\n+    training_data_set()->iterate([&](TrainingData* td) {\n+      if (td->is_KlassTrainingData()) {\n+        KlassTrainingData* ktd = td->as_KlassTrainingData();\n+        ktd->verify();\n+      } else if (td->is_MethodTrainingData()) {\n+        MethodTrainingData* mtd = td->as_MethodTrainingData();\n+        \/\/ During the training run init deps tracking is not setup yet,\n+        \/\/ don't verify it.\n+        mtd->verify(\/*verify_dep_counter*\/false);\n@@ -232,1 +243,1 @@\n-void CompileTrainingData::dec_init_deps_left(KlassTrainingData* ktd) {\n+void CompileTrainingData::dec_init_deps_left_release(KlassTrainingData* ktd) {\n@@ -453,1 +464,1 @@\n-    comp_dep(i)->dec_init_deps_left(this);\n+    comp_dep(i)->dec_init_deps_left_release(this);\n@@ -479,0 +490,1 @@\n+  }\n@@ -480,3 +492,2 @@\n-    if (AOTVerifyTrainingData) {\n-      training_data_set()->verify();\n-    }\n+  if (AOTVerifyTrainingData) {\n+    TrainingData::verify();\n@@ -595,12 +606,3 @@\n-void MethodTrainingData::verify() {\n-  iterate_compiles([](CompileTrainingData* ctd) {\n-    ctd->verify();\n-\n-    int init_deps_left1 = ctd->init_deps_left();\n-    int init_deps_left2 = ctd->compute_init_deps_left();\n-\n-    if (init_deps_left1 != init_deps_left2) {\n-      ctd->print_on(tty); tty->cr();\n-    }\n-    guarantee(init_deps_left1 == init_deps_left2, \"mismatch: %d %d %d\",\n-              init_deps_left1, init_deps_left2, ctd->init_deps_left());\n+void MethodTrainingData::verify(bool verify_dep_counter) {\n+  iterate_compiles([&](CompileTrainingData* ctd) {\n+    ctd->verify(verify_dep_counter);\n@@ -610,1 +612,1 @@\n-void CompileTrainingData::verify() {\n+void CompileTrainingData::verify(bool verify_dep_counter) {\n@@ -627,0 +629,12 @@\n+\n+  if (verify_dep_counter) {\n+    int init_deps_left1 = init_deps_left_acquire();\n+    int init_deps_left2 = compute_init_deps_left();\n+\n+    bool invariant = (init_deps_left1 >= init_deps_left2);\n+    if (!invariant) {\n+      print_on(tty);\n+      tty->cr();\n+    }\n+    guarantee(invariant, \"init deps invariant violation: %d >= %d\", init_deps_left1, init_deps_left2);\n+  }\n@@ -693,1 +707,1 @@\n-  return k->meta() == nullptr || MetaspaceObj::is_shared(k->meta());\n+  return k->meta() == nullptr || MetaspaceObj::in_aot_cache(k->meta());\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":38,"deletions":24,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -99,1 +99,1 @@\n-  \/\/ It is also a part of the TD collection termination protocol (see the \"spanshot\" field).\n+  \/\/ It is also a part of the TD collection termination protocol (see the \"snapshot\" field).\n@@ -108,1 +108,1 @@\n-        TrainingData_lock->lock();\n+        TrainingData_lock->lock_without_safepoint_check();\n@@ -176,1 +176,1 @@\n-    ResizeableResourceHashtable<const Key*, TrainingData*,\n+    ResizeableHashTable<const Key*, TrainingData*,\n@@ -232,1 +232,1 @@\n-    ResizeableResourceHashtable<TrainingData*, bool> _visited;\n+    ResizeableHashTable<TrainingData*, bool> _visited;\n@@ -676,3 +676,3 @@\n-  void dec_init_deps_left(KlassTrainingData* ktd);\n-  int init_deps_left() const {\n-    return Atomic::load(&_init_deps_left);\n+  void dec_init_deps_left_release(KlassTrainingData* ktd);\n+  int init_deps_left_acquire() const {\n+    return Atomic::load_acquire(&_init_deps_left);\n@@ -710,1 +710,1 @@\n-  void verify();\n+  void verify(bool verify_dep_counter);\n@@ -831,1 +831,1 @@\n-  void verify();\n+  void verify(bool verify_dep_counter);\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    _caller_jvms->set_receiver_info(caller_jvms->receiver_info());\n@@ -440,1 +441,0 @@\n-    \/\/ count the current method and the callee\n@@ -442,5 +442,5 @@\n-    int inline_level = 0;\n-    if (!is_compiled_lambda_form) {\n-      if (method() == callee_method) {\n-        inline_level++;\n-      }\n+    const bool is_method_handle_invoker = is_compiled_lambda_form && !jvms->method()->is_compiled_lambda_form();\n+\n+    ciInstance* lform_callee_recv = nullptr;\n+    if (is_compiled_lambda_form && !is_method_handle_invoker) { \/\/ MH invokers don't have a receiver\n+      lform_callee_recv = jvms->compute_receiver_info(callee_method);\n@@ -448,3 +448,3 @@\n-    \/\/ count callers of current method and callee\n-    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : nullptr;\n-    for (JVMState* j = jvms->caller(); j != nullptr && j->has_method(); j = j->caller()) {\n+\n+    int inline_level = 0;\n+    for (JVMState* j = jvms; j != nullptr && j->has_method(); j = j->caller()) {\n@@ -452,6 +452,9 @@\n-        if (is_compiled_lambda_form) {\n-          \/\/ Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n-          \/\/ a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n-          \/\/ compiler stack.\n-          Node* caller_argument0 = j->map()->argument(j, 0)->uncast();\n-          if (caller_argument0 == callee_argument0) {\n+        \/\/ Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n+        \/\/ a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n+        \/\/ compiler stack.\n+        if (lform_callee_recv != nullptr) {\n+          ciInstance* lform_caller_recv = j->receiver_info();\n+          assert(lform_caller_recv != nullptr || j->depth() == 1 ||\n+                 !j->caller()->method()->is_compiled_lambda_form(), \/\/ MH invoker\n+                 \"missing receiver info\");\n+          if (lform_caller_recv == lform_callee_recv || lform_caller_recv == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -362,0 +362,9 @@\n+  product(bool, UseAutoVectorizationPredicate, true, DIAGNOSTIC,            \\\n+          \"Use AutoVectorization predicate (for speculative compilation)\")  \\\n+                                                                            \\\n+  product(bool, UseAutoVectorizationSpeculativeAliasingChecks, true, DIAGNOSTIC, \\\n+          \"Allow the use Multiversioning or Predicate to add aliasing\"      \\\n+          \"runtime checks. Runtime checks will only be inserted if either\"  \\\n+          \"LoopMultiversioning or UseAutoVectorizationPredicate are\"        \\\n+          \"enabled.\")                                                       \\\n+                                                                            \\\n@@ -669,0 +678,3 @@\n+  develop(bool, VerifyIntrinsicChecks, false,                               \\\n+          \"Verify in intrinsic that Java level checks work as expected\")    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -265,1 +265,2 @@\n-  _method(method) {\n+  _method(method),\n+  _receiver_info(nullptr) {\n@@ -281,1 +282,2 @@\n-  _method(nullptr) {\n+  _method(nullptr),\n+  _receiver_info(nullptr) {\n@@ -616,0 +618,1 @@\n+  n->set_receiver_info(_receiver_info);\n@@ -690,0 +693,14 @@\n+\/\/ Compute receiver info for a compiled lambda form at call site.\n+ciInstance* JVMState::compute_receiver_info(ciMethod* callee) const {\n+  assert(callee != nullptr && callee->is_compiled_lambda_form(), \"\");\n+  if (has_method() && method()->is_compiled_lambda_form()) { \/\/ callee is not a MH invoker\n+    Node* recv = map()->argument(this, 0);\n+    assert(recv != nullptr, \"\");\n+    const TypeOopPtr* recv_toop = recv->bottom_type()->isa_oopptr();\n+    if (recv_toop != nullptr && recv_toop->const_oop() != nullptr) {\n+      return recv_toop->const_oop()->as_instance();\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1367,1 +1384,1 @@\n-void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {\n+void SafePointNode::set_local(const JVMState* jvms, uint idx, Node *c) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+  ciInstance*       _receiver_info; \/\/ Constant receiver instance for compiled lambda forms\n@@ -262,0 +263,1 @@\n+  ciInstance*    receiver_info() const { assert(has_method(), \"\"); return _receiver_info; }\n@@ -307,0 +309,1 @@\n+  void              set_receiver_info(ciInstance* recv) { assert(has_method() || recv == nullptr, \"\"); _receiver_info = recv; }\n@@ -314,0 +317,1 @@\n+  ciInstance* compute_receiver_info(ciMethod* callee) const;\n@@ -377,1 +381,1 @@\n-  void verify_input(JVMState* jvms, uint idx) const {\n+  void verify_input(const JVMState* jvms, uint idx) const {\n@@ -386,3 +390,5 @@\n-  Node *local(JVMState* jvms, uint idx) const {\n-    verify_input(jvms, jvms->locoff() + idx);\n-    return in(jvms->locoff() + idx);\n+  Node* local(const JVMState* jvms, uint idx) const {\n+    uint loc_idx = jvms->locoff() + idx;\n+    assert(jvms->is_loc(loc_idx), \"not a local slot\");\n+    verify_input(jvms, loc_idx);\n+    return in(loc_idx);\n@@ -390,3 +396,5 @@\n-  Node *stack(JVMState* jvms, uint idx) const {\n-    verify_input(jvms, jvms->stkoff() + idx);\n-    return in(jvms->stkoff() + idx);\n+  Node* stack(const JVMState* jvms, uint idx) const {\n+    uint stk_idx = jvms->stkoff() + idx;\n+    assert(jvms->is_stk(stk_idx), \"not a stack slot\");\n+    verify_input(jvms, stk_idx);\n+    return in(stk_idx);\n@@ -394,2 +402,4 @@\n-  Node *argument(JVMState* jvms, uint idx) const {\n-    verify_input(jvms, jvms->argoff() + idx);\n+  Node* argument(const JVMState* jvms, uint idx) const {\n+    uint arg_idx = jvms->argoff() + idx;\n+    assert(jvms->is_stk(arg_idx), \"not an argument slot\");\n+    verify_input(jvms, arg_idx);\n@@ -398,1 +408,1 @@\n-  Node *monitor_box(JVMState* jvms, uint idx) const {\n+  Node* monitor_box(const JVMState* jvms, uint idx) const {\n@@ -400,1 +410,3 @@\n-    return in(jvms->monitor_box_offset(idx));\n+    uint mon_box_idx = jvms->monitor_box_offset(idx);\n+    assert(jvms->is_monitor_box(mon_box_idx), \"not a monitor box offset\");\n+    return in(mon_box_idx);\n@@ -402,1 +414,1 @@\n-  Node *monitor_obj(JVMState* jvms, uint idx) const {\n+  Node* monitor_obj(const JVMState* jvms, uint idx) const {\n@@ -404,1 +416,3 @@\n-    return in(jvms->monitor_obj_offset(idx));\n+    uint mon_obj_idx = jvms->monitor_obj_offset(idx);\n+    assert(jvms->is_mon(mon_obj_idx) && !jvms->is_monitor_box(mon_obj_idx), \"not a monitor obj offset\");\n+    return in(mon_obj_idx);\n@@ -407,1 +421,1 @@\n-  void  set_local(JVMState* jvms, uint idx, Node *c);\n+  void  set_local(const JVMState* jvms, uint idx, Node *c);\n@@ -409,1 +423,1 @@\n-  void  set_stack(JVMState* jvms, uint idx, Node *c) {\n+  void  set_stack(const JVMState* jvms, uint idx, Node *c) {\n@@ -413,1 +427,1 @@\n-  void  set_argument(JVMState* jvms, uint idx, Node *c) {\n+  void  set_argument(const JVMState* jvms, uint idx, Node *c) {\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -91,1 +92,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -2789,1 +2789,1 @@\n-static uint eval_operand(Node* n, ResourceHashtable<Node*,uint>& eval_map) {\n+static uint eval_operand(Node* n, HashTable<Node*,uint>& eval_map) {\n@@ -2797,1 +2797,1 @@\n-                          ResourceHashtable<Node*,uint>& eval_map) {\n+                          HashTable<Node*,uint>& eval_map) {\n@@ -2821,1 +2821,1 @@\n-  ResourceHashtable<Node*,uint> eval_map;\n+  HashTable<Node*,uint> eval_map;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2312,7 +2312,9 @@\n-        assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n-        ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n-        uint i = 0;\n-        for (; i < call->row_limit(); i++) {\n-          ciKlass* receiver = call->receiver(i);\n-          if (receiver != nullptr) {\n-            break;\n+        if (TypeProfileCasts) {\n+          assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n+          ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n+          uint i = 0;\n+          for (; i < call->row_limit(); i++) {\n+            ciKlass* receiver = call->receiver(i);\n+            if (receiver != nullptr) {\n+              break;\n+            }\n@@ -2320,0 +2322,1 @@\n+          ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n@@ -2321,1 +2324,0 @@\n-        ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n@@ -4077,1 +4079,3 @@\n-  add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n+  if (UseAutoVectorizationPredicate) {\n+    add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -643,2 +643,2 @@\n-        int written_chars = os::snprintf_checked(buffer, sizeof(buffer), \"%d\", value);\n-        if (written_chars <= 4) {\n+        int written_chars = os::snprintf(buffer, sizeof(buffer), \"%d\", value);\n+        if (written_chars > 0 && written_chars <= 4) {\n@@ -657,2 +657,2 @@\n-        int written_chars = os::snprintf_checked(buffer, sizeof(buffer), JLONG_FORMAT, value);\n-        if (written_chars <= 4) {\n+        int written_chars = os::snprintf(buffer, sizeof(buffer), JLONG_FORMAT, value);\n+        if (written_chars > 0 && written_chars <= 4) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -942,1 +942,5 @@\n-void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {\n+void LibraryCallKit::generate_string_range_check(Node* array,\n+                                                 Node* offset,\n+                                                 Node* count,\n+                                                 bool char_count,\n+                                                 bool halt_on_oob) {\n@@ -960,4 +964,11 @@\n-    PreserveJVMState pjvms(this);\n-    set_control(_gvn.transform(bailout));\n-    uncommon_trap(Deoptimization::Reason_intrinsic,\n-                  Deoptimization::Action_maybe_recompile);\n+    if (halt_on_oob) {\n+      bailout = _gvn.transform(bailout)->as_Region();\n+      Node* frame = _gvn.transform(new ParmNode(C->start(), TypeFunc::FramePtr));\n+      Node* halt = _gvn.transform(new HaltNode(bailout, frame, \"unexpected guard failure in intrinsic\"));\n+      C->root()->add_req(halt);\n+    } else {\n+      PreserveJVMState pjvms(this);\n+      set_control(_gvn.transform(bailout));\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_maybe_recompile);\n+    }\n@@ -1121,0 +1132,1 @@\n+\/\/ int java.lang.StringCoding#countPositives0(byte[] ba, int off, int len)\n@@ -1132,6 +1144,6 @@\n-  ba = must_be_not_null(ba, true);\n-\n-  \/\/ Range checks\n-  generate_string_range_check(ba, offset, len, false);\n-  if (stopped()) {\n-    return true;\n+  if (VerifyIntrinsicChecks) {\n+    ba = must_be_not_null(ba, true);\n+    generate_string_range_check(ba, offset, len, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n@@ -1139,0 +1151,1 @@\n+\n@@ -3278,1 +3291,1 @@\n-  lease_result_value->init_req(_true_path, null()); \/\/ if the lease was returned, return 0.\n+  lease_result_value->init_req(_true_path, _gvn.longcon(0)); \/\/ if the lease was returned, return 0L.\n@@ -4778,10 +4791,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n-      Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n-      Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n-\n-      generate_slow_guard(test_monitor, slow_region);\n-    } else {\n-      Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n-      Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n-      Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n@@ -4789,2 +4795,1 @@\n-      generate_slow_guard(test_not_unlocked, slow_region);\n-    }\n+    generate_slow_guard(test_monitor, slow_region);\n@@ -6131,0 +6136,3 @@\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n@@ -6141,2 +6149,8 @@\n-  src = must_be_not_null(src, true);\n-  dst = must_be_not_null(dst, true);\n+  \/\/ Cast source & target arrays to not-null\n+  if (VerifyIntrinsicChecks) {\n+    src = must_be_not_null(src, true);\n+    dst = must_be_not_null(dst, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n@@ -6159,0 +6173,9 @@\n+  \/\/ Check source & target bounds\n+  if (VerifyIntrinsicChecks) {\n+    generate_string_range_check(src, src_offset, length, src_elem == T_BYTE, true);\n+    generate_string_range_check(dst, dst_offset, length, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":49,"deletions":26,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -166,1 +166,2 @@\n-                                    Node* length, bool char_count);\n+                                    Node* length, bool char_count,\n+                                    bool halt_on_oob = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -484,0 +484,2 @@\n+\/\/ For more descriptions on multiversioning:\n+\/\/ See: PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/c2_globals.hpp\"\n@@ -1136,5 +1137,7 @@\n-    \/\/ We only want to use the auto-vectorization check as a trap once per bci. And\n-    \/\/ PhaseIdealLoop::add_parse_predicate only checks trap limits per method, so\n-    \/\/ we do a custom check here.\n-    if (!C->too_many_traps(cloned_sfpt->jvms()->method(), cloned_sfpt->jvms()->bci(), Deoptimization::Reason_auto_vectorization_check)) {\n-      add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, inner_head, outer_ilt, cloned_sfpt);\n+    if (UseAutoVectorizationPredicate) {\n+      \/\/ We only want to use the auto-vectorization check as a trap once per bci. And\n+      \/\/ PhaseIdealLoop::add_parse_predicate only checks trap limits per method, so\n+      \/\/ we do a custom check here.\n+      if (!C->too_many_traps(cloned_sfpt->jvms()->method(), cloned_sfpt->jvms()->bci(), Deoptimization::Reason_auto_vectorization_check)) {\n+        add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, inner_head, outer_ilt, cloned_sfpt);\n+      }\n@@ -4645,0 +4648,3 @@\n+  if (UseAutoVectorizationPredicate && predicates.auto_vectorization_check_block()->is_non_empty()) {\n+    tty->print(\" auto_vectorization_check_predicate\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1633,0 +1633,58 @@\n+private:\n+  \/\/ Class to keep track of wins in split_thru_phi.\n+  class SplitThruPhiWins {\n+  private:\n+    \/\/ Region containing the phi we are splitting through.\n+    const Node* _region;\n+\n+    \/\/ Sum of all wins regardless of where they happen. This applies to Loops phis as well as non-loop phis.\n+    int _total_wins;\n+\n+    \/\/ For Loops, wins have different impact depending on if they happen on loop entry or on the backedge.\n+    \/\/ Number of wins on a loop entry edge if the split is through a loop head,\n+    \/\/ otherwise 0. Entry edge wins only pay dividends once on loop entry.\n+    int _loop_entry_wins;\n+    \/\/ Number of wins on a loop back-edge, which pay dividends on every iteration.\n+    int _loop_back_wins;\n+\n+  public:\n+    SplitThruPhiWins(const Node* region) :\n+      _region(region),\n+      _total_wins(0),\n+      _loop_entry_wins(0),\n+      _loop_back_wins(0) {};\n+\n+    void reset() {_total_wins = 0; _loop_entry_wins = 0; _loop_back_wins = 0;}\n+    void add_win(int ctrl_index) {\n+      if (_region->is_Loop() && ctrl_index == LoopNode::EntryControl) {\n+        _loop_entry_wins++;\n+      } else if (_region->is_Loop() && ctrl_index == LoopNode::LoopBackControl) {\n+        _loop_back_wins++;\n+      }\n+      _total_wins++;\n+    }\n+    \/\/ Is this split profitable with respect to the policy?\n+    bool profitable(int policy) const {\n+      assert(_region->is_Loop() || (_loop_entry_wins == 0 && _loop_back_wins == 0), \"wins on loop edges without a loop\");\n+      assert(!_region->is_Loop() || _total_wins == _loop_entry_wins + _loop_back_wins, \"missed some win\");\n+      \/\/ In general this means that the split has to have more wins than specified\n+      \/\/ in the policy. However, for loops we need to take into account where the\n+      \/\/ wins happen. We need to be careful when splitting, because splitting nodes\n+      \/\/ related to the iv through the phi can sufficiently rearrange the loop\n+      \/\/ structure to prevent RCE and thus vectorization. Thus, we only deem splitting\n+      \/\/ profitable if the win of a split is not on the entry edge, as such wins\n+      \/\/ only pay off once and have a high chance of messing up the loop structure.\n+      return (_loop_entry_wins == 0 && _total_wins > policy) ||\n+      \/\/ If there are wins on the entry edge but the backadge also has sufficient wins,\n+      \/\/ there is sufficient profitability to spilt regardless of the risk of messing\n+      \/\/ up the loop structure.\n+             _loop_back_wins > policy ||\n+      \/\/ If the policy is less than 0, a split is always profitable, i.e. we always\n+      \/\/ split. This is needed when we split a node and then must also split a\n+      \/\/ dependant node, i.e. spliting a Bool node after splitting a Cmp node.\n+             policy < 0;\n+    }\n+  };\n+\n+public:\n+\n@@ -1985,1 +2043,1 @@\n-        \/\/ Use 107 as best guess which is the first resize value in ResizeableResourceHashtable::large_table_sizes.\n+        \/\/ Use 107 as best guess which is the first resize value in ResizeableHashTable::large_table_sizes.\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -69,1 +70,1 @@\n-  int wins = 0;\n+  SplitThruPhiWins wins(region);\n@@ -122,1 +123,1 @@\n-      wins++;\n+      wins.add_win(i);\n@@ -137,1 +138,1 @@\n-        wins++;\n+        wins.add_win(i);\n@@ -145,1 +146,1 @@\n-          wins++;\n+          wins.add_win(i);\n@@ -168,1 +169,1 @@\n-      wins = 0;\n+      wins.reset();\n@@ -173,1 +174,1 @@\n-  if (wins <= policy) {\n+  if (!wins.profitable(policy)) {\n@@ -230,0 +231,7 @@\n+#ifndef PRODUCT\n+  if (TraceLoopOpts) {\n+    tty->print_cr(\"Split %d %s through %d Phi in %d %s\",\n+                  n->_idx, n->Name(), phi->_idx, region->_idx, region->Name());\n+  }\n+#endif \/\/ !PRODUCT\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -44,0 +44,1 @@\n+  assert(_raw_summands.is_empty(), \"no prior parsing\");\n@@ -49,0 +50,8 @@\n+#ifndef PRODUCT\n+  if (trace.is_trace_parsing()) {\n+    tty->print_cr(\"MemPointerParser::parse: size=%d\", size);\n+    tty->print(\"  mem:     \"); _mem->dump();\n+    tty->print(\"  pointer: \"); pointer->dump();\n+  }\n+#endif\n+\n@@ -50,1 +59,1 @@\n-  _worklist.push(MemPointerSummand(pointer, NoOverflowInt(1)));\n+  _worklist.push(MemPointerRawSummand::make_trivial(pointer));\n@@ -63,3 +72,61 @@\n-  \/\/ Bail out if there is a constant overflow.\n-  if (_con.is_NaN()) {\n-    return MemPointer::make_trivial(pointer, size NOT_PRODUCT(COMMA trace));\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerRawSummand::print_on(tty, _raw_summands); } )\n+  canonicalize_raw_summands();\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerRawSummand::print_on(tty, _raw_summands); } )\n+\n+  create_summands();\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerSummand::print_on(tty, _con, _summands); } )\n+  canonicalize_summands();\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerSummand::print_on(tty, _con, _summands); } )\n+\n+  return MemPointer::make(pointer, _raw_summands, _con, _summands, size NOT_PRODUCT(COMMA trace));\n+}\n+\n+void MemPointerParser::canonicalize_raw_summands() {\n+  \/\/ We sort by:\n+  \/\/  - int group id\n+  \/\/  - variable idx\n+  \/\/ This means that summands of the same int group with the same variable are consecutive.\n+  \/\/ This simplifies the combining of summands below.\n+  _raw_summands.sort(MemPointerRawSummand::cmp_by_int_group_and_variable_idx);\n+\n+  \/\/ Combine summands of the same int group with the same variable, adding up the scales.\n+  int pos_put = 0;\n+  int pos_get = 0;\n+  while (pos_get < _raw_summands.length()) {\n+    const MemPointerRawSummand& summand = _raw_summands.at(pos_get++);\n+    Node* variable      = summand.variable();\n+    NoOverflowInt scaleI = summand.scaleI();\n+    NoOverflowInt scaleL = summand.scaleL();\n+    int int_group = summand.int_group();\n+    \/\/ Add up scale of all summands with the same variable.\n+    while (pos_get < _raw_summands.length() &&\n+           _raw_summands.at(pos_get).int_group() == int_group &&\n+           _raw_summands.at(pos_get).variable() == variable) {\n+      MemPointerRawSummand s = _raw_summands.at(pos_get++);\n+      if (int_group == 0) {\n+        assert(scaleI.is_one() && s.scaleI().is_one(), \"no ConvI2L\");\n+        scaleL = scaleL + s.scaleL();\n+      } else {\n+        assert(scaleL.value() == s.scaleL().value(), \"same ConvI2L, same scaleL\");\n+        scaleI = scaleI + s.scaleI();\n+      }\n+    }\n+    \/\/ Keep summands with non-zero scale.\n+    if (!scaleI.is_zero() && !scaleL.is_NaN()) {\n+      _raw_summands.at_put(pos_put++, MemPointerRawSummand(variable, scaleI, scaleL, int_group));\n+    }\n+  }\n+  _raw_summands.trunc_to(pos_put);\n+}\n+\n+void MemPointerParser::create_summands() {\n+  assert(_con.is_zero(), \"no prior parsing\");\n+  assert(_summands.is_empty(), \"no prior parsing\");\n+\n+  for (int i = 0; i < _raw_summands.length(); i++) {\n+    const MemPointerRawSummand& raw_summand = _raw_summands.at(i);\n+    if (raw_summand.is_con()) {\n+      _con = _con + raw_summand.to_con();\n+    } else {\n+      _summands.push(raw_summand.to_summand());\n+    }\n@@ -67,0 +134,1 @@\n+}\n@@ -68,0 +136,1 @@\n+void MemPointerParser::canonicalize_summands() {\n@@ -84,4 +153,0 @@\n-    \/\/ Bail out if scale is NaN.\n-    if (scale.is_NaN()) {\n-      return MemPointer::make_trivial(pointer, size NOT_PRODUCT(COMMA trace));\n-    }\n@@ -94,2 +159,0 @@\n-\n-  return MemPointer::make(pointer, _summands, _con, size NOT_PRODUCT(COMMA trace));\n@@ -101,1 +164,1 @@\n-void MemPointerParser::parse_sub_expression(const MemPointerSummand& summand, MemPointerParserCallback& callback) {\n+void MemPointerParser::parse_sub_expression(const MemPointerRawSummand& summand, MemPointerParserCallback& callback) {\n@@ -103,1 +166,3 @@\n-  const NoOverflowInt scale = summand.scale();\n+  const NoOverflowInt scaleI = summand.scaleI();\n+  const NoOverflowInt scaleL = summand.scaleL();\n+  const int int_group = summand.int_group();\n@@ -107,1 +172,1 @@\n-  if (is_safe_to_decompose_op(opc, scale)) {\n+  if (is_safe_to_decompose_op(opc, scaleI * scaleL)) {\n@@ -112,1 +177,1 @@\n-        \/\/ Terminal: add to constant.\n+        \/\/ Terminal summand.\n@@ -115,1 +180,3 @@\n-        _con = _con + scale * con;\n+        NoOverflowInt conI = (int_group == 0) ? scaleI : scaleI * con;\n+        NoOverflowInt conL = (int_group == 0) ? scaleL * con : scaleL;\n+        _raw_summands.push(MemPointerRawSummand::make_con(conI, conL, int_group));\n@@ -125,2 +192,2 @@\n-        _worklist.push(MemPointerSummand(a, scale));\n-        _worklist.push(MemPointerSummand(b, scale));\n+        _worklist.push(MemPointerRawSummand(a, scaleI, scaleL, int_group));\n+        _worklist.push(MemPointerRawSummand(b, scaleI, scaleL, int_group));\n@@ -137,1 +204,3 @@\n-        NoOverflowInt sub_scale = NoOverflowInt(-1) * scale;\n+        \/\/                   int_group  x.scaleI  x.scaleL  y.scaleI  y.scaleL\n+        \/\/ 2L * (x - y)      0          1         2         1         -2\n+        \/\/ ConvI2L(x - y)    1          1         1         -1        1\n@@ -139,2 +208,5 @@\n-        _worklist.push(MemPointerSummand(a, scale));\n-        _worklist.push(MemPointerSummand(b, sub_scale));\n+        NoOverflowInt sub_scaleI = (int_group == 0) ? scaleI : scaleI * NoOverflowInt(-1);\n+        NoOverflowInt sub_scaleL = (int_group == 0) ? scaleL * NoOverflowInt(-1) : scaleL;\n+\n+        _worklist.push(MemPointerRawSummand(a,     scaleI,     scaleL, int_group));\n+        _worklist.push(MemPointerRawSummand(b, sub_scaleI, sub_scaleL, int_group));\n@@ -172,2 +244,6 @@\n-        \/\/ Accumulate scale.\n-        NoOverflowInt new_scale = scale * factor;\n+        \/\/                         int_group  x.scaleI  x.scaleL\n+        \/\/ 2L * (4L * x)           0          1         8\n+        \/\/ 2L * ConvI2L(4 * x)     1          4         2\n+\n+        NoOverflowInt mul_scaleI = (int_group == 0) ? scaleI : scaleI * factor;\n+        NoOverflowInt mul_scaleL = (int_group == 0) ? scaleL * factor : scaleL;\n@@ -175,1 +251,1 @@\n-        _worklist.push(MemPointerSummand(variable, new_scale));\n+        _worklist.push(MemPointerRawSummand(variable, mul_scaleI, mul_scaleL, int_group));\n@@ -203,1 +279,10 @@\n-          _worklist.push(MemPointerSummand(a, scale));\n+\n+          int cast_int_group = int_group;\n+#ifdef _LP64\n+          if (opc == Op_ConvI2L) {\n+            assert(int_group == 0, \"only find ConvI2L once\");\n+            \/\/ We just discovered a new ConvI2L, and this creates a new \"int group\".\n+            cast_int_group = _next_int_group++;\n+          }\n+#endif\n+          _worklist.push(MemPointerRawSummand(a, scaleI, scaleL, cast_int_group));\n@@ -215,1 +300,1 @@\n-  _summands.push(summand);\n+  _raw_summands.push(summand);\n@@ -621,0 +706,52 @@\n+\/\/ Examples:\n+\/\/   p1 = MemPointer[size=1, base + i + 16]\n+\/\/   p2 = MemPointer[size=1, base + i + 17]\n+\/\/   -> Always at distance 1\n+\/\/   -> Can never overlap -> return false\n+\/\/\n+\/\/   p1 = MemPointer[size=1, base + i + 16]\n+\/\/   p2 = MemPointer[size=1, base + i + 16]\n+\/\/   -> Always at distance 0\n+\/\/   -> Always have exact overlap -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=4, x + y + z + 4L * i + 16]\n+\/\/   p2 = MemPointer[size=4, x + y + z + 4L * i + 56]\n+\/\/   -> Always at distance 40\n+\/\/   -> Can never overlap -> return false\n+\/\/\n+\/\/   p1 = MemPointer[size=8, x + y + z + 4L * i + 16]\n+\/\/   p2 = MemPointer[size=8, x + y + z + 4L * i + 20]\n+\/\/   -> Always at distance 4\n+\/\/   -> Always have partial overlap -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=4, base1 + 4L * i1 + 16]\n+\/\/   p2 = MemPointer[size=4, base2 + 4L * i2 + 20]\n+\/\/   -> Have differing summands, distance is unknown\n+\/\/   -> Unknown if overlap at runtime -> return false\n+bool MemPointer::always_overlaps_with(const MemPointer& other) const {\n+  const MemPointerAliasing aliasing = get_aliasing_with(other NOT_PRODUCT( COMMA _trace ));\n+\n+  \/\/ The aliasing tries to compute:\n+  \/\/   distance = other - this\n+  \/\/\n+  \/\/ We know that we have an overlap if we can prove:\n+  \/\/   this < other + other.size       &&  this + this.size > other\n+  \/\/\n+  \/\/ Which we can restate as:\n+  \/\/   distance > -other.size          &&  this.size > distance\n+  \/\/\n+  const jint distance_lo = -other.size();\n+  const jint distance_hi = size();\n+  bool is_always_overlap = aliasing.is_always_in_distance_range(distance_lo, distance_hi);\n+\n+#ifndef PRODUCT\n+  if (_trace.is_trace_overlap()) {\n+    tty->print(\"Always Overlap: %s, distance_lo: %d, distance_hi: %d, aliasing: \",\n+               is_always_overlap ? \"true\" : \"false\", distance_lo, distance_hi);\n+    aliasing.print_on(tty);\n+    tty->cr();\n+  }\n+#endif\n+\n+  return is_always_overlap;\n+}\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":163,"deletions":26,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+\/\/ A more advanced use case of MemPointers is speculative aliasing analysis. If we can prove that\n+\/\/ the MemPointer has a linear form in the loop induction variable (iv), we can formulate runtime\n+\/\/ checks to establish that two MemPointer never overlap for all iterations, i.e. for all iv values.\n+\/\/\n@@ -161,1 +165,1 @@\n-\/\/   Where each summand_i in summands has the form:\n+\/\/   Where each summand_i in summands has the MemPointerSummand form:\n@@ -270,0 +274,4 @@\n+\/\/   Even further down, we prove the \"MemPointer Linearity Corrolary\", where we show that\n+\/\/   (under reasonable restrictions) both the MemPointer and the corresponding pointer\n+\/\/   can be considered linear functions.\n+\/\/\n@@ -388,1 +396,97 @@\n-\n+\/\/\n+\/\/\n+\/\/ Having proven the \"MemPointer Lemma\", we can now derive an interesting corrolary.\n+\/\/\n+\/\/ With the \"Linearity Corrolary\" below, we can prove that some MemPointers can be treated as\n+\/\/ linear in some summand variable v over some range r. This is useful when MemPointers are\n+\/\/ used in loops, where v=iv scale_v=scale_iv and the range is the iv range from some initial\n+\/\/ iv value to the last iv value just before the limit.\n+\/\/ For an application, see: VPointer::make_speculative_aliasing_check_with\n+\/\/\n+\/\/ MemPointer Linearity Corrolary:\n+\/\/   Given:\n+\/\/     (C0) pointer p and its MemPointer mp, which is constructed with safe decompositions.\n+\/\/     (C1) a specific summand \"scale_v * v\" that occurs in mp.\n+\/\/     (C2) a strided range r = [lo, lo + stride_v, .. hi] for v (lo and hi are inclusive in the range).\n+\/\/     (C3) for all v in this strided range r we know that p is within bounds of its memory object.\n+\/\/     (C4) abs(scale_v * stride_v) < 2^31\n+\/\/            Required for (S2) in application of MemPointer Lemma below, it is essencial in\n+\/\/            establishing linearity of mp.\n+\/\/\n+\/\/   Then:\n+\/\/     Both p and mp have a linear form for v in r:\n+\/\/       p(v)  = p(lo)  - lo * scale_v + v * scale_v              (Corrolary P)\n+\/\/       mp(v) = mp(lo) - lo * scale_v + v * scale_v              (Corrolary MP)\n+\/\/\n+\/\/     Note: the calculations are done in long, and hence there can be no int overflow.\n+\/\/           Thus, p(v) and mp(v) can be considered linear functions for v in r.\n+\/\/\n+\/\/   It can be useful to \"anchor\" at hi instead of lo:\n+\/\/     p(hi) = p(lo) - lo * scale_v + hi * scale_v\n+\/\/\n+\/\/     p(v) = p(lo) - lo * scale_v + v * scale_v\n+\/\/            --------------------\n+\/\/          = p(hi) - hi * scale_v + v * scale_v             (Alternative Corrolary P)\n+\/\/\n+\/\/\n+\/\/ Proof of \"MemPointer Linearity Corrolary\":\n+\/\/   We state the form of mp:\n+\/\/\n+\/\/     mp = summand_rest + scale_v * v + con\n+\/\/\n+\/\/   We prove the Corrolary by induction over v:\n+\/\/   Base Case: v = lo\n+\/\/     p(lo)  = p(lo)  - lo * scale_v + lo * scale_v\n+\/\/     mp(lo) = mp(lo) - lo * scale_v + lo * scale_v\n+\/\/\n+\/\/   Step Case: v0 and v1 in r, v1 = v0 + stride_v\n+\/\/     Assume:\n+\/\/       p(v0)  = p(lo)  - lo * scale_v + v * scale_v          (Induction Hypothesis IH-P)\n+\/\/       mp(v0) = mp(lo) - lo * scale_v + v * scale_v          (Induction Hypothesis IH-MP)\n+\/\/\n+\/\/     We take the form of mp, and further apply SAFE1 decompositions, i.e. long addition,\n+\/\/     subtraction and multiplication:\n+\/\/       mp(v1) = summand_rest + scale_v * v1                                   + con\n+\/\/              = summand_rest + scale_v * (v0 + stride_v)                      + con\n+\/\/              = summand_rest + scale_v * v0              + scale_v * stride_v + con\n+\/\/              = mp(v0)                                   + scale_v * stride_v\n+\/\/\n+\/\/     From this it follows that we can see mp(v0) and mp(v1) as two MemPointer with the\n+\/\/     same summands, and only their constants differ by exactly \"scale_v * stride_v\":\n+\/\/       mp(v0) = summand_rest + scale_v * v0 + con\n+\/\/       mp(v1) = summand_rest + scale_v * v0 + con + scale_v * stride_v            (MP-DIFF)\n+\/\/\n+\/\/     We continue by applying the Induction Hypothesis IH-MP\n+\/\/       mp(v1) = mp(v0)                                + scale_v * stride_v\n+\/\/                -------- apply (IH-MP) -------------\n+\/\/              = mp(lo) - lo * scale_v + v0 * scale_v  + scale_v * stride_v\n+\/\/              = mp(lo) - lo * scale_v + (v0 + stride_v) * scale_v\n+\/\/              = mp(lo) - lo * scale_v + v1 * scale_v\n+\/\/\n+\/\/     This proves the Corrolary MP.\n+\/\/\n+\/\/     To prove the Corrolary P, we now apply the MemPointer Lemma:\n+\/\/       (S0) Let p(v0) and p(v1) be the pointers corresponding to v0 and v1, and mp(v0) and mp(v1)\n+\/\/            their MemPointer. (C0) provides the safe deconstruction, and reformulation of terms\n+\/\/            happens with long addition, subtraction and multiplication only, and is hence SAFE\n+\/\/            as well.\n+\/\/       (S1) According to (C3), p is in bounds of its memory object for all v in r. Since v0 and\n+\/\/            v1 are in r, it follows that p(v0) and p(v1) are in bounds of the same memory object.\n+\/\/       (S2) The difference of constants of mp(v0) and mp(v1) is exactly \"scale_v * stride_v\" (MP-DIFF).\n+\/\/            Given (C4), this difference is not too large.\n+\/\/       (S3) All summands of mp0 and mp1 are the same (only the constants differ), given (MP-DIFF).\n+\/\/\n+\/\/     It follows:\n+\/\/       p(v1) - p(v0) = mp(v1) - mp(v0)\n+\/\/\n+\/\/     Reformulating and applying (MP-DIFF) and (IH-P):\n+\/\/       p(v1) = p(v0)                                  + mp(v1) - mp(v1)\n+\/\/                                                        apply (MP-DIFF)\n+\/\/             = p(v0)                                  + scale_v * stride_v\n+\/\/               ------------ apply (IH-P) ------------\n+\/\/             = p(lo) - lo * scale_v + v0 * scale_v    + scale_v * stride_v\n+\/\/             = p(lo) - lo * scale_v + (v0 + stride_v) * scale_v\n+\/\/             = p(lo) - lo * scale_v + v1 * scale_v\n+\/\/\n+\/\/     This proves Corrolary P.\n+\/\/\n@@ -469,0 +573,7 @@\n+  \/\/ Use case: overlap.\n+  \/\/ Note: the bounds are exclusive: lo < element < hi\n+  bool is_always_in_distance_range(const jint distance_lo, const jint distance_hi) const {\n+    return _aliasing == AlwaysAtDistance &&\n+           (distance_lo < _distance && _distance < distance_hi);\n+  }\n+\n@@ -543,1 +654,161 @@\n-    tty->print(\" * [%d %s]\", _variable->_idx, _variable->Name());\n+    st->print(\" * [%d %s]\", _variable->_idx, _variable->Name());\n+  }\n+\n+  static void print_on(outputStream* st, NoOverflowInt con, const GrowableArray<MemPointerSummand>& summands) {\n+    st->print(\"Summands (%d): con(\", summands.length());\n+    con.print_on(st);\n+    st->print(\")\");\n+    for (int i = 0; i < summands.length(); i++) {\n+      st->print(\" + \");\n+      summands.at(i).print_on(tty);\n+    }\n+    st->cr();\n+  }\n+#endif\n+};\n+\n+\/\/ We need two different ways of tracking the summands:\n+\/\/ - MemPointerRawSummand: designed to keep track of the original form of\n+\/\/                         the pointer, preserving its overflow behavior.\n+\/\/ - MemPointerSummand:    designed to allow simplification of the MemPointer\n+\/\/                         form, does not preserve the original form and\n+\/\/                         ignores overflow from ConvI2L.\n+\/\/\n+\/\/ The MemPointerSummand is designed to allow the simplification of\n+\/\/ the MemPointer form as much as possible, to allow aliasing checks\n+\/\/ to be as simple as possible. For example, the C2 IR pointer:\n+\/\/\n+\/\/   pointer = AddP(\n+\/\/               AddP(\n+\/\/                 base,\n+\/\/                 LShiftL(\n+\/\/                   ConvI2L(\n+\/\/                     AddI(AddI(i, LShiftI(j, 2)), con1)\n+\/\/                   ),\n+\/\/                   1\n+\/\/                 )\n+\/\/               ),\n+\/\/               con2\n+\/\/             )\n+\/\/\n+\/\/ and more readable:\n+\/\/\n+\/\/   pointer = base + 2L * ConvI2L(i + 4 * j + con1) + con2\n+\/\/\n+\/\/ is simplified to this MemPointer form, using only MemPointerSummands,\n+\/\/ which ignore the possible overflow in ConvI2L:\n+\/\/\n+\/\/   pointer = base + 2L * ConvI2L(i) + 8L * ConvI2L(j) + con\n+\/\/   con = 2L * con1 + con2\n+\/\/\n+\/\/ This is really convenient, because this way we are able to ignore\n+\/\/ the ConvI2L in the aliasing anaylsis computation, and we can collect\n+\/\/ all constants to a single constant. Even with this simplicication,\n+\/\/ we are able to prove the correctness of the aliasing checks.\n+\/\/\n+\/\/ However, there is one thing we are not able to do with this simplification:\n+\/\/ we cannot reconstruct the original pointer expression, because the\n+\/\/ simplification ignores overflows that could happen inside the ConvI2L:\n+\/\/\n+\/\/   2L * ConvI2L(i + 4 * j + con1) != 2L * ConvI2L(i) + 8L * ConvI2L(j) + 2L * con1\n+\/\/\n+\/\/ The MemPointerRawSummand is designed to keep track of the original form\n+\/\/ of the pointer, preserving its overflow behaviour. We observe that the\n+\/\/ only critical point for overflows is at the ConvI2L. Thus, we give each\n+\/\/ ConvI2L a \"int group\" id > 0, and all raw summands belonging to that ConvI2L\n+\/\/ have that id. This allows us to reconstruct which raw summands need to\n+\/\/ be added together before the ConvI2L. Any raw summands that do not belong\n+\/\/ to a ConvI2L (i.e. the summands with long variables) have \"int group\"\n+\/\/ id = 0, since they do not belong to any such \"int group\" and can be\n+\/\/ directly added together. For raw summands belonging to an \"int group\",\n+\/\/ we need to track the scale inside (scaleI) and outside (scaleL) the\n+\/\/ ConvI2L. With the example from above:\n+\/\/\n+\/\/   pointer = base + 2L * ConvI2L(i + 4 * j + con1) + con2\n+\/\/\n+\/\/   _variable  = base  _variable  = i  _variable  = j  _variable  = null  _variable  = null\n+\/\/   _scaleI    = 1     _scaleI    = 1  _scaleI    = 4  _scaleI    = con1  _scaleI    = 1\n+\/\/   _scaleL    = 1     _scaleL    = 2  _scaleL    = 2  _scaleL    = 2     _scaleL    = con2\n+\/\/   _int_group = 0     _int_group = 1  _int_group = 1  _int_group = 1     _int_group = 0\n+\/\/\n+\/\/ Note: we also need to track constants as separate raw summands. For\n+\/\/       this, we say that a raw summand tracks a constant iff _variable == null,\n+\/\/       and we store the constant value in _scaleI (for int constant) and in\n+\/\/       _scaleL (for long constants).\n+\/\/\n+class MemPointerRawSummand : public StackObj {\n+private:\n+  Node* _variable;\n+  NoOverflowInt _scaleI;\n+  NoOverflowInt _scaleL;\n+  int _int_group;\n+\n+public:\n+  MemPointerRawSummand(Node* variable, NoOverflowInt scaleI, NoOverflowInt scaleL, int int_group) :\n+    _variable(variable), _scaleI(scaleI), _scaleL(scaleL), _int_group(int_group) {}\n+\n+  MemPointerRawSummand() :\n+    MemPointerRawSummand(nullptr, NoOverflowInt::make_NaN(), NoOverflowInt::make_NaN(), -1) {}\n+\n+  static MemPointerRawSummand make_trivial(Node* variable) {\n+    assert(variable != nullptr, \"must have variable\");\n+    return MemPointerRawSummand(variable, NoOverflowInt(1), NoOverflowInt(1), 0);\n+  }\n+\n+  static MemPointerRawSummand make_con(NoOverflowInt scaleI, NoOverflowInt scaleL, int int_group) {\n+    return MemPointerRawSummand(nullptr, scaleI, scaleL, int_group);\n+  }\n+\n+  bool is_valid() const { return _int_group >= 0; }\n+  bool is_con() const { assert(is_valid(), \"\"); return _variable == nullptr; }\n+  Node* variable() const { assert(is_valid(), \"\"); return _variable; }\n+  NoOverflowInt scaleI() const { assert(is_valid(), \"\"); return _scaleI; }\n+  NoOverflowInt scaleL() const { assert(is_valid(), \"\"); return _scaleL; }\n+  int int_group() const { assert(is_valid(), \"\"); return _int_group; }\n+\n+  MemPointerSummand to_summand() const {\n+    assert(!is_con(), \"must be variable\");\n+    return MemPointerSummand(variable(), scaleL() * scaleI());\n+  }\n+\n+  NoOverflowInt to_con() const {\n+    assert(is_con(), \"must be constant\");\n+    return scaleL() * scaleI();\n+  }\n+\n+  static int cmp_by_int_group_and_variable_idx(MemPointerRawSummand* p1, MemPointerRawSummand* p2) {\n+    int int_group_diff = p1->int_group() - p2->int_group();\n+    if (int_group_diff != 0) { return int_group_diff; }\n+\n+    if (p1->is_con()) {\n+      return p2->is_con() ? 0 : 1;\n+    }\n+    if (p2->is_con()) {\n+      return -1;\n+    }\n+    return p1->variable()->_idx - p2->variable()->_idx;\n+  }\n+\n+#ifndef PRODUCT\n+  void print_on(outputStream* st) const {\n+    if (!is_valid()) {\n+      st->print(\"<invalid>\");\n+    } else {\n+      st->print(\"<%d: \", _int_group);\n+      _scaleL.print_on(st);\n+      st->print(\" * \");\n+      _scaleI.print_on(st);\n+      if (!is_con()) {\n+        st->print(\" * [%d %s]\", _variable->_idx, _variable->Name());\n+      }\n+      st->print(\">\");\n+    }\n+  }\n+\n+  static void print_on(outputStream* st, const GrowableArray<MemPointerRawSummand>& summands) {\n+    st->print(\"Raw Summands (%d): \", summands.length());\n+    for (int i = 0; i < summands.length(); i++) {\n+      if (i > 0) { st->print(\" + \"); }\n+      summands.at(i).print_on(tty);\n+    }\n+    st->cr();\n@@ -585,4 +856,7 @@\n-  \/\/ We limit the number of summands to 10. This is just a best guess, and not at this\n-  \/\/ point supported by evidence. But I think it is reasonable: usually, a pointer\n-  \/\/ contains a base pointer (e.g. array pointer or null for native memory) and a few\n-  \/\/ variables. It should be rare that we have more than 9 variables.\n+  \/\/ We limit the number of summands to 10, and the raw summands to 16. This is just a\n+  \/\/ best guess, and not at this point supported by evidence. But I think it is reasonable:\n+  \/\/ usually, a pointer contains a base pointer (e.g. array pointer or null for native memory)\n+  \/\/ and a few variables. It should be rare that we have more than 9 variables. We need\n+  \/\/ a few more raw summands, especially because there can be multiple constants, one\n+  \/\/ per ConvI2L \"int group\".\n+  static const int RAW_SUMMANDS_SIZE = 16;\n@@ -640,0 +914,7 @@\n+  \/\/ Raw summands: represent the pointer form exactly, allowing the reconstruction of the\n+  \/\/               pointer expression. Overflows inside the \"int groups\" (i.e. ConvI2L)\n+  \/\/               are preserved, and there may be multiple constants.\n+  MemPointerRawSummand _raw_summands[RAW_SUMMANDS_SIZE];\n+\n+  \/\/ Summands:     Simplified form, with only a single constant. Makes aliasing analysis\n+  \/\/               much simpler.\n@@ -643,0 +924,2 @@\n+\n+  \/\/ Size in bytes for the referenced memory region: [pointer, pointer + size)\n@@ -644,0 +927,1 @@\n+\n@@ -662,0 +946,1 @@\n+             const GrowableArray<MemPointerRawSummand>& raw_summands,\n@@ -673,0 +958,1 @@\n+    assert(raw_summands.length() <= RAW_SUMMANDS_SIZE, \"raw summands must fit\");\n@@ -679,0 +965,5 @@\n+    for (int i = 0; i < raw_summands.length(); i++) {\n+      const MemPointerRawSummand& s = raw_summands.at(i);\n+      assert(!s.scaleI().is_NaN(), \"non-NaN scale\");\n+      assert(!s.scaleL().is_NaN(), \"non-NaN scale\");\n+    }\n@@ -681,0 +972,5 @@\n+    \/\/ Copy raw summands in the same order.\n+    for (int i = 0; i < raw_summands.length(); i++) {\n+      _raw_summands[i] = raw_summands.at(i);\n+    }\n+\n@@ -711,0 +1007,5 @@\n+\n+    for (int i = 0; i < RAW_SUMMANDS_SIZE; i++) {\n+      _raw_summands[i] = old.raw_summands_at(i);\n+    }\n+\n@@ -736,0 +1037,2 @@\n+                         const GrowableArray<MemPointerRawSummand>& raw_summands,\n+                         const NoOverflowInt con,\n@@ -737,1 +1040,0 @@\n-                         const NoOverflowInt& con,\n@@ -740,2 +1042,4 @@\n-    if (summands.length() <= SUMMANDS_SIZE) {\n-      return MemPointer(pointer, summands, con, size NOT_PRODUCT(COMMA trace));\n+    if (raw_summands.length() <= RAW_SUMMANDS_SIZE &&\n+        summands.length() <= SUMMANDS_SIZE &&\n+        has_no_NaN_in_con_and_summands(con, summands)) {\n+      return MemPointer(pointer, raw_summands, summands, con, size NOT_PRODUCT(COMMA trace));\n@@ -747,0 +1051,9 @@\n+  static bool has_no_NaN_in_con_and_summands(const NoOverflowInt con,\n+                                             const GrowableArray<MemPointerSummand>& summands) {\n+    if (con.is_NaN()) { return false; }\n+    for (int i = 0; i < summands.length(); i++) {\n+      if (summands.at(i).scale().is_NaN()) { return false; }\n+    }\n+    return true;\n+  }\n+\n@@ -778,0 +1091,5 @@\n+  const MemPointerRawSummand& raw_summands_at(const uint i) const {\n+    assert(i < RAW_SUMMANDS_SIZE, \"in bounds\");\n+    return _raw_summands[i];\n+  }\n+\n@@ -782,0 +1100,19 @@\n+  int max_int_group() const {\n+    int n = 0;\n+    for (int i = 0; i < RAW_SUMMANDS_SIZE; i++) {\n+      const MemPointerRawSummand& s = _raw_summands[i];\n+      if (!s.is_valid()) { continue; }\n+      n = MAX2(n, s.int_group());\n+    }\n+    return n;\n+  }\n+\n+  template<typename Callback>\n+  void for_each_raw_summand_of_int_group(int int_group, Callback callback) const {\n+    for (int i = 0; i < RAW_SUMMANDS_SIZE; i++) {\n+      const MemPointerRawSummand& s = _raw_summands[i];\n+      if (!s.is_valid() || s.int_group() != int_group) { continue; }\n+      callback(s);\n+    }\n+  }\n+\n@@ -804,0 +1141,1 @@\n+  bool always_overlaps_with(const MemPointer& other) const;\n@@ -821,1 +1159,1 @@\n-  void print_on(outputStream* st, bool end_with_cr = true) const {\n+  void print_on(outputStream* st) const {\n@@ -827,1 +1165,42 @@\n-    if (end_with_cr) { st->cr(); }\n+    st->cr();\n+\n+    st->print(\"  raw: \");\n+\n+    int long_count = 0;\n+    for_each_raw_summand_of_int_group(0, [&] (const MemPointerRawSummand& s) {\n+      if (long_count > 0) { st->print(\" + \"); }\n+      long_count++;\n+      if (s.is_con()) {\n+        \/\/ Long constant.\n+        NoOverflowInt con = s.scaleI() * s.scaleL();\n+        con.print_on(st);\n+        st->print(\"L\");\n+      } else {\n+        \/\/ Long variable.\n+        assert(s.scaleI().is_one(), \"must be long variable\");\n+        s.scaleL().print_on(st);\n+        st->print(\"L * [%d %s]\", s.variable()->_idx, s.variable()->Name());\n+      }\n+    });\n+\n+    \/\/ Int groups, i.e. \"ConvI2L(...)\"\n+    for (int int_group = 1; int_group <= max_int_group(); int_group++) {\n+      if (long_count > 0) { st->print(\" + \"); }\n+      long_count++;\n+      int int_count = 0;\n+      for_each_raw_summand_of_int_group(int_group, [&] (const MemPointerRawSummand& s) {\n+        if (int_count == 0) {\n+          s.scaleL().print_on(st);\n+          st->print(\"L * ConvI2L(\");\n+        } else {\n+          st->print(\" + \");\n+        }\n+        int_count++;\n+        s.scaleI().print_on(st);\n+        if (!s.is_con()) {\n+          st->print(\" * [%d %s]\", s.variable()->_idx, s.variable()->Name());\n+        }\n+      });\n+      st->print(\")\");\n+    }\n+    st->cr();\n@@ -841,3 +1220,7 @@\n-  \/\/ Internal data-structures for parsing.\n-  NoOverflowInt _con;\n-  GrowableArray<MemPointerSummand> _worklist;\n+  \/\/ Internal data-structures for parsing raw summands.\n+  int _next_int_group = 1;\n+  GrowableArray<MemPointerRawSummand> _worklist;\n+  GrowableArray<MemPointerRawSummand> _raw_summands;\n+\n+  \/\/ Internal data-structures for parsing \"regular\" summands.\n+  NoOverflowInt _con = NoOverflowInt(0);\n@@ -853,1 +1236,0 @@\n-    _con(NoOverflowInt(0)),\n@@ -884,1 +1266,1 @@\n-  void parse_sub_expression(const MemPointerSummand& summand, MemPointerParserCallback& callback);\n+  void parse_sub_expression(const MemPointerRawSummand& summand, MemPointerParserCallback& callback);\n@@ -888,0 +1270,4 @@\n+\n+  void canonicalize_raw_summands();\n+  void create_summands();\n+  void canonicalize_summands();\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":403,"deletions":17,"binary":false,"changes":420,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-typedef ResizeableResourceHashtable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> OrigToNewHashtable;\n+typedef ResizeableHashTable<Node*, Node*, AnyObj::RESOURCE_AREA, mtCompiler> OrigToNewHashtable;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1152,0 +1152,7 @@\n+\n+  \/\/ Capture receiver info for compiled lambda forms.\n+  if (method()->is_compiled_lambda_form()) {\n+    ciInstance* recv_info = _caller->compute_receiver_info(method());\n+    jvms->set_receiver_info(recv_info);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1673,0 +1673,1 @@\n+    \/\/   Note: The -XX:LockingMode option is not available anymore.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"phasetype.hpp\"\n+\n+const char* const CompilerPhaseTypeHelper::_phase_descriptions[] = {\n+#define array_of_labels(name, description) description,\n+       COMPILER_PHASES(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+const char* const CompilerPhaseTypeHelper::_phase_names[] = {\n+#define array_of_labels(name, description) #name,\n+       COMPILER_PHASES(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+CompilerPhaseType CompilerPhaseTypeHelper::find_phase(const char* str) {\n+  for (int i = 0; i < PHASE_NUM_TYPES; i++) {\n+    if (strcmp(CompilerPhaseTypeHelper::_phase_names[i], str) == 0) {\n+      return (CompilerPhaseType)i;\n+    }\n+  }\n+  return PHASE_NONE;\n+}\n","filename":"src\/hotspot\/share\/opto\/phasetype.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -141,12 +141,0 @@\n-static const char* phase_descriptions[] = {\n-#define array_of_labels(name, description) description,\n-       COMPILER_PHASES(array_of_labels)\n-#undef array_of_labels\n-};\n-\n-static const char* phase_names[] = {\n-#define array_of_labels(name, description) #name,\n-       COMPILER_PHASES(array_of_labels)\n-#undef array_of_labels\n-};\n-\n@@ -154,1 +142,5 @@\n-  public:\n+ private:\n+  static const char* const _phase_descriptions[];\n+  static const char* const _phase_names[];\n+\n+ public:\n@@ -156,1 +148,1 @@\n-    return phase_names[cpt];\n+    return _phase_names[cpt];\n@@ -159,1 +151,1 @@\n-    return phase_descriptions[cpt];\n+    return _phase_descriptions[cpt];\n@@ -161,1 +153,0 @@\n-};\n@@ -163,8 +154,2 @@\n-static CompilerPhaseType find_phase(const char* str) {\n-  for (int i = 0; i < PHASE_NUM_TYPES; i++) {\n-    if (strcmp(phase_names[i], str) == 0) {\n-      return (CompilerPhaseType)i;\n-    }\n-  }\n-  return PHASE_NONE;\n-}\n+  static CompilerPhaseType find_phase(const char* str);\n+};\n@@ -186,1 +171,1 @@\n-      CompilerPhaseType cpt = find_phase(*iter);\n+      CompilerPhaseType cpt = CompilerPhaseTypeHelper::find_phase(*iter);\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/c2_globals.hpp\"\n@@ -47,4 +48,6 @@\n- *                    There are initially three Parse Predicates for each loop:\n- *                    - Loop Parse Predicate:             The Parse Predicate added for Loop Predicates.\n- *                    - Profiled Loop Parse Predicate:    The Parse Predicate added for Profiled Loop Predicates.\n- *                    - Loop Limit Check Parse Predicate: The Parse Predicate added for a Loop Limit Check Predicate.\n+ *                    There are initially five Parse Predicates for each loop:\n+ *                    - Loop Parse Predicate:               The Parse Predicate added for Loop Predicates.\n+ *                    - Profiled Loop Parse Predicate:      The Parse Predicate added for Profiled Loop Predicates.\n+ *                    - Loop Limit Check Parse Predicate:   The Parse Predicate added for a Loop Limit Check Predicate.\n+ *                    - Short Running Loop Parse Predicate: The Parse Predicate added for the short running long loop check.\n+ *                    - AutoVectorization Parse Predicate:  The Parse Predicate added for AutoVectorization runtime checks.\n@@ -52,1 +55,2 @@\n- *                      Loop Predicate) or a Loop Limit Check Predicate. These predicates will be checked at runtime while\n+ *                      Loop Predicate), a Loop Limit Check Predicate, a Short Running Long Loop Predicate, or a\n+ *                      AutoVectorization Runtime Check Predicate. These predicates will be checked at runtime while\n@@ -84,0 +88,15 @@\n+ *     - AutoVectorization:  This predicate is used for speculative runtime checks required for AutoVectorization.\n+ *       Runtime Check       There are multiple reasons why we need a runtime check to allow vectorization:\n+ *       Predicate           - Unknown aliasing:\n+ *                             An important compoinent of AutoVectorization is proving that memory addresses do not\n+ *                             alias, and can therefore be reordered. In some cases, this cannot be done statically\n+ *                             and a runtime check is necessary.\n+ *                           - Unknown alignment of native memory:\n+ *                             While heap objects have 8-byte alignment, off-heap (native) memory often has no alignment\n+ *                             guarantees. On platforms that require vectors to be aligned, we need to prove alignment.\n+ *                             We cannot do that statically with native memory, hence we need a runtime check.\n+ *                           The benefit of using a predicate is that we only have to compile the vectorized loop. If\n+ *                           the runtime check fails, we simply deoptimize. Should we eventually recompile, then the\n+ *                           predicate is not available any more, and we instead use a multiversioning approach with\n+ *                           both a vectorized and a scalar loop, where the runtime determines which loop is taken.\n+ *                           See: PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n@@ -160,1 +179,3 @@\n- *                    There are three different Predicate Blocks:\n+ *                    There are five different Predicate Blocks:\n+ *                    - Short Running Long    Groups the Short Running Long Loop Predicate (if created), and the\n+ *                      Loop Predicate Block: Short Running Long Loop Parse Predicate together.\n@@ -166,0 +187,3 @@\n+ *                    - AutoVectorization     Groups the AutoVectorization Runtime Check Predicates (if any), and the\n+ *                      Runtime Check         AutoVectorization Runtime Check Parse Predicate together.\n+ *                      Predicate Block:\n@@ -172,1 +196,4 @@\n- * (predicates inside square brackets [] do not need to exist if there are no checks to hoist):\n+ * (predicates inside square brackets [] do not need to exist if there are no checks to hoist \/ insert):\n+ *\n+ *   [Short Running Long Loop Predicate] (at most one)                 \\ Short Running Long\n+ * Short Running Long Loop Parse Predicate                             \/ Loop Predicate Block\n@@ -186,0 +213,6 @@\n+ *   [AutoVectorization Runtime Check Predicate 1]                     \\\n+ *   [AutoVectorization Runtime Check Predicate 2]                     | AutoVectorization\n+ *   ...                                                               | Runtime Check\n+ *   [AutoVectorization Runtime Check Predicate l]                     | Predicate Block\n+ * AutoVectorization Runtime Check Parse Predicate                     \/\n+ *\n@@ -785,2 +818,4 @@\n-    PredicateBlockIterator auto_vectorization_check_iterator(current_node, Deoptimization::Reason_auto_vectorization_check);\n-    current_node = auto_vectorization_check_iterator.for_each(predicate_visitor);\n+    if (UseAutoVectorizationPredicate) {\n+      PredicateBlockIterator auto_vectorization_check_iterator(current_node, Deoptimization::Reason_auto_vectorization_check);\n+      current_node = auto_vectorization_check_iterator.for_each(predicate_visitor);\n+    }\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -70,2 +70,4 @@\n-    static int cmp(int a, int b) {\n-      return a - b;\n+    static RBTreeOrdering cmp(int a, int b) {\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n","filename":"src\/hotspot\/share\/opto\/printinlining.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -697,0 +697,5 @@\n+\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n@@ -801,0 +806,6 @@\n+\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+\n@@ -942,0 +953,6 @@\n+\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+\n@@ -996,0 +1013,5 @@\n+  const Type* joined = r0->join(r1);\n+  if (joined == Type::TOP) {\n+    return TypeInt::CC_NE;\n+  }\n+\n@@ -1371,0 +1393,4 @@\n+  if( CC == TypeInt::CC_NE ) {\n+    if( _test == ne ) return TypeInt::ONE;\n+    if( _test == eq ) return TypeInt::ZERO;\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -464,0 +464,3 @@\n+\/\/ Runtime Checks:\n+\/\/   Some required properties cannot be proven statically, and require a\n+\/\/   runtime check. See VTransform::add_speculative_check\n@@ -835,0 +838,5 @@\n+  \/\/ If we can speculate (using the aliasing runtime check), we can drop the weak edges,\n+  \/\/ and later insert a runtime check.\n+  \/\/ If we cannot speculate (aliasing analysis runtime checks), we need to respect all edges.\n+  bool speculate_away_weak_edges = _vloop.use_speculative_aliasing_checks();\n+\n@@ -841,0 +849,1 @@\n+      if (speculate_away_weak_edges && preds.is_current_weak_memory_edge()) { continue; }\n@@ -872,0 +881,6 @@\n+\n+  \/\/ If we can speculate (using the aliasing runtime check), we can drop the weak edges,\n+  \/\/ and later insert a runtime check.\n+  \/\/ If we cannot speculate (aliasing analysis runtime checks), we need to respect all edges.\n+  bool speculate_away_weak_edges = _vloop.use_speculative_aliasing_checks();\n+\n@@ -875,0 +890,1 @@\n+      if (speculate_away_weak_edges && preds.is_current_weak_memory_edge()) { continue; }\n@@ -1635,0 +1651,2 @@\n+    } else if (VectorNode::is_reinterpret_opcode(opc)) {\n+      retValue = Matcher::match_rule_supported_auto_vectorization(Op_VectorReinterpret, size, velt_basic_type(p0));\n@@ -1939,0 +1957,1 @@\n+                        _vloop.is_trace_speculative_aliasing_analysis(),\n@@ -1992,1 +2011,2 @@\n-  apply_speculative_runtime_checks();\n+  apply_speculative_alignment_runtime_checks();\n+  apply_speculative_aliasing_runtime_checks();\n@@ -2093,5 +2113,1 @@\n-  \/\/ We keep track of the resulting Nodes from every \"VTransformNode::apply\" call.\n-  \/\/ Since \"apply\" is called on defs before uses, this allows us to find the\n-  \/\/ generated def (input) nodes when we are generating the use nodes in \"apply\".\n-  int length = _vtnodes.length();\n-  GrowableArray<Node*> vtnode_idx_to_transformed_node(length, length, nullptr);\n+  VTransformApplyState apply_state(_vloop_analyzer, _vtnodes.length());\n@@ -2101,2 +2117,1 @@\n-    VTransformApplyResult result = vtn->apply(_vloop_analyzer,\n-                                              vtnode_idx_to_transformed_node);\n+    VTransformApplyResult result = vtn->apply(apply_state);\n@@ -2105,1 +2120,1 @@\n-    vtnode_idx_to_transformed_node.at_put(vtn->_idx, result.node());\n+    apply_state.set_transformed_node(vtn, result.node());\n@@ -3059,1 +3074,1 @@\n-  Node* xbic = igvn().intcon(is_sub ? -con : con);\n+  Node* xbic = phase()->intcon(is_sub ? -con : con);\n@@ -3076,1 +3091,1 @@\n-    Node* invar_scale_con = igvn().intcon(invar_scale);\n+    Node* invar_scale_con = phase()->intcon(invar_scale);\n@@ -3128,1 +3143,1 @@\n-  Node* log2_abs_iv_scale = igvn().intcon(exact_log2(abs(iv_scale)));\n+  Node* log2_abs_iv_scale = phase()->intcon(exact_log2(abs(iv_scale)));\n@@ -3153,1 +3168,1 @@\n-  Node* mask_AW = igvn().intcon(AW-1);\n+  Node* mask_AW = phase()->intcon(AW-1);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+\/\/\n+\/\/ For more documentation, see: SuperWord::SLP_extract\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,13 @@\n-    VTransformScalarNode* vtn = new (_vtransform.arena()) VTransformScalarNode(_vtransform, n);\n+\n+    VTransformNode* vtn = nullptr;\n+    if (n->is_Load() || n->is_Store()) {\n+      MemNode* mem = n->as_Mem();\n+      const VPointer& mem_p = _vloop_analyzer.vpointers().vpointer(mem);\n+      vtn = new (_vtransform.arena()) VTransformMemopScalarNode(_vtransform, mem, mem_p);\n+    } else if (n->is_Phi()) {\n+      vtn = new (_vtransform.arena()) VTransformLoopPhiNode(_vtransform, n->as_Phi());\n+    } else if (n->is_CFG()) {\n+      vtn = new (_vtransform.arena()) VTransformCFGNode(_vtransform, n);\n+    } else {\n+      vtn = new (_vtransform.arena()) VTransformDataScalarNode(_vtransform, n);\n+    }\n@@ -71,1 +83,1 @@\n-      set_req_with_scalar(p0,   vtn, MemNode::Address);\n+      init_req_with_scalar(p0,   vtn, MemNode::Address);\n@@ -76,2 +88,2 @@\n-      set_req_with_scalar(p0,   vtn, MemNode::Address);\n-      set_req_with_vector(pack, vtn, MemNode::ValueIn);\n+      init_req_with_scalar(p0,   vtn, MemNode::Address);\n+      init_req_with_vector(pack, vtn, MemNode::ValueIn);\n@@ -82,2 +94,2 @@\n-      set_req_with_scalar(p0,   vtn, 1); \/\/ scalar init\n-      set_req_with_vector(pack, vtn, 2); \/\/ vector\n+      init_req_with_scalar(p0,   vtn, 1); \/\/ scalar init\n+      init_req_with_vector(pack, vtn, 2); \/\/ vector\n@@ -89,2 +101,2 @@\n-        set_req_with_vector(pack, vtn, 1);\n-        set_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n+        init_req_with_vector(pack, vtn, 1);\n+        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n@@ -92,2 +104,2 @@\n-        set_req_with_vector(pack, vtn, 1);\n-        set_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n+        init_req_with_vector(pack, vtn, 1);\n+        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n@@ -97,1 +109,1 @@\n-        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in(1)->isa_BoolVector();\n+        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(1)->isa_BoolVector();\n@@ -111,2 +123,2 @@\n-    VTransformScalarNode* vtn = get_vtnode(n)->isa_Scalar();\n-    if (vtn == nullptr) { continue; }\n+    VTransformNode* vtn = get_vtnode(n);\n+    if (vtn->isa_Vector() != nullptr) { continue; }\n@@ -116,1 +128,1 @@\n-      set_req_with_scalar(n, vtn, MemNode::Address);\n+      init_req_with_scalar(n, vtn, MemNode::Address);\n@@ -119,2 +131,2 @@\n-      set_req_with_scalar(n, vtn, MemNode::Address);\n-      set_req_with_scalar(n, vtn, MemNode::ValueIn);\n+      init_req_with_scalar(n, vtn, MemNode::Address);\n+      init_req_with_scalar(n, vtn, MemNode::ValueIn);\n@@ -127,1 +139,1 @@\n-      set_req_with_scalar(n, vtn, 0);\n+      init_req_with_scalar(n, vtn, 0);\n@@ -180,3 +192,3 @@\n-void SuperWordVTransformBuilder::set_req_with_scalar(Node* n, VTransformNode* vtn, const int index) {\n-  VTransformNode* req = get_vtnode_or_wrap_as_input_scalar(n->in(index));\n-  vtn->set_req(index, req);\n+void SuperWordVTransformBuilder::init_req_with_scalar(Node* n, VTransformNode* vtn, const int index) {\n+  VTransformNode* req = get_vtnode_or_wrap_as_outer(n->in(index));\n+  vtn->init_req(index, req);\n@@ -213,1 +225,1 @@\n-    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_input_scalar(_vloop.iv());\n+    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_outer(_vloop.iv());\n@@ -220,1 +232,1 @@\n-    populate_index->set_req(1, iv_vtn);\n+    populate_index->init_req(1, iv_vtn);\n@@ -225,1 +237,1 @@\n-    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_input_scalar(same_input);\n+    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_outer(same_input);\n@@ -233,1 +245,1 @@\n-      shift_count->set_req(1, same_input_vtn);\n+      shift_count->init_req(1, same_input_vtn);\n@@ -248,1 +260,1 @@\n-        conv->set_req(1, same_input_vtn);\n+        conv->init_req(1, same_input_vtn);\n@@ -252,1 +264,1 @@\n-      replicate->set_req(1, same_input_vtn);\n+      replicate->init_req(1, same_input_vtn);\n@@ -267,1 +279,1 @@\n-VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_input_scalar(Node* n) {\n+VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_outer(Node* n) {\n@@ -272,1 +284,1 @@\n-  vtn = new (_vtransform.arena()) VTransformInputScalarNode(_vtransform, n);\n+  vtn = new (_vtransform.arena()) VTransformOuterNode(_vtransform, n);\n@@ -277,1 +289,1 @@\n-void SuperWordVTransformBuilder::set_req_with_vector(const Node_List* pack, VTransformNode* vtn, int j) {\n+void SuperWordVTransformBuilder::init_req_with_vector(const Node_List* pack, VTransformNode* vtn, int j) {\n@@ -279,1 +291,1 @@\n-  vtn->set_req(j, req);\n+  vtn->init_req(j, req);\n@@ -287,1 +299,1 @@\n-    set_req_with_scalar(n, vtn, j);\n+    init_req_with_scalar(n, vtn, j);\n@@ -298,1 +310,1 @@\n-    set_req_with_vector(pack, vtn, j);\n+    init_req_with_vector(pack, vtn, j);\n@@ -302,1 +314,4 @@\n-void SuperWordVTransformBuilder::add_memory_dependencies_of_node_to_vtnode(Node*n, VTransformNode* vtn, VectorSet& vtn_memory_dependencies) {\n+void SuperWordVTransformBuilder::add_memory_dependencies_of_node_to_vtnode(Node* n, VTransformNode* vtn, VectorSet& vtn_memory_dependencies) {\n+  \/\/ If we cannot speculate, then all dependencies must be strong edges, i.e. scheduling must respect them.\n+  bool are_speculative_checks_possible = _vloop.are_speculative_checks_possible();\n+\n@@ -307,0 +322,1 @@\n+    assert(n->is_Mem() && pred->is_Mem(), \"only memory edges\");\n@@ -312,2 +328,5 @@\n-    assert(n->is_Mem() && pred->is_Mem(), \"only memory edges\");\n-    vtn->add_memory_dependency(dependency); \/\/ Add every dependency only once per vtn.\n+    if (are_speculative_checks_possible && preds.is_current_weak_memory_edge()) {\n+      vtn->add_weak_memory_edge(dependency);\n+    } else {\n+      vtn->add_strong_memory_edge(dependency);\n+    }\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":54,"deletions":35,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  ResourceHashtable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n+  HashTable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n@@ -79,3 +79,3 @@\n-  VTransformNode* get_vtnode_or_wrap_as_input_scalar(Node* n);\n-  void set_req_with_scalar(Node* n, VTransformNode* vtn, const int index);\n-  void set_req_with_vector(const Node_List* pack, VTransformNode* vtn, const int index);\n+  VTransformNode* get_vtnode_or_wrap_as_outer(Node* n);\n+  void init_req_with_scalar(Node* n, VTransformNode* vtn, const int index);\n+  void init_req_with_vector(const Node_List* pack, VTransformNode* vtn, const int index);\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  flags(SPECULATIVE_ALIASING_ANALYSIS, \"Trace Speculative Aliasing Analysis\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-  if ((sopc != 0) && !arch_supports_vector(sopc, num_elem, elem_bt, mask_use_type)) {\n+  if (!arch_supports_vector(sopc, num_elem, elem_bt, mask_use_type)) {\n@@ -394,1 +394,1 @@\n-  bool use_predicate = is_masked_op && sopc != 0 && arch_supports_vector(sopc, num_elem, elem_bt, VecMaskUsePred);\n+  bool use_predicate = is_masked_op && arch_supports_vector(sopc, num_elem, elem_bt, VecMaskUsePred);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -28,0 +29,2 @@\n+#include \"opto\/divnode.hpp\"\n+#include \"opto\/movenode.hpp\"\n@@ -29,0 +32,2 @@\n+#include \"opto\/noOverflowInt.hpp\"\n+#include \"opto\/phaseX.hpp\"\n@@ -260,0 +265,3 @@\n+\/\/    - Strong edge: must be respected.\n+\/\/    - Weak edge:   if we add a speculative aliasing check, we can violate\n+\/\/                   the edge, i.e. spaw the order.\n@@ -266,1 +274,2 @@\n-  GrowableArray<int> memory_pred_edges;\n+  GrowableArray<int> strong_memory_edges;\n+  GrowableArray<int> weak_memory_edges;\n@@ -278,1 +287,2 @@\n-      memory_pred_edges.clear();\n+      strong_memory_edges.clear();\n+      weak_memory_edges.clear();\n@@ -289,0 +299,2 @@\n+\n+        \/\/ If we can prove that they will never overlap -> drop edge.\n@@ -290,2 +302,5 @@\n-          \/\/ Possibly overlapping memory\n-          memory_pred_edges.append(_body.bb_idx(n2));\n+          if (p1.can_make_speculative_aliasing_check_with(p2)) {\n+            weak_memory_edges.append(_body.bb_idx(n2));\n+          } else {\n+            strong_memory_edges.append(_body.bb_idx(n2));\n+          }\n@@ -294,1 +309,1 @@\n-      if (memory_pred_edges.is_nonempty()) {\n+      if (strong_memory_edges.is_nonempty() || weak_memory_edges.is_nonempty()) {\n@@ -297,1 +312,1 @@\n-        add_node(n1, memory_pred_edges);\n+        add_node(n1, strong_memory_edges, weak_memory_edges);\n@@ -308,1 +323,1 @@\n-void VLoopDependencyGraph::add_node(MemNode* n, GrowableArray<int>& memory_pred_edges) {\n+void VLoopDependencyGraph::add_node(MemNode* n, GrowableArray<int>& strong_memory_edges, GrowableArray<int>& weak_memory_edges) {\n@@ -310,2 +325,1 @@\n-  assert(!memory_pred_edges.is_empty(), \"no need to create a node without edges\");\n-  DependencyNode* dn = new (_arena) DependencyNode(n, memory_pred_edges, _arena);\n+  DependencyNode* dn = new (_arena) DependencyNode(n, strong_memory_edges, weak_memory_edges, _arena);\n@@ -318,0 +332,3 @@\n+    \/\/ We must compute the dependence graph depth with all edges (including the weak edges), so that\n+    \/\/ the independence queries work correctly, no matter if we check independence with or without\n+    \/\/ weak edges.\n@@ -361,2 +378,7 @@\n-      for (uint j = 0; j < dn->memory_pred_edges_length(); j++) {\n-        Node* pred = _body.body().at(dn->memory_pred_edge(j));\n+      for (uint j = 0; j < dn->num_strong_memory_edges(); j++) {\n+        Node* pred = _body.body().at(dn->strong_memory_edge(j));\n+        tty->print(\"  %d %s\", pred->_idx, pred->Name());\n+      }\n+      tty->print(\" | weak:\");\n+      for (uint j = 0; j < dn->num_weak_memory_edges(); j++) {\n+        Node* pred = _body.body().at(dn->weak_memory_edge(j));\n@@ -370,1 +392,7 @@\n-  tty->print_cr(\" Complete dependency graph:\");\n+  \/\/ If we cannot speculate (aliasing analysis runtime checks), we need to respect all edges.\n+  bool with_weak_memory_edges = !_vloop.use_speculative_aliasing_checks();\n+  if (with_weak_memory_edges) {\n+    tty->print_cr(\" Complete dependency graph (with weak edges, because we cannot speculate):\");\n+  } else {\n+    tty->print_cr(\" Dependency graph without weak edges (because we can speculate):\");\n+  }\n@@ -375,0 +403,1 @@\n+      if (!with_weak_memory_edges && it.is_current_weak_memory_edge()) { continue; }\n@@ -384,1 +413,2 @@\n-                                                     GrowableArray<int>& memory_pred_edges,\n+                                                     GrowableArray<int>& strong_memory_edges,\n+                                                     GrowableArray<int>& weak_memory_edges,\n@@ -387,2 +417,3 @@\n-    _memory_pred_edges_length(memory_pred_edges.length()),\n-    _memory_pred_edges(nullptr)\n+    _num_strong_memory_edges(strong_memory_edges.length()),\n+    _num_weak_memory_edges(weak_memory_edges.length()),\n+    _memory_edges(nullptr)\n@@ -390,4 +421,11 @@\n-  assert(memory_pred_edges.is_nonempty(), \"not empty\");\n-  uint bytes = memory_pred_edges.length() * sizeof(int);\n-  _memory_pred_edges = (int*)arena->Amalloc(bytes);\n-  memcpy(_memory_pred_edges, memory_pred_edges.adr_at(0), bytes);\n+  assert(strong_memory_edges.is_nonempty() || weak_memory_edges.is_nonempty(), \"only generate DependencyNode if there are pred edges\");\n+  uint bytes_strong = strong_memory_edges.length() * sizeof(int);\n+  uint bytes_weak = weak_memory_edges.length() * sizeof(int);\n+  uint bytes_total = bytes_strong + bytes_weak;\n+  _memory_edges = (int*)arena->Amalloc(bytes_total);\n+  if (strong_memory_edges.length() > 0) {\n+    memcpy(_memory_edges, strong_memory_edges.adr_at(0), bytes_strong);\n+  }\n+  if (weak_memory_edges.length() > 0) {\n+    memcpy(_memory_edges + strong_memory_edges.length(), weak_memory_edges.adr_at(0), bytes_weak);\n+  }\n@@ -403,4 +441,7 @@\n-    _next_pred(0),\n-    _end_pred(node->req()),\n-    _next_memory_pred(0),\n-    _end_memory_pred((_dependency_node != nullptr) ? _dependency_node->memory_pred_edges_length() : 0)\n+    _is_current_weak_memory_edge(false),\n+    _next_data_edge(0),\n+    _end_data_edge(node->req()),\n+    _next_strong_memory_edge(0),\n+    _end_strong_memory_edge((_dependency_node != nullptr) ? _dependency_node->num_strong_memory_edges() : 0),\n+    _next_weak_memory_edge(0),\n+    _end_weak_memory_edge((_dependency_node != nullptr) ? _dependency_node->num_weak_memory_edges() : 0)\n@@ -409,3 +450,5 @@\n-    \/\/ Load: address\n-    \/\/ Store: address, value\n-    _next_pred = MemNode::Address;\n+    \/\/ Ignore ctrl and memory, only address and value are data dependencies.\n+    \/\/ Memory edges are already covered by the strong and weak memory edges.\n+    \/\/ Load:  [ctrl, memory] address\n+    \/\/ Store: [ctrl, memory] address, value\n+    _next_data_edge = MemNode::Address;\n@@ -414,1 +457,1 @@\n-    _next_pred = 1; \/\/ skip control\n+    _next_data_edge = 1; \/\/ skip control\n@@ -420,2 +463,2 @@\n-  if (_next_pred < _end_pred) {\n-    _current = _node->in(_next_pred++);\n+  if (_next_data_edge < _end_data_edge) {\n+    _current = _node->in(_next_data_edge++);\n@@ -423,2 +466,8 @@\n-  } else if (_next_memory_pred < _end_memory_pred) {\n-    int pred_bb_idx = _dependency_node->memory_pred_edge(_next_memory_pred++);\n+    _is_current_weak_memory_edge = false;\n+  } else if (_next_strong_memory_edge < _end_strong_memory_edge) {\n+    int pred_bb_idx = _dependency_node->strong_memory_edge(_next_strong_memory_edge++);\n+    _current = _dependency_graph._body.body().at(pred_bb_idx);\n+    _is_current_memory_edge = true;\n+    _is_current_weak_memory_edge = false;\n+  } else if (_next_weak_memory_edge < _end_weak_memory_edge) {\n+    int pred_bb_idx = _dependency_node->weak_memory_edge(_next_weak_memory_edge++);\n@@ -427,0 +476,1 @@\n+    _is_current_weak_memory_edge = true;\n@@ -430,0 +480,591 @@\n+    _is_current_weak_memory_edge = false;\n+  }\n+}\n+\n+\/\/ Computing aliasing runtime check using init and last of main-loop\n+\/\/ -----------------------------------------------------------------\n+\/\/\n+\/\/ We have two VPointer vp1 and vp2, and would like to create a runtime check that\n+\/\/ guarantees that the corresponding pointers p1 and p2 do not overlap (alias) for\n+\/\/ any iv value in the strided range r = [init, init + iv_stride, .. limit).\n+\/\/ Remember that vp1 and vp2 both represent a region in memory, starting at a\n+\/\/ \"pointer\", and extending for \"size\" bytes:\n+\/\/\n+\/\/   vp1(iv) = [p1(iv), size1)\n+\/\/   vp2(iv) = [p2(iv), size2)\n+\/\/\n+\/\/       |---size1--->           |-------size2------->\n+\/\/       |                       |\n+\/\/     p1(iv)                  p2(iv)\n+\/\/\n+\/\/ In each iv value (intuitively: for each iteration), we check that there is no\n+\/\/ overlap:\n+\/\/\n+\/\/   for all iv in r: p1(iv) + size1 <= p2(iv) OR p2(iv) + size2 <= p1(iv)\n+\/\/\n+\/\/ This would allow situations where for some iv p1 is lower than p2, and for\n+\/\/ other iv p1 is higher than p2. This is not very useful in practice. We can\n+\/\/ strengthen the condition, which will make the check simpler later:\n+\/\/\n+\/\/   for all iv in r: p1(iv) + size1 <= p2(iv)                    (P1-BEFORE-P2)\n+\/\/   OR\n+\/\/   for all iv in r: p2(iv) + size2 <= p1(iv)                    (P1-AFTER-P2)\n+\/\/\n+\/\/ Note: apart from this strengthening, the checks we derive below are byte accurate,\n+\/\/       i.e. they are equivalent to the conditions above. This means we have NO case\n+\/\/       where:\n+\/\/       1) The check passes (predicts no overlap) but the pointers do actually overlap.\n+\/\/          This would be bad because we would wrongly vectorize, possibly leading to\n+\/\/          wrong results.\n+\/\/       2) The check does not pass (predicts overlap) but the pointers do not overlap.\n+\/\/          This would be suboptimal, as we would not be able to vectorize, and either\n+\/\/          trap (with predicate), or go into the slow-loop (with multiversioning).\n+\/\/\n+\/\/\n+\/\/ We apply the \"MemPointer Linearity Corrolary\" to VPointer vp and the corresponding\n+\/\/ pointer p:\n+\/\/   (C0) is given by the construction of VPointer vp, which simply wraps a MemPointer mp.\n+\/\/   (c1) with v = iv and scale_v = iv_scale\n+\/\/   (C2) with r = [init, init + iv_stride, .. last - stride_v, last], which is the set\n+\/\/        of possible iv values in the loop, with \"init\" the first iv value, and \"last\"\n+\/\/        the last iv value which is closest to limit.\n+\/\/        Note: iv_stride > 0  ->  limit - iv_stride <= last < limit\n+\/\/              iv_stride < 0  ->  limit < last <= limit - iv_stride\n+\/\/        We have to be a little careful, and cannot just use \"limit\" instead of \"last\" as\n+\/\/        the last value in r, because the iv never reaches limit in the main-loop, and\n+\/\/        so we are not sure if the memory access at p(limit) is still in bounds.\n+\/\/        For now, we just assume that we can compute init and limit, and we will derive\n+\/\/        the computation of these values later on.\n+\/\/   (C3) the memory accesses for every iv value in the loop must be in bounds, otherwise\n+\/\/        the program has undefined behaviour already.\n+\/\/   (C4) abs(iv_scale * iv_stride) < 2^31 is given by the checks in\n+\/\/        VPointer::init_are_scale_and_stride_not_too_large.\n+\/\/\n+\/\/ Hence, it follows that we can see p and vp as linear functions of iv in r, i.e. for\n+\/\/ all iv values in the loop:\n+\/\/   p(iv)  = p(init)  - init * iv_scale + iv * iv_scale\n+\/\/   vp(iv) = vp(init) - init * iv_scale + iv * iv_scale\n+\/\/\n+\/\/ Hence, p1 and p2 have the linear form:\n+\/\/   p1(iv)  = p1(init) - init * iv_scale1 + iv * iv_scale1             (LINEAR-FORM-INIT)\n+\/\/   p2(iv)  = p2(init) - init * iv_scale2 + iv * iv_scale2\n+\/\/\n+\/\/ With the (Alternative Corrolary P) we get the alternative linar form:\n+\/\/   p1(iv)  = p1(last) - last * iv_scale1 + iv * iv_scale1             (LINEAR-FORM-LAST)\n+\/\/   p2(iv)  = p2(last) - last * iv_scale2 + iv * iv_scale2\n+\/\/\n+\/\/\n+\/\/ We can now use this linearity to construct aliasing runtime checks, depending on the\n+\/\/ different \"geometry\" of the two VPointer over their iv, i.e. the \"slopes\" of the linear\n+\/\/ functions. In the following graphs, the x-axis denotes the values of iv, from init to\n+\/\/ last. And the y-axis denotes the pointer position p(iv). Intuitively, this problem\n+\/\/ can be seen as having two bands that should not overlap.\n+\/\/\n+\/\/       Case 1                     Case 2                     Case 3\n+\/\/       parallel lines             same sign slope            different sign slope\n+\/\/                                  but not parallel\n+\/\/\n+\/\/       +---------+                +---------+                +---------+\n+\/\/       |         |                |        #|                |#        |\n+\/\/       |         |                |       # |                |  #      |\n+\/\/       |        #|                |      #  |                |    #    |\n+\/\/       |      #  |                |     #   |                |      #  |\n+\/\/       |    #    |                |    #    |                |        #|\n+\/\/       |  # ^    |                |   #     |                |        ^|\n+\/\/       |#   |   #|                |  #      |                |        ||\n+\/\/       |    v #  |                | #       |                |        v|\n+\/\/       |    #    |                |#       #|                |        #|\n+\/\/       |  #      |                |^     #  |                |      #  |\n+\/\/       |#        |                ||   #    |                |    #    |\n+\/\/       |         |                |v #      |                |  #      |\n+\/\/       |         |                |#        |                |#        |\n+\/\/       +---------+                +---------+                +---------+\n+\/\/\n+\/\/\n+\/\/ Case 1: parallel lines, i.e. iv_scale = iv_scale1 = iv_scale2\n+\/\/\n+\/\/   p1(iv)  = p1(init)  - init * iv_scale + iv * iv_scale\n+\/\/   p2(iv)  = p2(init)  - init * iv_scale + iv * iv_scale\n+\/\/\n+\/\/   Given this, it follows:\n+\/\/     p1(iv) + size1 <= p2(iv)      <==>      p1(init) + size1 <= p2(init)\n+\/\/     p2(iv) + size2 <= p1(iv)      <==>      p2(init) + size2 <= p1(init)\n+\/\/\n+\/\/   Hence, we do not have to check the condition for every iv, but only for init.\n+\/\/\n+\/\/   p1(init) + size1 <= p2(init)  OR  p2(init) + size2 <= p1(init)\n+\/\/   ----- is equivalent to -----      ---- is equivalent to ------\n+\/\/          (P1-BEFORE-P2)         OR         (P1-AFTER-P2)\n+\/\/\n+\/\/\n+\/\/ Case 2 and 3: different slopes, i.e. iv_scale1 != iv_scale2\n+\/\/\n+\/\/   Without loss of generality, we assume iv_scale1 < iv_scale2.\n+\/\/   (Otherwise, we just swap p1 and p2).\n+\/\/\n+\/\/   If iv_stride >= 0, i.e. init <= iv <= last:\n+\/\/     (iv - init) * iv_scale1 <= (iv - init) * iv_scale2\n+\/\/     (iv - last) * iv_scale1 >= (iv - last) * iv_scale2                 (POS-STRIDE)\n+\/\/   If iv_stride <= 0, i.e. last <= iv <= init:\n+\/\/     (iv - init) * iv_scale1 >= (iv - init) * iv_scale2\n+\/\/     (iv - last) * iv_scale1 <= (iv - last) * iv_scale2                 (NEG-STRIDE)\n+\/\/\n+\/\/   Below, we show that these conditions are equivalent:\n+\/\/\n+\/\/       p1(init) + size1 <= p2(init)       (if iv_stride >= 0)  |    p2(last) + size2 <= p1(last)      (if iv_stride >= 0)   |\n+\/\/       p1(last) + size1 <= p2(last)       (if iv_stride <= 0)  |    p2(init) + size2 <= p1(init)      (if iv_stride <= 0)   |\n+\/\/       ---- are equivalent to -----                            |    ---- are equivalent to -----                            |\n+\/\/              (P1-BEFORE-P2)                                   |           (P1-AFTER-P2)                                    |\n+\/\/                                                               |                                                            |\n+\/\/   Proof:                                                      |                                                            |\n+\/\/                                                               |                                                            |\n+\/\/     Assume: (P1-BEFORE-P2)                                    |  Assume: (P1-AFTER-P2)                                     |\n+\/\/       for all iv in r: p1(iv) + size1 <= p2(iv)               |    for all iv in r: p2(iv) + size2 <= p1(iv)               |\n+\/\/       => And since init and last in r =>                      |    => And since init and last in r =>                      |\n+\/\/       p1(init) + size1 <= p2(init)                            |    p2(init) + size2 <= p1(init)                            |\n+\/\/       p1(last) + size1 <= p2(last)                            |    p2(last) + size2 <= p1(last)                            |\n+\/\/                                                               |                                                            |\n+\/\/                                                               |                                                            |\n+\/\/     Assume: p1(init) + size1 <= p2(init)                      |  Assume: p2(last) + size2 <= p1(last)                      |\n+\/\/        and: iv_stride >= 0                                    |     and: iv_stride >= 0                                    |\n+\/\/                                                               |                                                            |\n+\/\/          size1 + p1(iv)                                       |       size2 + p2(iv)                                       |\n+\/\/                  --------- apply (LINEAR-FORM-INIT) --------- |               --------- apply (LINEAR-FORM-LAST) --------- |\n+\/\/        = size1 + p1(init) - init * iv_scale1 + iv * iv_scale1 |     = size2 + p2(last) - last * iv_scale2 + iv * iv_scale2 |\n+\/\/                           ------ apply (POS-STRIDE) --------- |                        ------ apply (POS-STRIDE) --------- |\n+\/\/       <= size1 + p1(init) - init * iv_scale2 + iv * iv_scale2 |    <= size2 + p2(last) - last * iv_scale1 + iv * iv_scale1 |\n+\/\/          -- assumption --                                     |       -- assumption --                                     |\n+\/\/       <=         p2(init) - init * iv_scale2 + iv * iv_scale2 |    <=         p1(last) - last * iv_scale1 + iv * iv_scale1 |\n+\/\/                  --------- apply (LINEAR-FORM-INIT) --------- |               --------- apply (LINEAR-FORM-LAST) --------- |\n+\/\/        =         p2(iv)                                       |     =         p1(iv)                                       |\n+\/\/                                                               |                                                            |\n+\/\/                                                               |                                                            |\n+\/\/     Assume: p1(last) + size1 <= p2(last)                      |  Assume: p2(init) + size2 <= p1(init)                      |\n+\/\/        and: iv_stride <= 0                                    |     and: iv_stride <= 0                                    |\n+\/\/                                                               |                                                            |\n+\/\/          size1 + p1(iv)                                       |       size2 + p2(iv)                                       |\n+\/\/                  --------- apply (LINEAR-FORM-LAST) --------- |               --------- apply (LINEAR-FORM-INIT) --------- |\n+\/\/        = size1 + p1(last) - last * iv_scale1 + iv * iv_scale1 |     = size2 + p2(init) - init * iv_scale2 + iv * iv_scale2 |\n+\/\/                           ------ apply (NEG-STRIDE) --------- |                        ------ apply (NEG-STRIDE) --------- |\n+\/\/       <= size1 + p1(last) - last * iv_scale2 + iv * iv_scale2 |    <= size2 + p2(init) - init * iv_scale1 + iv * iv_scale1 |\n+\/\/          -- assumption --                                     |       -- assumption --                                     |\n+\/\/       <=         p2(last) - last * iv_scale2 + iv * iv_scale2 |    <=         p1(init) - init * iv_scale1 + iv * iv_scale1 |\n+\/\/                  --------- apply (LINEAR-FORM-LAST) --------- |               --------- apply (LINEAR-FORM-INIT) --------- |\n+\/\/        =         p2(iv)                                       |     =         p1(iv)                                       |\n+\/\/                                                               |                                                            |\n+\/\/\n+\/\/   The obtained conditions already look very simple. However, we would like to avoid\n+\/\/   computing 4 addresses (p1(init), p1(last), p2(init), p2(last)), and would instead\n+\/\/   prefer to only compute 2 addresses, and derive the other two from the distance (span)\n+\/\/   between the pointers at init and last. Using (LINEAR-FORM-INIT), we get:\n+\/\/\n+\/\/     p1(last) = p1(init) - init * iv_scale1 + last * iv_scale1                 (SPAN-1)\n+\/\/                         --------------- defines -------------\n+\/\/                p1(init) + span1\n+\/\/\n+\/\/     p2(last) = p2(init) - init * iv_scale2 + last * iv_scale2                 (SPAN-2)\n+\/\/                         --------------- defines -------------\n+\/\/                p1(init) + span2\n+\/\/\n+\/\/     span1 = - init * iv_scale1 + last * iv_scale1 = (last - init) * iv_scale1\n+\/\/     span2 = - init * iv_scale2 + last * iv_scale2 = (last - init) * iv_scale2\n+\/\/\n+\/\/   Thus, we can use the conditions below:\n+\/\/     p1(init)         + size1 <= p2(init)          OR  p2(init) + span2 + size2 <= p1(init) + span1    (if iv_stride >= 0)\n+\/\/     p1(init) + span1 + size1 <= p2(init) + span2  OR  p2(init)         + size2 <= p1(init)            (if iv_stride <= 0)\n+\/\/\n+\/\/   Below, we visualize the conditions, so that the reader can gain an intuitiion.\n+\/\/   For simplicity, we only show the case with iv_stride > 0. Also, remember that\n+\/\/   iv_scale1 < iv_scale2.\n+\/\/\n+\/\/                             +---------+                     +---------+\n+\/\/                             |        #|                     |        #| <-- p1(init) + span1\n+\/\/                             |       # |  ^ span2    span1 ^ |      # ^|\n+\/\/                             |      #  |  |                | |    #   ||\n+\/\/                             |     #   |  |                | |  #     v| <-- p2(init) + span2 + size2\n+\/\/                             |    #    |  |                v |#       #|\n+\/\/                             |   #     |  |          span2 ^ |       # |\n+\/\/                             |  #      |  |                | |      #  |\n+\/\/                             | #       |  |                | |     #   |\n+\/\/        p2(init)         --> |#       #|  v                | |    #    |\n+\/\/                             |^     #  |  ^ span1          | |   #     |\n+\/\/                             ||   #    |  |                | |  #      |\n+\/\/        p1(init) + size1 --> |v #      |  |                | | #       |\n+\/\/                             |#        |  v                v |#        |\n+\/\/                             +---------+                     +---------+\n+\/\/\n+\/\/ -------------------------------------------------------------------------------------------------------------------------\n+\/\/\n+\/\/ Computing the last iv value in a loop\n+\/\/ -------------------------------------\n+\/\/\n+\/\/ Let us define a helper function, that computes the last iv value in a loop,\n+\/\/ given variable init and limit values, and a constant stride. If the loop\n+\/\/ is never entered, we just return the init value.\n+\/\/\n+\/\/   LAST(init, stride, limit), where stride > 0:   |  LAST(init, stride, limit), where stride < 0:\n+\/\/     last = init                                  |  last = init\n+\/\/     for (iv = init; iv < limit; iv += stride)    |  for (iv = init; iv > limit; iv += stride)\n+\/\/       last = iv                                  |    last = iv\n+\/\/\n+\/\/ It follows that for some k:\n+\/\/    last = init + k * stride\n+\/\/\n+\/\/ If the loop is not entered, we can set k=0.\n+\/\/\n+\/\/ If the loop is entered:\n+\/\/   last is very close to limit:\n+\/\/     stride > 0  ->  limit - stride <= last < limit\n+\/\/     stride < 0  ->  limit < last <= limit - stride\n+\/\/\n+\/\/     If stride > 0:\n+\/\/         limit        - stride                   <= last              <   limit\n+\/\/         limit        - stride                   <= init + k * stride <   limit\n+\/\/         limit - init - stride                   <=        k * stride <   limit - init\n+\/\/         limit - init - stride - 1               <         k * stride <=  limit - init - 1\n+\/\/        (limit - init - stride - 1) \/ stride     <         k          <= (limit - init - 1) \/ stride\n+\/\/        (limit - init          - 1) \/ stride - 1 <         k          <= (limit - init - 1) \/ stride\n+\/\/     -> k = (limit - init - 1) \/ stride\n+\/\/     -> dividend \"limit - init - 1\" is >=0. So a regular round to zero division can be used.\n+\/\/        Note: to incorporate the case where the loop is not entered (init >= limit), we see\n+\/\/              that the divident is zero or negative, and so the result will be zero or\n+\/\/              negative. Thus, we can just clamp k to zero, or last to init, so that we get\n+\/\/              a solution that also works when the loop is not entered:\n+\/\/\n+\/\/              k = (limit - init - 1) \/ abs(stride)\n+\/\/              last = MAX(init, init + k * stride)\n+\/\/\n+\/\/     If stride < 0:\n+\/\/         limit                               <  last              <=   limit        - stride\n+\/\/         limit                               <  init + k * stride <=   limit        - stride\n+\/\/         limit - init                        <         k * stride <=   limit - init - stride\n+\/\/         limit - init + 1                    <=        k * stride <    limit - init - stride + 1\n+\/\/        (limit - init + 1) \/     stride      >=        k          >   (limit - init - stride + 1) \/     stride\n+\/\/       -(limit - init + 1) \/ abs(stride)     >=        k          >  -(limit - init - stride + 1) \/ abs(stride)\n+\/\/       -(limit - init + 1) \/ abs(stride)     >=        k          >  -(limit - init          + 1) \/ abs(stride) - 1\n+\/\/        (init - limit - 1) \/ abs(stride)     >=        k          >   (init - limit          - 1) \/ abs(stride) - 1\n+\/\/        (init - limit - 1) \/ abs(stride)     >=        k          >   (init - limit          - 1) \/ abs(stride) - 1\n+\/\/     -> k = (init - limit - 1) \/ abs(stride)\n+\/\/     -> dividend \"init - limit\" is >=0. So a regular round to zero division can be used.\n+\/\/        Note: to incorporate the case where the loop is not entered (init <= limit), we see\n+\/\/              that the divident is zero or negative, and so the result will be zero or\n+\/\/              negative. Thus, we can just clamp k to zero, or last to init, so that we get\n+\/\/              a solution that also works when the loop is not entered:\n+\/\/\n+\/\/              k = (init - limit - 1) \/ abs(stride)\n+\/\/              last = MIN(init, init + k * stride)\n+\/\/\n+\/\/ Now we can put it all together:\n+\/\/   LAST(init, stride, limit)\n+\/\/     If stride > 0:\n+\/\/       k = (limit - init - 1) \/ abs(stride)\n+\/\/       last = MAX(init, init + k * stride)\n+\/\/     If stride < 0:\n+\/\/       k = (init - limit - 1) \/ abs(stride)\n+\/\/       last = MIN(init, init + k * stride)\n+\/\/\n+\/\/ We will have to consider the implications of clamping to init when the loop is not entered\n+\/\/ at the use of LAST further down.\n+\/\/\n+\/\/ -------------------------------------------------------------------------------------------------------------------------\n+\/\/\n+\/\/ Computing init and last for the main-loop\n+\/\/ -----------------------------------------\n+\/\/\n+\/\/ As we have seen above, we always need the \"init\" of the main-loop. And if \"iv_scale1 != iv_scale2\", then we\n+\/\/ also need the \"last\" of the main-loop. These values need to be pre-loop invariant, because the check is\n+\/\/ to be performed before the pre-loop (at the predicate or multiversioning selector_if). It will be helpful\n+\/\/ to recall the iv structure in the pre and main-loop:\n+\/\/\n+\/\/                  | iv = pre_init\n+\/\/                  |\n+\/\/   Pre-Loop       | +----------------+\n+\/\/                  phi                |\n+\/\/                   |                 |  -> pre_last: last iv value in pre-loop\n+\/\/                   + pre_iv_stride   |\n+\/\/                   |-----------------+\n+\/\/                   | exit check: < pre_limit\n+\/\/                   |\n+\/\/                   | iv = main_init = init\n+\/\/                   |\n+\/\/   Main-Loop       | +------------------------------+\n+\/\/                   phi                              |\n+\/\/                    |                               | -> last: last iv value in main-loop\n+\/\/                    + main_iv_stride = iv_stride    |\n+\/\/                    |-------------------------------+\n+\/\/                    | exit check: < main_limit = limit\n+\/\/\n+\/\/ Unfortunately, the init (aka. main_init) is not pre-loop invariant, rather it is only available\n+\/\/ after the pre-loop. We will have to compute:\n+\/\/\n+\/\/   pre_last = LAST(pre_init, pre_iv_stride, pre_limit)\n+\/\/   init = pre_last + pre_iv_stride\n+\/\/\n+\/\/ If we need \"last\", we unfortunately must compute it as well:\n+\/\/\n+\/\/   last = LAST(init, iv_stride, limit)\n+\/\/\n+\/\/\n+\/\/ These computations assume that we indeed do enter the main-loop - otherwise\n+\/\/ it does not make sense to talk about the \"last main iteration\". Of course\n+\/\/ entering the main-loop implies that we entered the pre-loop already. But\n+\/\/ what happens if we check the aliasing runtime check, but later would never\n+\/\/ enter the main-loop?\n+\/\/\n+\/\/ First: no matter if we pass or fail the aliasing runtime check, we will\n+\/\/ not get wrong results. If we fail the check, we end up in the less optimized\n+\/\/ slow-loop. If we pass the check, and we don't enter the main-loop, we\n+\/\/ never rely on the aliasing check, after all only the vectorized main-loop\n+\/\/ (and the vectorized post-loop) rely on the aliasing check.\n+\/\/\n+\/\/ But: The worry is that we may fail the aliasing runtime check \"spuriously\",\n+\/\/ i.e. even though we would never enter the main-loop, and that this could have\n+\/\/ unfortunate side-effects (for example deopting unnecessarily). Let's\n+\/\/ look at the two possible cases:\n+\/\/  1) We would never even enter the pre-loop.\n+\/\/     There are only predicates between the aliasing runtime check and the pre-loop,\n+\/\/     so a predicate would have to fail. These are rather rare cases. If we\n+\/\/     are using multiversioning for the aliasing runtime check, we would\n+\/\/     immediately fail the predicate in either the slow or fast loop, so\n+\/\/     the decision of the aliasing runtime check does not matter. But if\n+\/\/     we are using a predicate for the aliaing runtime check, then we may\n+\/\/     end up deopting twice: once for the aliasing runtime check, and then\n+\/\/     again for the other predicate. This would not be great, but again,\n+\/\/     failing predicates are rare in the first place.\n+\/\/\n+\/\/  2) We would enter the pre-loop, but not the main-loop.\n+\/\/     The pre_last must be accurate, because we are entering the pre-loop.\n+\/\/     But then we fail the zero-trip guard of the main-loop. Thus, for the\n+\/\/     main-loop, the init lies \"after\" the limit. Thus, the computed last\n+\/\/     for the main-loop equals the init. This means that span1 and span2\n+\/\/     are zero. Hence, p1(init) and p2(init) would have to alias for the\n+\/\/     aliasing runtime check to fail. Hence, it would not be surprising\n+\/\/     at all if we deopted because of the aliasing runtime check.\n+\/\/\n+bool VPointer::can_make_speculative_aliasing_check_with(const VPointer& other) const {\n+  const VPointer& vp1 = *this;\n+  const VPointer& vp2 = other;\n+\n+  if (!_vloop.use_speculative_aliasing_checks()) { return false; }\n+\n+  \/\/ Both pointers need a nice linear form, otherwise we cannot formulate the check.\n+  if (!vp1.is_valid() || !vp2.is_valid()) { return false; }\n+\n+  \/\/ The pointers always overlap -> a speculative check would always fail.\n+  if (vp1.always_overlaps_with(vp2)) { return false; }\n+\n+  \/\/ The pointers never overlap -> a speculative check would always succeed.\n+  assert(!vp1.never_overlaps_with(vp2), \"ensured by caller\");\n+\n+  \/\/ The speculative aliasing check happens either at the AutoVectorization predicate\n+  \/\/ or at the multiversion_if. That is before the pre-loop. From the construction of\n+  \/\/ VPointer, we already know that all its variables (except iv) are pre-loop invariant.\n+  \/\/\n+  \/\/ For the computation of main_init, we also need the pre_limit, and so we need\n+  \/\/ to check that this value is pre-loop invariant. In the case of non-equal iv_scales,\n+  \/\/ we also need the main_limit in the aliasing check, and so this value must then\n+  \/\/ also be pre-loop invariant.\n+  Opaque1Node* pre_limit_opaq = _vloop.pre_loop_end()->limit()->as_Opaque1();\n+  Node* pre_limit = pre_limit_opaq->in(1);\n+  Node* main_limit = _vloop.cl()->limit();\n+\n+  if (!_vloop.is_pre_loop_invariant(pre_limit)) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis()) {\n+      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: pre_limit is not pre-loop independent!\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  if (vp1.iv_scale() != vp2.iv_scale() && !_vloop.is_pre_loop_invariant(main_limit)) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis()) {\n+      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: main_limit is not pre-loop independent!\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+\/\/ For description and derivation see \"Computing the last iv value in a loop\".\n+\/\/ Note: the iv computations here should not overflow. But out of an abundance\n+\/\/       of caution, we compute everything in long anyway.\n+Node* make_last(Node* initL, jint stride, Node* limitL, PhaseIdealLoop* phase) {\n+  PhaseIterGVN& igvn = phase->igvn();\n+\n+  Node* abs_strideL = igvn.longcon(abs(stride));\n+  Node* strideL = igvn.longcon(stride);\n+\n+  \/\/ If in some rare case the limit is \"before\" init, then\n+  \/\/ this subtraction could overflow. Doing the calculations\n+  \/\/ in long prevents this. Below, we clamp the \"last\" value\n+  \/\/ back to init, which gets us back into the safe int range.\n+  Node* diffL = (stride > 0) ? new SubLNode(limitL, initL)\n+                             : new SubLNode(initL, limitL);\n+  Node* diffL_m1 = new AddLNode(diffL, igvn.longcon(-1));\n+  Node* k = new DivLNode(nullptr, diffL_m1, abs_strideL);\n+\n+  \/\/ Compute last = init + k * iv_stride\n+  Node* k_mul_stride = new MulLNode(k, strideL);\n+  Node* last = new AddLNode(initL, k_mul_stride);\n+\n+  \/\/ Make sure that the last does not lie \"before\" init.\n+  Node* last_clamped = MaxNode::build_min_max_long(&igvn, initL, last, stride > 0);\n+\n+  phase->register_new_node_with_ctrl_of(diffL,        initL);\n+  phase->register_new_node_with_ctrl_of(diffL_m1,     initL);\n+  phase->register_new_node_with_ctrl_of(k,            initL);\n+  phase->register_new_node_with_ctrl_of(k_mul_stride, initL);\n+  phase->register_new_node_with_ctrl_of(last,         initL);\n+  phase->register_new_node_with_ctrl_of(last_clamped, initL);\n+\n+  return last_clamped;\n+}\n+\n+BoolNode* make_a_plus_b_leq_c(Node* a, Node* b, Node* c, PhaseIdealLoop* phase) {\n+  Node* a_plus_b = new AddLNode(a, b);\n+  Node* cmp = CmpNode::make(a_plus_b, c, T_LONG, true);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::le);\n+  phase->register_new_node_with_ctrl_of(a_plus_b, a);\n+  phase->register_new_node_with_ctrl_of(cmp, a);\n+  phase->register_new_node_with_ctrl_of(bol, a);\n+  return bol;\n+}\n+\n+BoolNode* VPointer::make_speculative_aliasing_check_with(const VPointer& other, Node* ctrl) const {\n+  \/\/ Ensure iv_scale1 <= iv_scale2.\n+  const VPointer& vp1 = (this->iv_scale() <= other.iv_scale()) ? *this : other;\n+  const VPointer& vp2 = (this->iv_scale() <= other.iv_scale()) ? other :*this ;\n+  assert(vp1.iv_scale() <= vp2.iv_scale(), \"ensured by swapping if necessary\");\n+\n+  assert(vp1.can_make_speculative_aliasing_check_with(vp2), \"sanity\");\n+\n+  PhaseIdealLoop* phase = _vloop.phase();\n+  PhaseIterGVN& igvn = phase->igvn();\n+\n+  \/\/ init (aka main_init): compute it from the the pre-loop structure.\n+  \/\/ As described above, we cannot just take the _vloop.cl().init_trip(), because that\n+  \/\/ value is pre-loop dependent, and we need a pre-loop independent value, so we can\n+  \/\/ have it available at the predicate \/ multiversioning selector_if.\n+  \/\/ For this, we need to be sure that the pre_limit is pre-loop independent as well,\n+  \/\/ see can_make_speculative_aliasing_check_with.\n+  Node* pre_init = _vloop.pre_loop_end()->init_trip();\n+  jint pre_iv_stride = _vloop.pre_loop_end()->stride_con();\n+  Opaque1Node* pre_limit_opaq = _vloop.pre_loop_end()->limit()->as_Opaque1();\n+  Node* pre_limit = pre_limit_opaq->in(1);\n+  assert(_vloop.is_pre_loop_invariant(pre_init),  \"needed for aliasing check before pre-loop\");\n+  assert(_vloop.is_pre_loop_invariant(pre_limit), \"needed for aliasing check before pre-loop\");\n+\n+  Node* pre_initL = new ConvI2LNode(pre_init);\n+  Node* pre_limitL = new ConvI2LNode(pre_limit);\n+  phase->register_new_node_with_ctrl_of(pre_initL, pre_init);\n+  phase->register_new_node_with_ctrl_of(pre_limitL, pre_init);\n+\n+  Node* pre_lastL = make_last(pre_initL, pre_iv_stride, pre_limitL, phase);\n+\n+  Node* main_initL = new AddLNode(pre_lastL, igvn.longcon(pre_iv_stride));\n+  phase->register_new_node_with_ctrl_of(main_initL, pre_init);\n+\n+  Node* main_init = new ConvL2INode(main_initL);\n+  phase->register_new_node_with_ctrl_of(main_init, pre_init);\n+\n+  Node* p1_init = vp1.make_pointer_expression(main_init, ctrl);\n+  Node* p2_init = vp2.make_pointer_expression(main_init, ctrl);\n+  Node* size1 = igvn.longcon(vp1.size());\n+  Node* size2 = igvn.longcon(vp2.size());\n+\n+#ifdef ASSERT\n+  if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+    tty->print_cr(\"\\nVPointer::make_speculative_aliasing_check_with:\");\n+    tty->print(\"pre_init:  \"); pre_init->dump();\n+    tty->print(\"pre_limit: \"); pre_limit->dump();\n+    tty->print(\"pre_lastL: \"); pre_lastL->dump();\n+    tty->print(\"main_init: \"); main_init->dump();\n+    tty->print_cr(\"p1_init:\");\n+    p1_init->dump_bfs(5, nullptr, \"\");\n+    tty->print_cr(\"p2_init:\");\n+    p2_init->dump_bfs(5, nullptr, \"\");\n+  }\n+#endif\n+\n+  BoolNode* condition1 = nullptr;\n+  BoolNode* condition2 = nullptr;\n+  if (vp1.iv_scale() == vp2.iv_scale()) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+      tty->print_cr(\"  Same iv_scale(%d) -> parallel lines -> simple conditions:\", vp1.iv_scale());\n+      tty->print_cr(\"  p1(init) + size1 <= p2(init)  OR  p2(init) + size2 <= p1(init)\");\n+      tty->print_cr(\"  -------- condition1 --------      ------- condition2 ---------\");\n+    }\n+#endif\n+    condition1 = make_a_plus_b_leq_c(p1_init, size1, p2_init, phase);\n+    condition2 = make_a_plus_b_leq_c(p2_init, size2, p1_init, phase);\n+  } else {\n+    assert(vp1.iv_scale() < vp2.iv_scale(), \"assumed in proof, established above by swapping\");\n+\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+      tty->print_cr(\"  Different iv_scale -> lines with different slopes -> more complex conditions:\");\n+      tty->print_cr(\"  p1(init)         + size1 <= p2(init)          OR  p2(init) + span2 + size2 <= p1(init) + span1  (if iv_stride >= 0)\");\n+      tty->print_cr(\"  p1(init) + span1 + size1 <= p2(init) + span2  OR  p2(init)         + size2 <= p1(init)          (if iv_stride <= 0)\");\n+      tty->print_cr(\"  ---------------- condition1 ----------------      --------------- condition2 -----------------\");\n+    }\n+#endif\n+\n+    \/\/ last (aka main_last): compute from main-loop structure.\n+    jint main_iv_stride = _vloop.iv_stride();\n+    Node* main_limit = _vloop.cl()->limit();\n+    assert(_vloop.is_pre_loop_invariant(main_limit), \"needed for aliasing check before pre-loop\");\n+\n+    Node* main_limitL = new ConvI2LNode(main_limit);\n+    phase->register_new_node_with_ctrl_of(main_limitL, pre_init);\n+\n+    Node* main_lastL = make_last(main_initL, main_iv_stride, main_limitL, phase);\n+\n+    \/\/ Compute span1 = (last - init) * iv_scale1\n+    \/\/         span2 = (last - init) * iv_scale2\n+    Node* last_minus_init = new SubLNode(main_lastL, main_initL);\n+    Node* iv_scale1 = igvn.longcon(vp1.iv_scale());\n+    Node* iv_scale2 = igvn.longcon(vp2.iv_scale());\n+    Node* span1 = new MulLNode(last_minus_init, iv_scale1);\n+    Node* span2 = new MulLNode(last_minus_init, iv_scale2);\n+\n+    phase->register_new_node_with_ctrl_of(last_minus_init, pre_init);\n+    phase->register_new_node_with_ctrl_of(span1,           pre_init);\n+    phase->register_new_node_with_ctrl_of(span2,           pre_init);\n+\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+      tty->print(\"main_limitL: \"); main_limitL->dump();\n+      tty->print(\"main_lastL: \"); main_lastL->dump();\n+      tty->print(\"p1_init: \"); p1_init->dump();\n+      tty->print(\"p2_init: \"); p2_init->dump();\n+      tty->print(\"size1: \"); size1->dump();\n+      tty->print(\"size2: \"); size2->dump();\n+      tty->print_cr(\"span1: \"); span1->dump_bfs(5, nullptr, \"\");\n+      tty->print_cr(\"span2: \"); span2->dump_bfs(5, nullptr, \"\");\n+    }\n+#endif\n+\n+    Node* p1_init_plus_span1 = new AddLNode(p1_init, span1);\n+    Node* p2_init_plus_span2 = new AddLNode(p2_init, span2);\n+    phase->register_new_node_with_ctrl_of(p1_init_plus_span1, pre_init);\n+    phase->register_new_node_with_ctrl_of(p2_init_plus_span2, pre_init);\n+    if (_vloop.iv_stride() >= 0) {\n+      condition1 = make_a_plus_b_leq_c(p1_init,            size1, p2_init,            phase);\n+      condition2 = make_a_plus_b_leq_c(p2_init_plus_span2, size2, p1_init_plus_span1, phase);\n+    } else {\n+      condition1 = make_a_plus_b_leq_c(p1_init_plus_span1, size1, p2_init_plus_span2, phase);\n+      condition2 = make_a_plus_b_leq_c(p2_init,            size2, p1_init,            phase);\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+    tty->print_cr(\"condition1:\");\n+    condition1->dump_bfs(5, nullptr, \"\");\n+    tty->print_cr(\"condition2:\");\n+    condition2->dump_bfs(5, nullptr, \"\");\n@@ -431,0 +1072,94 @@\n+#endif\n+\n+  \/\/ Construct \"condition1 OR condition2\". Convert the bol value back to an int value\n+  \/\/ that we can \"OR\" to create a single bol value. On x64, the two CMove are converted\n+  \/\/ to two setbe instructions which capture the condition bits to a register, meaning\n+  \/\/ we only have a single branch in the end.\n+  Node* zero = igvn.intcon(0);\n+  Node* one  = igvn.intcon(1);\n+  Node* cmov1 = new CMoveINode(condition1, zero, one, TypeInt::INT);\n+  Node* cmov2 = new CMoveINode(condition2, zero, one, TypeInt::INT);\n+  phase->register_new_node_with_ctrl_of(cmov1, main_initL);\n+  phase->register_new_node_with_ctrl_of(cmov2, main_initL);\n+\n+  Node* c1_or_c2 = new OrINode(cmov1, cmov2);\n+  Node* cmp = CmpNode::make(c1_or_c2, zero, T_INT);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::ne);\n+  phase->register_new_node_with_ctrl_of(c1_or_c2, main_initL);\n+  phase->register_new_node_with_ctrl_of(cmp, main_initL);\n+  phase->register_new_node_with_ctrl_of(bol, main_initL);\n+\n+  return bol;\n+}\n+\n+\/\/ Creates the long pointer expression, evaluated with iv = iv_value.\n+\/\/ Since we are casting pointers to long with CastP2X, we must be careful\n+\/\/ that the values do not cross SafePoints, where the oop could be moved\n+\/\/ by GC, and the already cast value would not be updated, as it is not in\n+\/\/ the oop-map. For this, we must set a ctrl that is late enough, so that we\n+\/\/ cannot cross a SafePoint.\n+Node* VPointer::make_pointer_expression(Node* iv_value, Node* ctrl) const {\n+  assert(is_valid(), \"must be valid\");\n+\n+  PhaseIdealLoop* phase = _vloop.phase();\n+  PhaseIterGVN& igvn = phase->igvn();\n+  Node* iv = _vloop.iv();\n+\n+  auto maybe_add = [&] (Node* n1, Node* n2, BasicType bt) {\n+    if (n1 == nullptr) { return n2; }\n+    Node* add = AddNode::make(n1, n2, bt);\n+    phase->register_new_node(add, ctrl);\n+    return add;\n+  };\n+\n+  Node* expression = nullptr;\n+  mem_pointer().for_each_raw_summand_of_int_group(0, [&] (const MemPointerRawSummand& s) {\n+    Node* node = nullptr;\n+    if (s.is_con()) {\n+      \/\/ Long constant.\n+      NoOverflowInt con = s.scaleI() * s.scaleL();\n+      node = igvn.longcon(con.value());\n+    } else {\n+      \/\/ Long variable.\n+      assert(s.scaleI().is_one(), \"must be long variable\");\n+      Node* scaleL = igvn.longcon(s.scaleL().value());\n+      Node* variable = (s.variable() == iv) ? iv_value : s.variable();\n+      if (variable->bottom_type()->isa_ptr() != nullptr) {\n+        \/\/ Use a ctrl that is late enough, so that we do not\n+        \/\/ evaluate the cast before a SafePoint.\n+        variable = new CastP2XNode(ctrl, variable);\n+        phase->register_new_node(variable, ctrl);\n+      }\n+      node = new MulLNode(scaleL, variable);\n+      phase->register_new_node(node, ctrl);\n+    }\n+    expression = maybe_add(expression, node, T_LONG);\n+  });\n+\n+  int max_int_group = mem_pointer().max_int_group();\n+  for (int int_group = 1; int_group <= max_int_group; int_group++) {\n+    Node* int_expression = nullptr;\n+    NoOverflowInt int_group_scaleL;\n+    mem_pointer().for_each_raw_summand_of_int_group(int_group, [&] (const MemPointerRawSummand& s) {\n+      Node* node = nullptr;\n+      if (s.is_con()) {\n+        node = igvn.intcon(s.scaleI().value());\n+      } else {\n+        Node* scaleI = igvn.intcon(s.scaleI().value());\n+        Node* variable = (s.variable() == iv) ? iv_value : s.variable();\n+        node = new MulINode(scaleI, variable);\n+        phase->register_new_node(node, ctrl);\n+      }\n+      int_group_scaleL = s.scaleL(); \/\/ remember for multiplication after ConvI2L\n+      int_expression = maybe_add(int_expression, node, T_INT);\n+    });\n+    assert(int_expression != nullptr, \"no empty int group\");\n+    int_expression = new ConvI2LNode(int_expression);\n+    phase->register_new_node(int_expression, ctrl);\n+    Node* scaleL = igvn.longcon(int_group_scaleL.value());\n+    int_expression = new MulLNode(scaleL, int_expression);\n+    phase->register_new_node(int_expression, ctrl);\n+    expression = maybe_add(expression, int_expression, T_LONG);\n+  }\n+\n+  return expression;\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":766,"deletions":31,"binary":false,"changes":797,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -164,0 +165,4 @@\n+  bool use_speculative_aliasing_checks() const {\n+    return are_speculative_checks_possible() && UseAutoVectorizationSpeculativeAliasingChecks;\n+  }\n+\n@@ -206,0 +211,4 @@\n+\n+  bool is_trace_speculative_aliasing_analysis() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SPECULATIVE_ALIASING_ANALYSIS);\n+  }\n@@ -225,0 +234,1 @@\n+    \/\/ Usually the ctrl of n is already before the pre-loop.\n@@ -226,4 +236,2 @@\n-\n-    \/\/ Quick test: is it in the main-loop?\n-    if (lpt()->is_member(phase()->get_loop(ctrl))) {\n-      return false;\n+    if (is_before_pre_loop(ctrl)) {\n+      return true;\n@@ -232,2 +240,6 @@\n-    \/\/ Is it before the pre-loop?\n-    return phase()->is_dominator(ctrl, pre_loop_head());\n+    \/\/ But in some cases, the ctrl of n is between the pre and\n+    \/\/ main loop, but the early ctrl is before the pre-loop.\n+    \/\/ As long as the early ctrl is before the pre-loop, we can\n+    \/\/ compute n before the pre-loop.\n+    Node* early = phase()->compute_early_ctrl(n, ctrl);\n+    return is_before_pre_loop(early);\n@@ -242,0 +254,10 @@\n+\n+  bool is_before_pre_loop(Node* ctrl) const {\n+    \/\/ Quick test: is it in the main-loop?\n+    if (lpt()->is_member(phase()->get_loop(ctrl))) {\n+      return false;\n+    }\n+\n+    \/\/ Is it before the pre-loop?\n+    return phase()->is_dominator(ctrl, pre_loop_head());\n+  }\n@@ -572,0 +594,3 @@\n+\/\/    - Strong edge: must be respected.\n+\/\/    - Weak edge:   if we add a speculative aliasing check, we can violate\n+\/\/                   the edge, i.e. swap the order.\n@@ -614,1 +639,1 @@\n-  void add_node(MemNode* n, GrowableArray<int>& memory_pred_edges);\n+  void add_node(MemNode* n, GrowableArray<int>& strong_memory_edges, GrowableArray<int>& weak_memory_edges);\n@@ -628,2 +653,3 @@\n-    const uint _memory_pred_edges_length;\n-    int* _memory_pred_edges; \/\/ memory pred-edges, mapping to bb_idx\n+    const uint _num_strong_memory_edges;\n+    const uint _num_weak_memory_edges;\n+    int* _memory_edges; \/\/ memory pred-edges, mapping to bb_idx\n@@ -631,1 +657,1 @@\n-    DependencyNode(MemNode* n, GrowableArray<int>& memory_pred_edges, Arena* arena);\n+    DependencyNode(MemNode* n, GrowableArray<int>& strong_memory_edges, GrowableArray<int>& weak_memory_edges, Arena* arena);\n@@ -633,1 +659,7 @@\n-    uint memory_pred_edges_length() const { return _memory_pred_edges_length; }\n+    uint num_strong_memory_edges() const { return _num_strong_memory_edges; }\n+    uint num_weak_memory_edges() const { return _num_weak_memory_edges; }\n+\n+    int strong_memory_edge(uint i) const {\n+      assert(i < _num_strong_memory_edges, \"bounds check\");\n+      return _memory_edges[i];\n+    }\n@@ -635,3 +667,3 @@\n-    int memory_pred_edge(uint i) const {\n-      assert(i < _memory_pred_edges_length, \"bounds check\");\n-      return _memory_pred_edges[i];\n+    int weak_memory_edge(uint i) const {\n+      assert(i < _num_weak_memory_edges, \"bounds check\");\n+      return _memory_edges[_num_strong_memory_edges + i];\n@@ -652,0 +684,9 @@\n+    bool _is_current_weak_memory_edge;\n+\n+    \/\/ Iterate in data edges, i.e. iterate node->in(i), excluding control and memory edges.\n+    int _next_data_edge;\n+    int _end_data_edge;\n+\n+    \/\/ Iterate in dependency_node->strong_memory_edges()\n+    int _next_strong_memory_edge;\n+    int _end_strong_memory_edge;\n@@ -653,3 +694,3 @@\n-    \/\/ Iterate in node->in(i)\n-    int _next_pred;\n-    int _end_pred;\n+    \/\/ Iterate in dependency_node->weak_memory_edge()\n+    int _next_weak_memory_edge;\n+    int _end_weak_memory_edge;\n@@ -657,3 +698,0 @@\n-    \/\/ Iterate in dependency_node->memory_pred_edge(i)\n-    int _next_memory_pred;\n-    int _end_memory_pred;\n@@ -665,0 +703,1 @@\n+\n@@ -669,0 +708,1 @@\n+\n@@ -673,0 +713,5 @@\n+\n+    bool is_current_weak_memory_edge() const {\n+      assert(!done(), \"not done yet\");\n+      return _is_current_weak_memory_edge;\n+    }\n@@ -937,0 +982,37 @@\n+  \/\/ Delegate to MemPointer::always_overlaps_with, but guard for invalid cases\n+  \/\/ where we must return a conservative answer: unknown overlap, return false.\n+  bool always_overlaps_with(const VPointer& other) const {\n+    if (!is_valid() || !other.is_valid()) {\n+#ifndef PRODUCT\n+      if (_vloop.mptrace().is_trace_overlap()) {\n+        tty->print_cr(\"VPointer::always_overlaps_with: invalid VPointer, overlap unknown.\");\n+      }\n+#endif\n+      return false;\n+    }\n+    return mem_pointer().always_overlaps_with(other.mem_pointer());\n+  }\n+\n+  static int cmp_summands(const VPointer& vp1, const VPointer& vp2) {\n+    return MemPointer::cmp_summands(vp1.mem_pointer(), vp2.mem_pointer());\n+  }\n+\n+  static int cmp_con(const VPointer& vp1, const VPointer& vp2) {\n+    \/\/ We use two comparisons, because a subtraction could underflow.\n+    jint con1 = vp1.con();\n+    jint con2 = vp2.con();\n+    if (con1 < con2) { return -1; }\n+    if (con1 > con2) { return  1; }\n+    return 0;\n+  }\n+\n+  static int cmp_summands_and_con(const VPointer& vp1, const VPointer& vp2) {\n+    int cmp = cmp_summands(vp1, vp2);\n+    if (cmp != 0) { return cmp; }\n+    return cmp_con(vp1, vp2);\n+  }\n+\n+  bool can_make_speculative_aliasing_check_with(const VPointer& other) const;\n+  Node* make_pointer_expression(Node* iv_value, Node* ctrl) const;\n+  BoolNode* make_speculative_aliasing_check_with(const VPointer& other, Node* ctrl) const;\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":102,"deletions":20,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -995,0 +995,4 @@\n+    case Op_MoveF2I:\n+    case Op_MoveD2L:\n+    case Op_MoveL2D:\n+    case Op_MoveI2F:\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/vectorization.hpp\"\n@@ -60,1 +61,1 @@\n-  collect_nodes_without_req_or_dependency(stack);\n+  collect_nodes_without_strong_in_edges(stack);\n@@ -75,2 +76,5 @@\n-      for (int i = 0; i < vtn->outs(); i++) {\n-        VTransformNode* use = vtn->out(i);\n+      \/\/ We only need to respect the strong edges (data edges and strong memory edges).\n+      \/\/ Violated weak memory edges are allowed, but require a speculative aliasing\n+      \/\/ runtime check, see VTransform::apply_speculative_aliasing_runtime_checks.\n+      for (uint i = 0; i < vtn->out_strong_edges(); i++) {\n+        VTransformNode* use = vtn->out_strong_edge(i);\n@@ -112,2 +116,2 @@\n-\/\/ Push all \"root\" nodes, i.e. those that have no inputs (req or dependency):\n-void VTransformGraph::collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n+\/\/ Push all \"root\" nodes, i.e. those that have no strong input edges (data edges and strong memory edges):\n+void VTransformGraph::collect_nodes_without_strong_in_edges(GrowableArray<VTransformNode*>& stack) const {\n@@ -116,1 +120,1 @@\n-    if (!vtn->has_req_or_dependency()) {\n+    if (!vtn->has_strong_in_edge()) {\n@@ -147,1 +151,1 @@\n-void VTransform::apply_speculative_runtime_checks() {\n+void VTransform::apply_speculative_alignment_runtime_checks() {\n@@ -151,1 +155,1 @@\n-      tty->print_cr(\"\\nVTransform::apply_speculative_runtime_checks: native memory alignment\");\n+      tty->print_cr(\"\\nVTransform::apply_speculative_alignment_runtime_checks: native memory alignment\");\n@@ -202,1 +206,1 @@\n-  Node* mask_alignment = igvn().intcon(alignment-1);\n+  Node* mask_alignment = phase()->intcon(alignment-1);\n@@ -208,1 +212,1 @@\n-  Node* zero = igvn().intcon(0);\n+  Node* zero = phase()->intcon(0);\n@@ -216,1 +220,1 @@\n-  add_speculative_check(bol_alignment);\n+  add_speculative_check([&] (Node* ctrl) { return bol_alignment; });\n@@ -219,1 +223,208 @@\n-void VTransform::add_speculative_check(BoolNode* bol) {\n+class VPointerWeakAliasingPair : public StackObj {\n+private:\n+  \/\/ Using references instead of pointers would be preferrable, but GrowableArray\n+  \/\/ requires a default constructor, and we do not have a default constructor for\n+  \/\/ VPointer.\n+  const VPointer* _vp1 = nullptr;\n+  const VPointer* _vp2 = nullptr;\n+\n+  VPointerWeakAliasingPair(const VPointer& vp1, const VPointer& vp2) : _vp1(&vp1), _vp2(&vp2) {\n+    assert(vp1.is_valid(), \"sanity\");\n+    assert(vp2.is_valid(), \"sanity\");\n+    assert(!vp1.never_overlaps_with(vp2), \"otherwise no aliasing\");\n+    assert(!vp1.always_overlaps_with(vp2), \"otherwise must be strong\");\n+    assert(VPointer::cmp_summands_and_con(vp1, vp2) <= 0, \"must be sorted\");\n+  }\n+\n+public:\n+  \/\/ Default constructor to make GrowableArray happy.\n+  VPointerWeakAliasingPair() : _vp1(nullptr), _vp2(nullptr) {}\n+\n+  static VPointerWeakAliasingPair make(const VPointer& vp1, const VPointer& vp2) {\n+    if (VPointer::cmp_summands_and_con(vp1, vp2) <= 0) {\n+      return VPointerWeakAliasingPair(vp1, vp2);\n+    } else {\n+      return VPointerWeakAliasingPair(vp2, vp1);\n+    }\n+  }\n+\n+  const VPointer& vp1() const { return *_vp1; }\n+  const VPointer& vp2() const { return *_vp2; }\n+\n+  \/\/ Sort by summands, so that pairs with same summands (summand1, summands2) are adjacent.\n+  static int cmp_for_sort(VPointerWeakAliasingPair* pair1, VPointerWeakAliasingPair* pair2) {\n+    int cmp_summands1 = VPointer::cmp_summands(pair1->vp1(), pair2->vp1());\n+    if (cmp_summands1 != 0) { return cmp_summands1; }\n+    return VPointer::cmp_summands(pair1->vp2(), pair2->vp2());\n+  }\n+};\n+\n+void VTransform::apply_speculative_aliasing_runtime_checks() {\n+\n+  if (_vloop.use_speculative_aliasing_checks()) {\n+\n+#ifdef ASSERT\n+    if (_trace._speculative_aliasing_analysis || _trace._speculative_runtime_checks) {\n+      tty->print_cr(\"\\nVTransform::apply_speculative_aliasing_runtime_checks: speculative aliasing analysis runtime checks\");\n+    }\n+#endif\n+\n+    \/\/ It would be nice to add a ResourceMark here. But it would collide with resource allocation\n+    \/\/ in PhaseIdealLoop::set_idom for _idom and _dom_depth. See also JDK-8337015.\n+    VectorSet visited;\n+    GrowableArray<VPointerWeakAliasingPair> weak_aliasing_pairs;\n+\n+    const GrowableArray<VTransformNode*>& schedule = _graph.get_schedule();\n+    for (int i = 0; i < schedule.length(); i++) {\n+      VTransformNode* vtn = schedule.at(i);\n+      for (uint i = 0; i < vtn->out_weak_edges(); i++) {\n+        VTransformNode* use = vtn->out_weak_edge(i);\n+        if (visited.test(use->_idx)) {\n+          \/\/ The use node was already visited, i.e. is higher up in the schedule.\n+          \/\/ The \"out\" edge thus points backward, i.e. it is violated.\n+          const VPointer& vp1 = vtn->vpointer();\n+          const VPointer& vp2 = use->vpointer();\n+#ifdef ASSERT\n+          if (_trace._speculative_aliasing_analysis || _trace._speculative_runtime_checks) {\n+            tty->print_cr(\"\\nViolated Weak Edge:\");\n+            vtn->print();\n+            vp1.print_on(tty);\n+            use->print();\n+            vp2.print_on(tty);\n+          }\n+#endif\n+\n+          \/\/ We could generate checks for the pair (vp1, vp2) directly. But in\n+          \/\/ some graphs, this generates quadratically many checks. Example:\n+          \/\/\n+          \/\/   set1: a[i+0] a[i+1] a[i+2] a[i+3]\n+          \/\/   set2: b[i+0] b[i+1] b[i+2] b[i+3]\n+          \/\/\n+          \/\/ We may have a weak memory edge between every memory access from\n+          \/\/ set1 to every memory access from set2. In this example, this would\n+          \/\/ be 4 * 4 = 16 checks. But instead, we can create a union VPointer\n+          \/\/ for set1 and set2 each, and only create a single check.\n+          \/\/\n+          \/\/   set1: a[i+0, size = 4]\n+          \/\/   set1: b[i+0, size = 4]\n+          \/\/\n+          \/\/ For this, we add all pairs to an array, and process it below.\n+          weak_aliasing_pairs.push(VPointerWeakAliasingPair::make(vp1, vp2));\n+        }\n+      }\n+      visited.set(vtn->_idx);\n+    }\n+\n+    \/\/ Sort so that all pairs with the same summands (summands1, summands2)\n+    \/\/ are consecutive, i.e. in the same group. This allows us to do a linear\n+    \/\/ walk over all pairs of a group and create the union VPointers.\n+    weak_aliasing_pairs.sort(VPointerWeakAliasingPair::cmp_for_sort);\n+\n+    int group_start = 0;\n+    while (group_start < weak_aliasing_pairs.length()) {\n+      \/\/ New group: pick the first pair as the reference.\n+      const VPointer* vp1 = &weak_aliasing_pairs.at(group_start).vp1();\n+      const VPointer* vp2 = &weak_aliasing_pairs.at(group_start).vp2();\n+      jint size1 = vp1->size();\n+      jint size2 = vp2->size();\n+      int group_end = group_start + 1;\n+      while (group_end < weak_aliasing_pairs.length()) {\n+        const VPointer* vp1_next = &weak_aliasing_pairs.at(group_end).vp1();\n+        const VPointer* vp2_next = &weak_aliasing_pairs.at(group_end).vp2();\n+        jint size1_next = vp1_next->size();\n+        jint size2_next = vp2_next->size();\n+\n+        \/\/ Different summands -> different group.\n+        if (VPointer::cmp_summands(*vp1, *vp1_next) != 0) { break; }\n+        if (VPointer::cmp_summands(*vp2, *vp2_next) != 0) { break; }\n+\n+        \/\/ Pick the one with the lower con as the reference.\n+        if (vp1->con() > vp1_next->con()) {\n+          swap(vp1, vp1_next);\n+          swap(size1, size1_next);\n+        }\n+        if (vp2->con() > vp2_next->con()) {\n+          swap(vp2, vp2_next);\n+          swap(size2, size2_next);\n+        }\n+\n+        \/\/ Compute the distance from vp1 to vp1_next + size, to get a size that would include vp1_next.\n+        NoOverflowInt new_size1 = NoOverflowInt(vp1_next->con()) + NoOverflowInt(size1_next) - NoOverflowInt(vp1->con());\n+        NoOverflowInt new_size2 = NoOverflowInt(vp2_next->con()) + NoOverflowInt(size2_next) - NoOverflowInt(vp2->con());\n+        if (new_size1.is_NaN() || new_size2.is_NaN()) { break; \/* overflow -> new group *\/ }\n+\n+        \/\/ The \"next\" VPointer indeed belong to the group.\n+        \/\/\n+        \/\/ vp1:       |-------------->\n+        \/\/ vp1_next:            |---------------->\n+        \/\/ result:    |-------------------------->\n+        \/\/\n+        \/\/ vp1:       |-------------------------->\n+        \/\/ vp1_next:            |------->\n+        \/\/ result:    |-------------------------->\n+        \/\/\n+        size1 = MAX2(size1, new_size1.value());\n+        size2 = MAX2(size2, new_size2.value());\n+        group_end++;\n+      }\n+      \/\/ Create \"union\" VPointer that cover all VPointer from the group.\n+      const VPointer vp1_union = vp1->make_with_size(size1);\n+      const VPointer vp2_union = vp2->make_with_size(size2);\n+\n+#ifdef ASSERT\n+      if (_trace._speculative_aliasing_analysis || _trace._speculative_runtime_checks) {\n+        tty->print_cr(\"\\nUnion of %d weak aliasing edges:\", group_end - group_start);\n+        vp1_union.print_on(tty);\n+        vp2_union.print_on(tty);\n+      }\n+\n+      \/\/ Verification - union must contain all VPointer of the group.\n+      for (int i = group_start; i < group_end; i++) {\n+        const VPointer& vp1_i = weak_aliasing_pairs.at(i).vp1();\n+        const VPointer& vp2_i = weak_aliasing_pairs.at(i).vp2();\n+        assert(vp1_union.con() <= vp1_i.con(), \"must start before\");\n+        assert(vp2_union.con() <= vp2_i.con(), \"must start before\");\n+        assert(vp1_union.size() >= vp1_i.size(), \"must end after\");\n+        assert(vp2_union.size() >= vp2_i.size(), \"must end after\");\n+      }\n+#endif\n+\n+      add_speculative_check([&] (Node* ctrl) {\n+        return vp1_union.make_speculative_aliasing_check_with(vp2_union, ctrl);\n+      });\n+\n+      group_start = group_end;\n+    }\n+  }\n+}\n+\n+\/\/ Runtime Checks:\n+\/\/   Some required properties cannot be proven statically, and require a\n+\/\/   runtime check:\n+\/\/   - Alignment:\n+\/\/       See VTransform::add_speculative_alignment_check\n+\/\/   - Aliasing:\n+\/\/       See VTransform::apply_speculative_aliasing_runtime_checks\n+\/\/   There is a two staged approach for compilation:\n+\/\/   - AutoVectorization Predicate:\n+\/\/       See VM flag UseAutoVectorizationPredicate and documentation in predicates.hpp\n+\/\/       We speculate that the checks pass, and only compile a vectorized  loop.\n+\/\/       We expect the checks to pass in almost all cases, and so we only need\n+\/\/       to compile and cache the vectorized loop.\n+\/\/       If the predicate ever fails, we deoptimize, and eventually compile\n+\/\/       without predicate. This means we will recompile with multiversioning.\n+\/\/    - Multiversioning:\n+\/\/       See VM Flag LoopMultiversioning and documentaiton in loopUnswitch.cpp\n+\/\/       If the predicate is not available or previously failed, then we compile\n+\/\/       a vectorized and a scalar loop. If the runtime check passes we take the\n+\/\/       vectorized loop, else the scalar loop.\n+\/\/       Multiversioning takes more compile time and code cache, but it also\n+\/\/       produces fast code for when the runtime check passes (vectorized) and\n+\/\/       when it fails (scalar performance).\n+\/\/\n+\/\/ Callback:\n+\/\/   In some cases, we require the ctrl just before the check iff_speculate to\n+\/\/   generate the values required in the check. We pass this ctrl into the\n+\/\/   callback, which is expected to produce the check, i.e. a BoolNode.\n+template<typename Callback>\n+void VTransform::add_speculative_check(Callback callback) {\n@@ -231,0 +442,4 @@\n+\n+  \/\/ Create the check, given the ctrl just before the iff.\n+  BoolNode* bol = callback(iff_speculate->in(0));\n+\n@@ -429,1 +644,1 @@\n-        const VPointer& p = vtn->vpointer(vloop_analyzer);\n+        const VPointer& p = vtn->vpointer();\n@@ -496,3 +711,8 @@\n-Node* VTransformNode::find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* n = vnode_idx_to_transformed_node.at(in(i)->_idx);\n-  assert(n != nullptr, \"must find input IR node\");\n+void VTransformApplyState::set_transformed_node(VTransformNode* vtn, Node* n) {\n+  assert(_vtnode_idx_to_transformed_node.at(vtn->_idx) == nullptr, \"only set once\");\n+  _vtnode_idx_to_transformed_node.at_put(vtn->_idx, n);\n+}\n+\n+Node* VTransformApplyState::transformed_node(const VTransformNode* vtn) const {\n+  Node* n = _vtnode_idx_to_transformed_node.at(vtn->_idx);\n+  assert(n != nullptr, \"must find IR node for vtnode\");\n@@ -502,2 +722,6 @@\n-VTransformApplyResult VTransformScalarNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                  const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformMemopScalarNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformDataScalarNode::apply(VTransformApplyState& apply_state) const {\n@@ -508,3 +732,17 @@\n-VTransformApplyResult VTransformReplicateNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                     const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformLoopPhiNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformCFGNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformOuterNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformReplicateNode::apply(VTransformApplyState& apply_state) const {\n+  Node* val = apply_state.transformed_node(in_req(1));\n@@ -512,1 +750,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  register_new_node_from_vectorization(apply_state, vn, val);\n@@ -516,3 +754,2 @@\n-VTransformApplyResult VTransformConvI2LNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                   const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformConvI2LNode::apply(VTransformApplyState& apply_state) const {\n+  Node* val = apply_state.transformed_node(in_req(1));\n@@ -520,1 +757,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, n, val);\n+  register_new_node_from_vectorization(apply_state, n, val);\n@@ -524,4 +761,3 @@\n-VTransformApplyResult VTransformShiftCountNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  Node* shift_count_in = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformShiftCountNode::apply(VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  Node* shift_count_in = apply_state.transformed_node(in_req(1));\n@@ -532,2 +768,2 @@\n-  Node* shift_count_masked = new AndINode(shift_count_in, phase->igvn().intcon(_mask));\n-  register_new_node_from_vectorization(vloop_analyzer, shift_count_masked, shift_count_in);\n+  Node* shift_count_masked = new AndINode(shift_count_in, phase->intcon(_mask));\n+  register_new_node_from_vectorization(apply_state, shift_count_masked, shift_count_in);\n@@ -536,1 +772,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, vn, shift_count_in);\n+  register_new_node_from_vectorization(apply_state, vn, shift_count_in);\n@@ -541,4 +777,3 @@\n-VTransformApplyResult VTransformPopulateIndexNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                         const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformPopulateIndexNode::apply(VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  Node* val = apply_state.transformed_node(in_req(1));\n@@ -548,2 +783,2 @@\n-  VectorNode* vn = new PopulateIndexNode(val, phase->igvn().intcon(1), vt);\n-  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  VectorNode* vn = new PopulateIndexNode(val, phase->intcon(1), vt);\n+  register_new_node_from_vectorization(apply_state, vn, val);\n@@ -553,2 +788,1 @@\n-VTransformApplyResult VTransformElementWiseVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                             const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformElementWiseVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -558,1 +792,1 @@\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n@@ -568,3 +802,3 @@\n-  Node* in1 =                find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* in2 = (req() >= 3) ? find_transformed_input(2, vnode_idx_to_transformed_node) : nullptr;\n-  Node* in3 = (req() >= 4) ? find_transformed_input(3, vnode_idx_to_transformed_node) : nullptr;\n+  Node* in1 =                apply_state.transformed_node(in_req(1));\n+  Node* in2 = (req() >= 3) ? apply_state.transformed_node(in_req(2)) : nullptr;\n+  Node* in3 = (req() >= 4) ? apply_state.transformed_node(in_req(3)) : nullptr;\n@@ -582,1 +816,1 @@\n-    vn = new VectorReinterpretNode(in1, vt, in1->bottom_type()->is_vect());\n+    vn = new VectorReinterpretNode(in1, in1->bottom_type()->is_vect(), vt);\n@@ -590,1 +824,1 @@\n-    register_new_node_from_vectorization(vloop_analyzer, long_vn, first);\n+    register_new_node_from_vectorization(apply_state, long_vn, first);\n@@ -608,1 +842,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -612,2 +846,1 @@\n-VTransformApplyResult VTransformBoolVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformBoolVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -616,1 +849,1 @@\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n@@ -619,1 +852,1 @@\n-  VTransformElementWiseVectorNode* vtn_cmp = in(1)->isa_ElementWiseVector();\n+  VTransformElementWiseVectorNode* vtn_cmp = in_req(1)->isa_ElementWiseVector();\n@@ -623,2 +856,2 @@\n-  Node* cmp_in1 = vtn_cmp->find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* cmp_in2 = vtn_cmp->find_transformed_input(2, vnode_idx_to_transformed_node);\n+  Node* cmp_in1 = apply_state.transformed_node(vtn_cmp->in_req(1));\n+  Node* cmp_in2 = apply_state.transformed_node(vtn_cmp->in_req(2));\n@@ -627,2 +860,2 @@\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  ConINode* mask_node  = phase->igvn().intcon((int)mask);\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  ConINode* mask_node  = phase->intcon((int)mask);\n@@ -631,1 +864,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -635,2 +868,1 @@\n-VTransformApplyResult VTransformReductionVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                           const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformReductionVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -642,2 +874,2 @@\n-  Node* init = find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* vec  = find_transformed_input(2, vnode_idx_to_transformed_node);\n+  Node* init = apply_state.transformed_node(in_req(1));\n+  Node* vec  = apply_state.transformed_node(in_req(2));\n@@ -646,1 +878,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -650,2 +882,1 @@\n-VTransformApplyResult VTransformLoadVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformLoadVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -659,1 +890,1 @@\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n@@ -664,1 +895,1 @@\n-  const VPointer& load_p = vpointer(vloop_analyzer);\n+  const VPointer& load_p = vpointer();\n@@ -666,1 +897,1 @@\n-    VPointer store_p(mem->as_Mem(), vloop_analyzer.vloop());\n+    VPointer store_p(mem->as_Mem(), apply_state.vloop());\n@@ -677,1 +908,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -681,2 +912,1 @@\n-VTransformApplyResult VTransformStoreVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                       const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformStoreVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -691,1 +921,1 @@\n-  Node* value = find_transformed_input(MemNode::ValueIn, vnode_idx_to_transformed_node);\n+  Node* value = apply_state.transformed_node(in_req(MemNode::ValueIn));\n@@ -694,1 +924,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -698,2 +928,2 @@\n-void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(VTransformApplyState& apply_state, Node* vn) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n@@ -702,1 +932,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, vn, first);\n+  register_new_node_from_vectorization(apply_state, vn, first);\n@@ -710,2 +940,2 @@\n-void VTransformNode::register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+void VTransformNode::register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n@@ -753,2 +983,8 @@\n-    tty->print(\" |\");\n-    for (int i = _req; i < _in.length(); i++) {\n+    tty->print(\" | strong:\");\n+    for (uint i = _req; i < _in_end_strong_memory_edges; i++) {\n+      print_node_idx(_in.at(i));\n+    }\n+  }\n+  if ((uint)_in.length() > _in_end_strong_memory_edges) {\n+    tty->print(\" | weak:\");\n+    for (uint i = _in_end_strong_memory_edges; i < (uint)_in.length(); i++) {\n@@ -759,1 +995,1 @@\n-  for (int i = 0; i < _out.length(); i++) {\n+  for (uint i = 0; i < _out_end_strong_edges; i++) {\n@@ -762,0 +998,6 @@\n+  if ((uint)_out.length() > _out_end_strong_edges) {\n+    tty->print(\" | weak:\");\n+    for (uint i = _out_end_strong_edges; i < (uint)_out.length(); i++) {\n+      print_node_idx(_out.at(i));\n+    }\n+  }\n@@ -775,1 +1017,18 @@\n-void VTransformScalarNode::print_spec() const {\n+void VTransformMemopScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s] \", _node->_idx, _node->Name());\n+  _vpointer.print_on(tty, false);\n+}\n+\n+void VTransformDataScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformLoopPhiNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformCFGNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformOuterNode::print_spec() const {\n@@ -803,0 +1062,4 @@\n+  if (is_load_or_store_in_loop()) {\n+    tty->print(\" \");\n+    vpointer().print_on(tty, false);\n+  }\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":344,"deletions":81,"binary":false,"changes":425,"status":"modified"},{"patch":"@@ -63,2 +63,5 @@\n-class VTransformScalarNode;\n-class VTransformInputScalarNode;\n+class VTransformMemopScalarNode;\n+class VTransformDataScalarNode;\n+class VTransformLoopPhiNode;\n+class VTransformCFGNode;\n+class VTransformOuterNode;\n@@ -112,0 +115,1 @@\n+  const bool _speculative_aliasing_analysis;\n@@ -118,0 +122,1 @@\n+                  const bool is_trace_speculative_aliasing_analysis,\n@@ -121,4 +126,5 @@\n-    _rejections                (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n-    _align_vector              (_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n-    _speculative_runtime_checks(_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_runtime_checks),\n-    _info                      (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n+    _rejections                    (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n+    _align_vector                  (_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n+    _speculative_aliasing_analysis (_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_aliasing_analysis),\n+    _speculative_runtime_checks    (_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_runtime_checks),\n+    _info                          (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n@@ -164,0 +170,1 @@\n+  const GrowableArray<VTransformNode*>& get_schedule() const { return _schedule; }\n@@ -176,1 +183,1 @@\n-  void collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n+  void collect_nodes_without_strong_in_edges(GrowableArray<VTransformNode*>& stack) const;\n@@ -251,1 +258,2 @@\n-  void apply_speculative_runtime_checks();\n+  void apply_speculative_alignment_runtime_checks();\n+  void apply_speculative_aliasing_runtime_checks();\n@@ -253,1 +261,3 @@\n-  void add_speculative_check(BoolNode* bol);\n+\n+  template<typename Callback>\n+  void add_speculative_check(Callback callback);\n@@ -258,0 +268,26 @@\n+\/\/ Keeps track of the state during \"VTransform::apply\"\n+\/\/ -> keep track of the already transformed nodes\n+class VTransformApplyState : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+\n+  \/\/ We keep track of the resulting Nodes from every \"VTransformNode::apply\" call.\n+  \/\/ Since \"apply\" is called on defs before uses, this allows us to find the\n+  \/\/ generated def (input) nodes when we are generating the use nodes in \"apply\".\n+  GrowableArray<Node*> _vtnode_idx_to_transformed_node;\n+\n+public:\n+  VTransformApplyState(const VLoopAnalyzer& vloop_analyzer, int num_vtnodes) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vtnode_idx_to_transformed_node(num_vtnodes, num_vtnodes, nullptr)\n+  {\n+  }\n+\n+  const VLoop& vloop() const { return _vloop_analyzer.vloop(); }\n+  PhaseIdealLoop* phase() const { return vloop().phase(); }\n+  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n+\n+  void set_transformed_node(VTransformNode* vtn, Node* n);\n+  Node* transformed_node(const VTransformNode* vtn) const;\n+};\n+\n@@ -262,0 +298,20 @@\n+\/\/\n+\/\/ There are 3 tyes of edges:\n+\/\/ - data edges (req):           corresponding to C2 IR Node data edges, except control\n+\/\/                               and memory.\n+\/\/ - strong memory edges:        memory edges that must be respected when scheduling.\n+\/\/ - weak memory edges:          memory edges that can be violated, but if violated then\n+\/\/                               corresponding aliasing analysis runtime checks must be\n+\/\/                               inserted.\n+\/\/\n+\/\/ Strong edges: union of data edges and strong memory edges.\n+\/\/               These must be respected by scheduling in all cases.\n+\/\/\n+\/\/ The C2 IR Node memory edges essentially define a linear order of all memory operations\n+\/\/ (only Loads with the same memory input can be executed in an arbitrary order). This is\n+\/\/ efficient, because it means every Load and Store has exactly one input memory edge,\n+\/\/ which keeps the memory edge count linear. This is approach is too restrictive for\n+\/\/ vectorization, for example, we could never vectorize stores, since they are all in a\n+\/\/ dependency chain. Instead, we model the memory edges between all memory nodes, which\n+\/\/ could be quadratic in the worst case. For vectorization, we must essentially reorder the\n+\/\/ instructions in the graph. For this we must model all memory dependencies.\n@@ -267,2 +323,4 @@\n-  \/\/ _in is split into required inputs (_req, i.e. all data dependencies),\n-  \/\/ and memory dependencies.\n+  \/\/ We split _in into 3 sections:\n+  \/\/ - data edges (req):     _in[0                           .. _req-1]\n+  \/\/ - strong memory edges:  _in[_req                        .. _in_end_strong_memory_edges-1]\n+  \/\/ - weak memory edges:    _in[_in_end_strong_memory_edges .. ]\n@@ -270,0 +328,1 @@\n+  uint _in_end_strong_memory_edges;\n@@ -271,0 +330,5 @@\n+\n+  \/\/ We split _out into 2 sections:\n+  \/\/ - strong edges:         _out[0                     .. _out_end_strong_edges-1]\n+  \/\/ - weak memory edges:    _out[_out_end_strong_edges .. _len-1]\n+  uint _out_end_strong_edges;\n@@ -277,0 +341,1 @@\n+    _in_end_strong_memory_edges(req),\n@@ -278,0 +343,1 @@\n+    _out_end_strong_edges(0),\n@@ -283,1 +349,1 @@\n-  void set_req(uint i, VTransformNode* n) {\n+  void init_req(uint i, VTransformNode* n) {\n@@ -287,1 +353,1 @@\n-    n->add_out(this);\n+    n->add_out_strong_edge(this);\n@@ -298,1 +364,16 @@\n-  void add_memory_dependency(VTransformNode* n) {\n+  void add_strong_memory_edge(VTransformNode* n) {\n+    assert(n != nullptr, \"no need to add nullptr\");\n+    if (_in_end_strong_memory_edges < (uint)_in.length()) {\n+      \/\/ Put n in place of first weak memory edge, and move\n+      \/\/ the weak memory edge to the end.\n+      VTransformNode* first_weak = _in.at(_in_end_strong_memory_edges);\n+      _in.at_put(_in_end_strong_memory_edges, n);\n+      _in.push(first_weak);\n+    } else {\n+      _in.push(n);\n+    }\n+    _in_end_strong_memory_edges++;\n+    n->add_out_strong_edge(this);\n+  }\n+\n+  void add_weak_memory_edge(VTransformNode* n) {\n@@ -301,1 +382,15 @@\n-    n->add_out(this);\n+    n->add_out_weak_memory_edge(this);\n+  }\n+\n+private:\n+  void add_out_strong_edge(VTransformNode* n) {\n+    if (_out_end_strong_edges < (uint)_out.length()) {\n+      \/\/ Put n in place of first weak memory edge, and move\n+      \/\/ the weak memory edge to the end.\n+      VTransformNode* first_weak = _out.at(_out_end_strong_edges);\n+      _out.at_put(_out_end_strong_edges, n);\n+      _out.push(first_weak);\n+    } else {\n+      _out.push(n);\n+    }\n+    _out_end_strong_edges++;\n@@ -304,1 +399,1 @@\n-  void add_out(VTransformNode* n) {\n+  void add_out_weak_memory_edge(VTransformNode* n) {\n@@ -308,0 +403,1 @@\n+public:\n@@ -309,3 +405,2 @@\n-  VTransformNode* in(int i) const { return _in.at(i); }\n-  int outs() const { return _out.length(); }\n-  VTransformNode* out(int i) const { return _out.at(i); }\n+  uint out_strong_edges() const { return _out_end_strong_edges; }\n+  uint out_weak_edges() const { return _out.length() - _out_end_strong_edges; }\n@@ -313,2 +408,17 @@\n-  bool has_req_or_dependency() const {\n-    for (int i = 0; i < _in.length(); i++) {\n+  VTransformNode* in_req(uint i) const {\n+    assert(i < _req, \"must be a req\");\n+    return _in.at(i);\n+  }\n+\n+  VTransformNode* out_strong_edge(uint i) const {\n+    assert(i < out_strong_edges(), \"must be a strong memory edge or data edge\");\n+    return _out.at(i);\n+  }\n+\n+  VTransformNode* out_weak_edge(uint i) const {\n+    assert(i < out_weak_edges(), \"must be a strong memory edge\");\n+    return _out.at(_out_end_strong_edges + i);\n+  }\n+\n+  bool has_strong_in_edge() const {\n+    for (uint i = 0; i < _in_end_strong_memory_edges; i++) {\n@@ -320,2 +430,2 @@\n-  virtual VTransformScalarNode* isa_Scalar() { return nullptr; }\n-  virtual VTransformInputScalarNode* isa_InputScalar() { return nullptr; }\n+  virtual VTransformMemopScalarNode* isa_MemopScalar() { return nullptr; }\n+  virtual VTransformOuterNode* isa_Outer() { return nullptr; }\n@@ -332,1 +442,1 @@\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const { ShouldNotReachHere(); }\n+  virtual const VPointer& vpointer() const { ShouldNotReachHere(); }\n@@ -334,2 +444,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const = 0;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const = 0;\n@@ -339,1 +448,1 @@\n-  void register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const;\n+  void register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const;\n@@ -347,2 +456,2 @@\n-\/\/ Identity transform for scalar nodes.\n-class VTransformScalarNode : public VTransformNode {\n+\/\/ Identity transform for scalar loads and stores.\n+class VTransformMemopScalarNode : public VTransformNode {\n@@ -350,1 +459,2 @@\n-  Node* _node;\n+  MemNode* _node;\n+  const VPointer _vpointer;\n@@ -352,4 +462,9 @@\n-  VTransformScalarNode(VTransform& vtransform, Node* n) :\n-    VTransformNode(vtransform, n->req()), _node(n) {}\n-  Node* node() const { return _node; }\n-  virtual VTransformScalarNode* isa_Scalar() override { return this; }\n+  VTransformMemopScalarNode(VTransform& vtransform, MemNode* n, const VPointer& vpointer) :\n+    VTransformNode(vtransform, n->req()), _node(n), _vpointer(vpointer)\n+  {\n+    assert(node()->is_Load() || node()->is_Store(), \"must be memop\");\n+  }\n+\n+  MemNode* node() const { return _node; }\n+  virtual VTransformMemopScalarNode* isa_MemopScalar() override { return this; }\n+\n@@ -357,5 +472,53 @@\n-  virtual bool is_load_or_store_in_loop() const override { return _node->is_Load() || _node->is_Store(); }\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return vloop_analyzer.vpointers().vpointer(node()->as_Mem()); }\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"Scalar\"; };)\n+  virtual bool is_load_or_store_in_loop() const override { return true; }\n+\n+  virtual const VPointer& vpointer() const override { return _vpointer; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"MemopScalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for scalar data nodes.\n+class VTransformDataScalarNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformDataScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(!_node->is_Mem() && !_node->is_Phi() && !_node->is_CFG(), \"must be data node: %s\", _node->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"DataScalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for loop head phi nodes.\n+class VTransformLoopPhiNode : public VTransformNode {\n+private:\n+  PhiNode* _node;\n+public:\n+  VTransformLoopPhiNode(VTransform& vtransform, PhiNode* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(_node->in(0)->is_Loop(), \"phi ctrl must be Loop: %s\", _node->in(0)->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"LoopPhi\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for CFG nodes.\n+class VTransformCFGNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformCFGNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(_node->is_CFG(), \"must be CFG node: %s\", _node->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"CFG\"; };)\n@@ -368,1 +531,3 @@\n-class VTransformInputScalarNode : public VTransformScalarNode {\n+class VTransformOuterNode : public VTransformNode {\n+private:\n+  Node* _node;\n@@ -370,6 +535,7 @@\n-  VTransformInputScalarNode(VTransform& vtransform, Node* n) :\n-    VTransformScalarNode(vtransform, n) {}\n-  virtual VTransformInputScalarNode* isa_InputScalar() override { return this; }\n-  virtual bool is_load_in_loop() const override { return false; }\n-  virtual bool is_load_or_store_in_loop() const override { return false; }\n-  NOT_PRODUCT(virtual const char* name() const override { return \"InputScalar\"; };)\n+  VTransformOuterNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n) {}\n+\n+  virtual VTransformOuterNode* isa_Outer() override { return this; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Outer\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n@@ -386,2 +552,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -396,2 +561,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -411,2 +575,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -425,2 +588,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -447,1 +609,1 @@\n-  void register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const;\n+  void register_new_node_from_vectorization_and_replace_scalar_nodes(VTransformApplyState& apply_state, Node* vn) const;\n@@ -457,2 +619,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -478,2 +639,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -489,2 +649,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -505,1 +664,1 @@\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return _vpointer; }\n+  virtual const VPointer& vpointer() const override { return _vpointer; }\n@@ -516,2 +675,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -528,2 +686,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -541,2 +698,2 @@\n-    \/\/ We can ignore input nodes, they are outside the loop.\n-    if (vtn->isa_InputScalar() != nullptr) { continue; }\n+    \/\/ We must ignore nodes outside the loop.\n+    if (vtn->isa_Outer() != nullptr) { continue; }\n@@ -544,3 +701,3 @@\n-    VTransformScalarNode* scalar = vtn->isa_Scalar();\n-    if (scalar != nullptr && scalar->node()->is_Mem()) {\n-      callback(scalar->node()->as_Mem());\n+    VTransformMemopScalarNode* scalar = vtn->isa_MemopScalar();\n+    if (scalar != nullptr) {\n+      callback(scalar->node());\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":228,"deletions":71,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-\/\/ These header files are included in at least 130 C++ files, as of\n-\/\/ measurements made in November 2018. This list excludes files named\n-\/\/ *.inline.hpp, since including them decreased build performance.\n+\/\/ These header files are selected using the output of Clang\n+\/\/ '-ftime-trace' as a measure of how much time we spend\n+\/\/ compiling them.\n@@ -32,6 +32,1 @@\n-#include \"classfile\/classLoaderData.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"gc\/shared\/gcCause.hpp\"\n-#include \"logging\/log.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -39,35 +34,1 @@\n-#include \"memory\/iterator.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"nmt\/memTracker.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/method.hpp\"\n-#include \"oops\/objArrayKlass.hpp\"\n-#include \"oops\/objArrayOop.hpp\"\n-#include \"oops\/oop.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/handles.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/orderAccess.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/timer.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/bitMap.hpp\"\n-#include \"utilities\/copy.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-#ifdef TARGET_COMPILER_visCPP\n-\/\/ For Visual Studio, including the *.inline.hpp files actually\n-\/\/ increased performance.\n-#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/iterator.inline.hpp\"\n@@ -75,0 +36,2 @@\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -76,2 +39,13 @@\n-#include \"runtime\/handles.inline.hpp\"\n-#endif \/\/ TARGET_COMPILER_visCPP\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#if INCLUDE_SHENANDOAHGC\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#endif\n+#if INCLUDE_ZGC\n+#include \"gc\/z\/zBarrier.inline.hpp\"\n+#include \"gc\/z\/zGeneration.inline.hpp\"\n+#include \"gc\/z\/zHeap.inline.hpp\"\n+#endif\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":20,"deletions":46,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"foreignGlobals.hpp\"\n@@ -29,1 +28,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -204,1 +203,1 @@\n-  using KillerTable = ResourceHashtable<\n+  using KillerTable = HashTable<\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n@@ -48,1 +47,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"classfile\/classLoaderData.hpp\"\n@@ -64,1 +64,0 @@\n-#include \"oops\/recordComponent.hpp\"\n@@ -68,0 +67,1 @@\n+#include \"oops\/recordComponent.hpp\"\n@@ -76,0 +76,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -78,0 +79,1 @@\n+#include \"runtime\/handshake.hpp\"\n@@ -80,2 +82,0 @@\n-#include \"runtime\/deoptimization.hpp\"\n-#include \"runtime\/handshake.hpp\"\n@@ -95,1 +95,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -97,0 +96,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -1180,1 +1180,1 @@\n-      Klass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n+      InstanceKlass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n@@ -1930,1 +1930,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj))\n@@ -1938,1 +1938,1 @@\n-JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jint index))\n@@ -1951,1 +1951,1 @@\n-JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jint index))\n@@ -1995,1 +1995,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jint index))\n@@ -2005,1 +2005,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jint index))\n@@ -2040,1 +2040,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jint index))\n@@ -2050,1 +2050,1 @@\n-JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jint index))\n@@ -2060,1 +2060,1 @@\n-JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jint index))\n@@ -2085,1 +2085,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jint index))\n@@ -2098,1 +2098,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jint index))\n@@ -2111,1 +2111,1 @@\n-JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jint index))\n@@ -2132,1 +2132,1 @@\n-JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jint index))\n@@ -2144,1 +2144,1 @@\n-JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jint index))\n@@ -2156,1 +2156,1 @@\n-JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jint index))\n@@ -2168,1 +2168,1 @@\n-JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jint index))\n@@ -2180,1 +2180,1 @@\n-JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jint index))\n@@ -2193,1 +2193,1 @@\n-JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jint index))\n@@ -2208,1 +2208,1 @@\n-JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))\n+JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jint index))\n@@ -2948,1 +2948,1 @@\n-  oop trace = java_lang_Thread::async_get_stack_trace(JNIHandles::resolve(jthread), THREAD);\n+  oop trace = java_lang_Thread::async_get_stack_trace(jthread, THREAD);\n@@ -3426,1 +3426,1 @@\n-  if (!caller_ik->is_shared()) {\n+  if (!caller_ik->in_aot_cache()) {\n@@ -3507,1 +3507,1 @@\n-  MetaspaceShared::dump_loaded_classes(file_name, THREAD);\n+  AOTMetaspace::dump_loaded_classes(file_name, THREAD);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -39,1 +40,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -26,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/stringTable.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/stringTable.hpp\"\n@@ -1370,5 +1370,0 @@\n-  if (LockingMode == LM_LEGACY && java_thread == nullptr) {\n-    *owned_monitor_count_ptr = 0;\n-    return JVMTI_ERROR_NONE;\n-  }\n-\n@@ -1430,5 +1425,0 @@\n-  if (LockingMode == LM_LEGACY && java_thread == nullptr) {\n-    *monitor_info_count_ptr = 0;\n-    return JVMTI_ERROR_NONE;\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"oops\/oopHandle.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -44,1 +43,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -46,0 +44,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -64,1 +63,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n@@ -1841,3 +1839,0 @@\n-  \/\/ return a flag when a method terminates by throwing an exception\n-  \/\/ i.e. if an exception is thrown and it's not caught by the current method\n-  bool exception_exit = state->is_exception_detected() && !state->is_exception_caught();\n@@ -1849,11 +1844,9 @@\n-    \/\/ if the method hasn't been popped because of an exception then we populate\n-    \/\/ the return_value parameter for the callback. At this point we only have\n-    \/\/ the address of a \"raw result\" and we just call into the interpreter to\n-    \/\/ convert this into a jvalue.\n-    if (!exception_exit) {\n-      oop oop_result;\n-      BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n-      if (is_reference_type(type)) {\n-        result = Handle(thread, oop_result);\n-        value.l = JNIHandles::make_local(thread, result());\n-      }\n+    \/\/ At this point we only have the address of a \"raw result\" and\n+    \/\/ we just call into the interpreter to convert this into a jvalue.\n+    oop oop_result;\n+    BasicType type = current_frame.interpreter_frame_result(&oop_result, &value);\n+    assert(type == T_VOID || current_frame.interpreter_frame_expression_stack_size() > 0,\n+           \"Stack shouldn't be empty\");\n+    if (is_reference_type(type)) {\n+      result = Handle(thread, oop_result);\n+      value.l = JNIHandles::make_local(thread, result());\n@@ -1867,3 +1860,1 @@\n-  \/\/ Deferred transition to VM, so we can stash away the return oop before GC\n-  \/\/ Note that this transition is not needed when throwing an exception, because\n-  \/\/ there is no oop to retain.\n+  \/\/ Deferred transition to VM, so we can stash away the return oop before GC.\n@@ -1872,1 +1863,1 @@\n-    post_method_exit_inner(thread, mh, state, exception_exit, current_frame, value);\n+    post_method_exit_inner(thread, mh, state, false \/* not exception exit *\/, current_frame, value);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"runtime\/mutexLocker.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -26,1 +27,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"classfile\/klassFactory.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"classfile\/klassFactory.hpp\"\n@@ -58,1 +58,0 @@\n-#include \"prims\/resolvedMethodTable.hpp\"\n@@ -60,0 +59,1 @@\n+#include \"prims\/resolvedMethodTable.hpp\"\n@@ -257,1 +257,1 @@\n-    if (!MetaspaceShared::remap_shared_readonly_as_readwrite()) {\n+    if (!AOTMetaspace::remap_shared_readonly_as_readwrite()) {\n@@ -1361,1 +1361,3 @@\n-\n+    size_t avail_mem = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -1363,2 +1365,2 @@\n-      (\"loading name=%s kind=%d (avail_mem=\" UINT64_FORMAT \"K)\",\n-       the_class->external_name(), _class_load_kind, os::available_memory() >> 10);\n+      (\"loading name=%s kind=%d (avail_mem=%zuK)\",\n+       the_class->external_name(), _class_load_kind, avail_mem >> 10);\n@@ -1528,1 +1530,2 @@\n-\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -1530,1 +1533,1 @@\n-      (\"loaded name=%s (avail_mem=\" UINT64_FORMAT \"K)\", the_class->external_name(), os::available_memory() >> 10);\n+      (\"loaded name=%s (avail_mem=%zuK)\", the_class->external_name(), avail_mem >> 10);\n@@ -4438,0 +4441,3 @@\n+    size_t avail_mem = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -4439,2 +4445,2 @@\n-      (\"redefined name=%s, count=%d (avail_mem=\" UINT64_FORMAT \"K)\",\n-       the_class->external_name(), java_lang_Class::classRedefinedCount(the_class->java_mirror()), os::available_memory() >> 10);\n+      (\"redefined name=%s, count=%d (avail_mem=%zuK)\",\n+       the_class->external_name(), java_lang_Class::classRedefinedCount(the_class->java_mirror()), avail_mem >> 10);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -64,1 +63,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -66,0 +64,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -67,1 +66,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -69,1 +67,1 @@\n-#include \"utilities\/objectBitSet.inline.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -71,0 +69,1 @@\n+#include \"utilities\/objectBitSet.inline.hpp\"\n@@ -455,1 +454,1 @@\n-  for (InstanceKlass* super_klass = ik->java_super(); super_klass != nullptr; super_klass = super_klass->java_super()) {\n+  for (InstanceKlass* super_klass = ik->super(); super_klass != nullptr; super_klass = super_klass->super()) {\n@@ -482,1 +481,1 @@\n-  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->java_super()) {\n+  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->super()) {\n@@ -487,1 +486,1 @@\n-  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->java_super()) {\n+  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->super()) {\n@@ -2601,4 +2600,4 @@\n-    InstanceKlass* java_super = ik->java_super();\n-    if (java_super != nullptr && java_super != vmClasses::Object_klass()) {\n-      oop super = java_super->java_mirror();\n-      if (!CallbackInvoker::report_superclass_reference(mirror, super)) {\n+    InstanceKlass* super_klass = ik->super();\n+    if (super_klass != nullptr && super_klass != vmClasses::Object_klass()) {\n+      oop super_oop = super_klass->java_mirror();\n+      if (!CallbackInvoker::report_superclass_reference(mirror, super_oop)) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -68,1 +68,1 @@\n-ResizeableResourceHashtable <JvmtiTagMapKey, jlong,\n+ResizeableHashTable <JvmtiTagMapKey, jlong,\n@@ -71,1 +71,1 @@\n-                              JvmtiTagMapKey::equals> ResizableResourceHT;\n+                              JvmtiTagMapKey::equals> ResizableHT;\n@@ -75,1 +75,1 @@\n-  ResizableResourceHT _table;\n+  ResizableHT _table;\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/handles.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiUtil.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -55,1 +55,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -60,0 +59,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/frame.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/frame.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -33,1 +31,1 @@\n-#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -35,0 +33,2 @@\n+#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"prims\/jvmtiAgentList.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -43,1 +43,0 @@\n-#include \"prims\/unsafe.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"prims\/unsafe.hpp\"\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/stackwalk.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -57,0 +56,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-#include <cstdint>\n-\n@@ -34,0 +32,2 @@\n+#include <cstdint>\n+\n","filename":"src\/hotspot\/share\/prims\/vmstorage.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"prims\/whitebox.inline.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"prims\/whitebox.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/wbtestmethods\/parserTests.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -129,1 +129,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -131,0 +130,1 @@\n+#include \"osContainer_linux.hpp\"\n@@ -1887,1 +1887,1 @@\n-WB_ENTRY(jlong, WB_MetaspaceSharedRegionAlignment(JNIEnv* env, jobject wb))\n+WB_ENTRY(jlong, WB_AOTMetaspaceRegionAlignment(JNIEnv* env, jobject wb))\n@@ -1889,1 +1889,1 @@\n-  return (jlong)MetaspaceShared::core_region_alignment();\n+  return (jlong)AOTMetaspace::core_region_alignment();\n@@ -2157,1 +2157,1 @@\n-  return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));\n+  return (jboolean)AOTMetaspace::in_aot_cache(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));\n@@ -2508,2 +2508,2 @@\n-  LINUX_ONLY(return os::Linux::physical_memory();)\n-  return os::physical_memory();\n+  LINUX_ONLY(return static_cast<jlong>(os::Linux::physical_memory());)\n+  return static_cast<jlong>(os::physical_memory());\n@@ -2514,1 +2514,4 @@\n-  return os::available_memory();\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  return static_cast<jlong>(avail_mem);\n@@ -2887,1 +2890,1 @@\n-  {CC\"metaspaceSharedRegionAlignment\", CC\"()J\",       (void*)&WB_MetaspaceSharedRegionAlignment },\n+  {CC\"metaspaceSharedRegionAlignment\", CC\"()J\",       (void*)&WB_AOTMetaspaceRegionAlignment },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -274,0 +274,12 @@\n+      #elif _MSC_VER == 1939\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.9 (VS2022)\"\n+      #elif _MSC_VER == 1940\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.10 (VS2022)\"\n+      #elif _MSC_VER == 1941\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.11 (VS2022)\"\n+      #elif _MSC_VER == 1942\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.12 (VS2022)\"\n+      #elif _MSC_VER == 1943\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.13 (VS2022)\"\n+      #elif _MSC_VER == 1944\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.14 (VS2022)\"\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -570,0 +570,2 @@\n+  { \"PretenureSizeThreshold\",       JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+\n@@ -1520,1 +1522,1 @@\n-      phys_mem = os::physical_memory();\n+      phys_mem = static_cast<julong>(os::physical_memory());\n@@ -1526,1 +1528,1 @@\n-    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)\n+    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(static_cast<julong>(os::physical_memory()), (julong)MaxRAM)\n@@ -1648,1 +1650,2 @@\n-  julong total_memory = os::physical_memory();\n+  size_t phys_mem = os::physical_memory();\n+  julong total_memory = static_cast<julong>(phys_mem);\n@@ -1854,18 +1857,0 @@\n-  if (UseObjectMonitorTable && LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ ObjectMonitorTable requires lightweight locking.\n-    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n-    warning(\"UseObjectMonitorTable requires LM_LIGHTWEIGHT\");\n-  }\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(PPC64) && !defined(RISCV64) && !defined(S390)\n-  if (LockingMode == LM_MONITOR) {\n-    jio_fprintf(defaultStream::error_stream(),\n-                \"LockingMode == 0 (LM_MONITOR) is not fully implemented on this architecture\\n\");\n-    return false;\n-  }\n-#endif\n-  if (VerifyHeavyMonitors && LockingMode != LM_MONITOR) {\n-    jio_fprintf(defaultStream::error_stream(),\n-                \"-XX:+VerifyHeavyMonitors requires LockingMode == 0 (LM_MONITOR)\\n\");\n-    return false;\n-  }\n@@ -2414,1 +2399,1 @@\n-      int maxf = (int)(strtod(tail, &err) * 100);\n+      double dmaxf = strtod(tail, &err);\n@@ -2417,1 +2402,7 @@\n-                    \"Bad max heap free percentage size: %s\\n\",\n+                    \"Bad max heap free ratio: %s\\n\",\n+                    option->optionString);\n+        return JNI_EINVAL;\n+      }\n+      if (dmaxf < 0.0 || dmaxf > 1.0) {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"-Xmaxf value (%s) is outside the allowed range [ 0.0 ... 1.0 ]\\n\",\n@@ -2420,4 +2411,10 @@\n-      } else {\n-        if (FLAG_SET_CMDLINE(MaxHeapFreeRatio, maxf) != JVMFlag::SUCCESS) {\n-            return JNI_EINVAL;\n-        }\n+      }\n+      const uintx umaxf = (uintx)(dmaxf * 100);\n+      if (MinHeapFreeRatio > umaxf) {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"-Xmaxf value (%s) must be greater than or equal to the implicit -Xminf value (%.2f)\\n\",\n+                    tail, MinHeapFreeRatio \/ 100.0f);\n+        return JNI_EINVAL;\n+      }\n+      if (FLAG_SET_CMDLINE(MaxHeapFreeRatio, umaxf) != JVMFlag::SUCCESS) {\n+        return JNI_EINVAL;\n@@ -2428,1 +2425,1 @@\n-      int minf = (int)(strtod(tail, &err) * 100);\n+      double dminf = strtod(tail, &err);\n@@ -2431,1 +2428,1 @@\n-                    \"Bad min heap free percentage size: %s\\n\",\n+                    \"Bad min heap free ratio: %s\\n\",\n@@ -2434,4 +2431,16 @@\n-      } else {\n-        if (FLAG_SET_CMDLINE(MinHeapFreeRatio, minf) != JVMFlag::SUCCESS) {\n-          return JNI_EINVAL;\n-        }\n+      }\n+      if (dminf < 0.0 || dminf > 1.0) {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"-Xminf value (%s) is outside the allowed range [ 0.0 ... 1.0 ]\\n\",\n+                    tail);\n+        return JNI_EINVAL;\n+      }\n+      const uintx uminf = (uintx)(dminf * 100);\n+      if (MaxHeapFreeRatio < uminf) {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"-Xminf value (%s) must be less than or equal to the implicit -Xmaxf value (%.2f)\\n\",\n+                    tail, MaxHeapFreeRatio \/ 100.0f);\n+        return JNI_EINVAL;\n+      }\n+      if (FLAG_SET_CMDLINE(MinHeapFreeRatio, uminf) != JVMFlag::SUCCESS) {\n+        return JNI_EINVAL;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":42,"deletions":33,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"memory\/allStatic.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"memory\/allStatic.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,7 +37,0 @@\n-  } else if (LockingMode == LM_LEGACY) {\n-    markWord mark_word = displaced_header();\n-    if (mark_word.value() != 0) {\n-      \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n-      bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n-      mark_word.print_on(st, print_monitor_info);\n-    }\n@@ -76,17 +69,1 @@\n-  if (LockingMode == LM_LEGACY) {\n-    if (displaced_header().is_neutral()) {\n-      \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-      \/\/ locked so it can't be async deflated until ownership is dropped.\n-      ObjectSynchronizer::inflate_helper(obj);\n-      \/\/ WARNING: We cannot put a check here, because the inflation\n-      \/\/ will not update the displaced header. Once BasicLock is inflated,\n-      \/\/ no one should ever look at its content.\n-    } else {\n-      \/\/ Typically the displaced header will be 0 (recursive stack lock) or\n-      \/\/ unused_mark.  Naively we'd like to assert that the displaced mark\n-      \/\/ value is either 0, neutral, or 3.  But with the advent of the\n-      \/\/ store-before-CAS avoidance in fast_lock\/compiler_lock_object\n-      \/\/ we can find any flavor mark in the displaced mark.\n-    }\n-    dest->set_displaced_header(displaced_header());\n-  } else if (UseObjectMonitorTable) {\n+  if (UseObjectMonitorTable) {\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -38,6 +38,0 @@\n-  \/\/ * For LM_MONITOR\n-  \/\/ Unused.\n-  \/\/ * For LM_LEGACY\n-  \/\/ This is either the actual displaced header from a locked object, or\n-  \/\/ a sentinel zero value indicating a recursive stack-lock.\n-  \/\/ * For LM_LIGHTWEIGHT\n@@ -55,1 +49,0 @@\n-  \/\/ LM_MONITOR\n@@ -58,3 +51,0 @@\n-  \/\/ LM_LEGACY\n-  inline markWord displaced_header() const;\n-  inline void set_displaced_header(markWord header);\n@@ -63,1 +53,0 @@\n-  \/\/ LM_LIGHTWEIGHT\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,6 +29,0 @@\n-#include \"runtime\/objectMonitor.inline.hpp\"\n-\n-inline markWord BasicLock::displaced_header() const {\n-  assert(LockingMode == LM_LEGACY, \"must be\");\n-  return markWord(get_metadata());\n-}\n@@ -36,4 +30,1 @@\n-inline void BasicLock::set_displaced_header(markWord header) {\n-  assert(LockingMode == LM_LEGACY, \"must be\");\n-  Atomic::store(&_metadata, header.value());\n-}\n+#include \"runtime\/objectMonitor.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -149,4 +149,0 @@\n-  if (LockingMode == LM_LEGACY) {\n-    return freeze_unsupported;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"gc\/shared\/barrierSet.hpp\"\n@@ -42,1 +42,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -60,1 +60,0 @@\n-#include \"runtime\/smallRegisterMap.inline.hpp\"\n@@ -62,0 +61,1 @@\n+#include \"runtime\/smallRegisterMap.inline.hpp\"\n@@ -463,0 +463,1 @@\n+  inline void patch_pd_unused(intptr_t* sp);\n@@ -535,5 +536,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    _monitors_in_lockstack = 0;\n-  } else {\n-    _monitors_in_lockstack = _thread->lock_stack().monitor_count();\n-  }\n+  _monitors_in_lockstack = _thread->lock_stack().monitor_count();\n@@ -589,20 +586,0 @@\n-#ifdef ASSERT\n-static bool monitors_on_stack(JavaThread* thread) {\n-  assert_frames_in_continuation_are_safe(thread);\n-  ContinuationEntry* ce = thread->last_continuation();\n-  RegisterMap map(thread,\n-                  RegisterMap::UpdateMap::include,\n-                  RegisterMap::ProcessFrames::skip,\n-                  RegisterMap::WalkContinuation::skip);\n-  map.set_include_argument_oops(false);\n-  for (frame f = thread->last_frame(); Continuation::is_frame_in_continuation(ce, f); f = f.sender(&map)) {\n-    if ((f.is_interpreted_frame() && ContinuationHelper::InterpretedFrame::is_owning_locks(f)) ||\n-        (f.is_compiled_frame() && ContinuationHelper::CompiledFrame::is_owning_locks(map.thread(), &map, f)) ||\n-        (f.is_native_frame() && ContinuationHelper::NativeFrame::is_owning_locks(map.thread(), f))) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-#endif \/\/ ASSERT\n-\n@@ -615,1 +592,0 @@\n-  assert(LockingMode != LM_LEGACY || !monitors_on_stack(_thread), \"unexpected monitors on stack\");\n@@ -786,3 +762,18 @@\n-  intptr_t* from = _cont_stack_top - frame::metadata_words_at_bottom;\n-  intptr_t* to   = chunk_top - frame::metadata_words_at_bottom;\n-  copy_to_chunk(from, to, cont_size() + frame::metadata_words_at_bottom);\n+\n+  int adjust = frame::metadata_words_at_bottom;\n+#if INCLUDE_ASAN && defined(AARCH64)\n+  \/\/ Reading at offset frame::metadata_words_at_bottom from _cont_stack_top\n+  \/\/ will accesss memory at the callee frame, which on preemption cases will\n+  \/\/ be the VM native method being called. The Arm 64-bit ABI doesn't specify\n+  \/\/ a location where the frame record (returnpc+fp) has to be stored within\n+  \/\/ a stack frame, and GCC currently chooses to save it at the top of the\n+  \/\/ frame (lowest address). ASan treats this memory access in the callee as\n+  \/\/ an overflow access to one of the locals stored in that frame. For these\n+  \/\/ preemption cases we don't need to read these words anyways so we avoid it.\n+  if (_preempt) {\n+    adjust = 0;\n+  }\n+#endif\n+  intptr_t* from = _cont_stack_top - adjust;\n+  intptr_t* to   = chunk_top - adjust;\n+  copy_to_chunk(from, to, cont_size() + adjust);\n@@ -819,0 +810,5 @@\n+    \/\/ For stub\/native frames the fp is not used while frozen, and will be constructed\n+    \/\/ again when thawing the frame (see ThawBase::handle_preempted_continuation). We\n+    \/\/ patch it with a special bad address to help with debugging, particularly when\n+    \/\/ inspecting frames and identifying invalid accesses.\n+    patch_pd_unused(chunk_top);\n@@ -1744,2 +1740,2 @@\n-  assert(LockingMode == LM_LEGACY || (current->held_monitor_count() == 0 && current->jni_monitor_count() == 0),\n-         \"Held monitor count should only be used for LM_LEGACY: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n+  assert((current->held_monitor_count() == 0 && current->jni_monitor_count() == 0),\n+         \"Held monitor count should not be used for lightweight locking: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n@@ -2487,1 +2483,1 @@\n-    \/\/ we copied the original fp at the time of freeze which now will have to be fixed.\n+    \/\/ we copied the fp patched during freeze, which will now have to be fixed.\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+  static const bool compiled = false;\n@@ -130,0 +131,2 @@\n+  static const bool compiled = true;\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -78,4 +78,1 @@\n-  \/\/ Ensure that we are only incrementing atomically by using Atomic::cmpxchg\n-  \/\/ to set the value to zero after we obtain the new CPU time difference.\n-  jlong old_value;\n-  jlong fetched_value = Atomic::load(&(instance->_gc_total_cpu_time_diff));\n+  \/\/ Atomically fetch the current _gc_total_cpu_time_diff and reset it to zero.\n@@ -83,4 +80,1 @@\n-  do {\n-    old_value = fetched_value;\n-    fetched_value = Atomic::cmpxchg(&(instance->_gc_total_cpu_time_diff), old_value, new_value);\n-  } while (old_value != fetched_value);\n+  jlong fetched_value = Atomic::xchg(&(instance->_gc_total_cpu_time_diff), new_value);\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"interpreter\/bytecode.hpp\"\n@@ -71,1 +70,0 @@\n-#include \"runtime\/fieldDescriptor.hpp\"\n@@ -94,1 +92,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -96,0 +93,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n@@ -564,1 +562,2 @@\n-    guarantee(expressions != nullptr && expressions->length() > 0, \"must have exception to throw\");\n+    guarantee(expressions != nullptr && expressions->length() == 1, \"should have only exception on stack\");\n+    guarantee(exec_mode != Unpack_exception, \"rethrow_exception set with Unpack_exception\");\n@@ -740,0 +739,1 @@\n+    assert(array->element(0)->rethrow_exception(), \"must be\");\n@@ -847,0 +847,1 @@\n+#ifdef ASSERT\n@@ -871,0 +872,1 @@\n+#endif\n@@ -935,1 +937,0 @@\n-    bool is_top_frame = true;\n@@ -937,3 +938,3 @@\n-    int callee_max_locals = 0;\n-    for (int i = 0; i < cur_array->frames(); i++) {\n-      vframeArrayElement* el = cur_array->element(i);\n+    for (int frame_idx = 0; frame_idx < cur_array->frames(); frame_idx++) {\n+      bool is_top_frame = (frame_idx == 0);\n+      vframeArrayElement* el = cur_array->element(frame_idx);\n@@ -942,0 +943,2 @@\n+      methodHandle mh(thread, iframe->interpreter_frame_method());\n+      bool reexecute = el->should_reexecute();\n@@ -943,2 +946,0 @@\n-      \/\/ Get the oop map for this bci\n-      InterpreterOopMap mask;\n@@ -946,2 +947,0 @@\n-      bool try_next_mask = false;\n-      int next_mask_expression_stack_size = -1;\n@@ -949,3 +948,0 @@\n-      methodHandle mh(thread, iframe->interpreter_frame_method());\n-      OopMapCache::compute_one_oop_map(mh, iframe->interpreter_frame_bci(), &mask);\n-      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n@@ -953,1 +949,1 @@\n-      \/\/ Get to the next bytecode if possible\n+      BytecodeStream str(mh, iframe->interpreter_frame_bci());\n@@ -955,0 +951,32 @@\n+      Bytecodes::Code cur_code = str.next();\n+\n+      if (!reexecute && !Bytecodes::is_invoke(cur_code)) {\n+        \/\/ We can only compute OopMaps for the before state, so we need to roll forward\n+        \/\/ to the next bytecode.\n+        assert(is_top_frame, \"must be\");\n+        assert(falls_through(cur_code), \"must be\");\n+        assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+        assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+        \/\/ Need to subtract off the size of the result type of\n+        \/\/ the bytecode because this is not described in the\n+        \/\/ debug info but returned to the interpreter in the TOS\n+        \/\/ caching register\n+        BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n+        if (bytecode_result_type != T_ILLEGAL) {\n+          top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n+        }\n+        assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n+\n+        cur_code = str.next();\n+        \/\/ Reflect the fact that we have rolled forward and now need\n+        \/\/ top_frame_expression_stack_adjustment\n+        reexecute = true;\n+      }\n+\n+      assert(cur_code != Bytecodes::_illegal, \"illegal bytecode\");\n+      assert(str.bci() < max_bci, \"bci in interpreter frame out of bounds\");\n+\n+      \/\/ Get the oop map for this bci\n+      InterpreterOopMap mask;\n+      OopMapCache::compute_one_oop_map(mh, str.bci(), &mask);\n@@ -958,2 +986,0 @@\n-      Bytecodes::Code cur_code = str.next();\n-      Bytecodes::Code next_code = Bytecodes::_shouldnotreachhere;\n@@ -961,1 +987,1 @@\n-        Bytecode_invoke invoke(mh, iframe->interpreter_frame_bci());\n+        Bytecode_invoke invoke(mh, str.bci());\n@@ -963,1 +989,1 @@\n-        if (i != 0 && invoke.has_member_arg()) {\n+        if (!is_top_frame && invoke.has_member_arg()) {\n@@ -967,30 +993,0 @@\n-      if (str.bci() < max_bci) {\n-        next_code = str.next();\n-        if (next_code >= 0) {\n-          \/\/ The interpreter oop map generator reports results before\n-          \/\/ the current bytecode has executed except in the case of\n-          \/\/ calls. It seems to be hard to tell whether the compiler\n-          \/\/ has emitted debug information matching the \"state before\"\n-          \/\/ a given bytecode or the state after, so we try both\n-          if (!Bytecodes::is_invoke(cur_code) && falls_through(cur_code)) {\n-            \/\/ Get expression stack size for the next bytecode\n-            InterpreterOopMap next_mask;\n-            OopMapCache::compute_one_oop_map(mh, str.bci(), &next_mask);\n-            next_mask_expression_stack_size = next_mask.expression_stack_size();\n-            if (Bytecodes::is_invoke(next_code)) {\n-              Bytecode_invoke invoke(mh, str.bci());\n-              next_mask_expression_stack_size += invoke.size_of_parameters();\n-            }\n-            \/\/ Need to subtract off the size of the result type of\n-            \/\/ the bytecode because this is not described in the\n-            \/\/ debug info but returned to the interpreter in the TOS\n-            \/\/ caching register\n-            BasicType bytecode_result_type = Bytecodes::result_type(cur_code);\n-            if (bytecode_result_type != T_ILLEGAL) {\n-              top_frame_expression_stack_adjustment = type2size[bytecode_result_type];\n-            }\n-            assert(top_frame_expression_stack_adjustment >= 0, \"stack adjustment must be positive\");\n-            try_next_mask = true;\n-          }\n-        }\n-      }\n@@ -999,38 +995,10 @@\n-      \/\/ This assertion may be dependent on the platform we're running on and may need modification (tested on x86 and sparc)\n-      if (!(\n-            \/* SPARC *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_size_of_parameters) ||\n-            \/* x86 *\/\n-            (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_max_locals) ||\n-            (try_next_mask &&\n-             (iframe->interpreter_frame_expression_stack_size() == (next_mask_expression_stack_size -\n-                                                                    top_frame_expression_stack_adjustment))) ||\n-            (is_top_frame && (exec_mode == Unpack_exception) && iframe->interpreter_frame_expression_stack_size() == 0) ||\n-            (is_top_frame && (exec_mode == Unpack_uncommon_trap || exec_mode == Unpack_reexecute || el->should_reexecute()) &&\n-             (iframe->interpreter_frame_expression_stack_size() == mask.expression_stack_size() + cur_invoke_parameter_size))\n-            )) {\n-        {\n-          \/\/ Print out some information that will help us debug the problem\n-          tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n-          tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", i, cur_array->frames() - 1);\n-          tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n-          if (try_next_mask) {\n-            tty->print_cr(\"  Next code %s\", Bytecodes::name(next_code));\n-          }\n-          tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n-                        iframe->interpreter_frame_expression_stack_size());\n-          tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n-          tty->print_cr(\"  try_next_mask = %d\", try_next_mask);\n-          tty->print_cr(\"  next_mask_expression_stack_size = %d\", next_mask_expression_stack_size);\n-          tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n-          tty->print_cr(\"  callee_max_locals = %d\", callee_max_locals);\n-          tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n-          tty->print_cr(\"  exec_mode = %d\", exec_mode);\n-          tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n-          tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n-          tty->print_cr(\"  Interpreted frames:\");\n-          for (int k = 0; k < cur_array->frames(); k++) {\n-            vframeArrayElement* el = cur_array->element(k);\n-            tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n-          }\n-          cur_array->print_on_2(tty);\n+      auto match = [&]() {\n+        int iframe_expr_ssize = iframe->interpreter_frame_expression_stack_size();\n+#if INCLUDE_JVMCI\n+        if (is_top_frame && el->rethrow_exception()) {\n+          return iframe_expr_ssize == 1;\n+        }\n+#endif\n+        \/\/ This should only be needed for C1\n+        if (is_top_frame && exec_mode == Unpack_exception && iframe_expr_ssize == 0) {\n+          return true;\n@@ -1038,0 +1006,34 @@\n+        if (reexecute) {\n+          int expr_ssize_before = iframe_expr_ssize + top_frame_expression_stack_adjustment;\n+          int oopmap_expr_invoke_ssize = mask.expression_stack_size() + cur_invoke_parameter_size;\n+          return expr_ssize_before == oopmap_expr_invoke_ssize;\n+        } else {\n+          int oopmap_expr_callee_ssize = mask.expression_stack_size() + callee_size_of_parameters;\n+          return iframe_expr_ssize == oopmap_expr_callee_ssize;\n+        }\n+      };\n+      if (!match()) {\n+        \/\/ Print out some information that will help us debug the problem\n+        tty->print_cr(\"Wrong number of expression stack elements during deoptimization\");\n+        tty->print_cr(\"  Error occurred while verifying frame %d (0..%d, 0 is topmost)\", frame_idx, cur_array->frames() - 1);\n+        tty->print_cr(\"  Current code %s\", Bytecodes::name(cur_code));\n+        tty->print_cr(\"  Fabricated interpreter frame had %d expression stack elements\",\n+                      iframe->interpreter_frame_expression_stack_size());\n+        tty->print_cr(\"  Interpreter oop map had %d expression stack elements\", mask.expression_stack_size());\n+        tty->print_cr(\"  callee_size_of_parameters = %d\", callee_size_of_parameters);\n+        tty->print_cr(\"  top_frame_expression_stack_adjustment = %d\", top_frame_expression_stack_adjustment);\n+        tty->print_cr(\"  exec_mode = %d\", exec_mode);\n+        tty->print_cr(\"  original should_reexecute = %s\", el->should_reexecute() ? \"true\" : \"false\");\n+        tty->print_cr(\"  reexecute = %s%s\", reexecute ? \"true\" : \"false\",\n+                      (reexecute != el->should_reexecute()) ? \" (changed)\" : \"\");\n+#if INCLUDE_JVMCI\n+        tty->print_cr(\"  rethrow_exception = %s\", el->rethrow_exception() ? \"true\" : \"false\");\n+#endif\n+        tty->print_cr(\"  cur_invoke_parameter_size = %d\", cur_invoke_parameter_size);\n+        tty->print_cr(\"  Thread = \" INTPTR_FORMAT \", thread ID = %d\", p2i(thread), thread->osthread()->thread_id());\n+        tty->print_cr(\"  Interpreted frames:\");\n+        for (int k = 0; k < cur_array->frames(); k++) {\n+          vframeArrayElement* el = cur_array->element(k);\n+          tty->print_cr(\"    %s (bci %d)\", el->method()->name_and_sig_as_C_string(), el->bci());\n+        }\n+        cur_array->print_on_2(tty);\n@@ -1043,2 +1045,0 @@\n-      callee_max_locals = mh->max_locals();\n-      is_top_frame = false;\n@@ -1477,1 +1477,1 @@\n-  InstanceKlass* super = klass->superklass();\n+  InstanceKlass* super = klass->super();\n@@ -1648,7 +1648,0 @@\n-          if (LockingMode == LM_LEGACY && mark.has_locker() && fr.sp() > (intptr_t*)mark.locker()) {\n-            \/\/ With exec_mode == Unpack_none obj may be thread local and locked in\n-            \/\/ a callee frame. Make the lock in the callee a recursive lock and restore the displaced header.\n-            markWord dmw = mark.displaced_mark_helper();\n-            mark.locker()->set_displaced_header(markWord::encode((BasicLock*) nullptr));\n-            obj->set_mark(dmw);\n-          }\n@@ -1660,3 +1653,1 @@\n-              if (LockingMode == LM_LEGACY) {\n-                mon_info->lock()->set_displaced_header(markWord::unused_mark());\n-              } else if (UseObjectMonitorTable) {\n+              if (UseObjectMonitorTable) {\n@@ -1667,1 +1658,1 @@\n-                assert(LockingMode == LM_MONITOR || !UseObjectMonitorTable, \"must be\");\n+                assert(!UseObjectMonitorTable, \"must be\");\n@@ -1677,12 +1668,11 @@\n-        if (LockingMode == LM_LIGHTWEIGHT) {\n-          \/\/ We have lost information about the correct state of the lock stack.\n-          \/\/ Entering may create an invalid lock stack. Inflate the lock if it\n-          \/\/ was fast_locked to restore the valid lock stack.\n-          if (UseObjectMonitorTable) {\n-            \/\/ UseObjectMonitorTable expects the BasicLock cache to be either a\n-            \/\/ valid ObjectMonitor* or nullptr. Right now it is garbage, set it\n-            \/\/ to nullptr.\n-            lock->clear_object_monitor_cache();\n-          }\n-          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n-          if (deoptee_thread->lock_stack().contains(obj())) {\n+        \/\/ We have lost information about the correct state of the lock stack.\n+        \/\/ Entering may create an invalid lock stack. Inflate the lock if it\n+        \/\/ was fast_locked to restore the valid lock stack.\n+        if (UseObjectMonitorTable) {\n+          \/\/ UseObjectMonitorTable expects the BasicLock cache to be either a\n+          \/\/ valid ObjectMonitor* or nullptr. Right now it is garbage, set it\n+          \/\/ to nullptr.\n+          lock->clear_object_monitor_cache();\n+        }\n+        ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n+        if (deoptee_thread->lock_stack().contains(obj())) {\n@@ -1690,9 +1680,1 @@\n-                                                                deoptee_thread, thread);\n-          }\n-          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n-          assert(obj->mark().has_monitor(), \"must be\");\n-          assert(!deoptee_thread->lock_stack().contains(obj()), \"must be\");\n-          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->has_owner(deoptee_thread), \"must be\");\n-        } else {\n-          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n-          assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+                                                              deoptee_thread, thread);\n@@ -1700,0 +1682,4 @@\n+        assert(mon_info->owner()->is_locked(), \"object must be locked now\");\n+        assert(obj->mark().has_monitor(), \"must be\");\n+        assert(!deoptee_thread->lock_stack().contains(obj()), \"must be\");\n+        assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->has_owner(deoptee_thread), \"must be\");\n@@ -2927,2 +2913,0 @@\n-            if (bc_case == BC_CASE_LIMIT && (int)bc == 0)\n-              bc = Bytecodes::_illegal;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":109,"deletions":125,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"oops\/fieldStreams.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -32,0 +32,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"oops\/metadata.hpp\"\n-#include \"runtime\/os.hpp\"\n@@ -31,0 +29,1 @@\n+#include \"oops\/metadata.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -139,0 +139,10 @@\n+JVMFlag::Error LargePageSizeInBytesConstraintFunc(size_t value, bool verbose) {\n+  if (!is_power_of_2(value)) {\n+    JVMFlag::printError(verbose, \"LargePageSizeInBytes ( %zu ) must be \"\n+                        \"a power of 2\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  f(size_t, LargePageSizeInBytesConstraintFunc)       \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -27,0 +26,2 @@\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -33,2 +34,0 @@\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLookup.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n@@ -55,0 +54,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"oops\/stackChunkOop.inline.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"oops\/stackChunkOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,1 +240,2 @@\n-          \"page size for the environment as the maximum)\")                  \\\n+          \"page size for the environment as the maximum) \"                  \\\n+          \"(must be a power of 2)\")                                         \\\n@@ -242,0 +243,1 @@\n+          constraint(LargePageSizeInBytesConstraintFunc, AtParse)           \\\n@@ -486,0 +488,3 @@\n+  develop(bool, ZapCHeap, trueInDebug,                                      \\\n+          \"Zap allocated\/freed C heap space\")                               \\\n+                                                                            \\\n@@ -1046,4 +1051,0 @@\n-  develop(bool, VerifyHeavyMonitors, false,                                 \\\n-          \"Checks that no stack locking happens when using \"                \\\n-          \"-XX:LockingMode=0 (LM_MONITOR)\")                                 \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/javaThread.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"utilities\/formatBuffer.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -205,1 +205,1 @@\n-    VMError::set_handshake_timed_out_thread(p2i(target));\n+    VMError::set_handshake_timed_out_thread(target);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,4 +198,1 @@\n-  \/\/ Initialize TrainingData only we're recording\/replaying\n-  if (TrainingData::have_data() || TrainingData::need_data()) {\n-   TrainingData::initialize();\n-  }\n+  TrainingData::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -78,0 +80,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -80,1 +83,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -451,1 +453,1 @@\n-    MetaspaceShared::preload_and_dump(thread);\n+    AOTMetaspace::preload_and_dump(thread);\n@@ -478,13 +480,1 @@\n-  Universe::heap()->before_exit();\n-\n-  \/\/ Print GC\/heap related information.\n-  Log(gc, exit) log;\n-  if (log.is_info()) {\n-    LogStream ls_info(log.info());\n-    Universe::print_on(&ls_info);\n-    if (log.is_trace()) {\n-      LogStream ls_trace(log.trace());\n-      MutexLocker mcld(ClassLoaderDataGraph_lock);\n-      ClassLoaderDataGraph::print_on(&ls_trace);\n-    }\n-  }\n+  Universe::before_exit();\n@@ -518,0 +508,6 @@\n+  #if INCLUDE_CDS\n+  if (AOTVerifyTrainingData) {\n+    TrainingData::verify();\n+  }\n+  #endif\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-              entry_point = method->adapter()->get_i2c_entry();\n+              entry_point = method->get_i2c_entry();\n@@ -556,1 +556,1 @@\n-      guarantee(oopDesc::is_oop_or_null(vv, true),\n+      guarantee(oopDesc::is_oop_or_null(vv),\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"compiler\/compileTask.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -91,1 +91,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -93,1 +92,1 @@\n-#include \"runtime\/vmThread.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n@@ -95,0 +94,1 @@\n+#include \"runtime\/vmThread.hpp\"\n@@ -1066,5 +1066,0 @@\n-bool JavaThread::is_lock_owned(address adr) const {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"should not be called with new lightweight locking\");\n-  return is_in_full_stack(adr);\n-}\n-\n@@ -1143,1 +1138,1 @@\n-                         InstanceKlass::cast(exception->klass())->external_name());\n+                         exception->klass()->external_name());\n@@ -1440,3 +1435,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lock_stack().oops_do(f);\n-  }\n+  \/\/ Due to lightweight locking\n+  lock_stack().oops_do(f);\n@@ -2002,16 +1996,3 @@\n-\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Nothing to do. Just do some sanity check.\n-    assert(_held_monitor_count == 0, \"counter should not be used\");\n-    assert(_jni_monitor_count == 0, \"counter should not be used\");\n-    return;\n-  }\n-\n-  assert(_held_monitor_count >= 0, \"Must always be non-negative: %zd\", _held_monitor_count);\n-  _held_monitor_count += i;\n-  if (jni) {\n-    assert(_jni_monitor_count >= 0, \"Must always be non-negative: %zd\", _jni_monitor_count);\n-    _jni_monitor_count += i;\n-  }\n-  assert(_held_monitor_count >= _jni_monitor_count, \"Monitor count discrepancy detected - held count \"\n-         \"%zd is less than JNI count %zd\", _held_monitor_count, _jni_monitor_count);\n+  \/\/ Nothing to do. Just do some sanity check.\n+  assert(_held_monitor_count == 0, \"counter should not be used\");\n+  assert(_jni_monitor_count == 0, \"counter should not be used\");\n@@ -2025,20 +2006,3 @@\n-\n-  if (LockingMode != LM_LEGACY) {\n-    \/\/ Nothing to do. Just do some sanity check.\n-    assert(_held_monitor_count == 0, \"counter should not be used\");\n-    assert(_jni_monitor_count == 0, \"counter should not be used\");\n-    return;\n-  }\n-\n-  _held_monitor_count -= i;\n-  assert(_held_monitor_count >= 0, \"Must always be non-negative: %zd\", _held_monitor_count);\n-  if (jni) {\n-    _jni_monitor_count -= i;\n-    assert(_jni_monitor_count >= 0, \"Must always be non-negative: %zd\", _jni_monitor_count);\n-  }\n-  \/\/ When a thread is detaching with still owned JNI monitors, the logic that releases\n-  \/\/ the monitors doesn't know to set the \"jni\" flag and so the counts can get out of sync.\n-  \/\/ So we skip this assert if the thread is exiting. Once all monitors are unlocked the\n-  \/\/ JNI count is directly set to zero.\n-  assert(_held_monitor_count >= _jni_monitor_count || is_exiting(), \"Monitor count discrepancy detected - held count \"\n-         \"%zd is less than JNI count %zd\", _held_monitor_count, _jni_monitor_count);\n+  \/\/ Nothing to do. Just do some sanity check.\n+  assert(_held_monitor_count == 0, \"counter should not be used\");\n+  assert(_jni_monitor_count == 0, \"counter should not be used\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":12,"deletions":48,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -43,0 +42,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -758,3 +758,0 @@\n-  \/\/ Stack-locking support (not for LM_LIGHTWEIGHT)\n-  bool is_lock_owned(address adr) const;\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"runtime\/keepStackGCProcessed.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,2 +336,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-\n@@ -631,1 +629,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -660,1 +657,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -721,1 +717,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -773,10 +768,7 @@\n-\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to to get an inflated\n-\/\/ ObjectMonitor* with LM_LIGHTWEIGHT. It is used from contexts which require\n-\/\/ an inflated ObjectMonitor* for a monitor, and expects to throw a\n-\/\/ java.lang.IllegalMonitorStateException if it is not held by the current\n-\/\/ thread. Such as notify\/wait and jni_exit. LM_LIGHTWEIGHT keeps it invariant\n-\/\/ that it only inflates if it is already locked by the current thread or the\n-\/\/ current thread is in the process of entering. To maintain this invariant we\n-\/\/ need to throw a java.lang.IllegalMonitorStateException before inflating if\n-\/\/ the current thread is not the owner.\n-\/\/ LightweightSynchronizer::inflate_locked_or_imse facilitates this.\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to get an\n+\/\/ inflated ObjectMonitor* from contexts which require that, such as\n+\/\/ notify\/wait and jni_exit. Lightweight locking keeps the invariant that it\n+\/\/ only inflates if it is already locked by the current thread or the current\n+\/\/ thread is in the process of entering. To maintain this invariant we need to\n+\/\/ throw a java.lang.IllegalMonitorStateException before inflating if the\n+\/\/ current thread is not the owner.\n@@ -784,1 +776,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n@@ -829,4 +820,3 @@\n-  \/\/ The JavaThread* locking_thread parameter is only used by LM_LIGHTWEIGHT and requires\n-  \/\/ that the locking_thread == Thread::current() or is suspended throughout the call by\n-  \/\/ some other mechanism.\n-  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ The JavaThread* locking parameter requires that the locking_thread == JavaThread::current,\n+  \/\/ or is suspended throughout the call by some other mechanism.\n+  \/\/ Even with lightweight locking the thread might be nullptr when called from a non\n@@ -834,1 +824,1 @@\n-  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ important for the correctness of the lightweight locking algorithm that the thread\n@@ -946,1 +936,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n@@ -1003,1 +992,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":11,"deletions":23,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"never use lock-stack when light weight locking is disabled\");\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-  MUTEX_DEFL(TrainingData_lock               , PaddedMutex  , MethodCompileQueue_lock);\n+  MUTEX_DEFN(TrainingData_lock               , PaddedMutex  , nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n@@ -300,2 +299,1 @@\n-  _wait_set_lock(0),\n-  _stack_locker(nullptr)\n+  _wait_set_lock(0)\n@@ -714,0 +712,1 @@\n+  assert(node->TState == ObjectWaiter::TS_RUN, \"\");\n@@ -729,0 +728,1 @@\n+      node->TState = ObjectWaiter::TS_RUN;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -163,3 +163,3 @@\n-  \/\/ * LM_LIGHTWEIGHT with UseObjectMonitorTable:\n-  \/\/ Contains the _object's hashCode.\n-  \/\/ * LM_LEGACY, LM_MONITOR, LM_LIGHTWEIGHT without UseObjectMonitorTable:\n+  \/\/ * Lightweight locking with UseObjectMonitorTable:\n+  \/\/   Contains the _object's hashCode.\n+  \/\/ * * Lightweight locking without UseObjectMonitorTable:\n@@ -207,3 +207,0 @@\n-  \/\/ Used in LM_LEGACY mode to store BasicLock* in case of inflation by contending thread.\n-  BasicLock* volatile _stack_locker;\n-\n@@ -321,4 +318,0 @@\n-  \/\/ Get and set _stack_locker.\n-  BasicLock* stack_locker() const;\n-  void set_stack_locker(BasicLock* locker);\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -55,5 +55,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      return current->lock_stack().contains(object());\n-    } else {\n-      return current->is_lock_owned((address)stack_locker());\n-    }\n+    return current->lock_stack().contains(object());\n@@ -119,8 +115,0 @@\n-inline BasicLock* ObjectMonitor::stack_locker() const {\n-  return Atomic::load(&_stack_locker);\n-}\n-\n-inline void ObjectMonitor::set_stack_locker(BasicLock* locker) {\n-  Atomic::store(&_stack_locker, locker);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -70,0 +69,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -92,1 +92,0 @@\n-# include <signal.h>\n@@ -94,0 +93,1 @@\n+# include <signal.h>\n@@ -111,1 +111,1 @@\n-int os::snprintf_checked(char* buf, size_t len, const char* fmt, ...) {\n+void os::snprintf_checked(char* buf, size_t len, const char* fmt, ...) {\n@@ -116,1 +116,0 @@\n-  assert(result >= 0, \"os::snprintf error\");\n@@ -118,1 +117,0 @@\n-  return result;\n@@ -122,0 +120,2 @@\n+  assert(buf != nullptr || len == 0, \"Valid buffer and length must be given\");\n+  assert(fmt != nullptr, \"Missing format string\");\n@@ -123,1 +123,1 @@\n-  \/\/ If an encoding error occurred (result < 0) then it's not clear\n+  \/\/ If an error occurred (result < 0) then it's not clear\n@@ -125,1 +125,1 @@\n-  if ((result < 0) && (len > 0)) {\n+  if ((result < 0) && (len > 0) && (buf != nullptr)) {\n@@ -128,0 +128,1 @@\n+  assert(result >= 0, \"os::vsnprintf error: %s\", strerror(errno));\n@@ -461,1 +462,1 @@\n-            InstanceKlass::cast(PENDING_EXCEPTION->klass())->\n+            PENDING_EXCEPTION->klass()->\n@@ -669,2 +670,2 @@\n-  } else {\n-    DEBUG_ONLY(::memset(inner_ptr, uninitBlockPad, size);)\n+  } else if (ZapCHeap) {\n+    ::memset(inner_ptr, uninitBlockPad, size);\n@@ -743,1 +744,1 @@\n-    if (old_size < size) {\n+    if (ZapCHeap && old_size < size) {\n@@ -1186,1 +1187,2 @@\n-  size_t mem = physical_memory()\/G;\n+  size_t phys_mem = physical_memory();\n+  size_t mem = phys_mem\/G;\n@@ -1188,1 +1190,1 @@\n-    mem = physical_memory()\/M;\n+    mem = phys_mem\/M;\n@@ -1943,1 +1945,1 @@\n-\n+  size_t phys_mem = os::physical_memory();\n@@ -1946,1 +1948,1 @@\n-      (os::physical_memory() >= (server_memory - missing_memory))) {\n+      (phys_mem >= (server_memory - missing_memory))) {\n@@ -2205,1 +2207,1 @@\n-julong os::used_memory() {\n+bool os::used_memory(size_t& value) {\n@@ -2210,1 +2212,4 @@\n-      return mem_usage;\n+      value = static_cast<size_t>(mem_usage);\n+      return true;\n+    } else {\n+      return false;\n@@ -2214,1 +2219,6 @@\n-  return os::physical_memory() - os::available_memory();\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  size_t phys_mem = os::physical_memory();\n+  value = phys_mem - avail_mem;\n+  return true;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -335,3 +335,3 @@\n-  static julong available_memory();\n-  static julong used_memory();\n-  static julong free_memory();\n+  [[nodiscard]] static bool available_memory(size_t& value);\n+  [[nodiscard]] static bool used_memory(size_t& value);\n+  [[nodiscard]] static bool free_memory(size_t& value);\n@@ -339,2 +339,2 @@\n-  static jlong total_swap_space();\n-  static jlong free_swap_space();\n+  [[nodiscard]] static bool total_swap_space(size_t& value);\n+  [[nodiscard]] static bool free_swap_space(size_t& value);\n@@ -342,1 +342,1 @@\n-  static julong physical_memory();\n+  static size_t physical_memory();\n@@ -807,2 +807,0 @@\n-  static int vsnprintf(char* buf, size_t len, const char* fmt, va_list args) ATTRIBUTE_PRINTF(3, 0);\n-  static int snprintf(char* buf, size_t len, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);\n@@ -810,3 +808,13 @@\n-  \/\/ Performs snprintf and asserts the result is non-negative (so there was not\n-  \/\/ an encoding error) and that the output was not truncated.\n-  static int snprintf_checked(char* buf, size_t len, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);\n+  \/\/ Performs vsnprintf and asserts the result is non-negative (so there was not\n+  \/\/ an encoding error or any other kind of usage error).\n+  [[nodiscard]]\n+  ATTRIBUTE_PRINTF(3, 0)\n+  static int vsnprintf(char* buf, size_t len, const char* fmt, va_list args);\n+  \/\/ Delegates to vsnprintf.\n+  [[nodiscard]]\n+  ATTRIBUTE_PRINTF(3, 4)\n+  static int snprintf(char* buf, size_t len, const char* fmt, ...);\n+\n+  \/\/ Delegates to snprintf and asserts that the output was not truncated.\n+  ATTRIBUTE_PRINTF(3, 4)\n+  static void snprintf_checked(char* buf, size_t len, const char* fmt, ...);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-        VMError::set_safepoint_timed_out_thread(p2i(cur_thread));\n+        VMError::set_safepoint_timed_out_thread(cur_thread);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"jvm.h\"\n@@ -47,0 +46,1 @@\n+#include \"jvm.h\"\n@@ -83,1 +83,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -2453,1 +2453,1 @@\n-using AdapterHandlerTable = ResourceHashtable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n+using AdapterHandlerTable = HashTable<AdapterFingerPrint*, AdapterHandlerEntry*, 293,\n@@ -2513,1 +2513,0 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = nullptr;\n@@ -2549,15 +2548,0 @@\n-void AdapterHandlerLibrary::create_abstract_method_handler() {\n-  assert_lock_strong(AdapterHandlerLibrary_lock);\n-  \/\/ Create a special handler for abstract methods.  Abstract methods\n-  \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n-  \/\/ throw AbstractMethodError just in case.\n-  \/\/ Pass wrong_method_abstract for the c2i transitions to return\n-  \/\/ AbstractMethodError for invalid invocations.\n-  address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n-  _abstract_method_handler = AdapterHandlerLibrary::new_entry(AdapterFingerPrint::allocate(0, nullptr));\n-  _abstract_method_handler->set_entry_points(SharedRuntime::throw_AbstractMethodError_entry(),\n-                                             wrong_method_abstract,\n-                                             wrong_method_abstract,\n-                                             nullptr);\n-}\n-\n@@ -2567,1 +2551,0 @@\n-    MutexLocker mu(AdapterHandlerLibrary_lock);\n@@ -2570,1 +2553,0 @@\n-    create_abstract_method_handler();\n@@ -2605,5 +2587,7 @@\n-    assert(no_arg_blob != nullptr &&\n-           obj_arg_blob != nullptr &&\n-           int_arg_blob != nullptr &&\n-           obj_int_arg_blob != nullptr &&\n-           obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n+    \/\/ we should always get an entry back but we don't have any\n+    \/\/ associated blob on Zero\n+    assert(_no_arg_handler != nullptr &&\n+           _obj_arg_handler != nullptr &&\n+           _int_arg_handler != nullptr &&\n+           _obj_int_arg_handler != nullptr &&\n+           _obj_obj_arg_handler != nullptr, \"Initial adapter handlers must be properly created\");\n@@ -2613,0 +2597,2 @@\n+#ifndef ZERO\n+  \/\/ no blobs to register when we are on Zero\n@@ -2618,0 +2604,1 @@\n+#endif \/\/ ZERO\n@@ -2625,3 +2612,0 @@\n-  if (method->is_abstract()) {\n-    return _abstract_method_handler;\n-  }\n@@ -2712,0 +2696,2 @@\n+  \/\/ we can only check for the same code if there is any\n+#ifndef ZERO\n@@ -2718,0 +2704,1 @@\n+# endif \/\/ ZERO\n@@ -2722,0 +2709,1 @@\n+  assert(!method->is_abstract(), \"abstract methods do not have adapters\");\n@@ -2752,1 +2740,1 @@\n-      if (!entry->is_shared() && VerifyAdapterSharing) {\n+      if (!entry->in_aot_cache() && VerifyAdapterSharing) {\n@@ -2781,1 +2769,6 @@\n-    handler->set_entry_points(i2c_entry, i2c_entry + offsets[1], i2c_entry + offsets[2], i2c_entry + offsets[3]);\n+    handler->set_entry_points(\n+      i2c_entry,\n+      (offsets[1] != -1) ? (i2c_entry + offsets[1]) : nullptr,\n+      (offsets[2] != -1) ? (i2c_entry + offsets[2]) : nullptr,\n+      (offsets[3] != -1) ? (i2c_entry + offsets[3]) : nullptr\n+    );\n@@ -2790,1 +2783,2 @@\n-  int insts_size = adapter_blob->code_size();\n+  int insts_size;\n+  \/\/ on Zero the blob may be null\n@@ -2792,0 +2786,4 @@\n+  if (adapter_blob == nullptr) {\n+    return;\n+  }\n+  insts_size = adapter_blob->code_size();\n@@ -2832,0 +2830,5 @@\n+#ifdef ZERO\n+  \/\/ On zero there is no code to save and no need to create a blob and\n+  \/\/ or relocate the handler.\n+  adapter_blob = nullptr;\n+#else\n@@ -2845,3 +2848,6 @@\n-  entry_offset[1] = handler->get_c2i_entry() - i2c_entry;\n-  entry_offset[2] = handler->get_c2i_unverified_entry() - i2c_entry;\n-  entry_offset[3] = handler->get_c2i_no_clinit_check_entry() - i2c_entry;\n+  entry_offset[1] = (handler->get_c2i_entry() != nullptr) ?\n+                    (handler->get_c2i_entry() - i2c_entry) : -1;\n+  entry_offset[2] = (handler->get_c2i_unverified_entry() != nullptr) ?\n+                    (handler->get_c2i_unverified_entry() - i2c_entry) : -1;\n+  entry_offset[3] = (handler->get_c2i_no_clinit_check_entry() != nullptr) ?\n+                    (handler->get_c2i_no_clinit_check_entry() - i2c_entry) : -1;\n@@ -2864,0 +2870,2 @@\n+#endif \/\/ ZERO\n+\n@@ -2870,0 +2878,1 @@\n+\n@@ -3342,12 +3351,1 @@\n-      if (LockingMode == LM_LEGACY) {\n-        \/\/ Inflate so the object's header no longer refers to the BasicLock.\n-        if (lock->displaced_header().is_unlocked()) {\n-          \/\/ The object is locked and the resulting ObjectMonitor* will also be\n-          \/\/ locked so it can't be async deflated until ownership is dropped.\n-          \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n-          ObjectSynchronizer::inflate_helper(kptr2->obj());\n-        }\n-        \/\/ Now the displaced header is free to move because the\n-        \/\/ object's header no longer refers to it.\n-        buf[i] = (intptr_t)lock->displaced_header().value();\n-      } else if (UseObjectMonitorTable) {\n+      if (UseObjectMonitorTable) {\n@@ -3471,7 +3469,0 @@\n-bool AdapterHandlerLibrary::is_abstract_method_adapter(AdapterHandlerEntry* entry) {\n-  if (entry == _abstract_method_handler) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":45,"deletions":54,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -786,1 +786,0 @@\n-  static AdapterHandlerEntry* _abstract_method_handler;\n@@ -804,1 +803,0 @@\n-  static void create_abstract_method_handler();\n@@ -834,2 +832,0 @@\n-  static bool is_abstract_method_adapter(AdapterHandlerEntry* adapter);\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -171,8 +171,0 @@\n-  if (code_size == 0) {\n-    LogTarget(Info, stubs) lt;\n-    if (lt.is_enabled()) {\n-      LogStream ls(lt);\n-      ls.print_cr(\"%s\\t not generated\", buffer_name);\n-    }\n-    return nullptr;\n-  }\n@@ -199,0 +191,9 @@\n+  if (code_size == 0) {\n+    assert(buffer.insts_size() == 0, \"should not write into buffer when bob size declared as 0\");\n+    LogTarget(Info, stubs) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print_cr(\"%s\\t not generated\", buffer_name);\n+    }\n+    return nullptr;\n+  }\n@@ -201,1 +202,1 @@\n-  assert(code_size == 0 || buffer.insts_remaining() > 200,\n+  assert(buffer.insts_remaining() > 200,\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n@@ -285,3 +284,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    LightweightSynchronizer::initialize();\n-  }\n+  LightweightSynchronizer::initialize();\n@@ -346,12 +343,4 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if (mark.is_fast_locked() && current->lock_stack().contains(cast_to_oop(obj))) {\n-      \/\/ Degenerate notify\n-      \/\/ fast-locked by caller so by definition the implied waitset is empty.\n-      return true;\n-    }\n-  } else if (LockingMode == LM_LEGACY) {\n-    if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n-      \/\/ Degenerate notify\n-      \/\/ stack-locked by caller so by definition the implied waitset is empty.\n-      return true;\n-    }\n+  if (mark.is_fast_locked() && current->lock_stack().contains(cast_to_oop(obj))) {\n+    \/\/ Degenerate notify\n+    \/\/ fast-locked by caller so by definition the implied waitset is empty.\n+    return true;\n@@ -362,1 +351,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT && mon == nullptr) {\n+    if (mon == nullptr) {\n@@ -385,73 +374,0 @@\n-static bool useHeavyMonitors() {\n-#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n-  return LockingMode == LM_MONITOR;\n-#else\n-  return false;\n-#endif\n-}\n-\n-\/\/ The LockNode emitted directly at the synchronization site would have\n-\/\/ been too big if it were to have included support for the cases of inflated\n-\/\/ recursive enter and exit, so they go here instead.\n-\/\/ Note that we can't safely call AsyncPrintJavaStack() from within\n-\/\/ quick_enter() as our thread state remains _in_Java.\n-\n-bool ObjectSynchronizer::quick_enter_legacy(oop obj, BasicLock* lock, JavaThread* current) {\n-  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n-\n-  if (useHeavyMonitors()) {\n-    return false;  \/\/ Slow path\n-  }\n-\n-  assert(LockingMode == LM_LEGACY, \"legacy mode below\");\n-\n-  const markWord mark = obj->mark();\n-\n-  if (mark.has_monitor()) {\n-\n-    ObjectMonitor* const m = read_monitor(mark);\n-    \/\/ An async deflation or GC can race us before we manage to make\n-    \/\/ the ObjectMonitor busy by setting the owner below. If we detect\n-    \/\/ that race we just bail out to the slow-path here.\n-    if (m->object_peek() == nullptr) {\n-      return false;\n-    }\n-\n-    \/\/ Lock contention and Transactional Lock Elision (TLE) diagnostics\n-    \/\/ and observability\n-    \/\/ Case: light contention possibly amenable to TLE\n-    \/\/ Case: TLE inimical operations such as nested\/recursive synchronization\n-\n-    if (m->has_owner(current)) {\n-      m->increment_recursions(current);\n-      current->inc_held_monitor_count();\n-      return true;\n-    }\n-\n-    \/\/ This Java Monitor is inflated so obj's header will never be\n-    \/\/ displaced to this thread's BasicLock. Make the displaced header\n-    \/\/ non-null so this BasicLock is not seen as recursive nor as\n-    \/\/ being locked. We do this unconditionally so that this thread's\n-    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-    \/\/ performance reasons, stack walkers generally first check for\n-    \/\/ stack-locking in the object's header, the second check is for\n-    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n-    lock->set_displaced_header(markWord::unused_mark());\n-\n-    if (!m->has_owner() && m->try_set_owner(current)) {\n-      assert(m->recursions() == 0, \"invariant\");\n-      current->inc_held_monitor_count();\n-      return true;\n-    }\n-  }\n-\n-  \/\/ Note that we could inflate in quick_enter.\n-  \/\/ This is likely a useful optimization\n-  \/\/ Critically, in quick_enter() we must not:\n-  \/\/ -- block indefinitely, or\n-  \/\/ -- reach a safepoint\n-\n-  return false;        \/\/ revert to slow-path\n-}\n-\n@@ -516,138 +432,1 @@\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    return LightweightSynchronizer::enter_for(obj, lock, locking_thread);\n-  }\n-\n-  if (!enter_fast_impl(obj, lock, locking_thread)) {\n-    \/\/ Inflated ObjectMonitor::enter_for is required\n-\n-    \/\/ An async deflation can race after the inflate_for() call and before\n-    \/\/ enter_for() can make the ObjectMonitor busy. enter_for() returns false\n-    \/\/ if we have lost the race to async deflation and we simply try again.\n-    while (true) {\n-      ObjectMonitor* monitor = inflate_for(locking_thread, obj(), inflate_cause_monitor_enter);\n-      if (monitor->enter_for(locking_thread)) {\n-        return;\n-      }\n-      assert(monitor->is_being_async_deflated(), \"must be\");\n-    }\n-  }\n-}\n-\n-void ObjectSynchronizer::enter_legacy(Handle obj, BasicLock* lock, JavaThread* current) {\n-  if (!enter_fast_impl(obj, lock, current)) {\n-    \/\/ Inflated ObjectMonitor::enter is required\n-\n-    \/\/ An async deflation can race after the inflate() call and before\n-    \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n-    \/\/ we have lost the race to async deflation and we simply try again.\n-    while (true) {\n-      ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_monitor_enter);\n-      if (monitor->enter(current)) {\n-        return;\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ The interpreter and compiler assembly code tries to lock using the fast path\n-\/\/ of this algorithm. Make sure to update that code if the following function is\n-\/\/ changed. The implementation is extremely sensitive to race condition. Be careful.\n-bool ObjectSynchronizer::enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n-\n-  if (obj->klass()->is_value_based()) {\n-    handle_sync_on_value_based_class(obj, locking_thread);\n-  }\n-\n-  locking_thread->inc_held_monitor_count();\n-\n-  if (!useHeavyMonitors()) {\n-    if (LockingMode == LM_LEGACY) {\n-      markWord mark = obj->mark();\n-      if (mark.is_unlocked()) {\n-        \/\/ Anticipate successful CAS -- the ST of the displaced mark must\n-        \/\/ be visible <= the ST performed by the CAS.\n-        lock->set_displaced_header(mark);\n-        if (mark == obj()->cas_set_mark(markWord::from_pointer(lock), mark)) {\n-          return true;\n-        }\n-      } else if (mark.has_locker() &&\n-                 locking_thread->is_lock_owned((address) mark.locker())) {\n-        assert(lock != mark.locker(), \"must not re-lock the same lock\");\n-        assert(lock != (BasicLock*) obj->mark().value(), \"don't relock with same BasicLock\");\n-        lock->set_displaced_header(markWord::from_pointer(nullptr));\n-        return true;\n-      }\n-\n-      \/\/ The object header will never be displaced to this lock,\n-      \/\/ so it does not matter what the value is, except that it\n-      \/\/ must be non-zero to avoid looking like a re-entrant lock,\n-      \/\/ and must not look locked either.\n-      lock->set_displaced_header(markWord::unused_mark());\n-\n-      \/\/ Failed to fast lock.\n-      return false;\n-    }\n-  } else if (VerifyHeavyMonitors) {\n-    guarantee((obj->mark().value() & markWord::lock_mask_in_place) != markWord::locked_value, \"must not be lightweight\/stack-locked\");\n-  }\n-\n-  return false;\n-}\n-\n-void ObjectSynchronizer::exit_legacy(oop object, BasicLock* lock, JavaThread* current) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n-\n-  if (!useHeavyMonitors()) {\n-    markWord mark = object->mark();\n-    if (LockingMode == LM_LEGACY) {\n-      markWord dhw = lock->displaced_header();\n-      if (dhw.value() == 0) {\n-        \/\/ If the displaced header is null, then this exit matches up with\n-        \/\/ a recursive enter. No real work to do here except for diagnostics.\n-#ifndef PRODUCT\n-        if (mark != markWord::INFLATING()) {\n-          \/\/ Only do diagnostics if we are not racing an inflation. Simply\n-          \/\/ exiting a recursive enter of a Java Monitor that is being\n-          \/\/ inflated is safe; see the has_monitor() comment below.\n-          assert(!mark.is_unlocked(), \"invariant\");\n-          assert(!mark.has_locker() ||\n-                 current->is_lock_owned((address)mark.locker()), \"invariant\");\n-          if (mark.has_monitor()) {\n-            \/\/ The BasicLock's displaced_header is marked as a recursive\n-            \/\/ enter and we have an inflated Java Monitor (ObjectMonitor).\n-            \/\/ This is a special case where the Java Monitor was inflated\n-            \/\/ after this thread entered the stack-lock recursively. When a\n-            \/\/ Java Monitor is inflated, we cannot safely walk the Java\n-            \/\/ Monitor owner's stack and update the BasicLocks because a\n-            \/\/ Java Monitor can be asynchronously inflated by a thread that\n-            \/\/ does not own the Java Monitor.\n-            ObjectMonitor* m = read_monitor(mark);\n-            assert(m->object()->mark() == mark, \"invariant\");\n-            assert(m->is_entered(current), \"invariant\");\n-          }\n-        }\n-#endif\n-        return;\n-      }\n-\n-      if (mark == markWord::from_pointer(lock)) {\n-        \/\/ If the object is stack-locked by the current thread, try to\n-        \/\/ swing the displaced header from the BasicLock back to the mark.\n-        assert(dhw.is_neutral(), \"invariant\");\n-        if (object->cas_set_mark(dhw, mark) == mark) {\n-          return;\n-        }\n-      }\n-    }\n-  } else if (VerifyHeavyMonitors) {\n-    guarantee((object->mark().value() & markWord::lock_mask_in_place) != markWord::locked_value, \"must not be lightweight\/stack-locked\");\n-  }\n-\n-  \/\/ We have to take the slow-path of possible inflation and then exit.\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-  ObjectMonitor* monitor = inflate(current, object, inflate_cause_vm_internal);\n-  assert(!monitor->has_anonymous_owner(), \"must not be\");\n-  monitor->exit(current);\n+  return LightweightSynchronizer::enter_for(obj, lock, locking_thread);\n@@ -674,11 +453,2 @@\n-    ObjectMonitor* monitor;\n-    bool entered;\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      BasicLock lock;\n-      entered = LightweightSynchronizer::inflate_and_enter(obj(), &lock, inflate_cause_jni_enter, current, current) != nullptr;\n-    } else {\n-      monitor = inflate(current, obj(), inflate_cause_jni_enter);\n-      entered = monitor->enter(current);\n-    }\n-\n-    if (entered) {\n+    BasicLock lock;\n+    if (LightweightSynchronizer::inflate_and_enter(obj(), &lock, inflate_cause_jni_enter, current, current) != nullptr) {\n@@ -697,7 +467,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n-  } else {\n-    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-    \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-    monitor = inflate(current, obj, inflate_cause_jni_exit);\n-  }\n+  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n@@ -744,8 +508,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n-  } else {\n-    \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-    \/\/ field is incremented before ownership is dropped and decremented\n-    \/\/ after ownership is regained.\n-    monitor = inflate(current, obj(), inflate_cause_wait);\n-  }\n+  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n@@ -770,5 +527,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n-  } else {\n-    monitor = inflate(THREAD, obj(), inflate_cause_wait);\n-  }\n+  monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n@@ -783,19 +536,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n-      \/\/ Not inflated so there can't be any waiters to notify.\n-      return;\n-    }\n-  } else if (LockingMode == LM_LEGACY) {\n-    if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n-      \/\/ Not inflated so there can't be any waiters to notify.\n-      return;\n-    }\n-  }\n-\n-  ObjectMonitor* monitor;\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n-  } else {\n-    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-    \/\/ dropped by the calling thread.\n-    monitor = inflate(current, obj(), inflate_cause_notify);\n+  if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n+    \/\/ Not inflated so there can't be any waiters to notify.\n+    return;\n@@ -803,0 +540,1 @@\n+  ObjectMonitor* monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n@@ -811,10 +549,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n-      \/\/ Not inflated so there can't be any waiters to notify.\n-      return;\n-    }\n-  } else if (LockingMode == LM_LEGACY) {\n-    if (mark.has_locker() && current->is_lock_owned((address)mark.locker())) {\n-      \/\/ Not inflated so there can't be any waiters to notify.\n-      return;\n-    }\n+  if ((mark.is_fast_locked() && current->lock_stack().contains(obj()))) {\n+    \/\/ Not inflated so there can't be any waiters to notify.\n+    return;\n@@ -823,8 +554,1 @@\n-  ObjectMonitor* monitor;\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n-  } else {\n-    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-    \/\/ dropped by the calling thread.\n-    monitor = inflate(current, obj(), inflate_cause_notify);\n-  }\n+  ObjectMonitor* monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n@@ -850,61 +574,0 @@\n-static markWord read_stable_mark(oop obj) {\n-  markWord mark = obj->mark_acquire();\n-  if (!mark.is_being_inflated() || LockingMode == LM_LIGHTWEIGHT) {\n-    \/\/ New lightweight locking does not use the markWord::INFLATING() protocol.\n-    return mark;       \/\/ normal fast-path return\n-  }\n-\n-  int its = 0;\n-  for (;;) {\n-    markWord mark = obj->mark_acquire();\n-    if (!mark.is_being_inflated()) {\n-      return mark;    \/\/ normal fast-path return\n-    }\n-\n-    \/\/ The object is being inflated by some other thread.\n-    \/\/ The caller of read_stable_mark() must wait for inflation to complete.\n-    \/\/ Avoid live-lock.\n-\n-    ++its;\n-    if (its > 10000 || !os::is_MP()) {\n-      if (its & 1) {\n-        os::naked_yield();\n-      } else {\n-        \/\/ Note that the following code attenuates the livelock problem but is not\n-        \/\/ a complete remedy.  A more complete solution would require that the inflating\n-        \/\/ thread hold the associated inflation lock.  The following code simply restricts\n-        \/\/ the number of spinners to at most one.  We'll have N-2 threads blocked\n-        \/\/ on the inflationlock, 1 thread holding the inflation lock and using\n-        \/\/ a yield\/park strategy, and 1 thread in the midst of inflation.\n-        \/\/ A more refined approach would be to change the encoding of INFLATING\n-        \/\/ to allow encapsulation of a native thread pointer.  Threads waiting for\n-        \/\/ inflation to complete would use CAS to push themselves onto a singly linked\n-        \/\/ list rooted at the markword.  Once enqueued, they'd loop, checking a per-thread flag\n-        \/\/ and calling park().  When inflation was complete the thread that accomplished inflation\n-        \/\/ would detach the list and set the markword to inflated with a single CAS and\n-        \/\/ then for each thread on the list, set the flag and unpark() the thread.\n-\n-        \/\/ Index into the lock array based on the current object address.\n-        static_assert(is_power_of_2(inflation_lock_count()), \"must be\");\n-        size_t ix = (cast_from_oop<intptr_t>(obj) >> 5) & (inflation_lock_count() - 1);\n-        int YieldThenBlock = 0;\n-        assert(ix < inflation_lock_count(), \"invariant\");\n-        inflation_lock(ix)->lock();\n-        while (obj->mark_acquire() == markWord::INFLATING()) {\n-          \/\/ Beware: naked_yield() is advisory and has almost no effect on some platforms\n-          \/\/ so we periodically call current->_ParkEvent->park(1).\n-          \/\/ We use a mixed spin\/yield\/block mechanism.\n-          if ((YieldThenBlock++) >= 16) {\n-            Thread::current()->_ParkEvent->park(1);\n-          } else {\n-            os::naked_yield();\n-          }\n-        }\n-        inflation_lock(ix)->unlock();\n-      }\n-    } else {\n-      SpinPause();       \/\/ SMP-polite spinning\n-    }\n-  }\n-}\n-\n@@ -969,1 +632,1 @@\n-  assert(UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -1000,6 +663,2 @@\n-    markWord mark = read_stable_mark(obj);\n-    if (VerifyHeavyMonitors) {\n-      assert(LockingMode == LM_MONITOR, \"+VerifyHeavyMonitors requires LockingMode == 0 (LM_MONITOR)\");\n-      guarantee((obj->mark().value() & markWord::lock_mask_in_place) != markWord::locked_value, \"must not be lightweight\/stack-locked\");\n-    }\n-    if (mark.is_unlocked() || (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked())) {\n+    markWord mark = obj->mark_acquire();\n+    if (mark.is_unlocked() || mark.is_fast_locked()) {\n@@ -1017,4 +676,3 @@\n-      if (LockingMode == LM_LIGHTWEIGHT) {\n-        \/\/ CAS failed, retry\n-        continue;\n-      }\n+      \/\/ CAS failed, retry\n+      continue;\n+\n@@ -1052,19 +710,0 @@\n-    } else if (LockingMode == LM_LEGACY && mark.has_locker()\n-               && current->is_Java_thread()\n-               && JavaThread::cast(current)->is_lock_owned((address)mark.locker())) {\n-      \/\/ This is a stack-lock owned by the calling thread so fetch the\n-      \/\/ displaced markWord from the BasicLock on the stack.\n-      temp = mark.displaced_mark_helper();\n-      assert(temp.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, temp.value());\n-      hash = temp.hash();\n-      if (hash != 0) {                  \/\/ if it has a hash, just return it\n-        return hash;\n-      }\n-      \/\/ WARNING:\n-      \/\/ The displaced header in the BasicLock on a thread's stack\n-      \/\/ is strictly immutable. It CANNOT be changed in ANY cases.\n-      \/\/ So we have to inflate the stack-lock into an ObjectMonitor\n-      \/\/ even if the current thread owns the lock. The BasicLock on\n-      \/\/ a thread's stack can be asynchronously read by other threads\n-      \/\/ during an inflate() call so any change to that stack memory\n-      \/\/ may not propagate to other threads correctly.\n@@ -1073,3 +712,0 @@\n-    \/\/ Inflate the monitor to set the hash.\n-\n-    \/\/ There's no need to inflate if the mark has already got a monitor.\n@@ -1079,1 +715,3 @@\n-    monitor = mark.has_monitor() ? mark.monitor() : inflate(current, obj, inflate_cause_hash_code);\n+    assert(mark.has_monitor(), \"must be\");\n+    monitor = mark.monitor();\n+\n@@ -1119,6 +757,1 @@\n-  markWord mark = read_stable_mark(obj);\n-\n-  if (LockingMode == LM_LEGACY && mark.has_locker()) {\n-    \/\/ stack-locked case, header points into owner's stack\n-    return current->is_lock_owned((address)mark.locker());\n-  }\n+  markWord mark = obj->mark_acquire();\n@@ -1126,1 +759,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n+  if (mark.is_fast_locked()) {\n@@ -1131,1 +764,1 @@\n-  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+  while (mark.has_monitor()) {\n@@ -1145,7 +778,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n-    \/\/ Inflated monitor so header points to ObjectMonitor (tagged pointer).\n-    \/\/ The first stage of async deflation does not affect any field\n-    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n-    ObjectMonitor* monitor = read_monitor(mark);\n-    return monitor->is_entered(current) != 0;\n-  }\n@@ -1159,7 +785,1 @@\n-  markWord mark = read_stable_mark(obj);\n-\n-  if (LockingMode == LM_LEGACY && mark.has_locker()) {\n-    \/\/ stack-locked so header points into owner's stack.\n-    \/\/ owning_thread_from_monitor_owner() may also return null here:\n-    return Threads::owning_thread_from_stacklock(t_list, (address) mark.locker());\n-  }\n+  markWord mark = obj->mark_acquire();\n@@ -1167,1 +787,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n+  if (mark.is_fast_locked()) {\n@@ -1173,1 +793,1 @@\n-  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+  while (mark.has_monitor()) {\n@@ -1187,10 +807,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n-    \/\/ Inflated monitor so header points to ObjectMonitor (tagged pointer).\n-    \/\/ The first stage of async deflation does not affect any field\n-    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n-    ObjectMonitor* monitor = read_monitor(mark);\n-    assert(monitor != nullptr, \"monitor should be non-null\");\n-    \/\/ owning_thread_from_monitor() may also return null here:\n-    return Threads::owning_thread_from_monitor(t_list, monitor);\n-  }\n-\n@@ -1419,224 +1029,0 @@\n-static void post_monitor_inflate_event(EventJavaMonitorInflate* event,\n-                                       const oop obj,\n-                                       ObjectSynchronizer::InflateCause cause) {\n-  assert(event != nullptr, \"invariant\");\n-  const Klass* monitor_klass = obj->klass();\n-  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n-    return;\n-  }\n-  event->set_monitorClass(monitor_klass);\n-  event->set_address((uintptr_t)(void*)obj);\n-  event->set_cause((u1)cause);\n-  event->commit();\n-}\n-\n-\/\/ Fast path code shared by multiple functions\n-void ObjectSynchronizer::inflate_helper(oop obj) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n-  markWord mark = obj->mark_acquire();\n-  if (mark.has_monitor()) {\n-    ObjectMonitor* monitor = read_monitor(mark);\n-    markWord dmw = monitor->header();\n-    assert(dmw.is_neutral(), \"sanity check: header=\" INTPTR_FORMAT, dmw.value());\n-    return;\n-  }\n-  (void)inflate(Thread::current(), obj, inflate_cause_vm_internal);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate(Thread* current, oop obj, const InflateCause cause) {\n-  assert(current == Thread::current(), \"must be\");\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n-  return inflate_impl(current->is_Java_thread() ? JavaThread::cast(current) : nullptr, obj, cause);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate_for(JavaThread* thread, oop obj, const InflateCause cause) {\n-  assert(thread == Thread::current() || thread->is_obj_deopt_suspend(), \"must be\");\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_for\");\n-  return inflate_impl(thread, obj, cause);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* locking_thread, oop object, const InflateCause cause) {\n-  \/\/ The JavaThread* locking_thread requires that the locking_thread == Thread::current() or\n-  \/\/ is suspended throughout the call by some other mechanism.\n-  \/\/ The thread might be nullptr when called from a non JavaThread. (As may still be\n-  \/\/ the case from FastHashCode). However it is only important for correctness that the\n-  \/\/ thread is set when called from ObjectSynchronizer::enter from the owning thread,\n-  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_impl\");\n-  EventJavaMonitorInflate event;\n-\n-  for (;;) {\n-    const markWord mark = object->mark_acquire();\n-\n-    \/\/ The mark can be in one of the following states:\n-    \/\/ *  inflated     - If the ObjectMonitor owner is anonymous and the\n-    \/\/                   locking_thread owns the object lock, then we\n-    \/\/                   make the locking_thread the ObjectMonitor owner.\n-    \/\/ *  stack-locked - Coerce it to inflated from stack-locked.\n-    \/\/ *  INFLATING    - Busy wait for conversion from stack-locked to\n-    \/\/                   inflated.\n-    \/\/ *  unlocked     - Aggressively inflate the object.\n-\n-    \/\/ CASE: inflated\n-    if (mark.has_monitor()) {\n-      ObjectMonitor* inf = mark.monitor();\n-      markWord dmw = inf->header();\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n-      if (inf->has_anonymous_owner() && locking_thread != nullptr) {\n-        assert(LockingMode == LM_LEGACY, \"invariant\");\n-        if (locking_thread->is_lock_owned((address)inf->stack_locker())) {\n-          inf->set_stack_locker(nullptr);\n-          inf->set_owner_from_anonymous(locking_thread);\n-        }\n-      }\n-      return inf;\n-    }\n-\n-    \/\/ CASE: inflation in progress - inflating over a stack-lock.\n-    \/\/ Some other thread is converting from stack-locked to inflated.\n-    \/\/ Only that thread can complete inflation -- other threads must wait.\n-    \/\/ The INFLATING value is transient.\n-    \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n-    \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n-    if (mark == markWord::INFLATING()) {\n-      read_stable_mark(object);\n-      continue;\n-    }\n-\n-    \/\/ CASE: stack-locked\n-    \/\/ Could be stack-locked either by current or by some other thread.\n-    \/\/\n-    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_ attempting\n-    \/\/ to install INFLATING into the mark word.  We originally installed INFLATING,\n-    \/\/ allocated the ObjectMonitor, and then finally STed the address of the\n-    \/\/ ObjectMonitor into the mark.  This was correct, but artificially lengthened\n-    \/\/ the interval in which INFLATING appeared in the mark, thus increasing\n-    \/\/ the odds of inflation contention. If we lose the race to set INFLATING,\n-    \/\/ then we just delete the ObjectMonitor and loop around again.\n-    \/\/\n-    LogStreamHandle(Trace, monitorinflation) lsh;\n-    if (LockingMode == LM_LEGACY && mark.has_locker()) {\n-      ObjectMonitor* m = new ObjectMonitor(object);\n-      \/\/ Optimistically prepare the ObjectMonitor - anticipate successful CAS\n-      \/\/ We do this before the CAS in order to minimize the length of time\n-      \/\/ in which INFLATING appears in the mark.\n-\n-      markWord cmp = object->cas_set_mark(markWord::INFLATING(), mark);\n-      if (cmp != mark) {\n-        delete m;\n-        continue;       \/\/ Interference -- just retry\n-      }\n-\n-      \/\/ We've successfully installed INFLATING (0) into the mark-word.\n-      \/\/ This is the only case where 0 will appear in a mark-word.\n-      \/\/ Only the singular thread that successfully swings the mark-word\n-      \/\/ to 0 can perform (or more precisely, complete) inflation.\n-      \/\/\n-      \/\/ Why do we CAS a 0 into the mark-word instead of just CASing the\n-      \/\/ mark-word from the stack-locked value directly to the new inflated state?\n-      \/\/ Consider what happens when a thread unlocks a stack-locked object.\n-      \/\/ It attempts to use CAS to swing the displaced header value from the\n-      \/\/ on-stack BasicLock back into the object header.  Recall also that the\n-      \/\/ header value (hash code, etc) can reside in (a) the object header, or\n-      \/\/ (b) a displaced header associated with the stack-lock, or (c) a displaced\n-      \/\/ header in an ObjectMonitor.  The inflate() routine must copy the header\n-      \/\/ value from the BasicLock on the owner's stack to the ObjectMonitor, all\n-      \/\/ the while preserving the hashCode stability invariants.  If the owner\n-      \/\/ decides to release the lock while the value is 0, the unlock will fail\n-      \/\/ and control will eventually pass from slow_exit() to inflate.  The owner\n-      \/\/ will then spin, waiting for the 0 value to disappear.   Put another way,\n-      \/\/ the 0 causes the owner to stall if the owner happens to try to\n-      \/\/ drop the lock (restoring the header from the BasicLock to the object)\n-      \/\/ while inflation is in-progress.  This protocol avoids races that might\n-      \/\/ would otherwise permit hashCode values to change or \"flicker\" for an object.\n-      \/\/ Critically, while object->mark is 0 mark.displaced_mark_helper() is stable.\n-      \/\/ 0 serves as a \"BUSY\" inflate-in-progress indicator.\n-\n-\n-      \/\/ fetch the displaced mark from the owner's stack.\n-      \/\/ The owner can't die or unwind past the lock while our INFLATING\n-      \/\/ object is in the mark.  Furthermore the owner can't complete\n-      \/\/ an unlock on the object, either.\n-      markWord dmw = mark.displaced_mark_helper();\n-      \/\/ Catch if the object's header is not neutral (not locked and\n-      \/\/ not marked is what we care about here).\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n-\n-      \/\/ Setup monitor fields to proper values -- prepare the monitor\n-      m->set_header(dmw);\n-\n-      \/\/ Note that a thread can inflate an object\n-      \/\/ that it has stack-locked -- as might happen in wait() -- directly\n-      \/\/ with CAS.  That is, we can avoid the xchg-nullptr .... ST idiom.\n-      if (locking_thread != nullptr && locking_thread->is_lock_owned((address)mark.locker())) {\n-        m->set_owner(locking_thread);\n-      } else {\n-        \/\/ Use ANONYMOUS_OWNER to indicate that the owner is the BasicLock on the stack,\n-        \/\/ and set the stack locker field in the monitor.\n-        m->set_stack_locker(mark.locker());\n-        m->set_anonymous_owner();\n-      }\n-      \/\/ TODO-FIXME: assert BasicLock->dhw != 0.\n-\n-      \/\/ Must preserve store ordering. The monitor state must\n-      \/\/ be stable at the time of publishing the monitor address.\n-      guarantee(object->mark() == markWord::INFLATING(), \"invariant\");\n-      \/\/ Release semantics so that above set_object() is seen first.\n-      object->release_set_mark(markWord::encode(m));\n-\n-      \/\/ Once ObjectMonitor is configured and the object is associated\n-      \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-      _in_use_list.add(m);\n-\n-      if (log_is_enabled(Trace, monitorinflation)) {\n-        ResourceMark rm;\n-        lsh.print_cr(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n-                     INTPTR_FORMAT \", type='%s'\", p2i(object),\n-                     object->mark().value(), object->klass()->external_name());\n-      }\n-      if (event.should_commit()) {\n-        post_monitor_inflate_event(&event, object, cause);\n-      }\n-      return m;\n-    }\n-\n-    \/\/ CASE: unlocked\n-    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n-    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n-    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n-    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n-    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n-    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n-    \/\/ An inflateTry() method that we could call from enter() would be useful.\n-\n-    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n-    ObjectMonitor* m = new ObjectMonitor(object);\n-    \/\/ prepare m for installation - set monitor to initial state\n-    m->set_header(mark);\n-\n-    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n-      delete m;\n-      m = nullptr;\n-      continue;\n-      \/\/ interference - the markword changed - just retry.\n-      \/\/ The state-transitions are one-way, so there's no chance of\n-      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n-    }\n-\n-    \/\/ Once the ObjectMonitor is configured and object is associated\n-    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-    _in_use_list.add(m);\n-\n-    if (log_is_enabled(Trace, monitorinflation)) {\n-      ResourceMark rm;\n-      lsh.print_cr(\"inflate(unlocked): object=\" INTPTR_FORMAT \", mark=\"\n-                   INTPTR_FORMAT \", type='%s'\", p2i(object),\n-                   object->mark().value(), object->klass()->external_name());\n-    }\n-    if (event.should_commit()) {\n-      post_monitor_inflate_event(&event, object, cause);\n-    }\n-    return m;\n-  }\n-}\n-\n@@ -1918,1 +1304,0 @@\n-    case inflate_cause_hash_code:      return \"Monitor Hash Code\";\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":35,"deletions":650,"binary":false,"changes":685,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n@@ -76,1 +76,1 @@\n- public:\n+public:\n@@ -82,4 +82,3 @@\n-    inflate_cause_hash_code = 4,\n-    inflate_cause_jni_enter = 5,\n-    inflate_cause_jni_exit = 6,\n-    inflate_cause_nof = 7 \/\/ Number of causes\n+    inflate_cause_jni_enter = 4,\n+    inflate_cause_jni_exit = 5,\n+    inflate_cause_nof = 6 \/\/ Number of causes\n@@ -107,4 +106,0 @@\n-private:\n-  \/\/ Shared implementation for enter and enter_for. Performs all but\n-  \/\/ inflated monitor enter.\n-  static bool enter_fast_impl(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n@@ -112,4 +107,0 @@\n-  static bool quick_enter_legacy(oop obj, BasicLock* Lock, JavaThread* current);\n-  static void enter_legacy(Handle obj, BasicLock* Lock, JavaThread* current);\n-  static void exit_legacy(oop obj, BasicLock* lock, JavaThread* current);\n-public:\n@@ -134,9 +125,0 @@\n-  \/\/ Inflate light weight monitor to heavy weight monitor\n-  static ObjectMonitor* inflate(Thread* current, oop obj, const InflateCause cause);\n-  \/\/ Used to inflate a monitor as if it was done from the thread JavaThread.\n-  static ObjectMonitor* inflate_for(JavaThread* thread, oop obj, const InflateCause cause);\n-\n-private:\n-  \/\/ Shared implementation between the different LockingMode.\n-  static ObjectMonitor* inflate_impl(JavaThread* locking_thread, oop obj, const InflateCause cause);\n-\n@@ -144,2 +126,0 @@\n-  \/\/ This version is only for internal use\n-  static void inflate_helper(oop obj);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -50,3 +49,0 @@\n-  } else {\n-    enter_legacy(obj, lock, current);\n-  }\n@@ -64,5 +60,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    return LightweightSynchronizer::quick_enter(obj, lock, current);\n-  } else {\n-    return quick_enter_legacy(obj, lock, current);\n-  }\n+  return LightweightSynchronizer::quick_enter(obj, lock, current);\n@@ -74,5 +66,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    LightweightSynchronizer::exit(object, lock, current);\n-  } else {\n-    exit_legacy(object, lock, current);\n-  }\n+  LightweightSynchronizer::exit(object, lock, current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -605,1 +605,0 @@\n-  OrderAccess::fence();      \/\/ guarantee at least release consistency.\n@@ -613,4 +612,3 @@\n-  \/\/ Conceptually we need a #loadstore|#storestore \"release\" MEMBAR before\n-  \/\/ the ST of 0 into the lock-word which releases the lock, so fence\n-  \/\/ more than covers this on all platforms.\n-  *adr = 0;\n+  \/\/ So we need a #loadstore|#storestore \"release\" memory barrier before\n+  \/\/ the ST of 0 into the lock-word which releases the lock.\n+  Atomic::release_store(adr, 0);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -194,1 +194,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ HashTable SIZE is specified at compile time so we\n@@ -196,1 +196,1 @@\n-  typedef ResourceHashtable<void *, int, 1031,\n+  typedef HashTable<void *, int, 1031,\n@@ -202,1 +202,1 @@\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ HashTable is passed to various functions and populated in\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"runtime\/atomic.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/metaspaceShared.hpp\"\n@@ -40,1 +40,0 @@\n-#include \"compiler\/compileTask.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -94,1 +94,0 @@\n-#include \"runtime\/threadSMR.inline.hpp\"\n@@ -96,0 +95,1 @@\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -99,1 +99,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -101,0 +100,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -892,1 +892,1 @@\n-    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n+    AOTMetaspace::preload_and_dump(CHECK_JNI_ERR);\n@@ -895,1 +895,1 @@\n-    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n+    AOTMetaspace::preload_and_dump(CHECK_JNI_ERR);\n@@ -1297,13 +1297,0 @@\n-JavaThread *Threads::owning_thread_from_stacklock(ThreadsList * t_list, address basicLock) {\n-  assert(LockingMode == LM_LEGACY, \"Not with new lightweight locking\");\n-\n-  JavaThread* the_owner = nullptr;\n-  for (JavaThread* q : *t_list) {\n-    if (q->is_lock_owned(basicLock)) {\n-      the_owner = q;\n-      break;\n-    }\n-  }\n-  return the_owner;\n-}\n-\n@@ -1311,1 +1298,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Only with new lightweight locking\");\n@@ -1328,6 +1314,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      return owning_thread_from_object(t_list, monitor->object());\n-    } else {\n-      assert(LockingMode == LM_LEGACY, \"invariant\");\n-      return owning_thread_from_stacklock(t_list, (address)monitor->stack_locker());\n-    }\n+    return owning_thread_from_object(t_list, monitor->object());\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":7,"deletions":26,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,3 +137,0 @@\n-  \/\/ Get owning Java thread from the basicLock address.\n-  static JavaThread *owning_thread_from_stacklock(ThreadsList * t_list, address basicLock);\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n@@ -54,1 +53,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -56,0 +54,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/scopeDesc.hpp\"\n@@ -42,1 +43,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -44,0 +44,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n@@ -64,1 +65,4 @@\n-  _reexecute = vf->should_reexecute();\n+  _reexecute = vf->should_reexecute(); \/\/ initial value, updated in unpack_on_stack\n+#if INCLUDE_JVMCI\n+  _rethrow = vf->scope()->rethrow_exception();\n+#endif\n@@ -174,1 +178,28 @@\n-int unpack_counter = 0;\n+static int unpack_counter = 0;\n+\n+bool vframeArrayElement::should_reexecute(bool is_top_frame, int exec_mode) const {\n+  if (is_top_frame) {\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      return true;\n+    case Deoptimization::Unpack_exception:\n+      assert(raw_bci() >= 0, \"bad bci %d for Unpack_exception\", raw_bci());\n+    default:\n+      break;\n+    }\n+  }\n+  if (raw_bci() == SynchronizationEntryBCI) {\n+    return true;\n+  }\n+  bool reexec = should_reexecute();\n+  assert(is_top_frame || reexec == false, \"unexepected should_reexecute()\");\n+#ifdef ASSERT\n+  if (!reexec) {\n+    address bcp = method()->bcp_from(bci());\n+    Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+    assert(!Interpreter::bytecode_should_reexecute(code), \"should_reexecute mismatch\");\n+  }\n+#endif\n+  return reexec;\n+}\n@@ -192,3 +223,10 @@\n-  bool use_next_mdp = false; \/\/ true if we should use the mdp associated with the next bci\n-                             \/\/ rather than the one associated with bcp\n-  if (raw_bci() == SynchronizationEntryBCI) {\n+  bool reexecute = should_reexecute(is_top_frame, exec_mode);\n+  if (is_top_frame && exec_mode == Deoptimization::Unpack_exception) {\n+    assert(raw_bci() >= 0, \"bad bci %d for Unpack_exception\", raw_bci());\n+    bcp = method()->bcp_from(bci());\n+    \/\/ exception is pending\n+    pc = Interpreter::rethrow_exception_entry();\n+    \/\/ [phh] We're going to end up in some handler or other, so it doesn't\n+    \/\/ matter what mdp we point to.  See exception_handler_for_exception()\n+    \/\/ in interpreterRuntime.cpp.\n+  } else if (raw_bci() == SynchronizationEntryBCI) {\n@@ -198,1 +236,2 @@\n-  } else if (should_reexecute()) { \/\/reexecute this bytecode\n+    assert(reexecute, \"must be\");\n+  } else if (reexecute) { \/\/reexecute this bytecode\n@@ -201,1 +240,10 @@\n-    pc  = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    switch (exec_mode) {\n+    case Deoptimization::Unpack_uncommon_trap:\n+    case Deoptimization::Unpack_reexecute:\n+      \/\/ Do not special-case _athrow or _return_register_finalizer\n+      pc = Interpreter::deopt_entry(vtos, 0);\n+      break;\n+    default:\n+      \/\/ Yes, special-case _athrow and _return_register_finalizer\n+      pc = Interpreter::deopt_reexecute_entry(method(), bcp);\n+    }\n@@ -204,0 +252,1 @@\n+    assert(!reexecute, \"must be\");\n@@ -205,1 +254,0 @@\n-    use_next_mdp = true;\n@@ -242,1 +290,10 @@\n-        use_next_mdp = false;\n+#ifdef ASSERT\n+        Bytecodes::Code code = Bytecodes::code_at(method(), bcp);\n+        assert(Bytecodes::is_invoke(code), \"must be\");\n+        assert(!reexecute, \"must be\");\n+#endif\n+        \/\/ It would be nice if the VerifyStack logic in unpack_frames() was refactored so\n+        \/\/ we could check the stack before and after changing the reexecute mode, but\n+        \/\/ it should pass either way because an invoke uses the same stack state for both modes,\n+        \/\/ which is: args popped but result not yet pushed.\n+        reexecute = true;\n@@ -248,6 +305,5 @@\n-    } else if (!realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr &&\n-               state->is_earlyret_pending()) {\n-      \/\/ Force early return from top frame after deoptimization\n-      pc = Interpreter::remove_activation_early_entry(state->earlyret_tos());\n-    } else {\n-      if (realloc_failure_exception && JvmtiExport::can_force_early_return() && state != nullptr && state->is_earlyret_pending()) {\n+    } else if (JvmtiExport::can_force_early_return() && state != nullptr && state->is_earlyret_pending()) {\n+      if (!realloc_failure_exception) {\n+        \/\/ Force early return from top frame after deoptimization\n+        pc = Interpreter::remove_activation_early_entry(state->earlyret_tos());\n+      } else {\n@@ -258,21 +314,0 @@\n-      \/\/ Possibly override the previous pc computation of the top (youngest) frame\n-      switch (exec_mode) {\n-      case Deoptimization::Unpack_deopt:\n-        \/\/ use what we've got\n-        break;\n-      case Deoptimization::Unpack_exception:\n-        \/\/ exception is pending\n-        pc = SharedRuntime::raw_exception_handler_for_return_address(thread, pc);\n-        \/\/ [phh] We're going to end up in some handler or other, so it doesn't\n-        \/\/ matter what mdp we point to.  See exception_handler_for_exception()\n-        \/\/ in interpreterRuntime.cpp.\n-        break;\n-      case Deoptimization::Unpack_uncommon_trap:\n-      case Deoptimization::Unpack_reexecute:\n-        \/\/ redo last byte code\n-        pc  = Interpreter::deopt_entry(vtos, 0);\n-        use_next_mdp = false;\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-      }\n@@ -280,0 +315,1 @@\n+    _reexecute = reexecute;\n@@ -320,3 +356,0 @@\n-  if (ProfileInterpreter) {\n-    iframe()->interpreter_frame_set_mdp(nullptr); \/\/ clear out the mdp.\n-  }\n@@ -326,1 +359,1 @@\n-    if (mdo != nullptr) {\n+    if (mdo != nullptr && exec_mode != Deoptimization::Unpack_exception) {\n@@ -328,1 +361,1 @@\n-      if (use_next_mdp) ++bci;\n+      if (!reexecute) ++bci;\n@@ -331,0 +364,2 @@\n+    } else {\n+      iframe()->interpreter_frame_set_mdp(nullptr); \/\/ clear out the mdp.\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":77,"deletions":42,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,3 @@\n+#if INCLUDE_JVMCI\n+    bool _rethrow;                                               \/\/ from ScopeDesc::rethrow_exception()\n+#endif\n@@ -74,0 +77,1 @@\n+  bool should_reexecute(bool is_top_frame, int exec_mode) const;\n@@ -75,0 +79,3 @@\n+#if INCLUDE_JVMCI\n+  bool rethrow_exception(void) const  { return _rethrow; }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -47,0 +46,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -294,1 +294,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ HashTable SIZE is specified at compile time so we\n@@ -296,1 +296,1 @@\n-  typedef ResourceHashtable<int64_t, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n+  typedef HashTable<int64_t, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n@@ -329,1 +329,1 @@\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ HashTable is passed to various functions and populated in\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/vmOperation.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -59,1 +58,0 @@\n-#include \"oops\/constMethod.hpp\"\n@@ -61,0 +59,1 @@\n+#include \"oops\/constMethod.hpp\"\n@@ -102,1 +101,0 @@\n-#include \"runtime\/vmStructs.hpp\"\n@@ -104,0 +102,1 @@\n+#include \"runtime\/vmStructs.hpp\"\n@@ -324,1 +323,1 @@\n-  nonstatic_field(JNIid,                       _holder,                                       Klass*)                                \\\n+  nonstatic_field(JNIid,                       _holder,                                       InstanceKlass*)                        \\\n@@ -351,2 +350,2 @@\n-     static_field(MetaspaceObj,                _shared_metaspace_base,                        void*)                                 \\\n-     static_field(MetaspaceObj,                _shared_metaspace_top,                         void*)                                 \\\n+     static_field(MetaspaceObj,                _aot_metaspace_base,                           void*)                                 \\\n+     static_field(MetaspaceObj,                _aot_metaspace_top,                            void*)                                 \\\n@@ -677,1 +676,0 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _stack_locker,                                 BasicLock*)                            \\\n@@ -1644,8 +1642,0 @@\n-  \/**********************************************\/                        \\\n-  \/* LockingMode enum (globalDefinitions.hpp) *\/                          \\\n-  \/**********************************************\/                        \\\n-                                                                          \\\n-  declare_constant(LM_MONITOR)                                            \\\n-  declare_constant(LM_LEGACY)                                             \\\n-  declare_constant(LM_LIGHTWEIGHT)                                        \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -49,1 +49,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -51,0 +50,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/perfDataTypes.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"runtime\/perfDataTypes.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedupProcessor.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/perfData.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/cpuTimeUsage.hpp\"\n+\n+volatile bool CPUTimeUsage::Error::_has_error = false;\n+\n+static inline jlong thread_cpu_time_or_zero(Thread* thread) {\n+  jlong cpu_time = os::thread_cpu_time(thread);\n+  if (cpu_time == -1) {\n+    CPUTimeUsage::Error::mark_error();\n+    return 0;\n+  }\n+  return cpu_time;\n+}\n+\n+class CPUTimeThreadClosure : public ThreadClosure {\n+private:\n+  jlong _cpu_time = 0;\n+\n+public:\n+  virtual void do_thread(Thread* thread) {\n+    _cpu_time += thread_cpu_time_or_zero(thread);\n+  }\n+  jlong cpu_time() { return _cpu_time; };\n+};\n+\n+jlong CPUTimeUsage::GC::vm_thread() {\n+  return Universe::heap()->_vmthread_cpu_time;\n+}\n+\n+jlong CPUTimeUsage::GC::gc_threads() {\n+  CPUTimeThreadClosure cl;\n+  Universe::heap()->gc_threads_do(&cl);\n+  return cl.cpu_time();\n+}\n+\n+jlong CPUTimeUsage::GC::total() {\n+  return gc_threads() + vm_thread() + stringdedup();\n+}\n+\n+jlong CPUTimeUsage::GC::stringdedup() {\n+  if (UseStringDeduplication) {\n+    return thread_cpu_time_or_zero((Thread*)StringDedup::_processor->_thread);\n+  }\n+  return 0;\n+}\n+\n+bool CPUTimeUsage::Error::has_error() {\n+  return Atomic::load(&_has_error);\n+}\n+\n+void CPUTimeUsage::Error::mark_error() {\n+  Atomic::store(&_has_error, true);\n+}\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_CPUTIMEUSAGE_HPP\n+#define SHARE_SERVICES_CPUTIMEUSAGE_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+namespace CPUTimeUsage {\n+  class GC : public AllStatic {\n+  public:\n+    static jlong total();\n+    static jlong gc_threads();\n+    static jlong vm_thread();\n+    static jlong stringdedup();\n+  };\n+\n+  class Error : public AllStatic {\n+  private:\n+    static volatile bool _has_error;\n+\n+  public:\n+    static bool has_error();\n+    static void mark_error();\n+  };\n+}\n+\n+#endif \/\/ SHARE_SERVICES_CPUTIMEUSAGE_HPP\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -768,1 +768,1 @@\n-  static void dump_instance_class(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_instance_class(AbstractDumpWriter* writer, InstanceKlass* ik);\n@@ -834,1 +834,1 @@\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ HashTable SIZE is specified at compile time so we\n@@ -844,1 +844,1 @@\n-  typedef ResourceHashtable<InstanceKlass*, DumperClassCacheTableEntry*,\n+  typedef HashTable<InstanceKlass*, DumperClassCacheTableEntry*,\n@@ -1207,3 +1207,1 @@\n-void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-\n+void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, InstanceKlass* ik) {\n@@ -1230,2 +1228,2 @@\n-  InstanceKlass* java_super = ik->java_super();\n-  if (java_super == nullptr) {\n+  InstanceKlass* super = ik->super();\n+  if (super == nullptr) {\n@@ -1234,1 +1232,1 @@\n-    writer->write_classID(java_super);\n+    writer->write_classID(super);\n@@ -1508,1 +1506,1 @@\n-      DumperSupport::dump_instance_class(writer(), k);\n+      DumperSupport::dump_instance_class(writer(), InstanceKlass::cast(k));\n@@ -2116,1 +2114,1 @@\n-  os::snprintf(path, buf_size, \"%s.p%d\", base_path, seq);\n+  os::snprintf_checked(path, buf_size, \"%s.p%d\", base_path, seq);\n@@ -2615,1 +2613,4 @@\n-    julong max_threads = os::free_memory() \/ (20 * M);\n+    size_t free_memory = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::free_memory(free_memory);\n+    julong max_threads = free_memory \/ (20 * M);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -978,1 +978,1 @@\n-    return os::physical_memory();\n+    return static_cast<jlong>(os::physical_memory());\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+FORBID_C_FUNCTION(int snprintf(char*, size_t, const char*, ...), \"use os::snprintf\");\n","filename":"src\/hotspot\/share\/utilities\/forbiddenFunctions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-const int LockingMode = LM_LIGHTWEIGHT;\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+\/\/ offset_of was a workaround for UB with offsetof uses that are no longer an\n+\/\/ issue.  This can be removed once all uses have been converted.\n+#define offset_of(klass, field) offsetof(klass, field)\n@@ -644,8 +647,0 @@\n-\/\/ the fancy casts are a hopefully portable way\n-\/\/ to do unsigned 32 to 64 bit type conversion\n-inline void set_low (jlong* value, jint low )    { *value &= (jlong)0xffffffff << 32;\n-                                                   *value |= (jlong)(julong)(juint)low; }\n-\n-inline void set_high(jlong* value, jint high)    { *value &= (jlong)(julong)(juint)0xffffffff;\n-                                                   *value |= (jlong)high       << 32; }\n-\n@@ -653,4 +648,4 @@\n-  jlong result = 0; \/\/ initialization to avoid warning\n-  set_high(&result, h);\n-  set_low(&result,  l);\n-  return result;\n+  \/\/ First cast jint values to juint, so cast to julong will zero-extend.\n+  julong high = (julong)(juint)h << 32;\n+  julong low = (julong)(juint)l;\n+  return (jlong)(high | low);\n@@ -1012,11 +1007,0 @@\n-enum LockingMode {\n-  \/\/ Use only heavy monitors for locking\n-  LM_MONITOR     = 0,\n-  \/\/ Legacy stack-locking, with monitors as 2nd tier\n-  LM_LEGACY      = 1,\n-  \/\/ New lightweight locking, with monitors as 2nd tier\n-  LM_LIGHTWEIGHT = 2\n-};\n-\n-extern const int LockingMode;\n-\n@@ -1335,1 +1319,1 @@\n-\/\/ Default hash\/equals functions used by ResourceHashtable\n+\/\/ Default hash\/equals functions used by HashTable\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -87,18 +87,0 @@\n-\n-\/\/ gcc warns about applying offsetof() to non-POD object or calculating\n-\/\/ offset directly when base address is null. The -Wno-invalid-offsetof\n-\/\/ option could be used to suppress this warning, but we instead just\n-\/\/ avoid the use of offsetof().\n-\/\/\n-\/\/ FIXME: This macro is complex and rather arcane. Perhaps we should\n-\/\/ use offsetof() instead, with the invalid-offsetof warning\n-\/\/ temporarily disabled.\n-#define offset_of(klass,field)                          \\\n-([]() {                                                 \\\n-  alignas(16) char space[sizeof (klass)];               \\\n-  klass* dummyObj = (klass*)space;                      \\\n-  char* c = (char*)(void*)&dummyObj->field;             \\\n-  return (size_t)(c - space);                           \\\n-}())\n-\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -88,2 +88,0 @@\n-#define offset_of(klass,field) offsetof(klass,field)\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,6 +96,0 @@\n-\n-  void  clear()                 { _len = 0; }\n-  void  trunc_to(int length)    {\n-    assert(length <= _len,\"cannot increase length\");\n-    _len = length;\n-  }\n@@ -192,5 +186,0 @@\n-  E pop() {\n-    assert(_len > 0, \"empty list\");\n-    return _data[--_len];\n-  }\n-\n@@ -250,53 +239,0 @@\n-  \/\/ Order preserving remove operations.\n-\n-  void remove(const E& elem) {\n-    \/\/ Assuming that element does exist.\n-    bool removed = remove_if_existing(elem);\n-    if (removed) return;\n-    ShouldNotReachHere();\n-  }\n-\n-  bool remove_if_existing(const E& elem) {\n-    \/\/ Returns TRUE if elem is removed.\n-    for (int i = 0; i < _len; i++) {\n-      if (_data[i] == elem) {\n-        remove_at(i);\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-\n-  void remove_at(int index) {\n-    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n-    for (int j = index + 1; j < _len; j++) {\n-      _data[j-1] = _data[j];\n-    }\n-    _len--;\n-  }\n-\n-  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n-  void remove_till(int idx) {\n-    remove_range(0, idx);\n-  }\n-\n-  \/\/ Remove all elements in the range [start - end). The order is preserved.\n-  void remove_range(int start, int end) {\n-    assert(0 <= start, \"illegal start index %d\", start);\n-    assert(start < end && end <= _len, \"erase called with invalid range (%d, %d) for length %d\", start, end, _len);\n-\n-    for (int i = start, j = end; j < length(); i++, j++) {\n-      at_put(i, at(j));\n-    }\n-    trunc_to(length() - (end - start));\n-  }\n-\n-  \/\/ The order is changed.\n-  void delete_at(int index) {\n-    assert(0 <= index && index < _len, \"illegal index %d for length %d\", index, _len);\n-    if (index < --_len) {\n-      \/\/ Replace removed element with last one.\n-      _data[index] = _data[_len];\n-    }\n-  }\n-\n@@ -430,0 +366,5 @@\n+  E pop() {\n+    assert(this->_len > 0, \"empty list\");\n+    return this->_data[--this->_len];\n+  }\n+\n@@ -517,0 +458,61 @@\n+  void trunc_to(int length) {\n+    assert(length <= this->_len,\"cannot increase length\");\n+    this->_len = length;\n+  }\n+\n+  \/\/ Order preserving remove operations.\n+\n+  void remove_at(int index) {\n+    assert(0 <= index && index < this->_len,\n+           \"illegal index %d for length %d\", index, this->_len);\n+    for (int j = index + 1; j < this->_len; j++) {\n+      this->_data[j-1] = this->_data[j];\n+    }\n+    this->_len--;\n+  }\n+\n+  void remove(const E& elem) {\n+    \/\/ Assuming that element does exist.\n+    bool removed = this->remove_if_existing(elem);\n+    if (removed) return;\n+    ShouldNotReachHere();\n+  }\n+\n+  bool remove_if_existing(const E& elem) {\n+    \/\/ Returns TRUE if elem is removed.\n+    for (int i = 0; i < this->_len; i++) {\n+      if (this->_data[i] == elem) {\n+        this->remove_at(i);\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Remove all elements up to the index (exclusive). The order is preserved.\n+  void remove_till(int idx) {\n+    remove_range(0, idx);\n+  }\n+\n+  \/\/ Remove all elements in the range [start - end). The order is preserved.\n+  void remove_range(int start, int end) {\n+    assert(0 <= start, \"illegal start index %d\", start);\n+    assert(start < end && end <= this->_len,\n+           \"erase called with invalid range (%d, %d) for length %d\",\n+           start, end, this->_len);\n+\n+    for (int i = start, j = end; j < this->length(); i++, j++) {\n+      this->at_put(i, this->at(j));\n+    }\n+    this->_len -= (end - start);\n+  }\n+\n+  \/\/ Replaces the designated element with the last element and shrinks by 1.\n+  void delete_at(int index) {\n+    assert(0 <= index && index < this->_len, \"illegal index %d for length %d\", index, this->_len);\n+    if (index < --this->_len) {\n+      \/\/ Replace removed element with last one.\n+      this->_data[index] = this->_data[this->_len];\n+    }\n+  }\n+\n@@ -520,0 +522,1 @@\n+  void clear() { this->_len = 0; }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":67,"deletions":64,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -0,0 +1,380 @@\n+\/*\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_HASHTABLE_HPP\n+#define SHARE_UTILITIES_HASHTABLE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+#include \"utilities\/tableStatistics.hpp\"\n+\n+#include <type_traits>\n+\n+template<typename K, typename V>\n+class HashTableNode : public AnyObj {\n+public:\n+  unsigned _hash;\n+  K _key;\n+  V _value;\n+  HashTableNode* _next;\n+\n+  HashTableNode(unsigned hash, K const& key, V const& value,\n+                        HashTableNode* next = nullptr) :\n+    _hash(hash), _key(key), _value(value), _next(next) {}\n+\n+  \/\/ Create a node with a default-constructed value.\n+  HashTableNode(unsigned hash, K const& key,\n+                        HashTableNode* next = nullptr) :\n+    _hash(hash), _key(key), _value(), _next(next) {}\n+};\n+\n+template<\n+    class STORAGE,\n+    typename K, typename V,\n+    AnyObj::allocation_type ALLOC_TYPE,\n+    MemTag MEM_TAG,\n+    unsigned (*HASH)  (K const&),\n+    bool     (*EQUALS)(K const&, K const&)\n+    >\n+class HashTableBase : public STORAGE {\n+  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<K>::value,\n+                \"Destructor for K is only called with C_HEAP\");\n+  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<V>::value,\n+                \"Destructor for V is only called with C_HEAP\");\n+  using Node = HashTableNode<K, V>;\n+ private:\n+  int _number_of_entries;\n+\n+  Node** bucket_at(unsigned index) {\n+    Node** t = table();\n+    return &t[index];\n+  }\n+\n+  const Node* const* bucket_at(unsigned index) const {\n+    Node** t = table();\n+    return &t[index];\n+  }\n+\n+  \/\/ Returns a pointer to where the node where the value would reside if\n+  \/\/ it's in the table.\n+  Node** lookup_node(unsigned hash, K const& key) {\n+    unsigned index = hash % table_size();\n+    Node** ptr = bucket_at(index);\n+    while (*ptr != nullptr) {\n+      Node* node = *ptr;\n+      if (node->_hash == hash && EQUALS(key, node->_key)) {\n+        break;\n+      }\n+      ptr = &(node->_next);\n+    }\n+    return ptr;\n+  }\n+\n+  Node const** lookup_node(unsigned hash, K const& key) const {\n+    return const_cast<Node const**>(\n+        const_cast<HashTableBase*>(this)->lookup_node(hash, key));\n+  }\n+\n+ protected:\n+  Node** table() const { return STORAGE::table(); }\n+\n+  HashTableBase() : STORAGE(), _number_of_entries(0) {}\n+  HashTableBase(unsigned size) : STORAGE(size), _number_of_entries(0) {}\n+  NONCOPYABLE(HashTableBase);\n+\n+  ~HashTableBase() {\n+    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+      Node* const* bucket = table();\n+      const unsigned sz = table_size();\n+      while (bucket < bucket_at(sz)) {\n+        Node* node = *bucket;\n+        while (node != nullptr) {\n+          Node* cur = node;\n+          node = node->_next;\n+          delete cur;\n+        }\n+        ++bucket;\n+      }\n+    }\n+  }\n+\n+ public:\n+  unsigned table_size() const { return STORAGE::table_size(); }\n+  int number_of_entries() const { return _number_of_entries; }\n+\n+  bool contains(K const& key) const {\n+    return get(key) != nullptr;\n+  }\n+\n+  V* get(K const& key) const {\n+    unsigned hv = HASH(key);\n+    Node const** ptr = lookup_node(hv, key);\n+    if (*ptr != nullptr) {\n+      return const_cast<V*>(&(*ptr)->_value);\n+    } else {\n+      return nullptr;\n+    }\n+  }\n+\n+ \/**\n+  * Inserts a value in the front of the table, assuming that\n+  * the entry is absent.\n+  * The table must be locked for the get or test that the entry\n+  * is absent, and for this operation.\n+  * This is a faster variant of put_if_absent because it adds to the\n+  * head of the bucket, and doesn't search the bucket.\n+  * @return: true: a new item is always added\n+  *\/\n+  bool put_when_absent(K const& key, V const& value) {\n+    unsigned hv = HASH(key);\n+    unsigned index = hv % table_size();\n+    assert(*lookup_node(hv, key) == nullptr, \"use put_if_absent\");\n+    Node** ptr = bucket_at(index);\n+    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+      *ptr = new (MEM_TAG) Node(hv, key, value, *ptr);\n+    } else {\n+      *ptr = new Node(hv, key, value, *ptr);\n+    }\n+    _number_of_entries ++;\n+    return true;\n+  }\n+\n+ \/**\n+  * Inserts or replaces a value in the table.\n+  * @return: true:  if a new item is added\n+  *          false: if the item already existed and the value is updated\n+  *\/\n+  bool put(K const& key, V const& value) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+    if (*ptr != nullptr) {\n+      (*ptr)->_value = value;\n+      return false;\n+    } else {\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        *ptr = new (MEM_TAG) Node(hv, key, value);\n+      } else {\n+        *ptr = new Node(hv, key, value);\n+      }\n+      _number_of_entries ++;\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Look up the key.\n+  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n+  \/\/ If no entry for the key exists, create a new entry from key and a default-created value\n+  \/\/  and return a pointer to the value.\n+  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n+  V* put_if_absent(K const& key, bool* p_created) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+    if (*ptr == nullptr) {\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        *ptr = new (MEM_TAG) Node(hv, key);\n+      } else {\n+        *ptr = new Node(hv, key);\n+      }\n+      *p_created = true;\n+      _number_of_entries ++;\n+    } else {\n+      *p_created = false;\n+    }\n+    return &(*ptr)->_value;\n+  }\n+\n+  \/\/ Look up the key.\n+  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n+  \/\/ If no entry for the key exists, create a new entry from key and value and return a\n+  \/\/  pointer to the value.\n+  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n+  V* put_if_absent(K const& key, V const& value, bool* p_created) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+    if (*ptr == nullptr) {\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        *ptr = new (MEM_TAG) Node(hv, key, value);\n+      } else {\n+        *ptr = new Node(hv, key, value);\n+      }\n+      *p_created = true;\n+      _number_of_entries ++;\n+    } else {\n+      *p_created = false;\n+    }\n+    return &(*ptr)->_value;\n+  }\n+\n+  template<typename Function>\n+  bool remove(K const& key, Function function) {\n+    unsigned hv = HASH(key);\n+    Node** ptr = lookup_node(hv, key);\n+\n+    Node* node = *ptr;\n+    if (node != nullptr) {\n+      *ptr = node->_next;\n+      function(node->_key, node->_value);\n+      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+        delete node;\n+      }\n+      _number_of_entries --;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  bool remove(K const& key) {\n+    auto dummy = [&] (K& k, V& v) { };\n+    return remove(key, dummy);\n+  }\n+\n+  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n+  \/\/ called for each entry in the table.  If do_entry() returns false,\n+  \/\/ the iteration is cancelled.\n+  template<class ITER>\n+  void iterate(ITER* iter) const {\n+    auto function = [&] (K& k, V& v) {\n+      return iter->do_entry(k, v);\n+    };\n+    iterate(function);\n+  }\n+\n+  template<typename Function>\n+  void iterate(Function function) const { \/\/ lambda enabled API\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    int cnt = _number_of_entries;\n+\n+    while (cnt > 0 && bucket < bucket_at(sz)) {\n+      Node* node = *bucket;\n+      while (node != nullptr) {\n+        bool cont = function(node->_key, node->_value);\n+        if (!cont) { return; }\n+        node = node->_next;\n+        --cnt;\n+      }\n+      ++bucket;\n+    }\n+  }\n+\n+  \/\/ same as above, but unconditionally iterate all entries\n+  template<typename Function>\n+  void iterate_all(Function function) const { \/\/ lambda enabled API\n+    auto wrapper = [&] (K& k, V& v) {\n+      function(k, v);\n+      return true;\n+    };\n+    iterate(wrapper);\n+  }\n+\n+  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n+  \/\/ called for each entry in the table.  If do_entry() returns true,\n+  \/\/ the entry is deleted.\n+  template<class ITER>\n+  void unlink(ITER* iter) {\n+    const unsigned sz = table_size();\n+    for (unsigned index = 0; index < sz; index++) {\n+      Node** ptr = bucket_at(index);\n+      while (*ptr != nullptr) {\n+        Node* node = *ptr;\n+        \/\/ do_entry must clean up the key and value in Node.\n+        bool clean = iter->do_entry(node->_key, node->_value);\n+        if (clean) {\n+          *ptr = node->_next;\n+          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+            delete node;\n+          }\n+          _number_of_entries --;\n+        } else {\n+          ptr = &(node->_next);\n+        }\n+      }\n+    }\n+  }\n+\n+  template<typename Function>\n+  TableStatistics statistics_calculate(Function size_function) const {\n+    NumberSeq summary;\n+    size_t literal_bytes = 0;\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    while (bucket < bucket_at(sz)) {\n+      Node* node = *bucket;\n+      int count = 0;\n+      while (node != nullptr) {\n+        literal_bytes += size_function(node->_key, node->_value);\n+        count++;\n+        node = node->_next;\n+      }\n+      summary.add((double)count);\n+      ++bucket;\n+    }\n+    return TableStatistics(summary, literal_bytes, sizeof(Node*), sizeof(Node));\n+  }\n+\n+  \/\/ This method calculates the \"shallow\" size. If you want the recursive size, use statistics_calculate.\n+  size_t mem_size() const {\n+    return sizeof(*this) +\n+      table_size() * sizeof(Node*) +\n+      number_of_entries() * sizeof(Node);\n+  }\n+};\n+\n+template<unsigned TABLE_SIZE, typename K, typename V>\n+class FixedHashTableStorage : public AnyObj {\n+  using Node = HashTableNode<K, V>;\n+\n+  Node* _table[TABLE_SIZE];\n+protected:\n+  FixedHashTableStorage() { memset(_table, 0, sizeof(_table)); }\n+  ~FixedHashTableStorage() = default;\n+\n+  constexpr unsigned table_size() const {\n+    return TABLE_SIZE;\n+  }\n+\n+  Node** table() const {\n+    return const_cast<Node**>(_table);\n+  }\n+};\n+\n+template<\n+    typename K, typename V,\n+    unsigned SIZE = 256,\n+    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n+    MemTag MEM_TAG = mtInternal,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n+    >\n+class HashTable : public HashTableBase<\n+  FixedHashTableStorage<SIZE, K, V>,\n+    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n+  NONCOPYABLE(HashTable);\n+public:\n+  HashTable() : HashTableBase<FixedHashTableStorage<SIZE, K, V>,\n+                                              K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>() {}\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_HASHTABLE_HPP\n","filename":"src\/hotspot\/share\/utilities\/hashTable.hpp","additions":380,"deletions":0,"binary":false,"changes":380,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n@@ -55,1 +55,1 @@\n-  typedef ResizeableResourceHashtable<uintptr_t, CHeapBitMap*, AnyObj::C_HEAP, MT,\n+  typedef ResizeableHashTable<uintptr_t, CHeapBitMap*, AnyObj::C_HEAP, MT,\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  \/\/ destructors for ResourceHashtable base deletes nodes, and\n-  \/\/ ResizeableResourceHashtableStorage deletes the table.\n+  \/\/ destructors for HashTable base deletes nodes, and\n+  \/\/ ResizeableHashTableStorage deletes the table.\n","filename":"src\/hotspot\/share\/utilities\/objectBitSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -995,2 +995,3 @@\n-  delete defaultStream::instance;\n-  xtty = nullptr;\n+  \/\/ Keep xtty usable as long as possible by ensuring we null it out before\n+  \/\/ deleting anything.\n+  defaultStream* ds = defaultStream::instance;\n@@ -998,0 +999,3 @@\n+  xtty = nullptr;\n+  OrderAccess::fence(); \/\/ force visibility to concurrently executing threads\n+  delete ds;\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,11 +38,7 @@\n-\/\/     - an int < 0 when a < b\n-\/\/     - an int == 0 when a == b\n-\/\/     - an int > 0 when a > b\n-\/\/ Additional static functions used for extra validation can optionally be provided:\n-\/\/   `cmp(K a, K b)` which returns:\n-\/\/       - an int < 0 when a < b\n-\/\/       - an int == 0 when a == b\n-\/\/       - an int > 0 when a > b\n-\/\/   `cmp(const IntrusiveRBNode* a, const IntrusiveRBNode* b)` which returns:\n-\/\/       - true if a < b\n-\/\/       - false otherwise\n+\/\/     - RBTreeOrdering::LT when a < b\n+\/\/     - RBTreeOrdering::EQ when a == b\n+\/\/     - RBTreeOrdering::GT when a > b\n+\/\/ A second static function `less_than(const IntrusiveRBNode* a, const IntrusiveRBNode* b)`\n+\/\/ used for extra validation can optionally be provided. This should return:\n+\/\/     - true if a < b\n+\/\/     - false otherwise\n@@ -57,4 +53,4 @@\n-\/\/     - an int < 0 when a < b\n-\/\/     - an int == 0 when a == b\n-\/\/     - an int > 0 when a > b\n-\/\/ A second static function `cmp(const RBNode<K, V>* a, const RBNode<K, V>* b)`\n+\/\/     - RBTreeOrdering::LT when a < b\n+\/\/     - RBTreeOrdering::EQ when a == b\n+\/\/     - RBTreeOrdering::GT when a > b\n+\/\/ A second static function `less_than(const RBNode<K, V>* a, const RBNode<K, V>* b)`\n@@ -64,1 +60,0 @@\n-\/\/ ALLOCATOR must check for oom and exit, as RBTree does not handle the allocation failing.\n@@ -69,0 +64,2 @@\n+enum class RBTreeOrdering : int { LT, EQ, GT };\n+\n@@ -130,1 +127,1 @@\n-  template <typename NodeType, typename NodeVerifier>\n+  template <typename NodeType, typename NODE_VERIFIER, typename USER_VERIFIER>\n@@ -133,1 +130,2 @@\n-              size_t& tree_depth, bool expect_visited, NodeVerifier verifier) const;\n+              size_t& tree_depth, bool expect_visited, NODE_VERIFIER verifier,\n+              const USER_VERIFIER& extra_verifier) const;\n@@ -207,1 +205,1 @@\n-  static constexpr bool HasKeyComparator = has_cmp_type<CMP, int, K, K>::value;\n+  static constexpr bool HasKeyComparator = has_cmp_type<CMP, RBTreeOrdering, K, K>::value;\n@@ -210,1 +208,6 @@\n-  static constexpr bool HasNodeComparator = has_cmp_type<CMP, int, K, const NodeType*>::value;\n+  static constexpr bool HasNodeComparator = has_cmp_type<CMP, RBTreeOrdering, K, const NodeType*>::value;\n+\n+  template <typename CMP, typename RET, typename ARG1, typename ARG2, typename = void>\n+  struct has_less_than_type : std::false_type {};\n+  template <typename CMP, typename RET, typename ARG1, typename ARG2>\n+  struct has_less_than_type<CMP, RET, ARG1, ARG2, decltype(static_cast<RET(*)(ARG1, ARG2)>(CMP::less), void())> : std::true_type {};\n@@ -213,1 +216,1 @@\n-  static constexpr bool HasNodeVerifier = has_cmp_type<CMP, bool, const NodeType*, const NodeType*>::value;\n+  static constexpr bool HasNodeVerifier = has_less_than_type<CMP, bool, const NodeType*, const NodeType*>::value;\n@@ -216,1 +219,1 @@\n-  int cmp(const K& a, const NodeType* b) const {\n+  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n@@ -221,1 +224,1 @@\n-  int cmp(const K& a, const NodeType* b) const {\n+  RBTreeOrdering cmp(const K& a, const NodeType* b) const {\n@@ -226,1 +229,1 @@\n-  bool cmp(const NodeType* a, const NodeType* b) const {\n+  bool less_than(const NodeType* a, const NodeType* b) const {\n@@ -231,2 +234,2 @@\n-  bool cmp(const NodeType* a, const NodeType* b) const {\n-    return COMPARATOR::cmp(a, b);\n+  bool less_than(const NodeType* a, const NodeType* b) const {\n+    return COMPARATOR::less_than(a, b);\n@@ -241,1 +244,1 @@\n-    assert(COMPARATOR::cmp(a, b) <= 0, \"key a must be less or equal to key b\");\n+    assert(COMPARATOR::cmp(a, b) != RBTreeOrdering::GT, \"key a must be less or equal to key b\");\n@@ -260,2 +263,5 @@\n-  template <typename NodeVerifier>\n-  void verify_self(NodeVerifier verifier) const;\n+  struct empty_verifier {\n+    bool operator()(const NodeType* n) const {\n+      return true;\n+    }\n+  };\n@@ -263,1 +269,11 @@\n-  void print_node_on(outputStream* st, int depth, const NodeType* n) const;\n+  template <typename NODE_VERIFIER, typename USER_VERIFIER>\n+  void verify_self(NODE_VERIFIER verifier, const USER_VERIFIER& extra_verifier) const;\n+\n+  struct default_printer {\n+    void operator()(outputStream* st, const NodeType* n, int depth) const {\n+      n->print_on(st, depth);\n+    }\n+  };\n+\n+  template <typename PRINTER>\n+  void print_node_on(outputStream* st, int depth, const NodeType* n, const PRINTER& node_printer) const;\n@@ -426,3 +442,6 @@\n-  template <typename CMP = COMPARATOR, ENABLE_IF(HasNodeVerifier<CMP>)>\n-  void verify_self() const {\n-    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::cmp(a, b);});\n+  \/\/ Accepts an optional callable `bool extra_verifier(const Node* n)`.\n+  \/\/ This should return true if the node is valid.\n+  \/\/ If provided, each node is also verified through this callable.\n+  template <typename USER_VERIFIER = empty_verifier, typename CMP = COMPARATOR, ENABLE_IF(HasNodeVerifier<CMP>)>\n+  void verify_self(const USER_VERIFIER& extra_verifier = USER_VERIFIER()) const {\n+    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::less_than(a, b);}, extra_verifier);\n@@ -431,3 +450,4 @@\n-  template <typename CMP = COMPARATOR, ENABLE_IF(HasKeyComparator<CMP> && !HasNodeVerifier<CMP>)>\n-  void verify_self() const {\n-    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::cmp(a->key(), b->key()) < 0; });\n+  template <typename USER_VERIFIER = empty_verifier, typename CMP = COMPARATOR,\n+            ENABLE_IF(HasKeyComparator<CMP> && !HasNodeVerifier<CMP>)>\n+  void verify_self(const USER_VERIFIER& extra_verifier = USER_VERIFIER()) const {\n+    verify_self([](const NodeType* a, const NodeType* b){ return COMPARATOR::cmp(a->key(), b->key()) == RBTreeOrdering::LT; }, extra_verifier);\n@@ -436,3 +456,4 @@\n-  template <typename CMP = COMPARATOR, ENABLE_IF(HasNodeComparator<CMP> && !HasKeyComparator<CMP> && !HasNodeVerifier<CMP>)>\n-  void verify_self() const {\n-    verify_self([](const NodeType*, const NodeType*){ return true;});\n+  template <typename USER_VERIFIER = empty_verifier, typename CMP = COMPARATOR,\n+            ENABLE_IF(HasNodeComparator<CMP> && !HasKeyComparator<CMP> && !HasNodeVerifier<CMP>)>\n+  void verify_self(const USER_VERIFIER& extra_verifier = USER_VERIFIER()) const {\n+    verify_self([](const NodeType*, const NodeType*){ return true;}, extra_verifier);\n@@ -441,1 +462,4 @@\n-  void print_on(outputStream* st) const;\n+  \/\/ Accepts an optional printing callable `void node_printer(outputStream* st, const Node* n, int depth)`.\n+  \/\/ If provided, each node is printed through this callable rather than the default `print_on`.\n+  template <typename PRINTER = default_printer>\n+  void print_on(outputStream* st, const PRINTER& node_printer = PRINTER()) const;\n@@ -455,0 +479,8 @@\n+  RBTree(const RBTree& other) : BaseType(), _allocator() {\n+    assert(std::is_copy_constructible<V>(), \"Value type must be copy-constructible\");\n+    other.visit_in_order([&](auto node) {\n+      this->upsert(node->key(), node->val());\n+      return true;\n+    });\n+  }\n+  RBTree& operator=(const RBTree& other) = delete;\n@@ -471,1 +503,3 @@\n-    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    if (node_place == nullptr) {\n+      return nullptr;\n+    }\n@@ -477,1 +511,3 @@\n-    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    if (node_place == nullptr) {\n+      return nullptr;\n+    }\n@@ -488,1 +524,2 @@\n-  void upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr) {\n+  \/\/ Returns false if and only if allocation of a new node failed.\n+  bool upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr) {\n@@ -493,1 +530,1 @@\n-      return;\n+      return true;\n@@ -497,0 +534,3 @@\n+    if (node == nullptr) {\n+      return false;\n+    }\n@@ -498,0 +538,1 @@\n+    return true;\n@@ -548,1 +589,1 @@\n-template <MemTag mem_tag>\n+template <MemTag mem_tag, AllocFailType strategy>\n@@ -553,1 +594,1 @@\n-    if (allocation == nullptr) {\n+    if (allocation == nullptr && strategy == AllocFailStrategy::EXIT_OOM) {\n@@ -563,2 +604,2 @@\n-template <typename K, typename V, typename COMPARATOR, MemTag mem_tag>\n-using RBTreeCHeap = RBTree<K, V, COMPARATOR, RBTreeCHeapAllocator<mem_tag>>;\n+template <typename K, typename V, typename COMPARATOR, MemTag mem_tag, AllocFailType strategy = AllocFailStrategy::EXIT_OOM>\n+using RBTreeCHeap = RBTree<K, V, COMPARATOR, RBTreeCHeapAllocator<mem_tag, strategy>>;\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":89,"deletions":48,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-template <typename NodeType, typename NodeVerifier>\n+template <typename NodeType, typename NODE_VERIFIER, typename USER_VERIFIER>\n@@ -129,1 +129,3 @@\n-    size_t& tree_depth, bool expect_visited, NodeVerifier verifier) const {\n+    size_t& tree_depth, bool expect_visited, NODE_VERIFIER verifier, const USER_VERIFIER& extra_verifier) const {\n+  bool extra_verifier_result = extra_verifier(static_cast<const NodeType*>(this));\n+  assert(extra_verifier_result, \"user provided verifier failed\");\n@@ -146,1 +148,1 @@\n-                  longest_leaf_path_left, tree_depth_left, expect_visited, verifier);\n+                  longest_leaf_path_left, tree_depth_left, expect_visited, verifier, extra_verifier);\n@@ -162,1 +164,1 @@\n-                   longest_leaf_path_right, tree_depth_right, expect_visited, verifier);\n+                   longest_leaf_path_right, tree_depth_right, expect_visited, verifier, extra_verifier);\n@@ -193,1 +195,1 @@\n-    const int hint_cmp = cmp(key, hint_node);\n+    const RBTreeOrdering hint_cmp = cmp(key, hint_node);\n@@ -195,1 +197,1 @@\n-      const int parent_cmp = cmp(key, (NodeType*)hint_node->parent());\n+      const RBTreeOrdering parent_cmp = cmp(key, (NodeType*)hint_node->parent());\n@@ -198,2 +200,2 @@\n-      if ((parent_cmp <= 0 && hint_cmp < 0) ||\n-          (parent_cmp >= 0 && hint_cmp > 0)) {\n+      if ((parent_cmp != RBTreeOrdering::GT && hint_cmp == RBTreeOrdering::LT) ||\n+          (parent_cmp != RBTreeOrdering::LT    && hint_cmp == RBTreeOrdering::GT)) {\n@@ -215,1 +217,1 @@\n-    const int key_cmp_k = cmp(key, curr);\n+    const RBTreeOrdering key_cmp_k = cmp(key, curr);\n@@ -217,1 +219,1 @@\n-    if (key_cmp_k == 0) {\n+    if (key_cmp_k == RBTreeOrdering::EQ) {\n@@ -222,1 +224,1 @@\n-    if (key_cmp_k < 0) {\n+    if (key_cmp_k == RBTreeOrdering::LT) {\n@@ -554,1 +556,1 @@\n-    assert(cmp(static_cast<const NodeType*>(new_node), static_cast<const NodeType*>(new_node->parent())), \"new node not < parent\");\n+    assert(less_than(static_cast<const NodeType*>(new_node), static_cast<const NodeType*>(new_node->parent())), \"new node not < parent\");\n@@ -556,1 +558,1 @@\n-    assert(cmp(static_cast<const NodeType*>(new_node->parent()), static_cast<const NodeType*>(new_node)), \"new node not > parent\");\n+    assert(less_than(static_cast<const NodeType*>(new_node->parent()), static_cast<const NodeType*>(new_node)), \"new node not > parent\");\n@@ -562,1 +564,1 @@\n-    assert(cmp(static_cast<const NodeType*>(new_node->_left), static_cast<const NodeType*>(new_node)), \"left child not < new node\");\n+    assert(less_than(static_cast<const NodeType*>(new_node->_left), static_cast<const NodeType*>(new_node)), \"left child not < new node\");\n@@ -566,1 +568,1 @@\n-    assert(cmp(static_cast<const NodeType*>(new_node), static_cast<const NodeType*>(new_node->_right)), \"right child not > new node\");\n+    assert(less_than(static_cast<const NodeType*>(new_node), static_cast<const NodeType*>(new_node->_right)), \"right child not > new node\");\n@@ -664,2 +666,2 @@\n-template <typename NodeVerifier>\n-inline void AbstractRBTree<K, NodeType, COMPARATOR>::verify_self(NodeVerifier verifier) const {\n+template <typename NODE_VERIFIER, typename USER_VERIFIER>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::verify_self(NODE_VERIFIER verifier, const USER_VERIFIER& extra_verifier) const {\n@@ -682,1 +684,1 @@\n-                tree_depth, expected_visited, verifier);\n+                tree_depth, expected_visited, verifier, extra_verifier);\n@@ -734,2 +736,3 @@\n-void AbstractRBTree<K, NodeType, COMPARATOR>::print_node_on(outputStream* st, int depth, const NodeType* n) const {\n-  n->print_on(st, depth);\n+template <typename PRINTER>\n+void AbstractRBTree<K, NodeType, COMPARATOR>::print_node_on(outputStream* st, int depth, const NodeType* n, const PRINTER& node_printer) const {\n+  node_printer(st, n, depth);\n@@ -737,3 +740,0 @@\n-  if (n->_right != nullptr) {\n-    print_node_on(st, depth, (NodeType*)n->_right);\n-  }\n@@ -741,1 +741,4 @@\n-    print_node_on(st, depth, (NodeType*)n->_left);\n+    print_node_on(st, depth, (NodeType*)n->_left, node_printer);\n+  }\n+  if (n->_right != nullptr) {\n+    print_node_on(st, depth, (NodeType*)n->_right, node_printer);\n@@ -746,1 +749,2 @@\n-void AbstractRBTree<K, NodeType, COMPARATOR>::print_on(outputStream* st) const {\n+template <typename PRINTER>\n+void AbstractRBTree<K, NodeType, COMPARATOR>::print_on(outputStream* st, const PRINTER& node_printer) const {\n@@ -748,1 +752,1 @@\n-    print_node_on(st, 0, (NodeType*)_root);\n+    print_node_on(st, 0, (NodeType*)_root, node_printer);\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":30,"deletions":26,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RESIZEABLEHASHTABLE_HPP\n+#define SHARE_UTILITIES_RESIZEABLEHASHTABLE_HPP\n+\n+#include \"utilities\/hashTable.hpp\"\n+\n+template<\n+    typename K, typename V,\n+    AnyObj::allocation_type ALLOC_TYPE,\n+    MemTag MEM_TAG>\n+class ResizeableHashTableStorage : public AnyObj {\n+  using Node = HashTableNode<K, V>;\n+\n+protected:\n+  unsigned _table_size;\n+  Node** _table;\n+\n+  ResizeableHashTableStorage(unsigned table_size) {\n+    _table_size = table_size;\n+    _table = alloc_table(table_size);\n+  }\n+\n+  ~ResizeableHashTableStorage() {\n+    if (ALLOC_TYPE == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(Node*, _table);\n+    }\n+  }\n+\n+  Node** alloc_table(unsigned table_size) {\n+    Node** table;\n+    if (ALLOC_TYPE == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(Node*, table_size, MEM_TAG);\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(Node*, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(Node*));\n+    return table;\n+  }\n+\n+  unsigned table_size() const {\n+    return _table_size;\n+  }\n+\n+  Node** table() const {\n+    return _table;\n+  }\n+};\n+\n+template<\n+    typename K, typename V,\n+    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n+    MemTag MEM_TAG = mtInternal,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n+    >\n+class ResizeableHashTable : public HashTableBase<\n+    ResizeableHashTableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n+    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n+  unsigned _max_size;\n+\n+  using BASE = HashTableBase<ResizeableHashTableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n+                                     K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>;\n+  using Node = HashTableNode<K, V>;\n+  NONCOPYABLE(ResizeableHashTable);\n+\n+  \/\/ Calculate next \"good\" hashtable size based on requested count\n+  int calculate_resize(bool use_large_table_sizes) const {\n+    const int resize_factor = 2;     \/\/ by how much we will resize using current number of entries\n+\n+    \/\/ possible hashmap sizes - odd primes that roughly double in size.\n+    \/\/ To avoid excessive resizing the odd primes from 4801-76831 and\n+    \/\/ 76831-307261 have been removed.\n+    const int large_table_sizes[] =  { 107, 1009, 2017, 4049, 5051, 10103, 20201,\n+                                       40423, 76831, 307261, 614563, 1228891, 2457733,\n+                                       4915219, 9830479, 19660831, 39321619, 78643219 };\n+    const int large_array_size = sizeof(large_table_sizes)\/sizeof(int);\n+\n+    int requested = resize_factor * BASE::number_of_entries();\n+    int start_at = use_large_table_sizes ? 8 : 0;\n+    int newsize;\n+    for (int i = start_at; i < large_array_size; i++) {\n+      newsize = large_table_sizes[i];\n+      if (newsize >= requested) {\n+        return newsize;\n+      }\n+    }\n+    return requested; \/\/ greater than a size in the table\n+  }\n+\n+public:\n+  ResizeableHashTable(unsigned size, unsigned max_size)\n+  : BASE(size), _max_size(max_size) {\n+    assert(size <= 0x3fffffff && max_size <= 0x3fffffff, \"avoid overflow in resize\");\n+  }\n+\n+  bool maybe_grow(int load_factor = 8, bool use_large_table_sizes = false) {\n+    unsigned old_size = BASE::_table_size;\n+    if (old_size >= _max_size) {\n+      return false;\n+    }\n+    if (BASE::number_of_entries() \/ int(old_size) > load_factor) {\n+      unsigned new_size = MIN2<unsigned>(calculate_resize(use_large_table_sizes), _max_size);\n+      resize(new_size);\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  void resize(unsigned new_size) {\n+    Node** old_table = BASE::_table;\n+    Node** new_table = BASE::alloc_table(new_size);\n+\n+    Node* const* bucket = old_table;\n+    while (bucket < &old_table[BASE::_table_size]) {\n+      Node* node = *bucket;\n+      while (node != nullptr) {\n+        Node* next = node->_next;\n+        unsigned hash = node->_hash;\n+        unsigned index = hash % new_size;\n+\n+        node->_next = new_table[index];\n+        new_table[index] = node;\n+\n+        node = next;\n+      }\n+      ++bucket;\n+    }\n+\n+    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+      FREE_C_HEAP_ARRAY(Node*, old_table);\n+    }\n+    BASE::_table = new_table;\n+    BASE::_table_size = new_size;\n+  }\n+\n+#ifdef ASSERT\n+  int verify() {\n+    Node** table = BASE::_table;\n+    \/\/ Return max bucket size.  If hashcode is broken, this will be\n+    \/\/ too high.\n+    int max_bucket_size = 0;\n+    int index = 0;\n+    Node* const* bucket = table;\n+    while (bucket < &table[BASE::_table_size]) {\n+      int count = 0;\n+      Node* node = *bucket;\n+      while (node != nullptr) {\n+        count++;\n+        node = node->_next;\n+      }\n+      max_bucket_size = MAX2(count, max_bucket_size);\n+      ++bucket;\n+    }\n+    return max_bucket_size;\n+  }\n+#endif \/\/ ASSERT\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_RESIZABLEHASHTABLE_HPP\n","filename":"src\/hotspot\/share\/utilities\/resizableHashTable.hpp","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n-#define SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n-\n-#include \"utilities\/resourceHash.hpp\"\n-\n-template<\n-    typename K, typename V,\n-    AnyObj::allocation_type ALLOC_TYPE,\n-    MemTag MEM_TAG>\n-class ResizeableResourceHashtableStorage : public AnyObj {\n-  using Node = ResourceHashtableNode<K, V>;\n-\n-protected:\n-  unsigned _table_size;\n-  Node** _table;\n-\n-  ResizeableResourceHashtableStorage(unsigned table_size) {\n-    _table_size = table_size;\n-    _table = alloc_table(table_size);\n-  }\n-\n-  ~ResizeableResourceHashtableStorage() {\n-    if (ALLOC_TYPE == C_HEAP) {\n-      FREE_C_HEAP_ARRAY(Node*, _table);\n-    }\n-  }\n-\n-  Node** alloc_table(unsigned table_size) {\n-    Node** table;\n-    if (ALLOC_TYPE == C_HEAP) {\n-      table = NEW_C_HEAP_ARRAY(Node*, table_size, MEM_TAG);\n-    } else {\n-      table = NEW_RESOURCE_ARRAY(Node*, table_size);\n-    }\n-    memset(table, 0, table_size * sizeof(Node*));\n-    return table;\n-  }\n-\n-  unsigned table_size() const {\n-    return _table_size;\n-  }\n-\n-  Node** table() const {\n-    return _table;\n-  }\n-};\n-\n-template<\n-    typename K, typename V,\n-    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n-    MemTag MEM_TAG = mtInternal,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n-    >\n-class ResizeableResourceHashtable : public ResourceHashtableBase<\n-    ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n-    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n-  unsigned _max_size;\n-\n-  using BASE = ResourceHashtableBase<ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TAG>,\n-                                     K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>;\n-  using Node = ResourceHashtableNode<K, V>;\n-  NONCOPYABLE(ResizeableResourceHashtable);\n-\n-  \/\/ Calculate next \"good\" hashtable size based on requested count\n-  int calculate_resize(bool use_large_table_sizes) const {\n-    const int resize_factor = 2;     \/\/ by how much we will resize using current number of entries\n-\n-    \/\/ possible hashmap sizes - odd primes that roughly double in size.\n-    \/\/ To avoid excessive resizing the odd primes from 4801-76831 and\n-    \/\/ 76831-307261 have been removed.\n-    const int large_table_sizes[] =  { 107, 1009, 2017, 4049, 5051, 10103, 20201,\n-                                       40423, 76831, 307261, 614563, 1228891, 2457733,\n-                                       4915219, 9830479, 19660831, 39321619, 78643219 };\n-    const int large_array_size = sizeof(large_table_sizes)\/sizeof(int);\n-\n-    int requested = resize_factor * BASE::number_of_entries();\n-    int start_at = use_large_table_sizes ? 8 : 0;\n-    int newsize;\n-    for (int i = start_at; i < large_array_size; i++) {\n-      newsize = large_table_sizes[i];\n-      if (newsize >= requested) {\n-        return newsize;\n-      }\n-    }\n-    return requested; \/\/ greater than a size in the table\n-  }\n-\n-public:\n-  ResizeableResourceHashtable(unsigned size, unsigned max_size)\n-  : BASE(size), _max_size(max_size) {\n-    assert(size <= 0x3fffffff && max_size <= 0x3fffffff, \"avoid overflow in resize\");\n-  }\n-\n-  bool maybe_grow(int load_factor = 8, bool use_large_table_sizes = false) {\n-    unsigned old_size = BASE::_table_size;\n-    if (old_size >= _max_size) {\n-      return false;\n-    }\n-    if (BASE::number_of_entries() \/ int(old_size) > load_factor) {\n-      unsigned new_size = MIN2<unsigned>(calculate_resize(use_large_table_sizes), _max_size);\n-      resize(new_size);\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  void resize(unsigned new_size) {\n-    Node** old_table = BASE::_table;\n-    Node** new_table = BASE::alloc_table(new_size);\n-\n-    Node* const* bucket = old_table;\n-    while (bucket < &old_table[BASE::_table_size]) {\n-      Node* node = *bucket;\n-      while (node != nullptr) {\n-        Node* next = node->_next;\n-        unsigned hash = node->_hash;\n-        unsigned index = hash % new_size;\n-\n-        node->_next = new_table[index];\n-        new_table[index] = node;\n-\n-        node = next;\n-      }\n-      ++bucket;\n-    }\n-\n-    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-      FREE_C_HEAP_ARRAY(Node*, old_table);\n-    }\n-    BASE::_table = new_table;\n-    BASE::_table_size = new_size;\n-  }\n-\n-#ifdef ASSERT\n-  int verify() {\n-    Node** table = BASE::_table;\n-    \/\/ Return max bucket size.  If hashcode is broken, this will be\n-    \/\/ too high.\n-    int max_bucket_size = 0;\n-    int index = 0;\n-    Node* const* bucket = table;\n-    while (bucket < &table[BASE::_table_size]) {\n-      int count = 0;\n-      Node* node = *bucket;\n-      while (node != nullptr) {\n-        count++;\n-        node = node->_next;\n-      }\n-      max_bucket_size = MAX2(count, max_bucket_size);\n-      ++bucket;\n-    }\n-    return max_bucket_size;\n-  }\n-#endif \/\/ ASSERT\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -1,380 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_RESOURCEHASH_HPP\n-#define SHARE_UTILITIES_RESOURCEHASH_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/numberSeq.hpp\"\n-#include \"utilities\/tableStatistics.hpp\"\n-\n-#include <type_traits>\n-\n-template<typename K, typename V>\n-class ResourceHashtableNode : public AnyObj {\n-public:\n-  unsigned _hash;\n-  K _key;\n-  V _value;\n-  ResourceHashtableNode* _next;\n-\n-  ResourceHashtableNode(unsigned hash, K const& key, V const& value,\n-                        ResourceHashtableNode* next = nullptr) :\n-    _hash(hash), _key(key), _value(value), _next(next) {}\n-\n-  \/\/ Create a node with a default-constructed value.\n-  ResourceHashtableNode(unsigned hash, K const& key,\n-                        ResourceHashtableNode* next = nullptr) :\n-    _hash(hash), _key(key), _value(), _next(next) {}\n-};\n-\n-template<\n-    class STORAGE,\n-    typename K, typename V,\n-    AnyObj::allocation_type ALLOC_TYPE,\n-    MemTag MEM_TAG,\n-    unsigned (*HASH)  (K const&),\n-    bool     (*EQUALS)(K const&, K const&)\n-    >\n-class ResourceHashtableBase : public STORAGE {\n-  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<K>::value,\n-                \"Destructor for K is only called with C_HEAP\");\n-  static_assert(ALLOC_TYPE == AnyObj::C_HEAP || std::is_trivially_destructible<V>::value,\n-                \"Destructor for V is only called with C_HEAP\");\n-  using Node = ResourceHashtableNode<K, V>;\n- private:\n-  int _number_of_entries;\n-\n-  Node** bucket_at(unsigned index) {\n-    Node** t = table();\n-    return &t[index];\n-  }\n-\n-  const Node* const* bucket_at(unsigned index) const {\n-    Node** t = table();\n-    return &t[index];\n-  }\n-\n-  \/\/ Returns a pointer to where the node where the value would reside if\n-  \/\/ it's in the table.\n-  Node** lookup_node(unsigned hash, K const& key) {\n-    unsigned index = hash % table_size();\n-    Node** ptr = bucket_at(index);\n-    while (*ptr != nullptr) {\n-      Node* node = *ptr;\n-      if (node->_hash == hash && EQUALS(key, node->_key)) {\n-        break;\n-      }\n-      ptr = &(node->_next);\n-    }\n-    return ptr;\n-  }\n-\n-  Node const** lookup_node(unsigned hash, K const& key) const {\n-    return const_cast<Node const**>(\n-        const_cast<ResourceHashtableBase*>(this)->lookup_node(hash, key));\n-  }\n-\n- protected:\n-  Node** table() const { return STORAGE::table(); }\n-\n-  ResourceHashtableBase() : STORAGE(), _number_of_entries(0) {}\n-  ResourceHashtableBase(unsigned size) : STORAGE(size), _number_of_entries(0) {}\n-  NONCOPYABLE(ResourceHashtableBase);\n-\n-  ~ResourceHashtableBase() {\n-    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-      Node* const* bucket = table();\n-      const unsigned sz = table_size();\n-      while (bucket < bucket_at(sz)) {\n-        Node* node = *bucket;\n-        while (node != nullptr) {\n-          Node* cur = node;\n-          node = node->_next;\n-          delete cur;\n-        }\n-        ++bucket;\n-      }\n-    }\n-  }\n-\n- public:\n-  unsigned table_size() const { return STORAGE::table_size(); }\n-  int number_of_entries() const { return _number_of_entries; }\n-\n-  bool contains(K const& key) const {\n-    return get(key) != nullptr;\n-  }\n-\n-  V* get(K const& key) const {\n-    unsigned hv = HASH(key);\n-    Node const** ptr = lookup_node(hv, key);\n-    if (*ptr != nullptr) {\n-      return const_cast<V*>(&(*ptr)->_value);\n-    } else {\n-      return nullptr;\n-    }\n-  }\n-\n- \/**\n-  * Inserts a value in the front of the table, assuming that\n-  * the entry is absent.\n-  * The table must be locked for the get or test that the entry\n-  * is absent, and for this operation.\n-  * This is a faster variant of put_if_absent because it adds to the\n-  * head of the bucket, and doesn't search the bucket.\n-  * @return: true: a new item is always added\n-  *\/\n-  bool put_when_absent(K const& key, V const& value) {\n-    unsigned hv = HASH(key);\n-    unsigned index = hv % table_size();\n-    assert(*lookup_node(hv, key) == nullptr, \"use put_if_absent\");\n-    Node** ptr = bucket_at(index);\n-    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-      *ptr = new (MEM_TAG) Node(hv, key, value, *ptr);\n-    } else {\n-      *ptr = new Node(hv, key, value, *ptr);\n-    }\n-    _number_of_entries ++;\n-    return true;\n-  }\n-\n- \/**\n-  * Inserts or replaces a value in the table.\n-  * @return: true:  if a new item is added\n-  *          false: if the item already existed and the value is updated\n-  *\/\n-  bool put(K const& key, V const& value) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-    if (*ptr != nullptr) {\n-      (*ptr)->_value = value;\n-      return false;\n-    } else {\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        *ptr = new (MEM_TAG) Node(hv, key, value);\n-      } else {\n-        *ptr = new Node(hv, key, value);\n-      }\n-      _number_of_entries ++;\n-      return true;\n-    }\n-  }\n-\n-  \/\/ Look up the key.\n-  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n-  \/\/ If no entry for the key exists, create a new entry from key and a default-created value\n-  \/\/  and return a pointer to the value.\n-  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n-  V* put_if_absent(K const& key, bool* p_created) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-    if (*ptr == nullptr) {\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        *ptr = new (MEM_TAG) Node(hv, key);\n-      } else {\n-        *ptr = new Node(hv, key);\n-      }\n-      *p_created = true;\n-      _number_of_entries ++;\n-    } else {\n-      *p_created = false;\n-    }\n-    return &(*ptr)->_value;\n-  }\n-\n-  \/\/ Look up the key.\n-  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n-  \/\/ If no entry for the key exists, create a new entry from key and value and return a\n-  \/\/  pointer to the value.\n-  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n-  V* put_if_absent(K const& key, V const& value, bool* p_created) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-    if (*ptr == nullptr) {\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        *ptr = new (MEM_TAG) Node(hv, key, value);\n-      } else {\n-        *ptr = new Node(hv, key, value);\n-      }\n-      *p_created = true;\n-      _number_of_entries ++;\n-    } else {\n-      *p_created = false;\n-    }\n-    return &(*ptr)->_value;\n-  }\n-\n-  template<typename Function>\n-  bool remove(K const& key, Function function) {\n-    unsigned hv = HASH(key);\n-    Node** ptr = lookup_node(hv, key);\n-\n-    Node* node = *ptr;\n-    if (node != nullptr) {\n-      *ptr = node->_next;\n-      function(node->_key, node->_value);\n-      if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-        delete node;\n-      }\n-      _number_of_entries --;\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  bool remove(K const& key) {\n-    auto dummy = [&] (K& k, V& v) { };\n-    return remove(key, dummy);\n-  }\n-\n-  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n-  \/\/ called for each entry in the table.  If do_entry() returns false,\n-  \/\/ the iteration is cancelled.\n-  template<class ITER>\n-  void iterate(ITER* iter) const {\n-    auto function = [&] (K& k, V& v) {\n-      return iter->do_entry(k, v);\n-    };\n-    iterate(function);\n-  }\n-\n-  template<typename Function>\n-  void iterate(Function function) const { \/\/ lambda enabled API\n-    Node* const* bucket = table();\n-    const unsigned sz = table_size();\n-    int cnt = _number_of_entries;\n-\n-    while (cnt > 0 && bucket < bucket_at(sz)) {\n-      Node* node = *bucket;\n-      while (node != nullptr) {\n-        bool cont = function(node->_key, node->_value);\n-        if (!cont) { return; }\n-        node = node->_next;\n-        --cnt;\n-      }\n-      ++bucket;\n-    }\n-  }\n-\n-  \/\/ same as above, but unconditionally iterate all entries\n-  template<typename Function>\n-  void iterate_all(Function function) const { \/\/ lambda enabled API\n-    auto wrapper = [&] (K& k, V& v) {\n-      function(k, v);\n-      return true;\n-    };\n-    iterate(wrapper);\n-  }\n-\n-  \/\/ ITER contains bool do_entry(K const&, V const&), which will be\n-  \/\/ called for each entry in the table.  If do_entry() returns true,\n-  \/\/ the entry is deleted.\n-  template<class ITER>\n-  void unlink(ITER* iter) {\n-    const unsigned sz = table_size();\n-    for (unsigned index = 0; index < sz; index++) {\n-      Node** ptr = bucket_at(index);\n-      while (*ptr != nullptr) {\n-        Node* node = *ptr;\n-        \/\/ do_entry must clean up the key and value in Node.\n-        bool clean = iter->do_entry(node->_key, node->_value);\n-        if (clean) {\n-          *ptr = node->_next;\n-          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-            delete node;\n-          }\n-          _number_of_entries --;\n-        } else {\n-          ptr = &(node->_next);\n-        }\n-      }\n-    }\n-  }\n-\n-  template<typename Function>\n-  TableStatistics statistics_calculate(Function size_function) const {\n-    NumberSeq summary;\n-    size_t literal_bytes = 0;\n-    Node* const* bucket = table();\n-    const unsigned sz = table_size();\n-    while (bucket < bucket_at(sz)) {\n-      Node* node = *bucket;\n-      int count = 0;\n-      while (node != nullptr) {\n-        literal_bytes += size_function(node->_key, node->_value);\n-        count++;\n-        node = node->_next;\n-      }\n-      summary.add((double)count);\n-      ++bucket;\n-    }\n-    return TableStatistics(summary, literal_bytes, sizeof(Node*), sizeof(Node));\n-  }\n-\n-  \/\/ This method calculates the \"shallow\" size. If you want the recursive size, use statistics_calculate.\n-  size_t mem_size() const {\n-    return sizeof(*this) +\n-      table_size() * sizeof(Node*) +\n-      number_of_entries() * sizeof(Node);\n-  }\n-};\n-\n-template<unsigned TABLE_SIZE, typename K, typename V>\n-class FixedResourceHashtableStorage : public AnyObj {\n-  using Node = ResourceHashtableNode<K, V>;\n-\n-  Node* _table[TABLE_SIZE];\n-protected:\n-  FixedResourceHashtableStorage() { memset(_table, 0, sizeof(_table)); }\n-  ~FixedResourceHashtableStorage() = default;\n-\n-  constexpr unsigned table_size() const {\n-    return TABLE_SIZE;\n-  }\n-\n-  Node** table() const {\n-    return const_cast<Node**>(_table);\n-  }\n-};\n-\n-template<\n-    typename K, typename V,\n-    unsigned SIZE = 256,\n-    AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA,\n-    MemTag MEM_TAG = mtInternal,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n-    >\n-class ResourceHashtable : public ResourceHashtableBase<\n-  FixedResourceHashtableStorage<SIZE, K, V>,\n-    K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> {\n-  NONCOPYABLE(ResourceHashtable);\n-public:\n-  ResourceHashtable() : ResourceHashtableBase<FixedResourceHashtableStorage<SIZE, K, V>,\n-                                              K, V, ALLOC_TYPE, MEM_TAG, HASH, EQUALS>() {}\n-};\n-\n-#endif \/\/ SHARE_UTILITIES_RESOURCEHASH_HPP\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":0,"deletions":380,"binary":false,"changes":380,"status":"deleted"},{"patch":"@@ -70,1 +70,1 @@\n-      os::snprintf(extended_resource_info_at_startup, sizeof(extended_resource_info_at_startup), \"%s\", result_info);\n+      os::snprintf_checked(extended_resource_info_at_startup, sizeof(extended_resource_info_at_startup), \"%s\", result_info);\n@@ -76,1 +76,1 @@\n-      os::snprintf(host_information, sizeof(host_information), \"%s\", result_info);\n+      os::snprintf_checked(host_information, sizeof(host_information), \"%s\", result_info);\n","filename":"src\/hotspot\/share\/utilities\/virtualizationSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"cds\/metaspaceShared.hpp\"\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -107,2 +107,2 @@\n-volatile intptr_t VMError::_handshake_timed_out_thread = p2i(nullptr);\n-volatile intptr_t VMError::_safepoint_timed_out_thread = p2i(nullptr);\n+Thread* volatile VMError::_handshake_timed_out_thread = nullptr;\n+Thread* volatile VMError::_safepoint_timed_out_thread = nullptr;\n@@ -824,4 +824,4 @@\n-        if (_handshake_timed_out_thread == p2i(_thread)) {\n-          st->print(\" (sent by handshake timeout handler\");\n-        } else if (_safepoint_timed_out_thread == p2i(_thread)) {\n-          st->print(\" (sent by safepoint timeout handler\");\n+        if (get_handshake_timed_out_thread() == _thread) {\n+          st->print(\" (sent by handshake timeout handler)\");\n+        } else if (get_safepoint_timed_out_thread() == _thread) {\n+          st->print(\" (sent by safepoint timeout handler)\");\n@@ -1081,1 +1081,1 @@\n-  STEP_IF(\"printing lock stack\", _verbose && _thread != nullptr && _thread->is_Java_thread() && LockingMode == LM_LIGHTWEIGHT);\n+  STEP_IF(\"printing lock stack\", _verbose && _thread != nullptr && _thread->is_Java_thread());\n@@ -1202,1 +1202,1 @@\n-    CDS_ONLY(MetaspaceShared::print_on(st);)\n+    CDS_ONLY(AOTMetaspace::print_on(st);)\n@@ -1341,2 +1341,4 @@\n-void VMError::set_handshake_timed_out_thread(intptr_t thread_addr) {\n-  _handshake_timed_out_thread = thread_addr;\n+void VMError::set_handshake_timed_out_thread(Thread* thread) {\n+  \/\/ Only preserve the first thread to time-out this way. The atomic operation ensures\n+  \/\/ visibility to the target thread.\n+  Atomic::replace_if_null(&_handshake_timed_out_thread, thread);\n@@ -1345,2 +1347,12 @@\n-void VMError::set_safepoint_timed_out_thread(intptr_t thread_addr) {\n-  _safepoint_timed_out_thread = thread_addr;\n+void VMError::set_safepoint_timed_out_thread(Thread* thread) {\n+  \/\/ Only preserve the first thread to time-out this way. The atomic operation ensures\n+  \/\/ visibility to the target thread.\n+  Atomic::replace_if_null(&_safepoint_timed_out_thread, thread);\n+}\n+\n+Thread* VMError::get_handshake_timed_out_thread() {\n+  return Atomic::load(&_handshake_timed_out_thread);\n+}\n+\n+Thread* VMError::get_safepoint_timed_out_thread() {\n+  return Atomic::load(&_safepoint_timed_out_thread);\n@@ -1405,1 +1417,1 @@\n-    CDS_ONLY(MetaspaceShared::print_on(st);)\n+    CDS_ONLY(AOTMetaspace::print_on(st);)\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -146,2 +146,2 @@\n-  static volatile intptr_t _handshake_timed_out_thread;\n-  static volatile intptr_t _safepoint_timed_out_thread;\n+  static Thread* volatile _handshake_timed_out_thread;\n+  static Thread* volatile _safepoint_timed_out_thread;\n@@ -226,2 +226,4 @@\n-  static void set_handshake_timed_out_thread(intptr_t thread_addr);\n-  static void set_safepoint_timed_out_thread(intptr_t thread_addr);\n+  static void set_handshake_timed_out_thread(Thread* thread);\n+  static void set_safepoint_timed_out_thread(Thread* thread);\n+  static Thread* get_handshake_timed_out_thread();\n+  static Thread* get_safepoint_timed_out_thread();\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * <p> Whether a virtual machine has a console is dependent upon the\n+ * <p> Whether a virtual machine's console exists is dependent upon the\n@@ -45,1 +45,1 @@\n- * output streams then its console will exist and will typically be\n+ * output streams, then its console will generally exist and will be\n@@ -47,3 +47,4 @@\n- * was launched.  If the virtual machine is started automatically, for\n- * example by a background job scheduler, then it may not\n- * have a console.\n+ * was launched. If the standard input or standard output have been\n+ * redirected (for example, to a file or to a pipe), or if the virtual\n+ * machine was started from a background job scheduler, the console\n+ * will not exist.\n@@ -51,4 +52,3 @@\n- * If this virtual machine has a console then it is represented by a\n- * unique instance of this class which can be obtained by invoking the\n- * {@link java.lang.System#console()} method.  If no console device is\n- * available then an invocation of that method will return {@code null}.\n+ * If the console exists, then it is represented by a unique instance of this\n+ * class which can be obtained by invoking the {@link System#console()} method.\n+ * If the console does not exist, that method will return {@code null}.\n@@ -538,7 +538,3 @@\n-     * This method returns {@code true} if the console device, associated with the current\n-     * Java virtual machine, is a terminal, typically an interactive command line\n-     * connected to a keyboard and display.\n-     *\n-     * @implNote The default implementation returns the value equivalent to calling\n-     * {@code isatty(stdin\/stdout)} on POSIX platforms, or whether standard in\/out file\n-     * descriptors are character devices or not on Windows.\n+     * This method always returns {@code true}, since {@link System#console()}\n+     * provides a {@code Console} instance only when both standard input and\n+     * output are unredirected, that is, when running in an interactive terminal.\n@@ -549,1 +545,1 @@\n-        return istty;\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/io\/Console.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -602,1 +602,1 @@\n-                str = JLA.uncheckedNewStringNoRepl(bytearr, StandardCharsets.ISO_8859_1);\n+                str = JLA.uncheckedNewStringWithLatin1Bytes(bytearr);\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,3 +83,8 @@\n- * <p> Unless otherwise noted, {@linkplain java.nio.file##links symbolic links}\n- * are automatically redirected to the <i>target<\/i> of the link, whether they\n- * are provided by a pathname string or via a {@code File} object.\n+ * <p> Many operating systems and file systems have support for\n+ * {@linkplain java.nio.file##links symbolic links}.\n+ * A symbolic link is a special file that serves as a reference to another file.\n+ * Unless otherwise specified, symbolic links are transparent to applications\n+ * and operations on files that are symbolic links are automatically redirected\n+ * to the target of the link.  Methods that only operate on the abstract\n+ * pathname do not access the file system and thus do not resolve symbolic\n+ * links.\n@@ -92,2 +97,2 @@\n- * absolute pathname.  For example, the directory denoted by the abstract\n- * pathname {@code \"\/usr\"} is an ancestor of the directory denoted by the\n+ * absolute pathname.  For example, the directory located by the abstract\n+ * pathname {@code \"\/usr\"} is an ancestor of the directory located by the\n@@ -116,2 +121,2 @@\n- * <p> Instances of this class may or may not denote an actual file-system\n- * object such as a file or a directory.  If it does denote such an object\n+ * <p> Instances of this class may or may not locate an actual file-system\n+ * object such as a file or a directory.  If it does locate such an object\n@@ -451,1 +456,1 @@\n-     * Returns the name of the file or directory denoted by this abstract\n+     * Returns the name component of this abstract\n@@ -456,1 +461,1 @@\n-     * @return  The name of the file or directory denoted by this abstract\n+     * @return  The name component of this abstract\n@@ -595,1 +600,1 @@\n-     * <p> Every pathname that denotes an existing file or directory has a\n+     * <p> Every pathname that locates an existing file or directory has a\n@@ -604,1 +609,1 @@\n-     * @return  The canonical pathname string denoting the same file or\n+     * @return  The canonical pathname string locating the same file or\n@@ -626,1 +631,1 @@\n-     * @return  The canonical pathname string denoting the same file or\n+     * @return  The canonical pathname string locating the same file or\n@@ -659,1 +664,1 @@\n-     * the file denoted by this abstract pathname is a directory, then the\n+     * the file located by this abstract pathname is a directory, then the\n@@ -692,1 +697,1 @@\n-     * determined that the file denoted by this abstract pathname is a\n+     * determined that the file located by this abstract pathname is a\n@@ -743,1 +748,1 @@\n-     * Tests whether the application can read the file denoted by this\n+     * Tests whether the application can read the file located by this\n@@ -749,1 +754,1 @@\n-     * @return  {@code true} if and only if the file specified by this\n+     * @return  {@code true} if and only if the file located by this\n@@ -761,1 +766,1 @@\n-     * Tests whether the application can modify the file denoted by this\n+     * Tests whether the application can modify the file located by this\n@@ -768,1 +773,1 @@\n-     *          contains a file denoted by this abstract pathname <em>and<\/em>\n+     *          contains a file located by this abstract pathname <em>and<\/em>\n@@ -780,1 +785,1 @@\n-     * Tests whether the file or directory denoted by this abstract pathname\n+     * Tests whether the file or directory located by this abstract pathname\n@@ -783,1 +788,1 @@\n-     * @return  {@code true} if and only if the file or directory denoted\n+     * @return  {@code true} if and only if the file or directory located\n@@ -794,1 +799,1 @@\n-     * Tests whether the file denoted by this abstract pathname is a\n+     * Tests whether the file located by this abstract pathname is a\n@@ -803,1 +808,1 @@\n-     * @return {@code true} if and only if the file denoted by this\n+     * @return {@code true} if and only if the file located by this\n@@ -815,1 +820,1 @@\n-     * Tests whether the file denoted by this abstract pathname is a normal\n+     * Tests whether the file located by this abstract pathname is a normal\n@@ -826,1 +831,1 @@\n-     * @return  {@code true} if and only if the file denoted by this\n+     * @return  {@code true} if and only if the file located by this\n@@ -838,1 +843,1 @@\n-     * Tests whether the file named by this abstract pathname is a hidden\n+     * Tests whether the file located by this abstract pathname is a hidden\n@@ -852,1 +857,1 @@\n-     * @return  {@code true} if and only if the file denoted by this\n+     * @return  {@code true} if and only if the file located by this\n@@ -866,1 +871,1 @@\n-     * Returns the time that the file denoted by this abstract pathname was\n+     * Returns the time that the file located by this abstract pathname was\n@@ -900,2 +905,2 @@\n-     * Returns the length of the file denoted by this abstract pathname.\n-     * The return value is unspecified if this pathname denotes a directory.\n+     * Returns the length of the file located by this abstract pathname.\n+     * The return value is unspecified if this pathname locates a directory.\n@@ -909,1 +914,1 @@\n-     * @return  The length, in bytes, of the file denoted by this abstract\n+     * @return  The length, in bytes, of the file located by this abstract\n@@ -912,1 +917,1 @@\n-     *          denoting system-dependent entities such as devices or pipes.\n+     *          locating system-dependent entities such as devices or pipes.\n@@ -938,1 +943,1 @@\n-     *          already exists\n+     *          already exists, including if it is a symbolic link\n@@ -953,3 +958,3 @@\n-     * Deletes the file or directory denoted by this abstract pathname.  If\n-     * this pathname denotes a directory, then the directory must be empty in\n-     * order to be deleted.  If this pathname denotes a symbolic link, then the\n+     * Deletes the file or directory located by this abstract pathname.  If\n+     * this pathname locates a directory, then the directory must be empty in\n+     * order to be deleted.  If this pathname locates a symbolic link, then the\n@@ -974,1 +979,1 @@\n-     * Requests that the file or directory denoted by this abstract\n+     * Requests that the file or directory located by this abstract\n@@ -976,1 +981,1 @@\n-     * If this pathname denotes a symbolic link, then the\n+     * If this pathname locates a symbolic link, then the\n@@ -1006,1 +1011,1 @@\n-     * directory denoted by this abstract pathname.\n+     * directory located by this abstract pathname.\n@@ -1008,1 +1013,1 @@\n-     * <p> If this abstract pathname does not denote a directory, then this\n+     * <p> If this abstract pathname does not locate a directory, then this\n@@ -1011,1 +1016,1 @@\n-     * denoting the directory itself and the directory's parent directory are\n+     * locating the directory itself and the directory's parent directory are\n@@ -1026,1 +1031,1 @@\n-     *          directory denoted by this abstract pathname.  The array will be\n+     *          directory located by this abstract pathname.  The array will be\n@@ -1028,1 +1033,1 @@\n-     *          this abstract pathname does not denote a directory, or if an\n+     *          this abstract pathname does not locate a directory, or if an\n@@ -1037,1 +1042,1 @@\n-     * directory denoted by this abstract pathname.  The strings are\n+     * directory located by this abstract pathname.  The strings are\n@@ -1041,1 +1046,1 @@\n-     *          directory denoted by this abstract pathname.  The array will be\n+     *          directory located by this abstract pathname.  The array will be\n@@ -1043,1 +1048,1 @@\n-     *          this abstract pathname does not denote a directory, or if an\n+     *          this abstract pathname does not locate a directory, or if an\n@@ -1063,1 +1068,1 @@\n-     * directory denoted by this abstract pathname that satisfy the specified\n+     * directory located by this abstract pathname that satisfy the specified\n@@ -1071,1 +1076,1 @@\n-     * file or directory in the directory that it denotes.\n+     * file or directory in the directory that it locates.\n@@ -1077,1 +1082,1 @@\n-     *          directory denoted by this abstract pathname that were accepted\n+     *          directory located by this abstract pathname that were accepted\n@@ -1080,1 +1085,1 @@\n-     *          Returns {@code null} if this abstract pathname does not denote\n+     *          Returns {@code null} if this abstract pathname does not locate\n@@ -1100,2 +1105,2 @@\n-     * Returns an array of abstract pathnames denoting the files in the\n-     * directory denoted by this abstract pathname.\n+     * Returns an array of abstract pathnames locating the files in the\n+     * directory located by this abstract pathname.\n@@ -1103,1 +1108,1 @@\n-     * <p> If this abstract pathname does not denote a directory, then this\n+     * <p> If this abstract pathname does not locate a directory, then this\n@@ -1106,1 +1111,1 @@\n-     * denoting the directory itself and the directory's parent directory are\n+     * locating the directory itself and the directory's parent directory are\n@@ -1124,2 +1129,2 @@\n-     * @return  An array of abstract pathnames denoting the files and\n-     *          directories in the directory denoted by this abstract pathname.\n+     * @return  An array of abstract pathnames locating the files and\n+     *          directories in the directory located by this abstract pathname.\n@@ -1127,1 +1132,1 @@\n-     *          {@code null} if this abstract pathname does not denote a\n+     *          {@code null} if this abstract pathname does not locate a\n@@ -1144,2 +1149,2 @@\n-     * Returns an array of abstract pathnames denoting the files and\n-     * directories in the directory denoted by this abstract pathname that\n+     * Returns an array of abstract pathnames locating the files and\n+     * directories in the directory located by this abstract pathname that\n@@ -1154,1 +1159,1 @@\n-     * the directory that it denotes.\n+     * the directory that it locates.\n@@ -1159,2 +1164,2 @@\n-     * @return  An array of abstract pathnames denoting the files and\n-     *          directories in the directory denoted by this abstract pathname.\n+     * @return  An array of abstract pathnames locating the files and\n+     *          directories in the directory located by this abstract pathname.\n@@ -1162,1 +1167,1 @@\n-     *          {@code null} if this abstract pathname does not denote a\n+     *          {@code null} if this abstract pathname does not locate a\n@@ -1180,2 +1185,2 @@\n-     * Returns an array of abstract pathnames denoting the files and\n-     * directories in the directory denoted by this abstract pathname that\n+     * Returns an array of abstract pathnames locating the files and\n+     * directories in the directory located by this abstract pathname that\n@@ -1193,2 +1198,2 @@\n-     * @return  An array of abstract pathnames denoting the files and\n-     *          directories in the directory denoted by this abstract pathname.\n+     * @return  An array of abstract pathnames locating the files and\n+     *          directories in the directory located by this abstract pathname.\n@@ -1196,1 +1201,1 @@\n-     *          {@code null} if this abstract pathname does not denote a\n+     *          {@code null} if this abstract pathname does not locate a\n@@ -1258,2 +1263,2 @@\n-     * Renames the file denoted by this abstract pathname.  If this pathname\n-     * denotes a symbolic link, then the link itself, not its target, will be\n+     * Renames the file located by this abstract pathname.  If this pathname\n+     * locates a symbolic link, then the link itself, not its target, will be\n@@ -1294,1 +1299,1 @@\n-     * Sets the last-modified time of the file or directory named by this\n+     * Sets the last-modified time of the file or directory located by this\n@@ -1323,1 +1328,1 @@\n-     * Marks the file or directory named by this abstract pathname so that\n+     * Marks the file or directory located by this abstract pathname so that\n@@ -1344,1 +1349,2 @@\n-     * Sets the owner's or everybody's write permission for this abstract\n+     * Sets the owner's or everybody's write permission of the file or\n+     * directory located by this abstract\n@@ -1378,1 +1384,2 @@\n-     * A convenience method to set the owner's write permission for this abstract\n+     * A convenience method to set the owner's write permission for the file\n+     * or directory located by this abstract\n@@ -1405,1 +1412,2 @@\n-     * Sets the owner's or everybody's read permission for this abstract\n+     * Sets the owner's or everybody's read permission for the file or directory\n+     * located by this abstract\n@@ -1445,1 +1453,2 @@\n-     * A convenience method to set the owner's read permission for this abstract\n+     * A convenience method to set the owner's read permission for the file\n+     * or directory located by this abstract\n@@ -1478,1 +1487,2 @@\n-     * Sets the owner's or everybody's execute permission for this abstract\n+     * Sets the owner's or everybody's execute permission for the file or\n+     * directory located by this abstract\n@@ -1518,1 +1528,2 @@\n-     * A convenience method to set the owner's execute permission for this\n+     * A convenience method to set the owner's execute permission for the file\n+     * or directory located by this\n@@ -1551,1 +1562,1 @@\n-     * Tests whether the application can execute the file denoted by this\n+     * Tests whether the application can execute the file located by this\n@@ -1797,1 +1808,1 @@\n-     * <li> The file denoted by the returned abstract pathname did not exist\n+     * <li> The file located by the returned abstract pathname did not exist\n@@ -1840,1 +1851,1 @@\n-     * abstract pathname is valid and denotes an existing, writable directory,\n+     * abstract pathname is valid and locates an existing, writable directory,\n@@ -1857,1 +1868,1 @@\n-     * @return  An abstract pathname denoting a newly-created empty file\n+     * @return  An abstract pathname locating a newly-created empty file\n@@ -1914,1 +1925,1 @@\n-     * @return  An abstract pathname denoting a newly-created empty file\n+     * @return  An abstract pathname locating a newly-created empty file\n@@ -1937,1 +1948,3 @@\n-     * Microsoft Windows systems it is not.\n+     * Microsoft Windows systems it is not.  This method only compares the\n+     * abstract pathnames; it does not access the file system and the file is\n+     * not required to exist.\n@@ -1961,5 +1974,3 @@\n-     * on Microsoft Windows systems it is not.\n-     *\n-     * @apiNote This method only tests whether the abstract pathnames are equal;\n-     *          it does not access the file system and the file is not required\n-     *          to exist.\n+     * on Microsoft Windows systems it is not.  This method only tests whether\n+     * the abstract pathnames are equal; it does not access the file system and\n+     * the file is not required to exist.\n","filename":"src\/java.base\/share\/classes\/java\/io\/File.java","additions":99,"deletions":88,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -1052,3 +1053,9 @@\n-        Class<?> c = defineClass2(this, name, b, b.position(), len, protectionDomain, source);\n-        postDefineClass(c, protectionDomain);\n-        return c;\n+\n+        SharedSecrets.getJavaNioAccess().acquireSession(b);\n+        try {\n+            Class<?> c = defineClass2(this, name, b, b.position(), len, protectionDomain, source);\n+            postDefineClass(c, protectionDomain);\n+            return c;\n+        } finally {\n+            SharedSecrets.getJavaNioAccess().releaseSession(b);\n+        }\n@@ -1060,0 +1067,2 @@\n+    \/\/ Warning: Before calling this method, the provided ByteBuffer must be guarded\n+    \/\/          via JavaNioAccess::(acquire|release)Session\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -454,2 +456,4 @@\n-            pio4lo=  0x1.1a62633145c07p-55, \/\/ 3.06161699786838301793e-17\n-            T[] = {\n+            pio4lo=  0x1.1a62633145c07p-55; \/\/ 3.06161699786838301793e-17\n+        @Stable\n+        private static final double[]\n+            T = {\n@@ -549,0 +553,1 @@\n+        @Stable\n@@ -563,0 +568,1 @@\n+        @Stable\n@@ -810,0 +816,1 @@\n+        @Stable\n@@ -812,0 +819,1 @@\n+        @Stable\n@@ -1235,0 +1243,1 @@\n+        @Stable\n@@ -1242,0 +1251,1 @@\n+        @Stable\n@@ -1249,0 +1259,1 @@\n+        @Stable\n@@ -2248,6 +2259,2 @@\n-                final double BP[]    = {1.0,\n-                                       1.5};\n-                final double DP_H[]  = {0.0,\n-                                        0x1.2b80_34p-1};        \/\/ 5.84962487220764160156e-01\n-                final double DP_L[]  = {0.0,\n-                                        0x1.cfde_b43c_fd006p-27};\/\/ 1.35003920212974897128e-08\n+                final double DP_H    = 0x1.2b80_34p-1;           \/\/ 5.84962487220764160156e-01\n+                final double DP_L    = 0x1.cfde_b43c_fd006p-27;  \/\/ 1.35003920212974897128e-08\n@@ -2262,2 +2269,4 @@\n-                u = x_abs - BP[k];               \/\/ BP[0]=1.0, BP[1]=1.5\n-                v = 1.0 \/ (x_abs + BP[k]);\n+\n+                double BP_k = 1.0 + 0.5*k; \/\/ BP[0]=1.0, BP[1]=1.5\n+                u = x_abs - BP_k;\n+                v = 1.0 \/ (x_abs + BP_k);\n@@ -2270,1 +2279,1 @@\n-                t_l = x_abs - (t_h - BP[k]);\n+                t_l = x_abs - (t_h - BP_k);\n@@ -2288,1 +2297,1 @@\n-                z_l = CP_L * p_h + p_l * CP + DP_L[k];\n+                z_l = CP_L * p_h + p_l * CP + DP_L*k;\n@@ -2291,1 +2300,1 @@\n-                t1 = (((z_h + z_l) + DP_H[k]) + t);\n+                t1 = (((z_h + z_l) + DP_H*k) + t);\n@@ -2293,1 +2302,1 @@\n-                t2 = z_l - (((t1 - t) - DP_H[k]) - z_h);\n+                t2 = z_l - (((t1 - t) - DP_H*k) - z_h);\n@@ -2433,1 +2442,0 @@\n-        private static final double[] half = {0.5, -0.5,};\n@@ -2438,2 +2446,3 @@\n-        private static final double[] ln2HI   ={  0x1.62e42feep-1,         \/\/  6.93147180369123816490e-01\n-                                                 -0x1.62e42feep-1};        \/\/ -6.93147180369123816490e-01\n+        private static final double ln2HI   =     0x1.62e42feep-1;         \/\/  6.93147180369123816490e-01\n+\n+        @Stable\n@@ -2481,1 +2490,1 @@\n-                    hi = x - ln2HI[xsb];\n+                    hi = x - ln2HI*(1 - 2*xsb); \/* +\/- ln2HI *\/\n@@ -2485,1 +2494,1 @@\n-                    k  = (int)(invln2 * x + half[xsb]);\n+                    k  = (int)(invln2 * x + 0.5 * (1 - 2*xsb) \/* +\/- 0.5 *\/  );\n@@ -2487,1 +2496,1 @@\n-                    hi = x - t*ln2HI[0];    \/* t*ln2HI is exact here *\/\n+                    hi = x - t*ln2HI;    \/* t*ln2HI is exact here *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-            dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp, true);\n+            dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp);\n@@ -614,1 +614,1 @@\n-            int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n+            int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0);\n@@ -691,7 +691,15 @@\n-    \/*\n-     * Throws iae, instead of replacing, if malformed or unmappable.\n-     *\n-     * @param  noShare\n-     *         {@code true} if the resulting string MUST NOT share the byte array,\n-     *         {@code false} if the byte array can be exclusively used to construct\n-     *         the string and is not modified or used for any other purpose.\n+    \/**\n+     * {@return a new string by decoding from the given UTF-8 bytes array}\n+     * <p>\n+     * <b>WARNING: The caller of this method is assumed to have relinquished\n+     * and transferred the ownership of the byte array<\/b>. It can thus be\n+     * exclusively used to construct the {@code String}.\n+     *\n+     * @param bytes byte array containing UTF-8 encoded characters\n+     * @param offset the index of the first byte to decode\n+     * @param length the number of bytes to decode\n+     * @throws NullPointerException If {@code bytes} is null\n+     * @throws StringIndexOutOfBoundsException If {@code offset} is negative,\n+     *         {@code length} is negative, or {@code offset} is greater than\n+     *         {@code bytes.length - length}\n+     * @throws CharacterCodingException for malformed input or unmappable characters\n@@ -699,2 +707,3 @@\n-    static String newStringUTF8NoRepl(byte[] bytes, int offset, int length, boolean noShare) {\n-        checkBoundsOffCount(offset, length, bytes.length);\n+    private static String newStringUTF8OrThrow(byte[] bytes, int offset, int length)\n+            throws CharacterCodingException {\n+        checkBoundsOffCount(offset, length, bytes.length);  \/\/ Implicit null check on `bytes`\n@@ -710,1 +719,1 @@\n-                if (noShare || length != bytes.length) {\n+                if (length != bytes.length) {\n@@ -751,1 +760,1 @@\n-            dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, false);\n+            dp = decodeUTF8_UTF16OrThrow(bytes, offset, sl, dst, dp);\n@@ -754,1 +763,1 @@\n-            dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n+            dp = decodeUTF8_UTF16OrThrow(bytes, offset, offset + length, dst, 0);\n@@ -762,10 +771,8 @@\n-    static String newStringNoRepl(byte[] src, Charset cs) throws CharacterCodingException {\n-        try {\n-            return newStringNoRepl1(src, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/newStringNoRepl1 throws IAE with MalformedInputException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof MalformedInputException mie) {\n-                throw mie;\n-            }\n-            throw (CharacterCodingException)cause;\n+    \/**\n+     * {@return a new String created using the supplied latin1 bytes}\n+     * @param src a byte array with the bytes for a latin1 string\n+     *\/\n+    static String newStringWithLatin1Bytes(byte[] src) {\n+        int len = src.length;\n+        if (len == 0) {\n+            return \"\";\n@@ -773,0 +780,4 @@\n+\n+        if (COMPACT_STRINGS)\n+            return new String(src, LATIN1);\n+        return new String(StringLatin1.inflate(src, 0, src.length), UTF16);\n@@ -775,2 +786,17 @@\n-    private static String newStringNoRepl1(byte[] src, Charset cs) {\n-        int len = src.length;\n+    \/**\n+     * {@return a new {@code String} created using the given byte array that is\n+     * encoded in specified charset}\n+     * <p>\n+     * <b>WARNING: The caller of this method is assumed to have relinquished\n+     * and transferred the ownership of the byte array<\/b>. It can thus be\n+     * exclusively used to construct the {@code String}.\n+     *\n+     * @param src byte array containing encoded characters\n+     * @param cs charset the byte array encoded in\n+     *\n+     * @throws CharacterCodingException for malformed input or unmappable characters\n+     * @throws NullPointerException If {@code src} or {@code cs} is null\n+     *\/\n+    static String newStringOrThrow(byte[] src, Charset cs) throws CharacterCodingException {\n+        Objects.requireNonNull(cs);\n+        int len = src.length;   \/\/ Implicit null check on `src`\n@@ -781,1 +807,1 @@\n-            return newStringUTF8NoRepl(src, 0, src.length, false);\n+            return newStringUTF8OrThrow(src, 0, src.length);\n@@ -794,1 +820,1 @@\n-                throwMalformed(src);\n+                throw malformedASCII(src);\n@@ -809,7 +835,1 @@\n-        int caLen;\n-        try {\n-            caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n-        } catch (CharacterCodingException x) {\n-            \/\/ throw via IAE\n-            throw new IllegalArgumentException(x);\n-        }\n+        int caLen = decodeWithDecoder(cd, ca, src, 0, src.length);\n@@ -852,1 +872,1 @@\n-            return encodeUTF8(coder, val, true);\n+            return encodeUTF8(coder, val);\n@@ -860,1 +880,1 @@\n-        return encodeWithEncoder(cs, coder, val, true);\n+        return encodeWithEncoder(cs, coder, val, null);\n@@ -863,1 +883,17 @@\n-    private static byte[] encodeWithEncoder(Charset cs, byte coder, byte[] val, boolean doReplace) {\n+    \/**\n+     * {@return the byte array obtained by first decoding {@code val} with\n+     * {@code coder}, and then encoding the result with the encoder of {@code\n+     * cs}}\n+     *\n+     * @param cs a charset to obtain the encoder from\n+     * @param coder a coder to decode {@code val} with\n+     * @param val a string byte array encoded with {@code coder}\n+     * @param exClass The exception class where any non-null value indicates\n+     *                malformed or unmappable bytes will result in an exception\n+     *                to be thrown instead of getting replaced.\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n+     *\/\n+    private static <E extends Exception> byte[] encodeWithEncoder(\n+            Charset cs, byte coder, byte[] val, Class<E> exClass)\n+            throws E {\n@@ -867,0 +903,1 @@\n+        boolean doReplace = exClass == null;\n@@ -908,1 +945,3 @@\n-                throw new IllegalArgumentException(x);\n+                @SuppressWarnings(\"unchecked\")\n+                E cce = (E) x;\n+                throw cce;\n@@ -916,2 +955,6 @@\n-    \/*\n-     * Throws iae, instead of replacing, if unmappable.\n+    \/**\n+     * {@return the sequence of bytes obtained by encoding the given string in UTF-8}\n+     *\n+     * @param s the string to encode\n+     * @throws NullPointerException If {@code s} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -919,2 +962,2 @@\n-    static byte[] getBytesUTF8NoRepl(String s) {\n-        return encodeUTF8(s.coder(), s.value(), false);\n+    static byte[] getBytesUTF8OrThrow(String s) throws CharacterCodingException {\n+        return encodeUTF8OrThrow(s.coder(), s.value());  \/\/ Implicit null check on `s`\n@@ -927,2 +970,12 @@\n-    \/*\n-     * Throws CCE, instead of replacing, if unmappable.\n+    \/**\n+     * {@return the sequence of bytes obtained by encoding the given string in\n+     * the specified {@code Charset}}\n+     * <p>\n+     * <b>WARNING: This method returns the {@code byte[]} backing the provided\n+     * {@code String}, if the input is ASCII. Hence, the returned byte array\n+     * must not be modified.<\/b>\n+     *\n+     * @param s the string to encode\n+     * @param cs the charset\n+     * @throws NullPointerException If {@code s} or {@code cs} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -930,15 +983,3 @@\n-    static byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-        try {\n-            return getBytesNoRepl1(s, cs);\n-        } catch (IllegalArgumentException e) {\n-            \/\/getBytesNoRepl1 throws IAE with UnmappableCharacterException or CCE as the cause\n-            Throwable cause = e.getCause();\n-            if (cause instanceof UnmappableCharacterException) {\n-                throw (UnmappableCharacterException)cause;\n-            }\n-            throw (CharacterCodingException)cause;\n-        }\n-    }\n-\n-    private static byte[] getBytesNoRepl1(String s, Charset cs) {\n-        byte[] val = s.value();\n+    static byte[] getBytesOrThrow(String s, Charset cs) throws CharacterCodingException {\n+        Objects.requireNonNull(cs);\n+        byte[] val = s.value();     \/\/ Implicit null check on `s`\n@@ -950,1 +991,1 @@\n-            return encodeUTF8(coder, val, false);\n+            return encodeUTF8OrThrow(coder, val);\n@@ -956,1 +997,1 @@\n-            return encode8859_1(coder, val, false);\n+            return encode8859_1OrThrow(coder, val);\n@@ -963,1 +1004,1 @@\n-                    throwUnmappable(val);\n+                    throw unmappableASCII(val);\n@@ -967,1 +1008,1 @@\n-        return encodeWithEncoder(cs, coder, val, false);\n+        return encodeWithEncoder(cs, coder, val, CharacterCodingException.class);\n@@ -970,0 +1011,7 @@\n+    \/**\n+     * {@return the byte array obtained by first decoding {@code val} with\n+     * {@code coder}, and then encoding the result with US-ASCII}\n+     *\n+     * @param coder a coder to decode {@code val} with\n+     * @param val a string byte array encoded with {@code coder}\n+     *\/\n@@ -1009,1 +1057,5 @@\n-        return encode8859_1(coder, val, true);\n+        return encode8859_1(coder, val, null);\n+    }\n+\n+    private static byte[] encode8859_1OrThrow(byte coder, byte[] val) throws UnmappableCharacterException {\n+        return encode8859_1(coder, val, UnmappableCharacterException.class);\n@@ -1012,1 +1064,13 @@\n-    private static byte[] encode8859_1(byte coder, byte[] val, boolean doReplace) {\n+    \/**\n+     * {@return the byte array obtained by first decoding {@code val} with\n+     * {@code coder}, and then encoding the result with ISO-8859-1}\n+     *\n+     * @param coder a coder to decode {@code val} with\n+     * @param val a string byte array encoded with {@code coder}\n+     * @param exClass The exception class where any non-null value indicates\n+     *                malformed or unmappable bytes will result in an exception\n+     *                to be thrown instead of getting replaced.\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n+     *\/\n+    private static <E extends Exception> byte[] encode8859_1(byte coder, byte[] val, Class<E> exClass) throws E {\n@@ -1022,1 +1086,1 @@\n-            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n+            int ret = StringCoding.encodeISOArray(val, sp, dst, dp, len);\n@@ -1026,2 +1090,2 @@\n-                if (!doReplace) {\n-                    throwUnmappable(sp);\n+                if (exClass != null) {\n+                    throw String.<E>unmappableCharacterException(sp);\n@@ -1121,1 +1185,20 @@\n-    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp, boolean doReplace) {\n+    private static int decodeUTF8_UTF16(byte[] src, int sp, int sl, byte[] dst, int dp) {\n+        return decodeUTF8_UTF16(src, sp, sl, dst, dp, null);\n+    }\n+\n+    private static int decodeUTF8_UTF16OrThrow(\n+            byte[] src, int sp, int sl, byte[] dst, int dp)\n+            throws MalformedInputException {\n+        return decodeUTF8_UTF16(src, sp, sl, dst, dp, MalformedInputException.class);\n+    }\n+\n+    \/**\n+     * @param exClass The exception class where any non-null value indicates\n+     *                malformed or unmappable bytes will result in an exception\n+     *                to be thrown instead of getting replaced.\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n+     *\/\n+    private static <E extends Exception> int decodeUTF8_UTF16(\n+            byte[] src, int sp, int sl, byte[] dst, int dp, Class <E> exClass)\n+            throws E {\n@@ -1130,2 +1213,2 @@\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 1, 1);\n+                        if (exClass != null) {\n+                            throw String.<E>malformedInputException(sp - 1, 1);\n@@ -1140,2 +1223,2 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp, 1);  \/\/ underflow()\n+                if (exClass != null) {\n+                    throw String.<E>malformedInputException(sp, 1);  \/\/ underflow()\n@@ -1150,2 +1233,2 @@\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 3, 3);\n+                        if (exClass != null) {\n+                            throw String.<E>malformedInputException(sp - 3, 3);\n@@ -1159,2 +1242,2 @@\n-                            if (!doReplace) {\n-                                throwMalformed(sp - 3, 3);\n+                            if (exClass != null) {\n+                                throw String.<E>malformedInputException(sp - 3, 3);\n@@ -1170,2 +1253,2 @@\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 2);\n+                    if (exClass != null) {\n+                        throw String.<E>malformedInputException(sp - 1, 2);\n@@ -1176,2 +1259,2 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp, 1);\n+                if (exClass != null) {\n+                    throw String.<E>malformedInputException(sp, 1);\n@@ -1189,2 +1272,2 @@\n-                        if (!doReplace) {\n-                            throwMalformed(sp - 4, 4);\n+                        if (exClass != null) {\n+                            throw String.<E>malformedInputException(sp - 4, 4);\n@@ -1203,2 +1286,2 @@\n-                    if (!doReplace) {\n-                        throwMalformed(sp - 1, 1);  \/\/ or 2\n+                    if (exClass != null) {\n+                        throw String.<E>malformedInputException(sp - 1, 1);  \/\/ or 2\n@@ -1209,2 +1292,2 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n+                if (exClass != null) {\n+                    throw String.<E>malformedInputException(sp - 1, 1);\n@@ -1219,2 +1302,2 @@\n-                if (!doReplace) {\n-                    throwMalformed(sp - 1, 1);\n+                if (exClass != null) {\n+                    throw String.<E>malformedInputException(sp - 1, 1);\n@@ -1262,3 +1345,13 @@\n-    private static void throwMalformed(int off, int nb) {\n-        String msg = \"malformed input off : \" + off + \", length : \" + nb;\n-        throw new IllegalArgumentException(msg, new MalformedInputException(nb));\n+    \/**\n+     * {@return a new {@link MalformedInputException} for the sub-range denoted\n+     * by specified {@code offset} and {@code length}}\n+     *\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private static <E extends Exception> E malformedInputException(int offset, int length) {\n+        MalformedInputException mie = new MalformedInputException(length);\n+        String msg = \"malformed input offset : \" + offset + \", length : \" + length;\n+        mie.initCause(new IllegalArgumentException(msg));\n+        return (E) mie;\n@@ -1267,1 +1360,5 @@\n-    private static void throwMalformed(byte[] val) {\n+    \/**\n+     * {@return a new {@link MalformedInputException} for the given malformed\n+     * ASCII string}\n+     *\/\n+    private static MalformedInputException malformedASCII(byte[] val) {\n@@ -1269,1 +1366,1 @@\n-        throwMalformed(dp, 1);\n+        return malformedInputException(dp, 1);\n@@ -1272,3 +1369,12 @@\n-    private static void throwUnmappable(int off) {\n-        String msg = \"malformed input off : \" + off + \", length : 1\";\n-        throw new IllegalArgumentException(msg, new UnmappableCharacterException(1));\n+    \/**\n+     * {@return a new {@link UnmappableCharacterException} at given {@code offset}}\n+     *\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private static <E extends Exception> E unmappableCharacterException(int offset) {\n+        UnmappableCharacterException uce = new UnmappableCharacterException(1);\n+        String msg = \"malformed input offset : \" + offset + \", length : 1\";\n+        uce.initCause(new IllegalArgumentException(msg, uce));\n+        return (E) uce;\n@@ -1277,1 +1383,5 @@\n-    private static void throwUnmappable(byte[] val) {\n+    \/**\n+     * {@return a new {@link UnmappableCharacterException} for the given\n+     * malformed ASCII string}\n+     *\/\n+    private static UnmappableCharacterException unmappableASCII(byte[] val) {\n@@ -1279,1 +1389,9 @@\n-        throwUnmappable(dp);\n+        return unmappableCharacterException(dp);\n+    }\n+\n+    private static byte[] encodeUTF8(byte coder, byte[] val) {\n+        return encodeUTF8(coder, val, null);\n+    }\n+\n+    private static byte[] encodeUTF8OrThrow(byte coder, byte[] val) throws UnmappableCharacterException {\n+        return encodeUTF8(coder, val, UnmappableCharacterException.class);\n@@ -1282,1 +1400,13 @@\n-    private static byte[] encodeUTF8(byte coder, byte[] val, boolean doReplace) {\n+    \/**\n+     * {@return the byte array obtained by first decoding {@code val} with\n+     * {@code coder}, and then encoding the result with UTF-8}\n+     *\n+     * @param coder a coder to decode {@code val} with\n+     * @param val a string byte array encoded with {@code coder}\n+     * @param exClass The exception class where any non-null value indicates\n+     *                malformed or unmappable bytes will result in an exception\n+     *                to be thrown instead of getting replaced.\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n+     *\/\n+    private static <E extends Exception> byte[] encodeUTF8(byte coder, byte[] val, Class<E> exClass) throws E {\n@@ -1284,1 +1414,1 @@\n-            return encodeUTF8_UTF16(val, doReplace);\n+            return encodeUTF8_UTF16(val, exClass);\n@@ -1287,1 +1417,2 @@\n-        if (!StringCoding.hasNegatives(val, 0, val.length)) {\n+        int positives = StringCoding.countPositives(val, 0, val.length);\n+        if (positives == val.length) {\n@@ -1291,1 +1422,0 @@\n-        int dp = 0;\n@@ -1293,1 +1423,6 @@\n-        for (byte c : val) {\n+        if (positives > 0) {\n+            System.arraycopy(val, 0, dst, 0, positives);\n+        }\n+        int dp = positives;\n+        for (int i = dp; i < val.length; i++) {\n+            byte c = val[i];\n@@ -1307,1 +1442,12 @@\n-    private static byte[] encodeUTF8_UTF16(byte[] val, boolean doReplace) {\n+    \/**\n+     * {@return the byte array obtained by first decoding {@code val} with\n+     * UTF-16, and then encoding the result with UTF-8}\n+     *\n+     * @param val a string byte array encoded with UTF-16\n+     * @param exClass The exception class where any non-null value indicates\n+     *                malformed or unmappable bytes will result in an exception\n+     *                to be thrown instead of getting replaced.\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n+     *\/\n+    private static <E extends Exception> byte[] encodeUTF8_UTF16(byte[] val, Class<E> exClass) throws E {\n@@ -1313,1 +1459,1 @@\n-        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val, doReplace) : sl * 3;\n+        long allocLen = (sl * 3 < 0) ? computeSizeUTF8_UTF16(val, exClass) : sl * 3;\n@@ -1342,1 +1488,1 @@\n-                    if (doReplace) {\n+                    if (exClass == null) {\n@@ -1345,1 +1491,1 @@\n-                        throwUnmappable(sp - 1);\n+                        throw String.<E>unmappableCharacterException(sp - 1);\n@@ -1369,2 +1515,6 @@\n-     * @param val UTF16 encoded byte array\n-     * @param doReplace true to replace unmappable characters\n+     *\n+     * @param exClass The exception class where any non-null value indicates\n+     *                malformed or unmappable bytes will result in an exception\n+     *                to be thrown instead of getting discarded.\n+     * @param <E> The exception type parameter to enable callers to avoid\n+     *           having to declare the exception\n@@ -1372,1 +1522,1 @@\n-    private static long computeSizeUTF8_UTF16(byte[] val, boolean doReplace) {\n+    private static <E extends Exception> long computeSizeUTF8_UTF16(byte[] val, Class<E> exClass) throws E {\n@@ -1391,1 +1541,1 @@\n-                    if (doReplace) {\n+                    if (exClass == null) {\n@@ -1394,1 +1544,1 @@\n-                        throwUnmappable(sp - 1);\n+                        throw String.<E>unmappableCharacterException(sp - 1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":264,"deletions":114,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -31,0 +32,2 @@\n+import java.util.function.BiFunction;\n+\n@@ -41,1 +44,1 @@\n-    public static int countNonZeroAscii(String s) {\n+    static int countNonZeroAscii(String s) {\n@@ -53,1 +56,1 @@\n-    public static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n+    private static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n@@ -66,1 +69,1 @@\n-    public static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n+    private static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n@@ -77,1 +80,1 @@\n-    public static boolean hasNegatives(byte[] ba, int off, int len) {\n+    static boolean hasNegatives(byte[] ba, int off, int len) {\n@@ -88,0 +91,7 @@\n+     *\n+     * @param ba a byte array\n+     * @param off the index of the first byte to start reading from\n+     * @param len the total number of bytes to read\n+     * @throws NullPointerException if {@code ba} is null\n+     * @throws ArrayIndexOutOfBoundsException if the provided sub-range is\n+     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n@@ -89,0 +99,8 @@\n+    static int countPositives(byte[] ba, int off, int len) {\n+        Preconditions.checkFromIndexSize(\n+                off, len,\n+                ba.length,      \/\/ Implicit null check on `ba`\n+                Preconditions.AIOOBE_FORMATTER);\n+        return countPositives0(ba, off, len);\n+    }\n+\n@@ -90,1 +108,1 @@\n-    public static int countPositives(byte[] ba, int off, int len) {\n+    private static int countPositives0(byte[] ba, int off, int len) {\n@@ -100,0 +118,28 @@\n+    \/**\n+     * Encodes as many ISO-8859-1 codepoints as possible from the source byte\n+     * array containing characters encoded in UTF-16, into the destination byte\n+     * array, assuming that the encoding is ISO-8859-1 compatible.\n+     *\n+     * @param sa the source byte array containing characters encoded in UTF-16\n+     * @param sp the index of the <em>character (not byte!)<\/em> from the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the maximum number of <em>characters (not bytes!)<\/em> to be encoded\n+     * @return the total number of <em>characters (not bytes!)<\/em> successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    static int encodeISOArray(byte[] sa, int sp,\n+                              byte[] da, int dp, int len) {\n+        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+        int sl;\n+        if ((sp | dp | len) < 0 ||\n+                \/\/ Halving the length of `sa` to obtain the number of characters:\n+                sp >= (sl = sa.length >>> 1) ||     \/\/ Implicit null check on `sa`\n+                dp >= da.length) {                  \/\/ Implicit null check on `da`\n+            return 0;\n+        }\n+        int minLen = Math.min(len, Math.min(sl - sp, da.length - dp));\n+        return encodeISOArray0(sa, sp, da, dp, minLen);\n+    }\n+\n@@ -101,2 +147,2 @@\n-    public static int implEncodeISOArray(byte[] sa, int sp,\n-                                         byte[] da, int dp, int len) {\n+    private static int encodeISOArray0(byte[] sa, int sp,\n+                                       byte[] da, int dp, int len) {\n@@ -113,0 +159,26 @@\n+    \/**\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n+     *\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the maximum number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    static int encodeAsciiArray(char[] sa, int sp,\n+                                byte[] da, int dp, int len) {\n+        \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+        \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+        if ((sp | dp | len) < 0 ||\n+                sp >= sa.length ||      \/\/ Implicit null check on `sa`\n+                dp >= da.length) {      \/\/ Implicit null check on `da`\n+            return 0;\n+        }\n+        int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n+        return encodeAsciiArray0(sa, sp, da, dp, minLen);\n+    }\n+\n@@ -114,3 +186,2 @@\n-    public static int implEncodeAsciiArray(char[] sa, int sp,\n-                                           byte[] da, int dp, int len)\n-    {\n+    static int encodeAsciiArray0(char[] sa, int sp,\n+                                 byte[] da, int dp, int len) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":82,"deletions":11,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -241,1 +240,1 @@\n-     * Returns the unique {@link java.io.Console Console} object associated\n+     * Returns the unique {@link Console Console} object associated\n@@ -245,0 +244,1 @@\n+     * @see Console\n@@ -2127,0 +2127,1 @@\n+\n@@ -2130,2 +2131,7 @@\n-            public String uncheckedNewStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n-                return String.newStringNoRepl(bytes, cs);\n+\n+            public String uncheckedNewStringWithLatin1Bytes(byte[] bytes) {\n+                return String.newStringWithLatin1Bytes(bytes);\n+            }\n+\n+            public String uncheckedNewStringOrThrow(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+                return String.newStringOrThrow(bytes, cs);\n@@ -2133,0 +2139,1 @@\n+\n@@ -2136,0 +2143,1 @@\n+\n@@ -2139,3 +2147,0 @@\n-            public byte[] uncheckedGetBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n-                return String.getBytesNoRepl(s, cs);\n-            }\n@@ -2143,2 +2148,2 @@\n-            public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {\n-                return String.newStringUTF8NoRepl(bytes, off, len, true);\n+            public byte[] uncheckedGetBytesOrThrow(String s, Charset cs) throws CharacterCodingException {\n+                return String.getBytesOrThrow(s, cs);\n@@ -2147,2 +2152,2 @@\n-            public byte[] getBytesUTF8NoRepl(String s) {\n-                return String.getBytesUTF8NoRepl(s);\n+            public byte[] getBytesUTF8OrThrow(String s) throws CharacterCodingException {\n+                return String.getBytesUTF8OrThrow(s);\n@@ -2159,2 +2164,2 @@\n-            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n-                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n+            public int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len) {\n+                return StringCoding.encodeAsciiArray(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,3 @@\n-     * Constructs an UnsupportedOperationException with no detail message.\n+     * Constructs a new {@code UnsupportedOperationException} with {@code null}\n+     * as its detail message. The cause is not initialized, and may subsequently\n+     * be initialized by a call to {@link #initCause(Throwable)}.\n@@ -46,2 +48,3 @@\n-     * Constructs an UnsupportedOperationException with the specified\n-     * detail message.\n+     * Constructs a new {@code UnsupportedOperationException} with the specified\n+     * detail message. The cause is not initialized, and may subsequently be\n+     * initialized by a call to {@link #initCause(Throwable)}.\n@@ -56,2 +59,2 @@\n-     * Constructs a new exception with the specified detail message and\n-     * cause.\n+     * Constructs a new {@code UnsupportedOperationException} with the specified\n+     * detail message and cause.\n@@ -76,2 +79,3 @@\n-     * Constructs a new exception with the specified cause and a detail\n-     * message of {@code (cause==null ? null : cause.toString())} (which\n+     * Constructs a new {@code UnsupportedOperationException} with the specified\n+     * cause and a detail message of\n+     * {@code (cause==null ? null : cause.toString())} (which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/UnsupportedOperationException.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-     * {@return the access flags, as a bit mask}  It is in the range of unsigned\n-     * short, {@code [0, 0xFFFF]}.\n+     * {@return the access flags, as a bit mask}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AccessFlags.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -109,0 +111,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -119,0 +123,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -129,0 +135,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -212,0 +212,2 @@\n+     * @throws IllegalArgumentException if the number of associated values\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -676,0 +676,2 @@\n+     * @throws IllegalArgumentException if the length of array exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -689,0 +691,2 @@\n+     * @throws IllegalArgumentException if the length of array exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -702,1 +706,2 @@\n-     *         an enum constant, or an array of one of these.\n+     *         an enum constant, or an array of one of these; or any array has\n+     *         length over the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+     * @throws IllegalArgumentException if {@code major} or {@code minor} is not\n+     *         {@link java.lang.classfile##u2 u2}; {@code minor} may be {@code\n+     *         -1} to indicate {@value ClassFile#PREVIEW_MINOR_VERSION}\n@@ -80,0 +83,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -129,0 +134,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -140,0 +147,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -151,1 +160,3 @@\n-     * @throws IllegalArgumentException if any element of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -163,1 +174,3 @@\n-     * @throws IllegalArgumentException if any element of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -191,0 +204,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -224,0 +239,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -263,0 +280,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -287,0 +306,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -307,0 +328,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -336,0 +359,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-     * {@return the major version}  It is in the range of unsigned short, {@code\n-     * [0, 65535]}.\n+     * {@return the major version}  It is a {@link java.lang.classfile##u2 u2}\n+     * value.\n@@ -74,2 +74,2 @@\n-     * {@return the minor version}  It is in the range of unsigned short, {@code\n-     * [0, 65535]}.\n+     * {@return the minor version}  It is a {@link java.lang.classfile##u2 u2}\n+     * value.\n@@ -80,1 +80,3 @@\n-     * {@return a {@link ClassFileVersion} element}\n+     * {@return a {@link ClassFileVersion} element}  The minor version number\n+     * may be {@code -1} to represent {@value ClassFile#PREVIEW_MINOR_VERSION}.\n+     *\n@@ -83,0 +85,3 @@\n+     * @throws IllegalArgumentException if the major version or the minor\n+     *         version is not {@link java.lang.classfile##u2 u2}; the minor\n+     *         version may be {@code -1}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileVersion.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-     * {@return the major version of this class}  It is in the range of unsigned\n-     * short, {@code [0, 65535]}.\n+     * {@return the major version of this class}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -95,2 +95,2 @@\n-     * {@return the minor version of this class}  It is in the range of unsigned\n-     * short, {@code [0, 65535]}.\n+     * {@return the minor version of this class}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassModel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -156,2 +156,3 @@\n-     * {@return the unsigned short at the specified offset within the {@code\n-     * class} file}  Reads a 2-byte value and zero-extends it to an {@code int}.\n+     * {@return the {@link java.lang.classfile##u2 u2} at the specified offset\n+     * within the {@code class} file}  Reads a 2-byte value and zero-extends it\n+     * to an {@code int}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassReader.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -178,0 +178,5 @@\n+     * <p>\n+     * The location where a block of code merges back to its parent block, as\n+     * represented by the {@link #breakLabel()}, is expected to be reachable,\n+     * either from this block or the parent block.  The built code may be\n+     * malformed if there is no executable code at that location.\n@@ -328,0 +333,5 @@\n+     * <p>\n+     * The order of catch blocks is significant.  When an exception is thrown\n+     * by the try block, the first catch block whose exception type is {@linkplain\n+     * Class#isAssignableFrom(Class) the same class as or a superclass of} the\n+     * class of exception thrown is branched to (JVMS {@jvms 2.10}).\n@@ -346,0 +356,4 @@\n+         * @apiNote\n+         * If the type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -350,3 +364,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         an exception of the given type or {@code exceptionType}\n-         *         represents a primitive type\n+         * @throws IllegalArgumentException if {@code exceptionType} represents\n+         *         a primitive type\n@@ -370,0 +383,4 @@\n+         * @apiNote\n+         * If every type of exception to catch is already handled by previous\n+         * catch blocks, this block will never be executed.\n+         *\n@@ -374,2 +391,2 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         one or more exceptions of the given types\n+         * @throws IllegalArgumentException if any exception type represents a\n+         *         primitive type\n@@ -390,0 +407,4 @@\n+         * @apiNote\n+         * Since this block intercepts all exceptions, all subsequent catch\n+         * blocks will never be executed.\n+         *\n@@ -392,2 +413,0 @@\n-         * @throws IllegalArgumentException if an existing catch block catches\n-         *         all exceptions\n@@ -449,1 +468,1 @@\n-     *         void} or {@code slot} is out of range\n+     *         void} or {@code slot} is not {@link java.lang.classfile##u2 u2}\n@@ -463,1 +482,2 @@\n-     *         void} or {@code slot} is out of range\n+     *         void} or {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -795,0 +815,2 @@\n+     * @throws IllegalArgumentException if {@code line} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -891,0 +913,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -910,1 +934,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -930,1 +955,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -958,1 +984,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -983,1 +1010,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1042,1 +1070,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1112,1 +1141,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1368,1 +1398,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1433,1 +1464,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1680,1 +1712,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1745,1 +1778,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -2371,2 +2405,2 @@\n-     * {@code slot} exceeds {@code 255} or {@code val} exceeds the range of\n-     * {@link TypeKind#BYTE byte}.\n+     * {@code slot} exceeds the limit of {@link java.lang.classfile##u1 u1} or\n+     * {@code val} exceeds the range of {@link TypeKind#BYTE byte}.\n@@ -2377,1 +2411,3 @@\n-     * @throws IllegalArgumentException if {@code slot} or {@code val} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2} or {@code val} is out of range of\n+     *         {@link TypeKind#SHORT short}\n@@ -2394,1 +2430,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -2747,1 +2784,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -2985,1 +3023,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -3087,1 +3126,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":66,"deletions":26,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -72,0 +74,2 @@\n+     * @throws IllegalArgumentException if any flag cannot be applied to the\n+     *         {@link AccessFlag.Location#FIELD} location\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -65,0 +67,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -73,1 +77,3 @@\n-     * @throws IllegalArgumentException if any of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -82,1 +88,3 @@\n-     * @throws IllegalArgumentException if any of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Interfaces.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-     * @throws IllegalArgumentException if the {@link ClassFile#ACC_STATIC\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}, or the {@link ClassFile#ACC_STATIC\n@@ -77,1 +78,2 @@\n-     *         ACC_STATIC} flag is modified\n+     *         ACC_STATIC} flag is modified, or if any flag cannot be applied to\n+     *         the {@link AccessFlag.Location#METHOD} location\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -184,0 +185,2 @@\n+     * @throws IllegalArgumentException if the size of {@code targetPath}\n+     *         exceeds the limit of {@link java.lang.classfile##u1 u1}\n@@ -355,0 +358,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -363,0 +368,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -371,0 +378,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -379,0 +388,2 @@\n+         * @throws IllegalArgumentException if {@code supertypeIndex} is not\n+         *         {@link java.lang.classfile##u2 u2}\n@@ -390,0 +401,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         *         {@code boundIndex} is not {@link java.lang.classfile##u1 u1}\n@@ -400,0 +413,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         *         {@code boundIndex} is not {@link java.lang.classfile##u1 u1}\n@@ -410,0 +425,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         *         {@code boundIndex} is not {@link java.lang.classfile##u1 u1}\n@@ -451,0 +468,2 @@\n+         * @throws IllegalArgumentException if {@code formalParameterIndex} is\n+         *         not {@link java.lang.classfile##u1 u1}\n@@ -460,0 +479,2 @@\n+         * @throws IllegalArgumentException if {@code throwsTargetIndex} is\n+         *         not {@link java.lang.classfile##u2 u2}\n@@ -470,0 +491,2 @@\n+         * @throws IllegalArgumentException if the size of the list of targets\n+         *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -478,0 +501,2 @@\n+         * @throws IllegalArgumentException if the size of the list of targets\n+         *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -487,0 +512,2 @@\n+         * @throws IllegalArgumentException if the size of the list of targets\n+         *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -495,0 +522,2 @@\n+         * @throws IllegalArgumentException if {@code exceptionTableIndex} is\n+         *         not {@link java.lang.classfile##u2 u2}\n@@ -555,0 +584,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -564,0 +595,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -574,0 +607,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -584,0 +619,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -594,0 +631,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -604,0 +643,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -772,1 +813,0 @@\n-\n@@ -795,0 +835,2 @@\n+         * @throws IllegalArgumentException if {@code index} is not {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -962,0 +1004,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -964,1 +1008,1 @@\n-\n+            Util.checkU1(typeArgumentIndex, \"type argument index\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -169,0 +170,2 @@\n+     * @throws IllegalArgumentException if {@code startPc}, {@code endPc}, or\n+     *         {@code flags} is not {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CharacterRangeInfo.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+     * @throws IllegalArgumentException if the number of ranges exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CharacterRangeTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -88,0 +90,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -96,0 +100,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -104,0 +110,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ExceptionsAttribute.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,2 +71,1 @@\n-     * of the inner class}  It is in the range of unsigned short, {@code [0,\n-     * 0xFFFF]}.\n+     * of the inner class}  It is a {@link java.lang.classfile##u2 u2} value.\n@@ -107,0 +106,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -119,1 +120,3 @@\n-     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass} represents a primitive type\n+     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass}\n+     *         represents a primitive type, or if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassInfo.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -76,0 +78,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassesAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+     * @throws IllegalArgumentException if {@code startPc} or {@code lineNumber}\n+     *         is not {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTypeTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-     * {@return the access flags, as a bit mask}  It is in the range of unsigned\n-     * short, {@code [0, 0xFFFF]}.\n+     * {@return the access flags, as a bit mask}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -88,0 +88,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -108,0 +110,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParameterInfo.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}\n@@ -79,0 +81,2 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParametersAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-     * {@return the module flags of the module, as a bit mask}  It is in the\n-     * range of unsigned short, {@code [0, 0xFFFF]}.\n+     * {@return the module flags of the module, as a bit mask}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -173,0 +173,3 @@\n+     * @throws IllegalArgumentException if {@code moduleFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or any of the collections has a size\n+     *         over the limit of {@link java.lang.classfile##u2 u2}\n@@ -189,0 +192,3 @@\n+     * @throws IllegalArgumentException if the information from the handler exceeds\n+     *         the {@code class} file format limit, such as a list with size\n+     *         over the limit of {@link java.lang.classfile##u2 u2}\n@@ -233,0 +239,2 @@\n+         * @throws IllegalArgumentException if {@code flagsMask} is not {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -295,0 +303,2 @@\n+         * @throws IllegalArgumentException if the number of modules exceeds\n+         *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -306,1 +316,3 @@\n-         *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+         *         {@link AccessFlag.Location#MODULE_EXPORTS} location or the\n+         *         number of modules exceeds the limit of {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -332,0 +344,2 @@\n+         * @throws IllegalArgumentException if the number of modules exceeds the\n+         *         limit of {@link java.lang.classfile##u2 u2}\n@@ -348,1 +362,3 @@\n-         *         {@link AccessFlag.Location#MODULE_OPENS} location\n+         *         {@link AccessFlag.Location#MODULE_OPENS} location, or if the\n+         *         number of modules exceeds the limit of {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -390,1 +406,4 @@\n-         * @throws IllegalArgumentException if {@code service} or any of the {@code implClasses} represents a primitive type\n+         * @throws IllegalArgumentException if {@code service} or any of the\n+         *         {@code implClasses} represents a primitive type, or the\n+         *         number of implementations exceeds the limit of {@link\n+         *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-     * It is in the range of unsigned short, {@code [0, 0xFFFF]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -106,0 +106,3 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -120,1 +123,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -134,0 +139,3 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -149,1 +157,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -164,0 +174,3 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -180,1 +193,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -194,0 +209,3 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -209,1 +227,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleExportInfo.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -109,0 +111,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -119,0 +123,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -129,0 +135,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleHashesAttribute.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-     * It is in the range of unsigned short, {@code [0, 0xFFFF]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -112,0 +112,3 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -126,1 +129,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -140,0 +144,3 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -155,1 +162,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -169,0 +177,3 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -184,1 +195,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -197,0 +209,3 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -211,1 +226,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleOpenInfo.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -85,0 +87,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -93,0 +97,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -105,0 +111,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModulePackagesAttribute.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+     * @throws IllegalArgumentException if the number of implementations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -77,0 +79,2 @@\n+     * @throws IllegalArgumentException if the number of implementations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -88,1 +92,2 @@\n-     *         providesWith} represents a primitive type\n+     *         providesWith} represents a primitive type, or the number of\n+     *         implementations exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -100,1 +105,2 @@\n-     *         providesWith} represents a primitive type\n+     *         providesWith} represents a primitive type, or the number of\n+     *         implementations exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleProvideInfo.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-     * It is in the range of unsigned short, {@code [0, 0xFFFF]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -100,0 +100,2 @@\n+     * @throws IllegalArgumentException if {@code requiresFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -124,0 +126,2 @@\n+     * @throws IllegalArgumentException if {@code requiresFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleRequireInfo.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-     * {@return the module resolution flags}  It is in the range of unsigned\n-     * short, {@code [0, 0xFFFF]}.\n+     * {@return the module resolution flags}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -102,0 +102,2 @@\n+     * @throws IllegalArgumentException if {@code resolutionFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleResolutionAttribute.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+     * @throws IllegalArgumentException if the number of member classes exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -84,0 +86,2 @@\n+     * @throws IllegalArgumentException if the number of member classes exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -93,1 +97,3 @@\n-     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive\n+     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive,\n+     *         or if the number of member classes exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -103,1 +109,3 @@\n-     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive\n+     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive,\n+     *         or if the number of member classes exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestMembersAttribute.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+     * @throws IllegalArgumentException if the number of permitted subclasses\n+     *         or subinterfaces exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -89,0 +91,2 @@\n+     * @throws IllegalArgumentException if the number of permitted subclasses\n+     *         or subinterfaces exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -98,1 +102,3 @@\n-     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive\n+     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive,\n+     *         or if the number of permitted subclasses or subinterfaces exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -108,1 +114,3 @@\n-     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive\n+     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive,\n+     *         or if the number of permitted subclasses or subinterfaces exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/PermittedSubclassesAttribute.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+     * @throws IllegalArgumentException if the number of record components\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -80,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of record components\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,0 +93,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -106,0 +108,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -119,0 +123,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -134,0 +140,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordComponentInfo.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -85,0 +87,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,0 +89,4 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}, or the number of\n+     *         annotations on any parameter exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleParameterAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -91,0 +93,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleTypeAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -83,0 +85,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}, or the number of\n+     *         annotations on any parameter exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleParameterAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -91,0 +93,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleTypeAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.classfile.impl.StackMapGenerator;\n@@ -86,0 +87,2 @@\n+     * @throws IllegalArgumentException if the number of types in {@code locals}\n+     *         or {@code stack} exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -104,1 +107,1 @@\n-        int ITEM_TOP = 0;\n+        int ITEM_TOP = StackMapGenerator.ITEM_TOP;\n@@ -107,1 +110,1 @@\n-        int ITEM_INTEGER = 1;\n+        int ITEM_INTEGER = StackMapGenerator.ITEM_INTEGER;\n@@ -110,1 +113,1 @@\n-        int ITEM_FLOAT = 2;\n+        int ITEM_FLOAT = StackMapGenerator.ITEM_FLOAT;\n@@ -113,1 +116,1 @@\n-        int ITEM_DOUBLE = 3;\n+        int ITEM_DOUBLE = StackMapGenerator.ITEM_DOUBLE;\n@@ -116,1 +119,1 @@\n-        int ITEM_LONG = 4;\n+        int ITEM_LONG = StackMapGenerator.ITEM_LONG;\n@@ -119,1 +122,1 @@\n-        int ITEM_NULL = 5;\n+        int ITEM_NULL = StackMapGenerator.ITEM_NULL;\n@@ -122,1 +125,1 @@\n-        int ITEM_UNINITIALIZED_THIS = 6;\n+        int ITEM_UNINITIALIZED_THIS = StackMapGenerator.ITEM_UNINITIALIZED_THIS;\n@@ -125,1 +128,1 @@\n-        int ITEM_OBJECT = 7;\n+        int ITEM_OBJECT = StackMapGenerator.ITEM_OBJECT;\n@@ -128,1 +131,1 @@\n-        int ITEM_UNINITIALIZED = 8;\n+        int ITEM_UNINITIALIZED = StackMapGenerator.ITEM_UNINITIALIZED;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+     * @throws IllegalArgumentException if the number of frames exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-     * referring to a {@link MemberRefEntry}}  The reference kind must be\n+     * referring to a {@link MemberRefEntry}}  The reference kind is\n@@ -406,0 +406,2 @@\n+     * @throws IllegalArgumentException if {@code refKind} is not {@link\n+     *         java.lang.classfile##u1 u1}\n@@ -572,0 +574,2 @@\n+     * @throws IllegalArgumentException if the number of arguments exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -587,0 +591,2 @@\n+     * @throws IllegalArgumentException if the number of arguments exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n- * represent at most 65535 bytes of data due to the physical restrictions.\n+ * represent at most 65535 bytes of data due to the physical restrictions of\n+ * {@link java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/Utf8Entry.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/CharacterRange.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-     * where {@code slot} must be within {@code [0, 65535]}.\n+     * where {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -156,1 +156,1 @@\n-         * The value is within {@code [0, 65535]}.\n+         * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -163,3 +163,3 @@\n-         * {@code slot} must be in the closed range of {@code [0, 255]} for\n-         * {@link Opcode#RET ret}, or within {@code [0, 65535]} for {@link\n-         * Opcode#RET_W wide ret}.\n+         * {@code slot} must be {@link java.lang.classfile##u1 u1} for\n+         * {@link Opcode#RET ret}, or {@link java.lang.classfile##u2 u2} for\n+         * {@link Opcode#RET_W wide ret}.\n@@ -186,1 +186,1 @@\n-         * {@code slot} must be within {@code [0, 65535]}.\n+         * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -189,1 +189,2 @@\n-         * @throws IllegalArgumentException if {@code slot} is out of range\n+         * @throws IllegalArgumentException if {@code slot} is not {@link\n+         *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,2 +42,4 @@\n- * table entries.  Delivered as a {@link CodeElement} when traversing the\n- * contents of a {@link CodeModel}.\n+ * table entries.  The order of exception table entries is significant: when an\n+ * exception is thrown in a method, execution branches to the first matching\n+ * exception handler if such a handler exists (JVMS {@jvms 2.10}). Delivered as\n+ * a {@link CodeElement} when traversing the contents of a {@link CodeModel}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ExceptionCatch.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * <li>{@code slot} must be within {@code [0, 65535]}.\n+ * <li>{@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -76,1 +76,1 @@\n-     * <li>{@code slot} must be within {@code [0, 65535]}.\n+     * <li>{@code slot} must be {@link java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/IncrementInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+     * @throws IllegalArgumentException if {@code line} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LineNumber.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * computational}, and {@code slot} is within {@code [0, 65535]}.\n+ * computational}, and {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -65,1 +65,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -79,1 +79,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be a {@link java.lang.classfile##u2 u2} value.\n@@ -84,1 +84,2 @@\n-     *         {@link TypeKind#VOID void} or {@code slot} is out of range\n+     *         {@link TypeKind#VOID void} or {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -99,2 +100,4 @@\n-     * <li>If {@code op} has size 2, {@code slot} must be within {@code [0, 255]}.\n-     * <li>If {@code op} has size 4, {@code slot} must be within {@code [0, 65535]}.\n+     * <li>If {@code op} has size 2, {@code slot} must be {@link\n+     *     java.lang.classfile##u1 u1}.\n+     * <li>If {@code op} has size 4, {@code slot} must be {@link\n+     *     java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LoadInstruction.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * Where {@code slot} is within {@code [0, 65535]}.\n+ * Where {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -82,1 +82,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -119,1 +119,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -126,1 +126,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -135,1 +136,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -142,1 +143,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariable.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * Where {@code slot} is within {@code [0, 65535]}.\n+ * Where {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -75,1 +75,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -112,1 +112,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -119,1 +119,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -128,1 +129,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -135,1 +136,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariableType.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * computational}, and {@code slot} is within {@code [0, 65535]}.\n+ * computational}, and {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -69,1 +69,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -85,1 +85,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -90,1 +90,2 @@\n-     *         TypeKind#VOID void} or {@code slot} is out of range\n+     *         TypeKind#VOID void} or {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -105,2 +106,4 @@\n-     * <li>If {@code op} has size 2, {@code slot} must be within {@code [0, 255]}.\n-     * <li>If {@code op} has size 4, {@code slot} must be within {@code [0, 65535]}.\n+     * <li>If {@code op} has size 2, {@code slot} must be {@link\n+     *     java.lang.classfile##u1 u1}.\n+     * <li>If {@code op} has size 4, {@code slot} must be {@link\n+     *     java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/StoreInstruction.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n- * will cause a {@code NullPointerException}, unless otherwise specified. <\/p>\n+ * will cause a {@code NullPointerException}, unless otherwise specified.\n@@ -276,0 +276,8 @@\n+ * The Class-File API performs checks to ensure arguments are representable in\n+ * the {@code class} file format.  A value that is lost when it is built to a\n+ * {@code class} file and re-parsed to a model is rejected with an {@link\n+ * IllegalArgumentException}.  For example, a negative value or a value over\n+ * {@code 65535} is lost when built to a {@link ##u2 u2} item, with\n+ * the range {@code [0, 65535]}.  In particular, any variable-sized table\n+ * exceeding its maximum representable size is rejected.\n+ * <p>\n@@ -277,3 +285,4 @@\n- * (except for null arguments checks). All builders and classfile elements factory\n- * methods accepts the provided information without implicit validation.\n- * However, fatal inconsistencies (like for example invalid code sequence or\n+ * (except for null and representable arguments checks). All builders and\n+ * classfile elements factory methods accepts the provided information without\n+ * implicit validation, as long as they are representable in the {@code class}\n+ * file format.  However, fatal inconsistencies (like invalid code sequence or\n@@ -282,1 +291,1 @@\n- * {@link IllegalArgumentException}.\n+ * {@code IllegalArgumentException}.\n@@ -297,3 +306,3 @@\n- * directly from raw values, with no additional conversions or validations.\n- * Following example uses intentionally wrong class name form and it is applied\n- * without any validation or conversion.\n+ * directly from raw values, with no additional conversions or validations, as\n+ * long as they are representable.  Following example uses intentionally wrong\n+ * class name form, which is applied without any validation or conversion.\n@@ -454,0 +463,23 @@\n+ * <h3 id=\"data-types\">Conventional data types<\/h3>\n+ * Chapter {@jvms 4} of the <cite>Java Virtual Machine Specification<\/cite>\n+ * defines a few conventional data types in the {@code class} file format.\n+ * They are consistently represented as {@code int} in the API model.\n+ * Out-of-bound values provided for these data types to the API result in {@link\n+ * IllegalArgumentException}.\n+ * <dl>\n+ * <dt id=\"u1\">{@code u1}<\/dt>\n+ * <dd>One-byte {@linkplain Byte#toUnsignedInt(byte) unsigned} integer, in the\n+ * range {@code [0, 255]}.\n+ * <br>See {@link java.io.DataInput#readUnsignedByte()}.<\/dd>\n+ * <dt id=\"u2\">{@code u2}<\/dt>\n+ * <dd>Two-byte {@linkplain Short#toUnsignedInt(short) unsigned} integer, in the\n+ * range {@code [0, 65535]}.\n+ * <br>Equivalent to a Java {@link Character char}.  Frequently used for flag\n+ * fields and indices and sizes of list structures.\n+ * <br>See {@link java.io.DataInput#readUnsignedShort()}.<\/dd>\n+ * <dt id=\"u4\">{@code u4}<\/dt>\n+ * <dd>Four-byte {@linkplain Integer#toUnsignedLong(int) unsigned} integer, in\n+ * the range {@code [0, 4294967295]}.\n+ * <br>See {@link java.io.DataInput#readInt()}.<\/dd>\n+ * <\/dl>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.constant;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-\n-import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n-import static java.lang.constant.ConstantDescs.CD_MethodHandle;\n-import static java.util.Objects.requireNonNull;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n- * {@link MethodHandle} constant that performs a {@link MethodHandle#asType(MethodType)}\n- * adaptation on another {@link MethodHandle}.\n- *\/\n-final class AsTypeMethodHandleDesc extends DynamicConstantDesc<MethodHandle>\n-        implements MethodHandleDesc {\n-\n-    private final MethodHandleDesc underlying;\n-    private final MethodTypeDesc type;\n-\n-    AsTypeMethodHandleDesc(MethodHandleDesc underlying, MethodTypeDesc type) {\n-        super(BSM_INVOKE, ConstantDescs.DEFAULT_NAME, CD_MethodHandle,\n-              ConstantDescs.MHD_METHODHANDLE_ASTYPE, underlying, type);\n-        this.underlying = requireNonNull(underlying);\n-        this.type = requireNonNull(type);\n-    }\n-\n-    @Override\n-    public MethodTypeDesc invocationType() {\n-        return type;\n-    }\n-\n-    @Override\n-    public MethodHandle resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        MethodHandle handle = underlying.resolveConstantDesc(lookup);\n-        MethodType methodType = type.resolveConstantDesc(lookup);\n-        return handle.asType(methodType);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return  String.format(\"%s.asType%s\", underlying.toString(), type.displayDescriptor());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/AsTypeMethodHandleDesc.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -47,1 +47,0 @@\n-import static java.lang.constant.DirectMethodHandleDesc.*;\n@@ -341,3 +340,0 @@\n-    static final DirectMethodHandleDesc MHD_METHODHANDLE_ASTYPE\n-            = MethodHandleDesc.ofMethod(Kind.VIRTUAL, CD_MethodHandle, \"asType\",\n-                                        MethodTypeDesc.of(CD_MethodHandle, CD_MethodType));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.internal.constant.AsTypeMethodHandleDesc;\n@@ -84,9 +85,5 @@\n-        switch (kind) {\n-            case GETTER:\n-            case SETTER:\n-            case STATIC_GETTER:\n-            case STATIC_SETTER:\n-                return ofField(kind, owner, name, ClassDesc.ofDescriptor(lookupDescriptor));\n-            default:\n-                return new DirectMethodHandleDescImpl(kind, owner, name, MethodTypeDesc.ofDescriptor(lookupDescriptor));\n-        }\n+        return switch (kind) {\n+            case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER\n+                    -> ofField(kind, owner, name, ClassDesc.ofDescriptor(lookupDescriptor));\n+            default -> new DirectMethodHandleDescImpl(kind, owner, name, MethodTypeDesc.ofDescriptor(lookupDescriptor));\n+        };\n@@ -124,17 +121,7 @@\n-        switch (kind) {\n-            case GETTER:\n-            case SETTER:\n-            case STATIC_GETTER:\n-            case STATIC_SETTER:\n-                throw new IllegalArgumentException(kind.toString());\n-            case VIRTUAL:\n-            case SPECIAL:\n-            case INTERFACE_VIRTUAL:\n-            case INTERFACE_SPECIAL:\n-            case INTERFACE_STATIC:\n-            case STATIC:\n-            case CONSTRUCTOR:\n-                return new DirectMethodHandleDescImpl(kind, owner, name, lookupMethodType);\n-            default:\n-                throw new IllegalArgumentException(kind.toString());\n-        }\n+        return switch (kind) {\n+            case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER\n+                    -> throw new IllegalArgumentException(kind.toString());\n+            case VIRTUAL, SPECIAL, INTERFACE_VIRTUAL, INTERFACE_SPECIAL, INTERFACE_STATIC, STATIC, CONSTRUCTOR\n+                    -> new DirectMethodHandleDescImpl(kind, owner, name, lookupMethodType);\n+            default -> throw new IllegalArgumentException(kind.toString());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":14,"deletions":27,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -41,7 +41,17 @@\n-\/**\n- * The flavor of method handle which emulates an invoke instruction\n- * on a predetermined argument.  The JVM dispatches to the correct method\n- * when the handle is created, not when it is invoked.\n- *\n- * All bound arguments are encapsulated in dedicated species.\n- *\/\n+\/\/\/ The flavor of method handle which is constructed with unmodifiable bound values,\n+\/\/\/ usable by lambda forms. For example, they can carry a configuration object\n+\/\/\/ for its lambda form, or carry an underlying method handle and its bound\n+\/\/\/ arguments for currying.\n+\/\/\/\n+\/\/\/ Each BMH class supports a number of values, each of a particular [BasicType].\n+\/\/\/ This per-class value type and count information is recorded by [SpeciesData].\n+\/\/\/ A [Specializer] manages lookup for any species.\n+\/\/\/\n+\/\/\/ Factories are provided by [BoundMethodHandle.SpeciesData#factory()].\n+\/\/\/ Getters are exposed as [BoundMethodHandle.SpeciesData#getter(int)],\n+\/\/\/ which can be included as names in lambda forms.\n+\/\/\/\n+\/\/\/ [SimpleMethodHandle] (with no bound value) and [Species_L] (with a bound\n+\/\/\/ reference value) are explicitly provided to prevent bootstrap loops; the\n+\/\/\/ rest may be generated on demand, or may be pregenerated by\n+\/\/\/ [GenerateJLIClassesHelper].\n@@ -468,12 +478,4 @@\n-        \/**\n-         * Generation of concrete BMH classes.\n-         *\n-         * A concrete BMH species is fit for binding a number of values adhering to a\n-         * given type pattern. Reference types are erased.\n-         *\n-         * BMH species are cached by type pattern.\n-         *\n-         * A BMH species has a number of fields with the concrete (possibly erased) types of\n-         * bound values. Setters are provided as an API in BMH. Getters are exposed as MHs,\n-         * which can be included as names in lambda forms.\n-         *\/\n+        \/\/\/ Generates concrete BMH classes.\n+        \/\/\/\n+        \/\/\/ [GenerateJLIClassesHelper] can pre-generate species that are known\n+        \/\/\/ to be loaded from [MethodHandleStatics#traceSpeciesType].\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,11 +372,26 @@\n-     * <li>If {@code dstType} is a reference type, a reference cast\n-     *     is applied to {@code value} as if by calling {@code dstType.cast(value)}.\n-     * <li>If {@code dstType} is a primitive type, then, if the runtime type\n-     *     of {@code value} is a primitive wrapper type (such as {@link Integer}),\n-     *     a Java unboxing conversion is applied {@jls 5.1.8} followed by a\n-     *     Java casting conversion {@jls 5.5} converting either directly to\n-     *     {@code dstType}, or, if {@code dstType} is {@code boolean},\n-     *     to {@code int}, which is then converted to either {@code true}\n-     *     or {@code false} depending on whether the least-significant-bit\n-     *     is 1 or 0 respectively. If the runtime type of {@code value} is\n-     *     not a primitive wrapper type a {@link ClassCastException} is thrown.\n+     * <li>If {@code dstType} is a reference type, a reference cast is applied\n+     *     to {@code value} as if by calling {@link Class#cast(Object)\n+     *     dstType.cast(value)}.\n+     * <li>Otherwise, {@code dstType} is a primitive type:\n+     *     <ol>\n+     *     <li>If {@code value} is null, the default value (JVMS {@jvms 2.3})\n+     *         of {@code dstType} is returned.\n+     *     <li>If the runtime type of {@code value} is a primitive wrapper type\n+     *         (such as {@link Integer}), a Java unboxing conversion is applied\n+     *         (JLS {@jls 5.1.8}).\n+     *         <ul>\n+     *         <li>If the runtime type is {@link Boolean}, the unboxing result\n+     *             is then converted to {@code int}, where {@code true} becomes\n+     *             {@code 1} and {@code false} becomes {@code 0}.\n+     *         <\/ul>\n+     *         Followed by a Java casting conversion (JLS {@jls 5.5}):\n+     *         <ul>\n+     *         <li>If {@code dstType} is not {@code boolean}, the cast converts\n+     *             directly to {@code dstType}.\n+     *         <li>If {@code dstType} is {@code boolean}, the cast converts to\n+     *             {@code int}, and the resulting {@code boolean} is produced\n+     *             by testing whether the least significant bit of the cast\n+     *             {@code int} is 1.\n+     *         <\/ul>\n+     *     <li>Otherwise, a {@link ClassCastException} is thrown.\n+     *     <\/ol>\n@@ -396,1 +411,1 @@\n-     * @param value the value to be converted\n+     * @param value the value to be converted, may be null\n@@ -398,5 +413,4 @@\n-     * @throws ClassCastException when {@code dstType} is {@code void},\n-     *         when a cast per (1) fails, or when {@code dstType} is a primitive type\n-     *         and the runtime type of {@code value} is not a primitive wrapper type\n-     *         (such as {@link Integer})\n-     *\n+     * @throws ClassCastException when {@code dstType} is {@code void}; when\n+     *         {@code dstType} is a reference type, and the reference cast fails; or\n+     *         when {@code dstType} is primitive, and {@code value} is an\n+     *         instance of a reference type that is not a wrapper class\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":32,"deletions":18,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -199,1 +199,7 @@\n-    \/* Placeholder class for DelegatingMethodHandles generated ahead of time *\/\n+    \/\/\/ Holds pre-generated bytecode for lambda forms used by DelegatingMethodHandle.\n+    \/\/\/\n+    \/\/\/ This class may be substituted in the JDK's modules image, or in an AOT\n+    \/\/\/ cache, by a version generated by [GenerateJLIClassesHelper].\n+    \/\/\/\n+    \/\/\/ The method names of this class are internal tokens recognized by\n+    \/\/\/ [InvokerBytecodeGenerator#lookupPregenerated] and are subject to change.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DelegatingMethodHandle.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -942,1 +942,7 @@\n-    \/* Placeholder class for DirectMethodHandles generated ahead of time *\/\n+    \/\/\/ Holds pre-generated bytecode for lambda forms used by DirectMethodHandle.\n+    \/\/\/\n+    \/\/\/ This class may be substituted in the JDK's modules image, or in an AOT\n+    \/\/\/ cache, by a version generated by [GenerateJLIClassesHelper].\n+    \/\/\/\n+    \/\/\/ The method names of this class are internal tokens recognized by\n+    \/\/\/ [InvokerBytecodeGenerator#lookupPregenerated] and are subject to change.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,5 +50,66 @@\n-\/**\n- * Helper class to assist the GenerateJLIClassesPlugin to get access to\n- * generate classes ahead of time.\n- *\/\n-class GenerateJLIClassesHelper {\n+\/\/\/ Generates bound method handle species classes, and classes with methods that\n+\/\/\/ hold compiled lambda form bytecode ahead of time, so certain lambda forms\n+\/\/\/ no longer need to spin classes because they can find existing bytecode.\n+\/\/\/ Bytecode pre-generation reduces static initialization costs, footprint costs,\n+\/\/\/ and circular dependencies that may arise if a class is generated per\n+\/\/\/ LambdaForm by [InvokerBytecodeGenerator].\n+\/\/\/\n+\/\/\/ Since lambda forms and bound method handle species are closely tied to\n+\/\/\/ method types, which have many varieties, this generator needs *traces* to\n+\/\/\/ detect which method types are used, so generation matches the actual usage.\n+\/\/\/ See the main entrypoint [#generateHolderClasses(Stream)] for more details\n+\/\/\/ about *traces*.\n+\/\/\/\n+\/\/\/ Note this pregeneration does not cover all lambda forms that can be created.\n+\/\/\/ For example, forms created by [LambdaFormEditor] are not captured.\n+\/\/\/\n+\/\/\/ Pregenerated species classes are resolved in [ClassSpecializer.Factory#loadSpecies]\n+\/\/\/ and behave identically to on-demand generated ones.  Pregenerated lambda\n+\/\/\/ forms are resolved in [InvokerBytecodeGenerator#lookupPregenerated], which\n+\/\/\/ looks up methods for code from the following 4 possibly-generated classes:\n+\/\/\/  -  [Invokers.Holder]\n+\/\/\/  -  [DirectMethodHandle.Holder]\n+\/\/\/  -  [DelegatingMethodHandle.Holder]\n+\/\/\/  -  [LambdaForm.Holder]\n+\/\/\/\n+\/\/\/ [VarHandle] linker forms, analogous to invoker forms in [Invokers.Holder],\n+\/\/\/ have a similar pre-generation system except it is done at source generation;\n+\/\/\/ they reside in [VarHandleGuards].\n+\/\/\/\n+\/\/\/ ## Usages of this generator\n+\/\/\/ Currently, `GenerateJLIClassesHelper` is invoked when creating a modular JDK\n+\/\/\/ image or generating an AOT cache.\n+\/\/\/\n+\/\/\/ #### Modular Image\n+\/\/\/ When creating a modular JDK image,\n+\/\/\/ `jdk.tools.jlink.internal.plugins.GenerateJLIClassesPlugin` passes the\n+\/\/\/ *traces* in the file `jdk\/tools\/jlink\/internal\/plugins\/default_jli_trace.txt`\n+\/\/\/ in `$JAVA_HOME\/lib\/modules` to this generator.  The *traces* are generated\n+\/\/\/ from the execution of `build.tools.classlist.HelloClasslist` in the build\n+\/\/\/ process of the JDK.\n+\/\/\/\n+\/\/\/ > To list all the Species classes in a JDK image:\n+\/\/\/ > ```\n+\/\/\/ > jimage list $JAVA_HOME\/lib\/modules | grep BoundMethodHandle.Species_\n+\/\/\/ > ```\n+\/\/\/\n+\/\/\/ > All these pregenerated classes can be examined by javap in the same image:\n+\/\/\/ > (Note to escape `$` in bash)\n+\/\/\/ > ```\n+\/\/\/ > javap -c -p -v java.lang.invoke.LambdaForm\\$Holder\n+\/\/\/ > ```\n+\/\/\/\n+\/\/\/ #### AOT Cache\n+\/\/\/ When creating an AOT cache, *traces* generated from the training run are\n+\/\/\/ captured and stored inside the AOT configuration file, and are accessed with\n+\/\/\/ the C++ `FinalImageRecipes` class.  Classes regenerated from these *traces*\n+\/\/\/ are linked in assembly phase; see `regeneratedClasses.hpp`.\n+\/\/\/\n+\/\/\/ @see #generateHolderClasses(Stream)\n+\/\/\/ @see BoundMethodHandle.Specializer\n+\/\/\/ @see DelegatingMethodHandle.Holder\n+\/\/\/ @see DirectMethodHandle.Holder\n+\/\/\/ @see Invokers.Holder\n+\/\/\/ @see LambdaForm.Holder\n+\/\/\/ @see VarHandleGuards\n+final class GenerateJLIClassesHelper {\n@@ -324,7 +385,17 @@\n-    \/*\n-     * Returns a map of class name in internal form to the corresponding class bytes\n-     * per the given stream of SPECIES_RESOLVE and LF_RESOLVE trace logs.\n-     *\n-     * Used by GenerateJLIClassesPlugin to pre-generate holder classes during\n-     * jlink phase.\n-     *\/\n+    \/\/\/ Returns a map from class names in internal form to the corresponding\n+    \/\/\/ class bytes.\n+    \/\/\/\n+    \/\/\/ A few known lambda forms, such as field accessors, can be comprehensively\n+    \/\/\/ generated.  Most others lambda forms are associated with unique method\n+    \/\/\/ types; thus they are generated per the given stream of SPECIES_RESOLVE\n+    \/\/\/ and LF_RESOLVE *trace* logs, which are created according to {@link\n+    \/\/\/ MethodHandleStatics#TRACE_RESOLVE} configuration.\n+    \/\/\/\n+    \/\/\/ The names of methods in the generated classes are internal tokens\n+    \/\/\/ recognized by [InvokerBytecodeGenerator#lookupPregenerated] and are\n+    \/\/\/ subject to change.\n+    \/\/\/\n+    \/\/\/ @param traces the *traces* to determine the lambda forms and species\n+    \/\/\/        to generate\n+    \/\/\/ @see MethodHandleStatics#traceLambdaForm\n+    \/\/\/ @see MethodHandleStatics#traceSpeciesType\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":83,"deletions":12,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -448,0 +448,1 @@\n+    \/\/\/ Look up a method that may have been generated by [GenerateJLIClassesHelper].\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -700,1 +700,7 @@\n-    \/* Placeholder class for Invokers generated ahead of time *\/\n+    \/\/\/ Holds pre-generated bytecode for lambda forms used by method type invokers.\n+    \/\/\/\n+    \/\/\/ This class may be substituted in the JDK's modules image, or in an AOT\n+    \/\/\/ cache, by a version generated by [GenerateJLIClassesHelper].\n+    \/\/\/\n+    \/\/\/ The method names of this class are internal tokens recognized by\n+    \/\/\/ [InvokerBytecodeGenerator#lookupPregenerated] and are subject to change.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -142,0 +142,3 @@\n+    \/\/\/ Represents the \"basic\" types that exist in the JVM linkage and stack\/locals.\n+    \/\/\/ All objects are erased to a reference.\n+    \/\/\/ All subwords (boolean, byte, char, short) are promoted to int.\n@@ -143,1 +146,1 @@\n-        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.REFERENCE), \/\/ all reference types\n+        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.REFERENCE),\n@@ -147,2 +150,2 @@\n-        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DOUBLE),  \/\/ all primitive types\n-        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VOID);    \/\/ not valid in all contexts\n+        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DOUBLE),  \/\/ end arg types\n+        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VOID);    \/\/ only valid in method return\n@@ -1733,1 +1736,7 @@\n-    \/* Placeholder class for identity and constant forms generated ahead of time *\/\n+    \/\/\/ Holds pre-generated bytecode for common lambda forms.\n+    \/\/\/\n+    \/\/\/ This class may be substituted in the JDK's modules image, or in an AOT\n+    \/\/\/ cache, by a version generated by [GenerateJLIClassesHelper].\n+    \/\/\/\n+    \/\/\/ The method names of this class are internal tokens recognized by\n+    \/\/\/ [InvokerBytecodeGenerator#lookupPregenerated] and are subject to change.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,1619 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.invoke;\n-\n-import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Hidden;\n-\n-\/\/ This class is auto-generated by java.lang.invoke.VarHandles$GuardMethodGenerator. Do not edit.\n-@AOTSafeClassInitializer\n-final class VarHandleGuards {\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_L_L(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_L_I(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_L_J(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_L_F(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_L_D(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard__L(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard__I(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard__J(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard__F(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard__D(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LI_L(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LI_I(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LI_J(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LI_F(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LI_D(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJ_L(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJ_I(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LJ_J(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJ_F(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJ_D(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJJ_L(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJJ_I(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJJ_F(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJJ_D(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LL_V(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LI_V(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJ_V(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LF_V(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LD_V(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_L_V(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_I_V(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_J_V(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_F_V(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_D_V(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LIL_V(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LII_V(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LIJ_V(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LIF_V(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LID_V(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJL_V(VarHandle handle, Object arg0, long arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJI_V(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJ_V(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJF_V(VarHandle handle, Object arg0, long arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJD_V(VarHandle handle, Object arg0, long arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJL_V(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJI_V(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJJ_V(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJF_V(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJD_V(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LL_Z(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LIII_Z(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJLL_Z(VarHandle handle, Object arg0, long arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJFF_Z(VarHandle handle, Object arg0, long arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJDD_Z(VarHandle handle, Object arg0, long arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJLL_Z(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, Object arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJII_Z(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, int arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, long arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJFF_Z(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, float arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJDD_Z(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, double arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LIII_I(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJLL_L(VarHandle handle, Object arg0, long arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LJJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJFF_F(VarHandle handle, Object arg0, long arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJDD_D(VarHandle handle, Object arg0, long arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJJLL_L(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, Object arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJJII_I(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, int arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LJJJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, long arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJJFF_F(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, float arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJJDD_D(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, double arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LID_D(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJL_L(VarHandle handle, Object arg0, long arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJF_F(VarHandle handle, Object arg0, long arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJD_D(VarHandle handle, Object arg0, long arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJJL_L(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJJI_I(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJJF_F(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJJD_D(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":0,"deletions":1619,"binary":false,"changes":1619,"status":"deleted"},{"patch":"@@ -660,238 +660,0 @@\n-\n-\/\/    \/**\n-\/\/     * A helper program to generate the VarHandleGuards class with a set of\n-\/\/     * static guard methods each of which corresponds to a particular shape and\n-\/\/     * performs a type check of the symbolic type descriptor with the VarHandle\n-\/\/     * type descriptor before linking\/invoking to the underlying operation as\n-\/\/     * characterized by the operation member name on the VarForm of the\n-\/\/     * VarHandle.\n-\/\/     * <p>\n-\/\/     * The generated class essentially encapsulates pre-compiled LambdaForms,\n-\/\/     * one for each method, for the most set of common method signatures.\n-\/\/     * This reduces static initialization costs, footprint costs, and circular\n-\/\/     * dependencies that may arise if a class is generated per LambdaForm.\n-\/\/     * <p>\n-\/\/     * A maximum of L*T*S methods will be generated where L is the number of\n-\/\/     * access modes kinds (or unique operation signatures) and T is the number\n-\/\/     * of variable types and S is the number of shapes (such as instance field,\n-\/\/     * static field, or array access).\n-\/\/     * If there are 4 unique operation signatures, 5 basic types (Object, int,\n-\/\/     * long, float, double), and 3 shapes then a maximum of 60 methods will be\n-\/\/     * generated.  However, the number is likely to be less since there\n-\/\/     * be duplicate signatures.\n-\/\/     * <p>\n-\/\/     * Each method is annotated with @LambdaForm.Compiled to inform the runtime\n-\/\/     * that such methods should be treated as if a method of a class that is the\n-\/\/     * result of compiling a LambdaForm.  Annotation of such methods is\n-\/\/     * important for correct evaluation of certain assertions and method return\n-\/\/     * type profiling in HotSpot.\n-\/\/     *\/\n-\/\/    public static class GuardMethodGenerator {\n-\/\/\n-\/\/        static final String GUARD_METHOD_SIG_TEMPLATE = \"<RETURN> <NAME>_<SIGNATURE>(<PARAMS>)\";\n-\/\/\n-\/\/        static final String GUARD_METHOD_TEMPLATE =\n-\/\/                \"\"\"\n-\/\/                @ForceInline\n-\/\/                @LambdaForm.Compiled\n-\/\/                @Hidden\n-\/\/                static final <METHOD> throws Throwable {\n-\/\/                    boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-\/\/                    if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-\/\/                        <RESULT_ERASED>MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);<RETURN_ERASED>\n-\/\/                    } else {\n-\/\/                        MethodHandle mh = handle.getMethodHandle(ad.mode);\n-\/\/                        <RETURN>mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n-\/\/                    }\n-\/\/                }\"\"\";\n-\/\/\n-\/\/        static final String GUARD_METHOD_TEMPLATE_V =\n-\/\/                \"\"\"\n-\/\/                @ForceInline\n-\/\/                @LambdaForm.Compiled\n-\/\/                @Hidden\n-\/\/                static final <METHOD> throws Throwable {\n-\/\/                    boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-\/\/                    if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-\/\/                        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n-\/\/                    } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-\/\/                        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n-\/\/                    } else {\n-\/\/                        MethodHandle mh = handle.getMethodHandle(ad.mode);\n-\/\/                        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n-\/\/                    }\n-\/\/                }\"\"\";\n-\/\/\n-\/\/        \/\/ A template for deriving the operations\n-\/\/        \/\/ could be supported by annotating VarHandle directly with the\n-\/\/        \/\/ operation kind and shape\n-\/\/        interface VarHandleTemplate {\n-\/\/            Object get();\n-\/\/\n-\/\/            void set(Object value);\n-\/\/\n-\/\/            boolean compareAndSet(Object actualValue, Object expectedValue);\n-\/\/\n-\/\/            Object compareAndExchange(Object actualValue, Object expectedValue);\n-\/\/\n-\/\/            Object getAndUpdate(Object value);\n-\/\/        }\n-\/\/\n-\/\/        record HandleType(Class<?> receiver, Class<?>... intermediates) {\n-\/\/        }\n-\/\/\n-\/\/        \/**\n-\/\/         * @param args parameters\n-\/\/         *\/\n-\/\/        public static void main(String[] args) {\n-\/\/            System.out.println(\"package java.lang.invoke;\");\n-\/\/            System.out.println();\n-\/\/            System.out.println(\"import jdk.internal.vm.annotation.AOTSafeClassInitializer;\");\n-\/\/            System.out.println(\"import jdk.internal.vm.annotation.ForceInline;\");\n-\/\/            System.out.println(\"import jdk.internal.vm.annotation.Hidden;\");\n-\/\/            System.out.println();\n-\/\/            System.out.println(\"\/\/ This class is auto-generated by \" +\n-\/\/                               GuardMethodGenerator.class.getName() +\n-\/\/                               \". Do not edit.\");\n-\/\/            System.out.println(\"@AOTSafeClassInitializer\");\n-\/\/            System.out.println(\"final class VarHandleGuards {\");\n-\/\/\n-\/\/            System.out.println();\n-\/\/\n-\/\/            \/\/ Declare the stream of shapes\n-\/\/            List<HandleType> hts = List.of(\n-\/\/                    \/\/ Object->T\n-\/\/                    new HandleType(Object.class),\n-\/\/\n-\/\/                    \/\/ <static>->T\n-\/\/                    new HandleType(null),\n-\/\/\n-\/\/                    \/\/ Array[index]->T\n-\/\/                    new HandleType(Object.class, int.class),\n-\/\/\n-\/\/                    \/\/ MS[base]->T\n-\/\/                    new HandleType(Object.class, long.class),\n-\/\/\n-\/\/                    \/\/ MS[base][offset]->T\n-\/\/                    new HandleType(Object.class, long.class, long.class)\n-\/\/            );\n-\/\/\n-\/\/            Stream.of(VarHandleTemplate.class.getMethods()).<MethodType>\n-\/\/                    mapMulti((m, sink) -> {\n-\/\/                        for (var ht : hts) {\n-\/\/                            for (var bt : LambdaForm.BasicType.ARG_TYPES) {\n-\/\/                                sink.accept(generateMethodType(m, ht.receiver, bt.btClass, ht.intermediates));\n-\/\/                            }\n-\/\/                        }\n-\/\/                    }).\n-\/\/                    distinct().\n-\/\/                    map(GuardMethodGenerator::generateMethod).\n-\/\/                    forEach(System.out::println);\n-\/\/\n-\/\/            System.out.println(\"}\");\n-\/\/        }\n-\/\/\n-\/\/        static MethodType generateMethodType(Method m, Class<?> receiver, Class<?> value, Class<?>... intermediates) {\n-\/\/            Class<?> returnType = m.getReturnType() == Object.class\n-\/\/                                  ? value : m.getReturnType();\n-\/\/\n-\/\/            List<Class<?>> params = new ArrayList<>();\n-\/\/            if (receiver != null)\n-\/\/                params.add(receiver);\n-\/\/            java.util.Collections.addAll(params, intermediates);\n-\/\/            for (var p : m.getParameters()) {\n-\/\/                params.add(value);\n-\/\/            }\n-\/\/            return MethodType.methodType(returnType, params);\n-\/\/        }\n-\/\/\n-\/\/        static String generateMethod(MethodType mt) {\n-\/\/            Class<?> returnType = mt.returnType();\n-\/\/\n-\/\/            var params = new java.util.LinkedHashMap<String, Class<?>>();\n-\/\/            params.put(\"handle\", VarHandle.class);\n-\/\/            for (int i = 0; i < mt.parameterCount(); i++) {\n-\/\/                params.put(\"arg\" + i, mt.parameterType(i));\n-\/\/            }\n-\/\/            params.put(\"ad\", VarHandle.AccessDescriptor.class);\n-\/\/\n-\/\/            \/\/ Generate method signature line\n-\/\/            String RETURN = className(returnType);\n-\/\/            String NAME = \"guard\";\n-\/\/            String SIGNATURE = getSignature(mt);\n-\/\/            String PARAMS = params.entrySet().stream().\n-\/\/                    map(e -> className(e.getValue()) + \" \" + e.getKey()).\n-\/\/                    collect(java.util.stream.Collectors.joining(\", \"));\n-\/\/            String METHOD = GUARD_METHOD_SIG_TEMPLATE.\n-\/\/                    replace(\"<RETURN>\", RETURN).\n-\/\/                    replace(\"<NAME>\", NAME).\n-\/\/                    replace(\"<SIGNATURE>\", SIGNATURE).\n-\/\/                    replace(\"<PARAMS>\", PARAMS);\n-\/\/\n-\/\/            \/\/ Generate method\n-\/\/            params.remove(\"ad\");\n-\/\/\n-\/\/            List<String> LINK_TO_STATIC_ARGS = new ArrayList<>(params.keySet());\n-\/\/            LINK_TO_STATIC_ARGS.add(\"handle.vform.getMemberName(ad.mode)\");\n-\/\/\n-\/\/            List<String> LINK_TO_INVOKER_ARGS = new ArrayList<>(params.keySet());\n-\/\/            LINK_TO_INVOKER_ARGS.set(0, LINK_TO_INVOKER_ARGS.get(0) + \".asDirect()\");\n-\/\/\n-\/\/            RETURN = returnType == void.class\n-\/\/                     ? \"\"\n-\/\/                     : returnType == Object.class\n-\/\/                       ? \"return \"\n-\/\/                       : \"return (\" + returnType.getName() + \") \";\n-\/\/\n-\/\/            String RESULT_ERASED = returnType == void.class\n-\/\/                                   ? \"\"\n-\/\/                                   : returnType != Object.class\n-\/\/                                     ? \"return (\" + returnType.getName() + \") \"\n-\/\/                                     : \"Object r = \";\n-\/\/\n-\/\/            String RETURN_ERASED = returnType != Object.class\n-\/\/                                   ? \"\"\n-\/\/                                   : \"\\n        return ad.returnType.cast(r);\";\n-\/\/\n-\/\/            String template = returnType == void.class\n-\/\/                              ? GUARD_METHOD_TEMPLATE_V\n-\/\/                              : GUARD_METHOD_TEMPLATE;\n-\/\/            return template.\n-\/\/                    replace(\"<METHOD>\", METHOD).\n-\/\/                    replace(\"<NAME>\", NAME).\n-\/\/                    replaceAll(\"<RETURN>\", RETURN).\n-\/\/                    replace(\"<RESULT_ERASED>\", RESULT_ERASED).\n-\/\/                    replace(\"<RETURN_ERASED>\", RETURN_ERASED).\n-\/\/                    replaceAll(\"<LINK_TO_STATIC_ARGS>\", String.join(\", \", LINK_TO_STATIC_ARGS)).\n-\/\/                    replace(\"<LINK_TO_INVOKER_ARGS>\", String.join(\", \", LINK_TO_INVOKER_ARGS))\n-\/\/                    .indent(4);\n-\/\/        }\n-\/\/\n-\/\/        static String className(Class<?> c) {\n-\/\/            String n = c.getName();\n-\/\/            if (n.startsWith(\"java.lang.\")) {\n-\/\/                n = n.replace(\"java.lang.\", \"\");\n-\/\/                if (n.startsWith(\"invoke.\")) {\n-\/\/                    n = n.replace(\"invoke.\", \"\");\n-\/\/                }\n-\/\/            }\n-\/\/            return n.replace('$', '.');\n-\/\/        }\n-\/\/\n-\/\/        static String getSignature(MethodType m) {\n-\/\/            StringBuilder sb = new StringBuilder(m.parameterCount() + 1);\n-\/\/\n-\/\/            for (int i = 0; i < m.parameterCount(); i++) {\n-\/\/                Class<?> pt = m.parameterType(i);\n-\/\/                sb.append(getCharType(pt));\n-\/\/            }\n-\/\/\n-\/\/            sb.append('_').append(getCharType(m.returnType()));\n-\/\/\n-\/\/            return sb.toString();\n-\/\/        }\n-\/\/\n-\/\/        static char getCharType(Class<?> pt) {\n-\/\/            return Wrapper.forBasicType(pt).basicTypeChar();\n-\/\/        }\n-\/\/    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":0,"deletions":238,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -1519,5 +1519,1 @@\n-     * Returns the set of packages in the module.\n-     *\n-     * <p> The set of packages includes all exported and open packages, as well\n-     * as the packages of any service providers, and the package for the main\n-     * class. <\/p>\n+     * Returns the set of all packages in the module.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.StandardCharsets;\n@@ -4152,5 +4150,1 @@\n-            try {\n-                return JLA.uncheckedNewStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-            } catch (CharacterCodingException cce) {\n-                throw new AssertionError(cce);\n-            }\n+            return JLA.uncheckedNewStringWithLatin1Bytes(buf);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,7 @@\n-    \/\/ ## Override bulk get methods for better performance\n+    @Override\n+    CharBuffer getArray(int index, char[] dst, int dstOffset, int length) {\n+        \/\/ Note: the variable \"offset\" is defined and set in the superclass\n+        int srcOffset = offset + index;\n+        str.getChars(srcOffset, srcOffset + length, dst, dstOffset);\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/StringCharBuffer.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -953,2 +953,5 @@\n-    private $Type$Buffer getArray(int index, $type$[] dst, int offset, int length) {\n-        if (\n+    \/\/\n+    \/\/ This method does not perform bounds checking which it expects\n+    \/\/ will have been done by the caller\n+    \/\/\n+    $Type$Buffer getArray(int index, $type$[] dst, int offset, int length) {\n@@ -956,1 +959,1 @@\n-            isAddressable() &&\n+        assert isAddressable();\n@@ -958,1 +961,1 @@\n-            ((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n+        if (((long)length << $LG_BYTES_PER_VALUE$) > Bits.JNI_COPY_TO_ARRAY_THRESHOLD) {\n@@ -1119,0 +1122,4 @@\n+    \/\/\n+    \/\/ This method does not perform bounds checking which it expects\n+    \/\/ will have been done by the caller\n+    \/\/\n@@ -1153,3 +1160,7 @@\n-            int posMax = pos + n;\n-            for (int i = pos, j = srcPos; i < posMax; i++, j++)\n-                put(i, src.get(j));\n+            if (this.hb != null && src instanceof StringCharBuffer scb) {\n+                scb.getArray(srcPos, this.hb, pos, n);\n+            } else {\n+                int posMax = pos + n;\n+                for (int i = pos, j = srcPos; i < posMax; i++, j++)\n+                    put(i, src.get(j));\n+            }\n@@ -1345,0 +1356,4 @@\n+    \/\/\n+    \/\/ This method does not perform bounds checking which it expects\n+    \/\/ will have been done by the caller\n+    \/\/\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.List;\n@@ -43,0 +44,1 @@\n+import java.util.Objects;\n@@ -47,0 +49,1 @@\n+import java.util.function.Supplier;\n@@ -384,11 +387,1 @@\n-    private static class ThreadTrackHolder {\n-        static final ThreadTracker TRACKER = new ThreadTracker();\n-    }\n-\n-    private static Object tryBeginLookup() {\n-        return ThreadTrackHolder.TRACKER.tryBegin();\n-    }\n-\n-    private static void endLookup(Object key) {\n-        ThreadTrackHolder.TRACKER.end(key);\n-    }\n+    private static final ScopedValue<Boolean> IN_LOOKUP = ScopedValue.newInstance();\n@@ -409,2 +402,1 @@\n-        Object key = tryBeginLookup();\n-        if (key == null) {\n+        if (IN_LOOKUP.isBound()) {\n@@ -415,9 +407,17 @@\n-            for (Iterator<CharsetProvider> i = providers(); i.hasNext();) {\n-                CharsetProvider cp = i.next();\n-                Charset cs = cp.charsetForName(charsetName);\n-                if (cs != null)\n-                    return cs;\n-            }\n-            return null;\n-        } finally {\n-            endLookup(key);\n+            return ScopedValue.where(IN_LOOKUP, true).call(\n+                    new ScopedValue.CallableOp<Charset, Exception>() {\n+                        @Override\n+                        public Charset call() {\n+                            for (Iterator<CharsetProvider> i = providers(); i.hasNext(); ) {\n+                                CharsetProvider cp = i.next();\n+                                Charset cs = cp.charsetForName(charsetName);\n+                                if (cs != null)\n+                                    return cs;\n+                            }\n+                            return null;\n+                        }\n+                    }\n+            );\n+        } catch (Exception t) {\n+            \/\/ Should not happen\n+            throw new RuntimeException(t);\n@@ -425,0 +425,1 @@\n+\n@@ -428,7 +429,7 @@\n-    private static class ExtendedProviderHolder {\n-        static final CharsetProvider[] extendedProviders = extendedProviders();\n-        \/\/ returns ExtendedProvider, if installed\n-        private static CharsetProvider[] extendedProviders() {\n-            CharsetProvider[] cps = new CharsetProvider[1];\n-            int n = 0;\n-            ServiceLoader<CharsetProvider> sl =\n+    private static final Supplier<List<CharsetProvider>> EXTENDED_PROVIDERS = StableValue.supplier(\n+            new Supplier<>() { public List<CharsetProvider> get() { return extendedProviders0(); }});\n+\n+    private static List<CharsetProvider> extendedProviders0() {\n+        CharsetProvider[] cps = new CharsetProvider[1];\n+        int n = 0;\n+        final ServiceLoader<CharsetProvider> sl =\n@@ -436,5 +437,3 @@\n-            for (CharsetProvider cp : sl) {\n-                if (n + 1 > cps.length) {\n-                    cps = Arrays.copyOf(cps, cps.length << 1);\n-                }\n-                cps[n++] = cp;\n+        for (CharsetProvider cp : sl) {\n+            if (n + 1 > cps.length) {\n+                cps = Arrays.copyOf(cps, cps.length << 1);\n@@ -442,1 +441,1 @@\n-            return n == cps.length ? cps : Arrays.copyOf(cps, n);\n+            cps[n++] = cp;\n@@ -444,0 +443,1 @@\n+        return List.of(n == cps.length ? cps : Arrays.copyOf(cps, n));\n@@ -449,2 +449,1 @@\n-        CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;\n-        for (CharsetProvider cp : ecps) {\n+        for (CharsetProvider cp : EXTENDED_PROVIDERS.get()) {\n@@ -611,2 +610,1 @@\n-        CharsetProvider[] ecps = ExtendedProviderHolder.extendedProviders;\n-        for (CharsetProvider ecp :ecps) {\n+        for (CharsetProvider ecp : EXTENDED_PROVIDERS.get()) {\n@@ -622,1 +620,10 @@\n-    private @Stable static Charset defaultCharset;\n+    private static final Supplier<Charset> defaultCharset = StableValue.supplier(\n+            new Supplier<>() { public Charset get() { return defaultCharset0(); }});\n+\n+    private static Charset defaultCharset0() {\n+        \/\/ do not look for providers other than the standard one\n+        final Charset cs = standardProvider.charsetForName(StaticProperty.fileEncoding());\n+        return (cs == null)\n+                ? sun.nio.cs.UTF_8.INSTANCE\n+                : cs;\n+    }\n@@ -643,11 +650,1 @@\n-        if (defaultCharset == null) {\n-            synchronized (Charset.class) {\n-                \/\/ do not look for providers other than the standard one\n-                Charset cs = standardProvider.charsetForName(StaticProperty.fileEncoding());\n-                if (cs != null)\n-                    defaultCharset = cs;\n-                else\n-                    defaultCharset = sun.nio.cs.UTF_8.INSTANCE;\n-            }\n-        }\n-        return defaultCharset;\n+        return defaultCharset.get();\n@@ -659,3 +656,7 @@\n-    private final String name;          \/\/ tickles a bug in oldjavac\n-    private final String[] aliases;     \/\/ tickles a bug in oldjavac\n-    private Set<String> aliasSet;\n+    @Stable\n+    private final String name;\n+    @Stable\n+    private final String[] aliases;\n+    @Stable\n+    private final Supplier<Set<String>> aliasSet = StableValue.supplier(\n+            new Supplier<>() { public Set<String> get() { return Set.of(aliases); }});\n@@ -713,6 +714,1 @@\n-        Set<String> set = this.aliasSet;\n-        if (set == null) {\n-            set = Set.of(aliases);\n-            this.aliasSet = set;\n-        }\n-        return set;\n+        return aliasSet.get();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/charset\/Charset.java","additions":56,"deletions":60,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -3046,1 +3046,1 @@\n-        return JLA.uncheckedNewStringNoRepl(ba, cs);\n+        return JLA.uncheckedNewStringOrThrow(ba, cs);\n@@ -3365,1 +3365,1 @@\n-        byte[] bytes = JLA.uncheckedGetBytesNoRepl(String.valueOf(csq), cs);\n+        byte[] bytes = JLA.uncheckedGetBytesOrThrow(String.valueOf(csq), cs);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-                    throw new IllegalArgumentException(\"Invalid KeySpec.\");\n+                    throw new ClassCastException(\"Invalid KeySpec\");\n@@ -443,3 +443,3 @@\n-                throw new IllegalArgumentException(\"Invalid KeySpec \" +\n-                    \"specified (\" + tClass.getName() +\") for key (\" +\n-                    key.getClass().getName() +\")\", e);\n+                throw new ClassCastException(\"Invalid KeySpec \" +\n+                    \"specified: \" + tClass.getName() + \" for key \" +\n+                    key.getClass().getName());\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-     * @spec security\/standard-names.html Java Security Standard Algorithm Names\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/EncodedKeySpec.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-     * @spec security\/standard-names.html Java Security Standard Algorithm Names\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/PKCS8EncodedKeySpec.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-     * @spec security\/standard-names.html Java Security Standard Algorithm Names\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/X509EncodedKeySpec.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-     * different accented forms of the same base letter (\"a\" vs \"ä\" (U+00E9)) to be\n+     * different accented forms of the same base letter (\"a\" vs \"ä\" (U+00E4)) to be\n@@ -164,2 +164,2 @@\n-     * \"&#092;u00C0\" (A-grave) and combining accents such as \"A&#092;u0300\"\n-     * (A, combining-grave) will be considered significant at the IDENTICAL\n+     * \"&#092;u00E4\" (a-diaeresis) and combining accents such as \"a&#092;u0308\"\n+     * (a, combining-diaeresis) will be considered significant at the IDENTICAL\n","filename":"src\/java.base\/share\/classes\/java\/text\/Collator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n- * <h3>Negative Subpatterns<\/h3>\n+ * <h3><a id=\"negative_subpatterns\">Negative Subpatterns<\/a><\/h3>\n@@ -162,1 +162,4 @@\n- * as {@code \"0K;-0K\"}.\n+ * as {@code \"0K;-0K\"}. In {@link NumberFormat##leniency lenient parsing}\n+ * mode, loose matching of the minus sign pattern is enabled, following the\n+ * LDML’s <a href=\"https:\/\/unicode.org\/reports\/tr35\/#Loose_Matching\">\n+ * loose matching<\/a> specification.\n@@ -1588,0 +1591,3 @@\n+     * When lenient, the minus sign in the {@link ##negative_subpatterns\n+     * negative subpatterns} is loosely matched against lenient minus sign characters.\n+     * <p>\n@@ -1696,2 +1702,1 @@\n-            if (text.regionMatches(pos.index, defaultPosPrefix, 0,\n-                    defaultPosPrefix.length())) {\n+            if (decimalFormat.matchAffix(text, position, defaultPosPrefix)) {\n@@ -1702,2 +1707,1 @@\n-            if (text.regionMatches(pos.index, defaultNegPrefix, 0,\n-                    defaultNegPrefix.length())) {\n+            if (decimalFormat.matchAffix(text, position, defaultNegPrefix)) {\n@@ -1927,1 +1931,1 @@\n-                return text.regionMatches(position, affix, 0, affix.length());\n+                return decimalFormat.matchAffix(text, position, affix);\n@@ -2029,2 +2033,1 @@\n-            boolean containsPosSuffix = text.regionMatches(position,\n-                    positiveSuffix, 0, positiveSuffix.length());\n+            boolean containsPosSuffix = decimalFormat.matchAffix(text, position, positiveSuffix);\n@@ -2038,2 +2041,1 @@\n-            boolean containsNegSuffix = text.regionMatches(position,\n-                    negativeSuffix, 0, negativeSuffix.length());\n+            boolean containsNegSuffix = decimalFormat.matchAffix(text, position, negativeSuffix);\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n- * and\/or \"tz\" (timezone) <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode\n- * extensions<\/a>, the calendar, the country and\/or the time zone for formatting\n+ * and\/or \"tz\" (timezone) {@linkplain Locale##def_locale_extension Unicode\n+ * extensions}, the calendar, the country and\/or the time zone for formatting\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n- * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+ * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -148,0 +148,1 @@\n+     * @throws     NullPointerException if {@code locale} is null\n@@ -151,1 +152,2 @@\n-        initializeData(locale);\n+        initializeData(Objects.requireNonNull(locale,\n+            \"locale should not be null\"));\n@@ -347,0 +349,1 @@\n+        Objects.requireNonNull(locale, \"locale should not be null\");\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormatSymbols.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n- * <h3>Negative Subpatterns<\/h3>\n+ * <h3><a id=\"negative_subpatterns\">Negative Subpatterns<\/a><\/h3>\n@@ -310,1 +310,5 @@\n- * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}.\n+ * the same behavior as {@code \"#,##0.0#;(#,##0.0#)\"}. In\n+ * {@link NumberFormat##leniency lenient parsing} mode, loose matching of the\n+ * minus sign pattern is enabled, following the LDML’s\n+ * <a href=\"https:\/\/unicode.org\/reports\/tr35\/#Loose_Matching\">\n+ * loose matching<\/a> specification.\n@@ -655,8 +659,1 @@\n-        \/* Detecting whether a double is negative is easy with the exception of\n-         * the value -0.0.  This is a double which has a zero mantissa (and\n-         * exponent), but a negative sign bit.  It is semantically distinct from\n-         * a zero with a positive sign bit, and this distinction is important\n-         * to certain kinds of computations.  However, it's a little tricky to\n-         * detect, since (-0.0 == 0.0) and !(-0.0 < 0.0).  How then, you may\n-         * ask, does it behave distinctly from +0.0?  Well, 1\/(-0.0) ==\n-         * -Infinity.  Proper detection of -0.0 is needed to deal with the\n+        \/* Proper detection of -0.0 is needed to deal with the\n@@ -665,1 +662,1 @@\n-        boolean isNegative = ((number < 0.0) || (number == 0.0 && 1\/number < 0.0)) ^ (multiplier < 0);\n+        boolean isNegative = Double.doubleToRawLongBits(number) < 0 ^ multiplier < 0;\n@@ -2199,0 +2196,3 @@\n+     * When lenient, the minus sign in the {@link ##negative_subpatterns\n+     * negative subpatterns} is loosely matched against lenient minus sign characters.\n+     * <p>\n@@ -2395,4 +2395,2 @@\n-        gotPositive = text.regionMatches(position, positivePrefix, 0,\n-                positivePrefix.length());\n-        gotNegative = text.regionMatches(position, negativePrefix, 0,\n-                negativePrefix.length());\n+        gotPositive = matchAffix(text, position, positivePrefix);\n+        gotNegative = matchAffix(text, position, negativePrefix);\n@@ -2434,2 +2432,1 @@\n-                boolean containsPosSuffix =\n-                        text.regionMatches(position, positiveSuffix, 0, positiveSuffix.length());\n+                boolean containsPosSuffix = matchAffix(text, position, positiveSuffix);\n@@ -2441,2 +2438,1 @@\n-                boolean containsNegSuffix =\n-                        text.regionMatches(position, negativeSuffix, 0, negativeSuffix.length());\n+                boolean containsNegSuffix = matchAffix(text, position, negativeSuffix);\n@@ -3511,0 +3507,49 @@\n+    \/**\n+     * {@return true if the text matches the affix}\n+     * In lenient mode, lenient minus signs also match the hyphen-minus\n+     * (U+002D). Package-private access, as this is called from\n+     * CompactNumberFormat.\n+     *\n+     * Note: Minus signs in the supplementary character range or normalization\n+     * equivalents are not matched, as they may alter the affix length.\n+     *\/\n+    boolean matchAffix(String text, int position, String affix) {\n+        var alen = affix.length();\n+        var tlen = text.length();\n+\n+        \/\/ Verify position can fit length wise before checking char by char\n+        if (position + alen > tlen || position < 0) {\n+            return false;\n+        }\n+        if (alen == 0) {\n+            \/\/ always match with an empty affix, as affix is optional\n+            return true;\n+        }\n+        if (parseStrict) {\n+            return text.regionMatches(position, affix, 0, alen);\n+        }\n+\n+        var lms = symbols.getLenientMinusSigns();\n+        int i = 0;\n+        int limit = Math.min(tlen, position + alen);\n+        for (; position + i < limit; i++) {\n+            char t = text.charAt(position + i);\n+            char a = affix.charAt(i);\n+            int tIndex = lms.indexOf(t);\n+            int aIndex = lms.indexOf(a);\n+            \/\/ Non LMS. Match direct\n+            if (tIndex < 0 && aIndex < 0) {\n+                if (t != a) {\n+                    return false;\n+                }\n+            } else {\n+                \/\/ By here, at least one LMS. Ensure both LMS.\n+                if (tIndex < 0 || aIndex < 0) {\n+                    return false;\n+                }\n+            }\n+        }\n+        \/\/ Return true if entire affix was matched\n+        return i == alen;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":64,"deletions":19,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,3 +62,6 @@\n- * <p>If the locale contains \"rg\" (region override)\n- * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extension<\/a>,\n- * the symbols are overridden for the designated region.\n+ * <p>The \"rg\" (region override), \"nu\" (numbering system), and \"cu\" (currency)\n+ * {@code Locale} {@linkplain Locale##def_locale_extension Unicode\n+ * extensions} are supported which may override values within the symbols.\n+ * For both \"nu\" and \"cu\", if they are specified in addition to \"rg\" by the\n+ * backing {@code Locale}, the respective values from the \"nu\" and \"cu\" extension\n+ * supersede the implicit ones from the \"rg\" extension.\n@@ -91,1 +94,1 @@\n-        initialize( Locale.getDefault(Locale.Category.FORMAT) );\n+        initialize(Locale.getDefault(Locale.Category.FORMAT));\n@@ -114,2 +117,3 @@\n-    public DecimalFormatSymbols( Locale locale ) {\n-        initialize( locale );\n+    public DecimalFormatSymbols(Locale locale) {\n+        initialize(Objects.requireNonNull(locale,\n+            \"locale should not be null\"));\n@@ -180,0 +184,1 @@\n+        Objects.requireNonNull(locale, \"locale should not be null\");\n@@ -718,0 +723,11 @@\n+    \/**\n+     * {@return the lenient minus signs} Multiple lenient minus signs\n+     * are concatenated to form the returned string. Each codepoint\n+     * in the string is a valid minus sign pattern. If there are no\n+     * lenient minus signs defined in this locale, {@code minusSignText}\n+     * is returned.\n+     *\/\n+    String getLenientMinusSigns() {\n+        return lenientMinusSigns;\n+    }\n+\n@@ -815,1 +831,1 @@\n-    private void initialize( Locale locale ) {\n+    private void initialize(Locale locale) {\n@@ -818,12 +834,1 @@\n-        \/\/ check for region override\n-        Locale override = locale.getUnicodeLocaleType(\"nu\") == null ?\n-            CalendarDataUtility.findRegionOverride(locale) :\n-            locale;\n-\n-        \/\/ get resource bundle data\n-        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, override);\n-        \/\/ Avoid potential recursions\n-        if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n-            adapter = LocaleProviderAdapter.getResourceBundleBased();\n-        }\n-        Object[] data = adapter.getLocaleResources(override).getDecimalFormatSymbolsData();\n+        Object[] data = loadNumberData(locale);\n@@ -854,0 +859,3 @@\n+        \/\/ Lenient minus signs\n+        lenientMinusSigns = numberElements.length < 14 ? minusSignText : numberElements[13];\n+\n@@ -859,0 +867,16 @@\n+    private Object[] loadNumberData(Locale locale) {\n+        \/\/ check for region override\n+        Locale override = locale.getUnicodeLocaleType(\"nu\") == null ?\n+            CalendarDataUtility.findRegionOverride(locale) :\n+            locale;\n+\n+        \/\/ get resource bundle data\n+        LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DecimalFormatSymbolsProvider.class, override);\n+        \/\/ Avoid potential recursions\n+        if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n+            adapter = LocaleProviderAdapter.getResourceBundleBased();\n+        }\n+\n+        return adapter.getLocaleResources(override).getDecimalFormatSymbolsData();\n+    }\n+\n@@ -995,0 +1019,9 @@\n+\n+        \/\/ `locale` was once nullable, need to check before loading locale data\n+        if (locale != null && loadNumberData(locale) instanceof Object[] d &&\n+            d[0] instanceof String[] numberElements &&\n+            numberElements.length >= 14) {\n+            lenientMinusSigns = numberElements[13];\n+        } else {\n+            lenientMinusSigns = minusSignText;\n+        }\n@@ -1174,0 +1207,3 @@\n+    \/\/ Lenient minus. No need to be set by applications\n+    private transient String lenientMinusSigns;\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":56,"deletions":20,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+import java.nio.charset.StandardCharsets;\n+\n+import jdk.internal.access.SharedSecrets;\n@@ -45,0 +48,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -54,1 +58,1 @@\n- *\n+ * <p>\n@@ -58,1 +62,1 @@\n- *\n+ * <p>\n@@ -84,1 +88,1 @@\n-     *\n+     * <p>\n@@ -90,1 +94,1 @@\n-     *\n+     * <p>\n@@ -94,1 +98,1 @@\n-     *\n+     * <p>\n@@ -99,1 +103,1 @@\n-     *\n+     * <p>\n@@ -105,1 +109,1 @@\n-    public char[] digits = new char[MAX_COUNT];\n+    public byte[] digits = new byte[MAX_COUNT];\n@@ -107,1 +111,1 @@\n-    private char[] data;\n+    private byte[] data;\n@@ -156,1 +160,1 @@\n-            char[] data = new char[count + 100];\n+            byte[] data = new byte[ArraysSupport.newLength(count, 1, count)];\n@@ -160,1 +164,1 @@\n-        digits[count++] = digit;\n+        digits[count++] = (byte) digit;\n@@ -168,1 +172,1 @@\n-    public final double getDouble() {\n+    public double getDouble() {\n@@ -180,1 +184,1 @@\n-    public final long getLong() {\n+    public long getLong() {\n@@ -190,1 +194,1 @@\n-        long v = Long.parseUnsignedLong(new String(digits, 0, count));\n+        long v = Long.parseUnsignedLong(new String(digits, 0, count, StandardCharsets.ISO_8859_1));\n@@ -210,1 +214,2 @@\n-    public final BigDecimal getBigDecimal() {\n+    public BigDecimal getBigDecimal() {\n+        int count = this.count;\n@@ -215,5 +220,9 @@\n-       if (decimalAt == count) {\n-           return new BigDecimal(digits, 0, count);\n-       } else {\n-           return new BigDecimal(digits, 0, count).scaleByPowerOfTen(decimalAt - count);\n-       }\n+        char[] chars = new char[count];\n+        SharedSecrets.getJavaLangAccess()\n+                     .inflateBytesToChars(digits, 0, chars, 0, count);\n+        BigDecimal value = new BigDecimal(chars, 0, count);\n+        if (decimalAt == count) {\n+            return value;\n+        } else {\n+            return value.scaleByPowerOfTen(decimalAt - count);\n+        }\n@@ -258,1 +267,1 @@\n-            char dig = digits[i], max = LONG_MIN_REP[i];\n+            byte dig = digits[i], max = LONG_MIN_REP[i];\n@@ -282,1 +291,1 @@\n-    final void set(boolean isNegative, double source, int maximumFractionDigits) {\n+    void set(boolean isNegative, double source, int maximumFractionDigits) {\n@@ -286,0 +295,16 @@\n+    \/*\n+     * This compatibility option will only be available for a *very* limited\n+     * number of releases.\n+     * It restores the original behavior to help migrating to the new one,\n+     * and is used by adding\n+     *      -Djdk.compat.DecimalFormat=true\n+     * to the launcher's command line.\n+     *\n+     * The new behavior differs from the old one only in very rare cases,\n+     * so migration should be painless.\n+     *\n+     * When this option is removed, the old behavior, including relevant\n+     * fields and methods, will be removed as well.\n+     *\/\n+    private static final boolean COMPAT = Boolean.getBoolean(\"jdk.compat.DecimalFormat\");\n+\n@@ -297,3 +322,3 @@\n-    final void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n-\n-        FloatingDecimal.BinaryToASCIIConverter fdConverter  = FloatingDecimal.getBinaryToASCIIConverter(source);\n+    void set(boolean isNegative, double source, int maximumDigits, boolean fixedPoint) {\n+        FloatingDecimal.BinaryToASCIIConverter fdConverter =\n+                FloatingDecimal.getBinaryToASCIIConverter(source, COMPAT);\n@@ -303,1 +328,0 @@\n-        String digitsString = fdConverter.toJavaFormatString();\n@@ -305,1 +329,3 @@\n-        set(isNegative, digitsString,\n+        byte[] chars = getDataChars(26);\n+        int len = fdConverter.getChars(chars);\n+        set(isNegative, chars, len,\n@@ -317,1 +343,1 @@\n-    private void set(boolean isNegative, String s,\n+    private void set(boolean isNegative, byte[] source, int len,\n@@ -322,3 +348,0 @@\n-        int len = s.length();\n-        char[] source = getDataChars(len);\n-        s.getChars(0, len, source, 0);\n@@ -335,1 +358,1 @@\n-            char c = source[i++];\n+            byte c = source[i++];\n@@ -417,1 +440,1 @@\n-    private final void round(int maximumDigits,\n+    private void round(int maximumDigits,\n@@ -584,1 +607,1 @@\n-    final void set(boolean isNegative, long source) {\n+    void set(boolean isNegative, long source) {\n@@ -597,1 +620,1 @@\n-    final void set(boolean isNegative, long source, int maximumDigits) {\n+    void set(boolean isNegative, long source, int maximumDigits) {\n@@ -619,1 +642,1 @@\n-                digits[--left] = (char)('0' + (source % 10));\n+                digits[--left] = (byte)('0' + (source % 10));\n@@ -647,1 +670,2 @@\n-    final void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n+    @SuppressWarnings(\"deprecation\")\n+    void set(boolean isNegative, BigDecimal source, int maximumDigits, boolean fixedPoint) {\n@@ -651,1 +675,4 @@\n-        set(isNegative, s,\n+        int len = s.length();\n+        byte[] chars = getDataChars(len);\n+        s.getBytes(0, len, chars, 0);\n+        set(isNegative, chars, len,\n@@ -664,1 +691,2 @@\n-    final void set(boolean isNegative, BigInteger source, int maximumDigits) {\n+    @SuppressWarnings(\"deprecation\")\n+    void set(boolean isNegative, BigInteger source, int maximumDigits) {\n@@ -669,1 +697,1 @@\n-        s.getChars(0, len, digits, 0);\n+        s.getBytes(0, len, digits, 0);\n@@ -720,1 +748,1 @@\n-            char[] newDigits = new char[digits.length];\n+            byte[] newDigits = new byte[digits.length];\n@@ -735,2 +763,2 @@\n-    private static int parseInt(char[] str, int offset, int strLen) {\n-        char c;\n+    private static int parseInt(byte[] str, int offset, int strLen) {\n+        byte c;\n@@ -758,1 +786,1 @@\n-    private static final char[] LONG_MIN_REP = \"9223372036854775808\".toCharArray();\n+    private static final byte[] LONG_MIN_REP = \"9223372036854775808\".getBytes(StandardCharsets.ISO_8859_1);\n@@ -765,1 +793,1 @@\n-        return \"0.\" + new String(digits, 0, count) + \"x10^\" + decimalAt;\n+        return \"0.\" + new String(digits, 0, count, StandardCharsets.ISO_8859_1) + \"x10^\" + decimalAt;\n@@ -770,1 +798,1 @@\n-            digits = new char[len];\n+            digits = new byte[len];\n@@ -774,1 +802,1 @@\n-    private final char[] getDataChars(int length) {\n+    private byte[] getDataChars(int length) {\n@@ -776,1 +804,1 @@\n-            data = new char[length];\n+            data = new byte[length];\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":75,"deletions":47,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n- * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+ * {@linkplain Locale##def_locale_extension Unicode extensions},\n@@ -106,0 +106,3 @@\n+ * <li> \"cu\"\n+ * (<a href=\"https:\/\/www.unicode.org\/reports\/tr35\/tr35.html#UnicodeCurrencyIdentifier\">\n+ * Currency Type<\/a>) - Overrides the Currency used\n@@ -108,3 +111,3 @@\n- * If both \"nu\" and \"rg\" are specified, the decimal digits from the \"nu\"\n- * extension supersedes the implicit one from the \"rg\" extension.\n- * Although <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>\n+ * For both \"nu\" and \"cu\", if they are specified in addition to \"rg\", the respective\n+ * values from the \"nu\" and \"cu\" extension supersede the implicit ones from the \"rg\" extension.\n+ * Although {@linkplain Locale##def_locale_extension Unicode extensions}\n@@ -195,1 +198,5 @@\n- * {@code 1000} out of the String \"$1,000.00 was paid\".\n+ * {@code 1000} out of the String \"$1,000.00 was paid\". Lenient parsing also\n+ * allows loose matching of characters in the source text. For example, an\n+ * implementation of the {@code NumberFormat} class may allow matching \"−\"\n+ * (U+2212 MINUS SIGN) to the \"-\" (U+002D HYPHEN-MINUS) pattern character\n+ * when used as a negative prefix.\n@@ -687,1 +694,1 @@\n-     * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extension},\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- * <p>The requested {@code Locale} may contain an <a\n- * href=\"..\/..\/util\/Locale.html#def_locale_extension\"> extension<\/a> for\n+ * <p>The requested {@code Locale} may contain an {@linkplain\n+ * Locale##def_locale_extension extension} for\n","filename":"src\/java.base\/share\/classes\/java\/text\/spi\/DecimalFormatSymbolsProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1202,2 +1202,4 @@\n-     * When parsing, the behaviour of {@link DateTimeFormatterBuilder#appendOffsetId()}\n-     * will be used to parse the offset, converting the instant to UTC as necessary.\n+     * When parsing, the lenient mode behavior of\n+     * {@link DateTimeFormatterBuilder#appendOffset(String, String)\n+     * appendOffset(\"+HH\", \"Z\")} will be used to parse the offset,\n+     * converting the instant to UTC as necessary.\n@@ -1509,3 +1511,3 @@\n-     * If the locale has <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">\n-     * Unicode extensions<\/a>, they may be used later in text\n-     * processing. To set the chronology, time-zone and decimal style from\n+     * If the locale has {@linkplain Locale##def_locale_extension Unicode extensions},\n+     * they may be used later in text processing.\n+     * To set the chronology, time-zone and decimal style from\n@@ -1536,1 +1538,1 @@\n-     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extensions},\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extensions},\n@@ -238,1 +238,1 @@\n-     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extensions},\n@@ -897,2 +897,4 @@\n-     * When parsing, the behaviour of {@link DateTimeFormatterBuilder#appendOffsetId()}\n-     * will be used to parse the offset, converting the instant to UTC as necessary.\n+     * When parsing, the lenient mode behaviour of\n+     * {@link DateTimeFormatterBuilder#appendOffset(String, String)\n+     * appendOffset(\"+HH\", \"Z\")} will be used to parse the offset,\n+     * converting the instant to UTC as necessary.\n@@ -959,1 +961,1 @@\n-     * This is equivalent to calling {@code appendOffset(\"+HH:mm:ss\", \"Z\")}.\n+     * This is equivalent to calling {@code appendOffset(\"+HH:MM:ss\", \"Z\")}.\n@@ -3890,1 +3892,2 @@\n-                    .appendOffsetId()\n+                    .parseLenient()\n+                    .appendOffset(\"+HH\", \"Z\")\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,13 @@\n+    \/**\n+     * Adjusts the given {@link TemporalAccessor} using chronology and time-zone from a formatter if present.\n+     * <p>\n+     * This method serves as an optimization front-end that checks for non-null overrides in the formatter.\n+     * If neither chronology nor time-zone is specified in the formatter, returns the original temporal unchanged.\n+     * Otherwise, delegates to the core adjustment method {@link #adjustWithOverride(TemporalAccessor, Chronology, ZoneId)}.\n+     *\n+     * @implNote Optimizes for the common case where formatters don't specify chronology\/time-zone\n+     *           by avoiding unnecessary processing. Most formatters have null for these properties.\n+     * @param temporal  the temporal object to adjust, not null\n+     * @param formatter the formatter providing potential chronology and time-zone overrides\n+     * @return the adjusted temporal, or the original if no overrides are present in the formatter\n+     *\/\n@@ -131,0 +144,26 @@\n+        \/\/ Placing the non-null cases in a separate method allows more flexible code optimizations\n+        return adjustWithOverride(temporal, overrideChrono, overrideZone);\n+    }\n+\n+    \/**\n+     * Adjusts the given {@link TemporalAccessor} with optional overriding chronology and time-zone.\n+     * <p>\n+     * This method minimizes changes by returning the original temporal if the override parameters\n+     * are either {@code null} or equivalent to those already present in the temporal. When overrides\n+     * are applied:\n+     * <ul>\n+     *   <li>If a time-zone override is provided and the temporal supports {@link ChronoField#INSTANT_SECONDS},\n+     *       the result is a zoned date-time using the override time-zone and chronology (defaulting to ISO if not overridden).<\/li>\n+     *   <li>Other cases (including partial date-times or mixed chronology\/time-zone changes) are delegated\n+     *       to a secondary adjustment method.<\/li>\n+     * <\/ul>\n+     *\n+     * @param temporal       the temporal object to adjust, not null\n+     * @param overrideChrono the chronology to override (null retains the original chronology)\n+     * @param overrideZone   the time-zone to override (null retains the original time-zone)\n+     * @return the adjusted temporal, which may be the original object if no effective changes were made,\n+     *         or a new object with the applied overrides\n+     * @implNote Optimizes for common cases where overrides are identical to existing values\n+     *           or where instant-based temporals can be directly converted with a time-zone.\n+     *\/\n+    private static TemporalAccessor adjustWithOverride(TemporalAccessor temporal, Chronology overrideChrono, ZoneId overrideZone) {\n@@ -152,0 +191,47 @@\n+        }\n+\n+        \/\/ Split uncommon code branches into a separate method\n+        return adjustSlow(temporal, overrideZone, temporalZone, overrideChrono, effectiveChrono, temporalChrono);\n+    }\n+\n+    \/**\n+     * Internal helper method to adjust temporal fields using override chronology and time-zone in complex cases.\n+     * <p>\n+     * Handles non-instant temporal objects by creating a delegate {@link TemporalAccessor} that combines:\n+     * <ul>\n+     *   <li>The original temporal's time-related fields<\/li>\n+     *   <li>Date fields converted to the effective chronology (if available)<\/li>\n+     *   <li>Override zone\/chronology information for temporal queries<\/li>\n+     * <\/ul>\n+     *\n+     * Performs critical validation before processing:\n+     * <ul>\n+     *   <li>Rejects offset changes for non-instant temporal objects with existing offsets<\/li>\n+     *   <li>Verifies date field integrity when applying chronology overrides to partial dates<\/li>\n+     * <\/ul>\n+     *\n+     * @param temporal        the original temporal object to adjust, not null\n+     * @param overrideZone    override time-zone (nullable)\n+     * @param temporalZone    original time-zone from temporal (nullable)\n+     * @param overrideChrono  override chronology (nullable)\n+     * @param effectiveChrono precomputed effective chronology (override if present, otherwise temporal's chronology)\n+     * @param temporalChrono  original chronology from temporal (nullable)\n+     * @return adjusted temporal accessor combining original fields with overrides\n+     * @throws DateTimeException if:\n+     *         <ul>\n+     *           <li>Applying a {@link ZoneOffset} override to a temporal with conflicting existing offset that doesn't represent an instant<\/li>\n+     *           <li>Applying chronology override to temporal with partial date fields<\/li>\n+     *         <\/ul>\n+     * @implNote Creates an anonymous temporal accessor that:\n+     *         <ul>\n+     *           <li>Delegates time-based fields to original temporal<\/li>\n+     *           <li>Uses converted date fields when chronology override is applied<\/li>\n+     *           <li>Responds to chronology\/zone queries with effective values<\/li>\n+     *           <li>Preserves precision queries from original temporal<\/li>\n+     *         <\/ul>\n+     *\/\n+    private static TemporalAccessor adjustSlow(\n+            TemporalAccessor temporal,\n+            ZoneId overrideZone, ZoneId temporalZone,\n+            Chronology overrideChrono, Chronology effectiveChrono, Chronology temporalChrono) {\n+        if (overrideZone != null) {\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimePrintContext.java","additions":87,"deletions":1,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-     * (Region Override) <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">\n-     * Unicode extensions<\/a>, returned instance will reflect the values specified with\n+     * (Region Override) {@linkplain Locale##def_locale_extension Unicode extensions},\n+     * returned instance will reflect the values specified with\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DecimalStyle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -292,2 +292,2 @@\n-     * (Region Override) <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">\n-     * Unicode extensions<\/a>, returned instance will reflect the values specified with\n+     * (Region Override) {@linkplain Locale##def_locale_extension Unicode extensions},\n+     * returned instance will reflect the values specified with\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/WeekFields.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,2 +132,2 @@\n- * locale contains \"fw\" and\/or \"rg\" <a href=\".\/Locale.html#def_locale_extension\">\n- * Unicode extensions<\/a>, the first day of the week will be obtained according to\n+ * locale contains \"fw\" and\/or \"rg\" {@linkplain Locale##def_locale_extension\n+ * Unicode extensions}, the first day of the week will be obtained according to\n@@ -1457,1 +1457,1 @@\n-         * <a href=\"Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+         * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -1618,1 +1618,1 @@\n-     * <a href=\"Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -1650,1 +1650,1 @@\n-     * <a href=\"Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -2635,2 +2635,2 @@\n-     * calendar types can be used for the <a\n-     * href=\"Locale.html#def_locale_extension\">Unicode locale extensions<\/a>.\n+     * calendar types can be used for the {@linkplain Locale##def_locale_extension\n+     * Unicode locale extensions}.\n@@ -2670,1 +2670,1 @@\n-     * @see <a href=\"Locale.html#def_extensions\">Locale extensions<\/a>\n+     * @see Locale##def_locale_extension Locale extensions\n","filename":"src\/java.base\/share\/classes\/java\/util\/Calendar.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.StandardCharsets;\n@@ -463,6 +461,1 @@\n-        try {\n-            \/\/ Return a new string using the bytes without making a copy\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -698,5 +691,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -734,5 +723,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -762,5 +747,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -798,5 +779,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n@@ -826,5 +803,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(rep, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(rep);\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":6,"deletions":33,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -3055,2 +3055,2 @@\n-         * <a href=\".\/Locale.html#legacy_language_codes\">Legacy language\n-         * codes<\/a>, either old or new, then repeat the loading process\n+         * {@linkplain Locale##legacy_language_codes Legacy language\n+         * codes}, either old or new, then repeat the loading process\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.StandardCharsets;\n@@ -482,5 +480,1 @@\n-        try {\n-            return jla.uncheckedNewStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n-        } catch (CharacterCodingException cce) {\n-            throw new AssertionError(cce);\n-        }\n+        return jla.uncheckedNewStringWithLatin1Bytes(buf);\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -703,1 +703,1 @@\n-         *     var joiner = Joiner.all(new CancelAfterTwoFailures<String>());\n+         *     var joiner = Joiner.allUntil(new CancelAfterTwoFailures<String>());\n@@ -708,1 +708,1 @@\n-         * except that it yields a stream of the completed subtasks.\n+         * except that it yields a list of the completed subtasks.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,1 @@\n-     * <a href=\"..\/Locale.html#def_locale_extension\">Unicode extension<\/a> key,\n+     * {@linkplain Locale##def_locale_extension Unicode extension} key,\n@@ -172,1 +172,1 @@\n-     * <a href=\"..\/Locale.html#def_locale_extension\">Unicode extension<\/a> type,\n+     * {@linkplain Locale##def_locale_extension Unicode extension} type,\n","filename":"src\/java.base\/share\/classes\/java\/util\/spi\/LocaleNameProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -255,1 +256,7 @@\n-            return JLA.newStringUTF8NoRepl(ba, off, length);\n+            try {\n+                \/\/ Copy subrange for exclusive use by the string being created\n+                byte[] bytes = Arrays.copyOfRange(ba, off, off + length);\n+                return JLA.uncheckedNewStringOrThrow(bytes, StandardCharsets.UTF_8);\n+            } catch (CharacterCodingException cce) {\n+                throw new IllegalArgumentException(cce);\n+            }\n@@ -260,1 +267,5 @@\n-            return JLA.getBytesUTF8NoRepl(s);\n+            try {\n+                return JLA.getBytesUTF8OrThrow(s);\n+            } catch (CharacterCodingException cce) {\n+                throw new IllegalArgumentException(cce);\n+            }\n@@ -274,3 +285,1 @@\n-                \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n-                \/\/ exceptions eagerly when opening ZipFiles\n-                return hash(JLA.newStringUTF8NoRepl(a, off, len));\n+                return hash(toString(a, off, len));\n@@ -292,1 +301,1 @@\n-                byte[] encoded = JLA.uncheckedGetBytesNoRepl(str, UTF_8.INSTANCE);\n+                byte[] encoded = JLA.uncheckedGetBytesOrThrow(str, UTF_8.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -320,0 +320,12 @@\n+    \/**\n+     * Constructs a new {@code String} with the supplied Latin1 bytes.\n+     * <p>\n+     * <b>WARNING: The caller of this method shall relinquish and transfer the\n+     * ownership of the byte array to the callee<\/b>, since the latter will not\n+     * make a copy.\n+     *\n+     * @param bytes the byte array source\n+     * @return the newly created string\n+     *\/\n+    String uncheckedNewStringWithLatin1Bytes(byte[] bytes);\n+\n@@ -322,1 +334,1 @@\n-     * using the specified {@linkplain java.nio.charset.Charset charset}.\n+     * using the specified {@code Charset}.\n@@ -332,0 +344,1 @@\n+     * @throws NullPointerException If {@code bytes} or {@code cs} is null\n@@ -333,1 +346,1 @@\n-    String uncheckedNewStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException;\n+    String uncheckedNewStringOrThrow(byte[] bytes, Charset cs) throws CharacterCodingException;\n@@ -336,2 +349,2 @@\n-     * Encode the given string into a sequence of bytes using the specified\n-     * {@linkplain java.nio.charset.Charset charset}.\n+     * {@return the sequence of bytes obtained by encoding the given string in\n+     * the specified {@code Charset}}\n@@ -342,3 +355,0 @@\n-     * <p>\n-     * This method throws {@code CharacterCodingException} instead of replacing\n-     * when malformed input or unmappable characters are encountered.\n@@ -348,1 +358,1 @@\n-     * @return the encoded bytes\n+     * @throws NullPointerException If {@code s} or {@code cs} is null\n@@ -351,11 +361,1 @@\n-    byte[] uncheckedGetBytesNoRepl(String s, Charset cs) throws CharacterCodingException;\n-\n-    \/**\n-     * Returns a new string by decoding from the given UTF-8 bytes array.\n-     *\n-     * @param off the index of the first byte to decode\n-     * @param len the number of bytes to decode\n-     * @return the newly created string\n-     * @throws IllegalArgumentException for malformed or unmappable bytes.\n-     *\/\n-    String newStringUTF8NoRepl(byte[] bytes, int off, int len);\n+    byte[] uncheckedGetBytesOrThrow(String s, Charset cs) throws CharacterCodingException;\n@@ -387,1 +387,1 @@\n-     * Encode the given string into a sequence of bytes using utf8.\n+     * {@return the sequence of bytes obtained by encoding the given string in UTF-8}\n@@ -390,2 +390,2 @@\n-     * @return the encoded bytes in utf8\n-     * @throws IllegalArgumentException for malformed surrogates\n+     * @throws NullPointerException If {@code s} is null\n+     * @throws CharacterCodingException For malformed input or unmappable characters\n@@ -393,1 +393,1 @@\n-    byte[] getBytesUTF8NoRepl(String s);\n+    byte[] getBytesUTF8OrThrow(String s) throws CharacterCodingException;\n@@ -425,5 +425,3 @@\n-     * Encodes as many ASCII codepoints as possible from the source array into\n-     * the destination byte array, assuming that the encoding is ASCII\n-     * compatible.\n-     * <p>\n-     * <b>WARNING: This method does not perform any bound checks.<\/b>\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n@@ -431,3 +429,9 @@\n-     * @return the number of bytes successfully encoded, or 0 if none\n-     *\/\n-    int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the total number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     *\/\n+    int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":35,"deletions":31,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-            this.flags = flags;\n+            this.flags = Util.checkU2(flags, \"character range flags\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    public  AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n+    public AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n@@ -46,1 +46,1 @@\n-        this.flagsMask = mask;\n+        this.flagsMask = Util.checkFlags(mask);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AccessFlagsImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        elements = List.copyOf(elements);\n+        elements = Util.sanitizeU2List(elements);\n@@ -192,1 +192,1 @@\n-            values = List.copyOf(values);\n+            values = Util.sanitizeU2List(values);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+        Util.checkU2(attributesCount, \"attributes count\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-                                 MethodHandleEntryImpl handle,\n-                                 List<LoadableConstantEntry> arguments) {\n+                             MethodHandleEntryImpl handle,\n+                             List<LoadableConstantEntry> arguments) {\n@@ -50,1 +50,1 @@\n-        this.arguments = List.copyOf(arguments);\n+        this.arguments = Util.sanitizeU2List(arguments);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -279,3 +279,1 @@\n-        if (utflen > 65535) {\n-            throw new IllegalArgumentException(\"string too long\");\n-        }\n+        Util.checkU2(utflen, \"utf8 length\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -31,1 +32,1 @@\n-import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n@@ -42,1 +43,0 @@\n-    final Set<ConstantDesc> catchTypes;\n@@ -49,1 +49,0 @@\n-        this.catchTypes = new HashSet<>();\n@@ -62,3 +61,8 @@\n-        if (catchBlock == null) {\n-            if (tryBlock.reachable()) {\n-                b.branch(Opcode.GOTO, tryCatchEnd);\n+        \/\/ nullable list of CP entries - null means catching all (0)\n+        List<ClassEntry> entries = new ArrayList<>(Math.max(1, exceptionTypes.size()));\n+        if (exceptionTypes.isEmpty()) {\n+            entries.add(null);\n+        } else {\n+            for (var exceptionType : exceptionTypes) {\n+                var entry = b.constantPool().classEntry(exceptionType); \/\/ throws IAE\n+                entries.add(entry);\n@@ -67,0 +71,1 @@\n+        \/\/ End validation\n@@ -68,3 +73,3 @@\n-        for (var exceptionType : exceptionTypes) {\n-            if (!catchTypes.add(exceptionType)) {\n-                throw new IllegalArgumentException(\"Existing catch block catches exception of type: \" + exceptionType);\n+        if (catchBlock == null) {\n+            if (tryBlock.reachable()) {\n+                b.branch(Opcode.GOTO, tryCatchEnd);\n@@ -85,7 +90,3 @@\n-        if (exceptionTypes.isEmpty()) {\n-            catchBlock.exceptionCatchAll(tryStart, tryEnd, catchBlock.startLabel());\n-        }\n-        else {\n-            for (var exceptionType : exceptionTypes) {\n-                catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), exceptionType);\n-            }\n+        for (var entry : entries) {\n+            \/\/ This accepts null for catching all\n+            catchBlock.exceptionCatch(tryStart, tryEnd, catchBlock.startLabel(), entry);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CatchBuilderImpl.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import static java.lang.classfile.ClassFile.PREVIEW_MINOR_VERSION;\n+\n@@ -35,2 +37,3 @@\n-        this.majorVersion = majorVersion;\n-        this.minorVersion = minorVersion;\n+        this.majorVersion = Util.checkU2(majorVersion, \"major version\");\n+        this.minorVersion = minorVersion == -1 ? PREVIEW_MINOR_VERSION\n+                : Util.checkU2(minorVersion, \"minor version\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileVersionImpl.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static jdk.internal.classfile.impl.StackMapGenerator.*;\n@@ -295,1 +296,1 @@\n-            if (frameType < 64) {\n+            if (frameType <= SAME_FRAME_END) {\n@@ -299,1 +300,1 @@\n-            else if (frameType < 128) {\n+            else if (frameType <= SAME_LOCALS_1_STACK_ITEM_FRAME_END) {\n@@ -305,1 +306,1 @@\n-                    case 247 -> {\n+                    case SAME_LOCALS_1_STACK_ITEM_EXTENDED -> {\n@@ -309,1 +310,1 @@\n-                    case 248, 249, 250, 251 -> {\n+                    case CHOP_FRAME_START, CHOP_FRAME_START + 1, CHOP_FRAME_END, SAME_FRAME_EXTENDED -> {\n@@ -313,1 +314,1 @@\n-                    case 252, 253, 254 -> {\n+                    case APPEND_FRAME_START, APPEND_FRAME_START + 1, APPEND_FRAME_END -> {\n@@ -315,1 +316,1 @@\n-                        int k = frameType - 251;\n+                        int k = frameType - APPEND_FRAME_START + 1;\n@@ -321,1 +322,1 @@\n-                    case 255 -> {\n+                    case FULL_FRAME -> {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+        Util.checkU2(handlersSize, \"exception handlers\");\n@@ -190,1 +191,1 @@\n-            writeExceptionHandlers(buf, pos);\n+            writeExceptionHandlers(buf, pos, handlersSize);\n@@ -194,2 +195,1 @@\n-    private void writeExceptionHandlers(BufWriterImpl buf, int pos) {\n-        int handlersSize = handlers.size();\n+    private void writeExceptionHandlers(BufWriterImpl buf, int pos, int handlersSize) {\n@@ -230,0 +230,1 @@\n+                        Util.checkU2(crSize, \"character range count\");\n@@ -265,0 +266,1 @@\n+                        Util.checkU2(lvSize, \"local variable count\");\n@@ -294,0 +296,1 @@\n+                        Util.checkU2(lvtSize, \"local variable type count\");\n@@ -444,1 +447,1 @@\n-            b.writeU2(buf.size() \/ 4);\n+            b.writeU2(Util.checkU2(buf.size() \/ 4, \"line number count\"));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        this.flags = flags;\n+        this.flags = Util.checkFlags(flags);\n@@ -74,1 +74,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        this.flags = flags;\n+        this.flags = Util.checkFlags(flags);\n@@ -59,1 +59,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        this.interfaces = List.copyOf(interfaces);\n+        this.interfaces = Util.sanitizeU2List(interfaces);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/InterfacesImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        return (line < INTERN_LIMIT)\n+        return (Util.checkU2(line, \"line number\") < INTERN_LIMIT)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LineNumberImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-        this.moduleFlags = flags;\n+        this.moduleFlags = Util.checkFlags(flags);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+        Util.checkU2(bsmSize, \"num bootstrap methods\");\n@@ -163,4 +164,3 @@\n-        if (size() >= 65536) {\n-            throw new IllegalArgumentException(String.format(\"Constant pool is too large %d\", size()));\n-        }\n-        buf.writeU2(size());\n+        int mySize = size();\n+        Util.checkU2(mySize, \"constant pool count\");\n+        buf.writeU2(mySize);\n@@ -171,1 +171,1 @@\n-        for (int i = writeFrom; i < size(); ) {\n+        for (int i = writeFrom; i < mySize; ) {\n@@ -597,0 +597,1 @@\n+        Util.checkU1(refKind, \"reference kind\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import static java.lang.classfile.attribute.StackMapFrameInfo.VerificationTypeInfo.*;\n@@ -49,0 +48,1 @@\n+import static jdk.internal.classfile.impl.StackMapGenerator.*;\n@@ -52,3 +52,0 @@\n-    private static final int\n-                    SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247,\n-                    SAME_EXTENDED = 251;\n@@ -139,1 +136,1 @@\n-                if (diffLocalsSize == 0 && offsetDelta < 64) { \/\/same frame\n+                if (diffLocalsSize == 0 && offsetDelta <= SAME_FRAME_END) { \/\/same frame\n@@ -142,1 +139,1 @@\n-                    out.writeU1U2(251 + diffLocalsSize, offsetDelta);\n+                    out.writeU1U2(SAME_FRAME_EXTENDED + diffLocalsSize, offsetDelta);\n@@ -148,2 +145,2 @@\n-            if (offsetDelta < 64) {  \/\/same locals 1 stack item frame\n-                out.writeU1(64 + offsetDelta);\n+            if (offsetDelta <= SAME_LOCALS_1_STACK_ITEM_FRAME_END  - SAME_LOCALS_1_STACK_ITEM_FRAME_START) {  \/\/same locals 1 stack item frame\n+                out.writeU1(SAME_LOCALS_1_STACK_ITEM_FRAME_START + offsetDelta);\n@@ -151,1 +148,1 @@\n-                out.writeU1U2(247, offsetDelta);\n+                out.writeU1U2(SAME_LOCALS_1_STACK_ITEM_EXTENDED, offsetDelta);\n@@ -157,1 +154,1 @@\n-        out.writeU1U2U2(255, offsetDelta, fr.locals().size());\n+        out.writeU1U2U2(FULL_FRAME, offsetDelta, fr.locals().size());\n@@ -191,1 +188,1 @@\n-            if (frameType < 64) {\n+            if (frameType <= SAME_FRAME_END) {\n@@ -194,2 +191,2 @@\n-            } else if (frameType < 128) {\n-                bci += frameType - 63;\n+            } else if (frameType <= SAME_LOCALS_1_STACK_ITEM_FRAME_END) {\n+                bci += frameType - SAME_LOCALS_1_STACK_ITEM_FRAME_START + 1;\n@@ -203,2 +200,2 @@\n-                } else if (frameType < SAME_EXTENDED) {\n-                    locals = locals.subList(0, locals.size() + frameType - SAME_EXTENDED);\n+                } else if (frameType < SAME_FRAME_EXTENDED) {\n+                    locals = locals.subList(0, locals.size() + frameType - SAME_FRAME_EXTENDED);\n@@ -206,1 +203,1 @@\n-                } else if (frameType == SAME_EXTENDED) {\n+                } else if (frameType == SAME_FRAME_EXTENDED) {\n@@ -208,1 +205,1 @@\n-                } else if (frameType < SAME_EXTENDED + 4) {\n+                } else if (frameType <= APPEND_FRAME_END) {\n@@ -210,1 +207,1 @@\n-                    var newLocals = locals.toArray(new VerificationTypeInfo[actSize + frameType - SAME_EXTENDED]);\n+                    var newLocals = locals.toArray(new VerificationTypeInfo[actSize + frameType - SAME_FRAME_EXTENDED]);\n@@ -306,2 +303,2 @@\n-            locals = List.copyOf(locals);\n-            stack = List.copyOf(stack);\n+            locals = Util.sanitizeU2List(locals);\n+            stack = Util.sanitizeU2List(stack);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -169,1 +169,2 @@\n-    private static final int ITEM_TOP = 0,\n+    public static final int\n+            ITEM_TOP = 0,\n@@ -183,1 +184,16 @@\n-            ITEM_DOUBLE_2ND = 14;\n+            ITEM_DOUBLE_2ND = 14,\n+            ITEM_BOGUS = -1;\n+\n+    \/\/ Ranges represented by these constants are inclusive on both ends\n+    public static final int\n+            SAME_FRAME_END = 63,\n+            SAME_LOCALS_1_STACK_ITEM_FRAME_START = 64,\n+            SAME_LOCALS_1_STACK_ITEM_FRAME_END = 127,\n+            RESERVED_END = 246,\n+            SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247,\n+            CHOP_FRAME_START = 248,\n+            CHOP_FRAME_END = 250,\n+            SAME_FRAME_EXTENDED = 251,\n+            APPEND_FRAME_START = 252,\n+            APPEND_FRAME_END = 254,\n+            FULL_FRAME = 255;\n@@ -1232,1 +1248,1 @@\n-                    if (diffLocalsSize == 0 && offsetDelta < 64) { \/\/same frame\n+                    if (diffLocalsSize == 0 && offsetDelta <= SAME_FRAME_END) { \/\/same frame\n@@ -1235,1 +1251,1 @@\n-                        out.writeU1U2(251 + diffLocalsSize, offsetDelta);\n+                        out.writeU1U2(SAME_FRAME_EXTENDED + diffLocalsSize, offsetDelta);\n@@ -1241,2 +1257,2 @@\n-                if (offsetDelta < 64) {  \/\/same locals 1 stack item frame\n-                    out.writeU1(64 + offsetDelta);\n+                if (offsetDelta <= SAME_LOCALS_1_STACK_ITEM_FRAME_END  - SAME_LOCALS_1_STACK_ITEM_FRAME_START) {  \/\/same locals 1 stack item frame\n+                    out.writeU1(SAME_LOCALS_1_STACK_ITEM_FRAME_START + offsetDelta);\n@@ -1244,1 +1260,1 @@\n-                    out.writeU1U2(247, offsetDelta);\n+                    out.writeU1U2(SAME_LOCALS_1_STACK_ITEM_EXTENDED, offsetDelta);\n@@ -1250,1 +1266,1 @@\n-            out.writeU1U2U2(255, offsetDelta, localsSize);\n+            out.writeU1U2U2(FULL_FRAME, offsetDelta, localsSize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,3 @@\n-        public TypeParameterTargetImpl(TargetType targetType, int typeParameterIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER, TARGET_METHOD_TYPE_PARAMETER);\n-            this.typeParameterIndex = typeParameterIndex;\n+        public TypeParameterTargetImpl {\n+            checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER, TARGET_METHOD_TYPE_PARAMETER);\n+            Util.checkU1(typeParameterIndex, \"type parameter index\");\n@@ -54,0 +54,5 @@\n+\n+        public SupertypeTargetImpl {\n+            Util.checkU2(supertypeIndex, \"supertype index\");\n+        }\n+\n@@ -63,4 +68,4 @@\n-        public TypeParameterBoundTargetImpl(TargetType targetType, int typeParameterIndex, int boundIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER_BOUND, TARGET_METHOD_TYPE_PARAMETER_BOUND);\n-            this.typeParameterIndex = typeParameterIndex;\n-            this.boundIndex = boundIndex;\n+        public TypeParameterBoundTargetImpl {\n+            checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER_BOUND, TARGET_METHOD_TYPE_PARAMETER_BOUND);\n+            Util.checkU1(typeParameterIndex, \"type parameter index\");\n+            Util.checkU1(boundIndex, \"bound index\");\n@@ -78,0 +83,5 @@\n+\n+        public FormalParameterTargetImpl {\n+            Util.checkU1(formalParameterIndex, \"formal parameter index\");\n+        }\n+\n@@ -85,0 +95,5 @@\n+\n+        public ThrowsTargetImpl {\n+            Util.checkU2(throwsTargetIndex, \"throws type index\");\n+        }\n+\n@@ -96,1 +111,1 @@\n-            this.table = List.copyOf(table);\n+            this.table = Util.sanitizeU2List(table);\n@@ -110,0 +125,1 @@\n+            BytecodeHelpers.validateSlot(index);\n@@ -114,0 +130,5 @@\n+\n+        public CatchTargetImpl {\n+            Util.checkU2(exceptionTableIndex, \"exception table index\");\n+        }\n+\n@@ -131,4 +152,4 @@\n-        public TypeArgumentTargetImpl(TargetType targetType, Label target, int typeArgumentIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CAST, TARGET_METHOD_REFERENCE_TYPE_ARGUMENT);\n-            this.target = requireNonNull(target);\n-            this.typeArgumentIndex = typeArgumentIndex;\n+        public TypeArgumentTargetImpl {\n+            checkValid(targetType, TARGET_CAST, TARGET_METHOD_REFERENCE_TYPE_ARGUMENT);\n+            requireNonNull(target);\n+            Util.checkU1(typeArgumentIndex, \"type argument index\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TargetInfoImpl.java","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,1 +177,1 @@\n-            this.exceptions = List.copyOf(exceptions);\n+            this.exceptions = Util.sanitizeU2List(exceptions);\n@@ -247,1 +247,1 @@\n-            this.entries = List.copyOf(entries);\n+            this.entries = Util.sanitizeU2List(entries);\n@@ -271,1 +271,1 @@\n-            this.innerClasses = List.copyOf(innerClasses);\n+            this.innerClasses = Util.sanitizeU2List(innerClasses);\n@@ -295,1 +295,1 @@\n-            this.components = List.copyOf(components);\n+            this.components = Util.sanitizeU2List(components);\n@@ -350,1 +350,1 @@\n-            this.parameters = List.copyOf(parameters);\n+            this.parameters = Util.sanitizeU1List(parameters);\n@@ -424,1 +424,1 @@\n-            this.hashes = List.copyOf(hashes);\n+            this.hashes = Util.sanitizeU2List(hashes);\n@@ -449,1 +449,1 @@\n-        private final Collection<PackageEntry> packages;\n+        private final List<PackageEntry> packages;\n@@ -453,1 +453,1 @@\n-            this.packages = List.copyOf(packages);\n+            this.packages = Util.sanitizeU2List(packages);\n@@ -458,1 +458,1 @@\n-            return List.copyOf(packages);\n+            return packages;\n@@ -477,1 +477,1 @@\n-            resolutionFlags = flags;\n+            resolutionFlags = Util.checkU2(flags, \"resolution flags\");\n@@ -501,1 +501,1 @@\n-            this.permittedSubclasses = List.copyOf(permittedSubclasses);\n+            this.permittedSubclasses = Util.sanitizeU2List(permittedSubclasses);\n@@ -525,1 +525,1 @@\n-            this.memberEntries = List.copyOf(memberEntries);\n+            this.memberEntries = Util.sanitizeU2List(memberEntries);\n@@ -645,1 +645,1 @@\n-            this.ranges = List.copyOf(ranges);\n+            this.ranges = Util.sanitizeU2List(ranges);\n@@ -669,1 +669,1 @@\n-            this.lines = List.copyOf(lines);\n+            this.lines = Util.sanitizeU2List(lines);\n@@ -693,1 +693,1 @@\n-            this.locals = List.copyOf(locals);\n+            this.locals = Util.sanitizeU2List(locals);\n@@ -717,1 +717,1 @@\n-            this.locals = List.copyOf(locals);\n+            this.locals = Util.sanitizeU2List(locals);\n@@ -741,1 +741,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -765,1 +765,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -789,7 +789,1 @@\n-            \/\/ deep copy\n-            var array = elements.toArray().clone();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = List.copyOf((List<?>) array[i]);\n-            }\n-\n-            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+            this.elements = Util.sanitizeParameterAnnotations(elements);\n@@ -819,7 +813,1 @@\n-            \/\/ deep copy\n-            var array = elements.toArray().clone();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = List.copyOf((List<?>) array[i]);\n-            }\n-\n-            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+            this.elements = Util.sanitizeParameterAnnotations(elements);\n@@ -849,1 +837,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -873,1 +861,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -891,1 +879,8 @@\n-            implements CharacterRangeInfo { }\n+            implements CharacterRangeInfo {\n+\n+        public UnboundCharacterRangeInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(endPc, \"end pc\");\n+            Util.checkU2(flags, \"flags\");\n+        }\n+    }\n@@ -902,0 +897,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -906,1 +902,6 @@\n-            implements LineNumberInfo { }\n+            implements LineNumberInfo {\n+        public UnboundLineNumberInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(lineNumber, \"line number\");\n+        }\n+    }\n@@ -934,0 +935,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -943,1 +945,2 @@\n-            exportsTo = List.copyOf(exportsTo);\n+            Util.checkFlags(exportsFlagsMask);\n+            exportsTo = Util.sanitizeU2List(exportsTo);\n@@ -960,1 +963,2 @@\n-            opensTo = List.copyOf(opensTo);\n+            Util.checkFlags(opensFlagsMask);\n+            opensTo = Util.sanitizeU2List(opensTo);\n@@ -969,1 +973,1 @@\n-            providesWith = List.copyOf(providesWith);\n+            providesWith = Util.sanitizeU2List(providesWith);\n@@ -978,0 +982,1 @@\n+            Util.checkFlags(requiresFlagsMask);\n@@ -989,1 +994,1 @@\n-            attributes = List.copyOf(attributes);\n+            attributes = Util.sanitizeU2List(attributes);\n@@ -999,1 +1004,1 @@\n-            targetPath = List.copyOf(targetPath);\n+            targetPath = Util.sanitizeU1List(targetPath);\n@@ -1031,1 +1036,1 @@\n-            this.moduleFlags = moduleFlags;\n+            this.moduleFlags = Util.checkFlags(moduleFlags);\n@@ -1033,5 +1038,5 @@\n-            this.requires = List.copyOf(requires);\n-            this.exports = List.copyOf(exports);\n-            this.opens = List.copyOf(opens);\n-            this.uses = List.copyOf(uses);\n-            this.provides = List.copyOf(provides);\n+            this.requires = Util.sanitizeU2List(requires);\n+            this.exports = Util.sanitizeU2List(exports);\n+            this.opens = Util.sanitizeU2List(opens);\n+            this.uses = Util.sanitizeU2List(uses);\n+            this.provides = Util.sanitizeU2List(provides);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":53,"deletions":48,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-public class Util {\n+public final class Util {\n@@ -149,0 +149,27 @@\n+    \/\/\/ Sanitizes an input list to make it immutable, and verify its size can\n+    \/\/\/ be represented with U1, throwing IAE otherwise.\n+    public static <T> List<T> sanitizeU1List(List<T> input) {\n+        var copy = List.copyOf(input);\n+        checkU1(copy.size(), \"list size\");\n+        return copy;\n+    }\n+\n+    \/\/\/ Sanitizes an input list to make it immutable, and verify its size can\n+    \/\/\/ be represented with U2, throwing IAE otherwise.\n+    public static <T> List<T> sanitizeU2List(Collection<T> input) {\n+        var copy = List.copyOf(input);\n+        checkU2(copy.size(), \"list size\");\n+        return copy;\n+    }\n+\n+    \/\/\/ Sanitizes an input nested list of parameter annotations.\n+    public static List<List<Annotation>> sanitizeParameterAnnotations(List<List<Annotation>> input) {\n+        var array = input.toArray().clone();\n+        checkU1(array.length, \"parameter count\");\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = sanitizeU2List((List<?>) array[i]);\n+        }\n+\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+    }\n+\n@@ -189,0 +216,25 @@\n+    \/\/\/ Ensures the given value won't be truncated when written as a u1\n+    public static int checkU1(int incoming, String valueName) {\n+        if ((incoming & ~0xFF) != 0) {\n+            throw outOfRangeException(incoming, valueName, \"u1\");\n+        }\n+        return incoming;\n+    }\n+\n+    \/\/\/ Ensures the given value won't be truncated when written as a u2\n+    public static char checkU2(int incoming, String valueName) {\n+        if ((incoming & ~0xFFFF) != 0)\n+            throw outOfRangeException(incoming, valueName, \"u2\");\n+        return (char) incoming;\n+    }\n+\n+    public static IllegalArgumentException outOfRangeException(int value, String fieldName, String typeName) {\n+        return new IllegalArgumentException(\n+                String.format(\"%s out of range of %d: %d\", fieldName, typeName, value));\n+    }\n+\n+    \/\/\/ Ensures the given mask won't be truncated when written as an access flag\n+    public static char checkFlags(int mask) {\n+        return checkU2(mask, \"access flags\");\n+    }\n+\n@@ -237,0 +289,1 @@\n+        Util.checkU2(size, \"attributes count\");\n@@ -245,0 +298,1 @@\n+        Util.checkU2(size, \"member count\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import static jdk.internal.classfile.impl.StackMapGenerator.*;\n@@ -452,6 +453,6 @@\n-        if (ft < 64) return 1;\n-        if (ft < 128) return 1 + verificationTypeSize(frame.stack().getFirst());\n-        if (ft > 246) {\n-            if (ft == 247) return 3 + verificationTypeSize(frame.stack().getFirst());\n-            if (ft < 252) return 3;\n-            if (ft < 255) {\n+        if (ft <= SAME_FRAME_END) return 1;\n+        if (ft <= SAME_LOCALS_1_STACK_ITEM_FRAME_END) return 1 + verificationTypeSize(frame.stack().getFirst());\n+        if (ft > RESERVED_END) {\n+            if (ft == SAME_LOCALS_1_STACK_ITEM_EXTENDED) return 3 + verificationTypeSize(frame.stack().getFirst());\n+            if (ft <= SAME_FRAME_EXTENDED) return 3;\n+            if (ft <= APPEND_FRAME_END) {\n@@ -460,1 +461,2 @@\n-                for (int i = loc.size() + 251 - ft; i < loc.size(); i++) {\n+                var k = ft - APPEND_FRAME_START + 1;\n+                for (int i = loc.size() - k; i < loc.size(); i++) {\n@@ -465,1 +467,1 @@\n-            if (ft == 255) {\n+            if (ft == FULL_FRAME) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,3 +30,1 @@\n-import static jdk.internal.classfile.impl.verifier.VerificationType.ITEM_Object;\n-import static jdk.internal.classfile.impl.verifier.VerificationType.ITEM_Uninitialized;\n-import static jdk.internal.classfile.impl.verifier.VerificationType.ITEM_UninitializedThis;\n+import static jdk.internal.classfile.impl.StackMapGenerator.*;\n@@ -161,5 +159,0 @@\n-        private static final int\n-                        SAME_LOCALS_1_STACK_ITEM_EXTENDED = 247,\n-                        SAME_EXTENDED = 251,\n-                        FULL = 255;\n-\n@@ -255,1 +248,1 @@\n-            if (tag < ITEM_UninitializedThis) {\n+            if (tag < ITEM_UNINITIALIZED_THIS) {\n@@ -258,1 +251,1 @@\n-            if (tag == ITEM_Object) {\n+            if (tag == ITEM_OBJECT) {\n@@ -266,1 +259,1 @@\n-            if (tag == ITEM_UninitializedThis) {\n+            if (tag == ITEM_UNINITIALIZED_THIS) {\n@@ -272,1 +265,1 @@\n-            if (tag == ITEM_Uninitialized) {\n+            if (tag == ITEM_UNINITIALIZED) {\n@@ -288,1 +281,1 @@\n-            if (frame_type < 64) {\n+            if (frame_type <= SAME_FRAME_END) {\n@@ -305,1 +298,1 @@\n-            if (frame_type < 128) {\n+            if (frame_type <= SAME_LOCALS_1_STACK_ITEM_FRAME_END) {\n@@ -307,1 +300,1 @@\n-                    offset = frame_type - 64;\n+                    offset = frame_type - SAME_LOCALS_1_STACK_ITEM_FRAME_START;\n@@ -312,1 +305,1 @@\n-                    offset = _prev_frame.offset() + frame_type - 63;\n+                    offset = _prev_frame.offset() + frame_type - SAME_LOCALS_1_STACK_ITEM_FRAME_START + 1;\n@@ -359,1 +352,1 @@\n-            if (frame_type <= SAME_EXTENDED) {\n+            if (frame_type <= SAME_FRAME_EXTENDED) {\n@@ -362,1 +355,1 @@\n-                int chops = SAME_EXTENDED - frame_type;\n+                int chops = SAME_FRAME_EXTENDED - frame_type;\n@@ -392,2 +385,2 @@\n-            } else if (frame_type < SAME_EXTENDED + 4) {\n-                int appends = frame_type - SAME_EXTENDED;\n+            } else if (frame_type <= APPEND_FRAME_END) {\n+                int appends = frame_type - APPEND_FRAME_START + 1;\n@@ -421,1 +414,1 @@\n-            if (frame_type == FULL) {\n+            if (frame_type == FULL_FRAME) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationTable.java","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import static jdk.internal.classfile.impl.StackMapGenerator.*;\n@@ -43,12 +44,0 @@\n-    static final int\n-            ITEM_Top = 0,\n-            ITEM_Integer = 1,\n-            ITEM_Float = 2,\n-            ITEM_Double = 3,\n-            ITEM_Long = 4,\n-            ITEM_Null = 5,\n-            ITEM_UninitializedThis = 6,\n-            ITEM_Object = 7,\n-            ITEM_Uninitialized = 8,\n-            ITEM_Bogus = -1;\n-\n@@ -95,3 +84,0 @@\n-    private static final int\n-            ITEM_Boolean = 9, ITEM_Byte = 10, ITEM_Short = 11, ITEM_Char = 12,\n-            ITEM_Long_2nd = 13, ITEM_Double_2nd = 14;\n@@ -119,11 +105,11 @@\n-                            Bogus                            = (ITEM_Bogus            << 2 * BitsPerByte) | Primitive,\n-                            Boolean                        = (ITEM_Boolean        << 2 * BitsPerByte) | Category1,\n-                            Byte                             = (ITEM_Byte             << 2 * BitsPerByte) | Category1,\n-                            Short                            = (ITEM_Short            << 2 * BitsPerByte) | Category1,\n-                            Char                             = (ITEM_Char             << 2 * BitsPerByte) | Category1,\n-                            Integer                        = (ITEM_Integer        << 2 * BitsPerByte) | Category1,\n-                            Float                            = (ITEM_Float            << 2 * BitsPerByte) | Category1,\n-                            Long                             = (ITEM_Long             << 2 * BitsPerByte) | Category2,\n-                            Double                         = (ITEM_Double         << 2 * BitsPerByte) | Category2,\n-                            Long_2nd                     = (ITEM_Long_2nd     << 2 * BitsPerByte) | Category2_2nd,\n-                            Double_2nd                 = (ITEM_Double_2nd << 2 * BitsPerByte) | Category2_2nd,\n+                            Bogus                            = (ITEM_BOGUS            << 2 * BitsPerByte) | Primitive,\n+                            Boolean                        = (ITEM_BOOLEAN        << 2 * BitsPerByte) | Category1,\n+                            Byte                             = (ITEM_BYTE             << 2 * BitsPerByte) | Category1,\n+                            Short                            = (ITEM_SHORT            << 2 * BitsPerByte) | Category1,\n+                            Char                             = (ITEM_CHAR             << 2 * BitsPerByte) | Category1,\n+                            Integer                        = (ITEM_INTEGER        << 2 * BitsPerByte) | Category1,\n+                            Float                            = (ITEM_FLOAT            << 2 * BitsPerByte) | Category1,\n+                            Long                             = (ITEM_LONG             << 2 * BitsPerByte) | Category2,\n+                            Double                         = (ITEM_DOUBLE         << 2 * BitsPerByte) | Category2,\n+                            Long_2nd                     = (ITEM_LONG_2ND     << 2 * BitsPerByte) | Category2_2nd,\n+                            Double_2nd                 = (ITEM_DOUBLE_2ND << 2 * BitsPerByte) | Category2_2nd,\n@@ -367,6 +353,6 @@\n-            case ITEM_Top:         return bogus_type;\n-            case ITEM_Integer: return integer_type;\n-            case ITEM_Float:     return float_type;\n-            case ITEM_Double:    return double_type;\n-            case ITEM_Long:        return long_type;\n-            case ITEM_Null:        return null_type;\n+            case ITEM_TOP:         return bogus_type;\n+            case ITEM_INTEGER: return integer_type;\n+            case ITEM_FLOAT:     return float_type;\n+            case ITEM_DOUBLE:    return double_type;\n+            case ITEM_LONG:        return long_type;\n+            case ITEM_NULL:        return null_type;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationType.java","additions":18,"deletions":32,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.constant.ConstantDescs.BSM_INVOKE;\n+import static java.lang.constant.ConstantDescs.CD_MethodHandle;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a\n+ * {@link MethodHandle} constant that performs a {@link MethodHandle#asType(MethodType)}\n+ * adaptation on another {@link MethodHandle}.\n+ *\/\n+public final class AsTypeMethodHandleDesc extends DynamicConstantDesc<MethodHandle>\n+        implements MethodHandleDesc {\n+\n+    private static final DirectMethodHandleDesc MHD_METHODHANDLE_ASTYPE\n+            = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.VIRTUAL, CD_MethodHandle, \"asType\",\n+                                        MethodTypeDesc.of(CD_MethodHandle, ConstantDescs.CD_MethodType));\n+\n+    private final MethodHandleDesc underlying;\n+    private final MethodTypeDesc type;\n+\n+    public AsTypeMethodHandleDesc(MethodHandleDesc underlying, MethodTypeDesc type) {\n+        super(BSM_INVOKE, ConstantDescs.DEFAULT_NAME, CD_MethodHandle,\n+              MHD_METHODHANDLE_ASTYPE, underlying, type);\n+        this.underlying = requireNonNull(underlying);\n+        this.type = requireNonNull(type);\n+    }\n+\n+    @Override\n+    public MethodTypeDesc invocationType() {\n+        return type;\n+    }\n+\n+    @Override\n+    public MethodHandle resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        MethodHandle handle = underlying.resolveConstantDesc(lookup);\n+        MethodType methodType = type.resolveConstantDesc(lookup);\n+        return handle.asType(methodType);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return  String.format(\"%s.asType%s\", underlying.toString(), type.displayDescriptor());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/AsTypeMethodHandleDesc.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -74,1 +75,6 @@\n-        return new String(bytes, charset);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+            \/\/ use replacement characters for malformed input\n+            return new String(bytes, charset);\n+        }\n@@ -88,1 +94,6 @@\n-        return new String(bytes, charset);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+          \/\/ use replacement characters for malformed input\n+          return new String(bytes, charset);\n+        }\n@@ -102,1 +113,6 @@\n-        return new String(bytes, charset);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringOrThrow(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+            \/\/ use replacement characters for malformed input\n+            return new String(bytes, charset);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n@@ -34,2 +32,0 @@\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileTime;\n@@ -37,0 +33,1 @@\n+import java.nio.file.attribute.BasicFileAttributes;\n@@ -38,0 +35,1 @@\n+import java.util.Arrays;\n@@ -45,1 +43,3 @@\n-import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n@@ -48,0 +48,25 @@\n+ * A view over the entries of a jimage file with a unified namespace suitable\n+ * for file system use. The jimage entries (resources, module and package\n+ * information) are mapped into a unified hierarchy of named nodes, which serve\n+ * as the underlying structure for {@code JrtFileSystem} and other utilities.\n+ *\n+ * <p>Entries in jimage are expressed as one of three {@link Node} types;\n+ * resource nodes, directory nodes and link nodes.\n+ *\n+ * <p>When remapping jimage entries, jimage location names (e.g. {@code\n+ * \"\/java.base\/java\/lang\/Integer.class\"}) are prefixed with {@code \"\/modules\"}\n+ * to form the names of resource nodes. This aligns with the naming of module\n+ * entries in jimage (e.g. \"\/modules\/java.base\/java\/lang\"), which appear as\n+ * directory nodes in {@code ImageReader}.\n+ *\n+ * <p>Package entries (e.g. {@code \"\/packages\/java.lang\"} appear as directory\n+ * nodes containing link nodes, which resolve back to the root directory of the\n+ * module in which that package exists (e.g. {@code \"\/modules\/java.base\"}).\n+ * Unlike other nodes, the jimage file does not contain explicit entries for\n+ * link nodes, and their existence is derived only from the contents of the\n+ * parent directory.\n+ *\n+ * <p>While similar to {@code BasicImageReader}, this class is not a conceptual\n+ * subtype of it, and deliberately hides types such as {@code ImageLocation} to\n+ * give a focused API based only on nodes.\n+ *\n@@ -63,0 +88,4 @@\n+    \/**\n+     * Opens an image reader for a jimage file at the specified path, using the\n+     * given byte order.\n+     *\/\n@@ -70,0 +99,4 @@\n+    \/**\n+     * Opens an image reader for a jimage file at the specified path, using the\n+     * platform native byte order.\n+     *\/\n@@ -95,7 +128,7 @@\n-    \/\/ directory management interface\n-    public Directory getRootDirectory() throws IOException {\n-        ensureOpen();\n-        return reader.getRootDirectory();\n-    }\n-\n-\n+    \/**\n+     * Finds the node with the given name.\n+     *\n+     * @param name a node name of the form {@code \"\/modules\/<module>\/...} or\n+     *     {@code \"\/packages\/<package>\/...}.\n+     * @return a node representing a resource, directory or symbolic link.\n+     *\/\n@@ -107,0 +140,8 @@\n+    \/**\n+     * Returns a copy of the content of a resource node. The buffer returned by\n+     * this method is not cached by the node, and each call returns a new array\n+     * instance.\n+     *\n+     * @throws IOException if the content cannot be returned (including if the\n+     * given node is not a resource node).\n+     *\/\n@@ -112,10 +153,7 @@\n-    public byte[] getResource(Resource rs) throws IOException {\n-        ensureOpen();\n-        return reader.getResource(rs);\n-    }\n-\n-    public ImageHeader getHeader() {\n-        requireOpen();\n-        return reader.getHeader();\n-    }\n-\n+    \/**\n+     * Releases a (possibly cached) {@link ByteBuffer} obtained via\n+     * {@link #getResourceBuffer(Node)}.\n+     *\n+     * <p>Note that no testing is performed to check whether the buffer about\n+     * to be released actually came from a call to {@code getResourceBuffer()}.\n+     *\/\n@@ -126,57 +164,6 @@\n-    public String getName() {\n-        requireOpen();\n-        return reader.getName();\n-    }\n-\n-    public ByteOrder getByteOrder() {\n-        requireOpen();\n-        return reader.getByteOrder();\n-    }\n-\n-    public Path getImagePath() {\n-        requireOpen();\n-        return reader.getImagePath();\n-    }\n-\n-    public ImageStringsReader getStrings() {\n-        requireOpen();\n-        return reader.getStrings();\n-    }\n-\n-    public ImageLocation findLocation(String mn, String rn) {\n-        requireOpen();\n-        return reader.findLocation(mn, rn);\n-    }\n-\n-    public boolean verifyLocation(String mn, String rn) {\n-        requireOpen();\n-        return reader.verifyLocation(mn, rn);\n-    }\n-\n-    public ImageLocation findLocation(String name) {\n-        requireOpen();\n-        return reader.findLocation(name);\n-    }\n-\n-    public String[] getEntryNames() {\n-        requireOpen();\n-        return reader.getEntryNames();\n-    }\n-\n-    public String[] getModuleNames() {\n-        requireOpen();\n-        int off = \"\/modules\/\".length();\n-        return reader.findNode(\"\/modules\")\n-                     .getChildren()\n-                     .stream()\n-                     .map(Node::getNameString)\n-                     .map(s -> s.substring(off, s.length()))\n-                     .toArray(String[]::new);\n-    }\n-\n-    public long[] getAttributes(int offset) {\n-        requireOpen();\n-        return reader.getAttributes(offset);\n-    }\n-\n-    public String getString(int offset) {\n+    \/**\n+     * Returns the content of a resource node in a possibly cached byte buffer.\n+     * Callers of this method must call {@link #releaseByteBuffer(ByteBuffer)}\n+     * when they are finished with it.\n+     *\/\n+    public ByteBuffer getResourceBuffer(Node node) {\n@@ -184,21 +171,4 @@\n-        return reader.getString(offset);\n-    }\n-\n-    public byte[] getResource(String name) {\n-        requireOpen();\n-        return reader.getResource(name);\n-    }\n-\n-    public byte[] getResource(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResource(loc);\n-    }\n-\n-    public ByteBuffer getResourceBuffer(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResourceBuffer(loc);\n-    }\n-\n-    public InputStream getResourceStream(ImageLocation loc) {\n-        requireOpen();\n-        return reader.getResourceStream(loc);\n+        if (!node.isResource()) {\n+            throw new IllegalArgumentException(\"Not a resource node: \" + node);\n+        }\n+        return reader.getResourceBuffer(node.getLocation());\n@@ -208,3 +178,7 @@\n-        static final int SIZE_OF_OFFSET = Integer.BYTES;\n-\n-        static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n+        private static final Map<Path, SharedImageReader> OPEN_FILES = new HashMap<>();\n+        private static final String MODULES_ROOT = \"\/modules\";\n+        private static final String PACKAGES_ROOT = \"\/packages\";\n+        \/\/ There are >30,000 nodes in a complete jimage tree, and even relatively\n+        \/\/ common tasks (e.g. starting up javac) load somewhere in the region of\n+        \/\/ 1000 classes. Thus, an initial capacity of 2000 is a reasonable guess.\n+        private static final int INITIAL_NODE_CACHE_CAPACITY = 2000;\n@@ -213,1 +187,1 @@\n-        final Set<ImageReader> openers;\n+        private final Set<ImageReader> openers = new HashSet<>();\n@@ -215,1 +189,1 @@\n-        \/\/ attributes of the .jimage file. jimage file does not contain\n+        \/\/ Attributes of the jimage file. The jimage file does not contain\n@@ -218,6 +192,1 @@\n-        \/\/ Iniitalized lazily, see {@link #imageFileAttributes()}.\n-        BasicFileAttributes imageFileAttributes;\n-\n-        \/\/ directory management implementation\n-        final HashMap<String, Node> nodes;\n-        volatile Directory rootDir;\n+        private final BasicFileAttributes imageFileAttributes;\n@@ -225,2 +194,5 @@\n-        Directory packagesDir;\n-        Directory modulesDir;\n+        \/\/ Cache of all user visible nodes, guarded by synchronizing 'this' instance.\n+        private final Map<String, Node> nodes;\n+        \/\/ Used to classify ImageLocation instances without string comparison.\n+        private final int modulesStringOffset;\n+        private final int packagesStringOffset;\n@@ -230,2 +202,30 @@\n-            this.openers = new HashSet<>();\n-            this.nodes = new HashMap<>();\n+            this.imageFileAttributes = Files.readAttributes(imagePath, BasicFileAttributes.class);\n+            this.nodes = new HashMap<>(INITIAL_NODE_CACHE_CAPACITY);\n+            \/\/ Pick stable jimage names from which to extract string offsets (we cannot\n+            \/\/ use \"\/modules\" or \"\/packages\", since those have a module offset of zero).\n+            this.modulesStringOffset = getModuleOffset(\"\/modules\/java.base\");\n+            this.packagesStringOffset = getModuleOffset(\"\/packages\/java.lang\");\n+\n+            \/\/ Node creation is very lazy, so we can just make the top-level directories\n+            \/\/ now without the risk of triggering the building of lots of other nodes.\n+            Directory packages = newDirectory(PACKAGES_ROOT);\n+            nodes.put(packages.getName(), packages);\n+            Directory modules = newDirectory(MODULES_ROOT);\n+            nodes.put(modules.getName(), modules);\n+\n+            Directory root = newDirectory(\"\/\");\n+            root.setChildren(Arrays.asList(packages, modules));\n+            nodes.put(root.getName(), root);\n+        }\n+\n+        \/**\n+         * Returns the offset of the string denoting the leading \"module\" segment in\n+         * the given path (e.g. {@code <module>\/<path>}). We can't just pass in the\n+         * {@code \/<module>} string here because that has a module offset of zero.\n+         *\/\n+        private int getModuleOffset(String path) {\n+            ImageLocation location = findLocation(path);\n+            assert location != null : \"Cannot find expected jimage location: \" + path;\n+            int offset = location.getModuleOffset();\n+            assert offset != 0 : \"Invalid module offset for jimage location: \" + path;\n+            return offset;\n@@ -234,1 +234,1 @@\n-        public static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n+        private static ImageReader open(Path imagePath, ByteOrder byteOrder) throws IOException {\n@@ -267,1 +267,0 @@\n-                    rootDir = null;\n@@ -276,17 +275,0 @@\n-        void addOpener(ImageReader reader) {\n-            synchronized (OPEN_FILES) {\n-                openers.add(reader);\n-            }\n-        }\n-\n-        boolean removeOpener(ImageReader reader) {\n-            synchronized (OPEN_FILES) {\n-                return openers.remove(reader);\n-            }\n-        }\n-\n-        \/\/ directory management interface\n-        Directory getRootDirectory() {\n-            return buildRootDirectory();\n-        }\n-\n@@ -294,1 +276,11 @@\n-         * Lazily build a node from a name.\n+         * Returns a node with the given name, or null if no resource or directory of\n+         * that name exists.\n+         *\n+         * <p>This is the only public API by which anything outside this class can access\n+         * {@code Node} instances either directly, or by resolving symbolic links.\n+         *\n+         * <p>Note also that there is no reentrant calling back to this method from within\n+         * the node handling code.\n+         *\n+         * @param name an absolute, {@code \/}-separated path string, prefixed with either\n+         *     \"\/modules\" or \"\/packages\".\n@@ -296,16 +288,9 @@\n-        synchronized Node buildNode(String name) {\n-            Node n;\n-            boolean isPackages = name.startsWith(\"\/packages\");\n-            boolean isModules = !isPackages && name.startsWith(\"\/modules\");\n-\n-            if (!(isModules || isPackages)) {\n-                return null;\n-            }\n-\n-            ImageLocation loc = findLocation(name);\n-\n-            if (loc != null) { \/\/ A sub tree node\n-                if (isPackages) {\n-                    n = handlePackages(name, loc);\n-                } else { \/\/ modules sub tree\n-                    n = handleModulesSubTree(name, loc);\n+        synchronized Node findNode(String name) {\n+            Node node = nodes.get(name);\n+            if (node == null) {\n+                \/\/ We cannot get the root paths (\"\/modules\" or \"\/packages\") here\n+                \/\/ because those nodes are already in the nodes cache.\n+                if (name.startsWith(MODULES_ROOT + \"\/\")) {\n+                    node = buildModulesNode(name);\n+                } else if (name.startsWith(PACKAGES_ROOT + \"\/\")) {\n+                    node = buildPackagesNode(name);\n@@ -313,7 +298,2 @@\n-            } else { \/\/ Asking for a resource? \/modules\/java.base\/java\/lang\/Object.class\n-                if (isModules) {\n-                    n = handleResource(name);\n-                } else {\n-                    \/\/ Possibly ask for \/packages\/java.lang\/java.base\n-                    \/\/ although \/packages\/java.base not created\n-                    n = handleModuleLink(name);\n+                if (node != null) {\n+                    nodes.put(node.getName(), node);\n@@ -321,0 +301,4 @@\n+            } else if (!node.isCompleted()) {\n+                \/\/ Only directories can be incomplete.\n+                assert node instanceof Directory : \"Invalid incomplete node: \" + node;\n+                completeDirectory((Directory) node);\n@@ -322,22 +306,2 @@\n-            return n;\n-        }\n-\n-        synchronized Directory buildRootDirectory() {\n-            Directory root = rootDir; \/\/ volatile read\n-            if (root != null) {\n-                return root;\n-            }\n-\n-            root = newDirectory(null, \"\/\");\n-            root.setIsRootDir();\n-\n-            \/\/ \/packages dir\n-            packagesDir = newDirectory(root, \"\/packages\");\n-            packagesDir.setIsPackagesDir();\n-\n-            \/\/ \/modules dir\n-            modulesDir = newDirectory(root, \"\/modules\");\n-            modulesDir.setIsModulesDir();\n-\n-            root.setCompleted(true);\n-            return rootDir = root;\n+            assert node == null || node.isCompleted() : \"Incomplete node: \" + node;\n+            return node;\n@@ -347,1 +311,4 @@\n-         * To visit sub tree resources.\n+         * Builds a node in the \"\/modules\/...\" namespace.\n+         *\n+         * <p>Called by {@link #findNode(String)} if a {@code \/modules\/...} node\n+         * is not present in the cache.\n@@ -349,37 +316,9 @@\n-        interface LocationVisitor {\n-            void visit(ImageLocation loc);\n-        }\n-\n-        void visitLocation(ImageLocation loc, LocationVisitor visitor) {\n-            byte[] offsets = getResource(loc);\n-            ByteBuffer buffer = ByteBuffer.wrap(offsets);\n-            buffer.order(getByteOrder());\n-            IntBuffer intBuffer = buffer.asIntBuffer();\n-            for (int i = 0; i < offsets.length \/ SIZE_OF_OFFSET; i++) {\n-                int offset = intBuffer.get(i);\n-                ImageLocation pkgLoc = getLocation(offset);\n-                visitor.visit(pkgLoc);\n-            }\n-        }\n-\n-        void visitPackageLocation(ImageLocation loc) {\n-            \/\/ Retrieve package name\n-            String pkgName = getBaseExt(loc);\n-            \/\/ Content is array of offsets in Strings table\n-            byte[] stringsOffsets = getResource(loc);\n-            ByteBuffer buffer = ByteBuffer.wrap(stringsOffsets);\n-            buffer.order(getByteOrder());\n-            IntBuffer intBuffer = buffer.asIntBuffer();\n-            \/\/ For each module, create a link node.\n-            for (int i = 0; i < stringsOffsets.length \/ SIZE_OF_OFFSET; i++) {\n-                \/\/ skip empty state, useless.\n-                intBuffer.get(i);\n-                i++;\n-                int offset = intBuffer.get(i);\n-                String moduleName = getString(offset);\n-                Node targetNode = findNode(\"\/modules\/\" + moduleName);\n-                if (targetNode != null) {\n-                    String pkgDirName = packagesDir.getName() + \"\/\" + pkgName;\n-                    Directory pkgDir = (Directory) nodes.get(pkgDirName);\n-                    newLinkNode(pkgDir, pkgDir.getName() + \"\/\" + moduleName, targetNode);\n-                }\n+        private Node buildModulesNode(String name) {\n+            assert name.startsWith(MODULES_ROOT + \"\/\") : \"Invalid module node name: \" + name;\n+            \/\/ Returns null for non-directory resources, since the jimage name does not\n+            \/\/ start with \"\/modules\" (e.g. \"\/java.base\/java\/lang\/Object.class\").\n+            ImageLocation loc = findLocation(name);\n+            if (loc != null) {\n+                assert name.equals(loc.getFullName()) : \"Mismatched location for directory: \" + name;\n+                assert isModulesSubdirectory(loc) : \"Invalid modules directory: \" + name;\n+                return completeModuleDirectory(newDirectory(name), loc);\n@@ -387,0 +326,5 @@\n+            \/\/ Now try the non-prefixed resource name, but be careful to avoid false\n+            \/\/ positives for names like \"\/modules\/modules\/xxx\" which could return a\n+            \/\/ location of a directory entry.\n+            loc = findLocation(name.substring(MODULES_ROOT.length()));\n+            return loc != null && isResource(loc) ? newResource(name, loc) : null;\n@@ -389,10 +333,17 @@\n-        Node handlePackages(String name, ImageLocation loc) {\n-            long size = loc.getUncompressedSize();\n-            Node n = null;\n-            \/\/ Only possibilities are \/packages, \/packages\/package\/module\n-            if (name.equals(\"\/packages\")) {\n-                visitLocation(loc, (childloc) -> {\n-                    findNode(childloc.getFullName());\n-                });\n-                packagesDir.setCompleted(true);\n-                n = packagesDir;\n+        \/**\n+         * Builds a node in the \"\/packages\/...\" namespace.\n+         *\n+         * <p>Called by {@link #findNode(String)} if a {@code \/packages\/...} node\n+         * is not present in the cache.\n+         *\/\n+        private Node buildPackagesNode(String name) {\n+            \/\/ There are only locations for the root \"\/packages\" or \"\/packages\/xxx\"\n+            \/\/ directories, but not the symbolic links below them (the links can be\n+            \/\/ entirely derived from the name information in the parent directory).\n+            \/\/ However, unlike resources this means that we do not have a constant\n+            \/\/ time lookup for link nodes when creating them.\n+            int packageStart = PACKAGES_ROOT.length() + 1;\n+            int packageEnd = name.indexOf('\/', packageStart);\n+            if (packageEnd == -1) {\n+                ImageLocation loc = findLocation(name);\n+                return loc != null ? completePackageDirectory(newDirectory(name), loc) : null;\n@@ -400,45 +351,13 @@\n-                if (size != 0) { \/\/ children are offsets to module in StringsTable\n-                    String pkgName = getBaseExt(loc);\n-                    Directory pkgDir = newDirectory(packagesDir, packagesDir.getName() + \"\/\" + pkgName);\n-                    visitPackageLocation(loc);\n-                    pkgDir.setCompleted(true);\n-                    n = pkgDir;\n-                } else { \/\/ Link to module\n-                    String pkgName = loc.getParent();\n-                    String modName = getBaseExt(loc);\n-                    Node targetNode = findNode(\"\/modules\/\" + modName);\n-                    if (targetNode != null) {\n-                        String pkgDirName = packagesDir.getName() + \"\/\" + pkgName;\n-                        Directory pkgDir = (Directory) nodes.get(pkgDirName);\n-                        Node linkNode = newLinkNode(pkgDir, pkgDir.getName() + \"\/\" + modName, targetNode);\n-                        n = linkNode;\n-                    }\n-                }\n-            }\n-            return n;\n-        }\n-\n-        \/\/ Asking for \/packages\/package\/module although\n-        \/\/ \/packages\/<pkg>\/ not yet created, need to create it\n-        \/\/ prior to return the link to module node.\n-        Node handleModuleLink(String name) {\n-            \/\/ eg: unresolved \/packages\/package\/module\n-            \/\/ Build \/packages\/package node\n-            Node ret = null;\n-            String radical = \"\/packages\/\";\n-            String path = name;\n-            if (path.startsWith(radical)) {\n-                int start = radical.length();\n-                int pkgEnd = path.indexOf('\/', start);\n-                if (pkgEnd != -1) {\n-                    String pkg = path.substring(start, pkgEnd);\n-                    String pkgPath = radical + pkg;\n-                    Node n = findNode(pkgPath);\n-                    \/\/ If not found means that this is a symbolic link such as:\n-                    \/\/ \/packages\/java.util\/java.base\/java\/util\/Vector.class\n-                    \/\/ and will be done by a retry of the filesystem\n-                    for (Node child : n.getChildren()) {\n-                        if (child.name.equals(name)) {\n-                            ret = child;\n-                            break;\n-                        }\n+                \/\/ We cannot assume that the parent directory exists for a link node, since\n+                \/\/ the given name is untrusted and could reference a non-existent link.\n+                \/\/ However, if the parent directory is present, we can conclude that the\n+                \/\/ given name was not a valid link (or else it would already be cached).\n+                String dirName = name.substring(0, packageEnd);\n+                if (!nodes.containsKey(dirName)) {\n+                    ImageLocation loc = findLocation(dirName);\n+                    \/\/ If the parent location doesn't exist, the link node cannot exist.\n+                    if (loc != null) {\n+                        nodes.put(dirName, completePackageDirectory(newDirectory(dirName), loc));\n+                        \/\/ When the parent is created its child nodes are created and cached,\n+                        \/\/ but this can still return null if given name wasn't a valid link.\n+                        return nodes.get(name);\n@@ -448,23 +367,1 @@\n-            return ret;\n-        }\n-\n-        Node handleModulesSubTree(String name, ImageLocation loc) {\n-            Node n;\n-            assert (name.equals(loc.getFullName()));\n-            Directory dir = makeDirectories(name);\n-            visitLocation(loc, (childloc) -> {\n-                String path = childloc.getFullName();\n-                if (path.startsWith(\"\/modules\")) { \/\/ a package\n-                    makeDirectories(path);\n-                } else { \/\/ a resource\n-                    makeDirectories(childloc.buildName(true, true, false));\n-                    \/\/ if we have already created a resource for this name previously, then don't\n-                    \/\/ recreate it\n-                    if (!nodes.containsKey(childloc.getFullName(true))) {\n-                        newResource(dir, childloc);\n-                    }\n-                }\n-            });\n-            dir.setCompleted(true);\n-            n = dir;\n-            return n;\n+            return null;\n@@ -473,21 +370,16 @@\n-        Node handleResource(String name) {\n-            Node n = null;\n-            if (!name.startsWith(\"\/modules\/\")) {\n-                return null;\n-            }\n-            \/\/ Make sure that the thing that follows \"\/modules\/\" is a module name.\n-            int moduleEndIndex = name.indexOf('\/', \"\/modules\/\".length());\n-            if (moduleEndIndex == -1) {\n-                return null;\n-            }\n-            ImageLocation moduleLoc = findLocation(name.substring(0, moduleEndIndex));\n-            if (moduleLoc == null || moduleLoc.getModuleOffset() == 0) {\n-                return null;\n-            }\n-\n-            String locationPath = name.substring(\"\/modules\".length());\n-            ImageLocation resourceLoc = findLocation(locationPath);\n-            if (resourceLoc != null) {\n-                Directory dir = makeDirectories(resourceLoc.buildName(true, true, false));\n-                Resource res = newResource(dir, resourceLoc);\n-                n = res;\n+        \/** Completes a directory by ensuring its child list is populated correctly. *\/\n+        private void completeDirectory(Directory dir) {\n+            String name = dir.getName();\n+            \/\/ Since the node exists, we can assert that its name starts with\n+            \/\/ either \"\/modules\" or \"\/packages\", making differentiation easy.\n+            \/\/ It also means that the name is valid, so it must yield a location.\n+            assert name.startsWith(MODULES_ROOT) || name.startsWith(PACKAGES_ROOT);\n+            ImageLocation loc = findLocation(name);\n+            assert loc != null && name.equals(loc.getFullName()) : \"Invalid location for name: \" + name;\n+            \/\/ We cannot use 'isXxxSubdirectory()' methods here since we could\n+            \/\/ be given a top-level directory (for which that test doesn't work).\n+            \/\/ The string MUST start \"\/modules\" or \"\/packages\" here.\n+            if (name.charAt(1) == 'm') {\n+                completeModuleDirectory(dir, loc);\n+            } else {\n+                completePackageDirectory(dir, loc);\n@@ -495,1 +387,1 @@\n-            return n;\n+            assert dir.isCompleted() : \"Directory must be complete by now: \" + dir;\n@@ -498,7 +390,19 @@\n-        String getBaseExt(ImageLocation loc) {\n-            String base = loc.getBase();\n-            String ext = loc.getExtension();\n-            if (ext != null && !ext.isEmpty()) {\n-                base = base + \".\" + ext;\n-            }\n-            return base;\n+        \/**\n+         * Completes a modules directory by setting the list of child nodes.\n+         *\n+         * <p>The given directory can be the top level {@code \/modules} directory,\n+         * so it is NOT safe to use {@code isModulesSubdirectory(loc)} here.\n+         *\/\n+        private Directory completeModuleDirectory(Directory dir, ImageLocation loc) {\n+            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n+            List<Node> children = createChildNodes(loc, childLoc -> {\n+                if (isModulesSubdirectory(childLoc)) {\n+                    return nodes.computeIfAbsent(childLoc.getFullName(), this::newDirectory);\n+                } else {\n+                    \/\/ Add \"\/modules\" prefix to image location paths to get node names.\n+                    String resourceName = childLoc.getFullName(true);\n+                    return nodes.computeIfAbsent(resourceName, n -> newResource(n, childLoc));\n+                }\n+            });\n+            dir.setChildren(children);\n+            return dir;\n@@ -507,5 +411,29 @@\n-        synchronized Node findNode(String name) {\n-            buildRootDirectory();\n-            Node n = nodes.get(name);\n-            if (n == null || !n.isCompleted()) {\n-                n = buildNode(name);\n+        \/**\n+         * Completes a package directory by setting the list of child nodes.\n+         *\n+         * <p>The given directory can be the top level {@code \/packages} directory,\n+         * so it is NOT safe to use {@code isPackagesSubdirectory(loc)} here.\n+         *\/\n+        private Directory completePackageDirectory(Directory dir, ImageLocation loc) {\n+            assert dir.getName().equals(loc.getFullName()) : \"Mismatched location for directory: \" + dir;\n+            \/\/ The only directories in the \"\/packages\" namespace are \"\/packages\" or\n+            \/\/ \"\/packages\/<package>\". However, unlike \"\/modules\" directories, the\n+            \/\/ location offsets mean different things.\n+            List<Node> children;\n+            if (dir.getName().equals(PACKAGES_ROOT)) {\n+                \/\/ Top-level directory just contains a list of subdirectories.\n+                children = createChildNodes(loc, c -> nodes.computeIfAbsent(c.getFullName(), this::newDirectory));\n+            } else {\n+                \/\/ A package directory's content is array of offset PAIRS in the\n+                \/\/ Strings table, but we only need the 2nd value of each pair.\n+                IntBuffer intBuffer = getOffsetBuffer(loc);\n+                int offsetCount = intBuffer.capacity();\n+                assert (offsetCount & 0x1) == 0 : \"Offset count must be even: \" + offsetCount;\n+                children = new ArrayList<>(offsetCount \/ 2);\n+                \/\/ Iterate the 2nd offset in each pair (odd indices).\n+                for (int i = 1; i < offsetCount; i += 2) {\n+                    String moduleName = getString(intBuffer.get(i));\n+                    children.add(nodes.computeIfAbsent(\n+                            dir.getName() + \"\/\" + moduleName,\n+                            n -> newLinkNode(n, MODULES_ROOT + \"\/\" + moduleName)));\n+                }\n@@ -513,1 +441,3 @@\n-            return n;\n+            \/\/ This only happens once and \"completes\" the directory.\n+            dir.setChildren(children);\n+            return dir;\n@@ -517,1 +447,4 @@\n-         * Returns the file attributes of the image file.\n+         * Creates the list of child nodes for a {@code Directory} based on a given\n+         *\n+         * <p>Note: This cannot be used for package subdirectories as they have\n+         * child offsets stored differently to other directories.\n@@ -519,10 +452,6 @@\n-        BasicFileAttributes imageFileAttributes() {\n-            BasicFileAttributes attrs = imageFileAttributes;\n-            if (attrs == null) {\n-                try {\n-                    Path file = getImagePath();\n-                    attrs = Files.readAttributes(file, BasicFileAttributes.class);\n-                } catch (IOException ioe) {\n-                    throw new UncheckedIOException(ioe);\n-                }\n-                imageFileAttributes = attrs;\n+        private List<Node> createChildNodes(ImageLocation loc, Function<ImageLocation, Node> newChildFn) {\n+            IntBuffer offsets = getOffsetBuffer(loc);\n+            int childCount = offsets.capacity();\n+            List<Node> children = new ArrayList<>(childCount);\n+            for (int i = 0; i < childCount; i++) {\n+                children.add(newChildFn.apply(getLocation(offsets.get(i))));\n@@ -530,1 +459,1 @@\n-            return attrs;\n+            return children;\n@@ -533,4 +462,7 @@\n-        Directory newDirectory(Directory parent, String name) {\n-            Directory dir = Directory.create(parent, name, imageFileAttributes());\n-            nodes.put(dir.getName(), dir);\n-            return dir;\n+        \/** Helper to extract the integer offset buffer from a directory location. *\/\n+        private IntBuffer getOffsetBuffer(ImageLocation dir) {\n+            assert !isResource(dir) : \"Not a directory: \" + dir.getFullName();\n+            byte[] offsets = getResource(dir);\n+            ByteBuffer buffer = ByteBuffer.wrap(offsets);\n+            buffer.order(getByteOrder());\n+            return buffer.asIntBuffer();\n@@ -539,4 +471,12 @@\n-        Resource newResource(Directory parent, ImageLocation loc) {\n-            Resource res = Resource.create(parent, loc, imageFileAttributes());\n-            nodes.put(res.getName(), res);\n-            return res;\n+        \/**\n+         * Efficiently determines if an image location is a resource.\n+         *\n+         * <p>A resource must have a valid module associated with it, so its\n+         * module offset must be non-zero, and not equal to the offsets for\n+         * \"\/modules\/...\" or \"\/packages\/...\" entries.\n+         *\/\n+        private boolean isResource(ImageLocation loc) {\n+            int moduleOffset = loc.getModuleOffset();\n+            return moduleOffset != 0\n+                    && moduleOffset != modulesStringOffset\n+                    && moduleOffset != packagesStringOffset;\n@@ -545,4 +485,10 @@\n-        LinkNode newLinkNode(Directory dir, String name, Node link) {\n-            LinkNode linkNode = LinkNode.create(dir, name, link);\n-            nodes.put(linkNode.getName(), linkNode);\n-            return linkNode;\n+        \/**\n+         * Determines if an image location is a directory in the {@code \/modules}\n+         * namespace (if so, the location name is the node name).\n+         *\n+         * <p>In jimage, every {@code ImageLocation} under {@code \/modules\/} is a\n+         * directory and has the same value for {@code getModule()}, and {@code\n+         * getModuleOffset()}.\n+         *\/\n+        private boolean isModulesSubdirectory(ImageLocation loc) {\n+            return loc.getModuleOffset() == modulesStringOffset;\n@@ -551,9 +497,8 @@\n-        Directory makeDirectories(String parent) {\n-            Directory last = rootDir;\n-            for (int offset = parent.indexOf('\/', 1);\n-                    offset != -1;\n-                    offset = parent.indexOf('\/', offset + 1)) {\n-                String dir = parent.substring(0, offset);\n-                last = makeDirectory(dir, last);\n-            }\n-            return makeDirectory(parent, last);\n+        \/**\n+         * Creates an \"incomplete\" directory node with no child nodes set.\n+         * Directories need to be \"completed\" before they are returned by\n+         * {@link #findNode(String)}.\n+         *\/\n+        private Directory newDirectory(String name) {\n+            return new Directory(name, imageFileAttributes);\n+        }\n@@ -561,0 +506,8 @@\n+        \/**\n+         * Creates a new resource from an image location. This is the only case\n+         * where the image location name does not match the requested node name.\n+         * In image files, resource locations are NOT prefixed by {@code \/modules}.\n+         *\/\n+        private Resource newResource(String name, ImageLocation loc) {\n+            assert name.equals(loc.getFullName(true)) : \"Mismatched location for resource: \" + name;\n+            return new Resource(name, loc, imageFileAttributes);\n@@ -563,6 +516,8 @@\n-        Directory makeDirectory(String dir, Directory last) {\n-            Directory nextDir = (Directory) nodes.get(dir);\n-            if (nextDir == null) {\n-                nextDir = newDirectory(last, dir);\n-            }\n-            return nextDir;\n+        \/**\n+         * Creates a new link node pointing at the given target name.\n+         *\n+         * <p>Note that target node is resolved each time {@code resolve()} is called,\n+         * so if a link node is retained after its reader is closed, it will fail.\n+         *\/\n+        private LinkNode newLinkNode(String name, String targetName) {\n+            return new LinkNode(name, () -> findNode(targetName), imageFileAttributes);\n@@ -571,1 +526,3 @@\n-        byte[] getResource(Node node) throws IOException {\n+        \/** Returns the content of a resource node. *\/\n+        private byte[] getResource(Node node) throws IOException {\n+            \/\/ We could have been given a non-resource node here.\n@@ -577,4 +534,0 @@\n-\n-        byte[] getResource(Resource rs) throws IOException {\n-            return super.getResource(rs.getLocation());\n-        }\n@@ -583,3 +536,13 @@\n-    \/\/ jimage file does not store directory structure. We build nodes\n-    \/\/ using the \"path\" strings found in the jimage file.\n-    \/\/ Node can be a directory or a resource\n+    \/**\n+     * A directory, resource or symbolic link.\n+     *\n+     * <h3 id=\"node_equality\">Node Equality<\/h3>\n+     *\n+     * Nodes are identified solely by their name, and it is not valid to attempt\n+     * to compare nodes from different reader instances. Different readers may\n+     * produce nodes with the same names, but different contents.\n+     *\n+     * <p>Furthermore, since a {@link ImageReader} provides \"perfect\" caching of\n+     * nodes, equality of nodes from the same reader is equivalent to instance\n+     * identity.\n+     *\/\n@@ -587,5 +550,0 @@\n-        private static final int ROOT_DIR = 0b0000_0000_0000_0001;\n-        private static final int PACKAGES_DIR = 0b0000_0000_0000_0010;\n-        private static final int MODULES_DIR = 0b0000_0000_0000_0100;\n-\n-        private int flags;\n@@ -594,6 +552,0 @@\n-        private boolean completed;\n-\n-        protected Node(String name, BasicFileAttributes fileAttrs) {\n-            this.name = Objects.requireNonNull(name);\n-            this.fileAttrs = Objects.requireNonNull(fileAttrs);\n-        }\n@@ -602,1 +554,2 @@\n-         * A node is completed when all its direct children have been built.\n+         * Creates an abstract {@code Node}, which is either a resource, directory\n+         * or symbolic link.\n@@ -604,1 +557,2 @@\n-         * @return\n+         * <p>This constructor is only non-private so it can be used by the\n+         * {@code ExplodedImage} class, and must not be used otherwise.\n@@ -606,22 +560,3 @@\n-        public boolean isCompleted() {\n-            return completed;\n-        }\n-\n-        public void setCompleted(boolean completed) {\n-            this.completed = completed;\n-        }\n-\n-        public final void setIsRootDir() {\n-            flags |= ROOT_DIR;\n-        }\n-\n-        public final boolean isRootDir() {\n-            return (flags & ROOT_DIR) != 0;\n-        }\n-\n-        public final void setIsPackagesDir() {\n-            flags |= PACKAGES_DIR;\n-        }\n-\n-        public final boolean isPackagesDir() {\n-            return (flags & PACKAGES_DIR) != 0;\n+        protected Node(String name, BasicFileAttributes fileAttrs) {\n+            this.name = Objects.requireNonNull(name);\n+            this.fileAttrs = Objects.requireNonNull(fileAttrs);\n@@ -630,2 +565,4 @@\n-        public final void setIsModulesDir() {\n-            flags |= MODULES_DIR;\n+        \/\/ A node is completed when all its direct children have been built.\n+        \/\/ As such, non-directory nodes are always complete.\n+        boolean isCompleted() {\n+            return true;\n@@ -634,2 +571,3 @@\n-        public final boolean isModulesDir() {\n-            return (flags & MODULES_DIR) != 0;\n+        \/\/ Only resources can return a location.\n+        ImageLocation getLocation() {\n+            throw new IllegalStateException(\"not a resource: \" + getName());\n@@ -638,0 +576,8 @@\n+        \/**\n+         * Returns the name of this node (e.g. {@code\n+         * \"\/modules\/java.base\/java\/lang\/Object.class\"} or {@code\n+         * \"\/packages\/java.lang\"}).\n+         *\n+         * <p>Note that for resource nodes this is NOT the underlying jimage\n+         * resource name (it is prefixed with {@code \"\/modules\"}).\n+         *\/\n@@ -642,0 +588,4 @@\n+        \/**\n+         * Returns file attributes for this node. The value returned may be the\n+         * same for all nodes, and should not be relied upon for accuracy.\n+         *\/\n@@ -646,1 +596,4 @@\n-        \/\/ resolve this Node (if this is a soft link, get underlying Node)\n+        \/**\n+         * Resolves a symbolic link to its target node. If this code is not a\n+         * symbolic link, then it resolves to itself.\n+         *\/\n@@ -651,0 +604,4 @@\n+        \/**\n+         * Resolves a symbolic link to its target node. If this code is not a\n+         * symbolic link, then it resolves to itself.\n+         *\/\n@@ -655,1 +612,1 @@\n-        \/\/ is this a soft link Node?\n+        \/** Returns whether this node is a symbolic link. *\/\n@@ -660,0 +617,5 @@\n+        \/**\n+         * Returns whether this node is a directory. Directory nodes can have\n+         * {@link #getChildNames()} invoked to get the fully qualified names\n+         * of any child nodes.\n+         *\/\n@@ -664,4 +626,5 @@\n-        public List<Node> getChildren() {\n-            throw new IllegalArgumentException(\"not a directory: \" + getNameString());\n-        }\n-\n+        \/**\n+         * Returns whether this node is a resource. Resource nodes can have\n+         * their contents obtained via {@link ImageReader#getResource(Node)}\n+         * or {@link ImageReader#getResourceBuffer(Node)}.\n+         *\/\n@@ -672,2 +635,8 @@\n-        public ImageLocation getLocation() {\n-            throw new IllegalArgumentException(\"not a resource: \" + getNameString());\n+        \/**\n+         * Returns the fully qualified names of any child nodes for a directory.\n+         *\n+         * <p>By default, this method throws {@link IllegalStateException} and\n+         * is overridden for directories.\n+         *\/\n+        public Stream<String> getChildNames() {\n+            throw new IllegalStateException(\"not a directory: \" + getName());\n@@ -676,0 +645,4 @@\n+        \/**\n+         * Returns the uncompressed size of this node's content. If this node is\n+         * not a resource, this method returns zero.\n+         *\/\n@@ -680,0 +653,4 @@\n+        \/**\n+         * Returns the compressed size of this node's content. If this node is\n+         * not a resource, this method returns zero.\n+         *\/\n@@ -684,0 +661,4 @@\n+        \/**\n+         * Returns the extension string of a resource node. If this node is not\n+         * a resource, this method returns null.\n+         *\/\n@@ -688,20 +669,0 @@\n-        public long contentOffset() {\n-            return 0L;\n-        }\n-\n-        public final FileTime creationTime() {\n-            return fileAttrs.creationTime();\n-        }\n-\n-        public final FileTime lastAccessTime() {\n-            return fileAttrs.lastAccessTime();\n-        }\n-\n-        public final FileTime lastModifiedTime() {\n-            return fileAttrs.lastModifiedTime();\n-        }\n-\n-        public final String getNameString() {\n-            return name;\n-        }\n-\n@@ -710,1 +671,1 @@\n-            return getNameString();\n+            return getName();\n@@ -713,0 +674,1 @@\n+        \/** See <a href=\"#node_equality\">Node Equality<\/a>. *\/\n@@ -718,0 +680,1 @@\n+        \/** See <a href=\"#node_equality\">Node Equality<\/a>. *\/\n@@ -732,3 +695,26 @@\n-    \/\/ directory node - directory has full path name without '\/' at end.\n-    static final class Directory extends Node {\n-        private final List<Node> children;\n+    \/**\n+     * Directory node (referenced from a full path, without a trailing '\/').\n+     *\n+     * <p>Directory nodes have two distinct states:\n+     * <ul>\n+     *     <li>Incomplete: The child list has not been set.\n+     *     <li>Complete: The child list has been set.\n+     * <\/ul>\n+     *\n+     * <p>When a directory node is returned by {@link ImageReader#findNode(String)}\n+     * it is always complete, but this DOES NOT mean that its child nodes are\n+     * complete yet.\n+     *\n+     * <p>To avoid users being able to access incomplete child nodes, the\n+     * {@code Node} API offers only a way to obtain child node names, forcing\n+     * callers to invoke {@code findNode()} if they need to access the child\n+     * node itself.\n+     *\n+     * <p>This approach allows directories to be implemented lazily with respect\n+     * to child nodes, while retaining efficiency when child nodes are accessed\n+     * (since any incomplete nodes will be created and placed in the node cache\n+     * when the parent was first returned to the user).\n+     *\/\n+    private static final class Directory extends Node {\n+        \/\/ Monotonic reference, will be set to the unmodifiable child list exactly once.\n+        private List<Node> children = null;\n@@ -738,1 +724,0 @@\n-            children = new ArrayList<>();\n@@ -741,6 +726,3 @@\n-        static Directory create(Directory parent, String name, BasicFileAttributes fileAttrs) {\n-            Directory d = new Directory(name, fileAttrs);\n-            if (parent != null) {\n-                parent.addChild(d);\n-            }\n-            return d;\n+        @Override\n+        boolean isCompleted() {\n+            return children != null;\n@@ -755,17 +737,3 @@\n-        public List<Node> getChildren() {\n-            return Collections.unmodifiableList(children);\n-        }\n-\n-        void addChild(Node node) {\n-            assert !children.contains(node) : \"Child \" + node + \" already added\";\n-            children.add(node);\n-        }\n-\n-        public void walk(Consumer<? super Node> consumer) {\n-            consumer.accept(this);\n-            for (Node child : children) {\n-                if (child.isDirectory()) {\n-                    ((Directory)child).walk(consumer);\n-                } else {\n-                    consumer.accept(child);\n-                }\n+        public Stream<String> getChildNames() {\n+            if (children != null) {\n+                return children.stream().map(Node::getName);\n@@ -773,6 +741,21 @@\n-        }\n-    }\n-\n-    \/\/ \"resource\" is .class or any other resource (compressed\/uncompressed) in a jimage.\n-    \/\/ full path of the resource is the \"name\" of the resource.\n-    static class Resource extends Node {\n+            throw new IllegalStateException(\"Cannot get child nodes of an incomplete directory: \" + getName());\n+        }\n+\n+        private void setChildren(List<Node> children) {\n+            assert this.children == null : this + \": Cannot set child nodes twice!\";\n+            this.children = Collections.unmodifiableList(children);\n+        }\n+    }\n+    \/**\n+     * Resource node (e.g. a \".class\" entry, or any other data resource).\n+     *\n+     * <p>Resources are leaf nodes referencing an underlying image location. They\n+     * are lightweight, and do not cache their contents.\n+     *\n+     * <p>Unlike directories (where the node name matches the jimage path for the\n+     * corresponding {@code ImageLocation}), resource node names are NOT the same\n+     * as the corresponding jimage path. The difference is that node names for\n+     * resources are prefixed with \"\/modules\", which is missing from the\n+     * equivalent jimage path.\n+     *\/\n+    private static class Resource extends Node {\n@@ -781,2 +764,2 @@\n-        private Resource(ImageLocation loc, BasicFileAttributes fileAttrs) {\n-            super(loc.getFullName(true), fileAttrs);\n+        private Resource(String name, ImageLocation loc, BasicFileAttributes fileAttrs) {\n+            super(name, fileAttrs);\n@@ -786,6 +769,0 @@\n-        static Resource create(Directory parent, ImageLocation loc, BasicFileAttributes fileAttrs) {\n-            Resource rs = new Resource(loc, fileAttrs);\n-            parent.addChild(rs);\n-            return rs;\n-        }\n-\n@@ -793,2 +770,2 @@\n-        public boolean isCompleted() {\n-            return true;\n+        ImageLocation getLocation() {\n+            return loc;\n@@ -802,5 +779,0 @@\n-        @Override\n-        public ImageLocation getLocation() {\n-            return loc;\n-        }\n-\n@@ -821,5 +793,0 @@\n-\n-        @Override\n-        public long contentOffset() {\n-            return loc.getContentOffset();\n-        }\n@@ -828,3 +795,10 @@\n-    \/\/ represents a soft link to another Node\n-    static class LinkNode extends Node {\n-        private final Node link;\n+    \/**\n+     * Link node (a symbolic link to a top-level modules directory).\n+     *\n+     * <p>Link nodes resolve their target by invoking a given supplier, and do\n+     * not cache the result. Since nodes are cached by the {@code ImageReader},\n+     * this means that only the first call to {@link #resolveLink(boolean)}\n+     * could do any significant work.\n+     *\/\n+    private static class LinkNode extends Node {\n+        private final Supplier<Node> link;\n@@ -832,2 +806,2 @@\n-        private LinkNode(String name, Node link) {\n-            super(name, link.getFileAttributes());\n+        private LinkNode(String name, Supplier<Node> link, BasicFileAttributes fileAttrs) {\n+            super(name, fileAttrs);\n@@ -837,11 +811,0 @@\n-        static LinkNode create(Directory parent, String name, Node link) {\n-            LinkNode ln = new LinkNode(name, link);\n-            parent.addChild(ln);\n-            return ln;\n-        }\n-\n-        @Override\n-        public boolean isCompleted() {\n-            return true;\n-        }\n-\n@@ -850,1 +813,3 @@\n-            return (recursive && link instanceof LinkNode) ? ((LinkNode)link).resolveLink(true) : link;\n+            \/\/ No need to use or propagate the recursive flag, since the target\n+            \/\/ cannot possibly be a link node (links only point to directories).\n+            return link.get();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReader.java","additions":482,"deletions":517,"binary":false,"changes":999,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.nio.file.FileSystem;\n@@ -32,1 +31,0 @@\n-import java.nio.file.FileSystems;\n@@ -37,1 +35,0 @@\n-import java.util.Collections;\n@@ -41,0 +38,1 @@\n+import java.util.Objects;\n@@ -59,1 +57,0 @@\n-    private static final int PACKAGES_LEN = PACKAGES.length();\n@@ -61,1 +58,1 @@\n-    private final FileSystem defaultFS;\n+    private final Path modulesDir;\n@@ -63,1 +60,1 @@\n-    private final Map<String, PathNode> nodes = Collections.synchronizedMap(new HashMap<>());\n+    private final Map<String, PathNode> nodes = new HashMap<>();\n@@ -67,2 +64,2 @@\n-        defaultFS = FileSystems.getDefault();\n-        String str = defaultFS.getSeparator();\n+        this.modulesDir = modulesDir;\n+        String str = modulesDir.getFileSystem().getSeparator();\n@@ -82,1 +79,1 @@\n-        PathNode(String name, Path path, BasicFileAttributes attrs) {  \/\/ path\n+        private PathNode(String name, Path path, BasicFileAttributes attrs) {  \/\/ path\n@@ -87,1 +84,1 @@\n-        PathNode(String name, Node link) {              \/\/ link\n+        private PathNode(String name, Node link) {              \/\/ link\n@@ -92,1 +89,1 @@\n-        PathNode(String name, List<Node> children) {    \/\/ dir\n+        private PathNode(String name, List<Node> children) {    \/\/ dir\n@@ -97,0 +94,5 @@\n+        @Override\n+        public boolean isResource() {\n+            return link == null && !getFileAttributes().isDirectory();\n+        }\n+\n@@ -115,1 +117,1 @@\n-        byte[] getContent() throws IOException {\n+        private byte[] getContent() throws IOException {\n@@ -122,1 +124,1 @@\n-        public List<Node> getChildren() {\n+        public Stream<String> getChildNames() {\n@@ -124,1 +126,1 @@\n-                throw new IllegalArgumentException(\"not a directory: \" + getNameString());\n+                throw new IllegalArgumentException(\"not a directory: \" + getName());\n@@ -129,1 +131,1 @@\n-                        p = explodedModulesDir.relativize(p);\n+                        p = modulesDir.relativize(p);\n@@ -141,1 +143,1 @@\n-            return children;\n+            return children.stream().map(Node::getName);\n@@ -155,1 +157,1 @@\n-    public void close() throws IOException {\n+    public synchronized void close() throws IOException {\n@@ -164,1 +166,0 @@\n-    \/\/ find Node for the given Path\n@@ -166,2 +167,2 @@\n-    public synchronized Node findNode(String str) {\n-        Node node = findModulesNode(str);\n+    public synchronized Node findNode(String name) {\n+        PathNode node = nodes.get(name);\n@@ -171,22 +172,6 @@\n-        \/\/ lazily created for paths like \/packages\/<package>\/<module>\/xyz\n-        \/\/ For example \/packages\/java.lang\/java.base\/java\/lang\/\n-        if (str.startsWith(PACKAGES)) {\n-            \/\/ pkgEndIdx marks end of <package> part\n-            int pkgEndIdx = str.indexOf('\/', PACKAGES_LEN);\n-            if (pkgEndIdx != -1) {\n-                \/\/ modEndIdx marks end of <module> part\n-                int modEndIdx = str.indexOf('\/', pkgEndIdx + 1);\n-                if (modEndIdx != -1) {\n-                    \/\/ make sure we have such module link!\n-                    \/\/ ie., \/packages\/<package>\/<module> is valid\n-                    Node linkNode = nodes.get(str.substring(0, modEndIdx));\n-                    if (linkNode == null || !linkNode.isLink()) {\n-                        return null;\n-                    }\n-                    \/\/ map to \"\/modules\/zyz\" path and return that node\n-                    \/\/ For example, \"\/modules\/java.base\/java\/lang\" for\n-                    \/\/ \"\/packages\/java.lang\/java.base\/java\/lang\".\n-                    String mod = MODULES + str.substring(pkgEndIdx + 1);\n-                    return findModulesNode(mod);\n-                }\n-            }\n+        \/\/ If null, this was not the name of \"\/modules\/...\" node, and since all\n+        \/\/ \"\/packages\/...\" nodes were created and cached in advance, the name\n+        \/\/ cannot reference a valid node.\n+        Path path = underlyingModulesPath(name);\n+        if (path == null) {\n+            return null;\n@@ -194,1 +179,2 @@\n-        return null;\n+        \/\/ This can still return null for hidden files.\n+        return createModulesNode(name, path);\n@@ -197,16 +183,23 @@\n-    \/\/ find a Node for a path that starts like \"\/modules\/...\"\n-    Node findModulesNode(String str) {\n-        PathNode node = nodes.get(str);\n-        if (node != null) {\n-            return node;\n-        }\n-        \/\/ lazily created \"\/modules\/xyz\/abc\/\" Node\n-        \/\/ This is mapped to default file system path \"<JDK_MODULES_DIR>\/xyz\/abc\"\n-        Path p = underlyingPath(str);\n-        if (p != null) {\n-            try {\n-                BasicFileAttributes attrs = Files.readAttributes(p, BasicFileAttributes.class);\n-                if (attrs.isRegularFile()) {\n-                    Path f = p.getFileName();\n-                    if (f.toString().startsWith(\"_the.\"))\n-                        return null;\n+    \/**\n+     * Lazily creates and caches a {@code Node} for the given \"\/modules\/...\" name\n+     * and corresponding path to a file or directory.\n+     *\n+     * @param name a resource or directory node name, of the form \"\/modules\/...\".\n+     * @param path the path of a file for a resource or directory.\n+     * @return the newly created and cached node, or {@code null} if the given\n+     *     path references a file which must be hidden in the node hierarchy.\n+     *\/\n+    private Node createModulesNode(String name, Path path) {\n+        assert !nodes.containsKey(name) : \"Node must not already exist: \" + name;\n+        assert isNonEmptyModulesPath(name) : \"Invalid modules name: \" + name;\n+\n+        try {\n+            \/\/ We only know if we're creating a resource of directory when we\n+            \/\/ look up file attributes, and we only do that once. Thus, we can\n+            \/\/ only reject \"marker files\" here, rather than by inspecting the\n+            \/\/ given name string, since it doesn't apply to directories.\n+            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\n+            if (attrs.isRegularFile()) {\n+                Path f = path.getFileName();\n+                if (f.toString().startsWith(\"_the.\")) {\n+                    return null;\n@@ -214,5 +207,2 @@\n-                node = new PathNode(str, p, attrs);\n-                nodes.put(str, node);\n-                return node;\n-            } catch (IOException x) {\n-                \/\/ does not exists or unable to determine\n+            } else if (!attrs.isDirectory()) {\n+                return null;\n@@ -220,0 +210,6 @@\n+            PathNode node = new PathNode(name, path, attrs);\n+            nodes.put(name, node);\n+            return node;\n+        } catch (IOException x) {\n+            \/\/ Since the path reference a file, any errors should not be ignored.\n+            throw new UncheckedIOException(x);\n@@ -221,1 +217,0 @@\n-        return null;\n@@ -224,4 +219,9 @@\n-    Path underlyingPath(String str) {\n-        if (str.startsWith(MODULES)) {\n-            str = frontSlashToNativeSlash(str.substring(\"\/modules\".length()));\n-            return defaultFS.getPath(explodedModulesDir.toString(), str);\n+    \/**\n+     * Returns the expected file path for name in the \"\/modules\/...\" namespace,\n+     * or {@code null} if the name is not in the \"\/modules\/...\" namespace or the\n+     * path does not reference a file.\n+     *\/\n+    private Path underlyingModulesPath(String name) {\n+        if (isNonEmptyModulesPath(name)) {\n+            Path path = modulesDir.resolve(frontSlashToNativeSlash(name.substring(MODULES.length())));\n+            return Files.exists(path) ? path : null;\n@@ -232,0 +232,6 @@\n+    private static boolean isNonEmptyModulesPath(String name) {\n+        \/\/ Don't just check the prefix, there must be something after it too\n+        \/\/ (otherwise you end up with an empty string after trimming).\n+        return name.startsWith(MODULES) && name.length() > MODULES.length();\n+    }\n+\n@@ -252,1 +258,1 @@\n-        try (DirectoryStream<Path> stream = Files.newDirectoryStream(explodedModulesDir)) {\n+        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modulesDir)) {\n@@ -257,1 +263,1 @@\n-                    findModulesNode(MODULES + moduleName);\n+                    Objects.requireNonNull(createModulesNode(MODULES + moduleName, module));\n@@ -264,6 +270,3 @@\n-                                List<String> moduleNames = packageToModules.get(pkgName);\n-                                if (moduleNames == null) {\n-                                    moduleNames = new ArrayList<>();\n-                                    packageToModules.put(pkgName, moduleNames);\n-                                }\n-                                moduleNames.add(moduleName);\n+                                packageToModules\n+                                        .computeIfAbsent(pkgName, k -> new ArrayList<>())\n+                                        .add(moduleName);\n@@ -278,2 +281,2 @@\n-        PathNode modulesDir = new PathNode(\"\/modules\", new ArrayList<>(nodes.values()));\n-        nodes.put(modulesDir.getName(), modulesDir);\n+        PathNode modulesRootNode = new PathNode(\"\/modules\", new ArrayList<>(nodes.values()));\n+        nodes.put(modulesRootNode.getName(), modulesRootNode);\n@@ -288,1 +291,1 @@\n-                Node moduleNode = findModulesNode(MODULES + moduleName);\n+                Node moduleNode = Objects.requireNonNull(nodes.get(MODULES + moduleName));\n@@ -298,2 +301,2 @@\n-        PathNode packagesDir = new PathNode(\"\/packages\", packagesChildren);\n-        nodes.put(packagesDir.getName(), packagesDir);\n+        PathNode packagesRootNode = new PathNode(\"\/packages\", packagesChildren);\n+        nodes.put(packagesRootNode.getName(), packagesRootNode);\n@@ -303,2 +306,2 @@\n-        rootChildren.add(packagesDir);\n-        rootChildren.add(modulesDir);\n+        rootChildren.add(packagesRootNode);\n+        rootChildren.add(modulesRootNode);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/ExplodedImage.java","additions":88,"deletions":85,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        return node.creationTime();\n+        return node.getFileAttributes().creationTime();\n@@ -72,1 +72,1 @@\n-        return node.lastAccessTime();\n+        return node.getFileAttributes().lastAccessTime();\n@@ -77,1 +77,1 @@\n-        return node.lastModifiedTime();\n+        return node.getFileAttributes().lastModifiedTime();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileAttributes.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import java.util.ArrayList;\n@@ -67,1 +66,0 @@\n-import static java.util.stream.Collectors.toList;\n@@ -228,4 +226,3 @@\n-            return node.getChildren()\n-                       .stream()\n-                       .map(child -> (Path)(path.resolve(new JrtPath(this, child.getNameString()).getFileName())))\n-                       .iterator();\n+            return node.getChildNames()\n+                    .map(child -> (Path) (path.resolve(new JrtPath(this, child).getFileName())))\n+                    .iterator();\n@@ -233,8 +230,9 @@\n-        return node.getChildren()\n-                   .stream()\n-                   .map(child -> (Path)(path.resolve(new JrtPath(this, child.getNameString()).getFileName())))\n-                   .filter(p ->  { try { return filter.accept(p);\n-                                   } catch (IOException x) {}\n-                                   return false;\n-                                  })\n-                   .iterator();\n+        return node.getChildNames()\n+                .map(child -> (Path) (path.resolve(new JrtPath(this, child).getFileName())))\n+                .filter(p -> {\n+                    try {\n+                        return filter.accept(p);\n+                    } catch (IOException x) {}\n+                    return false;\n+                })\n+                .iterator();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtFileSystem.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-            image.getRootDirectory();\n@@ -82,1 +81,1 @@\n-    static final String RUNTIME_HOME;\n+    private static final String RUNTIME_HOME;\n@@ -84,1 +83,1 @@\n-    static final Path moduleImageFile;\n+    private static final Path moduleImageFile;\n@@ -86,1 +85,1 @@\n-    static final boolean modulesImageExists;\n+    private static final boolean modulesImageExists;\n@@ -88,1 +87,1 @@\n-    static final Path explodedModulesDir;\n+    private static final Path explodedModulesDir;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-                        return toChars(str, index, f, 0, fd) - start;\n+                        return toChars(str, index, f, 0, fd, true, false) - start;\n@@ -327,0 +327,3 @@\n+             *\n+             * Also,\n+             * d_v = v      iff     4 sp10 = vb\n@@ -333,1 +336,2 @@\n-                return toChars(str, index, upin ? sp10 : tp10, k, fd);\n+                \/* Exactly one of u' or w' lies in Rv *\/\n+                return toChars(str, index, upin ? sp10 : tp10, k, fd, sp10 << 2 == vb, wpin);\n@@ -342,0 +346,3 @@\n+         *\n+         * Also,\n+         * d_v = v      iff     4 s = vb\n@@ -348,1 +355,1 @@\n-            return toChars(str, index, uin ? s : t, k + dk, fd);\n+            return toChars(str, index, uin ? s : t, k + dk, fd, s << 2 == vb, win);\n@@ -355,1 +362,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk, fd);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk, fd, s << 2 == vb, away);\n@@ -374,1 +382,2 @@\n-    private int toChars(byte[] str, int index, long f, int e, FormattedFPDecimal fd) {\n+    private int toChars(byte[] str, int index, long f, int e,\n+                        FormattedFPDecimal fd, boolean exact, boolean away) {\n@@ -386,1 +395,1 @@\n-            fd.set(f, e, len);\n+            fd.set(f, e, len, exact, away);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/DoubleToDecimal.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -307,0 +307,1 @@\n+                \/* Exactly one of u' or w' lies in Rv *\/\n@@ -329,1 +330,2 @@\n-        return toChars(str, index, cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        boolean away = cmp > 0 || cmp == 0 && (s & 0x1) != 0;\n+        return toChars(str, index, away ? t : s, k + dk);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatToDecimal.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,38 +63,0 @@\n-    \/**\n-     * Converts a double precision floating point value to a <code>String<\/code>.\n-     *\n-     * @param d The double precision value.\n-     * @return The value converted to a <code>String<\/code>.\n-     *\/\n-    public static String toJavaFormatString(double d) {\n-        return getBinaryToASCIIConverter(d).toJavaFormatString();\n-    }\n-\n-    \/**\n-     * Converts a single precision floating point value to a <code>String<\/code>.\n-     *\n-     * @param f The single precision value.\n-     * @return The value converted to a <code>String<\/code>.\n-     *\/\n-    public static String toJavaFormatString(float f) {\n-        return getBinaryToASCIIConverter(f).toJavaFormatString();\n-    }\n-\n-    \/**\n-     * Appends a double precision floating point value to an <code>Appendable<\/code>.\n-     * @param d The double precision value.\n-     * @param buf The <code>Appendable<\/code> with the value appended.\n-     *\/\n-    public static void appendTo(double d, Appendable buf) {\n-        getBinaryToASCIIConverter(d).appendTo(buf);\n-    }\n-\n-    \/**\n-     * Appends a single precision floating point value to an <code>Appendable<\/code>.\n-     * @param f The single precision value.\n-     * @param buf The <code>Appendable<\/code> with the value appended.\n-     *\/\n-    public static void appendTo(float f, Appendable buf) {\n-        getBinaryToASCIIConverter(f).appendTo(buf);\n-    }\n-\n@@ -134,1 +96,1 @@\n-    public static double parseDoubleSignlessDigits(int decExp, char[] digits, int length) {\n+    public static double parseDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n@@ -143,11 +105,1 @@\n-        \/**\n-         * Converts a floating point value into an ASCII <code>String<\/code>.\n-         * @return The value converted to a <code>String<\/code>.\n-         *\/\n-        String toJavaFormatString();\n-\n-        \/**\n-         * Appends a floating point value to an <code>Appendable<\/code>.\n-         * @param buf The <code>Appendable<\/code> to receive the value.\n-         *\/\n-        void appendTo(Appendable buf);\n+        int getChars(byte[] result);\n@@ -212,13 +164,4 @@\n-        public String toJavaFormatString() {\n-            return image;\n-        }\n-\n-        @Override\n-        public void appendTo(Appendable buf) {\n-            if (buf instanceof StringBuilder) {\n-                ((StringBuilder) buf).append(image);\n-            } else if (buf instanceof StringBuffer) {\n-                ((StringBuffer) buf).append(image);\n-            } else {\n-                assert false;\n-            }\n+        @SuppressWarnings(\"deprecation\")\n+        public int getChars(byte[] chars) {\n+            image.getBytes(0, image.length(), chars, 0);\n+            return image.length();\n@@ -264,2 +207,2 @@\n-    private static final BinaryToASCIIConverter B2AC_POSITIVE_ZERO = new BinaryToASCIIBuffer(false, new char[]{'0'});\n-    private static final BinaryToASCIIConverter B2AC_NEGATIVE_ZERO = new BinaryToASCIIBuffer(true,  new char[]{'0'});\n+    private static final BinaryToASCIIConverter B2AC_POSITIVE_ZERO = new BinaryToASCIIBuffer(false, new byte[]{'0'});\n+    private static final BinaryToASCIIConverter B2AC_NEGATIVE_ZERO = new BinaryToASCIIBuffer(true,  new byte[]{'0'});\n@@ -275,2 +218,1 @@\n-        private final char[] digits;\n-        private final char[] buffer = new char[26];\n+        private final byte[] digits;\n@@ -296,1 +238,1 @@\n-            this.digits = new char[20];\n+            this.digits = new byte[20];\n@@ -302,1 +244,1 @@\n-        BinaryToASCIIBuffer(boolean isNegative, char[] digits){\n+        BinaryToASCIIBuffer(boolean isNegative, byte[] digits){\n@@ -310,18 +252,0 @@\n-        @Override\n-        public String toJavaFormatString() {\n-            int len = getChars(buffer);\n-            return new String(buffer, 0, len);\n-        }\n-\n-        @Override\n-        public void appendTo(Appendable buf) {\n-            int len = getChars(buffer);\n-            if (buf instanceof StringBuilder) {\n-                ((StringBuilder) buf).append(buffer, 0, len);\n-            } else if (buf instanceof StringBuffer) {\n-                ((StringBuffer) buf).append(buffer, 0, len);\n-            } else {\n-                assert false;\n-            }\n-        }\n-\n@@ -406,1 +330,1 @@\n-                    digits[digitno--] = (char)(c+'0');\n+                    digits[digitno--] = (byte)(c+'0');\n@@ -411,1 +335,1 @@\n-                digits[digitno] = (char)(c+'0');\n+                digits[digitno] = (byte)(c+'0');\n@@ -423,1 +347,1 @@\n-                    digits[digitno--] = (char)(c+'0');\n+                    digits[digitno--] = (byte) (c+'0');\n@@ -428,1 +352,1 @@\n-                digits[digitno] = (char)(c+'0');\n+                digits[digitno] = (byte)(c+'0');\n@@ -629,1 +553,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -657,1 +581,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -683,1 +607,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -711,1 +635,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -744,1 +668,1 @@\n-                    digits[ndigit++] = (char)('0' + q);\n+                    digits[ndigit++] = (byte)('0' + q);\n@@ -761,1 +685,1 @@\n-                    digits[ndigit++] = (char)('0' + q);\n+                    digits[ndigit++] = (byte)('0' + q);\n@@ -815,1 +739,1 @@\n-            digits[i] = (char) (q + 1);\n+            digits[i] = (byte) (q + 1);\n@@ -848,8 +772,0 @@\n-        private static int insignificantDigits(long insignificant) {\n-            int i;\n-            for ( i = 0; insignificant >= 10L; i++ ) {\n-                insignificant \/= 10L;\n-            }\n-            return i;\n-        }\n-\n@@ -858,3 +774,0 @@\n-         * <pre>\n-         * insignificantDigitsForPow2(v) == insignificantDigits(1L<<v)\n-         * <\/pre>\n@@ -916,1 +829,8 @@\n-        private int getChars(char[] result) {\n+        \/**\n+         * Converts the decimal representation of a floating-point number into its\n+         * ASCII character representation and stores it in the provided byte array.\n+         *\n+         * @param result the byte array to store the ASCII representation, must have length at least 26\n+         * @return the number of characters written to the result array\n+         *\/\n+        public int getChars(byte[] result) {\n@@ -930,1 +850,1 @@\n-                    Arrays.fill(result,i,i+charLength,'0');\n+                    Arrays.fill(result, i, i + charLength, (byte) '0');\n@@ -938,1 +858,1 @@\n-                        System.arraycopy(digits, firstDigitIndex+charLength, result, i, t);\n+                        System.arraycopy(digits, firstDigitIndex + charLength, result, i, t);\n@@ -948,1 +868,1 @@\n-                    Arrays.fill(result, i, i-decExponent, '0');\n+                    Arrays.fill(result, i, i-decExponent, (byte) '0');\n@@ -972,1 +892,1 @@\n-                    result[i++] = (char) (e + '0');\n+                    result[i++] = (byte) (e + '0');\n@@ -974,2 +894,2 @@\n-                    result[i++] = (char) (e \/ 10 + '0');\n-                    result[i++] = (char) (e % 10 + '0');\n+                    result[i++] = (byte) (e \/ 10 + '0');\n+                    result[i++] = (byte) (e % 10 + '0');\n@@ -977,1 +897,1 @@\n-                    result[i++] = (char) (e \/ 100 + '0');\n+                    result[i++] = (byte) (e \/ 100 + '0');\n@@ -979,2 +899,2 @@\n-                    result[i++] = (char) (e \/ 10 + '0');\n-                    result[i++] = (char) (e % 10 + '0');\n+                    result[i++] = (byte) (e \/ 10 + '0');\n+                    result[i++] = (byte) (e % 10 + '0');\n@@ -1046,4 +966,4 @@\n-        boolean     isNegative;\n-        int         decExponent;\n-        byte[]      digits;\n-        int         nDigits;\n+        final boolean isNegative;\n+        final int     decExponent;\n+        final byte[]  digits;\n+        int           nDigits;\n@@ -1745,1 +1665,2 @@\n-     * @param d The double precision value to convert.\n+     * @param d      The double precision value to convert.\n+     * @param compat    compatibility with releases < JDK 21\n@@ -1748,2 +1669,4 @@\n-    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n-        return getBinaryToASCIIConverter(d, true);\n+    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean compat) {\n+        return compat\n+                ? getCompatBinaryToASCIIConverter(d, true)\n+                : getBinaryToASCIIConverter(d);\n@@ -1752,7 +1675,26 @@\n-    \/**\n-     * Returns a <code>BinaryToASCIIConverter<\/code> for a <code>double<\/code>.\n-     * The returned object is a <code>ThreadLocal<\/code> variable of this class.\n-     *\n-     * @param d The double precision value to convert.\n-     * @param isCompatibleFormat\n-     * @return The converter.\n+    private static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {\n+        assert Double.isFinite(d);\n+\n+        FormattedFPDecimal dec = FormattedFPDecimal.split(d);\n+        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();\n+\n+        buf.nDigits = dec.getPrecision();\n+        buf.decExponent = dec.getExp() + buf.nDigits;\n+        buf.firstDigitIndex = 0;\n+        buf.exactDecimalConversion = dec.getExact();\n+        buf.decimalDigitsRoundedUp = dec.getAway();\n+\n+        long f = dec.getSignificand();\n+        byte[] digits = buf.digits;\n+        for (int i = buf.nDigits - 1; i >= 0; --i) {\n+            long q = f \/ 10;\n+            digits[i] = (byte) ((f - 10 * q) + '0');\n+            f = q;\n+        }\n+        return buf;\n+    }\n+\n+    \/*\n+     * The old implementation of getBinaryToASCIIConverter().\n+     * Should be removed in the future, along with its dependent methods and\n+     * fields (> 550 lines).\n@@ -1760,1 +1702,1 @@\n-    static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n+    private static BinaryToASCIIConverter getCompatBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {\n@@ -1800,41 +1742,1 @@\n-    private static BinaryToASCIIConverter getBinaryToASCIIConverter(float f) {\n-        int fBits = Float.floatToRawIntBits( f );\n-        boolean isNegative = (fBits&FloatConsts.SIGN_BIT_MASK) != 0;\n-        int fractBits = fBits&FloatConsts.SIGNIF_BIT_MASK;\n-        int binExp = (fBits&FloatConsts.EXP_BIT_MASK) >> SINGLE_EXP_SHIFT;\n-        \/\/ Discover obvious special cases of NaN and Infinity.\n-        if ( binExp == (FloatConsts.EXP_BIT_MASK>>SINGLE_EXP_SHIFT) ) {\n-            if ( fractBits == 0L ){\n-                return isNegative ? B2AC_NEGATIVE_INFINITY : B2AC_POSITIVE_INFINITY;\n-            } else {\n-                return B2AC_NOT_A_NUMBER;\n-            }\n-        }\n-        \/\/ Finish unpacking\n-        \/\/ Normalize denormalized numbers.\n-        \/\/ Insert assumed high-order bit for normalized numbers.\n-        \/\/ Subtract exponent bias.\n-        int  nSignificantBits;\n-        if ( binExp == 0 ){\n-            if ( fractBits == 0 ){\n-                \/\/ not a denorm, just a 0!\n-                return isNegative ? B2AC_NEGATIVE_ZERO : B2AC_POSITIVE_ZERO;\n-            }\n-            int leadingZeros = Integer.numberOfLeadingZeros(fractBits);\n-            int shift = leadingZeros-(31-SINGLE_EXP_SHIFT);\n-            fractBits <<= shift;\n-            binExp = 1 - shift;\n-            nSignificantBits =  32 - leadingZeros; \/\/ recall binExp is  - shift count.\n-        } else {\n-            fractBits |= SINGLE_FRACT_HOB;\n-            nSignificantBits = SINGLE_EXP_SHIFT+1;\n-        }\n-        binExp -= FloatConsts.EXP_BIAS;\n-        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();\n-        buf.setSign(isNegative);\n-        \/\/ call the routine that actually does all the hard work.\n-        buf.dtoa(binExp, ((long)fractBits)<<(EXP_SHIFT-SINGLE_EXP_SHIFT), nSignificantBits, true);\n-        return buf;\n-    }\n-\n-    static ASCIIToBinaryConverter readDoubleSignlessDigits(int decExp, char[] digits, int length) {\n+    static ASCIIToBinaryConverter readDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n@@ -1847,5 +1749,1 @@\n-        byte[] buf = new byte[length];\n-        for (int i = 0; i < length; i++) {\n-            buf[i] = (byte) digits[i];\n-        }\n-        return new ASCIIToBinaryBuffer(false, decExp, buf, length);\n+        return new ASCIIToBinaryBuffer(false, decExp, digits, length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":78,"deletions":180,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -50,1 +50,7 @@\n-    private long f;\n+    \/* Whether the decimal exactly represents the double *\/\n+    private boolean exact;\n+    \/*\n+     * When not exact, whether the magnitude of the decimal is larger than\n+     * the magnitude of the double. Aka \"away from zero\".\n+     *\/\n+    private boolean away;\n@@ -53,0 +59,1 @@\n+    private long f;\n@@ -71,1 +78,1 @@\n-    private static FormattedFPDecimal split(double v) {\n+    static FormattedFPDecimal split(double v) {\n@@ -122,1 +129,1 @@\n-        fd.set(s, eNew, prec);\n+        fd.set(s, eNew, prec, fd.exact, fd.away);\n@@ -135,0 +142,8 @@\n+    public boolean getAway() {\n+        return away;\n+    }\n+\n+    public boolean getExact() {\n+        return exact;\n+    }\n+\n@@ -139,1 +154,1 @@\n-    public void set(long f, int e, int n) {\n+    public void set(long f, int e, int n, boolean exact, boolean away) {\n@@ -144,0 +159,2 @@\n+        this.exact = exact;\n+        this.away = away;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FormattedFPDecimal.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-import java.net.URLConnection;\n@@ -57,1 +56,0 @@\n-import jdk.internal.jimage.ImageLocation;\n@@ -213,1 +211,1 @@\n-     * Parses the module-info.class of all module in the runtime image and\n+     * Parses the {@code module-info.class} of all modules in the runtime image and\n@@ -222,5 +220,0 @@\n-        ImageReader reader = SystemImage.reader();\n-        for (String mn : reader.getModuleNames()) {\n-            ImageLocation loc = reader.findLocation(mn, \"module-info.class\");\n-            ModuleInfo.Attributes attrs\n-                = ModuleInfo.read(reader.getResourceBuffer(loc), null);\n@@ -228,1 +221,2 @@\n-            nameToAttributes.put(mn, attrs);\n+        allModuleAttributes().forEach(attrs -> {\n+            nameToAttributes.put(attrs.descriptor().name(), attrs);\n@@ -235,1 +229,1 @@\n-        }\n+        });\n@@ -256,0 +250,34 @@\n+    \/**\n+     * Parses the {@code module-info.class} of all modules in the runtime image and\n+     * returns a stream of {@link ModuleInfo.Attributes Attributes} for them. The\n+     * returned attributes are in no specific order.\n+     *\/\n+    private static Stream<ModuleInfo.Attributes> allModuleAttributes() {\n+        \/\/ System-wide image reader.\n+        ImageReader reader = SystemImage.reader();\n+        try {\n+            return reader.findNode(\"\/modules\")\n+                    .getChildNames()\n+                    .map(mn -> readModuleAttributes(reader, mn));\n+        } catch (IOException e) {\n+            throw new Error(\"Error reading root \/modules entry\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the module's \"module-info\", returning a holder for its class file\n+     * attributes. Every module is required to have a valid {@code module-info.class}.\n+     *\/\n+    private static ModuleInfo.Attributes readModuleAttributes(ImageReader reader, String moduleName) {\n+        Exception err = null;\n+        try {\n+            ImageReader.Node node = reader.findNode(moduleName + \"\/module-info.class\");\n+            if (node != null && node.isResource()) {\n+                return ModuleInfo.read(reader.getResourceBuffer(node), null);\n+            }\n+        } catch (IOException | UncheckedIOException e) {\n+            err = e;\n+        }\n+        throw new Error(\"Missing or invalid module-info.class for module: \" + moduleName, err);\n+    }\n+\n@@ -385,17 +413,0 @@\n-        \/**\n-         * Returns the ImageLocation for the given resource, {@code null}\n-         * if not found.\n-         *\/\n-        private ImageLocation findImageLocation(String name) throws IOException {\n-            Objects.requireNonNull(name);\n-            if (closed)\n-                throw new IOException(\"ModuleReader is closed\");\n-            ImageReader imageReader = SystemImage.reader();\n-            if (imageReader != null) {\n-                return imageReader.findLocation(module, name);\n-            } else {\n-                \/\/ not an images build\n-                return null;\n-            }\n-        }\n-\n@@ -406,2 +417,2 @@\n-        private boolean containsImageLocation(String name) throws IOException {\n-            Objects.requireNonNull(name);\n+        private boolean containsResource(String resourcePath) throws IOException {\n+            Objects.requireNonNull(resourcePath);\n@@ -412,1 +423,2 @@\n-                return imageReader.verifyLocation(module, name);\n+                ImageReader.Node node = imageReader.findNode(\"\/modules\" + resourcePath);\n+                return node != null && node.isResource();\n@@ -421,2 +433,4 @@\n-            if (containsImageLocation(name)) {\n-                URI u = JNUA.create(\"jrt\", \"\/\" + module + \"\/\" + name);\n+            Objects.requireNonNull(name);\n+            String resourcePath = \"\/\" + module + \"\/\" + name;\n+            if (containsResource(resourcePath)) {\n+                URI u = JNUA.create(\"jrt\", resourcePath);\n@@ -445,0 +459,14 @@\n+        \/**\n+         * Returns the node for the given resource if found. If the name references\n+         * a non-resource node, then {@code null} is returned.\n+         *\/\n+        private ImageReader.Node findResource(ImageReader reader, String name) throws IOException {\n+            Objects.requireNonNull(name);\n+            if (closed) {\n+                throw new IOException(\"ModuleReader is closed\");\n+            }\n+            String nodeName = \"\/modules\/\" + module + \"\/\" + name;\n+            ImageReader.Node node = reader.findNode(nodeName);\n+            return (node != null && node.isResource()) ? node : null;\n+        }\n+\n@@ -447,6 +475,3 @@\n-            ImageLocation location = findImageLocation(name);\n-            if (location != null) {\n-                return Optional.of(SystemImage.reader().getResourceBuffer(location));\n-            } else {\n-                return Optional.empty();\n-            }\n+            ImageReader reader = SystemImage.reader();\n+            return Optional.ofNullable(findResource(reader, name))\n+                    .map(reader::getResourceBuffer);\n@@ -484,1 +509,1 @@\n-        Iterator<ImageReader.Node> iterator;\n+        Iterator<String> iterator;\n@@ -505,2 +530,2 @@\n-                    ImageReader.Node node = iterator.next();\n-                    String name = node.getName();\n+                    String name = iterator.next();\n+                    ImageReader.Node node = SystemImage.reader().findNode(name);\n@@ -508,4 +533,1 @@\n-                        \/\/ build node\n-                        ImageReader.Node dir = SystemImage.reader().findNode(name);\n-                        assert dir.isDirectory();\n-                        stack.push(dir);\n+                        stack.push(node);\n@@ -523,1 +545,1 @@\n-                    iterator = dir.getChildren().iterator();\n+                    iterator = dir.getChildNames().iterator();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":69,"deletions":47,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,3 @@\n-  public int      getSize()                      { return getSize0            (constantPoolOop);        }\n-  public Class<?> getClassAt         (int index) { return getClassAt0         (constantPoolOop, index); }\n-  public Class<?> getClassAtIfLoaded (int index) { return getClassAtIfLoaded0 (constantPoolOop, index); }\n+  public int      getSize()                      { return getSize0            ();        }\n+  public Class<?> getClassAt         (int index) { return getClassAt0         (index); }\n+  public Class<?> getClassAtIfLoaded (int index) { return getClassAtIfLoaded0 (index); }\n@@ -42,1 +42,1 @@\n-      return getClassRefIndexAt0(constantPoolOop, index);\n+      return getClassRefIndexAt0(index);\n@@ -46,4 +46,4 @@\n-  public Member   getMethodAt        (int index) { return getMethodAt0        (constantPoolOop, index); }\n-  public Member   getMethodAtIfLoaded(int index) { return getMethodAtIfLoaded0(constantPoolOop, index); }\n-  public Field    getFieldAt         (int index) { return getFieldAt0         (constantPoolOop, index); }\n-  public Field    getFieldAtIfLoaded (int index) { return getFieldAtIfLoaded0 (constantPoolOop, index); }\n+  public Member   getMethodAt        (int index) { return getMethodAt0        (index); }\n+  public Member   getMethodAtIfLoaded(int index) { return getMethodAtIfLoaded0(index); }\n+  public Field    getFieldAt         (int index) { return getFieldAt0         (index); }\n+  public Field    getFieldAtIfLoaded (int index) { return getFieldAtIfLoaded0 (index); }\n@@ -52,1 +52,1 @@\n-  public String[] getMemberRefInfoAt (int index) { return getMemberRefInfoAt0 (constantPoolOop, index); }\n+  public String[] getMemberRefInfoAt (int index) { return getMemberRefInfoAt0 (index); }\n@@ -55,1 +55,1 @@\n-      return getNameAndTypeRefIndexAt0(constantPoolOop, index);\n+      return getNameAndTypeRefIndexAt0(index);\n@@ -59,1 +59,1 @@\n-      return getNameAndTypeRefInfoAt0(constantPoolOop, index);\n+      return getNameAndTypeRefInfoAt0(index);\n@@ -61,6 +61,6 @@\n-  public int      getIntAt           (int index) { return getIntAt0           (constantPoolOop, index); }\n-  public long     getLongAt          (int index) { return getLongAt0          (constantPoolOop, index); }\n-  public float    getFloatAt         (int index) { return getFloatAt0         (constantPoolOop, index); }\n-  public double   getDoubleAt        (int index) { return getDoubleAt0        (constantPoolOop, index); }\n-  public String   getStringAt        (int index) { return getStringAt0        (constantPoolOop, index); }\n-  public String   getUTF8At          (int index) { return getUTF8At0          (constantPoolOop, index); }\n+  public int      getIntAt           (int index) { return getIntAt0           (index); }\n+  public long     getLongAt          (int index) { return getLongAt0          (index); }\n+  public float    getFloatAt         (int index) { return getFloatAt0         (index); }\n+  public double   getDoubleAt        (int index) { return getDoubleAt0        (index); }\n+  public String   getStringAt        (int index) { return getStringAt0        (index); }\n+  public String   getUTF8At          (int index) { return getUTF8At0          (index); }\n@@ -68,1 +68,1 @@\n-      return Tag.valueOf(getTagAt0(constantPoolOop, index));\n+      return Tag.valueOf(getTagAt0(index));\n@@ -71,1 +71,1 @@\n-  public static enum Tag {\n+  public enum Tag {\n@@ -85,0 +85,1 @@\n+      DYNAMIC(17),\n@@ -86,0 +87,1 @@\n+      \/\/ For index after long\/double and 0\n@@ -114,18 +116,18 @@\n-  private native int      getSize0            (Object constantPoolOop);\n-  private native Class<?> getClassAt0         (Object constantPoolOop, int index);\n-  private native Class<?> getClassAtIfLoaded0 (Object constantPoolOop, int index);\n-  private native int      getClassRefIndexAt0 (Object constantPoolOop, int index);\n-  private native Member   getMethodAt0        (Object constantPoolOop, int index);\n-  private native Member   getMethodAtIfLoaded0(Object constantPoolOop, int index);\n-  private native Field    getFieldAt0         (Object constantPoolOop, int index);\n-  private native Field    getFieldAtIfLoaded0 (Object constantPoolOop, int index);\n-  private native String[] getMemberRefInfoAt0 (Object constantPoolOop, int index);\n-  private native int      getNameAndTypeRefIndexAt0(Object constantPoolOop, int index);\n-  private native String[] getNameAndTypeRefInfoAt0(Object constantPoolOop, int index);\n-  private native int      getIntAt0           (Object constantPoolOop, int index);\n-  private native long     getLongAt0          (Object constantPoolOop, int index);\n-  private native float    getFloatAt0         (Object constantPoolOop, int index);\n-  private native double   getDoubleAt0        (Object constantPoolOop, int index);\n-  private native String   getStringAt0        (Object constantPoolOop, int index);\n-  private native String   getUTF8At0          (Object constantPoolOop, int index);\n-  private native byte     getTagAt0           (Object constantPoolOop, int index);\n+  private native int      getSize0            ();\n+  private native Class<?> getClassAt0         (int index);\n+  private native Class<?> getClassAtIfLoaded0 (int index);\n+  private native int      getClassRefIndexAt0 (int index);\n+  private native Member   getMethodAt0        (int index);\n+  private native Member   getMethodAtIfLoaded0(int index);\n+  private native Field    getFieldAt0         (int index);\n+  private native Field    getFieldAtIfLoaded0 (int index);\n+  private native String[] getMemberRefInfoAt0 (int index);\n+  private native int      getNameAndTypeRefIndexAt0(int index);\n+  private native String[] getNameAndTypeRefInfoAt0(int index);\n+  private native int      getIntAt0           (int index);\n+  private native long     getLongAt0          (int index);\n+  private native float    getFloatAt0         (int index);\n+  private native double   getDoubleAt0        (int index);\n+  private native String   getStringAt0        (int index);\n+  private native String   getUTF8At0          (int index);\n+  private native byte     getTagAt0           (int index);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ConstantPool.java","additions":40,"deletions":38,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -157,8 +157,1 @@\n-        java.desktop, \/\/ for ScopedValue\n-        jdk.compiler,\n-        jdk.incubator.vector, \/\/ participates in preview features\n-        jdk.jartool, \/\/ participates in preview features\n-        jdk.jdeps, \/\/ participates in preview features\n-        jdk.jfr, \/\/ participates in preview features\n-        jdk.jlink,   \/\/ participates in preview features\n-        jdk.jshell; \/\/ participates in preview features\n+        jdk.compiler;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,9 @@\n-            if (t != null)\n-                t = t.arrayType();\n+            if (t != null) {\n+                try {\n+                    t = t.arrayType();\n+                } catch (UnsupportedOperationException ex) {\n+                    \/\/ Bad arrays, such as [V or more than 255 dims\n+                    \/\/ We have a more informative IAE\n+                    return null;\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -302,0 +303,1 @@\n+        Objects.requireNonNull(task, \"task\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousChannelGroupImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,1 +181,5 @@\n-        if (!uninterruptible) end(completed);\n+        if (!uninterruptible) {\n+            end(completed);\n+        } else if (!completed && !isOpen()) {\n+            throw new AsynchronousCloseException();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n@@ -554,1 +554,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n@@ -689,1 +689,1 @@\n-                int n = JLA.uncheckedEncodeASCII(src, sp, dst, dp, len);\n+                int n = JLA.encodeASCII(src, sp, dst, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.util.Preconditions;\n@@ -145,1 +144,13 @@\n-        \/\/ Method possible replaced with a compiler intrinsic.\n+        \/**\n+         * Encodes as many ISO-8859-1 codepoints as possible from the source\n+         * character array into the destination byte array, assuming that\n+         * the encoding is ISO-8859-1 compatible.\n+         *\n+         * @param sa the source character array\n+         * @param sp the index of the source array to start reading from\n+         * @param da the target byte array\n+         * @param dp the index of the target array to start writing to\n+         * @param len the maximum number of characters to be encoded\n+         * @return the total number of characters successfully encoded\n+         * @throws NullPointerException if any of the provided arrays is null\n+         *\/\n@@ -148,1 +159,5 @@\n-            if (len <= 0) {\n+            \/\/ This method should tolerate invalid arguments, matching the lenient behavior of the VM intrinsic.\n+            \/\/ Hence, using operator expressions instead of `Preconditions`, which throw on failure.\n+            if ((sp | dp | len) < 0 ||\n+                    sp >= sa.length ||      \/\/ Implicit null check on `sa`\n+                    dp >= da.length) {      \/\/ Implicit null check on `da`\n@@ -151,2 +166,2 @@\n-            encodeISOArrayCheck(sa, sp, da, dp, len);\n-            return implEncodeISOArray(sa, sp, da, dp, len);\n+            int minLen = Math.min(len, Math.min(sa.length - sp, da.length - dp));\n+            return encodeISOArray0(sa, sp, da, dp, minLen);\n@@ -156,3 +171,1 @@\n-        private static int implEncodeISOArray(char[] sa, int sp,\n-                                              byte[] da, int dp, int len)\n-        {\n+        private static int encodeISOArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n@@ -169,11 +182,0 @@\n-        private static void encodeISOArrayCheck(char[] sa, int sp,\n-                                                byte[] da, int dp, int len) {\n-            Objects.requireNonNull(sa);\n-            Objects.requireNonNull(da);\n-            Preconditions.checkIndex(sp, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp, da.length, Preconditions.AIOOBE_FORMATTER);\n-\n-            Preconditions.checkIndex(sp + len - 1, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp + len - 1, da.length, Preconditions.AIOOBE_FORMATTER);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ISO_8859_1.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-                int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, len);\n+                int n = JLA.encodeASCII(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/US_ASCII.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/UTF_8.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1565,3 +1565,0 @@\n-        if (ids == null) {\n-            throw new Exception(\"Must provide -id when -gencrl\");\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n- * href=\"http:\/\/www.ibm.com\/java\/education\/boundaries\/boundaries.html\">http:\/\/www.ibm.com\/java\/education\/boundaries\/boundaries.html<\/a>.\n+ * href=\"https:\/\/icu-project.org\/docs\/papers\/text_boundary_analysis_in_java\/\">Text Boundary Analysis in Java<\/a> by Richard Gillam.\n","filename":"src\/java.base\/share\/classes\/sun\/text\/RuleBasedBreakIterator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2504,4 +2504,3 @@\n-    soft goal, and the JVM will make its best effort to achieve it. The\n-    specified value doesn't adapt to your heap size. By default, for G1 the\n-    maximum pause time target is 200 milliseconds. The other generational\n-    collectors do not use a pause time goal by default.\n+    soft goal, and the JVM will make its best effort to achieve it. Only G1\n+    and Parallel support a maximum GC pause time target. For G1, the default\n+    maximum pause time target is 200 milliseconds.\n@@ -2886,0 +2885,40 @@\n+`-XX:+UseShenandoahGC`\n+:   Enables the use of the Shenandoah garbage collector. This is a low pause\n+    time, concurrent garbage collector. Its pause times are not proportional to\n+    the size of the heap. Shenandoah garbage collector can work with compressed\n+    pointers. See `-XX:UseCompressedOops` for further information about\n+    compressed pointers.\n+\n+`-XX:ShenandoahGCMode=`*mode*\n+:   Sets the GC mode for Shenandoah GC to use. By default, this option is set\n+    to `satb`. Among other things, this defines which barriers are in use.\n+    Possible mode values include the following:\n+\n+    `satb`\n+    :   Snapshot-at-the-beginning concurrent GC (three pass mark-evac-update).\n+        It is a single generation GC.\n+\n+    `generational`\n+    :   It is also a snapshot-at-the-beginning and concurrent GC, but it is\n+        generational. Please see [JEP 404](https:\/\/openjdk.org\/jeps\/404) and\n+        [JEP 521](https:\/\/openjdk.org\/jeps\/521) for its advantages and risks.\n+\n+`-XX:ShenandoahGCHeuristics=`*heuristics*\n+:   Sets the heuristics for Shenandoah GC to use. By default, this option is\n+    set to `adaptive`. This fine-tunes the GC mode selected, by choosing when\n+    to start the GC, how much to process on each cycle, and what other features\n+    to automatically enable. When `-XX:ShenandoahGCMode` is `generational`, the\n+    only supported option is the default, `adaptive`.\n+\n+    Possible heuristics are the following:\n+\n+    `adaptive`\n+    :   To maintain the given amount of free heap at all times, even during\n+        the GC cycle.\n+\n+    `static`\n+    :   Trigger GC when free heap falls below a specified threshold.\n+\n+    `compact`\n+    :   Run GC more frequently and with deeper targets to free up more memory.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool)\n+(JNIEnv *env, jobject jcpool)\n@@ -32,1 +32,1 @@\n-  return JVM_ConstantPoolGetSize(env, unused, jcpool);\n+  return JVM_ConstantPoolGetSize(env, jcpool);\n@@ -36,1 +36,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -38,1 +38,1 @@\n-  return JVM_ConstantPoolGetClassAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetClassAt(env, jcpool, index);\n@@ -42,1 +42,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -44,1 +44,1 @@\n-  return JVM_ConstantPoolGetClassAtIfLoaded(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetClassAtIfLoaded(env, jcpool, index);\n@@ -48,1 +48,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -50,1 +50,1 @@\n-    return JVM_ConstantPoolGetClassRefIndexAt(env, unused, jcpool, index);\n+    return JVM_ConstantPoolGetClassRefIndexAt(env, jcpool, index);\n@@ -54,1 +54,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -56,1 +56,1 @@\n-  return JVM_ConstantPoolGetMethodAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetMethodAt(env, jcpool, index);\n@@ -60,1 +60,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -62,1 +62,1 @@\n-  return JVM_ConstantPoolGetMethodAtIfLoaded(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetMethodAtIfLoaded(env, jcpool, index);\n@@ -66,1 +66,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -68,1 +68,1 @@\n-  return JVM_ConstantPoolGetFieldAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetFieldAt(env, jcpool, index);\n@@ -72,1 +72,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -74,1 +74,1 @@\n-  return JVM_ConstantPoolGetFieldAtIfLoaded(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetFieldAtIfLoaded(env, jcpool, index);\n@@ -78,1 +78,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -80,1 +80,1 @@\n-  return JVM_ConstantPoolGetMemberRefInfoAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetMemberRefInfoAt(env, jcpool, index);\n@@ -84,1 +84,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -86,1 +86,1 @@\n-    return JVM_ConstantPoolGetNameAndTypeRefIndexAt(env, unused, jcpool, index);\n+    return JVM_ConstantPoolGetNameAndTypeRefIndexAt(env, jcpool, index);\n@@ -90,1 +90,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -92,1 +92,1 @@\n-  return JVM_ConstantPoolGetNameAndTypeRefInfoAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetNameAndTypeRefInfoAt(env, jcpool, index);\n@@ -96,1 +96,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -98,1 +98,1 @@\n-  return JVM_ConstantPoolGetIntAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetIntAt(env, jcpool, index);\n@@ -102,1 +102,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -104,1 +104,1 @@\n-  return JVM_ConstantPoolGetLongAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetLongAt(env, jcpool, index);\n@@ -108,1 +108,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -110,1 +110,1 @@\n-  return JVM_ConstantPoolGetFloatAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetFloatAt(env, jcpool, index);\n@@ -114,1 +114,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -116,1 +116,1 @@\n-  return JVM_ConstantPoolGetDoubleAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetDoubleAt(env, jcpool, index);\n@@ -120,1 +120,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -122,1 +122,1 @@\n-  return JVM_ConstantPoolGetStringAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetStringAt(env, jcpool, index);\n@@ -126,1 +126,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -128,1 +128,1 @@\n-  return JVM_ConstantPoolGetUTF8At(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetUTF8At(env, jcpool, index);\n@@ -132,1 +132,1 @@\n-(JNIEnv *env, jobject unused, jobject jcpool, jint index)\n+(JNIEnv *env, jobject jcpool, jint index)\n@@ -134,1 +134,1 @@\n-  return JVM_ConstantPoolGetTagAt(env, unused, jcpool, index);\n+  return JVM_ConstantPoolGetTagAt(env, jcpool, index);\n","filename":"src\/java.base\/share\/native\/libjava\/ConstantPool.c","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,59 +151,0 @@\n-\/\/ ImageModuleData constructor maps out sub-tables for faster access.\n-ImageModuleData::ImageModuleData(const ImageFileReader* image_file) :\n-        _image_file(image_file),\n-        _endian(image_file->endian()) {\n-}\n-\n-\/\/ Release module data resource.\n-ImageModuleData::~ImageModuleData() {\n-}\n-\n-\n-\/\/ Return the module in which a package resides.    Returns NULL if not found.\n-const char* ImageModuleData::package_to_module(const char* package_name) {\n-    \/\/ replace all '\/' by '.'\n-    char* replaced = new char[(int) strlen(package_name) + 1];\n-    assert(replaced != NULL && \"allocation failed\");\n-    int i;\n-    for (i = 0; package_name[i] != '\\0'; i++) {\n-      replaced[i] = package_name[i] == '\/' ? '.' : package_name[i];\n-    }\n-    replaced[i] = '\\0';\n-\n-    \/\/ build path \/packages\/<package_name>\n-    const char* radical = \"\/packages\/\";\n-    char* path = new char[(int) strlen(radical) + (int) strlen(package_name) + 1];\n-    assert(path != NULL && \"allocation failed\");\n-    strcpy(path, radical);\n-    strcat(path, replaced);\n-    delete[] replaced;\n-\n-    \/\/ retrieve package location\n-    ImageLocation location;\n-    bool found = _image_file->find_location(path, location);\n-    delete[] path;\n-    if (!found) {\n-        return NULL;\n-    }\n-\n-    \/\/ retrieve offsets to module name\n-    int size = (int)location.get_attribute(ImageLocation::ATTRIBUTE_UNCOMPRESSED);\n-    u1* content = new u1[size];\n-    assert(content != NULL && \"allocation failed\");\n-    _image_file->get_resource(location, content);\n-    u1* ptr = content;\n-    \/\/ sequence of sizeof(8) isEmpty|offset. Use the first module that is not empty.\n-    u4 offset = 0;\n-    for (i = 0; i < size; i+=8) {\n-        u4 isEmpty = _endian->get(*((u4*)ptr));\n-        ptr += 4;\n-        if (!isEmpty) {\n-            offset = _endian->get(*((u4*)ptr));\n-            break;\n-        }\n-        ptr += 4;\n-    }\n-    delete[] content;\n-    return _image_file->get_strings().get(offset);\n-}\n-\n@@ -343,2 +284,1 @@\n-ImageFileReader::ImageFileReader(const char* name, bool big_endian) :\n-    _module_data(NULL) {\n+ImageFileReader::ImageFileReader(const char* name, bool big_endian) {\n@@ -365,4 +305,0 @@\n-\n-    if (_module_data != NULL) {\n-        delete _module_data;\n-    }\n@@ -417,5 +353,1 @@\n-\n-    \/\/ Initialize the module data\n-    _module_data = new ImageModuleData(this);\n-    \/\/ Successful open (if memory allocation succeeded).\n-    return _module_data != NULL;\n+    return true;\n@@ -436,5 +368,0 @@\n-\n-    if (_module_data != NULL) {\n-        delete _module_data;\n-        _module_data = NULL;\n-    }\n@@ -570,5 +497,0 @@\n-\n-\/\/ Return the ImageModuleData for this image\n-ImageModuleData * ImageFileReader::get_image_module_data() {\n-    return _module_data;\n-}\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":3,"deletions":81,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,14 +305,0 @@\n-\/\/\n-\/\/ Manage the image module meta data.\n-class ImageModuleData {\n-    const ImageFileReader* _image_file; \/\/ Source image file\n-    Endian* _endian;                    \/\/ Endian handler\n-\n-public:\n-    ImageModuleData(const ImageFileReader* image_file);\n-    ~ImageModuleData();\n-\n-    \/\/ Return the module in which a package resides.    Returns NULL if not found.\n-    const char* package_to_module(const char* package_name);\n-};\n-\n@@ -431,1 +417,0 @@\n-    ImageModuleData *_module_data;       \/\/ The ImageModuleData for this image\n@@ -580,4 +565,0 @@\n-\n-    \/\/ Return the ImageModuleData for this image\n-    ImageModuleData * get_image_module_data();\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,17 +89,0 @@\n-\/*\n- * JImagePackageToModule - Given an open image file (see JImageOpen) and the name\n- * of a package, return the name of module where the package resides. If the\n- * package does not exist in the image file, the function returns NULL.\n- * The resulting string does\/should not have to be released. All strings are\n- * utf-8, zero byte terminated.\n- *\n- * Ex.\n- *  const char* package = (*JImagePackageToModule)(image, \"java\/lang\");\n- *  tty->print_cr(package);\n- *  -> java.base\n- *\/\n-extern \"C\" JNIEXPORT const char*\n-JIMAGE_PackageToModule(JImageFile* image, const char* package_name) {\n-    return ((ImageFileReader*) image)->get_image_module_data()->package_to_module(package_name);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,19 +96,0 @@\n-\/*\n- * JImagePackageToModule - Given an open image file (see JImageOpen) and the name\n- * of a package, return the name of module where the package resides. If the\n- * package does not exist in the image file, the function returns NULL.\n- * The resulting string does\/should not have to be released. All strings are\n- * utf-8, zero byte terminated.\n- *\n- * Ex.\n- *  const char* package = (*JImagePackageToModule)(image, \"java\/lang\");\n- *  tty->print_cr(package);\n- *  -> java.base\n- *\/\n-\n-extern \"C\" JNIEXPORT const char *\n-JIMAGE_PackageToModule(JImageFile* jimage, const char* package_name);\n-\n-typedef const char* (*JImagePackageToModule_t)(JImageFile* jimage, const char* package_name);\n-\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.hpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,3 +95,5 @@\n-        if (errno() == UnixConstants.ELOOP)\n-            return new FileSystemException(file, other, errorString()\n-                + \" or unable to access attributes of symbolic link\");\n+        if (errno() == UnixConstants.ELOOP) {\n+            String msg = file + \": \" + errorString()\n+                 + \" or unable to access attributes of symbolic link\";\n+            return new FileSystemLoopException(msg);\n+        }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixException.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -84,1 +84,2 @@\n-    \/\/ get the UnixFileAttributes for a given file. Returns null if the file does not exist.\n+    \/\/ get the UnixFileAttributes for a given file.\n+    \/\/ Returns null if the file does not exist.\n@@ -86,0 +87,8 @@\n+        return getIfExists(path, true);\n+    }\n+\n+    \/\/ get the UnixFileAttributes for a given file, optionally following links.\n+    \/\/ Returns null if the file does not exist.\n+    static UnixFileAttributes getIfExists(UnixPath path, boolean followLinks)\n+        throws UnixException\n+    {\n@@ -87,2 +96,4 @@\n-        int errno = UnixNativeDispatcher.stat2(path, attrs);\n-        if (errno == 0) {\n+        int flag = (followLinks) ? 0 : UnixConstants.AT_SYMLINK_NOFOLLOW;\n+        int errno = UnixNativeDispatcher.fstatat2(UnixConstants.AT_FDCWD,\n+                                                  path, flag, attrs);\n+        if (errno == 0)\n@@ -90,1 +101,1 @@\n-        } else if (errno == UnixConstants.ENOENT) {\n+        else if (errno == UnixConstants.ENOENT)\n@@ -92,1 +103,1 @@\n-        } else {\n+        else\n@@ -94,1 +105,0 @@\n-        }\n@@ -110,1 +120,1 @@\n-        UnixNativeDispatcher.fstatat(dfd, path.asByteArray(), flag, attrs);\n+        UnixNativeDispatcher.fstatat(dfd, path, flag, attrs);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributes.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import java.util.HashSet;\n@@ -351,0 +352,23 @@\n+    \/\/ find the key of the last accessible link in the chain\n+    private UnixFileKey lastFileKey(UnixPath path) throws UnixException {\n+        var fileKeys = new HashSet<UnixFileKey>();\n+        UnixFileKey lastFileKey = null;\n+        while (path != null) {\n+            UnixFileAttributes attrs = UnixFileAttributes.getIfExists(path, false);\n+            if (attrs == null) {\n+                break;\n+            }\n+            UnixFileKey fileKey = attrs.fileKey();\n+            if (!attrs.isSymbolicLink()) {\n+                break;\n+            }\n+            if (!fileKeys.add(fileKey)) {\n+                throw new UnixException(ELOOP);\n+            }\n+            lastFileKey = fileKey;\n+            byte[] target = readlink(path);\n+            path = new UnixPath(theFileSystem, target);\n+        }\n+        return lastFileKey;\n+    }\n+\n@@ -353,0 +377,1 @@\n+        \/\/ toUnixPath verifies its argument is a non-null UnixPath\n@@ -361,2 +386,1 @@\n-        UnixFileAttributes attrs1;\n-        UnixFileAttributes attrs2;\n+        UnixFileKey key1;\n@@ -364,4 +388,5 @@\n-             attrs1 = UnixFileAttributes.get(file1, true);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file1);\n-            return false;    \/\/ keep compiler happy\n+            UnixFileAttributes attrs = UnixFileAttributes.getIfExists(file1);\n+            key1 = (attrs != null) ? attrs.fileKey() : lastFileKey(file1);\n+        } catch (UnixException e) {\n+            e.rethrowAsIOException(file1);\n+            return false;\n@@ -369,0 +394,5 @@\n+\n+        if (key1 == null)\n+            return false;\n+\n+        UnixFileKey key2;\n@@ -370,4 +400,5 @@\n-            attrs2 = UnixFileAttributes.get(file2, true);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file2);\n-            return false;    \/\/ keep compiler happy\n+            UnixFileAttributes attrs = UnixFileAttributes.getIfExists(file2);\n+            key2 = (attrs != null) ? attrs.fileKey() : lastFileKey(file2);\n+        } catch (UnixException e) {\n+            e.rethrowAsIOException(file2);\n+            return false;\n@@ -375,1 +406,2 @@\n-        return attrs1.isSameFile(attrs2);\n+\n+        return key1.equals(key2);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":44,"deletions":12,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+    private static native int stat0(long pathAddress, UnixFileAttributes attrs);\n@@ -260,0 +261,1 @@\n+    \/\/ Variant of stat() returning errno instead of throwing UnixException\n@@ -266,2 +268,0 @@\n-    private static native int stat0(long pathAddress, UnixFileAttributes attrs);\n-\n@@ -291,1 +291,1 @@\n-    static void fstatat(int dfd, byte[] path, int flag, UnixFileAttributes attrs)\n+    static void fstatat(int dfd, UnixPath path, int flag, UnixFileAttributes attrs)\n@@ -294,2 +294,14 @@\n-        try (NativeBuffer buffer = NativeBuffers.asNativeBuffer(path)) {\n-            fstatat0(dfd, buffer.address(), flag, attrs);\n+        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n+            int errno = fstatat0(dfd, buffer.address(), flag, attrs);\n+            if (errno != 0) {\n+                throw new UnixException(errno);\n+            }\n+        }\n+    }\n+    private static native int fstatat0(int dfd, long pathAddress, int flag,\n+        UnixFileAttributes attrs);\n+\n+    \/\/ Variant of fstatat() returning errno instead of throwing UnixException\n+    static int fstatat2(int dfd, UnixPath path, int flag, UnixFileAttributes attrs) {\n+        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n+            return fstatat0(dfd, buffer.address(), flag, attrs);\n@@ -298,2 +310,0 @@\n-    private static native void fstatat0(int dfd, long pathAddress, int flag,\n-        UnixFileAttributes attrs) throws UnixException;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-            return JLA.uncheckedGetBytesNoRepl(input, Util.jnuEncoding());\n+            return JLA.uncheckedGetBytesOrThrow(input, Util.jnuEncoding());\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -429,0 +429,5 @@\n+    \/\/ Children should be started with default signal disposition for SIGPIPE\n+    if (signal(SIGPIPE, SIG_DFL) == SIG_ERR) {\n+        goto WhyCantJohnnyExec;\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+    CHECKED_MALLOC4(_pointer, _type, _size, {})\n+\n+#define CHECKED_MALLOC4(_pointer, _type, _size, _onFailure) \\\n@@ -65,0 +68,1 @@\n+            do _onFailure while (0); \\\n@@ -998,1 +1002,1 @@\n-         CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);\n+         CHECKED_MALLOC4(currif, netif *, sizeof(netif) + IFNAMESIZE, { free(addrP); });\n@@ -1030,1 +1034,4 @@\n-            CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);\n+            CHECKED_MALLOC4(currif, netif *, sizeof(netif) + IFNAMESIZE, {\n+                free(addrP);\n+                free(parent);\n+            });\n@@ -1042,1 +1049,5 @@\n-        CHECKED_MALLOC3(tmpaddr, netaddr *, sizeof(netaddr) + 2 * addr_size);\n+        CHECKED_MALLOC4(tmpaddr, netaddr *, sizeof(netaddr) + 2 * addr_size, {\n+            free(addrP);\n+            free(parent);\n+            free(currif);\n+        });\n","filename":"src\/java.base\/unix\/native\/libnet\/NetworkInterface.c","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -346,8 +346,0 @@\n-#if defined(_ALLBSD_SOURCE)\n-    my_openat_func = (openat_func*) openat;\n-    my_fstatat_func = (fstatat_func*) fstatat;\n-#else\n-    \/\/ Make sure we link to the 64-bit version of the functions\n-    my_openat_func = (openat_func*) dlsym(RTLD_DEFAULT, \"openat64\");\n-    my_fstatat_func = (fstatat_func*) dlsym(RTLD_DEFAULT, \"fstatat64\");\n-#endif\n@@ -358,0 +350,2 @@\n+    my_openat_func = (openat_func*) dlsym(RTLD_DEFAULT, \"open64at\");\n+    my_fstatat_func = (fstatat_func*) dlsym(RTLD_DEFAULT, \"stat64at\");\n@@ -360,0 +354,2 @@\n+    my_openat_func = (openat_func*) openat;\n+    my_fstatat_func = (fstatat_func*) fstatat;\n@@ -362,0 +358,3 @@\n+    \/\/ Make sure we link to the 64-bit version of the functions\n+    my_openat_func = (openat_func*) dlsym(RTLD_DEFAULT, \"openat64\");\n+    my_fstatat_func = (fstatat_func*) dlsym(RTLD_DEFAULT, \"fstatat64\");\n@@ -745,1 +744,1 @@\n-JNIEXPORT void JNICALL\n+JNIEXPORT jint JNICALL\n@@ -765,0 +764,1 @@\n+            return 0;\n@@ -766,1 +766,1 @@\n-            throwUnixException(env, errno);\n+            return errno;\n@@ -768,2 +768,0 @@\n-        \/\/ statx was available, so return now\n-        return;\n@@ -775,1 +773,1 @@\n-        return;\n+        return ENOTSUP;\n@@ -778,3 +776,1 @@\n-    if (err == -1) {\n-        throwUnixException(env, errno);\n-    } else {\n+    if (err == 0) {\n@@ -782,0 +778,3 @@\n+        return 0;\n+    } else {\n+        return errno;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -437,1 +437,3 @@\n-            x.rethrowAsIOException(file1);\n+            if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                x.lastError() != ERROR_PATH_NOT_FOUND)\n+                x.rethrowAsIOException(file1);\n@@ -439,0 +441,5 @@\n+\n+        \/\/ if file1 does not exist, it cannot equal file2\n+        if (h1 == 0L)\n+            return false;\n+\n@@ -450,1 +457,3 @@\n-                x.rethrowAsIOException(file2);\n+                if (x.lastError() != ERROR_FILE_NOT_FOUND &&\n+                    x.lastError() != ERROR_PATH_NOT_FOUND)\n+                    x.rethrowAsIOException(file2);\n@@ -452,0 +461,5 @@\n+\n+            \/\/ if file2 does not exist, it cannot equal file1, which does\n+            if (h2 == 0L)\n+                return false;\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsFileSystemProvider.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -968,1 +968,0 @@\n- \/\/ int got = 0;\n@@ -972,2 +971,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -977,2 +975,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -984,2 +981,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -989,2 +985,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -994,2 +989,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n","filename":"src\/java.base\/windows\/native\/libjava\/HostLocaleProviderAdapter_md.c","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -235,1 +235,0 @@\n-     \/\/ int onlyMapID;\n@@ -307,1 +306,0 @@\n-     \/\/ onlyMapID = 0;\n@@ -328,1 +326,0 @@\n-             \/\/ onlyMapID = 1;\n","filename":"src\/java.base\/windows\/native\/libjava\/TimeZone_md.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-\/\/ static HINSTANCE lib = NULL;\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/NTLMAuthSequence.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,3 +36,4 @@\n-    private Cache cache = new Cache();\n-    CFont fFont;\n-    int numGlyphs = -1;\n+    private final Cache rawCache = new Cache(true);\n+    private final Cache modCache = new Cache(false);\n+    private final CFont fFont;\n+    private int numGlyphs = -1;\n@@ -104,1 +105,2 @@\n-        int glyph = cache.get(unicode, raw);\n+        Cache cache = raw ? rawCache : modCache;\n+        int glyph = cache.get(unicode);\n@@ -107,4 +109,8 @@\n-        final char[] unicodeArray = new char[] { unicode };\n-        final int[] glyphArray = new int[1];\n-        nativeCharsToGlyphs(fFont.getNativeFontPtr(), 1, unicodeArray, glyphArray);\n-        glyph = glyphArray[0];\n+        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n+            glyph = INVISIBLE_GLYPH_ID;\n+        } else {\n+            final char[] unicodeArray = new char[]{unicode};\n+            final int[] glyphArray = new int[1];\n+            nativeCharsToGlyphs(fFont.getNativeFontPtr(), 1, unicodeArray, glyphArray);\n+            glyph = glyphArray[0];\n+        }\n@@ -134,1 +140,2 @@\n-            cache.get(2, surrogates, glyphs, raw);\n+            Cache cache = raw ? rawCache : modCache;\n+            cache.get(2, surrogates, glyphs);\n@@ -143,1 +150,1 @@\n-        cache.get(count, unicodes, glyphs, false);\n+        modCache.get(count, unicodes, glyphs);\n@@ -167,0 +174,1 @@\n+        private final boolean raw;\n@@ -171,1 +179,2 @@\n-        Cache() {\n+        Cache(boolean raw) {\n+            this.raw = raw;\n@@ -176,5 +185,1 @@\n-        public synchronized int get(final int index, final boolean raw) {\n-            if (isIgnorableWhitespace(index) || (isDefaultIgnorable(index) && !raw)) {\n-                return INVISIBLE_GLYPH_ID;\n-            }\n-\n+        public synchronized int get(final int index) {\n@@ -251,1 +256,1 @@\n-        public synchronized void get(int count, char[] indices, int[] values, boolean raw)\n+        public synchronized void get(int count, char[] indices, int[] values)\n@@ -273,1 +278,1 @@\n-                final int value = get(code, raw);\n+                final int value = get(code);\n@@ -280,0 +285,3 @@\n+                } else if (isIgnorableWhitespace(code) || (isDefaultIgnorable(code) && !raw)) {\n+                    values[i] = INVISIBLE_GLYPH_ID;\n+                    put(code, INVISIBLE_GLYPH_ID);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCharToGlyphMapper.java","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,2 +144,0 @@\n-        System.err.flush();\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,6 +74,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer (for improved performance; no need to call\n-        \/\/ super.finalize() in this case)\n-    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/common\/SubImageInputStream.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -737,0 +737,1 @@\n+        stream.flush();\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/gif\/GIFImageWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -394,0 +394,6 @@\n+    private void verifyImageIndex(int imageIndex) {\n+        if (imageIndex < minIndex) {\n+            throw new IndexOutOfBoundsException(\"imageIndex < \" + minIndex);\n+        }\n+    }\n+\n@@ -500,3 +506,1 @@\n-        if (imageIndex < minIndex) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        verifyImageIndex(imageIndex);\n@@ -845,0 +849,1 @@\n+            verifyImageIndex(imageIndex);\n@@ -859,0 +864,1 @@\n+            verifyImageIndex(imageIndex);\n@@ -889,0 +895,1 @@\n+            verifyImageIndex(imageIndex);\n@@ -907,0 +914,1 @@\n+            verifyImageIndex(imageIndex);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageReader.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -149,7 +149,0 @@\n-\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer (for improved performance; no need to call\n-        \/\/ super.finalize() in this case)\n-    }\n@@ -286,7 +279,0 @@\n-\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer (for improved performance; no need to call\n-        \/\/ super.finalize() in this case)\n-    }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGImageWriter.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2330,0 +2330,1 @@\n+        stream.flush();\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFImageWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.imageio.stream;\n-\n-import java.io.IOException;\n-import javax.imageio.stream.ImageInputStream;\n-\n-\/**\n- * Small class to assist in properly closing an ImageInputStream instance\n- * prior to garbage collection.  The ImageInputStreamImpl class defines a\n- * finalize() method, but in a number of its public subclasses\n- * (e.g. FileImageInputStream) we override the finalize() method to be\n- * empty for performance reasons, and instead rely on the Disposer mechanism\n- * for closing\/disposing resources.  This is fine when one of these classes\n- * is instantiated directly (e.g. new FileImageInputStream()) but in the\n- * unlikely case where a user defines their own subclass of one of those\n- * streams, we need some way to get back to the behavior of\n- * ImageInputStreamImpl, which will call close() as part of finalization.\n- *\n- * Typically an Image{Input,Output}Stream will construct an instance of\n- * StreamFinalizer in its constructor if it detects that it has been\n- * subclassed by the user.  The ImageInputStream instance will hold a\n- * reference to the StreamFinalizer, and the StreamFinalizer will hold a\n- * reference back to the ImageInputStream from which it was created.  When\n- * both are no longer reachable, the StreamFinalizer.finalize() method will\n- * be called, which will take care of closing down the ImageInputStream.\n- *\n- * Clearly this is a bit of a hack, but it will likely only be used in the\n- * rarest of circumstances: when a user has subclassed one of the public\n- * stream classes.  (It should be no worse than the old days when the public\n- * stream classes had non-empty finalize() methods.)\n- *\/\n-public class StreamFinalizer {\n-    private ImageInputStream stream;\n-\n-    public StreamFinalizer(ImageInputStream stream) {\n-        this.stream = stream;\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        try {\n-            stream.close();\n-        } catch (IOException e) {\n-        } finally {\n-            stream = null;\n-            super.finalize();\n-        }\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/stream\/StreamFinalizer.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -72,4 +72,0 @@\n-    private static Color disabledForeground;\n-    private static Color acceleratorSelectionForeground;\n-    private static Color acceleratorForeground;\n-\n@@ -207,1 +203,4 @@\n-                             MenuItemLayoutHelper.LayoutResult lr) {\n+                             MenuItemLayoutHelper.LayoutResult lr,\n+                             Color disabledForeground,\n+                             Color acceleratorSelectionForeground,\n+                             Color acceleratorForeground) {\n@@ -246,12 +245,0 @@\n-    public static void setDisabledForeground(Color disabledFg) {\n-        disabledForeground = disabledFg;\n-    }\n-\n-    public static void setAcceleratorSelectionForeground(Color acceleratorSelectionFg) {\n-        acceleratorForeground = acceleratorSelectionFg;\n-    }\n-\n-    public static void setAcceleratorForeground(Color acceleratorFg) {\n-        acceleratorForeground = acceleratorFg;\n-    }\n-\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/SwingUtilities3.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.BufferedInputStream;\n-import java.io.ByteArrayOutputStream;\n@@ -31,1 +29,0 @@\n-import java.io.FileInputStream;\n@@ -35,1 +32,0 @@\n-import java.net.URL;\n@@ -38,8 +34,0 @@\n-import javax.sound.SoundClip;\n-import javax.sound.midi.InvalidMidiDataException;\n-import javax.sound.midi.MetaEventListener;\n-import javax.sound.midi.MetaMessage;\n-import javax.sound.midi.MidiFileFormat;\n-import javax.sound.midi.MidiSystem;\n-import javax.sound.midi.MidiUnavailableException;\n-import javax.sound.midi.Sequence;\n@@ -47,9 +35,3 @@\n-import javax.sound.sampled.AudioFormat;\n-import javax.sound.sampled.AudioInputStream;\n-import javax.sound.sampled.AudioSystem;\n-import javax.sound.sampled.Clip;\n-import javax.sound.sampled.DataLine;\n-import javax.sound.sampled.LineEvent;\n-import javax.sound.sampled.LineListener;\n-import javax.sound.sampled.SourceDataLine;\n-import javax.sound.sampled.UnsupportedAudioFileException;\n+import javax.sound.SoundClip;\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n@@ -60,2 +42,0 @@\n- * @author Arthur van Hoff, Kara Kytle, Jan Borgersen\n- * @author Florian Bomers\n@@ -63,33 +43,1 @@\n-public final class JavaSoundAudioClip implements MetaEventListener, LineListener {\n-\n-    private long lastPlayCall = 0;\n-    private static final int MINIMUM_PLAY_DELAY = 30;\n-\n-    private byte[] loadedAudio = null;\n-    private int loadedAudioByteLength = 0;\n-    private AudioFormat loadedAudioFormat = null;\n-\n-    private AutoClosingClip clip = null;\n-    private boolean clipLooping = false;\n-    private boolean clipPlaying = false;\n-\n-    private DataPusher datapusher = null;\n-    private boolean daemonThread = false;\n-\n-    private Sequencer sequencer = null;\n-    private Sequence sequence = null;\n-    private boolean sequencerloop = false;\n-    private volatile boolean success;\n-\n-    \/**\n-     * used for determining how many samples is the\n-     * threshold between playing as a Clip and streaming\n-     * from the file.\n-     *\n-     * $$jb: 11.07.99: the engine has a limit of 1M\n-     * samples to play as a Clip, so compare this number\n-     * with the number of samples in the stream.\n-     *\n-     *\/\n-    private static final long CLIP_THRESHOLD = 1048576;\n-    private static final int STREAM_BUFFER_SIZE = 1024;\n+public final class JavaSoundAudioClip {\n@@ -98,6 +46,1 @@\n-        JavaSoundAudioClip clip = new JavaSoundAudioClip();\n-        clip.daemonThread = true; \/\/ used only by javax.sound.SoundClip\n-        try (FileInputStream stream = new FileInputStream(file)) {\n-            clip.init(stream);\n-        }\n-        return clip;\n+        return new JavaSoundAudioClip(file);\n@@ -130,7 +73,1 @@\n-    private void init(InputStream in) throws IOException {\n-        BufferedInputStream bis = new BufferedInputStream(in, STREAM_BUFFER_SIZE);\n-        bis.mark(STREAM_BUFFER_SIZE);\n-        try {\n-            AudioInputStream as = AudioSystem.getAudioInputStream(bis);\n-            \/\/ load the stream data into memory\n-            success = loadAudioData(as);\n+    private JavaSoundAudioClipDelegate delegate;\n@@ -138,17 +75,4 @@\n-            if (success) {\n-                success = false;\n-                if (loadedAudioByteLength < CLIP_THRESHOLD) {\n-                    success = createClip();\n-                }\n-                if (!success) {\n-                    success = createSourceDataLine();\n-                }\n-            }\n-        } catch (UnsupportedAudioFileException e) {\n-            try {\n-                MidiFileFormat mff = MidiSystem.getMidiFileFormat(bis);\n-                success = createSequencer(bis);\n-            } catch (InvalidMidiDataException e1) {\n-                success = false;\n-            }\n-        }\n+    public JavaSoundAudioClip(final File file) throws IOException {\n+        disposerRecord = new AudioClipDisposerRecord();\n+        Disposer.addRecord(this, disposerRecord);\n+        delegate = new JavaSoundAudioClipDelegate(file, disposerRecord);\n@@ -158,1 +82,1 @@\n-        return success;\n+        return delegate.canPlay();\n@@ -162,10 +86,1 @@\n-        if (!canPlay()) {\n-            return false;\n-        } else if (clip != null) {\n-            return clipPlaying;\n-        } else if (datapusher != null) {\n-            return datapusher.isPlaying();\n-        } else if (sequencer != null) {\n-           return sequencer.isRunning();\n-        }\n-        return false;\n+        return delegate.isPlaying();\n@@ -175,4 +90,1 @@\n-        if (!success) {\n-            return;\n-        }\n-        startImpl(false);\n+        delegate.play();\n@@ -182,68 +94,1 @@\n-        if (!success) {\n-            return;\n-        }\n-        startImpl(true);\n-    }\n-\n-    private synchronized void startImpl(boolean loop) {\n-        \/\/ hack for some applications that call the start method very rapidly...\n-        long currentTime = System.currentTimeMillis();\n-        long diff = currentTime - lastPlayCall;\n-        if (diff < MINIMUM_PLAY_DELAY) {\n-            return;\n-        }\n-        lastPlayCall = currentTime;\n-        try {\n-            if (clip != null) {\n-                \/\/ We need to disable autoclosing mechanism otherwise the clip\n-                \/\/ can be closed after \"!clip.isOpen()\" check, because of\n-                \/\/ previous inactivity.\n-                clip.setAutoClosing(false);\n-                try {\n-                    if (!clip.isOpen()) {\n-                        clip.open(loadedAudioFormat, loadedAudio, 0,\n-                                  loadedAudioByteLength);\n-                    } else {\n-                        clip.flush();\n-                        if (loop != clipLooping) {\n-                            \/\/ need to stop in case the looped status changed\n-                            clip.stop();\n-                        }\n-                    }\n-                    clip.setFramePosition(0);\n-                    if (loop) {\n-                        clip.loop(Clip.LOOP_CONTINUOUSLY);\n-                    } else {\n-                        clip.start();\n-                    }\n-                    clipLooping = loop;\n-                } finally {\n-                    clip.setAutoClosing(true);\n-                }\n-            } else if (datapusher != null ) {\n-                datapusher.start(loop);\n-\n-            } else if (sequencer != null) {\n-                sequencerloop = loop;\n-                if (sequencer.isRunning()) {\n-                    sequencer.setMicrosecondPosition(0);\n-                }\n-                if (!sequencer.isOpen()) {\n-                    try {\n-                        sequencer.open();\n-                        sequencer.setSequence(sequence);\n-\n-                    } catch (InvalidMidiDataException | MidiUnavailableException e) {\n-                        if (Printer.err) e.printStackTrace();\n-                    }\n-                }\n-                sequencer.addMetaEventListener(this);\n-                try {\n-                    sequencer.start();\n-                } catch (Exception e) {\n-                    if (Printer.err) e.printStackTrace();\n-                }\n-            }\n-        } catch (Exception e) {\n-            if (Printer.err) e.printStackTrace();\n-        }\n+        delegate.loop();\n@@ -253,63 +98,1 @@\n-        if (!success) {\n-            return;\n-        }\n-        lastPlayCall = 0;\n-\n-        if (clip != null) {\n-            try {\n-                clip.flush();\n-            } catch (Exception e1) {\n-                if (Printer.err) e1.printStackTrace();\n-            }\n-            try {\n-                clip.stop();\n-            } catch (Exception e2) {\n-                if (Printer.err) e2.printStackTrace();\n-            }\n-        } else if (datapusher != null) {\n-            datapusher.stop();\n-        } else if (sequencer != null) {\n-            try {\n-                sequencerloop = false;\n-                sequencer.removeMetaEventListener(this);\n-                sequencer.stop();\n-            } catch (Exception e3) {\n-                if (Printer.err) e3.printStackTrace();\n-            }\n-            try {\n-                sequencer.close();\n-            } catch (Exception e4) {\n-                if (Printer.err) e4.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    \/\/ Event handlers (for debugging)\n-\n-    @Override\n-    public synchronized void update(LineEvent event) {\n-       if (clip != null) {\n-           if (clip == event.getSource()) {\n-               if (event.getType() == LineEvent.Type.START) {\n-                  clipPlaying = true;\n-               } else if ((event.getType() == LineEvent.Type.STOP) ||\n-                          (event.getType() == LineEvent.Type.CLOSE)) {\n-                  clipPlaying = false;\n-               }\n-           }\n-       }\n-    }\n-\n-    \/\/ handle MIDI track end meta events for looping\n-\n-    @Override\n-    public synchronized void meta(MetaMessage message) {\n-        if( message.getType() == 47 ) {\n-            if (sequencerloop){\n-                \/\/notifyAll();\n-                sequencer.setMicrosecondPosition(0);\n-                loop();\n-            } else {\n-                stop();\n-            }\n-        }\n+        delegate.stop();\n@@ -323,26 +106,2 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() {\n-\n-        if (clip != null) {\n-            clip.close();\n-        }\n-\n-        \/\/$$fb 2001-09-26: may improve situation related to bug #4302884\n-        if (datapusher != null) {\n-            datapusher.close();\n-        }\n-\n-        if (sequencer != null) {\n-            sequencer.close();\n-        }\n-    }\n-\n-    \/\/ FILE LOADING METHODS\n-\n-    private boolean loadAudioData(AudioInputStream as)  throws IOException, UnsupportedAudioFileException {\n-        \/\/ first possibly convert this stream to PCM\n-        as = Toolkit.getPCMConvertedAudioInputStream(as);\n-        if (as == null) {\n-            return false;\n-        }\n+    private AudioClipDisposerRecord disposerRecord;\n+    static class AudioClipDisposerRecord implements DisposerRecord {\n@@ -350,22 +109,3 @@\n-        loadedAudioFormat = as.getFormat();\n-        long frameLen = as.getFrameLength();\n-        int frameSize = loadedAudioFormat.getFrameSize();\n-        long byteLen = AudioSystem.NOT_SPECIFIED;\n-        if (frameLen != AudioSystem.NOT_SPECIFIED\n-            && frameLen > 0\n-            && frameSize != AudioSystem.NOT_SPECIFIED\n-            && frameSize > 0) {\n-            byteLen = frameLen * frameSize;\n-        }\n-        if (byteLen != AudioSystem.NOT_SPECIFIED) {\n-            \/\/ if the stream length is known, it can be efficiently loaded into memory\n-            readStream(as, byteLen);\n-        } else {\n-            \/\/ otherwise we use a ByteArrayOutputStream to load it into memory\n-            readStream(as);\n-        }\n-\n-        \/\/ if everything went fine, we have now the audio data in\n-        \/\/ loadedAudio, and the byte length in loadedAudioByteLength\n-        return true;\n-    }\n+        private volatile AutoClosingClip clip;\n+        private volatile DataPusher datapusher;\n+        private volatile Sequencer sequencer;\n@@ -373,7 +113,2 @@\n-    private void readStream(AudioInputStream as, long byteLen) throws IOException {\n-        \/\/ arrays \"only\" max. 2GB\n-        int intLen;\n-        if (byteLen > 2147483647) {\n-            intLen = 2147483647;\n-        } else {\n-            intLen = (int) byteLen;\n+        void setClip(AutoClosingClip clip) {\n+            this.clip = clip;\n@@ -381,2 +116,0 @@\n-        loadedAudio = new byte[intLen];\n-        loadedAudioByteLength = 0;\n@@ -384,8 +117,2 @@\n-        \/\/ this loop may throw an IOException\n-        while (true) {\n-            int bytesRead = as.read(loadedAudio, loadedAudioByteLength, intLen - loadedAudioByteLength);\n-            if (bytesRead <= 0) {\n-                as.close();\n-                break;\n-            }\n-            loadedAudioByteLength += bytesRead;\n+        void setDataPusher(DataPusher datapusher) {\n+            this.datapusher = datapusher;\n@@ -393,1 +120,0 @@\n-    }\n@@ -395,6 +121,2 @@\n-    private void readStream(AudioInputStream as) throws IOException {\n-\n-        DirectBAOS baos = new DirectBAOS();\n-        int totalBytesRead;\n-        try (as) {\n-            totalBytesRead = (int) as.transferTo(baos);\n+        void setSequencer(Sequencer sequencer) {\n+            this.sequencer = sequencer;\n@@ -402,5 +124,0 @@\n-        loadedAudio = baos.getInternalBuffer();\n-        loadedAudioByteLength = totalBytesRead;\n-    }\n-\n-    \/\/ METHODS FOR CREATING THE DEVICE\n@@ -408,13 +125,3 @@\n-    private boolean createClip() {\n-        try {\n-            DataLine.Info info = new DataLine.Info(Clip.class, loadedAudioFormat);\n-            if (!(AudioSystem.isLineSupported(info)) ) {\n-                if (Printer.err) Printer.err(\"Clip not supported: \"+loadedAudioFormat);\n-                \/\/ fail silently\n-                return false;\n-            }\n-            Object line = AudioSystem.getLine(info);\n-            if (!(line instanceof AutoClosingClip)) {\n-                if (Printer.err) Printer.err(\"Clip is not auto closing!\"+clip);\n-                \/\/ fail -> will try with SourceDataLine\n-                return false;\n+        public void dispose() {\n+            if (clip != null) {\n+                clip.close();\n@@ -422,15 +129,0 @@\n-            clip = (AutoClosingClip) line;\n-            clip.setAutoClosing(true);\n-            clip.addLineListener(this);\n-        } catch (Exception e) {\n-            if (Printer.err) e.printStackTrace();\n-            \/\/ fail silently\n-            return false;\n-        }\n-\n-        if (clip==null) {\n-            \/\/ fail silently\n-            return false;\n-        }\n-        return true;\n-    }\n@@ -438,7 +130,2 @@\n-    private boolean createSourceDataLine() {\n-        try {\n-            DataLine.Info info = new DataLine.Info(SourceDataLine.class, loadedAudioFormat);\n-            if (!(AudioSystem.isLineSupported(info)) ) {\n-                if (Printer.err) Printer.err(\"Line not supported: \"+loadedAudioFormat);\n-                \/\/ fail silently\n-                return false;\n+            if (datapusher != null) {\n+                datapusher.close();\n@@ -446,7 +133,0 @@\n-            SourceDataLine source = (SourceDataLine) AudioSystem.getLine(info);\n-            datapusher = new DataPusher(source, loadedAudioFormat, loadedAudio, loadedAudioByteLength, daemonThread);\n-        } catch (Exception e) {\n-            if (Printer.err) e.printStackTrace();\n-            \/\/ fail silently\n-            return false;\n-        }\n@@ -454,23 +134,2 @@\n-        if (datapusher==null) {\n-            \/\/ fail silently\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    private boolean createSequencer(BufferedInputStream in) throws IOException {\n-        \/\/ get the sequencer\n-        try {\n-            sequencer = MidiSystem.getSequencer( );\n-        } catch(MidiUnavailableException me) {\n-            if (Printer.err) me.printStackTrace();\n-            return false;\n-        }\n-        if (sequencer==null) {\n-            return false;\n-        }\n-\n-        try {\n-            sequence = MidiSystem.getSequence(in);\n-            if (sequence == null) {\n-                return false;\n+            if (sequencer != null) {\n+                sequencer.close();\n@@ -478,3 +137,0 @@\n-        } catch (InvalidMidiDataException e) {\n-            if (Printer.err) e.printStackTrace();\n-            return false;\n@@ -482,1 +138,0 @@\n-        return true;\n@@ -484,15 +139,0 @@\n-\n-    \/*\n-     * private inner class representing a ByteArrayOutputStream\n-     * which allows retrieval of the internal array\n-     *\/\n-    private static class DirectBAOS extends ByteArrayOutputStream {\n-        DirectBAOS() {\n-            super();\n-        }\n-\n-        public byte[] getInternalBuffer() {\n-            return buf;\n-        }\n-\n-    } \/\/ class DirectBAOS\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/JavaSoundAudioClip.java","additions":33,"deletions":393,"binary":false,"changes":426,"status":"modified"},{"patch":"@@ -0,0 +1,455 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.media.sound;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import javax.sound.SoundClip;\n+import javax.sound.midi.InvalidMidiDataException;\n+import javax.sound.midi.MetaEventListener;\n+import javax.sound.midi.MetaMessage;\n+import javax.sound.midi.MidiFileFormat;\n+import javax.sound.midi.MidiSystem;\n+import javax.sound.midi.MidiUnavailableException;\n+import javax.sound.midi.Sequence;\n+import javax.sound.midi.Sequencer;\n+import javax.sound.sampled.AudioFormat;\n+import javax.sound.sampled.AudioInputStream;\n+import javax.sound.sampled.AudioSystem;\n+import javax.sound.sampled.Clip;\n+import javax.sound.sampled.DataLine;\n+import javax.sound.sampled.LineEvent;\n+import javax.sound.sampled.LineListener;\n+import javax.sound.sampled.SourceDataLine;\n+import javax.sound.sampled.UnsupportedAudioFileException;\n+import com.sun.media.sound.JavaSoundAudioClip.AudioClipDisposerRecord;\n+\n+\/**\n+ * Java Sound audio clip;\n+ *\n+ *\/\n+public final class JavaSoundAudioClipDelegate implements MetaEventListener, LineListener {\n+\n+    private long lastPlayCall = 0;\n+    private static final int MINIMUM_PLAY_DELAY = 30;\n+\n+    private byte[] loadedAudio = null;\n+    private int loadedAudioByteLength = 0;\n+    private AudioFormat loadedAudioFormat = null;\n+\n+    private AutoClosingClip clip = null;\n+    private boolean clipLooping = false;\n+    private boolean clipPlaying = false;\n+\n+    private DataPusher datapusher = null;\n+\n+    private Sequencer sequencer = null;\n+    private Sequence sequence = null;\n+    private boolean sequencerloop = false;\n+    private volatile boolean success;\n+\n+    \/**\n+     * used for determining how many samples is the\n+     * threshold between playing as a Clip and streaming\n+     * from the file.\n+     *\n+     * $$jb: 11.07.99: the engine has a limit of 1M\n+     * samples to play as a Clip, so compare this number\n+     * with the number of samples in the stream.\n+     *\n+     *\/\n+    private static final long CLIP_THRESHOLD = 1048576;\n+    private static final int STREAM_BUFFER_SIZE = 1024;\n+\n+    private AudioClipDisposerRecord disposerRecord;\n+    JavaSoundAudioClipDelegate(File file, AudioClipDisposerRecord record) throws IOException {\n+       this.disposerRecord = record;\n+        try (FileInputStream stream = new FileInputStream(file)) {\n+            init(stream);\n+        }\n+\n+    }\n+\n+    private void init(InputStream in) throws IOException {\n+        BufferedInputStream bis = new BufferedInputStream(in, STREAM_BUFFER_SIZE);\n+        bis.mark(STREAM_BUFFER_SIZE);\n+        try {\n+            AudioInputStream as = AudioSystem.getAudioInputStream(bis);\n+            \/\/ load the stream data into memory\n+            success = loadAudioData(as);\n+\n+            if (success) {\n+                success = false;\n+                if (loadedAudioByteLength < CLIP_THRESHOLD) {\n+                    success = createClip();\n+                }\n+                if (!success) {\n+                    success = createSourceDataLine();\n+                }\n+            }\n+        } catch (UnsupportedAudioFileException e) {\n+            try {\n+                MidiFileFormat mff = MidiSystem.getMidiFileFormat(bis);\n+                success = createSequencer(bis);\n+            } catch (InvalidMidiDataException e1) {\n+                success = false;\n+            }\n+        }\n+    }\n+\n+    public synchronized boolean canPlay() {\n+        return success;\n+    }\n+\n+    public synchronized boolean isPlaying() {\n+        if (!canPlay()) {\n+            return false;\n+        } else if (clip != null) {\n+            return clipPlaying;\n+        } else if (datapusher != null) {\n+            return datapusher.isPlaying();\n+        } else if (sequencer != null) {\n+           return sequencer.isRunning();\n+        }\n+        return false;\n+    }\n+\n+    public synchronized void play() {\n+        if (!success) {\n+            return;\n+        }\n+        startImpl(false);\n+    }\n+\n+    public synchronized void loop() {\n+        if (!success) {\n+            return;\n+        }\n+        startImpl(true);\n+    }\n+\n+    private synchronized void startImpl(boolean loop) {\n+        \/\/ hack for some applications that call the start method very rapidly...\n+        long currentTime = System.currentTimeMillis();\n+        long diff = currentTime - lastPlayCall;\n+        if (diff < MINIMUM_PLAY_DELAY) {\n+            return;\n+        }\n+        lastPlayCall = currentTime;\n+        try {\n+            if (clip != null) {\n+                \/\/ We need to disable autoclosing mechanism otherwise the clip\n+                \/\/ can be closed after \"!clip.isOpen()\" check, because of\n+                \/\/ previous inactivity.\n+                clip.setAutoClosing(false);\n+                try {\n+                    if (!clip.isOpen()) {\n+                        clip.open(loadedAudioFormat, loadedAudio, 0,\n+                                  loadedAudioByteLength);\n+                    } else {\n+                        clip.flush();\n+                        if (loop != clipLooping) {\n+                            \/\/ need to stop in case the looped status changed\n+                            clip.stop();\n+                        }\n+                    }\n+                    clip.setFramePosition(0);\n+                    if (loop) {\n+                        clip.loop(Clip.LOOP_CONTINUOUSLY);\n+                    } else {\n+                        clip.start();\n+                    }\n+                    clipLooping = loop;\n+                } finally {\n+                    clip.setAutoClosing(true);\n+                }\n+            } else if (datapusher != null ) {\n+                datapusher.start(loop);\n+\n+            } else if (sequencer != null) {\n+                sequencerloop = loop;\n+                if (sequencer.isRunning()) {\n+                    sequencer.setMicrosecondPosition(0);\n+                }\n+                if (!sequencer.isOpen()) {\n+                    try {\n+                        sequencer.open();\n+                        sequencer.setSequence(sequence);\n+\n+                    } catch (InvalidMidiDataException | MidiUnavailableException e) {\n+                        if (Printer.err) e.printStackTrace();\n+                    }\n+                }\n+                sequencer.addMetaEventListener(this);\n+                try {\n+                    sequencer.start();\n+                } catch (Exception e) {\n+                    if (Printer.err) e.printStackTrace();\n+                }\n+            }\n+        } catch (Exception e) {\n+            if (Printer.err) e.printStackTrace();\n+        }\n+    }\n+\n+    public synchronized void stop() {\n+        if (!success) {\n+            return;\n+        }\n+        lastPlayCall = 0;\n+\n+        if (clip != null) {\n+            try {\n+                clip.flush();\n+            } catch (Exception e1) {\n+                if (Printer.err) e1.printStackTrace();\n+            }\n+            try {\n+                clip.stop();\n+            } catch (Exception e2) {\n+                if (Printer.err) e2.printStackTrace();\n+            }\n+        } else if (datapusher != null) {\n+            datapusher.stop();\n+        } else if (sequencer != null) {\n+            try {\n+                sequencerloop = false;\n+                sequencer.removeMetaEventListener(this);\n+                sequencer.stop();\n+            } catch (Exception e3) {\n+                if (Printer.err) e3.printStackTrace();\n+            }\n+            try {\n+                sequencer.close();\n+            } catch (Exception e4) {\n+                if (Printer.err) e4.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    \/\/ Event handlers (for debugging)\n+\n+    @Override\n+    public synchronized void update(LineEvent event) {\n+       if (clip != null) {\n+           if (clip == event.getSource()) {\n+               if (event.getType() == LineEvent.Type.START) {\n+                  clipPlaying = true;\n+               } else if ((event.getType() == LineEvent.Type.STOP) ||\n+                          (event.getType() == LineEvent.Type.CLOSE)) {\n+                  clipPlaying = false;\n+               }\n+           }\n+       }\n+    }\n+\n+    \/\/ handle MIDI track end meta events for looping\n+\n+    @Override\n+    public synchronized void meta(MetaMessage message) {\n+        if( message.getType() == 47 ) {\n+            if (sequencerloop){\n+                \/\/notifyAll();\n+                sequencer.setMicrosecondPosition(0);\n+                loop();\n+            } else {\n+                stop();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getClass().toString();\n+    }\n+\n+    \/\/ FILE LOADING METHODS\n+\n+    private boolean loadAudioData(AudioInputStream as)  throws IOException, UnsupportedAudioFileException {\n+        \/\/ first possibly convert this stream to PCM\n+        as = Toolkit.getPCMConvertedAudioInputStream(as);\n+        if (as == null) {\n+            return false;\n+        }\n+\n+        loadedAudioFormat = as.getFormat();\n+        long frameLen = as.getFrameLength();\n+        int frameSize = loadedAudioFormat.getFrameSize();\n+        long byteLen = AudioSystem.NOT_SPECIFIED;\n+        if (frameLen != AudioSystem.NOT_SPECIFIED\n+            && frameLen > 0\n+            && frameSize != AudioSystem.NOT_SPECIFIED\n+            && frameSize > 0) {\n+            byteLen = frameLen * frameSize;\n+        }\n+        if (byteLen != AudioSystem.NOT_SPECIFIED) {\n+            \/\/ if the stream length is known, it can be efficiently loaded into memory\n+            readStream(as, byteLen);\n+        } else {\n+            \/\/ otherwise we use a ByteArrayOutputStream to load it into memory\n+            readStream(as);\n+        }\n+\n+        \/\/ if everything went fine, we have now the audio data in\n+        \/\/ loadedAudio, and the byte length in loadedAudioByteLength\n+        return true;\n+    }\n+\n+    private void readStream(AudioInputStream as, long byteLen) throws IOException {\n+        \/\/ arrays \"only\" max. 2GB\n+        int intLen;\n+        if (byteLen > 2147483647) {\n+            intLen = 2147483647;\n+        } else {\n+            intLen = (int) byteLen;\n+        }\n+        loadedAudio = new byte[intLen];\n+        loadedAudioByteLength = 0;\n+\n+        \/\/ this loop may throw an IOException\n+        while (true) {\n+            int bytesRead = as.read(loadedAudio, loadedAudioByteLength, intLen - loadedAudioByteLength);\n+            if (bytesRead <= 0) {\n+                as.close();\n+                break;\n+            }\n+            loadedAudioByteLength += bytesRead;\n+        }\n+    }\n+\n+    private void readStream(AudioInputStream as) throws IOException {\n+\n+        DirectBAOS baos = new DirectBAOS();\n+        int totalBytesRead;\n+        try (as) {\n+            totalBytesRead = (int) as.transferTo(baos);\n+        }\n+        loadedAudio = baos.getInternalBuffer();\n+        loadedAudioByteLength = totalBytesRead;\n+    }\n+\n+    \/\/ METHODS FOR CREATING THE DEVICE\n+\n+    private boolean createClip() {\n+        try {\n+            DataLine.Info info = new DataLine.Info(Clip.class, loadedAudioFormat);\n+            if (!(AudioSystem.isLineSupported(info)) ) {\n+                if (Printer.err) Printer.err(\"Clip not supported: \"+loadedAudioFormat);\n+                \/\/ fail silently\n+                return false;\n+            }\n+            Object line = AudioSystem.getLine(info);\n+            if (!(line instanceof AutoClosingClip)) {\n+                if (Printer.err) Printer.err(\"Clip is not auto closing!\"+clip);\n+                \/\/ fail -> will try with SourceDataLine\n+                return false;\n+            }\n+            clip = (AutoClosingClip) line;\n+            disposerRecord.setClip(clip);\n+            clip.setAutoClosing(true);\n+            clip.addLineListener(this);\n+        } catch (Exception e) {\n+            if (Printer.err) e.printStackTrace();\n+            \/\/ fail silently\n+            return false;\n+        }\n+\n+        if (clip==null) {\n+            \/\/ fail silently\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private boolean createSourceDataLine() {\n+        try {\n+            DataLine.Info info = new DataLine.Info(SourceDataLine.class, loadedAudioFormat);\n+            if (!(AudioSystem.isLineSupported(info)) ) {\n+                if (Printer.err) Printer.err(\"Line not supported: \"+loadedAudioFormat);\n+                \/\/ fail silently\n+                return false;\n+            }\n+            SourceDataLine source = (SourceDataLine) AudioSystem.getLine(info);\n+            datapusher = new DataPusher(source, loadedAudioFormat, loadedAudio, loadedAudioByteLength, true);\n+            disposerRecord.setDataPusher(datapusher);\n+        } catch (Exception e) {\n+            if (Printer.err) e.printStackTrace();\n+            \/\/ fail silently\n+            return false;\n+        }\n+\n+        if (datapusher==null) {\n+            \/\/ fail silently\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private boolean createSequencer(BufferedInputStream in) throws IOException {\n+        \/\/ get the sequencer\n+        try {\n+            sequencer = MidiSystem.getSequencer( );\n+            disposerRecord.setSequencer(sequencer);\n+        } catch(MidiUnavailableException me) {\n+            if (Printer.err) me.printStackTrace();\n+            return false;\n+        }\n+        if (sequencer==null) {\n+            return false;\n+        }\n+\n+        try {\n+            sequence = MidiSystem.getSequence(in);\n+            if (sequence == null) {\n+                return false;\n+            }\n+        } catch (InvalidMidiDataException e) {\n+            if (Printer.err) e.printStackTrace();\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    \/*\n+     * private inner class representing a ByteArrayOutputStream\n+     * which allows retrieval of the internal array\n+     *\/\n+    private static class DirectBAOS extends ByteArrayOutputStream {\n+        DirectBAOS() {\n+            super();\n+        }\n+\n+        public byte[] getInternalBuffer() {\n+            return buf;\n+        }\n+\n+    } \/\/ class DirectBAOS\n+}\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/JavaSoundAudioClipDelegate.java","additions":455,"deletions":0,"binary":false,"changes":455,"status":"added"},{"patch":"@@ -54,0 +54,1 @@\n+import sun.java2d.cmm.BuiltinProfileInfo;\n@@ -58,1 +59,0 @@\n-import sun.java2d.cmm.ProfileDeferralInfo;\n@@ -105,4 +105,3 @@\n-     * Stores some information about {@code ICC_Profile} without causing a\n-     * deferred profile to be loaded. Note that we can defer the loading of\n-     * standard profiles only. If this field is null, then {@link #cmmProfile}\n-     * should be used to access profile information.\n+     * Stores information about a built-in profile without triggering profile\n+     * loading. If this field is null, {@link #cmmProfile} should be used to\n+     * access profile data. If not null, the profile is considered immutable.\n@@ -110,9 +109,1 @@\n-    private transient volatile ProfileDeferralInfo deferralInfo;\n-\n-\n-    \/**\n-     * Set to {@code true} for {@code BuiltInProfile}, {@code false} otherwise.\n-     * This flag is used in {@link #setData(int, byte[])} to prevent modifying\n-     * built-in profiles.\n-     *\/\n-    private final transient boolean builtIn;\n+    private transient final BuiltinProfileInfo builtInInfo;\n@@ -127,1 +118,1 @@\n-         * ProfileDeferralInfo is used for built-in profile creation only,\n+         * BuiltinProfileInfo is used for built-in profile creation only,\n@@ -130,1 +121,1 @@\n-        ICC_Profile SRGB = new ICC_ProfileRGB(new ProfileDeferralInfo(\n+        ICC_Profile SRGB = new ICC_ProfileRGB(new BuiltinProfileInfo(\n@@ -133,1 +124,1 @@\n-        ICC_Profile LRGB = new ICC_ProfileRGB(new ProfileDeferralInfo(\n+        ICC_Profile LRGB = new ICC_ProfileRGB(new BuiltinProfileInfo(\n@@ -136,1 +127,1 @@\n-        ICC_Profile XYZ = new ICC_Profile(new ProfileDeferralInfo(\n+        ICC_Profile XYZ = new ICC_Profile(new BuiltinProfileInfo(\n@@ -139,1 +130,1 @@\n-        ICC_Profile PYCC = new ICC_Profile(new ProfileDeferralInfo(\n+        ICC_Profile PYCC = new ICC_Profile(new BuiltinProfileInfo(\n@@ -142,1 +133,1 @@\n-        ICC_Profile GRAY = new ICC_ProfileGray(new ProfileDeferralInfo(\n+        ICC_Profile GRAY = new ICC_ProfileGray(new BuiltinProfileInfo(\n@@ -774,1 +765,1 @@\n-        builtIn = false;\n+        builtInInfo = null;\n@@ -782,1 +773,1 @@\n-     * Note: {@code ProfileDeferralInfo} is used for built-in profile\n+     * Note: {@code BuiltinProfileInfo} is used for built-in profile\n@@ -785,3 +776,2 @@\n-    ICC_Profile(ProfileDeferralInfo pdi) {\n-        deferralInfo = pdi;\n-        builtIn = true;\n+    ICC_Profile(BuiltinProfileInfo bpi) {\n+        builtInInfo = bpi;\n@@ -937,1 +927,1 @@\n-            var is = getStandardProfileInputStream(deferralInfo.filename);\n+            var is = getStandardProfileInputStream(builtInInfo.filename);\n@@ -945,2 +935,0 @@\n-                    \/\/ from now we cannot use the deferred value, drop it\n-                    deferralInfo = null;\n@@ -978,3 +966,2 @@\n-        ProfileDeferralInfo info = deferralInfo;\n-        if (info != null) {\n-            return info.profileClass;\n+        if (builtInInfo != null) {\n+            return builtInInfo.profileClass;\n@@ -1015,3 +1002,2 @@\n-        ProfileDeferralInfo info = deferralInfo;\n-        if (info != null) {\n-            return info.colorSpaceType;\n+        if (builtInInfo != null) {\n+            return builtInInfo.colorSpaceType;\n@@ -1163,2 +1149,2 @@\n-        if (builtIn) {\n-            throw new IllegalArgumentException(\"Built-in profile cannot be modified\");\n+        if (builtInInfo != null) {\n+            throw new IllegalArgumentException(\"Can't modify built-in profile\");\n@@ -1208,3 +1194,2 @@\n-        ProfileDeferralInfo info = deferralInfo;\n-        if (info != null) {\n-            return info.numComponents;\n+        if (builtInInfo != null) {\n+            return builtInInfo.numComponents;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":24,"deletions":39,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.java2d.cmm.BuiltinProfileInfo;\n@@ -41,1 +42,0 @@\n-import sun.java2d.cmm.ProfileDeferralInfo;\n@@ -90,1 +90,1 @@\n-     * {@code ProfileDeferralInfo} object.\n+     * {@code BuiltinProfileInfo} object.\n@@ -92,2 +92,2 @@\n-    ICC_ProfileGray(ProfileDeferralInfo pdi) {\n-        super(pdi);\n+    ICC_ProfileGray(BuiltinProfileInfo bpi) {\n+        super(bpi);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileGray.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.java2d.cmm.BuiltinProfileInfo;\n@@ -41,1 +42,0 @@\n-import sun.java2d.cmm.ProfileDeferralInfo;\n@@ -125,3 +125,1 @@\n-     * {@code ProfileDeferralInfo} object.\n-     *\n-     * @param  pdi\n+     * {@code BuiltinProfileInfo} object.\n@@ -129,2 +127,2 @@\n-    ICC_ProfileRGB(ProfileDeferralInfo pdi) {\n-        super(pdi);\n+    ICC_ProfileRGB(BuiltinProfileInfo bpi) {\n+        super(bpi);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ProfileRGB.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2504,2 +2504,1 @@\n-     * result of calling any other method (other than\n-     * {@code finalize}) subsequent to a call to this method\n+     * result of calling any other method subsequent to a call to this method\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/ImageReader.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2003,2 +2003,1 @@\n-     * result of calling any other method (other than\n-     * {@code finalize}) subsequent to a call to this method\n+     * result of calling any other method subsequent to a call to this method\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/ImageWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import sun.awt.AppContext;\n@@ -108,0 +107,2 @@\n+    private static final IIORegistry registry = new IIORegistry();\n+\n@@ -112,5 +113,1 @@\n-     *\n-     * <p> Each {@code ThreadGroup} will receive its own instance.\n-     *\n-     * @return the default registry for the current\n-     * {@code ThreadGroup}.\n+     * @return the default registry for the Image I\/O API\n@@ -119,8 +116,0 @@\n-        AppContext context = AppContext.getAppContext();\n-        IIORegistry registry =\n-            (IIORegistry)context.get(IIORegistry.class);\n-        if (registry == null) {\n-            \/\/ Create an instance for this AppContext\n-            registry = new IIORegistry();\n-            context.put(IIORegistry.class, registry);\n-        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/IIORegistry.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n- * sees fit, so long as it has the appropriate runtime permission.\n+ * sees fit.\n@@ -286,2 +286,1 @@\n-     * it is deregistered from a category or when the registry is\n-     * finalized.\n+     * it is deregistered from a category.\n@@ -316,2 +315,1 @@\n-     * it is deregistered from a category or when the registry is\n-     * finalized.\n+     * it is deregistered from a category.\n@@ -663,0 +661,6 @@\n+     * <p>\n+     * If an application creates a new {@code ServiceRegistry} instance and registers providers,\n+     * and at some point no longer needs the instance, it should call this method to ensure\n+     * that all providers which are instances of {@link RegisterableService}\n+     * receive a {@link RegisterableService#onDeregistration(ServiceRegistry, Class<?>)} call back,\n+     * before allowing the instance to be garbage collected.\n@@ -670,20 +674,0 @@\n-    \/**\n-     * Finalizes this object prior to garbage collection.  The\n-     * {@code deregisterAll} method is called to deregister all\n-     * currently registered service providers.  This method should not\n-     * be called from application code.\n-     *\n-     * @throws Throwable if an error occurs during superclass\n-     * finalization.\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    public void finalize() throws Throwable {\n-        deregisterAll();\n-        super.finalize();\n-    }\n-\n@@ -824,4 +808,0 @@\n-    @SuppressWarnings(\"removal\")\n-    public synchronized void finalize() {\n-        clear();\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/ServiceRegistry.java","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -61,1 +60,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -112,6 +111,1 @@\n-        if (getClass() == FileCacheImageInputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -261,16 +255,1 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ RandomAccessFile is closed\/deleted prior to garbage collection\n-    }\n-\n-    private static class StreamDisposerRecord implements DisposerRecord {\n+    static class StreamDisposerRecord implements DisposerRecord {\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileCacheImageInputStream.java","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import javax.imageio.stream.FileCacheImageInputStream.StreamDisposerRecord;\n@@ -34,0 +35,2 @@\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n@@ -49,0 +52,3 @@\n+    private final Object disposerReferent = new Object();\n+\n+    private final StreamDisposerRecord disposerRecord;\n@@ -94,0 +100,7 @@\n+        \/\/ If this instance becomes unreachable the disposer will clean up resources\n+        \/\/ used for caching. This can't flush any un-flushed cache.\n+        this.disposerRecord = new StreamDisposerRecord(cacheFile, cache);\n+        Disposer.addRecord(this.disposerReferent, this.disposerRecord);\n+        \/\/ If the VM is exiting and this instance is still reachable,\n+        \/\/ StreamCloser will call close() to flush the cache and clean up resources.\n+        \/\/ However closing the java.io.OutputStream is the application's responsibility.\n@@ -234,1 +247,1 @@\n-        cache.close();\n+        disposerRecord.dispose();\n@@ -236,1 +249,0 @@\n-        cacheFile.delete();\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileCacheImageOutputStream.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -48,1 +47,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -98,6 +97,1 @@\n-        if (getClass() == FileImageInputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -157,15 +151,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ RandomAccessFile is closed prior to garbage collection\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileImageInputStream.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n@@ -47,1 +46,1 @@\n-    private final Object disposerReferent;\n+    private final Object disposerReferent = new Object();\n@@ -90,6 +89,1 @@\n-        if (getClass() == FileImageOutputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n+        Disposer.addRecord(disposerReferent, disposerRecord);\n@@ -165,15 +159,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ RandomAccessFile is closed prior to garbage collection\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/FileImageOutputStream.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -844,25 +844,0 @@\n-\n-    \/**\n-     * Finalizes this object prior to garbage collection.  The\n-     * {@code close} method is called to close any open input\n-     * source.  This method should not be called from application\n-     * code.\n-     *\n-     * @throws Throwable if an error occurs during superclass\n-     * finalization.\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        if (!isClosed) {\n-            try {\n-                close();\n-            } catch (IOException e) {\n-            }\n-        }\n-        super.finalize();\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/ImageInputStreamImpl.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import com.sun.imageio.stream.StreamFinalizer;\n-import sun.java2d.Disposer;\n-import sun.java2d.DisposerRecord;\n@@ -52,6 +49,0 @@\n-    \/** The referent to be registered with the Disposer. *\/\n-    private final Object disposerReferent;\n-\n-    \/** The DisposerRecord that resets the underlying MemoryCache. *\/\n-    private final DisposerRecord disposerRecord;\n-\n@@ -72,8 +63,0 @@\n-\n-        disposerRecord = new StreamDisposerRecord(cache);\n-        if (getClass() == MemoryCacheImageInputStream.class) {\n-            disposerReferent = new Object();\n-            Disposer.addRecord(disposerReferent, disposerRecord);\n-        } else {\n-            disposerReferent = new StreamFinalizer(this);\n-        }\n@@ -174,1 +157,0 @@\n-        disposerRecord.dispose(); \/\/ this resets the MemoryCache\n@@ -176,0 +158,1 @@\n+        cache.reset();\n@@ -178,30 +161,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @deprecated Finalization has been deprecated for removal.  See\n-     * {@link java.lang.Object#finalize} for background information and details\n-     * about migration options.\n-     *\/\n-    @Deprecated(since=\"9\", forRemoval=true)\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        \/\/ Empty finalizer: for performance reasons we instead use the\n-        \/\/ Disposer mechanism for ensuring that the underlying\n-        \/\/ MemoryCache is reset prior to garbage collection\n-    }\n-\n-    private static class StreamDisposerRecord implements DisposerRecord {\n-        private MemoryCache cache;\n-\n-        public StreamDisposerRecord(MemoryCache cache) {\n-            this.cache = cache;\n-        }\n-\n-        public synchronized void dispose() {\n-            if (cache != null) {\n-                cache.reset();\n-                cache = null;\n-            }\n-        }\n-    }\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/MemoryCacheImageInputStream.java","additions":1,"deletions":48,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -47,1 +47,25 @@\n- *\n+ * <p>\n+ * An {@code ImageInputStream} or {@code ImageOutputStream} may internally allocate\n+ * system resources, such as a temporary cache file.\n+ * Clients are encouraged to use a try-with-resources statement to ensure the\n+ * {@link ImageInputStream#close()} or {@link ImageOutputStream#close()}\n+ * method is called which can promptly free those native resources.\n+ * Otherwise there is the possibility they will leak and eventually cause the\n+ * application to fail as well the possibility that not all data is flushed\n+ * to the underlying output stream. A logical consequence of that is that\n+ * this should be done before closing the destination {@link java.io.OutputStream}.\n+ * A simple pattern would be\n+ * {@snippet lang='java':\n+ * try (FileOutputStream fos = new FileOutputStream(\"out.jpg\");\n+ *      ImageOutputStream ios = new FileCacheImageOutputStream(fos, null)) {\n+ *     ImageIO.write(img, \"jpg\", ios);\n+ * } catch (IOException e) {\n+ * } \/\/ implicit finally block closes the streams in the reverse order to opening\n+ * }\n+ * <p>\n+ * Sub-classers of these Image I\/O API stream types can, to a limited extent, protect\n+ * the application from the consequences of failures to close by adopting mechanisms\n+ * such as {@link java.lang.ref.Cleaner} to free internal resources when it\n+ * is no longer reachable. This is only necessary if there are any resources to release.\n+ * However applications cannot rely on this, either for resource management, or\n+ * for program correctness.\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/stream\/package-info.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,8 @@\n+ * If the image source parameter to a constructor or method is non-null,\n+ * but does not reference valid accessible image data,\n+ * no exceptions will be thrown but no image will be rendered\n+ * even though {@link #getImage()} will return a non-null value,\n+ * as the image will have no dimensions\n+ * and {@link #getImageLoadStatus()} will report {@code MediaTracker.ERRORED}.\n+ *\n+ * <p>\n@@ -181,0 +189,1 @@\n+     * @throws NullPointerException if {@code location} is {@code null}\n@@ -200,0 +209,1 @@\n+     * @throws NullPointerException if {@code location} is {@code null}\n@@ -210,0 +220,1 @@\n+     * @throws NullPointerException if {@code image} is {@code null}\n@@ -212,1 +223,1 @@\n-        this(image);\n+        this.image = image;\n@@ -214,0 +225,2 @@\n+\n+        loadImage(image);\n@@ -221,0 +234,1 @@\n+     * @throws NullPointerException if {@code image} is {@code null}\n@@ -225,6 +239,11 @@\n-        this.image = image;\n-        Object o = image.getProperty(\"comment\", imageObserver);\n-        if (o instanceof String) {\n-            description = (String) o;\n-        }\n-        loadImage(image);\n+        this(image, getImageComment(image));\n+    }\n+\n+    \/**\n+     * @return the {@code \"comment\"} property of the image\n+     *         if the value of the property is a sting}\n+     * @param image the image to get the {@code \"comment\"} property\n+     *\/\n+    private static String getImageComment(Image image) {\n+        Object o = image.getProperty(\"comment\", null);\n+        return (o instanceof String) ? (String) o : null;\n@@ -244,0 +263,1 @@\n+     * @throws NullPointerException if {@code imageData} is {@code null}\n@@ -267,0 +287,1 @@\n+     * @throws NullPointerException if {@code imageData} is {@code null}\n@@ -371,0 +392,1 @@\n+     * @throws NullPointerException if {@code image} is {@code null}\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ImageIcon.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1167,1 +1167,1 @@\n-            = \"The color used to draw the grid lines.\")\n+            = \"Whether grid lines are drawn around the cells.\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -719,5 +719,4 @@\n-        SwingUtilities3.setDisabledForeground(disabledForeground);\n-        SwingUtilities3.setAcceleratorSelectionForeground(\n-                        acceleratorSelectionForeground);\n-        SwingUtilities3.setAcceleratorForeground(acceleratorForeground);\n-        SwingUtilities3.paintAccText(g, lh, lr);\n+        SwingUtilities3.paintAccText(g, lh, lr,\n+                                     disabledForeground,\n+                                     acceleratorSelectionForeground,\n+                                     acceleratorForeground);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicMenuItemUI.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-\/* remember that the API requires a Font use a\n+\/* Remember that the API requires a Font use a\n@@ -39,1 +39,1 @@\n- * to 216*256*4 bytes of storage per composite font. If an app\n+ * to 2*216*256*4 bytes of storage per composite font. If an app\n@@ -41,1 +41,1 @@\n- * over 1Mb of cached data. May need to employ WeakReferences if\n+ * over 2Mb of cached data. May need to employ WeakReferences if\n@@ -57,4 +57,5 @@\n-    CompositeFont font;\n-    CharToGlyphMapper[] slotMappers;\n-    int[][] glyphMaps;\n-    private boolean hasExcludes;\n+    private final CompositeFont font;\n+    private final CharToGlyphMapper[] slotMappers;\n+    private final int[][] glyphMapsRaw;\n+    private final int[][] glyphMapsMod;\n+    private final boolean hasExcludes;\n@@ -64,1 +65,6 @@\n-        initMapper();\n+        glyphMapsRaw = new int[NBLOCKS][];\n+        glyphMapsMod = new int[NBLOCKS][];\n+        slotMappers = new CharToGlyphMapper[font.numSlots];\n+        \/* This requires that slot 0 is never empty. *\/\n+        missingGlyph = font.getSlotFont(0).getMissingGlyphCode();\n+        missingGlyph = compositeGlyphCode(0, missingGlyph);\n@@ -76,13 +82,1 @@\n-    private void initMapper() {\n-        if (missingGlyph == CharToGlyphMapper.UNINITIALIZED_GLYPH) {\n-            if (glyphMaps == null) {\n-                glyphMaps = new int[NBLOCKS][];\n-            }\n-            slotMappers = new CharToGlyphMapper[font.numSlots];\n-            \/* This requires that slot 0 is never empty. *\/\n-            missingGlyph = font.getSlotFont(0).getMissingGlyphCode();\n-            missingGlyph = compositeGlyphCode(0, missingGlyph);\n-        }\n-    }\n-\n-    private int getCachedGlyphCode(int unicode) {\n+    private int getCachedGlyphCode(int unicode, boolean raw) {\n@@ -93,0 +87,1 @@\n+        int[][] glyphMaps = raw ? glyphMapsRaw : glyphMapsMod;\n@@ -99,1 +94,1 @@\n-    private void setCachedGlyphCode(int unicode, int glyphCode) {\n+    private void setCachedGlyphCode(int unicode, int glyphCode, boolean raw) {\n@@ -104,0 +99,1 @@\n+        int[][] glyphMaps = raw ? glyphMapsRaw : glyphMapsMod;\n@@ -123,4 +119,1 @@\n-        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n-            return INVISIBLE_GLYPH_ID;\n-        }\n-        int glyphCode = getCachedGlyphCode(unicode);\n+        int glyphCode = getCachedGlyphCode(unicode, raw);\n@@ -130,0 +123,5 @@\n+        if (isIgnorableWhitespace(unicode) || (isDefaultIgnorable(unicode) && !raw)) {\n+            glyphCode = INVISIBLE_GLYPH_ID;\n+            setCachedGlyphCode(unicode, glyphCode, raw);\n+            return glyphCode;\n+        }\n@@ -136,1 +134,1 @@\n-                    setCachedGlyphCode(unicode, glyphCode);\n+                    setCachedGlyphCode(unicode, glyphCode, raw);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeGlyphMapper.java","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.cmm;\n+\n+\/**\n+ * Stores information about a built-in profile used by\n+ * ICC_Profile.getInstance(int cspace) to defer the loading of profile data and\n+ * CMM initialization. Since built-in profiles are immutable, this information\n+ * is always valid.\n+ *\/\n+public final class BuiltinProfileInfo {\n+\n+    \/**\n+     * Used by ICC_ColorSpace without triggering built-in profile loading.\n+     *\/\n+    public final int colorSpaceType, numComponents, profileClass;\n+\n+    \/**\n+     * The profile file name, such as \"CIEXYZ.pf\", \"sRGB.pf\", etc.\n+     *\/\n+    public final String filename;\n+\n+    public BuiltinProfileInfo(String fn, int type, int ncomp, int pclass) {\n+        filename = fn;\n+        colorSpaceType = type;\n+        numComponents = ncomp;\n+        profileClass = pclass;\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/BuiltinProfileInfo.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.cmm;\n-\n-\/**\n- * A class to pass information about a profile to be loaded from a file to the\n- * static getInstance(int cspace) method of ICC_Profile. Loading of the profile\n- * data and initialization of the CMM is to be deferred as long as possible.\n- *\/\n-public final class ProfileDeferralInfo {\n-\n-    \/**\n-     * Need to have this info for ICC_ColorSpace without causing a deferred\n-     * profile to be loaded.\n-     *\/\n-    public final int colorSpaceType, numComponents, profileClass;\n-\n-    \/**\n-     * The profile file name, such as \"CIEXYZ.pf\", \"sRGB.pf\", etc.\n-     *\/\n-    public final String filename;\n-\n-    public ProfileDeferralInfo(String fn, int type, int ncomp, int pclass) {\n-        filename = fn;\n-        colorSpaceType = type;\n-        numComponents = ncomp;\n-        profileClass = pclass;\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/ProfileDeferralInfo.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,3 @@\n-        switch (image.getType()) {\n+        Raster raster = image.getRaster();\n+        int type = image.getType();\n+        switch (type) {\n@@ -167,1 +169,1 @@\n-                    return createImageLayout(image.getRaster(), cm);\n+                    return createImageLayout(raster, cm);\n@@ -175,1 +177,1 @@\n-        switch (image.getType()) {\n+        switch (type) {\n@@ -179,1 +181,3 @@\n-                var intRaster = (IntegerComponentRaster) image.getRaster();\n+                if (!(raster instanceof IntegerComponentRaster intRaster)) {\n+                    return null;\n+                }\n@@ -191,1 +195,3 @@\n-                var byteRaster = (ByteComponentRaster) image.getRaster();\n+                if (!(raster instanceof ByteComponentRaster byteRaster)) {\n+                    return null;\n+                }\n@@ -201,1 +207,3 @@\n-                var shortRaster = (ShortComponentRaster) image.getRaster();\n+                if (!(raster instanceof ShortComponentRaster shortRaster)) {\n+                    return null;\n+                }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSImageLayout.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-            profiles[i].getNumComponents(); \/\/ force header initialization\n+            profiles[i].getMajorVersion(); \/\/ force header initialization\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,5 +103,5 @@\n-    private Reference<AccelSurface> validSrcDataRef = new WeakReference<>(null);\n-    private Reference<AccelSurface> validDstDataRef = new WeakReference<>(null);\n-    private Reference<Region> validClipRef = new WeakReference<>(null);\n-    private Reference<Composite> validCompRef = new WeakReference<>(null);\n-    private Reference<Paint> validPaintRef = new WeakReference<>(null);\n+    private Reference<AccelSurface> validSrcDataRef = null;\n+    private Reference<AccelSurface> validDstDataRef = null;\n+    private Reference<Region> validClipRef = null;\n+    private Reference<Composite> validCompRef = null;\n+    private Reference<Paint> validPaintRef = null;\n@@ -216,1 +216,1 @@\n-        } else if (validPaintRef.get() != paint) {\n+        } else if (stateChanged(validPaintRef, paint)) {\n@@ -223,5 +223,3 @@\n-        final AccelSurface validatedSrcData = validSrcDataRef.get();\n-        final AccelSurface validatedDstData = validDstDataRef.get();\n-        if ((currentContext != this) ||\n-            (srcData != validatedSrcData) ||\n-            (dstData != validatedDstData))\n+        final boolean srcChanged = stateChanged(validSrcDataRef, srcData);\n+        final boolean dstChanged = stateChanged(validDstDataRef, dstData);\n+        if ((currentContext != this) || srcChanged || dstChanged)\n@@ -229,1 +227,1 @@\n-            if (dstData != validatedDstData) {\n+            if (dstChanged) {\n@@ -246,2 +244,2 @@\n-            validSrcDataRef = new WeakReference<>(srcData);\n-            validDstDataRef = new WeakReference<>(dstData);\n+            validSrcDataRef = wrapState(srcData);\n+            validDstDataRef = wrapState(dstData);\n@@ -251,2 +249,2 @@\n-        final Region validatedClip = validClipRef.get();\n-        if ((clip != validatedClip) || updateClip) {\n+        final Region validatedClip = validClipRef == null ? null : validClipRef.get();\n+        if (stateChanged(validClipRef, clip) || updateClip) {\n@@ -267,1 +265,1 @@\n-            validClipRef = new WeakReference<>(clip);\n+            validClipRef = wrapState(clip);\n@@ -273,1 +271,1 @@\n-        if ((comp != validCompRef.get()) || (flags != validatedFlags)) {\n+        if (stateChanged(validCompRef, comp) || (flags != validatedFlags)) {\n@@ -282,1 +280,1 @@\n-            validCompRef = new WeakReference<>(comp);\n+            validCompRef = wrapState(comp);\n@@ -316,1 +314,1 @@\n-            validPaintRef = new WeakReference<>(paint);\n+            validPaintRef = wrapState(paint);\n@@ -324,0 +322,12 @@\n+    private static <T> boolean stateChanged(Reference<T> ref, T obj) {\n+        \/\/ null ref means \"true\" null object\n+        if (ref == null) return obj != null;\n+        T old = ref.get();\n+        \/\/ null ref value means the object was GC'ed, return true in that case\n+        return old == null || old != obj;\n+    }\n+\n+    private static <T> Reference<T> wrapState(T obj) {\n+        return obj == null ? null : new WeakReference<>(obj);\n+    }\n+\n@@ -437,5 +447,5 @@\n-        validSrcDataRef.clear();\n-        validDstDataRef.clear();\n-        validCompRef.clear();\n-        validClipRef.clear();\n-        validPaintRef.clear();\n+        validSrcDataRef = null;\n+        validDstDataRef = null;\n+        validCompRef = null;\n+        validClipRef = null;\n+        validPaintRef = null;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/BufferedContext.java","additions":35,"deletions":25,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1101,2 +1101,0 @@\n-        updateFocusability();\n-        promoteDefaultPosition();\n@@ -1104,0 +1102,4 @@\n+        if (refreshChildsTransientFor) {\n+            updateFocusability();\n+        }\n+        promoteDefaultPosition();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindowPeer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -175,7 +175,0 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        dispose();\n-        super.finalize();\n-    }\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11InputMethodBase.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+            @Override\n@@ -87,1 +88,3 @@\n-                    arrowIcon, background, foreground, defaultTextIconGap,\n+                    arrowIcon, background, foreground,\n+                    disabledForeground, acceleratorSelectionForeground,\n+                    acceleratorForeground, defaultTextIconGap,\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsCheckBoxMenuItemUI.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-    private static Color disabledForeground;\n-    private static Color acceleratorSelectionForeground;\n-    private static Color acceleratorForeground;\n@@ -75,1 +72,1 @@\n-        new  WindowsMenuItemUIAccessor() {\n+        new WindowsMenuItemUIAccessor() {\n@@ -82,0 +79,1 @@\n+            @Override\n@@ -170,30 +168,0 @@\n-    private static void applyInsets(Rectangle rect, Insets insets) {\n-        SwingUtilities3.applyInsets(rect, insets);\n-    }\n-\n-    private static void paintCheckIcon(Graphics g, MenuItemLayoutHelper lh,\n-                                MenuItemLayoutHelper.LayoutResult lr,\n-                                Color holdc, Color foreground) {\n-        SwingUtilities3.paintCheckIcon(g, lh, lr, holdc, foreground);\n-    }\n-\n-    private static void paintIcon(Graphics g, MenuItemLayoutHelper lh,\n-                           MenuItemLayoutHelper.LayoutResult lr, Color holdc) {\n-        SwingUtilities3.paintIcon(g, lh, lr, holdc);\n-    }\n-\n-    private static void paintAccText(Graphics g, MenuItemLayoutHelper lh,\n-                              MenuItemLayoutHelper.LayoutResult lr) {\n-        SwingUtilities3.setDisabledForeground(disabledForeground);\n-        SwingUtilities3.setAcceleratorSelectionForeground(\n-                        acceleratorSelectionForeground);\n-        SwingUtilities3.setAcceleratorForeground(acceleratorForeground);\n-        SwingUtilities3.paintAccText(g, lh, lr);\n-    }\n-\n-    private static void paintArrowIcon(Graphics g, MenuItemLayoutHelper lh,\n-                                MenuItemLayoutHelper.LayoutResult lr,\n-                                Color foreground) {\n-        SwingUtilities3.paintArrowIcon(g, lh, lr, foreground);\n-    }\n-\n@@ -207,1 +175,2 @@\n-                                            defaultTextIconGap, menuItem,\n+                                            disabledForeground, acceleratorSelectionForeground,\n+                                            acceleratorForeground, defaultTextIconGap, menuItem,\n@@ -218,0 +187,3 @@\n+                              Color disabledForeground,\n+                              Color acceleratorSelectionForeground,\n+                              Color acceleratorForeground,\n@@ -227,1 +199,1 @@\n-        applyInsets(viewRect, mi.getInsets());\n+        SwingUtilities3.applyInsets(viewRect, mi.getInsets());\n@@ -245,2 +217,2 @@\n-        paintCheckIcon(g, lh, lr, holdc, foreground);\n-        paintIcon(g, lh, lr, holdc);\n+        SwingUtilities3.paintCheckIcon(g, lh, lr, holdc, foreground);\n+        SwingUtilities3.paintIcon(g, lh, lr, holdc);\n@@ -270,2 +242,4 @@\n-        paintAccText(g, lh, lr);\n-        paintArrowIcon(g, lh, lr, foreground);\n+        SwingUtilities3.paintAccText(g, lh, lr, disabledForeground,\n+                                     acceleratorSelectionForeground,\n+                                     acceleratorForeground);\n+        SwingUtilities3.paintArrowIcon(g, lh, lr, foreground);\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuItemUI.java","additions":14,"deletions":40,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-    protected Integer menuBarHeight;\n-    protected boolean hotTrackingOn;\n+    private Integer menuBarHeight;\n+    private boolean hotTrackingOn;\n@@ -65,0 +65,1 @@\n+            @Override\n@@ -143,1 +144,2 @@\n-                                            defaultTextIconGap, menuItem,\n+                                            disabledForeground, acceleratorSelectionForeground,\n+                                            acceleratorForeground, defaultTextIconGap, menuItem,\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuUI.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+           @Override\n@@ -87,1 +88,3 @@\n-                    arrowIcon, background, foreground, defaultTextIconGap,\n+                    arrowIcon, background, foreground,\n+                    disabledForeground, acceleratorSelectionForeground,\n+                    acceleratorForeground, defaultTextIconGap,\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsRadioButtonMenuItemUI.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n@@ -127,0 +129,2 @@\n+        disposerRecord = new ContextDisposerRecord(context);\n+        Disposer.addRecord(this, disposerRecord);\n@@ -135,8 +139,16 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable\n-    {\n-        \/\/ Release the resources used by the native input context.\n-        if (context!=0) {\n-            destroyNativeContext(context);\n-            context=0;\n+    private final ContextDisposerRecord disposerRecord;\n+\n+    private static final class ContextDisposerRecord implements DisposerRecord {\n+\n+        private final int context;\n+        private volatile boolean disposed;\n+\n+        ContextDisposerRecord(int c) {\n+            context = c;\n+        }\n+\n+        public synchronized void dispose() {\n+            if (!disposed) {\n+                destroyNativeContext(context);\n+            }\n+            disposed = true;\n@@ -144,1 +156,0 @@\n-        super.finalize();\n@@ -154,3 +165,1 @@\n-        \/\/ Due to a memory management problem in Windows 98, we should retain\n-        \/\/ the native input context until this object is finalized. So do\n-        \/\/ nothing here.\n+        disposerRecord.dispose();\n@@ -451,0 +460,1 @@\n+        disableNativeIME(awtFocussedComponentPeer);\n@@ -661,2 +671,2 @@\n-    private native int createNativeContext();\n-    private native void destroyNativeContext(int context);\n+    private static native int createNativeContext();\n+    private static native void destroyNativeContext(int context);\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WInputMethod.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-Java_sun_awt_windows_WInputMethod_createNativeContext(JNIEnv *env, jobject self)\n+Java_sun_awt_windows_WInputMethod_createNativeContext(JNIEnv *env, jclass cls)\n@@ -72,1 +72,1 @@\n-Java_sun_awt_windows_WInputMethod_destroyNativeContext(JNIEnv *env, jobject self, jint context)\n+Java_sun_awt_windows_WInputMethod_destroyNativeContext(JNIEnv *env, jclass cls, jint context)\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_InputMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.Serial;\n@@ -51,0 +52,1 @@\n+    @Serial\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/LoggingPermission.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,2 +294,7 @@\n-        \/\/ ------------------------------\n-        \/\/ ------------------------------\n+        if (object == null) {\n+            final RuntimeException wrapped =\n+                new IllegalArgumentException(\"Object cannot be null\");\n+            throw new RuntimeOperationsException(wrapped,\n+                      \"Exception occurred trying to register the MBean\");\n+        }\n+\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/interceptor\/DefaultMBeanServerInterceptor.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -32,0 +33,1 @@\n+import java.nio.channels.FileChannel;\n@@ -34,2 +36,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n@@ -723,0 +723,38 @@\n+        \/**\n+         * {@return a request body publisher whose body is the {@code length}\n+         * content bytes read from the provided file {@code channel} starting\n+         * from the specified {@code offset}}\n+         * <p>\n+         * This method and the returned {@code BodyPublisher} do not modify the\n+         * {@code channel}'s position, and do not close the {@code channel}. The\n+         * caller is expected to close the {@code channel} when no longer needed.\n+         *\n+         * @apiNote\n+         * This method can be used to either publish just a region of a file as\n+         * the request body or to publish different regions of a file\n+         * concurrently. A typical usage would be to publish different regions\n+         * of a file by creating a single instance of {@link FileChannel} and\n+         * then send multiple concurrent {@code HttpRequest}s, each of which\n+         * uses a new {@code ofFileChannel BodyPublisher} created from the same\n+         * channel with a different, typically non-overlapping, range of bytes\n+         * specified by offset and length.\n+         *\n+         * @param channel a file channel\n+         * @param offset the offset of the first byte\n+         * @param length the number of bytes to read from the file channel\n+         *\n+         * @throws IndexOutOfBoundsException if the specified byte range is\n+         * found to be {@linkplain Objects#checkFromIndexSize(long, long, long)\n+         * out of bounds} compared with the size of the file referred by the\n+         * channel\n+         *\n+         * @throws IOException if the {@linkplain FileChannel#size() channel's\n+         * size} cannot be determined or the {@code channel} is closed\n+         *\n+         * @since 26\n+         *\/\n+        public static BodyPublisher ofFileChannel(FileChannel channel, long offset, long length) throws IOException {\n+            Objects.requireNonNull(channel, \"channel\");\n+            return new RequestPublishers.FileChannelPublisher(channel, offset, length);\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.channels.FileChannel;\n@@ -421,0 +422,75 @@\n+    public static final class FileChannelPublisher implements BodyPublisher {\n+\n+        private final FileChannel channel;\n+\n+        private final long position;\n+\n+        private final long limit;\n+\n+        public FileChannelPublisher(FileChannel channel, long offset, long length) throws IOException {\n+            this.channel = Objects.requireNonNull(channel, \"channel\");\n+            long fileSize = channel.size();\n+            Objects.checkFromIndexSize(offset, length, fileSize);\n+            this.position = offset;\n+            this.limit = offset + length;\n+        }\n+\n+        @Override\n+        public long contentLength() {\n+            return limit - position;\n+        }\n+\n+        @Override\n+        public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+            Iterable<ByteBuffer> iterable = () -> new FileChannelIterator(channel, position, limit);\n+            new PullPublisher<>(iterable).subscribe(subscriber);\n+        }\n+\n+    }\n+\n+    private static final class FileChannelIterator implements Iterator<ByteBuffer> {\n+\n+        private final FileChannel channel;\n+\n+        private final long limit;\n+\n+        private long position;\n+\n+        private boolean terminated;\n+\n+        private FileChannelIterator(FileChannel channel, long position, long limit) {\n+            this.channel = channel;\n+            this.position = position;\n+            this.limit = limit;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return position < limit && !terminated;\n+        }\n+\n+        @Override\n+        public ByteBuffer next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            long remaining = limit - position;\n+            ByteBuffer buffer = Utils.getBufferWithAtMost(remaining);\n+            try {\n+                int readLength = channel.read(buffer, position);\n+                \/\/ Short-circuit if `read()` has failed, e.g., due to file content being changed in the meantime\n+                if (readLength < 0) {\n+                    \/\/ Throw to signal that the request needs to be cancelled\n+                    throw new IOException(\"Unexpected EOF (position=%s)\".formatted(position));\n+                } else {\n+                    position += readLength;\n+                }\n+            } catch (IOException ioe) {\n+                terminated = true;\n+                throw new UncheckedIOException(ioe);\n+            }\n+            return buffer.flip();\n+        }\n+\n+    }\n+\n@@ -433,1 +509,1 @@\n-        public final long contentLength() {\n+        public long contentLength() {\n@@ -438,1 +514,1 @@\n-        public final void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+        public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RequestPublishers.java","additions":78,"deletions":2,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -395,0 +395,4 @@\n+\n+    \/**\n+     * {@return a new {@link ByteBuffer} instance of {@link #BUFSIZE} capacity}\n+     *\/\n@@ -399,0 +403,18 @@\n+    \/**\n+     * {@return a new {@link ByteBuffer} instance whose capacity is set to the\n+     * smaller of the specified {@code maxCapacity} and the default\n+     * ({@value BUFSIZE})}\n+     *\n+     * @param maxCapacity a buffer capacity, in bytes\n+     * @throws IllegalArgumentException if {@code maxCapacity < 0}\n+     *\/\n+    public static ByteBuffer getBufferWithAtMost(long maxCapacity) {\n+        if (maxCapacity < 0) {\n+            throw new IllegalArgumentException(\n+                    \/\/ Match the message produced by `ByteBuffer::createCapacityException`\n+                    \"capacity < 0: (%s < 0)\".formatted(maxCapacity));\n+        }\n+        int effectiveCapacity = (int) Math.min(maxCapacity, BUFSIZE);\n+        return ByteBuffer.allocate(effectiveCapacity);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2151,6 +2151,2 @@\n-            (Error OPAQUE_FRAME      \"Attempted to return early from a frame \"\n-                                     \"corresponding to a native method, \"\n-                                     \"the thread is a suspended virtual thread and the target \"\n-                                     \"VM is unable to force its current frame to return, \"\n-                                     \"or the implementation is unable to provide this \"\n-                                     \"functionality on this frame.\")\n+            (Error OPAQUE_FRAME      \"Unable to force the current frame to return \"\n+                                     \"(e.g. the current frame is executing a native method).\")\n@@ -2628,0 +2624,2 @@\n+            (Error OPAQUE_FRAME      \"Unable to get the value of local variables in the frame \"\n+                                     \"(e.g. the frame is executing a native method).\")\n@@ -2665,3 +2663,3 @@\n-            (Error OPAQUE_FRAME      \"The thread is a suspended virtual thread and the target VM \"\n-                                     \"does not support setting the value of local \"\n-                                     \"variables in the frame.\")\n+            (Error INVALID_SLOT)\n+            (Error OPAQUE_FRAME      \"Unable to set the value of local variables in the frame \"\n+                                     \"(e.g. the frame is executing a native method).\")\n@@ -2716,4 +2714,3 @@\n-            (Error OPAQUE_FRAME      \"If one or more of the frames to pop is a native \"\n-                                     \"method or its caller is a native method, or the \"\n-                                     \"thread is a suspended virtual thread and the implementation \"\n-                                     \"was unable to pop the frames.\")\n+            (Error OPAQUE_FRAME      \"Unable to pop one or more of the frames \"\n+                                     \"(e.g. one or more of the frames to pop is a native \"\n+                                     \"method or its caller is a native method).\")\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.security.Provider;\n@@ -54,1 +55,1 @@\n- * The JDK implementation supports the following property that can be set\n+ * The JDK implementation supports the following properties that can be set\n@@ -57,0 +58,3 @@\n+ *   <li><code>org.jcp.xml.dsig.internal.dom.SignatureProvider<\/code>: value\n+ *       must be a {@link Provider}. If specified, the underlying {@code Signature}\n+ *       will be instantiated from this provider.\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/dom\/DOMSignContext.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import java.security.Provider;\n+\n@@ -55,12 +57,22 @@\n- * By default, the JDK implementation enables a secure validation mode by\n- * setting the <code>org.jcp.xml.dsig.secureValidation<\/code> property to\n- * <code>Boolean.TRUE<\/code> (see the {@link #setProperty setProperty}\n- * method). When enabled, validation of XML signatures are subject to\n- * stricter checking of algorithms and other constraints as specified by the\n- * <code>jdk.xml.dsig.secureValidationPolicy<\/code> security property.\n- * The mode can be disabled by setting the property to {@code Boolean.FALSE}.\n- * The mode can also be enabled or disabled by setting the\n- * {@systemProperty org.jcp.xml.dsig.secureValidation} system property to\n- * \"true\" or \"false\". Any other value for the system property is also treated\n- * as \"false\". If the system property is set, it supersedes the\n- * {@code DOMValidateContext} property value.\n+ * The JDK implementation supports the following properties that can be set\n+ * using the {@link #setProperty setProperty} method.\n+ * <ul>\n+ *   <li><code>org.jcp.xml.dsig.secureValidation<\/code>: value must be a\n+ *      {@link Boolean}. When enabled, validation of XML signatures are subject\n+ *      to stricter checking of algorithms and other constraints as specified by the\n+ *      <code>jdk.xml.dsig.secureValidationPolicy<\/code> security property.\n+ *      The default value if not specified is <code>Boolean.TRUE<\/code>.\n+ *      The mode can be disabled by setting the property to {@code Boolean.FALSE}.\n+ *      The mode can also be enabled or disabled by setting the\n+ *      {@systemProperty org.jcp.xml.dsig.secureValidation} system property to\n+ *      \"true\" or \"false\". Any other value for the system property is also treated\n+ *      as \"false\". If the system property is set, it supersedes the\n+ *      {@code DOMValidateContext} property value.\n+ *   <li><code>org.jcp.xml.dsig.validateManifests<\/code>: value\n+ *      must be a {@link Boolean}. If enabled, the references in manifest\n+ *      elements (if exist) are validated during signature validation.\n+ *      The default value if not specified is <code>Boolean.FALSE<\/code>.\n+ *   <li><code>org.jcp.xml.dsig.internal.dom.SignatureProvider<\/code>: value\n+ *      must be a {@link Provider}. If specified, the underlying {@code Signature}\n+ *      will be instantiated from this provider.\n+ * <\/ul>\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/dom\/DOMValidateContext.java","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/EUC_JP.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -415,0 +415,1 @@\n+            compiler.log.reportOutstandingWarnings();\n@@ -486,1 +487,2 @@\n-            if (compiler != null)\n+            if (compiler != null) {\n+                compiler.log.reportOutstandingWarnings();\n@@ -488,0 +490,1 @@\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -271,0 +272,1 @@\n+                LintMapper.instance(this).clear();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskPool.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -363,3 +363,8 @@\n-                    Type t = attr.attribType(dcReference.qualifierExpression, env);\n-                    if (t != null && !t.isErroneous()) {\n-                        return t;\n+                    JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+                    try {\n+                        Type t = attr.attribType(dcReference.qualifierExpression, env);\n+                        if (t != null && !t.isErroneous()) {\n+                            return t;\n+                        }\n+                    } finally {\n+                        log.useSource(prevSource);\n@@ -391,0 +396,1 @@\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n@@ -512,0 +518,1 @@\n+            log.useSource(prevSource);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.code;\n-\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.Tag;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.Context;\n-\n-\/**\n- * Holds pending {@link Lint} warnings until the {@lint Lint} instance associated with the containing\n- * module, package, class, method, or variable declaration is known so that {@link @SupressWarnings}\n- * suppressions may be applied.\n- *\n- * <p>\n- * Warnings are regsistered at any time prior to attribution via {@link #report}. The warning will be\n- * associated with the declaration placed in context by the most recent invocation of {@link #push push()}\n- * not yet {@link #pop}'d. Warnings are actually emitted later, during attribution, via {@link #flush}.\n- *\n- * <p>\n- * There is also an \"immediate\" mode, where warnings are emitted synchronously; see {@link #pushImmediate}.\n- *\n- * <p>\n- * Deferred warnings are grouped by the innermost containing module, package, class, method, or variable\n- * declaration (represented by {@link JCTree} nodes), so that the corresponding {@link Lint} configuration\n- * can be applied when the warning is eventually generated.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own risk.\n- * This code and its internal interfaces are subject to change or\n- * deletion without notice.<\/b>\n- *\/\n-public class DeferredLintHandler {\n-\n-    protected static final Context.Key<DeferredLintHandler> deferredLintHandlerKey = new Context.Key<>();\n-\n-    public static DeferredLintHandler instance(Context context) {\n-        DeferredLintHandler instance = context.get(deferredLintHandlerKey);\n-        if (instance == null)\n-            instance = new DeferredLintHandler(context);\n-        return instance;\n-    }\n-\n-    \/**\n-     * Registered {@link LintLogger}s grouped by the innermost containing module, package, class,\n-     * method, or variable declaration.\n-     *\/\n-    private final HashMap<JCTree, ArrayList<LintLogger>> deferralMap = new HashMap<>();\n-\n-    \/**\n-     * The current \"reporter\" stack, reflecting calls to {@link #push} and {@link #pop}.\n-     *\n-     * <p>\n-     * The top of the stack determines how calls to {@link #report} are handled.\n-     *\/\n-    private final ArrayDeque<Consumer<LintLogger>> reporterStack = new ArrayDeque<>();\n-\n-    @SuppressWarnings(\"this-escape\")\n-    protected DeferredLintHandler(Context context) {\n-        context.put(deferredLintHandlerKey, this);\n-        Lint rootLint = Lint.instance(context);\n-        pushImmediate(rootLint);            \/\/ default to \"immediate\" mode\n-    }\n-\n-\/\/ LintLogger\n-\n-    \/**An interface for deferred lint reporting - loggers passed to\n-     * {@link #report(LintLogger) } will be called when\n-     * {@link #flush(DiagnosticPosition) } is invoked.\n-     *\/\n-    public interface LintLogger {\n-\n-        \/**\n-         * Generate a warning if appropriate.\n-         *\n-         * @param lint the applicable lint configuration\n-         *\/\n-        void report(Lint lint);\n-    }\n-\n-\/\/ Reporter Stack\n-\n-    \/**\n-     * Defer {@link #report}ed warnings until the given declaration is flushed.\n-     *\n-     * @param decl module, package, class, method, or variable declaration\n-     * @see #pop\n-     *\/\n-    public void push(JCTree decl) {\n-        Assert.check(decl.getTag() == Tag.MODULEDEF\n-                  || decl.getTag() == Tag.PACKAGEDEF\n-                  || decl.getTag() == Tag.CLASSDEF\n-                  || decl.getTag() == Tag.METHODDEF\n-                  || decl.getTag() == Tag.VARDEF);\n-        reporterStack.push(logger -> deferralMap\n-                                        .computeIfAbsent(decl, s -> new ArrayList<>())\n-                                        .add(logger));\n-    }\n-\n-    \/**\n-     * Enter \"immediate\" mode so that {@link #report}ed warnings are emitted synchonously.\n-     *\n-     * @param lint lint configuration to use for reported warnings\n-     *\/\n-    public void pushImmediate(Lint lint) {\n-        reporterStack.push(logger -> logger.report(lint));\n-    }\n-\n-    \/**\n-     * Revert to the previous configuration in effect prior to the most recent invocation\n-     * of {@link #push} or {@link #pushImmediate}.\n-     *\n-     * @see #pop\n-     *\/\n-    public void pop() {\n-        Assert.check(reporterStack.size() > 1);     \/\/ the bottom stack entry should never be popped\n-        reporterStack.pop();\n-    }\n-\n-    \/**\n-     * Report a warning.\n-     *\n-     * <p>\n-     * In immediate mode, the warning is emitted synchronously. Otherwise, the warning is emitted later\n-     * when the current declaration is flushed.\n-     *\/\n-    public void report(LintLogger logger) {\n-        Assert.check(!reporterStack.isEmpty());\n-        reporterStack.peek().accept(logger);\n-    }\n-\n-\/\/ Warning Flush\n-\n-    \/**\n-     * Emit deferred warnings encompassed by the given declaration.\n-     *\n-     * @param decl module, package, class, method, or variable declaration\n-     * @param lint lint configuration corresponding to {@code decl}\n-     *\/\n-    public void flush(JCTree decl, Lint lint) {\n-        Optional.of(decl)\n-          .map(deferralMap::remove)\n-          .stream()\n-          .flatMap(ArrayList::stream)\n-          .forEach(logger -> logger.report(lint));\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n@@ -38,1 +40,0 @@\n-import com.sun.tools.javac.util.StringUtils;\n@@ -54,1 +55,1 @@\n-        for (Flag flag : asFlagSet(flags)) {\n+        for (FlagsEnum flag : asFlagSet(flags)) {\n@@ -62,4 +63,4 @@\n-    public static EnumSet<Flag> asFlagSet(long flags) {\n-        EnumSet<Flag> flagSet = EnumSet.noneOf(Flag.class);\n-        for (Flag flag : Flag.values()) {\n-            if ((flags & flag.value) != 0) {\n+    public static EnumSet<FlagsEnum> asFlagSet(long flags) {\n+        EnumSet<FlagsEnum> flagSet = EnumSet.noneOf(FlagsEnum.class);\n+        for (FlagsEnum flag : FlagsEnum.values()) {\n+            if ((flags & flag.value()) != 0) {\n@@ -67,1 +68,1 @@\n-                flags &= ~flag.value;\n+                flags &= ~flag.value();\n@@ -76,0 +77,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -77,0 +79,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -78,0 +81,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -79,0 +83,1 @@\n+    @Use({FlagTarget.BLOCK, FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -80,0 +85,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -81,0 +87,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -82,0 +89,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -83,0 +91,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -84,0 +93,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -85,0 +95,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -86,0 +97,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -87,0 +99,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -90,0 +103,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -93,0 +107,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -97,0 +112,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE})\n@@ -100,0 +116,1 @@\n+    @Use({FlagTarget.MODULE, FlagTarget.VARIABLE})\n@@ -102,0 +119,1 @@\n+    @NotFlag\n@@ -108,4 +126,12 @@\n-    public static final int ACC_SUPER    = 0x0020;\n-    public static final int ACC_BRIDGE   = 0x0040;\n-    public static final int ACC_VARARGS  = 0x0080;\n-    public static final int ACC_MODULE   = 0x8000;\n+    @Use({FlagTarget.CLASS})\n+    @NoToStringValue\n+    public static final int ACC_SUPER    = 1<<5;\n+    @Use({FlagTarget.METHOD})\n+    @NoToStringValue\n+    public static final int ACC_BRIDGE   = 1<<6;\n+    @Use({FlagTarget.METHOD})\n+    @NoToStringValue\n+    public static final int ACC_VARARGS  = 1<<7;\n+    @Use({FlagTarget.CLASS})\n+    @NoToStringValue\n+    public static final int ACC_MODULE   = 1<<15;\n@@ -119,0 +145,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -124,0 +151,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -128,0 +156,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -133,0 +162,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -137,1 +167,2 @@\n-    public static final int FROM_SOURCE      = 1<<21; \/\/ClassSymbols\n+    @Use({FlagTarget.CLASS})\n+    public static final int FROM_SOURCE      = 1<<21;\n@@ -146,0 +177,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE})\n@@ -151,0 +183,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.PACKAGE})\n@@ -156,0 +189,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -160,0 +194,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -165,0 +200,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -175,0 +211,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -180,0 +217,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -184,1 +222,2 @@\n-    public static final int ANONCONSTR   = 1<<29; \/\/non-class members\n+    @Use({FlagTarget.METHOD})\n+    public static final int ANONCONSTR   = 1<<29;\n@@ -189,1 +228,2 @@\n-    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29; \/\/ClassSymbols\n+    @Use({FlagTarget.CLASS})\n+    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29;\n@@ -194,0 +234,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.TYPE_VAR})\n@@ -198,0 +239,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -202,0 +244,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -206,0 +249,1 @@\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -211,0 +255,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -215,0 +260,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -221,0 +267,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -226,0 +273,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -231,0 +279,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -237,0 +286,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.TYPE_VAR})\n@@ -242,0 +292,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -248,0 +299,1 @@\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n@@ -253,0 +305,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD})\n@@ -259,0 +312,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -264,0 +318,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -269,0 +324,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -274,0 +330,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -279,0 +336,1 @@\n+    @Use({FlagTarget.TYPE_VAR})\n@@ -284,0 +342,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -289,1 +348,2 @@\n-    public static final long LAMBDA_METHOD = 1L<<49; \/\/MethodSymbols only\n+    @Use({FlagTarget.METHOD})\n+    public static final long LAMBDA_METHOD = 1L<<49;\n@@ -294,1 +354,2 @@\n-    public static final long LOCAL_CAPTURE_FIELD = 1L<<49; \/\/VarSymbols only\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long LOCAL_CAPTURE_FIELD = 1L<<49;\n@@ -299,0 +360,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -304,0 +366,1 @@\n+    @Use({FlagTarget.CLASS})\n@@ -309,1 +372,2 @@\n-    public static final long AUTOMATIC_MODULE = 1L<<52; \/\/ModuleSymbols only\n+    @Use({FlagTarget.MODULE})\n+    public static final long AUTOMATIC_MODULE = 1L<<52;\n@@ -314,1 +378,2 @@\n-    public static final long HAS_RESOURCE = 1L<<52; \/\/PackageSymbols only\n+    @Use({FlagTarget.PACKAGE})\n+    public static final long HAS_RESOURCE = 1L<<52;\n@@ -319,1 +384,2 @@\n-    public static final long NAME_FILLED = 1L<<52; \/\/ParamSymbols only\n+    @Use({FlagTarget.VARIABLE}) \/\/ParamSymbols only\n+    public static final long NAME_FILLED = 1L<<52;\n@@ -324,1 +390,2 @@\n-    public static final long SYSTEM_MODULE = 1L<<53; \/\/ModuleSymbols only\n+    @Use({FlagTarget.MODULE})\n+    public static final long SYSTEM_MODULE = 1L<<53;\n@@ -329,1 +396,2 @@\n-    public static final long VALUE_BASED = 1L<<53; \/\/ClassSymbols only\n+    @Use({FlagTarget.CLASS})\n+    public static final long VALUE_BASED = 1L<<53;\n@@ -334,0 +402,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -339,0 +408,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -344,0 +414,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -349,0 +420,1 @@\n+    @Use({FlagTarget.METHOD})\n@@ -355,1 +427,2 @@\n-    public static final long BODY_ONLY_FINALIZE = 1L<<17; \/\/blocks only\n+    @Use({FlagTarget.BLOCK})\n+    public static final long BODY_ONLY_FINALIZE = 1L<<17;\n@@ -360,0 +433,1 @@\n+    @Use({FlagTarget.CLASS, FlagTarget.METHOD, FlagTarget.MODULE, FlagTarget.PACKAGE, FlagTarget.TYPE_VAR, FlagTarget.VARIABLE})\n@@ -365,0 +439,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -370,0 +445,1 @@\n+    @Use({FlagTarget.VARIABLE})\n@@ -376,1 +452,2 @@\n-    public static final long RECORD = 1L<<61; \/\/ ClassSymbols, MethodSymbols and VarSymbols\n+    @Use({FlagTarget.CLASS, FlagTarget.VARIABLE, FlagTarget.METHOD})\n+    public static final long RECORD = 1L<<61;\n@@ -381,1 +458,2 @@\n-    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<51; \/\/ MethodSymbols only\n+    @Use({FlagTarget.METHOD})\n+    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<51;\n@@ -386,1 +464,2 @@\n-    public static final long UNINITIALIZED_FIELD= 1L<<51; \/\/ VarSymbols only\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long UNINITIALIZED_FIELD= 1L<<51;\n@@ -391,1 +470,2 @@\n-    public static final int GENERATED_MEMBER = 1<<24; \/\/ MethodSymbols and VarSymbols\n+    @Use({FlagTarget.METHOD, FlagTarget.VARIABLE})\n+    public static final int GENERATED_MEMBER = 1<<24;\n@@ -396,1 +476,2 @@\n-    public static final long RESTRICTED = 1L<<62; \/\/ MethodSymbols\n+    @Use({FlagTarget.METHOD})\n+    public static final long RESTRICTED = 1L<<62;\n@@ -401,1 +482,2 @@\n-    public static final long REQUIRES_IDENTITY = 1L<<62; \/\/ VarSymbols (parameters)\n+    @Use({FlagTarget.VARIABLE}) \/\/ParamSymbols only\n+    public static final long REQUIRES_IDENTITY = 1L<<62;\n@@ -406,1 +488,2 @@\n-    public static final long FIELD_INIT_TYPE_ANNOTATIONS_QUEUED = 1L<<53; \/\/ VarSymbols\n+    @Use({FlagTarget.VARIABLE})\n+    public static final long FIELD_INIT_TYPE_ANNOTATIONS_QUEUED = 1L<<53;\n@@ -411,0 +494,2 @@\n+    @Use({FlagTarget.CLASS})\n+    @CustomToStringValue(\"non-sealed\")\n@@ -425,0 +510,1 @@\n+    @NotFlag\n@@ -441,0 +527,1 @@\n+    @NotFlag\n@@ -494,0 +581,24 @@\n+    public enum FlagTarget {\n+        \/** This flag can appear the JCBlock.\n+         *\/\n+        BLOCK,\n+        \/** This flag can appear on ClassSymbols.\n+         *\/\n+        CLASS,\n+        \/** This flag can appear on ModuleSymbols.\n+         *\/\n+        MODULE,\n+        \/** This flag can appear on PackageSymbols.\n+         *\/\n+        PACKAGE,\n+        \/** This flag can appear on TypeVarSymbols.\n+         *\/\n+        TYPE_VAR,\n+        \/** This flag can appear on MethodSymbols.\n+         *\/\n+        METHOD,\n+        \/** This flag can appear on VarSymbols, includes\n+         *  including ParamSymbol, and BindingSymbol.\n+         *\/\n+        VARIABLE;\n+    }\n@@ -495,76 +606,4 @@\n-    public enum Flag {\n-        PUBLIC(Flags.PUBLIC),\n-        PRIVATE(Flags.PRIVATE),\n-        PROTECTED(Flags.PROTECTED),\n-        STATIC(Flags.STATIC),\n-        FINAL(Flags.FINAL),\n-        SYNCHRONIZED(Flags.SYNCHRONIZED),\n-        VOLATILE(Flags.VOLATILE),\n-        TRANSIENT(Flags.TRANSIENT),\n-        NATIVE(Flags.NATIVE),\n-        INTERFACE(Flags.INTERFACE),\n-        ABSTRACT(Flags.ABSTRACT),\n-        DEFAULT(Flags.DEFAULT),\n-        STRICTFP(Flags.STRICTFP),\n-        BRIDGE(Flags.BRIDGE),\n-        SYNTHETIC(Flags.SYNTHETIC),\n-        ANNOTATION(Flags.ANNOTATION),\n-        DEPRECATED(Flags.DEPRECATED),\n-        HASINIT(Flags.HASINIT),\n-        IMPLICIT_CLASS(Flags.IMPLICIT_CLASS),\n-        BLOCK(Flags.BLOCK),\n-        FROM_SOURCE(Flags.FROM_SOURCE),\n-        ENUM(Flags.ENUM),\n-        MANDATED(Flags.MANDATED),\n-        NOOUTERTHIS(Flags.NOOUTERTHIS),\n-        EXISTS(Flags.EXISTS),\n-        COMPOUND(Flags.COMPOUND),\n-        CLASS_SEEN(Flags.CLASS_SEEN),\n-        SOURCE_SEEN(Flags.SOURCE_SEEN),\n-        LOCKED(Flags.LOCKED),\n-        UNATTRIBUTED(Flags.UNATTRIBUTED),\n-        ANONCONSTR(Flags.ANONCONSTR),\n-        ACYCLIC(Flags.ACYCLIC),\n-        PARAMETER(Flags.PARAMETER),\n-        VARARGS(Flags.VARARGS),\n-        ACYCLIC_ANN(Flags.ACYCLIC_ANN),\n-        GENERATEDCONSTR(Flags.GENERATEDCONSTR),\n-        HYPOTHETICAL(Flags.HYPOTHETICAL),\n-        PROPRIETARY(Flags.PROPRIETARY),\n-        UNION(Flags.UNION),\n-        EFFECTIVELY_FINAL(Flags.EFFECTIVELY_FINAL),\n-        CLASH(Flags.CLASH),\n-        AUXILIARY(Flags.AUXILIARY),\n-        NOT_IN_PROFILE(Flags.NOT_IN_PROFILE),\n-        BAD_OVERRIDE(Flags.BAD_OVERRIDE),\n-        SIGNATURE_POLYMORPHIC(Flags.SIGNATURE_POLYMORPHIC),\n-        THROWS(Flags.THROWS),\n-        LAMBDA_METHOD(Flags.LAMBDA_METHOD),\n-        TYPE_TRANSLATED(Flags.TYPE_TRANSLATED),\n-        MODULE(Flags.MODULE),\n-        AUTOMATIC_MODULE(Flags.AUTOMATIC_MODULE),\n-        SYSTEM_MODULE(Flags.SYSTEM_MODULE),\n-        DEPRECATED_ANNOTATION(Flags.DEPRECATED_ANNOTATION),\n-        DEPRECATED_REMOVAL(Flags.DEPRECATED_REMOVAL),\n-        HAS_RESOURCE(Flags.HAS_RESOURCE),\n-        SEALED(Flags.SEALED),\n-        ANONCONSTR_BASED(Flags.ANONCONSTR_BASED),\n-        NAME_FILLED(Flags.NAME_FILLED),\n-        PREVIEW_API(Flags.PREVIEW_API),\n-        PREVIEW_REFLECTIVE(Flags.PREVIEW_REFLECTIVE),\n-        MATCH_BINDING(Flags.MATCH_BINDING),\n-        MATCH_BINDING_TO_OUTER(Flags.MATCH_BINDING_TO_OUTER),\n-        RECORD(Flags.RECORD),\n-        RECOVERABLE(Flags.RECOVERABLE),\n-        RESTRICTED(Flags.RESTRICTED),\n-        NON_SEALED(Flags.NON_SEALED) {\n-            @Override\n-            public String toString() {\n-                return \"non-sealed\";\n-            }\n-        };\n-\n-        Flag(long flag) {\n-            this.value = flag;\n-            this.lowercaseName = StringUtils.toLowerCase(name());\n-        }\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Use {\n+        public FlagTarget[] value();\n+    }\n@@ -572,4 +611,2 @@\n-        @Override\n-        public String toString() {\n-            return lowercaseName;\n-        }\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NotFlag {}\n@@ -577,2 +614,3 @@\n-        final long value;\n-        final String lowercaseName;\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface CustomToStringValue {\n+        public String value();\n@@ -581,0 +619,3 @@\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface NoToStringValue {\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":152,"deletions":111,"binary":false,"changes":263,"status":"modified"},{"patch":"@@ -377,3 +377,0 @@\n-         *\n-         * <p>\n-         * This category is not supported by {@code @SuppressWarnings} (yet - see JDK-8224228).\n@@ -381,1 +378,1 @@\n-        TEXT_BLOCKS(\"text-blocks\", false),\n+        TEXT_BLOCKS(\"text-blocks\"),\n@@ -479,21 +476,0 @@\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(LintWarning warning) {\n-        logIfEnabled(null, warning);\n-    }\n-\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param pos source position at which to report the warning\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(DiagnosticPosition pos, LintWarning warning) {\n-        if (isEnabled(warning.getLintCategory())) {\n-            log.warning(pos, warning);\n-        }\n-    }\n-\n@@ -531,8 +507,9 @@\n-        Attribute.Array values = (Attribute.Array)suppressWarnings.member(names.value);\n-        for (Attribute value : values.values) {\n-            Optional.of(value)\n-              .filter(val -> val instanceof Attribute.Constant)\n-              .map(val -> (String) ((Attribute.Constant) val).value)\n-              .flatMap(LintCategory::get)\n-              .filter(lc -> lc.annotationSuppression)\n-              .ifPresent(result::add);\n+        if (suppressWarnings.member(names.value) instanceof Attribute.Array values) {\n+            for (Attribute value : values.values) {\n+                Optional.of(value)\n+                  .filter(val -> val instanceof Attribute.Constant)\n+                  .map(val -> (String) ((Attribute.Constant) val).value)\n+                  .flatMap(LintCategory::get)\n+                  .filter(lc -> lc.annotationSuppression)\n+                  .ifPresent(result::add);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":10,"deletions":33,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,328 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.code;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.tools.javac.tree.EndPosTable;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+\n+\/**\n+ * Maps source code positions to the applicable {@link Lint} instance.\n+ *\n+ * <p>\n+ * Because {@code @SuppressWarnings} is a Java symbol, in general this mapping can't be\n+ * calculated until after attribution. As each top-level declaration (class, package, or module)\n+ * is attributed, this singleton is notified and the {@link Lint}s that apply to every source\n+ * position within that top-level declaration are calculated.\n+ *\n+ * <p>\n+ * The method {@link #lintAt} returns the {@link Lint} instance applicable to source position;\n+ * if it can't be determined yet, an empty {@link Optional} is returned.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public class LintMapper {\n+\n+    \/\/ The key for the context singleton\n+    private static final Context.Key<LintMapper> CONTEXT_KEY = new Context.Key<>();\n+\n+    \/\/ Per-source file information. Note: during the parsing of a file, an entry exists but the FileInfo value is null\n+    private final Map<JavaFileObject, FileInfo> fileInfoMap = new HashMap<>();\n+\n+    \/\/ Compiler context\n+    private final Context context;\n+\n+    \/\/ These are initialized lazily; see initializeIfNeeded()\n+    private Lint rootLint;\n+\n+    \/**\n+     * Obtain the {@link LintMapper} context singleton.\n+     *\/\n+    public static LintMapper instance(Context context) {\n+        LintMapper instance = context.get(CONTEXT_KEY);\n+        if (instance == null)\n+            instance = new LintMapper(context);\n+        return instance;\n+    }\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected LintMapper(Context context) {\n+        context.put(CONTEXT_KEY, this);\n+        this.context = context;\n+    }\n+\n+    \/\/ Lazy initialization to avoid dependency loops\n+    private void initializeIfNeeded() {\n+        if (rootLint == null)\n+            rootLint = Lint.instance(context);\n+    }\n+\n+\/\/ Lint Operations\n+\n+    \/**\n+     * Determine if the given file is known to this instance.\n+     *\n+     * @param sourceFile source file\n+     * @return true if file is recognized\n+     *\/\n+    public boolean isKnown(JavaFileObject sourceFile) {\n+        return fileInfoMap.containsKey(sourceFile);\n+    }\n+\n+    \/**\n+     * Obtain the {@link Lint} configuration that applies at the given position, if known.\n+     *\n+     * @param sourceFile source file\n+     * @param pos source position\n+     * @return the applicable {@link Lint}, if known, otherwise empty\n+     *\/\n+    public Optional<Lint> lintAt(JavaFileObject sourceFile, DiagnosticPosition pos) {\n+        initializeIfNeeded();\n+        return Optional.of(sourceFile)\n+          .map(fileInfoMap::get)\n+          .flatMap(fileInfo -> fileInfo.lintAt(pos));\n+    }\n+\n+    \/**\n+     * Calculate {@lint Lint} configurations for all positions within the given top-level declaration.\n+     *\n+     * @param sourceFile source file\n+     * @param tree top-level declaration (class, package, or module)\n+     *\/\n+    public void calculateLints(JavaFileObject sourceFile, JCTree tree, EndPosTable endPositions) {\n+        Assert.check(rootLint != null);\n+        fileInfoMap.get(sourceFile).afterAttr(tree, endPositions);\n+    }\n+\n+    \/**\n+     * Reset this instance.\n+     *\/\n+    public void clear() {\n+        fileInfoMap.clear();\n+    }\n+\n+\/\/ Parsing Notifications\n+\n+    \/**\n+     * Invoked when file parsing starts to create an entry for the new file (but with a null value).\n+     *\/\n+    public void startParsingFile(JavaFileObject sourceFile) {\n+        initializeIfNeeded();\n+        fileInfoMap.put(sourceFile, null);\n+    }\n+\n+    \/**\n+     * Invoked when file parsing completes to put in place a corresponding {@link FileInfo}.\n+     *\/\n+    public void finishParsingFile(JCCompilationUnit tree) {\n+        Assert.check(rootLint != null);\n+        fileInfoMap.put(tree.sourcefile, new FileInfo(rootLint, tree));\n+    }\n+\n+\/\/ FileInfo\n+\n+    \/**\n+     * Holds {@link Lint} information for a fully parsed source file.\n+     *\n+     * <p>\n+     * Initially (immediately after parsing), \"unmappedDecls\" contains a {@link Span} corresponding to each\n+     * top-level declaration in the source file. As each top-level declaration is attributed, the corresponding\n+     * {@link Span} is removed and the corresponding {@link LintRange} subtree is populated under \"rootRange\".\n+     *\/\n+    private static class FileInfo {\n+\n+        final LintRange rootRange;                              \/\/ the root LintRange (covering the entire source file)\n+        final List<Span> unmappedDecls = new ArrayList<>();     \/\/ unmapped top-level declarations awaiting attribution\n+\n+        \/\/ After parsing: Add top-level declarations to our \"unmappedDecls\" list\n+        FileInfo(Lint rootLint, JCCompilationUnit tree) {\n+            rootRange = new LintRange(rootLint);\n+            tree.defs.stream()\n+              .filter(this::isTopLevelDecl)\n+              .map(decl -> new Span(decl, tree.endPositions))\n+              .forEach(unmappedDecls::add);\n+        }\n+\n+        \/\/ After attribution: Discard the span from \"unmappedDecls\" and populate the declaration's subtree under \"rootRange\"\n+        void afterAttr(JCTree tree, EndPosTable endPositions) {\n+            for (Iterator<Span> i = unmappedDecls.iterator(); i.hasNext(); ) {\n+                if (i.next().contains(tree.pos())) {\n+                    rootRange.populateSubtree(tree, endPositions);\n+                    i.remove();\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"top-level declaration not found\");\n+        }\n+\n+        \/\/ Find the most specific Lint configuration applying to the given position, unless the position has not been mapped yet\n+        Optional<Lint> lintAt(DiagnosticPosition pos) {\n+            boolean mapped = unmappedDecls.stream().noneMatch(span -> span.contains(pos));\n+            return mapped ? Optional.of(rootRange.bestMatch(pos).lint) : Optional.empty();\n+        }\n+\n+        boolean isTopLevelDecl(JCTree tree) {\n+            return tree.getTag() == Tag.MODULEDEF\n+                || tree.getTag() == Tag.PACKAGEDEF\n+                || tree.getTag() == Tag.CLASSDEF;\n+        }\n+    }\n+\n+\/\/ Span\n+\n+    \/**\n+     * A lexical range.\n+     *\/\n+    private record Span(int startPos, int endPos) {\n+\n+        static final Span MAXIMAL = new Span(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+\n+        Span(JCTree tree, EndPosTable endPositions) {\n+            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n+        }\n+\n+        boolean contains(DiagnosticPosition pos) {\n+            int offset = pos.getLintPosition();\n+            return offset == startPos || (offset > startPos && offset < endPos);\n+        }\n+\n+        boolean contains(Span that) {\n+            return this.startPos <= that.startPos && this.endPos >= that.endPos;\n+        }\n+    }\n+\n+\/\/ LintRange\n+\n+    \/**\n+     * A tree of nested lexical ranges and the {@link Lint} configurations that apply therein.\n+     *\/\n+    private record LintRange(\n+        Span span,                                      \/\/ declaration's lexical range\n+        Lint lint,                                      \/\/ the Lint configuration that applies at this declaration\n+        List<LintRange> children                        \/\/ the nested declarations one level below this node\n+    ) {\n+\n+        \/\/ Create a node representing the entire file, using the root lint configuration\n+        LintRange(Lint rootLint) {\n+            this(Span.MAXIMAL, rootLint, new ArrayList<>());\n+        }\n+\n+        \/\/ Create a node representing the given declaration and its corresponding Lint configuration\n+        LintRange(JCTree tree, EndPosTable endPositions, Lint lint) {\n+            this(new Span(tree, endPositions), lint, new ArrayList<>());\n+        }\n+\n+        \/\/ Find the most specific node in this tree (including me) that contains the given position, if any\n+        LintRange bestMatch(DiagnosticPosition pos) {\n+            return children.stream()\n+              .map(child -> child.bestMatch(pos))\n+              .filter(Objects::nonNull)\n+              .reduce((a, b) -> a.span.contains(b.span) ? b : a)\n+              .orElseGet(() -> span.contains(pos) ? this : null);\n+        }\n+\n+        \/\/ Populate a sparse subtree corresponding to the given nested declaration.\n+        \/\/ Only when the Lint configuration differs from the parent is a node added.\n+        void populateSubtree(JCTree tree, EndPosTable endPositions) {\n+            new TreeScanner() {\n+\n+                private LintRange currentNode = LintRange.this;\n+\n+                @Override\n+                public void visitModuleDef(JCModuleDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitModuleDef);\n+                }\n+                @Override\n+                public void visitPackageDef(JCPackageDecl tree) {\n+                    scanDecl(tree, tree.packge, super::visitPackageDef);\n+                }\n+                @Override\n+                public void visitClassDef(JCClassDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitClassDef);\n+                }\n+                @Override\n+                public void visitMethodDef(JCMethodDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitMethodDef);\n+                }\n+                @Override\n+                public void visitVarDef(JCVariableDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitVarDef);\n+                }\n+\n+                private <T extends JCTree> void scanDecl(T tree, Symbol symbol, Consumer<? super T> recursor) {\n+\n+                    \/\/ The \"symbol\" can be null if there were earlier errors; skip this declaration if so\n+                    if (symbol == null) {\n+                        recursor.accept(tree);\n+                        return;\n+                    }\n+\n+                    \/\/ Update the Lint using the declaration; if there's no change, then we don't need a new node here\n+                    Lint newLint = currentNode.lint.augment(symbol);\n+                    if (newLint == currentNode.lint) {  \/\/ note: lint.augment() returns the same instance if there's no change\n+                        recursor.accept(tree);\n+                        return;\n+                    }\n+\n+                    \/\/ Add a new node here and proceed\n+                    final LintRange previousNode = currentNode;\n+                    currentNode = new LintRange(tree, endPositions, newLint);\n+                    previousNode.children.add(currentNode);\n+                    try {\n+                        recursor.accept(tree);\n+                    } finally {\n+                        currentNode = previousNode;\n+                    }\n+                }\n+            }.scan(tree);\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":328,"deletions":0,"binary":false,"changes":328,"status":"added"},{"patch":"@@ -70,3 +70,0 @@\n-    \/** flag: is the \"preview\" lint category enabled? *\/\n-    private final boolean verbose;\n-\n@@ -103,1 +100,0 @@\n-        verbose = Lint.instance(context).isEnabled(LintCategory.PREVIEW);\n@@ -187,3 +183,1 @@\n-        if (verbose) {\n-            log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n-        }\n+        log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -94,1 +93,0 @@\n-    private final Lint lint;\n@@ -113,1 +111,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -116,1 +113,0 @@\n-        lint = Lint.instance(context);\n@@ -238,1 +234,0 @@\n-     * @param deferDecl   enclosing declaration for DeferredLintHandler, or null for no deferral\n@@ -240,2 +235,1 @@\n-    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv,\n-            Symbol s, JCTree deferDecl)\n+    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv, Symbol s)\n@@ -259,2 +253,0 @@\n-            Assert.check(deferDecl != null);\n-            deferredLintHandler.push(deferDecl);\n@@ -271,1 +263,0 @@\n-                deferredLintHandler.pop();\n@@ -288,2 +279,1 @@\n-    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv,\n-            MethodSymbol m, JCTree deferDecl)\n+    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv, MethodSymbol m)\n@@ -293,1 +283,0 @@\n-            deferredLintHandler.push(deferDecl);\n@@ -297,1 +286,0 @@\n-                deferredLintHandler.pop();\n@@ -685,1 +673,1 @@\n-            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, null);\n+            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym);\n@@ -1037,2 +1025,1 @@\n-    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env,\n-            Symbol s, JCTree deferDecl, boolean isTypeParam)\n+    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env, Symbol s, boolean isTypeParam)\n@@ -1043,3 +1030,0 @@\n-        if (deferDecl != null) {\n-            deferredLintHandler.push(deferDecl);\n-        }\n@@ -1049,2 +1033,0 @@\n-            if (deferDecl != null)\n-                deferredLintHandler.pop();\n@@ -1058,1 +1040,1 @@\n-    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym, JCTree deferDecl)\n+    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym)\n@@ -1061,1 +1043,1 @@\n-        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferDecl)));\n+        normal(() -> tree.accept(new TypeAnnotate(env, sym)));\n@@ -1096,1 +1078,0 @@\n-        private JCTree deferDecl;\n@@ -1098,1 +1079,1 @@\n-        public TypeAnnotate(Env<AttrContext> env, Symbol sym, JCTree deferDecl) {\n+        public TypeAnnotate(Env<AttrContext> env, Symbol sym) {\n@@ -1102,1 +1083,0 @@\n-            this.deferDecl = deferDecl;\n@@ -1107,1 +1087,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1113,1 +1093,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, true);\n+            enterTypeAnnotations(tree.annotations, env, sym, true);\n@@ -1119,1 +1099,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1121,1 +1101,1 @@\n-                enterTypeAnnotations(dimAnnos, env, sym, deferDecl, false);\n+                enterTypeAnnotations(dimAnnos, env, sym, false);\n@@ -1140,12 +1120,5 @@\n-            JCTree prevDecl = deferDecl;\n-            deferDecl = tree;\n-            try {\n-                if (sym != null && sym.kind == VAR) {\n-                    \/\/ Don't visit a parameter once when the sym is the method\n-                    \/\/ and once when the sym is the parameter.\n-                    scan(tree.mods);\n-                    scan(tree.vartype);\n-                }\n-                scan(tree.init);\n-            } finally {\n-                deferDecl = prevDecl;\n+            if (sym != null && sym.kind == VAR) {\n+                \/\/ Don't visit a parameter once when the sym is the method\n+                \/\/ and once when the sym is the parameter.\n+                scan(tree.mods);\n+                scan(tree.vartype);\n@@ -1153,0 +1126,1 @@\n+            scan(tree.init);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":17,"deletions":43,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -101,0 +102,1 @@\n+    final LintMapper lintMapper;\n@@ -119,1 +121,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -140,0 +141,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -159,1 +161,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -856,1 +857,0 @@\n-        deferredLintHandler.push(variable);\n@@ -872,1 +872,0 @@\n-            deferredLintHandler.pop();\n@@ -1001,1 +1000,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1236,1 +1234,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m);\n@@ -1266,1 +1264,1 @@\n-                        tree.vartype = make.Erroneous();\n+                        tree.vartype = make.at(tree.pos()).Erroneous();\n@@ -1273,1 +1271,1 @@\n-                            tree.vartype = make.Erroneous();\n+                            tree.vartype = make.at(tree.pos()).Erroneous();\n@@ -1300,1 +1298,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1345,1 +1342,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym);\n@@ -1442,1 +1439,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);\n+            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner);\n@@ -1955,1 +1952,1 @@\n-            env.info.lint.logIfEnabled(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n+            log.warning(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n@@ -2057,1 +2054,1 @@\n-                env.info.lint.logIfEnabled(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n+                log.warning(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n@@ -4229,1 +4226,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n+        annotate.annotateLater(tree.var.mods.annotations, env, v);\n@@ -4231,1 +4228,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v);\n@@ -4469,1 +4466,1 @@\n-            env.info.lint.logIfEnabled(tree, LintWarnings.TryExplicitCloseCall);\n+            log.warning(tree, LintWarnings.TryExplicitCloseCall);\n@@ -4496,1 +4493,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n@@ -4498,1 +4495,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n@@ -5300,0 +5297,3 @@\n+\n+        \/\/ Now that this tree is attributed, we can calculate the Lint configuration everywhere within it\n+        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree, env.toplevel.endPositions);\n@@ -5342,1 +5342,0 @@\n-            deferredLintHandler.flush(env.tree, lint);\n@@ -5526,1 +5525,0 @@\n-                deferredLintHandler.flush(env.tree, env.info.lint);\n@@ -5572,3 +5570,0 @@\n-        chk.checkModuleName(tree);\n-        chk.checkDeprecatedAnnotation(tree, msym);\n-\n@@ -5576,1 +5571,2 @@\n-            deferredLintHandler.flush(tree, lint);\n+            chk.checkModuleName(tree);\n+            chk.checkDeprecatedAnnotation(tree, msym);\n@@ -5714,0 +5710,3 @@\n+        } else if (tree.declaredUsingVar()) {\n+            Assert.check(tree.typePos != Position.NOPOS);\n+            tree.vartype = make.at(tree.typePos).Type(type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    Lint lint;\n+    private Lint lint;\n@@ -167,2 +167,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-\n@@ -183,4 +181,0 @@\n-    \/** A handler for deferred lint warnings.\n-     *\/\n-    private DeferredLintHandler deferredLintHandler;\n-\n@@ -232,18 +226,9 @@\n-        LintWarning warningKey = null;\n-        if (sym.isDeprecatedForRemoval()) {\n-            if (!lint.isSuppressed(LintCategory.REMOVAL)) {\n-                if (sym.kind == MDL) {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemovalModule(sym);\n-                } else {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location());\n-                }\n-            }\n-        } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {\n-            if (sym.kind == MDL) {\n-                warningKey = LintWarnings.HasBeenDeprecatedModule(sym);\n-            } else {\n-                warningKey = LintWarnings.HasBeenDeprecated(sym, sym.location());\n-            }\n-        }\n-        if (warningKey != null)\n-            log.warning(pos, warningKey);\n+        Assert.check(!importSuppression);\n+        LintWarning warningKey = sym.isDeprecatedForRemoval() ?\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedForRemovalModule(sym) :\n+                LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location())) :\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedModule(sym) :\n+                LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+        log.warning(pos, warningKey);\n@@ -257,1 +242,1 @@\n-        if (!importSuppression && !lint.isSuppressed(LintCategory.PREVIEW))\n+        if (!importSuppression)\n@@ -261,8 +246,0 @@\n-    \/** Log a preview warning.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param msg        A Warning describing the problem.\n-     *\/\n-    public void warnRestrictedAPI(DiagnosticPosition pos, Symbol sym) {\n-        lint.logIfEnabled(pos, LintWarnings.RestrictedMethod(sym.enclClass(), sym));\n-    }\n-\n@@ -274,2 +251,1 @@\n-        if (!lint.isSuppressed(LintCategory.UNCHECKED))\n-            log.warning(pos, warnKey);\n+        log.warning(pos, warnKey);\n@@ -611,3 +587,1 @@\n-            deferredLintHandler.report(_l -> {\n-                lint.logIfEnabled(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n-            });\n+            log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n@@ -917,1 +891,1 @@\n-            lint.logIfEnabled(tree, LintWarnings.VarargsRedundantTrustmeAnno(\n+            log.warning(tree.pos(), LintWarnings.VarargsRedundantTrustmeAnno(\n@@ -1176,1 +1150,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1220,1 +1194,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1284,10 +1258,0 @@\n-    private void warnOnExplicitStrictfp(JCTree tree) {\n-        deferredLintHandler.push(tree);\n-        try {\n-            deferredLintHandler.report(_ -> lint.logIfEnabled(tree.pos(), LintWarnings.Strictfp));\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n-    }\n-\n-\n@@ -1506,1 +1470,1 @@\n-            lint.logIfEnabled(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n+            log.warning(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n@@ -1830,1 +1794,1 @@\n-            lint.logIfEnabled(TreeInfo.diagnosticPositionFor(m, tree),\n+            log.warning(TreeInfo.diagnosticPositionFor(m, tree),\n@@ -1844,6 +1808,1 @@\n-            Lint prevLint = setLint(lint.augment(m));\n-            try {\n-                checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n-            } finally {\n-                setLint(prevLint);\n-            }\n+            checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n@@ -2918,7 +2877,2 @@\n-        final Lint prevLint = setLint(warnOnAnyAccessToMembers ? lint.enable(LintCategory.SERIAL) : lint);\n-        try {\n-            if (warnOnAnyAccessToMembers || isLambda)\n-                checkAccessFromSerializableElementInner(tree, isLambda);\n-        } finally {\n-            setLint(prevLint);\n-        }\n+        if (warnOnAnyAccessToMembers || isLambda)\n+            checkAccessFromSerializableElementInner(tree, isLambda);\n@@ -2928,5 +2882,4 @@\n-        if (lint.isEnabled(LintCategory.SERIAL)) {\n-            Symbol sym = TreeInfo.symbol(tree);\n-            if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n-                return;\n-            }\n+        Symbol sym = TreeInfo.symbol(tree);\n+        if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n+            return;\n+        }\n@@ -2934,7 +2887,6 @@\n-            if (sym.kind == VAR) {\n-                if ((sym.flags() & PARAMETER) != 0 ||\n-                    sym.isDirectlyOrIndirectlyLocal() ||\n-                    sym.name == names._this ||\n-                    sym.name == names._super) {\n-                    return;\n-                }\n+        if (sym.kind == VAR) {\n+            if ((sym.flags() & PARAMETER) != 0 ||\n+                sym.isDirectlyOrIndirectlyLocal() ||\n+                sym.name == names._this ||\n+                sym.name == names._super) {\n+                return;\n@@ -2942,0 +2894,1 @@\n+        }\n@@ -2943,10 +2896,5 @@\n-            if (!types.isSubtype(sym.owner.type, syms.serializableType) &&\n-                isEffectivelyNonPublic(sym)) {\n-                if (isLambda) {\n-                    if (belongsToRestrictedPackage(sym)) {\n-                        log.warning(tree.pos(),\n-                                    LintWarnings.AccessToMemberFromSerializableLambda(sym));\n-                    }\n-                } else {\n-                    log.warning(tree.pos(),\n-                                LintWarnings.AccessToMemberFromSerializableElement(sym));\n+        if (!types.isSubtype(sym.owner.type, syms.serializableType) && isEffectivelyNonPublic(sym)) {\n+            DiagnosticFlag flag = warnOnAnyAccessToMembers ? DiagnosticFlag.DEFAULT_ENABLED : null;\n+            if (isLambda) {\n+                if (belongsToRestrictedPackage(sym)) {\n+                    log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableLambda(sym));\n@@ -2954,0 +2902,2 @@\n+            } else {\n+                log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableElement(sym));\n@@ -3740,2 +3690,1 @@\n-                log.warning(pos,\n-                            LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n+                log.warning(pos, LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n@@ -3755,1 +3704,1 @@\n-            deferredLintHandler.report(_l -> warnDeprecated(pos.get(), s));\n+            warnDeprecated(pos.get(), s);\n@@ -3761,3 +3710,1 @@\n-            deferredLintHandler.report(_l -> {\n-                log.warning(pos, Warnings.SunProprietary(s));\n-            });\n+            log.warning(pos, Warnings.SunProprietary(s));\n@@ -3820,1 +3767,1 @@\n-            deferredLintHandler.report(_l -> warnRestrictedAPI(pos, s));\n+            log.warning(pos, LintWarnings.RestrictedMethod(s.enclClass(), s));\n@@ -4092,1 +4039,1 @@\n-                deferredLintHandler.report(_ -> lint.logIfEnabled(pos, LintWarnings.DivZero));\n+                log.warning(pos, LintWarnings.DivZero);\n@@ -4105,2 +4052,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PossibleLossOfPrecision(found, req)));\n+            log.warning(pos, LintWarnings.PossibleLossOfPrecision(found, req));\n@@ -4115,1 +4061,1 @@\n-            lint.logIfEnabled(tree.thenpart.pos(), LintWarnings.EmptyIf);\n+            log.warning(tree.thenpart.pos(), LintWarnings.EmptyIf);\n@@ -4262,2 +4208,1 @@\n-            lint.logIfEnabled(pos,\n-                        LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n+            log.warning(pos, LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n@@ -4305,2 +4250,1 @@\n-                            deferredLintHandler.report(_ ->\n-                                lint.logIfEnabled(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle)));\n+                            log.warning(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle));\n@@ -4342,1 +4286,1 @@\n-                        Check.this.lint.logIfEnabled(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n+                        log.warning(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n@@ -4640,2 +4584,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.ModuleNotFound(msym)));\n+            log.warning(pos, LintWarnings.ModuleNotFound(msym));\n@@ -4648,2 +4591,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PackageEmptyOrNotFound(packge)));\n+            log.warning(pos, LintWarnings.PackageEmptyOrNotFound(packge));\n@@ -4655,7 +4597,5 @@\n-            deferredLintHandler.report(_ -> {\n-                if (rd.isTransitive() && lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {\n-                    log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n-                } else {\n-                    lint.logIfEnabled(pos, LintWarnings.RequiresAutomatic);\n-                }\n-            });\n+            if (rd.isTransitive()) {    \/\/ see comment in Log.applyLint() for special logic that applies\n+                log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n+            } else {\n+                log.warning(pos, LintWarnings.RequiresAutomatic);\n+            }\n@@ -5696,1 +5636,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5703,1 +5643,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5730,1 +5670,1 @@\n-                lint.logIfEnabled(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                log.warning(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5807,1 +5747,1 @@\n-                        .forEach(ta -> lint.logIfEnabled(typeParamTrees.get(ta.position.parameter_index).pos(),\n+                        .forEach(ta -> log.warning(typeParamTrees.get(ta.position.parameter_index).pos(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":60,"deletions":120,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -217,1 +217,0 @@\n-    private       Lint lint;\n@@ -340,1 +339,0 @@\n-        lint = Lint.instance(context);\n@@ -565,1 +563,0 @@\n-            Lint lintPrev = lint;\n@@ -568,1 +565,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -599,1 +595,0 @@\n-                lint = lintPrev;\n@@ -605,3 +600,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -611,4 +603,3 @@\n-            try {\n-                alive = Liveness.ALIVE;\n-                scanStat(tree.body);\n-                tree.completesNormally = alive != Liveness.DEAD;\n+            alive = Liveness.ALIVE;\n+            scanStat(tree.body);\n+            tree.completesNormally = alive != Liveness.DEAD;\n@@ -616,2 +607,2 @@\n-                if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n-                    log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n+            if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n+                log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n@@ -619,4 +610,1 @@\n-                clearPendingExits(true);\n-            } finally {\n-                lint = lintPrev;\n-            }\n+            clearPendingExits(true);\n@@ -637,9 +625,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -727,2 +707,1 @@\n-                    lint.logIfEnabled(l.tail.head.pos(),\n-                                LintWarnings.PossibleFallThroughIntoCase);\n+                    log.warning(l.tail.head.pos(), LintWarnings.PossibleFallThroughIntoCase);\n@@ -1235,1 +1214,1 @@\n-                    lint.logIfEnabled(TreeInfo.diagEndPos(tree.finalizer),\n+                    log.warning(TreeInfo.diagEndPos(tree.finalizer),\n@@ -1456,1 +1435,0 @@\n-            Lint lintPrev = lint;\n@@ -1464,1 +1442,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -1513,1 +1490,0 @@\n-                lint = lintPrev;\n@@ -1522,3 +1498,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -1557,1 +1530,0 @@\n-                lint = lintPrev;\n@@ -1562,9 +1534,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -2390,7 +2354,4 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try {\n-                JCClassDecl classDefPrev = classDef;\n-                int firstadrPrev = firstadr;\n-                int nextadrPrev = nextadr;\n-                ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n+            JCClassDecl classDefPrev = classDef;\n+            int firstadrPrev = firstadr;\n+            int nextadrPrev = nextadr;\n+            ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n@@ -2398,15 +2359,14 @@\n-                pendingExits = new ListBuffer<>();\n-                if (tree.name != names.empty) {\n-                    firstadr = nextadr;\n-                }\n-                classDef = tree;\n-                try {\n-                    \/\/ define all the static fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) != 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+            pendingExits = new ListBuffer<>();\n+            if (tree.name != names.empty) {\n+                firstadr = nextadr;\n+            }\n+            classDef = tree;\n+            try {\n+                \/\/ define all the static fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) != 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2416,0 +2376,1 @@\n+                }\n@@ -2417,5 +2378,5 @@\n-                    \/\/ process all the static initializers\n-                    forEachInitializer(tree, true, def -> {\n-                        scan(def);\n-                        clearPendingExits(false);\n-                    });\n+                \/\/ process all the static initializers\n+                forEachInitializer(tree, true, def -> {\n+                    scan(def);\n+                    clearPendingExits(false);\n+                });\n@@ -2423,7 +2384,6 @@\n-                    \/\/ verify all static final fields got initialized\n-                    for (int i = firstadr; i < nextadr; i++) {\n-                        JCVariableDecl vardecl = vardecls[i];\n-                        VarSymbol var = vardecl.sym;\n-                        if (var.owner == classDef.sym && var.isStatic()) {\n-                            checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n-                        }\n+                \/\/ verify all static final fields got initialized\n+                for (int i = firstadr; i < nextadr; i++) {\n+                    JCVariableDecl vardecl = vardecls[i];\n+                    VarSymbol var = vardecl.sym;\n+                    if (var.owner == classDef.sym && var.isStatic()) {\n+                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2431,0 +2391,1 @@\n+                }\n@@ -2432,9 +2393,8 @@\n-                    \/\/ define all the instance fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) == 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+                \/\/ define all the instance fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) == 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2444,0 +2404,1 @@\n+                }\n@@ -2445,5 +2406,4 @@\n-                    \/\/ process all the methods\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(METHODDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the methods\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(METHODDEF)) {\n+                        scan(l.head);\n@@ -2451,0 +2411,1 @@\n+                }\n@@ -2452,5 +2413,4 @@\n-                    \/\/ process all the nested classes\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(CLASSDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the nested classes\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(CLASSDEF)) {\n+                        scan(l.head);\n@@ -2458,5 +2418,0 @@\n-                } finally {\n-                    pendingExits = pendingExitsPrev;\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    classDef = classDefPrev;\n@@ -2465,1 +2420,4 @@\n-                lint = lintPrev;\n+                pendingExits = pendingExitsPrev;\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                classDef = classDefPrev;\n@@ -2480,2 +2438,8 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n+            final Bits initsPrev = new Bits(inits);\n+            final Bits uninitsPrev = new Bits(uninits);\n+            int nextadrPrev = nextadr;\n+            int firstadrPrev = firstadr;\n+            int returnadrPrev = returnadr;\n+\n+            Assert.check(pendingExits.isEmpty());\n+            boolean isConstructorPrev = isConstructor;\n@@ -2483,15 +2447,1 @@\n-                final Bits initsPrev = new Bits(inits);\n-                final Bits uninitsPrev = new Bits(uninits);\n-                int nextadrPrev = nextadr;\n-                int firstadrPrev = firstadr;\n-                int returnadrPrev = returnadr;\n-\n-                Assert.check(pendingExits.isEmpty());\n-                boolean isConstructorPrev = isConstructor;\n-                try {\n-                    isConstructor = TreeInfo.isConstructor(tree);\n-\n-                    \/\/ We only track field initialization inside constructors\n-                    if (!isConstructor) {\n-                        firstadr = nextadr;\n-                    }\n+                isConstructor = TreeInfo.isConstructor(tree);\n@@ -2499,42 +2449,44 @@\n-                    \/\/ Mark all method parameters as DA\n-                    for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n-                        JCVariableDecl def = l.head;\n-                        scan(def);\n-                        Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n-                        \/*  If we are executing the code from Gen, then there can be\n-                         *  synthetic or mandated variables, ignore them.\n-                         *\/\n-                        initParam(def);\n-                    }\n-                    \/\/ else we are in an instance initializer block;\n-                    \/\/ leave caught unchanged.\n-                    scan(tree.body);\n-\n-                    boolean isCompactOrGeneratedRecordConstructor = (tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n-                            (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD);\n-                    if (isConstructor) {\n-                        boolean isSynthesized = (tree.sym.flags() &\n-                                                 GENERATEDCONSTR) != 0;\n-                        for (int i = firstadr; i < nextadr; i++) {\n-                            JCVariableDecl vardecl = vardecls[i];\n-                            VarSymbol var = vardecl.sym;\n-                            if (var.owner == classDef.sym && !var.isStatic()) {\n-                                \/\/ choose the diagnostic position based on whether\n-                                \/\/ the ctor is default(synthesized) or not\n-                                if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n-                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n-                                            var, Errors.VarNotInitializedInDefaultConstructor(var));\n-                                } else if (isCompactOrGeneratedRecordConstructor) {\n-                                    boolean isInstanceRecordField = var.enclClass().isRecord() &&\n-                                            (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n-                                            var.owner.kind == TYP;\n-                                    if (isInstanceRecordField) {\n-                                        boolean notInitialized = !inits.isMember(var.adr);\n-                                        if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n-                                        \/*  this way we indicate Lower that it should generate an initialization for this field\n-                                         *  in the compact constructor\n-                                         *\/\n-                                            var.flags_field |= UNINITIALIZED_FIELD;\n-                                        } else {\n-                                            checkInit(TreeInfo.diagEndPos(tree.body), var);\n-                                        }\n+                \/\/ We only track field initialization inside constructors\n+                if (!isConstructor) {\n+                    firstadr = nextadr;\n+                }\n+\n+                \/\/ Mark all method parameters as DA\n+                for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n+                    JCVariableDecl def = l.head;\n+                    scan(def);\n+                    Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n+                    \/*  If we are executing the code from Gen, then there can be\n+                     *  synthetic or mandated variables, ignore them.\n+                     *\/\n+                    initParam(def);\n+                }\n+                \/\/ else we are in an instance initializer block;\n+                \/\/ leave caught unchanged.\n+                scan(tree.body);\n+\n+                boolean isCompactOrGeneratedRecordConstructor = (tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+                        (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD);\n+                if (isConstructor) {\n+                    boolean isSynthesized = (tree.sym.flags() &\n+                                             GENERATEDCONSTR) != 0;\n+                    for (int i = firstadr; i < nextadr; i++) {\n+                        JCVariableDecl vardecl = vardecls[i];\n+                        VarSymbol var = vardecl.sym;\n+                        if (var.owner == classDef.sym && !var.isStatic()) {\n+                            \/\/ choose the diagnostic position based on whether\n+                            \/\/ the ctor is default(synthesized) or not\n+                            if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n+                                checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n+                                        var, Errors.VarNotInitializedInDefaultConstructor(var));\n+                            } else if (isCompactOrGeneratedRecordConstructor) {\n+                                boolean isInstanceRecordField = var.enclClass().isRecord() &&\n+                                        (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n+                                        var.owner.kind == TYP;\n+                                if (isInstanceRecordField) {\n+                                    boolean notInitialized = !inits.isMember(var.adr);\n+                                    if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n+                                    \/*  this way we indicate Lower that it should generate an initialization for this field\n+                                     *  in the compact constructor\n+                                     *\/\n+                                        var.flags_field |= UNINITIALIZED_FIELD;\n@@ -2542,1 +2494,1 @@\n-                                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n+                                        checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2545,1 +2497,1 @@\n-                                    checkInit(TreeInfo.diagEndPos(tree.body), var);\n+                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2547,0 +2499,2 @@\n+                            } else {\n+                                checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2550,8 +2504,0 @@\n-                    clearPendingExits(true);\n-                } finally {\n-                    inits.assign(initsPrev);\n-                    uninits.assign(uninitsPrev);\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    returnadr = returnadrPrev;\n-                    isConstructor = isConstructorPrev;\n@@ -2559,0 +2505,1 @@\n+                clearPendingExits(true);\n@@ -2560,1 +2507,6 @@\n-                lint = lintPrev;\n+                inits.assign(initsPrev);\n+                uninits.assign(uninitsPrev);\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                returnadr = returnadrPrev;\n+                isConstructor = isConstructorPrev;\n@@ -2588,12 +2540,8 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try{\n-                boolean track = trackable(tree.sym);\n-                if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n-                    newVar(tree);\n-                }\n-                if (tree.init != null) {\n-                    scanExpr(tree.init);\n-                    if (track) {\n-                        letInit(tree.pos(), tree.sym);\n-                    }\n+            boolean track = trackable(tree.sym);\n+            if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n+                newVar(tree);\n+            }\n+            if (tree.init != null) {\n+                scanExpr(tree.init);\n+                if (track) {\n+                    letInit(tree.pos(), tree.sym);\n@@ -2601,2 +2549,0 @@\n-            } finally {\n-                lint = lintPrev;\n@@ -2854,2 +2800,1 @@\n-            if (!resourceVarDecls.isEmpty() &&\n-                    lint.isEnabled(Lint.LintCategory.TRY)) {\n+            if (!resourceVarDecls.isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":136,"deletions":191,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -90,1 +89,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -197,10 +195,5 @@\n-        deferredLintHandler.push(tree);\n-        try {\n-            \/\/ Compute the method type\n-            m.type = signature(m, tree.typarams, tree.params,\n-                               tree.restype, tree.recvparam,\n-                               tree.thrown,\n-                               localEnv);\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n+        \/\/ Compute the method type\n+        m.type = signature(m, tree.typarams, tree.params,\n+                           tree.restype, tree.recvparam,\n+                           tree.thrown,\n+                           localEnv);\n@@ -230,1 +223,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, m);\n@@ -233,1 +226,1 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree);\n+        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m);\n@@ -237,1 +230,1 @@\n-            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree);\n+            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m);\n@@ -266,1 +259,0 @@\n-        deferredLintHandler.push(tree);\n@@ -268,10 +260,6 @@\n-        try {\n-            if (TreeInfo.isEnumInit(tree)) {\n-                attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n-            } else if (!tree.isImplicitlyTyped()) {\n-                attr.attribType(tree.vartype, localEnv);\n-                if (TreeInfo.isReceiverParam(tree))\n-                    checkReceiver(tree, localEnv);\n-            }\n-        } finally {\n-            deferredLintHandler.pop();\n+        if (TreeInfo.isEnumInit(tree)) {\n+            attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n+        } else if (!tree.isImplicitlyTyped()) {\n+            attr.attribType(tree.vartype, localEnv);\n+            if (TreeInfo.isReceiverParam(tree))\n+                checkReceiver(tree, localEnv);\n@@ -318,1 +306,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, v);\n@@ -320,1 +308,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -65,1 +64,1 @@\n-import com.sun.tools.javac.code.Flags.Flag;\n+import com.sun.tools.javac.code.FlagsEnum;\n@@ -144,1 +143,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -172,2 +170,0 @@\n-    private final boolean lintOptions;\n-\n@@ -196,1 +192,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -208,2 +203,0 @@\n-        lintOptions = !options.isLintDisabled(LintCategory.OPTIONS);\n-\n@@ -749,1 +742,0 @@\n-                deferredLintHandler.push(moduleDecl);\n@@ -757,1 +749,0 @@\n-                    deferredLintHandler.pop();\n@@ -828,1 +819,1 @@\n-                        log.error(tree.pos(), Errors.ModNotAllowedHere(EnumSet.of(Flag.STATIC)));\n+                        log.error(tree.pos(), Errors.ModNotAllowedHere(EnumSet.of(FlagsEnum.STATIC)));\n@@ -994,1 +985,0 @@\n-            deferredLintHandler.push(decl);\n@@ -1000,1 +990,0 @@\n-                deferredLintHandler.pop();\n@@ -1266,6 +1255,3 @@\n-            if (lintOptions) {\n-                for (ModuleSymbol msym : limitMods) {\n-                    if (!observable.contains(msym)) {\n-                        log.warning(\n-                                LintWarnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n-                    }\n+            for (ModuleSymbol msym : limitMods) {\n+                if (!observable.contains(msym)) {\n+                    log.warning(LintWarnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n@@ -1724,4 +1710,1 @@\n-            if (lintOptions) {\n-                log.warning(\n-                        LintWarnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n-            }\n+            log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n@@ -1763,3 +1746,1 @@\n-                if (lintOptions) {\n-                    log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n-                }\n+                log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n@@ -1783,3 +1764,1 @@\n-                        if (lintOptions) {\n-                            log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n-                        }\n+                        log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":8,"deletions":29,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -60,0 +61,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -70,0 +72,1 @@\n+import static com.sun.tools.javac.util.Position.NOPOS;\n@@ -159,1 +162,1 @@\n-    private       Lint lint;\n+    private final LintMapper lintMapper;\n@@ -171,4 +174,0 @@\n-    \/** Contains symbols of fields and constructors that have warnings suppressed.\n-     *\/\n-    private final Set<Symbol> suppressed = new HashSet<>();\n-\n@@ -234,1 +233,1 @@\n-        lint = Lint.instance(context);\n+        lintMapper = LintMapper.instance(context);\n@@ -265,2 +264,2 @@\n-        \/\/ Short circuit if warnings are totally disabled\n-        if (!lint.isEnabled(THIS_ESCAPE))\n+        \/\/ Short circuit if this calculation is unnecessary\n+        if (!lintMapper.lintAt(env.toplevel.sourcefile, env.tree.pos()).get().isEnabled(THIS_ESCAPE))\n@@ -281,1 +280,0 @@\n-        \/\/ Track which constructors and fields have warnings suppressed.\n@@ -285,1 +283,0 @@\n-            private Lint lint = ThisEscapeAnalyzer.this.lint;\n@@ -293,2 +290,0 @@\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n@@ -309,18 +304,0 @@\n-                    lint = lintPrev;\n-                }\n-            }\n-\n-            @Override\n-            public void visitVarDef(JCVariableDecl tree) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try {\n-\n-                    \/\/ Track warning suppression of fields\n-                    if (tree.sym.owner.kind == TYP && !lint.isEnabled(THIS_ESCAPE))\n-                        suppressed.add(tree.sym);\n-\n-                    \/\/ Recurse\n-                    super.visitVarDef(tree);\n-                } finally {\n-                    lint = lintPrev;\n@@ -332,7 +309,0 @@\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try {\n-\n-                    \/\/ Track warning suppression of constructors\n-                    if (TreeInfo.isConstructor(tree) && !lint.isEnabled(THIS_ESCAPE))\n-                        suppressed.add(tree.sym);\n@@ -340,5 +310,5 @@\n-                    \/\/ Gather some useful info\n-                    boolean constructor = TreeInfo.isConstructor(tree);\n-                    boolean extendableClass = currentClassIsExternallyExtendable();\n-                    boolean nonPrivate = (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0;\n-                    boolean finalish = (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n+                \/\/ Gather some useful info\n+                boolean constructor = TreeInfo.isConstructor(tree);\n+                boolean extendableClass = currentClassIsExternallyExtendable();\n+                boolean nonPrivate = (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0;\n+                boolean finalish = (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n@@ -346,2 +316,2 @@\n-                    \/\/ Determine if this is a constructor we should analyze\n-                    boolean analyzable = extendableClass && constructor && nonPrivate;\n+                \/\/ Determine if this is a constructor we should analyze\n+                boolean analyzable = extendableClass && constructor && nonPrivate;\n@@ -349,2 +319,2 @@\n-                    \/\/ Determine if it's safe to \"invoke\" the method in an analysis (i.e., it can't be overridden)\n-                    boolean invokable = !extendableClass || constructor || finalish;\n+                \/\/ Determine if it's safe to \"invoke\" the method in an analysis (i.e., it can't be overridden)\n+                boolean invokable = !extendableClass || constructor || finalish;\n@@ -352,2 +322,2 @@\n-                    \/\/ Add this method or constructor to our map\n-                    methodMap.put(tree.sym, new MethodInfo(currentClass, tree, constructor, analyzable, invokable));\n+                \/\/ Add this method or constructor to our map\n+                methodMap.put(tree.sym, new MethodInfo(currentClass, tree, constructor, analyzable, invokable));\n@@ -355,5 +325,2 @@\n-                    \/\/ Recurse\n-                    super.visitMethodDef(tree);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n+                \/\/ Recurse\n+                super.visitMethodDef(tree);\n@@ -404,1 +371,1 @@\n-                log.warning(frame.site.pos(), key);\n+                log.warning(frame.warningPos(), key);\n@@ -1749,0 +1716,8 @@\n+        DiagnosticPosition warningPos() {\n+            return site.pos().withLintPosition(NOPOS);      \/\/ disable normal Lint suppression\n+        }\n+\n+        Lint lint() {\n+            return lintMapper.lintAt(topLevelEnv.toplevel.sourcefile, site.pos()).get();\n+        }\n+\n@@ -1750,2 +1725,1 @@\n-            return suppressible &&\n-              suppressed.contains(initializer instanceof JCVariableDecl v ? v.sym : method.declaration.sym);\n+            return suppressible && !lint().isEnabled(THIS_ESCAPE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":30,"deletions":56,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -111,2 +110,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n-    private final Lint lint;\n@@ -138,2 +135,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-        lint = Lint.instance(context);\n@@ -277,1 +272,0 @@\n-                deferredLintHandler.push(tree);\n@@ -285,1 +279,0 @@\n-                    deferredLintHandler.pop();\n@@ -354,2 +347,0 @@\n-            deferredLintHandler.pushImmediate(lint);\n-            Lint prevLint = chk.setLint(lint);\n@@ -379,7 +370,2 @@\n-                    deferredLintHandler.push(decl);\n-                    try {\n-                        \/\/check @Deprecated:\n-                        markDeprecated(decl.sym, decl.mods.annotations, env);\n-                    } finally {\n-                        deferredLintHandler.pop();\n-                    }\n+                    \/\/check for @Deprecated annotations\n+                    markDeprecated(decl.sym, decl.mods.annotations, env);\n@@ -387,1 +373,1 @@\n-                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl);\n+                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle);\n@@ -391,2 +377,0 @@\n-                chk.setLint(prevLint);\n-                deferredLintHandler.pop();\n@@ -425,1 +409,1 @@\n-            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree);\n+            annotate.annotateLater(tree.annotations, env, env.toplevel.packge);\n@@ -917,1 +901,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym);\n@@ -919,1 +903,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym);\n@@ -934,1 +918,1 @@\n-            annotate.annotateLater(tree.mods.annotations, baseEnv, sym, tree);\n+            annotate.annotateLater(tree.mods.annotations, baseEnv, sym);\n@@ -938,1 +922,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        locations.update(log, lint, FSInfo.instance(context));\n+        locations.update(log, FSInfo.instance(context));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -86,0 +84,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -126,5 +125,0 @@\n-    \/**\n-     * The root {@link Lint} instance.\n-     *\/\n-    private Lint lint;\n-\n@@ -171,1 +165,1 @@\n-    void update(Log log, Lint lint, FSInfo fsInfo) {\n+    void update(Log log, FSInfo fsInfo) {\n@@ -173,1 +167,0 @@\n-        this.lint = lint;\n@@ -224,1 +217,1 @@\n-                    lint.logIfEnabled(LintWarnings.InvalidPath(s));\n+                    log.warning(LintWarnings.InvalidPath(s));\n@@ -319,1 +312,1 @@\n-                    lint.logIfEnabled(LintWarnings.DirPathElementNotFound(dir));\n+                    log.warning(LintWarnings.DirPathElementNotFound(dir));\n@@ -364,1 +357,1 @@\n-                    lint.logIfEnabled(LintWarnings.PathElementNotFound(file));\n+                    log.warning(LintWarnings.PathElementNotFound(file));\n@@ -386,1 +379,1 @@\n-                                lint.logIfEnabled(LintWarnings.UnexpectedArchiveFile(file));\n+                                log.warning(LintWarnings.UnexpectedArchiveFile(file));\n@@ -391,1 +384,1 @@\n-                                lint.logIfEnabled(LintWarnings.InvalidArchiveFile(file));\n+                                log.warning(LintWarnings.InvalidArchiveFile(file));\n@@ -1654,1 +1647,1 @@\n-                lint.logIfEnabled(Files.exists(prefix) ?\n+                log.warning(Files.exists(prefix) ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/Locations.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -142,3 +141,0 @@\n-    \/** The root Lint config. *\/\n-    Lint lint;\n-\n@@ -306,2 +302,0 @@\n-        lint = Lint.instance(context);\n-\n@@ -857,2 +851,1 @@\n-                        lint.logIfEnabled(\n-                                    LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n+                        log.warning(LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n@@ -1612,1 +1605,1 @@\n-            lint.logIfEnabled(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+            log.warning(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n@@ -2078,1 +2071,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFound(container, name));\n+                    log.warning(LintWarnings.AnnotationMethodNotFound(container, name));\n@@ -2080,1 +2073,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFoundReason(container,\n+                    log.warning(LintWarnings.AnnotationMethodNotFoundReason(container,\n@@ -2957,1 +2950,1 @@\n-        lint.logIfEnabled(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+        log.warning(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -506,6 +505,3 @@\n-                    boolean lintPaths = !options.isLintDisabled(LintCategory.PATH);\n-                    if (lintPaths) {\n-                        Path outDirParent = outDir.getParent();\n-                        if (outDirParent != null && Files.exists(outDirParent.resolve(\"module-info.class\"))) {\n-                            log.warning(LintWarnings.OutdirIsInExplodedModule(outDir));\n-                        }\n+                    Path outDirParent = outDir.getParent();\n+                    if (outDirParent != null && Files.exists(outDirParent.resolve(\"module-info.class\"))) {\n+                        log.warning(LintWarnings.OutdirIsInExplodedModule(outDir));\n@@ -579,2 +575,1 @@\n-        boolean lintOptions = !options.isLintDisabled(LintCategory.OPTIONS);\n-        if (lintOptions && source.compareTo(Source.DEFAULT) < 0 && !options.isSet(Option.RELEASE)) {\n+        if (source.compareTo(Source.DEFAULT) < 0 && !options.isSet(Option.RELEASE)) {\n@@ -583,1 +578,1 @@\n-                    if (baseFileManager.isDefaultBootClassPath())\n+                    if (baseFileManager.isDefaultBootClassPath()) {\n@@ -585,3 +580,3 @@\n-                } else {\n-                    if (baseFileManager.isDefaultSystemModulesPath())\n-                        log.warning(LintWarnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n+                    }\n+                } else if (baseFileManager.isDefaultSystemModulesPath()) {\n+                    log.warning(LintWarnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n@@ -596,1 +591,1 @@\n-        } else if (source == Source.MIN && lintOptions) {\n+        } else if (source == Source.MIN) {\n@@ -603,1 +598,1 @@\n-        } else if (target == Target.MIN && lintOptions) {\n+        } else if (target == Target.MIN) {\n@@ -637,1 +632,1 @@\n-        if (obsoleteOptionFound && lintOptions) {\n+        if (obsoleteOptionFound) {\n@@ -648,1 +643,1 @@\n-        if (lintOptions && options.isSet(Option.ADD_OPENS)) {\n+        if (options.isSet(Option.ADD_OPENS)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -261,0 +261,4 @@\n+    \/** The Lint mapper.\n+     *\/\n+    protected LintMapper lintMapper;\n+\n@@ -387,0 +391,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -578,0 +583,1 @@\n+        log.reportOutstandingWarnings();\n@@ -628,0 +634,1 @@\n+        lintMapper.startParsingFile(filename);\n@@ -647,0 +654,1 @@\n+        lintMapper.finishParsingFile(tree);\n@@ -1846,0 +1854,1 @@\n+        log.reportOutstandingWarnings();\n@@ -1919,0 +1928,1 @@\n+        lintMapper = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+        ensureEntered(\"getAllModuleElements\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -86,1 +84,1 @@\n-    private final Log log;\n+    protected final Log log;\n@@ -138,7 +136,0 @@\n-    \/**\n-     * The set of lint options currently in effect. It is initialized\n-     * from the context, and then is set\/reset as needed by Attr as it\n-     * visits all the various parts of the trees during attribution.\n-     *\/\n-    protected final Lint lint;\n-\n@@ -171,1 +162,0 @@\n-        this.lint = fac.lint;\n@@ -208,11 +198,0 @@\n-    \/**\n-     * Report a warning at the given position using the provided arguments.\n-     *\n-     * @param pos    position in input buffer.\n-     * @param key    error key to report.\n-     *\/\n-    protected void lexWarning(int pos, JCDiagnostic.LintWarning key) {\n-        DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;\n-        log.warning(dp, key);\n-    }\n-\n@@ -1063,11 +1042,6 @@\n-                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                        Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                TextBlockSupport.checkWhitespace(string);\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.InconsistentWhiteSpaceIndentation);\n-                        }\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n-                        }\n+                    Set<TextBlockSupport.WhitespaceChecks> checks = TextBlockSupport.checkWhitespace(string);\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                        log.warning(pos, LintWarnings.InconsistentWhiteSpaceIndentation);\n+                    }\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                        log.warning(pos, LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -119,2 +119,0 @@\n-    \/** Handler for deferred diagnostics. *\/\n-    protected final DeferredLintHandler deferredLintHandler;\n@@ -193,1 +191,0 @@\n-        this.deferredLintHandler = fac.deferredLintHandler;\n@@ -219,1 +216,0 @@\n-        this.deferredLintHandler = parser.deferredLintHandler;\n@@ -594,2 +590,1 @@\n-     *     dangling comments are also attached to the tree node\n-     *     by registering them using the {@link #deferredLintHandler}.\n+     *     dangling comments are reported to the log as warnings.\n@@ -656,6 +651,1 @@\n-            deferredLintHandler.push(tree);\n-            try {\n-                list.forEach(this::reportDanglingDocComment);\n-            } finally {\n-                deferredLintHandler.pop();\n-            }\n+            list.forEach(c -> reportDanglingDocComment(tree, c));\n@@ -666,1 +656,1 @@\n-     * Reports an individual dangling comment using the {@link #deferredLintHandler}.\n+     * Reports an individual dangling comment as a warning to the log.\n@@ -672,1 +662,1 @@\n-    void reportDanglingDocComment(Comment c) {\n+    void reportDanglingDocComment(JCTree tree, Comment c) {\n@@ -674,8 +664,3 @@\n-        if (pos != null) {\n-            deferredLintHandler.report(lint -> {\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n-                        !shebang(c, pos)) {\n-                    log.warning(\n-                            pos, LintWarnings.DanglingDocComment);\n-                }\n-            });\n+        if (pos != null && !shebang(c, pos)) {\n+            pos = pos.withLintPosition(tree.getStartPosition());\n+            S.lintWarning(pos, LintWarnings.DanglingDocComment);\n@@ -1008,0 +993,1 @@\n+            int varTypePos = Position.NOPOS;\n@@ -1012,0 +998,1 @@\n+                    varTypePos = e.pos;\n@@ -1049,1 +1036,3 @@\n-                JCVariableDecl var = toP(F.at(varPos).VarDef(mods, name, e, null));\n+                JCVariableDecl var = toP(F.at(varPos).VarDef(mods, name, e, null,\n+                  varTypePos != Position.NOPOS ? JCVariableDecl.DeclKind.VAR : JCVariableDecl.DeclKind.EXPLICIT,\n+                  varTypePos));\n@@ -1051,1 +1040,0 @@\n-                    var.startPos = pos;\n@@ -1119,0 +1107,5 @@\n+        if ((lastmode & TYPE) == 0) {\n+            \/\/if the mode was switched to expression while expecting type, wrap with Erroneous:\n+            result = F.Erroneous(List.of(result));\n+        }\n+\n@@ -1446,0 +1439,1 @@\n+        int startMode = mode;\n@@ -1775,0 +1769,3 @@\n+            if (typeArgs != null && (startMode & TYPE) != 0) {\n+                return F.at(pos).TypeApply(F.Erroneous(), typeArgs);\n+            }\n@@ -2193,1 +2190,2 @@\n-                    param.startPos = TreeInfo.getStartPos(param.vartype);\n+                    param.declKind = JCVariableDecl.DeclKind.VAR;\n+                    param.typePos = TreeInfo.getStartPos(param.vartype);\n@@ -3833,1 +3831,1 @@\n-        int startPos = Position.NOPOS;\n+        int varTypePos = Position.NOPOS;\n@@ -3845,0 +3843,1 @@\n+                    varTypePos = elemType.pos;\n@@ -3848,3 +3847,0 @@\n-                    startPos = TreeInfo.getStartPos(mods);\n-                    if (startPos == Position.NOPOS)\n-                        startPos = TreeInfo.getStartPos(type);\n@@ -3856,2 +3852,2 @@\n-        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n-        result.startPos = startPos;\n+        JCVariableDecl result = toP(F.at(pos).VarDef(mods, name, type, init,\n+          declaredUsingVar ? JCVariableDecl.DeclKind.VAR : JCVariableDecl.DeclKind.EXPLICIT, varTypePos));\n@@ -3971,2 +3967,5 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null,\n-                type != null && type.hasTag(IDENT) && ((JCIdent)type).name == names.var));\n+        boolean declaredUsingVar = type != null && type.hasTag(IDENT) && ((JCIdent)type).name == names.var;\n+        JCVariableDecl.DeclKind declKind = declaredUsingVar ? JCVariableDecl.DeclKind.VAR :\n+          type != null ? JCVariableDecl.DeclKind.EXPLICIT : JCVariableDecl.DeclKind.IMPLICIT;\n+        int typePos = type != null ? type.pos : pos;\n+        return toP(F.at(pos).VarDef(mods, name, type, null, declKind, typePos));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":32,"deletions":33,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -106,0 +108,8 @@\n+\n+    \/**\n+     * Report a warning that is subject to possible suppression by {@code @SuppressWarnings}.\n+     *\n+     * @param pos the lexical position at which the warning occurs\n+     * @param key the warning to report\n+     *\/\n+    void lintWarning(DiagnosticPosition pos, LintWarning key);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Lexer.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -73,1 +72,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -91,1 +89,0 @@\n-        this.deferredLintHandler = DeferredLintHandler.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ParserFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -153,0 +155,5 @@\n+    @Override\n+    public void lintWarning(DiagnosticPosition pos, LintWarning key) {\n+        tokenizer.log.warning(pos, key);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.code.Lint;\n@@ -65,1 +64,0 @@\n-    final Lint lint;\n@@ -77,1 +75,0 @@\n-        this.lint = Lint.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -170,4 +171,3 @@\n-        public void commit() {\n-            for (int i = 0 ; i < offset ; i++) {\n-                S.nextToken(); \/\/ advance underlying lexer until position matches\n-            }\n+        @Override\n+        public void lintWarning(DiagnosticPosition pos, LintWarning key) {\n+           \/\/ ignore\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Lint;\n@@ -65,1 +64,0 @@\n-import static com.sun.tools.javac.code.Lint.LintCategory.PROCESSING;\n@@ -341,1 +339,0 @@\n-    Lint lint;\n@@ -424,2 +421,0 @@\n-        lint = Lint.instance(context);\n-\n@@ -489,8 +484,6 @@\n-        if (lint.isEnabled(PROCESSING)) {\n-            int periodIndex = name.lastIndexOf(\".\");\n-            if (periodIndex != -1) {\n-                String base = name.substring(periodIndex);\n-                String extn = (isSourceFile ? \".java\" : \".class\");\n-                if (base.equals(extn))\n-                    log.warning(LintWarnings.ProcSuspiciousClassName(name, extn));\n-            }\n+        int periodIndex = name.lastIndexOf(\".\");\n+        if (periodIndex != -1) {\n+            String base = name.substring(periodIndex);\n+            String extn = (isSourceFile ? \".java\" : \".class\");\n+            if (base.equals(extn))\n+                log.warning(LintWarnings.ProcSuspiciousClassName(name, extn));\n@@ -710,1 +703,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcIllegalFileName(name));\n+            log.warning(LintWarnings.ProcIllegalFileName(name));\n@@ -738,1 +731,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcTypeRecreate(typename));\n+            log.warning(LintWarnings.ProcTypeRecreate(typename));\n@@ -742,1 +735,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcTypeAlreadyExists(typename));\n+            log.warning(LintWarnings.ProcTypeAlreadyExists(typename));\n@@ -771,1 +764,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcFileReopening(fileObject.getName()));\n+            log.warning(LintWarnings.ProcFileReopening(fileObject.getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacFiler.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-    private final Lint lint;\n@@ -209,1 +208,0 @@\n-        lint = Lint.instance(context);\n@@ -629,1 +627,1 @@\n-                       boolean allowModules, ProcessingEnvironment env, Lint lint) {\n+                       boolean allowModules, ProcessingEnvironment env) {\n@@ -650,2 +648,1 @@\n-                        add(importStringToPattern(allowModules, annotationPattern,\n-                                                  processor, log, lint));\n+                        add(importStringToPattern(allowModules, annotationPattern, processor, log));\n@@ -653,1 +650,1 @@\n-                        lint.logIfEnabled(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                        log.warning(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -666,1 +663,1 @@\n-                    lint.logIfEnabled(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    log.warning(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -674,2 +671,1 @@\n-                            lint.logIfEnabled(LintWarnings.ProcDuplicateOptionName(optionName,\n-                                                                         p.getClass().getName()));\n+                            log.warning(LintWarnings.ProcDuplicateOptionName(optionName, p.getClass().getName()));\n@@ -762,2 +758,1 @@\n-                                                           JavacProcessingEnvironment.this,\n-                                                           lint);\n+                                                           JavacProcessingEnvironment.this);\n@@ -891,1 +886,1 @@\n-        if (lint.isEnabled(PROCESSING) && unmatchedAnnotations.size() > 0) {\n+        if (unmatchedAnnotations.size() > 0) {\n@@ -1652,1 +1647,1 @@\n-    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, Lint lint) {\n+    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log) {\n@@ -1665,1 +1660,1 @@\n-                return warnAndNoMatches(s, p, log, lint);\n+                return warnAndNoMatches(s, p, log);\n@@ -1674,1 +1669,1 @@\n-            return warnAndNoMatches(s, p, log, lint);\n+            return warnAndNoMatches(s, p, log);\n@@ -1678,2 +1673,2 @@\n-    private static Pattern warnAndNoMatches(String s, Processor p, Log log, Lint lint) {\n-        lint.logIfEnabled(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n+    private static Pattern warnAndNoMatches(String s, Processor p, Log log) {\n+        log.warning(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1603,0 +1603,1 @@\n+# flags: default-enabled\n@@ -1927,1 +1928,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1933,1 +1934,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1939,1 +1940,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1950,1 +1951,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1962,1 +1963,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1968,1 +1969,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2197,0 +2198,1 @@\n+# flags: default-enabled\n@@ -2202,0 +2204,1 @@\n+# flags: default-enabled\n@@ -2227,0 +2230,1 @@\n+# flags: default-enabled\n@@ -2232,0 +2236,1 @@\n+# flags: default-enabled\n@@ -2244,0 +2249,1 @@\n+# flags: default-enabled\n@@ -2368,1 +2374,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2374,1 +2380,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2384,1 +2390,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2392,1 +2398,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2398,1 +2404,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2797,1 +2803,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3194,1 +3200,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3201,1 +3207,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3305,1 +3311,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3311,1 +3317,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3882,0 +3888,1 @@\n+# flags: default-enabled\n@@ -3898,0 +3905,1 @@\n+# flags: default-enabled\n@@ -4275,1 +4283,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1005,0 +1005,7 @@\n+\n+        public enum DeclKind {\n+            EXPLICIT,       \/\/ \"SomeType name\"\n+            IMPLICIT,       \/\/ \"name\"\n+            VAR,            \/\/ \"var name\"\n+        }\n+\n@@ -1017,4 +1024,4 @@\n-        \/** explicit start pos *\/\n-        public int startPos = Position.NOPOS;\n-        \/** declared using `var` *\/\n-        private boolean declaredUsingVar;\n+        \/** how the variable's type was declared *\/\n+        public DeclKind declKind;\n+        \/** a source code position to use for \"vartype\" when null (can happen if declKind != EXPLICIT) *\/\n+        public int typePos;\n@@ -1027,1 +1034,1 @@\n-            this(mods, name, vartype, init, sym, false);\n+            this(mods, name, vartype, init, sym, DeclKind.EXPLICIT, Position.NOPOS);\n@@ -1035,1 +1042,2 @@\n-                                 boolean declaredUsingVar) {\n+                                 DeclKind declKind,\n+                                 int typePos) {\n@@ -1041,1 +1049,2 @@\n-            this.declaredUsingVar = declaredUsingVar;\n+            this.declKind = declKind;\n+            this.typePos = typePos;\n@@ -1047,1 +1056,1 @@\n-            this(mods, null, vartype, null, null, false);\n+            this(mods, null, vartype, null, null, DeclKind.EXPLICIT, Position.NOPOS);\n@@ -1062,1 +1071,1 @@\n-            return declaredUsingVar;\n+            return declKind == DeclKind.VAR;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -727,1 +727,4 @@\n-                    printExpr(tree.vartype);\n+                    if (tree.vartype == null && tree.declaredUsingVar())\n+                        print(\"var\");\n+                    else\n+                        printExpr(tree.vartype);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -554,1 +554,1 @@\n-            return M.at(t.pos).VarDef(mods, t.name, vartype, init);\n+            return M.at(t.pos).VarDef(mods, t.name, vartype, init, t.declKind, t.typePos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -613,3 +613,1 @@\n-                if (node.startPos != Position.NOPOS) {\n-                    return node.startPos;\n-                } else if (node.mods.pos != Position.NOPOS) {\n+                if (node.mods.pos != Position.NOPOS) {\n@@ -617,5 +615,1 @@\n-                } else if (node.vartype == null || node.vartype.pos == Position.NOPOS) {\n-                    \/\/if there's no type (partially typed lambda parameter)\n-                    \/\/simply return node position\n-                    return node.pos;\n-                } else {\n+                } else if (node.vartype != null) {\n@@ -623,0 +617,2 @@\n+                } else if (node.typePos != Position.NOPOS) {\n+                    return node.typePos;\n@@ -624,0 +620,1 @@\n+                break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -240,2 +240,3 @@\n-    public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init, boolean declaredUsingVar) {\n-        JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null, declaredUsingVar);\n+    public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init,\n+      JCVariableDecl.DeclKind declKind, int typePos) {\n+        JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null, declKind, typePos);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -371,0 +371,30 @@\n+        \/** Get the position that determines which Lint configuration applies. *\/\n+        default int getLintPosition() {\n+            return getStartPosition();\n+        }\n+        \/** Create a new instance from this instance and the given lint position. *\/\n+        default DiagnosticPosition withLintPosition(int lintPos) {\n+            DiagnosticPosition orig = this;\n+            return new DiagnosticPosition() {\n+                @Override\n+                public JCTree getTree() {\n+                    return orig.getTree();\n+                }\n+                @Override\n+                public int getStartPosition() {\n+                    return orig.getStartPosition();\n+                }\n+                @Override\n+                public int getPreferredPosition() {\n+                    return orig.getPreferredPosition();\n+                }\n+                @Override\n+                public int getEndPosition(EndPosTable endPosTable) {\n+                    return orig.getEndPosition(endPosTable);\n+                }\n+                @Override\n+                public int getLintPosition() {\n+                    return lintPos;\n+                }\n+            };\n+        }\n@@ -408,0 +438,4 @@\n+        \/** Flag for lint diagnostics that should be emitted even when their category\n+         *  is not explicitly enabled, as long as it is not explicitly suppressed.\n+         *\/\n+        DEFAULT_ENABLED,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n@@ -39,0 +41,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -45,0 +48,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -47,0 +51,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -48,0 +53,3 @@\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.comp.AttrContext;\n+import com.sun.tools.javac.comp.Env;\n@@ -51,1 +59,4 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -55,0 +66,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -58,0 +70,4 @@\n+import static com.sun.tools.javac.code.Lint.LintCategory.*;\n+import static com.sun.tools.javac.resources.CompilerProperties.LintWarnings.RequiresAutomatic;\n+import static com.sun.tools.javac.resources.CompilerProperties.LintWarnings.RequiresTransitiveAutomatic;\n+import static com.sun.tools.javac.tree.JCTree.Tag.*;\n@@ -106,0 +122,5 @@\n+        \/**\n+         * Diagnostics waiting for an applicable {@link Lint} instance.\n+         *\/\n+        protected Map<JavaFileObject, List<JCDiagnostic>> lintWaitersMap = new LinkedHashMap<>();\n+\n@@ -116,1 +137,57 @@\n-         * Handle a diagnostic.\n+         * Step 1: Handle a diagnostic for which the applicable Lint instance (if any) may not be known yet.\n+         *\/\n+        public final void report(JCDiagnostic diag) {\n+            Lint lint = null;\n+            LintCategory category = diag.getLintCategory();\n+            if (category != null) {                                         \/\/ this is a lint warning; find the applicable Lint\n+                DiagnosticPosition pos = diag.getDiagnosticPosition();\n+                if (pos != null && category.annotationSuppression) {        \/\/ we should apply the Lint from the warning's position\n+                    if ((lint = lintFor(diag)) == null) {\n+                        addLintWaiter(currentSourceFile(), diag);           \/\/ ...but we don't know it yet, so defer\n+                        return;\n+                    }\n+                } else                                                      \/\/ we should apply the root Lint\n+                    lint = rootLint();\n+            }\n+            reportWithLint(diag, lint);\n+        }\n+\n+        \/**\n+         * Step 2: Handle a diagnostic for which the applicable Lint instance (if any) is known and provided.\n+         *\/\n+        public final void reportWithLint(JCDiagnostic diag, Lint lint) {\n+\n+            \/\/ Apply hackery for REQUIRES_TRANSITIVE_AUTOMATIC (see also Check.checkModuleRequires())\n+            if (diag.getCode().equals(RequiresTransitiveAutomatic.key()) && !lint.isEnabled(REQUIRES_TRANSITIVE_AUTOMATIC)) {\n+                reportWithLint(\n+                  diags.warning(null, diag.getDiagnosticSource(), diag.getDiagnosticPosition(), RequiresAutomatic), lint);\n+                return;\n+            }\n+\n+            \/\/ Apply the lint configuration (if any) and discard the warning if it gets filtered out\n+            if (lint != null) {\n+                LintCategory category = diag.getLintCategory();\n+                boolean emit = !diag.isFlagSet(DEFAULT_ENABLED) ?       \/\/ is the warning not enabled by default?\n+                  lint.isEnabled(category) :                            \/\/ then emit if the category is enabled\n+                  category.annotationSuppression ?                      \/\/ else emit if the category is not suppressed, where\n+                    !lint.isSuppressed(category) :                      \/\/ ...suppression happens via @SuppressWarnings\n+                    !options.isLintDisabled(category);                  \/\/ ...suppression happens via -Xlint:-category\n+                if (!emit)\n+                    return;\n+            }\n+\n+            \/\/ Proceed\n+            reportReady(diag);\n+        }\n+\n+        \/**\n+         * Step 3: Handle a diagnostic to which the applicable Lint instance (if any) has been applied.\n+         *\/\n+        protected abstract void reportReady(JCDiagnostic diag);\n+\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diagnostic) {\n+            lintWaitersMap.computeIfAbsent(sourceFile, s -> new LinkedList<>()).add(diagnostic);\n+        }\n+\n+        \/**\n+         * Flush any lint waiters whose {@link Lint} configurations are now known.\n@@ -118,1 +195,28 @@\n-        public abstract void report(JCDiagnostic diag);\n+        public void flushLintWaiters() {\n+            lintWaitersMap.entrySet().removeIf(entry -> {\n+\n+                \/\/ Is the source file no longer recognized? If so, discard warnings (e.g., this can happen with JShell)\n+                JavaFileObject sourceFile = entry.getKey();\n+                if (!lintMapper.isKnown(sourceFile))\n+                    return true;\n+\n+                \/\/ Flush those diagnostics for which we now know the applicable Lint\n+                List<JCDiagnostic> diagnosticList = entry.getValue();\n+                JavaFileObject prevSourceFile = useSource(sourceFile);\n+                try {\n+                    diagnosticList.removeIf(diag -> {\n+                        Lint lint = lintFor(diag);\n+                        if (lint != null) {\n+                            reportWithLint(diag, lint);\n+                            return true;\n+                        }\n+                        return false;\n+                    });\n+                } finally {\n+                    useSource(prevSourceFile);\n+                }\n+\n+                \/\/ Discard list if empty\n+                return diagnosticList.isEmpty();\n+            });\n+        }\n@@ -127,1 +231,4 @@\n-        public void report(JCDiagnostic diag) { }\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diagnostic) { }\n+\n+        @Override\n+        protected void reportReady(JCDiagnostic diag) { }\n@@ -160,1 +267,1 @@\n-        public void report(JCDiagnostic diag) {\n+        protected void reportReady(JCDiagnostic diag) {\n@@ -164,1 +271,10 @@\n-                prev.report(diag);\n+                prev.reportReady(diag);\n+            }\n+        }\n+\n+        @Override\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diag) {\n+            if (deferrable(diag)) {\n+                super.addLintWaiter(sourceFile, diag);\n+            } else {\n+                prev.addLintWaiter(sourceFile, diag);\n@@ -185,0 +301,7 @@\n+\n+            \/\/ Flush matching Lint waiters to the previous handler\n+            lintWaitersMap.forEach(\n+              (sourceFile, diagnostics) -> diagnostics.stream()\n+                .filter(accepter)\n+                .forEach(diagnostic -> prev.addLintWaiter(sourceFile, diagnostic)));\n+            lintWaitersMap = null; \/\/ prevent accidental ongoing use\n@@ -250,0 +373,10 @@\n+    \/**\n+     * The {@link Options} singleton.\n+     *\/\n+    private final Options options;\n+\n+    \/**\n+     * The lint positions table.\n+     *\/\n+    private final LintMapper lintMapper;\n+\n@@ -353,0 +486,2 @@\n+        this.options = Options.instance(context);\n+        this.lintMapper = LintMapper.instance(context);\n@@ -372,1 +507,0 @@\n-        final Options options = Options.instance(context);\n@@ -692,0 +826,15 @@\n+\/\/ Deferred Lint Calculation\n+\n+    \/**\n+     * Report unreported lint warnings for which the applicable {@link Lint} configuration is now known.\n+     *\/\n+    public void reportOutstandingWarnings() {\n+        diagnosticHandler.flushLintWaiters();\n+    }\n+\n+    \/\/ Get the Lint config for the given warning (if known)\n+    private Lint lintFor(JCDiagnostic diag) {\n+        Assert.check(diag.getLintCategory() != null);\n+        return lintMapper.lintAt(diag.getSource(), diag.getDiagnosticPosition()).orElse(null);\n+    }\n+\n@@ -759,1 +908,1 @@\n-        public void report(JCDiagnostic diagnostic) {\n+        protected void reportReady(JCDiagnostic diagnostic) {\n@@ -786,1 +935,1 @@\n-                    boolean verbose = rootLint().isEnabled(category);\n+                    boolean verbose = lintFor(diagnostic).isEnabled(category);\n@@ -792,1 +941,1 @@\n-                if (diagnostic.isFlagSet(DiagnosticFlag.STRICT)) {\n+                if (diagnostic.isFlagSet(STRICT)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":159,"deletions":10,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -1464,2 +1464,1 @@\n-        case CKA_ECDSA_PARAMS:\n-            \/* CKA_EC_PARAMS is the same, these two are equivalent *\/\n+        case CKA_EC_PARAMS:\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-#define CK_ATTRIBUTES_TEMPLATE_LENGTH (CK_ULONG)61U\n+#define CK_ATTRIBUTES_TEMPLATE_LENGTH (CK_ULONG)60U\n@@ -61,0 +61,2 @@\n+\/\/ Group attributes based on their value types; put attributes whose values\n+\/\/ requiring address alignments, e.g. CK_ULONG, first\n@@ -62,7 +64,1 @@\n-        {CKA_CLASS, 0, 0},\n-        {CKA_TOKEN, 0, 0},\n-        {CKA_PRIVATE, 0, 0},\n-        {CKA_LABEL, 0, 0},\n-        {CKA_APPLICATION, 0, 0},\n-        {CKA_VALUE, 0, 0},\n-        {CKA_OBJECT_ID, 0, 0},\n+        \/\/ CK_ULONG\n@@ -70,6 +66,3 @@\n-        {CKA_ISSUER, 0, 0},\n-        {CKA_SERIAL_NUMBER, 0, 0},\n-        {CKA_AC_ISSUER, 0, 0},\n-        {CKA_OWNER, 0, 0},\n-        {CKA_ATTR_TYPES, 0, 0},\n-        {CKA_TRUSTED, 0, 0},\n+        {CKA_CLASS, 0, 0},\n+        {CKA_HW_FEATURE_TYPE, 0, 0},\n+        {CKA_KEY_GEN_MECHANISM, 0, 0},\n@@ -77,15 +70,0 @@\n-        {CKA_SUBJECT, 0, 0},\n-        {CKA_ID, 0, 0},\n-        {CKA_SENSITIVE, 0, 0},\n-        {CKA_ENCRYPT, 0, 0},\n-        {CKA_DECRYPT, 0, 0},\n-        {CKA_WRAP, 0, 0},\n-        {CKA_UNWRAP, 0, 0},\n-        {CKA_SIGN, 0, 0},\n-        {CKA_SIGN_RECOVER, 0, 0},\n-        {CKA_VERIFY, 0, 0},\n-        {CKA_VERIFY_RECOVER, 0, 0},\n-        {CKA_DERIVE, 0, 0},\n-        {CKA_START_DATE, 0, 0},\n-        {CKA_END_DATE, 0, 0},\n-        {CKA_MODULUS, 0, 0},\n@@ -93,10 +71,0 @@\n-        {CKA_PUBLIC_EXPONENT, 0, 0},\n-        {CKA_PRIVATE_EXPONENT, 0, 0},\n-        {CKA_PRIME_1, 0, 0},\n-        {CKA_PRIME_2, 0, 0},\n-        {CKA_EXPONENT_1, 0, 0},\n-        {CKA_EXPONENT_2, 0, 0},\n-        {CKA_COEFFICIENT, 0, 0},\n-        {CKA_PRIME, 0, 0},\n-        {CKA_SUBPRIME, 0, 0},\n-        {CKA_BASE, 0, 0},\n@@ -107,0 +75,5 @@\n+        \/\/ CK_BBOOL\n+        {CKA_ALWAYS_SENSITIVE, 0, 0},\n+        {CKA_DECRYPT, 0, 0},\n+        {CKA_DERIVE, 0, 0},\n+        {CKA_ENCRYPT, 0, 0},\n@@ -108,0 +81,1 @@\n+        {CKA_HAS_RESET, 0, 0},\n@@ -109,3 +83,0 @@\n-        {CKA_NEVER_EXTRACTABLE, 0, 0},\n-        {CKA_ALWAYS_SENSITIVE, 0, 0},\n-        {CKA_KEY_GEN_MECHANISM, 0, 0},\n@@ -113,1 +84,17 @@\n-        {CKA_ECDSA_PARAMS, 0, 0},\n+        {CKA_NEVER_EXTRACTABLE, 0, 0},\n+        {CKA_PRIVATE, 0, 0},\n+        {CKA_RESET_ON_INIT, 0, 0},\n+        {CKA_SENSITIVE, 0, 0},\n+        {CKA_SIGN, 0, 0},\n+        {CKA_SIGN_RECOVER, 0, 0},\n+        {CKA_TOKEN, 0, 0},\n+        {CKA_TRUSTED, 0, 0},\n+        {CKA_UNWRAP, 0, 0},\n+        {CKA_VERIFY, 0, 0},\n+        {CKA_VERIFY_RECOVER, 0, 0},\n+        {CKA_WRAP, 0, 0},\n+        \/\/ PTR: byte[]\n+        {CKA_AC_ISSUER, 0, 0},\n+        {CKA_ATTR_TYPES, 0, 0},\n+        {CKA_BASE, 0, 0},\n+        {CKA_COEFFICIENT, 0, 0},\n@@ -116,0 +103,23 @@\n+        {CKA_EXPONENT_1, 0, 0},\n+        {CKA_EXPONENT_2, 0, 0},\n+        {CKA_ID, 0, 0},\n+        {CKA_ISSUER, 0, 0},\n+        {CKA_MODULUS, 0, 0},\n+        {CKA_OBJECT_ID, 0, 0},\n+        {CKA_OWNER, 0, 0},\n+        {CKA_PRIME, 0, 0},\n+        {CKA_PRIME_1, 0, 0},\n+        {CKA_PRIME_2, 0, 0},\n+        {CKA_PRIVATE_EXPONENT, 0, 0},\n+        {CKA_PUBLIC_EXPONENT, 0, 0},\n+        {CKA_SERIAL_NUMBER, 0, 0},\n+        {CKA_SUBJECT, 0, 0},\n+        {CKA_SUBPRIME, 0, 0},\n+        {CKA_VALUE, 0, 0},\n+        \/\/ PTR: CK_UTF8CHAR[]\n+        {CKA_APPLICATION, 0, 0},\n+        {CKA_LABEL, 0, 0},\n+        \/\/ PTR: CK_DATE\n+        {CKA_START_DATE, 0, 0},\n+        {CKA_END_DATE, 0, 0},\n+        \/\/ deprecated\n@@ -118,3 +128,1 @@\n-        {CKA_HW_FEATURE_TYPE, 0, 0},\n-        {CKA_RESET_ON_INIT, 0, 0},\n-        {CKA_HAS_RESET, 0, 0},\n+        \/\/ misc\n@@ -122,0 +130,1 @@\n+        \/\/ keep this at the end to match the impl in getNativeKeyInfo(...)\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_keymgmt.c","additions":56,"deletions":47,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,0 @@\n-        jframe.setLocationRelativeTo(null);\n@@ -100,0 +99,1 @@\n+        jframe.setLocationRelativeTo(null);\n","filename":"src\/jdk.editpad\/share\/classes\/jdk\/editpad\/EditPad.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  private static Address sharedMetaspaceBaseAddr;\n-  private static Address sharedMetaspaceTopAddr;\n+  private static Address aotMetaspaceBaseAddr;\n+  private static Address aotMetaspaceTopAddr;\n@@ -48,2 +48,2 @@\n-    sharedMetaspaceBaseAddr = type.getAddressField(\"_shared_metaspace_base\").getStaticFieldAddress();\n-    sharedMetaspaceTopAddr  = type.getAddressField(\"_shared_metaspace_top\").getStaticFieldAddress();\n+    aotMetaspaceBaseAddr = type.getAddressField(\"_aot_metaspace_base\").getStaticFieldAddress();\n+    aotMetaspaceTopAddr  = type.getAddressField(\"_aot_metaspace_top\").getStaticFieldAddress();\n@@ -53,2 +53,2 @@\n-    Address base = sharedMetaspaceBaseAddr.getAddressAt(0);\n-    Address top  = sharedMetaspaceTopAddr. getAddressAt(0);\n+    Address base = aotMetaspaceBaseAddr.getAddressAt(0);\n+    Address top  = aotMetaspaceTopAddr. getAddressAt(0);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/MetaspaceObj.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,0 @@\n-    f = type.getField(\"_stack_locker\");\n-    stackLockerFieldOffset = f.getOffset();\n@@ -92,1 +90,0 @@\n-  public Address stackLocker() { return addr.getAddressAt(stackLockerFieldOffset); }\n@@ -123,1 +120,0 @@\n-  private static long          stackLockerFieldOffset;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        return new LazyDelegatingJdkConsoleImpl(inCharset, outCharset);\n+        return isTTY ? new LazyDelegatingJdkConsoleImpl(inCharset, outCharset) : null;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -361,2 +361,12 @@\n-            List<? extends DocTree> ref2 = transform(tree.reference);\n-            return (equal(ref2, tree.getReference()))\n+            \/\/ Some extra work is required to accommodate various forms of @see tags, as a\n+            \/\/ leading reference affects the position of the label following it (JDK-8356411),\n+            var ref = tree.reference;\n+            var hasReference = !ref.isEmpty() && ref.getFirst().getKind() == DocTree.Kind.REFERENCE;\n+            List<DCTree> transformed = new ArrayList<>();\n+            if (hasReference) {\n+                transformed.add(ref.getFirst());\n+                transformed.addAll(transform(ref.subList(1, ref.size())));\n+            } else {\n+                transformed.addAll(transform(ref));\n+            }\n+            return (equal(ref, transformed))\n@@ -364,1 +374,1 @@\n-                    : m.at(tree.pos).newSeeTree(ref2);\n+                    : m.at(tree.pos).newSeeTree(transformed);\n","filename":"src\/jdk.internal.md\/share\/classes\/jdk\/internal\/markdown\/MarkdownTransformer.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -290,1 +290,2 @@\n-        AVX10_2\n+        AVX10_2,\n+        HYBRID\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.LongFunction;\n@@ -33,1 +34,0 @@\n-import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n@@ -51,1 +51,2 @@\n-     * @param features bits specifying CPU features\n+     * @param bitMaskSupplier supplier to get the bit mask for the corresponding VM constant\n+     * @param featuresSupplier supplier to get the bits specifying CPU features\n@@ -60,1 +61,2 @@\n-                    long features,\n+                    LongFunction<Long> bitMaskSupplier,\n+                    LongFunction<Long> featuresSupplier,\n@@ -65,1 +67,1 @@\n-            long bitMask = e.getValue();\n+            long bitMask = bitMaskSupplier.apply(e.getValue());\n@@ -71,1 +73,1 @@\n-                    if ((features & bitMask) != 0) {\n+                    if ((featuresSupplier.apply(e.getValue()) & bitMask) != 0) {\n@@ -85,53 +87,0 @@\n-    \/**\n-     * Converts CPU features bit map into enum constants.\n-     *\n-     * @param <CPUFeatureType> CPU feature enum type\n-     * @param enumType the class of {@code CPUFeatureType}\n-     * @param constants VM constants. Each entry whose key starts with {@code \"VM_Version::CPU_\"}\n-     *            specifies a CPU feature and its value is a mask for a bit in {@code features}\n-     * @param featuresBitMapAddress pointer to {@code VM_Features::_features_bitmap} field of {@code VM_Version::_features}\n-     * @param featuresBitMapSize size of feature bit map in bytes\n-     * @param renaming maps from VM feature names to enum constant names where the two differ\n-     * @throws IllegalArgumentException if any VM CPU feature constant cannot be converted to an\n-     *             enum value\n-     * @return the set of converted values\n-     *\/\n-    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertFeatures(\n-                    Class<CPUFeatureType> enumType,\n-                    Map<String, Long> constants,\n-                    long featuresBitMapAddress,\n-                    long featuresBitMapSize,\n-                    Map<String, String> renaming) {\n-        EnumSet<CPUFeatureType> outFeatures = EnumSet.noneOf(enumType);\n-        List<String> missing = new ArrayList<>();\n-\n-        for (Entry<String, Long> e : constants.entrySet()) {\n-            String key = e.getKey();\n-            long bitIndex = e.getValue();\n-            if (key.startsWith(\"VM_Version::CPU_\")) {\n-                String name = key.substring(\"VM_Version::CPU_\".length());\n-                try {\n-                    final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n-                    final long featuresElementMask = (1L << featuresElementShiftCount) - 1;\n-\n-                    CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));\n-\n-                    long featureIndex = bitIndex >>> featuresElementShiftCount;\n-                    long featureBitMask = 1L << (bitIndex & featuresElementMask);\n-                    assert featureIndex < featuresBitMapSize;\n-\n-                    long featuresElement = UNSAFE.getLong(featuresBitMapAddress + featureIndex * Long.BYTES);\n-\n-                    if ((featuresElement & featureBitMask) != 0) {\n-                        outFeatures.add(feature);\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    missing.add(name);\n-                }\n-            }\n-        }\n-        if (!missing.isEmpty()) {\n-            throw new JVMCIError(\"Missing CPU feature constants: %s\", missing);\n-        }\n-        return outFeatures;\n-    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIBackendFactory.java","additions":7,"deletions":58,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -189,1 +189,4 @@\n-                            result.getCompiler();\n+                            \/\/ EagerJVMCI only applies to JVMCI when used by the CompileBroker.\n+                            if (result.getCompilerToVM().isCompilerThread()) {\n+                                result.getCompiler();\n+                            }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, idx -> 1L << idx, _ -> config.vmVersionFeatures, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/aarch64\/AArch64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+import jdk.internal.misc.Unsafe;\n@@ -53,5 +55,9 @@\n-        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class,\n-                                                                                  constants,\n-                                                                                  featuresBitMapAddress,\n-                                                                                  config.vmFeaturesFeaturesSize,\n-                                                                                  renaming);\n+        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, idx -> {\n+            final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n+            final long featuresElementMask = (1L << featuresElementShiftCount) - 1;\n+            return 1L << (idx & featuresElementMask);\n+        }, idx -> {\n+            final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n+            long featureIndex = idx >>> featuresElementShiftCount;\n+            return Unsafe.getUnsafe().getLong(featuresBitMapAddress + featureIndex * Long.BYTES);\n+        }, renaming);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotJVMCIBackendFactory.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, emptyMap());\n+        return HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, mask -> mask, _ -> config.vmVersionFeatures, emptyMap());\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/riscv64\/RISCV64HotSpotJVMCIBackendFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -52,1 +50,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jartool\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -879,0 +879,5 @@\n+                    \/\/ If the file exists, remove it from all entries in entriesInSF\n+                    for (var signed : entriesInSF.values()) {\n+                        signed.remove(name);\n+                    }\n+\n@@ -893,3 +898,0 @@\n-                        for (var signed : entriesInSF.values()) {\n-                            signed.remove(name);\n-                        }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -423,1 +423,2 @@\n-                    file = createTemporaryFile(\"tmpJar\", \".jar\");\n+                    tmpFile = createTemporaryFile(\"tmpJar\", \".jar\");\n+                    file = tmpFile;\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.LinkedHashMap;\n@@ -32,0 +33,1 @@\n+import java.util.Map;\n@@ -48,0 +50,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;\n@@ -55,0 +58,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -209,2 +213,3 @@\n-\n-        buildMainSummary(summaryTreeList);\n+        var inheritedTocEntries = new LinkedHashMap<HtmlId, Content>();\n+        var ownMemberCount = buildMainSummary(summaryTreeList);\n+        var inheritedSummaries = 0;\n@@ -217,2 +222,3 @@\n-        if (showInherited)\n-            buildInheritedSummary(summaryTreeList);\n+        if (showInherited) {\n+            inheritedSummaries = buildInheritedSummary(summaryTreeList, inheritedTocEntries);\n+        }\n@@ -226,0 +232,6 @@\n+\n+            \/\/ Omit TOC entries for inherited members unless there's a substantial number of own members.\n+            if (!inheritedTocEntries.isEmpty() && ownMemberCount > 8 && inheritedSummaries > 0) {\n+                inheritedTocEntries.forEach((key, value)\n+                        -> writer.tableOfContents.addLink(key, value, TableOfContents.Level.SECOND));\n+            }\n@@ -233,0 +245,1 @@\n+     * @return the number of documented members\n@@ -234,1 +247,1 @@\n-    private void buildMainSummary(List<Content> summaryTreeList) {\n+    private int buildMainSummary(List<Content> summaryTreeList) {\n@@ -238,0 +251,1 @@\n+            var table = getSummaryTable();\n@@ -239,16 +253,1 @@\n-                final Element property = pHelper.getPropertyElement(member);\n-                if (property != null && member instanceof ExecutableElement ee) {\n-                    configuration.cmtUtils.updatePropertyMethodComment(ee, property);\n-                }\n-                if (utils.isMethod(member)) {\n-                    var docFinder = utils.docFinder();\n-                    Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n-                        var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n-                        Optional<List<? extends DocTree>> optional = firstSentenceTrees.isEmpty() ? Optional.empty() : Optional.of(firstSentenceTrees);\n-                        return DocFinder.Result.fromOptional(optional);\n-                    })).toOptional();\n-                    \/\/ The fact that we use `member` for possibly unrelated tags is suspicious\n-                    addMemberSummary(typeElement, member, r.orElse(List.of()));\n-                } else {\n-                    addMemberSummary(typeElement, member, utils.getFirstSentenceTrees(member));\n-                }\n+                addMemberSummaryTableRow(typeElement, member, table, pHelper);\n@@ -258,0 +257,30 @@\n+        return members.size();\n+    }\n+\n+    \/**\n+     * Adds the summary table row for a member.\n+     * @param enclosingType the enclosing type of the member\n+     * @param member the member\n+     * @param table the summary table\n+     * @param propertyHelper property helper to patch doctree\n+     *\/\n+    private void addMemberSummaryTableRow(TypeElement enclosingType, Element member, Table<Element> table,\n+                                          PropertyUtils.PropertyHelper propertyHelper) {\n+        final Element property = propertyHelper.getPropertyElement(member);\n+        if (property != null && member instanceof ExecutableElement ee) {\n+            configuration.cmtUtils.updatePropertyMethodComment(ee, property);\n+        }\n+\n+        if (utils.isMethod(member)) {\n+            var docFinder = utils.docFinder();\n+            Optional<List<? extends DocTree>> r = docFinder.search((ExecutableElement) member, (m -> {\n+                var firstSentenceTrees = utils.getFirstSentenceTrees(m);\n+                Optional<List<? extends DocTree>> optional = firstSentenceTrees.isEmpty()\n+                        ? Optional.empty() : Optional.of(firstSentenceTrees);\n+                return DocFinder.Result.fromOptional(optional);\n+            })).toOptional();\n+            \/\/ The fact that we use `member` for possibly unrelated tags is suspicious\n+            addMemberSummary(enclosingType, member, r.orElse(List.of()), table);\n+        } else {\n+            addMemberSummary(enclosingType, member, utils.getFirstSentenceTrees(member), table);\n+        }\n@@ -264,0 +293,2 @@\n+     * @param tocEntries map of TOC entries for added summaries\n+     * @return the number of added summary lists, excluding methods from java.lang.Object\n@@ -265,1 +296,1 @@\n-    private void buildInheritedSummary(List<Content> targets) {\n+    private int buildInheritedSummary(List<Content> targets, Map<HtmlId, Content> tocEntries) {\n@@ -267,0 +298,2 @@\n+        \/\/ Avoid showing TOC entry if it's just methods inherited from java.lang.Object\n+        var summaryCount = kind == METHODS && utils.isClass(typeElement) ? -1 : 0;\n@@ -287,0 +320,11 @@\n+\n+                if (utils.isIncluded(inheritedClass)) {\n+                    var pHelper = writer.getPropertyHelper();\n+                    Table<Element> table = createInheritedSummaryTable(inheritedClass);\n+\n+                    for (Element member : inheritedMembers) {\n+                        addMemberSummaryTableRow(inheritedClass, member, table, pHelper);\n+                    }\n+\n+                    inheritedHeader.add(table);\n+                }\n@@ -288,0 +332,5 @@\n+\n+                summaryCount++;\n+                var label = new ContentBuilder();\n+                addInheritedSummaryLabel(inheritedClass, label);\n+                tocEntries.put(getInheritedSummaryId(inheritedClass), label.stripTags());\n@@ -290,0 +339,2 @@\n+\n+        return summaryCount;\n@@ -331,0 +382,1 @@\n+\n@@ -386,0 +438,22 @@\n+    \/**\n+     * Creates a summary table for members of the kind supported by this writer inherited\n+     * from {@code typeElement}.\n+     *\n+     * @param typeElement the superclass or interface\n+     * @return a summary table\n+     *\/\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        throw new UnsupportedOperationException(\"Inherited summary not supported for \" + kind);\n+    }\n+\n+    \/**\n+     * Creates an id for a summary table for members of the kind supported by this writer\n+     * inherited from {@code typeElement}.\n+     *\n+     * @param typeElement the superclass or interface\n+     * @return the id for the summary table\n+     *\/\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        throw new UnsupportedOperationException(\"Inherited summary not supported for \" + kind);\n+    }\n+\n@@ -392,1 +466,3 @@\n-    public abstract void addInheritedSummaryLabel(TypeElement typeElement, Content content);\n+    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n+        throw new UnsupportedOperationException(\"Inherited summary not supported for \" + kind);\n+    }\n@@ -431,2 +507,3 @@\n-    protected abstract void addInheritedSummaryLink(TypeElement typeElement,\n-            Element member, Content target);\n+    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n+        throw new UnsupportedOperationException(\"Inherited summary not supported for \" + kind);\n+    }\n@@ -619,5 +696,1 @@\n-            List<? extends DocTree> firstSentenceTrees) {\n-        if (tElement != typeElement) {\n-            throw new IllegalStateException(getClass() + \": \" + tElement + \", \" + typeElement);\n-        }\n-        var table = getSummaryTable();\n+            List<? extends DocTree> firstSentenceTrees, Table<Element> table) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":103,"deletions":30,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -287,4 +287,0 @@\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n@@ -300,6 +296,0 @@\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement,\n-            Element member, Content target) {\n-        \/\/Not applicable.\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AnnotationTypeMemberWriter.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.element.TypeElement;\n@@ -43,1 +42,0 @@\n-import jdk.javadoc.internal.html.HtmlTag;\n@@ -296,4 +294,0 @@\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -216,4 +216,0 @@\n-    @Override\n-    public void addInheritedSummaryLabel(TypeElement typeElement, Content content) {\n-    }\n-\n@@ -229,4 +225,0 @@\n-    @Override\n-    protected void addInheritedSummaryLink(TypeElement typeElement, Element member, Content target) {\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/EnumConstantWriter.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n-\n@@ -41,1 +38,1 @@\n-import jdk.javadoc.internal.html.HtmlStyle;\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -222,3 +219,0 @@\n-        List<HtmlStyle> bodyRowStyles = Arrays.asList(HtmlStyles.colFirst, HtmlStyles.colSecond,\n-                HtmlStyles.colLast);\n-\n@@ -228,1 +222,10 @@\n-                .setColumnStyles(bodyRowStyles);\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond,\n+                        HtmlStyles.colLast);\n+    }\n+\n+    @Override\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        return new Table<Element>(HtmlStyles.summaryTable)\n+                .setHeader(getSummaryTableHeader(null))\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond, HtmlStyles.colLast)\n+                .setRenderTabs(false);\n@@ -246,1 +249,1 @@\n-        labelHeading.setId(htmlIds.forInheritedFields(typeElement));\n+        labelHeading.setId(getInheritedSummaryId(typeElement));\n@@ -272,0 +275,5 @@\n+    @Override\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        return htmlIds.forInheritedFields(typeElement);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/FieldWriter.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -320,2 +320,3 @@\n-        \/\/ If a stylesheet file is not specified, copy the default stylesheet\n-        \/\/ and replace newline with platform-specific newline.\n+        \/\/ If a stylesheet file is not specified, copy the default stylesheet,\n+        \/\/ replace newline with platform-specific newline,\n+        \/\/ and remove the reference to fonts if --no-fonts is used.\n@@ -323,1 +324,1 @@\n-            copyResource(DocPaths.STYLESHEET, DocPaths.RESOURCE_FILES.resolve(DocPaths.STYLESHEET), true);\n+            copyStylesheet(options);\n@@ -326,0 +327,1 @@\n+        copyResource(DocPaths.DOWN_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.DOWN_SVG), true);\n@@ -330,0 +332,2 @@\n+        copyResource(DocPaths.MOON_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.MOON_SVG), true);\n+        copyResource(DocPaths.SUN_SVG, DocPaths.RESOURCE_FILES.resolve(DocPaths.SUN_SVG), true);\n@@ -464,6 +468,1 @@\n-        DocPath resourcePath = DocPaths.RESOURCES.resolve(sourcePath);\n-        \/\/ Resolve resources against doclets.formats.html package\n-        URL resourceURL = HtmlConfiguration.class.getResource(resourcePath.getPath());\n-        if (resourceURL == null) {\n-            throw new ResourceIOException(sourcePath, new FileNotFoundException(resourcePath.getPath()));\n-        }\n+        ReadableResource resource = resolveResource(sourcePath);\n@@ -473,1 +472,1 @@\n-            f.copyResource(resourcePath, resourceURL, configuration.docResources);\n+            f.copyResource(resource.path(), resource.url(), configuration.docResources);\n@@ -475,1 +474,1 @@\n-            f.copyResource(resourcePath, resourceURL, replaceNewLine);\n+            f.copyResource(resource.path(), resource.url(), replaceNewLine);\n@@ -504,0 +503,17 @@\n+    private void copyStylesheet(HtmlOptions options) throws DocletException {\n+        ReadableResource resource = resolveResource(DocPaths.STYLESHEET);\n+        var targetPath = DocPaths.RESOURCE_FILES.resolve(DocPaths.STYLESHEET);\n+        DocFile f = DocFile.createFileForOutput(configuration, targetPath);\n+\n+        if (options.noFonts()) {\n+            f.copyResource(resource.path(), resource.url(), line -> {\n+                if (line.startsWith(\"@import url('fonts\")) {\n+                    return null; \/\/ remove the line\n+                }\n+                return line;\n+            });\n+        } else {\n+            f.copyResource(resource.path(), resource.url(), true);\n+        }\n+    }\n+\n@@ -520,0 +536,13 @@\n+\n+    private ReadableResource resolveResource(DocPath sourcePath) throws ResourceIOException {\n+        DocPath resolvedPath = DocPaths.RESOURCES.resolve(sourcePath);\n+        \/\/ Resolve resources against doclets.formats.html package\n+        URL resourceURL = HtmlConfiguration.class.getResource(resolvedPath.getPath());\n+        if (resourceURL == null) {\n+            throw new ResourceIOException(sourcePath, new FileNotFoundException(resolvedPath.getPath()));\n+        }\n+        return new ReadableResource(resolvedPath, resourceURL);\n+    }\n+\n+    private record ReadableResource(DocPath path, URL url) {\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":40,"deletions":11,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -117,0 +117,5 @@\n+    static final HtmlId THEME_BUTTON = HtmlId.of(\"theme-button\");\n+    static final HtmlId THEME_DARK = HtmlId.of(\"theme-dark\");\n+    static final HtmlId THEME_LIGHT = HtmlId.of(\"theme-light\");\n+    static final HtmlId THEME_OS = HtmlId.of(\"theme-os\");\n+    static final HtmlId THEME_PANEL = HtmlId.of(\"theme-panel\");\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -305,0 +306,8 @@\n+    @Override\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        return new Table<Element>(HtmlStyles.summaryTable)\n+                .setHeader(getSummaryTableHeader(null))\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond, HtmlStyles.colLast)\n+                .setRenderTabs(false);\n+    }\n+\n@@ -320,1 +329,1 @@\n-        labelHeading.setId(htmlIds.forInheritedMethods(typeElement));\n+        labelHeading.setId(getInheritedSummaryId(typeElement));\n@@ -326,0 +335,5 @@\n+    @Override\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        return htmlIds.forInheritedMethods(typeElement);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriter.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+                addThemeSwitcher(target);\n@@ -151,0 +152,1 @@\n+                addThemeSwitcher(target);\n@@ -169,0 +171,1 @@\n+                addThemeSwitcher(target);\n@@ -187,0 +190,1 @@\n+                addThemeSwitcher(target);\n@@ -211,0 +215,1 @@\n+                addThemeSwitcher(target);\n@@ -229,0 +234,1 @@\n+                addThemeSwitcher(target);\n@@ -271,0 +277,1 @@\n+                addThemeSwitcher(target);\n@@ -288,0 +295,1 @@\n+                addThemeSwitcher(target);\n@@ -314,0 +322,1 @@\n+                addThemeSwitcher(target);\n@@ -320,4 +329,0 @@\n-    private void addContentToList(List<Content> listContents, Content source) {\n-        listContents.add(HtmlTree.LI(source));\n-    }\n-\n@@ -495,0 +500,11 @@\n+    private void addThemeSwitcher(Content target) {\n+        var selectTheme = contents.getContent(\"doclet.theme.select_theme\");\n+        target.add(HtmlTree.LI(HtmlTree.BUTTON(HtmlIds.THEME_BUTTON)\n+                .add(HtmlTree.IMG(pathToRoot.resolve(DocPaths.RESOURCE_FILES).resolve(DocPaths.SUN_SVG),\n+                        selectTheme.toString()).addStyle(HtmlIds.THEME_LIGHT.name()))\n+                .add(HtmlTree.IMG(pathToRoot.resolve(DocPaths.RESOURCE_FILES).resolve(DocPaths.MOON_SVG),\n+                        selectTheme.toString()).addStyle(HtmlIds.THEME_DARK.name()))\n+                .put(HtmlAttr.ARIA_LABEL, selectTheme.toString())\n+                .put(HtmlAttr.TITLE, selectTheme.toString())));\n+    }\n+\n@@ -548,0 +564,1 @@\n+\n@@ -560,0 +577,16 @@\n+        var selectTheme = contents.getContent(\"doclet.theme.select_theme\");\n+        subNavContent.add(HtmlTree.DIV(HtmlIds.THEME_PANEL)\n+                .add(HtmlTree.DIV(selectTheme))\n+                .add(HtmlTree.DIV(HtmlTree.LABEL(HtmlIds.THEME_LIGHT.name(), Text.EMPTY)\n+                                .add(HtmlTree.INPUT(HtmlAttr.InputType.RADIO, HtmlIds.THEME_LIGHT)\n+                                        .put(HtmlAttr.NAME, \"theme\").put(HtmlAttr.VALUE, HtmlIds.THEME_LIGHT.name()))\n+                                .add(HtmlTree.SPAN(contents.getContent(\"doclet.theme.light\"))))\n+                        .add(HtmlTree.LABEL(HtmlIds.THEME_DARK.name(), Text.EMPTY)\n+                                .add(HtmlTree.INPUT(HtmlAttr.InputType.RADIO, HtmlIds.THEME_DARK)\n+                                        .put(HtmlAttr.NAME, \"theme\").put(HtmlAttr.VALUE, HtmlIds.THEME_DARK.name()))\n+                                .add(HtmlTree.SPAN(contents.getContent(\"doclet.theme.dark\"))))\n+                        .add(HtmlTree.LABEL(HtmlIds.THEME_OS.name(), Text.EMPTY)\n+                                .add(HtmlTree.INPUT(HtmlAttr.InputType.RADIO, HtmlIds.THEME_OS)\n+                                        .put(HtmlAttr.NAME, \"theme\").put(HtmlAttr.VALUE, HtmlIds.THEME_OS.name()))\n+                                .add(HtmlTree.SPAN(contents.getContent(\"doclet.theme.system\"))))));\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":37,"deletions":4,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n-\n@@ -39,1 +36,1 @@\n-import jdk.javadoc.internal.html.HtmlStyle;\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -97,3 +94,0 @@\n-        List<HtmlStyle> bodyRowStyles = Arrays.asList(HtmlStyles.colFirst, HtmlStyles.colSecond,\n-                HtmlStyles.colLast);\n-\n@@ -103,1 +97,10 @@\n-                .setColumnStyles(bodyRowStyles);\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond,\n+                        HtmlStyles.colLast);\n+    }\n+\n+    @Override\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        return new Table<Element>(HtmlStyles.summaryTable)\n+                .setHeader(getSummaryTableHeader(typeElement))\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond, HtmlStyles.colLast)\n+                .setRenderTabs(false);\n@@ -120,1 +123,1 @@\n-        labelHeading.setId(htmlIds.forInheritedClasses(typeElement));\n+        labelHeading.setId(getInheritedSummaryId(typeElement));\n@@ -126,0 +129,5 @@\n+    @Override\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        return htmlIds.forInheritedClasses(typeElement);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/NestedClassWriter.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -258,0 +259,8 @@\n+    @Override\n+    protected Table<Element> createInheritedSummaryTable(TypeElement typeElement) {\n+        return new Table<Element>(HtmlStyles.summaryTable)\n+                .setHeader(getSummaryTableHeader(null))\n+                .setColumnStyles(HtmlStyles.colFirst, HtmlStyles.colSecond, HtmlStyles.colLast)\n+                .setRenderTabs(false);\n+    }\n+\n@@ -273,1 +282,1 @@\n-                        .setId(htmlIds.forInheritedProperties(typeElement))\n+                        .setId(getInheritedSummaryId(typeElement))\n@@ -279,0 +288,5 @@\n+    @Override\n+    protected HtmlId getInheritedSummaryId(TypeElement typeElement) {\n+        return htmlIds.forInheritedProperties(typeElement);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PropertyWriter.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -379,2 +379,5 @@\n-        if ((tabs == null || occurringTabs.size() == 1) && renderTabs) {\n-            if (tabs == null) {\n+        if (tabs == null || (occurringTabs.size() == 1 && renderTabs)) {\n+            \/\/ Render table with static content. Note that a single-tab table is only static\n+            \/\/ if it is controlled by local tabs. In a multi-table summary page, it still\n+            \/\/ must be able to show\/hide its content depending on page-level controls.\n+            if (caption != null) {\n@@ -382,1 +385,1 @@\n-            } else {\n+            } else if (tabs != null) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Table.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,12 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+-->\n+\n+<svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100 100\">\n+  <path d=\"m35.763 5.058 38.675 36.885a12.596 12.596 90 0 1 0 18.23L35.763 97.058v-18.32l27.055-25.431a2.975 2.975 90.09 0 0 .007-4.33L35.763 23.38Z\" style=\"fill:#000;stroke-width:.285806\" transform=\"rotate(90 53.877 47.354)\"\/>\n+<\/svg>\n\\ No newline at end of file\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/down.svg","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -11,3 +11,3 @@\n-    <path d=\"M66.37 55.005C64.415 58.958 60.147 63.321 56.153 66l32.478 33.456L99.377 88.99Z\" style=\"baseline-shift:baseline;display:inline;overflow:visible;opacity:1;vector-effect:none;fill:#1a73a8;stop-color:#000;stop-opacity:1\"\/>\n-    <circle cx=\"35.072\" cy=\"35.072\" r=\"30.635\" style=\"fill:none;fill-opacity:1;stroke:#1a73a8;stroke-width:8;stroke-dasharray:none;stroke-opacity:1\"\/>\n-<\/svg>\n\\ No newline at end of file\n+    <path d=\"M66.37 55.005C64.415 58.958 60.147 63.321 56.153 66l32.478 33.456L99.377 88.99Z\" style=\"fill:#1a73a8\"\/>\n+    <circle cx=\"35.072\" cy=\"35.072\" r=\"30.635\" style=\"fill:none;stroke:#1a73a8;stroke-width:8\"\/>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/glass.svg","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,185 @@\n+body.theme-dark {\n+    .hljs-title.function_,\n+    .hljs-template-variable {\n+        color: #66bcce;\n+    }\n+    .hljs-code,\n+    .hljs-comment,\n+    .hljs-quote {\n+        color:#9d9d9d;\n+        font-style: italic;\n+    }\n+    .hljs-meta {\n+        color: #836F00;\n+    }\n+    .hljs-symbol,\n+    .hljs-template-tag,\n+    .hljs-keyword,\n+    .hljs-literal,\n+    .hljs-name,\n+    .hljs-built_in,\n+    .hljs-char.escape_ {\n+        color: #88aece;\n+    }\n+    .hljs-variable,\n+    .hljs-property,\n+    .hljs-attr,\n+    .hljs-section {\n+        color: #c59bc1;\n+    }\n+    .hljs-attribute {\n+        color:  #c59bc1;\n+    }\n+    .hljs-regexp,\n+    .hljs-number {\n+        color: #cfe374;\n+    }\n+    .hljs-link {\n+        color: #b5bd68;\n+    }\n+    .hljs-string {\n+        color: #b5bd68;\n+    }\n+    .hljs-doctag {\n+        text-decoration: underline;\n+    }\n+    .hljs-emphasis {\n+        font-style: italic;\n+    }\n+    .hljs-strong {\n+        font-weight: bold;\n+    }\n+    .hljs-subst,\n+    .hljs-title,\n+    .hljs-params,\n+    .hljs-bullet,\n+    .hljs-formula,\n+    .hljs-tag,\n+    .hljs-type {\n+        \/* ignored *\/\n+    }\n+}\n+\n+@media (prefers-color-scheme: dark) {\n+    .hljs-title.function_,\n+    .hljs-template-variable {\n+        color: #66bcce;\n+    }\n+    .hljs-code,\n+    .hljs-comment,\n+    .hljs-quote {\n+        color:#9d9d9d;\n+        font-style: italic;\n+    }\n+    .hljs-meta {\n+        color: #836F00;\n+    }\n+    .hljs-symbol,\n+    .hljs-template-tag,\n+    .hljs-keyword,\n+    .hljs-literal,\n+    .hljs-name,\n+    .hljs-built_in,\n+    .hljs-char.escape_ {\n+        color: #88aece;\n+    }\n+    .hljs-variable,\n+    .hljs-property,\n+    .hljs-attr,\n+    .hljs-section {\n+        color: #c59bc1;\n+    }\n+    .hljs-attribute {\n+        color:  #c59bc1;\n+    }\n+    .hljs-regexp,\n+    .hljs-number {\n+        color: #cfe374;\n+    }\n+    .hljs-link {\n+        color: #b5bd68;\n+    }\n+    .hljs-string {\n+        color: #b5bd68;\n+    }\n+    .hljs-doctag {\n+        text-decoration: underline;\n+    }\n+    .hljs-emphasis {\n+        font-style: italic;\n+    }\n+    .hljs-strong {\n+        font-weight: bold;\n+    }\n+    .hljs-subst,\n+    .hljs-title,\n+    .hljs-params,\n+    .hljs-bullet,\n+    .hljs-formula,\n+    .hljs-tag,\n+    .hljs-type {\n+        \/* ignored *\/\n+    }\n+\n+    body.theme-light {\n+        .hljs-title.function_,\n+        .hljs-template-variable {\n+            color: #00738F;\n+        }\n+        .hljs-code,\n+        .hljs-comment,\n+        .hljs-quote {\n+            color: #6e6e71;\n+            font-style: italic;\n+        }\n+        .hljs-meta {\n+            color: #836F00;\n+        }\n+        .hljs-symbol,\n+        .hljs-template-tag,\n+        .hljs-keyword,\n+        .hljs-literal,\n+        .hljs-name,\n+        .hljs-built_in,\n+        .hljs-char.escape_ {\n+            color: #0C40C2;\n+        }\n+        .hljs-variable,\n+        .hljs-property,\n+        .hljs-attr,\n+        .hljs-section {\n+            color: #841191;\n+        }\n+        .hljs-attribute {\n+            color: #164ad9;\n+        }\n+        .hljs-regexp,\n+        .hljs-number {\n+            color: #104BEB;\n+        }\n+        .hljs-link {\n+            color: #47688a;\n+        }\n+        .hljs-string {\n+            color: #008313;\n+        }\n+        .hljs-doctag {\n+            text-decoration: underline;\n+        }\n+        .hljs-emphasis {\n+            font-style: italic;\n+        }\n+        .hljs-strong {\n+            font-weight: bold;\n+        }\n+        .hljs-subst,\n+        .hljs-title,\n+        .hljs-params,\n+        .hljs-bullet,\n+        .hljs-formula,\n+        .hljs-tag,\n+        .hljs-type {\n+            \/* ignored *\/\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/highlight.css","additions":185,"deletions":0,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+-->\n+\n+<svg version=\"1.1\" viewBox=\"0 0 100 100\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <g fill=\"none\" stroke=\"#fff\" stroke-linecap=\"round\">\n+        <path d=\"m34.834 21.49a29.94 29.94 0 0 1 33.103 12.994 29.94 29.94 0 0 1-2.6651 35.462 29.94 29.94 0 0 1-34.674 7.9004\" stroke-width=\"7.6\"\/>\n+        <path d=\"m35.411 22.187a42.812 42.812 0 0 1-4.6466 55.023\" stroke-width=\"7.6892\"\/>\n+    <\/g>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/moon.svg","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -12,1 +12,1 @@\n-<\/svg>\n+<\/svg>\n\\ No newline at end of file\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/right.svg","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+const toggleMemberListing = \"##REPLACE:doclet.Toggle_member_listing##\";\n@@ -331,1 +332,0 @@\n-    \/\/ Make sure current element is visible in breadcrumb navigation on small displays\n@@ -333,3 +333,0 @@\n-    if (subnav && subnav.lastElementChild) {\n-        subnav.lastElementChild.scrollIntoView({ behavior: \"instant\", inline: \"start\", block: \"nearest\" });\n-    }\n@@ -354,0 +351,43 @@\n+    const themeButton = document.querySelector(\"button#theme-button\");\n+    const themePanel = document.querySelector(\"div#theme-panel\");\n+    var themePanelVisible = false;\n+    themeButton.addEventListener(\"click\", e => {\n+        if (!themePanelVisible) {\n+            let {x, y} = themeButton.getBoundingClientRect();\n+            themePanel.style.display = \"block\";\n+            if (window.innerHeight - 85 < y) {\n+                themePanel.style.top = \"\";\n+                themePanel.style.bottom = \"4px\";\n+            } else {\n+                themePanel.style.top = y + (expanded ? 0 : 36) + \"px\";\n+                themePanel.style.bottom = \"\";\n+            }\n+            themePanel.style.left = x + (expanded ? 36 : 0) + \"px\";\n+            themeButton.setAttribute(\"aria-expanded\", \"true\");\n+            themePanelVisible = true;\n+            e.stopPropagation();\n+        }\n+    });\n+    function closeThemePanel(e) {\n+        if (themePanelVisible && (!e || !themePanel.contains(e.target))) {\n+            themePanel.style.removeProperty(\"display\");\n+            themeButton.setAttribute(\"aria-expanded\", \"false\");\n+            themePanelVisible = false;\n+        }\n+    }\n+    themePanel.querySelectorAll(\"input\").forEach(input => {\n+        input.removeAttribute(\"disabled\");\n+        input.addEventListener(\"change\", e => {\n+            setTheme(e.target.value);\n+        })\n+    });\n+    const THEMES = [\"theme-light\", \"theme-dark\", \"theme-os\"];\n+    function setTheme(theme) {\n+        THEMES.forEach(t => {\n+            if (t !== theme) document.body.classList.remove(t);\n+        });\n+        document.body.classList.add(theme);\n+        localStorage.setItem(\"theme\", theme);\n+        document.getElementById(theme).checked = true;\n+    }\n+    setTheme(localStorage.getItem(\"theme\") || THEMES[0]);\n@@ -365,0 +405,1 @@\n+            closeThemePanel();\n@@ -373,0 +414,1 @@\n+            closeThemePanel();\n@@ -392,0 +434,1 @@\n+        closeThemePanel();\n@@ -406,0 +449,1 @@\n+        closeThemePanel();\n@@ -460,0 +504,1 @@\n+    document.querySelector(\"body\").addEventListener(\"click\", closeThemePanel);\n@@ -467,3 +512,3 @@\n-                template.innerHTML =\" <a href='#\" + encodeURI(id) + \"' class='anchor-link' aria-label='\" + linkToSection\n-                    + \"'><img src='\" + pathtoroot + \"resource-files\/link.svg' alt='\" + linkIcon +\"' tabindex='0'\"\n-                    + \" width='16' height='16'><\/a>\";\n+                template.innerHTML =\" <a href='#\" + encodeURI(id) + \"' class='anchor-link' aria-label='\"\n+                    + linkToSection + \"'><img src='\" + pathtoroot + \"resource-files\/link.svg' alt='\"\n+                    + linkIcon + \"' width='16' height='16'><\/a>\";\n@@ -473,0 +518,15 @@\n+    document.querySelectorAll(\"div.inherited-list:has( > div.summary-table) > h3\").forEach(h => {\n+        const button = document.createElement(\"button\");\n+        const p = h.parentElement;\n+        button.addEventListener(\"click\", e => {\n+            toggleStyle(p.classList, p.classList.contains(\"expanded\"), \"collapsed\", \"expanded\");\n+        });\n+        button.addEventListener(\"keydown\", e => {\n+            if (e.key === \" \" || e.key === \"Enter\") {\n+                toggleStyle(p.classList, p.classList.contains(\"expanded\"), \"collapsed\", \"expanded\");\n+                e.preventDefault();\n+            }\n+        });\n+        button.setAttribute(\"aria-label\", toggleMemberListing);\n+        h.insertAdjacentElement(\"afterbegin\", button);\n+    });\n@@ -478,10 +538,12 @@\n-        sections = [{ id: \"\", top: 0 }].concat(Array.from(main.querySelectorAll(\n-                \"section[id], h2[id], h2 a[id], h3[id], h3 a[id], div[id]\"))\n-            .filter((e) => {\n-                return sidebar.querySelector(\"a[href=\\\"#\" + encodeURI(e.getAttribute(\"id\")) + \"\\\"]\") !== null\n-            }).map((e) => {\n-                return {\n-                    id: e.getAttribute(\"id\"),\n-                    top: e.offsetTop\n-                };\n-            }));\n+        sections = [{ id: \"\", top: 0 }].concat(\n+            Array.from(main.querySelectorAll(\"section[id], h2[id], h2 a[id], h3[id], h3 a[id], div[id]\"))\n+                .filter((e) => {\n+                    var id = encodeURI(e.getAttribute(\"id\"));\n+                    return sidebar.querySelector(\"a[href=\\\"#\" + id + \"\\\"]\") !== null\n+                }).map((e) => {\n+                    return {\n+                        id: e.getAttribute(\"id\"),\n+                       top: e.offsetTop\n+                    };\n+                })\n+        );\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":79,"deletions":17,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -426,1 +426,2 @@\n-            .append($(\"<div\/>\")\n+            .append($(\"<a\/>\")\n+                .attr(\"href\", item.indexItem ? pathtoroot + getURL(item.indexItem, item.category) : null)\n@@ -518,1 +519,1 @@\n-            }, 1000);\n+            }, 500);\n@@ -534,0 +535,5 @@\n+            for (var e = event.originalEvent; e != null; e = e.originalEvent) {\n+                if (e.type === \"click\") {\n+                    return;\n+                }\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/search.js.template","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -196,0 +196,4 @@\n+doclet.theme.select_theme=Select Theme\n+doclet.theme.light=Light\n+doclet.theme.dark=Dark\n+doclet.theme.system=System Setting\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,22 @@\n+    \/* Navigation bar and content area dimensions *\/\n+    --top-nav-height: 44px;\n+    --sub-nav-height: 36px;\n+    --nav-height: calc(var(--top-nav-height) + var(--sub-nav-height));\n+    --max-content-width: 1500px;\n+    --content-margin: 0 auto;\n+    \/* Inline SVG icons for dark theme *\/\n+    --right-svg-dark: url('data:image\/svg+xml; utf8, \\\n+    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" width=\"100\" height=\"100\"> \\\n+    <path d=\"m35.763 5.058 38.675 36.885a12.596 12.596 90 0 1 0 18.23L35.763 97.058v-18.32l27.055-25.431a2.975 2.975 90.09 0 0 .007-4.33L35.763 23.38Z\" \\\n+    style=\"fill:%23fff;stroke-width:.285806\" transform=\"translate(-5.292 -1.058)\"\/> \\\n+    <\/svg>');\n+    --glass-svg-dark: url('data:image\/svg+xml; utf8, \\\n+    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100 100\"> \\\n+    <path d=\"M66.37 55.005C64.415 58.958 60.147 63.321 56.153 66l32.478 33.456L99.377 88.99Z\" style=\"fill:%23a1d3ff\"\/>\\\n+    <circle cx=\"35.072\" cy=\"35.072\" r=\"30.635\" style=\"fill:none;stroke:%23a1d3ff;stroke-width:8\"\/><\/svg>');\n+    --x-svg-dark: url('data:image\/svg+xml; utf8, \\\n+    <svg xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 100 100\">\\\n+    <path d=\"m8 8 84 84\" style=\"stroke:%23e0e0e0;stroke-width:15\"\/>\\\n+    <path d=\"M8 92 92 8\" style=\"stroke:%23e0e0e0;stroke-width:15\"\/><\/svg>');\n+}\n+body {\n@@ -37,1 +59,1 @@\n-    --detail-background-color: #ffffff;\n+    --detail-background-color: var(--body-background-color);\n@@ -79,1 +101,1 @@\n-    --search-input-placeholder-color: #909090;\n+    --search-input-placeholder-color: #757575;\n@@ -81,1 +103,2 @@\n-    --search-tag-highlight-color: #ffff66;\n+    --search-tag-background-color: #ffff66;\n+    --search-tag-text-color: var(--block-text-color);\n@@ -89,6 +112,155 @@\n-    \/* Navigation bar dimensions *\/\n-    --top-nav-height: 44px;\n-    --sub-nav-height: 36px;\n-    --nav-height: calc(var(--top-nav-height) + var(--sub-nav-height));\n-    --max-content-width: 1500px;\n-    --content-margin: 0 auto;\n+}\n+\n+body.theme-dark {\n+    --body-text-color: #e8e8e8;\n+    --block-text-color: #e8e8e8;\n+    --body-background-color: #222528;\n+    --section-background-color: var(--body-background-color);\n+    --detail-background-color: var(--body-background-color);\n+    --code-background-color: #303940;\n+    --mark-background-color: #313131;\n+    --detail-block-color: #f4f4f4;\n+    --navbar-background-color: #395A6F;\n+    --navbar-text-color: #ffffff;\n+    --subnav-background-color: #3d454d;\n+    --subnav-link-color: #d8dcdf;\n+    --member-heading-background-color: var(--subnav-background-color);\n+    --selected-background-color: #f8981d;\n+    --selected-text-color: #253441;\n+    --selected-link-color: #4a698a;\n+    --table-header-color: #38444d;\n+    --even-row-color: #222528;\n+    --odd-row-color: #2d3135;\n+    --title-color: #fff;\n+    --link-color: #94badb;\n+    --link-color-active: #ffb45b;\n+    --toc-background-color: #31363c;\n+    --toc-highlight-color: var(--subnav-background-color);\n+    --toc-hover-color: #3f4146;\n+    --snippet-background-color: #2d363c;\n+    --snippet-text-color: var(--block-text-color);\n+    --snippet-highlight-color: #f7c590;\n+    --pre-background-color: var(--snippet-background-color);\n+    --pre-text-color: var(--snippet-text-color);\n+    --border-color: #444444;\n+    --table-border-color: #717171;\n+    --tab-border-radius: 2px 2px 0 0;\n+    --search-input-background-color: #303030;\n+    --search-input-text-color: #d0d0d0;\n+    --search-input-placeholder-color: #979797;\n+    --search-tag-background-color: #c6c61e;\n+    --search-tag-text-color: #282828;\n+    --button-border-color: #909090;\n+    --button-active-filter: brightness(96%);\n+    --button-focus-filter: brightness(104%);\n+    --invalid-tag-background-color: #ffe6e6;\n+    --invalid-tag-text-color: #000000;\n+    div.main-grid img,\n+    .inherited-list h3 > button {\n+        filter: invert(100%) brightness(160%);\n+    }\n+}\n+\n+\/*\n+ * Dark theme\n+ *\/\n+@media (prefers-color-scheme: dark) {\n+    body {\n+        --body-text-color: #e8e8e8;\n+        --block-text-color: #e8e8e8;\n+        --body-background-color: #222528;\n+        --section-background-color: var(--body-background-color);\n+        --detail-background-color: var(--body-background-color);\n+        --code-background-color: #303940;\n+        --mark-background-color: #313131;\n+        --detail-block-color: #f4f4f4;\n+        --navbar-background-color: #395A6F;\n+        --navbar-text-color: #ffffff;\n+        --subnav-background-color: #3d454d;\n+        --subnav-link-color: #d8dcdf;\n+        --member-heading-background-color: var(--subnav-background-color);\n+        --selected-background-color: #f8981d;\n+        --selected-text-color: #253441;\n+        --selected-link-color: #4a698a;\n+        --table-header-color: #38444d;\n+        --even-row-color: #222528;\n+        --odd-row-color: #2d3135;\n+        --title-color: #fff;\n+        --link-color: #94badb;\n+        --link-color-active: #ffb45b;\n+        --toc-background-color: #31363c;\n+        --toc-highlight-color: var(--subnav-background-color);\n+        --toc-hover-color: #3f4146;\n+        --snippet-background-color: #2d363c;\n+        --snippet-text-color: var(--block-text-color);\n+        --snippet-highlight-color: #f7c590;\n+        --pre-background-color: var(--snippet-background-color);\n+        --pre-text-color: var(--snippet-text-color);\n+        --border-color: #444444;\n+        --table-border-color: #717171;\n+        --tab-border-radius: 2px 2px 0 0;\n+        --search-input-background-color: #303030;\n+        --search-input-text-color: #d0d0d0;\n+        --search-input-placeholder-color: #979797;\n+        --search-tag-background-color: #c6c61e;\n+        --search-tag-text-color: #282828;\n+        --button-border-color: #909090;\n+        --button-active-filter: brightness(96%);\n+        --button-focus-filter: brightness(104%);\n+        --invalid-tag-background-color: #ffe6e6;\n+        --invalid-tag-text-color: #000000;\n+        div.main-grid img,\n+        .inherited-list h3 > button {\n+            filter: invert(100%) brightness(160%);\n+        }\n+    }\n+\n+    body.theme-light {\n+        --body-text-color: #282828;\n+        --block-text-color: #282828;\n+        --body-background-color: #ffffff;\n+        --section-background-color: var(--body-background-color);\n+        --detail-background-color: var(--body-background-color);\n+        --code-background-color: #f5f5f5;\n+        --mark-background-color: #f7f7f7;\n+        --detail-block-color: #f4f4f4;\n+        --navbar-background-color: #4D7A97;\n+        --navbar-text-color: #ffffff;\n+        --subnav-background-color: #dee3e9;\n+        --subnav-link-color: #47688a;\n+        --member-heading-background-color: var(--subnav-background-color);\n+        --selected-background-color: #f8981d;\n+        --selected-text-color: #253441;\n+        --selected-link-color: #4a698a;\n+        --table-header-color: #ebeff4;\n+        --even-row-color: #ffffff;\n+        --odd-row-color: #f0f0f2;\n+        --title-color: #2c4557;\n+        --link-color: #437291;\n+        --link-color-active: #bb7a2a;\n+        --toc-background-color: #f8f8f8;\n+        --toc-highlight-color: var(--subnav-background-color);\n+        --toc-hover-color: #e9ecf0;\n+        --snippet-background-color: #f2f2f4;\n+        --snippet-text-color: var(--block-text-color);\n+        --snippet-highlight-color: #f7c590;\n+        --pre-background-color: var(--snippet-background-color);\n+        --pre-text-color: var(--snippet-text-color);\n+        --border-color: #e6e6e6;\n+        --table-border-color: #000000;\n+        --tab-border-radius: 2px 2px 0 0;\n+        --search-input-background-color: #ffffff;\n+        --search-input-text-color: #000000;\n+        --search-input-placeholder-color: #757575;\n+        --search-tag-background-color: #ffff66;\n+        --search-tag-text-color: var(--block-text-color);\n+        --button-border-color: #b0b8c8;\n+        --button-active-filter: brightness(96%);\n+        --button-focus-filter: brightness(104%);\n+        --invalid-tag-background-color: #ffe6e6;\n+        --invalid-tag-text-color: #000000;\n+        div.main-grid img,\n+        .inherited-list h3 > button {\n+            filter: none;\n+        }\n+    }\n@@ -189,1 +361,1 @@\n-    padding:0 20px;\n+    padding:0 20px 0 10px;\n@@ -218,0 +390,1 @@\n+    position: relative;\n@@ -239,0 +412,62 @@\n+button#theme-button {\n+    position: relative;\n+    top: -9.5px;\n+    width: 32px;\n+    height: 32px;\n+    padding: 6px;\n+    margin-left: -6px;\n+    background-color: transparent;\n+    border: 1px solid transparent;\n+    border-radius: 6px;\n+    cursor: pointer;\n+}\n+button#theme-button:hover,\n+button#theme-button:focus-visible {\n+    border: 1px solid var(--button-border-color);\n+}\n+button#theme-button img {\n+    display: none;\n+    width: 18px;\n+}\n+body.theme-light button#theme-button img.theme-light {\n+    display: inline;\n+}\n+body.theme-dark button#theme-button img.theme-dark {\n+    display: inline;\n+}\n+@media (prefers-color-scheme: dark) {\n+    body.theme-os button#theme-button img.theme-dark {\n+        display: inline;\n+    }\n+}\n+@media (prefers-color-scheme: light) {\n+    body.theme-os button#theme-button img.theme-light {\n+        display: inline;\n+    }\n+}\n+div#theme-panel {\n+    display: none;\n+    position: fixed;\n+    z-index: 8;\n+    background-color: var(--toc-background-color);\n+    color: var(--body-text-color);\n+    padding: 4px;\n+    white-space: nowrap;\n+    border: 1px solid var(--border-color);\n+    border-radius: 4px;\n+    box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);\n+}\n+div#theme-panel div:first-child {\n+    font-weight: bold;\n+    font-size: 16px;\n+}\n+div#theme-panel div {\n+    padding: 8px;\n+}\n+div#theme-panel label {\n+    margin-right: 8px;\n+    cursor: pointer;\n+}\n+div#theme-panel input {\n+    margin-right: 4px;\n+}\n@@ -255,1 +490,0 @@\n-    overflow:hidden;\n@@ -257,1 +491,1 @@\n-    height: var(--sub-nav-height);\n+    min-height: var(--sub-nav-height);\n@@ -261,2 +495,1 @@\n-    line-height: 1.8;\n-    display: inline-flex;\n+    line-height: 1.7;\n@@ -264,3 +497,0 @@\n-    scroll-snap-type: x mandatory;\n-    scroll-padding-left: 13px;\n-    scrollbar-width: none;\n@@ -268,2 +498,2 @@\n-    white-space: nowrap;\n-    margin:0;\n+    margin: 4px 0;\n+    min-height: 28px;\n@@ -276,1 +506,3 @@\n-    scroll-snap-align: start;\n+    display: inline-block;\n+    padding: 2px 0;\n+    margin-right: -4px;\n@@ -284,0 +516,11 @@\n+body.theme-dark ol.sub-nav-list li:not(:first-child) {\n+    background-image: var(--right-svg-dark);\n+}\n+@media (prefers-color-scheme: dark) {\n+    ol.sub-nav-list li:not(:first-child) {\n+        background-image: var(--right-svg-dark);\n+    }\n+    body.theme-light ol.sub-nav-list li:not(:first-child) {\n+        background-image: url(\"right.svg\");\n+    }\n+}\n@@ -293,1 +536,2 @@\n-    margin: 0 15px;\n+    margin: 4.5px 15px auto 5px;\n+    padding: 1px 0;\n@@ -365,1 +609,1 @@\n-    filter: invert(100%) sepia(4%) saturate(98%) hue-rotate(212deg) brightness(160%) contrast(160%);\n+    filter: invert(100%) brightness(160%);\n@@ -643,2 +887,2 @@\n-    padding:5px 12px 7px 12px;\n-    height:16px;\n+    padding:4.5px 12px;\n+    height:19px;\n@@ -650,2 +894,2 @@\n-    padding:6px 12px 7px 12px;\n-    height:17px;\n+    padding:5px 5px 6px 12px;\n+    height:18px;\n@@ -654,0 +898,1 @@\n+    font-size: 0.99em;\n@@ -669,0 +914,6 @@\n+.caption a:hover,\n+.caption a:active,\n+.inherited-list.expanded h3 a:hover,\n+.inherited-list.expanded h3 a:active {\n+    color: var(--link-color-active);\n+}\n@@ -757,1 +1008,1 @@\n-    padding: 8px 3px 3px 7px;\n+    padding: 8px 5px 3px 7px;\n@@ -997,1 +1248,1 @@\n-.ui-autocomplete > li > div {\n+.ui-autocomplete > li > a {\n@@ -1001,1 +1252,1 @@\n-.ui-autocomplete > li.result-item > div {\n+.ui-autocomplete > li.result-item > a {\n@@ -1012,0 +1263,1 @@\n+    color: var(--block-text-color);\n@@ -1018,1 +1270,1 @@\n-    color: #404040;\n+    color: var(--block-text-color);\n@@ -1025,0 +1277,1 @@\n+.ui-menu .ui-state-active .search-result-label,\n@@ -1026,1 +1279,1 @@\n-    color: #383838;\n+    color: var(--selected-text-color);\n@@ -1045,0 +1298,11 @@\n+body.theme-dark input[type=\"text\"] {\n+    background-image: var(--glass-svg-dark);\n+}\n+@media (prefers-color-scheme: dark) {\n+    input[type=\"text\"] {\n+        background-image: var(--glass-svg-dark);\n+    }\n+    body.theme-light input[type=\"text\"] {\n+        background-image: url('glass.svg');\n+    }\n+}\n@@ -1072,0 +1336,15 @@\n+body.theme-dark input#reset-search,\n+body.theme-dark input.reset-filter,\n+body.theme-dark input#page-search-reset {\n+    background-image: var(--x-svg-dark);\n+}\n+@media (prefers-color-scheme: dark) {\n+    input#reset-search, input.reset-filter, input#page-search-reset {\n+        background-image: var(--x-svg-dark);\n+    }\n+    body.theme-light input#reset-search,\n+    body.theme-light input.reset-filter,\n+    body.theme-light input#page-search-reset {\n+        background-image: url('x.svg');\n+    }\n+}\n@@ -1104,0 +1383,1 @@\n+    color: #282828;\n@@ -1112,1 +1392,2 @@\n-    background-color:var(--search-tag-highlight-color);\n+    background-color:var(--search-tag-background-color);\n+    color:var(--search-tag-text-color);\n@@ -1116,1 +1397,2 @@\n-    background-color: var(--search-tag-highlight-color);\n+    background-color: var(--search-tag-background-color);\n+    color:var(--search-tag-text-color);\n@@ -1163,0 +1445,1 @@\n+    color: var(--selected-text-color);\n@@ -1171,1 +1454,0 @@\n-    color: #404040;\n@@ -1246,0 +1528,21 @@\n+.inherited-list h3 > button {\n+    cursor: pointer;\n+    color: var(--subnav-link-color);\n+    position: relative;\n+    background-color: transparent;\n+    background-image:url(\"right.svg\");\n+    background-repeat: no-repeat;\n+    background-size: 12px;\n+    background-position:3px 6px;\n+    border:none;\n+    width: 1.3em;\n+    height: 1.6em;\n+    vertical-align: middle;\n+    top: -2px;\n+}\n+.inherited-list h3:has(button) {\n+    padding-left: 2px;\n+}\n+.inherited-list.expanded h3 > button {\n+    background-image: url(\"down.svg\");\n+}\n@@ -1253,0 +1556,9 @@\n+.inherited-list > div {\n+    display: none;\n+}\n+.inherited-list.expanded > code {\n+    display: none;\n+}\n+.inherited-list.expanded > div {\n+    display: grid;\n+}\n@@ -1505,11 +1817,0 @@\n-    nav.toc a:link, nav.toc a:visited {\n-        text-decoration:none;\n-        color:var(--link-color);\n-    }\n-    nav.toc a[href]:hover, nav.toc a[href]:focus {\n-        text-decoration:none;\n-        color:var(--link-color-active);\n-    }\n-    :root {\n-        scroll-behavior: auto;\n-    }\n@@ -1587,1 +1888,1 @@\n-    .ui-autocomplete > li > div,\n+    .ui-autocomplete > li > a,\n@@ -1589,1 +1890,1 @@\n-    .ui-autocomplete > li.result-item > div {\n+    .ui-autocomplete > li.result-item > a {\n@@ -1606,1 +1907,0 @@\n-        padding: 0 16px;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":348,"deletions":48,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -0,0 +1,22 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+ Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+-->\n+\n+<svg version=\"1.1\" viewBox=\"0 0 100 100\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\">\n+    <g fill=\"none\" stroke=\"#fff\" stroke-linecap=\"round\">\n+        <circle cx=\"49.932\" cy=\"50.193\" r=\"24.947\" stroke-width=\"7.6\"\/>\n+        <path d=\"m50.882 5.5255v10.822\" stroke-width=\"7.533\"\/>\n+        <path d=\"m24.315 74.134-7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m75.461 73.989 7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m18.223 16.442c7.6524 7.6524 7.6524 7.6524 7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m83.27 19.68-7.6524 7.6524\" stroke-width=\"7.533\"\/>\n+        <path d=\"m50.014 84.417v10.822\" stroke-width=\"7.533\"\/>\n+        <path d=\"m95.53 49.53h-10.822\" stroke-width=\"7.533\"\/>\n+        <path d=\"m15.446 49.162h-10.822\" stroke-width=\"7.533\"\/>\n+    <\/g>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/sun.svg","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -11,3 +11,3 @@\n-    <path d=\"m8 8 84 84\" style=\"fill:#c6c6c6;fill-opacity:1;stroke:#505050;stroke-width:15;stroke-dasharray:none;stroke-opacity:1\"\/>\n-    <path d=\"M8 92 92 8\" style=\"fill:#000;stroke:#505050;stroke-width:15;stroke-dasharray:none;stroke-opacity:1\"\/>\n-<\/svg>\n\\ No newline at end of file\n+    <path d=\"m8 8 84 84\" style=\"stroke:#505050;stroke-width:15\"\/>\n+    <path d=\"M8 92 92 8\" style=\"stroke:#505050;stroke-width:15\"\/>\n+<\/svg>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/x.svg","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,3 @@\n-        Content desc = tagletWriter.htmlWriter.commentTagsToContent(element, indexTree.getDescription(), context.within(indexTree));\n-        String descText = utils.normalizeWhitespace(extractText(desc));\n+        Content desc = tagletWriter.htmlWriter.commentTagsToContent(element, indexTree.getDescription(),\n+                context.within(indexTree));\n+        String descText = utils.normalizeWhitespace(desc.stripTags().toString());\n@@ -68,6 +69,0 @@\n-\n-    \/\/ ugly but simple;\n-    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n-    private String extractText(Content c) {\n-        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n-    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/IndexTaglet.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.javadoc.internal.html.Entity;\n@@ -51,1 +50,0 @@\n-import jdk.javadoc.internal.html.RawHtml;\n@@ -53,1 +51,0 @@\n-import jdk.javadoc.internal.html.TextBuilder;\n@@ -126,29 +123,1 @@\n-                utils.normalizeWhitespace(textOf(label)), label);\n-    }\n-\n-    \/\/ this is here, for now, but might be a useful addition elsewhere,\n-    \/\/ perhaps as a method on Content\n-    private String textOf(Content c) {\n-        return appendText(new StringBuilder(), c).toString();\n-    }\n-\n-    private StringBuilder appendText(StringBuilder sb, Content c) {\n-        if (c instanceof ContentBuilder cb) {\n-            appendText(sb, cb.getContents());\n-        } else if (c instanceof HtmlTree ht) {\n-            appendText(sb, ht.getContents());\n-        } else if (c instanceof RawHtml rh) {\n-            sb.append(rh.toString().replaceAll(\"<[^>]*>\", \"\"));\n-        } else if (c instanceof TextBuilder tb) {\n-            sb.append(tb.toString());\n-        } else if (c instanceof Text t) {\n-            sb.append(t.toString());\n-        } else if (c instanceof Entity e) {\n-            sb.append(e.toString());\n-        }\n-        return sb;\n-    }\n-\n-    private StringBuilder appendText(StringBuilder sb, List<? extends Content> contents) {\n-        contents.forEach(c -> appendText(sb, c));\n-        return sb;\n+                utils.normalizeWhitespace(label.stripTags().toString()), label);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SpecTaglet.java","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -364,0 +364,4 @@\n+        \/\/ Check if member was already processed\n+        if (dcInfoMap.containsKey(member)) {\n+            return;\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/CommentUtils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+doclet.Toggle_member_listing=Toggle between short and detailed list view\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.function.UnaryOperator;\n@@ -191,1 +192,1 @@\n-        copyResource(resource, url, replaceNewLine, null);\n+        copyResource(resource, url, replaceNewLine, UnaryOperator.identity());\n@@ -205,1 +206,1 @@\n-        copyResource(resource, url, true, resources);\n+        copyResource(resource, url, resources == null ? UnaryOperator.identity() : line -> localize(line, resources));\n@@ -208,2 +209,18 @@\n-    private void copyResource(DocPath resource, URL url, boolean replaceNewLine, Resources resources)\n-                throws DocFileIOException, ResourceIOException {\n+    \/**\n+     * Copy the contents of a resource file to this file while transforming and filtering its lines.\n+     *\n+     * @param resource the path of the resource\n+     * @param url the URL of the resource\n+     * @param lineTransformer the transforming function that is called for each line; may return\n+     * {@code null} to remove a line.\n+     *\n+     * @throws DocFileIOException if there is a problem while writing the copy\n+     * @throws ResourceIOException if there is a problem while reading the resource\n+     *\/\n+    public void copyResource(DocPath resource, URL url, UnaryOperator<String> lineTransformer)\n+            throws DocFileIOException, ResourceIOException {\n+        copyResource(resource, url, true, lineTransformer);\n+    }\n+\n+    private void copyResource(DocPath resource, URL url, boolean replaceNewLine, UnaryOperator<String> lineTransformer)\n+            throws ResourceIOException, DocFileIOException {\n@@ -219,2 +236,5 @@\n-                                write(this, writer, resources == null ? line : localize(line, resources));\n-                                write(this, writer, PLATFORM_LINE_SEPARATOR);\n+                                String transformedLine = lineTransformer.apply(line);\n+                                if (transformedLine != null) {\n+                                    write(this, writer, transformedLine);\n+                                    write(this, writer, PLATFORM_LINE_SEPARATOR);\n+                                }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocFile.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -109,0 +109,3 @@\n+    \/** The name of the downwards pointing angle icon. *\/\n+    public static final DocPath DOWN_SVG = DocPath.create(\"down.svg\");\n+\n@@ -118,0 +121,6 @@\n+    \/** The name of the moon icon for the dark theme. *\/\n+    public static final DocPath MOON_SVG = DocPath.create(\"moon.svg\");\n+\n+    \/** The name of the sun icon for the light theme. *\/\n+    public static final DocPath SUN_SVG = DocPath.create(\"sun.svg\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -145,0 +145,7 @@\n+    \/**\n+     * {@return the plain text of this content with HTML tags removed}\n+     *\/\n+    public Content stripTags() {\n+        return this;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/Content.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -108,0 +108,9 @@\n+    @Override\n+    public Content stripTags() {\n+        var text = new ContentBuilder();\n+        for (Content c : contents) {\n+            text.add(c.stripTags());\n+        }\n+        return text;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/ContentBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+        RADIO,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/HtmlAttr.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+        Objects.requireNonNull(content, \"Content must not be null\");\n@@ -282,0 +283,9 @@\n+    @Override\n+    public Content stripTags() {\n+        var text = new ContentBuilder();\n+        for (Content c : content) {\n+            text.add(c.stripTags());\n+        }\n+        return text;\n+    }\n+\n@@ -589,2 +599,1 @@\n-        return new HtmlTree(HtmlTag.FOOTER)\n-                .setRole(HtmlAttr.Role.CONTENTINFO);\n+        return new HtmlTree(HtmlTag.FOOTER);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/HtmlTree.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -160,0 +160,5 @@\n+    @Override\n+    public Content stripTags() {\n+        return Text.of(rawHtmlContent.replaceAll(\"<[^>]*>\", \"\"));\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/RawHtml.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -65,1 +63,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jdeps\/share\/classes\/module-info.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,2 +405,2 @@\n-     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n-     * target VM was unable to pop the frames.\n+     * @throws OpaqueFrameException if the target VM is unable to pop this frame\n+     * (e.g. a virtual thread is suspended, but not at an event).\n@@ -487,2 +487,2 @@\n-     * @throws OpaqueFrameException if this thread is a suspended virtual thread and the\n-     * target VM is unable to force the method to return.\n+     * @throws OpaqueFrameException if the target VM is unable to force the method to return\n+     * (e.g. a virtual thread is suspended, but not at an event).\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -398,16 +398,13 @@\n-                if (thread.isVirtual()) {\n-                    \/\/ We first need to find out if the current frame is native, or if the\n-                    \/\/ previous frame is native, in which case we throw NativeMethodException\n-                    for (int i = 0; i < 2; i++) {\n-                        StackFrameImpl sf;\n-                        try {\n-                            sf = (StackFrameImpl)thread.frame(i);\n-                        } catch (IndexOutOfBoundsException e) {\n-                            \/\/ This should never happen, but we need to check for it.\n-                            break;\n-                        }\n-                        sf.validateStackFrame();\n-                        MethodImpl meth = (MethodImpl)sf.location().method();\n-                        if (meth.isNative()) {\n-                            throw new NativeMethodException();\n-                        }\n+                \/\/ We first need to find out if the current frame is native, or if the\n+                \/\/ previous frame is native, in which case we throw NativeMethodException\n+                for (int i = 0; i < 2; i++) {\n+                    StackFrame sf;\n+                    try {\n+                        sf = thread.frame(i);\n+                    } catch (IndexOutOfBoundsException e) {\n+                        \/\/ This should never happen, but we need to check for it.\n+                        break;\n+                    }\n+                    Method meth = sf.location().method();\n+                    if (meth.isNative()) {\n+                        throw new NativeMethodException();\n@@ -415,5 +412,0 @@\n-                    \/\/ No native frames involved. Must have been due to thread\n-                    \/\/ not being mounted.\n-                    throw new OpaqueFrameException();\n-                } else {\n-                    throw new NativeMethodException();\n@@ -421,0 +413,3 @@\n+                \/\/ No native frames involved. Must have been due to virtual thread\n+                \/\/ not being mounted or some other reason such as failure to deopt.\n+                throw new OpaqueFrameException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/StackFrameImpl.java","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -600,3 +600,1 @@\n-                if (isVirtual() && !meth.isNative()) {\n-                    throw new OpaqueFrameException();\n-                } else {\n+                if (meth.isNative()) {\n@@ -604,0 +602,2 @@\n+                } else {\n+                    throw new OpaqueFrameException();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ThreadReferenceImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                descriptors.add(String.valueOf(object));\n+                values.add(String.valueOf(object));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/AnnotationElement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-     * Returns the settings that specifies how a recording is configured.\n+     * Returns the settings that specify how a recording is configured.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Configuration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-     * @return {@code true} if by default the event should be enabled by default, {@code false} otherwise\n+     * @return {@code true} if by default the event should be enabled, {@code false} otherwise\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Enabled.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-            label = platformEventType.getLabel();;\n+            label = platformEventType.getLabel();\n@@ -229,1 +229,1 @@\n-     * Returns the list of human-readable names that makes up the categories for\n+     * Returns the list of human-readable names that make up the categories for\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-     * This method is also be invoked when a listener is added to an already\n+     * This method is also invoked when a listener is added to an already\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorderListener.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * The following example shows how configure, start, stop and dump recording data to disk.\n+ * The following example shows how to configure, start, stop and dump recording data to disk.\n@@ -141,1 +141,1 @@\n-     * @param configuration configuration that contains the settings to be use, not\n+     * @param configuration configuration that contains the settings to be used, not\n@@ -342,1 +342,1 @@\n-     * with the {@link #setMaxAge(Duration)} method and the {@link #setMaxSize(long)}method.\n+     * with the {@link #setMaxAge(Duration)} method and the {@link #setMaxSize(long)} method.\n@@ -618,1 +618,1 @@\n-     * If multiple events with same name (for example, the same class is loaded\n+     * If multiple events with the same name (for example, the same class is loaded\n@@ -620,1 +620,1 @@\n-     * name is disabled. To disable a specific class, use the\n+     * name are disabled. To disable a specific class, use the\n@@ -656,1 +656,1 @@\n-     * @param eventClass the event to enable, not {@code null}\n+     * @param eventClass the event to disable, not {@code null}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Recording.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-     * Specifies that events arrives in chronological order, sorted by the time\n+     * Specifies that events arrive in chronological order, sorted by the time\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/EventStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-     * @return an immutable list of added event types, not {@code null}\n+     * @return an immutable list of removed event types, not {@code null}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/MetadataEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-     * Returns the class this method belongs to, if it belong to a Java frame.\n+     * Returns the class this method belongs to, if it belongs to a Java frame.\n@@ -102,1 +102,1 @@\n-     * expressions).\n+     * expression).\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedMethod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-        if (object == null || object.getClass().isAssignableFrom(clazz)) {\n+        if (object == null || object.getClass() == clazz) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordedObject.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * The following example shows how read and print all events in a recording file.\n+ * The following example shows how to read and print all events in a recording file.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -235,2 +235,2 @@\n-     * If neither maximum limit or the maximum age is set, the size of the\n-     * recording may grow indefinitely if events are on\n+     * If neither the maximum limit nor the maximum age is set, the size of the\n+     * recording may grow indefinitely if events are not consumed.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * parameters is passed to a method that throws other exceptions, such as\n+ * parameter is passed to a method that throws other exceptions, such as\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-            eventType.setThrottler(new Throttler(eventType));\n+            eventType.setThrottler(new Throttler());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                list.add(o);\n+                list.add(o == NULL_OBJECT ? null : o);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LongMap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.jfr.events.ActiveSettingEvent;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.jfr.FlightRecorderPermission;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PrivateAccess.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.file.Paths;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ChunkFilename.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.jfr.internal.MetadataRepository;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/FlushTask.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+        @SuppressWarnings({ \"unchecked\"})\n@@ -61,2 +61,2 @@\n-            if (keys instanceof Set set) {\n-                set.add(o);\n+            if (keys instanceof Set<?> set) {\n+                ((Set<Object>) set).add(o);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Histogram.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.BiConsumer;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryParser.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,3 +43,3 @@\n-         SELECT E.id, LAST_BATCH(E.value), LAST_BATCH(T.value),\n-                LAST_BATCH(S.value), LAST_BATCH(P.value),\n-                LAST_BATCH(C.value), LAST_BATCH(U.value)\n+         SELECT E.id, LAST(E.value), LAST(T.value),\n+                LAST(S.value), LAST(P.value),\n+                LAST(C.value), LAST(U.value)\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,0 @@\n-import static jdk.jfr.internal.util.TimespanUnit.SECONDS;\n-import static jdk.jfr.internal.util.TimespanUnit.MILLISECONDS;\n-\n@@ -44,1 +41,0 @@\n-import jdk.jfr.internal.util.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CPUThrottleSetting.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    private volatile static boolean initialized;\n+    private static volatile boolean initialized;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/MethodSetting.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-    public Throttler(PlatformEventType t) {\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/Throttler.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    public static <T> Predicate<T> matchAny(List<Predicate<T>> filters) {\n+    public static <T> Predicate<T> matchAll(List<Predicate<T>> filters) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Filters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,1 +206,1 @@\n-                filter =  Filters.matchAny(filters);\n+                filter = Filters.matchAll(filters);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Array;\n@@ -294,1 +295,1 @@\n-                printValue(frame, null, \"\");\n+                printJavaFrame(frame, \"\");\n@@ -326,1 +327,1 @@\n-    private void printArray(Object[] array) {\n+    private void printArray(Object[] array, ValueDescriptor field) {\n@@ -331,1 +332,1 @@\n-            printValue(array[i], null, i + 1 < array.length ? \", \" : \"\");\n+            printValue(array[i], field, i + 1 < array.length ? \", \" : \"\");\n@@ -339,37 +340,9 @@\n-        if (value == null) {\n-            println(\"N\/A\" + postFix);\n-            return;\n-        }\n-        if (value instanceof RecordedObject) {\n-            if (value instanceof RecordedThread rt) {\n-                printThread(rt, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedClass rc) {\n-                printClass(rc, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedClassLoader rcl) {\n-                printClassLoader(rcl, postFix);\n-                return;\n-            }\n-            if (value instanceof RecordedFrame frame) {\n-                if (frame.isJavaFrame()) {\n-                    printJavaFrame((RecordedFrame) value, postFix);\n-                    return;\n-                }\n-            }\n-            if (value instanceof RecordedMethod rm) {\n-                println(formatMethod(rm));\n-                return;\n-            }\n-            if (field.getTypeName().equals(TYPE_OLD_OBJECT)) {\n-                printOldObject((RecordedObject) value);\n-                return;\n-            }\n-             print((RecordedObject) value, postFix);\n-            return;\n-        }\n-        if (value.getClass().isArray()) {\n-            printArray((Object[]) value);\n-            return;\n+        switch (value) {\n+            case null -> println(\"N\/A\" + postFix);\n+            case RecordedObject object -> printRecordedObject(object, field, postFix);\n+            case Number number -> printNumber(number, field);\n+            case String text -> println(\"\\\"\" + text + \"\\\"\");\n+            case Duration duration -> printDuration(duration);\n+            case OffsetDateTime dateTime -> printOffsetDateTime(dateTime);\n+            case Object[] array -> printArray(array, field);\n+            default -> println(value);\n@@ -377,0 +350,1 @@\n+    }\n@@ -378,29 +352,9 @@\n-        if (value instanceof Double d) {\n-            if (Double.isNaN(d) || d == Double.NEGATIVE_INFINITY) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Float f) {\n-            if (Float.isNaN(f) || f == Float.NEGATIVE_INFINITY) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Long l) {\n-            if (l == Long.MIN_VALUE) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-        if (value instanceof Integer i) {\n-            if (i == Integer.MIN_VALUE) {\n-                println(\"N\/A\");\n-                return;\n-            }\n-        }\n-\n-        if (field.getContentType() != null) {\n-            if (printFormatted(field, value)) {\n-                return;\n-            }\n+    private void printRecordedObject(RecordedObject struct, ValueDescriptor field, String postFix) {\n+        switch (struct) {\n+            case RecordedThread rt -> printThread(rt, postFix);\n+            case RecordedClass rc -> printClass(rc, postFix);\n+            case RecordedClassLoader rcl -> printClassLoader(rcl, postFix);\n+            case RecordedFrame rf when rf.isJavaFrame() -> printJavaFrame(rf, postFix);\n+            case RecordedMethod rm -> println(formatMethod(rm));\n+            case RecordedObject ro when field.getTypeName().equals(TYPE_OLD_OBJECT) -> printOldObject(ro);\n+            default -> print(struct, postFix);\n@@ -408,0 +362,1 @@\n+    }\n@@ -409,3 +364,7 @@\n-        String text = String.valueOf(value);\n-        if (value instanceof String) {\n-            text = \"\\\"\" + text + \"\\\"\";\n+    private void printNumber(Number number, ValueDescriptor field) {\n+        switch (number) {\n+            case Double d when Double.isNaN(d) || d == Double.NEGATIVE_INFINITY -> println(\"N\/A\");\n+            case Float f when Float.isNaN(f) || f == Float.NEGATIVE_INFINITY -> println(\"N\/A\");\n+            case Long l when l == Long.MIN_VALUE -> println(\"N\/A\");\n+            case Integer i when i == Integer.MIN_VALUE -> println(\"N\/A\");\n+            default -> printFormatted(field, number);\n@@ -413,1 +372,0 @@\n-        println(text);\n@@ -549,16 +507,4 @@\n-    private boolean printFormatted(ValueDescriptor field, Object value) {\n-        if (value instanceof Duration d) {\n-            if (d.getSeconds() == Long.MIN_VALUE && d.getNano() == 0)  {\n-                println(\"N\/A\");\n-                return true;\n-            }\n-            if (d.equals(ChronoUnit.FOREVER.getDuration())) {\n-                println(\"Forever\");\n-                return true;\n-            }\n-            if (showExact) {\n-                println(String.format(\"%.9f s\", (double) d.toNanos() \/ 1_000_000_000));\n-            } else {\n-                println(ValueFormatter.formatDuration(d));\n-            }\n-            return true;\n+    private void printOffsetDateTime(OffsetDateTime dateTime) {\n+        if (dateTime.equals(OffsetDateTime.MIN)) {\n+            println(\"N\/A\");\n+            return;\n@@ -566,11 +512,11 @@\n-        if (value instanceof OffsetDateTime odt) {\n-            if (odt.equals(OffsetDateTime.MIN))  {\n-                println(\"N\/A\");\n-                return true;\n-            }\n-            if (showExact) {\n-                println(TIME_FORMAT_EXACT.format(odt));\n-            } else {\n-                println(TIME_FORMAT.format(odt));\n-            }\n-            return true;\n+        if (showExact) {\n+            println(TIME_FORMAT_EXACT.format(dateTime));\n+        } else {\n+            println(TIME_FORMAT.format(dateTime));\n+        }\n+    }\n+\n+    private void printDuration(Duration duration) {\n+        if (duration.getSeconds() == Long.MIN_VALUE && duration.getNano() == 0) {\n+            println(\"N\/A\");\n+            return;\n@@ -578,4 +524,16 @@\n-        Percentage percentage = field.getAnnotation(Percentage.class);\n-        if (percentage != null) {\n-            if (value instanceof Number n) {\n-                double p = 100 * n.doubleValue();\n+        if (duration.equals(ChronoUnit.FOREVER.getDuration())) {\n+            println(\"Forever\");\n+            return;\n+        }\n+        if (showExact) {\n+            println(String.format(\"%.9f s\", (double) duration.toNanos() \/ 1_000_000_000));\n+        } else {\n+            println(ValueFormatter.formatDuration(duration));\n+        }\n+    }\n+\n+    private void printFormatted(ValueDescriptor field, Number number) {\n+        if (field.getContentType() != null) {\n+            Percentage percentage = field.getAnnotation(Percentage.class);\n+            if (percentage != null) {\n+                double p = 100 * number.doubleValue();\n@@ -587,1 +545,1 @@\n-                return true;\n+                return;\n@@ -589,10 +547,10 @@\n-        }\n-        DataAmount dataAmount = field.getAnnotation(DataAmount.class);\n-        if (dataAmount != null && value instanceof Number number) {\n-            boolean frequency = field.getAnnotation(Frequency.class) != null;\n-            String unit = dataAmount.value();\n-            boolean bits = unit.equals(DataAmount.BITS);\n-            boolean bytes = unit.equals(DataAmount.BYTES);\n-            if (bits || bytes) {\n-                formatMemory(number.longValue(), bytes, frequency);\n-                return true;\n+            DataAmount dataAmount = field.getAnnotation(DataAmount.class);\n+            if (dataAmount != null) {\n+                boolean frequency = field.getAnnotation(Frequency.class) != null;\n+                String unit = dataAmount.value();\n+                boolean bits = unit.equals(DataAmount.BITS);\n+                boolean bytes = unit.equals(DataAmount.BYTES);\n+                if (bits || bytes) {\n+                    printMemory(number.longValue(), bytes, frequency);\n+                    return;\n+                }\n@@ -600,5 +558,3 @@\n-        }\n-        MemoryAddress memoryAddress = field.getAnnotation(MemoryAddress.class);\n-        if (memoryAddress != null) {\n-            if (value instanceof Number n) {\n-                long d = n.longValue();\n+            MemoryAddress memoryAddress = field.getAnnotation(MemoryAddress.class);\n+            if (memoryAddress != null) {\n+                long d = number.longValue();\n@@ -606,1 +562,1 @@\n-                return true;\n+                return;\n@@ -608,6 +564,4 @@\n-        }\n-        Frequency frequency = field.getAnnotation(Frequency.class);\n-        if (frequency != null) {\n-            if (value instanceof Number) {\n-                println(value + \" Hz\");\n-                return true;\n+            Frequency frequency = field.getAnnotation(Frequency.class);\n+            if (frequency != null) {\n+                println(number + \" Hz\");\n+                return;\n@@ -616,2 +570,1 @@\n-\n-        return false;\n+        println(number);\n@@ -620,1 +573,1 @@\n-    private void formatMemory(long value, boolean bytesUnit, boolean frequency) {\n+    private void printMemory(long value, boolean bytesUnit, boolean frequency) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":83,"deletions":130,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-            eventWriter.setEventFilter(Filters.matchAny(eventFilters));\n+            eventWriter.setEventFilter(Filters.matchAll(eventFilters));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Print.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-        return Filters.matchAny(filters);\n+        return Filters.matchAll(filters);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Scrub.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,4 @@\n+    public final void println(Object object) {\n+        println(String.valueOf(object));\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/StructuredWriter.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.jfr.internal.Type;\n@@ -267,10 +266,9 @@\n-        try {\n-            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"Method tracer initialization started.\");\n-            Thread current = Thread.currentThread();\n-            JVM.exclude(current);\n-            long methodId = 16384126;\n-            long classId = methodId >> 16;\n-            ClassLoader cl = null;\n-            String className = \" java\/lang\/String\";\n-            Module m = String.class.getModule();\n-            var is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"java\/lang\/String.class\");\n+        Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"Method tracer initialization started.\");\n+        Thread current = Thread.currentThread();\n+        JVM.exclude(current);\n+        long methodId = 16384126;\n+        long classId = methodId >> 16;\n+        ClassLoader cl = null;\n+        String className = \"java\/lang\/String\";\n+        Module m = String.class.getModule();\n+        try (var is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"java\/lang\/String.class\")) {\n@@ -278,1 +276,0 @@\n-            is.close();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/PlatformTracer.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.jfr.internal.settings.CPUThrottleSetting;\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/TimespanRate.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * fields that matches the data types of the payload. Metadata about fields,\n+ * fields that match the data types of the payload. Metadata about fields,\n@@ -235,1 +235,1 @@\n- * parameters is passed to a method that throws other exceptions, such as\n+ * parameters are passed to a method that throws other exceptions, such as\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -34,1 +32,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jfr\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n@@ -41,1 +41,1 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n@@ -765,1 +765,1 @@\n-      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"enabled\">false<\/setting>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -56,1 +54,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jlink\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.jpackage.internal.model.LauncherShortcut;\n@@ -240,0 +241,17 @@\n+        data.put(\"STARTUP_DIRECTORY\", launcher.shortcut()\n+                .flatMap(LauncherShortcut::startupDirectory)\n+                .map(startupDirectory -> {\n+                    switch (startupDirectory) {\n+                        case DEFAULT -> {\n+                            return (Path)null;\n+                        }\n+                        case APP_DIR -> {\n+                            return installedLayout.appDirectory();\n+                        }\n+                        default -> {\n+                            throw new AssertionError();\n+                        }\n+                    }\n+                }).map(str -> {\n+                    return \"Path=\" + str;\n+                }).orElse(null));\n@@ -340,1 +358,1 @@\n-        var srcPath = pkg.asPackageApplicationLayout().orElseThrow().resolveAt(env.appImageDir()).desktopIntegrationDirectory().resolve(fileName);\n+        var srcPath = env.asApplicationLayout().orElseThrow().desktopIntegrationDirectory().resolve(fileName);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -43,2 +44,20 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, libAppLauncher()));\n+        return (LinuxApplicationLayout)ApplicationLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout unresolve() {\n+        return (LinuxApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), libAppLauncher());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, libAppLauncher()));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayout.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayoutMixin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -354,2 +354,1 @@\n-                AppImageLayout.toPathGroup(pkg.packageLayout().resolveAt(\n-                        env.appImageDir())).sizeInBytes() >> 10));\n+                AppImageLayout.toPathGroup(env.appImageLayout()).sizeInBytes() >> 10));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -112,6 +112,2 @@\n-    private static final BundlerParamInfo<Boolean> LINUX_SHORTCUT_HINT = new BundlerParamInfo<>(\n-            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n-            Boolean.class,\n-            params -> false,\n-            (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ? false : Boolean.valueOf(s)\n-    );\n+    private static final BundlerParamInfo<String> LINUX_SHORTCUT_HINT = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId());\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.jpackage.internal.model.LinuxApplication;\n@@ -37,0 +38,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -55,1 +57,1 @@\n-        final var pkg = pkgBuilder.create();\n+        final var tmpPkg = pkgBuilder.create();\n@@ -57,1 +59,1 @@\n-        final var stdPkgType = pkg.asStandardPackageType();\n+        final var stdPkgType = tmpPkg.asStandardPackageType();\n@@ -59,1 +61,1 @@\n-            validatePackageName(pkg.packageName(), stdPkgType.orElseThrow());\n+            validatePackageName(tmpPkg.packageName(), stdPkgType.orElseThrow());\n@@ -62,3 +64,10 @@\n-        var reply = create(pkg, pkg.packageLayout());\n-        if (reply.isInstallDirInUsrTree()) {\n-            reply = create(pkg, usrTreePackageLayout(pkg.relativeInstallDir(), pkg.packageName()));\n+        final AppImageLayout relativeInstalledLayout;\n+        if (create(tmpPkg).isInstallDirInUsrTree()) {\n+            final var usrTreeLayout = usrTreePackageLayout(tmpPkg.relativeInstallDir(), tmpPkg.packageName());\n+            if (tmpPkg.isRuntimeInstaller()) {\n+                relativeInstalledLayout = RuntimeLayout.create(usrTreeLayout.runtimeDirectory());\n+            } else {\n+                relativeInstalledLayout = usrTreeLayout;\n+            }\n+        } else {\n+            relativeInstalledLayout = tmpPkg.appImageLayout().resolveAt(tmpPkg.relativeInstallDir()).resetRootDirectory();\n@@ -67,1 +76,6 @@\n-        return reply;\n+        final var app = ApplicationBuilder.overrideAppImageLayout(pkgBuilder.app(), relativeInstalledLayout);\n+\n+        return create(pkgBuilder\n+                .app(LinuxApplication.create(app))\n+                .installedPackageLayout(relativeInstalledLayout.resolveAt(Path.of(\"\/\")).resetRootDirectory())\n+                .create());\n@@ -70,1 +84,1 @@\n-    private LinuxPackage create(Package pkg, AppImageLayout pkgLayout) throws ConfigException {\n+    private LinuxPackage create(Package pkg) throws ConfigException {\n@@ -72,1 +86,0 @@\n-                pkgLayout,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBuilder.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-    @Override\n-    AppImageLayout packageLayout();\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackage.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,5 +34,0 @@\n-    \/**\n-     * Overrides {@link Package#packageLayout()}.\n-     *\/\n-    AppImageLayout packageLayout();\n-\n@@ -91,1 +86,1 @@\n-    record Stub(AppImageLayout packageLayout, String menuGroupName,\n+    record Stub(String menuGroupName,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackageMixin.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+STARTUP_DIRECTORY\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.desktop","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -47,0 +49,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -53,1 +56,1 @@\n-    static Consumer<Path> createSigner(MacApplication app, CodesignConfig signingCfg) {\n+    static Consumer<MacBundle> createSigner(MacApplication app, CodesignConfig signingCfg) {\n@@ -70,1 +73,1 @@\n-        SignFilter(Application app, Path appImage) {\n+        SignFilter(Application app, MacBundle appImage) {\n@@ -75,1 +78,1 @@\n-                return appLayout.resolveAt(appImage);\n+                return appLayout.resolveAt(appImage.root());\n@@ -101,1 +104,6 @@\n-    private void sign(MacApplication app, Path appImage) throws CodesignException, IOException {\n+    private void sign(MacApplication app, MacBundle appImage) throws CodesignException, IOException {\n+        if (!appImage.isValid()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        app = normalizeAppImageLayout(app);\n@@ -105,1 +113,1 @@\n-        try (var content = Files.walk(appImage)) {\n+        try (var content = Files.walk(appImage.root())) {\n@@ -121,1 +129,1 @@\n-            return appLayout.resolveAt(appImage);\n+            return appLayout.resolveAt(appImage.root());\n@@ -124,1 +132,1 @@\n-        final var frameworkPath = appImage.resolve(\"Contents\/Frameworks\");\n+        final var frameworkPath = appImage.contentsDir().resolve(\"Frameworks\");\n@@ -134,1 +142,1 @@\n-        codesigners.accept(appImage);\n+        codesigners.accept(appImage.root());\n@@ -238,0 +246,14 @@\n+    private static MacApplication normalizeAppImageLayout(MacApplication app) {\n+        switch (app.imageLayout()) {\n+            case MacApplicationLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, APPLICATION_LAYOUT);\n+            }\n+            case RuntimeLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, RUNTIME_BUNDLE_LAYOUT);\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                 env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+                 env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n@@ -49,1 +49,1 @@\n-                 env = BuildEnv.withAppImageDir(BuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n+                 env = BuildEnv.withAppImageDir(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.file.Files;\n@@ -30,0 +31,2 @@\n+import java.util.List;\n+import java.util.Set;\n@@ -37,0 +40,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -97,0 +101,1 @@\n+        validateAppContentDirs(app);\n@@ -98,2 +103,7 @@\n-        final var mixin = new MacApplicationMixin.Stub(validatedIcon(), validatedBundleName(),\n-                validatedBundleIdentifier(), validatedCategory(), appStore, createSigningConfig());\n+        final var mixin = new MacApplicationMixin.Stub(\n+                validatedIcon(),\n+                validatedBundleName(),\n+                validatedBundleIdentifier(),\n+                validatedCategory(),\n+                appStore,\n+                createSigningConfig());\n@@ -104,0 +114,11 @@\n+    static MacApplication overrideAppImageLayout(MacApplication app, AppImageLayout appImageLayout) {\n+        final var mixin = new MacApplicationMixin.Stub(\n+                app.icon(),\n+                app.bundleName(),\n+                app.bundleIdentifier(),\n+                app.category(),\n+                app.appStore(),\n+                app.signingConfig());\n+        return MacApplication.create(ApplicationBuilder.overrideAppImageLayout(app, appImageLayout), mixin);\n+    }\n+\n@@ -126,0 +147,12 @@\n+    private static void validateAppContentDirs(Application app) {\n+        for (var contentDir : app.contentDirs()) {\n+            if (!Files.isDirectory(contentDir)) {\n+                Log.info(I18N.format(\"warning.app.content.is.not.dir\",\n+                        contentDir));\n+            } else if (!CONTENTS_SUB_DIRS.contains(contentDir.getFileName().toString())) {\n+                Log.info(I18N.format(\"warning.non.standard.contents.sub.dir\",\n+                        contentDir));\n+            }\n+        }\n+    }\n+\n@@ -236,0 +269,4 @@\n+\n+    \/\/ List of standard subdirectories of the \"Contents\" directory\n+    private static final Set<String> CONTENTS_SUB_DIRS = Set.of(\"MacOS\",\n+            \"Resources\", \"Frameworks\", \"PlugIns\", \"SharedSupport\");\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationBuilder.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -38,1 +39,2 @@\n-                .create(MacApplicationLayout.class, layout, new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n+                .create(MacApplicationLayout.class, layout,\n+                        new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n@@ -43,2 +45,1 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, runtimeRootDirectory()));\n+        return (MacApplicationLayout)ApplicationLayout.super.resolveAt(root);\n@@ -46,0 +47,20 @@\n+\n+    @Override\n+    default MacApplicationLayout unresolve() {\n+        return (MacApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default MacApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), runtimeRootDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default MacApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, runtimeRootDirectory()));\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayout.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n@@ -33,1 +33,2 @@\n-     * Path to the root Java runtime directory in the application image.\n+     * Returns path to the root Java runtime directory in the application image.\n+     * <p>\n@@ -35,0 +36,2 @@\n+     *\n+     * @return the path to the root Java runtime directory in the application image\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayoutMixin.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import jdk.jpackage.internal.model.MacPackage;\n+\n+final class MacBuildEnvFromParams {\n+\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return BuildEnvFromParams.create(params, MacPackagingPipeline.APPLICATION_LAYOUT::resolveAt, MacPackage::guessRuntimeLayout);\n+    });\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBuildEnvFromParams.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -76,2 +77,14 @@\n-    static MacBundle fromAppImageLayout(AppImageLayout layout) {\n-        return new MacBundle(layout.rootDirectory());\n+    static Optional<MacBundle> fromAppImageLayout(AppImageLayout layout) {\n+        final var root = layout.rootDirectory();\n+        final var bundleSubdir = root.relativize(layout.runtimeDirectory());\n+        final var contentsDirname = Path.of(\"Contents\");\n+        var bundleRoot = root;\n+        for (int i = 0; i != bundleSubdir.getNameCount(); i++) {\n+            var nameComponent = bundleSubdir.getName(i);\n+            if (contentsDirname.equals(nameComponent)) {\n+                return Optional.of(new MacBundle(bundleRoot));\n+            } else {\n+                bundleRoot = bundleRoot.resolve(nameComponent);\n+            }\n+        }\n+        return Optional.empty();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundle.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-        final var superPkgBuilder = pkgBuilder.pkgBuilder();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackageBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static jdk.jpackage.internal.model.MacPackage.RUNTIME_PACKAGE_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -48,1 +48,0 @@\n-import java.nio.file.Files;\n@@ -67,0 +66,1 @@\n+import jdk.jpackage.internal.model.MacPackage;\n@@ -78,7 +78,3 @@\n-        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params).map(predefinedRuntimeImage -> {\n-            if (Files.isDirectory(RUNTIME_PACKAGE_LAYOUT.resolveAt(predefinedRuntimeImage).runtimeDirectory())) {\n-                return RUNTIME_PACKAGE_LAYOUT;\n-            } else {\n-                return RuntimeLayout.DEFAULT;\n-            }\n-        });\n+        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params)\n+                .map(MacPackage::guessRuntimeLayout)\n+                .map(RuntimeLayout::unresolve);\n@@ -91,1 +87,1 @@\n-        }), APPLICATION_LAYOUT, predefinedRuntimeLayout);\n+        }), APPLICATION_LAYOUT, RUNTIME_BUNDLE_LAYOUT, predefinedRuntimeLayout);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.LayoutUtils.packagerLayout;\n+\n@@ -29,0 +31,1 @@\n+import jdk.jpackage.internal.model.MacApplication;\n@@ -48,1 +51,9 @@\n-        final var pkg = pkgBuilder.create();\n+\n+        final var app = (MacApplication)pkgBuilder.app();\n+\n+        var pkg = pkgBuilder.create();\n+\n+        pkgBuilder.app(MacApplicationBuilder.overrideAppImageLayout(app, packagerLayout(pkg)))\n+                .installedPackageLayout(pkg.installedPackageLayout());\n+\n+        pkg = pkgBuilder.create();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.UncheckedIOException;\n@@ -52,0 +53,1 @@\n+import java.util.function.UnaryOperator;\n@@ -56,0 +58,1 @@\n+import jdk.jpackage.internal.PackagingPipeline.AppImageTaskAction;\n@@ -101,4 +104,0 @@\n-    static AppImageLayout packagingLayout(Package pkg) {\n-        return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName());\n-    }\n-\n@@ -107,9 +106,2 @@\n-                .appContextMapper(appContext -> {\n-                    return new TaskContextProxy(appContext, true, false);\n-                })\n-                .pkgContextMapper(appContext -> {\n-                    final var isRuntimeInstaller = pkg.map(Package::isRuntimeInstaller).orElse(false);\n-                    final var withPredefinedAppImage = pkg.flatMap(Package::predefinedAppImage).isPresent();\n-                    return new TaskContextProxy(appContext, false, isRuntimeInstaller || withPredefinedAppImage);\n-                })\n-                .appImageLayoutForPackaging(MacPackagingPipeline::packagingLayout)\n+                .contextMapper(pkg.map(MacPackagingPipeline::mapPackageTaskContext)\n+                        .orElseGet(MacPackagingPipeline::mapAppTaskContext))\n@@ -159,1 +151,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -165,1 +157,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -185,1 +177,0 @@\n-                builder.appImageLayoutForPackaging(Package::appImageLayout);\n@@ -239,2 +230,49 @@\n-    private static void copyAppImage(MacPackage pkg, AppImageDesc srcAppImage,\n-            AppImageDesc dstAppImage) throws IOException {\n+    static final class LayoutUtils {\n+        \/**\n+         * Returns unresolved app image layout for the specified package for use with\n+         * the signing function defined in {@link MacPackagingPipeline} class and\n+         * {@link MacPkgPackager} and {@link MacDmgPackager} packagers.\n+         * <p>\n+         * Paths of the result app image layout will start with the bundle name. E.g.:\n+         * for a package with relative installation directory set to\n+         * {@code \"Applications\/Acme\/MyApp.app\"} and the \"launchers\" directory of an\n+         * application layout set to {@code \"Contents\/MacOS\"}, the result application\n+         * layout object will be such that the value of its \"launchers\" directory will\n+         * be {@code \"MyApp.app\/Contents\/MacOS\"}. The root directory of the result app\n+         * image layout will be an empty path ({@link Path.of(\"\")}), i.e. the app image\n+         * layout will be unresolved.\n+         *\n+         * @param pkg the package\n+         * @return the unresolved app image layout for the specified package suitable\n+         *         for the use with macosx packaging pipeline and packagers\n+         *\/\n+        static AppImageLayout packagerLayout(Package pkg) {\n+            return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName()).resetRootDirectory();\n+        }\n+\n+        static <T extends AppImageLayout> AppImageBuildEnv<MacApplication, T> fromPackagerLayout(AppImageBuildEnv<MacApplication, T> cfg) {\n+\n+            var bundleDirectoryName = cfg.envLayout().runtimeDirectory().getName(0);\n+            var bundleLayout = cfg.envLayout().map(bundleDirectoryName::relativize).resetRootDirectory();\n+            var bundleRoot = cfg.env().appImageDir().resolve(bundleDirectoryName);\n+            var app = MacApplicationBuilder.overrideAppImageLayout(cfg.app(), bundleLayout);\n+            var env = BuildEnv.withAppImageLayout(cfg.env(), bundleLayout.resolveAt(bundleRoot));\n+\n+            return new AppImageBuildEnv<>(env, app);\n+        }\n+\n+        static <T extends AppImageLayout> AppImageTaskAction<MacApplication, T> withBundleLayout(AppImageTaskAction<MacApplication, T> action) {\n+            return new AppImageTaskAction<>() {\n+                @Override\n+                public void execute(AppImageBuildEnv<MacApplication, T> env) throws IOException, PackagerException {\n+                    if (!env.envLayout().runtimeDirectory().getName(0).equals(Path.of(\"Contents\"))) {\n+                        env = LayoutUtils.fromPackagerLayout(env);\n+                    }\n+                    action.execute(env);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static void copyAppImage(MacPackage pkg, AppImageLayout srcAppImage,\n+            AppImageLayout dstAppImage) throws IOException {\n@@ -244,1 +282,6 @@\n-        var inputRootDirectory = srcAppImage.resolvedAppImagelayout().rootDirectory();\n+        final Optional<MacBundle> srcMacBundle;\n+        if (pkg.isRuntimeInstaller()) {\n+            srcMacBundle = MacBundle.fromAppImageLayout(srcAppImage);\n+        } else {\n+            srcMacBundle = Optional.empty();\n+        }\n@@ -246,1 +289,1 @@\n-        if (pkg.isRuntimeInstaller() && MacBundle.isDirectoryMacBundle(inputRootDirectory)) {\n+        srcMacBundle.ifPresentOrElse(inputBundle -> {\n@@ -249,7 +292,15 @@\n-            FileUtils.copyRecursive(\n-                    inputRootDirectory,\n-                    dstAppImage.resolvedAppImagelayout().rootDirectory(),\n-                    LinkOption.NOFOLLOW_LINKS);\n-        } else {\n-            PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !predefinedAppImageSigned);\n-        }\n+            try {\n+                FileUtils.copyRecursive(\n+                        inputBundle.root(),\n+                        MacBundle.fromAppImageLayout(dstAppImage).orElseThrow().root(),\n+                        LinkOption.NOFOLLOW_LINKS);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }, () -> {\n+            try {\n+                PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !predefinedAppImageSigned);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n@@ -275,4 +326,17 @@\n-    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> env) throws IOException {\n-        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env.env(), env.env().appImageDir().resolve(env.envLayout().rootDirectory())),\n-                env.pkg(), env.pkg().appImageLayout(), env.outputDir()));\n+    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> cfg) throws IOException {\n+        var appCfg = LayoutUtils.fromPackagerLayout(\n+                new AppImageBuildEnv<>(cfg.env(), (MacApplication)cfg.pkg().app()));\n+\n+        var pkg = cfg.pkg(); pkg = new Package.Stub(\n+                appCfg.app(),\n+                pkg.type(),\n+                pkg.packageName(),\n+                pkg.description(),\n+                pkg.version(),\n+                pkg.aboutURL(),\n+                pkg.licenseFile(),\n+                pkg.predefinedAppImage(),\n+                pkg.installedPackageLayout(),\n+                pkg.relativeInstallDir());\n+\n+        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(appCfg.env(), pkg, cfg.outputDir()));\n@@ -334,1 +398,1 @@\n-        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).infoPlistFile();\n+        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow().infoPlistFile();\n@@ -387,2 +451,1 @@\n-            final var appImageDir = env.resolvedLayout().rootDirectory();\n-            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(appImageDir);\n+            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow());\n@@ -470,1 +533,1 @@\n-            return new MacBundle(env.resolvedLayout().rootDirectory());\n+            return MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow();\n@@ -501,0 +564,15 @@\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapAppTaskContext() {\n+        return ctx -> {\n+            return new TaskContextProxy(ctx, true, false);\n+        };\n+    }\n+\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapPackageTaskContext(Package pkg) {\n+        return ctx -> {\n+            final var isRuntimeInstaller = pkg.isRuntimeInstaller();\n+            final var withPredefinedAppImage = pkg.predefinedAppImage().isPresent();\n+            return new TaskContextProxy(ctx, false, isRuntimeInstaller || withPredefinedAppImage);\n+        };\n+    }\n+\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":113,"deletions":35,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.nio.file.Files;\n@@ -32,2 +33,0 @@\n-    MacApplication app();\n-\n@@ -35,7 +34,1 @@\n-    default AppImageLayout appImageLayout() {\n-        if (isRuntimeInstaller()) {\n-            return RUNTIME_PACKAGE_LAYOUT;\n-        } else {\n-            return Package.super.appImageLayout();\n-        }\n-    }\n+    MacApplication app();\n@@ -51,1 +44,15 @@\n-    public static final RuntimeLayout RUNTIME_PACKAGE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n+    \/**\n+     * Guesses layout of a runtime image at the given path.\n+     *\n+     * @param path the path to a runtime image\n+     * @return the runtime image layout resolved at the given path\n+     *\/\n+    public static RuntimeLayout guessRuntimeLayout(Path path) {\n+        if (Files.isDirectory(RUNTIME_BUNDLE_LAYOUT.resolveAt(path).runtimeDirectory())) {\n+            return RUNTIME_BUNDLE_LAYOUT.resolveAt(path);\n+        } else {\n+            return RuntimeLayout.DEFAULT.resolveAt(path);\n+        }\n+    }\n+\n+    public static final RuntimeLayout RUNTIME_BUNDLE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacPackage.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-        <string>English<\/string>\n+        <string>en-US<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/ApplicationRuntime-Info.plist.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-  <string>English<\/string>\n+  <string>en-US<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/Info-lite.plist.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+warning.non.standard.contents.sub.dir=Warning: The file name of the directory \"{0}\" specified for the --app-content option is not a standard subdirectory name in the \"Contents\" directory of the application bundle. The result application bundle may fail code signing and\/or notarization.\n+warning.app.content.is.not.dir=Warning: The value \"{0}\" of the --app-content option is not a directory. The result application bundle may fail code signing and\/or notarization.\n\\ No newline at end of file\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-        <string>English<\/string>\n+        <string>en-US<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/Runtime-Info.plist.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-\n-record AppImageDesc(AppImageLayout appImageLayout, Path path) {\n-\n-    AppImageDesc {\n-        Objects.requireNonNull(appImageLayout);\n-        Objects.requireNonNull(path);\n-    }\n-\n-    AppImageLayout resolvedAppImagelayout() {\n-        return appImageLayout.resolveAt(path);\n-    }\n-\n-    Optional<ApplicationLayout> asResolvedApplicationLayout() {\n-        return asApplicationLayout().map(v -> v.resolveAt(path));\n-    }\n-\n-    Optional<ApplicationLayout> asApplicationLayout() {\n-        if (appImageLayout instanceof ApplicationLayout layout) {\n-            return Optional.of(layout);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageDesc.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -156,3 +156,24 @@\n-        return new Launcher.Stub(launcher.name(), Optional.of(startupInfo),\n-                launcher.fileAssociations(), launcher.isService(), launcher.description(),\n-                launcher.icon(), launcher.defaultIconResourceName(), launcher.extraAppImageFileData());\n+        return new Launcher.Stub(\n+                launcher.name(),\n+                Optional.of(startupInfo),\n+                launcher.fileAssociations(),\n+                launcher.isService(),\n+                launcher.description(),\n+                launcher.icon(),\n+                launcher.defaultIconResourceName(),\n+                launcher.extraAppImageFileData());\n+    }\n+\n+    static Application overrideAppImageLayout(Application app, AppImageLayout appImageLayout) {\n+        return new Application.Stub(\n+                app.name(),\n+                app.description(),\n+                app.version(),\n+                app.vendor(),\n+                app.copyright(),\n+                app.srcDir(),\n+                app.contentDirs(),\n+                Objects.requireNonNull(appImageLayout),\n+                app.runtimeBuilder(),\n+                app.launchers(),\n+                app.extraAppImageFileData());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-            env.app().runtimeBuilder().orElseThrow().createRuntime(env.resolvedLayout());\n+            env.app().runtimeBuilder().orElseThrow().create(env.resolvedLayout());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -351,3 +352,2 @@\n-        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-menu\", true);\n-        }),\n+        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN,\n+                createArgumentWithOptionalValueAction(\"win-menu\")),\n@@ -357,4 +357,2 @@\n-        WIN_SHORTCUT_HINT (\"win-shortcut\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-shortcut\", true);\n-        }),\n+        WIN_SHORTCUT_HINT (\"win-shortcut\", OptionCategories.PLATFORM_WIN,\n+                createArgumentWithOptionalValueAction(\"win-shortcut\")),\n@@ -399,4 +397,2 @@\n-        LINUX_SHORTCUT_HINT (\"linux-shortcut\",\n-                OptionCategories.PLATFORM_LINUX, () -> {\n-            setOptionValue(\"linux-shortcut\", true);\n-        }),\n+        LINUX_SHORTCUT_HINT (\"linux-shortcut\", OptionCategories.PLATFORM_LINUX,\n+                createArgumentWithOptionalValueAction(\"linux-shortcut\")),\n@@ -481,0 +477,5 @@\n+        private static void prevArg() {\n+            Objects.checkIndex(context().pos, context().argList.size());\n+            context().pos--;\n+        }\n+\n@@ -484,0 +485,18 @@\n+\n+        private static Runnable createArgumentWithOptionalValueAction(String option) {\n+            Objects.requireNonNull(option);\n+            return () -> {\n+                nextArg();\n+                if (hasNextArg()) {\n+                    var value = getArg();\n+                    if (value.startsWith(\"-\")) {\n+                        prevArg();\n+                        setOptionValue(option, true);\n+                    } else {\n+                        setOptionValue(option, value);\n+                    }\n+                } else {\n+                    setOptionValue(option, true);\n+                }\n+            };\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -31,0 +33,3 @@\n+\/**\n+ * Build environment.\n+ *\/\n@@ -33,0 +38,5 @@\n+    \/**\n+     * Returns root directory for intermediate build files.\n+     *\n+     * @return the root directory for intermediate build files\n+     *\/\n@@ -35,0 +45,5 @@\n+    \/**\n+     * Returns <code>true<\/code> if the build should be verbose output.\n+     *\n+     * @return <code>true<\/code> if the build should be verbose output\n+     *\/\n@@ -37,0 +52,7 @@\n+    \/**\n+     * Returns the path of the resource directory or an empty {@link Optional}\n+     * instance if none is configured with the build.\n+     *\n+     * @return the path of the resource directory or an empty {@link Optional}\n+     *         instance if non is configured with the build\n+     *\/\n@@ -40,1 +62,1 @@\n-     * Returns path to application image directory.\n+     * Returns the path of the app image directory of this build.\n@@ -42,2 +64,1 @@\n-     * The return value is supposed to be used as a parameter for\n-     * ApplicationLayout#resolveAt function.\n+     * @return the path of the app image directory of this build\n@@ -46,1 +67,1 @@\n-        return buildRoot().resolve(\"image\");\n+        return appImageLayout().rootDirectory();\n@@ -49,0 +70,20 @@\n+    \/**\n+     * Returns resolved app image layout of the app image directory. The return\n+     * layout is resolved at {@link #appImageDir()} path.\n+     *\n+     * @return the resolved app image layout of the app image directory\n+     *\/\n+    AppImageLayout appImageLayout();\n+\n+    default Optional<ApplicationLayout> asApplicationLayout() {\n+        if (appImageLayout() instanceof ApplicationLayout layout) {\n+            return Optional.of(layout);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Returns a path to a directory for intermediate configuration files.\n+     * @return the path to the directory for intermediate configuration files\n+     *\/\n@@ -53,0 +94,7 @@\n+    \/**\n+     * Creates an {@link OverridableResource} instance for the given resource name.\n+     *\n+     * @param defaultName the resource name\n+     * @return the {@link OverridableResource} instance wrapping a resource with the\n+     *         given name\n+     *\/\n@@ -59,2 +107,8 @@\n-    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose, Class<?> resourceLocator) {\n-        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.empty());\n+    static BuildEnv withAppImageLayout(BuildEnv env, AppImageLayout appImageLayout) {\n+        return ((Internal.DefaultBuildEnv)env).copyWithAppImageLayout(appImageLayout);\n+    }\n+\n+    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose,\n+            Class<?> resourceLocator, AppImageLayout appImageLayout) {\n+        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose,\n+                resourceLocator, appImageLayout);\n@@ -64,2 +118,3 @@\n-        private static record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n-                boolean verbose, Class<?> resourceLocator, Optional<Path> optAppImageDir) implements BuildEnv {\n+        private record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n+                boolean verbose, Class<?> resourceLocator,\n+                AppImageLayout appImageLayout) implements BuildEnv {\n@@ -71,1 +126,1 @@\n-                Objects.requireNonNull(optAppImageDir);\n+                Objects.requireNonNull(appImageLayout);\n@@ -74,2 +129,2 @@\n-            DefaultBuildEnv copyWithAppImageDir(Path appImageDir) {\n-                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.of(appImageDir));\n+            DefaultBuildEnv copyWithAppImageDir(Path v) {\n+                return copyWithAppImageLayout(appImageLayout.unresolve().resolveAt(v));\n@@ -78,3 +133,2 @@\n-            @Override\n-            public Path appImageDir() {\n-                return optAppImageDir.orElseGet(BuildEnv.super::appImageDir);\n+            DefaultBuildEnv copyWithAppImageLayout(AppImageLayout v) {\n+                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, v);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnv.java","additions":68,"deletions":14,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.internal.model.Package;\n@@ -43,2 +45,0 @@\n-        Objects.requireNonNull(appImageDir);\n-\n@@ -60,2 +60,2 @@\n-        return BuildEnv.withAppImageDir(BuildEnv.create(root, Optional.ofNullable(resourceDir),\n-                verbose, ResourceLocator.class), appImageDir);\n+        return BuildEnv.create(root, Optional.ofNullable(resourceDir), verbose,\n+                ResourceLocator.class, resolvedAppImageLayout());\n@@ -79,0 +79,5 @@\n+    BuildEnvBuilder appImageLayout(AppImageLayout v) {\n+        appImageLayout = v;\n+        return this;\n+    }\n+\n@@ -81,0 +86,1 @@\n+        appImageLayout = app.imageLayout();\n@@ -84,1 +90,1 @@\n-    BuildEnvBuilder appImageDirForPackage() {\n+    BuildEnvBuilder appImageDirFor(Package pkg) {\n@@ -86,0 +92,1 @@\n+        appImageLayout = pkg.appImageLayout();\n@@ -89,0 +96,5 @@\n+    private AppImageLayout resolvedAppImageLayout() {\n+        Objects.requireNonNull(appImageLayout);\n+        return Optional.ofNullable(appImageDir).map(appImageLayout.unresolve()::resolveAt).orElse(appImageLayout);\n+    }\n+\n@@ -94,0 +106,1 @@\n+    private AppImageLayout appImageLayout;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvBuilder.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n@@ -33,0 +34,1 @@\n+import java.nio.file.Path;\n@@ -34,0 +36,2 @@\n+import java.util.function.Function;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -35,0 +39,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -38,1 +43,3 @@\n-    static BuildEnv create(Map<String, ? super Object> params) throws ConfigException {\n+    static BuildEnv create(Map<String, ? super Object> params,\n+            Function<Path, ApplicationLayout> predefinedAppImageLayoutProvider,\n+            Function<Path, RuntimeLayout> predefinedRuntimeImageLayoutProvider) throws ConfigException {\n@@ -50,1 +57,2 @@\n-            PREDEFINED_RUNTIME_IMAGE.copyInto(params, builder::appImageDir);\n+            var layout = predefinedRuntimeImageLayoutProvider.apply(PREDEFINED_RUNTIME_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -52,1 +60,2 @@\n-            PREDEFINED_APP_IMAGE.copyInto(params, builder::appImageDir);\n+            var layout = predefinedAppImageLayoutProvider.apply(PREDEFINED_APP_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -54,1 +63,1 @@\n-            builder.appImageDirForPackage();\n+            builder.appImageDirFor(pkg.orElseThrow());\n@@ -62,2 +71,3 @@\n-    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(\n-            BuildEnv.class, BuildEnvFromParams::create);\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return create(params, PLATFORM_APPLICATION_LAYOUT::resolveAt, RuntimeLayout.DEFAULT::resolveAt);\n+    });\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromParams.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+            String pAppContentNote;\n@@ -69,0 +70,2 @@\n+                    pAppContentNote\n+                            = I18N.getString(\"MSG_Help_mac_app_content_note\");\n@@ -79,0 +82,1 @@\n+                    pAppContentNote = \"\";\n@@ -89,0 +93,1 @@\n+                    pAppContentNote = \"\";\n@@ -102,0 +107,1 @@\n+                    pAppContentNote = \"\";\n@@ -107,1 +113,1 @@\n-                    pSignSampleUsage));\n+                    pSignSampleUsage, pAppContentNote));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CLIHelp.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -72,0 +73,1 @@\n+import jdk.jpackage.internal.model.ParseUtils;\n@@ -80,1 +82,1 @@\n-        return createApplicationBuilder(params, launcherMapper, appLayout, Optional.of(RuntimeLayout.DEFAULT));\n+        return createApplicationBuilder(params, launcherMapper, appLayout, RuntimeLayout.DEFAULT, Optional.of(RuntimeLayout.DEFAULT));\n@@ -85,1 +87,2 @@\n-            ApplicationLayout appLayout, Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n+            ApplicationLayout appLayout, RuntimeLayout runtimeLayout,\n+            Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n@@ -105,1 +108,1 @@\n-            appBuilder.appImageLayout(predefinedRuntimeLayout.orElseThrow());\n+            appBuilder.appImageLayout(runtimeLayout);\n@@ -174,1 +177,1 @@\n-            BundlerParamInfo<Boolean> shortcutParam,\n+            BundlerParamInfo<String> shortcutParam,\n@@ -178,1 +181,1 @@\n-        Optional<Boolean> launcherValue;\n+        Optional<String> launcherValue;\n@@ -186,11 +189,13 @@\n-        return launcherValue.map(withShortcut -> {\n-            if (withShortcut) {\n-                return Optional.of(LauncherShortcutStartupDirectory.DEFAULT);\n-            } else {\n-                return Optional.<LauncherShortcutStartupDirectory>empty();\n-            }\n-        }).or(() -> {\n-            return shortcutParam.findIn(mainParams).map(_ -> {\n-                return Optional.of(LauncherShortcutStartupDirectory.DEFAULT);\n-            });\n-        }).map(LauncherShortcut::new);\n+        return launcherValue.map(ParseUtils::parseLauncherShortcutForAddLauncher).or(() -> {\n+            return Optional.ofNullable(mainParams.get(shortcutParam.getID())).map(toFunction(value -> {\n+                if (value instanceof Boolean) {\n+                    return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n+                } else {\n+                    try {\n+                        return ParseUtils.parseLauncherShortcutForMainLauncher((String)value);\n+                    } catch (IllegalArgumentException ex) {\n+                        throw I18N.buildConfigException(\"error.invalid-option-value\", value, \"--\" + shortcutParam.getID()).create();\n+                    }\n+                }\n+            }));\n+        });\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    public void createRuntime(AppImageLayout appImageLayout) throws PackagerException {\n+    public void create(AppImageLayout appImageLayout) throws PackagerException {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -89,0 +90,1 @@\n+                validatedInstalledPackageLayout(relativeInstallDir),\n@@ -92,0 +94,9 @@\n+    PackageBuilder app(Application v) {\n+        app = v;\n+        return this;\n+    }\n+\n+    Application app() {\n+        return app;\n+    }\n+\n@@ -172,0 +183,9 @@\n+    PackageBuilder installedPackageLayout(AppImageLayout v) {\n+        installedPackageLayout = v;\n+        return this;\n+    }\n+\n+    Optional<AppImageLayout> installedPackageLayout() {\n+        return Optional.ofNullable(installedPackageLayout);\n+    }\n+\n@@ -176,0 +196,15 @@\n+    private AppImageLayout validatedInstalledPackageLayout(Path relativeInstallDir) {\n+        return installedPackageLayout().orElseGet(() -> {\n+            var theInstallDir = relativeInstallDir;\n+            if (type instanceof StandardPackageType stdType) {\n+                switch (stdType) {\n+                    case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n+                        theInstallDir = Path.of(\"\/\").resolve(theInstallDir);\n+                    }\n+                    default -> {}\n+                }\n+            }\n+            return app.imageLayout().resolveAt(theInstallDir).resetRootDirectory();\n+        });\n+    }\n+\n@@ -238,0 +273,1 @@\n+    private Application app;\n@@ -246,0 +282,1 @@\n+    private AppImageLayout installedPackageLayout;\n@@ -248,1 +285,0 @@\n-    private final Application app;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackageBuilder.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -41,1 +42,0 @@\n-import java.util.function.Function;\n@@ -44,0 +44,1 @@\n+import java.util.stream.Stream;\n@@ -65,1 +66,1 @@\n-        execute(appContextMapper.apply(createTaskContext(env, app)));\n+        execute(contextMapper.apply(createTaskContext(env, app)));\n@@ -84,2 +85,1 @@\n-        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir,\n-                taskConfig, appImageLayoutForPackaging.apply(pkg)));\n+        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir, taskConfig));\n@@ -95,1 +95,1 @@\n-        execute(pkgContextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n+        execute(contextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n@@ -138,1 +138,6 @@\n-    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app, U envLayout) {\n+    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app) {\n+        @SuppressWarnings(\"unchecked\")\n+        U envLayout() {\n+            return (U)app.imageLayout();\n+        }\n+\n@@ -141,1 +146,1 @@\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+            return (U)env.appImageLayout();\n@@ -145,1 +150,1 @@\n-    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, U envLayout, Path outputDir) {\n+    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, Path outputDir) {\n@@ -147,2 +152,2 @@\n-        U resolvedLayout() {\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+        U envLayout() {\n+            return (U)pkg.appImageLayout();\n@@ -151,2 +156,3 @@\n-        AppImageBuildEnv<Application, U> appImageBuildEnv() {\n-            return new AppImageBuildEnv<>(env, pkg.app(), envLayout);\n+        @SuppressWarnings(\"unchecked\")\n+        U resolvedLayout() {\n+            return (U)env.appImageLayout();\n@@ -168,1 +174,1 @@\n-        void execute(T pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException, PackagerException;\n+        void execute(T pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException, PackagerException;\n@@ -198,0 +204,5 @@\n+            private TaskBuilder(TaskID id, TaskConfig config) {\n+                this(id);\n+                config.action().ifPresent(this::setAction);\n+            }\n+\n@@ -228,0 +239,4 @@\n+            boolean hasAction() {\n+                return action != null;\n+            }\n+\n@@ -286,0 +301,6 @@\n+        Stream<TaskBuilder> configuredTasks() {\n+            return taskConfig.entrySet().stream().map(e -> {\n+                return new TaskBuilder(e.getKey(), e.getValue());\n+            });\n+        }\n+\n@@ -293,17 +314,1 @@\n-            appContextMapper(v);\n-            pkgContextMapper(v);\n-            return this;\n-        }\n-\n-        Builder appContextMapper(UnaryOperator<TaskContext> v) {\n-            appContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder pkgContextMapper(UnaryOperator<TaskContext> v) {\n-            pkgContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder appImageLayoutForPackaging(Function<Package, AppImageLayout> v) {\n-            appImageLayoutForPackaging = v;\n+            contextMapper = v;\n@@ -321,6 +326,1 @@\n-            return createPackagingTaskContext(env, pkg, outputDir, taskConfig,\n-                    validatedAppImageLayoutForPackaging().apply(pkg));\n-        }\n-\n-        private Function<Package, AppImageLayout> validatedAppImageLayoutForPackaging() {\n-            return Optional.ofNullable(appImageLayoutForPackaging).orElse(Package::packageLayout);\n+            return createPackagingTaskContext(env, pkg, outputDir, taskConfig);\n@@ -331,3 +331,1 @@\n-                    Optional.ofNullable(appContextMapper).orElse(UnaryOperator.identity()),\n-                    Optional.ofNullable(pkgContextMapper).orElse(UnaryOperator.identity()),\n-                    validatedAppImageLayoutForPackaging());\n+                    Optional.ofNullable(contextMapper).orElse(UnaryOperator.identity()));\n@@ -339,3 +337,1 @@\n-        private UnaryOperator<TaskContext> appContextMapper;\n-        private UnaryOperator<TaskContext> pkgContextMapper;\n-        private Function<Package, AppImageLayout> appImageLayoutForPackaging;\n+        private UnaryOperator<TaskContext> contextMapper;\n@@ -407,1 +403,1 @@\n-    static void copyAppImage(Package pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException {\n+    static void copyAppImage(Package pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException {\n@@ -411,1 +407,1 @@\n-    static void copyAppImage(AppImageDesc srcAppImage, AppImageDesc dstAppImage,\n+    static void copyAppImage(AppImageLayout srcAppImage, AppImageLayout dstAppImage,\n@@ -413,2 +409,1 @@\n-        final var srcLayout = srcAppImage.resolvedAppImagelayout();\n-        final var srcLayoutPathGroup = AppImageLayout.toPathGroup(srcLayout);\n+        final var srcLayoutPathGroup = toPathGroup(srcAppImage);\n@@ -416,1 +411,1 @@\n-        if (removeAppImageFile && srcLayout instanceof ApplicationLayout appLayout) {\n+        if (removeAppImageFile && srcAppImage instanceof ApplicationLayout appLayout) {\n@@ -421,1 +416,1 @@\n-        srcLayoutPathGroup.copy(AppImageLayout.toPathGroup(dstAppImage.resolvedAppImagelayout()), LinkOption.NOFOLLOW_LINKS);\n+        srcLayoutPathGroup.copy(toPathGroup(dstAppImage), LinkOption.NOFOLLOW_LINKS);\n@@ -435,2 +430,1 @@\n-            UnaryOperator<TaskContext> appContextMapper, UnaryOperator<TaskContext> pkgContextMapper,\n-            Function<Package, AppImageLayout> appImageLayoutForPackaging) {\n+            UnaryOperator<TaskContext> contextMapper) {\n@@ -439,3 +433,1 @@\n-        this.appContextMapper = Objects.requireNonNull(appContextMapper);\n-        this.pkgContextMapper = Objects.requireNonNull(pkgContextMapper);\n-        this.appImageLayoutForPackaging = Objects.requireNonNull(appImageLayoutForPackaging);\n+        this.contextMapper = Objects.requireNonNull(contextMapper);\n@@ -445,1 +437,1 @@\n-        return new DefaultTaskContext(taskGraph, env, app, app.asApplicationLayout(), Optional.empty());\n+        return new DefaultTaskContext(taskGraph, env, app, Optional.empty());\n@@ -449,3 +441,2 @@\n-        final var pkgEnv = BuildEnv.withAppImageDir(packagingContext.env.env(), packagingContext.srcAppImage.path());\n-        return new DefaultTaskContext(taskGraph, pkgEnv, packagingContext.env.pkg.app(),\n-                packagingContext.srcAppImage.asApplicationLayout(), Optional.of(packagingContext));\n+        return new DefaultTaskContext(taskGraph, packagingContext.env(),\n+                packagingContext.pkg().app(), Optional.of(packagingContext));\n@@ -455,1 +446,1 @@\n-            Path outputDir, Map<TaskID, TaskConfig> taskConfig, AppImageLayout appImageLayoutForPackaging) {\n+            Path outputDir, Map<TaskID, TaskConfig> taskConfig) {\n@@ -460,1 +451,3 @@\n-        Objects.requireNonNull(appImageLayoutForPackaging);\n+        if (pkg.appImageLayout().isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -462,2 +455,2 @@\n-        final AppImageDesc srcAppImageDesc;\n-        final AppImageDesc dstAppImageDesc;\n+        final AppImageLayout srcLayout;\n+        final AppImageLayout dstLayout;\n@@ -466,3 +459,2 @@\n-            \/\/ appImageDir() should point to a directory where the application image will be created.\n-            srcAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.appImageDir());\n-            dstAppImageDesc = srcAppImageDesc;\n+            srcLayout = pkg.appImageLayout().resolveAt(env.appImageDir());\n+            dstLayout = srcLayout;\n@@ -470,2 +462,17 @@\n-            srcAppImageDesc = new AppImageDesc(pkg.app().imageLayout(),\n-                    pkg.predefinedAppImage().orElseThrow(UnsupportedOperationException::new));\n+            srcLayout = pkg.predefinedAppImage().map(predefinedAppImage -> {\n+                \/\/ Will create a package from the predefined app image.\n+                if (predefinedAppImage.equals(env.appImageDir())) {\n+                    return env.appImageLayout();\n+                } else {\n+                    return pkg.appImageLayout().resolveAt(predefinedAppImage);\n+                }\n+            }).orElseGet(() -> {\n+                \/\/ No predefined app image and no runtime builder.\n+                \/\/ This should be runtime packaging.\n+                if (pkg.isRuntimeInstaller()) {\n+                    return env.appImageLayout();\n+                } else {\n+                    \/\/ Can't create app image without runtime builder.\n+                    throw new UnsupportedOperationException();\n+                }\n+            });\n@@ -474,3 +481,3 @@\n-                \/\/ \"copy app image\" task action is undefined indicating\n-                \/\/ the package will use provided app image as-is.\n-                dstAppImageDesc = srcAppImageDesc;\n+                \/\/ \"copy app image\" task action is empty indicating\n+                \/\/ the package will use provided app image in place.\n+                dstLayout = srcLayout;\n@@ -478,1 +485,1 @@\n-                dstAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.buildRoot().resolve(\"image\"));\n+                dstLayout = pkg.appImageLayout().resolveAt(env.buildRoot().resolve(\"image\"));\n@@ -482,4 +489,1 @@\n-        final var pkgEnv = new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env, dstAppImageDesc.path()), pkg, dstAppImageDesc.appImageLayout(), outputDir);\n-\n-        return new PackagingTaskContext(pkgEnv, srcAppImageDesc);\n+        return new PackagingTaskContext(BuildEnv.withAppImageLayout(env, dstLayout), pkg, outputDir, srcLayout);\n@@ -503,0 +507,6 @@\n+        } catch (ExceptionBox ex) {\n+            throw new PackagerException(ex.getCause());\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (PackagerException ex) {\n+            throw ex;\n@@ -504,7 +514,1 @@\n-            if (ex instanceof PackagerException pex) {\n-                throw pex;\n-            } else if (ex instanceof ExceptionBox bex) {\n-                throw new PackagerException(bex.getCause());\n-            } else {\n-                throw new PackagerException(ex);\n-            }\n+            throw new PackagerException(ex);\n@@ -514,2 +518,2 @@\n-    private record PackagingTaskContext(PackageBuildEnv<Package, AppImageLayout> env,\n-            AppImageDesc srcAppImage) implements TaskContext, StartupParameters {\n+    private record PackagingTaskContext(BuildEnv env, Package pkg, Path outputDir,\n+            AppImageLayout srcAppImage) implements TaskContext, StartupParameters {\n@@ -519,0 +523,2 @@\n+            Objects.requireNonNull(pkg);\n+            Objects.requireNonNull(outputDir);\n@@ -524,1 +530,1 @@\n-            return env.env;\n+            return env;\n@@ -541,1 +547,1 @@\n-                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(env);\n+                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(pkgBuildEnv());\n@@ -543,2 +549,2 @@\n-                ((CopyAppImageTaskAction<Package>)taskAction).execute(env.pkg(),\n-                        srcAppImage, new AppImageDesc(env.envLayout(), env.env().appImageDir()));\n+                ((CopyAppImageTaskAction<Package>)taskAction).execute(pkg(),\n+                        srcAppImage, env.appImageLayout());\n@@ -551,1 +557,5 @@\n-            return env.appImageBuildEnv();\n+            return new AppImageBuildEnv<>(env, pkg.app());\n+        }\n+\n+        PackageBuildEnv<Package, AppImageLayout> pkgBuildEnv() {\n+            return new PackageBuildEnv<>(env, pkg, outputDir);\n@@ -556,1 +566,1 @@\n-            Optional<ApplicationLayout> appLayout, Optional<PackagingTaskContext> pkg) implements TaskContext {\n+            Optional<PackagingTaskContext> pkg) implements TaskContext {\n@@ -562,1 +572,0 @@\n-            Objects.requireNonNull(appLayout);\n@@ -574,2 +583,2 @@\n-            } else if (pkg.isEmpty() && isPackageTask) {\n-                \/\/ Building application image, skip packaging tasks.\n+            } else if (pkg.isEmpty() && (isPackageTask || isCopyAppImageTask)) {\n+                \/\/ Building application image, skip packaging and copying app image tasks.\n@@ -577,2 +586,2 @@\n-            } else if (app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n-                \/\/ Runtime builder is not present, skip building application image tasks.\n+            } else if (pkg.isPresent() && app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n+                \/\/ Building a package, runtime builder is not present, skip building application image tasks.\n@@ -599,1 +608,1 @@\n-                pkg.orElseThrow().execute(taskAction);\n+                pkg.orElseThrow(UnsupportedOperationException::new).execute(taskAction);\n@@ -615,1 +624,1 @@\n-            return new AppImageBuildEnv<>(env, app, (T)appLayout.orElseThrow());\n+            return new AppImageBuildEnv<>(env, app);\n@@ -625,5 +634,1 @@\n-                try {\n-                    context.execute(config.action.orElseThrow());\n-                } catch (ExceptionBox ex) {\n-                    throw ExceptionBox.rethrowUnchecked(ex);\n-                }\n+                context.execute(config.action.orElseThrow());\n@@ -637,3 +642,1 @@\n-    private final Function<Package, AppImageLayout> appImageLayoutForPackaging;\n-    private final UnaryOperator<TaskContext> appContextMapper;\n-    private final UnaryOperator<TaskContext> pkgContextMapper;\n+    private final UnaryOperator<TaskContext> contextMapper;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":107,"deletions":104,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -32,0 +35,1 @@\n+import java.util.Objects;\n@@ -33,0 +37,1 @@\n+import java.util.function.UnaryOperator;\n@@ -35,2 +40,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n@@ -44,3 +47,8 @@\n- *\n- * The layout is \"unresolved\" if the root directory is an empty string and\n- * \"resolved\" otherwise.\n+ * <p>\n+ * The layout is \"unresolved\" if the root directory is an empty path\n+ * ({@code Path.of(\"\")}) and \"resolved\" otherwise.\n+ * <p>\n+ * The return value of the {@link #runtimeDirectory()} method call is always a\n+ * path starting with the path returned by the {@link #rootDirectory()} method\n+ * call. Public methods without parameters and with the return type {@link Path}\n+ * in the derived interfaces must comply to this constrain.\n@@ -59,1 +67,1 @@\n-     * Root directory of this app image.\n+     * Root directory of this app image layout.\n@@ -62,1 +70,1 @@\n-     * @return the root directory of this app image\n+     * @return the root directory of this app image layout\n@@ -67,1 +75,21 @@\n-     * Creates a copy of this app image resolved at the given root directory.\n+     * Returns a copy of this app image layout with the root directory set to an empty\n+     * path ({@code Path.of(\"\")}) or this instance if its root directory is already\n+     * an empty path.\n+     *\n+     * @return an app image layout with the root directory set to an empty path\n+     *\/\n+    AppImageLayout resetRootDirectory();\n+\n+    \/**\n+     * Returns <code>true<\/code> if the root directory of this app image layout is\n+     * not an empty path, i.e, if it is not equal to <code>Path.of(\"\")<\/code>.\n+     *\n+     * @return <code>true<\/code> if the root directory of this app image layout is\n+     *         not an empty path\n+     *\/\n+    default boolean isResolved() {\n+        return !rootDirectory().equals(Path.of(\"\"));\n+    }\n+\n+    \/**\n+     * Creates a copy of this app image layout resolved at the given root directory.\n@@ -70,1 +98,29 @@\n-     * @return a copy of this app image resolved at the given root directory\n+     * @return a copy of this app image layout resolved at the given root directory\n+     *\/\n+    default AppImageLayout resolveAt(Path root) {\n+        return map(root::resolve);\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout resolved such that its root directory\n+     * is set to an empty path ({@code Path.of(\"\")}) or this instance if its root\n+     * directory is already an empty path.\n+     *\n+     * @return an app image layout resolved at {@code Path.of(\"\")} path\n+     *\/\n+    default AppImageLayout unresolve() {\n+        if (isResolved()) {\n+            final var root = rootDirectory();\n+            return map(root::relativize);\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout with the specified mapper applied to\n+     * every path.\n+     *\n+     * @param mapper the mapper to use with every path in this app image layout.\n+     * @return the copy of this app image layout with the specified mapper applied\n+     *         to every path\n@@ -72,1 +128,1 @@\n-    AppImageLayout resolveAt(Path root);\n+    AppImageLayout map(UnaryOperator<Path> mapper);\n@@ -76,1 +132,1 @@\n-    *\/\n+     *\/\n@@ -79,0 +135,17 @@\n+        public Stub {\n+            Objects.requireNonNull(rootDirectory);\n+        }\n+\n+        public Stub(Path runtimeDirectory) {\n+            this(Path.of(\"\"), runtimeDirectory);\n+        }\n+\n+        @Override\n+        public AppImageLayout resetRootDirectory() {\n+            if (isResolved()) {\n+                return new Stub(runtimeDirectory);\n+            } else {\n+                return this;\n+            }\n+        }\n+\n@@ -80,2 +153,2 @@\n-        public AppImageLayout resolveAt(Path base) {\n-            return new Stub(resolveNullablePath(base, rootDirectory), resolveNullablePath(base, runtimeDirectory));\n+        public AppImageLayout map(UnaryOperator<Path> mapper) {\n+            return new Stub(mapNullablePath(mapper, rootDirectory), mapNullablePath(mapper, runtimeDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/AppImageLayout.java","additions":86,"deletions":13,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -31,0 +31,1 @@\n+import java.util.function.UnaryOperator;\n@@ -45,1 +46,20 @@\n-        return buildFrom(this).resolveAt(root).create();\n+        return (ApplicationLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default ApplicationLayout unresolve() {\n+        return (ApplicationLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default ApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return buildFrom(this).rootDirectory(\"\").create();\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default ApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return buildFrom(this).mutate(mapper).create();\n@@ -116,8 +136,8 @@\n-        public Builder resolveAt(Path base) {\n-            rootDirectory(resolveNullablePath(base, rootDirectory));\n-            launchersDirectory(resolveNullablePath(base, launchersDirectory));\n-            appDirectory(resolveNullablePath(base, appDirectory));\n-            runtimeDirectory(resolveNullablePath(base, runtimeDirectory));\n-            appModsDirectory(resolveNullablePath(base, appModsDirectory));\n-            desktopIntegrationDirectory(resolveNullablePath(base, desktopIntegrationDirectory));\n-            contentDirectory(resolveNullablePath(base, contentDirectory));\n+        public Builder mutate(UnaryOperator<Path> mapper) {\n+            rootDirectory(mapNullablePath(mapper, rootDirectory));\n+            launchersDirectory(mapNullablePath(mapper, launchersDirectory));\n+            appDirectory(mapNullablePath(mapper, appDirectory));\n+            runtimeDirectory(mapNullablePath(mapper, runtimeDirectory));\n+            appModsDirectory(mapNullablePath(mapper, appModsDirectory));\n+            desktopIntegrationDirectory(mapNullablePath(mapper, desktopIntegrationDirectory));\n+            contentDirectory(mapNullablePath(mapper, contentDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLayout.java","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -44,1 +44,8 @@\n-    DEFAULT(\"true\");\n+    DEFAULT(\"true\"),\n+\n+    \/**\n+     * The 'app' directory in the installed application app image. This is the\n+     * directory that is referenced with {@link ApplicationLayout#appDirectory()}\n+     * method.\n+     *\/\n+    APP_DIR(\"app-dir\");\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherShortcutStartupDirectory.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n- * The interface specifies the source app image layout with two transformations:\n- * package app image layout and installed app image layout.\n+ * The interface specifies the source app image and the installed app image layouts.\n@@ -39,7 +38,0 @@\n- * Package app image layout is the source app image layout resolved at the\n- * relative installation directory of the package. Additionally, to resolve the\n- * source layout, some packages may transform the source layout.\n- * <p>\n- * Use {@link #packageLayout()} or {@link #asPackageApplicationLayout()} to get\n- * the package app image layout.\n- * <p>\n@@ -58,1 +50,0 @@\n- * <th>Package app image layout<\/th>\n@@ -65,1 +56,0 @@\n- * <td>Duke\/bin\/foo.exe Duke\/app\/foo.jar<\/td>\n@@ -70,1 +60,0 @@\n- * <td>opt\/duke\/bin\/foo opt\/duke\/lib\/app\/foo.jar<\/td>\n@@ -76,1 +65,0 @@\n- * <td>Applications\/Duke.app\/Contents\/MacOS\/foo Applications\/Duke.app\/Contents\/app\/foo.jar<\/td>\n@@ -172,1 +160,0 @@\n-     * @see #packageLayout\n@@ -196,38 +183,0 @@\n-    \/**\n-     * Gets the layout of the installed app image of the application resolved at the\n-     * relative installation directory of this package.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package\n-     *\n-     * @see #relativeInstallDir\n-     * @see #appImageLayout\n-     * @see #installedPackageLayout\n-     *\/\n-    default AppImageLayout packageLayout() {\n-        return appImageLayout().resolveAt(relativeInstallDir());\n-    }\n-\n-    \/**\n-     * Returns the layout of the installed app image of the application resolved at\n-     * the relative installation directory of this package as\n-     * {@link ApplicationLayout} type or an empty {@link Optional} instance if the\n-     * layout object is of incompatible type.\n-     * <p>\n-     * Returns an empty {@link Optional} instance if {@link #isRuntimeInstaller()}\n-     * returns <code>true<\/code>.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package as\n-     *         {@link ApplicationLayout} type\n-     *\n-     * @see #packageLayout\n-     *\/\n-    default Optional<ApplicationLayout> asPackageApplicationLayout() {\n-        if (packageLayout() instanceof ApplicationLayout layout) {\n-            return Optional.of(layout);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n@@ -240,1 +189,0 @@\n-     * @see #packageLayout\n@@ -242,16 +190,1 @@\n-    default AppImageLayout installedPackageLayout() {\n-        return asStandardPackageType().map(stdType -> {\n-            switch (stdType) {\n-                case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n-                    return packageLayout().resolveAt(Path.of(\"\/\"));\n-                }\n-                case WIN_EXE, WIN_MSI -> {\n-                    return packageLayout();\n-                }\n-                default -> {\n-                    \/\/ Should never get here\n-                    throw new IllegalStateException();\n-                }\n-            }\n-        }).orElseThrow(UnsupportedOperationException::new);\n-    }\n+    AppImageLayout installedPackageLayout();\n@@ -337,1 +270,1 @@\n-            Path relativeInstallDir) implements Package {\n+            AppImageLayout installedPackageLayout, Path relativeInstallDir) implements Package {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Package.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Collection of functions to create instances of types defined in this package from strings.\n+ *\/\n+public final class ParseUtils {\n+\n+    private ParseUtils() {\n+    }\n+\n+    public static LauncherShortcut parseLauncherShortcutForMainLauncher(String str) {\n+        return parse(str, LauncherShortcutStartupDirectory.APP_DIR).map(LauncherShortcut::new).orElseThrow(IllegalArgumentException::new);\n+    }\n+\n+    public static LauncherShortcut parseLauncherShortcutForAddLauncher(String str) {\n+        return parse(str, LauncherShortcutStartupDirectory.values()).map(LauncherShortcut::new).orElseGet(() -> {\n+            if (Boolean.valueOf(str)) {\n+                return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n+            } else {\n+                return new LauncherShortcut();\n+            }\n+        });\n+    }\n+\n+    private static Optional<LauncherShortcutStartupDirectory> parse(String str, LauncherShortcutStartupDirectory... recognizedValues) {\n+        Objects.requireNonNull(str);\n+        return Stream.of(recognizedValues).filter(v -> {\n+            return str.equals(v.asStringValue());\n+        }).findFirst();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ParseUtils.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -46,1 +46,1 @@\n-    void createRuntime(AppImageLayout appImageLayout) throws PackagerException;\n+    void create(AppImageLayout appImageLayout) throws PackagerException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -42,2 +43,21 @@\n-        return create(new AppImageLayout.Stub(resolveNullablePath(root, rootDirectory()),\n-                resolveNullablePath(root, runtimeDirectory())));\n+        return (RuntimeLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default RuntimeLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(runtimeDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default RuntimeLayout unresolve() {\n+        return (RuntimeLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default RuntimeLayout map(UnaryOperator<Path> mapper) {\n+        return create(new RuntimeLayout.Stub(mapNullablePath(mapper, rootDirectory()),\n+                mapNullablePath(mapper, runtimeDirectory())));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeLayout.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-\\n\\\n+{7}\\n\\\n@@ -337,0 +337,7 @@\n+\n+MSG_Help_mac_app_content_note=\\\n+\\          Note: The value should be a directory with the \"Resources\"\\n\\\n+\\          subdirectory (or any other directory that is valid in the \"Contents\"\\n\\\n+\\          directory of the application bundle). Otherwise, jpackage may produce\\n\\\n+\\          invalid application bundle which may fail code signing and\/or\\n\\\n+\\          notarization.\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+error.invalid-option-value=Invalid value \"{0}\" of option {1}\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-public class ResourceLocator {\n-    public ResourceLocator() {\n+public final class ResourceLocator {\n+    private ResourceLocator() {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/ResourceLocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -473,0 +473,17 @@\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(entries);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        PathGroup other = (PathGroup) obj;\n+        return Objects.equals(entries, other.entries);\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathGroup.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -29,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -50,2 +52,7 @@\n-    public static Path resolveNullablePath(Path base, Path path) {\n-        return Optional.ofNullable(path).map(base::resolve).orElse(null);\n+    public static Path mapNullablePath(UnaryOperator<Path> mapper, Path path) {\n+        Objects.requireNonNull(mapper);\n+        if (path != null) {\n+            return mapper.apply(path);\n+        } else {\n+            return null;\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathUtils.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -193,0 +193,6 @@\n+    macOS note: The value should be a directory with the \"Resources\"\n+                subdirectory (or any other directory that is valid in the\n+                \"Contents\" directory of the application bundle). Otherwise,\n+                jpackage may produce invalid application bundle which may fail\n+                code signing and\/or notarization.\n+\n","filename":"src\/jdk.jpackage\/share\/man\/jpackage.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    private static final BundlerParamInfo<Boolean> WIN_MENU_HINT = createBooleanBundlerParam(\n+    private static final BundlerParamInfo<String> WIN_MENU_HINT = createStringBundlerParam(\n@@ -111,1 +111,1 @@\n-    private static final BundlerParamInfo<Boolean> WIN_SHORTCUT_HINT = createBooleanBundlerParam(\n+    private static final BundlerParamInfo<String> WIN_SHORTCUT_HINT = createStringBundlerParam(\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -50,1 +49,0 @@\n-                .appImageLayoutForPackaging(Package::appImageLayout)\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinPackagingPipeline.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -477,0 +477,3 @@\n+                            case APP_DIR -> {\n+                                return installedAppImage.appDirectory();\n+                            }\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                pkg.installedPackageLayout(),\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinExePackage.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.javac.PreviewFeature;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/JShellConsole.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+import com.sun.tools.javac.util.Log;\n@@ -94,1 +95,0 @@\n-import java.net.URI;\n@@ -103,0 +103,1 @@\n+import java.nio.file.ProviderNotFoundException;\n@@ -142,0 +143,1 @@\n+import javax.tools.DiagnosticListener;\n@@ -657,1 +659,4 @@\n-            Scanner scanner = ScannerFactory.instance(new Context()).newScanner(wrappedCode, false);\n+            Context ctx = new Context();\n+            ctx.put(DiagnosticListener.class, (DiagnosticListener) d -> {});\n+            Scanner scanner = ScannerFactory.instance(ctx).newScanner(wrappedCode, false);\n+            Log.instance(ctx).useSource(cut.getSourceFile());\n@@ -2000,6 +2005,16 @@\n-            Collection<Path> paths = new ArrayList<>();\n-            MemoryFileManager fm = proc.taskFactory.fileManager();\n-\n-            appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, paths);\n-            appendPaths(fm, StandardLocation.CLASS_PATH, paths);\n-            appendPaths(fm, StandardLocation.SOURCE_PATH, paths);\n+            Collection<Path> paths = proc.taskFactory.parse(\"\", task -> {\n+                MemoryFileManager fm = proc.taskFactory.fileManager();\n+                Collection<Path> _paths = new ArrayList<>();\n+                try {\n+                    appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, _paths);\n+                    appendPaths(fm, StandardLocation.CLASS_PATH, _paths);\n+                    appendPaths(fm, StandardLocation.SOURCE_PATH, _paths);\n+                    appendModulePaths(fm, StandardLocation.SYSTEM_MODULES, _paths);\n+                    appendModulePaths(fm, StandardLocation.UPGRADE_MODULE_PATH, _paths);\n+                    appendModulePaths(fm, StandardLocation.MODULE_PATH, _paths);\n+                    return _paths;\n+                } catch (Exception ex) {\n+                    proc.debug(ex, \"SourceCodeAnalysisImpl.refreshIndexes(\" + version + \")\");\n+                    return List.of();\n+                }\n+            });\n@@ -2058,0 +2073,14 @@\n+    private void appendModulePaths(MemoryFileManager fm, Location loc, Collection<Path> paths) throws IOException {\n+        for (Set<Location> moduleLocations : fm.listLocationsForModules(loc)) {\n+            for (Location moduleLocation : moduleLocations) {\n+                Iterable<? extends Path> modulePaths = fm.getLocationAsPaths(moduleLocation);\n+\n+                if (modulePaths == null) {\n+                    continue;\n+                }\n+\n+                modulePaths.forEach(paths::add);\n+            }\n+        }\n+    }\n+\n@@ -2061,18 +2090,1 @@\n-        if (isJRTMarkerFile(path)) {\n-            FileSystem jrtfs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n-            Path modules = jrtfs.getPath(\"modules\");\n-            return PATH_TO_INDEX.compute(path, (p, index) -> {\n-                try {\n-                    long lastModified = Files.getLastModifiedTime(modules).toMillis();\n-                    if (index == null || index.timestamp != lastModified) {\n-                        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modules)) {\n-                            index = doIndex(lastModified, path, stream);\n-                        }\n-                    }\n-                    return index;\n-                } catch (IOException ex) {\n-                    proc.debug(ex, \"SourceCodeAnalysisImpl.indexesForPath(\" + path.toString() + \")\");\n-                    return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());\n-                }\n-            });\n-        } else if (!Files.isDirectory(path)) {\n+        if (!Files.isDirectory(path)) {\n@@ -2091,1 +2103,1 @@\n-                    } catch (IOException ex) {\n+                    } catch (IOException | ProviderNotFoundException ex) {\n@@ -2110,4 +2122,0 @@\n-    static boolean isJRTMarkerFile(Path path) {\n-        return path.equals(Paths.get(System.getProperty(\"java.home\"), \"lib\", \"modules\"));\n-    }\n-\n@@ -2198,1 +2206,1 @@\n-            INDEXER.submit(() -> {}).get();\n+            waitCurrentBackgroundTasksFinished();\n@@ -2205,0 +2213,4 @@\n+    public static void waitCurrentBackgroundTasksFinished() throws Exception {\n+        INDEXER.submit(() -> {}).get();\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+    if (type.isPrimitive() || type.isHidden() || type.isArray()) throw new IllegalArgumentException(\"Type has no class file: \" + type);\n@@ -12,2 +13,1 @@\n-        var name = type.getCanonicalName();\n-        if (name == null) throw new IllegalArgumentException(\"Type not supported: \" + type);\n+        var name = type.getName();\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/tool\/resources\/TOOLING.jsh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import jdk.internal.javac.ParticipatesInPreview;\n-\n@@ -68,1 +66,0 @@\n-@ParticipatesInPreview\n","filename":"src\/jdk.jshell\/share\/classes\/module-info.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,1 +166,1 @@\n-     * {@code \"Garbage collection performed by the JVM\"\"}.\n+     * {@code \"Garbage collection performed by the JVM\"}.\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/EventTypeInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.file.Paths;\n@@ -50,1 +51,1 @@\n- * Specify which events should be enabled and what kind information each\n+ * Specify which events should be enabled and what kind of information each\n@@ -62,1 +63,1 @@\n- * The following table shows the options names to use with {@link #setRecordingOptions(long, Map)}\n+ * The following table shows the option names to use with {@link #setRecordingOptions(long, Map)}\n@@ -70,1 +71,1 @@\n- * <th scope=\"col\">Descripion<\/th>\n+ * <th scope=\"col\">Description<\/th>\n@@ -110,1 +111,1 @@\n- * <td>Specifies the size, measured in bytes, at which data is kept in disk\n+ * <td>Specifies the size, measured in bytes, at which data is kept in the disk\n@@ -134,2 +135,2 @@\n- * is relative to the working directory where the target JVM was started.}<\/td>\n- * <td>{@code \"c:\\recording\\recotding.jfr\"},<br>\n+ * is relative to the working directory where the target JVM was started.<\/td>\n+ * <td>{@code \"c:\\recording\\recording.jfr\"},<br>\n@@ -148,1 +149,1 @@\n- * <td>Sets how long the recording should be running<\/td>\n+ * <td>Specifies the duration of the recording.<\/td>\n@@ -290,1 +291,1 @@\n-     * <th scope=\"col\">Descripion<\/th>\n+     * <th scope=\"col\">Description<\/th>\n@@ -340,1 +341,1 @@\n-     * To be able to read from a running recording the value must be set<\/td>\n+     * To be able to read from a running recording the value must be set to<\/td>\n@@ -358,1 +359,1 @@\n-     * @throws IllegalArgumentException if a recording with the iD doesn't\n+     * @throws IllegalArgumentException if a recording with the ID doesn't\n@@ -428,1 +429,1 @@\n-     * @param recordingId the ID of the recordings to get settings for\n+     * @param recordingId the ID of the recording to get settings for\n@@ -525,1 +526,1 @@\n-     * Returns the list of the available recordings, not necessarily running.\n+     * Returns the list of available recordings, not necessarily running.\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/FlightRecorderMXBean.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-     * {@code \"The duration an event must exceed to be be recorded\"}).\n+     * {@code \"The duration an event must exceed to be recorded\"}).\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/SettingDescriptorInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-    if (read_ticks(\"\/proc\/self\/stat\", &userTicks, &systemTicks) < 0) {\n+    if (read_ticks(\"\/proc\/self\/stat\", &userTicks, &systemTicks) != 2) {\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        <batik.version>1.17<\/batik.version>\n+        <batik.version>1.19<\/batik.version>\n","filename":"src\/utils\/IdealGraphVisualizer\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    os::snprintf(symbol_name, symbol_name_length, \"some_symbol%d\", i);\n+    os::snprintf_checked(symbol_name, symbol_name_length, \"some_symbol%d\", i);\n@@ -161,1 +161,1 @@\n-    os::snprintf(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n+    os::snprintf_checked(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n@@ -180,1 +180,1 @@\n-    os::snprintf(symbol_name, symbol_name_length, \"temp-%d\", i);\n+    os::snprintf_checked(symbol_name, symbol_name_length, \"temp-%d\", i);\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-  ASSERT_EQ(a.long_term_pause_time_ratio(), 0.0);\n-  ASSERT_EQ(a.short_term_pause_time_ratio(), 0.0);\n+  ASSERT_EQ(a.long_term_gc_time_ratio(), 0.0);\n+  ASSERT_EQ(a.short_term_gc_time_ratio(), 0.0);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1Analytics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -446,1 +446,1 @@\n-TEST(BasicShenandoahSimpleBitMapTest, minimum_test) {\n+TEST_F(ShenandoahSimpleBitMapTest, minimum_test) {\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahSimpleBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+        int ri = reversed.length();\n@@ -131,1 +132,1 @@\n-          ASSERT_EQ(e, reversed.pop());\n+          ASSERT_EQ(e, reversed.at(--ri));\n@@ -133,0 +134,1 @@\n+        ASSERT_EQ(ri, 0);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zArray.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-  snprintf(path, len, \"%s\/lib\/jli\/libjli.dylib\", java_home);\n+  os::snprintf_checked(path, len, \"%s\/lib\/jli\/libjli.dylib\", java_home);\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  snprintf(name, len, \"%s%s\", LogFileOutput::Prefix, TestLogFileName);\n+  os::snprintf_checked(name, len, \"%s%s\", LogFileOutput::Prefix, TestLogFileName);\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-      if (!compare_limits(a->category_limit(NMTUtil::index_to_tag(i)),\n-                          b->category_limit(NMTUtil::index_to_tag(i)))) {\n+      if (!compare_limits(a->mem_tag_limit(NMTUtil::index_to_tag(i)),\n+                          b->mem_tag_limit(NMTUtil::index_to_tag(i)))) {\n@@ -95,1 +95,1 @@\n-TEST(NMT, MallocLimitCategoryEnumNames) {\n+TEST(NMT, MallocLimitMemTagEnumNames) {\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_malloclimit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,2 +91,2 @@\n-    int category = i % (mt_number_of_tags - 1);\n-    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)category);\n+    int mtag = i % (mt_number_of_tags - 1);\n+    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MemTag)mtag);\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -344,1 +344,0 @@\n-  delete_file(test_file);\n@@ -361,0 +360,2 @@\n+\n+  delete_file(test_file);\n@@ -396,0 +397,2 @@\n+\n+  delete_file(test_file);\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,6 @@\n-    ReservedMemoryRegion rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region(stack_end);\n+    ReservedMemoryRegion rmr_found;\n+    {\n+      MemTracker::NmtVirtualMemoryLocker vml;\n+      rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region(stack_end);\n+    }\n+\n@@ -50,0 +55,1 @@\n+\n@@ -57,12 +63,14 @@\n-    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr) {\n-      if (cmr.base() + cmr.size() == stack_top) {\n-        EXPECT_TRUE(cmr.size() <= stack_size);\n-        found_stack_top = true;\n-      }\n-      if(i_addr < stack_top && i_addr >= cmr.base()) {\n-        found_i_addr = true;\n-      }\n-      i++;\n-      return true;\n-    });\n-\n+    {\n+      MemTracker::NmtVirtualMemoryLocker vml;\n+      VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr) {\n+        if (cmr.base() + cmr.size() == stack_top) {\n+          EXPECT_TRUE(cmr.size() <= stack_size);\n+          found_stack_top = true;\n+        }\n+        if (i_addr < stack_top && i_addr >= cmr.base()) {\n+          found_i_addr = true;\n+        }\n+        i++;\n+        return true;\n+      });\n+    }\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT || !VM_Version::supports_recursive_lightweight_locking()) {\n+  if (!VM_Version::supports_recursive_lightweight_locking()) {\n@@ -133,1 +133,1 @@\n-  if (LockingMode != LM_LIGHTWEIGHT || !VM_Version::supports_recursive_lightweight_locking()) {\n+  if (!VM_Version::supports_recursive_lightweight_locking()) {\n@@ -200,4 +200,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    return;\n-  }\n-\n@@ -266,4 +262,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    return;\n-  }\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_lockStack.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/hashTable.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"utilities\/resourceHash.hpp\"\n@@ -209,1 +209,1 @@\n-  ResourceHashtable<char*, unsigned> ht;\n+  HashTable<char*, unsigned> ht;\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_reserve_between.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -379,1 +379,1 @@\n-    os::snprintf(buf, JVM_MAXPATHLEN, \"%d\", (int) wcslen(path));\n+    os::snprintf_checked(buf, JVM_MAXPATHLEN, \"%d\", (int) wcslen(path));\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,0 +298,27 @@\n+\n+TEST(globalDefinitions, jlong_from) {\n+  jlong val = jlong_from(0xFF, 0);\n+  EXPECT_EQ(val, CONST64(0x00000000FF00000000));\n+\n+  val = jlong_from(0, 0xFF);\n+  EXPECT_EQ(val, CONST64(0x00000000000000FF));\n+\n+  val = jlong_from(0xFFFFFFFF, 0);\n+  EXPECT_EQ((julong)val, UCONST64(0xFFFFFFFF00000000));\n+\n+  val = jlong_from(0, 0xFFFFFFFF);\n+  EXPECT_EQ(val, CONST64(0x00000000FFFFFFFF));\n+\n+  val = jlong_from(0, -1);\n+  EXPECT_EQ(val, CONST64(0x00000000FFFFFFFF));\n+\n+  val = jlong_from(-1, 0);\n+  EXPECT_EQ((julong)val, UCONST64(0xFFFFFFFF00000000));\n+\n+  val = jlong_from(-1, -1);\n+  EXPECT_EQ((julong)val, UCONST64(0xFFFFFFFFFFFFFFFF));\n+  EXPECT_EQ(val, CONST64(-1));\n+\n+  val = jlong_from(0xABCD, 0xEFEF);\n+  EXPECT_EQ(val, CONST64(0x0000ABCD0000EFEF));\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalDefinitions.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/symbolHandle.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n+\n+class CommonHashTableTest : public ::testing::Test {\n+ protected:\n+  typedef void* K;\n+  typedef uintx V;\n+  const static MemTag MEM_TAG = mtInternal;\n+\n+  static unsigned identity_hash(const K& k) {\n+    return (unsigned) (uintptr_t) k;\n+  }\n+\n+  static unsigned bad_hash(const K& k) {\n+    return 1;\n+  }\n+\n+  static void* as_K(uintptr_t val) {\n+    return (void*) val;\n+  }\n+\n+  class EqualityTestIter {\n+   public:\n+\n+    bool do_entry(K const& k, V const& v) {\n+      if ((uintptr_t) k != (uintptr_t) v) {\n+        EXPECT_EQ((uintptr_t) k, (uintptr_t) v);\n+        return false;\n+      } else {\n+        return true; \/\/ continue iteration\n+      }\n+    }\n+  };\n+\n+  class DeleterTestIter {\n+    int _val;\n+   public:\n+    DeleterTestIter(int i) : _val(i) {}\n+\n+    bool do_entry(K const& k, V const& v) {\n+      if ((uintptr_t) k == (uintptr_t) _val) {\n+        \/\/ Delete me!\n+        return true;\n+      } else {\n+        return false; \/\/ continue iteration\n+      }\n+    }\n+  };\n+\n+};\n+\n+class SmallHashTableTest : public CommonHashTableTest {\n+ protected:\n+\n+  template<\n+  unsigned (*HASH) (K const&) = primitive_hash<K>,\n+  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n+  unsigned SIZE = 256,\n+  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n+  >\n+  class Runner : public AllStatic {\n+   public:\n+\n+    static void test(V step) {\n+      EqualityTestIter et;\n+      HashTable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n+\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+\n+      ASSERT_TRUE(rh.put(as_K(step), step));\n+      ASSERT_TRUE(rh.contains(as_K(step)));\n+\n+      ASSERT_FALSE(rh.put(as_K(step), step));\n+\n+      ASSERT_TRUE(rh.put(as_K(2 * step), 2 * step));\n+      ASSERT_TRUE(rh.put(as_K(3 * step), 3 * step));\n+      ASSERT_TRUE(rh.put(as_K(4 * step), 4 * step));\n+      ASSERT_TRUE(rh.put(as_K(5 * step), 5 * step));\n+\n+      ASSERT_FALSE(rh.remove(as_K(0x0)));\n+\n+      rh.iterate(&et);\n+      if (::testing::Test::HasFailure()) {\n+        return;\n+      }\n+\n+      ASSERT_TRUE(rh.remove(as_K(step)));\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+      rh.iterate(&et);\n+\n+\n+      \/\/ Test put_if_absent(key) (creating a default-created value)\n+      bool created = false;\n+      V* v = rh.put_if_absent(as_K(step), &created);\n+      ASSERT_TRUE(rh.contains(as_K(step)));\n+      ASSERT_TRUE(created);\n+      *v = (V)step;\n+\n+      \/\/ Calling this function a second time should yield the same value pointer\n+      V* v2 = rh.put_if_absent(as_K(step), &created);\n+      ASSERT_EQ(v, v2);\n+      ASSERT_EQ(*v2, *v);\n+      ASSERT_FALSE(created);\n+\n+      ASSERT_TRUE(rh.remove(as_K(step)));\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+      rh.iterate(&et);\n+\n+      \/\/ Test put_if_absent(key, value)\n+      v = rh.put_if_absent(as_K(step), step, &created);\n+      ASSERT_EQ(*v, step);\n+      ASSERT_TRUE(rh.contains(as_K(step)));\n+      ASSERT_TRUE(created);\n+\n+      v2 = rh.put_if_absent(as_K(step), step, &created);\n+      \/\/ Calling this function a second time should yield the same value pointer\n+      ASSERT_EQ(v, v2);\n+      ASSERT_EQ(*v2, (V)step);\n+      ASSERT_FALSE(created);\n+\n+      ASSERT_TRUE(rh.remove(as_K(step)));\n+      ASSERT_FALSE(rh.contains(as_K(step)));\n+      rh.iterate(&et);\n+\n+\n+    }\n+  };\n+};\n+\n+TEST_VM_F(SmallHashTableTest, default) {\n+  ResourceMark rm;\n+  Runner<>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, default_shifted) {\n+  ResourceMark rm;\n+  Runner<>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash) {\n+  ResourceMark rm;\n+  Runner<bad_hash>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash_shifted) {\n+  ResourceMark rm;\n+  Runner<bad_hash>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash) {\n+  ResourceMark rm;\n+  Runner<identity_hash>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash_shifted) {\n+  ResourceMark rm;\n+  Runner<identity_hash>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, primitive_hash_no_rm) {\n+  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, primitive_hash_no_rm_shifted) {\n+  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash_no_rm) {\n+  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, bad_hash_no_rm_shifted) {\n+  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash_no_rm) {\n+  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x1);\n+}\n+\n+TEST_VM_F(SmallHashTableTest, identity_hash_no_rm_shifted) {\n+  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x10);\n+}\n+\n+class GenericHashTableTest : public CommonHashTableTest {\n+ protected:\n+\n+  template<\n+  unsigned (*HASH) (K const&) = primitive_hash<K>,\n+  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n+  unsigned SIZE = 256,\n+  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n+  >\n+  class Runner : public AllStatic {\n+   public:\n+\n+    static void test(unsigned num_elements = SIZE) {\n+      EqualityTestIter et;\n+      HashTable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n+\n+      for (uintptr_t i = 0; i < num_elements; ++i) {\n+        ASSERT_TRUE(rh.put(as_K(i), i));\n+      }\n+\n+      rh.iterate(&et);\n+      if (::testing::Test::HasFailure()) {\n+        return;\n+      }\n+\n+      for (uintptr_t i = num_elements; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_TRUE((rh.remove(as_K(index))));\n+      }\n+\n+      rh.iterate(&et);\n+      if (::testing::Test::HasFailure()) {\n+        return;\n+      }\n+      for (uintptr_t i = num_elements; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_FALSE(rh.remove(as_K(index)));\n+      }\n+      rh.iterate(&et);\n+\n+      \/\/ Add more entries in and then delete one.\n+      for (uintptr_t i = 10; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_TRUE(rh.put(as_K(index), index));\n+      }\n+      DeleterTestIter dt(5);\n+      rh.unlink(&dt);\n+      ASSERT_FALSE(rh.get(as_K(5)));\n+    }\n+  };\n+};\n+\n+TEST_VM_F(GenericHashTableTest, default) {\n+  ResourceMark rm;\n+  Runner<>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, bad_hash) {\n+  ResourceMark rm;\n+  Runner<bad_hash>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, identity_hash) {\n+  ResourceMark rm;\n+  Runner<identity_hash>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, primitive_hash_no_rm) {\n+  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, bad_hash_no_rm) {\n+  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n+}\n+\n+TEST_VM_F(GenericHashTableTest, identity_hash_no_rm) {\n+  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(512);\n+}\n+\n+\/\/ Simple HashTable whose key is a SymbolHandle and value is an int\n+\/\/ This test is to show that the SymbolHandle will correctly handle the refcounting\n+\/\/ in the table.\n+class SimpleHashTableDeleteTest : public ::testing::Test {\n+ public:\n+    HashTable<SymbolHandle, int, 107, AnyObj::C_HEAP, mtTest, SymbolHandle::compute_hash> _simple_test_table;\n+\n+    class SimpleDeleter : public StackObj {\n+      public:\n+        bool do_entry(SymbolHandle& key, int value) {\n+          return true;\n+        }\n+    };\n+};\n+\n+TEST_VM_F(SimpleHashTableDeleteTest, simple_remove) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 55);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Deleting this value from a hashtable\n+  _simple_test_table.remove(s);\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n+TEST_VM_F(SimpleHashTableDeleteTest, simple_delete) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 66);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Use unlink to remove the matching (or all) values from the table.\n+  SimpleDeleter deleter;\n+  _simple_test_table.unlink(&deleter);\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n+\/\/ More complicated HashTable with SymbolHandle in the key. Since the *same* Symbol is part\n+\/\/ of the value, it's not necessary to manipulate the refcount of the key, but you must in the value.\n+\/\/ Luckily SymbolHandle does this.\n+class HashTableDeleteTest : public ::testing::Test {\n+ public:\n+    class TestValue : public CHeapObj<mtTest> {\n+        SymbolHandle _s;\n+      public:\n+        \/\/ Never have ctors and dtors fix refcounts without copy ctors and assignment operators!\n+        \/\/ Unless it's declared and used as a CHeapObj with\n+        \/\/ NONCOPYABLE(TestValue)\n+\n+        \/\/ Using SymbolHandle deals with refcount manipulation so this class doesn't have to\n+        \/\/ have dtors, copy ctors and assignment operators to do so.\n+        TestValue(Symbol* name) : _s(name) { }\n+        \/\/ Symbol* s() const { return _s; }  \/\/ needed for conversion from TempNewSymbol to SymbolHandle member\n+    };\n+\n+    \/\/ HashTable whose value is a *copy* of TestValue.\n+    HashTable<Symbol*, TestValue, 107, AnyObj::C_HEAP, mtTest> _test_table;\n+\n+    class Deleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, TestValue& value) {\n+          \/\/ Since we didn't increment the key, we shouldn't decrement it.\n+          \/\/ Calling delete on the hashtable Node which contains value will\n+          \/\/ decrement the refcount.  That's actually best since the whole\n+          \/\/ entry will be gone at once.\n+          return true;\n+        }\n+    };\n+\n+    \/\/ HashTable whose value is a pointer to TestValue.\n+    HashTable<Symbol*, TestValue*, 107, AnyObj::C_HEAP, mtTest> _ptr_test_table;\n+\n+    class PtrDeleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, TestValue*& value) {\n+          \/\/ If the hashtable value is a pointer, need to delete it from here.\n+          \/\/ This will also potentially make the refcount of the Key = 0, but the\n+          \/\/ next thing that happens is that the hashtable node is deleted so this is ok.\n+          delete value;\n+          return true;\n+        }\n+    };\n+};\n+\n+\n+TEST_VM_F(HashTableDeleteTest, value_remove) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue tv(s);\n+    \/\/ Since TestValue contains the pointer to the key, it will handle the\n+    \/\/ refcounting.\n+    _test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  \/\/ Deleting this value from a hashtable calls the destructor!\n+  _test_table.remove(s);\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n+\n+TEST_VM_F(HashTableDeleteTest, value_delete) {\n+  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n+  int d_orig_count = d->refcount();\n+  {\n+    TestValue tv(d);\n+    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n+    \/\/ hashtable node is deleted.\n+    _test_table.put(d, tv);\n+    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n+  Deleter deleter;\n+  _test_table.unlink(&deleter);\n+  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n+}\n+\n+TEST_VM_F(HashTableDeleteTest, check_delete_ptr) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue* tv = new TestValue(s);\n+    \/\/ Again since TestValue contains the pointer to the key Symbol, it will\n+    \/\/ handle the refcounting.\n+    _ptr_test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented by allocation\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  \/\/ Deleting this pointer value from a hashtable must call the destructor in the\n+  \/\/ do_entry function.\n+  PtrDeleter deleter;\n+  _ptr_test_table.unlink(&deleter);\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n+\n+class HashTablePrintTest : public ::testing::Test {\n+ public:\n+    class TestValue {\n+      int _i;\n+      int _j;\n+      int _k;\n+     public:\n+      TestValue(int i) : _i(i), _j(i+1), _k(i+2) {}\n+    };\n+    HashTable<int, TestValue*, 30, AnyObj::C_HEAP, mtTest> _test_table;\n+\n+    class TableDeleter {\n+     public:\n+      bool do_entry(int& key, TestValue*& val) {\n+        delete val;\n+        return true;\n+      }\n+    };\n+};\n+\n+TEST_VM_F(HashTablePrintTest, print_test) {\n+  for (int i = 0; i < 300; i++) {\n+    TestValue* tv = new TestValue(i);\n+    _test_table.put(i, tv);  \/\/ all the entries can be the same.\n+  }\n+  auto printer = [&] (int& key, TestValue*& val) {\n+    return sizeof(*val);\n+  };\n+  TableStatistics ts = _test_table.statistics_calculate(printer);\n+  ResourceMark rm;\n+  stringStream st;\n+  ts.print(&st, \"TestTable\");\n+  \/\/ Verify output in string\n+  const char* strings[] = {\n+      \"Number of buckets\", \"Number of entries\", \"300\", \"Number of literals\", \"Average bucket size\", \"Maximum bucket size\" };\n+  for (const auto& str : strings) {\n+    ASSERT_THAT(st.base(), testing::HasSubstr(str));\n+  }\n+  \/\/ Cleanup: need to delete pointers in entries\n+  TableDeleter deleter;\n+  _test_table.unlink(&deleter);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_hashtable.cpp","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -39,2 +39,4 @@\n-    static int cmp(int a, int b) {\n-      return a - b;\n+    static RBTreeOrdering cmp(int a, int b) {\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n@@ -43,1 +45,1 @@\n-    static bool cmp(const RBTreeIntNode* a, const RBTreeIntNode* b) {\n+    static bool less_than(const RBTreeIntNode* a, const RBTreeIntNode* b) {\n@@ -49,2 +51,4 @@\n-    static int cmp(int a, int b) {\n-      return b - a;\n+    static RBTreeOrdering cmp(int a, int b) {\n+      if (a < b) return RBTreeOrdering::GT;\n+      if (a > b) return RBTreeOrdering::LT;\n+      return RBTreeOrdering::EQ;\n@@ -55,4 +59,4 @@\n-    static int cmp(float a, float b) {\n-      if (a < b) return -1;\n-      if (a == b) return 0;\n-      return 1;\n+    static RBTreeOrdering cmp(float a, float b) {\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n@@ -97,6 +101,5 @@\n-    static int cmp(int a, const IntrusiveTreeNode* b) {\n-      return a - IntrusiveHolder::cast_to_self(b)->key;\n-    }\n-\n-    static int cmp(int a, int b) {\n-      return a - b;\n+    static RBTreeOrdering cmp(int a, const IntrusiveTreeNode* b_node) {\n+      int b = IntrusiveHolder::cast_to_self(b_node)->key;\n+      if (a < b) return RBTreeOrdering::LT;\n+      if (a > b) return RBTreeOrdering::GT;\n+      return RBTreeOrdering::EQ;\n@@ -106,1 +109,1 @@\n-    static bool cmp(const IntrusiveTreeNode* a, const IntrusiveTreeNode* b) {\n+    static bool less_than(const IntrusiveTreeNode* a, const IntrusiveTreeNode* b) {\n@@ -840,0 +843,44 @@\n+  static bool custom_validator(const IntrusiveRBNode* n) {\n+    IntrusiveHolder* holder = IntrusiveHolder::cast_to_self(n);\n+    assert(holder->key == holder->data, \"must be\");\n+\n+    return true;\n+  }\n+\n+  void test_custom_verify_intrusive() {\n+    IntrusiveTreeInt intrusive_tree;\n+    int num_nodes = 100;\n+\n+    \/\/ Insert values\n+    for (int n = 0; n < num_nodes; n++) {\n+      IntrusiveCursor cursor = intrusive_tree.cursor(n);\n+      EXPECT_NULL(cursor.node());\n+\n+      \/\/ Custom allocation here is just malloc\n+      IntrusiveHolder* place = (IntrusiveHolder*)os::malloc(sizeof(IntrusiveHolder), mtTest);\n+      new (place) IntrusiveHolder(n, n);\n+\n+      intrusive_tree.insert_at_cursor(place->get_node(), cursor);\n+      IntrusiveCursor cursor2 = intrusive_tree.cursor(n);\n+\n+      EXPECT_NOT_NULL(cursor2.node());\n+    }\n+\n+    intrusive_tree.verify_self(RBTreeTest::custom_validator);\n+\n+    int node_count = 0;\n+    intrusive_tree.verify_self([&](const IntrusiveRBNode* n) {\n+      node_count++;\n+\n+      IntrusiveHolder* holder = IntrusiveHolder::cast_to_self(n);\n+      assert(holder->key >= 0, \"must be\");\n+      assert(holder->data >= 0, \"must be\");\n+      assert(holder->key < num_nodes, \"must be\");\n+      assert(holder->data < num_nodes, \"must be\");\n+\n+      return true;\n+    });\n+\n+    EXPECT_EQ(node_count, num_nodes);\n+  }\n+\n@@ -948,1 +995,1 @@\n-  static int cmp(const void* a, const void* b) {\n+  static RBTreeOrdering cmp(const void* a, const void* b) {\n@@ -951,1 +998,4 @@\n-    return ai == bi ? 0 : (ai > bi ? 1 : -1);\n+\n+    if (ai < bi) return RBTreeOrdering::LT;\n+    if (ai > bi) return RBTreeOrdering::GT;\n+    return RBTreeOrdering::EQ;\n@@ -985,1 +1035,5 @@\n-  static int cmp(int a, int b) { return a == b ? 0 : (a > b ? 1 : -1); }\n+  static RBTreeOrdering cmp(int a, int b) {\n+    if (a < b) return RBTreeOrdering::LT;\n+    if (a > b) return RBTreeOrdering::GT;\n+    return RBTreeOrdering::EQ;\n+  }\n@@ -989,17 +1043,45 @@\n-  typedef RBTree<int, unsigned, IntCmp, RBTreeCHeapAllocator<mtTest> > TreeType;\n-    TreeType tree;\n-    const int i1 = 82924;\n-    const char* const s1 = \"[82924] = 1\";\n-    const int i2 = -13591;\n-    const char* const s2 = \"[-13591] = 2\";\n-    const int i3 = 0;\n-    const char* const s3 = \"[0] = 3\";\n-    tree.upsert(i1, 1U);\n-    tree.upsert(i2, 2U);\n-    tree.upsert(i3, 3U);\n-    stringStream ss;\n-    tree.print_on(&ss);\n-    const char* const N = nullptr;\n-    ASSERT_NE(strstr(ss.base(), s1), N);\n-    ASSERT_NE(strstr(ss.base(), s2), N);\n-    ASSERT_NE(strstr(ss.base(), s3), N);\n+  using TreeType = RBTreeCHeap<int, unsigned, IntCmp, mtTest>;\n+  TreeType tree;\n+  const int i1 = 82924;\n+  const char* const s1 = \"[82924] = 1\";\n+  const int i2 = -13591;\n+  const char* const s2 = \"[-13591] = 2\";\n+  const int i3 = 0;\n+  const char* const s3 = \"[0] = 3\";\n+  tree.upsert(i1, 1U);\n+  tree.upsert(i2, 2U);\n+  tree.upsert(i3, 3U);\n+  stringStream ss;\n+  tree.print_on(&ss);\n+  const char* const N = nullptr;\n+  ASSERT_NE(strstr(ss.base(), s1), N);\n+  ASSERT_NE(strstr(ss.base(), s2), N);\n+  ASSERT_NE(strstr(ss.base(), s3), N);\n+}\n+\n+TEST_VM(RBTreeTestNonFixture, TestPrintCustomPrinter) {\n+  typedef RBTreeCHeap<int, unsigned, IntCmp, mtTest> TreeType;\n+  typedef RBNode<int, unsigned> NodeType;\n+\n+  TreeType tree;\n+  const int i1 = -13591;\n+  const int i2 = 0;\n+  const int i3 = 82924;\n+  tree.upsert(i1, 1U);\n+  tree.upsert(i2, 2U);\n+  tree.upsert(i3, 3U);\n+\n+  stringStream ss;\n+  int print_count = 0;\n+  tree.print_on(&ss, [&](outputStream* st, const NodeType* n, int depth) {\n+    st->print_cr(\"[%d] (%d): %d\", depth, n->val(), n->key());\n+    print_count++;\n+  });\n+\n+const char* const expected =\n+    \"[0] (2): 0\\n\"\n+    \"[1] (1): -13591\\n\"\n+    \"[1] (3): 82924\\n\";\n+\n+  ASSERT_EQ(print_count, 3);\n+  ASSERT_STREQ(ss.base(), expected);\n@@ -1012,0 +1094,4 @@\n+TEST_VM_F(RBTreeTest, IntrusiveCustomVerifyTest) {\n+  this->test_custom_verify_intrusive();\n+}\n+\n@@ -1024,0 +1110,16 @@\n+\n+TEST_VM_ASSERT_MSG(RBTreeTestNonFixture, CustomVerifyAssert, \".*failed on key = 7\") {\n+  typedef RBTreeCHeap<int, int, IntCmp, mtTest> TreeType;\n+  typedef RBNode<int, int> NodeType;\n+\n+  TreeType tree;\n+  for (int i = 0; i < 10; i++) {\n+    tree.upsert(i, i);\n+  }\n+\n+  tree.verify_self([&](const NodeType* n) {\n+    assert(n->key() != 7, \"failed on key = %d\", n->key());\n+    return true;\n+  });\n+}\n+\n@@ -1042,0 +1144,19 @@\n+TEST_VM_F(RBTreeTest, CustomVerify) {\n+  constexpr int num_nodes = 1000;\n+  RBTreeInt tree;\n+  for (int i = 0; i < num_nodes; i++) {\n+    tree.upsert(i, i);\n+  }\n+\n+  int node_count = 0;\n+  tree.verify_self([&](const RBTreeIntNode* n) {\n+    node_count++;\n+\n+    assert(n->key() >= 0, \"must be\");\n+    assert(n->key() < num_nodes, \"must be\");\n+    return true;\n+  });\n+\n+  EXPECT_EQ(node_count, num_nodes);\n+}\n+\n@@ -1082,0 +1203,12 @@\n+struct OomAllocator {\n+  void* allocate(size_t sz) {\n+    return nullptr;\n+  }\n+  void free(void* ptr) {}\n+};\n+TEST_VM_F(RBTreeTest, AllocatorMayReturnNull) {\n+  RBTree<int, int, Cmp, OomAllocator> rbtree;\n+  bool success = rbtree.upsert(5, 5);\n+  EXPECT_EQ(false, success);\n+  \/\/ The test didn't exit the VM, so it was succesful.\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":169,"deletions":36,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -1,476 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"nmt\/nmtCommon.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/symbolHandle.hpp\"\n-#include \"unittest.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n-\n-class CommonResourceHashtableTest : public ::testing::Test {\n- protected:\n-  typedef void* K;\n-  typedef uintx V;\n-  const static MemTag MEM_TAG = mtInternal;\n-\n-  static unsigned identity_hash(const K& k) {\n-    return (unsigned) (uintptr_t) k;\n-  }\n-\n-  static unsigned bad_hash(const K& k) {\n-    return 1;\n-  }\n-\n-  static void* as_K(uintptr_t val) {\n-    return (void*) val;\n-  }\n-\n-  class EqualityTestIter {\n-   public:\n-\n-    bool do_entry(K const& k, V const& v) {\n-      if ((uintptr_t) k != (uintptr_t) v) {\n-        EXPECT_EQ((uintptr_t) k, (uintptr_t) v);\n-        return false;\n-      } else {\n-        return true; \/\/ continue iteration\n-      }\n-    }\n-  };\n-\n-  class DeleterTestIter {\n-    int _val;\n-   public:\n-    DeleterTestIter(int i) : _val(i) {}\n-\n-    bool do_entry(K const& k, V const& v) {\n-      if ((uintptr_t) k == (uintptr_t) _val) {\n-        \/\/ Delete me!\n-        return true;\n-      } else {\n-        return false; \/\/ continue iteration\n-      }\n-    }\n-  };\n-\n-};\n-\n-class SmallResourceHashtableTest : public CommonResourceHashtableTest {\n- protected:\n-\n-  template<\n-  unsigned (*HASH) (K const&) = primitive_hash<K>,\n-  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n-  unsigned SIZE = 256,\n-  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n-  >\n-  class Runner : public AllStatic {\n-   public:\n-\n-    static void test(V step) {\n-      EqualityTestIter et;\n-      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n-\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-\n-      ASSERT_TRUE(rh.put(as_K(step), step));\n-      ASSERT_TRUE(rh.contains(as_K(step)));\n-\n-      ASSERT_FALSE(rh.put(as_K(step), step));\n-\n-      ASSERT_TRUE(rh.put(as_K(2 * step), 2 * step));\n-      ASSERT_TRUE(rh.put(as_K(3 * step), 3 * step));\n-      ASSERT_TRUE(rh.put(as_K(4 * step), 4 * step));\n-      ASSERT_TRUE(rh.put(as_K(5 * step), 5 * step));\n-\n-      ASSERT_FALSE(rh.remove(as_K(0x0)));\n-\n-      rh.iterate(&et);\n-      if (::testing::Test::HasFailure()) {\n-        return;\n-      }\n-\n-      ASSERT_TRUE(rh.remove(as_K(step)));\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-      rh.iterate(&et);\n-\n-\n-      \/\/ Test put_if_absent(key) (creating a default-created value)\n-      bool created = false;\n-      V* v = rh.put_if_absent(as_K(step), &created);\n-      ASSERT_TRUE(rh.contains(as_K(step)));\n-      ASSERT_TRUE(created);\n-      *v = (V)step;\n-\n-      \/\/ Calling this function a second time should yield the same value pointer\n-      V* v2 = rh.put_if_absent(as_K(step), &created);\n-      ASSERT_EQ(v, v2);\n-      ASSERT_EQ(*v2, *v);\n-      ASSERT_FALSE(created);\n-\n-      ASSERT_TRUE(rh.remove(as_K(step)));\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-      rh.iterate(&et);\n-\n-      \/\/ Test put_if_absent(key, value)\n-      v = rh.put_if_absent(as_K(step), step, &created);\n-      ASSERT_EQ(*v, step);\n-      ASSERT_TRUE(rh.contains(as_K(step)));\n-      ASSERT_TRUE(created);\n-\n-      v2 = rh.put_if_absent(as_K(step), step, &created);\n-      \/\/ Calling this function a second time should yield the same value pointer\n-      ASSERT_EQ(v, v2);\n-      ASSERT_EQ(*v2, (V)step);\n-      ASSERT_FALSE(created);\n-\n-      ASSERT_TRUE(rh.remove(as_K(step)));\n-      ASSERT_FALSE(rh.contains(as_K(step)));\n-      rh.iterate(&et);\n-\n-\n-    }\n-  };\n-};\n-\n-TEST_VM_F(SmallResourceHashtableTest, default) {\n-  ResourceMark rm;\n-  Runner<>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, default_shifted) {\n-  ResourceMark rm;\n-  Runner<>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash) {\n-  ResourceMark rm;\n-  Runner<bad_hash>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash_shifted) {\n-  ResourceMark rm;\n-  Runner<bad_hash>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash) {\n-  ResourceMark rm;\n-  Runner<identity_hash>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash_shifted) {\n-  ResourceMark rm;\n-  Runner<identity_hash>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, primitive_hash_no_rm) {\n-  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, primitive_hash_no_rm_shifted) {\n-  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash_no_rm) {\n-  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, bad_hash_no_rm_shifted) {\n-  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test(0x10);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash_no_rm) {\n-  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x1);\n-}\n-\n-TEST_VM_F(SmallResourceHashtableTest, identity_hash_no_rm_shifted) {\n-  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(0x10);\n-}\n-\n-class GenericResourceHashtableTest : public CommonResourceHashtableTest {\n- protected:\n-\n-  template<\n-  unsigned (*HASH) (K const&) = primitive_hash<K>,\n-  bool (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n-  unsigned SIZE = 256,\n-  AnyObj::allocation_type ALLOC_TYPE = AnyObj::RESOURCE_AREA\n-  >\n-  class Runner : public AllStatic {\n-   public:\n-\n-    static void test(unsigned num_elements = SIZE) {\n-      EqualityTestIter et;\n-      ResourceHashtable<K, V, SIZE, ALLOC_TYPE, MEM_TAG, HASH, EQUALS> rh;\n-\n-      for (uintptr_t i = 0; i < num_elements; ++i) {\n-        ASSERT_TRUE(rh.put(as_K(i), i));\n-      }\n-\n-      rh.iterate(&et);\n-      if (::testing::Test::HasFailure()) {\n-        return;\n-      }\n-\n-      for (uintptr_t i = num_elements; i > 0; --i) {\n-        uintptr_t index = i - 1;\n-        ASSERT_TRUE((rh.remove(as_K(index))));\n-      }\n-\n-      rh.iterate(&et);\n-      if (::testing::Test::HasFailure()) {\n-        return;\n-      }\n-      for (uintptr_t i = num_elements; i > 0; --i) {\n-        uintptr_t index = i - 1;\n-        ASSERT_FALSE(rh.remove(as_K(index)));\n-      }\n-      rh.iterate(&et);\n-\n-      \/\/ Add more entries in and then delete one.\n-      for (uintptr_t i = 10; i > 0; --i) {\n-        uintptr_t index = i - 1;\n-        ASSERT_TRUE(rh.put(as_K(index), index));\n-      }\n-      DeleterTestIter dt(5);\n-      rh.unlink(&dt);\n-      ASSERT_FALSE(rh.get(as_K(5)));\n-    }\n-  };\n-};\n-\n-TEST_VM_F(GenericResourceHashtableTest, default) {\n-  ResourceMark rm;\n-  Runner<>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, bad_hash) {\n-  ResourceMark rm;\n-  Runner<bad_hash>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, identity_hash) {\n-  ResourceMark rm;\n-  Runner<identity_hash>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, primitive_hash_no_rm) {\n-  Runner<primitive_hash<K>, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, bad_hash_no_rm) {\n-  Runner<bad_hash, primitive_equals<K>, 512, AnyObj::C_HEAP>::test();\n-}\n-\n-TEST_VM_F(GenericResourceHashtableTest, identity_hash_no_rm) {\n-  Runner<identity_hash, primitive_equals<K>, 1, AnyObj::C_HEAP>::test(512);\n-}\n-\n-\/\/ Simple ResourceHashtable whose key is a SymbolHandle and value is an int\n-\/\/ This test is to show that the SymbolHandle will correctly handle the refcounting\n-\/\/ in the table.\n-class SimpleResourceHashtableDeleteTest : public ::testing::Test {\n- public:\n-    ResourceHashtable<SymbolHandle, int, 107, AnyObj::C_HEAP, mtTest, SymbolHandle::compute_hash> _simple_test_table;\n-\n-    class SimpleDeleter : public StackObj {\n-      public:\n-        bool do_entry(SymbolHandle& key, int value) {\n-          return true;\n-        }\n-    };\n-};\n-\n-TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_remove) {\n-  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n-  Symbol* s = t;\n-  int s_orig_count = s->refcount();\n-  _simple_test_table.put(s, 55);\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n-\n-  \/\/ Deleting this value from a hashtable\n-  _simple_test_table.remove(s);\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n-}\n-\n-TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_delete) {\n-  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n-  Symbol* s = t;\n-  int s_orig_count = s->refcount();\n-  _simple_test_table.put(s, 66);\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n-\n-  \/\/ Use unlink to remove the matching (or all) values from the table.\n-  SimpleDeleter deleter;\n-  _simple_test_table.unlink(&deleter);\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n-}\n-\n-\/\/ More complicated ResourceHashtable with SymbolHandle in the key. Since the *same* Symbol is part\n-\/\/ of the value, it's not necessary to manipulate the refcount of the key, but you must in the value.\n-\/\/ Luckily SymbolHandle does this.\n-class ResourceHashtableDeleteTest : public ::testing::Test {\n- public:\n-    class TestValue : public CHeapObj<mtTest> {\n-        SymbolHandle _s;\n-      public:\n-        \/\/ Never have ctors and dtors fix refcounts without copy ctors and assignment operators!\n-        \/\/ Unless it's declared and used as a CHeapObj with\n-        \/\/ NONCOPYABLE(TestValue)\n-\n-        \/\/ Using SymbolHandle deals with refcount manipulation so this class doesn't have to\n-        \/\/ have dtors, copy ctors and assignment operators to do so.\n-        TestValue(Symbol* name) : _s(name) { }\n-        \/\/ Symbol* s() const { return _s; }  \/\/ needed for conversion from TempNewSymbol to SymbolHandle member\n-    };\n-\n-    \/\/ ResourceHashtable whose value is a *copy* of TestValue.\n-    ResourceHashtable<Symbol*, TestValue, 107, AnyObj::C_HEAP, mtTest> _test_table;\n-\n-    class Deleter : public StackObj {\n-      public:\n-        bool do_entry(Symbol*& key, TestValue& value) {\n-          \/\/ Since we didn't increment the key, we shouldn't decrement it.\n-          \/\/ Calling delete on the hashtable Node which contains value will\n-          \/\/ decrement the refcount.  That's actually best since the whole\n-          \/\/ entry will be gone at once.\n-          return true;\n-        }\n-    };\n-\n-    \/\/ ResourceHashtable whose value is a pointer to TestValue.\n-    ResourceHashtable<Symbol*, TestValue*, 107, AnyObj::C_HEAP, mtTest> _ptr_test_table;\n-\n-    class PtrDeleter : public StackObj {\n-      public:\n-        bool do_entry(Symbol*& key, TestValue*& value) {\n-          \/\/ If the hashtable value is a pointer, need to delete it from here.\n-          \/\/ This will also potentially make the refcount of the Key = 0, but the\n-          \/\/ next thing that happens is that the hashtable node is deleted so this is ok.\n-          delete value;\n-          return true;\n-        }\n-    };\n-};\n-\n-\n-TEST_VM_F(ResourceHashtableDeleteTest, value_remove) {\n-  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg\");\n-  int s_orig_count = s->refcount();\n-  {\n-    TestValue tv(s);\n-    \/\/ Since TestValue contains the pointer to the key, it will handle the\n-    \/\/ refcounting.\n-    _test_table.put(s, tv);\n-    ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount incremented by copy\";\n-  }\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n-\n-  \/\/ Deleting this value from a hashtable calls the destructor!\n-  _test_table.remove(s);\n-  \/\/ Removal should make the refcount be the original refcount.\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n-}\n-\n-TEST_VM_F(ResourceHashtableDeleteTest, value_delete) {\n-  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n-  int d_orig_count = d->refcount();\n-  {\n-    TestValue tv(d);\n-    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n-    \/\/ hashtable node is deleted.\n-    _test_table.put(d, tv);\n-    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n-  }\n-  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n-  Deleter deleter;\n-  _test_table.unlink(&deleter);\n-  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n-}\n-\n-TEST_VM_F(ResourceHashtableDeleteTest, check_delete_ptr) {\n-  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n-  int s_orig_count = s->refcount();\n-  {\n-    TestValue* tv = new TestValue(s);\n-    \/\/ Again since TestValue contains the pointer to the key Symbol, it will\n-    \/\/ handle the refcounting.\n-    _ptr_test_table.put(s, tv);\n-    ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented by allocation\";\n-  }\n-  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n-\n-  \/\/ Deleting this pointer value from a hashtable must call the destructor in the\n-  \/\/ do_entry function.\n-  PtrDeleter deleter;\n-  _ptr_test_table.unlink(&deleter);\n-  \/\/ Removal should make the refcount be the original refcount.\n-  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n-}\n-\n-class ResourceHashtablePrintTest : public ::testing::Test {\n- public:\n-    class TestValue {\n-      int _i;\n-      int _j;\n-      int _k;\n-     public:\n-      TestValue(int i) : _i(i), _j(i+1), _k(i+2) {}\n-    };\n-    ResourceHashtable<int, TestValue*, 30, AnyObj::C_HEAP, mtTest> _test_table;\n-\n-    class TableDeleter {\n-     public:\n-      bool do_entry(int& key, TestValue*& val) {\n-        delete val;\n-        return true;\n-      }\n-    };\n-};\n-\n-TEST_VM_F(ResourceHashtablePrintTest, print_test) {\n-  for (int i = 0; i < 300; i++) {\n-    TestValue* tv = new TestValue(i);\n-    _test_table.put(i, tv);  \/\/ all the entries can be the same.\n-  }\n-  auto printer = [&] (int& key, TestValue*& val) {\n-    return sizeof(*val);\n-  };\n-  TableStatistics ts = _test_table.statistics_calculate(printer);\n-  ResourceMark rm;\n-  stringStream st;\n-  ts.print(&st, \"TestTable\");\n-  \/\/ Verify output in string\n-  const char* strings[] = {\n-      \"Number of buckets\", \"Number of entries\", \"300\", \"Number of literals\", \"Average bucket size\", \"Maximum bucket size\" };\n-  for (const auto& str : strings) {\n-    ASSERT_THAT(st.base(), testing::HasSubstr(str));\n-  }\n-  \/\/ Cleanup: need to delete pointers in entries\n-  TableDeleter deleter;\n-  _test_table.unlink(&deleter);\n-}\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":0,"deletions":476,"binary":false,"changes":476,"status":"deleted"},{"patch":"@@ -0,0 +1,101 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#############################################################################\n+#\n+# List of quarantined tests failing with jvmti stress agent in any mode.\n+#\n+#############################################################################\n+\n+\n+compiler\/macronodes\/TestTopInMacroElimination.java      8362832 generic-all\n+\n+gc\/stringdedup\/TestStringDeduplicationAgeThreshold.java 8362562 generic-all\n+gc\/stringdedup\/TestStringDeduplicationInterned.java     8362562 generic-all\n+gc\/stringdedup\/TestStringDeduplicationPrintOptions.java 8362562 generic-all\n+\n+\n+serviceability\/jvmti\/events\/SingleStep\/singlestep02\/singlestep02.java       8362350 generic-all\n+vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t007\/TestDescription.java\t8362350 generic-all\n+\n+# Incompatbile tests\n+\n+# IR\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v032-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx1-v032-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v032-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#avx2-v032-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v004-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v004-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v008-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v008-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v016-A          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#sse4-v016-U          0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-A            0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vanilla-U            0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v004-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v004-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v008-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v008-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v016-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v016-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v032-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v032-U           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v064-A           0000000 generic-all\n+compiler\/loopopts\/superword\/TestDependencyOffsets.java#vec-v064-U           0000000 generic-all\n+\n+# Requires solo jvmti capabilities\n+\n+compiler\/jvmci\/events\/JvmciShutdownEventTest.java                           0000000 generic-all\n+\n+# jdwp\n+runtime\/6294277\/SourceDebugExtension.java                                   0000000 generic-all\n+\n+# heap stats\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorArrayAllSampledTest.java                  0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorEventOnOffTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCParallelTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCSerialTest.java                         0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorGCTest.java                               0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorIllegalArgumentTest.java                  0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInitialAllocationTest.java                0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterArrayTest.java                 0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterObjectTest.java                0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorMultiArrayTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorNoCapabilityTest.java                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorRecursiveTest.java                        0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatArrayCorrectnessTest.java             0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatIntervalTest.java                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatObjectCorrectnessTest.java            0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatSimpleTest.java                       0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorTest.java                                 0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadDisabledTest.java                   0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadOnOffTest.java                      0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadTest.java                           0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorTwoAgentsTest.java                        0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id0                     0000000 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java#id1                     0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-jvmti-stress-agent.txt","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -100,0 +100,1 @@\n+runtime\/cds\/DeterministicDump.java 8363986 macosx-x64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+    vm.cds.nocoops.archive.available \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arguments;\n+\n+\/*\n+ * @test TestCompileTaskTimeout\n+ * @bug 8308094 8365909\n+ * @requires vm.debug & vm.flagless & os.name == \"Linux\"\n+ * @summary Check functionality of CompileTaskTimeout\n+ * @library \/test\/lib\n+ * @run driver\/timeout=480 compiler.arguments.TestCompileTaskTimeout\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestCompileTaskTimeout {\n+\n+    public static void main(String[] args) throws Throwable {\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=1\", \"--version\")\n+                    .shouldHaveExitValue(134)\n+                    .shouldContain(\"timed out after\");\n+\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=1\", \"-XX:TieredStopAtLevel=3\", \"--version\")\n+                    .shouldHaveExitValue(134)\n+                    .shouldContain(\"timed out after\");\n+\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=1\", \"-XX:-TieredCompilation\", \"--version\")\n+                    .shouldHaveExitValue(134)\n+                    .shouldContain(\"timed out after\");\n+\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=2000\", \"--version\")\n+                    .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestCompileTaskTimeout.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8358781\n+ * @summary Regression test for -XX:-TypeProfileCasts crash\n+ * @requires vm.debug\n+ * @run main\/othervm -XX:-TypeProfileCasts -XX:CompileThresholdScaling=0.01\n+ *                   compiler.arguments.TestProfileCasts\n+ *\/\n+package compiler.arguments;\n+\n+public class TestProfileCasts {\n+    static class Foo {\n+    }\n+\n+    private static void test(Object o) {\n+        if (o instanceof Foo) {\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 100; i++) {\n+            test(new Foo());\n+            test(null);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestProfileCasts.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n- * @run main\/othervm\/timeout=7200\n+ * @run main\/othervm\/timeout=28800\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressArrayCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  * @run main\/othervm\/timeout=480 -Xcomp -XX:CompileCommand=compileonly,TestConcurrentPatching::* -XX:TieredStopAtLevel=1 TestConcurrentPatching\n+  * @run main\/othervm\/timeout=1920 -Xcomp -XX:CompileCommand=compileonly,TestConcurrentPatching::* -XX:TieredStopAtLevel=1 TestConcurrentPatching\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestConcurrentPatching.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -XX:TieredStopAtLevel=1 -Xbatch\n+ * @run main\/othervm\/timeout=480 -XX:TieredStopAtLevel=1 -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestPinnedIntrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main compiler.c2.TestMergeStores aligned\n+ * @run main\/timeout=480 compiler.c2.TestMergeStores aligned\n@@ -49,1 +49,1 @@\n- * @run main compiler.c2.TestMergeStores unaligned\n+ * @run main\/timeout=480 compiler.c2.TestMergeStores unaligned\n@@ -58,1 +58,1 @@\n- * @run main compiler.c2.TestMergeStores StressIGVN\n+ * @run main\/timeout=480 compiler.c2.TestMergeStores StressIGVN\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @run main\/othervm compiler.c2.TestScalarReplacementMaxLiveNodes\n- * @run main\/othervm -Xbatch -XX:-OptimizeStringConcat -XX:-TieredCompilation\n+ * @run main\/othervm\/timeout=480 compiler.c2.TestScalarReplacementMaxLiveNodes\n+ * @run main\/othervm\/timeout=480 -Xbatch -XX:-OptimizeStringConcat -XX:-TieredCompilation\n@@ -41,0 +41,1 @@\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:CompileTaskTimeout=0\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestScalarReplacementMaxLiveNodes.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xcomp -XX:+IgnoreUnrecognizedVMOptions -XX:+StressRecompilation\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:+IgnoreUnrecognizedVMOptions -XX:+StressRecompilation\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestStressRecompilation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/* Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8361582\n+* @summary Ensure the correct backend replicate node is being generated for\n+*          half precision float constants on >16B SVE machines\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run main\/othervm compiler.c2.aarch64.TestFloat16Replicate\n+*\/\n+\n+package compiler.c2.aarch64;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.incubator.vector.Float16;\n+import jdk.test.lib.*;\n+import jdk.test.lib.Utils;\n+\n+import static java.lang.Float.*;\n+import static jdk.incubator.vector.Float16.*;\n+\n+public class TestFloat16Replicate {\n+    private static short[] input;\n+    private static short[] output;\n+    private static short[] expected;\n+    private static Random rnd;\n+\n+    \/\/ Choose FP16_IMM8 which is within the range of [-128 << 8, 127 << 8] and a multiple of 256\n+    private static final Float16 FP16_IMM8;\n+\n+    \/\/ Choose a value in the range [-128 << 8, 127 << 8] and a non multiple of 256 for FP16_NON_IMM8\n+    private static final Float16 FP16_NON_IMM8;\n+\n+    private static final int LEN = 1024;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\");\n+    }\n+\n+    static {\n+        rnd = Utils.getRandomInstance();\n+        int k = rnd.nextInt(-128, 128);\n+        int b = rnd.nextInt(1, 256);\n+        short bits_imm8     = (short) (k << 8);\n+        short bits_non_imm8 = (short) ((k << 8) + b);\n+\n+        FP16_IMM8     = Float16.shortBitsToFloat16(bits_imm8);\n+        FP16_NON_IMM8 = Float16.shortBitsToFloat16(bits_non_imm8);\n+\n+        input  = new short[LEN];\n+        output = new short[LEN];\n+        expected = new short[LEN];\n+\n+        for (int i = 0; i < LEN; i++) {\n+            input[i] = (short) i;\n+        }\n+    }\n+\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 immediate is a signed value within the\n+    \/\/ range [-128, 127] or a signed multiple of 256 in the range [-32768, 32512] for element widths of\n+    \/\/ 16 bits or higher then the backend should generate the \"replicateHF_imm_gt128b\" machnode.\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF_IMM8, \">0\"},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void TestFloat16AddInRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(Float16.add(shortBitsToFloat16(input[i]), FP16_IMM8));\n+        }\n+    }\n+\n+    @Check(test=\"TestFloat16AddInRange\")\n+    public void checkResultFloat16AddInRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            expected[i] = floatToFloat16(float16ToFloat(input[i]) + FP16_IMM8.floatValue());\n+        }\n+        Verify.checkEQWithRawBits(output, expected);\n+    }\n+\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 constant falls outside the immediate\n+    \/\/ range accepted by the SVE \"dup\" instruction, the backend must:\n+    \/\/   1. Generate the \"loadConH\" machnode to load the FP16 constant from the constant pool.\n+    \/\/   2. Emit the \"replicateHF\" machnode to broadcast this loaded constant into an SVE register.\n+    \/\/ In this case, the backend should not generate the \"replicateHF_imm8_gt128b\" machnode.\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF, \">0\"},\n+        failOn = {IRNode.REPLICATE_HF_IMM8},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void TestFloat16AddOutOfRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input[i]), FP16_NON_IMM8));\n+        }\n+    }\n+\n+    @Check(test=\"TestFloat16AddOutOfRange\")\n+    public void checkResultFloat16AddOutOfRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            expected[i] = floatToFloat16(float16ToFloat(input[i]) + FP16_NON_IMM8.floatValue());\n+        }\n+        Verify.checkEQWithRawBits(output, expected);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestFloat16Replicate.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -53,13 +54,18 @@\n-        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:-UseCompactObjectHeaders\",\n-                                   \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:-UseCompactObjectHeaders\",\n-                                   \"-XX:+AlignVector\");\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:+UseCompactObjectHeaders\",\n-                                   \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:+UseCompactObjectHeaders\",\n-                                   \"-XX:+AlignVector\");\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                           \"-XX:+UnlockExperimentalVMOptions\");\n+\n+        \/\/ Cross-product:\n+        \/\/   +-AlignVector\n+        \/\/   +-UseCompactObjectHeaders\n+        \/\/   +-UseAutoVectorizationSpeculativeAliasingChecks\n+        int idx = 0;\n+        for (String av : List.of(\"-XX:-AlignVector\", \"-XX:+AlignVector\")) {\n+            for (String coh : List.of(\"-XX:-UseCompactObjectHeaders\", \"-XX:+UseCompactObjectHeaders\")) {\n+                for (String sac : List.of(\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\")) {\n+                    framework.addScenarios(new Scenario(idx++, av, coh, sac));\n+                }\n+            }\n+        }\n+\n+        framework.start();\n@@ -129,1 +135,1 @@\n-            int val = offset > 0 ? verifyByteArray[(i-offset) % 8] : verifyByteArray[i-offset];\n+            int val = offset >=1 ? verifyByteArray[(i-offset) % 8] : verifyByteArray[i-offset];\n@@ -482,1 +488,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -490,1 +503,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -504,1 +524,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -512,1 +539,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -527,1 +561,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -535,1 +576,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":68,"deletions":20,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=300 -XX:-TieredCompilation -XX:CompileThreshold=2 -XX:CICompilerCount=1\n+ * @run main\/othervm\/timeout=1200 -XX:-TieredCompilation -XX:CompileThreshold=2 -XX:CICompilerCount=1\n@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=300 -XX:TieredCompileTaskTimeout=1000 -XX:CompileThresholdScaling=0.001 -XX:CICompilerCount=2\n+ * @run main\/othervm\/timeout=1200 -XX:TieredCompileTaskTimeout=1000 -XX:CompileThresholdScaling=0.001 -XX:CICompilerCount=2\n","filename":"test\/hotspot\/jtreg\/compiler\/classUnloading\/methodUnloading\/TestOverloadCompileQueues.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +29,3 @@\n- * @run main\/othervm -XX:CompileOnly=TestAntiDependenciesHighMemUsage::test1 -Xcomp TestAntiDependenciesHighMemUsage\n+ * @run main\/othervm -XX:CompileOnly=TestAntiDependenciesHighMemUsage::test1 -Xcomp\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:CompileTaskTimeout=0\n+ *                   TestAntiDependenciesHighMemUsage\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestAntiDependenciesHighMemUsage.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +29,5 @@\n- * @run main\/othervm -XX:CompileOnly=TestAntiDependenciesHighMemUsage2::test1 -XX:-ClipInlining\n- *                   -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:-UseOnStackReplacement TestAntiDependenciesHighMemUsage2\n+ * @run main\/othervm\/timeout=480 -XX:CompileOnly=TestAntiDependenciesHighMemUsage2::test1\n+ *                               -XX:-ClipInlining -XX:-BackgroundCompilation\n+ *                               -XX:-TieredCompilation -XX:-UseOnStackReplacement\n+ *                               -XX:+IgnoreUnrecognizedVMOptions -XX:CompileTaskTimeout=0\n+ *                               TestAntiDependenciesHighMemUsage2\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestAntiDependenciesHighMemUsage2.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm -Xbatch\n+ * @run main\/othervm\/timeout=480 -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/TestCipherBlockChainingEncrypt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestLoadBypassesClassCast::test\n+ * @run main\/othervm\/timeout=480 -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestLoadBypassesClassCast::test\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestLoadBypassesClassCast.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm\/native compiler.floatingpoint.TestFloatSyncJNIArgs\n+ * @run main\/othervm\/native\/timeout=480 compiler.floatingpoint.TestFloatSyncJNIArgs\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestFloatSyncJNIArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8360561\n+ * @summary Ranges can be proven to be disjoint but not orderable (thanks to unsigned range)\n+ *          Comparing such values in such range with != should always be true.\n+ * @run main\/othervm -Xcomp\n+ *                   -XX:CompileCommand=compileonly,compiler.igvn.CmpDisjointButNonOrderedRanges::*\n+ *                   compiler.igvn.CmpDisjointButNonOrderedRanges\n+ * @run main compiler.igvn.CmpDisjointButNonOrderedRanges\n+ *\/\n+package compiler.igvn;\n+\n+public class CmpDisjointButNonOrderedRanges {\n+    static boolean bFld;\n+\n+    public static void main(String[] strArr) {\n+        test();\n+    }\n+\n+    static void test() {\n+        int x = 7;\n+        int y = 4;\n+        for (int i = 3; i < 12; i++) {\n+            \/\/ x = 7 \\\/ x = -195 => x \\in [-195, 7] as a signed value\n+            \/\/ but [7, bitwise_cast_uint(-195)] as unsigned\n+            \/\/ So 0 is not possible.\n+            if (x != 0) {\n+                A.foo();\n+                \/\/ Because A is not loaded, A.foo() traps and this point is not reachable.\n+            }\n+            \/\/ x is tighten to be in the meet (so Hotspot's join) of [0, 0] and [7, bitwise_cast_uint(-195)]\n+            \/\/ that is bottom (Hotspot's top). Data is dead, control needs to be dead as well.\n+            for (int j = 1; j < 8; j++) {\n+                x = -195;\n+                if (bFld) {\n+                    y += 2;\n+                }\n+            }\n+        }\n+    }\n+\n+    static void foo() {\n+    }\n+}\n+\n+\n+class A {\n+    static void foo() {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/CmpDisjointButNonOrderedRanges.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8360561\n+ * @summary Ranges can be proven to be disjoint but not orderable (thanks to unsigned range)\n+ *          Comparing such values in such range with != should always be true.\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:CompileCommand=compileonly,compiler.igvn.CmpDisjointButNonOrderedRanges2::*\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:+UnlockExperimentalVMOptions\n+ *                   -XX:PerMethodTrapLimit=0\n+ *                   compiler.igvn.CmpDisjointButNonOrderedRanges2\n+ * @run main compiler.igvn.CmpDisjointButNonOrderedRanges2\n+ *\/\n+package compiler.igvn;\n+\n+public class CmpDisjointButNonOrderedRanges2 {\n+    int array[];\n+\n+    void test() {\n+        int val = 2;\n+        for (int i = 0; i < 10; i++) {\n+            \/\/ val = 2 \\\/ val = -12 => val \\in [-12, 2] as a signed value\n+            \/\/ but [2, bitwise_cast_uint(-12)] as unsigned\n+            \/\/ So 0 is not possible.\n+            if (val != 0) {\n+                return;\n+            }\n+            \/\/ val is tighten to be in the meet (so Hotspot's join) of [0, 0] and [2, bitwise_cast_uint(-12)]\n+            \/\/ that is bottom (Hotspot's top). Data is dead, control needs to be dead as well.\n+            for (int j = 0; j < 10; j++) {\n+                array[1] = val;\n+                val = -12;\n+            }\n+        }\n+    }\n+\n+    static public void main(String[] args) {\n+        var c = new CmpDisjointButNonOrderedRanges2();\n+        for (int i = 0; i < 1000; ++i) {\n+            c.test();\n+            for (int j = 0; j < 100; ++j) {\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/CmpDisjointButNonOrderedRanges2.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8360561\n+ * @summary Ranges can be proven to be disjoint but not orderable (thanks to unsigned range)\n+ *          Comparing such values in such range with != should always be true.\n+ * @library \/test\/lib \/\n+ * @run main compiler.igvn.CmpDisjointButNonOrderedRangesLong\n+ *\/\n+package compiler.igvn;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class CmpDisjointButNonOrderedRangesLong {\n+    static boolean bFld;\n+    static double dFld1;\n+    static double dFld2;\n+\n+    public static void main(String[] strArr) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.PHI})\n+    @Warmup(0)\n+    static int test() {\n+        long x = 7;\n+        if (bFld) {\n+            x = -195;\n+        }\n+\n+        dFld1 = dFld2 % 2.5;\n+\n+        if (x == 0) {\n+            return 0;\n+        }\n+        return 1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/CmpDisjointButNonOrderedRangesLong.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-* @run driver compiler.intrinsics.TestLongUnsignedDivMod\n+* @run driver\/timeout=480 compiler.intrinsics.TestLongUnsignedDivMod\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8359235\n+ * @summary Test C1 stack2reg after fixing incorrect use of T_LONG in intrinsic\n+ * @requires vm.debug == true & vm.compiler1.enabled\n+ * @run main\/othervm -XX:TieredStopAtLevel=1\n+ *                   -XX:C1MaxInlineSize=200\n+ *                   -XX:CompileThreshold=10\n+ *                   -XX:CompileCommand=compileonly,java.lang.invoke.LambdaFormEditor::putInCache\n+ *                   compiler.intrinsics.TestStack2RegSlotMismatch\n+ *\/\n+package compiler.intrinsics;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class TestStack2RegSlotMismatch {\n+    public static int target(int x, int y) {\n+        return x + y;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        MethodHandle mh = MethodHandles.lookup().findStatic(\n+            TestStack2RegSlotMismatch.class,\n+            \"target\",\n+            MethodType.methodType(int.class, int.class, int.class)\n+        );\n+        List<Object> argsList = new ArrayList<>();\n+        int j = 0;\n+\n+        for (int i = 0; i < 50; i++) {\n+            mh = MethodHandles.dropArguments(mh, 0, int.class);\n+            argsList.add(0);\n+            argsList.add(1);\n+            argsList.add(2);\n+            Object result = mh.invokeWithArguments(argsList);\n+            j += (int) result;\n+            argsList.remove(argsList.size() - 1);\n+            argsList.remove(argsList.size() - 1);\n+            if (i % 5 == 0) {\n+                Thread.sleep(1000);\n+            }\n+        }\n+\n+        if (j == 150) {\n+            System.out.println(\"passed\");\n+        } else {\n+            throw new Exception(\"TestStack2RegSlotMismatch Error\");\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestStack2RegSlotMismatch.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361842\n+ * @summary Verify the effectiveness of the `VerifyIntrinsicChecks` VM flag\n+ *          through (bypassing `StringCoding::encodeAsciiArray`, and) feeding\n+ *          invalid input to an intrinsified `StringCoding::encodeAsciiArray0`\n+ *          (note the `0` suffix!).\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ * @build java.base\/java.lang.Helper\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true & vm.flavor == \"server\" & !vm.graal.enabled\n+ * @requires (os.arch != \"riscv64\" | (os.arch == \"riscv64\" & vm.cpu.features ~= \".*rvv.*\"))\n+ * @run main\/othervm compiler.intrinsics.TestVerifyIntrinsicChecks verify\n+ *\/\n+\n+package compiler.intrinsics;\n+\n+import java.lang.Helper;\n+import java.time.Instant;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public final class TestVerifyIntrinsicChecks {\n+\n+    public static void main(String[] args) throws Exception {\n+        switch (args[0]) {\n+            case \"verify\" -> {\n+                log(\"Starting JVM in a separate process to verify the crash\");\n+                OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                        \"-Xcomp\",\n+                        \"-XX:-TieredCompilation\",\n+                        \"-XX:CompileCommand=inline,java.lang.StringCoding::encodeAsciiArray0\",\n+                        \"-XX:+VerifyIntrinsicChecks\",\n+                        \"--patch-module\", \"java.base=%s\/java.base\".formatted(System.getProperty(\"test.patch.path\")),\n+                        \"compiler.intrinsics.TestVerifyIntrinsicChecks\",\n+                        \"crash\");\n+                outputAnalyzer.shouldContain(\"unexpected null in intrinsic\");\n+                outputAnalyzer.shouldNotHaveExitValue(0);\n+            }\n+            case \"crash\" -> {\n+                log(\"Triggering the crash\");\n+                warmUpIntrinsicMethod();\n+                violateIntrinsicMethodContract();\n+            }\n+            default -> throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    private static void warmUpIntrinsicMethod() {\n+        log(\"Warming up the intrinsic method\");\n+        char[] sa = createAsciiChars(8192);\n+        byte[] sp = new byte[4096];\n+        for (int i = 0; i < 1_000; i++) {\n+            Helper.StringCodingEncodeAsciiArray0(sa, i, sp, 0, sp.length - i);\n+        }\n+    }\n+\n+    private static char[] createAsciiChars(int length) {\n+        char[] buffer = new char[length];\n+        for (int i = 0; i < length; i++) {\n+            buffer[i] = (char) (i % '\\u0080');\n+        }\n+        return buffer;\n+    }\n+\n+    private static void violateIntrinsicMethodContract() {\n+        log(\"Violating the intrinsic method contract (sa=null)\");\n+        Helper.StringCodingEncodeAsciiArray0(null, 1, null, 1, 1);\n+    }\n+\n+    private synchronized static void log(String format, Object... args) {\n+        Object[] extendedArgs = new Object[2 + args.length];\n+        extendedArgs[0] = Instant.now();\n+        extendedArgs[1] = Thread.currentThread().getName();\n+        System.arraycopy(args, 0, extendedArgs, extendedArgs.length - args.length, args.length);\n+        String extendedFormat = \"%%s [%%s] %s%%n\".formatted(format);\n+        System.out.printf(extendedFormat, extendedArgs);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestVerifyIntrinsicChecks.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365206\n+ * @summary Verify NaN sign and significand bits are preserved across conversions,\n+ *          float -> float16 -> float\n+ * @requires (os.arch == \"riscv64\" & vm.cpu.features ~= \".*zfh.*\")\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @library \/test\/lib \/\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xmixed -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+ *                   -XX:CompileThresholdScaling=1000.0 Binary16ConversionNaN_2\n+ *\/\n+\n+\/*\n+ * The behavior tested below is an implementation property not\n+ * required by the specification. It would be acceptable for this\n+ * information to not be preserved (as long as a NaN is returned) if,\n+ * say, a intrinsified version using native hardware instructions\n+ * behaved differently.\n+ *\n+ * If that is the case, this test should be modified to disable\n+ * intrinsics or to otherwise not run on platforms with an differently\n+ * behaving intrinsic.\n+ *\/\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+import java.lang.reflect.Method;\n+import java.util.Random;\n+\n+public class Binary16ConversionNaN_2 {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    \/*\n+     * Put all 16-bit NaN values through a conversion loop and make\n+     * sure the significand, sign, and exponent are all preserved.\n+     *\/\n+    public static void main(String... argv) throws NoSuchMethodException {\n+        int errors = 0;\n+        final int NAN_EXPONENT = 0x7f80_0000;\n+        final int SIGN_BIT     = 0x8000_0000;\n+\n+        \/\/ First, run with Interpreter only to  collect \"gold\" data.\n+        \/\/ Glags -Xmixed -XX:CompileThresholdScaling=1000.0 are used\n+        \/\/ to prevent compilation during this phase.\n+        float[] pVal = new float[1024];\n+        float[] pRes = new float[1024];\n+        float[] nVal = new float[1024];\n+        float[] nRes = new float[1024];\n+\n+        Random rand = new Random();\n+\n+        \/\/ A NaN has a nonzero significand\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            int shift = rand.nextInt(13+1);\n+            int binaryNaN = (NAN_EXPONENT | (i << shift));\n+            assert isNaN(binaryNaN);\n+            \/\/ the payloads of non-canonical NaNs are preserved.\n+            float f1 = Float.intBitsToFloat(binaryNaN);\n+            float f2 = testRoundTrip(f1);\n+            errors  += verify(f1, f2);\n+            pVal[i] = f1;\n+            pRes[i] = f2;\n+\n+            int binaryNegNaN = (SIGN_BIT | binaryNaN);\n+            float f3 = Float.intBitsToFloat(binaryNegNaN);\n+            float f4 = testRoundTrip(f3);\n+            errors  += verify(f3, f4);\n+            nVal[i] = f3;\n+            nRes[i] = f4;\n+        }\n+        if (errors > 0) { \/\/ Exit if Interpreter failed\n+            throw new RuntimeException(errors + \" errors\");\n+        }\n+\n+        Method test_method = Binary16ConversionNaN_2.class.getDeclaredMethod(\"testRoundTrip\", float.class);\n+\n+        \/\/ Compile with C1 and compare results\n+        WHITE_BOX.enqueueMethodForCompilation(test_method, CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE);\n+        if (!WHITE_BOX.isMethodCompiled(test_method)) {\n+            throw new RuntimeException(\"test is not compiled by C1\");\n+        }\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            float f1 = testRoundTrip(pVal[i]);\n+            errors  += verifyCompiler(pRes[i], f1, \"C1\");\n+            float f2 = testRoundTrip(nVal[i]);\n+            errors  += verifyCompiler(nRes[i], f2, \"C1\");\n+        }\n+\n+        WHITE_BOX.deoptimizeMethod(test_method);\n+\n+        \/\/ Compile with C2 and compare results\n+        WHITE_BOX.enqueueMethodForCompilation(test_method, CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        if (!WHITE_BOX.isMethodCompiled(test_method)) {\n+            throw new RuntimeException(\"test is not compiled by C2\");\n+        }\n+        for (int i = 1; i <= 0x3ff; i++) {\n+            float f1 = testRoundTrip(pVal[i]);\n+            errors  += verifyCompiler(pRes[i], f1, \"C2\");\n+            float f2 = testRoundTrip(nVal[i]);\n+            errors  += verifyCompiler(nRes[i], f2, \"C2\");\n+        }\n+\n+        if (errors > 0) {\n+            throw new RuntimeException(errors + \" errors\");\n+        }\n+    }\n+\n+    private static boolean isNaN(int binary) {\n+        return ((binary & 0x7f80_0000) == 0x7f80_0000) \/\/ Max exponent and...\n+            && ((binary & 0x007f_ffff) != 0 );         \/\/ significand nonzero.\n+    }\n+\n+    private static float testRoundTrip(float f) {\n+        short s = Float.floatToFloat16(f);\n+        return Float.float16ToFloat(s);\n+    }\n+\n+    private static int verify(float f1, float f2) {\n+        int errors = 0;\n+        int i1 = Float.floatToRawIntBits(f1);\n+        int i2 = Float.floatToRawIntBits(f2);\n+        assert Float.isNaN(f1);\n+        if (!Float.isNaN(f2) ||\n+            ((i1 & 0x8000_0000) != (i2 & 0x8000_0000))) {\n+            errors++;\n+            System.out.println(\"Roundtrip failure on NaN value \" +\n+                               Integer.toHexString(i1) +\n+                               \"\\t got back \" + Integer.toHexString(i2));\n+        }\n+        return errors;\n+    }\n+\n+    private static int verifyCompiler(float f1, float f2, String name) {\n+        int errors = 0;\n+        int i1 = Float.floatToRawIntBits(f1);\n+        int i2 = Float.floatToRawIntBits(f2);\n+        assert Float.isNaN(f1);\n+        if (!Float.isNaN(f2) ||\n+            ((i1 & 0x8000_0000) != (i2 & 0x8000_0000))) {\n+            errors++;\n+            System.out.println(\"Roundtrip failure on NaN value \" +\n+                               Integer.toHexString(i1) +\n+                               \"\\t got back \" + Integer.toHexString(i2) +\n+                               \"\\t from \" + name + \" code\");\n+        }\n+        return errors;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16ConversionNaN_2.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+\n@@ -49,2 +50,20 @@\n-\/**\n- * This test was derived from compiler.intrinsics.string.TestHasNegatives\n+\n+\/*\n+ * @test\n+ * @bug 8281146\n+ * @summary Verify `StringCoding::countPositives` intrinsic Java wrapper checks\n+ *          by enabling the ones in the VM intrinsic using\n+ *          `-XX:+VerifyIntrinsicChecks`\n+ * @comment This does not check out-of-range conditions. The\n+ *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n+ *          that the VM intrinsic will produce no spurious errors.\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true\n+ * @build java.base\/java.lang.Helper\n+ * @run main\/othervm\n+ *      -XX:+VerifyIntrinsicChecks\n+ *      compiler.intrinsics.string.TestCountPositives\n@@ -52,0 +71,1 @@\n+\n@@ -56,1 +76,0 @@\n-import java.util.stream.IntStream;\n@@ -60,0 +79,3 @@\n+\/**\n+ * This test was derived from {@link TestHasNegatives}.\n+ *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,20 @@\n+\/*\n+ * @test\n+ * @bug 6896617 8274242\n+ * @summary Verify `sun.nio.cs.ISO_8859_1.Encoder::encodeISOArray` intrinsic\n+ *          Java wrapper checks by enabling the ones in the VM intrinsic using\n+ *          `-XX:+VerifyIntrinsicChecks`\n+ * @comment This does not check out-of-range conditions. The\n+ *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n+ *          that the VM intrinsic will produce no spurious errors.\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true\n+ * @run main\/othervm\/timeout=1200\n+ *      -XX:+VerifyIntrinsicChecks\n+ *      --add-opens=java.base\/sun.nio.cs=ALL-UNNAMED -Xbatch -Xmx256m\n+ *      compiler.intrinsics.string.TestEncodeIntrinsics\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestEncodeIntrinsics.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+\n@@ -49,0 +50,21 @@\n+\/*\n+ * @test\n+ * @bug 8054307\n+ * @summary Verify `StringCoding::hasNegatives` intrinsic Java wrapper checks\n+ *          by enabling the ones in the VM intrinsic using\n+ *          `-XX:+VerifyIntrinsicChecks`\n+ * @comment This does not check out-of-range conditions. The\n+ *          `-XX:+VerifyIntrinsicChecks` version of this test simply ensures\n+ *          that the VM intrinsic will produce no spurious errors.\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ * @comment `vm.debug == true` is required since `VerifyIntrinsicChecks` is a\n+ *          development flag\n+ * @requires vm.debug == true\n+ * @build java.base\/java.lang.Helper\n+ * @run main\/othervm\n+ *      -XX:+VerifyIntrinsicChecks\n+ *      compiler.intrinsics.string.TestHasNegatives\n+ *\/\n+\n@@ -53,1 +75,0 @@\n-import java.util.stream.IntStream;\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestHasNegatives.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run driver\/timeout=180 compiler.jsr292.ContinuousCallSiteTargetChange\n+ * @run driver\/timeout=720 compiler.jsr292.ContinuousCallSiteTargetChange\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/ContinuousCallSiteTargetChange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm -Djdk.attach.allowAttachSelf compiler.jsr292.RedefineMethodUsedByMultipleMethodHandles\n+ * @run main\/othervm\/timeout=480 -Djdk.attach.allowAttachSelf compiler.jsr292.RedefineMethodUsedByMultipleMethodHandles\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/RedefineMethodUsedByMultipleMethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler -Djdk.attach.allowAttachSelf jdk.vm.ci.runtime.test.RedefineClassTest\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler -Djdk.attach.allowAttachSelf jdk.vm.ci.runtime.test.RedefineClassTest\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/RedefineClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm\/timeout=240 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestResolvedJavaMethod\n+ * @run junit\/othervm\/timeout=960 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestResolvedJavaMethod\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2899,0 +2899,10 @@\n+    public static final String REPLICATE_HF = PREFIX + \"REPLICATE_HF\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF, \"replicateHF\");\n+    }\n+\n+    public static final String REPLICATE_HF_IMM8 = PREFIX + \"REPLICATE_HF_IMM8\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF_IMM8, \"replicateHF_imm8_gt128b\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java).\n+If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java). If a user wants to test all combinations of multiple sets of flags, they can use `TestFramework.addCrossProductScenarios()`.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jtreg.SkippedException;\n@@ -48,0 +49,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -49,0 +51,1 @@\n+import java.util.stream.Stream;\n@@ -335,0 +338,65 @@\n+    \/**\n+     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when when constructing\n+     * scenarios directly a string can contain multiple flags separated with a space. This allows grouping\n+     * flags that have to be specified togeher. Further, an empty string in a set stands in for \"no flag\".\n+     * <p>\n+     * Example:\n+     * <pre>\n+     *     addCrossProductScenarios(Set.of(\"\", \"-Xint\", \"-Xbatch -XX:-TieredCompilation\"),\n+     *                              Set.of(\"-XX:+UseNewCode\", \"-XX:UseNewCode2\"))\n+     * <\/pre>\n+     *   produces the following Scenarios\n+     * <pre>\n+     *     Scenario(0, \"-XX:+UseNewCode\")\n+     *     Scenario(1, \"-XX:+UseNewCode2\")\n+     *     Scenario(2, \"-Xint\", \"-XX:+UseNewCode\")\n+     *     Scenario(3, \"-Xint\", \"-XX:+UseNewCode2\")\n+     *     Scenario(4, \"-Xbatch -XX:-TieredCompilation\", \"-XX:+UseNewCode\")\n+     *     Scenario(5, \"-Xbatch -XX:-TieredCompilation\", \"-XX:+UseNewCode2\")\n+     * <\/pre>\n+     *\n+     * @param sets sets of flags to generate the cross product for.\n+     * @return the same framework instance.\n+     *\/\n+    @SafeVarargs\n+    final public TestFramework addCrossProductScenarios(Set<String>... flagSets) {\n+        TestFormat.checkAndReport(flagSets != null &&\n+                                  Arrays.stream(flagSets).noneMatch(Objects::isNull) &&\n+                                  Arrays.stream(flagSets).flatMap(Set::stream).noneMatch(Objects::isNull),\n+                                  \"Flags must not be null\");\n+        if (flagSets.length == 0) {\n+            return this;\n+        }\n+\n+        int initIdx = 0;\n+        if (this.scenarioIndices != null && !this.scenarioIndices.isEmpty()) {\n+            initIdx = this.scenarioIndices.stream().max(Comparator.comparingInt(Integer::intValue)).get() + 1;\n+        }\n+        AtomicInteger idx = new AtomicInteger(initIdx);\n+\n+        Stream<List<String>> crossProduct = Arrays.stream(flagSets)\n+            .reduce(\n+                Stream.of(Collections.<String>emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n+                (Stream<List<String>> acc, Set<String> set) ->\n+                    acc.flatMap(lAcc -> \/\/ For each List<String>> lAcc in acc...\n+                        set.stream().map(flag -> { \/\/ ...and each flag in the current set...\n+                            List<String> newList = new ArrayList<>(lAcc); \/\/ ...create a new list containing lAcc...\n+                            newList.add(flag); \/\/ ...and append the flag.\n+                            return newList;\n+                        }) \/\/ This results in one List<List<String>> for each lAcc...\n+                    ), \/\/ ...that get flattend into one big List<List<String>>.\n+                (a, b) -> Stream.concat(a, b)); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n+\n+        Scenario[] newScenarios = crossProduct\n+            .map(flags -> new Scenario( \/\/ For each List<String> flags in crossProduct create a new Scenario.\n+                idx.getAndIncrement(),\n+                flags.stream() \/\/ Process flags\n+                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split muliple flags in the same string into separate strings.\n+                     .flatMap(Collection::stream) \/\/ Flatten the Stream<List<String>> into Stream<String>>.\n+                     .filter(s -> !s.isEmpty()) \/\/ Remove empty string flags.\n+                     .collect(Collectors.toList())\n+                     .toArray(new String[0])))\n+            .collect(Collectors.toList()).toArray(new Scenario[0]);\n+        return addScenarios(newScenarios);\n+    }\n+\n@@ -352,0 +420,1 @@\n+        checkCompatibleFlags();\n@@ -778,0 +847,8 @@\n+    private void checkCompatibleFlags() {\n+        for (String flag : Utils.getTestJavaOpts()) {\n+            if (flag.contains(\"-agentpath\")) {\n+                throw new SkippedException(\"Can't run test with agent.\");\n+            }\n+        }\n+    }\n+\n@@ -784,0 +861,3 @@\n+            if (flag.contains(\"agentpath\")) {\n+                throw new SkippedException(\"Can't run test with -javaagent\");\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -384,1 +384,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -420,1 +420,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -456,1 +456,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n@@ -492,1 +492,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/InvariantCodeMotionReassociateAddSub.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,4 @@\n- * @run main\/othervm -Xcomp -XX:-PartialPeelLoop -XX:CompileCommand=compileonly,TestMaxLoopOptsCountReached::test TestMaxLoopOptsCountReached\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:-PartialPeelLoop\n+ *                               -XX:CompileCommand=compileonly,TestMaxLoopOptsCountReached::test\n+ *                               -XX:+IgnoreUnrecognizedVMOptions -XX:CompileTaskTimeout=0\n+ *                               TestMaxLoopOptsCountReached\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMaxLoopOptsCountReached.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ * @run main\/othervm\/timeout=480 -Xbatch -XX:-TieredCompilation\n@@ -37,1 +37,1 @@\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation\n@@ -48,1 +48,1 @@\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n@@ -58,1 +58,1 @@\n- * @run main compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ * @run main\/timeout=480 compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPartialPeelAtUnsignedTestsNegativeLimit.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.ProdRed_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.ProdRed_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.ProdRed_Float\n+ * @run driver\/timeout=480 compiler.loopopts.superword.ProdRed_Float\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Float.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.ProdRed_Int\n+ * @run driver\/timeout=480 compiler.loopopts.superword.ProdRed_Int\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRedAbsNeg_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRedAbsNeg_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedAbsNeg_Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRedAbsNeg_Float\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRedAbsNeg_Float\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedAbsNeg_Float.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRedSqrt_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRedSqrt_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedSqrt_Double.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRed_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRed_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Double.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRed_Float\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRed_Float\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Float.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRed_Int\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRed_Int\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,516 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Test Speculative Aliasing checks in SuperWord\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_yAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_yAV_nSAC\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.test.lib.Utils;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import static compiler.lib.generators.Generators.G;\n+import compiler.lib.generators.Generator;\n+\n+\/**\n+ * More complicated test cases can be found in {@link TestAliasingFuzzing}.\n+ *\/\n+public class TestAliasing {\n+    static int SIZE = 1024*8;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final Generator INT_GEN = G.ints();\n+\n+    \/\/ Invariants used in tests.\n+    public static int INVAR_ZERO = 0;\n+\n+    \/\/ Original data.\n+    public static byte[] ORIG_AB = fillRandom(new byte[SIZE]);\n+    public static byte[] ORIG_BB = fillRandom(new byte[SIZE]);\n+    public static int[]  ORIG_AI = fillRandom(new int[SIZE]);\n+    public static int[]  ORIG_BI = fillRandom(new int[SIZE]);\n+\n+    \/\/ The data we use in the tests. It is initialized from ORIG_* every time.\n+    public static byte[] AB = new byte[SIZE];\n+    public static byte[] BB = new byte[SIZE];\n+    public static int[]  AI = new int[SIZE];\n+    public static int[]  BI = new int[SIZE];\n+\n+    \/\/ Parallel to data above, but for use in reference methods.\n+    public static byte[] AB_REFERENCE = new byte[SIZE];\n+    public static byte[] BB_REFERENCE = new byte[SIZE];\n+    public static int[]  AI_REFERENCE = new int[SIZE];\n+    public static int[]  BI_REFERENCE = new int[SIZE];\n+\n+    interface TestFunction {\n+        void run();\n+    }\n+\n+    \/\/ Map of goldTests, i.e. tests that work with a golds value generated from the same test method,\n+    \/\/ at the beginning when we are still executing in the interpreter.\n+    Map<String,TestFunction> goldTests = new HashMap<String,TestFunction>();\n+\n+    \/\/ Map of gold, the results from the first run before compilation, one per goldTests entry.\n+    Map<String,Object> golds = new HashMap<String,Object>();\n+\n+    \/\/ Map of referenceTests, i.e. tests that have a reference implementation that is run with the interpreter.\n+    \/\/ The TestFunction must run both the test and reference methods.\n+    Map<String,TestFunction> referenceTests = new HashMap<String,TestFunction>();\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestAliasing.class);\n+        switch (args[0]) {\n+            case \"nCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n+    }\n+\n+    public TestAliasing() {\n+        \/\/ Add all goldTests to list\n+        goldTests.put(\"copy_B_sameIndex_noalias\",         () -> { copy_B_sameIndex_noalias(AB, BB); });\n+        goldTests.put(\"copy_B_sameIndex_alias\",           () -> { copy_B_sameIndex_alias(AB, AB); });\n+        goldTests.put(\"copy_B_differentIndex_noalias\",    () -> { copy_B_differentIndex_noalias(AB, BB); });\n+        goldTests.put(\"copy_B_differentIndex_noalias_v2\", () -> { copy_B_differentIndex_noalias_v2(); });\n+        goldTests.put(\"copy_B_differentIndex_alias\",      () -> { copy_B_differentIndex_alias(AB, AB); });\n+\n+        goldTests.put(\"copy_I_sameIndex_noalias\",         () -> { copy_I_sameIndex_noalias(AI, BI); });\n+        goldTests.put(\"copy_I_sameIndex_alias\",           () -> { copy_I_sameIndex_alias(AI, AI); });\n+        goldTests.put(\"copy_I_differentIndex_noalias\",    () -> { copy_I_differentIndex_noalias(AI, BI); });\n+        goldTests.put(\"copy_I_differentIndex_alias\",      () -> { copy_I_differentIndex_alias(AI, AI); });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            init();\n+            test.run();\n+            Object gold = snapshotCopy();\n+            golds.put(name, gold);\n+        }\n+\n+        referenceTests.put(\"fill_B_sameArray_alias\", () -> {\n+            int invar1 = RANDOM.nextInt(64);\n+            int invar2 = RANDOM.nextInt(64);\n+            test_fill_B_sameArray_alias(AB, AB, invar1, invar2);\n+            reference_fill_B_sameArray_alias(AB_REFERENCE, AB_REFERENCE, invar1, invar2);\n+        });\n+        referenceTests.put(\"fill_B_sameArray_noalias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ But they never overlap.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle;\n+            int invar2 = middle;\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_B_sameArray_noalias(AB, AB, invar1, invar2, limit);\n+            reference_fill_B_sameArray_noalias(AB_REFERENCE, AB_REFERENCE, invar1, invar2, limit);\n+        });\n+    }\n+\n+    public static void init() {\n+        System.arraycopy(ORIG_AB, 0, AB, 0, SIZE);\n+        System.arraycopy(ORIG_BB, 0, BB, 0, SIZE);\n+        System.arraycopy(ORIG_AI, 0, AI, 0, SIZE);\n+        System.arraycopy(ORIG_BI, 0, BI, 0, SIZE);\n+    }\n+\n+    public static void initReference() {\n+        System.arraycopy(ORIG_AB, 0, AB_REFERENCE, 0, SIZE);\n+        System.arraycopy(ORIG_BB, 0, BB_REFERENCE, 0, SIZE);\n+        System.arraycopy(ORIG_AI, 0, AI_REFERENCE, 0, SIZE);\n+        System.arraycopy(ORIG_BI, 0, BI_REFERENCE, 0, SIZE);\n+    }\n+\n+    public static Object snapshotCopy() {\n+        return new Object[] {\n+            AB.clone(), BB.clone(),\n+            AI.clone(), BI.clone()\n+        };\n+    }\n+\n+    public static Object snapshot() {\n+        return new Object[] {\n+            AB, BB,\n+            AI, BI\n+        };\n+    }\n+\n+    public static Object snapshotReference() {\n+        return new Object[] {\n+            AB_REFERENCE, BB_REFERENCE,\n+            AI_REFERENCE, BI_REFERENCE\n+        };\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"copy_B_sameIndex_noalias\",\n+                 \"copy_B_sameIndex_alias\",\n+                 \"copy_B_differentIndex_noalias\",\n+                 \"copy_B_differentIndex_noalias_v2\",\n+                 \"copy_B_differentIndex_alias\",\n+                 \"copy_I_sameIndex_noalias\",\n+                 \"copy_I_sameIndex_alias\",\n+                 \"copy_I_differentIndex_noalias\",\n+                 \"copy_I_differentIndex_alias\",\n+                 \"test_fill_B_sameArray_alias\",\n+                 \"test_fill_B_sameArray_noalias\"})\n+    public void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object gold = golds.get(name);\n+            \/\/ Compute new result\n+            init();\n+            test.run();\n+            Object result = snapshot();\n+            \/\/ Compare gold and new result\n+            try {\n+                Verify.checkEQ(gold, result);\n+            } catch (VerifyException e) {\n+                throw new RuntimeException(\"Verify failed for \" + name, e);\n+            }\n+        }\n+\n+        for (Map.Entry<String,TestFunction> entry : referenceTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Init data for test and reference\n+            init();\n+            initReference();\n+            \/\/ Run test and reference\n+            test.run();\n+            \/\/ Capture results from test and reference\n+            Object result = snapshot();\n+            Object expected = snapshotReference();\n+            \/\/ Compare expected and new result\n+            try {\n+                Verify.checkEQ(expected, result);\n+            } catch (VerifyException e) {\n+                throw new RuntimeException(\"Verify failed for \" + name, e);\n+            }\n+        }\n+    }\n+\n+    static byte[] fillRandom(byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)(int)INT_GEN.next();\n+        }\n+        return a;\n+    }\n+\n+    static int[] fillRandom(int[] a) {\n+        G.fill(INT_GEN, a);\n+        return a;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_B_sameIndex_noalias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_B_sameIndex_alias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_B_differentIndex_noalias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    \/\/\n+    \/\/ Same as \"copy_B_differentIndex_noalias, but somehow loading from fields rather\n+    \/\/ than arguments does not lead to vectorization.\n+    static void copy_B_differentIndex_noalias_v2() {\n+        for (int i = 0; i < AB.length; i++) {\n+            BB[i] = AB[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B,            \"> 0\",\n+                  IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*pre .* multiversion_fast.*\",  \"= 1\",\n+                  \".*main .* multiversion_fast.*\", \"= 1\",\n+                  \".*post .* multiversion_fast.*\", \"= 2\", \/\/ vectorized and scalar versions\n+                  \".*multiversion_slow.*\",         \"= 2\", \/\/ main and post (pre-loop only has a single iteration)\n+                  \".*multiversion.*\",              \"= 6\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, it fails and so we do need multiversioning.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_B_differentIndex_alias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_I_sameIndex_noalias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_I_sameIndex_alias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_I_differentIndex_noalias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,            \"> 0\",\n+                  IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*pre .* multiversion_fast.*\",  \"= 1\",\n+                  \".*main .* multiversion_fast.*\", \"= 1\",\n+                  \".*post .* multiversion_fast.*\", \"= 2\", \/\/ vectorized and scalar versions\n+                  \".*multiversion_slow.*\",         \"= 2\", \/\/ main and post (pre-loop only has a single iteration)\n+                  \".*multiversion.*\",              \"= 6\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, it fails and so we do need multiversioning.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_I_differentIndex_alias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*pre .* multiversion_fast.*\",  \"= 1\",\n+                  \".*main .* multiversion_fast.*\", \"= 1\",\n+                  \".*post .* multiversion_fast.*\", \"= 2\", \/\/ vectorized and scalar versions\n+                  \".*multiversion_slow.*\",         \"= 2\", \/\/ main and post (pre-loop only has a single iteration)\n+                  \".*multiversion.*\",              \"= 6\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, it fails and so we do need multiversioning.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    \/\/\n+    \/\/ FYI: invar1 and invar2 are small values, only used to test that everything runs\n+    \/\/      correctly with at different offsets \/ with different alignment.\n+    static void test_fill_B_sameArray_alias(byte[] a, byte[] b, int invar1, int invar2) {\n+        for (int i = 0; i < a.length - 100; i++) {\n+            a[i + invar1] = (byte)0x0a;\n+            b[a.length - i - 1 - invar2] = (byte)0x0b;\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_B_sameArray_alias(byte[] a, byte[] b, int invar1, int invar2) {\n+        for (int i = 0; i < a.length - 100; i++) {\n+            a[i + invar1] = (byte)0x0a;\n+            b[a.length - i - 1 - invar2] = (byte)0x0b;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*multiversion.*\",              \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, and they should not fail, so no multiversioning.\n+    static void test_fill_B_sameArray_noalias(byte[] a, byte[] b, int invar1, int invar2, int limit) {\n+        for (int i = 0; i < limit; i++) {\n+            a[invar1 + i] = (byte)0x0a;\n+            b[invar2 - i] = (byte)0x0b;\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_B_sameArray_noalias(byte[] a, byte[] b, int invar1, int invar2, int limit) {\n+        for (int i = 0; i < limit; i++) {\n+            a[invar1 + i] = (byte)0x0a;\n+            b[invar2 - i] = (byte)0x0b;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasing.java","additions":516,"deletions":0,"binary":false,"changes":516,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=all-flags\n+ * @bug 8366490\n+ * @summary Test that we set the ctrl of CastP2X when generating\n+ *          the aliasing runtime check, preventing the CastP2X\n+ *          from floating over a SafePoint that could move the oop,\n+ *          and render the cast value stale.\n+ * @requires vm.gc == \"G1\" | vm.gc == \"null\"\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestAliasingCastP2XCtrl::test\n+ *      -XX:CompileCommand=dontinline,*TestAliasingCastP2XCtrl::allocateArrays\n+ *      -XX:-TieredCompilation\n+ *      -Xbatch\n+ *      -XX:+UseG1GC\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM\n+ *      compiler.loopopts.superword.TestAliasingCastP2XCtrl\n+ *\/\n+\n+\/*\n+ * @test id=fewer-flags\n+ * @bug 8366490\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestAliasingCastP2XCtrl::test\n+ *      -XX:CompileCommand=dontinline,*TestAliasingCastP2XCtrl::allocateArrays\n+ *      -Xbatch\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM\n+ *      compiler.loopopts.superword.TestAliasingCastP2XCtrl\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8366490\n+ * @run main compiler.loopopts.superword.TestAliasingCastP2XCtrl\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestAliasingCastP2XCtrl {\n+    static final int N = 400;\n+    static boolean flag = false;\n+\n+    static void allocateArrays() {\n+        for (int i = 0; 200_000 > i; ++i) {\n+            int[] a = new int[N];\n+        }\n+        \/\/ Makes GC more likely.\n+        \/\/ Without it I could not reproduce it on slowdebug,\n+        \/\/ but only with fastdebug.\n+        if (flag) { System.gc(); }\n+        flag = !flag;\n+    }\n+\n+    static int[] test() {\n+        int a[] = new int[N];\n+        \/\/ We must make sure that no CastP2X happens before\n+        \/\/ the call below, otherwise we may have an old oop.\n+        allocateArrays();\n+        \/\/ The CastP2X for the aliasing runtime check should\n+        \/\/ only be emitted after the call, to ensure we only\n+        \/\/ deal with oops that are updated if there is a GC\n+        \/\/ that could move our allocated array.\n+\n+        \/\/ Not fully sure why we need the outer loop, but maybe\n+        \/\/ it is needed so that a part of the check is hoisted,\n+        \/\/ and the floats up, over the call if we do not set\n+        \/\/ the ctrl.\n+        for (int k = 0; k < 500; k++) {\n+            for (int i = 1; i < 69; i++) {\n+                \/\/ Aliasing references -> needs runtime check,\n+                \/\/ should always fail.\n+                a[i] =  14;\n+                a[4] -= 14;\n+                \/\/ The range computation for the constant access\n+                \/\/ produces a shape:\n+                \/\/   AddL(CastP2X(a), 0x20)\n+                \/\/ And this shape only depends on a, so it could\n+                \/\/ easily float above the call to allocateArrays\n+                \/\/ if we do not set a ctrl that prevents that.\n+            }\n+        }\n+        return a;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] gold = test();\n+        for (int r = 0; r < 20; r++) {\n+            int[] a = test();\n+            if (a[4] != gold[4]) {\n+                throw new RuntimeException(\"wrong value \" + gold[4] + \" \" + a[4]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingCastP2XCtrl.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,1284 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8324751\n+ * @summary Test Speculative Aliasing checks in SuperWord\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver compiler.loopopts.superword.TestAliasingFuzzer vanilla\n+ *\/\n+\n+\/*\n+ * @test id=random-flags\n+ * @bug 8324751\n+ * @summary Test Speculative Aliasing checks in SuperWord\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver compiler.loopopts.superword.TestAliasingFuzzer random-flags\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.util.Set;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+\/**\n+ * Simpler test cases can be found in {@link TestAliasing}.\n+ *\n+ * We randomly generate tests to verify the behavior of the aliasing runtime checks. We feature:\n+ * - Different primitive types:\n+ *   - for access type (primitive, we can have multiple types in a single loop)\n+ *   - for backing type (primitive and additionally we have native memory)\n+ * - Different AccessScenarios:\n+ *   - copy (load and store)\n+ *   - fill (using two stores)\n+ * - Different Aliasing: in some cases we never alias at runtime, in other cases we might\n+ *   -> Should exercise both the predicate and the multiversioning approach with the\n+ *      aliasing runtime checks.\n+ * - Backing memory\n+ *   - Arrays: using int-index\n+ *   - MemorySegment (backed by primitive array or native memory):\n+ *     - Using long-index with MemorySegment::getAtIndex\n+ *     - Using byte-offset with MemorySegment::get\n+ * - Loop iv:\n+ *   - forward (counting up) and backward (counting down)\n+ *   - Different iv stride:\n+ *     - inc\/dec by one, and then scale with ivScale:   for (..; i++)  { access(i * 4); }\n+ *     - abs(ivScale) == 1, but use iv stride instead:  for (..; i+=4) { access(i); }\n+ *   - type of index, invars, and bounds (see isLongIvType)\n+ *     - int: for array and MemorySegment\n+ *     - long: for MemorySegment\n+ * - IR rules:\n+ *   - Verify that verification does (not) happen as expected.\n+ *   - Verify that we do not use multiversioning when no aliasing is expected at runtime.\n+ *     -> verify that the aliasing runtime check is not overly sensitive, so that the\n+ *        predicate does not fail unnecessarily and we have to recompile with multiversioning.\n+ *\n+ * Possible extensions (Future Work):\n+ * - Access with Unsafe\n+ * - Backing memory with Buffers\n+ * - AccessScenario:\n+ *   - More than two accesses\n+ * - Improve IR rules, once more cases vectorize (see e.g. JDK-8359688)\n+ * - Aliasing:\n+ *   - MemorySegment on same backing memory, creating different MemorySegments\n+ *     via slicing. Possibly overlapping MemorySegments.\n+ *   - CONTAINER_UNKNOWN_ALIASING_NEVER: currently always has different\n+ *     memory and split ranges. But we could alternate between same memory\n+ *     and split ranges, and then different memory but overlapping ranges.\n+ *     This would also be never aliasing.\n+ *\n+ *\/\n+public class TestAliasingFuzzer {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public record MyType(String name, int byteSize, String con1, String con2, String layout) {\n+        @Override\n+        public String toString() { return name(); }\n+\n+        public String letter() { return name().substring(0, 1).toUpperCase(); }\n+    }\n+    public static final String con1 = \"0x0102030405060708L\";\n+    public static final String con2 = \"0x0910111213141516L\";\n+    public static final String con1F = \"Float.intBitsToFloat(0x01020304)\";\n+    public static final String con2F = \"Float.intBitsToFloat(0x09101112)\";\n+    public static final String con1D = \"Double.longBitsToDouble(\" + con1 + \")\";\n+    public static final String con2D = \"Double.longBitsToDouble(\" + con2 + \")\";\n+\n+    \/\/ List of primitive types for accesses and arrays.\n+    public static final MyType myByte   = new MyType(\"byte\",   1, con1, con2,   \"ValueLayout.JAVA_BYTE\");\n+    public static final MyType myChar   = new MyType(\"char\",   2, con1, con2,   \"ValueLayout.JAVA_CHAR_UNALIGNED\");\n+    public static final MyType myShort  = new MyType(\"short\",  2, con1, con2,   \"ValueLayout.JAVA_SHORT_UNALIGNED\");\n+    public static final MyType myInt    = new MyType(\"int\",    4, con1, con2,   \"ValueLayout.JAVA_INT_UNALIGNED\");\n+    public static final MyType myLong   = new MyType(\"long\",   8, con1, con2,   \"ValueLayout.JAVA_LONG_UNALIGNED\");\n+    public static final MyType myFloat  = new MyType(\"float\",  4, con1F, con2F, \"ValueLayout.JAVA_FLOAT_UNALIGNED\");\n+    public static final MyType myDouble = new MyType(\"double\", 8, con1D, con2D, \"ValueLayout.JAVA_DOUBLE_UNALIGNED\");\n+    public static final List<MyType> primitiveTypes\n+        = List.of(myByte, myChar, myShort, myInt, myLong, myFloat, myDouble);\n+\n+    \/\/ For native memory, we use this \"fake\" type. It has a byteSize of 1, since we measure the memory in bytes.\n+    public static final MyType myNative = new MyType(\"native\", 1, null, null,   null);\n+    public static final List<MyType> primitiveTypesAndNative\n+        = List.of(myByte, myChar, myShort, myInt, myLong, myFloat, myDouble, myNative);\n+\n+    \/\/ Do the containers (array, MemorySegment, etc) ever overlap?\n+    enum Aliasing {\n+        CONTAINER_DIFFERENT,\n+        CONTAINER_SAME_ALIASING_NEVER,\n+        CONTAINER_SAME_ALIASING_UNKNOWN,\n+        CONTAINER_UNKNOWN_ALIASING_NEVER,\n+        CONTAINER_UNKNOWN_ALIASING_UNKNOWN,\n+    }\n+\n+    enum AccessScenario {\n+        COPY_LOAD_STORE,  \/\/ a[i1] = b[i2];\n+        FILL_STORE_STORE, \/\/ a[i1] = x; b[i2] = y;\n+    }\n+\n+    enum ContainerKind {\n+        ARRAY,\n+        MEMORY_SEGMENT_LONG_ADR_SCALE,  \/\/ for (..; i++)  { access(i * 4); }\n+        MEMORY_SEGMENT_LONG_ADR_STRIDE, \/\/ for (..; i+=4) { access(i); }\n+        MEMORY_SEGMENT_AT_INDEX,\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        long t0 = System.nanoTime();\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"compiler.loopopts.superword.templated.AliasingFuzzer\", generate(comp));\n+\n+        long t1 = System.nanoTime();\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        long t2 = System.nanoTime();\n+\n+        String[] flags = switch(args[0]) {\n+            case \"vanilla\" -> new String[] {};\n+            case \"random-flags\" -> randomFlags();\n+            default -> throw new RuntimeException(\"unknown run id=\" + args[0]);\n+        };\n+        \/\/ Run the tests without any additional VM flags.\n+        \/\/ compiler.loopopts.superword.templated.AliasingFuzzer.main(new String[] {});\n+        comp.invoke(\"compiler.loopopts.superword.templated.AliasingFuzzer\", \"main\", new Object[] {flags});\n+        long t3 = System.nanoTime();\n+\n+        System.out.println(\"Code Generation:  \" + (t1-t0) * 1e-9f);\n+        System.out.println(\"Code Compilation: \" + (t2-t1) * 1e-9f);\n+        System.out.println(\"Running Tests:    \" + (t3-t2) * 1e-9f);\n+    }\n+\n+    public static String[] randomFlags() {\n+        \/\/ We don't want to always run with all flags, that is too expensive.\n+        \/\/ But let's make sure things don't completely, rot by running with some\n+        \/\/ random flags that are relevant.\n+        \/\/ We set the odds towards the \"default\" we are targetting.\n+        return new String[] {\n+            \/\/ Default disabled.\n+            \"-XX:\" + randomPlusMinus(1, 5) + \"AlignVector\",\n+            \/\/ Default enabled.\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"UseAutoVectorizationSpeculativeAliasingChecks\",\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"UseAutoVectorizationPredicate\",\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"ShortRunningLongLoop\",\n+            \/\/ Either way is ok.\n+            \"-XX:\" + randomPlusMinus(1, 1) + \"UseCompactObjectHeaders\",\n+            \"-XX:SuperWordAutomaticAlignment=\" + RANDOM.nextInt(0,3)\n+        };\n+    }\n+\n+    public static String randomPlusMinus(int plus, int minus) {\n+        return (RANDOM.nextInt(plus + minus) < plus) ? \"+\" : \"-\";\n+    }\n+\n+    public static <T> T sample(List<T> list) {\n+        int r = RANDOM.nextInt(list.size());\n+        return list.get(r);\n+    }\n+\n+    public static String generate(CompileFramework comp) {\n+        \/\/ Create a list to collect all tests.\n+        List<TemplateToken> testTemplateTokens = new ArrayList<>();\n+\n+        \/\/ Add some basic functionalities.\n+        testTemplateTokens.add(generateIndexForm());\n+\n+        \/\/ Array tests\n+        for (int i = 0; i < 10; i++) {\n+            testTemplateTokens.add(TestGenerator.makeArray().generate());\n+        }\n+\n+        \/\/ MemorySegment with getAtIndex \/ setAtIndex\n+        for (int i = 0; i < 20; i++) {\n+            testTemplateTokens.add(TestGenerator.makeMemorySegment().generate());\n+        }\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"compiler.loopopts.superword.templated\", \"AliasingFuzzer\",\n+            \/\/ List of imports.\n+            Set.of(\"compiler.lib.generators.*\",\n+                   \"compiler.lib.verify.*\",\n+                   \"java.lang.foreign.*\",\n+                   \"java.util.Random\",\n+                   \"jdk.test.lib.Utils\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+\n+    \/\/ The IndexForm is used to model the index. We can use it for arrays, but also by\n+    \/\/ restricting the MemorySegment index to a simple index.\n+    \/\/\n+    \/\/ Form:\n+    \/\/   index = con + iv * ivScale + invar0 * invar0Scale + invarRest\n+    \/\/                                                       [err]\n+    \/\/\n+    \/\/ The index has a size >= 1, so that the index refers to a region:\n+    \/\/   [index, index + size]\n+    \/\/\n+    \/\/ The idea is that invarRest is always close to zero, with some small range [-err .. err].\n+    \/\/ The invar variables for invarRest must be in the range [-1, 0, 1], so that we can\n+    \/\/ estimate the error range from the invarRestScales.\n+    \/\/\n+    \/\/ At runtime, we will have to generate inputs for the iv.lo\/iv.hi, as well as the invar0,\n+    \/\/ so that the index range lays in some predetermined range [range.lo, range.hi] and the\n+    \/\/ ivStride:\n+    \/\/\n+    \/\/ for (int iv = iv.lo; iv < iv.hi; iv += ivStride) {\n+    \/\/     assert: range.lo <= index(iv)\n+    \/\/                         index(iv) + size <= range.hi\n+    \/\/ }\n+    \/\/\n+    \/\/ Since there are multiple memory accesses, we may have multiple indices to compute.\n+    \/\/ Since they are all in the same loop, the indices share the same iv.lo and iv.hi. Hence,\n+    \/\/ we fix either iv.lo or iv.hi, and compute the other via the constraints.\n+    \/\/\n+    \/\/ Fix iv.lo, assume ivScale > 0:\n+    \/\/   index(iv) is smallest for iv = iv.lo, so we must satisfy\n+    \/\/     range.lo <= con + iv.lo * ivScale + invar0 * invar0Scale + invarRest\n+    \/\/              <= con + iv.lo * ivScale + invar0 * invar0Scale - err\n+    \/\/   It follows:\n+    \/\/     invar0 * invar0Scale >= range.lo - con - iv.lo * ivScale + err\n+    \/\/   This allows us to pick a invar0.\n+    \/\/   Now, we can compute the largest iv.lo possible.\n+    \/\/   index(iv) is largest for iv = iv.hi, so we must satisfy:\n+    \/\/     range.hi >= con + iv.hi * ivScale + invar0 * invar0Scale + invarRest + size\n+    \/\/              >= con + iv.hi * ivScale + invar0 * invar0Scale + err       + size\n+    \/\/   It follows:\n+    \/\/     iv.hi * ivScale <= range.hi - con - invar0 * invar0Scale - err - size\n+    \/\/   This allows us to pick a iv.hi.\n+    \/\/\n+    \/\/ More details can be found in the implementation below.\n+    \/\/\n+    public static record IndexForm(int con, int ivScale, int invar0Scale, int[] invarRestScales, int size) {\n+        public static IndexForm random(int numInvarRest, int size, int ivStrideAbs) {\n+            int con = RANDOM.nextInt(-100_000, 100_000);\n+            int ivScale = randomScale(size \/ ivStrideAbs);\n+            int invar0Scale = randomScale(size);\n+            int[] invarRestScales = new int[numInvarRest];\n+            \/\/ Sample values [-1, 0, 1]\n+            for (int i = 0; i < invarRestScales.length; i++) {\n+                invarRestScales[i] = RANDOM.nextInt(-1, 2);\n+            }\n+            return new IndexForm(con, ivScale, invar0Scale, invarRestScales, size);\n+        }\n+\n+        public static int randomScale(int size) {\n+            int scale = switch(RANDOM.nextInt(10)) {\n+                case 0 -> RANDOM.nextInt(1, 4 * size + 1); \/\/ any strided access\n+                default -> size; \/\/ in most cases, we do not want it to be strided\n+            };\n+            return RANDOM.nextBoolean() ? scale : -scale;\n+        }\n+\n+        public String generate() {\n+            return \"new IndexForm(\" + con() + \", \" + ivScale() + \", \" + invar0Scale() + \", new int[] {\" +\n+                   Arrays.stream(invarRestScales)\n+                         .mapToObj(String::valueOf)\n+                         .collect(Collectors.joining(\", \")) +\n+                   \"}, \" + size() + \")\";\n+        }\n+\n+        public TemplateToken index(String invar0, String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"con\", con),\n+                let(\"ivScale\", ivScale),\n+                let(\"invar0Scale\", invar0Scale),\n+                let(\"invar0\", invar0),\n+                \"#con + #ivScale * i + #invar0Scale * #invar0\",\n+                IntStream.range(0, invarRestScales.length).mapToObj(\n+                    i -> List.of(\" + \", invarRestScales[i], \" * \", invarRest[i])\n+                ).toList()\n+            ));\n+            return template.asToken();\n+        }\n+\n+        \/\/ MemorySegment need to be long-addressed, otherwise there can be int-overflow\n+        \/\/ in the index, and that prevents RangeCheck Elimination and Vectorization.\n+        public TemplateToken indexLong(String invar0, String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"con\", con),\n+                let(\"ivScale\", ivScale),\n+                let(\"invar0Scale\", invar0Scale),\n+                let(\"invar0\", invar0),\n+                \"#{con}L + #{ivScale}L * i + #{invar0Scale}L * #invar0\",\n+                IntStream.range(0, invarRestScales.length).mapToObj(\n+                    i -> List.of(\" + \", invarRestScales[i], \"L * \", invarRest[i])\n+                ).toList()\n+            ));\n+            return template.asToken();\n+        }\n+    }\n+\n+    \/\/ Mirror the IndexForm from the generator to the test.\n+    public static TemplateToken generateIndexForm() {\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            private static final Random RANDOM = Utils.getRandomInstance();\n+\n+            public static record IndexForm(int con, int ivScale, int invar0Scale, int[] invarRestScales, int size) {\n+                public IndexForm {\n+                    if (ivScale == 0 || invar0Scale == 0) {\n+                        throw new RuntimeException(\"Bad scales: \" + ivScale + \" \" + invar0Scale);\n+                    }\n+                }\n+\n+                public static record Range(int lo, int hi) {\n+                    public Range {\n+                        if (lo >= hi) { throw new RuntimeException(\"Bad range: \" + lo + \" \" + hi); }\n+                    }\n+                }\n+\n+                public int err() {\n+                    int sum = 0;\n+                    for (int scale : invarRestScales) { sum += Math.abs(scale); }\n+                    return sum;\n+                }\n+\n+                public int invar0ForIvLo(Range range, int ivLo) {\n+                    if (ivScale > 0) {\n+                        \/\/ index(iv) is smallest for iv = ivLo, so we must satisfy:\n+                        \/\/   range.lo <= con + iv.lo * ivScale + invar0 * invar0Scale + invarRest\n+                        \/\/            <= con + iv.lo * ivScale + invar0 * invar0Scale - err\n+                        \/\/ It follows:\n+                        \/\/   invar0 * invar0Scale >= range.lo - con - iv.lo * ivScale + err\n+                        int rhs = range.lo() - con - ivLo * ivScale + err();\n+                        int invar0 = (invar0Scale > 0)\n+                        ?\n+                            \/\/ invar0 * invar0Scale >=  range.lo - con - iv.lo * ivScale + err\n+                            \/\/ invar0               >= (range.lo - con - iv.lo * ivScale + err) \/ invar0Scale\n+                            Math.floorDiv(rhs + invar0Scale - 1, invar0Scale) \/\/ round up division\n+                        :\n+                            \/\/ invar0 * invar0Scale >=  range.lo - con - iv.lo * ivScale + err\n+                            \/\/ invar0               <= (range.lo - con - iv.lo * ivScale + err) \/ invar0Scale\n+                            Math.floorDiv(rhs, invar0Scale); \/\/ round down division\n+                        if (range.lo() > con + ivLo * ivScale + invar0 * invar0Scale - err()) {\n+                            throw new RuntimeException(\"sanity check failed (1)\");\n+                        }\n+                        return invar0;\n+                    } else {\n+                        \/\/ index(iv) is largest for iv = ivLo, so we must satisfy:\n+                        \/\/   range.hi >= con + iv.lo * ivScale + invar0 * invar0Scale + invarRest + size\n+                        \/\/            >= con + iv.lo * ivScale + invar0 * invar0Scale + err       + size\n+                        \/\/ It follows:\n+                        \/\/   invar0 * invar0Scale <= range.hi - con - iv.lo * ivScale - err - size\n+                        int rhs = range.hi() - con - ivLo * ivScale - err() - size();\n+                        int invar0 = (invar0Scale > 0)\n+                        ?\n+                            \/\/ invar0 * invar0Scale <= rhs\n+                            \/\/ invar0               <= rhs \/ invar0Scale\n+                            Math.floorDiv(rhs, invar0Scale) \/\/ round down division\n+                        :\n+                            \/\/ invar0 * invar0Scale <= rhs\n+                            \/\/ invar0               >= rhs \/ invar0Scale\n+                            Math.floorDiv(rhs + invar0Scale + 1, invar0Scale); \/\/ round up division\n+                        if (range.hi() < con + ivLo * ivScale + invar0 * invar0Scale + err() + size()) {\n+                            throw new RuntimeException(\"sanity check failed (2)\");\n+                        }\n+                        return invar0;\n+\n+                    }\n+                }\n+\n+                public int ivHiForInvar0(Range range, int invar0) {\n+                    if (ivScale > 0) {\n+                        \/\/ index(iv) is largest for iv = ivHi, so we must satisfy:\n+                        \/\/   range.hi >= con + iv.hi * ivScale + invar0 * invar0Scale + invarRest + size\n+                        \/\/            >= con + iv.hi * ivScale + invar0 * invar0Scale + err       + size\n+                        \/\/ It follows:\n+                        \/\/   iv.hi * ivScale <=  range.hi - con - invar0 * invar0Scale - err - size\n+                        \/\/   iv.hi           <= (range.hi - con - invar0 * invar0Scale - err - size) \/ ivScale\n+                        int rhs = range.hi() - con - invar0 * invar0Scale - err() - size();\n+                        int ivHi = Math.floorDiv(rhs, ivScale); \/\/ round down division\n+                        if (range.hi() < con + ivHi * ivScale + invar0 * invar0Scale + err() + size()) {\n+                            throw new RuntimeException(\"sanity check failed (3)\");\n+                        }\n+                        return ivHi;\n+                    } else {\n+                        \/\/ index(iv) is smallest for iv = ivHi, so we must satisfy:\n+                        \/\/   range.lo <= con + iv.hi * ivScale + invar0 * invar0Scale + invarRest\n+                        \/\/            <= con + iv.hi * ivScale + invar0 * invar0Scale - err\n+                        \/\/ It follows:\n+                        \/\/   iv.hi * ivScale >=  range.lo - con - invar0 * invar0Scale + err\n+                        \/\/   iv.hi           <= (range.lo - con - invar0 * invar0Scale + err) \/ ivScale\n+                        int rhs = range.lo() - con - invar0 * invar0Scale + err();\n+                        int ivHi = Math.floorDiv(rhs, ivScale); \/\/ round down division\n+                        if (range.lo() > con + ivHi * ivScale + invar0 * invar0Scale - err()) {\n+                            throw new RuntimeException(\"sanity check failed (4)\");\n+                        }\n+                        return ivHi;\n+\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        ));\n+        return template.asToken();\n+    }\n+\n+    public static record TestGenerator(\n+        \/\/ The containers.\n+        int numContainers,\n+        int containerByteSize,\n+        ContainerKind containerKind,\n+        MyType containerElementType,\n+\n+        \/\/ Do we count up or down, iterate over the containers forward or backward?\n+        boolean loopForward,\n+        int ivStrideAbs,\n+        boolean isLongIvType,\n+\n+        \/\/ For all index forms: number of invariants in the rest, i.e. the [err] term.\n+        int numInvarRest,\n+\n+        \/\/ Each access has an index form and a type.\n+        IndexForm[] accessIndexForm,\n+        MyType[] accessType,\n+\n+        \/\/ The scenario.\n+        Aliasing aliasing,\n+        AccessScenario accessScenario) {\n+\n+        public static TestGenerator makeArray() {\n+            \/\/ Sample some random parameters:\n+            Aliasing aliasing = sample(Arrays.asList(Aliasing.values()));\n+            AccessScenario accessScenario = sample(Arrays.asList(AccessScenario.values()));\n+            MyType type = sample(primitiveTypes);\n+\n+            \/\/ size must be large enough for:\n+            \/\/   - scale = 4\n+            \/\/   - range with size \/ 4\n+            \/\/ -> need at least size 16_000 to ensure we have 1000 iterations\n+            \/\/ We want there to be a little variation, so alignment is not always the same.\n+            int numElements = Generators.G.safeRestrict(Generators.G.ints(), 18_000, 20_000).next();\n+            int containerByteSize = numElements * type.byteSize();\n+            boolean loopForward = RANDOM.nextBoolean();\n+\n+            int numInvarRest = RANDOM.nextInt(5);\n+            int ivStrideAbs = 1;\n+            boolean isLongIvType = false; \/\/ int index\n+            var form0 = IndexForm.random(numInvarRest, 1, ivStrideAbs);\n+            var form1 = IndexForm.random(numInvarRest, 1, ivStrideAbs);\n+\n+            return new TestGenerator(\n+                2,\n+                containerByteSize,\n+                ContainerKind.ARRAY,\n+                type,\n+                loopForward,\n+                ivStrideAbs,\n+                isLongIvType,\n+                numInvarRest,\n+                new IndexForm[] {form0, form1},\n+                new MyType[]    {type,   type},\n+                aliasing,\n+                accessScenario);\n+        }\n+\n+        public static int alignUp(int value, int align) {\n+            return Math.ceilDiv(value, align) * align;\n+        }\n+\n+        public static TestGenerator makeMemorySegment() {\n+            \/\/ Sample some random parameters:\n+            Aliasing aliasing = sample(Arrays.asList(Aliasing.values()));\n+            AccessScenario accessScenario = sample(Arrays.asList(AccessScenario.values()));\n+            \/\/ Backing memory can be native, access must be primitive.\n+            MyType containerElementType = sample(primitiveTypesAndNative);\n+            MyType accessType0 = sample(primitiveTypes);\n+            MyType accessType1 = sample(primitiveTypes);\n+            ContainerKind containerKind = sample(List.of(\n+                ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE\n+            ));\n+\n+            if (containerKind == ContainerKind.MEMORY_SEGMENT_AT_INDEX) {\n+                \/\/ The access types must be the same, it is a limitation of the index computation.\n+                accessType1 = accessType0;\n+            }\n+\n+            final int minAccessSize = Math.min(accessType0.byteSize(), accessType1.byteSize());\n+            final int maxAccessSize = Math.max(accessType0.byteSize(), accessType1.byteSize());\n+\n+            \/\/ size must be large enough for:\n+            \/\/   - scale = 4\n+            \/\/   - range with size \/ 4\n+            \/\/ -> need at least size 16_000 to ensure we have 1000 iterations\n+            \/\/ We want there to be a little variation, so alignment is not always the same.\n+            final int numAccessElements = Generators.G.safeRestrict(Generators.G.ints(), 18_000, 20_000).next();\n+            final int align = Math.max(maxAccessSize, containerElementType.byteSize());\n+            \/\/ We need to align up, so the size is divisible exactly by all involved type sizes.\n+            final int containerByteSize = alignUp(numAccessElements * maxAccessSize, align);\n+            final boolean loopForward = RANDOM.nextBoolean();\n+\n+            final int numInvarRest = RANDOM.nextInt(5);\n+            int indexSize0 = accessType0.byteSize();\n+            int indexSize1 = accessType1.byteSize();\n+            if (containerKind == ContainerKind.MEMORY_SEGMENT_AT_INDEX) {\n+                \/\/ These are int-indeces for getAtIndex, so we index by element and not bytes.\n+                indexSize0 = 1;\n+                indexSize1 = 1;\n+            }\n+\n+            boolean withAbsOneIvScale = containerKind == ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE;\n+            int ivStrideAbs = containerKind == ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ? minAccessSize : 1;\n+            boolean isLongIvType = RANDOM.nextBoolean();\n+            var form0 = IndexForm.random(numInvarRest, indexSize0, ivStrideAbs);\n+            var form1 = IndexForm.random(numInvarRest, indexSize1, ivStrideAbs);\n+\n+            return new TestGenerator(\n+                2,\n+                containerByteSize,\n+                containerKind,\n+                containerElementType,\n+                loopForward,\n+                ivStrideAbs,\n+                isLongIvType,\n+                numInvarRest,\n+                new IndexForm[] {form0, form1},\n+                new MyType[]    {accessType0, accessType1},\n+                aliasing,\n+                accessScenario);\n+        }\n+\n+        public TemplateToken generate() {\n+            var testTemplate = Template.make(() -> {\n+                \/\/ Let's generate the variable names that are to be shared for the nested Templates.\n+                String[] invarRest = new String[numInvarRest];\n+                for (int i = 0; i < invarRest.length; i++) {\n+                    invarRest[i] = $(\"invar\" + i);\n+                }\n+                String[] containerNames = new String[numContainers];\n+                for (int i = 0; i < numContainers; i++) {\n+                    containerNames[i] = $(\"container\" + i);\n+                }\n+                String[] indexFormNames = new String[accessIndexForm.length];\n+                for (int i = 0; i < indexFormNames.length; i++) {\n+                    indexFormNames[i] = $(\"index\" + i);\n+                }\n+                return body(\n+                    \"\"\"\n+                    \/\/ --- $test start ---\n+                    \"\"\",\n+                    generateTestFields(invarRest, containerNames, indexFormNames),\n+                    \"\"\"\n+                    \/\/ Count the run invocations.\n+                    private static int $iterations = 0;\n+\n+                    @Run(test = \"$test\")\n+                    @Warmup(100)\n+                    public static void $run(RunInfo info) {\n+\n+                        \/\/ Once warmup is over (100x), repeat 10x to get reasonable coverage of the\n+                        \/\/ randomness in the tests.\n+                        int reps = info.isWarmUp() ? 10 : 1;\n+                        for (int r = 0; r < reps; r++) {\n+\n+                            $iterations++;\n+                    \"\"\",\n+                    generateContainerInit(containerNames),\n+                    generateContainerAliasing(containerNames, $(\"iterations\")),\n+                    generateRanges(),\n+                    generateBoundsAndInvariants(indexFormNames, invarRest),\n+                    \"\"\"\n+                            \/\/ Run test and compare with interpreter results.\n+                    \"\"\",\n+                    generateCallMethod(\"result\", $(\"test\"), \"test\"),\n+                    generateCallMethod(\"expected\", $(\"reference\"), \"reference\"),\n+                    \"\"\"\n+                            Verify.checkEQ(result, expected);\n+                        } \/\/ end reps\n+                    } \/\/ end $run\n+\n+                    @Test\n+                    \"\"\",\n+                    generateIRRules(),\n+                    generateTestMethod($(\"test\"), invarRest),\n+                    \"\"\"\n+                    @DontCompile\n+                    \"\"\",\n+                    generateTestMethod($(\"reference\"), invarRest),\n+                    \"\"\"\n+\n+                    \/\/ --- $test end ---\n+                    \"\"\"\n+                );\n+            });\n+            return testTemplate.asToken();\n+        }\n+\n+        private TemplateToken generateArrayField(String name, MyType type) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ type.byteSize()),\n+                let(\"name\", name),\n+                let(\"type\", type),\n+                \"\"\"\n+                private static #type[] original_#name  = new #type[#size];\n+                private static #type[] test_#name      = new #type[#size];\n+                private static #type[] reference_#name = new #type[#size];\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateMemorySegmentField(String name, MyType type) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ type.byteSize()),\n+                let(\"byteSize\", containerByteSize),\n+                let(\"name\", name),\n+                let(\"type\", type),\n+                (type == myNative\n+                 ?  \"\"\"\n+                    private static MemorySegment original_#name  = Arena.ofAuto().allocate(#byteSize);\n+                    private static MemorySegment test_#name      = Arena.ofAuto().allocate(#byteSize);\n+                    private static MemorySegment reference_#name = Arena.ofAuto().allocate(#byteSize);\n+                    \"\"\"\n+                 :  \"\"\"\n+                    private static MemorySegment original_#name  = MemorySegment.ofArray(new #type[#size]);\n+                    private static MemorySegment test_#name      = MemorySegment.ofArray(new #type[#size]);\n+                    private static MemorySegment reference_#name = MemorySegment.ofArray(new #type[#size]);\n+                    \"\"\"\n+                )\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIndexField(String name, IndexForm form) {\n+            var template = Template.make(() -> body(\n+                let(\"name\", name),\n+                let(\"form\", form.generate()),\n+                \"\"\"\n+                private static IndexForm #name = #form;\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestFields(String[] invarRest, String[] containerNames, String[] indexFormNames) {\n+            var template = Template.make(() -> body(\n+                let(\"ivType\", isLongIvType ? \"long\" : \"int\"),\n+                \"\"\"\n+                \/\/ invarRest fields:\n+                \"\"\",\n+                Arrays.stream(invarRest).map(invar ->\n+                    List.of(\"private static #ivType \", invar, \" = 0;\\n\")\n+                ).toList(),\n+                \"\"\"\n+                \/\/ Containers fields:\n+                \"\"\",\n+                Arrays.stream(containerNames).map(name ->\n+                    switch (containerKind) {\n+                        case ContainerKind.ARRAY ->\n+                            generateArrayField(name, containerElementType);\n+                        case ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                            generateMemorySegmentField(name, containerElementType);\n+                    }\n+                ).toList(),\n+                \"\"\"\n+                \/\/ Index forms for the accesses:\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    generateIndexField(indexFormNames[i], accessIndexForm[i])\n+                ).toList()\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerInitArray(String name) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ containerElementType.byteSize()),\n+                let(\"name\", name),\n+                \"\"\"\n+                System.arraycopy(original_#name, 0, test_#name, 0, #size);\n+                System.arraycopy(original_#name, 0, reference_#name, 0, #size);\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerInitMemorySegment(String name) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ containerElementType.byteSize()),\n+                let(\"name\", name),\n+                \"\"\"\n+                test_#name.copyFrom(original_#name);\n+                reference_#name.copyFrom(original_#name);\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerInit(String[] containerNames) {\n+            var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Init containers from original data:\n+                \"\"\",\n+                Arrays.stream(containerNames).map(name ->\n+                    switch (containerKind) {\n+                        case ContainerKind.ARRAY ->\n+                            generateContainerInitArray(name);\n+                        case ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                            generateContainerInitMemorySegment(name);\n+                    }\n+                ).toList()\n+             ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerAliasingAssignment(int i, String name1, String name2, String iterations) {\n+            var template = Template.make(() -> body(\n+                let(\"i\", i),\n+                let(\"name1\", name1),\n+                let(\"name2\", name2),\n+                let(\"iterations\", iterations),\n+                \"\"\"\n+                var test_#i      = (#iterations % 2 == 0) ? test_#name1      : test_#name2;\n+                var reference_#i = (#iterations % 2 == 0) ? reference_#name1 : reference_#name2;\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerAliasing(String[] containerNames, String iterations) {\n+            var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Container aliasing:\n+                \"\"\",\n+                IntStream.range(0, containerNames.length).mapToObj(i ->\n+                    switch(aliasing) {\n+                        case Aliasing.CONTAINER_DIFFERENT ->\n+                            generateContainerAliasingAssignment(i, containerNames[i], containerNames[i], iterations);\n+                        case Aliasing.CONTAINER_SAME_ALIASING_NEVER,\n+                             Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN ->\n+                            generateContainerAliasingAssignment(i, containerNames[0], containerNames[0], iterations);\n+                        case Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER,\n+                             Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                            generateContainerAliasingAssignment(i, containerNames[i], containerNames[0], iterations);\n+                    }\n+                ).toList()\n+             ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateRanges() {\n+            int size = switch (containerKind) {\n+                case ContainerKind.ARRAY,\n+                     ContainerKind.MEMORY_SEGMENT_AT_INDEX ->\n+                    \/\/ Access with element index\n+                    containerByteSize \/ accessType[0].byteSize();\n+                case ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                     ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                    \/\/ Access with byte offset\n+                    containerByteSize;\n+            };\n+\n+            if (accessIndexForm.length != 2) { throw new RuntimeException(\"not yet implemented\"); }\n+\n+            var templateSplitRanges = Template.make(() -> body(\n+                let(\"size\", size),\n+                \"\"\"\n+                int middle = RANDOM.nextInt(#size \/ 3, #size * 2 \/ 3);\n+                int rnd = Math.min(256, #size \/ 10);\n+                int range = #size \/ 3 - RANDOM.nextInt(rnd);\n+                \"\"\",\n+                (RANDOM.nextBoolean()\n+                 \/\/ Maximal range\n+                 ?  \"\"\"\n+                    var r0 = new IndexForm.Range(0, middle);\n+                    var r1 = new IndexForm.Range(middle, #size);\n+                    \"\"\"\n+                 \/\/ Same size range\n+                 \/\/ If the accesses run towards each other, and the runtime\n+                 \/\/ check is too relaxed, we may fail the checks even though\n+                 \/\/ there is no overlap. Having same size ranges makes this\n+                 \/\/ more likely, and we could detect it if we get multiversioning\n+                 \/\/ unexpectedly.\n+                 :  \"\"\"\n+                    var r0 = new IndexForm.Range(middle - range, middle);\n+                    var r1 = new IndexForm.Range(middle, middle + range);\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                if (RANDOM.nextBoolean()) {\n+                    var tmp = r0;\n+                    r0 = r1;\n+                    r1 = tmp;\n+                }\n+                \"\"\"\n+            ));\n+\n+            var templateWholeRanges = Template.make(() -> body(\n+                let(\"size\", size),\n+                \"\"\"\n+                var r0 = new IndexForm.Range(0, #size);\n+                var r1 = new IndexForm.Range(0, #size);\n+                \"\"\"\n+            ));\n+\n+            var templateRandomRanges = Template.make(() -> body(\n+                let(\"size\", size),\n+                \"\"\"\n+                int lo0 = RANDOM.nextInt(0, #size * 3 \/ 4);\n+                int lo1 = RANDOM.nextInt(0, #size * 3 \/ 4);\n+                var r0 = new IndexForm.Range(lo0, lo0 + #size \/ 4);\n+                var r1 = new IndexForm.Range(lo1, lo1 + #size \/ 4);\n+                \"\"\"\n+            ));\n+\n+            var templateSmallOverlapRanges = Template.make(() -> body(\n+                \/\/ Idea: same size ranges, with size \"range\". A small overlap,\n+                \/\/       so that bad runtime checks would create wrong results.\n+                let(\"size\", size),\n+                \"\"\"\n+                int rnd = Math.min(256, #size \/ 10);\n+                int middle = #size \/ 2 + RANDOM.nextInt(-rnd, rnd);\n+                int range = #size \/ 3 - RANDOM.nextInt(rnd);\n+                int overlap = RANDOM.nextInt(-rnd, rnd);\n+                var r0 = new IndexForm.Range(middle - range + overlap, middle + overlap);\n+                var r1 = new IndexForm.Range(middle, middle + range);\n+                if (RANDOM.nextBoolean()) {\n+                    var tmp = r0;\n+                    r0 = r1;\n+                    r1 = tmp;\n+                }\n+                \"\"\"\n+                \/\/ Can this go out of bounds? Assume worst case on lower end:\n+                \/\/   middle         - range          + overlap\n+                \/\/   (size\/2 - rnd) - (size\/3 - rnd) - rnd\n+                \/\/   size\/6 - rnd\n+                \/\/ -> safe with rnd = size\/10\n+            ));\n+\n+            var templateAnyRanges = Template.make(() -> body(\n+                switch(RANDOM.nextInt(4)) {\n+                    case 0 -> templateSplitRanges.asToken();\n+                    case 1 -> templateWholeRanges.asToken();\n+                    case 2 -> templateRandomRanges.asToken();\n+                    case 3 -> templateSmallOverlapRanges.asToken();\n+                    default -> throw new RuntimeException(\"impossible\");\n+                }\n+            ));\n+\n+            var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Generate ranges:\n+                \"\"\",\n+                switch(aliasing) {\n+                    case Aliasing.CONTAINER_DIFFERENT ->\n+                        templateAnyRanges.asToken();\n+                    case Aliasing.CONTAINER_SAME_ALIASING_NEVER ->\n+                        templateSplitRanges.asToken();\n+                    case Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN ->\n+                        templateAnyRanges.asToken();\n+                    case Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER ->\n+                        templateSplitRanges.asToken();\n+                    case Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                        templateAnyRanges.asToken();\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateBoundsAndInvariants(String[] indexFormNames, String[] invarRest) {\n+            \/\/ We want there to be at least 1000 iterations.\n+            final int minIvRange = ivStrideAbs * 1000;\n+\n+            var template = Template.make(() -> body(\n+                let(\"containerByteSize\", containerByteSize),\n+                \"\"\"\n+                \/\/ Compute loop bounds and loop invariants.\n+                int ivLo = RANDOM.nextInt(-1000, 1000);\n+                int ivHi = ivLo + #containerByteSize;\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    Template.make(() -> body(\n+                        let(\"i\", i),\n+                        let(\"form\", indexFormNames[i]),\n+                        \"\"\"\n+                        int invar0_#i = #form.invar0ForIvLo(r#i, ivLo);\n+                        ivHi = Math.min(ivHi, #form.ivHiForInvar0(r#i, invar0_#i));\n+                        \"\"\"\n+                    )).asToken()\n+                ).toList(),\n+                let(\"minIvRange\", minIvRange),\n+                \"\"\"\n+                \/\/ Let's check that the range is large enough, so that the vectorized\n+                \/\/ main loop can even be entered.\n+                if (ivLo + #minIvRange > ivHi) { throw new RuntimeException(\"iv range too small: \" + ivLo + \" \" + ivHi); }\n+                \"\"\",\n+                Arrays.stream(invarRest).map(invar ->\n+                    List.of(invar, \" = RANDOM.nextInt(-1, 2);\\n\")\n+                ).toList(),\n+                \"\"\"\n+                \/\/ Verify the bounds we just created, just to be sure there is no unexpected aliasing!\n+                int i = ivLo;\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    List.of(\"int lo_\", i, \" = (int)(\", accessIndexForm[i].index(\"invar0_\" + i, invarRest), \");\\n\")\n+                ).toList(),\n+                \"\"\"\n+                i = ivHi;\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    List.of(\"int hi_\", i, \" =  (int)(\", accessIndexForm[i].index(\"invar0_\" + i, invarRest), \");\\n\")\n+                ).toList(),\n+                switch(aliasing) {\n+                    case Aliasing.CONTAINER_SAME_ALIASING_NEVER,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER -> \/\/ could fail in the future if we make it smarter\n+                        List.of(\n+                        \"\"\"\n+                        \/\/ Bounds should not overlap.\n+                        if (false\n+                        \"\"\",\n+                        IntStream.range(0, indexFormNames.length).mapToObj(i1 ->\n+                            IntStream.range(0, i1).mapToObj(i2 ->\n+                                Template.make(() -> body(\n+                                    let(\"i1\", i1),\n+                                    let(\"i2\", i2),\n+                                    \/\/ i1 < i2 or i1 > i2\n+                                    \"\"\"\n+                                    || (lo_#i1 < lo_#i2 && lo_#i1 < hi_#i2 && hi_#i1 < lo_#i2 && hi_#i1 < hi_#i2)\n+                                    || (lo_#i1 > lo_#i2 && lo_#i1 > hi_#i2 && hi_#i1 > lo_#i2 && hi_#i1 > hi_#i2)\n+                                    \"\"\"\n+                                )).asToken()\n+                            ).toList()\n+                        ).toList(),\n+                        \"\"\"\n+                        ) {\n+                            \/\/ pass\n+                        } else {\n+                            throw new RuntimeException(\"bounds overlap!\");\n+                        }\n+                        \"\"\");\n+                    case Aliasing.CONTAINER_DIFFERENT,\n+                         Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                        \"\"\"\n+                        \/\/ Aliasing unknown, cannot verify bounds.\n+                        \"\"\";\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+\n+        private TemplateToken generateCallMethod(String output, String methodName, String containerPrefix) {\n+            var template = Template.make(() -> body(\n+                let(\"output\", output),\n+                let(\"methodName\", methodName),\n+                \"var #output = #methodName(\",\n+                IntStream.range(0, numContainers).mapToObj(i ->\n+                    List.of(containerPrefix, \"_\", i, \", invar0_\", i, \", \")\n+                ).toList(),\n+                \"ivLo, ivHi);\\n\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRules() {\n+            var template = Template.make(() -> body(\n+                switch (containerKind) {\n+                    case ContainerKind.ARRAY ->\n+                        generateIRRulesArray();\n+                    case ContainerKind.MEMORY_SEGMENT_AT_INDEX ->\n+                        generateIRRulesMemorySegmentAtIndex();\n+                    case ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE ->\n+                        generateIRRulesMemorySegmentLongAdrScale();\n+                    case ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                        generateIRRulesMemorySegmentLongAdrStride();\n+                },\n+                \/\/ In same scnearios, we know that a aliasing runtime check will never fail.\n+                \/\/ That means if we have UseAutoVectorizationPredicate enabled, that predicate\n+                \/\/ will never fail, and we will not have to do multiversioning.\n+                switch(aliasing) {\n+                    case Aliasing.CONTAINER_DIFFERENT,\n+                         Aliasing.CONTAINER_SAME_ALIASING_NEVER,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER ->\n+                        \/\/ We would have liked to check that there is no multiversioning.\n+                        \/\/\n+                        \/\/ But sadly there are some cases that have issues with RCE and\/or\n+                        \/\/ predicates, and so we end up using multiversioning anyway. We\n+                        \/\/ should fix those cases eventually, to strengthen the checks here.\n+                        \/\/\n+                        \/\/ The array cases are a little more tame, and do not have the same\n+                        \/\/ issues as the MemorySegment cases.\n+                        (containerKind == ContainerKind.ARRAY)\n+                        ? \"\"\"\n+                          \/\/ Aliasing check should never fail at runtime, so the predicate\n+                          \/\/ should never fail, and we do not have to use multiversioning.\n+                          \/\/ Failure could have a few causes:\n+                          \/\/ - issues with doing RCE \/ missing predicates\n+                          \/\/   -> other loop-opts need to be fixed\n+                          \/\/ - predicate fails: recompile with multiversioning\n+                          \/\/   -> logic in runtime check may be wrong\n+                          @IR(counts = {\".*multiversion.*\", \"= 0\"},\n+                              phase = CompilePhase.PRINT_IDEAL,\n+                              applyIf = {\"UseAutoVectorizationPredicate\", \"true\"},\n+                              applyIfPlatform = {\"64-bit\", \"true\"},\n+                              applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                          \"\"\"\n+                        : \"\"\"\n+                          \/\/ Due to cases like JDK-8360204 and JDK-8365982, there can be issues\n+                          \/\/ with RCE leading cases where we remove predicates and then unroll again\n+                          \/\/ and then end up multiversioning. These cases seem relatively rare but\n+                          \/\/ prevent us from asserting that there is never multiversioning in these cases.\n+                          \"\"\";\n+                   case Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                            \"\"\"\n+                            \/\/ Aliasing unknown, we may use the predicate or multiversioning.\n+                            \"\"\";\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        \/\/ Regular array-accesses are vectorized quite predictably, and we can create nice\n+        \/\/ IR rules - even for cases where we do not expect vectorization.\n+        private TemplateToken generateIRRulesArray() {\n+            var template = Template.make(() -> body(\n+                let(\"T\", containerElementType.letter()),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        \/\/ Currently, we do not allow strided access or shuffle.\n+                        \/\/ Since the load and store are connected, we either vectorize both or none.\n+                        (accessIndexForm[0].ivScale() == accessIndexForm[1].ivScale() &&\n+                         Math.abs(accessIndexForm[0].ivScale()) == 1)\n+                        ?   \"\"\"\n+                            \/\/ Good ivScales, vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"> 0\",\n+                                          IRNode.STORE_VECTOR,   \"> 0\"},\n+                                applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                                              \"AlignVector\", \"false\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\"\n+                        :   \"\"\"\n+                            \/\/ Bad ivScales, no vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"= 0\",\n+                                          IRNode.STORE_VECTOR,   \"= 0\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\";\n+                    case FILL_STORE_STORE ->\n+                        \/\/ Currently, we do not allow strided access.\n+                        \/\/ We vectorize any contiguous pattern. Possibly only one is vectorized.\n+                        (Math.abs(accessIndexForm[0].ivScale()) == 1 ||\n+                         Math.abs(accessIndexForm[1].ivScale()) == 1)\n+                        ?   \"\"\"\n+                            \/\/ Good ivScales, vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"= 0\",\n+                                          IRNode.STORE_VECTOR,   \"> 0\"},\n+                                applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                                              \"AlignVector\", \"false\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\"\n+                        :   \"\"\"\n+                            \/\/ Bad ivScales, no vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"= 0\",\n+                                          IRNode.STORE_VECTOR,   \"= 0\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\";\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRulesMemorySegmentAtIndex() {\n+           var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Unfortunately, there are some issues that prevent RangeCheck elimination.\n+                \/\/ The cases are currently quite unpredictable, so we cannot create any IR\n+                \/\/ rules - sometimes there are vectors sometimes not.\n+                \"\"\"\n+                \/\/ JDK-8359688: it seems we only vectorize with ivScale=1, and not ivScale=-1\n+                \/\/              The issue seems to be RangeCheck elimination\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRulesMemorySegmentLongAdrStride() {\n+           var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Unfortunately, there are some issues that prevent RangeCheck elimination.\n+                \/\/ The cases are currently quite unpredictable, so we cannot create any IR\n+                \/\/ rules - sometimes there are vectors sometimes not.\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRulesMemorySegmentLongAdrScale() {\n+           var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Unfortunately, there are some issues that prevent RangeCheck elimination.\n+                \/\/ The cases are currently quite unpredictable, so we cannot create any IR\n+                \/\/ rules - sometimes there are vectors sometimes not.\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestMethod(String methodName, String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"methodName\", methodName),\n+                let(\"containerElementType\", containerElementType),\n+                let(\"ivStrideAbs\", ivStrideAbs),\n+                let(\"ivType\", isLongIvType ? \"long\" : \"int\"),\n+                \/\/ Method head \/ signature.\n+                \"public static Object #methodName(\",\n+                IntStream.range(0, numContainers).mapToObj(i ->\n+                    switch (containerKind) {\n+                        case ContainerKind.ARRAY ->\n+                            List.of(\"#containerElementType[] container_\", i, \", #ivType invar0_\", i, \", \");\n+                        case ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                            List.of(\"MemorySegment container_\", i, \", #ivType invar0_\", i, \", \");\n+                    }\n+                ).toList(),\n+                \"#ivType ivLo, #ivType ivHi) {\\n\",\n+                \/\/ Method loop body.\n+                (loopForward\n+                 ?  \"for (#ivType i = ivLo; i < ivHi; i+=#ivStrideAbs) {\\n\"\n+                 :  \"for (#ivType i = ivHi-#ivStrideAbs; i >= ivLo; i-=#ivStrideAbs) {\\n\"),\n+                \/\/ Loop iteration.\n+                switch (containerKind) {\n+                    case ContainerKind.ARRAY ->\n+                        generateTestLoopIterationArray(invarRest);\n+                    case ContainerKind.MEMORY_SEGMENT_AT_INDEX ->\n+                        generateTestLoopIterationMemorySegmentAtIndex(invarRest);\n+                    case ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                         ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                        generateTestLoopIterationMemorySegmentLongAdr(invarRest);\n+                },\n+                \"\"\"\n+                    }\n+                    return new Object[] {\n+                \"\"\",\n+                \/\/ Return a list of all containers that are involved in the test.\n+                \/\/ The caller can then compare the results of the test and reference method.\n+                IntStream.range(0, numContainers).mapToObj(i ->\n+                    \"container_\" + i\n+                ).collect(Collectors.joining(\", \")), \"\\n\",\n+                \"\"\"\n+                    };\n+                }\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestLoopIterationArray(String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"type\", containerElementType),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        List.of(\"container_0[\", accessIndexForm[0].index(\"invar0_0\", invarRest), \"] = \",\n+                                \"container_1[\", accessIndexForm[1].index(\"invar0_1\", invarRest), \"];\\n\");\n+                    case FILL_STORE_STORE ->\n+                        List.of(\"container_0[\", accessIndexForm[0].index(\"invar0_0\", invarRest), \"] = (#type)0x0102030405060708L;\\n\",\n+                                \"container_1[\", accessIndexForm[1].index(\"invar0_1\", invarRest), \"] = (#type)0x1112131415161718L;\\n\");\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestLoopIterationMemorySegmentAtIndex(String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"type0\", accessType[0]),\n+                let(\"type1\", accessType[1]),\n+                let(\"type0Layout\", accessType[0].layout()),\n+                let(\"type1Layout\", accessType[1].layout()),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        \/\/ Conversion not implemented, index bound computation is too limited for this currently.\n+                        List.of(\"var v = \",\n+                                \"container_0.getAtIndex(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \");\\n\",\n+                                \"container_1.setAtIndex(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", v);\\n\");\n+                    case FILL_STORE_STORE ->\n+                        List.of(\"container_0.setAtIndex(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \", (#type0)0x0102030405060708L);\\n\",\n+                                \"container_1.setAtIndex(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", (#type1)0x1112131415161718L);\\n\");\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestLoopIterationMemorySegmentLongAdr(String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"type0\", accessType[0]),\n+                let(\"type1\", accessType[1]),\n+                let(\"type0Layout\", accessType[0].layout()),\n+                let(\"type1Layout\", accessType[1].layout()),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        \/\/ We allow conversions here.\n+                        List.of(\"#type1 v = (#type1)\",\n+                                \"container_0.get(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \");\\n\",\n+                                \"container_1.set(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", v);\\n\");\n+                    case FILL_STORE_STORE ->\n+                        List.of(\"container_0.set(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \", (#type0)0x0102030405060708L);\\n\",\n+                                \"container_1.set(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", (#type1)0x1112131415161718L);\\n\");\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":1284,"deletions":0,"binary":false,"changes":1284,"status":"added"},{"patch":"@@ -1066,1 +1066,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"rvv\", \"true\"})\n+        applyIfCPUFeature = {\"avx2\", \"true\"})\n@@ -1068,0 +1068,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"rvv\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n@@ -1178,1 +1186,1 @@\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"rvv\", \"true\"})\n+        applyIfCPUFeature = {\"avx2\", \"true\"})\n@@ -1180,0 +1188,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.LOAD_VECTOR_L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VL, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"riscv64\", \"true\"},\n+        applyIfCPUFeature = {\"rvv\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-    \/\/ Would be nice to vectorize: Missing support for CmpF, CMove and MoveF2I.\n+    \/\/ Would be nice to vectorize: Missing support for CmpF and CMove.\n@@ -407,1 +407,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -410,1 +412,0 @@\n-    \/\/ Missing support for MoveF2I\n@@ -419,1 +420,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -422,1 +425,0 @@\n-    \/\/ Missing support for MoveI2F\n@@ -434,1 +436,1 @@\n-    \/\/ Missing support for Needs CmpD, CMove and MoveD2L\n+    \/\/ Missing support to vectorize CmpD and CMove\n@@ -443,1 +445,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -446,1 +450,0 @@\n-    \/\/ Missing support for MoveD2L\n@@ -455,1 +458,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -458,1 +463,0 @@\n-    \/\/ Missing support for MoveL2D\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -39,1 +40,0 @@\n-    static final int ITER  = 100;\n@@ -76,6 +76,22 @@\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:-VerifyAlignVector\");\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:-VerifyAlignVector\");\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+VerifyAlignVector\");\n+        \/\/ Cross-product:\n+        \/\/ - AlignVector (+VerifyAlignVector)\n+        \/\/ - UseAutoVectorizationSpeculativeAliasingChecks\n+        List<String[]> avList = List.of(\n+            new String[] {\"-XX:-AlignVector\", \"-XX:-VerifyAlignVector\"},\n+            new String[] {\"-XX:+AlignVector\", \"-XX:-VerifyAlignVector\"},\n+            new String[] {\"-XX:+AlignVector\", \"-XX:+VerifyAlignVector\"}\n+        );\n+        List<String[]> sacList = List.of(\n+            new String[] {\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"},\n+            new String[] {\"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"}\n+        );\n+        for (String[] av : avList) {\n+            for (String[] sac : sacList) {\n+                TestFramework framework = new TestFramework();\n+                framework.addFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n+                                   \"-XX:+IgnoreUnrecognizedVMOptions\");\n+                framework.addFlags(av);\n+                framework.addFlags(sac);\n+                framework.start();\n+            }\n+        }\n@@ -137,1 +153,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -148,1 +164,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -159,1 +175,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -170,1 +186,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -181,1 +197,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -192,1 +208,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -203,1 +219,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -214,1 +230,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -225,1 +241,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -236,1 +252,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -247,1 +263,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -260,1 +276,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -271,1 +287,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -282,1 +298,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -295,1 +311,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -306,1 +322,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -433,2 +449,4 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -437,1 +455,9 @@\n-                  IRNode.ADD_VF, \"= 0\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, \"= 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -448,4 +474,8 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always different.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two float-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataF and dataF_2 do not alias -> full vectorization.\n+            \/\/ Note: at runtime the float-arrays are always different -> predicate suffices, no multiversioning.\n@@ -459,2 +489,11 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n@@ -464,0 +503,1 @@\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -474,4 +514,9 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always the same.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two float-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataF and dataF_2 do not alias -> full vectorization.\n+            \/\/       multiversion_slow loop can still vectorize, but only with 2 elements.\n+            \/\/ Note: at runtime the float-arrays are always the same -> predicate fails -> multiversioning.\n@@ -511,2 +556,10 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n@@ -515,1 +568,3 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -523,4 +578,8 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always different.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two int-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataI and dataI_2 do not alias -> full vectorization.\n+            \/\/ Note: at runtime the int-arrays are always different -> predicate suffices, no multiversioning.\n@@ -537,2 +596,11 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \">0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n@@ -542,0 +610,1 @@\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -549,4 +618,9 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always the same.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two int-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataF and dataF_2 do not alias -> full vectorization.\n+            \/\/       multiversion_slow loop can still vectorize, but only with 2 elements.\n+            \/\/ Note: at runtime the int-arrays are always the same -> predicate fails -> multiversioning.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCyclicDependency.java","additions":123,"deletions":49,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vanilla-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vanilla-A\n@@ -39,1 +39,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vanilla-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vanilla-U\n@@ -51,1 +51,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v016-A\n@@ -63,1 +63,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v016-U\n@@ -75,1 +75,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v008-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v008-A\n@@ -87,1 +87,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v008-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v008-U\n@@ -99,1 +99,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v004-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v004-A\n@@ -111,1 +111,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v004-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v004-U\n@@ -123,1 +123,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v032-A\n@@ -135,1 +135,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v032-U\n@@ -147,1 +147,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v016-A\n@@ -159,1 +159,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v016-U\n@@ -171,1 +171,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v032-A\n@@ -183,1 +183,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v032-U\n@@ -195,1 +195,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v016-A\n@@ -207,1 +207,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v016-U\n@@ -219,1 +219,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v064-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v064-A\n@@ -231,1 +231,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v064-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v064-U\n@@ -243,1 +243,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v032-A\n@@ -255,1 +255,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v032-U\n@@ -267,1 +267,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-A\n@@ -279,1 +279,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-U\n@@ -291,1 +291,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-A\n@@ -303,1 +303,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-U\n@@ -314,1 +314,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v064-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v064-A\n@@ -325,1 +325,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v064-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v064-U\n@@ -336,1 +336,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v032-A\n@@ -347,1 +347,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v032-U\n@@ -358,1 +358,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v016-A\n@@ -369,1 +369,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v016-U\n@@ -380,1 +380,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v008-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v008-A\n@@ -391,1 +391,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v008-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v008-U\n@@ -402,1 +402,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v004-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v004-A\n@@ -413,1 +413,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v004-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v004-U\n@@ -754,0 +754,2 @@\n+                \/\/ If we have two array references, then we can speculate that they do not alias, and\n+                \/\/ still produce full vectorization.\n@@ -758,1 +760,1 @@\n-                if (0 < byteOffset && byteOffset < maxVectorWidth) {\n+                if (isSingleArray && 0 < byteOffset && byteOffset < maxVectorWidth) {\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":37,"deletions":35,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run driver\/timeout=1200 compiler.loopopts.superword.TestEquivalentInvariants\n+ * @run driver\/timeout=4800 compiler.loopopts.superword.TestEquivalentInvariants\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-        applyIfAnd = {\"SuperWordReductions\", \"true\",\"UsePopCountInstruction\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"UsePopCountInstruction\", \"true\"},\n@@ -169,1 +169,1 @@\n-        applyIfAnd = {\"SuperWordReductions\", \"true\",\"UsePopCountInstruction\", \"true\"},\n+        applyIfAnd = {\"SuperWordReductions\", \"true\", \"UsePopCountInstruction\", \"true\", \"MaxVectorSize\", \">=32\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestGeneralizedReductions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,16 @@\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n@@ -66,0 +82,7 @@\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n@@ -163,0 +186,40 @@\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-NoShortRunningLongLoop\n+ * @bug 8329273 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n@@ -196,0 +259,4 @@\n+                case \"NoSpeculativeAliasingCheck\" -> framework.addFlags(\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\");\n+                \/\/ Disabling the ShortRunningLongLoop optimization changes the shape of the loop.\n+                \/\/ Testing both with and without it allows us to simulate long running loops with short running loops,\n+                \/\/ i.e. we don't need to allocate massive amounts of memory.\n@@ -197,0 +264,1 @@\n+                default ->                           throw new RuntimeException(\"Bad tag: \" + tag);\n@@ -199,3 +267,0 @@\n-        if (args.length > 1 && args[1].equals(\"AlignVector\")) {\n-            framework.addFlags(\"-XX:+AlignVector\");\n-        }\n@@ -709,3 +774,5 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -723,3 +790,5 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -801,6 +870,0 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -810,1 +873,1 @@\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n+        applyIf = { \"AlignVector\", \"false\" },\n@@ -813,2 +876,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n@@ -826,6 +887,0 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -835,1 +890,1 @@\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n+        applyIf = { \"AlignVector\", \"false\" },\n@@ -838,2 +893,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":80,"deletions":27,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,914 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import jdk.test.lib.Utils;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test id=byte-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoAutoAlignment\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoAutoAlignment\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=char-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing CharArray\n+ *\/\n+\n+\/*\n+ * @test id=short-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ShortArray\n+ *\/\n+\n+\/*\n+ * @test id=int-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray\n+ *\/\n+\n+\/*\n+ * @test id=int-array-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=int-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoAutoAlignment\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoAutoAlignment\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=long-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray\n+ *\/\n+\n+\/*\n+ * @test id=long-array-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=long-array-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=long-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=float-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing FloatArray\n+ *\/\n+\n+\/*\n+ * @test id=double-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing DoubleArray\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteBuffer\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer-direct\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteBufferDirect\n+ *\/\n+\n+\/*\n+ * @test id=native\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n+public class TestMemorySegmentAliasing {\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMemorySegmentAliasingImpl.class);\n+        framework.addFlags(\"-DmemorySegmentProviderNameForTestVM=\" + args[0]);\n+        for (int i = 1; i < args.length; i++) {\n+            String tag = args[i];\n+            switch (tag) {\n+                case \"AlignVector\" ->                framework.addFlags(\"-XX:+AlignVector\");\n+                case \"NoSpeculativeAliasingCheck\" -> framework.addFlags(\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\");\n+                \/\/ automatic alignment has an impact on where the main-loop starts, and that affects init and limit\n+                \/\/ of the main loop.\n+                case \"NoAutoAlignment\" ->            framework.addFlags(\"-XX:SuperWordAutomaticAlignment=0\");\n+                \/\/ Disabling the ShortRunningLongLoop optimization changes the shape of the loop.\n+                \/\/ Testing both with and without it allows us to simulate long running loops with short running loops,\n+                \/\/ i.e. we don't need to allocate massive amounts of memory.\n+                case \"NoShortRunningLongLoop\" ->     framework.addFlags(\"-XX:-ShortRunningLongLoop\");\n+                default ->                           throw new RuntimeException(\"Bad tag: \" + tag);\n+            }\n+        }\n+        framework.setDefaultWarmup(100);\n+        framework.start();\n+    }\n+}\n+\n+class TestMemorySegmentAliasingImpl {\n+    static final int BACKING_SIZE = 1024 * 8;\n+    static final Random RANDOM = Utils.getRandomInstance();\n+\n+\n+    interface TestFunction {\n+        void run();\n+    }\n+\n+    interface MemorySegmentProvider {\n+        MemorySegment newMemorySegment();\n+    }\n+\n+    public static MemorySegmentProvider provider;\n+\n+    static {\n+        String providerName = System.getProperty(\"memorySegmentProviderNameForTestVM\");\n+        provider = switch (providerName) {\n+            case \"ByteArray\"        -> TestMemorySegmentAliasingImpl::newMemorySegmentOfByteArray;\n+            case \"CharArray\"        -> TestMemorySegmentAliasingImpl::newMemorySegmentOfCharArray;\n+            case \"ShortArray\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfShortArray;\n+            case \"IntArray\"         -> TestMemorySegmentAliasingImpl::newMemorySegmentOfIntArray;\n+            case \"LongArray\"        -> TestMemorySegmentAliasingImpl::newMemorySegmentOfLongArray;\n+            case \"FloatArray\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfFloatArray;\n+            case \"DoubleArray\"      -> TestMemorySegmentAliasingImpl::newMemorySegmentOfDoubleArray;\n+            case \"ByteBuffer\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfByteBuffer;\n+            case \"ByteBufferDirect\" -> TestMemorySegmentAliasingImpl::newMemorySegmentOfByteBufferDirect;\n+            case \"Native\"           -> TestMemorySegmentAliasingImpl::newMemorySegmentOfNative;\n+            case \"MixedArray\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfMixedArray;\n+            case \"MixedBuffer\"      -> TestMemorySegmentAliasingImpl::newMemorySegmentOfMixedBuffer;\n+            case \"Mixed\"            -> TestMemorySegmentAliasingImpl::newMemorySegmentOfMixed;\n+            default -> throw new RuntimeException(\"Test argument not recognized: \" + providerName);\n+        };\n+    }\n+\n+    \/\/ Map of goldTests\n+    public static Map<String, TestFunction> goldTests = new HashMap<>();\n+\n+    \/\/ Map of gold for the goldTests, the results from the first run before compilation\n+    public static Map<String, Object> golds = new HashMap<>();\n+\n+    \/\/ Map of referenceTests, i.e. tests that have a reference implementation that is run with the interpreter.\n+    \/\/ The TestFunction must run both the test and reference methods.\n+    public static Map<String, TestFunction> referenceTests = new HashMap<>();\n+\n+    \/\/ Original data.\n+    public static MemorySegment ORIG_A = fillRandom(newMemorySegment());\n+    public static MemorySegment ORIG_B = fillRandom(newMemorySegment());\n+    public static MemorySegment ORIG_C = fillRandom(newMemorySegment());\n+\n+    \/\/ The data we use in the tests. It is initialized from ORIG_* every time.\n+    public static MemorySegment A = newMemorySegment();\n+    public static MemorySegment B = newMemorySegment();\n+    public static MemorySegment C = newMemorySegment();\n+\n+    \/\/ Parallel to data above, but for use in reference methods.\n+    public static MemorySegment A_REFERENCE = newMemorySegment();\n+    public static MemorySegment B_REFERENCE = newMemorySegment();\n+    public static MemorySegment C_REFERENCE = newMemorySegment();\n+\n+    public TestMemorySegmentAliasingImpl () {\n+        \/\/ Add all goldTests to list\n+        goldTests.put(\"test_byte_incr_noaliasing\",     () -> test_byte_incr_noaliasing(A, B));\n+        goldTests.put(\"test_byte_incr_aliasing\",       () -> test_byte_incr_aliasing(A, A));\n+        goldTests.put(\"test_byte_incr_aliasing_fwd3\",  () -> {\n+            MemorySegment x = A.asSlice(0, BACKING_SIZE - 3);\n+            MemorySegment y = A.asSlice(3, BACKING_SIZE - 3);\n+            test_byte_incr_aliasing_fwd3(x, y);\n+        });\n+        goldTests.put(\"test_byte_incr_noaliasing_fwd128\",  () -> {\n+            MemorySegment x = A.asSlice(0,   BACKING_SIZE - 128);\n+            MemorySegment y = A.asSlice(120, BACKING_SIZE - 128);\n+            test_byte_incr_noaliasing_fwd128(x, y);\n+        });\n+\n+        goldTests.put(\"test_int_to_long_noaliasing\",   () -> test_int_to_long_noaliasing(A, B));\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            init();\n+            test.run();\n+            Object gold = snapshotCopy();\n+            golds.put(name, gold);\n+        }\n+\n+        referenceTests.put(\"test_fill_byte_sameMS_alias\", () -> {\n+            int invar1 = RANDOM.nextInt(64);\n+            int invar2 = RANDOM.nextInt(64);\n+            test_fill_byte_sameMS_alias(A, A, invar1, invar2);\n+            reference_fill_byte_sameMS_alias(A_REFERENCE, A_REFERENCE, invar1, invar2);\n+        });\n+        referenceTests.put(\"test_fill_byte_sameMS_noalias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ But they never overlap.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle;\n+            int invar2 = middle;\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_byte_sameMS_noalias(A, A, invar1, invar2, limit);\n+            reference_fill_byte_sameMS_noalias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+        referenceTests.put(\"test_fill_byte_sameMS_maybeAlias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ In the middle, sometimes we overlap and sometimes not.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle + RANDOM.nextInt(-256, 256);\n+            int invar2 = middle + RANDOM.nextInt(-256, 256);\n+            \/\/ Are the bounds safe? Assume extreme values:\n+            \/\/ invar1 = 8k\/2 + 256 + 256\n+            \/\/ limit = 8k\/3 + 256\n+            \/\/ invar1 + limit = 8k * 5\/6 + 3 * 256\n+            \/\/                = 8k * 5\/6 + 3\/4 * 1k = 7.41k < 8k\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_byte_sameMS_maybeAlias(A, A, invar1, invar2, limit);\n+            reference_fill_byte_sameMS_maybeAlias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+        referenceTests.put(\"test_fill_int_sameMS_alias\", () -> {\n+            int invar1 = RANDOM.nextInt(64);\n+            int invar2 = RANDOM.nextInt(64);\n+            test_fill_int_sameMS_alias(A, A, invar1, invar2);\n+            reference_fill_int_sameMS_alias(A_REFERENCE, A_REFERENCE, invar1, invar2);\n+        });\n+        referenceTests.put(\"test_fill_int_sameMS_noalias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ But they never overlap.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle;\n+            int invar2 = middle;\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_int_sameMS_noalias(A, A, invar1, invar2, limit);\n+            reference_fill_int_sameMS_noalias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+        referenceTests.put(\"test_fill_int_sameMS_maybeAlias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ In the middle, sometimes we overlap and sometimes not.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle + RANDOM.nextInt(-256, 256);\n+            int invar2 = middle + RANDOM.nextInt(-256, 256);\n+            \/\/ Are the bounds safe? Assume extreme values:\n+            \/\/ invar1 = 8k\/2 + 256 + 256\n+            \/\/ limit = 8k\/3 + 256\n+            \/\/ invar1 + limit = 8k * 5\/6 + 3 * 256\n+            \/\/                = 8k * 5\/6 + 3\/4 * 1k = 7.41k < 8k\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_int_sameMS_maybeAlias(A, A, invar1, invar2, limit);\n+            reference_fill_int_sameMS_maybeAlias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+    }\n+\n+    static MemorySegment newMemorySegment() {\n+        return provider.newMemorySegment();\n+    }\n+\n+    static MemorySegment copy(MemorySegment src) {\n+        MemorySegment dst = newMemorySegment();\n+        dst.copyFrom(src);\n+        return dst;\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteArray() {\n+        return MemorySegment.ofArray(new byte[BACKING_SIZE]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfCharArray() {\n+        return MemorySegment.ofArray(new char[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfShortArray() {\n+        return MemorySegment.ofArray(new short[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfIntArray() {\n+        return MemorySegment.ofArray(new int[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfLongArray() {\n+        return MemorySegment.ofArray(new long[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfFloatArray() {\n+        return MemorySegment.ofArray(new float[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfDoubleArray() {\n+        return MemorySegment.ofArray(new double[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBuffer() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocate(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBufferDirect() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocateDirect(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfNative() {\n+        \/\/ Auto arena: GC decides when there is no reference to the MemorySegment,\n+        \/\/ and then it deallocates the backing memory.\n+        return Arena.ofAuto().allocate(BACKING_SIZE, 1);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedArray() {\n+        switch(RANDOM.nextInt(7)) {\n+            case 0  -> { return newMemorySegmentOfByteArray(); }\n+            case 1  -> { return newMemorySegmentOfCharArray(); }\n+            case 2  -> { return newMemorySegmentOfShortArray(); }\n+            case 3  -> { return newMemorySegmentOfIntArray(); }\n+            case 4  -> { return newMemorySegmentOfLongArray(); }\n+            case 5  -> { return newMemorySegmentOfFloatArray(); }\n+            default -> { return newMemorySegmentOfDoubleArray(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedBuffer() {\n+        switch (RANDOM.nextInt(2)) {\n+            case 0  -> { return newMemorySegmentOfByteBuffer(); }\n+            default -> { return newMemorySegmentOfByteBufferDirect(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixed() {\n+        switch (RANDOM.nextInt(3)) {\n+            case 0  -> { return newMemorySegmentOfMixedArray(); }\n+            case 1  -> { return newMemorySegmentOfMixedBuffer(); }\n+            default -> { return newMemorySegmentOfNative(); }\n+        }\n+    }\n+\n+    static MemorySegment fillRandom(MemorySegment data) {\n+        for (int i = 0; i < (int)data.byteSize(); i += 8) {\n+            data.set(ValueLayout.JAVA_LONG_UNALIGNED, i, RANDOM.nextLong());\n+        }\n+        return data;\n+    }\n+\n+    public static void init() {\n+        A.copyFrom(ORIG_A);\n+        B.copyFrom(ORIG_B);\n+        C.copyFrom(ORIG_C);\n+    }\n+\n+    public static void initReference() {\n+        A_REFERENCE.copyFrom(ORIG_A);\n+        B_REFERENCE.copyFrom(ORIG_B);\n+        C_REFERENCE.copyFrom(ORIG_C);\n+    }\n+\n+    public static Object snapshotCopy() {\n+        return new Object[]{copy(A), copy(B), copy(C)};\n+    }\n+\n+    public static Object snapshot() {\n+        return new Object[]{A, B, C};\n+    }\n+\n+    public static Object snapshotReference() {\n+        return new Object[]{A_REFERENCE, B_REFERENCE, C_REFERENCE};\n+    }\n+\n+    @Run(test = {\"test_byte_incr_noaliasing\",\n+                 \"test_byte_incr_aliasing\",\n+                 \"test_byte_incr_aliasing_fwd3\",\n+                 \"test_byte_incr_noaliasing_fwd128\",\n+                 \"test_int_to_long_noaliasing\",\n+                 \"test_fill_byte_sameMS_alias\",\n+                 \"test_fill_byte_sameMS_noalias\",\n+                 \"test_fill_byte_sameMS_maybeAlias\",\n+                 \"test_fill_int_sameMS_alias\",\n+                 \"test_fill_int_sameMS_noalias\",\n+                 \"test_fill_int_sameMS_maybeAlias\"})\n+    void runTests(RunInfo info) {\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object gold = golds.get(name);\n+            \/\/ Compute new result\n+            init();\n+            test.run();\n+            Object result = snapshot();\n+            \/\/ Compare gold and new result\n+            try {\n+                Verify.checkEQ(gold, result);\n+            } catch (VerifyException e) {\n+                throw new RuntimeException(\"Verify failed for \" + name, e);\n+            }\n+        }\n+\n+        \/\/ Once warmup is over (100x), repeat 10x to get reasonable coverage of the\n+        \/\/ randomness in the tests.\n+        int reps = info.isWarmUp() ? 10 : 1;\n+        for (int r = 0; r < reps; r++) {\n+            for (Map.Entry<String,TestFunction> entry : referenceTests.entrySet()) {\n+                String name = entry.getKey();\n+                TestFunction test = entry.getValue();\n+                \/\/ Init data for test and reference\n+                init();\n+                initReference();\n+                \/\/ Run test and reference\n+                test.run();\n+                \/\/ Capture results from test and reference\n+                Object result = snapshot();\n+                Object expected = snapshotReference();\n+                \/\/ Compare expected and new result\n+                try {\n+                    Verify.checkEQ(expected, result);\n+                } catch (VerifyException e) {\n+                    throw new RuntimeException(\"Verify failed for \" + name, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_noaliasing(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_aliasing(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_aliasing_fwd3(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_noaliasing_fwd128(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_I2L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,                                                   \"> 0\",\n+                  \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ In this case, the limit is pre-loop independent, but its assigned\n+    \/\/ ctrl sits between main and pre loop. Only the early ctrl is before\n+    \/\/ the pre loop.\n+    static void test_int_to_long_noaliasing(MemorySegment a, MemorySegment b) {\n+        long limit = a.byteSize() \/ 8L;\n+        for (long i = 0; i < limit; i++) {\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * i);\n+            b.set(ValueLayout.JAVA_LONG_UNALIGNED, 8L * i, v);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    static void test_fill_byte_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, i + invar1, (byte)0x0a);\n+            b.set(ValueLayout.JAVA_BYTE, a.byteSize() - i - 1 - invar2, (byte)0x0b);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_byte_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, i + invar1, (byte)0x0a);\n+            b.set(ValueLayout.JAVA_BYTE, a.byteSize() - i - 1 - invar2, (byte)0x0b);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ For now, we just assert that there is never multiversioning, which holds with or without vectorization:\n+    @IR(counts = {\".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_fill_byte_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_byte_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ Note: we may or may not use multiversioning, depending if we alias or not at runtime.\n+    static void test_fill_byte_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_byte_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    static void test_fill_int_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, i + invar1, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, a.byteSize() - i - 4 - invar2, 0x11121314);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_int_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, i + invar1, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, a.byteSize() - i - 4 - invar2, 0x11121314);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ For now, we just assert that there is never multiversioning, which holds with or without vectorization:\n+    @IR(counts = {\".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_fill_int_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_int_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ Note: we may or may not use multiversioning, depending if we alias or not at runtime.\n+    static void test_fill_int_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_int_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentAliasing.java","additions":914,"deletions":0,"binary":false,"changes":914,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Scenario;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+\/*\n+ * @test\n+ * @bug 8356176\n+ * @summary Test vectorization of loops over MemorySegment with unaligned access\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentByteSizeLongLoopLimit\n+ *\/\n+\n+\n+public class TestMemorySegmentByteSizeLongLoopLimit {\n+    public static int SIZE = 10_000;\n+\n+    public static int[] a = new int[SIZE];\n+    public static long[] b = new long[SIZE];\n+\n+    public static MemorySegment msA = MemorySegment.ofArray(a);\n+    public static MemorySegment msB = MemorySegment.ofArray(b);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\",        \"> 0\",\n+                  IRNode.STORE_VECTOR,                          \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    public static void test() {\n+        for (long i = 0; i < msA.byteSize() \/ 8L; i++) {\n+            int v = msA.get(ValueLayout.JAVA_INT_UNALIGNED, i * 4L);\n+            msB.set(ValueLayout.JAVA_LONG_UNALIGNED, i * 8L, v + 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentByteSizeLongLoopLimit.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test\n+ * @bug 8356176\n+ * @summary Test vectorization of loops over MemorySegment stored in field\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentField\n+ *\/\n+\n+public class TestMemorySegmentField {\n+    static int SIZE = 10_000;\n+    static MemorySegment MS = Arena.ofAuto().allocate(SIZE * 4);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    static int zeroInvarI = 0;\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    public static void testFields() {\n+        int invar = zeroInvarI;\n+        for (long i = 0; i < MS.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = MS.get(ValueLayout.JAVA_BYTE, adr);\n+            MS.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentField.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8359688: C2 SuperWord: missing RCE with MemorySegment\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8359688\n+ *\/\n+\n+\n+public class TestMemorySegment_8359688 {\n+\n+    public static MemorySegment b = MemorySegment.ofArray(new long[4 * 30_000]);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { b, 0, 5_000, 0 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n+                  IRNode.REPLICATE_L,  \"= 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Does not manage to remove all RangeChecks -> no vectorization\n+    \/\/ If you see this IR rule fail: investigate JDK-8359688, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test1(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 30_000L - (long)i + (long)invar, 42);\n+            \/\/                                                    ^ subtraction here\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_L,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Is fully RFE'd and vectorized\n+    public static void test2(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 1_000L + 1L * i + (long)invar, 42);\n+            \/\/                                                   ^ addition here\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8359688.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8360204: C2 SuperWord: missing RCE with MemorySegment.getAtIndex\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8360204\n+ *\/\n+\n+public class TestMemorySegment_8360204 {\n+\n+    public static MemorySegment a = Arena.ofAuto().allocate(10_000);\n+    public static MemorySegment b = Arena.ofAuto().allocate(10_000);\n+\n+    private static long invar0_1159 = 0;\n+    private static long invar1_1159 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -19125L, b, 71734L + 2_000L, 0, 1_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ Sadly, we now multiversion\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ There is no aliasing, so we should compile without multiversioning.\n+    \/\/ But currently, there seems to be some issue with RCE, we peel and lose the predicate.\n+    \/\/ Then we multiversion.\n+    \/\/ We could imagine that this would eventually vectorize, but since one counts up, and the other down,\n+    \/\/ we would have to implement shuffle first.\n+    \/\/\n+    \/\/ If you see this IR rule fail: investigate JDK-8360204, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivLo; i < ivHi; i+=1) {\n+            var v = container_0.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED, 19125L + 1L * i + 1L * invar0_0 + 0L * invar0_1159 + 1L * invar1_1159);\n+            container_1.setAtIndex(ValueLayout.JAVA_INT_UNALIGNED, -71734L + -1L * i + 1L * invar0_1 + 1L * invar0_1159 + 0L * invar1_1159, v);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8360204.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8365982: C2 SuperWord: missing RCE \/ strange Multiversioning with MemorySegment.set\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8365982\n+ *\/\n+\n+public class TestMemorySegment_8365982 {\n+\n+    public static MemorySegment a = MemorySegment.ofArray(new short[100_000]);\n+    public static MemorySegment b = MemorySegment.ofArray(new short[100_000]);\n+\n+    private static long invar0_853 = 0;\n+    private static long invar1_853 = 0;\n+    private static long invar2_853 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -50_000, b, -30_000, 0, 10_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ Good: The AutoVectorization predicate suffices.\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"> 0\"}, \/\/ Bad: Sadly, we now multiversion\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some but not all predicates are RCE'd at the beginning. After unrolling, we multiversion (why?).\n+    \/\/ After PreMainPost, we can do more RangeCheck. Now the main-loop of the multiversion_fast loop\n+    \/\/ does not have any range checks any more.\n+    \/\/ Now it vectorizes. That's good, but we should be able to vectorize without multiversioning.\n+    \/\/\n+    \/\/ If you see this IR rule fail: investigate JDK-8365982, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivHi-1; i >= ivLo; i-=1) {\n+            container_0.set(ValueLayout.JAVA_CHAR_UNALIGNED, -47143L + -2L * i + -2L * invar0_0 + -1L * invar0_853 + -1L * invar1_853 + 0L * invar2_853, (char)0x0102030405060708L);\n+            container_1.set(ValueLayout.JAVA_CHAR_UNALIGNED, 74770L + 2L * i + 2L * invar0_1 + 0L * invar0_853 + 0L * invar1_853 + 0L * invar2_853, (char)0x1112131415161718L);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8365982.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -32,6 +32,7 @@\n- * @run main\/othervm -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestMovingLoadBeforeStore::test*\n- *                   --add-modules java.base --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n- *                   -Xbatch\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressLCM\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=100\n- *                   compiler.loopopts.superword.TestMovingLoadBeforeStore\n+ * @run main\/othervm\/timeout=480\n+ *   -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestMovingLoadBeforeStore::test*\n+ *   --add-modules java.base --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UnlockDiagnosticVMOptions -XX:+StressLCM\n+ *   -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=100\n+ *   compiler.loopopts.superword.TestMovingLoadBeforeStore\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMovingLoadBeforeStore.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366845\n+ * @summary Test Reinterpret with Cast cases, where the order of the src\/dst types of Reinterpret matters.\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestReinterpretAndCast\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.incubator.vector.Float16;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.generators.*;\n+\n+public class TestReinterpretAndCast {\n+    static int SIZE = 1028 * 8;\n+\n+    public static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n+    public static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n+    private static final Generator<Short> GEN_FLOAT16 = Generators.G.float16s();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    static long[] fillWithDoubles(long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Double.doubleToLongBits(GEN_DOUBLE.next());\n+        }\n+        return a;\n+    }\n+\n+    static int[] fillWithFloats(int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = Float.floatToIntBits(GEN_FLOAT.next());\n+        }\n+        return a;\n+    }\n+\n+    static short[] fillWithFloat16s(short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = GEN_FLOAT16.next();\n+        }\n+        return a;\n+    }\n+\n+    static void verify(long[] a, long[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Make sure we remove non-canonical NaN's.\n+            long aa = Double.doubleToLongBits(Double.longBitsToDouble(a[i]));\n+            long bb = Double.doubleToLongBits(Double.longBitsToDouble(b[i]));\n+            if (aa != bb) {\n+                throw new RuntimeException(\"Wrong value: \" + aa + \" vs \" + bb + \" - \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Make sure we remove non-canonical NaN's.\n+            int aa = Float.floatToIntBits(Float.intBitsToFloat(a[i]));\n+            int bb = Float.floatToIntBits(Float.intBitsToFloat(b[i]));\n+            if (aa != bb) {\n+                throw new RuntimeException(\"Wrong value: \" + aa + \" vs \" + bb + \" - \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(short[] a, short[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Make sure we remove non-canonical NaN's.\n+            int aa = Float.floatToIntBits(Float16.shortBitsToFloat16(a[i]).floatValue());\n+            int bb = Float.floatToIntBits(Float16.shortBitsToFloat16(b[i]).floatValue());\n+            if (aa != bb) {\n+                throw new RuntimeException(\"Wrong value: \" + aa + \" vs \" + bb + \" - \" + a[i] + \" vs \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ -------------- test1\n+    public static long[] test1_in   = fillWithDoubles(new long[SIZE]);\n+    public static int[]  test1_gold = new int[SIZE];\n+    public static int[]  test1_test = new int[SIZE];\n+\n+    \/\/ Esecute in interpreter, to compare to compiled results later.\n+    static { test1(test1_in, test1_gold); }\n+\n+    @Setup\n+    public static Object[] setup1() {\n+        return new Object[] {test1_in, test1_test};\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup1\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_L,   IRNode.VECTOR_SIZE + \"min(max_int, max_float, max_double, max_long)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_D2F, IRNode.VECTOR_SIZE + \"min(max_int, max_float, max_double, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,       \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"}, \/\/ We have both L2D and F2I\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test1(long[] a, int[] b) {\n+        for (int i = 0; i < SIZE; i++) {\n+            long   v0 = a[i];\n+            double v1 = Double.longBitsToDouble(v0);\n+            \/\/ Reinterpret: long -> double\n+            \/\/ Before fix:  double -> long (no direct problem)\n+            float  v2 = (float)v1;\n+            \/\/ Cast:        double -> float\n+            \/\/ Before fix:  long -> float  (wrong!)\n+            int    v3 = Float.floatToRawIntBits(v2);\n+            b[i] = v3;\n+        }\n+    }\n+\n+    @Check(test = \"test1\")\n+    public static void check1() {\n+        verify(test1_test, test1_gold);\n+    }\n+\n+    \/\/ -------------- test2\n+    public static int[]   test2_in   = fillWithFloats(new int[SIZE]);\n+    public static short[] test2_gold = new short[SIZE];\n+    public static short[] test2_test = new short[SIZE];\n+\n+    \/\/ Esecute in interpreter, to compare to compiled results later.\n+    static { test2(test2_in, test2_gold); }\n+\n+    @Setup\n+    public static Object[] setup2() {\n+        return new Object[] {test2_in, test2_test};\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup2\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,    IRNode.VECTOR_SIZE + \"min(max_int, max_float, max_short)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE + \"min(max_int, max_float, max_short)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,       \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"}, \/\/ We have at least I2F\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test2(int[] a, short[] b) {\n+        for (int i = 0; i < SIZE; i++) {\n+            int v0 = a[i];\n+            float v1 = Float.intBitsToFloat(v0);\n+            \/\/ Reinterpret: int -> float\n+            \/\/ Before fix:  float -> int (no direct problem)\n+            short v2 = Float.floatToFloat16(v1);\n+            \/\/ Cast:        float -> float16\/short\n+            \/\/ Before fix:  int ->   float16\/short (wrong!)\n+            b[i] = v2;\n+        }\n+    }\n+\n+    @Check(test = \"test2\")\n+    public static void check2() {\n+        verify(test2_test, test2_gold);\n+    }\n+\n+    \/\/ -------------- test3\n+    public static short[] test3_in   = fillWithFloat16s(new short[SIZE]);\n+    public static long[]  test3_gold = new long[SIZE];\n+    public static long[]  test3_test = new long[SIZE];\n+\n+    \/\/ Esecute in interpreter, to compare to compiled results later.\n+    static { test3(test3_in, test3_gold); }\n+\n+    @Setup\n+    public static Object[] setup3() {\n+        return new Object[] {test3_in, test3_test};\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup3\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_S,    IRNode.VECTOR_SIZE + \"min(max_float, max_short, max_long)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE + \"min(max_float, max_short, max_long)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_I2L,  IRNode.VECTOR_SIZE + \"min(max_float, max_short, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,       \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"}, \/\/ We have at least F2I\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test3(short[] a, long[] b) {\n+        for (int i = 0; i < SIZE; i++) {\n+            short v0 = a[i];\n+            Float16 v1 = Float16.shortBitsToFloat16(v0);\n+            float v2 = v1.floatValue();\n+            int v3 = Float.floatToRawIntBits(v2);\n+            \/\/ Reinterpret: float -> int\n+            \/\/ Before fix:  int -> float\n+            long v4 = v3;\n+            \/\/ Cast:        int -> long\n+            \/\/ Before fix:  float -> long (wrong!)\n+            b[i] = v4;\n+        }\n+    }\n+\n+    @Check(test = \"test3\")\n+    public static void check3() {\n+        verify(test3_test, test3_gold);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestReinterpretAndCast.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -40,4 +40,8 @@\n- * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV\n- * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV\n- * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV\n- * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV_nSAC\n@@ -79,4 +83,8 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n@@ -117,0 +125,7 @@\n+        tests.put(\"test4a_alias\",() -> { short[] x = aS.clone(); return test4a_alias(x, x); });\n+        tests.put(\"test4b_alias\",() -> { short[] x = aS.clone(); return test4b_alias(x, x); });\n+        tests.put(\"test4c_alias\",() -> { short[] x = aS.clone(); return test4c_alias(x, x); });\n+        tests.put(\"test4d_alias\",() -> { short[] x = aS.clone(); return test4d_alias(x, x); });\n+        tests.put(\"test4e_alias\",() -> { short[] x = aS.clone(); return test4e_alias(x, x); });\n+        tests.put(\"test4f_alias\",() -> { short[] x = aS.clone(); return test4f_alias(x, x); });\n+        tests.put(\"test4g_alias\",() -> { short[] x = aS.clone(); return test4g_alias(x, x); });\n@@ -148,0 +163,7 @@\n+                 \"test4a_alias\",\n+                 \"test4b_alias\",\n+                 \"test4c_alias\",\n+                 \"test4d_alias\",\n+                 \"test4e_alias\",\n+                 \"test4f_alias\",\n+                 \"test4g_alias\",\n@@ -714,1 +736,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -718,0 +743,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -727,2 +760,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -732,0 +767,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -741,2 +784,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \">=8\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -746,0 +791,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -755,2 +808,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -760,0 +815,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -769,2 +832,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -774,0 +839,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -783,2 +856,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -788,0 +863,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -797,2 +880,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -802,0 +887,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -809,0 +902,175 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Cyclic dependency with distance 2 -> split into 2-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4a_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+2] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Cyclic dependency with distance 3 -> split into 2-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4b_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+3] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 4 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4c_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+4] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 5 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4d_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+5] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 6 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4e_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+6] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 7 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4f_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+7] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 8 -> split into 8-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4g_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+8] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":289,"deletions":21,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver compiler.loopstripmining.CheckLoopStripMining\n+ * @run driver\/timeout=480 compiler.loopstripmining.CheckLoopStripMining\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/CheckLoopStripMining.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int StringCodingEncodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n+        return StringCoding.encodeAsciiArray0(sa, sp, da, dp, len);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xbatch -XX:-UseOnStackReplacement -XX:+IgnoreUnrecognizedVMOptions -XX:MaxTrivialSize=0 -XX:C1MaxTrivialSize=0 compiler.profiling.TestProfileCounterOverflow\n+ * @run main\/othervm\/timeout=480 -Xbatch -XX:-UseOnStackReplacement -XX:+IgnoreUnrecognizedVMOptions -XX:MaxTrivialSize=0 -XX:C1MaxTrivialSize=0 compiler.profiling.TestProfileCounterOverflow\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/TestProfileCounterOverflow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,4 @@\n- * @run main\/othervm -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n- *                   -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n- *                   -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n- *                   compiler.profiling.spectrapredefineclass.Agent\n+ * @run main\/othervm\/timeout=480 -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n+ *                               -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n+ *                               -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n+ *                               compiler.profiling.spectrapredefineclass.Agent\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass\/Launcher.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,4 @@\n- * @run main\/othervm -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n- *                   -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n- *                   -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n- *                   compiler.profiling.spectrapredefineclass_classloaders.Agent\n+ * @run main\/othervm\/timeout=480 -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n+ *                               -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n+ *                               -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n+ *                               compiler.profiling.spectrapredefineclass_classloaders.Agent\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass_classloaders\/Launcher.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.test.lib.Platform;\n@@ -63,0 +64,3 @@\n+        \/\/ On s390x, generated code is ~6x larger in fastdebug and ~1.4x in release builds vs. other archs,\n+        \/\/ hence we require slightly more minimum space.\n+        int minInitialSize = 800 + (Platform.isS390x() ? 800 : 0);\n@@ -64,1 +68,1 @@\n-            int initialCodeCacheSizeInKb = 800 + rand.nextInt(400);\n+            int initialCodeCacheSizeInKb = minInitialSize + rand.nextInt(400);\n","filename":"test\/hotspot\/jtreg\/compiler\/startup\/StartupOutput.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+TieredCompilation\n+ * @run main\/othervm\/timeout=960 -Xbootclasspath\/a:. -XX:+TieredCompilation\n@@ -104,1 +104,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/tiered\/Level2RecompilationTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n+ * @run main\/othervm\/timeout=480 -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n@@ -41,1 +41,1 @@\n- * @run main\/othervm -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n+ * @run main\/othervm\/timeout=480 -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestDeoptOOM.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n- * @run main\/othervm -XX:-TieredCompilation -Xbatch\n+ * @run main\/othervm\/timeout=480\n+ *                   -XX:-TieredCompilation -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestRawOopAtSafepoint.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,1 +39,6 @@\n- * @run testng\/othervm -XX:UseSVE=0 -XX:-TieredCompilation -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:CompileCommand=MemLimit,*.*,0 compiler.vectorapi.VectorReplicateLongSpecialImmTest\n+ * @run testng\/othervm -XX:UseSVE=0 -XX:-TieredCompilation\n+ *                     -XX:CompileThreshold=100\n+ *                     -XX:+IgnoreUnrecognizedVMOptions\n+ *                     -XX:CompileCommand=MemLimit,*.*,0\n+ *                     -XX:CompileTaskTimeout=0\n+ *                     compiler.vectorapi.VectorReplicateLongSpecialImmTest\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorReplicateLongSpecialImmTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-* @run driver compiler.vectorization.TestFloat16VectorOperations\n+* @run driver\/timeout=480 compiler.vectorization.TestFloat16VectorOperations\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,4 +30,1 @@\n- * @run driver compiler.vectorization.TestFloatConversionsVector nCOH_nAV\n- * @run driver compiler.vectorization.TestFloatConversionsVector nCOH_yAV\n- * @run driver compiler.vectorization.TestFloatConversionsVector yCOH_nAV\n- * @run driver compiler.vectorization.TestFloatConversionsVector yCOH_yAV\n+ * @run driver compiler.vectorization.TestFloatConversionsVector\n@@ -38,0 +35,2 @@\n+import java.util.Set;\n+\n@@ -52,7 +51,2 @@\n-        switch (args[0]) {\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n-        };\n+        framework.addCrossProductScenarios(Set.of(\"-XX:-UseCompactObjectHeaders\", \"-XX:+UseCompactObjectHeaders\"),\n+                                           Set.of(\"-XX:-AlignVector\", \"-XX:+AlignVector\"));\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -40,0 +41,1 @@\n+import java.util.Random;\n@@ -43,0 +45,1 @@\n+import jdk.test.lib.Utils;\n@@ -82,0 +85,1 @@\n+        Random rand = Utils.getRandomInstance();\n@@ -88,2 +92,3 @@\n-            if (i%39 == 0) {\n-                int x = 0x7f800000 + ((i\/39) << 13);\n+            if (i%3 == 0) {\n+                int shift = rand.nextInt(13+1);\n+                int x = 0x7f800000 + ((i\/39) << shift);\n@@ -131,1 +136,2 @@\n-        String msg = \"floatToFloat16 wrong result: idx: \" + idx + \", \\t\" + f +\n+        String msg = \"floatToFloat16 wrong result: idx: \" + idx +\n+                     \", \\t\" + f + \", hex: \" + Integer.toHexString(Float.floatToRawIntBits(f)) +\n@@ -170,1 +176,1 @@\n-            if (i%39 == 0) {\n+            if (i%3 == 0) {\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVectorNaN.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm compiler.vectorization.TestVectorZeroCount\n+ * @run main\/othervm\/timeout=480 compiler.vectorization.TestVectorZeroCount\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorZeroCount.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    \/\/ The ConvI2L can be split through the AddI, creating a mix of\n+    \/\/ The ConvI2L can be pushed through the AddI, creating a mix of\n@@ -135,2 +135,1 @@\n-        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n-    \/\/ See: JDK-8332878\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -158,2 +157,1 @@\n-        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n-    \/\/ See: JDK-8332878\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,4 +34,12 @@\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *                   -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI\n- *                   compiler.vectorization.runner.LoopArrayIndexComputeTest\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest nAV_ySAC\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest yAV_ySAC\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest nAV_nSAC\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest yAV_nSAC\n@@ -51,0 +59,12 @@\n+    \/\/ We must pass the flags directly to the test-VM, and not the driver vm in the @run above.\n+    @Override\n+    protected String[] testVMFlags(String[] args) {\n+        return switch (args[0]) {\n+            case \"nAV_ySAC\" -> new String[]{\"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            case \"yAV_ySAC\" -> new String[]{\"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            case \"nAV_nSAC\" -> new String[]{\"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            case \"yAV_nSAC\" -> new String[]{\"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+    }\n+\n@@ -178,1 +198,10 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+     \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -189,1 +218,10 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -279,1 +317,11 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.MUL_VS, \">0\",\n+                  IRNode.LOAD_VECTOR_S, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -307,0 +355,2 @@\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -308,1 +358,2 @@\n-                  IRNode.MUL_VS, IRNode.VECTOR_SIZE_2, \">0\"}) \/\/ size 2 only\n+                  IRNode.MUL_VS, IRNode.VECTOR_SIZE_2, \">0\", \/\/ size 2 only\n+                  \".*multiversion.*\", \"= 0\"})\n@@ -335,1 +386,11 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.ADD_VB, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -340,1 +401,1 @@\n-            res[i] *= bytes[i - 3];\n+            res[i] += bytes[i - 3];\n@@ -362,0 +423,9 @@\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.OR_VB, IRNode.VECTOR_SIZE_4, \">0\", \/\/ size 4 only\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -363,1 +433,3 @@\n-                  IRNode.OR_VB, IRNode.VECTOR_SIZE_4, \">0\"}) \/\/ size 4 only\n+                  IRNode.OR_VB, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -389,1 +461,10 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":93,"deletions":12,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @summary Run tests with G1\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.G1\n+ * @run driver TestTransparentHugePagesHeap G1\n+*\/\n+\/*\n+ * @test id=Parallel\n+ * @summary Run tests with Parallel\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.Parallel\n+ * @run driver TestTransparentHugePagesHeap Parallel\n+*\/\n+\/*\n+ * @test id=Serial\n+ * @summary Run tests with Serial\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.Serial\n+ * @run driver TestTransparentHugePagesHeap Serial\n+*\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.Scanner;\n+\n+import jdk.test.lib.os.linux.HugePageConfiguration;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Platform;\n+\n+import jtreg.SkippedException;\n+\n+\/\/ We verify that the heap can be backed by THP by looking at the\n+\/\/ THPeligible field for the heap section in \/proc\/self\/smaps. This\n+\/\/ field indicates if a mapping can use THP.\n+\/\/ THP mode 'always': this field is 1 whenever huge pages can be used\n+\/\/ THP mode 'madvise': this field is 1 if the mapping has been madvised\n+\/\/ as MADV_HUGEPAGE. In the JVM that should happen when the flag\n+\/\/ -XX:+UseTransparentHugePages is specified.\n+\/\/\n+\/\/ Note: we don't verify if the heap is backed by huge pages because we\n+\/\/ can't know if the underlying system have any available.\n+public class TestTransparentHugePagesHeap {\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ To be able to detect large page use (esp. THP) somewhat reliably, we\n+        \/\/  need at least kernel 3.8 to get the \"VmFlags\" tag in smaps.\n+        \/\/ (Note: its still good we started the VM at least since this serves as a nice\n+        \/\/  test for all manners of large page options).\n+        if (Platform.getOsVersionMajor() < 3 ||\n+            (Platform.getOsVersionMajor() == 3 && Platform.getOsVersionMinor() < 8)) {\n+            throw new SkippedException(\"Kernel older than 3.8 - skipping this test.\");\n+        }\n+\n+        final HugePageConfiguration hugePageConfiguration = HugePageConfiguration.readFromOS();\n+        if (!hugePageConfiguration.supportsTHP()) {\n+            throw new SkippedException(\"THP is turned off\");\n+        }\n+\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\"-XX:+Use\" + args[0] + \"GC\", \"-Xmx128m\", \"-Xms128m\", \"-Xlog:pagesize:thp-%p.log\", \"-XX:+UseTransparentHugePages\", VerifyTHPEnabledForHeap.class.getName());\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    class VerifyTHPEnabledForHeap {\n+\n+        public static void main(String args[]) throws Exception {\n+            String heapAddress = readHeapAddressInLog();\n+            Path smaps = makeSmapsCopy();\n+\n+            final Pattern heapSection = Pattern.compile(\"^\" + heapAddress + \".*\");\n+            final Pattern thpEligible = Pattern.compile(\"THPeligible:\\\\s+(\\\\d)\\\\s*\");\n+\n+            Scanner smapsFile = new Scanner(smaps);\n+            while (smapsFile.hasNextLine()) {\n+                Matcher heapMatcher = heapSection.matcher(smapsFile.nextLine());\n+\n+                if (heapMatcher.matches()) {\n+                    \/\/ Found the first heap section, verify that it is THP eligible\n+                    while (smapsFile.hasNextLine()) {\n+                        Matcher m = thpEligible.matcher(smapsFile.nextLine());\n+                        if (m.matches()) {\n+                            if (Integer.parseInt(m.group(1)) == 1) {\n+                                \/\/ THPeligible is 1, heap can be backed by huge pages\n+                                return;\n+                            }\n+\n+                            throw new RuntimeException(\"First heap section at 0x\" + heapAddress + \" is not THPeligible\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ Failed to verify THP for heap\n+            throw new RuntimeException(\"Could not find heap section in smaps file\");\n+        }\n+\n+        private static String readHeapAddressInLog() throws Exception {\n+            final Pattern heapAddress = Pattern.compile(\".* Heap: .*base=(0x[0-9A-Fa-f]*).*\");\n+\n+            Scanner logFile = new Scanner(Paths.get(\"thp-\" + ProcessHandle.current().pid() + \".log\"));\n+            while (logFile.hasNextLine()) {\n+                Matcher m = heapAddress.matcher(logFile.nextLine());\n+                if (m.matches()) {\n+                    return Long.toHexString(Long.decode(m.group(1)));\n+                }\n+            }\n+            throw new RuntimeException(\"Failed to parse heap address, failing test\");\n+        }\n+\n+        private static Path makeSmapsCopy() throws Exception {\n+            Path src = Paths.get(\"\/proc\/self\/smaps\");\n+            Path dest = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + \".txt\");\n+            Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);\n+            return dest;\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestTransparentHugePagesHeap.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,6 +50,1 @@\n-  private static void testMinMaxFreeRatio(String min, String max, Validation type) throws Exception {\n-    OutputAnalyzer output = GCArguments.executeTestJava(\n-        \"-Xminf\" + min,\n-        \"-Xmaxf\" + max,\n-        \"-version\");\n-\n+  private static void checkValidity(OutputAnalyzer output, String min, String max, Validation type) {\n@@ -62,1 +57,1 @@\n-      output.shouldContain(\"Bad min heap free percentage size: -Xminf\" + min);\n+      output.shouldContain(\"Bad min heap free ratio: -Xminf\" + min);\n@@ -67,1 +62,1 @@\n-      output.shouldContain(\"Bad max heap free percentage size: -Xmaxf\" + max);\n+      output.shouldContain(\"Bad max heap free ratio: -Xmaxf\" + max);\n@@ -77,1 +72,1 @@\n-      output.shouldContain(\"must be less than or equal to MaxHeapFreeRatio\");\n+      output.shouldMatch(\"must be (less|greater) than or equal to the implicit -Xm..f value\");\n@@ -88,0 +83,18 @@\n+  private static void testMinMaxFreeRatio_Reordered(String min, String max, Validation type) throws Exception {\n+    OutputAnalyzer output = GCArguments.executeTestJava(\n+        \"-Xmaxf\" + max,\n+        \"-Xminf\" + min,\n+        \"-version\");\n+\n+    checkValidity(output, min, max, type);\n+  }\n+\n+  private static void testMinMaxFreeRatio(String min, String max, Validation type) throws Exception {\n+    OutputAnalyzer output = GCArguments.executeTestJava(\n+        \"-Xminf\" + min,\n+        \"-Xmaxf\" + max,\n+        \"-version\");\n+\n+    checkValidity(output, min, max, type);\n+  }\n+\n@@ -89,3 +102,4 @@\n-    testMinMaxFreeRatio( \"0.1\", \"0.5\", Validation.VALID);\n-    testMinMaxFreeRatio(  \".1\",  \".5\", Validation.VALID);\n-    testMinMaxFreeRatio( \"0.5\", \"0.5\", Validation.VALID);\n+    testMinMaxFreeRatio( \"0.1\",  \"0.5\", Validation.VALID);\n+    testMinMaxFreeRatio(  \".1\",   \".5\", Validation.VALID);\n+    testMinMaxFreeRatio( \"0.5\",  \"0.5\", Validation.VALID);\n+    testMinMaxFreeRatio( \"0.0\",\"0.001\", Validation.VALID);\n@@ -106,1 +120,3 @@\n-                  \"2147483647\", \"0.5\", Validation.OUT_OF_RANGE);\n+                   \"2147483647\", \"0.5\", Validation.OUT_OF_RANGE);\n+    testMinMaxFreeRatio(\n+                  \"-2147483647\", \"0.5\", Validation.OUT_OF_RANGE);\n@@ -111,0 +127,15 @@\n+    testMinMaxFreeRatio(\n+                   \"0.1\", \"-2147483647\", Validation.OUT_OF_RANGE);\n+\n+    testMinMaxFreeRatio( \"0.5\",   \"0.1\", Validation.COMBINATION_INVALID);\n+    testMinMaxFreeRatio(  \".5\",   \".10\", Validation.COMBINATION_INVALID);\n+    testMinMaxFreeRatio(\"0.12\", \"0.100\", Validation.COMBINATION_INVALID);\n+\n+    \/\/ Default range is [0.40, 0.70]\n+    \/\/ setting minf to 0.80 violates minf < maxf\n+    testMinMaxFreeRatio(\"0.80\", \"0.90\", Validation.COMBINATION_INVALID);\n+\n+    \/\/ Options are re-ordered: -Xmaxf is given before -Xminf\n+\n+    \/\/ valid range, but acceptable only if maxf be set first\n+    testMinMaxFreeRatio_Reordered(\"0.80\", \"0.90\", Validation.VALID);\n@@ -112,3 +143,2 @@\n-    testMinMaxFreeRatio( \"0.5\",  \"0.1\", Validation.COMBINATION_INVALID);\n-    testMinMaxFreeRatio(  \".5\",  \".10\", Validation.COMBINATION_INVALID);\n-    testMinMaxFreeRatio(\"0.12\",\"0.100\", Validation.COMBINATION_INVALID);\n+    \/\/ although a valid range, but setting maxf first violates minf < maxf\n+    testMinMaxFreeRatio_Reordered(\"0.10\", \"0.30\", Validation.COMBINATION_INVALID);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestHeapFreeRatio.java","additions":47,"deletions":17,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires vm.opt.UseLargePages == null | !vm.opt.UseLargePages\n+ * @requires !vm.opt.final.UseLargePages\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestParallelGCErgo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main\/othervm -XX:+UseG1GC -Xss32m -Xmx128m -XX:G1HeapRegionSize=1m\n+ * @run main\/othervm\/timeout=480 -XX:+UseG1GC -Xss32m -Xmx128m -XX:G1HeapRegionSize=1m\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGreyReclaimedHumongousObjects.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm\/timeout=240  -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=960  -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -59,1 +59,1 @@\n- * @run main\/othervm -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -64,1 +64,1 @@\n- *@run main\/othervm -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *@run main\/othervm\/timeout=480 -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousClassLoader.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -59,1 +59,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -63,1 +63,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousNonArrayAllocation.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run driver\/timeout=480 gc.g1.ihop.TestIHOPErgo\n+ * @run driver\/timeout=1920 gc.g1.ihop.TestIHOPErgo\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/ihop\/TestIHOPErgo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -62,1 +62,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=480 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjects.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -106,1 +106,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=480 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/native\/timeout=240 -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/native\/timeout=240 -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/native\/timeout=240 -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -59,1 +59,1 @@\n- * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/native\/timeout=240 -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestJNIGlobalRefs.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm\/timeout=700 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=1200 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestMultiThreadStressRSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,4 @@\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory -XX:+UseSerialGC\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory -XX:+UseParallelGC\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory -XX:+UseG1GC\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseSerialGC\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseParallelGC\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseG1GC\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestReclaimStringsLeaksMemory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver\/timeout=180 gc.stress.TestStressG1Humongous 4 3 1.1 120\n+ * @run driver\/timeout=240 gc.stress.TestStressG1Humongous 4 3 1.1 120\n@@ -43,1 +43,1 @@\n- * @run driver\/timeout=180 gc.stress.TestStressG1Humongous 16 5 2.1 120\n+ * @run driver\/timeout=240 gc.stress.TestStressG1Humongous 16 5 2.1 120\n@@ -52,1 +52,1 @@\n- * @run driver\/timeout=180 gc.stress.TestStressG1Humongous 32 4 0.6 120\n+ * @run driver\/timeout=240 gc.stress.TestStressG1Humongous 32 4 0.6 120\n@@ -61,1 +61,1 @@\n- * @run driver\/timeout=900 gc.stress.TestStressG1Humongous 1 7 0.6 600\n+ * @run driver\/timeout=1200 gc.stress.TestStressG1Humongous 1 7 0.6 600\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressG1Humongous.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -71,1 +71,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -86,1 +86,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -101,1 +101,1 @@\n- * @run main\/othervm\/timeout=1800\n+ * @run main\/othervm\/timeout=7200\n@@ -116,1 +116,1 @@\n- * @run main\/othervm\/timeout=1800\n+ * @run main\/othervm\/timeout=7200\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressRSetCoarsening.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UseG1GC gc.stress.systemgc.TestSystemGCWithG1 270\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UseG1GC gc.stress.systemgc.TestSystemGCWithG1 270\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithG1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc=info -Xmx512m -XX:+UseParallelGC gc.stress.systemgc.TestSystemGCWithParallel 270\n+ * @run main\/othervm\/timeout=540 -Xlog:gc=info -Xmx512m -XX:+UseParallelGC gc.stress.systemgc.TestSystemGCWithParallel 270\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithParallel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UseSerialGC gc.stress.systemgc.TestSystemGCWithSerial 270\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UseSerialGC gc.stress.systemgc.TestSystemGCWithSerial 270\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithSerial.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n@@ -52,1 +52,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n@@ -57,1 +57,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithShenandoah.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/*\n+ * @test id=Normal\n+ * @requires vm.gc.Z & vm.debug\n+ * @summary Test ZGC graceful failure when a commit fails\n+ * @library \/ \/test\/lib\n+ * @run driver gc.z.TestCommitFailure\n+ *\/\n+\n+\/*\n+ * @test id=ZFakeNUMA\n+ * @requires vm.gc.Z & vm.debug\n+ * @library \/ \/test\/lib\n+ * @summary Test ZGC graceful failure when a commit fails (with ZFakeNUMA)\n+ * @run driver gc.z.TestCommitFailure -XX:ZFakeNUMA=16\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import static gc.testlibrary.Allocation.blackHole;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TestCommitFailure {\n+    static final int K = 1024;\n+    static final int M = 1024 * K;\n+\n+    static final int XMS = 128 * M;\n+    static final int XMX = 512 * M;\n+\n+    static class Test {\n+        static final int LARGE_ALLOC = 256 * M;\n+        static final int SMALL_GARBAGE = 256 * M;\n+        static final int SMALL_LIVE = 128 * M;\n+\n+        \/\/ Allocates at least totalLive bytes of objects and add them to list.\n+        static void allocLive(List<Object> list, int totalLive) {\n+            final int largePageAllocationSize = 6 * M;\n+            for (int live = 0; live < totalLive; live += largePageAllocationSize) {\n+                list.add(new byte[largePageAllocationSize - K]);\n+            }\n+        }\n+\n+        \/\/ Allocates at least totalGarbage bytes of garbage large pages.\n+        static void allocGarbage(int totalGarbage) {\n+            final int largePageAllocationSize = 6 * M;\n+            for (int garbage = 0; garbage < totalGarbage; garbage += largePageAllocationSize) {\n+                blackHole(new byte[largePageAllocationSize - K]);\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            final var list = new ArrayList<Object>();\n+            try {\n+                \/\/ Fill heap with small live objects\n+                allocLive(list, SMALL_LIVE);\n+                \/\/ Fill with small garbage objects\n+                allocGarbage(SMALL_GARBAGE);\n+                \/\/ Allocate large objects where commit fails until an OOME is thrown\n+                while (true) {\n+                    list.add(new byte[LARGE_ALLOC - K]);\n+                }\n+            } catch (OutOfMemoryError oome) {}\n+            blackHole(list);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        final int xmxInM = XMX \/ M;\n+        final int xmsInM = XMS \/ M;\n+        final var arguments = new ArrayList(Arrays.asList(args));\n+        arguments.addAll(List.of(\n+            \"-XX:+UseZGC\",\n+            \"-Xlog:gc+init\",\n+            \"-XX:ZFailLargerCommits=\" + XMS,\n+            \"-Xms\" + xmsInM + \"M\",\n+            \"-Xmx\" + xmxInM + \"M\",\n+            Test.class.getName()));\n+\n+        ProcessTools.executeTestJava(arguments)\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestCommitFailure.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+                \/\/ Disable NUMA to avoid potential OOM after JDK-8359683\n+                \"-XX:-UseNUMA\",\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestSmallHeap.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+UseZGC -Xlog:gc*,gc+heap=debug,gc+stats=off -Xms128M -Xmx512M -XX:ZUncommitDelay=5 gc.z.TestUncommit\n+ * @run main\/othervm\/timeout=480 -XX:+UseZGC -Xlog:gc*,gc+heap=debug,gc+stats=off -Xms128M -Xmx512M -XX:ZUncommitDelay=5 gc.z.TestUncommit\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestUncommit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/native GTestWrapper\n+ * @run main\/native\/timeout=480 GTestWrapper\n","filename":"test\/hotspot\/jtreg\/gtest\/GTestWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n- * @run driver TestInheritFD\n+ * @run driver\/timeout=480 TestInheritFD\n@@ -81,0 +81,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -93,2 +95,1 @@\n-    public static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    public static long subProcessTimeout = (long)(15L * timeoutFactor);\n+    public static long subProcessTimeout = (long)(60L * Utils.TIMEOUT_FACTOR);\n","filename":"test\/hotspot\/jtreg\/runtime\/8176717\/TestInheritFD.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.cds.default.archive.available\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+ * @comment Asan changes memory layout and we get a different coops mode\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/UseCompressedOops.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xcomp ArraysNewInstanceBug\n+ * @run main\/othervm\/timeout=480 -Xcomp ArraysNewInstanceBug\n","filename":"test\/hotspot\/jtreg\/runtime\/CreateMirror\/ArraysNewInstanceBug.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run driver CreateCoredumpOnCrash\n+ * @run driver\/timeout=480 CreateCoredumpOnCrash\n@@ -33,0 +33,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/CreateCoredumpOnCrash.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,5 @@\n-                pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"R0=.*\")};\n+                if (Platform.isLinux()) {\n+                    pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"R0=.*\")};\n+                } else if (Platform.isWindows()) {\n+                    pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"X0 =.*\")};\n+                }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ShowRegistersOnAssertTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver\/timeout=1800 invocationC1Tests special\n+ * @run driver\/timeout=7200 invocationC1Tests special\n@@ -48,1 +48,1 @@\n- * @run driver\/timeout=1800 invocationC1Tests virtual\n+ * @run driver\/timeout=7200 invocationC1Tests virtual\n@@ -61,1 +61,1 @@\n- * @run driver\/timeout=1800 invocationC1Tests interface\n+ * @run driver\/timeout=7200 invocationC1Tests interface\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invocationC1Tests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver\/timeout=1800 invokeinterfaceTests current-int\n+ * @run driver\/timeout=5400 invokeinterfaceTests current-int\n@@ -50,1 +50,1 @@\n- * @run driver\/timeout=1800 invokeinterfaceTests current-comp\n+ * @run driver\/timeout=5400 invokeinterfaceTests current-comp\n@@ -64,1 +64,1 @@\n- * @run driver\/timeout=1800 invokeinterfaceTests old-int\n+ * @run driver\/timeout=5400 invokeinterfaceTests old-int\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invokeinterfaceTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver TestResize\n+ * @run driver\/timeout=480 TestResize\n","filename":"test\/hotspot\/jtreg\/runtime\/LoadClass\/TestResize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -Xint -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail VirtualAllocCommitMerge\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -Xint -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail VirtualAllocCommitMerge\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocCommitMerge.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-                output.shouldContain(\"(sent by safepoint timeout handler\");\n+                output.shouldContain(\"(sent by safepoint timeout handler)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Safepoint\/TestAbortVMOnSafepointTimeout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=500 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceICCE\n+ * @run main\/othervm\/timeout=2000 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceICCE\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeInterfaceICCE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=300 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceSuccessTest\n+ * @run main\/othervm\/timeout=1200 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceSuccessTest\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeInterfaceSuccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=1200 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualICCE\n+ * @run main\/othervm\/timeout=4800 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualICCE\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeVirtualICCE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=400 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualSuccessTest\n+ * @run main\/othervm\/timeout=1600 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualSuccessTest\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeVirtualSuccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm TestThreadDumpMonitorContention\n+ * @run main\/othervm\/timeout=480 TestThreadDumpMonitorContention\n@@ -53,0 +53,5 @@\n+    \/\/ jstack streaming output should be disabled because if the attach operation is executed at a safepoint,\n+    \/\/ the attach streaming output is enabled, and the tool output is lengthy, then we can get both buffers (the attach\n+    \/\/ channel and the tool redirection buffer) full and the test hangs.\n+    \/\/ Instead the attach operation output is buffered and is sent after the operation is completed.\n+    final static String DISABLE_STREAMING_OUTPUT = \"-J-Djdk.attach.allowStreamingOutput=false\";\n@@ -382,1 +387,1 @@\n-            Process process = new ProcessBuilder(JSTACK, PID)\n+            Process process = new ProcessBuilder(JSTACK, DISABLE_STREAMING_OUTPUT, PID)\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestThreadDumpMonitorContention.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -49,1 +51,1 @@\n-        ArrayList<String> dumpArgs = new ArrayList<>();\n+        ArrayList<String> vmArgs = new ArrayList<>();\n@@ -52,1 +54,1 @@\n-        dumpArgs.add(\"-Xmx128M\");\n+        vmArgs.add(\"-Xmx128M\");\n@@ -57,1 +59,1 @@\n-            dumpArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n+            vmArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n@@ -60,1 +62,3 @@\n-        dump(dumpArgs);\n+        String archiveFile = dump(vmArgs);\n+        exec(vmArgs, archiveFile);\n+\n@@ -64,1 +68,3 @@\n-    static void dump(ArrayList<String> args, String... more) throws Exception {\n+\n+    \/\/ Create a map file when creating the archive\n+    static String dump(ArrayList<String> args) throws Exception {\n@@ -70,0 +76,1 @@\n+            \/\/ filesize=0 ensures that a large map file not broken up in multiple files.\n@@ -72,2 +79,1 @@\n-            .addSuffix(args)\n-            .addSuffix(more);\n+            .addSuffix(args);\n@@ -78,0 +84,19 @@\n+\n+        return archiveName;\n+    }\n+\n+    \/\/ Create a map file when using the archive\n+    static void exec(ArrayList<String> vmArgs, String archiveFile) throws Exception {\n+        String mapName = archiveFile + \".exec.map\";\n+        vmArgs.add(\"-XX:SharedArchiveFile=\" + archiveFile);\n+        vmArgs.add(\"-Xlog:cds=debug\");\n+        vmArgs.add(\"-Xshare:on\");\n+        vmArgs.add(\"-Xlog:aot+map=debug,aot+map+oops=trace:file=\" + mapName + \":none:filesize=0\");\n+        vmArgs.add(\"--version\");\n+        String[] cmdLine = vmArgs.toArray(new String[vmArgs.size()]);\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        OutputAnalyzer out = CDSTestUtils.executeAndLog(pb, \"exec\");\n+        out.shouldHaveExitValue(0);\n+\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n+        CDSMapReader.validate(mapFile);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        System.out.println(\"MetaspaceShared::core_region_alignment() = \" + reserve_alignment);\n+        System.out.println(\"AOTMetaspace::core_region_alignment() = \" + reserve_alignment);\n@@ -93,1 +93,1 @@\n-                        throw new RuntimeException(\"Unused space (\" + unused + \") must be smaller than MetaspaceShared::core_region_alignment() (\" +\n+                        throw new RuntimeException(\"Unused space (\" + unused + \") must be smaller than AOTMetaspace::core_region_alignment() (\" +\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/SpaceUtilizationCheck.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-    private static boolean isCOHArchiveAvailable(char coops, char coh,\n-                                                 String archiveSuffix) throws Exception {\n+    private static boolean isArchiveAvailable(char coops, char coh,\n+                                              String archiveSuffix) throws Exception {\n@@ -116,0 +116,4 @@\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n+                    throw new SkippedException(\"Skipping test due to \" +\n+                                               archivePath(archiveSuffix).toString() + \" not available\");\n+                }\n@@ -121,1 +125,1 @@\n-                if (!isCOHArchiveAvailable(coops, coh, archiveSuffix)) {\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n@@ -130,0 +134,4 @@\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n+                    throw new SkippedException(\"Skipping test due to \" +\n+                                               archivePath(archiveSuffix).toString() + \" not available\");\n+                }\n@@ -134,1 +142,1 @@\n-                if (!isCOHArchiveAvailable(coops, coh, archiveSuffix)) {\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/TestDefaultArchiveLoading.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run driver\/timeout=500 LotsOfSyntheticClasses\n+ * @run driver\/timeout=8000 LotsOfSyntheticClasses\n@@ -123,1 +123,0 @@\n-                MAIN_CLASS_NAME,\n@@ -126,0 +125,1 @@\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n@@ -137,0 +137,1 @@\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfSyntheticClasses.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    \/\/ The following should be consistent with the enum in the C++ MetaspaceShared class\n+    \/\/ The following should be consistent with the enum in the C++ AOTMetaspace class\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,9 +25,1 @@\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.BuildHelper;\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.cds.CDSOptions;\n-import jdk.test.lib.cds.CDSTestUtils;\n-import jdk.test.lib.cds.CDSTestUtils.Result;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n+import cdsutils.DynamicDumpHelper;\n@@ -37,1 +29,0 @@\n-import java.io.InputStream;\n@@ -39,0 +30,1 @@\n+import java.io.InputStream;\n@@ -41,1 +33,0 @@\n-import java.nio.file.Files;\n@@ -44,0 +35,1 @@\n+import java.nio.file.Files;\n@@ -47,1 +39,0 @@\n-import java.util.Arrays;\n@@ -49,0 +40,1 @@\n+import java.util.Arrays;\n@@ -56,0 +48,10 @@\n+import jdk.test.lib.BuildHelper;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils.Result;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -57,1 +59,0 @@\n-import cdsutils.DynamicDumpHelper;\n@@ -79,3 +80,0 @@\n-    private static final String timeoutFactor =\n-        System.getProperty(\"test.timeout.factor\", \"1.0\");\n-\n@@ -423,1 +421,1 @@\n-        cmd.add(\"-Dtest.timeout.factor=\" + timeoutFactor);\n+        cmd.add(\"-Dtest.timeout.factor=\" + Utils.TIMEOUT_FACTOR);\n@@ -430,2 +428,0 @@\n-        CDSTestUtils.addVerifyArchivedFields(cmd);\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=aot\n+ * @bug 8362566\n+ * @summary Test the contents of -Xlog:aot+map with AOT workflow\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n+ * @build AOTMapTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar AOTMapTestApp\n+ * @run driver AOTMapTest AOT --two-step-training\n+ *\/\n+\n+\/**\n+ * @test id=dynamic\n+ * @bug 8362566\n+ * @summary Test the contents of -Xlog:aot+map with AOT workflow\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @build AOTMapTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar AOTMapTestApp\n+ * @run  main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. AOTMapTest DYNAMIC\n+ *\/\n+\n+\n+import java.util.ArrayList;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.Platform;\n+\n+public class AOTMapTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"AOTMapTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        doTest(args);\n+    }\n+\n+    public static void doTest(String[] args) throws Exception {\n+        Tester tester = new Tester();\n+        tester.run(args);\n+\n+        validate(tester.dumpMapFile);\n+        validate(tester.runMapFile);\n+    }\n+\n+    static void validate(String mapFileName) {\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapFileName);\n+        CDSMapReader.validate(mapFile);\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        String dumpMapFile;\n+        String runMapFile;\n+\n+        public Tester() {\n+            super(mainClass);\n+\n+            dumpMapFile = \"test\" + \"0\" + \".dump.aotmap\";\n+            runMapFile  = \"test\" + \"0\" + \".run.aotmap\";\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            ArrayList<String> vmArgs = new ArrayList<>();\n+\n+            vmArgs.add(\"-Xmx128M\");\n+            vmArgs.add(\"-Xlog:aot=debug\");\n+\n+            \/\/ filesize=0 ensures that a large map file not broken up in multiple files.\n+            String logMapPrefix = \"-Xlog:aot+map=debug,aot+map+oops=trace:file=\";\n+            String logMapSuffix = \":none:filesize=0\";\n+\n+            if (runMode == RunMode.ASSEMBLY || runMode == RunMode.DUMP_DYNAMIC) {\n+                vmArgs.add(logMapPrefix + dumpMapFile + logMapSuffix);\n+            } else if (runMode == RunMode.PRODUCTION) {\n+                vmArgs.add(logMapPrefix + runMapFile + logMapSuffix);\n+            }\n+\n+            return vmArgs.toArray(new String[vmArgs.size()]);\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+            };\n+        }\n+    }\n+}\n+\n+class AOTMapTestApp {\n+    public static void main(String[] args) {\n+        System.out.println(\"Hello AOTMapTestApp\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/AOTMapTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ * @run driver\/timeout=480 jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n@@ -40,1 +40,1 @@\n- * @run driver AOTCodeCompressedOopsTest\n+ * @run driver\/timeout=480 AOTCodeCompressedOopsTest\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeCompressedOopsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -260,0 +260,10 @@\n+\n+        \/\/ Training run with -XX:+PrintTieredEvents (see JDK-8362530).\n+        printTestCase(\"Training run with -XX:+PrintTieredEvents\");\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=record\",\n+            \"-XX:+PrintTieredEvents\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"train-with-tiered-events\");\n+        out.shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotFlags\/AOTFlags.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run driver AOTProfileFlags\n+ * @run driver\/timeout=480 AOTProfileFlags\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotProfile\/AOTProfileFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+ * @requires vm.cds.nocoops.archive.available\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/loaderConstraints\/DynamicLoaderConstraintsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver\/timeout=650 SharedStringsStress\n+ * @run driver\/timeout=2600 SharedStringsStress\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsStress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- * @run testng\/othervm -Xcomp -XX:-TieredCompilation  ArrayIndexOutOfBoundsExceptionTest\n- * @run testng\/othervm -Xcomp -XX:TieredStopAtLevel=1 ArrayIndexOutOfBoundsExceptionTest\n+ * @run testng\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation  ArrayIndexOutOfBoundsExceptionTest\n+ * @run testng\/othervm\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 ArrayIndexOutOfBoundsExceptionTest\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/ArrayIndexOutOfBoundsException\/ArrayIndexOutOfBoundsExceptionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,3 +56,0 @@\n-        if (WB.getBooleanVMFlag(\"VerifyHeavyMonitors\")) {\n-            throw new SkippedException(\"VerifyHeavyMonitors always inflates. Invalid test.\");\n-        }\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestRecursiveMonitorChurn.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -Xlog:all=trace:file=all.log RedefineClasses\n+ * @run main\/othervm\/timeout=480 -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -Xlog:all=trace:file=all.log RedefineClasses\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/RedefineClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver StressAsyncUL\n+ * @run driver\/timeout=480 StressAsyncUL\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/StressAsyncUL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xmx128m ReflectOutOfMemoryError\n+ * @run main\/othervm\/timeout=480 -Xmx128m ReflectOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/runtime\/reflect\/ReflectOutOfMemoryError.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @requires os.family != \"windows\" & os.family != \"aix\" & vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/signal\/TestSigalrm.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run junit\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI --enable-native-access=ALL-UNNAMED UnmountedVThreadNativeMethodAtTop\n+ * @run junit\/othervm\/native\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI --enable-native-access=ALL-UNNAMED UnmountedVThreadNativeMethodAtTop\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/UnmountedVThreadNativeMethodAtTop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm\/native -Xmx512m -agentlib:HeapMonitorTest MyPackage.HeapMonitorThreadTest\n+ * @run main\/othervm\/native\/timeout=480 -Xmx512m -agentlib:HeapMonitorTest MyPackage.HeapMonitorThreadTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,3 @@\n- * @run main\/othervm\/native -agentlib:TagMapTest\n- *                          -Xlog:jvmti+table\n- *                          TagMapTest\n+ * @run main\/othervm\/native\/timeout=480 -agentlib:TagMapTest\n+ *                                      -Xlog:jvmti+table\n+ *                                      TagMapTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SetTag\/TagMapTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test verifies that MethodExit event is correctly posted\n+ *          if method is called while there is a pending exception on this thread.\n+ *\n+ * @bug 8365937\n+ * @run main\/othervm\/native -agentlib:TestMethodExitWithPendingException TestMethodExitWithPendingException\n+ *\/\n+public class TestMethodExitWithPendingException {\n+\n+    private static native void enable();\n+    private static native void disableAndCheck();\n+\n+    static String exceptionExit() {\n+        throw new RuntimeException(\"MyRuntimeException\");\n+    }\n+\n+\n+    \/\/ Called from ExceptionExit MethodExit callback via JNI.\n+    \/\/ So MyRuntimeException is thrown already and hasn't been caught yet\n+    \/\/ when this method is called.\n+    static String upCall() {\n+        return \"MyNewString\";\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        System.loadLibrary(\"TestMethodExitWithPendingException\");\n+        try {\n+            enable();\n+            exceptionExit();\n+        } catch (RuntimeException e){\n+            disableAndCheck();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PendingException\/TestMethodExitWithPendingException.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+#include \"jvmti_common.hpp\"\n+\n+jvmtiEnv* jvmti_env;\n+\n+bool method_exit_posted = false;\n+\/\/ This method exit callback actually works only for 2 methods:\n+\/\/ 1) for ExceptionExit it verifies that method exit\n+\/\/    has been popped by exception and calls 'upCall' method using JNI.\n+\/\/ 2) for upCall method it verifies that event has correct\n+\/\/    return value and was not popped by exception.\n+\/\/ The event callback just exits for all other methods.\n+static void JNICALL\n+cbMethodExit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+             jboolean was_popped_by_exception, jvalue return_value) {\n+  const char * mname = get_method_name(jvmti, jni, method);\n+  if (strcmp(\"upCall\", mname) == 0) {\n+    if (was_popped_by_exception) {\n+      fatal(jni, \"The method's was_popped_by_exception value is incorrect.\");\n+    }\n+    jstring upcall_result = (jstring) return_value.l;\n+    const char *str = jni->GetStringUTFChars(upcall_result, nullptr);\n+    if (str == nullptr) {\n+      fatal(jni, \"Failed to convert Java string to C string.\");\n+    }\n+    if (strcmp(\"MyNewString\", str) != 0) {\n+      fatal(jni, \"The upCall result value is incorrect.\");\n+    }\n+    method_exit_posted = true;\n+  }\n+  if (strcmp(\"exceptionExit\", mname) != 0) {\n+    return;\n+  }\n+  if (!was_popped_by_exception) {\n+    fatal(jni, \"Should have was_popped_by_esxception = true.\");\n+  }\n+  jclass main_class = jni->FindClass(\"TestMethodExitWithPendingException\");\n+  if (main_class == nullptr) {\n+    fatal(jni, \"Can't find TestMethodExitWithPendingException class.\");\n+    return;\n+  }\n+  jmethodID upcall_method = jni->GetStaticMethodID(main_class,\n+                                                   \"upCall\", \"()Ljava\/lang\/String;\");\n+  if (upcall_method == nullptr) {\n+    fatal(jni, \"Can't find upCall method.\");\n+  }\n+  \/\/ Call 'upCall' method while current thread has exception\n+  \/\/ that has been thrown but hasn't been caught yet.\n+  jstring upcall_result = (jstring) jni->CallStaticObjectMethod(main_class, upcall_method);\n+  const char *str = jni->GetStringUTFChars(upcall_result, nullptr);\n+  if (str == nullptr) {\n+    fatal(jni, \"Failed to convert Java string to C string.\");\n+    return;\n+  }\n+  if (strcmp(\"MyNewString\", str) != 0) {\n+    fatal(jni, \"The upCall result value is incorrect.\");\n+  }\n+  jni->ReleaseStringUTFChars(upcall_result, str);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  capabilities.can_generate_method_exit_events = true;\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+  jvmtiEventCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.MethodExit = &cbMethodExit;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  jvmti_env = jvmti;\n+  return JNI_OK;\n+}\n+\n+\n+extern \"C\" {\n+\n+JNIEXPORT void JNICALL\n+Java_TestMethodExitWithPendingException_enable(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_TestMethodExitWithPendingException_disableAndCheck(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+  if (!method_exit_posted) {\n+    fatal(jni, \"Failed to post method exit event.\");\n+  }\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PendingException\/libTestMethodExitWithPendingException.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run main\/othervm\/native -agentlib:TestPoppedByException TestPoppedByException\n+ *\/\n+public class TestPoppedByException {\n+\n+    private static native void enable();\n+    private static native void disableAndCheck();\n+\n+   static String exceptionExit() {\n+        throw new RuntimeException(\"MyRuntimeException\");\n+    }\n+\n+    static String exceptionExitOuter() {\n+        return exceptionExit();\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        System.loadLibrary(\"TestPoppedByException\");\n+        try {\n+            enable();\n+            exceptionExitOuter();\n+        } catch (RuntimeException e){\n+            disableAndCheck();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PoppedByException\/TestPoppedByException.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+#include \"jvmti_common.hpp\"\n+\n+jvmtiEnv* jvmti_env;\n+bool method_exit_posted = false;\n+static void JNICALL\n+cbMethodExit(jvmtiEnv* jvmti, JNIEnv* jni, jthread thread, jmethodID method,\n+             jboolean was_popped_by_exception, jvalue return_value) {\n+  const char * mname = get_method_name(jvmti, jni, method);\n+  if (strcmp(\"exceptionExitOuter\", mname) == 0) {\n+    if (!was_popped_by_exception) {\n+      fatal(jni, \"The method's was_popped_by_exception value is incorrect.\");\n+    }\n+    if (return_value.l != nullptr) {\n+      fatal(jni, \"return_value should be nullptr.\");\n+    }\n+    method_exit_posted = true;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  capabilities.can_generate_method_exit_events = true;\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+  jvmtiEventCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.MethodExit = &cbMethodExit;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  jvmti_env = jvmti;\n+ return JNI_OK;\n+}\n+\n+\n+extern \"C\" {\n+JNIEXPORT void JNICALL\n+Java_TestPoppedByException_enable(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_TestPoppedByException_disableAndCheck(JNIEnv *jni, jclass clazz) {\n+  jthread thread = get_current_thread(jvmti_env, jni);\n+  jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, thread);\n+  if (!method_exit_posted) {\n+    fatal(jni, \"Failed to post method exit event.\");\n+  }\n+  printf(\"The expected method_exit posted.\\n\");\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/PoppedByException\/libTestPoppedByException.cpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=700\n@@ -43,1 +43,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=700\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=700\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResume2\/SuspendResume2.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\/timeout=240 ClhsdbDumpheap\n+ * @run main\/othervm\/timeout=960 ClhsdbDumpheap\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpheap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC true false\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC true false\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC true true\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC true true\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC false false\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC false false\n@@ -77,1 +77,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC false true\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC false true\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver\/timeout=300 ClhsdbJstackXcompStress\n+ * @run driver\/timeout=1200 ClhsdbJstackXcompStress\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbJstackXcompStress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm ClhsdbThreadContext\n+ * @run main\/othervm\/timeout=480 ClhsdbThreadContext\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbThreadContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver TestJhsdbJstackLineNumbers\n+ * @run driver\/timeout=480 TestJhsdbJstackLineNumbers\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLineNumbers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run driver TestObjectAlignment\n+ * @run driver\/timeout=480 TestObjectAlignment\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestObjectAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run driver SADebugDTest\n+ * @run driver\/timeout=480 SADebugDTest\n@@ -128,1 +128,1 @@\n-                Process debugd = startProcess(\"debugd\", pb, null, l -> checkOutput(l, useRmiPort, rmiPort), 20, TimeUnit.SECONDS);\n+                Process debugd = startProcess(\"debugd\", pb, null, l -> checkOutput(l, useRmiPort, rmiPort), 80, TimeUnit.SECONDS);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/SADebugDTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,14 +46,2 @@\n-                    \"share\/adlc\",\n-                    \"share\/c1\",\n-                    \"share\/cds\",\n-                    \"share\/ci\",\n-                    \"share\/classfile\",\n-                    \"share\/code\",\n-                    \"share\/compiler\",\n-                    \"share\/jvmci\",\n-                    \"share\/libadt\",\n-                    \"share\/metaprogramming\",\n-                    \"share\/oops\",\n-                    \"share\/opto\",\n-                    \"share\/services\",\n-                    \"share\/utilities\"\n+                    \"os\/linux\",\n+                    \"share\"\n","filename":"test\/hotspot\/jtreg\/sources\/TestIncludesAreSorted.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1127,2 +1127,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\"})\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_MAX, \"> 0\"}) \/\/ valid\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"> 0\"}) \/\/ valid, but only if MaxVectorSize > 0, otherwise, a violation is reported\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_MAX, \"> 0\"}, applyIf = {\"MaxVectorSize\", \"> 0\"}) \/\/ valid, but only if MaxVectorSize > 0, otherwise, a violation is reported\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestBadFormat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver ir_framework.tests.TestNotCompilable\n+ * @run driver\/timeout=480 ir_framework.tests.TestNotCompilable\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestNotCompilable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import java.util.Set;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test cross product scenarios with the framework.\n+ * @library \/test\/lib \/testlibrary_tests \/\n+ * @run driver ir_framework.tests.TestScenariosCrossProduct\n+ *\/\n+\n+public class TestScenariosCrossProduct {\n+    static void hasNFailures(String s, int count) {\n+        if (!s.matches(\"The following scenarios have failed: (#[0-9](, )?){\" + count + \"}. Please check stderr for more information.\")) {\n+            throw new RuntimeException(\"Expected \" + count + \" failures in \\\"\" + s + \"\\\"\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Test argument handling\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios((Set<String>[]) null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestFormatException e) {}\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios(Set.of(\"foo\", \"bar\"), null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestFormatException e) {}\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios(Set.of(\"blub\"), Set.of(\"foo\", null));\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (NullPointerException e) {} \/\/ Set.of prevents null elements\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios();\n+        } catch (TestFormatException e) {\n+            Asserts.fail(\"Should not have thrown exception\");\n+        }\n+\n+        \/\/ Single set should test all flags in the set by themselves.\n+        try {\n+            TestFramework t1 = new TestFramework();\n+            t1.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\",\n+                                               \"-XX:TLABRefillWasteFraction=53\",\n+                                               \"-XX:TLABRefillWasteFraction=64\"));\n+            t1.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 3);\n+        }\n+\n+        \/\/ The cross product of a set with one element and a set with three elements is three sets.\n+        try {\n+            TestFramework t2 = new TestFramework();\n+            t2.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\", \"-XX:+UseNewCode3\"));\n+            t2.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 3);\n+        }\n+\n+        \/\/ The cross product of two sets with two elements is four sets.\n+        try {\n+            TestFramework t3 = new TestFramework();\n+            t3.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:TLABRefillWasteFraction=64\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:-UseNewCode\"));\n+            t3.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 4);\n+        }\n+\n+        \/\/ Test with a pair of flags.\n+        try {\n+            TestFramework t4 = new TestFramework();\n+            t4.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=50 -XX:+UseNewCode\", \"-XX:TLABRefillWasteFraction=40\"),\n+                                        Set.of(\"-XX:+UseNewCode2\"));\n+            t4.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 1);\n+        }\n+\n+        \/\/ Test with an empty string. All 6 scenarios fail because 64 is the default value for TLABRefillWasteFraction.\n+        try {\n+            TestFramework t5 = new TestFramework();\n+            t5.addCrossProductScenarios(Set.of(\"\", \"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n+            t5.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 6);\n+        }\n+\n+        try {\n+            TestFramework t6 = new TestFramework();\n+            t6.addScenarios(new Scenario(0, \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\")); \/\/ failPair\n+            t6.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n+            try {\n+                t6.addScenarios(new Scenario(4, \"-XX:+UseNewCode3\")); \/\/ fails because index 4 is already used\n+            Asserts.fail(\"Should have thrown exception\");\n+            } catch (TestFormatException e) {}\n+            t6.addScenarios(new Scenario(5, \"-XX:+UseNewCode3\")); \/\/ fail default\n+            t6.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 6);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"64\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failDefault() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"51\"}, counts = {IRNode.CALL, \"1\"})\n+    public void fail1() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"53\"}, counts = {IRNode.CALL, \"1\"})\n+    public void fail2() {\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"TLABRefillWasteFraction\", \"50\", \"UseNewCode\", \"true\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failPair() {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestScenariosCrossProduct.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_class\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_obj\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large001\/large001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large002\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large003\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large004\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large005\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft004.soft004 -t 1\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft004.soft004 -t 1\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft004\/soft004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak004.weak004 -t 1\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak004.weak004 -t 1\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak004\/weak004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm gc.vector.SimpleGC.SimpleGC -ms low -gp circularList(low)\n+ * @run main\/othervm\/timeout=480 gc.vector.SimpleGC.SimpleGC -ms low -gp circularList(low)\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/CircularListLow\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run driver\/timeout=300 ExecDriver --java -server -Xcomp -XX:+DoEscapeAnalysis\n+ * @run driver\/timeout=1200 ExecDriver --java -server -Xcomp -XX:+DoEscapeAnalysis\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/escape\/AdaptiveBlocking\/AdaptiveBlocking001\/AdaptiveBlocking001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -41,1 +41,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/shrink_grow\/CompressedClassSpaceSize\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver metaspace.shrink_grow.ShrinkGrowMultiJVM.ShrinkGrowMultiJVM\n+ * @run driver\/timeout=480 metaspace.shrink_grow.ShrinkGrowMultiJVM.ShrinkGrowMultiJVM\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/shrink_grow\/ShrinkGrowMultiJVM\/ShrinkGrowMultiJVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy001\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy002\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy003\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy004\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy005\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy006\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy007\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy008\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy009\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy010\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy011\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy012\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy013\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy014\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy015\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects001\/referringObjects001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n- * @run driver\n+ * @run driver\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepEvent\/_itself_\/stepEvent004\/stepEvent004.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n- * @run driver\n+ * @run driver\/timeout=480\n@@ -94,1 +94,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadDeathEvent\/thread\/thread001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -79,1 +79,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/stress\/serial\/mixed002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=420\n+ * @run main\/othervm\/timeout=1680\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/VirtualMachine\/HoldEvents\/holdevents002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,2 @@\n+ * @comment Do not run with asan enabled because asan has issues with ulimit\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Allocate\/alloc001\/alloc001.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\/native -agentlib:rawmnwait001 nsk.jvmti.RawMonitorWait.rawmnwait001\n+ * @run main\/othervm\/native\/timeout=480 -agentlib:rawmnwait001 nsk.jvmti.RawMonitorWait.rawmnwait001\n@@ -42,1 +42,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorWait\/rawmnwait001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -66,1 +66,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP03\/sp03t001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -66,1 +66,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP03\/sp03t002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP04\/sp04t001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP04\/sp04t002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -45,1 +45,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP07\/sp07t001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n+ * @run main\/othervm\/timeout=480 nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n- * @run main\/othervm\/native nsk.monitoring.stress.thread.strace001 -threadCount=50 -depth=200\n+ * @run main\/othervm\/native\/timeout=480 nsk.monitoring.stress.thread.strace001 -threadCount=50 -depth=200\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -67,1 +67,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -68,1 +68,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace003\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+\n+    \/\/ In nanoseconds\n@@ -62,1 +64,0 @@\n-    private long finishTime;\n@@ -64,0 +65,2 @@\n+    private long stressTime;\n+\n@@ -182,1 +185,1 @@\n-        println(out, \"Execution time: \" + (currentTime - startTime) + \" seconds\");\n+        println(out, \"Execution time: \" + (currentTime - startTime) \/ 1_000_000_000.0 + \" seconds\");\n@@ -189,2 +192,2 @@\n-        } else if (finishTime != 0 && currentTime >= finishTime) {\n-            println(out, \"Execution finished because time was exceeded: \" + (currentTime - startTime) + \" >= \" + (finishTime - startTime));\n+        } else if (stressTime != 0 && (currentTime - startTime) >= stressTime) {\n+            println(out, \"Execution finished because time has exceeded stress time: \" + stressTime \/ 1_000_000_000 + \" seconds\");\n@@ -211,7 +214,2 @@\n-        long stressTime = options.getTime();\n-        startTime = System.currentTimeMillis();\n-        if (stressTime == 0) {\n-            finishTime = 0;\n-        } else {\n-            finishTime = startTime + stressTime * 1000;\n-        }\n+        stressTime = options.getTime() * 1_000_000_000;\n+        startTime = System.nanoTime();\n@@ -235,1 +233,1 @@\n-        currentTime = System.currentTimeMillis();\n+        currentTime = System.nanoTime();\n@@ -258,0 +256,2 @@\n+        boolean result = continueExecution();\n+        \/\/ Call print at the end to show the most up-to-date info.\n@@ -261,1 +261,1 @@\n-        return continueExecution();\n+        return result;\n@@ -270,1 +270,1 @@\n-        currentTime = System.currentTimeMillis();\n+        currentTime = System.nanoTime();\n@@ -277,1 +277,1 @@\n-                && (finishTime == 0 || currentTime < finishTime);\n+                && (stressTime == 0 || (currentTime - startTime) < stressTime);\n@@ -312,1 +312,1 @@\n-        return System.currentTimeMillis() - startTime;\n+        return (System.nanoTime() - startTime) \/ 1_000_000;\n@@ -321,2 +321,2 @@\n-        long current = System.currentTimeMillis();\n-        if (current >= finishTime) {\n+        long elapsedTime = System.nanoTime() - startTime;\n+        if (elapsedTime >= stressTime) {\n@@ -325,1 +325,1 @@\n-            return finishTime - current;\n+            return (stressTime - elapsedTime) \/ 1_000_000;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/Stresser.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\/native nsk.stress.strace.strace006\n+ * @run main\/othervm\/native\/timeout=480 nsk.stress.strace.strace006\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace006.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm nsk.stress.thread.thread001 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread001 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm nsk.stress.thread.thread002 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread002 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm nsk.stress.thread.thread005 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread005 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread005.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm nsk.stress.thread.thread006 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread006 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread006.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=300 nsk.stress.thread.thread007 500 2m 5s\n+ * @run main\/othervm\/timeout=1200 nsk.stress.thread.thread007 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread007.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/timeout=300 nsk.stress.thread.thread008 500 2m 5s\n+ * @run main\/othervm\/timeout=1200 nsk.stress.thread.thread008 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread008.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree001\/btree001.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree002\/btree002.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree003\/btree003.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree004\/btree004.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree005\/btree005.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree006\/btree006.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -47,1 +47,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -56,1 +56,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree007\/btree007.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -56,1 +56,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree008\/btree008.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -56,1 +56,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree009\/btree009.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -47,1 +47,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree010\/btree010.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree011\/btree011.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree012\/btree012.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_indy2manyDiff_a\/TestDescription.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm -XX:CompileCommand=MemLimit,*.*,0 vm.mlvm.meth.stress.compiler.i2c_c2i.Test\n+ * @run main\/othervm\/timeout=480 -XX:CompileCommand=MemLimit,*.*,0 vm.mlvm.meth.stress.compiler.i2c_c2i.Test\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/sequences\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#############################################################################\n+#\n+# List of quarantined tests failing with jvmti stress agent in any mode.\n+#\n+#############################################################################\n+\n+\n+sun\/security\/ssl\/SSLEngineImpl\/SSLEngineKeyLimit.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java                         8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java              8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java                       8362658 generic-all\n+sun\/security\/ssl\/SSLSessionImpl\/ResumptionUpdateBoundValues.java            8362658 generic-all\n+sun\/security\/ssl\/SSLSocketImpl\/SSLSocketKeyLimit.java                       8362658 generic-all\n+\n+\n+# List of tests incompatible with jvmti stress agent or requiring more investigation\n+\n+com\/sun\/jdi\/EATests.java#id0                                                0000000 generic-all\n+com\/sun\/jdi\/ThreadMemoryLeakTest.java                                       0000000 generic-all\n+\n+# weak referenced are not cleared\n+java\/lang\/WeakPairMap\/Driver.java                                           0000000 generic-all\n+java\/lang\/ref\/ReachabilityFenceTest.java                                    0000000 generic-all\n","filename":"test\/jdk\/ProblemList-jvmti-stress-agent.txt","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -122,1 +122,0 @@\n-java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java 8361521 linux-all\n@@ -264,1 +263,1 @@\n-java\/awt\/Choice\/ChoiceMouseWheelTest\/ChoiceMouseWheelTest.java 6849371 macosx-all,linux-all\n+java\/awt\/Choice\/ChoiceMouseWheelTest\/ChoiceMouseWheelTest.java 8366852 generic-all\n@@ -618,2 +617,0 @@\n-java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java       7191877 generic-all\n-\n@@ -622,1 +619,1 @@\n-\n+java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java       8365398 generic-all\n@@ -755,5 +752,0 @@\n-sun\/tools\/jstat\/jstatLineCounts1.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts2.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts3.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-sun\/tools\/jstat\/jstatLineCounts4.sh                             8248691,8268211 linux-ppc64le,aix-ppc64,linux-aarch64\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @library \/test\/lib\n@@ -50,0 +51,1 @@\n+import jdk.test.lib.Utils;\n@@ -62,3 +64,1 @@\n-            double timeoutFactor = Double.parseDouble(\n-                    System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-            timeout = (int) (timeout * timeoutFactor);\n+            timeout = (int) (timeout * Utils.TIMEOUT_FACTOR);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KeyFactory\/TestProviderLeak.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.test.lib.Utils;\n@@ -33,0 +34,1 @@\n+ * @library \/test\/lib\n@@ -287,2 +289,1 @@\n-                    float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-                    long sleepSeconds = (long)(20 * timeoutFactor);\n+                    long sleepSeconds = (long)(20 * Utils.TIMEOUT_FACTOR);\n","filename":"test\/jdk\/com\/sun\/jdi\/InterruptHangTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,1 @@\n+    private static final String[] DEBUGGEE_OPTIONS = {\"-Xmx64M\"};\n@@ -118,1 +119,2 @@\n-        super(DEBUGGEE_CLASS);\n+        super(new LaunchOptions(DEBUGGEE_CLASS)\n+                .addDebuggeeOptions(DEBUGGEE_OPTIONS));\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbStopInNotificationThreadTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,3 @@\n- * @run driver MethodEntryExitEvents SUSPEND_EVENT_THREAD MethodEntryExitEventsDebugee\n- * @run driver MethodEntryExitEvents SUSPEND_NONE MethodEntryExitEventsDebugee\n- * @run driver MethodEntryExitEvents SUSPEND_ALL MethodEntryExitEventsDebugee\n+ * @run driver\/timeout=480 MethodEntryExitEvents SUSPEND_EVENT_THREAD MethodEntryExitEventsDebugee\n+ * @run driver\/timeout=480 MethodEntryExitEvents SUSPEND_NONE MethodEntryExitEventsDebugee\n+ * @run driver\/timeout=480 MethodEntryExitEvents SUSPEND_ALL MethodEntryExitEventsDebugee\n","filename":"test\/jdk\/com\/sun\/jdi\/MethodEntryExitEvents.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xmx7m ThreadMemoryLeakTest\n+ * @run main\/othervm\/timeout=480 -Xmx7m ThreadMemoryLeakTest\n","filename":"test\/jdk\/com\/sun\/jdi\/ThreadMemoryLeakTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm LdapPoolTimeoutTest\n+ * @run testng\/othervm\/timeout=480 LdapPoolTimeoutTest\n@@ -147,1 +147,0 @@\n-\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapPoolTimeoutTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -57,6 +60,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -344,0 +341,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Bind.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @key intermittent\n@@ -48,0 +49,2 @@\n+import jtreg.SkippedException;\n+\n@@ -57,1 +60,1 @@\n-            throw new jtreg.SkippedException(\"SCTP protocol is not supported\");\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n@@ -66,1 +69,1 @@\n-            throw new jtreg.SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n+            throw new SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/CloseDescriptors.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -52,0 +53,2 @@\n+import jtreg.SkippedException;\n+\n@@ -64,6 +67,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -358,0 +355,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/CommUp.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -28,0 +29,1 @@\n+ * @run main\/timeout=480 Connect\n@@ -46,0 +48,2 @@\n+import jtreg.SkippedException;\n+\n@@ -53,6 +57,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -238,0 +236,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Connect.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -64,7 +67,0 @@\n-\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -352,0 +348,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Receive.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -48,0 +49,2 @@\n+import jtreg.SkippedException;\n+\n@@ -59,6 +62,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -267,0 +264,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/ReceiveIntoDirect.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -63,6 +66,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -454,0 +451,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Send.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -46,0 +47,2 @@\n+import jtreg.SkippedException;\n+\n@@ -54,6 +57,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -275,0 +272,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Shutdown.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -46,0 +47,2 @@\n+import jtreg.SkippedException;\n+\n@@ -69,6 +72,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -193,0 +190,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/SocketOptionTests.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -61,6 +64,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -280,0 +277,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/Branch.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -41,0 +42,2 @@\n+import jtreg.SkippedException;\n+\n@@ -49,3 +52,1 @@\n-            System.out.println(\"SCTP protocol is not supported\");\n-            System.out.println(\"Test cannot be run\");\n-            return;\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n@@ -60,3 +61,1 @@\n-            System.out.println(\"Cannot locate lsof in \" + lsofDirs);\n-            System.out.println(\"Test cannot be run\");\n-            return;\n+            throw new SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/CloseDescriptors.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -45,0 +46,2 @@\n+import jtreg.SkippedException;\n+\n@@ -55,6 +58,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -358,0 +355,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/Send.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,2 @@\n+import jtreg.SkippedException;\n+\n@@ -48,6 +51,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -189,0 +186,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/SendFailed.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -54,0 +55,2 @@\n+import jtreg.SkippedException;\n+\n@@ -77,6 +80,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -247,0 +244,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/SocketOptionTests.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -44,0 +45,2 @@\n+import jtreg.SkippedException;\n+\n@@ -53,6 +56,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -265,0 +262,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpServerChannel\/Accept.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -28,0 +29,1 @@\n+ * @run main\/timeout=480 NonBlockingAccept\n@@ -45,0 +47,2 @@\n+import jtreg.SkippedException;\n+\n@@ -54,6 +58,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -221,0 +219,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpServerChannel\/NonBlockingAccept.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.VolatileImage;\n+import java.lang.ref.WeakReference;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8364434\n+ * @summary Check that garbage-collecting Color before accelerated painting is complete does not cause artifacts.\n+ * @requires (os.family != \"linux\")\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xms16m -Xmx16m WeakColorTest\n+ *\/\n+\n+public class WeakColorTest {\n+    public static void main(String[] args) throws Exception {\n+        BufferedImage bi = new BufferedImage(100, 100, BufferedImage.TYPE_INT_RGB); \/\/ This image is full-black.\n+        VolatileImage image = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                .getDefaultScreenDevice().getDefaultConfiguration().createCompatibleVolatileImage(100, 100);\n+        Graphics2D g = image.createGraphics();\n+\n+        \/\/ Create a new Color - we want it to be collected later.\n+        g.setColor(new Color(255, 0, 0));\n+        WeakReference<Color> color = new WeakReference<>(g.getColor());\n+\n+        g.fillRect(0, 0, 100, 100);\n+\n+        \/\/ Change color to prevent Graphics from keeping our Color alive.\n+        g.setColor(Color.BLACK);\n+\n+        \/\/ Force Color to be GC'ed.\n+        final int MAX_ITERATIONS = 1000, ARRAY_SIZE = 1000000;\n+        WeakReference<Object[]> array = null;\n+        for (int i = 0;; i++) {\n+            System.gc();\n+            if (color.get() == null) {\n+                System.out.println(\"Color collected at: \" + i);\n+                break;\n+            } else if (i >= MAX_ITERATIONS) {\n+                throw new SkippedException(\"Color was not collected after \" + MAX_ITERATIONS + \" iterations\");\n+            }\n+            Object[] a = new Object[ARRAY_SIZE];\n+            a[0] = array;\n+            array = new WeakReference<>(a);\n+        }\n+\n+        \/\/ Do a blit. If it succeeds, the resulting image will be full-black.\n+        g.drawImage(bi, 0, 0, null);\n+        g.dispose();\n+\n+        \/\/ We expect black. If it's red, then the blit must have failed.\n+        int actualColor = image.getSnapshot().getRGB(50, 50);\n+        if ((actualColor & 0xFFFFFF) != 0) throw new Error(\"Wrong color: 0x\" + Integer.toHexString(actualColor));\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/ColorClass\/WeakColorTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.awt.Rectangle;\n@@ -40,0 +41,1 @@\n+import java.awt.Toolkit;\n@@ -45,0 +47,5 @@\n+import java.io.File;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.imageio.ImageIO;\n@@ -52,1 +59,0 @@\n-    static volatile boolean passed;\n@@ -56,0 +62,1 @@\n+    static final CountDownLatch focusGainedLatch = new CountDownLatch(1);\n@@ -78,5 +85,1 @@\n-        new Thread(new Runnable() {\n-            public void run() {\n-                dialog.setVisible(true);\n-            }\n-        }).start();\n+        new Thread(() -> dialog.setVisible(true)).start();\n@@ -101,1 +104,1 @@\n-                passed = true;\n+                focusGainedLatch.countDown();\n@@ -119,0 +122,11 @@\n+    private static void captureScreen() {\n+        try {\n+            final Rectangle screenBounds = new Rectangle(\n+                    Toolkit.getDefaultToolkit().getScreenSize());\n+            ImageIO.write(r.createScreenCapture(screenBounds),\n+                    \"png\", new File(\"ComponentLostFocusTest.png\"));\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n@@ -141,3 +155,4 @@\n-\n-            if (!passed) {\n-                throw new RuntimeException(\"TextField got no focus! Test failed.\");\n+            if (!focusGainedLatch.await(5, TimeUnit.SECONDS)) {\n+                captureScreen();\n+                throw new RuntimeException(\"Waited too long, \" +\n+                        \"TextField got no focus! Test failed.\");\n@@ -154,1 +169,0 @@\n-\n","filename":"test\/jdk\/java\/awt\/Focus\/ComponentLostFocusTest.java","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8346952\n+ * @bug 8346952 8361521\n","filename":"test\/jdk\/java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,6 +25,5 @@\n-  @test\n-  @key headful\n-  @bug 6315717\n-  @summary verifies that drag events are coming for every button if the property is set to true\n-  @author Andrei Dmitriev : area=awt.mouse\n-  @run main ExtraButtonDrag\n+ * @test\n+ * @key headful\n+ * @bug 6315717\n+ * @summary Verifies that the mouse drag events received for every button if the property is set to true\n+ * @run main ExtraButtonDrag\n@@ -33,36 +32,27 @@\n-\/\/events from standard should also come\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-\n-public class ExtraButtonDrag extends Frame {\n-    static String tk = Toolkit.getDefaultToolkit().getClass().getName();\n-    static Robot robot;\n-    static int [] buttonsPressed;\n-    static int [] buttonsReleased;\n-    static int [] buttonsClicked;\n-    volatile static boolean dragged = false;\n-    volatile static boolean moved = false;\n-\n-    public ExtraButtonDrag(){\n-        super(\"ExtraButtonDrag\");\n-    }\n-\n-    public static void main(String []s){\n-        Frame frame = new ExtraButtonDrag();\n-\n-        MouseAdapter ma = new MouseAdapter() {\n-                public void mouseDragged(MouseEvent e) {\n-                    System.out.println(\"Dragged \"+e);\/\/ +\" : \"+ e.getButton() + \" : \" +e.getButtonState(e.getButton()));\n-                    dragged = true;\n-                }\n-                public void mouseMoved(MouseEvent e) {\n-                    System.out.println(\"Moved \"+e);\n-                    moved = true;\n-                }\n-                public void mousePressed(MouseEvent e) {\n-                    System.out.println(\">>> \"+e);\n-                }\n-                public void mouseReleased(MouseEvent e) {\n-                    System.out.println(\">>> \"+e);\n-                }\n+import java.awt.AWTException;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.MouseInfo;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ExtraButtonDrag {\n+\n+    private static Frame frame;\n+    private static Robot robot;\n+    private static volatile boolean dragged = false;\n+    private static volatile boolean moved = false;\n+    private static volatile Point centerFrame;\n+    private static volatile Point outboundsFrame;\n+    private static final String OS_NAME = System.getProperty(\"os.name\");\n+    private static MouseAdapter mAdapter = new MouseAdapter() {\n+        @Override\n+        public void mouseDragged(MouseEvent e) {\n+            dragged = true;\n+        }\n@@ -70,1 +60,5 @@\n-            };\n+        @Override\n+        public void mouseMoved(MouseEvent e) {\n+            moved = true;\n+        }\n+    };\n@@ -72,2 +66,4 @@\n-        frame.addMouseMotionListener(ma);\n-        frame.addMouseListener(ma);\n+    public static void initializeGUI() {\n+        frame = new Frame(\"ExtraButtonDrag\");\n+        frame.addMouseMotionListener(mAdapter);\n+        frame.addMouseListener(mAdapter);\n@@ -76,0 +72,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -77,0 +74,1 @@\n+    }\n@@ -78,6 +76,2 @@\n-        int [] buttonMask = new int [MouseInfo.getNumberOfButtons()]; \/\/InputEvent.getButtonMasks();\n-\n-        for (int i = 0; i < MouseInfo.getNumberOfButtons(); i++){\n-            buttonMask[i] = InputEvent.getMaskForButton(i+1);\n-            \/\/            System.out.println(\"TEST: \"+tmp[i]);\n-        }\n+    public static void doTest()\n+        throws InvocationTargetException, InterruptedException {\n@@ -85,5 +79,1 @@\n-        try {\n-            robot = new Robot();\n-            robot.delay(1000);\n-            Point centerFrame = new Point(frame.getLocationOnScreen().x + frame.getWidth()\/2, frame.getLocationOnScreen().y + frame.getHeight()\/2);\n-            Point outboundsFrame = new Point(frame.getLocationOnScreen().x + frame.getWidth()*3\/2, frame.getLocationOnScreen().y + frame.getHeight()\/2);\n+        int[] buttonMask = new int[MouseInfo.getNumberOfButtons()];\n@@ -91,4 +81,3 @@\n-            System.out.println(\"areExtraMouseButtonsEnabled() == \" + Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled() );\n-\n-            for (int i = 0; i < MouseInfo.getNumberOfButtons(); i++){\n-                System.out.println(\"button to drag = \" +(i+1) + \" : value passed to robot = \" +buttonMask[i]);\n+        for (int i = 0; i < MouseInfo.getNumberOfButtons(); i++) {\n+            buttonMask[i] = InputEvent.getMaskForButton(i + 1);\n+        }\n@@ -96,5 +85,23 @@\n-                try {\n-                    dragMouse(buttonMask[i], centerFrame.x, centerFrame.y, outboundsFrame.x, outboundsFrame.y);\n-                } catch (IllegalArgumentException e){\n-                    throw new RuntimeException(\"Test failed. Exception occured.\", e);\n-                }\n+        EventQueue.invokeAndWait(() -> {\n+            Point location = frame.getLocationOnScreen();\n+            Dimension size = frame.getSize();\n+            centerFrame = new Point(location.x + size.width \/ 2,\n+                location.y + size.height \/ 2);\n+            outboundsFrame = new Point(location.x + size.width * 3 \/ 2,\n+                location.y + size.height \/ 2);\n+        });\n+\n+        System.out.println(\"areExtraMouseButtonsEnabled() == \"\n+            + Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled());\n+\n+        for (int i = 0; i < MouseInfo.getNumberOfButtons(); i++) {\n+            System.out.println(\"button to drag = \" + (i + 1)\n+                + \" : value passed to robot = \" + buttonMask[i]);\n+\n+            try {\n+                dragMouse(buttonMask[i], centerFrame.x, centerFrame.y,\n+                    outboundsFrame.x, outboundsFrame.y);\n+            } catch (IllegalArgumentException e) {\n+                throw new RuntimeException(\"Test failed. Exception occured.\",\n+                    e);\n+            }\n@@ -102,14 +109,12 @@\n-                robot.delay(500);\n-                \/\/this is a choice-case for X protocol issue: native events from extra buttons doesn't contain\n-                \/\/ the correct state so it's unable to decide if there is a drag or move. By default we send MOVED event.\n-                \/\/XToolkit: extra buttons should report MOVED events only\n-                \/\/WToolkit: extra buttons should report DRAGGED events only\n-                if (i > 2){ \/\/extra buttons only\n-                    if (tk.equals(\"sun.awt.X11.XToolkit\")) {\n-                        if (!moved || dragged) {\n-                            throw new RuntimeException(\"Test failed.\"+ tk +\" Button = \" +(i+1) + \" moved = \"+moved +\" : dragged = \" +dragged);\n-                        }\n-                    } else { \/\/WToolkit\n-                        if (moved || !dragged) {\n-                            throw new RuntimeException(\"Test failed.\"+ tk +\" Button = \" +(i+1) + \" moved = \"+moved +\" : dragged = \" +dragged);\n-                        }\n+            \/\/ this is a choice-case for X protocol issue: native events from\n+            \/\/ extra buttons doesn't contain\n+            \/\/ the correct state so it's unable to decide if there is a drag or\n+            \/\/ move. By default we send MOVED event.\n+            \/\/ XToolkit: extra buttons should report MOVED events only\n+            \/\/ WToolkit: extra buttons should report DRAGGED events only\n+            if (i > 2) { \/\/ extra buttons only\n+                if (OS_NAME.equals(\"Linux\")) {\n+                    if (!moved || dragged) {\n+                        throw new RuntimeException(\"Test failed.\" + OS_NAME\n+                            + \" Button = \" + (i + 1) + \" moved = \" + moved\n+                            + \" : dragged = \" + dragged);\n@@ -117,3 +122,5 @@\n-                } else {\n-                    if (moved || !dragged){\n-                        throw new RuntimeException(\"Test failed. Button = \" +(i+1) + \" not dragged.\");\n+                } else { \/\/ WToolkit\n+                    if (moved || !dragged) {\n+                        throw new RuntimeException(\"Test failed.\" + OS_NAME\n+                            + \" Button = \" + (i + 1) + \" moved = \" + moved\n+                            + \" : dragged = \" + dragged);\n@@ -122,0 +129,5 @@\n+            } else {\n+                if (moved || !dragged) {\n+                    throw new RuntimeException(\n+                        \"Test failed. Button = \" + (i + 1) + \" not dragged.\");\n+                }\n@@ -123,2 +135,0 @@\n-        } catch (Exception e){\n-            throw new RuntimeException(\"\", e);\n@@ -128,1 +138,1 @@\n-    public static void dragMouse(int button, int x0, int y0, int x1, int y1){\n+    public static void dragMouse(int button, int x0, int y0, int x1, int y1) {\n@@ -141,1 +151,1 @@\n-        while (curX != x1){\n+        while (curX != x1) {\n@@ -146,1 +156,1 @@\n-        while (curY != y1 ){\n+        while (curY != y1) {\n@@ -154,0 +164,26 @@\n+    public static void main(String[] s)\n+        throws InvocationTargetException, InterruptedException, AWTException {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(10);\n+            robot.setAutoWaitForIdle(true);\n+\n+            EventQueue.invokeAndWait(ExtraButtonDrag::initializeGUI);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            doTest();\n+\n+            System.out.println(\"Test Passed\");\n+        } finally {\n+            EventQueue.invokeAndWait(ExtraButtonDrag::disposeFrame);\n+        }\n+    }\n+\n+    public static void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseModifiersUnitTest\/ExtraButtonDrag.java","additions":124,"deletions":88,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,3 @@\n- * @bug 8256321\n- * @summary Verifies profile properties are the same before\/after activation\n+ * @bug 8256321 8359380\n+ * @summary Verifies built-in profile properties are the same before and after\n+ *          activation and in copies of built-in profiles\n@@ -49,6 +50,9 @@\n-        \/\/ check default values, before profile activation\n-        test(srgb, TYPE_RGB, 3, CLASS_DISPLAY);\n-        test(gray, TYPE_GRAY, 1, CLASS_DISPLAY);\n-        test(xyz, TYPE_XYZ, 3, CLASS_ABSTRACT);\n-        test(lrgb, TYPE_RGB, 3, CLASS_DISPLAY);\n-        test(pycc, TYPE_3CLR, 3, CLASS_COLORSPACECONVERSION);\n+        \/\/ checks default values before built-in profiles are activated\n+        test(srgb, gray, xyz, lrgb, pycc);\n+\n+        \/\/ activates built-in profiles and creates copies\n+        ICC_Profile srgbCopy = ICC_Profile.getInstance(srgb.getData());\n+        ICC_Profile grayCopy = ICC_Profile.getInstance(gray.getData());\n+        ICC_Profile xyzCopy = ICC_Profile.getInstance(xyz.getData());\n+        ICC_Profile lrgbCopy = ICC_Profile.getInstance(lrgb.getData());\n+        ICC_Profile pyccCopy = ICC_Profile.getInstance(pycc.getData());\n@@ -56,6 +60,6 @@\n-        \/\/ activate profiles\n-        srgb.getData();\n-        gray.getData();\n-        xyz.getData();\n-        lrgb.getData();\n-        pycc.getData();\n+        \/\/ checks default values after profile activation\n+        test(srgb, gray, xyz, lrgb, pycc);\n+\n+        \/\/ checks default values in copies of the built-in profiles\n+        test(srgbCopy, grayCopy, xyzCopy, lrgbCopy, pyccCopy);\n+    }\n@@ -63,1 +67,3 @@\n-        \/\/ check default values, after profile activation\n+    private static void test(ICC_Profile srgb, ICC_Profile gray,\n+                             ICC_Profile xyz, ICC_Profile lrgb,\n+                             ICC_Profile pycc) {\n","filename":"test\/jdk\/java\/awt\/color\/CheckDefaultProperties.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    private static final String EXCEPTION_MSG = \"Built-in profile cannot be modified\";\n+    private static final String EXCEPTION_MSG = \"Can't modify built-in profile\";\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/BuiltInProfileCheck\/BuiltInProfileCheck.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.ColorConvertOp;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+\n+\/**\n+ * @test\n+ * @bug 8272860 8359380\n+ * @summary Verifies that ICC_Profile methods work correctly after a\n+ *          ColorConvertOp transformation\n+ * @library \/test\/lib\n+ *\/\n+public final class GetProfileDataAfterTransform {\n+\n+    private static final int[] CSS = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY,\n+            ColorSpace.CS_LINEAR_RGB, ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    \/**\n+     * The main process records expected get*() values before conversion and\n+     * passes them to a subprocess, which verifies it after the transform.\n+     *\n+     * @param  args If empty, the main process runs all color space pairs and\n+     *         spawns subprocesses. If not empty, args[0] and args[1] are source\n+     *         and target color space constants, followed by expected profile\n+     *         values to validate in the subprocess.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            for (int csFrom : CSS) {\n+                for (int csTo : CSS) {\n+                    var from = (ICC_ColorSpace) ColorSpace.getInstance(csFrom);\n+                    var to = (ICC_ColorSpace) ColorSpace.getInstance(csTo);\n+\n+                    ICC_Profile profileFrom = from.getProfile();\n+                    ICC_Profile profileTo = to.getProfile();\n+\n+                    List<String> cmd = new ArrayList<>();\n+                    cmd.add(GetProfileDataAfterTransform.class.getSimpleName());\n+\n+                    cmd.add(String.valueOf(csFrom));\n+                    cmd.add(String.valueOf(csTo));\n+\n+                    for (ICC_Profile p : List.of(profileFrom, profileTo)) {\n+                        cmd.add(String.valueOf(p.getPCSType()));\n+                        cmd.add(String.valueOf(p.getProfileClass()));\n+                        cmd.add(String.valueOf(p.getMinorVersion()));\n+                        cmd.add(String.valueOf(p.getMajorVersion()));\n+                        cmd.add(String.valueOf(p.getColorSpaceType()));\n+                        cmd.add(String.valueOf(p.getNumComponents()));\n+                    }\n+\n+                    OutputAnalyzer output = ProcessTools.executeTestJava(cmd);\n+                    output.shouldHaveExitValue(0).stdoutShouldBeEmpty()\n+                          .stderrShouldBeEmpty();\n+                }\n+            }\n+        } else {\n+            int csFrom = Integer.parseInt(args[0]);\n+            int csTo = Integer.parseInt(args[1]);\n+            var from = (ICC_ColorSpace) ColorSpace.getInstance(csFrom);\n+            var to = (ICC_ColorSpace) ColorSpace.getInstance(csTo);\n+\n+            BufferedImageOp op = new ColorConvertOp(from, to, null);\n+            \/\/ Note from.getProfile() and to.getProfile() are not loaded yet!\n+            op.filter(new BufferedImage(10, 10, TYPE_INT_RGB),\n+                      new BufferedImage(10, 10, TYPE_INT_RGB));\n+\n+            test(from.getProfile(), args, 2);\n+            test(to.getProfile(), args, 8);\n+        }\n+    }\n+\n+    private static void test(ICC_Profile profile, String[] args, int offset) {\n+        \/\/ Uncomment when JDK-8272860 is fixed\n+        \/\/ if (profile.getData() == null) {\n+        \/\/    throw new RuntimeException(\"Profile data is null\");\n+        \/\/ }\n+        if (profile.getPCSType() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong PCStype\");\n+        }\n+        if (profile.getProfileClass() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong ProfileClass\");\n+        }\n+        if (profile.getMinorVersion() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong MinorVersion\");\n+        }\n+        if (profile.getMajorVersion() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong MajorVersion\");\n+        }\n+        if (profile.getColorSpaceType() != Integer.parseInt(args[offset++])) {\n+            throw new RuntimeException(\"Wrong ColorSpaceType\");\n+        }\n+        if (profile.getNumComponents() != Integer.parseInt(args[offset])) {\n+            throw new RuntimeException(\"Wrong NumComponents\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/GetProfileDataAfterTransform.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/timeout=300\/othervm MTTest\n+ * @run main\/timeout=400\/othervm MTTest\n","filename":"test\/jdk\/java\/awt\/font\/NumericShaper\/MTTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main TestMethodFinder\n+ * @run main\/timeout=480 TestMethodFinder\n","filename":"test\/jdk\/java\/beans\/XMLDecoder\/8028054\/TestMethodFinder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED StdLibTest\n+ * @run testng\/othervm\/timeout=480 --enable-native-access=ALL-UNNAMED StdLibTest\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,4 @@\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run junit TestBufferStackStress2\n+ * @run junit\/timeout=480 TestBufferStackStress2\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng\/othervm\n+ * @run testng\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/foreign\/TestConcurrentClose.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @run main\/othervm\/timeout=10 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n+ * @run main\/othervm\/timeout=60 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n","filename":"test\/jdk\/java\/foreign\/TestDeadlock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng TestMismatch\n+ * @run testng\/timeout=480 TestMismatch\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run testng\/othervm -Xmx6G TestStringEncodingJumbo\n+ * @run testng\/othervm\/timeout=480 -Xmx6G TestStringEncodingJumbo\n","filename":"test\/jdk\/java\/foreign\/TestStringEncodingJumbo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm\/native\n+ * @run testng\/othervm\/native\/timeout=480\n","filename":"test\/jdk\/java\/foreign\/TestStubAllocFailure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm\/native -Xcheck:jni -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ * @run testng\/othervm\/native\/timeout=480 -Xcheck:jni -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED TestLoaderLookup\n+ * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED TestLoaderLookup\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,2 +24,11 @@\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import static jdk.test.lib.Utils.*;\n@@ -29,1 +38,1 @@\n- * @bug 8341975 8351435\n+ * @bug 8341975 8351435 8361613\n@@ -32,6 +41,6 @@\n- * @modules jdk.internal.le\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=UTF-8 DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=ISO-8859-1 DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=US-ASCII DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=foo DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le DefaultCharsetTest\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.JDKToolFinder\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run junit DefaultCharsetTest\n@@ -40,2 +49,24 @@\n-    @Test\n-    public void testDefaultCharset() {\n+    @BeforeAll\n+    static void checkExpectAvailability() {\n+        \/\/ check \"expect\" command availability\n+        var expect = Paths.get(\"\/usr\/bin\/expect\");\n+        Assumptions.assumeTrue(Files.exists(expect) && Files.isExecutable(expect),\n+            \"'\" + expect + \"' not found. Test ignored.\");\n+    }\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"UTF-8\", \"ISO-8859-1\", \"US-ASCII\", \"foo\", \"\"})\n+    void testDefaultCharset(String stdoutEncoding) throws Exception {\n+        \/\/ invoking \"expect\" command\n+        OutputAnalyzer oa = ProcessTools.executeProcess(\n+            \"expect\",\n+            \"-n\",\n+            TEST_SRC + \"\/defaultCharset.exp\",\n+            TEST_CLASSES,\n+            TEST_JDK + \"\/bin\/java\",\n+            \"-Dstdout.encoding=\" + stdoutEncoding,\n+            getClass().getName());\n+        oa.reportDiagnosticSummary();\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    public static void main(String... args) {\n@@ -45,7 +76,9 @@\n-        System.out.println(\"\"\"\n-                    stdout.encoding = %s\n-                    System.out.charset() = %s\n-                    System.console().charset() = %s\n-                \"\"\".formatted(stdoutEncoding, sysoutCharset.name(), consoleCharset.name()));\n-        assertEquals(consoleCharset, sysoutCharset,\n-            \"Charsets for System.out and Console differ for stdout.encoding: %s\".formatted(stdoutEncoding));\n+        System.out.printf(\"\"\"\n+                stdout.encoding = %s\n+                System.out.charset() = %s\n+                System.console().charset() = %s\n+            \"\"\", stdoutEncoding, sysoutCharset.name(), consoleCharset.name());\n+        if (!consoleCharset.equals(sysoutCharset)) {\n+            System.err.printf(\"Charsets for System.out and Console differ for stdout.encoding: %s%n\", stdoutEncoding);\n+            System.exit(-1);\n+        }\n","filename":"test\/jdk\/java\/io\/Console\/DefaultCharsetTest.java","additions":51,"deletions":18,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.io.File;\n@@ -29,0 +28,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.function.Predicate;\n@@ -30,0 +32,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -31,0 +34,4 @@\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.Test;\n+\n+import static jdk.test.lib.Utils.*;\n@@ -34,1 +41,1 @@\n- * @bug 8330276 8351435\n+ * @bug 8330276 8351435 8361613\n@@ -36,0 +43,1 @@\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n@@ -37,1 +45,5 @@\n- * @modules jdk.internal.le jdk.localedata\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.JDKToolFinder\n+ *        jdk.test.lib.process.ProcessTools\n+ * @modules jdk.localedata\n+ * @run junit LocaleTest\n@@ -40,2 +52,2 @@\n-    private static Calendar TODAY  = new GregorianCalendar(2024, Calendar.APRIL, 22);\n-    private static String FORMAT = \"%1$tY-%1$tB-%1$te %1$tA\";\n+    private static final Calendar TODAY = new GregorianCalendar(2024, Calendar.APRIL, 22);\n+    private static final String FORMAT = \"%1$tY-%1$tB-%1$te %1$tA\";\n@@ -45,1 +57,1 @@\n-    private static List<String> EXPECTED = List.of(\n+    private static final List<String> EXPECTED = List.of(\n@@ -56,25 +68,25 @@\n-    public static void main(String... args) throws Throwable {\n-        if (args.length == 0) {\n-            \/\/ no arg will launch the child process that actually perform tests\n-            var pb = ProcessTools.createTestJavaProcessBuilder(\n-                    \"-Djdk.console=jdk.internal.le\",\n-                    \"LocaleTest\", \"dummy\");\n-            var input = new File(System.getProperty(\"test.src\", \".\"), \"input.txt\");\n-            pb.redirectInput(input);\n-            var oa = ProcessTools.executeProcess(pb);\n-            if (oa.getExitValue() == -1) {\n-                System.out.println(\"System.console() returns null. Ignoring the test.\");\n-            } else {\n-                var output = oa.asLines();\n-                var resultText =\n-                    \"\"\"\n-                    Actual output: %s\n-                    Expected output: %s\n-                    \"\"\".formatted(output, EXPECTED);\n-                if (!output.equals(EXPECTED)) {\n-                    throw new RuntimeException(\"Standard out had unexpected strings:\\n\" + resultText);\n-                } else {\n-                    oa.shouldHaveExitValue(0);\n-                    System.out.println(\"Formatting with explicit Locale succeeded.\\n\" + resultText);\n-                }\n-            }\n+    @Test\n+    void testLocale() throws Exception {\n+        \/\/ check \"expect\" command availability\n+        var expect = Paths.get(\"\/usr\/bin\/expect\");\n+        Assumptions.assumeTrue(Files.exists(expect) && Files.isExecutable(expect),\n+            \"'\" + expect + \"' not found. Test ignored.\");\n+\n+        \/\/ invoking \"expect\" command\n+        OutputAnalyzer oa = ProcessTools.executeProcess(\n+            \"expect\",\n+            \"-n\",\n+            TEST_SRC + \"\/locale.exp\",\n+            TEST_CLASSES,\n+            TEST_JDK + \"\/bin\/java\",\n+            getClass().getName());\n+\n+        var stdout =\n+            oa.stdoutAsLines().stream().filter(Predicate.not(String::isEmpty)).toList();\n+        var resultText =\n+            \"\"\"\n+            Actual output: %s\n+            Expected output: %s\n+            \"\"\".formatted(stdout, EXPECTED);\n+        if (!stdout.equals(EXPECTED)) {\n+            throw new RuntimeException(\"Standard out had unexpected strings:\\n\" + resultText);\n@@ -82,11 +94,17 @@\n-            var con = System.console();\n-            if (con != null) {\n-                \/\/ tests these additional methods that take a Locale\n-                con.format(Locale.UK, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.printf(Locale.FRANCE, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readLine(Locale.GERMANY, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readPassword(Locale.of(\"es\"), FORMAT, TODAY);\n-                con.printf(\"\\n\");\n+            oa.shouldHaveExitValue(0);\n+            System.out.println(\"Formatting with explicit Locale succeeded.\\n\" + resultText);\n+        }\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        var con = System.console();\n+        if (con != null) {\n+            \/\/ tests these additional methods that take a Locale\n+            con.format(Locale.UK, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.printf(Locale.FRANCE, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readLine(Locale.GERMANY, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readPassword(Locale.of(\"es\"), FORMAT, TODAY);\n+            con.printf(\"\\n\");\n@@ -94,12 +112,11 @@\n-                \/\/ tests null locale\n-                con.format((Locale)null, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.printf((Locale)null, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readLine((Locale)null, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readPassword((Locale)null, FORMAT, TODAY);\n-            } else {\n-                \/\/ Exit with -1\n-                System.exit(-1);\n-            }\n+            \/\/ tests null locale\n+            con.format((Locale)null, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.printf((Locale)null, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readLine((Locale)null, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readPassword((Locale)null, FORMAT, TODAY);\n+        } else {\n+            \/\/ Exit with -1\n+            System.exit(-1);\n","filename":"test\/jdk\/java\/io\/Console\/LocaleTest.java","additions":71,"deletions":54,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8295803 8299689 8351435\n+ * @bug 8295803 8299689 8351435 8361613\n@@ -29,5 +29,4 @@\n- * @modules java.base\/java.io:+open\n- * @run main\/othervm ModuleSelectionTest java.base\n- * @run main\/othervm -Djdk.console=jdk.internal.le ModuleSelectionTest jdk.internal.le\n- * @run main\/othervm -Djdk.console=java.base ModuleSelectionTest java.base\n- * @run main\/othervm --limit-modules java.base ModuleSelectionTest java.base\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run junit ModuleSelectionTest\n@@ -39,0 +38,12 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static jdk.test.lib.Utils.*;\n@@ -41,0 +52,39 @@\n+    private static Stream<Arguments> options() {\n+        return Stream.of(\n+            Arguments.of(\"-Djdk.console=foo\", \"java.base\"),\n+            Arguments.of(\"-Djdk.console=java.base\", \"java.base\"),\n+            Arguments.of(\"-Djdk.console=jdk.internal.le\", \"jdk.internal.le\"),\n+            Arguments.of(\"--limit-modules java.base\", \"java.base\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"options\")\n+    void testNonTTY(String opts) throws Exception {\n+        opts = opts +\n+            \" --add-opens java.base\/java.io=ALL-UNNAMED ModuleSelectionTest null\";\n+        OutputAnalyzer output = ProcessTools.executeTestJava(opts.split(\" \"));\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"options\")\n+    void testTTY(String opts, String expected) throws Exception {\n+        \/\/ check \"expect\" command availability\n+        var expect = Paths.get(\"\/usr\/bin\/expect\");\n+        Assumptions.assumeTrue(Files.exists(expect) && Files.isExecutable(expect),\n+            \"'\" + expect + \"' not found. Test ignored.\");\n+\n+        opts = \"expect -n \" + TEST_SRC + \"\/moduleSelection.exp \" +\n+            TEST_CLASSES + \" \" +\n+            expected + \" \" +\n+            TEST_JDK + \"\/bin\/java\" +\n+            \" --add-opens java.base\/java.io=ALL-UNNAMED \"\n+            + opts;\n+        \/\/ invoking \"expect\" command\n+        OutputAnalyzer output = ProcessTools.executeProcess(opts.split(\" \"));\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0);\n+    }\n+\n@@ -52,4 +102,1 @@\n-        var expected = switch (args[0]) {\n-            case \"java.base\" -> istty ? \"java.base\" : \"null\";\n-            default -> args[0];\n-        };\n+        var expected = args[0];\n@@ -65,1 +112,1 @@\n-            System.out.printf(\"%s is the expected implementation. (tty: %s)\\n\", impl, istty);\n+            System.out.printf(\"%s is the expected implementation. (tty: %s)\\n\", actual, istty);\n","filename":"test\/jdk\/java\/io\/Console\/ModuleSelectionTest.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# simply invoking java under expect command\n+set classpath [lrange $argv 0 0]\n+set java [lrange $argv 1 1]\n+set stdoutProp [lrange $argv 2 2]\n+set clsname [lrange $argv 3 3]\n+eval spawn $java -classpath $classpath $stdoutProp $clsname\n+expect eof\n+set result [wait]\n+exit [lindex $result 3]\n","filename":"test\/jdk\/java\/io\/Console\/defaultCharset.exp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# simply invoking java under expect command\n+set classpath [lrange $argv 0 0]\n+set java [lrange $argv 1 1]\n+set clsname [lrange $argv 2 2]\n+eval spawn -noecho $java -classpath $classpath $clsname\n+\n+# sends CR 4 times (readLine x 2, readPassword x 2)\n+send \"\\r\"\n+send \"\\r\"\n+send \"\\r\"\n+send \"\\r\"\n+expect eof\n+set result [wait]\n+exit [lindex $result 3]\n","filename":"test\/jdk\/java\/io\/Console\/locale.exp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# simply invoking java under expect command\n+set classpath [lrange $argv 0 0]\n+set expected [lrange $argv 1 1]\n+set java [lrange $argv 2 2]\n+set opts [lrange $argv 3 end]\n+eval spawn $java $opts -classpath $classpath ModuleSelectionTest $expected\n+expect eof\n","filename":"test\/jdk\/java\/io\/Console\/moduleSelection.exp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm UnreferencedFISClosesFd\n+ * @run main\/othervm\/timeout=480 UnreferencedFISClosesFd\n","filename":"test\/jdk\/java\/io\/FileInputStream\/UnreferencedFISClosesFd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main\/othervm UnreferencedFOSClosesFd\n+ * @run main\/othervm\/timeout=480 UnreferencedFOSClosesFd\n","filename":"test\/jdk\/java\/io\/FileOutputStream\/UnreferencedFOSClosesFd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm UnreferencedRAFClosesFd\n+ * @run main\/othervm\/timeout=480 UnreferencedRAFClosesFd\n","filename":"test\/jdk\/java\/io\/RandomAccessFile\/UnreferencedRAFClosesFd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run main\/othervm --add-modules=ALL-SYSTEM FieldSetAccessibleTest\n+ * @run main\/othervm\/timeout=480 --add-modules=ALL-SYSTEM FieldSetAccessibleTest\n","filename":"test\/jdk\/java\/lang\/Class\/getDeclaredField\/FieldSetAccessibleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365203\n+ * @summary Tests guarding of ByteBuffers in ClassLoader::defineClass\n+ * @run junit TestGuardByteBuffer\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.util.HexFormat;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestGuardByteBuffer {\n+\n+    @Test\n+    void guardCrash() {\n+        final byte[] classBytes = getClassBytes(); \/\/ get bytes of a valid class\n+        final var cl = new ClassLoader() {\n+            void tryCrash() {\n+                var arena = Arena.ofConfined();\n+                var byteBuffer = arena.allocate(classBytes.length).asByteBuffer();\n+                \/\/ Close the arena underneath\n+                arena.close();\n+                \/\/ expected to always fail because the arena\n+                \/\/ from which the ByteBuffer was constructed\n+                \/\/ has been closed\n+                assertThrows(IllegalStateException.class,\n+                        () -> defineClass(null, byteBuffer, null));\n+            }\n+        };\n+        for (int i = 0; i < 10_000; i++) {\n+            cl.tryCrash();\n+        }\n+    }\n+\n+    private static byte[] getClassBytes() {\n+        \/\/ unused. this is here just for reference\n+        final String source = \"\"\"\n+                    public class NoOp {}\n+                \"\"\";\n+        \/\/ (externally) compiled content of the above \"source\", represented as hex\n+        final String classBytesHex = \"\"\"\n+                cafebabe00000044000d0a000200030700040c000500060100106a6176612f\n+                6c616e672f4f626a6563740100063c696e69743e0100032829560700080100\n+                044e6f4f70010004436f646501000f4c696e654e756d6265725461626c6501\n+                000a536f7572636546696c650100094e6f4f702e6a61766100210007000200\n+                0000000001000100050006000100090000001d00010001000000052ab70001\n+                b100000001000a000000060001000000010001000b00000002000c\n+                \"\"\";\n+\n+        return HexFormat.of().parseHex(classBytesHex.replaceAll(\"\\n\", \"\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/defineClass\/TestGuardByteBuffer.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n- * @bug 8305457 8342936 8351435 8344706\n+ * @bug 8305457 8342936 8351435 8344706 8361613\n@@ -56,1 +56,0 @@\n- * @modules jdk.internal.le\n@@ -81,16 +80,0 @@\n-        \/*\n-         * Unlike printTest, which tests a _default_ console that is normally\n-         * jdk.internal.org.jline.JdkConsoleProviderImpl, this test tests\n-         * jdk.internal.io.JdkConsoleImpl. Those console implementations operate\n-         * in different conditions and, thus, are tested separately.\n-         *\n-         * To test jdk.internal.io.JdkConsoleImpl one needs to ensure that both\n-         * conditions are met:\n-         *\n-         *   - a non-existent console provider is requested\n-         *   - isatty is true\n-         *\n-         * To achieve isatty, the test currently uses the EXPECT(1) Unix command,\n-         * which does not work for Windows. Later, a library like pty4j or JPty\n-         * might be used instead of EXPECT, to cover both Unix and Windows.\n-         *\/\n@@ -105,2 +88,0 @@\n-                    \"--enable-preview\",\n-                    \"-Djdk.console=gibberish\",\n@@ -133,1 +114,1 @@\n-        public void inputTestInteractive(String console, String prompt) throws Exception {\n+        public void inputTestInteractive(String prompt) throws Exception {\n@@ -141,3 +122,0 @@\n-            command.add(\"--enable-preview\");\n-            if (console != null)\n-                command.add(\"-Djdk.console=\" + console);\n@@ -155,3 +133,2 @@\n-            \/\/ cross product: consoles x prompts\n-            return Stream.of(\"jdk.internal.le\", \"gibberish\").flatMap(console -> Stream.of(null, \"?\", \"%s\", PROMPT_NONE)\n-                    .map(prompt -> new String[]{console, prompt}).map(Arguments::of));\n+            \/\/ prompts\n+            return Stream.of(null, \"?\", \"%s\", PROMPT_NONE).map(Arguments::of);\n@@ -161,21 +138,0 @@\n-    @ParameterizedTest\n-    @ValueSource(strings = {\"println\", \"print\"})\n-    public void printTest(String mode) throws Exception {\n-        var file = Path.of(System.getProperty(\"test.src\", \".\"), \"Output.java\")\n-                .toAbsolutePath().toString();\n-        var pb = ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", \"--enable-preview\", file, mode);\n-        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n-        assertEquals(0, output.getExitValue());\n-        assertTrue(output.getStderr().isEmpty());\n-        output.reportDiagnosticSummary();\n-        String out = output.getStdout();\n-        \/\/ The first half of the output is produced by Console, the second\n-        \/\/ half is produced by IO: those halves must match.\n-        \/\/ Executing Console and IO in the same VM (as opposed to\n-        \/\/ consecutive VM runs, which are cleaner) to be able to compare string\n-        \/\/ representation of objects.\n-        assertFalse(out.isBlank());\n-        assertEquals(out.substring(0, out.length() \/ 2),\n-                out.substring(out.length() \/ 2));\n-    }\n-\n@@ -196,1 +152,1 @@\n-        var pb = ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", \"--enable-preview\", file.toString());\n+        var pb = ProcessTools.createTestJavaProcessBuilder(file.toString());\n","filename":"test\/jdk\/java\/lang\/IO\/IO.java","additions":5,"deletions":49,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run junit IntegralPowTest\n+ * @run junit\/timeout=480 IntegralPowTest\n","filename":"test\/jdk\/java\/lang\/Math\/IntegralPowTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include <errno.h>\n@@ -25,0 +26,3 @@\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys\/resource.h>\n@@ -27,0 +31,2 @@\n+static jint limit_num_fds();\n+\n@@ -29,0 +35,7 @@\n+  \/\/ Lower the number of possible open files to make the test go faster\n+  jint ret = limit_num_fds();\n+  if (ret != 0) {\n+    fprintf(stderr, \"Failed to limit number of fds: %s\", strerror(errno));\n+    return ret;\n+  }\n+\n@@ -32,0 +45,1 @@\n+    fprintf(stderr, \"Failed to open file: %s\", strerror(errno));\n@@ -34,0 +48,1 @@\n+\n@@ -37,0 +52,24 @@\n+\n+static jint limit_num_fds() {\n+  struct rlimit rl;\n+\n+  \/\/ Fetch the current limit\n+  int ret = getrlimit(RLIMIT_NOFILE, &rl);\n+  if (ret != 0) {\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Use a lower value unless it is already low\n+  rlim_t limit = 100;\n+  if (limit < rl.rlim_cur) {\n+    rl.rlim_cur = limit;\n+  }\n+\n+  \/\/ Lower the value\n+  int ret2 = setrlimit(RLIMIT_NOFILE, &rl);\n+  if (ret2 != 0) {\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/FDLeakTest\/libFDLeaker.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=POSIX_SPAWN UnblockSignals\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=POSIX_SPAWN -Xrs UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=POSIX_SPAWN UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=POSIX_SPAWN -Xrs UnblockSignals\n@@ -44,2 +44,2 @@\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=FORK UnblockSignals\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=FORK -Xrs UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=FORK UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=FORK -Xrs UnblockSignals\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/UnblockSignals.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=posix_spawn\n+ * @bug 8364611\n+ * @summary Check that childs start with SIG_DFL as SIGPIPE disposition\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=posix_spawn -agentlib:ChangeSignalDisposition TestChildSignalDisposition\n+ *\/\n+\n+\/**\n+ * @test id=fork\n+ * @bug 8364611\n+ * @summary Check that childs start with SIG_DFL as SIGPIPE disposition\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=fork -agentlib:ChangeSignalDisposition TestChildSignalDisposition\n+ *\/\n+\n+\/**\n+ * @test id=vfork\n+ * @bug 8364611\n+ * @summary Check that childs start with SIG_DFL as SIGPIPE disposition\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=vfork -agentlib:ChangeSignalDisposition TestChildSignalDisposition\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+public class TestChildSignalDisposition {\n+    \/\/ This test has two native parts:\n+    \/\/ - a library injected into the JVM with -agentlib changes signal disposition of the VM process for SIGPIPE to\n+    \/\/   SIG_IGN\n+    \/\/ - a small native executable that prints out, in its main function, all signal handler dispositions, to be executed\n+    \/\/   as a child process.\n+    \/\/\n+    \/\/ What should happen: In child process, SIGPIPE should be set to default.\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder(\"PrintSignalDisposition\");\n+        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+        output.shouldHaveExitValue(0);\n+        output.shouldNotMatch(\"SIGPIPE: +ignore\");\n+        output.shouldNotMatch(\"SIGPIPE: +block\");\n+        output.shouldMatch(\"SIGPIPE: +default\");\n+        output.reportDiagnosticSummary();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/childSignalDisposition\/TestChildSignalDisposition.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+#include \"jvmti.h\"\n+#include <signal.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+\n+static const struct { int sig; const char* name; } signals[] = {\n+    { SIGABRT, \"SIGABRT\" }, { SIGALRM, \"SIGALRM\" }, { SIGBUS, \"SIGBUS\" }, { SIGCHLD, \"SIGCHLD\" }, { SIGCONT, \"SIGCONT\" },\n+    { SIGFPE, \"SIGFPE\" }, { SIGHUP, \"SIGHUP\" }, { SIGILL, \"SIGILL\" }, { SIGINT, \"SIGINT\" }, { SIGKILL, \"SIGKILL\" },\n+    { SIGPIPE, \"SIGPIPE\" }, { SIGQUIT, \"SIGQUIT\" }, { SIGSEGV, \"SIGSEGV\" }, { SIGSTOP, \"SIGSTOP\" }, { SIGTERM, \"SIGTERM\" },\n+    { SIGTSTP, \"SIGTSTP\" }, { SIGTTIN, \"SIGTTIN\" }, { SIGTTOU, \"SIGTTOU\" }, { SIGUSR1, \"SIGUSR1\" }, { SIGUSR2, \"SIGUSR2\" },\n+#ifdef SIGPOLL\n+    { SIGPOLL, \"SIGPOLL\" },\n+#endif\n+    { SIGPROF, \"SIGPROF\" }, { SIGSYS, \"SIGSYS\" }, { SIGTRAP, \"SIGTRAP\" }, { SIGURG, \"SIGURG\" }, { SIGVTALRM, \"SIGVTALRM\" },\n+    { SIGXCPU, \"SIGXCPU\" }, { SIGXFSZ, \"SIGXFSZ\" }, { -1, NULL }\n+};\n+\n+int main(int argc, char** argv) {\n+\n+    printf(\"PID: %d\\n\", getpid());\n+\n+    sigset_t current_mask;\n+    sigemptyset(&current_mask);\n+    if (sigprocmask(SIG_BLOCK \/* ignored *\/, NULL, &current_mask) != 0) {\n+        printf(\"sigprocmask %d\\n\", errno);\n+        return -1;\n+    }\n+\n+    for (int n = 0; signals[n].sig != -1; n++) {\n+        printf(\"%s: \", signals[n].name);\n+        if (sigismember(&current_mask, signals[n].sig)) {\n+            printf(\"blocked \");\n+        }\n+        struct sigaction act;\n+        if (sigaction(signals[n].sig, NULL, &act) != 0) {\n+            printf(\"sigaction %d\\n\", errno);\n+            printf(\"\\n\");\n+            continue;\n+        }\n+        const void* const handler = (act.sa_flags & SA_SIGINFO ?\n+                                    (void*)act.sa_sigaction : (void*)act.sa_handler);\n+        if (handler == (void*)SIG_DFL) {\n+            printf(\"default \");\n+        } else if (handler == (void*)SIG_IGN) {\n+            printf(\"ignore \");\n+        } else if (handler == (void*)SIG_HOLD) {\n+            printf(\"hold \");\n+        } else {\n+            printf(\"%p \", handler);\n+        }\n+        printf(\"%X\\n\", act.sa_flags);\n+    }\n+\n+    return 0;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/childSignalDisposition\/exePrintSignalDisposition.c","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+#include \"jvmti.h\"\n+#include <signal.h>\n+#include <stdio.h>\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+\n+  if (signal(SIGPIPE, SIG_IGN) != SIG_ERR) {\n+    printf(\"changed signal disposition for SIGPIPE to SIG_IGN\\n\");\n+  } else {\n+    printf(\"FAILED to change signal disposition for SIGPIPE to SIG_IGN (%d)\\n\", errno);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/childSignalDisposition\/libChangeSignalDisposition.c","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run testng\/othervm -Xint -DtestUnused=true LocalsAndOperands\n- * @run testng\/othervm -Xcomp LocalsAndOperands\n+ * @run testng\/othervm\/timeout=480 -Xint -DtestUnused=true LocalsAndOperands\n+ * @run testng\/othervm\/timeout=480 -Xcomp LocalsAndOperands\n@@ -38,1 +38,1 @@\n- * @run testng\/othervm -Xcomp -XX:-TieredCompilation LocalsAndOperands\n+ * @run testng\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation LocalsAndOperands\n","filename":"test\/jdk\/java\/lang\/StackWalker\/LocalsAndOperands.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8139688\n+ * @bug 8139688 8362376\n@@ -90,0 +90,4 @@\n+\n+            \/\/ Test values near 0.5*ln*(2) and 1.5*ln(2) to check refactoring\n+            {0.34657359027997275,                  1.4142135623730951},\n+            {1.0397207708399183,                   2.828427124746191},\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExpTests.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8136874\n+ * @bug 8136874 8362376\n@@ -286,0 +286,15 @@\n+            \/\/ Check refactoring, abs(y) < 2^31, x < sqrt(3\/2), x < sqrt(3)\n+            {1.2, \/\/ x < sqrt(3\/2)\n+             5.0,\n+             2.4883199999999994\n+            },\n+\n+            {1.4142135623730951, \/\/ sqrt(3\/2) < x < sqrt(3)\n+             5.0,\n+             5.656854249492382\n+            },\n+\n+            {2.23606797749979, \/\/ x > sqrt(3)\n+             5.0,\n+             55.901699437494756\n+            },\n","filename":"test\/jdk\/java\/lang\/StrictMath\/PowTests.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,3 @@\n- * @run junit\/othervm -XX:+CompactStrings -Xmx8g MaxSizeUTF16String\n- * @run junit\/othervm -XX:-CompactStrings -Xmx8g MaxSizeUTF16String\n- * @run junit\/othervm -Xcomp -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm\/timeout=480 -XX:+CompactStrings -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm\/timeout=480 -XX:-CompactStrings -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm\/timeout=480 -Xcomp -Xmx8g MaxSizeUTF16String\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/MaxSizeUTF16String.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8286287 8288589\n- * @summary Tests for *NoRepl() shared secret methods.\n- * @run testng NoReplTest\n- * @modules jdk.charsets\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.charset.CharacterCodingException;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.util.HexFormat;\n-import static java.nio.charset.StandardCharsets.UTF_16;\n-\n-import org.testng.annotations.Test;\n-\n-@Test\n-public class NoReplTest {\n-    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n-    private final static String MALFORMED_WINDOWS_1252 = \"\\u0080\\u041e\";\n-    private final static Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n-\n-    \/**\n-     * Verifies newStringNoRepl() throws a CharacterCodingException.\n-     * The method is invoked by `Files.readString()` method.\n-     *\/\n-    @Test\n-    public void newStringNoReplTest() throws IOException {\n-        var f = Files.createTempFile(null, null);\n-        try (var fos = Files.newOutputStream(f)) {\n-            fos.write(MALFORMED_UTF16);\n-            var read = Files.readString(f, UTF_16);\n-            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n-                    HexFormat.of()\n-                            .withPrefix(\"x\")\n-                            .withUpperCase()\n-                            .formatHex(read.getBytes(UTF_16)));\n-        } catch (CharacterCodingException cce) {\n-            \/\/ success\n-        } finally {\n-            Files.delete(f);\n-        }\n-    }\n-\n-    \/**\n-     * Verifies getBytesNoRepl() throws a CharacterCodingException.\n-     * The method is invoked by `Files.writeString()` method.\n-     *\/\n-    @Test\n-    public void getBytesNoReplTest() throws IOException {\n-        var f = Files.createTempFile(null, null);\n-        try {\n-            Files.writeString(f, MALFORMED_WINDOWS_1252, WINDOWS_1252);\n-            throw new RuntimeException(\"Exception should be thrown\");\n-        } catch (CharacterCodingException cce) {\n-            \/\/ success\n-        } finally {\n-            Files.delete(f);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/String\/NoReplTest.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8286287 8288589\n+ * @summary Tests for *OrThrow() shared secret methods.\n+ * @run testng OrThrowTest\n+ * @modules jdk.charsets\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.util.HexFormat;\n+import static java.nio.charset.StandardCharsets.UTF_16;\n+\n+import org.testng.annotations.Test;\n+\n+@Test\n+public class OrThrowTest {\n+    private final static byte[] MALFORMED_UTF16 = {(byte)0x00, (byte)0x20, (byte)0x00};\n+    private final static String MALFORMED_WINDOWS_1252 = \"\\u0080\\u041e\";\n+    private final static Charset WINDOWS_1252 = Charset.forName(\"windows-1252\");\n+\n+    \/**\n+     * Verifies {@code uncheckedNewStringOrThrow()} throws a {@link CharacterCodingException}.\n+     * The method is invoked by {@code Files.readString()} method.\n+     *\/\n+    @Test\n+    public void uncheckedNewStringOrThrowTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try (var fos = Files.newOutputStream(f)) {\n+            fos.write(MALFORMED_UTF16);\n+            var read = Files.readString(f, UTF_16);\n+            throw new RuntimeException(\"Exception should be thrown for a malformed input. Bytes read: \" +\n+                    HexFormat.of()\n+                            .withPrefix(\"x\")\n+                            .withUpperCase()\n+                            .formatHex(read.getBytes(UTF_16)));\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies {@code uncheckedGetBytesOrThrow()} throws a {@link CharacterCodingException}.\n+     * The method is invoked by {@code Files.writeString()} method.\n+     *\/\n+    @Test\n+    public void uncheckedGetBytesOrThrowTest() throws IOException {\n+        var f = Files.createTempFile(null, null);\n+        try {\n+            Files.writeString(f, MALFORMED_WINDOWS_1252, WINDOWS_1252);\n+            throw new RuntimeException(\"Exception should be thrown\");\n+        } catch (CharacterCodingException cce) {\n+            \/\/ success\n+        } finally {\n+            Files.delete(f);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/OrThrowTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -36,3 +36,3 @@\n- * @run testng\/othervm -XX:+CompactStrings CompactStringBuilder\n- * @run testng\/othervm -XX:-CompactStrings CompactStringBuilder\n- * @run testng\/othervm -Xcomp CompactStringBuilder\n+ * @run testng\/othervm\/timeout=480 -XX:+CompactStrings CompactStringBuilder\n+ * @run testng\/othervm\/timeout=480 -XX:-CompactStrings CompactStringBuilder\n+ * @run testng\/othervm\/timeout=480 -Xcomp CompactStringBuilder\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/CompactStringBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CancelTimerWithContention.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.stream.IntStream;\n@@ -80,4 +81,6 @@\n-            ThreadFactory factory = Thread.ofVirtual().factory();\n-            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n-                for (int i = 0; i < 100; i++) {\n-                    executor.submit(() -> { });\n+            try {\n+                List<Thread> threads = IntStream.range(0, 100)\n+                        .mapToObj(_ -> Thread.startVirtualThread(() -> { }))\n+                        .toList();\n+                for (Thread t : threads) {\n+                    t.join();\n@@ -85,1 +88,0 @@\n-                Thread.sleep(1000); \/\/ give time for thread end events to be recorded\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit\/othervm MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 MiscMonitorTests\n@@ -38,1 +38,1 @@\n- * @run junit\/othervm -Xint MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xint MiscMonitorTests\n@@ -46,1 +46,1 @@\n- * @run junit\/othervm -Xcomp MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xcomp MiscMonitorTests\n@@ -54,1 +54,1 @@\n- * @run junit\/othervm -Xcomp -XX:TieredStopAtLevel=3 MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:TieredStopAtLevel=3 MiscMonitorTests\n@@ -63,1 +63,1 @@\n- * @run junit\/othervm -Xcomp -XX:-TieredCompilation MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation MiscMonitorTests\n@@ -71,1 +71,1 @@\n- * @run junit\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+FullGCALot -XX:FullGCALotInterval=1000 MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+FullGCALot -XX:FullGCALotInterval=1000 MiscMonitorTests\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MiscMonitorTests.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -36,1 +36,1 @@\n- * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xint --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm\/native -Xcomp --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -50,1 +50,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -57,1 +57,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorEnterExit\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterExit.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -36,1 +36,1 @@\n- * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xint --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm\/native -Xcomp --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -50,1 +50,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -57,1 +57,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit Parking\n+ * @run junit\/timeout=480 Parking\n@@ -36,1 +36,1 @@\n- * @run junit\/othervm -Xint Parking\n+ * @run junit\/othervm\/timeout=480 -Xint Parking\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm -Xcomp Parking\n+ * @run junit\/othervm\/timeout=480 -Xcomp Parking\n@@ -50,1 +50,1 @@\n- * @run junit\/othervm -Xcomp -XX:-TieredCompilation Parking\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation Parking\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Parking.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n+ * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/RetryMonitorEnterWhenPinned.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm\/timeout=200\/native --enable-native-access=ALL-UNNAMED Starvation 100000\n+ * @run main\/othervm\/timeout=800\/native --enable-native-access=ALL-UNNAMED Starvation 100000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Starvation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED SynchronizedNative\n@@ -39,1 +39,1 @@\n- * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 -Xint --enable-native-access=ALL-UNNAMED SynchronizedNative\n@@ -47,1 +47,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED SynchronizedNative\n@@ -55,1 +55,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED SynchronizedNative\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/SynchronizedNative.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED ThreadPollOnYield\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED ThreadPollOnYield\n@@ -39,1 +39,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED -Xcomp -XX:-TieredCompilation\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED -Xcomp -XX:-TieredCompilation\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadPollOnYield.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=300 GetStackTraceALotWhenBlocking 100000\n+ * @run main\/othervm\/timeout=1200 GetStackTraceALotWhenBlocking 100000\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\/timeout=300 GetStackTraceALotWhenBlocking 50000\n+ * @run main\/othervm\/timeout=1200 GetStackTraceALotWhenBlocking 50000\n@@ -56,2 +56,2 @@\n-        if (Platform.isOSX() && Platform.isX64()) {\n-            \/\/ reduced iterations on macosx-x64\n+        if (Platform.isOSX()) {\n+            \/\/ reduced iterations on macosx\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenBlocking.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n-        if (Platform.isOSX() && Platform.isX64()) {\n-            \/\/ reduced iterations on macosx-x64\n+        if (Platform.isOSX()) {\n+            \/\/ reduced iterations on macosx\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenPinned.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main GetStackTraceALotWithTimedWait 100000\n+ * @run main\/timeout=480 GetStackTraceALotWithTimedWait 100000\n@@ -34,1 +34,1 @@\n- * @run main GetStackTraceALotWithTimedWait 50000\n+ * @run main\/timeout=480 GetStackTraceALotWithTimedWait 50000\n@@ -91,1 +91,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWithTimedWait.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=300 ParkALot 300000\n+ * @run main\/othervm\/timeout=1200 ParkALot 300000\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/timeout=300 ParkALot 100000\n+ * @run main\/othervm\/timeout=1200 ParkALot 100000\n@@ -52,2 +52,2 @@\n-        if (Platform.isOSX() && Platform.isX64()) {\n-            \/\/ reduced iterations on macosx-x64\n+        if (Platform.isOSX()) {\n+            \/\/ reduced iterations on macosx\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/ParkALot.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED PinALot 500000\n+ * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED PinALot 500000\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/native\/timeout=300 --enable-native-access=ALL-UNNAMED PinALot 200000\n+ * @run main\/othervm\/native\/timeout=1200 --enable-native-access=ALL-UNNAMED PinALot 200000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PinALot.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=400 -Xmx1500m Skynet\n+ * @run main\/othervm\/timeout=1600 -Xmx1500m Skynet\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=400 -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=1600 -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=300 Skynet100kWithMonitors 50\n+ * @run main\/othervm\/timeout=1200 Skynet100kWithMonitors 50\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/timeout=300 Skynet100kWithMonitors 10\n+ * @run main\/othervm\/timeout=1200 Skynet100kWithMonitors 10\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet100kWithMonitors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main SleepALot 500000\n+ * @run main\/timeout=480 SleepALot 500000\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 SleepALot 200000\n+ * @run main\/othervm\/timeout=1200 SleepALot 200000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/SleepALot.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng LoaderLeakTest\n+ * @run testng\/timeout=480 LoaderLeakTest\n","filename":"test\/jdk\/java\/lang\/annotation\/LoaderLeakTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng ConvertTest\n- *\/\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.ConstantBootstraps;\n-import java.math.BigInteger;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class ConvertTest {\n-\n-    @DataProvider\n-    public static Object[][] cceInputs() {\n-        return new Object[][]{\n-            { void.class, null },\n-            { Integer.class, \"a\" },\n-            { int.class, BigInteger.ZERO },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"cceInputs\", expectedExceptions = ClassCastException.class)\n-    public void testBadConversion(Class<?> dstType, Object value) {\n-        ConstantBootstraps.explicitCast(null, null, dstType, value);\n-    }\n-\n-    @DataProvider\n-    public static Object[][] goodInputs() {\n-        Object o = new Object();\n-        return new Object[][]{\n-            { Object.class, null, null },\n-            { Object.class, o, o },\n-            { String.class, \"abc\", \"abc\" },\n-            { short.class, 10, (short) 10 },\n-            { int.class, (short) 10, 10 },\n-            { boolean.class, 1, true },\n-            { boolean.class, 2, false },\n-            { int.class, true, 1 },\n-            { int.class, false, 0 },\n-            { int.class, 10, 10 },\n-            { Integer.class, 10, 10 },\n-            { Object.class, 10, 10 },\n-            { Number.class, 10, 10 },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"goodInputs\")\n-    public void testSuccess(Class<?> dstType, Object value, Object expected) {\n-        Object actual = ConstantBootstraps.explicitCast(null, null, dstType, value);\n-        assertEquals(actual, expected);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/constant\/ConvertTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+ * @bug 8366028\n@@ -38,0 +39,2 @@\n+\n+import static org.testng.Assert.assertThrows;\n@@ -221,0 +224,18 @@\n+    @DataProvider(name = \"badMethodDescriptorStrings\")\n+    public String[] badMethodDescriptorStrings() {\n+        return new String[] {\n+                \"(I)\",\n+                \"(V)V\",\n+                \"([V)V\",\n+                \"(\" + \"[\".repeat(256) + \"J)I\",\n+                \"(java\/lang\/Object)V\",\n+                \"()java\/lang\/Object\",\n+        };\n+    }\n+\n+    \/\/ JDK-8366028\n+    @Test(dataProvider = \"badMethodDescriptorStrings\", expectedExceptions = IllegalArgumentException.class)\n+    public void testFromMethodDescriptorStringNegatives(String desc) {\n+        MethodType.fromMethodDescriptorString(desc, null);\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodTypeTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n-  * @run main TestLambdaFormCustomization\n-  * @run main\/othervm -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD=0 TestLambdaFormCustomization\n+  * @run main\/timeout=480 TestLambdaFormCustomization\n+  * @run main\/othervm\/timeout=480 -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD=0 TestLambdaFormCustomization\n","filename":"test\/jdk\/java\/lang\/invoke\/TestLambdaFormCustomization.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8186046 8195694\n+ * @bug 8186046 8195694 8241100 8364751\n@@ -34,0 +34,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -244,0 +245,41 @@\n+\n+    @DataProvider\n+    public static Object[][] cceCasts() {\n+        return new Object[][]{\n+                { void.class, null },\n+                { Integer.class, \"a\" },\n+                { int.class, BigInteger.ZERO },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"cceCasts\", expectedExceptions = ClassCastException.class)\n+    public void testBadCasts(Class<?> dstType, Object value) {\n+        ConstantBootstraps.explicitCast(null, null, dstType, value);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] validCasts() {\n+        Object o = new Object();\n+        return new Object[][]{\n+                { Object.class, null, null },\n+                { Object.class, o, o },\n+                { String.class, \"abc\", \"abc\" },\n+                { short.class, 10, (short) 10 },\n+                { int.class, (short) 10, 10 },\n+                { boolean.class, 1, true },\n+                { boolean.class, 2, false },\n+                { int.class, true, 1 },\n+                { int.class, false, 0 },\n+                { int.class, 10, 10 },\n+                { Integer.class, 10, 10 },\n+                { Object.class, 10, 10 },\n+                { Number.class, 10, 10 },\n+                { char.class, null, (char) 0 }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"validCasts\")\n+    public void testSuccessfulCasts(Class<?> dstType, Object value, Object expected) {\n+        Object actual = ConstantBootstraps.explicitCast(null, null, dstType, value);\n+        assertEquals(actual, expected);\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/ConstantBootstrapsTest.java","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm\/timeout=180 IllegalArgumentsTest\n+ * @run testng\/othervm\/timeout=720 IllegalArgumentsTest\n","filename":"test\/jdk\/java\/lang\/reflect\/IllegalArgumentsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm -Xmx4g LargeValueExceptions\n+ * @run testng\/othervm\/timeout=480 -Xmx4g LargeValueExceptions\n","filename":"test\/jdk\/java\/math\/BigInteger\/LargeValueExceptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-        lst.add(\"myCookie2=bar; path=\/dir; expires=Tue, 19 Aug 2025 16:00:00 GMT\");\n-        lst.add(\"myCookie3=test; path=\/dir; expires=Tue Aug 19 2025 16:00:00 GMT-0100\");\n+        lst.add(\"myCookie2=bar; path=\/dir; expires=Fri, 19 Aug 4242 16:00:00 GMT\");\n+        lst.add(\"myCookie3=test; path=\/dir; expires=Fri Aug 19 4242 16:00:00 GMT-0100\");\n@@ -67,1 +67,2 @@\n-            fail(\"Should have 5 cookies. Got only \"+ cookies.size() + \", expires probably didn't parse correctly\");\n+            fail(\"unexpected cookies: \" + cookies + \", should have 5 cookies. Got only \"\n+                    + cookies.size() + \", expires probably didn't parse correctly\");\n","filename":"test\/jdk\/java\/net\/CookieHandler\/B6644726.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm UnreferencedDatagramSockets\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets\n+ * @run main\/othervm\/timeout=480 UnreferencedDatagramSockets\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/UnreferencedDatagramSockets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,0 @@\n-\n-\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackModeIPv4.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true UnreferencedMulticastSockets\n- * @run main\/othervm UnreferencedMulticastSockets\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true UnreferencedMulticastSockets\n+ * @run main\/othervm\/timeout=480 UnreferencedMulticastSockets\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/UnreferencedMulticastSockets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @run main\/othervm UnreferencedSockets\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true UnreferencedSockets\n+ * @run main\/othervm\/timeout=480 UnreferencedSockets\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true UnreferencedSockets\n","filename":"test\/jdk\/java\/net\/ServerSocket\/UnreferencedSockets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main CloseAvailable\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true CloseAvailable\n+ * @run main\/timeout=480 CloseAvailable\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true CloseAvailable\n","filename":"test\/jdk\/java\/net\/Socket\/CloseAvailable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n- * @run testng\/othervm AsFileDownloadTest\n+ * @run testng\/othervm\/timeout=480 AsFileDownloadTest\n","filename":"test\/jdk\/java\/net\/httpclient\/AsFileDownloadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n- * @run testng\/othervm -Djdk.internal.httpclient.debug=true BufferingSubscriberTest\n+ * @run testng\/othervm\/timeout=480 -Djdk.internal.httpclient.debug=true BufferingSubscriberTest\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferingSubscriberTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,2 @@\n- * @run main\/othervm  CancelledResponse\n- * @run main\/othervm  CancelledResponse SSL\n+ * @run main\/othervm\/timeout=480 CancelledResponse\n+ * @run main\/othervm\/timeout=480 CancelledResponse SSL\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelledResponse.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,708 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verifies `HttpRequest.BodyPublishers::ofFileChannel`\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit FileChannelPublisherTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpResponse.BodyHandlers.discarding;\n+import static java.net.http.HttpResponse.BodyHandlers.ofInputStream;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FileChannelPublisherTest {\n+\n+    private static final String CLASS_NAME = FileChannelPublisherTest.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static final int DEFAULT_BUFFER_SIZE = Utils.getBuffer().capacity();\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    private static final HttpClient CLIENT = HttpClient.newBuilder().sslContext(SSL_CONTEXT).proxy(NO_PROXY).build();\n+\n+    private static final ExecutorService EXECUTOR = Executors.newCachedThreadPool();\n+\n+    private static final ServerRequestPair\n+            HTTP1 = ServerRequestPair.of(Version.HTTP_1_1, false),\n+            HTTPS1 = ServerRequestPair.of(Version.HTTP_1_1, true),\n+            HTTP2 = ServerRequestPair.of(Version.HTTP_2, false),\n+            HTTPS2 = ServerRequestPair.of(Version.HTTP_2, true);\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private record ServerRequestPair(\n+            String serverName,\n+            HttpTestServer server,\n+            BlockingQueue<byte[]> serverReadRequestBodyBytes,\n+            HttpRequest.Builder requestBuilder,\n+            boolean secure) {\n+\n+        private static CountDownLatch SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+\n+        private static CountDownLatch SERVER_READ_PERMISSION = null;\n+\n+        private static ServerRequestPair of(Version version, boolean secure) {\n+\n+            \/\/ Create the server\n+            SSLContext sslContext = secure ? SSL_CONTEXT : null;\n+            HttpTestServer server = createServer(version, sslContext);\n+            String serverName = secure ? version.toString().replaceFirst(\"_\", \"S_\") : version.toString();\n+\n+            \/\/ Add the handler\n+            String handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n+            BlockingQueue<byte[]> serverReadRequestBodyBytes =\n+                    addRequestBodyConsumingServerHandler(serverName, server, handlerPath);\n+\n+            \/\/ Create the request builder\n+            String requestUriScheme = secure ? \"https\" : \"http\";\n+            \/\/ `x` suffix in the URI is not a typo, but ensures that *only* the parent handler path is matched\n+            URI requestUri = URI.create(\"%s:\/\/%s%sx\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n+            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(requestUri).version(version);\n+\n+            \/\/ Create the pair\n+            ServerRequestPair pair = new ServerRequestPair(serverName, server, serverReadRequestBodyBytes, requestBuilder, secure);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", pair, server.serverAuthority());\n+\n+            return pair;\n+\n+        }\n+\n+        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+            try {\n+                \/\/ The default HTTP\/1.1 test server processes requests sequentially.\n+                \/\/ This causes a deadlock for concurrent tests such as `testSlicedUpload()`.\n+                \/\/ Hence, explicitly providing a multithreaded executor for HTTP\/1.1.\n+                ExecutorService executor = Version.HTTP_1_1.equals(version) ? EXECUTOR : null;\n+                return HttpTestServer.create(version, sslContext, executor);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static BlockingQueue<byte[]> addRequestBodyConsumingServerHandler(\n+                String serverName, HttpTestServer server, String handlerPath) {\n+            BlockingQueue<byte[]> readRequestBodyBytes = new LinkedBlockingQueue<>();\n+            HttpTestHandler handler = exchange -> {\n+                \/\/ `HttpTestExchange::toString` changes on failure, pin it\n+                String exchangeName = exchange.toString();\n+                try (exchange) {\n+\n+                    \/\/ Discard `HEAD` requests used for initial connection admission\n+                    if (\"HEAD\".equals(exchange.getRequestMethod())) {\n+                        exchange.sendResponseHeaders(200, -1L);\n+                        return;\n+                    }\n+\n+                    signalServerRequestReceived(serverName, exchangeName);\n+                    awaitServerReadPermission(serverName, exchangeName);\n+\n+                    LOGGER.log(\"Server[%s] is reading the request body (exchange=%s)\", serverName, exchangeName);\n+                    byte[] requestBodyBytes = exchange.getRequestBody().readAllBytes();\n+                    LOGGER.log(\"Server[%s] has read %s bytes (exchange=%s)\", serverName, requestBodyBytes.length, exchangeName);\n+                    readRequestBodyBytes.add(requestBodyBytes);\n+\n+                    LOGGER.log(\"Server[%s] is writing the response (exchange=%s)\", serverName, exchangeName);\n+                    exchange.sendResponseHeaders(200, requestBodyBytes.length);\n+                    exchange.getResponseBody().write(requestBodyBytes);\n+\n+                } catch (Throwable exception) {\n+                    LOGGER.log(\n+                            \"Server[%s] failed to process the request (exchange=%s)\".formatted(serverName, exception),\n+                            exception);\n+                    readRequestBodyBytes.add(new byte[0]);\n+                } finally {\n+                    LOGGER.log(\"Server[%s] completed processing the request (exchange=%s)\", serverName, exchangeName);\n+                }\n+            };\n+            server.addHandler(handler, handlerPath);\n+            return readRequestBodyBytes;\n+        }\n+\n+        private static void signalServerRequestReceived(String serverName, String exchangeName) {\n+            if (SERVER_REQUEST_RECEIVED_SIGNAL != null) {\n+                LOGGER.log(\"Server[%s] is signaling that the request is received (exchange=%s)\", serverName, exchangeName);\n+                SERVER_REQUEST_RECEIVED_SIGNAL.countDown();\n+            }\n+        }\n+\n+        private static void awaitServerReadPermission(String serverName, String exchangeName) {\n+            if (SERVER_READ_PERMISSION != null) {\n+                LOGGER.log(\"Server[%s] is waiting for the read permission (exchange=%s)\", serverName, exchangeName);\n+                try {\n+                    SERVER_READ_PERMISSION.await();\n+                } catch (InterruptedException ie) {\n+                    Thread.currentThread().interrupt();     \/\/ Restore the `interrupted` flag\n+                    throw new RuntimeException(ie);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return serverName;\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void shutDown() {\n+        LOGGER.log(\"Closing the client\");\n+        CLIENT.close();\n+        LOGGER.log(\"Closing servers\");\n+        closeServers();\n+        LOGGER.log(\"Closing the executor\");\n+        EXECUTOR.shutdownNow();\n+    }\n+\n+    private static void closeServers() {\n+        Exception[] exceptionRef = {null};\n+        Stream\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .map(pair -> (Runnable) pair.server::stop)\n+                .forEach(terminator -> {\n+                    try {\n+                        terminator.run();\n+                    } catch (Exception exception) {\n+                        if (exceptionRef[0] == null) {\n+                            exceptionRef[0] = exception;\n+                        } else {\n+                            exceptionRef[0].addSuppressed(exception);\n+                        }\n+                    }\n+                });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"failed closing one or more server resources\", exceptionRef[0]);\n+        }\n+    }\n+\n+    \/**\n+     * Resets {@link ServerRequestPair#serverReadRequestBodyBytes()} to avoid leftover state from a test leaking to the next.\n+     *\/\n+    @BeforeEach\n+    void resetServerHandlerResults() {\n+        Stream\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .forEach(pair -> pair.serverReadRequestBodyBytes.clear());\n+    }\n+\n+    static ServerRequestPair[] serverRequestPairs() {\n+        return new ServerRequestPair[]{\n+                HTTP1,\n+                HTTPS1,\n+                HTTP2,\n+                HTTPS2\n+        };\n+    }\n+\n+    @Test\n+    void testNullFileChannel() {\n+        assertThrows(NullPointerException.class, () -> BodyPublishers.ofFileChannel(null, 0, 1));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+            \"6,-1,1\",   \/\/ offset < 0\n+            \"6,7,1\",    \/\/ offset > fileSize\n+            \"6,0,-1\",   \/\/ length < 0\n+            \"6,0,7\",    \/\/ length > fileSize\n+            \"6,2,5\"     \/\/ (offset + length) > fileSize\n+    })\n+    void testIllegalOffsetOrLength(\n+            int fileLength,\n+            int fileChannelOffset,\n+            int fileChannelLength,\n+            @TempDir Path tempDir) throws Exception {\n+        withFileChannel(tempDir.resolve(\"data.txt\"), fileLength, (_, fileChannel) ->\n+                assertThrows(\n+                        IndexOutOfBoundsException.class,\n+                        () -> BodyPublishers.ofFileChannel(fileChannel, fileChannelOffset, fileChannelLength)));\n+    }\n+\n+    \/**\n+     * Stresses corner cases in {@linkplain\n+     * BodyPublishers#ofFileChannel(FileChannel, long, long) the file channel\n+     * publisher}, which uses a {@linkplain #DEFAULT_BUFFER_SIZE fixed size}\n+     * buffer to read files, by providing sub-ranges and files that are\n+     * <em>smaller<\/em> than the buffer size.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testContentLessThanBufferSize(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Use a file of length smaller than the default buffer size\n+        int fileLength = 6;\n+        assertTrue(fileLength < DEFAULT_BUFFER_SIZE);\n+\n+        \/\/ Publish the `[0, fileLength)` sub-range\n+        testSuccessfulContentDelivery(\n+                \"Complete content\",\n+                pair, tempDir, fileLength, 0, fileLength);\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range to stress the inclusion of EOF\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = fileLength - 1;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength - 1)` sub-range to stress the exclusion of EOF\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = fileLength - 2;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Stresses corner cases in {@linkplain\n+     * BodyPublishers#ofFileChannel(FileChannel, long, long) the file channel\n+     * publisher}, which uses a {@linkplain #DEFAULT_BUFFER_SIZE fixed size}\n+     * buffer to read files, by providing sub-ranges and files that are\n+     * <em>bigger<\/em> than the buffer size.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testContentMoreThanBufferSize(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Use a file of length that is\n+        \/\/ 1. greater than the default buffer size\n+        \/\/ 2. *not* a multitude of the buffer size\n+        int fileLength = 1 + 3 * DEFAULT_BUFFER_SIZE;\n+\n+        \/\/ Publish the `[0, fileLength)` sub-range\n+        testSuccessfulContentDelivery(\n+                \"Complete content\",\n+                pair, tempDir, fileLength, 0, fileLength);\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is included\n+        \/\/ - the total length is a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF. Occupies exactly 3 buffers. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is included\n+        \/\/ - the total length is *not* a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE - 1;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF. Occupies 3 buffers, the last is custom sized. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is *not* included\n+        \/\/ - the total length is a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 2 * DEFAULT_BUFFER_SIZE;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF. Occupies exactly 2 buffers. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is *not* included\n+        \/\/ - the total length is *not* a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE - 2;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF. Occupies 3 buffers, the last is custom sized. \"+ debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+    }\n+\n+    private static String debuggingContext(int fileLength, int fileChannelOffset, int fileChannelLength) {\n+        Map<String, Object> context = new LinkedHashMap<>();    \/\/ Using `LHM` to preserve the insertion order\n+        context.put(\"DEFAULT_BUFFER_SIZE\", DEFAULT_BUFFER_SIZE);\n+        context.put(\"fileLength\", fileLength);\n+        context.put(\"fileChannelOffset\", fileChannelOffset);\n+        context.put(\"fileChannelLength\", fileChannelLength);\n+        boolean customSizedBuffer = fileChannelLength % DEFAULT_BUFFER_SIZE == 0;\n+        context.put(\"customSizedBuffer\", customSizedBuffer);\n+        return context.toString();\n+    }\n+\n+    private void testSuccessfulContentDelivery(\n+            String caseDescription,\n+            ServerRequestPair pair,\n+            Path tempDir,\n+            int fileLength,\n+            int fileChannelOffset,\n+            int fileChannelLength) throws Exception {\n+\n+        \/\/ Case names come handy even when no debug logging is enabled.\n+        \/\/ Hence, intentionally avoiding `Logger`.\n+        System.err.printf(\"Case: %s%n\", caseDescription);\n+\n+        \/\/ Create the file to upload\n+        String fileName = \"data-%d-%d-%d.txt\".formatted(fileLength, fileChannelOffset, fileChannelLength);\n+        Path filePath = tempDir.resolve(fileName);\n+        withFileChannel(filePath, fileLength, (fileBytes, fileChannel) -> {\n+\n+            \/\/ Upload the file\n+            HttpRequest request = pair\n+                    .requestBuilder\n+                    .POST(BodyPublishers.ofFileChannel(fileChannel, fileChannelOffset, fileChannelLength))\n+                    .build();\n+            CLIENT.send(request, discarding());\n+\n+            \/\/ Verify the received request body\n+            byte[] expectedRequestBodyBytes = new byte[fileChannelLength];\n+            System.arraycopy(fileBytes, fileChannelOffset, expectedRequestBodyBytes, 0, fileChannelLength);\n+            byte[] actualRequestBodyBytes = pair.serverReadRequestBodyBytes.take();\n+            assertArrayEquals(expectedRequestBodyBytes, actualRequestBodyBytes);\n+\n+        });\n+\n+    }\n+\n+    \/**\n+     * <em>Big enough<\/em> file length to observe the effects of publisher state corruption while uploading.\n+     * <p>\n+     * Certain tests follow below steps:\n+     * <\/p>\n+     * <ol>\n+     * <li>Issue the request<\/li>\n+     * <li>Wait for the server's signal that the request (not the body!) is received<\/li>\n+     * <li>Corrupt the publisher's state; modify the file, close the file channel, etc.<\/li>\n+     * <li>Signal the server to proceed with reading<\/li>\n+     * <\/ol>\n+     * <p>\n+     * With small files, even before we permit the server to read (step 4), file gets already uploaded.\n+     * This voids the effect of state corruption (step 3).\n+     * To circumvent this, use this <em>big enough<\/em> file size.\n+     * <\/p>\n+     *\n+     * @see #testChannelCloseDuringPublisherRead(ServerRequestPair, Path)\n+     * @see #testFileModificationDuringPublisherRead(ServerRequestPair, Path)\n+     *\/\n+    private static final int BIG_FILE_LENGTH = 8 * 1024 * 1024;  \/\/ 8 MiB\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testChannelCloseDuringPublisherRead(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+        establishInitialConnection(pair);\n+        ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = new CountDownLatch(1);\n+        ServerRequestPair.SERVER_READ_PERMISSION = new CountDownLatch(1);\n+        try {\n+\n+            int fileLength = BIG_FILE_LENGTH;\n+            AtomicReference<Future<HttpResponse<Void>>> responseFutureRef = new AtomicReference<>();\n+            withFileChannel(tempDir.resolve(\"data.txt\"), fileLength, ((_, fileChannel) -> {\n+\n+                \/\/ Issue the request\n+                LOGGER.log(\"Issuing the request\");\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, 0, fileLength))\n+                        .build();\n+                responseFutureRef.set(CLIENT.sendAsync(request, discarding()));\n+\n+                \/\/ Wait for server to receive the request\n+                LOGGER.log(\"Waiting for the request to be received\");\n+                ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL.await();\n+\n+            }));\n+\n+            LOGGER.log(\"File channel is closed\");\n+\n+            \/\/ Let the server proceed\n+            LOGGER.log(\"Permitting the server to proceed\");\n+            ServerRequestPair.SERVER_READ_PERMISSION.countDown();\n+\n+            \/\/ Verifying the client failure\n+            LOGGER.log(\"Verifying the client failure\");\n+            Exception requestFailure0 = assertThrows(ExecutionException.class, () -> responseFutureRef.get().get());\n+            Exception requestFailure1 = assertInstanceOf(UncheckedIOException.class, requestFailure0.getCause());\n+            assertInstanceOf(ClosedChannelException.class, requestFailure1.getCause());\n+\n+            verifyServerIncompleteRead(pair, fileLength);\n+\n+        } finally {\n+            ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+            ServerRequestPair.SERVER_READ_PERMISSION = null;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testFileModificationDuringPublisherRead(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+        establishInitialConnection(pair);\n+        ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = new CountDownLatch(1);\n+        ServerRequestPair.SERVER_READ_PERMISSION = new CountDownLatch(1);\n+        try {\n+\n+            int fileLength = BIG_FILE_LENGTH;\n+            Path filePath = tempDir.resolve(\"data.txt\");\n+            withFileChannel(filePath, fileLength, ((_, fileChannel) -> {\n+\n+                \/\/ Issue the request\n+                LOGGER.log(\"Issuing the request\");\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, 0, fileLength))\n+                        .build();\n+                Future<HttpResponse<Void>> responseFuture = CLIENT.sendAsync(request, discarding());\n+\n+                \/\/ Wait for server to receive the request\n+                LOGGER.log(\"Waiting for the request to be received\");\n+                ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL.await();\n+\n+                \/\/ Modify the file\n+                LOGGER.log(\"Modifying the file\");\n+                Files.write(filePath, generateFileBytes(1));\n+\n+                \/\/ Let the server proceed\n+                LOGGER.log(\"Permitting the server to proceed\");\n+                ServerRequestPair.SERVER_READ_PERMISSION.countDown();\n+\n+                \/\/ Verifying the client failure\n+                LOGGER.log(\"Verifying the client failure\");\n+                Exception requestFailure0 = assertThrows(ExecutionException.class, responseFuture::get);\n+                Exception requestFailure1 = assertInstanceOf(UncheckedIOException.class, requestFailure0.getCause());\n+                Exception requestFailure2 = assertInstanceOf(IOException.class, requestFailure1.getCause());\n+                String requestFailure2Message = requestFailure2.getMessage();\n+                assertTrue(\n+                        requestFailure2Message.contains(\"Unexpected EOF\"),\n+                        \"unexpected message: \" + requestFailure2Message);\n+\n+                verifyServerIncompleteRead(pair, fileLength);\n+\n+            }));\n+\n+        } finally {\n+            ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+            ServerRequestPair.SERVER_READ_PERMISSION = null;\n+        }\n+    }\n+\n+    private static void verifyServerIncompleteRead(ServerRequestPair pair, int fileLength) throws InterruptedException {\n+        LOGGER.log(\"Verifying the server's incomplete read\");\n+        byte[] readRequestBodyBytes = pair.serverReadRequestBodyBytes.take();\n+        assertTrue(\n+                readRequestBodyBytes.length < fileLength,\n+                \"was expecting `readRequestBodyBytes < fileLength` (%s < %s)\".formatted(\n+                        readRequestBodyBytes.length, fileLength));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSlicedUpload(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Populate the file\n+        int sliceCount = 4;\n+        int sliceLength = 14_281; \/\/ Intentionally using a prime number to increase the chances of hitting corner cases\n+        int fileLength = sliceCount * sliceLength;\n+        byte[] fileBytes = generateFileBytes(fileLength);\n+        Path filePath = tempDir.resolve(\"data.txt\");\n+        Files.write(filePath, fileBytes, StandardOpenOption.CREATE);\n+\n+        List<InputStream> responseBodyStreams = new ArrayList<>(sliceCount);\n+        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n+\n+            \/\/ Upload the complete file in mutually exclusive slices\n+            List<Future<HttpResponse<InputStream>>> responseFutures = new ArrayList<>(sliceCount);\n+            for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+                LOGGER.log(\"Issuing request %d\/%d\", (sliceIndex + 1), sliceCount);\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, sliceIndex * sliceLength, sliceLength))\n+                        .build();\n+                responseFutures.add(CLIENT.sendAsync(\n+                        request,\n+                        \/\/ Intentionally using an `InputStream` response\n+                        \/\/ handler to defer consuming the response body\n+                        \/\/ until after the file channel is closed:\n+                        ofInputStream()));\n+            }\n+\n+            \/\/ Collect response body `InputStream`s from all requests\n+            for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+                LOGGER.log(\"Collecting response body `InputStream` for request %d\/%d\", (sliceIndex + 1), sliceCount);\n+                HttpResponse<InputStream> response = responseFutures.get(sliceIndex).get();\n+                assertEquals(200, response.statusCode());\n+                responseBodyStreams.add(response.body());\n+            }\n+\n+        }\n+\n+        LOGGER.log(\"File channel is closed\");\n+\n+        \/\/ Verify response bodies\n+        for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+            LOGGER.log(\"Consuming response body %d\/%d\", (sliceIndex + 1), sliceCount);\n+            byte[] expectedResponseBodyBytes = new byte[sliceLength];\n+            System.arraycopy(fileBytes, sliceIndex * sliceLength, expectedResponseBodyBytes, 0, sliceLength);\n+            try (InputStream responseBodyStream = responseBodyStreams.get(sliceIndex)) {\n+                byte[] responseBodyBytes = responseBodyStream.readAllBytes();\n+                assertArrayEquals(expectedResponseBodyBytes, responseBodyBytes);\n+            }\n+        }\n+\n+    }\n+\n+    \/**\n+     * Performs the initial {@code HEAD} request to the specified server. This\n+     * effectively admits a connection to the client's pool, where all protocol\n+     * upgrades, handshakes, etc. are already performed.\n+     * <p>\n+     * HTTP\/2 test server consumes the complete request payload in the very\n+     * first upgrade frame. That is, if a client sends 100 MiB of data, all\n+     * of it will be consumed first before the configured handler is\n+     * invoked. Though certain tests expect the data to be consumed\n+     * piecemeal. To accommodate this, we ensure client has an upgraded\n+     * connection in the pool.\n+     * <\/p>\n+     *\/\n+    private static void establishInitialConnection(ServerRequestPair pair) {\n+        LOGGER.log(\"Server[%s] is getting queried for the initial connection pool admission\", pair);\n+        try {\n+            CLIENT.send(pair.requestBuilder.HEAD().build(), discarding());\n+        } catch (Exception exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    private static void withFileChannel(Path filePath, int fileLength, FileChannelConsumer fileChannelConsumer) throws Exception {\n+        byte[] fileBytes = generateFileBytes(fileLength);\n+        Files.write(filePath, fileBytes, StandardOpenOption.CREATE);\n+        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n+            fileChannelConsumer.consume(fileBytes, fileChannel);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface FileChannelConsumer {\n+\n+        void consume(byte[] fileBytes, FileChannel fileChannel) throws Exception;\n+\n+    }\n+\n+    private static byte[] generateFileBytes(int length) {\n+        byte[] bytes = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            bytes[i] = (byte) i;\n+        }\n+        return bytes;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/FileChannelPublisherTest.java","additions":708,"deletions":0,"binary":false,"changes":708,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n- * @run main\/othervm -Dtest.requiresHost=true\n+ * @run main\/othervm\/timeout=480 -Dtest.requiresHost=true\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpSlowServerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @key intermittent\n@@ -35,4 +36,4 @@\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-public class ProxyServer extends Thread implements Closeable {\n+public final class ProxyServer implements Closeable {\n@@ -100,3 +100,1 @@\n-    public ProxyServer(Integer port,\n-                       Boolean debug,\n-                       Credentials credentials)\n+    private ProxyServer(Integer port, Boolean debug, Credentials credentials)\n@@ -111,8 +109,0 @@\n-        setName(\"ProxyListener\");\n-        setDaemon(true);\n-        connections = new CopyOnWriteArrayList<Connection>();\n-        start();\n-    }\n-\n-    public ProxyServer(String s) {\n-        credentials = null;\n@@ -120,0 +110,1 @@\n+        Thread.ofPlatform().name(\"ProxyListener\").daemon().start(this::run);\n@@ -151,1 +142,1 @@\n-    public void run() {\n+    private void run() {\n@@ -659,4 +650,5 @@\n-        ProxyServer ps = new ProxyServer(port, debug);\n-        System.out.println(\"Proxy server listening on port \" + ps.getPort());\n-        while (true) {\n-            Thread.sleep(5000);\n+        try (ProxyServer ps = new ProxyServer(port, debug)) {\n+            System.out.println(\"Proxy server listening on port \" + ps.getPort());\n+            while (true) {\n+                Thread.sleep(5000);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyServer.java","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm ResponseBodyBeforeError\n+ * @run testng\/othervm\/timeout=480 ResponseBodyBeforeError\n","filename":"test\/jdk\/java\/net\/httpclient\/ResponseBodyBeforeError.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm ResponsePublisher\n+ * @run testng\/othervm\/timeout=480 ResponsePublisher\n","filename":"test\/jdk\/java\/net\/httpclient\/ResponsePublisher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng\/othervm\n+ * @run testng\/othervm\/timeout=480\n@@ -37,1 +37,1 @@\n- * @run testng\/othervm -Djdk.httpclient.allowRestrictedHeaders=Host\n+ * @run testng\/othervm\/timeout=480 -Djdk.httpclient.allowRestrictedHeaders=Host\n","filename":"test\/jdk\/java\/net\/httpclient\/SpecialHeadersTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponse.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseKeepAlive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseKeepAliveAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSL.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSLAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSLKeepAlive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSLKeepAliveAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng java.net.http\/jdk.internal.net.http.FlowTest\n+ * @run testng\/timeout=480 java.net.http\/jdk.internal.net.http.FlowTest\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/FlowTestDriver.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4607272\n+ * @bug 4607272 8364761\n@@ -28,1 +28,1 @@\n- * @run main AsExecutor\n+ * @run junit AsExecutor\n@@ -31,0 +31,1 @@\n+import java.io.IOException;\n@@ -32,0 +33,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -36,0 +39,8 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -38,0 +49,6 @@\n+    private static ThreadFactory factory;\n+\n+    @BeforeAll\n+    public static void createThreadFactory() {\n+         factory = Executors.defaultThreadFactory();\n+    }\n@@ -39,9 +56,10 @@\n-    public static void main(String[] args) throws Exception {\n-        \/\/ create channel groups\n-        ThreadFactory factory = Executors.defaultThreadFactory();\n-        AsynchronousChannelGroup group1 = AsynchronousChannelGroup\n-            .withFixedThreadPool(5, factory);\n-        AsynchronousChannelGroup group2 = AsynchronousChannelGroup\n-            .withCachedThreadPool(Executors.newCachedThreadPool(factory), 0);\n-        AsynchronousChannelGroup group3 = AsynchronousChannelGroup\n-            .withThreadPool(Executors.newFixedThreadPool(10, factory));\n+    private static Stream<Arguments> channelGroups() throws IOException {\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(AsynchronousChannelGroup\n+            .withFixedThreadPool(5, factory)));\n+        list.add(Arguments.of(AsynchronousChannelGroup\n+            .withCachedThreadPool(Executors.newCachedThreadPool(factory), 0)));\n+        list.add(Arguments.of(AsynchronousChannelGroup\n+            .withThreadPool(Executors.newFixedThreadPool(10, factory))));\n+        return list.stream();\n+    }\n@@ -49,0 +67,5 @@\n+    @ParameterizedTest\n+    @MethodSource(\"channelGroups\")\n+    public void simpleTask(AsynchronousChannelGroup group)\n+        throws InterruptedException\n+    {\n@@ -50,4 +73,8 @@\n-            \/\/ execute simple tasks\n-            testSimpleTask(group1);\n-            testSimpleTask(group2);\n-            testSimpleTask(group3);\n+            Executor executor = (Executor)group;\n+            final CountDownLatch latch = new CountDownLatch(1);\n+            executor.execute(new Runnable() {\n+                    public void run() {\n+                        latch.countDown();\n+                    }\n+                });\n+            latch.await();\n@@ -55,3 +82,1 @@\n-            group1.shutdown();\n-            group2.shutdown();\n-            group3.shutdown();\n+            group.shutdown();\n@@ -61,1 +86,3 @@\n-    static void testSimpleTask(AsynchronousChannelGroup group) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"channelGroups\")\n+    public void nullTask(AsynchronousChannelGroup group) {\n@@ -63,7 +90,6 @@\n-        final CountDownLatch latch = new CountDownLatch(1);\n-        executor.execute(new Runnable() {\n-            public void run() {\n-                latch.countDown();\n-            }\n-        });\n-        latch.await();\n+        try {\n+            assertThrows(NullPointerException.class,\n+                         () -> executor.execute(null));\n+        } finally {\n+            group.shutdown();\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousChannelGroup\/AsExecutor.java","additions":53,"deletions":27,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Djdk.net.useFastTcpLoopback StressLoopback\n+ * @run main\/othervm\/timeout=480 -Djdk.net.useFastTcpLoopback StressLoopback\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousSocketChannel\/StressLoopback.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8361495\n+ * @summary Test for AsynchronousCloseException from uninterruptible FileChannel\n+ * @run junit AsyncCloseStreams\n+ *\/\n+\n+import java.io.Closeable;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.AsynchronousCloseException;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.LinkedTransferQueue;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class AsyncCloseStreams {\n+    private static final Closeable STOP = () -> { };\n+\n+    private static Thread startCloseThread(LinkedTransferQueue<Closeable> q) {\n+        return Thread.ofPlatform().start(() -> {\n+                try {\n+                    Closeable c;\n+                    while((c = q.take()) != STOP) {\n+                        try {\n+                            c.close();\n+                        } catch (IOException ignored) {\n+                        }\n+                    }\n+                } catch (InterruptedException ignored) {\n+                }\n+            });\n+    }\n+\n+    @Test\n+    public void available() throws InterruptedException, IOException {\n+        var close = new LinkedTransferQueue<Closeable>();\n+        Thread closeThread = startCloseThread(close);\n+\n+        try {\n+            Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+            path.toFile().deleteOnExit();\n+\n+            do {\n+                InputStream in = Files.newInputStream(path);\n+                close.offer(in);\n+                int available = 0;\n+                try {\n+                    available = in.available();\n+                } catch (AsynchronousCloseException ace) {\n+                    System.err.println(\"AsynchronousCloseException caught\");\n+                    break;\n+                } catch (ClosedChannelException ignored) {\n+                    continue;\n+                } catch (Throwable t) {\n+                    fail(\"Unexpected error\", t);\n+                }\n+                if (available < 0) {\n+                    fail(\"FAILED: available < 0\");\n+                }\n+            } while (true);\n+        } finally {\n+            close.offer(STOP);\n+            closeThread.join();\n+        }\n+    }\n+\n+    @Test\n+    public void read() throws InterruptedException, IOException {\n+        var close = new LinkedTransferQueue<Closeable>();\n+        Thread closeThread = startCloseThread(close);\n+\n+        try {\n+            Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+            path.toFile().deleteOnExit();\n+            byte[] bytes = new byte[100_000];\n+            Arrays.fill(bytes, (byte)27);\n+            Files.write(path, bytes);\n+\n+            do {\n+                InputStream in = Files.newInputStream(path);\n+                close.offer(in);\n+                int value = 0;\n+                try {\n+                    value = in.read();\n+                } catch (AsynchronousCloseException ace) {\n+                    System.err.println(\"AsynchronousCloseException caught\");\n+                    break;\n+                } catch (ClosedChannelException ignored) {\n+                    continue;\n+                } catch (Throwable t) {\n+                    fail(\"Unexpected error\", t);\n+                }\n+                if (value < 0) {\n+                    fail(\"FAILED: value < 0\");\n+                }\n+            } while (true);\n+        } finally {\n+            close.offer(STOP);\n+            closeThread.join();\n+        }\n+    }\n+\n+    @Test\n+    public void write() throws InterruptedException, IOException {\n+        var close = new LinkedTransferQueue<Closeable>();\n+        Thread closeThread = startCloseThread(close);\n+\n+        try {\n+            Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+            path.toFile().deleteOnExit();\n+\n+            do {\n+                OutputStream out = Files.newOutputStream(path);\n+                close.offer(out);\n+                try {\n+                    out.write(27);\n+                } catch (AsynchronousCloseException ace) {\n+                    System.err.println(\"AsynchronousCloseException caught\");\n+                    break;\n+                } catch (ClosedChannelException ignored) {\n+                } catch (Throwable t) {\n+                    fail(\"Write error\", t);\n+                }\n+            } while (true);\n+        } finally {\n+            close.offer(STOP);\n+            closeThread.join();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/AsyncCloseStreams.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- * @run testng\/othervm\/timeout=180 TransferTo\n+ * @run testng\/othervm\/timeout=720 TransferTo\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run testng\/othervm\/timeout=180 TransferTo_2GB_transferFrom\n+ * @run testng\/othervm\/timeout=720 TransferTo_2GB_transferFrom\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo_2GB_transferFrom.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng\/othervm\/timeout=180 TransferTo_2GB_transferTo\n+ * @run testng\/othervm\/timeout=720 TransferTo_2GB_transferTo\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo_2GB_transferTo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm CleanerTest\n+ * @run main\/othervm\/timeout=480 CleanerTest\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/CleanerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @modules java.base\/sun.nio.ch:+open java.base\/java.io:+open\n@@ -35,0 +36,1 @@\n+import java.lang.reflect.Field;\n@@ -50,0 +52,18 @@\n+    private static final int TRIES = 3;\n+\n+    public static int getFD(FileChannel channel) throws Exception {\n+        Field fFdFd = channel.getClass().getDeclaredField(\"fd\");\n+        fFdFd.setAccessible(true);\n+        FileDescriptor fd = (FileDescriptor) fFdFd.get(channel);\n+\n+        Field fFd = FileDescriptor.class.getDeclaredField(\"fd\");\n+        fFd.setAccessible(true);\n+        return fFd.getInt(fd);\n+    }\n+\n+    private static void testWrite(Path p, long blockSize) throws Exception {\n+        try (FileChannel fc = FileChannel.open(p,\n+                StandardOpenOption.READ,\n+                StandardOpenOption.WRITE,\n+                ExtendedOpenOption.DIRECT)) {\n+            int fd = getFD(fc);\n@@ -51,3 +71,0 @@\n-    private static int testWrite(Path p, long blockSize) throws Exception {\n-        try (FileChannel fc = FileChannel.open(p, StandardOpenOption.WRITE,\n-             ExtendedOpenOption.DIRECT)) {\n@@ -63,3 +80,17 @@\n-            src.flip();\n-            fc.write(src);\n-            return size;\n+\n+            \/\/ If there is AV or other FS tracing software, it may cache the file\n+            \/\/ contents on first access, even though we have asked for DIRECT here.\n+            \/\/ Do several attempts to make test more resilient.\n+\n+            for (int t = 0; t < TRIES; t++) {\n+                flushFileCache(size, fd);\n+                src.flip();\n+                fc.position(0);\n+                fc.write(src);\n+                if (!isFileInCache(size, fd)) {\n+                    return;\n+                }\n+            }\n+\n+            throw new RuntimeException(\"DirectIO is not working properly with \" +\n+                                       \"write. File still exists in cache!\");\n@@ -69,2 +100,6 @@\n-    private static int testRead(Path p, long blockSize) throws Exception {\n-        try (FileChannel fc = FileChannel.open(p, ExtendedOpenOption.DIRECT)) {\n+    private static void testRead(Path p, long blockSize) throws Exception {\n+        try (FileChannel fc = FileChannel.open(p,\n+                StandardOpenOption.READ,\n+                ExtendedOpenOption.DIRECT)) {\n+            int fd = getFD(fc);\n+\n@@ -77,2 +112,17 @@\n-            fc.read(dest);\n-            return size;\n+\n+            \/\/ If there is AV or other FS tracing software, it may cache the file\n+            \/\/ contents on first access, even though we have asked for DIRECT here.\n+            \/\/ Do several attempts to make test more resilient.\n+\n+            for (int t = 0; t < TRIES; t++) {\n+                flushFileCache(size, fd);\n+                dest.clear();\n+                fc.position(0);\n+                fc.read(dest);\n+                if (!isFileInCache(size, fd)) {\n+                    return;\n+                }\n+            }\n+\n+            throw new RuntimeException(\"DirectIO is not working properly with \" +\n+                                       \"read. File still exists in cache!\");\n@@ -87,6 +137,2 @@\n-    private static boolean isFileInCache(int size, Path p) {\n-        String path = p.toString();\n-        return isFileInCache0(size, path);\n-    }\n-\n-    private static native boolean isFileInCache0(int size, String path);\n+    private static native boolean flushFileCache(int size, int fd);\n+    private static native boolean isFileInCache(int size, int fd);\n@@ -101,10 +147,2 @@\n-            int size = testWrite(p, blockSize);\n-            if (isFileInCache(size, p)) {\n-                throw new RuntimeException(\"DirectIO is not working properly with \"\n-                    + \"write. File still exists in cache!\");\n-            }\n-            size = testRead(p, blockSize);\n-            if (isFileInCache(size, p)) {\n-                throw new RuntimeException(\"DirectIO is not working properly with \"\n-                    + \"read. File still exists in cache!\");\n-            }\n+            testWrite(p, blockSize);\n+            testRead(p, blockSize);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/DirectIOTest.java","additions":64,"deletions":26,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n- * Method:    isFileInCache0\n- * Signature: (ILjava\/lang\/String;)Z\n+ * Method:    flushFileCache\n+ * Signature: (II;)V\n@@ -51,1 +51,1 @@\n-JNIEXPORT jboolean Java_DirectIOTest_isFileInCache0(JNIEnv *env,\n+JNIEXPORT void Java_DirectIOTest_flushFileCache(JNIEnv *env,\n@@ -54,1 +54,15 @@\n-                                                jstring file_path) {\n+                                                jint fd) {\n+#ifdef __linux__\n+    posix_fadvise(fd, 0, file_size, POSIX_FADV_DONTNEED);\n+#endif\n+}\n+\n+\/*\n+ * Class:     DirectIO\n+ * Method:    isFileInCache\n+ * Signature: (II;)Z\n+ *\/\n+JNIEXPORT jboolean Java_DirectIOTest_isFileInCache(JNIEnv *env,\n+                                                jclass cls,\n+                                                jint file_size,\n+                                                jint fd) {\n@@ -72,6 +86,0 @@\n-    const char* path = (*env)->GetStringUTFChars(env, file_path, JNI_FALSE);\n-\n-    int fd = open(path, O_RDWR);\n-\n-    (*env)->ReleaseStringUTFChars(env, file_path, path);\n-\n@@ -80,1 +88,0 @@\n-        close(fd);\n@@ -82,1 +89,1 @@\n-            \"test of whether file exists in cache failed\");\n+            \"test of whether file exists in cache failed: mmap failed\");\n@@ -98,1 +105,1 @@\n-            \"test of whether file exists in cache failed\");\n+            \"test of whether file exists in cache failed: malloc failed\");\n@@ -100,1 +107,0 @@\n-    close(fd);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/libDirectIO.c","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main CloseDuringConnect\n+ * @run main\/timeout=480 CloseDuringConnect\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/CloseDuringConnect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run junit\/othervm OpenLeak\n+ * @run junit\/othervm\/timeout=480 OpenLeak\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/OpenLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng\/othervm IOExchanges\n+ * @run testng\/othervm\/timeout=480 IOExchanges\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/IOExchanges.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -29,1 +29,1 @@\n- * @run junit BlockingChannelOps\n+ * @run junit\/timeout=480 BlockingChannelOps\n@@ -32,1 +32,1 @@\n-\/**\n+\/*\n@@ -36,2 +36,2 @@\n- * @run junit\/othervm -Djdk.pollerMode=1 BlockingChannelOps\n- * @run junit\/othervm -Djdk.pollerMode=2 BlockingChannelOps\n+ * @run junit\/othervm\/timeout=480 -Djdk.pollerMode=1 BlockingChannelOps\n+ * @run junit\/othervm\/timeout=480 -Djdk.pollerMode=2 BlockingChannelOps\n@@ -40,1 +40,1 @@\n-\/**\n+\/*\n@@ -44,1 +44,1 @@\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingChannelOps\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingChannelOps\n@@ -65,0 +65,1 @@\n+import java.util.concurrent.locks.LockSupport;\n@@ -164,0 +165,16 @@\n+    \/**\n+     * SocketChannel shutdownInput while virtual thread blocked in read.\n+     *\/\n+    @Test\n+    void testSocketChannelReadAsyncShutdownInput() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (var connection = new Connection()) {\n+                SocketChannel sc = connection.channel1();\n+                runAfterParkedAsync(sc::shutdownInput);\n+                int n = sc.read(ByteBuffer.allocate(100));\n+                assertEquals(-1, n);\n+                assertTrue(sc.isOpen());\n+            }\n+        });\n+    }\n+\n@@ -193,2 +210,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -199,1 +216,3 @@\n-                    runAfterParkedAsync(sc::close);\n+                    runAfterParkedAsync(sc::close, true);\n+\n+                    \/\/ write until channel is closed\n@@ -209,1 +228,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -211,1 +230,26 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+\n+    \/**\n+     * SocketChannel shutdownOutput while virtual thread blocked in write.\n+     *\/\n+    @Test\n+    void testSocketChannelWriteAsyncShutdownOutput() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (var connection = new Connection()) {\n+                SocketChannel sc = connection.channel1();\n+\n+                \/\/ shutdown output when current thread blocks in write\n+                runAfterParkedAsync(sc::shutdownOutput);\n+                try {\n+                    ByteBuffer bb = ByteBuffer.allocate(100*1024);\n+                    for (;;) {\n+                        int n = sc.write(bb);\n+                        assertTrue(n > 0);\n+                        bb.clear();\n@@ -213,0 +257,2 @@\n+                } catch (ClosedChannelException e) {\n+                    \/\/ expected\n@@ -214,0 +260,1 @@\n+                assertTrue(sc.isOpen());\n@@ -224,2 +271,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -231,1 +278,1 @@\n-                    runAfterParkedAsync(thisThread::interrupt);\n+                    runAfterParkedAsync(thisThread::interrupt, true);\n@@ -233,0 +280,1 @@\n+                    \/\/ write until channel is closed\n@@ -243,1 +291,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -245,1 +293,2 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n@@ -737,2 +786,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -744,1 +793,3 @@\n-                    runAfterParkedAsync(sink::close);\n+                    runAfterParkedAsync(sink::close, true);\n+\n+                    \/\/ write until channel is closed\n@@ -754,1 +805,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -756,1 +807,2 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n@@ -769,2 +821,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -777,1 +829,1 @@\n-                    runAfterParkedAsync(thisThread::interrupt);\n+                    runAfterParkedAsync(thisThread::interrupt, true);\n@@ -779,0 +831,1 @@\n+                    \/\/ write until channel is closed\n@@ -789,1 +842,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -791,1 +844,2 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n@@ -851,1 +905,2 @@\n-     * Runs the given task asynchronously after the current virtual thread has parked.\n+     * Runs the given task asynchronously after the current virtual thread parks.\n+     * @param writing if the thread will block in write\n@@ -854,1 +909,1 @@\n-    static Thread runAfterParkedAsync(ThrowingRunnable task) {\n+    private static Thread runAfterParkedAsync(ThrowingRunnable task, boolean writing) {\n@@ -860,3 +915,2 @@\n-                Thread.State state = target.getState();\n-                while (state != Thread.State.WAITING\n-                        && state != Thread.State.TIMED_WAITING) {\n+                \/\/ wait for target thread to park\n+                while (!isWaiting(target)) {\n@@ -864,1 +918,0 @@\n-                    state = target.getState();\n@@ -866,1 +919,12 @@\n-                Thread.sleep(20);  \/\/ give a bit more time to release carrier\n+\n+                \/\/ if the target thread is parked in write then we nudge it a few times\n+                \/\/ to avoid wakeup with some bytes written\n+                if (writing) {\n+                    for (int i = 0; i < 3; i++) {\n+                        LockSupport.unpark(target);\n+                        while (!isWaiting(target)) {\n+                            Thread.sleep(20);\n+                        }\n+                    }\n+                }\n+\n@@ -868,0 +932,1 @@\n+\n@@ -873,0 +938,13 @@\n+\n+    private static Thread runAfterParkedAsync(ThrowingRunnable task) {\n+        return runAfterParkedAsync(task, false);\n+    }\n+\n+    \/**\n+     * Return true if the given Thread is parked.\n+     *\/\n+    private static boolean isWaiting(Thread target) {\n+        Thread.State state = target.getState();\n+        assertNotEquals(Thread.State.TERMINATED, state);\n+        return (state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING);\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":113,"deletions":35,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires (os.family == \"linux\" | os.family == \"mac\")\n+ * @requires (os.family == \"linux\" | os.family == \"mac\" | os.family == \"aix\")\n","filename":"test\/jdk\/java\/nio\/file\/DirectoryStream\/SecureDS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,457 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8154364 8366254\n+ * @summary Test of Files.isSameFile\n+ * @requires (os.family != \"windows\")\n+ * @library .. \/test\/lib\n+ * @build IsSameFile jdk.test.lib.util.FileUtils\n+ * @run junit IsSameFile\n+ *\/\n+import java.io.IOException;\n+import java.io.FileOutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystemLoopException;\n+import java.nio.file.FileSystemException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.TestInstance.Lifecycle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@TestInstance(Lifecycle.PER_CLASS)\n+public class IsSameFile {\n+    private Path home;\n+    private Path a;\n+    private Path aa;\n+    private Path b;\n+    private Path c;\n+    private List<Path> allFiles;\n+\n+    @BeforeAll\n+    public void init() throws IOException {\n+        home = Files.createTempDirectory(\"TestIsSameFile\");\n+\n+        allFiles = new ArrayList();\n+        allFiles.add(a = home.resolve(\"a\"));\n+        allFiles.add(aa = home.resolve(\"a\"));\n+        allFiles.add(b = home.resolve(\"b\"));\n+        allFiles.add(c = home.resolve(\"c\"));\n+    }\n+\n+    public void deleteFiles() throws IOException {\n+        for (Path p : allFiles)\n+            Files.deleteIfExists(p);\n+    }\n+\n+    @AfterAll\n+    public void deleteHome() throws IOException {\n+        TestUtil.removeAll(home);\n+    }\n+\n+    public void test(boolean expect, Path x, Path y) throws IOException {\n+        assertTrue(Files.isSameFile(x, y) == expect);\n+    }\n+\n+    private Stream<Arguments> stringCompareSource() throws IOException {\n+        deleteFiles();\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        Path x = Path.of(\"x\/y\/z\");\n+        list.add(Arguments.of(true, x, x));\n+        list.add(Arguments.of(false, Path.of(\"w\/x\/y\/z\"), x));\n+        Path y = Path.of(\"v\/w\/x\/..\/y\/z\");\n+        list.add(Arguments.of(false, y, Path.of(\"v\/w\/y\/z\")));\n+        list.add(Arguments.of(false, y, Path.of(\"v\/w\/x\/y\/..\/z\")));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"stringCompareSource\")\n+    public void stringCompare(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> noneExistSource() throws IOException {\n+        deleteFiles();\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        return list.stream();\n+    }\n+\n+    @Test\n+    public void obj2Null() {\n+        Path x = Path.of(\"x\/y\");\n+        assertThrows(NullPointerException.class, () -> Files.isSameFile(x, null));\n+    }\n+\n+    private static void zipStringToFile(String entry, String content,\n+                                        Path path)\n+        throws IOException\n+    {\n+        FileOutputStream fos = new FileOutputStream(path.toString());\n+        ZipOutputStream zos = new ZipOutputStream(fos);\n+\n+        ZipEntry zipEntry = new ZipEntry(entry);\n+        zos.putNextEntry(zipEntry);\n+        zos.write(content.getBytes());\n+\n+        zos.close();\n+        fos.close();\n+    }\n+\n+    private Stream<Arguments> obj2ZipSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        zipStringToFile(\"quote.txt\", \"To be determined\", b);\n+        FileSystem zipfs = FileSystems.newFileSystem(b);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, a, zipfs.getPath(b.toString())));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"obj2ZipSource\")\n+    public void obj2Zip(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"noneExistSource\")\n+    public void noneExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> aExistsSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"aExistsSource\")\n+    public void aExists(boolean expect, Path x, Path y) throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> abExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        Files.createFile(b);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        list.add(Arguments.of(false, a, c));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"abExistSource\")\n+    public void abExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> abcExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(a);\n+        Files.createFile(b);\n+        Files.createSymbolicLink(c, a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, c));\n+        list.add(Arguments.of(false, a, b));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"abcExistSource\")\n+    public void abcExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    private Stream<Arguments> bcExistSource() throws IOException {\n+        deleteFiles();\n+        Files.createFile(b);\n+        Files.createSymbolicLink(c, a);\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, a, a));\n+        list.add(Arguments.of(true, a, aa));\n+        list.add(Arguments.of(false, a, b));\n+        list.add(Arguments.of(true, b, b));\n+        list.add(Arguments.of(false, a, c));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"bcExistSource\")\n+    public void bcExist(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => target\n+    \/\/ L3 => L4 => target\n+    \/\/\n+    private Stream<Arguments> equalFollowingSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, target);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, target);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalFollowingSource\")\n+    public void equalFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => target\n+    \/\/ L3 => L4 => cible\n+    \/\/\n+    private Stream<Arguments> unequalFollowingSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, target);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path cible = home.resolve(\"cible\");\n+        Files.createFile(cible);\n+        allFiles.add(cible);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, cible);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unequalFollowingSource\")\n+    public void unequalFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => <does not exist>\n+    \/\/ L3 => L4 => <does not exist>\n+    \/\/\n+    private Stream<Arguments> unequalNotFollowingSource() throws IOException {\n+        deleteFiles();\n+\n+        Path doesNotExist = Path.of(\"doesNotExist\");\n+\n+        Path L2 = Path.of(\"link2\");\n+        Files.createSymbolicLink(L2, doesNotExist);\n+        allFiles.add(L2);\n+\n+        Path L1 = Path.of(\"link1\");\n+        Files.createSymbolicLink(L1, L2);\n+        allFiles.add(L1);\n+\n+        Path L4 = Path.of(\"link4\");\n+        Files.createSymbolicLink(L4, doesNotExist);\n+        allFiles.add(L4);\n+\n+        Path L3 = Path.of(\"link3\");\n+        Files.createSymbolicLink(L3, L4);\n+        allFiles.add(L3);\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(false, L1, L3));\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"unequalNotFollowingSource\")\n+    public void unequalNotFollowing(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => L3 => L4 => target\n+    \/\/\n+    \/\/ isSameFile(LX,LY) should be true for all X, Y\n+    \/\/\n+    private Stream<Arguments> multiLinkSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+        Path[] links = new Path[4];\n+        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n+        allFiles.add(links[3]);\n+        for (int i = 3; i > 0; i--) {\n+            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n+            allFiles.add(links[i-1]);\n+        }\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        for (int i = 0; i < 4; i++) {\n+            list.add(Arguments.of(true, links[i], target));\n+            for (int j = i+1; j < 4; j++)\n+                list.add(Arguments.of(true, links[i], links[j]));\n+        }\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"multiLinkSource\")\n+    public void multiLink(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 => L2 => L3 => L4 => <does not exist>\n+    \/\/\n+    \/\/ isSameFile(LX,LY) should be true for all X, Y\n+    \/\/\n+    private Stream<Arguments> multiLinkNoTargetSource() throws IOException {\n+        deleteFiles();\n+        Path target = home.resolve(\"target\");\n+        Files.createFile(target);\n+        allFiles.add(target);\n+        Path[] links = new Path[4];\n+        links[3] = Files.createSymbolicLink(Path.of(\"link4\"), target);\n+        allFiles.add(links[3]);\n+        Files.delete(target);\n+        allFiles.remove(target);\n+        for (int i = 3; i > 0; i--) {\n+            links[i-1] = Files.createSymbolicLink(Path.of(\"link\"+i), links[i]);\n+            allFiles.add(links[i-1]);\n+        }\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        for (int i = 0; i < 4; i++) {\n+            list.add(Arguments.of(false, links[i], target));\n+            for (int j = i+1; j < 4; j++)\n+                list.add(Arguments.of(true, links[i], links[j]));\n+        }\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"multiLinkNoTargetSource\")\n+    public void multiLinkNoTarget(boolean expect, Path x, Path y)\n+        throws IOException {\n+        test(expect, x, y);\n+    }\n+\n+    \/\/\n+    \/\/ L1 -> L2 -> L3 -> L1...\n+    \/\/\n+    \/\/ This is a loop and should throw FileSystemException.\n+    \/\/\n+    private Stream<Arguments> linkLoopSource() throws IOException {\n+        deleteFiles();\n+\n+        Path link1 = home.resolve(\"L1\");\n+        Path link2 = home.resolve(\"L2\");\n+        Path link3 = home.resolve(\"L3\");\n+        allFiles.add(Files.createSymbolicLink(link1, link2));\n+        allFiles.add(Files.createSymbolicLink(link2, link3));\n+        allFiles.add(Files.createSymbolicLink(link3, link1));\n+\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        list.add(Arguments.of(true, link1, link2));\n+        list.add(Arguments.of(true, link2, link3));\n+        list.add(Arguments.of(true, link3, link1));\n+\n+        return list.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"linkLoopSource\")\n+    public void linkLoop(boolean expect, Path x, Path y) throws IOException {\n+        assertThrows(FileSystemLoopException.class, () -> Files.isSameFile(x, y));\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":457,"deletions":0,"binary":false,"changes":457,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 8005566 8215467 8255576 8286160\n+ * @bug 4313887 6838333 8005566 8154364 8215467 8255576 8286160\n@@ -116,1 +116,1 @@\n-         * Test: Neither files exist\n+         * Test: Neither file exists\n@@ -118,10 +118,2 @@\n-        try {\n-            isSameFile(thisFile, thatFile);\n-            throw new RuntimeException(\"IOException not thrown\");\n-        } catch (IOException x) {\n-        }\n-        try {\n-            isSameFile(thatFile, thisFile);\n-            throw new RuntimeException(\"IOException not thrown\");\n-        } catch (IOException x) {\n-        }\n+        assertTrue(!isSameFile(thisFile, thatFile));\n+        assertTrue(!isSameFile(thatFile, thisFile));\n@@ -134,10 +126,2 @@\n-            try {\n-                isSameFile(thisFile, thatFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n-            try {\n-                isSameFile(thatFile, thisFile);\n-                throw new RuntimeException(\"IOException not thrown\");\n-            } catch (IOException x) {\n-            }\n+            assertTrue(!isSameFile(thisFile, thatFile));\n+            assertTrue(!isSameFile(thatFile, thisFile));\n","filename":"test\/jdk\/java\/nio\/file\/Files\/Misc.java","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,0 @@\n-import sun.rmi.transport.*;\n-import sun.rmi.*;\n@@ -63,0 +61,1 @@\n+import sun.rmi.transport.*;\n@@ -105,2 +104,0 @@\n-                                        \" -Djava.security.policy=\" +\n-                                        TestParams.defaultPolicy +\n@@ -131,2 +128,2 @@\n-        \/* numLeft should be 2 - if 11 there is a problem. *\/\n-        if (numLeft > 2) {\n+        \/* numLeft should be 4 - if 11 there is a problem. *\/\n+        if (numLeft > 4) {\n@@ -159,37 +156,32 @@\n-            f = (Field) java.security.AccessController.doPrivileged\n-                (new java.security.PrivilegedExceptionAction() {\n-                    public Object run() throws Exception {\n-\n-                        ObjID dgcID = new ObjID(DGC_ID);\n-\n-                        \/*\n-                         * Construct an ObjectEndpoint containing DGC's\n-                         * ObjID.\n-                         *\/\n-                        Class oeClass =\n-                            Class.forName(\"sun.rmi.transport.ObjectEndpoint\");\n-                        Class[] constrParams =\n-                            new Class[]{ ObjID.class, Transport.class };\n-                        Constructor oeConstructor =\n-                            oeClass.getDeclaredConstructor(constrParams);\n-                        oeConstructor.setAccessible(true);\n-                        Object oe =\n-                            oeConstructor.newInstance(\n-                                new Object[]{ dgcID, null });\n-\n-                        \/*\n-                         * Get Target that contains DGCImpl in ObjectTable\n-                         *\/\n-                        Class objTableClass =\n-                            Class.forName(\"sun.rmi.transport.ObjectTable\");\n-                        Class getTargetParams[] = new Class[] { oeClass };\n-                        Method objTableGetTarget =\n-                            objTableClass.getDeclaredMethod(\"getTarget\",\n-                                                            getTargetParams);\n-                        objTableGetTarget.setAccessible(true);\n-                        Target dgcTarget = (Target)\n-                            objTableGetTarget.invoke(null, new Object[]{ oe });\n-\n-                        \/* get the DGCImpl from its Target *\/\n-                        Method targetGetImpl =\n-                            dgcTarget.getClass().getDeclaredMethod\n+            ObjID dgcID = new ObjID(DGC_ID);\n+            \/*\n+             * Construct an ObjectEndpoint containing DGC's\n+             * ObjID.\n+             *\/\n+            Class oeClass =\n+                    Class.forName(\"sun.rmi.transport.ObjectEndpoint\");\n+            Class[] constrParams =\n+                    new Class[]{ ObjID.class, Transport.class };\n+            Constructor oeConstructor =\n+                    oeClass.getDeclaredConstructor(constrParams);\n+            oeConstructor.setAccessible(true);\n+            Object oe =\n+                    oeConstructor.newInstance(\n+                            new Object[]{ dgcID, null });\n+\n+            \/*\n+             * Get Target that contains DGCImpl in ObjectTable\n+             *\/\n+            Class objTableClass =\n+                    Class.forName(\"sun.rmi.transport.ObjectTable\");\n+            Class getTargetParams[] = new Class[] { oeClass };\n+            Method objTableGetTarget =\n+                    objTableClass.getDeclaredMethod(\"getTarget\",\n+                            getTargetParams);\n+            objTableGetTarget.setAccessible(true);\n+            Target dgcTarget = (Target)\n+                    objTableGetTarget.invoke(null, new Object[]{ oe });\n+\n+            \/* get the DGCImpl from its Target *\/\n+            Method targetGetImpl =\n+                    dgcTarget.getClass().getDeclaredMethod\n@@ -197,3 +189,3 @@\n-                        targetGetImpl.setAccessible(true);\n-                        dgcImpl[0] =\n-                            (Remote) targetGetImpl.invoke(dgcTarget, null);\n+            targetGetImpl.setAccessible(true);\n+            dgcImpl[0] =\n+                    (Remote) targetGetImpl.invoke(dgcTarget, null);\n@@ -201,3 +193,3 @@\n-                        \/* Get the lease table from the DGCImpl. *\/\n-                        Field reflectedLeaseTable =\n-                            dgcImpl[0].getClass().getDeclaredField\n+            \/* Get the lease table from the DGCImpl. *\/\n+            Field reflectedLeaseTable =\n+                    dgcImpl[0].getClass().getDeclaredField\n@@ -205,1 +197,3 @@\n-                        reflectedLeaseTable.setAccessible(true);\n+            reflectedLeaseTable.setAccessible(true);\n+\n+            f = reflectedLeaseTable;\n@@ -207,3 +201,0 @@\n-                        return reflectedLeaseTable;\n-                    }\n-            });\n@@ -220,3 +211,0 @@\n-            if (e instanceof java.security.PrivilegedActionException)\n-                e = ((java.security.PrivilegedActionException) e).\n-                    getException();\n","filename":"test\/jdk\/java\/rmi\/transport\/checkLeaseInfoLeak\/CheckLeaseLeak.java","additions":45,"deletions":57,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n","filename":"test\/jdk\/java\/rmi\/transport\/checkLeaseInfoLeak\/LeaseLeakClient.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main\/othervm\/timeout=360 DGCDeadLock\n+ * @run main\/othervm\/timeout=1440 DGCDeadLock\n@@ -59,2 +59,1 @@\n-    public static final double TEST_FAIL_TIME =\n-            (HOLD_TARGET_TIME + 30000) * TestLibrary.getTimeoutFactor();\n+    public static final double TEST_FAIL_TIME = (HOLD_TARGET_TIME + 30000) * Math.max(TestLibrary.getTimeoutFactor(), 4);\n","filename":"test\/jdk\/java\/rmi\/transport\/dgcDeadLock\/DGCDeadLock.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8298420\n+ * @bug 8298420 8365288\n@@ -81,1 +81,3 @@\n-        testClass(PEMData.rsapriv, X509EncodedKeySpec.class, false);\n+        testClass(PEMData.rsapriv, X509EncodedKeySpec.class, false, ClassCastException.class);\n+        System.out.println(\"Decoder test rsapriv PEM asking other EKS returned:\");\n+        testClass(PEMData.rsapriv, XEKS.class, false, ClassCastException.class);\n@@ -487,0 +489,13 @@\n+    static void testClass(PEMData.Entry entry, Class clazz, boolean pass,\n+        Class ec) throws RuntimeException {\n+        try {\n+            testClass(entry, clazz);\n+        } catch (Exception e) {\n+            if (ec.isInstance(e)) {\n+                System.out.println(\"PASS\");\n+                return;\n+            }\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n@@ -576,0 +591,11 @@\n+\n+    class XEKS extends EncodedKeySpec {\n+        public XEKS(byte[] encodedKey) {\n+            super(encodedKey);\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return \"\";\n+        }\n+    }\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main Chain\n+ * @run main\/timeout=480 Chain\n","filename":"test\/jdk\/java\/security\/SignedObject\/Chain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -30,0 +31,1 @@\n+import java.security.PEMDecoder;\n@@ -38,2 +40,0 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.CRL;\n@@ -43,1 +43,0 @@\n-import java.io.ByteArrayInputStream;\n@@ -48,0 +47,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -95,1 +96,1 @@\n-    private static X509Certificate getTrustedCertificate() throws Exception {\n+    private static X509Certificate getTrustedCertificate() {\n@@ -107,3 +108,1 @@\n-        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream bytes = new ByteArrayInputStream(sCert.getBytes());\n-        return (X509Certificate)certFactory.generateCertificate(bytes);\n+        return pemDecoder.decode(sCert, X509Certificate.class);\n@@ -112,1 +111,1 @@\n-    private static X509Certificate getUserCertificate1() throws Exception {\n+    private static X509Certificate getUserCertificate1() {\n@@ -126,3 +125,1 @@\n-        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream bytes = new ByteArrayInputStream(sCert.getBytes());\n-        return (X509Certificate)certFactory.generateCertificate(bytes);\n+        return pemDecoder.decode(sCert, X509Certificate.class);\n@@ -131,1 +128,1 @@\n-    private static X509Certificate getUserCertificate2() throws Exception {\n+    private static X509Certificate getUserCertificate2() {\n@@ -143,3 +140,1 @@\n-        CertificateFactory certFactory = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream bytes = new ByteArrayInputStream(sCert.getBytes());\n-        return (X509Certificate)certFactory.generateCertificate(bytes);\n+        return pemDecoder.decode(sCert, X509Certificate.class);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathBuilder\/NoExtensions.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+ * @enablePreview\n@@ -39,1 +40,0 @@\n- * @author Xuelei Fan\n@@ -42,3 +42,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n-import java.util.*;\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -46,2 +45,16 @@\n-import java.security.cert.*;\n-import java.security.cert.CertPathValidatorException.BasicReason;\n+import java.security.cert.CertPathBuilder;\n+import java.security.cert.CertStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CollectionCertStoreParameters;\n+import java.security.cert.PKIXBuilderParameters;\n+import java.security.cert.PKIXCertPathBuilderResult;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509CertSelector;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n@@ -186,4 +199,1 @@\n-    private static Set<TrustAnchor> generateTrustAnchors()\n-            throws CertificateException {\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -191,3 +201,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+    private static Set<TrustAnchor> generateTrustAnchors() {\n+        X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -197,1 +206,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -203,4 +212,0 @@\n-        Collection entries = new HashSet();\n-\n-        \/\/ generate certificate from certificate string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -208,1 +213,1 @@\n-        ByteArrayInputStream is;\n+        Collection<DEREncodable> entries = new HashSet<>();\n@@ -210,2 +215,1 @@\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate cert = cf.generateCertificate(is);\n+        DEREncodable cert = pemDecoder.decode(targetCertStr, X509Certificate.class);\n@@ -214,2 +218,1 @@\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n+        cert = pemDecoder.decode(subCaCertStr, X509Certificate.class);\n@@ -218,2 +221,1 @@\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n+        cert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -222,2 +224,1 @@\n-        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n+        cert = pemDecoder.decode(topCrlIssuerCertStr, X509Certificate.class);\n@@ -226,2 +227,1 @@\n-        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n-        cert = cf.generateCertificate(is);\n+        cert = pemDecoder.decode(subCrlIssuerCertStr, X509Certificate.class);\n@@ -231,3 +231,2 @@\n-        is = new ByteArrayInputStream(topCrlStr.getBytes());\n-        Collection mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        DEREncodable mixes = pemDecoder.decode(topCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -235,3 +234,2 @@\n-        is = new ByteArrayInputStream(subCrlStr.getBytes());\n-        mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -240,1 +238,1 @@\n-                            new CollectionCertStoreParameters(entries));\n+                new CollectionCertStoreParameters(entries));\n@@ -248,2 +246,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = null;\n+        String cert;\n@@ -251,1 +248,1 @@\n-            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+            cert = subCaCertStr;\n@@ -253,1 +250,1 @@\n-            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+            cert = subCrlIssuerCertStr;\n@@ -255,1 +252,1 @@\n-            is = new ByteArrayInputStream(targetCertStr.getBytes());\n+            cert = targetCertStr;\n@@ -258,1 +255,1 @@\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = pemDecoder.decode(cert, X509Certificate.class);\n@@ -272,3 +269,1 @@\n-    private static boolean match(String name, Certificate cert)\n-                throws Exception {\n-        X509CertSelector selector = new X509CertSelector();\n+    private static boolean match(String name, Certificate cert) {\n@@ -277,2 +272,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        ByteArrayInputStream is = null;\n+        String newCert;\n@@ -280,1 +274,1 @@\n-            is = new ByteArrayInputStream(subCaCertStr.getBytes());\n+            newCert = subCaCertStr;\n@@ -282,1 +276,1 @@\n-            is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n+            newCert = subCrlIssuerCertStr;\n@@ -284,1 +278,1 @@\n-            is = new ByteArrayInputStream(targetCertStr.getBytes());\n+            newCert = targetCertStr;\n@@ -286,1 +280,1 @@\n-        X509Certificate target = (X509Certificate)cf.generateCertificate(is);\n+        X509Certificate target = pemDecoder.decode(newCert, X509Certificate.class);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathBuilder\/selfIssued\/StatusLoopDependency.java","additions":46,"deletions":52,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @enablePreview\n@@ -39,3 +40,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n-import java.util.*;\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -43,1 +43,3 @@\n-import java.security.cert.*;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.CertPathValidatorException;\n@@ -45,0 +47,16 @@\n+import java.security.cert.CertStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CollectionCertStoreParameters;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -152,0 +170,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -157,10 +177,3 @@\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate targetCert = cf.generateCertificate(is);\n-\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        Certificate subCaCert = cf.generateCertificate(is);\n-\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        Certificate targetCert = pemDecoder.decode(targetCertStr, X509Certificate.class);\n+        Certificate subCaCert =  pemDecoder.decode(subCaCertStr, X509Certificate.class);\n+        Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -169,2 +182,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        targetCert, subCaCert, selfSignedCert});\n+        List<Certificate> list = Arrays.asList(targetCert, subCaCert, selfSignedCert);\n@@ -178,1 +190,0 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -180,3 +191,1 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        final X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -186,1 +195,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -192,1 +201,1 @@\n-        Collection entries = new HashSet();\n+        Collection<DEREncodable> entries = new HashSet<>();\n@@ -195,1 +204,0 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -197,4 +205,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(topCrlStr.getBytes());\n-        Collection mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        DEREncodable mixes = pemDecoder.decode(topCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -202,3 +208,2 @@\n-        is = new ByteArrayInputStream(subCrlStr.getBytes());\n-        mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -207,3 +212,2 @@\n-        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n-        mixes = cf.generateCertificates(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(topCrlIssuerCertStr, X509Certificate.class);\n+        entries.add(mixes);\n@@ -211,3 +215,2 @@\n-        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n-        mixes = cf.generateCertificates(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlIssuerCertStr, X509Certificate.class);\n+        entries.add(mixes);\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/indirectCRL\/CircularCRLTwoLevel.java","additions":40,"deletions":37,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ * @enablePreview\n@@ -39,3 +40,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n-import java.util.*;\n+import java.security.DEREncodable;\n+import java.security.PEMDecoder;\n@@ -43,1 +43,3 @@\n-import java.security.cert.*;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.CertPathValidatorException;\n@@ -45,0 +47,16 @@\n+import java.security.cert.CertStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CollectionCertStoreParameters;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -153,0 +171,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -158,10 +178,3 @@\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate targetCert = cf.generateCertificate(is);\n-\n-        is = new ByteArrayInputStream(subCaCertStr.getBytes());\n-        Certificate subCaCert = cf.generateCertificate(is);\n-\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        Certificate targetCert = pemDecoder.decode(targetCertStr, X509Certificate.class);\n+        Certificate subCaCert = pemDecoder.decode(subCaCertStr, X509Certificate.class);\n+        Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -170,2 +183,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        targetCert, subCaCert, selfSignedCert});\n+        List<Certificate> list = Arrays.asList(targetCert, subCaCert, selfSignedCert);\n@@ -179,5 +191,1 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        final X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -187,1 +195,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -193,1 +201,1 @@\n-        Collection entries = new HashSet();\n+        Collection<DEREncodable> entries = new HashSet<>();\n@@ -198,4 +206,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(topCrlStr.getBytes());\n-        Collection mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        DEREncodable mixes = pemDecoder.decode(topCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -203,3 +209,2 @@\n-        is = new ByteArrayInputStream(subCrlStr.getBytes());\n-        mixes = cf.generateCRLs(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlStr, X509CRL.class);\n+        entries.add(mixes);\n@@ -208,3 +213,2 @@\n-        is = new ByteArrayInputStream(topCrlIssuerCertStr.getBytes());\n-        mixes = cf.generateCertificates(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(topCrlIssuerCertStr, X509Certificate.class);\n+        entries.add(mixes);\n@@ -212,3 +216,2 @@\n-        is = new ByteArrayInputStream(subCrlIssuerCertStr.getBytes());\n-        mixes = cf.generateCertificates(is);\n-        entries.addAll(mixes);\n+        mixes = pemDecoder.decode(subCrlIssuerCertStr, X509Certificate.class);\n+        entries.add(mixes);\n@@ -217,1 +220,1 @@\n-                            new CollectionCertStoreParameters(entries));\n+                new CollectionCertStoreParameters(entries));\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/indirectCRL\/CircularCRLTwoLevelRevoked.java","additions":41,"deletions":38,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690\n+ * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690 8363972\n@@ -465,0 +465,2 @@\n+                \/\/ lenient parsing. Hyphen-minus should match the localized minus sign\n+                {FORMAT_SE_SHORT, \"-8\\u00a0mn\", -8000000L, Long.class},\n@@ -506,2 +508,1 @@\n-            \/\/ Localized minus sign should be used\n-            {FORMAT_SE_SHORT, \"-8\\u00a0mn\", null},};\n+        };\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit DateFormatTest\n+ * @run junit\/timeout=480 DateFormatTest\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/DateFormatTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @bug 8366517\n@@ -46,0 +47,1 @@\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -208,0 +210,6 @@\n+\n+    @Test\n+    void nullLocaleTest() {\n+        assertThrows(NullPointerException.class, () -> new DateFormatSymbols(null));\n+        assertThrows(NullPointerException.class, () -> DateFormatSymbols.getInstance(null));\n+    }\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/IntlTestDateFormatSymbols.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366401\n+ * @summary Check serialization of DecimalFormatSymbols. That is, ensure the\n+ *          behavior for each stream version is correct during de-serialization.\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED DFSSerializationTest\n+ *\/\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Field;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Currency;\n+import java.util.Locale;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class DFSSerializationTest {\n+\n+    @Nested\n+    class VersionTests {\n+\n+        \/\/ Ensure correct monetarySeparator and exponential field defaults\n+        \/\/ Reads monetary from decimal, and sets exponential to 'E'\n+        @Test\n+        public void version0Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(0)\n+                    .set(\"monetarySeparator\", '~')\n+                    .set(\"exponential\", 'Z')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            \/\/ Check exponential is set to proper default 'E', not 'Z'\n+            assertEquals('E', readField(dfs, \"exponential\"));\n+            \/\/ Ensure that mSep is based on dSep, and is not '~'\n+            assertNotEquals('~', dfs.getMonetaryDecimalSeparator());\n+            assertEquals(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator());\n+        }\n+\n+        \/\/ Version 1 did not have a locale field, and it defaulted to Locale.ROOT.\n+        \/\/ Note that other versions did allow a locale field, which was nullable.\n+        \/\/ E.g. see nullableLocaleTest which does not set locale when it is `null`\n+        @Test\n+        public void version1Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(1)\n+                    .set(\"locale\", null)\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(Locale.ROOT, dfs.getLocale());\n+        }\n+\n+        \/\/ Version 2 did not have an exponential separator, and created it via exponent\n+        \/\/ char field.\n+        @Test\n+        public void version2Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(2)\n+                    .set(\"exponentialSeparator\", null)\n+                    .set(\"exponential\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(\"~\", dfs.getExponentSeparator());\n+        }\n+\n+        \/\/ Version 3 didn't have perMillText, percentText, and minusSignText.\n+        \/\/ These were created from the corresponding char equivalents.\n+        @Test\n+        public void version3Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(3)\n+                    .set(\"perMillText\", null)\n+                    .set(\"percentText\", null)\n+                    .set(\"minusSignText\", null)\n+                    .set(\"perMill\", '~')\n+                    .set(\"percent\", '~')\n+                    .set(\"minusSign\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            \/\/ Need to check these String fields using reflection, since they\n+            \/\/ are not exposed via the public API\n+            assertEquals(\"~\", readField(dfs, \"perMillText\"));\n+            assertEquals(\"~\", readField(dfs, \"percentText\"));\n+            assertEquals(\"~\", readField(dfs, \"minusSignText\"));\n+        }\n+\n+        \/\/ Version 4 did not have monetaryGroupingSeparator. It should be based\n+        \/\/ off of groupingSeparator.\n+        @Test\n+        public void version4Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(4)\n+                    .set(\"monetaryGroupingSeparator\", 'Z')\n+                    .set(\"groupingSeparator\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator());\n+        }\n+    }\n+\n+    \/\/ Up-to-date DFS stream versions do not expect a null locale since the\n+    \/\/ standard DecimalFormatSymbols API forbids it. However, this was not always\n+    \/\/ the case and previous stream versions can contain a null locale. Thus,\n+    \/\/ ensure that a null locale does not cause number data loading to fail.\n+    @Test\n+    public void nullableLocaleTest() {\n+        var bytes = ser(new DFSBuilder()\n+                .set(\"locale\", null)\n+                .set(\"minusSignText\", \"zFoo\")\n+                .set(\"minusSign\", 'z') \/\/ Set so that char\/String forms agree\n+                .build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertNull(dfs.getLocale());\n+        \/\/ LMS should be based off of minusSignText when locale is null\n+        assertEquals(\"zFoo\", readField(dfs, \"lenientMinusSigns\"));\n+    }\n+\n+    \/\/ readObject fails when the {@code char} and {@code String} representations\n+    \/\/ of percent, per mille, and\/or minus sign disagree.\n+    @Test\n+    public void disagreeingTextTest() {\n+        var expected = \"'char' and 'String' representations of either percent, \" +\n+                \"per mille, and\/or minus sign disagree.\";\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"minusSignText\", \"Z\")\n+                        .set(\"minusSign\", 'X')\n+                        .build()))).getMessage());\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"perMillText\", \"Z\")\n+                        .set(\"perMill\", 'X')\n+                        .build()))).getMessage());\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"percentText\", \"Z\")\n+                        .set(\"percent\", 'X')\n+                        .build()))).getMessage());\n+    }\n+\n+    \/\/ Ensure the serial version is updated to the current after de-serialization.\n+    @Test\n+    public void updatedVersionTest() {\n+        var bytes = ser(new DFSBuilder().setVer(-25).build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(5, readField(dfs, \"serialVersionOnStream\"));\n+    }\n+\n+    \/\/ Should set currency from 4217 code when it is valid.\n+    @Test\n+    public void validIntlCurrencyTest() {\n+        var bytes = ser(new DFSBuilder().set(\"intlCurrencySymbol\", \"JPY\").build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(Currency.getInstance(\"JPY\"), dfs.getCurrency());\n+    }\n+\n+    \/\/ Should not set currency when 4217 code is invalid, it remains null.\n+    @Test\n+    public void invalidIntlCurrencyTest() {\n+        var bytes = ser(new DFSBuilder()\n+                .set(\"intlCurrencySymbol\", \">.,\")\n+                .set(\"locale\", Locale.JAPAN)\n+                .build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        \/\/ Can not init off invalid 4217 code, remains null\n+        assertNull(dfs.getCurrency());\n+    }\n+\n+\/\/ Utilities ----\n+\n+    \/\/ Utility to serialize\n+    private static byte[] ser(Object obj) {\n+        return assertDoesNotThrow(() -> {\n+            try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+                 ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream)) {\n+                oos.writeObject(obj);\n+                return byteArrayOutputStream.toByteArray();\n+            }\n+        }, \"Unexpected error during serialization\");\n+    }\n+\n+    \/\/ Utility to deserialize\n+    private static DecimalFormatSymbols deSer(byte[] bytes) throws IOException, ClassNotFoundException {\n+        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n+             ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream)) {\n+            return (DecimalFormatSymbols) ois.readObject();\n+        }\n+    }\n+\n+    \/\/ Utility to read a private field\n+    private static Object readField(DecimalFormatSymbols dfs, String name) {\n+        return assertDoesNotThrow(() -> {\n+            var field = DecimalFormatSymbols.class.getDeclaredField(name);\n+            field.setAccessible(true);\n+            return field.get(dfs);\n+        }, \"Unexpected error during field reading\");\n+    }\n+\n+    \/\/ Utility class to build instances of DFS via reflection\n+    private static class DFSBuilder {\n+\n+        private final DecimalFormatSymbols dfs;\n+\n+        private DFSBuilder() {\n+            dfs = new DecimalFormatSymbols();\n+        }\n+\n+        private DFSBuilder setVer(Object value) {\n+            return set(\"serialVersionOnStream\", value);\n+        }\n+\n+        private DFSBuilder set(String field, Object value) {\n+            return assertDoesNotThrow(() -> {\n+                Field f = dfs.getClass().getDeclaredField(field);\n+                f.setAccessible(true);\n+                f.set(dfs, value);\n+                return this;\n+            }, \"Unexpected error during reflection setting\");\n+        }\n+\n+        private DecimalFormatSymbols build() {\n+            return dfs;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DFSSerializationTest.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8362448\n+ * @summary Verify DecimalFormat::format on doubles.\n+ * @run junit DoubleFormattingTest\n+ * @run junit\/othervm -Djdk.compat.DecimalFormat=true DoubleFormattingTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.util.Formatter;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class DoubleFormattingTest {\n+\n+    private static final boolean COMPAT = Boolean.getBoolean(\"jdk.compat.DecimalFormat\");\n+\n+    static Stream<Arguments> testFormat() {\n+        return Stream.of(\n+                Arguments.of(4.8726570057E288, 0),\n+                Arguments.of(7.3879E20, 0),\n+                Arguments.of(1.9400994884341945E25, 0),\n+                Arguments.of(6.3E-322, 324)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testFormat(double v, int minFractionDigits) {\n+        DecimalFormat df = (DecimalFormat) NumberFormat.getNumberInstance(Locale.ROOT);\n+        df.setGroupingUsed(false);\n+        df.setMinimumFractionDigits(minFractionDigits);\n+        String actual = df.format(v);\n+        Formatter fmt = new Formatter(Locale.ROOT);\n+        fmt.format(\"%.\" + minFractionDigits + \"f\", v);\n+        String expected = fmt.toString();\n+        if (COMPAT) {\n+            assertNotEquals(expected, actual);\n+        } else {\n+            assertEquals(expected, actual);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DoubleFormattingTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8282625\n+ * @bug 8282625 8366517\n@@ -47,0 +47,1 @@\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -149,0 +150,6 @@\n+\n+    @Test\n+    void nullLocaleTest() {\n+        assertThrows(NullPointerException.class, () -> new DecimalFormatSymbols(null));\n+        assertThrows(NullPointerException.class, () -> DecimalFormatSymbols.getInstance(null));\n+    }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/IntlTestDecimalFormatSymbols.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8363972\n+ * @summary Unit tests for lenient minus parsing\n+ * @modules jdk.localedata\n+ *          java.base\/java.text:+open\n+ * @run junit LenientMinusSignTest\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class LenientMinusSignTest {\n+    private static final Locale FINNISH = Locale.of(\"fi\");\n+    private static final DecimalFormatSymbols DFS =\n+        new DecimalFormatSymbols(Locale.ROOT);\n+    private static final String MINUS_PATTERN = \"\\u002D\";\n+\n+    \/\/ \"parseLenient\" data from CLDR v47. These data are subject to change\n+    private static Stream<String> minus() {\n+        return Stream.of(\n+            MINUS_PATTERN,     \/\/ \"-\" Hyphen-Minus\n+            \"\\uFF0D\",          \/\/ \"－\" Fullwidth Hyphen-Minus\n+            \"\\uFE63\",          \/\/ \"﹣\" Small Hyphen-Minus\n+            \"\\u2010\",          \/\/ \"‐\" Hyphen\n+            \"\\u2011\",          \/\/ \"‑\" Non-Breaking Hyphen\n+            \"\\u2012\",          \/\/ \"‒\" Figure Dash\n+            \"\\u2013\",          \/\/ \"–\" En Dash\n+            \"\\u2212\",          \/\/ \"−\" Minus Sign\n+            \"\\u207B\",          \/\/ \"⁻\" Superscript Minus\n+            \"\\u208B\",          \/\/ \"₋\" Subscript Minus\n+            \"\\u2796\"           \/\/ \"➖\" Heavy Minus Sign\n+        );\n+    }\n+\n+    @Test\n+    void testFinnishMinus() throws ParseException {\n+        \/\/ originally reported in JDK-8189097\n+        \/\/ Should not throw a ParseException\n+        assertEquals(NumberFormat.getInstance(FINNISH).parse(MINUS_PATTERN + \"1,5\"), -1.5);\n+    }\n+\n+    @Test\n+    void testFinnishMinusStrict() {\n+        \/\/ Should throw a ParseException\n+        var nf = NumberFormat.getInstance(FINNISH);\n+        nf.setStrict(true);\n+        assertThrows(ParseException.class, () -> nf.parse(MINUS_PATTERN + \"1,5\"));\n+    }\n+\n+    @Test\n+    void testReadObject() throws IOException, ClassNotFoundException, ParseException {\n+        \/\/ check if deserialized NF works with lenient minus. Using the Finnish example\n+        var nf = NumberFormat.getInstance(FINNISH);\n+        NumberFormat nfDeser;\n+        byte[] serialized;\n+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(bos)) {\n+            out.writeObject(nf);\n+            out.flush();\n+            serialized = bos.toByteArray();\n+        }\n+        try (ByteArrayInputStream bis = new ByteArrayInputStream(serialized);\n+             ObjectInputStream in = new ObjectInputStream(bis)) {\n+            nfDeser = (NumberFormat) in.readObject();\n+        }\n+        assertEquals(nfDeser.parse(MINUS_PATTERN + \"1,5\"), -1.5);\n+    }\n+\n+    \/\/ White box test. modifies the private `lenientMinusSigns` field in the DFS\n+    @Test\n+    void testSupplementary() throws IllegalAccessException, NoSuchFieldException, ParseException {\n+        var dfs = new DecimalFormatSymbols(Locale.ROOT);\n+        MethodHandles.privateLookupIn(DecimalFormatSymbols.class, MethodHandles.lookup())\n+            .findVarHandle(DecimalFormatSymbols.class, \"lenientMinusSigns\", String.class)\n+            .set(dfs, \"-🙂\");\n+        \/\/ Direct match. Should succeed\n+        var df = new DecimalFormat(\"#.#;🙂#.#\", dfs);\n+        assertEquals(df.parse(\"🙂1.5\"), -1.5);\n+\n+        \/\/ Fail if the lengths of negative prefixes differ\n+        assertThrows(ParseException.class, () -> df.parse(\"-1.5\"));\n+        var df2= new DecimalFormat(\"#.#;-#.#\", dfs);\n+        assertThrows(ParseException.class, () -> df2.parse(\"🙂1.5\"));\n+    }\n+\n+    @Nested\n+    class DecimalFormatTest {\n+        private static final String PREFIX = \"+#;-#\";\n+        private static final String SUFFIX = \"#+;#-\";\n+        private static final String LONG_PREFIX = \"pos#;-neg#\";\n+        private static final String LONG_SUFFIX = \"#pos;#neg-\";\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientPrefix(String sign) throws ParseException {\n+            var df = new DecimalFormat(PREFIX, DFS);\n+            df.setStrict(false);\n+            assertEquals(MINUS_PATTERN + \"1\", df.format(df.parse(sign + \"1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientSuffix(String sign) throws ParseException {\n+            var df = new DecimalFormat(SUFFIX, DFS);\n+            df.setStrict(false);\n+            assertEquals(\"1\" + MINUS_PATTERN, df.format(df.parse(\"1\" + sign)));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictPrefix(String sign) throws ParseException {\n+            var df = new DecimalFormat(PREFIX, DFS);\n+            df.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(MINUS_PATTERN + \"1\", df.format(df.parse(sign + \"1\")));\n+            } else {\n+                assertThrows(ParseException.class, () -> df.parse(sign + \"1\"));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictSuffix(String sign) throws ParseException {\n+            var df = new DecimalFormat(SUFFIX, DFS);\n+            df.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(\"1\" + MINUS_PATTERN, df.format(df.parse(\"1\" + sign)));\n+            } else {\n+                assertThrows(ParseException.class, () -> df.parse(\"1\" + sign));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongPrefix(String sign) throws ParseException {\n+            var df = new DecimalFormat(LONG_PREFIX, DFS);\n+            assertEquals(MINUS_PATTERN + \"neg1\", df.format(df.parse(sign + \"neg1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongSuffix(String sign) throws ParseException {\n+            var df = new DecimalFormat(LONG_SUFFIX, DFS);\n+            assertEquals(\"1neg\" + MINUS_PATTERN, df.format(df.parse(\"1neg\" + sign)));\n+        }\n+    }\n+\n+    @Nested\n+    class CompactNumberFormatTest {\n+        private static final String[] PREFIX = {\"+0;-0\"};\n+        private static final String[] SUFFIX = {\"0+;0-\"};\n+        private static final String[] LONG_PREFIX = {\"pos0;-neg0\"};\n+        private static final String[] LONG_SUFFIX = {\"0pos;0neg-\"};\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientPrefix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, PREFIX);\n+            cnf.setStrict(false);\n+            assertEquals(MINUS_PATTERN + \"1\", cnf.format(cnf.parse(sign + \"1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLenientSuffix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, SUFFIX);\n+            cnf.setStrict(false);\n+            assertEquals(\"1\" + MINUS_PATTERN, cnf.format(cnf.parse(\"1\" + sign)));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictPrefix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, PREFIX);\n+            cnf.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(MINUS_PATTERN + \"1\", cnf.format(cnf.parse(sign + \"1\")));\n+            } else {\n+                assertThrows(ParseException.class, () -> cnf.parse(sign + \"1\"));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testStrictSuffix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, SUFFIX);\n+            cnf.setStrict(true);\n+            if (sign.equals(MINUS_PATTERN)) {\n+                assertEquals(\"1\" + MINUS_PATTERN, cnf.format(cnf.parse(\"1\" + sign)));\n+            } else {\n+                assertThrows(ParseException.class, () -> cnf.parse(\"1\" + sign));\n+            }\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongPrefix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, LONG_PREFIX);\n+            assertEquals(MINUS_PATTERN + \"neg1\", cnf.format(cnf.parse(sign + \"neg1\")));\n+        }\n+\n+        @ParameterizedTest\n+        @MethodSource(\"LenientMinusSignTest#minus\")\n+        public void testLongSuffix(String sign) throws ParseException {\n+            var cnf = new CompactNumberFormat(\"0\", DFS, LONG_SUFFIX);\n+            assertEquals(\"1neg\" + MINUS_PATTERN, cnf.format(cnf.parse( \"1neg\" + sign)));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientMinusSignTest.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,6 +24,0 @@\n-\/**\n- * @test\n- * @bug 4109023 4153060 4153061\n- * @summary test ParsePosition and FieldPosition\n- * @run junit PositionTest\n- *\/\n@@ -42,2 +36,6 @@\n-import java.text.*;\n-import java.io.*;\n+\/*\n+ * @test\n+ * @bug 4109023 4153060 4153061 8366400\n+ * @summary test ParsePosition and FieldPosition\n+ * @run junit PositionTest\n+ *\/\n@@ -47,0 +45,8 @@\n+import java.text.DecimalFormat;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -51,0 +57,44 @@\n+    \/\/ Parsing text which contains un-parseable data, but the index\n+    \/\/ begins at the valid portion. Ensure PP is properly updated.\n+    @Test\n+    public void modifiedPositionTest() {\n+        var df = new DecimalFormat(\"YY#\");\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        var pp = new ParsePosition(9);\n+        assertEquals(123L, assertDoesNotThrow(() -> df.parse(\"FOOBARBAZYY123\", pp)));\n+        assertEquals(-1, pp.getErrorIndex());\n+        assertEquals(14, pp.getIndex());\n+    }\n+\n+    \/\/ Clearly invalid index value that could not work under any scenarios\n+    \/\/ Specifically, ensuring no SIOOBE during affix matching\n+    @Test\n+    public void invalidPositionParseTest() {\n+        var df = new DecimalFormat();\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"1\", new ParsePosition(-1))));\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"1\", new ParsePosition(Integer.MAX_VALUE))));\n+    }\n+\n+    \/\/ When prefix matching, position + affix length is greater than parsed String length\n+    \/\/ Ensure we do not index out of bounds of the length of the parsed String\n+    @Test\n+    public void prefixMatchingTest() {\n+        var df = new DecimalFormat(\"ZZZ#;YYY#\");\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        \/\/ 0 + 3 > 2 = (pos + prefix > text)\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"Z1\", new ParsePosition(0))));\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"Y1\", new ParsePosition(0))));\n+    }\n+\n+    \/\/ When suffix matching, position + affix length is greater than parsed String length\n+    \/\/ Ensure we do not index out of bounds of the length of the parsed String\n+    @Test\n+    public void suffixMatchingTest() {\n+        var df = new DecimalFormat(\"#ZZ;#YY\");\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        \/\/ Matches prefix properly first. Then 3 + 2 > 4 = (pos + suffix > text)\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"123Z\", new ParsePosition(0))));\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"123Y\", new ParsePosition(0))));\n+    }\n+\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/PositionTest.java","additions":59,"deletions":9,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,3 @@\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeParseException;\n@@ -73,1 +76,1 @@\n- * @bug 8273369 8331202\n+ * @bug 8273369 8331202 8364752\n@@ -154,0 +157,54 @@\n+\n+    @DataProvider\n+    private Object[][] valid_instants() {\n+        var I1 = OffsetDateTime.of(2017, 1, 1, 0, 0, 0, 0, ZoneOffset.of(\"+02\")).toInstant();\n+        var I2 = OffsetDateTime.of(2017, 1, 1, 0, 0, 0, 0, ZoneOffset.of(\"+02:02\")).toInstant();\n+        var I3 = OffsetDateTime.of(2017, 1, 1, 0, 0, 0, 0, ZoneOffset.of(\"+02:02:02\")).toInstant();\n+        var I4 = OffsetDateTime.of(2017, 1, 1, 0, 0, 0, 0, ZoneOffset.of(\"Z\")).toInstant();\n+        return new Object[][] {\n+            {\"2017-01-01T00:00:00.000+02\", I1},\n+            {\"2017-01-01T00:00:00.000+0200\", I1},\n+            {\"2017-01-01T00:00:00.000+02:00\", I1},\n+            {\"2017-01-01T00:00:00.000+020000\", I1},\n+            {\"2017-01-01T00:00:00.000+02:00:00\", I1},\n+\n+            {\"2017-01-01T00:00:00.000+0202\", I2},\n+            {\"2017-01-01T00:00:00.000+02:02\", I2},\n+\n+            {\"2017-01-01T00:00:00.000+020202\", I3},\n+            {\"2017-01-01T00:00:00.000+02:02:02\", I3},\n+\n+            {\"2017-01-01T00:00:00.000Z\", I4},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"valid_instants\")\n+    public void test_parse_valid(String instant, Instant expected) {\n+        assertEquals(Instant.parse(instant), expected);\n+    }\n+\n+    @DataProvider\n+    private Object[][] invalid_instants() {\n+        return new Object[][] {\n+            {\"2017-01-01T00:00:00.000\"},\n+            {\"2017-01-01T00:00:00.000+0\"},\n+            {\"2017-01-01T00:00:00.000+0:\"},\n+            {\"2017-01-01T00:00:00.000+02:\"},\n+            {\"2017-01-01T00:00:00.000+020\"},\n+            {\"2017-01-01T00:00:00.000+02:0\"},\n+            {\"2017-01-01T00:00:00.000+02:0:\"},\n+            {\"2017-01-01T00:00:00.000+02:00:\"},\n+            {\"2017-01-01T00:00:00.000+02:000\"},\n+            {\"2017-01-01T00:00:00.000+02:00:0\"},\n+            {\"2017-01-01T00:00:00.000+02:00:0:\"},\n+            {\"2017-01-01T00:00:00.000+0200000\"},\n+            {\"2017-01-01T00:00:00.000+02:00:000\"},\n+            {\"2017-01-01T00:00:00.000+02:00:00:\"},\n+            {\"2017-01-01T00:00:00.000UTC\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invalid_instants\")\n+    public void test_parse_invalid(String instant) {\n+        assertThrows(DateTimeParseException.class, () -> Instant.parse(instant));\n+    }\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/TestInstant.java","additions":59,"deletions":2,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run testng\/othervm -Xmx2g WhiteBoxResizeTest\n+ * @run testng\/othervm\/timeout=960 -Xmx2g WhiteBoxResizeTest\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Djava.locale.providers=CLDR,SPI CurrencyNameProviderTest\n+ * @run main\/othervm\/timeout=480 -Djava.locale.providers=CLDR,SPI CurrencyNameProviderTest\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/CurrencyNameProviderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run junit\/othervm -Djava.locale.providers=CLDR,SPI LocaleNameProviderTest\n+ * @run junit\/othervm\/timeout=960 -Djava.locale.providers=CLDR,SPI LocaleNameProviderTest\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/LocaleNameProviderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,5 @@\n+import javax.swing.SwingConstants;\n+import javax.swing.BoxLayout;\n+import javax.swing.Box;\n+import java.awt.Dimension;\n+import java.awt.Component;\n@@ -101,1 +106,2 @@\n-        var label = new JLabel(SDF.format(new Date()));\n+        contents.setSize(350, 250);\n+        \/\/ Panel with vertical layout\n@@ -103,0 +109,8 @@\n+        panel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));\n+        \/\/ Time zone ID label\n+        var timeZoneID = new JLabel(\"Time zone ID: \" + SDF.getTimeZone().getID(), SwingConstants.CENTER);\n+        timeZoneID.setAlignmentX(Component.CENTER_ALIGNMENT);\n+        \/\/ Time label\n+        var label = new JLabel(SDF.format(new Date()), SwingConstants.CENTER);\n+        label.setAlignmentX(Component.CENTER_ALIGNMENT);\n+        \/\/ Update button\n@@ -104,0 +118,7 @@\n+        button.setAlignmentX(Component.CENTER_ALIGNMENT);\n+        \/\/ Add components with spacing\n+        panel.add(Box.createRigidArea(new Dimension(0, 10)));\n+        panel.add(timeZoneID);\n+        panel.add(Box.createRigidArea(new Dimension(0, 5)));\n+        panel.add(label);\n+        panel.add(Box.createRigidArea(new Dimension(0, 10)));\n@@ -105,3 +126,2 @@\n-        contents.setSize(350, 250);\n-        contents.add(label, BorderLayout.NORTH);\n-        contents.add(panel, BorderLayout.CENTER);\n+        contents.add(panel);\n+\n@@ -110,0 +130,3 @@\n+            \/\/ Clear JVM cached timezone and force reload from OS\n+            TimeZone.setDefault(null);\n+            System.setProperty(\"user.timezone\", \"\");\n@@ -112,0 +135,1 @@\n+            timeZoneID.setText(\"Time zone ID: \" + tz.getID());\n","filename":"test\/jdk\/java\/util\/TimeZone\/DefaultTimeZoneTest.java","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run main\/othervm -Xmx64m BasicCancelTest\n+ * @run main\/othervm\/timeout=480 -Xmx64m BasicCancelTest\n","filename":"test\/jdk\/java\/util\/concurrent\/ScheduledThreadPoolExecutor\/BasicCancelTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run main\/othervm FileHandlerPath\n+ * @run main\/othervm\/timeout=480 FileHandlerPath\n","filename":"test\/jdk\/java\/util\/logging\/FileHandlerPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -52,0 +53,1 @@\n+ * @library \/test\/lib\n@@ -63,5 +65,0 @@\n-    public static final double TIMEOUT_FACTOR;\n-    static {\n-        String toFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-        TIMEOUT_FACTOR = Double.parseDouble(toFactor);\n-    }\n@@ -69,1 +66,1 @@\n-        return Math.min(count, (int) Math.ceil(TIMEOUT_FACTOR * count));\n+        return Math.min(count, (int) Math.ceil(Utils.TIMEOUT_FACTOR * count));\n","filename":"test\/jdk\/java\/util\/logging\/LogManager\/Configuration\/updateConfiguration\/HandlersOnComplexResetUpdate.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -52,0 +53,1 @@\n+ * @library \/test\/lib\n@@ -63,5 +65,0 @@\n-    public static final double TIMEOUT_FACTOR;\n-    static {\n-        String toFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-        TIMEOUT_FACTOR = Double.parseDouble(toFactor);\n-    }\n@@ -69,1 +66,1 @@\n-        return Math.min(count, (int) Math.ceil(TIMEOUT_FACTOR * count));\n+        return Math.min(count, (int) Math.ceil(Utils.TIMEOUT_FACTOR * count));\n","filename":"test\/jdk\/java\/util\/logging\/LogManager\/Configuration\/updateConfiguration\/HandlersOnComplexUpdate.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+timeout.default.seconds=480\n","filename":"test\/jdk\/java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+timeout.default.seconds=480\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Test basic deflater & inflater functionality\n+ * @summary Test basic deflater and inflater functionality\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480 DeInflate\n","filename":"test\/jdk\/java\/util\/zip\/DeInflate.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng TestZipFileEncodings\n+ * @run testng\/timeout=480 TestZipFileEncodings\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/TestZipFileEncodings.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4421190\n- * @summary Tests that Image I\/O statics may be referenced properly from\n- *          multiple AppContexts, as would be the case for multiple Applets in a\n- *          single VM. Each AppContext should get its own copy of the registry\n- *          and the caching parameters in the ImageIO class.\n- * @modules java.desktop\/sun.awt\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-\n-import javax.imageio.ImageIO;\n-import javax.imageio.spi.IIORegistry;\n-\n-import sun.awt.SunToolkit;\n-\n-class TestThread extends Thread {\n-\n-    IIORegistry registry;\n-    boolean useCache;\n-    File cacheDirectory;\n-    boolean cacheSettingsOK = false;\n-    String threadName;\n-\n-    boolean gotCrosstalk = false;\n-\n-    public TestThread(ThreadGroup tg,\n-                      boolean useCache, File cacheDirectory,\n-                      String threadName) {\n-        super(tg, threadName);\n-        this.useCache = useCache;\n-        this.cacheDirectory = cacheDirectory;\n-        this.threadName = threadName;\n-    }\n-\n-    public void run() {\n-\/\/          System.out.println(\"Thread \" + threadName + \" in thread group \" +\n-\/\/                             getThreadGroup().getName());\n-\n-        \/\/ Create a new AppContext as though we were an applet\n-        SunToolkit.createNewAppContext();\n-\n-        \/\/ Get default registry and store reference\n-        this.registry = IIORegistry.getDefaultInstance();\n-\n-        for (int i = 0; i < 10; i++) {\n-\/\/              System.out.println(threadName +\n-\/\/                                 \": setting cache parameters to \" +\n-\/\/                                 useCache + \", \" + cacheDirectory);\n-            ImageIO.setUseCache(useCache);\n-            ImageIO.setCacheDirectory(cacheDirectory);\n-\n-            try {\n-                sleep(1000L);\n-            } catch (InterruptedException e) {\n-            }\n-\n-\/\/              System.out.println(threadName + \": reading cache parameters\");\n-            boolean newUseCache = ImageIO.getUseCache();\n-            File newCacheDirectory = ImageIO.getCacheDirectory();\n-            if (newUseCache != useCache ||\n-                newCacheDirectory != cacheDirectory) {\n-\/\/                  System.out.println(threadName + \": got \" +\n-\/\/                                     newUseCache + \", \" +\n-\/\/                                     newCacheDirectory);\n-\/\/                  System.out.println(threadName + \": crosstalk encountered!\");\n-                gotCrosstalk = true;\n-            }\n-        }\n-    }\n-\n-    public IIORegistry getRegistry() {\n-        return registry;\n-    }\n-\n-    public boolean gotCrosstalk() {\n-        return gotCrosstalk;\n-    }\n-}\n-\n-public class AppContextTest {\n-\n-    public AppContextTest() {\n-        ThreadGroup tg0 = new ThreadGroup(\"ThreadGroup0\");\n-        ThreadGroup tg1 = new ThreadGroup(\"ThreadGroup1\");\n-\n-        TestThread t0 =\n-            new TestThread(tg0, false, null, \"TestThread 0\");\n-        TestThread t1 =\n-            new TestThread(tg1, true, new File(\".\"), \"TestThread 1\");\n-\n-        t0.start();\n-        t1.start();\n-\n-        try {\n-            t0.join();\n-        } catch (InterruptedException ie0) {\n-        }\n-        try {\n-            t1.join();\n-        } catch (InterruptedException ie1) {\n-        }\n-\n-        if (t0.gotCrosstalk() || t1.gotCrosstalk()) {\n-            throw new RuntimeException(\"ImageIO methods had crosstalk!\");\n-        }\n-\n-        if (t0.getRegistry() == t1.getRegistry()) {\n-            throw new RuntimeException(\"ThreadGroups had same IIORegistry!\");\n-        }\n-    }\n-\n-    public static void main(String[] args) throws IOException {\n-        new AppContextTest();\n-    }\n-}\n","filename":"test\/jdk\/javax\/imageio\/AppContextTest.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8364768\n+ * @summary Tests that the standard plugins flush the stream after writing a complete image.\n+ *\/\n+\n+import static java.awt.Color.WHITE;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+import java.io.ByteArrayOutputStream;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.stream.FileCacheImageOutputStream;\n+\n+public class FlushTest {\n+\n+    static final int SZ = 1000;\n+    static BufferedImage bi;\n+    static final String[] FORMATS = { \"jpg\", \"png\", \"gif\", \"tiff\", \"bmp\", \"wbmp\" } ;\n+    static boolean failed = false;\n+\n+    public static void main(String[] args) throws IOException {\n+\n+        bi = new BufferedImage(SZ, SZ, BufferedImage.TYPE_BYTE_BINARY);\n+        Graphics2D g2d = bi.createGraphics();\n+        g2d.setPaint(WHITE);\n+        g2d.fillRect(0, 0, SZ, SZ);\n+\n+        for (String f : FORMATS) {\n+            testWrite(f);\n+        }\n+        if (failed) {\n+           throw new RuntimeException(\"Stream sizes differ.\");\n+        }\n+    }\n+\n+    static void testWrite(String fmt) throws IOException {\n+        ImageWriter iw = ImageIO.getImageWritersBySuffix(fmt).next();\n+        System.out.println(iw);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        FileCacheImageOutputStream fcs = new FileCacheImageOutputStream(baos, null);\n+        iw.setOutput(fcs);\n+        iw.write(bi);\n+        int sz0 = baos.size();\n+        fcs.close();\n+        int sz1 = baos.size();\n+        System.out.println(\"fmt=\" + fmt + \" sizes=\" + sz0 + \", \" + sz1);\n+        if (sz0 != sz1) {\n+           failed = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/FlushTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8364135\n+ * @summary Test verifies that jpeg image reader throws\n+ *          IndexOutOfBoundsException when \"-1\" image index is used.\n+ * @run main JpegNegativeImageIndexTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.concurrent.Callable;\n+\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+\n+public class JpegNegativeImageIndexTest {\n+\n+    private static boolean failed;\n+\n+    private static void checkException(boolean exceptionReceived,\n+                                       String testName) {\n+        if (!exceptionReceived) {\n+            System.out.println(\"Didn't receive IndexOutOfBoundsException for \"\n+                + testName);\n+            failed = true;\n+        }\n+    }\n+\n+    private static void testMethod(String methodName,\n+                                   Callable<?> method) {\n+        boolean exceptionReceived = false;\n+        System.out.println(\"Testing \" + methodName);\n+        try {\n+            method.call();\n+        } catch (Exception e) {\n+            if (e instanceof IndexOutOfBoundsException) {\n+                exceptionReceived = true;\n+            }\n+        }\n+        checkException(exceptionReceived, methodName);\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        Iterator<ImageReader> readers =\n+            ImageIO.getImageReadersByFormatName(\"jpeg\");\n+        if (!readers.hasNext()) {\n+            throw new RuntimeException(\"No jpeg image readers found\");\n+        }\n+\n+        ImageReader ir = readers.next();\n+\n+        testMethod(\"getImageTypes()\", () -> ir.getImageTypes(-1));\n+        testMethod(\"getWidth()\", () -> ir.getWidth(-1));\n+        testMethod(\"getHeight()\", () -> ir.getHeight(-1));\n+        testMethod(\"getRawImageType()\", () -> ir.getRawImageType(-1));\n+\n+        if (failed) {\n+            throw new RuntimeException(\"JpegImageReader didn't throw required\" +\n+                \" IndexOutOfBoundsException for -1 image index\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegNegativeImageIndexTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8364227\n+ * @summary Test various null parameters and verify Exceptions thrown\n+ * @modules java.management.rmi\n+ * @run main ExceptionTestNulls\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import javax.management.AttributeNotFoundException;\n+import javax.management.ObjectName;\n+import javax.management.InstanceAlreadyExistsException;\n+import javax.management.InstanceNotFoundException;\n+import javax.management.InvalidAttributeValueException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.MBeanException;\n+import javax.management.MBeanServer;\n+import javax.management.MBeanServerConnection;\n+import javax.management.MBeanServerFactory;\n+import javax.management.NotCompliantMBeanException;\n+import javax.management.NotificationListener;\n+import javax.management.ReflectionException;\n+import javax.management.RuntimeOperationsException;\n+\n+public class ExceptionTestNulls {\n+\n+    public interface MyMBean {\n+    }\n+\n+    public class My implements MyMBean {\n+    }\n+\n+    private int count;\n+\n+    public static void main(String args[]) throws Exception {\n+        ExceptionTestNulls test = new ExceptionTestNulls();\n+        test.run();\n+    }\n+\n+    public ExceptionTestNulls() {\n+        count = 0; \/\/ Simple index for printing tests, for readability.\n+    }\n+\n+    public void run() {\n+\n+        try {\n+        ObjectName name = new ObjectName(\"a:b=c\");\n+        ObjectName namePattern = new ObjectName(\"*:type=Foo\");\n+        My myMy = new My();\n+            MBeanServer mbs = MBeanServerFactory.newMBeanServer();\n+\n+            try {\n+                \/\/ createMBean with null className\n+                mbs.createMBean((String) null, name, name, new Object[0], new String[0]);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ createMBean with ObjectName as a pattern\n+                mbs.createMBean(\"myMy\", namePattern, name, new Object[0], new String[0]);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ registerMBean with null Object\n+                mbs.registerMBean(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ registerMBean with no name available\n+                mbs.registerMBean(myMy, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ unregisterMBean with null ObjectName\n+                mbs.unregisterMBean(null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                mbs.isRegistered(null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                mbs.getAttribute(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                mbs.getAttribute(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.getAttributes(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.getAttributes(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttribute(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttribute(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttributes(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttributes(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.addNotificationListener(null, (NotificationListener) null, null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.registerMBean(myMy, name);\n+                mbs.addNotificationListener(null, name, null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+        } catch (MBeanException | MalformedObjectNameException | InstanceAlreadyExistsException\n+                 | NotCompliantMBeanException | InstanceNotFoundException | ReflectionException\n+                 | AttributeNotFoundException | InvalidAttributeValueException e) {\n+            \/\/ Should not reach here.  Known Exceptions thrown by methods above.\n+            \/\/ These would be a failure, as would other exceptions not caught (e.g. NullPointerException).\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public void checkROEContainsIAE(RuntimeOperationsException e) {\n+        System.out.println(++count);\n+        System.out.println(\"Checking: \" + e);\n+        if (e.getCause() instanceof IllegalArgumentException) {\n+            System.out.println(\"Got expected cause: \" + e.getCause());\n+            System.out.println();\n+        } else {\n+            throw new RuntimeException(\"Not the expected cause: \" + e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/management\/MBeanServer\/ExceptionTestNulls.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @enablePreview\n@@ -41,4 +42,17 @@\n-import java.net.*;\n-import java.util.*;\n-import java.io.*;\n-import javax.net.ssl.*;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.security.PEMDecoder;\n+import java.security.PEMEncoder;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -50,3 +64,1 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n+import java.util.ArrayList;\n@@ -54,0 +66,1 @@\n+import java.util.List;\n@@ -77,16 +90,16 @@\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICkjCCAfugAwIBAgIBADANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjA3WhcNMzMwMzI4MTIwNjA3WjA7MQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwgZ8wDQYJ\\n\" +\n-        \"KoZIhvcNAQEBBQADgY0AMIGJAoGBANY+7Enp+1S566kLcKk+qe4Ki6BxaHGZ+v7r\\n\" +\n-        \"vLksx9IQZCbAEf4YLbrZhKzKD3SPIJXyxPFwknAknIh3Knk8mViOZks7T8L3GnJr\\n\" +\n-        \"TBaVvDyTzDJum\/QYiahfO2qpfN\/Oya2UILmqsBAeLyWpzbQsAyWBXfoUtkOUgnzK\\n\" +\n-        \"fk6QAKYrAgMBAAGjgaUwgaIwHQYDVR0OBBYEFEtmQi7jT1ijXOafPsfkrLwSVu9e\\n\" +\n-        \"MGMGA1UdIwRcMFqAFEtmQi7jT1ijXOafPsfkrLwSVu9eoT+kPTA7MQswCQYDVQQG\\n\" +\n-        \"EwJVUzENMAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n-        \"Y2WCAQAwDwYDVR0TAQH\/BAUwAwEB\/zALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEE\\n\" +\n-        \"BQADgYEAkKWxMc4+ODk5WwLXXweB8\/IKfVfrizNn0KLEgsZ6xNXFIXDpiPGAFcgl\\n\" +\n-        \"MzFO424JgyvUulsUc\/X16Cnuwwntkk6KUG7vEV7h4o9sAV7Cax3gfQE\/EZFb4ybn\\n\" +\n-        \"aBm1UsujMKd\/ovqbbbxJbmOWzCeo0QfIGleDEyh3NBBZ0i11Kiw=\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICkjCCAfugAwIBAgIBADANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjA3WhcNMzMwMzI4MTIwNjA3WjA7MQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwgZ8wDQYJ\\n\" +\n+            \"KoZIhvcNAQEBBQADgY0AMIGJAoGBANY+7Enp+1S566kLcKk+qe4Ki6BxaHGZ+v7r\\n\" +\n+            \"vLksx9IQZCbAEf4YLbrZhKzKD3SPIJXyxPFwknAknIh3Knk8mViOZks7T8L3GnJr\\n\" +\n+            \"TBaVvDyTzDJum\/QYiahfO2qpfN\/Oya2UILmqsBAeLyWpzbQsAyWBXfoUtkOUgnzK\\n\" +\n+            \"fk6QAKYrAgMBAAGjgaUwgaIwHQYDVR0OBBYEFEtmQi7jT1ijXOafPsfkrLwSVu9e\\n\" +\n+            \"MGMGA1UdIwRcMFqAFEtmQi7jT1ijXOafPsfkrLwSVu9eoT+kPTA7MQswCQYDVQQG\\n\" +\n+            \"EwJVUzENMAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2\\n\" +\n+            \"Y2WCAQAwDwYDVR0TAQH\/BAUwAwEB\/zALBgNVHQ8EBAMCAQYwDQYJKoZIhvcNAQEE\\n\" +\n+            \"BQADgYEAkKWxMc4+ODk5WwLXXweB8\/IKfVfrizNn0KLEgsZ6xNXFIXDpiPGAFcgl\\n\" +\n+            \"MzFO424JgyvUulsUc\/X16Cnuwwntkk6KUG7vEV7h4o9sAV7Cax3gfQE\/EZFb4ybn\\n\" +\n+            \"aBm1UsujMKd\/ovqbbbxJbmOWzCeo0QfIGleDEyh3NBBZ0i11Kiw=\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -96,15 +109,15 @@\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICVTCCAb6gAwIBAgIBAjANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjA4WhcNMzIwMTAzMTIwNjA4WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n-        \"BAMTD3d3dy5leGFtcGxlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n-        \"4zFp3PZNzsd3ZwG6FNNWO9eSN+UBymlf8oCwpKJM2tIinmMWvWIXnlx\/2UXIfSAq\\n\" +\n-        \"QEG3aXkAFyEiGGpQlBbqcfrESsHsiz2pnnm5dG2v\/eS0Bwz1jmcuNmwnh3UQw2Vl\\n\" +\n-        \"+BLk8ukdrLjiCT8jARiHExYf1Xg+wUqQ9y8NV26hdaUCAwEAAaNPME0wCwYDVR0P\\n\" +\n-        \"BAQDAgPoMB0GA1UdDgQWBBQwtx+gqzn2w4y82brXlp7tqBYEZDAfBgNVHSMEGDAW\\n\" +\n-        \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQAJWo8B6Ud+\\n\" +\n-        \"\/OU+UcZLihlfMX02OSlK2ZB7mfqpj2G3JT9yb0A+VbY3uuajmaYYIIxl3kXGz\/n8\\n\" +\n-        \"M2Q\/Ux\/MDxG+IFKHC26Kuj4dAQgzjq2pILVPTE2QnaQTNCsgVZtTaC47SG9FRSoC\\n\" +\n-        \"qvnIvn\/oTpKSqus76I1cR4joDtiV2OEuVw==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICVTCCAb6gAwIBAgIBAjANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjA4WhcNMzIwMTAzMTIwNjA4WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n+            \"BAMTD3d3dy5leGFtcGxlLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n+            \"4zFp3PZNzsd3ZwG6FNNWO9eSN+UBymlf8oCwpKJM2tIinmMWvWIXnlx\/2UXIfSAq\\n\" +\n+            \"QEG3aXkAFyEiGGpQlBbqcfrESsHsiz2pnnm5dG2v\/eS0Bwz1jmcuNmwnh3UQw2Vl\\n\" +\n+            \"+BLk8ukdrLjiCT8jARiHExYf1Xg+wUqQ9y8NV26hdaUCAwEAAaNPME0wCwYDVR0P\\n\" +\n+            \"BAQDAgPoMB0GA1UdDgQWBBQwtx+gqzn2w4y82brXlp7tqBYEZDAfBgNVHSMEGDAW\\n\" +\n+            \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQAJWo8B6Ud+\\n\" +\n+            \"\/OU+UcZLihlfMX02OSlK2ZB7mfqpj2G3JT9yb0A+VbY3uuajmaYYIIxl3kXGz\/n8\\n\" +\n+            \"M2Q\/Ux\/MDxG+IFKHC26Kuj4dAQgzjq2pILVPTE2QnaQTNCsgVZtTaC47SG9FRSoC\\n\" +\n+            \"qvnIvn\/oTpKSqus76I1cR4joDtiV2OEuVw==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -114,14 +127,16 @@\n-        \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAOMxadz2Tc7Hd2cB\\n\" +\n-        \"uhTTVjvXkjflAcppX\/KAsKSiTNrSIp5jFr1iF55cf9lFyH0gKkBBt2l5ABchIhhq\\n\" +\n-        \"UJQW6nH6xErB7Is9qZ55uXRtr\/3ktAcM9Y5nLjZsJ4d1EMNlZfgS5PLpHay44gk\/\\n\" +\n-        \"IwEYhxMWH9V4PsFKkPcvDVduoXWlAgMBAAECgYAqX2nuIyXp3fvgA0twXOYlbRRB\\n\" +\n-        \"Rn3qAXM6qFPJsNeCrFR2k+aG1cev6nKR1FkLNTeMGnWZv06MAcr5IML8i7WXyG4C\\n\" +\n-        \"LY\/C0gedn94FDKFlln+bTENwQTGjn4lKysDA+IuNpasTeMCajbic+dPByhIdTOjZ\\n\" +\n-        \"iMCyxbLfpk40zQopVQJBAPyfGmkeHB3GjdbdgujWCGKb2UxBa4O8dy3O4l2yizTn\\n\" +\n-        \"uUqMGcwGY4ciNSVvZQ7jKo4vDmkSuYib4\/woPChaNfMCQQDmO0BQuSWYGNtSwV35\\n\" +\n-        \"lafZfX1dNCLKm1iNA6A12evXgvQiE9WT4mqionig0VZW16HtiY4\/BkHOcos\/K9Um\\n\" +\n-        \"ARQHAkA8mkaRtSF1my5nv1gqVz5Hua+VdZQ\/VDUbDiiL5cszc+ulkJqXsWirAG\/T\\n\" +\n-        \"fTe3LJQG7A7+8fkEZrF4yoY0AAA1AkEAotokezULj5N9iAL5SzL9wIzQYV4ggfny\\n\" +\n-        \"YATBjXXxKccakwQ+ndWZIiMUeoS4ssLialhTgucVI0fIkU2a\/r\/ifwJAc6e+5Pvh\\n\" +\n-        \"MghQj\/U788Od\/v6rgqz\/NGsduZ7uilCMcWiwA73OR2MHMH\/OIuoofuEPrfuV9isV\\n\" +\n-        \"xVXhgpKfP\/pdOA==\";\n+            \"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAOMxadz2Tc7Hd2cB\\n\" +\n+            \"uhTTVjvXkjflAcppX\/KAsKSiTNrSIp5jFr1iF55cf9lFyH0gKkBBt2l5ABchIhhq\\n\" +\n+            \"UJQW6nH6xErB7Is9qZ55uXRtr\/3ktAcM9Y5nLjZsJ4d1EMNlZfgS5PLpHay44gk\/\\n\" +\n+            \"IwEYhxMWH9V4PsFKkPcvDVduoXWlAgMBAAECgYAqX2nuIyXp3fvgA0twXOYlbRRB\\n\" +\n+            \"Rn3qAXM6qFPJsNeCrFR2k+aG1cev6nKR1FkLNTeMGnWZv06MAcr5IML8i7WXyG4C\\n\" +\n+            \"LY\/C0gedn94FDKFlln+bTENwQTGjn4lKysDA+IuNpasTeMCajbic+dPByhIdTOjZ\\n\" +\n+            \"iMCyxbLfpk40zQopVQJBAPyfGmkeHB3GjdbdgujWCGKb2UxBa4O8dy3O4l2yizTn\\n\" +\n+            \"uUqMGcwGY4ciNSVvZQ7jKo4vDmkSuYib4\/woPChaNfMCQQDmO0BQuSWYGNtSwV35\\n\" +\n+            \"lafZfX1dNCLKm1iNA6A12evXgvQiE9WT4mqionig0VZW16HtiY4\/BkHOcos\/K9Um\\n\" +\n+            \"ARQHAkA8mkaRtSF1my5nv1gqVz5Hua+VdZQ\/VDUbDiiL5cszc+ulkJqXsWirAG\/T\\n\" +\n+            \"fTe3LJQG7A7+8fkEZrF4yoY0AAA1AkEAotokezULj5N9iAL5SzL9wIzQYV4ggfny\\n\" +\n+            \"YATBjXXxKccakwQ+ndWZIiMUeoS4ssLialhTgucVI0fIkU2a\/r\/ifwJAc6e+5Pvh\\n\" +\n+            \"MghQj\/U788Od\/v6rgqz\/NGsduZ7uilCMcWiwA73OR2MHMH\/OIuoofuEPrfuV9isV\\n\" +\n+            \"xVXhgpKfP\/pdOA==\\n\" +\n+            \"-----END PRIVATE KEY-----\";\n@@ -131,15 +146,15 @@\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICVTCCAb6gAwIBAgIBBDANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n-        \"BAMTD3d3dy5leGFtcGxlLm5ldDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n-        \"2VlzF1fvWYczDChrUeJiLJ1M\/dIShCaOTfYGiXfQGEZCAWTacUclwr+rVMnZ75\/c\\n\" +\n-        \"wwg5pNdXRijxMil8DBTS1gFcIFQhosLHvzIAe6ULlg\/xB+\/L6KBz+NTWfo\/2KF6t\\n\" +\n-        \"xatmcToNrCcwi7eUOfbzQje65Tizs56jJYem2m7Rk0ECAwEAAaNPME0wCwYDVR0P\\n\" +\n-        \"BAQDAgPoMB0GA1UdDgQWBBQT\/FR0cAWcZQ7h0X79KGki34OSQjAfBgNVHSMEGDAW\\n\" +\n-        \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQB67cPIT6fz\\n\" +\n-        \"6Ws8fBpYgW2ad4ci66i1WduBD9CpGFE+jRK2feRj6hvYBXocKj0AMWUFIEB2E3hA\\n\" +\n-        \"oIjxcf1GxIpHVl9DjlhxqXbA0Ktl7\/NGNRlDSLTizOTl3FB1mMTlOGvXDVmpcFhl\\n\" +\n-        \"HuoP1hYvhTsBwPx5igGNchuPtDIUzL2mXw==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICVTCCAb6gAwIBAgIBBDANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n+            \"BAMTD3d3dy5leGFtcGxlLm5ldDCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n+            \"2VlzF1fvWYczDChrUeJiLJ1M\/dIShCaOTfYGiXfQGEZCAWTacUclwr+rVMnZ75\/c\\n\" +\n+            \"wwg5pNdXRijxMil8DBTS1gFcIFQhosLHvzIAe6ULlg\/xB+\/L6KBz+NTWfo\/2KF6t\\n\" +\n+            \"xatmcToNrCcwi7eUOfbzQje65Tizs56jJYem2m7Rk0ECAwEAAaNPME0wCwYDVR0P\\n\" +\n+            \"BAQDAgPoMB0GA1UdDgQWBBQT\/FR0cAWcZQ7h0X79KGki34OSQjAfBgNVHSMEGDAW\\n\" +\n+            \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQB67cPIT6fz\\n\" +\n+            \"6Ws8fBpYgW2ad4ci66i1WduBD9CpGFE+jRK2feRj6hvYBXocKj0AMWUFIEB2E3hA\\n\" +\n+            \"oIjxcf1GxIpHVl9DjlhxqXbA0Ktl7\/NGNRlDSLTizOTl3FB1mMTlOGvXDVmpcFhl\\n\" +\n+            \"HuoP1hYvhTsBwPx5igGNchuPtDIUzL2mXw==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -148,14 +163,16 @@\n-        \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBANlZcxdX71mHMwwo\\n\" +\n-        \"a1HiYiydTP3SEoQmjk32Bol30BhGQgFk2nFHJcK\/q1TJ2e+f3MMIOaTXV0Yo8TIp\\n\" +\n-        \"fAwU0tYBXCBUIaLCx78yAHulC5YP8Qfvy+igc\/jU1n6P9ihercWrZnE6DawnMIu3\\n\" +\n-        \"lDn280I3uuU4s7OeoyWHptpu0ZNBAgMBAAECgYEAl19H26sfhD+32rDPxZCgBShs\\n\" +\n-        \"dZ33zVe45i0Bcn4iTLWpxKTDyf7eGps4rO2DvfKdYqt40ggzvSZIjUH9JcDe8GmG\\n\" +\n-        \"d3m0ILB7pg4jsFlpyeHpTO8grPLxA1G9s3o0DoFpz\/rooqgFfe\/DrRDmRoOSkgfV\\n\" +\n-        \"\/gseIbgJHRO\/Ctyvdh0CQQD6uFd0HxhH1jl\/JzvPzIH4LSnPcdEh9zsMEb6uzh75\\n\" +\n-        \"9qL+IHD5N2I\/pYZTKqDFIwhJf701+LKag55AX\/zrDt7rAkEA3e00AbnwanDMa6Wj\\n\" +\n-        \"+gFekUQveSVra38LiihzCkyVvQpFjbiF1rUhSNQ0dpU5\/hmrYF0C6H9VXAesfkUY\\n\" +\n-        \"WhpDgwJAYjgZOop77piDycZK7isFt32p5XSHIzFBVocVFlH1XKM8UyXOXDNQL\/Le\\n\" +\n-        \"XnJSrSf+NRzvuNcG0PVC56Ey6brXpQJAY4M4vcltt5zq3R5CQBmbGRJ1IyKXX3Vx\\n\" +\n-        \"bDslEqoyvri7ZYgnY5aG3UxiVgYmIf3KrgQnCLAIS6MZQumiuMxsFwJAK5pEG063\\n\" +\n-        \"9ngUof4fDMvZphqZjZR1zMKz\/V\/9ge0DWBINaqFgsgebNu+MyImsC8C6WKjGmV\/2\\n\" +\n-        \"f1MY0D7sC2vU\/Q==\";\n+            \"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBANlZcxdX71mHMwwo\\n\" +\n+            \"a1HiYiydTP3SEoQmjk32Bol30BhGQgFk2nFHJcK\/q1TJ2e+f3MMIOaTXV0Yo8TIp\\n\" +\n+            \"fAwU0tYBXCBUIaLCx78yAHulC5YP8Qfvy+igc\/jU1n6P9ihercWrZnE6DawnMIu3\\n\" +\n+            \"lDn280I3uuU4s7OeoyWHptpu0ZNBAgMBAAECgYEAl19H26sfhD+32rDPxZCgBShs\\n\" +\n+            \"dZ33zVe45i0Bcn4iTLWpxKTDyf7eGps4rO2DvfKdYqt40ggzvSZIjUH9JcDe8GmG\\n\" +\n+            \"d3m0ILB7pg4jsFlpyeHpTO8grPLxA1G9s3o0DoFpz\/rooqgFfe\/DrRDmRoOSkgfV\\n\" +\n+            \"\/gseIbgJHRO\/Ctyvdh0CQQD6uFd0HxhH1jl\/JzvPzIH4LSnPcdEh9zsMEb6uzh75\\n\" +\n+            \"9qL+IHD5N2I\/pYZTKqDFIwhJf701+LKag55AX\/zrDt7rAkEA3e00AbnwanDMa6Wj\\n\" +\n+            \"+gFekUQveSVra38LiihzCkyVvQpFjbiF1rUhSNQ0dpU5\/hmrYF0C6H9VXAesfkUY\\n\" +\n+            \"WhpDgwJAYjgZOop77piDycZK7isFt32p5XSHIzFBVocVFlH1XKM8UyXOXDNQL\/Le\\n\" +\n+            \"XnJSrSf+NRzvuNcG0PVC56Ey6brXpQJAY4M4vcltt5zq3R5CQBmbGRJ1IyKXX3Vx\\n\" +\n+            \"bDslEqoyvri7ZYgnY5aG3UxiVgYmIf3KrgQnCLAIS6MZQumiuMxsFwJAK5pEG063\\n\" +\n+            \"9ngUof4fDMvZphqZjZR1zMKz\/V\/9ge0DWBINaqFgsgebNu+MyImsC8C6WKjGmV\/2\\n\" +\n+            \"f1MY0D7sC2vU\/Q==\\n\" +\n+            \"-----END PRIVATE KEY-----\";\n@@ -165,15 +182,15 @@\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICVTCCAb6gAwIBAgIBAzANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n-        \"BAMTD3d3dy5pbnZhbGlkLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n-        \"q6MyQwzCr2nJ41l0frmHL0qULSyW51MhevBC+1W28i0LE\/efrmpwV3LdnlQEGFak\\n\" +\n-        \"DLDwtnff3iru8dSMcA7KdWVkivsE7ZTP+qFDaWBAy7XXiSsv6yZ2Nh4jJb0YcD28\\n\" +\n-        \"45zk2nAl5Az1\/PuoTi1vpQxzFZKuBm1HGgz3MEZvBvMCAwEAAaNPME0wCwYDVR0P\\n\" +\n-        \"BAQDAgPoMB0GA1UdDgQWBBRRMifrND015Nm8N6gV5X7cg1YjjjAfBgNVHSMEGDAW\\n\" +\n-        \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQBjkUO6Ri\/B\\n\" +\n-        \"uDC2gDMIyL5+NTe\/1dPPQYM4HhCNa\/KQYvU5lzCKO9Vpa+i+nyrUNNXUu8Tkyq4Y\\n\" +\n-        \"A+aGSm6+FT\/i9rFwkYUdorBtD3KfQiwTIWrVERXBkWI5iZNaVZhx0TFy4vUpf65d\\n\" +\n-        \"QtwkbHpC66fdKc2EdLXkuY9KkmtZZJJ7YA==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICVTCCAb6gAwIBAgIBAzANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjA5WhcNMzIwMTAzMTIwNjA5WjBVMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxGDAWBgNV\\n\" +\n+            \"BAMTD3d3dy5pbnZhbGlkLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA\\n\" +\n+            \"q6MyQwzCr2nJ41l0frmHL0qULSyW51MhevBC+1W28i0LE\/efrmpwV3LdnlQEGFak\\n\" +\n+            \"DLDwtnff3iru8dSMcA7KdWVkivsE7ZTP+qFDaWBAy7XXiSsv6yZ2Nh4jJb0YcD28\\n\" +\n+            \"45zk2nAl5Az1\/PuoTi1vpQxzFZKuBm1HGgz3MEZvBvMCAwEAAaNPME0wCwYDVR0P\\n\" +\n+            \"BAQDAgPoMB0GA1UdDgQWBBRRMifrND015Nm8N6gV5X7cg1YjjjAfBgNVHSMEGDAW\\n\" +\n+            \"gBRLZkIu409Yo1zmnz7H5Ky8ElbvXjANBgkqhkiG9w0BAQQFAAOBgQBjkUO6Ri\/B\\n\" +\n+            \"uDC2gDMIyL5+NTe\/1dPPQYM4HhCNa\/KQYvU5lzCKO9Vpa+i+nyrUNNXUu8Tkyq4Y\\n\" +\n+            \"A+aGSm6+FT\/i9rFwkYUdorBtD3KfQiwTIWrVERXBkWI5iZNaVZhx0TFy4vUpf65d\\n\" +\n+            \"QtwkbHpC66fdKc2EdLXkuY9KkmtZZJJ7YA==\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -182,14 +199,16 @@\n-        \"MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAKujMkMMwq9pyeNZ\\n\" +\n-        \"dH65hy9KlC0sludTIXrwQvtVtvItCxP3n65qcFdy3Z5UBBhWpAyw8LZ3394q7vHU\\n\" +\n-        \"jHAOynVlZIr7BO2Uz\/qhQ2lgQMu114krL+smdjYeIyW9GHA9vOOc5NpwJeQM9fz7\\n\" +\n-        \"qE4tb6UMcxWSrgZtRxoM9zBGbwbzAgMBAAECgYASJDK40Y12Wvki1Z6xkkyOnBRj\\n\" +\n-        \"XfYpRykfxGtgA2RN3qLwHlk7Zzaul46DIKA6LlYynTUkJDF+Ww1cdDnP0lBlwcmM\\n\" +\n-        \"iD0ck3zYyYBLhQHuVbkK3SYE+ANRhM0icvvqANP2at\/U4awQcPNEae\/KCiecLNu3\\n\" +\n-        \"CJGqyhPDdrEAqPuJGQJBAN46pQC6l3yrcSYE2s53jSmsm2HVVOFlFXjU6k\/RMTxG\\n\" +\n-        \"FfDJtGUAOQ37rPQ06ugr\/gjLAmmPp+FXozaBdA32D80CQQDFuGRgv3WYqbglIcRL\\n\" +\n-        \"JRs6xlj9w1F97s\/aiUenuwhIPNiUoRbV7mnNuZ\/sGF0svOVE7SazRjuFX6UqL9Y9\\n\" +\n-        \"HzG\/AkEA170pCI8cl4w8eUNHRB9trGKEKjMXhwVCFh7lJf2ZBcGodSzr8w2HVhrZ\\n\" +\n-        \"Ke7hiemDYffrbJ1oxmv05+o+x3r0lQJBAL6adVm2+FyFMFnLZXmzeb59O4jWY5bt\\n\" +\n-        \"Qz6\/HG6bpO5OidMuP99YCHMkQQDOs\/PO3Y5GuAoW6IY4n\/Y9S2B80+0CQBl1\/H9\/\\n\" +\n-        \"0n\/vrb6vW6Azds49tuS82RFAnOhtwTyBEajs08WF8rZQ3WD2RHJnH0+jjfL0anIp\\n\" +\n-        \"dQBSeNN7s7b6rRk=\";\n+            \"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAKujMkMMwq9pyeNZ\\n\" +\n+            \"dH65hy9KlC0sludTIXrwQvtVtvItCxP3n65qcFdy3Z5UBBhWpAyw8LZ3394q7vHU\\n\" +\n+            \"jHAOynVlZIr7BO2Uz\/qhQ2lgQMu114krL+smdjYeIyW9GHA9vOOc5NpwJeQM9fz7\\n\" +\n+            \"qE4tb6UMcxWSrgZtRxoM9zBGbwbzAgMBAAECgYASJDK40Y12Wvki1Z6xkkyOnBRj\\n\" +\n+            \"XfYpRykfxGtgA2RN3qLwHlk7Zzaul46DIKA6LlYynTUkJDF+Ww1cdDnP0lBlwcmM\\n\" +\n+            \"iD0ck3zYyYBLhQHuVbkK3SYE+ANRhM0icvvqANP2at\/U4awQcPNEae\/KCiecLNu3\\n\" +\n+            \"CJGqyhPDdrEAqPuJGQJBAN46pQC6l3yrcSYE2s53jSmsm2HVVOFlFXjU6k\/RMTxG\\n\" +\n+            \"FfDJtGUAOQ37rPQ06ugr\/gjLAmmPp+FXozaBdA32D80CQQDFuGRgv3WYqbglIcRL\\n\" +\n+            \"JRs6xlj9w1F97s\/aiUenuwhIPNiUoRbV7mnNuZ\/sGF0svOVE7SazRjuFX6UqL9Y9\\n\" +\n+            \"HzG\/AkEA170pCI8cl4w8eUNHRB9trGKEKjMXhwVCFh7lJf2ZBcGodSzr8w2HVhrZ\\n\" +\n+            \"Ke7hiemDYffrbJ1oxmv05+o+x3r0lQJBAL6adVm2+FyFMFnLZXmzeb59O4jWY5bt\\n\" +\n+            \"Qz6\/HG6bpO5OidMuP99YCHMkQQDOs\/PO3Y5GuAoW6IY4n\/Y9S2B80+0CQBl1\/H9\/\\n\" +\n+            \"0n\/vrb6vW6Azds49tuS82RFAnOhtwTyBEajs08WF8rZQ3WD2RHJnH0+jjfL0anIp\\n\" +\n+            \"dQBSeNN7s7b6rRk=\\n\" +\n+            \"-----END PRIVATE KEY-----\";\n@@ -198,16 +217,16 @@\n-    static String targetCertStr_D=\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICVDCCAb2gAwIBAgIBBTANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n-        \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n-        \"MTIwNDE3MTIwNjEwWhcNMzIwMTAzMTIwNjEwWjBUMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n-        \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxFzAVBgNV\\n\" +\n-        \"BAMTDkludGVyT3AgVGVzdGVyMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDo\\n\" +\n-        \"Q\/KoAIAC2ljFfW2KwjnxTzi4NQJeUuk2seqKpsAY8x4O5dvixzUl6142zmljapqi\\n\" +\n-        \"bJloQVpfB+CEc5\/l4h5gzGRVzkuqP1oPzDrpZ5GsvmvuHenV\/TzCIgX1cLETzQVt\\n\" +\n-        \"6Rk06okoBPnw3hDJEJiEc1Rv7HCE8p\/p+SaiHrskwwIDAQABo08wTTALBgNVHQ8E\\n\" +\n-        \"BAMCA+gwHQYDVR0OBBYEFPr91O33RIGfFSqza2AwQIgE4QswMB8GA1UdIwQYMBaA\\n\" +\n-        \"FEtmQi7jT1ijXOafPsfkrLwSVu9eMA0GCSqGSIb3DQEBBAUAA4GBANIDFYgAhoj3\\n\" +\n-        \"B8u1YpqeoEp2Lt9TwrYBshaIrbmBPCwCGio0JIsoov3n8BCSg5F+8MnOtPl+TjeO\\n\" +\n-        \"0Ug+7guPdCk\/wg8YNxLHgSsQlpcNJDjWiErqmUPVrg5BPPQb65qMund6KTmMN0y6\\n\" +\n-        \"4EbSmxRpZO\/N0\/5oK4umTk0EeXKNekBj\\n\" +\n-        \"-----END CERTIFICATE-----\";\n+    static String targetCertStr_D =\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICVDCCAb2gAwIBAgIBBTANBgkqhkiG9w0BAQQFADA7MQswCQYDVQQGEwJVUzEN\\n\" +\n+            \"MAsGA1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UwHhcN\\n\" +\n+            \"MTIwNDE3MTIwNjEwWhcNMzIwMTAzMTIwNjEwWjBUMQswCQYDVQQGEwJVUzENMAsG\\n\" +\n+            \"A1UEChMESmF2YTEdMBsGA1UECxMUU3VuSlNTRSBUZXN0IFNlcml2Y2UxFzAVBgNV\\n\" +\n+            \"BAMTDkludGVyT3AgVGVzdGVyMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDo\\n\" +\n+            \"Q\/KoAIAC2ljFfW2KwjnxTzi4NQJeUuk2seqKpsAY8x4O5dvixzUl6142zmljapqi\\n\" +\n+            \"bJloQVpfB+CEc5\/l4h5gzGRVzkuqP1oPzDrpZ5GsvmvuHenV\/TzCIgX1cLETzQVt\\n\" +\n+            \"6Rk06okoBPnw3hDJEJiEc1Rv7HCE8p\/p+SaiHrskwwIDAQABo08wTTALBgNVHQ8E\\n\" +\n+            \"BAMCA+gwHQYDVR0OBBYEFPr91O33RIGfFSqza2AwQIgE4QswMB8GA1UdIwQYMBaA\\n\" +\n+            \"FEtmQi7jT1ijXOafPsfkrLwSVu9eMA0GCSqGSIb3DQEBBAUAA4GBANIDFYgAhoj3\\n\" +\n+            \"B8u1YpqeoEp2Lt9TwrYBshaIrbmBPCwCGio0JIsoov3n8BCSg5F+8MnOtPl+TjeO\\n\" +\n+            \"0Ug+7guPdCk\/wg8YNxLHgSsQlpcNJDjWiErqmUPVrg5BPPQb65qMund6KTmMN0y6\\n\" +\n+            \"4EbSmxRpZO\/N0\/5oK4umTk0EeXKNekBj\\n\" +\n+            \"-----END CERTIFICATE-----\";\n@@ -216,14 +235,16 @@\n-        \"MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAOhD8qgAgALaWMV9\\n\" +\n-        \"bYrCOfFPOLg1Al5S6Tax6oqmwBjzHg7l2+LHNSXrXjbOaWNqmqJsmWhBWl8H4IRz\\n\" +\n-        \"n+XiHmDMZFXOS6o\/Wg\/MOulnkay+a+4d6dX9PMIiBfVwsRPNBW3pGTTqiSgE+fDe\\n\" +\n-        \"EMkQmIRzVG\/scITyn+n5JqIeuyTDAgMBAAECgYBw37yIKp4LRONJLnhSq6sO+0n8\\n\" +\n-        \"Mz6waiiN\/Q6XTQwj09pysQAYCGlqwSRrDAqpVsBJWO+Ae+oYLrLMi4hUZnwN75v3\\n\" +\n-        \"pe1nXlrD11RmPLXwBxqFxNSvAs2FgLHZEtwHI7Bn8KybT\/8bGkQ8csLceInYtMDD\\n\" +\n-        \"MuTyy2KRk\/pj60zIKQJBAPgebQiAH6viFQ88AwHaNvQhlUfwmSC1i6f8LVoeqaHC\\n\" +\n-        \"lnP0LJBwlyDeeEInhHrCR2ibnCB6I\/Pig+49XQgabK8CQQDvpJwuGEbsOO+3rkJJ\\n\" +\n-        \"OpOw4toG0QJZdRnT6l8I6BlboQRZSfFh+lGGahvFXkxc4KdUpJ7QPtXU7HHk6Huk\\n\" +\n-        \"8RYtAkA9CW8VGj+wTuuTVdX\/jKjcIa7RhbSFwWNbrcOSWdys+Gt+luCnn6rt4QyA\\n\" +\n-        \"aaxDbquWZkFgE+voQR7nap0KM0XtAkAznd0WAJymHM1lXt9gLoHJQ9N6TGKZKiPa\\n\" +\n-        \"BU1a+cMcfV4WbVrUo7oTnZ9Fr73681iXXq3mZOJh7lvJ1llreZIxAkBEnbiTgEf4\\n\" +\n-        \"tvku68jHcRbRPmdS7CBSWNEBaHLOm4pUSTcxVTKKMHw7vmM5\/UYUxJ8QNKCYxn6O\\n\" +\n-        \"+vtiBwBawwzN\";\n+            \"-----BEGIN PRIVATE KEY-----\\n\" +\n+            \"MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAOhD8qgAgALaWMV9\\n\" +\n+            \"bYrCOfFPOLg1Al5S6Tax6oqmwBjzHg7l2+LHNSXrXjbOaWNqmqJsmWhBWl8H4IRz\\n\" +\n+            \"n+XiHmDMZFXOS6o\/Wg\/MOulnkay+a+4d6dX9PMIiBfVwsRPNBW3pGTTqiSgE+fDe\\n\" +\n+            \"EMkQmIRzVG\/scITyn+n5JqIeuyTDAgMBAAECgYBw37yIKp4LRONJLnhSq6sO+0n8\\n\" +\n+            \"Mz6waiiN\/Q6XTQwj09pysQAYCGlqwSRrDAqpVsBJWO+Ae+oYLrLMi4hUZnwN75v3\\n\" +\n+            \"pe1nXlrD11RmPLXwBxqFxNSvAs2FgLHZEtwHI7Bn8KybT\/8bGkQ8csLceInYtMDD\\n\" +\n+            \"MuTyy2KRk\/pj60zIKQJBAPgebQiAH6viFQ88AwHaNvQhlUfwmSC1i6f8LVoeqaHC\\n\" +\n+            \"lnP0LJBwlyDeeEInhHrCR2ibnCB6I\/Pig+49XQgabK8CQQDvpJwuGEbsOO+3rkJJ\\n\" +\n+            \"OpOw4toG0QJZdRnT6l8I6BlboQRZSfFh+lGGahvFXkxc4KdUpJ7QPtXU7HHk6Huk\\n\" +\n+            \"8RYtAkA9CW8VGj+wTuuTVdX\/jKjcIa7RhbSFwWNbrcOSWdys+Gt+luCnn6rt4QyA\\n\" +\n+            \"aaxDbquWZkFgE+voQR7nap0KM0XtAkAznd0WAJymHM1lXt9gLoHJQ9N6TGKZKiPa\\n\" +\n+            \"BU1a+cMcfV4WbVrUo7oTnZ9Fr73681iXXq3mZOJh7lvJ1llreZIxAkBEnbiTgEf4\\n\" +\n+            \"tvku68jHcRbRPmdS7CBSWNEBaHLOm4pUSTcxVTKKMHw7vmM5\/UYUxJ8QNKCYxn6O\\n\" +\n+            \"+vtiBwBawwzN\\n\" +\n+            \"-----END PRIVATE KEY-----\";\n@@ -238,1 +259,1 @@\n-    static char passphrase[] = \"passphrase\".toCharArray();\n+    static char[] passphrase = \"passphrase\".toCharArray();\n@@ -248,1 +269,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -365,2 +386,1 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -372,5 +392,2 @@\n-        \/\/ import the trused cert\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trustedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n+        \/\/ generate certificate from cert string\n+        Certificate trusedCert = pemDecoder.decode(trustedCertStr, X509Certificate.class);\n@@ -378,0 +395,1 @@\n+        \/\/ import the trused cert\n@@ -393,2 +411,1 @@\n-            PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                                Base64.getMimeDecoder().decode(keySpecStr));\n+            PKCS8EncodedKeySpec priKeySpec = pemDecoder.decode(keySpecStr, PKCS8EncodedKeySpec.class);\n@@ -401,3 +418,1 @@\n-            is = new ByteArrayInputStream(keyCertStr.getBytes());\n-            Certificate keyCert = cf.generateCertificate(is);\n-            is.close();\n+            Certificate keyCert = pemDecoder.decode(keyCertStr, X509Certificate.class);\n@@ -524,14 +539,12 @@\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died, because of \" + e);\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n+            serverThread = new Thread(() -> {\n+                try {\n+                    doServerSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our server thread just died.\n+                     *\n+                     * Release the client, if not active already...\n+                     *\/\n+                    System.err.println(\"Server died, because of \" + e);\n+                    serverReady = true;\n+                    serverException = e;\n@@ -539,1 +552,1 @@\n-            };\n+            });\n@@ -554,11 +567,9 @@\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died, because of \" + e);\n-                        clientException = e;\n-                    }\n+            clientThread = new Thread(() -> {\n+                try {\n+                    doClientSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our client thread just died.\n+                     *\/\n+                    System.err.println(\"Client died, because of \" + e);\n+                    clientException = e;\n@@ -566,1 +577,1 @@\n-            };\n+            });\n","filename":"test\/jdk\/javax\/net\/ssl\/ServerName\/SSLSocketSNISensitive.java","additions":193,"deletions":182,"binary":false,"changes":375,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @run main\/othervm DisabledAlgorithms default\n- * @run main\/othervm DisabledAlgorithms empty\n+ * @run main\/othervm\/timeout=480 DisabledAlgorithms default\n+ * @run main\/othervm\/timeout=480 DisabledAlgorithms empty\n","filename":"test\/jdk\/javax\/net\/ssl\/ciphersuites\/DisabledAlgorithms.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloBufferUnderflowException.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @enablePreview\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloChromeInterOp.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,4 +24,8 @@\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.nio.*;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+import java.nio.ByteBuffer;\n@@ -29,0 +33,2 @@\n+import java.security.PEMDecoder;\n+import java.security.PEMRecord;\n@@ -30,1 +36,0 @@\n-import java.security.KeyFactory;\n@@ -32,3 +37,3 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.util.Base64;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.ECPrivateKey;\n+import java.security.interfaces.RSAPrivateKey;\n@@ -141,0 +146,1 @@\n+        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -143,1 +149,2 @@\n-        \"Ay6zUapMW9ydE84KGXyy5my+Sw7QKlmoveGNeZVf12nUVX+tQEYujVob\",\n+        \"Ay6zUapMW9ydE84KGXyy5my+Sw7QKlmoveGNeZVf12nUVX+tQEYujVob\\n\" +\n+        \"-----END PRIVATE KEY-----\",\n@@ -148,0 +155,1 @@\n+        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -173,2 +181,3 @@\n-        \"dKUqlw5BPHdbxoWB\/JpSHGCV\"\n-        };\n+        \"dKUqlw5BPHdbxoWB\/JpSHGCV\\n\" +\n+        \"-----END PRIVATE KEY-----\"\n+    };\n@@ -182,0 +191,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -254,4 +265,1 @@\n-        char passphrase[] = \"passphrase\".toCharArray();\n-\n-        \/\/ Generate certificate from cert string.\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        char[] passphrase = \"passphrase\".toCharArray();\n@@ -260,1 +268,0 @@\n-        ByteArrayInputStream is;\n@@ -269,7 +276,2 @@\n-\n-                is = new ByteArrayInputStream(trustedCertStr.getBytes());\n-                try {\n-                    trustedCert[i] = cf.generateCertificate(is);\n-                } finally {\n-                    is.close();\n-                }\n+                \/\/ Generate certificate from cert string.\n+                trustedCert[i] = pemDecoder.decode(trustedCertStr, X509Certificate.class);\n@@ -298,5 +300,5 @@\n-                PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(\n-                    Base64.getMimeDecoder().decode(keyMaterialKeys[i]));\n-                KeyFactory kf =\n-                    KeyFactory.getInstance(keyMaterialKeyAlgs[i]);\n-                PrivateKey priKey = kf.generatePrivate(priKeySpec);\n+                PrivateKey priKey = switch (keyMaterialKeyAlgs[i]) {\n+                    case \"RSA\" -> pemDecoder.decode(keyMaterialKeys[i], RSAPrivateKey.class);\n+                    case \"EC\" -> pemDecoder.decode(keyMaterialKeys[i], ECPrivateKey.class);\n+                    default -> pemDecoder.decode(keyMaterialKeys[i], PrivateKey.class);\n+                };\n@@ -305,8 +307,1 @@\n-                is = new ByteArrayInputStream(keyCertStr.getBytes());\n-                Certificate keyCert = null;\n-                try {\n-                    keyCert = cf.generateCertificate(is);\n-                } finally {\n-                    is.close();\n-                }\n-\n+                Certificate keyCert  = pemDecoder.decode(keyCertStr, X509Certificate.class);\n","filename":"test\/jdk\/javax\/net\/ssl\/interop\/ClientHelloInterOp.java","additions":32,"deletions":37,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,3 @@\n-import javax.print.attribute.AttributeSet;\n-import javax.print.attribute.HashAttributeSet;\n-import javax.print.attribute.standard.PrinterName;\n+import java.io.IOException;\n+\n+import jtreg.SkippedException;\n@@ -36,0 +36,2 @@\n+ * @library \/test\/lib\/\n+ * @requires (os.family == \"linux\")\n@@ -41,6 +43,0 @@\n-    String os = System.getProperty(\"os.name\").toLowerCase();\n-    System.out.println(\"OS is \" + os);\n-    if (!os.equals(\"linux\")) {\n-        System.out.println(\"Linux specific test. No need to continue\");\n-        return;\n-    }\n@@ -54,1 +50,10 @@\n-    Process proc = Runtime.getRuntime().exec(lpcmd);\n+    Process proc;\n+    try {\n+        proc = Runtime.getRuntime().exec(lpcmd);\n+    } catch (IOException e) {\n+        if (e.getMessage().contains(\"No such file or directory\")) {\n+            throw new SkippedException(\"Cannot find lpstat\");\n+        } else {\n+            throw e;\n+        }\n+    }\n@@ -69,1 +74,0 @@\n-\n","filename":"test\/jdk\/javax\/print\/PrintServiceLookup\/CountPrintServices.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8159055\n+ * @summary Verifies null parameter and invalid data handling of\n+ *          ImageIcon constructors and setImage method\n+ * @run main ImageIconTest\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.Random;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import javax.swing.ImageIcon;\n+\n+public class ImageIconTest {\n+\n+    static enum ArgType { FILE, URL, BYTE_ARRAY, IMAGE, SET_IMAGE };\n+    static enum ArgVal { NULL, INVALID_DATA };\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        String imgName = \"invalid.gif\";\n+        byte[] invalidData = new byte[100];\n+        new Random().nextBytes(invalidData);\n+        try (FileOutputStream fos = new FileOutputStream(imgName)) {\n+            fos.write(invalidData);\n+        }\n+        File file = new File(imgName);\n+        file.deleteOnExit();\n+\n+        for (ArgType a : ArgType.values()) {\n+            for (final ArgVal v : ArgVal.values()) {\n+                System.out.println(\"Testing for ArgType \" + a + \" for case \" + v);\n+                boolean expected = true;\n+                boolean passed = false;\n+                try {\n+                    switch (a) {\n+\n+                       case FILE :\n+\n+                           expected = false;\n+                           String s = (v == ArgVal.NULL) ? null : imgName;\n+                           new ImageIcon(s);\n+                           passed = true; \/\/ no exception expected for this case\n+                           break;\n+\n+                       case URL :\n+\n+                           if (v == ArgVal.NULL) {\n+\n+                               new ImageIcon((URL)null);\n+\n+                           } else if (v == ArgVal.INVALID_DATA) {\n+                               expected = false;\n+                               new ImageIcon(new URI(\"file:\/\/\" + imgName).toURL());\n+                               passed = true; \/\/ no exception expected for this case\n+\n+                           }\n+                           break;\n+\n+                       case BYTE_ARRAY :\n+\n+                           if (v == ArgVal.NULL) {\n+\n+                               byte[] bytes = null;\n+                               new ImageIcon(bytes);\n+\n+                           } else if (v == ArgVal.INVALID_DATA) {\n+                               expected = false;\n+\n+                               new ImageIcon(invalidData);\n+\n+                               passed = true; \/\/ no exception expected for this case\n+                           }\n+                           break;\n+\n+                       case IMAGE :\n+\n+                           if (v == ArgVal.NULL) {\n+\n+                               new ImageIcon((Image)null);\n+\n+                           } else if (v == ArgVal.INVALID_DATA) {\n+                               expected = false;\n+\n+                               new ImageIcon((Image)Toolkit.getDefaultToolkit().createImage(imgName));\n+\n+                               passed = true; \/\/ no exception expected for this case\n+                           }\n+                           break;\n+\n+                        case SET_IMAGE :\n+\n+                            ImageIcon ii = new ImageIcon();\n+\n+                            if (v == ArgVal.NULL) {\n+\n+                                ii.setImage((Image) null);\n+\n+                            } else if (v == ArgVal.INVALID_DATA) {\n+                                expected = false;\n+\n+                                ii.setImage((Image)Toolkit.getDefaultToolkit().createImage(imgName));\n+\n+                                passed = true; \/\/ no exception expected for this case\n+                            }\n+                            break;\n+                    }\n+                } catch (NullPointerException e) {\n+                    if (expected) {\n+                        passed = true;\n+                    }\n+                }\n+                if (expected && !passed) {\n+                   throw new RuntimeException(\"Did not receive expected exception for : \" + a);\n+                }\n+                if (!expected && !passed) {\n+                   throw new RuntimeException(\"Received unexpected exception for : \" + a);\n+                }\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/ImageIcon\/ImageIconTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main bug6868611\n+ * @run main\/timeout=480 bug6868611\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/6868611\/bug6868611.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import java.io.File;\n@@ -31,0 +32,1 @@\n+import javax.imageio.ImageIO;\n@@ -54,0 +56,1 @@\n+    private static final int tolerance = 10;\n@@ -72,0 +75,1 @@\n+            Color testColor = new Color(testRGB);\n@@ -75,1 +79,9 @@\n-                if (rgbCW != testRGB || rgbCH != testRGB) {\n+                Color rgbCWColor = new Color(rgbCW);\n+                Color rgbCHColor = new Color(rgbCH);\n+\n+                if (Math.abs(rgbCWColor.getRed() - testColor.getRed()) > tolerance\n+                    || Math.abs(rgbCWColor.getGreen() - testColor.getGreen()) > tolerance\n+                    || Math.abs(rgbCWColor.getBlue() - testColor.getBlue()) > tolerance\n+                    || Math.abs(rgbCHColor.getRed() - testColor.getRed()) > tolerance\n+                    || Math.abs(rgbCHColor.getGreen() - testColor.getGreen()) > tolerance\n+                    || Math.abs(rgbCHColor.getBlue() - testColor.getBlue()) > tolerance) {\n@@ -80,0 +92,1 @@\n+                    ImageIO.write(img, \"png\", new File(\"JInternalFrameDraggingTest.png\"));\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/8160248\/JInternalFrameDraggingTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -28,4 +29,4 @@\n- *     ComponentOrientation property is set to RIGHT_TO_LEFT. This test is\n- *     manual.  The tester is asked to compare left-to-right and\n- *     right-to-left menu bars and judge whether they are mirror images of each\n- *     other.\n+ *     ComponentOrientation property is set to RIGHT_TO_LEFT.\n+ *     The tester is asked to compare left-to-right and\n+ *     right-to-left menu bars and decide whether they are mirror\n+ *     images of each other.\n@@ -38,1 +39,0 @@\n-import java.awt.Point;\n@@ -41,0 +41,2 @@\n+import java.util.List;\n+\n@@ -45,0 +47,1 @@\n+import javax.swing.JOptionPane;\n@@ -50,1 +53,1 @@\n-public class RightLeftOrientation {\n+public final class RightLeftOrientation {\n@@ -52,2 +55,1 @@\n-    static JFrame ltrFrame;\n-    static JFrame rtlFrame;\n+    private static List<JFrame> frames;\n@@ -56,3 +58,1 @@\n-        This test checks menu bars for correct Right-To-Left Component Orientation.\n-\n-        You should see two frames, each containing a menu bar.\n+        This test checks menu bars for correct Right-To-Left component orientation.\n@@ -60,1 +60,2 @@\n-        One frame will be labelled \"Left To Right\" and will contain\n+        You should see two frames, each contains a menu bar.\n+        One frame is labelled \"Left To Right\" and contains\n@@ -62,2 +63,2 @@\n-        The other frame will be labelled \"Right To Left\" and will\n-        contain a menu bar with menus starting on its right side.\n+        The other frame is labelled \"Right To Left\" and\n+        contains a menu bar with menus starting on its right side.\n@@ -65,4 +66,5 @@\n-        The test will also contain radio buttons that can be used to set\n-        the look and feel of the menu bars.\n-        For each look and feel, you should compare the two menu\n-        bars and make sure they are mirror images of each other. \"\"\";\n+        The test also displays a frame with radio buttons\n+        to change the look and feel of the menu bars.\n+        For each look and feel, compare the two menu bars\n+        in LTR and RTL orientation and make sure they are mirror\n+        images of each other.\"\"\";\n@@ -72,1 +74,1 @@\n-                 .title(\"RTL test Instructions\")\n+                 .title(\"Menu Bar RTL Instructions\")\n@@ -74,1 +76,0 @@\n-                 .rows((int) INSTRUCTIONS.lines().count() + 2)\n@@ -77,0 +78,1 @@\n+                 .positionTestUIRightColumn()\n@@ -81,2 +83,2 @@\n-    private static JFrame createTestUI() {\n-        JFrame frame = new JFrame(\"RightLeftOrientation\");\n+    private static JFrame createPlafChangerFrame() {\n+        JFrame frame = new JFrame(\"Change Look and Feel\");\n@@ -86,1 +88,0 @@\n-        JRadioButton rb;\n@@ -91,1 +92,1 @@\n-            rb = new JRadioButton(lafInfos[i].getName());\n+            JRadioButton rb = new JRadioButton(lafInfos[i].getName());\n@@ -102,0 +103,3 @@\n+        frame.pack();\n+        return frame;\n+    }\n@@ -103,1 +107,4 @@\n-        ltrFrame = new JFrame(\"Left To Right\");\n+    private static List<JFrame> createTestUI() {\n+        JFrame plafFrame = createPlafChangerFrame();\n+\n+        JFrame ltrFrame = new JFrame(\"Left To Right\");\n@@ -106,2 +113,0 @@\n-        ltrFrame.setLocation(new Point(10, 10));\n-        ltrFrame.setVisible(true);\n@@ -109,1 +114,1 @@\n-        rtlFrame = new JFrame(\"Right To Left\");\n+        JFrame rtlFrame = new JFrame(\"Right To Left\");\n@@ -112,4 +117,2 @@\n-        rtlFrame.setLocation(new Point(10, 120));\n-        rtlFrame.setVisible(true);\n-        frame.pack();\n-        return frame;\n+\n+        return (frames = List.of(plafFrame, ltrFrame, rtlFrame));\n@@ -118,1 +121,2 @@\n-    static class PlafChanger implements ActionListener {\n+    private static final class PlafChanger implements ActionListener {\n+        @Override\n@@ -124,5 +128,8 @@\n-                SwingUtilities.updateComponentTreeUI(ltrFrame);\n-                SwingUtilities.updateComponentTreeUI(rtlFrame);\n-            }\n-            catch (Exception exc) {\n-                System.err.println(\"Could not load LookAndFeel: \" + lnfName);\n+                frames.forEach(SwingUtilities::updateComponentTreeUI);\n+            } catch (Exception exc) {\n+                String message = \"Could not set Look and Feel to \" + lnfName;\n+                System.err.println(message);\n+                JOptionPane.showMessageDialog(frames.get(0),\n+                                              message,\n+                                              \"Look and Feel Error\",\n+                                              JOptionPane.ERROR_MESSAGE);\n","filename":"test\/jdk\/javax\/swing\/JMenuBar\/RightLeftOrientation.java","additions":46,"deletions":39,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Djava.awt.headless=true ConcurrentModification\n+ * @run main\/othervm\/timeout=480 -Djava.awt.headless=true ConcurrentModification\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicDirectoryModel\/ConcurrentModification.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -38,0 +40,1 @@\n+   @library \/test\/lib\n@@ -41,2 +44,1 @@\n-    private static final float tf = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    private static final long TIMEOUT = 10_000 * (long)tf;\n+    private static final long TIMEOUT = (long) (10_000 * Utils.TIMEOUT_FACTOR);\n","filename":"test\/jdk\/javax\/swing\/text\/html\/parser\/Parser\/8078268\/bug8078268.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main\/othervm\/timeout=300 -Dsun.net.httpserver.nodelay=true GenerationTests\n+ * @run main\/othervm\/timeout=1200 -Dsun.net.httpserver.nodelay=true GenerationTests\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/GenerationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8361638\n@@ -40,0 +41,1 @@\n+import static java.lang.constant.ConstantDescs.*;\n@@ -50,0 +52,1 @@\n+import java.util.Collections;\n@@ -53,5 +56,0 @@\n-import static java.lang.constant.ConstantDescs.CD_Double;\n-import static java.lang.constant.ConstantDescs.CD_Integer;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_String;\n-\n@@ -64,0 +62,24 @@\n+    @Test\n+    void testExceptionalContracts() throws Throwable {\n+        generateTryCatchMethod(catchBuilder -> {\n+            Consumer<CodeBuilder.BlockCodeBuilder> handler = tb -> tb.pop().aconst_null().areturn();\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catching(CD_NPE, null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(null, handler));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(List.of(), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingMulti(Collections.singletonList(null), null));\n+            assertThrows(NullPointerException.class, () -> catchBuilder.catchingAll(null));\n+            catchBuilder.catchingMulti(List.of(CD_IOOBE, CD_NPE), tb -> {\n+                tb.invokevirtual(CD_Object, \"toString\", MTD_String);\n+                tb.astore(1);\n+            });\n+            catchBuilder.catchingAll(tb -> tb.pop().loadConstant(\"all\").areturn());\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catching(CD_int, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(CD_NPE, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catching(null, handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingMulti(List.of(CD_Exception, CD_IOOBE), handler));\n+            assertThrows(IllegalArgumentException.class, () -> catchBuilder.catchingMulti(List.of(CD_long, CD_Throwable), handler));\n+            assertDoesNotThrow(() -> catchBuilder.catchingAll(handler));\n+        });\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 8341277 8361102\n- * @summary Testing ClassFile instruction argument validation.\n+ * @bug 8341277 8361102 8361182 8361614\n+ * @summary Testing ClassFile (pseudo-)instruction argument validation.\n@@ -32,0 +32,2 @@\n+import java.lang.classfile.attribute.CharacterRangeInfo;\n+import java.lang.classfile.attribute.LineNumberInfo;\n@@ -281,0 +283,58 @@\n+\n+    @Test\n+    void testCharacterRange() {\n+        assertDoesNotThrow(() -> CharacterRangeInfo.of(0, 0, -234, 59494648, 0));\n+        assertDoesNotThrow(() -> CharacterRangeInfo.of(0, 0, -234, 59494648, 65535));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeInfo.of(0, 0, -234, 59494648, -1));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeInfo.of(0, 0, -234, 59494648, 65536));\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var dummyLabel = cob.startLabel();\n+            assertDoesNotThrow(() -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 0));\n+            assertDoesNotThrow(() -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 65535));\n+            assertThrows(IllegalArgumentException.class, () -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, -1));\n+            assertThrows(IllegalArgumentException.class, () -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 65536));\n+            assertThrows(IllegalArgumentException.class, () -> cob.characterRange(dummyLabel, dummyLabel, -234, 59494648, -1));\n+            assertThrows(IllegalArgumentException.class, () -> cob.characterRange(dummyLabel, dummyLabel, -234, 59494648, 65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testLineNumber() {\n+        assertDoesNotThrow(() -> LineNumberInfo.of(0, 25));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberInfo.of(0, -1));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberInfo.of(0, 65536));\n+        assertDoesNotThrow(() -> LineNumber.of(25));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumber.of(-1));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumber.of(65536));\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            assertThrows(IllegalArgumentException.class, () -> cob.lineNumber(-1));\n+            assertThrows(IllegalArgumentException.class, () -> cob.lineNumber(65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationLocalVarTargetInfo() {\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var label = cob.startLabel();\n+            assertDoesNotThrow(() -> TypeAnnotation.LocalVarTargetInfo.of(label, label, 256));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.LocalVarTargetInfo.of(label, label, -1));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.LocalVarTargetInfo.of(label, label, 65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationTypeArgumentTarget() {\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var label = cob.startLabel();\n+            assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofTypeArgument(TypeAnnotation.TargetType.CAST, label, 0));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofCastExpr(label, -1));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodInvocationTypeArgument(label, Integer.MIN_VALUE));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodReferenceTypeArgument(label, 256));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofConstructorInvocationTypeArgument(label, 300));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofConstructorReferenceTypeArgument(label, -2));\n+            cob.return_();\n+        }));\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/InstructionValidationTest.java","additions":63,"deletions":3,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8320360 8330684 8331320 8331655 8331940 8332486 8335820 8336833\n+ * @bug 8320360 8330684 8331320 8331655 8331940 8332486 8335820 8336833 8361635\n@@ -30,0 +30,3 @@\n+\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.AttributedElement;\n@@ -31,4 +34,1 @@\n-import java.lang.classfile.constantpool.PoolEntry;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.BufWriter;\n@@ -36,0 +36,4 @@\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CustomAttribute;\n+import java.lang.classfile.Label;\n@@ -37,0 +41,1 @@\n+import java.lang.classfile.Signature;\n@@ -44,0 +49,1 @@\n+import java.lang.classfile.constantpool.PoolEntry;\n@@ -45,0 +51,5 @@\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n@@ -46,0 +57,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n@@ -54,0 +67,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -76,0 +91,108 @@\n+    @Test\n+    void testBsmOverLimit() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            var cp = clb.constantPool();\n+            var mhe = cp.methodHandleEntry(BSM_GET_STATIC_FINAL);\n+            var digits = new IntegerEntry[10];\n+            for (int i = 0; i < 10; i++) {\n+                digits[i] = cp.intEntry(i);\n+            }\n+            int lastIndex = -1;\n+            for (int i = 0; i < 66000; i++) {\n+                lastIndex = cp.bsmEntry(mhe, List.of(\n+                        digits[i \/ 10000 % 10],\n+                        digits[i \/ 1000 % 10],\n+                        digits[i \/ 100 % 10],\n+                        digits[i \/ 10 % 10],\n+                        digits[i \/ 1 % 10])).bsmIndex();\n+            }\n+            assertEquals(65999, lastIndex);\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testTooManyFields() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                clb.withField(\"f\", CD_int, 0);\n+            }\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testTooManyMethods() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                clb.withMethodBody(\"m\", MTD_void, 0, CodeBuilder::return_);\n+            }\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    static final class MyAttribute extends CustomAttribute<MyAttribute> {\n+        static final MyAttribute INSTANCE = new MyAttribute();\n+\n+        private enum Mapper implements AttributeMapper<MyAttribute> {\n+            INSTANCE;\n+\n+            @Override\n+            public MyAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void writeAttribute(BufWriter buf, MyAttribute attr) {\n+                buf.writeIndex(buf.constantPool().utf8Entry(\"MyAttribute\"));\n+                buf.writeInt(0);\n+            }\n+\n+            @Override\n+            public boolean allowMultiple() {\n+                return true;\n+            }\n+\n+            @Override\n+            public AttributeStability stability() {\n+                return AttributeStability.STATELESS;\n+            }\n+\n+\n+        }\n+\n+        private MyAttribute() {\n+            super(Mapper.INSTANCE);\n+        }\n+    }\n+\n+    @Test\n+    void testTooManyClassAttributes() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                clb.with(MyAttribute.INSTANCE);\n+            }\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testTooManyFieldAttributes() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> clb.withField(\"f\", CD_int, fb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                fb.with(MyAttribute.INSTANCE);\n+            }\n+            reached.set(true);\n+        })));\n+        assertTrue(reached.get());\n+    }\n+\n@@ -102,0 +225,85 @@\n+    private static void testPseudoOverflow(BiConsumer<CodeBuilder, Label> handler) {\n+        ClassFile cf = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        AtomicBoolean reached = new AtomicBoolean(false);\n+        assertDoesNotThrow(() -> cf.build(CD_Void, cb -> cb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            cob.nop();\n+            var label = cob.newLabel();\n+            for (int i = 0; i < 65535; i++) {\n+                handler.accept(cob, label);\n+            }\n+            cob.labelBinding(label);\n+            cob.return_();\n+            reached.set(true);\n+        })));\n+        assertTrue(reached.get());\n+\n+        reached.set(false);\n+        assertThrows(IllegalArgumentException.class, () -> cf.build(CD_Void, cb -> cb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            cob.nop();\n+            var label = cob.newLabel();\n+            for (int i = 0; i < 65536; i++) {\n+                handler.accept(cob, label);\n+            }\n+            cob.labelBinding(label);\n+            cob.return_();\n+            reached.set(true);\n+        })));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testExceptionCatchOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.exceptionCatch(cob.startLabel(), label, label, CD_Throwable));\n+    }\n+\n+    @Test\n+    void testLocalVariableOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.localVariable(0, \"fake\", CD_int, cob.startLabel(), label));\n+    }\n+\n+    @Test\n+    void testLocalVariableTypeOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.localVariableType(0, \"fake\", Signature.of(CD_int), cob.startLabel(), label));\n+    }\n+\n+    @Test\n+    void testCharacterRangeOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.characterRange(cob.startLabel(), label, 0, 0, 0));\n+    }\n+\n+    \/\/ LineNumber deduplicates so cannot really overflow\n+\n+    @Test\n+    void testHugeLookupswitch() {\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> clb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            var l = cob.newLabel();\n+            \/\/ 10000 * 8 > 65535\n+            var cases = new ArrayList<SwitchCase>(10000);\n+            for (int i = 0; i < 10000; i++) {\n+                cases.add(SwitchCase.of(i, l));\n+            }\n+            cob.lookupswitch(l, cases);\n+            cob.labelBinding(l);\n+            cob.return_();\n+        })));\n+    }\n+\n+    @Test\n+    void testHugeTableswitch() {\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> clb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            var l = cob.newLabel();\n+            \/\/ 20000 * 4 > 65535\n+            cob.tableswitch(-10000, 10000, l, List.of());\n+            cob.labelBinding(l);\n+            cob.return_();\n+        })));\n+    }\n+\n+    @Test\n+    void testHugeUtf8Entry() {\n+        var longString = String.valueOf((char) 0x800).repeat(22000);\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            clb.constantPool().utf8Entry(longString);\n+        }));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":214,"deletions":6,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -0,0 +1,348 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361635\n+ * @summary Testing list size validation in class file format.\n+ * @run junit ListValidationTest\n+ *\/\n+\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Interfaces;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.util.Collections.nCopies;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class ListValidationTest {\n+    @Test\n+    void testAnnotationElements() {\n+        var e = AnnotationElement.ofInt(\"dummy\", 0);\n+        assertDoesNotThrow(() -> Annotation.of(CD_String, nCopies(65535, e)));\n+        assertThrows(IllegalArgumentException.class, () -> Annotation.of(CD_String, nCopies(66000, e)));\n+    }\n+\n+    @Test\n+    void testAnnotationArrayValue() {\n+        var v = AnnotationValue.ofInt(0);\n+        assertDoesNotThrow(() -> AnnotationValue.ofArray(nCopies(65535, v)));\n+        assertThrows(IllegalArgumentException.class, () -> AnnotationValue.ofArray(nCopies(66000, v)));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationPath() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> TypeAnnotation.of(TypeAnnotation.TargetInfo.ofField(), nCopies(255, TypeAnnotation.TypePathComponent.INNER_TYPE), anno));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.of(TypeAnnotation.TargetInfo.ofField(), nCopies(256, TypeAnnotation.TypePathComponent.INNER_TYPE), anno));\n+    }\n+\n+    @Test\n+    void testBsmArgs() {\n+        var cpb = ConstantPoolBuilder.of();\n+        assertDoesNotThrow(() -> cpb.bsmEntry(BSM_INVOKE, nCopies(65535, 0)));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.bsmEntry(BSM_INVOKE, nCopies(66000, 0)));\n+    }\n+\n+    @Test\n+    void testInterfaces() {\n+        var cpb = ConstantPoolBuilder.of();\n+        assertDoesNotThrow(() -> Interfaces.ofSymbols(nCopies(65535, CD_Number)));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.bsmEntry(BSM_INVOKE, nCopies(66000, 0)));\n+    }\n+\n+    @Test\n+    void testStackMapFrame() {\n+        Label label = dummyLabel();\n+        assertDoesNotThrow(() -> StackMapFrameInfo.of(label,\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE)));\n+        assertThrows(IllegalArgumentException.class, () -> StackMapFrameInfo.of(label,\n+                nCopies(66000, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE)));\n+        assertThrows(IllegalArgumentException.class, () -> StackMapFrameInfo.of(label,\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(66000, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE)));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationLocalVarTarget() {\n+        Label label = dummyLabel();\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofLocalVariable(nCopies(65535, TypeAnnotation.LocalVarTargetInfo.of(label, label, 0))));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofLocalVariable(nCopies(66000, TypeAnnotation.LocalVarTargetInfo.of(label, label, 0))));\n+    }\n+\n+    @Test\n+    void testExceptionsAttribute() {\n+        assertDoesNotThrow(() -> ExceptionsAttribute.ofSymbols(nCopies(65535, CD_Throwable)));\n+        assertThrows(IllegalArgumentException.class, () -> ExceptionsAttribute.ofSymbols(nCopies(66000, CD_Throwable)));\n+    }\n+\n+    @Test\n+    void testStackMapTableAttribute() {\n+        var frame = StackMapFrameInfo.of(dummyLabel(),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE));\n+        assertDoesNotThrow(() -> StackMapTableAttribute.of(nCopies(65535, frame)));\n+        assertThrows(IllegalArgumentException.class, () -> StackMapTableAttribute.of(nCopies(66000, frame)));\n+    }\n+\n+    @Test\n+    void testInnerClassesAttribute() {\n+        var entry = InnerClassInfo.of(CD_Void, Optional.empty(), Optional.empty(), 0);\n+        assertDoesNotThrow(() -> InnerClassesAttribute.of(nCopies(65535, entry)));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassesAttribute.of(nCopies(66000, entry)));\n+    }\n+\n+    @Test\n+    void testRecordAttribute() {\n+        var component = RecordComponentInfo.of(\"hello\", CD_int, List.of());\n+        assertDoesNotThrow(() -> RecordAttribute.of(nCopies(65535, component)));\n+        assertThrows(IllegalArgumentException.class, () -> RecordAttribute.of(nCopies(66000, component)));\n+    }\n+\n+    @Test\n+    void testMethodParametersAttribute() {\n+        var component = MethodParameterInfo.of(Optional.empty(), 0);\n+        assertDoesNotThrow(() -> MethodParametersAttribute.of(nCopies(255, component)));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParametersAttribute.of(nCopies(300, component)));\n+    }\n+\n+    @Test\n+    void testModuleHashesAttribute() {\n+        var hash = ModuleHashInfo.of(ModuleDesc.of(\"java.base\"), new byte[0]);\n+        assertDoesNotThrow(() -> ModuleHashesAttribute.of(\"dummy\", nCopies(65535, hash)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleHashesAttribute.of(\"dummy\", nCopies(66000, hash)));\n+    }\n+\n+    @Test\n+    void testModulePackagesAttribute() {\n+        var pkgDesc = PackageDesc.of(\"java.io\");\n+        assertDoesNotThrow(() -> ModulePackagesAttribute.ofNames(nCopies(65535, pkgDesc)));\n+        assertThrows(IllegalArgumentException.class, () -> ModulePackagesAttribute.ofNames(nCopies(66000, pkgDesc)));\n+    }\n+\n+    @Test\n+    void testPermittedSubclassesAttribute() {\n+        assertDoesNotThrow(() -> PermittedSubclassesAttribute.ofSymbols(nCopies(65535, CD_Collection)));\n+        assertThrows(IllegalArgumentException.class, () -> PermittedSubclassesAttribute.ofSymbols(nCopies(66000, CD_Collection)));\n+    }\n+\n+    @Test\n+    void testNestMembersAttribute() {\n+        assertDoesNotThrow(() -> NestMembersAttribute.ofSymbols(nCopies(65535, CD_Collection)));\n+        assertThrows(IllegalArgumentException.class, () -> NestMembersAttribute.ofSymbols(nCopies(66000, CD_Collection)));\n+    }\n+\n+    @Test\n+    void testCharacterRangeTableAttribute() {\n+        var range = CharacterRangeInfo.of(0, 0, 0, 0, 0);\n+        assertDoesNotThrow(() -> CharacterRangeTableAttribute.of(nCopies(65535, range)));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeTableAttribute.of(nCopies(66000, range)));\n+    }\n+\n+    @Test\n+    void testLineNumberTableAttribute() {\n+        var lineNumber = LineNumberInfo.of(0, 0);\n+        assertDoesNotThrow(() -> LineNumberTableAttribute.of(nCopies(65535, lineNumber)));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberTableAttribute.of(nCopies(66000, lineNumber)));\n+    }\n+\n+    @Test\n+    void testLocalVariableTableAttribute() {\n+        var utf8 = TemporaryConstantPool.INSTANCE.utf8Entry(\"dummy\");\n+        var localVariable = new UnboundAttribute.UnboundLocalVariableInfo(0, 0, utf8, utf8, 0);\n+        assertDoesNotThrow(() -> LocalVariableTableAttribute.of(nCopies(65535, localVariable)));\n+        assertThrows(IllegalArgumentException.class, () -> LocalVariableTableAttribute.of(nCopies(66000, localVariable)));\n+    }\n+\n+    @Test\n+    void testLocalVariableTypeTableAttribute() {\n+        var utf8 = TemporaryConstantPool.INSTANCE.utf8Entry(\"dummy\");\n+        var localVariableType = new UnboundAttribute.UnboundLocalVariableTypeInfo(0, 0, utf8, utf8, 0);\n+        assertDoesNotThrow(() -> LocalVariableTypeTableAttribute.of(nCopies(65535, localVariableType)));\n+        assertThrows(IllegalArgumentException.class, () -> LocalVariableTypeTableAttribute.of(nCopies(66000, localVariableType)));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleAnnotationsAttribute() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeVisibleAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleAnnotationsAttribute() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeInvisibleAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleParameterAnnotationsAttributeTopLevel() {\n+        assertDoesNotThrow(() -> RuntimeVisibleParameterAnnotationsAttribute.of(nCopies(255, List.of())));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleParameterAnnotationsAttribute.of(nCopies(256, List.of())));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleParameterAnnotationsAttributeTopLevel() {\n+        assertDoesNotThrow(() -> RuntimeInvisibleParameterAnnotationsAttribute.of(nCopies(255, List.of())));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleParameterAnnotationsAttribute.of(nCopies(256, List.of())));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleParameterAnnotationsAttributeNested() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeVisibleParameterAnnotationsAttribute.of(List.of(nCopies(65535, anno))));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleParameterAnnotationsAttribute.of(List.of(nCopies(65536, anno))));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleParameterAnnotationsAttributeNested() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(nCopies(65535, anno))));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(nCopies(65536, anno))));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleTypeAnnotationsAttribute() {\n+        var anno = TypeAnnotation.of(TypeAnnotation.TargetInfo.ofMethodReturn(), List.of(), Annotation.of(CD_String));\n+        assertDoesNotThrow(() -> RuntimeVisibleTypeAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleTypeAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleTypeAnnotationsAttribute() {\n+        var anno = TypeAnnotation.of(TypeAnnotation.TargetInfo.ofMethodReturn(), List.of(), Annotation.of(CD_String));\n+        assertDoesNotThrow(() -> RuntimeInvisibleTypeAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleTypeAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testModuleExportEntry() {\n+        var pkg = PackageDesc.of(\"dummy.test\");\n+        var mod = ModuleDesc.of(\"the.other\");\n+        assertDoesNotThrow(() -> ModuleExportInfo.of(pkg, 0, nCopies(65535, mod)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(pkg, 0, nCopies(66000, mod)));\n+    }\n+\n+    @Test\n+    void testModuleOpenEntry() {\n+        var pkg = PackageDesc.of(\"dummy.test\");\n+        var mod = ModuleDesc.of(\"the.other\");\n+        assertDoesNotThrow(() -> ModuleOpenInfo.of(pkg, 0, nCopies(65535, mod)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(pkg, 0, nCopies(66000, mod)));\n+    }\n+\n+    @Test\n+    void testModuleProvideEntry() {\n+        assertDoesNotThrow(() -> ModuleProvideInfo.of(CD_Object, nCopies(65535, CD_String)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleProvideInfo.of(CD_Object, nCopies(66000, CD_String)));\n+    }\n+\n+    @Test\n+    void testRecordComponentAttributes() {\n+        var attr = SyntheticAttribute.of();\n+        assertDoesNotThrow(() -> RecordComponentInfo.of(\"dummy\", CD_int, nCopies(65535, attr)));\n+        assertThrows(IllegalArgumentException.class, () -> RecordComponentInfo.of(\"dummy\", CD_int, nCopies(66000, attr)));\n+    }\n+\n+    @Test\n+    void testModuleAttribute() {\n+        var md = ModuleDesc.of(\"java.base\");\n+        var pkg = PackageDesc.of(\"java.lang\");\n+        var require = ModuleRequireInfo.of(md, 0, null);\n+        var export = ModuleExportInfo.of(pkg, 0, List.of());\n+        var provide = ModuleProvideInfo.of(CD_Object, List.of());\n+        var open = ModuleOpenInfo.of(pkg, 0, List.of());\n+        var classEntry = TemporaryConstantPool.INSTANCE.classEntry(CD_String);\n+        var moduleEntry = TemporaryConstantPool.INSTANCE.moduleEntry(md);\n+        assertDoesNotThrow(() -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(66000, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(66000, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(66000, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(66000, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(66000, provide)\n+        ));\n+    }\n+\n+    private static Label dummyLabel() {\n+        Label[] capture = new Label[1];\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            capture[0] = cob.startLabel();\n+            cob.return_();\n+        }));\n+        return capture[0];\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ListValidationTest.java","additions":348,"deletions":0,"binary":false,"changes":348,"status":"added"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import java.lang.classfile.ClassFile;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.constant.ClassDesc;\n-\n-import static java.lang.constant.ConstantDescs.*;\n-import static java.lang.classfile.ClassFile.*;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-\/*\n- * @test\n- * @bug 8311172\n- * @run junit PreviewMinorVersionTest\n- * @summary Ensures ClassFile.PREVIEW_MINOR_VERSION equals that of classes with\n- *          preview minor version from ClassModel::minorVersion\n- *\/\n-public class PreviewMinorVersionTest {\n-\n-    @Test\n-    public void testMinorVersionMatches() {\n-        \/\/ compile a class with --enable-preview\n-        \/\/ uses Record feature to trigger forcePreview\n-        var cf = ClassFile.of();\n-        var cd = ClassDesc.of(\"Test\");\n-        var bytes = cf.build(cd, cb -> cb\n-                .withSuperclass(CD_Object)\n-                \/\/ old preview minor version,\n-                \/\/ with all bits set to 1\n-                .withVersion(JAVA_17_VERSION, -1)\n-        );\n-\n-        var cm = ClassFile.of().parse(bytes);\n-        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, cm.minorVersion());\n-    }\n-}\n","filename":"test\/jdk\/jdk\/classfile\/PreviewMinorVersionTest.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileVersion;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.JAVA_17_VERSION;\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8311172 8361614\n+ * @summary Testing ClassFile validation of non-instruction subint (u1, u2) arguments.\n+ * @run junit SubIntValidationTest\n+ *\/\n+class SubIntValidationTest {\n+\n+    @Test\n+    public void testBuilderFlags() {\n+        ClassFile.of().build(CD_Void, clb -> {\n+            assertThrows(IllegalArgumentException.class, () -> clb.withFlags(-1));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withFlags(70000));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withField(\"test\", CD_String, -1));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withField(\"test\", CD_String, 70000));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withMethod(\"test\", MTD_void, -1, _ -> {}));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withMethod(\"test\", MTD_void, 70000, _ -> {}));\n+            clb.withField(\"test\", CD_String, fb -> {\n+                assertThrows(IllegalArgumentException.class, () -> fb.withFlags(-1));\n+                assertThrows(IllegalArgumentException.class, () -> fb.withFlags(70000 | ACC_STATIC));\n+            });\n+            clb.withMethod(\"test\", MTD_void, ACC_STATIC, mb -> {\n+                assertThrows(IllegalArgumentException.class, () -> mb.withFlags(-1));\n+                assertThrows(IllegalArgumentException.class, () -> mb.withFlags(70000 | ACC_STATIC));\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void testClassFileVersion() {\n+        \/\/ Prohibited but representable major\/minor\n+        assertDoesNotThrow(() -> ClassFileVersion.of(0, 0));\n+        \/\/ Non-representable major\/minor\n+        assertDoesNotThrow(() -> ClassFileVersion.of(JAVA_17_VERSION, 42));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(-1, 0));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(65536, 0));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(0, -2));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(0, 65536));\n+        ClassFile.of().build(CD_Void, clb -> assertThrows(IllegalArgumentException.class, () -> clb.withVersion(-1, 0)));\n+        \/\/ Special rule without serializing to class file format\n+        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, ClassFileVersion.of(0, -1).minorVersion());\n+    }\n+\n+    @Test\n+    public void testReadMinorVersion() {\n+        var cf = ClassFile.of();\n+        var cd = ClassDesc.of(\"Test\");\n+        var bytes = cf.build(cd, cb -> cb\n+                .withSuperclass(CD_Object)\n+                \/\/ old preview minor version,\n+                \/\/ with all bits set to 1\n+                .withVersion(JAVA_17_VERSION, -1)\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, cm.minorVersion());\n+    }\n+\n+    \/\/ LocalVarTargetInfo\/TypeArgumentTarget in InstructionValidationTest for Label\n+    @Test\n+    public void testTypeAnnotations() {\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofTypeParameter(TypeAnnotation.TargetType.CLASS_TYPE_PARAMETER, 0));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassTypeParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodTypeParameter(300));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofClassExtends(65535));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassExtends(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassExtends(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofClassTypeParameterBound(255, 255));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassTypeParameterBound(-1, 255));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodTypeParameterBound(0, 256));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(0));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(256));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofThrows(256));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofThrows(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofThrows(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofExceptionParameter(256));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofExceptionParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofExceptionParameter(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.ARRAY, 2));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.INNER_TYPE, -1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.TYPE_ARGUMENT, 256));\n+    }\n+\n+    @Test\n+    public void testInnerClasses() {\n+        assertDoesNotThrow(() -> InnerClassInfo.of(CD_Object, Optional.empty(), Optional.empty(), 65535));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassInfo.of(CD_Object, Optional.empty(), Optional.empty(), -1));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassInfo.of(ConstantPoolBuilder.of().classEntry(CD_String),\n+                Optional.empty(), Optional.empty(), 65536));\n+    }\n+\n+    @Test\n+    public void testMethodParameter() {\n+        assertDoesNotThrow(() -> MethodParameterInfo.of(Optional.empty(), 65535));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParameterInfo.of(Optional.empty(), -1));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParameterInfo.ofParameter(Optional.empty(), 65536));\n+    }\n+\n+    @Test\n+    public void testModule() {\n+        assertDoesNotThrow(() -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                65535, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                -1, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                65536, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        ModuleAttribute.of(ModuleDesc.of(\"java.base\"), b -> {\n+            assertThrows(IllegalArgumentException.class, () -> b.moduleFlags(-1));\n+            assertThrows(IllegalArgumentException.class, () -> b.moduleFlags(65536));\n+            b.moduleFlags(0);\n+        });\n+    }\n+\n+    @Test\n+    public void testModuleExport() {\n+        assertDoesNotThrow(() -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), 0));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), -1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), 65536));\n+    }\n+\n+    @Test\n+    public void testModuleOpen() {\n+        assertDoesNotThrow(() -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), 0));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), -1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), 65536));\n+    }\n+\n+    @Test\n+    public void testModuleRequire() {\n+        assertDoesNotThrow(() -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), 0, null));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), -1, null));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), 65536, null));\n+    }\n+\n+    @Test\n+    public void testModuleResolution() {\n+        assertDoesNotThrow(() -> ModuleResolutionAttribute.of(256));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleResolutionAttribute.of(-1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleResolutionAttribute.of(65536));\n+    }\n+\n+    @Test\n+    public void testMethodHandleEntry() {\n+        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n+        var ref = cp.fieldRefEntry(CD_String, \"a\", CD_int);\n+        \/\/ Intentionally choose an invalid but representable refKind\n+        assertDoesNotThrow(() -> cp.methodHandleEntry(25, ref));\n+        assertThrows(IllegalArgumentException.class, () -> cp.methodHandleEntry(256, ref));\n+        assertThrows(IllegalArgumentException.class, () -> cp.methodHandleEntry(-1, ref));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/SubIntValidationTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run main\/timeout=480 AddTest\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AddTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.jimage.ImageReader;\n+import jdk.internal.jimage.ImageReader.Node;\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import jdk.test.lib.util.JarBuilder;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import tests.Helper;\n+import tests.JImageGenerator;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;\n+\n+\/*\n+ * @test\n+ * @summary Tests for ImageReader.\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @library \/test\/jdk\/tools\/lib\n+ *          \/test\/lib\n+ * @build tests.*\n+ * @run junit\/othervm ImageReaderTest\n+ *\/\n+\n+\/\/\/ Using PER_CLASS lifecycle means the (expensive) image file is only build once.\n+\/\/\/ There is no mutable test instance state to worry about.\n+@TestInstance(PER_CLASS)\n+public class ImageReaderTest {\n+\n+    private static final Map<String, List<String>> IMAGE_ENTRIES = Map.of(\n+            \"modfoo\", Arrays.asList(\n+                    \"com.foo.Alpha\",\n+                    \"com.foo.Beta\",\n+                    \"com.foo.bar.Gamma\"),\n+            \"modbar\", Arrays.asList(\n+                    \"com.bar.One\",\n+                    \"com.bar.Two\"));\n+    private final Path image = buildJImage(IMAGE_ENTRIES);\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/\",\n+            \"\/modules\",\n+            \"\/modules\/modfoo\",\n+            \"\/modules\/modbar\",\n+            \"\/modules\/modfoo\/com\",\n+            \"\/modules\/modfoo\/com\/foo\",\n+            \"\/modules\/modfoo\/com\/foo\/bar\"})\n+    public void testModuleDirectories_expected(String name) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertDir(reader, name);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\",\n+            \"\/\/\",\n+            \"\/modules\/\",\n+            \"\/modules\/unknown\",\n+            \"\/modules\/modbar\/\",\n+            \"\/modules\/modfoo\/\/com\",\n+            \"\/modules\/modfoo\/com\/\"})\n+    public void testModuleNodes_absent(String name) throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertAbsent(reader, name);\n+        }\n+    }\n+\n+    @Test\n+    public void testModuleResources() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            assertNode(reader, \"\/modules\/modfoo\/com\/foo\/Alpha.class\");\n+            assertNode(reader, \"\/modules\/modbar\/com\/bar\/One.class\");\n+\n+            ImageClassLoader loader = new ImageClassLoader(reader, IMAGE_ENTRIES.keySet());\n+            assertEquals(\"Class: com.foo.Alpha\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Alpha\"));\n+            assertEquals(\"Class: com.foo.Beta\", loader.loadAndGetToString(\"modfoo\", \"com.foo.Beta\"));\n+            assertEquals(\"Class: com.foo.bar.Gamma\", loader.loadAndGetToString(\"modfoo\", \"com.foo.bar.Gamma\"));\n+            assertEquals(\"Class: com.bar.One\", loader.loadAndGetToString(\"modbar\", \"com.bar.One\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageDirectories() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            Node root = assertDir(reader, \"\/packages\");\n+            Set<String> pkgNames = root.getChildNames().collect(Collectors.toSet());\n+            assertTrue(pkgNames.contains(\"\/packages\/com\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.foo\"));\n+            assertTrue(pkgNames.contains(\"\/packages\/com.bar\"));\n+\n+            \/\/ Even though no classes exist directly in the \"com\" package, it still\n+            \/\/ creates a directory with links back to all the modules which contain it.\n+            Set<String> comLinks = assertDir(reader, \"\/packages\/com\").getChildNames().collect(Collectors.toSet());\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modfoo\"));\n+            assertTrue(comLinks.contains(\"\/packages\/com\/modbar\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testPackageLinks() throws IOException {\n+        try (ImageReader reader = ImageReader.open(image)) {\n+            Node moduleFoo = assertDir(reader, \"\/modules\/modfoo\");\n+            Node moduleBar = assertDir(reader, \"\/modules\/modbar\");\n+            assertSame(assertLink(reader, \"\/packages\/com.foo\/modfoo\").resolveLink(), moduleFoo);\n+            assertSame(assertLink(reader, \"\/packages\/com.bar\/modbar\").resolveLink(), moduleBar);\n+        }\n+    }\n+\n+    private static ImageReader.Node assertNode(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node node = reader.findNode(name);\n+        assertNotNull(node, \"Could not find node: \" + name);\n+        return node;\n+    }\n+\n+    private static ImageReader.Node assertDir(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node dir = assertNode(reader, name);\n+        assertTrue(dir.isDirectory(), \"Node was not a directory: \" + name);\n+        return dir;\n+    }\n+\n+    private static ImageReader.Node assertLink(ImageReader reader, String name) throws IOException {\n+        ImageReader.Node link = assertNode(reader, name);\n+        assertTrue(link.isLink(), \"Node was not a symbolic link: \" + name);\n+        return link;\n+    }\n+\n+    private static void assertAbsent(ImageReader reader, String name) throws IOException {\n+        assertNull(reader.findNode(name), \"Should not be able to find node: \" + name);\n+    }\n+\n+    \/\/\/ Builds a jimage file with the specified class entries. The classes in the built\n+    \/\/\/ image can be loaded and executed to return their names via `toString()` to confirm\n+    \/\/\/ the correct bytes were returned.\n+    public static Path buildJImage(Map<String, List<String>> entries) {\n+        Helper helper = getHelper();\n+        Path outDir = helper.createNewImageDir(\"test\");\n+        JImageGenerator.JLinkTask jlink = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(outDir);\n+\n+        Path jarDir = helper.getJarDir();\n+        entries.forEach((module, classes) -> {\n+            JarBuilder jar = new JarBuilder(jarDir.resolve(module + \".jar\").toString());\n+            String moduleInfo = \"module \" + module + \" {}\";\n+            jar.addEntry(\"module-info.class\", InMemoryJavaCompiler.compile(\"module-info\", moduleInfo));\n+\n+            classes.forEach(fqn -> {\n+                int lastDot = fqn.lastIndexOf('.');\n+                String pkg = fqn.substring(0, lastDot);\n+                String cls = fqn.substring(lastDot + 1);\n+\n+                String path = fqn.replace('.', '\/') + \".class\";\n+                String source = String.format(\n+                        \"\"\"\n+                        package %s;\n+                        public class %s {\n+                            public String toString() {\n+                                return \"Class: %s\";\n+                            }\n+                        }\n+                        \"\"\", pkg, cls, fqn);\n+                jar.addEntry(path, InMemoryJavaCompiler.compile(fqn, source));\n+            });\n+            try {\n+                jar.build();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+            jlink.addMods(module);\n+        });\n+        return jlink.call().assertSuccess().resolve(\"lib\", \"modules\");\n+    }\n+\n+    \/\/\/  Returns the helper for building JAR and jimage files.\n+    private static Helper getHelper() {\n+        Helper helper;\n+        try {\n+            boolean isLinkableRuntime = LinkableRuntimeImage.isLinkableRuntime();\n+            helper = Helper.newHelper(isLinkableRuntime);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        Assumptions.assumeTrue(helper != null, \"Cannot create test helper, skipping test!\");\n+        return helper;\n+    }\n+\n+    \/\/\/ Loads and performs actions on classes stored in a given `ImageReader`.\n+    private static class ImageClassLoader extends ClassLoader {\n+        private final ImageReader reader;\n+        private final Set<String> testModules;\n+\n+        private ImageClassLoader(ImageReader reader, Set<String> testModules) {\n+            this.reader = reader;\n+            this.testModules = testModules;\n+        }\n+\n+        @FunctionalInterface\n+        public interface ClassAction<R, T extends Exception> {\n+            R call(Class<?> cls) throws T;\n+        }\n+\n+        String loadAndGetToString(String module, String fqn) {\n+            return loadAndCall(module, fqn, c -> c.getDeclaredConstructor().newInstance().toString());\n+        }\n+\n+        <R> R loadAndCall(String module, String fqn, ClassAction<R, ?> action) {\n+            Class<?> cls = findClass(module, fqn);\n+            assertNotNull(cls, \"Could not load class: \" + module + \"\/\" + fqn);\n+            try {\n+                return action.call(cls);\n+            } catch (Exception e) {\n+                fail(\"Class loading failed\", e);\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String module, String fqn) {\n+            assumeTrue(testModules.contains(module), \"Can only load classes in modules: \" + testModules);\n+            String name = \"\/modules\/\" + module + \"\/\" + fqn.replace('.', '\/') + \".class\";\n+            Class<?> cls = findLoadedClass(fqn);\n+            if (cls == null) {\n+                try {\n+                    ImageReader.Node node = reader.findNode(name);\n+                    if (node != null && node.isResource()) {\n+                        byte[] classBytes = reader.getResource(node);\n+                        cls = defineClass(fqn, classBytes, 0, classBytes.length);\n+                        resolveClass(cls);\n+                        return cls;\n+                    }\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jimage\/ImageReaderTest.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,3 @@\n+import static java.nio.ByteOrder.BIG_ENDIAN;\n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+\n@@ -336,19 +339,6 @@\n-        ImageReader nativeReader = ImageReader.open(imageFile);\n-        Assert.assertEquals(nativeReader.getByteOrder(), ByteOrder.nativeOrder());\n-\n-        try {\n-            ImageReader leReader = ImageReader.open(imageFile, ByteOrder.LITTLE_ENDIAN);\n-            Assert.assertEquals(leReader.getByteOrder(), ByteOrder.LITTLE_ENDIAN);\n-            leReader.close();\n-        } catch (IOException io) {\n-            \/\/ IOException expected if LITTLE_ENDIAN not the nativeOrder()\n-            Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.LITTLE_ENDIAN);\n-        }\n-\n-        try {\n-            ImageReader beReader = ImageReader.open(imageFile, ByteOrder.BIG_ENDIAN);\n-            Assert.assertEquals(beReader.getByteOrder(), ByteOrder.BIG_ENDIAN);\n-            beReader.close();\n-        } catch (IOException io) {\n-            \/\/ IOException expected if LITTLE_ENDIAN not the nativeOrder()\n-            Assert.assertNotEquals(ByteOrder.nativeOrder(), ByteOrder.BIG_ENDIAN);\n+        \/\/ Will be opened with native byte order.\n+        try (ImageReader nativeReader = ImageReader.open(imageFile)) {\n+            \/\/ Just ensure something works as expected.\n+            Assert.assertNotNull(nativeReader.findNode(\"\/\"));\n+        } catch (IOException expected) {\n+            Assert.fail(\"Reader should be openable with native byte order.\");\n@@ -357,1 +347,3 @@\n-        nativeReader.close();\n+        \/\/ Reader should not be openable with the wrong byte order.\n+        ByteOrder otherOrder = ByteOrder.nativeOrder() == BIG_ENDIAN ? LITTLE_ENDIAN : BIG_ENDIAN;\n+        Assert.assertThrows(IOException.class, () -> ImageReader.open(imageFile, otherOrder));\n@@ -359,1 +351,0 @@\n-    \/\/ main method to run standalone from jtreg\n@@ -361,1 +352,2 @@\n-    @Test(enabled=false)\n+    \/\/ main method to run standalone from jtreg\n+    @Test(enabled = false)\n","filename":"test\/jdk\/jdk\/internal\/jimage\/JImageReadTest.java","additions":15,"deletions":23,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8331535 8351435 8347050\n+ * @bug 8331535 8351435 8347050 8361613\n@@ -28,1 +28,2 @@\n- * @modules jdk.internal.le\n+ * @modules java.base\/jdk.internal.io\n+ *          jdk.internal.le\/jdk.internal.org.jline\n@@ -30,1 +31,1 @@\n- * @run main\/othervm -Djdk.console=jdk.internal.le JLineConsoleProviderTest\n+ * @run main JLineConsoleProviderTest\n@@ -34,0 +35,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -36,0 +38,1 @@\n+import jdk.internal.org.jline.JdkConsoleProviderImpl;\n@@ -69,2 +72,7 @@\n-                ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", ConsoleTest.class.getName(),\n-                                                          testName);\n+                ProcessTools.createTestJavaProcessBuilder(\n+                    \"--add-exports\",\n+                    \"java.base\/jdk.internal.io=ALL-UNNAMED\",\n+                    \"--add-exports\",\n+                    \"jdk.internal.le\/jdk.internal.org.jline=ALL-UNNAMED\",\n+                    ConsoleTest.class.getName(),\n+                    testName);\n@@ -101,0 +109,2 @@\n+            \/\/ directly instantiate JLine JdkConsole, simulating isTTY=true\n+            var impl = new JdkConsoleProviderImpl().console(true, StandardCharsets.UTF_8, StandardCharsets.UTF_8);\n@@ -103,1 +113,1 @@\n-                    System.console().readLine(\"%%s\");\n+                    impl.readLine(null, \"%%s\");\n@@ -105,1 +115,1 @@\n-                    System.console().readPassword(\"%%s\");\n+                    impl.readPassword(null, \"%%s\");\n@@ -107,1 +117,1 @@\n-                    System.out.println(\"'\" + System.console().readLine() + \"'\");\n+                    System.out.println(\"'\" + impl.readLine() + \"'\");\n@@ -109,2 +119,2 @@\n-                    System.out.println(\"1: '\" +System.console().readLine() + \"'\");\n-                    System.out.println(\"2: '\" + System.console().readLine() + \"'\");\n+                    System.out.println(\"1: '\" + impl.readLine() + \"'\");\n+                    System.out.println(\"2: '\" + impl.readLine() + \"'\");\n","filename":"test\/jdk\/jdk\/internal\/jline\/JLineConsoleProviderTest.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8333086 8344706\n+ * @bug 8333086 8344706 8361613\n@@ -28,2 +28,3 @@\n- * @enablePreview\n- * @modules jdk.internal.le\/jdk.internal.org.jline.reader\n+ * @modules java.base\/jdk.internal.io\n+ *          jdk.internal.le\/jdk.internal.org.jline\n+ *          jdk.internal.le\/jdk.internal.org.jline.reader\n@@ -35,0 +36,3 @@\n+import java.nio.charset.StandardCharsets;\n+\n+import jdk.internal.org.jline.JdkConsoleProviderImpl;\n@@ -44,0 +48,1 @@\n+        \/\/ directly instantiate JLine JdkConsole, simulating isTTY=true\n@@ -46,10 +51,5 @@\n-                System.console().printf(\"Hello!\\n\");\n-                System.console().printf(\"Hello!\");\n-                System.console().format(\"\\nHello!\\n\");\n-                System.console().flush();\n-                IO.println(\"Hello!\");\n-                IO.print(\"Hello!\");\n-            }\n-            case \"read\" -> System.console().readLine(\"Hello!\");\n-            case \"IO-read\" -> {\n-                IO.readln(\"Hello!\");\n+                var impl = new JdkConsoleProviderImpl().console(true, StandardCharsets.UTF_8, StandardCharsets.UTF_8);\n+                impl.println(\"Hello!\\n\");\n+                impl.println(\"Hello!\");\n+                impl.format(null, \"\\nHello!\\n\");\n+                impl.flush();\n@@ -57,0 +57,3 @@\n+            case \"read\" -> new JdkConsoleProviderImpl()\n+                .console(true, StandardCharsets.UTF_8, StandardCharsets.UTF_8)\n+                .readLine(null, \"Hello!\");\n@@ -67,2 +70,1 @@\n-            new TestCase(\"read\", LineReader.class.getName(), null),\n-            new TestCase(\"IO-read\", null, Terminal.class.getName())\n+            new TestCase(\"read\", LineReader.class.getName(), null)\n@@ -72,3 +74,5 @@\n-                    ProcessTools.createTestJavaProcessBuilder(\"--enable-preview\",\n-                                                              \"-verbose:class\",\n-                                                              \"-Djdk.console=jdk.internal.le\",\n+                    ProcessTools.createTestJavaProcessBuilder(\"-verbose:class\",\n+                                                              \"--add-exports\",\n+                                                              \"java.base\/jdk.internal.io=ALL-UNNAMED\",\n+                                                              \"--add-exports\",\n+                                                              \"jdk.internal.le\/jdk.internal.org.jline=ALL-UNNAMED\",\n","filename":"test\/jdk\/jdk\/internal\/jline\/LazyJdkConsoleProvider.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1,181 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8330998 8351435\n- * @summary Verify that even if the stdout is redirected java.io.Console will\n- *          use it for writing.\n- * @modules jdk.internal.le\n- * @library \/test\/lib\n- * @run main RedirectedStdOut runRedirectAllTest\n- * @run main\/othervm --enable-native-access=ALL-UNNAMED RedirectedStdOut runRedirectOutOnly\n- *\/\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class RedirectedStdOut {\n-    private static final String OUTPUT = \"Hello!\";\n-\n-    public static void main(String... args) throws Throwable {\n-        RedirectedStdOut.class.getDeclaredMethod(args[0])\n-                              .invoke(new RedirectedStdOut());\n-    }\n-\n-    \/\/verify the case where neither stdin\/out\/err is attached to a terminal,\n-    \/\/this test is weaker, but more reliable:\n-    void runRedirectAllTest() throws Exception {\n-        ProcessBuilder builder =\n-                ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", ConsoleTest.class.getName());\n-        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n-\n-        output.waitFor();\n-\n-        if (output.getExitValue() != 0) {\n-            throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n-                                     \", actualOut: \" + output.getStdout() +\n-                                     \", actualErr: \" + output.getStderr());\n-        }\n-\n-        String expectedOut = OUTPUT;\n-        String actualOut = output.getStdout();\n-\n-        if (!Objects.equals(expectedOut, actualOut)) {\n-            throw new AssertionError(\"Unexpected stdout content. \" +\n-                                     \"Expected: '\" + expectedOut + \"'\" +\n-                                     \", got: '\" + actualOut + \"'\");\n-        }\n-\n-        String expectedErr = \"\";\n-        String actualErr = output.getStderr();\n-\n-        if (!Objects.equals(expectedErr, actualErr)) {\n-            throw new AssertionError(\"Unexpected stderr content. \" +\n-                                     \"Expected: '\" + expectedErr + \"'\" +\n-                                     \", got: '\" + actualErr + \"'\");\n-        }\n-    }\n-\n-    \/\/verify the case where stdin is attached to a terminal,\n-    \/\/this test allocates pty, and it might be skipped, if the appropriate\n-    \/\/native functions cannot be found\n-    \/\/it also leaves the VM in a broken state (with a pty attached), and so\n-    \/\/should run in a separate VM instance\n-    void runRedirectOutOnly() throws Throwable {\n-        Path stdout = Path.of(\".\", \"stdout.txt\").toAbsolutePath();\n-\n-        Files.deleteIfExists(stdout);\n-\n-        Linker linker = Linker.nativeLinker();\n-        SymbolLookup stdlib = linker.defaultLookup();\n-        MemorySegment parent = Arena.global().allocate(ValueLayout.ADDRESS);\n-        MemorySegment child = Arena.global().allocate(ValueLayout.ADDRESS);\n-        Optional<MemorySegment> openptyAddress = stdlib.find(\"openpty\");\n-\n-        if (openptyAddress.isEmpty()) {\n-            System.out.println(\"Cannot lookup openpty.\");\n-            \/\/does not have forkpty, ignore\n-            return ;\n-        }\n-\n-        Optional<MemorySegment> loginttyAddress = stdlib.find(\"login_tty\");\n-\n-        if (loginttyAddress.isEmpty()) {\n-            System.out.println(\"Cannot lookup login_tty.\");\n-            \/\/does not have forkpty, ignore\n-            return ;\n-        }\n-\n-        FunctionDescriptor openttyDescriptor =\n-                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS);\n-        MethodHandle forkpty = linker.downcallHandle(openptyAddress.get(),\n-                                                     openttyDescriptor);\n-        int res = (int) forkpty.invoke(parent,\n-                                       child,\n-                                       MemorySegment.NULL,\n-                                       MemorySegment.NULL,\n-                                       MemorySegment.NULL);\n-\n-        if (res != 0) {\n-            throw new AssertionError();\n-        }\n-\n-        \/\/set the current VM's in\/out to the terminal:\n-        FunctionDescriptor loginttyDescriptor =\n-                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n-                                      ValueLayout.JAVA_INT);\n-        MethodHandle logintty = linker.downcallHandle(loginttyAddress.get(),\n-                                                      loginttyDescriptor);\n-        logintty.invoke(child.get(ValueLayout.JAVA_INT, 0));\n-\n-        \/\/createTestJavaProcessBuilder logs to (current process') System.out, but\n-        \/\/that may not work since the redirect. Setting System.out to a scratch value:\n-        System.setOut(new PrintStream(new ByteArrayOutputStream()));\n-\n-        ProcessBuilder builder =\n-            ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", ConsoleTest.class.getName());\n-\n-        builder.inheritIO();\n-        builder.redirectOutput(stdout.toFile());\n-\n-        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n-\n-        output.waitFor();\n-\n-        String expectedOut = OUTPUT;\n-        String actualOut = Files.readString(stdout);\n-\n-        if (!Objects.equals(expectedOut, actualOut)) {\n-            throw new AssertionError(\"Unexpected stdout content. \" +\n-                                     \"Expected: '\" + expectedOut + \"'\" +\n-                                     \", got: '\" + actualOut + \"'\");\n-        }\n-    }\n-\n-    public static class ConsoleTest {\n-        public static void main(String... args) {\n-            System.console().printf(OUTPUT);\n-            System.exit(0);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/jline\/RedirectedStdOut.java","additions":0,"deletions":181,"binary":false,"changes":181,"status":"deleted"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Whitebox tests for ExplodedImage to ensure compatibility with ImageReader.\n+ * @modules java.base\/jdk.internal.jrtfs java.base\/jdk.internal.jimage\n+ * @run junit\/othervm java.base\/jdk.internal.jrtfs.ExplodedImageTest\n+ *\/\n+public class ExplodedImageTestDriver {}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/ExplodedImageTestDriver.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+modules = \\\n+    java.base\/jdk.internal.jimage \\\n+    java.base\/jdk.internal.jrtfs\n+bootclasspath.dirs=.\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/TEST.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jrtfs;\n+\n+import jdk.internal.jimage.ImageReader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * Tests an {@link ExplodedImage} view of a class-file hierarchy.\n+ *\n+ * <p>For simplicity and performance, only a subset of the JRT files are copied\n+ * to disk for testing.\n+ *\/\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class ExplodedImageTest {\n+\n+    private Path modulesRoot;\n+    private SystemImage explodedImage;\n+    private String pathSeparator;\n+\n+    @BeforeAll\n+    public void createTestDirectory(@TempDir Path modulesRoot) throws IOException {\n+        this.modulesRoot = modulesRoot;\n+        this.pathSeparator = modulesRoot.getFileSystem().getSeparator();\n+        \/\/ Copy only a useful subset of files for testing. Use at least two\n+        \/\/ modules with \"overlapping\" packages to test \/package links better.\n+        unpackModulesDirectoriesFromJrtFileSystem(modulesRoot,\n+                \"java.base\/java\/util\",\n+                \"java.base\/java\/util\/zip\",\n+                \"java.logging\/java\/util\/logging\");\n+        this.explodedImage = new ExplodedImage(modulesRoot);\n+    }\n+\n+    \/** Unpacks a list of \"\/modules\/...\" directories non-recursively into the specified root directory. *\/\n+    private static void unpackModulesDirectoriesFromJrtFileSystem(Path modulesRoot, String... dirNames)\n+            throws IOException {\n+        FileSystem jrtfs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+        List<Path> srcDirs = Arrays.stream(dirNames).map(s -> \"\/modules\/\" + s).map(jrtfs::getPath).toList();\n+        for (Path srcDir : srcDirs) {\n+            \/\/ Skip-1 to remove \"modules\" segment (not part of the file system path).\n+            Path dstDir = StreamSupport.stream(srcDir.spliterator(), false)\n+                    .skip(1)\n+                    .reduce(modulesRoot, (path, segment) -> path.resolve(segment.toString()));\n+            Files.createDirectories(dstDir);\n+            try (DirectoryStream<Path> files = Files.newDirectoryStream(srcDir)) {\n+                for (Path srcFile : files) {\n+                    Files.copy(srcFile, dstDir.resolve(srcFile.getFileName().toString()));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void topLevelNodes() throws IOException {\n+        ImageReader.Node root = explodedImage.findNode(\"\/\");\n+        ImageReader.Node modules = explodedImage.findNode(\"\/modules\");\n+        ImageReader.Node packages = explodedImage.findNode(\"\/packages\");\n+        assertEquals(\n+                Set.of(modules.getName(), packages.getName()),\n+                root.getChildNames().collect(Collectors.toSet()));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/modules\/java.base\/java\/util\/List.class\",\n+            \"\/modules\/java.base\/java\/util\/zip\/ZipEntry.class\",\n+            \"\/modules\/java.logging\/java\/util\/logging\/Logger.class\"})\n+    public void basicLookupResource(String expectedResourceName) throws IOException {\n+        ImageReader.Node node = assertResourceNode(expectedResourceName);\n+\n+        Path fsRelPath = getRelativePath(expectedResourceName);\n+        assertArrayEquals(\n+                Files.readAllBytes(modulesRoot.resolve(fsRelPath)),\n+                explodedImage.getResource(node));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/modules\/java.base\",\n+            \"\/modules\/java.logging\",\n+            \"\/modules\/java.base\/java\",\n+            \"\/modules\/java.base\/java\/util\",\n+            \"\/modules\/java.logging\/java\/util\",\n+    })\n+    public void basicLookupDirectory(String expectedDirectoryName) throws IOException {\n+        ImageReader.Node node = assertDirectoryNode(expectedDirectoryName);\n+\n+        Path fsRelPath = getRelativePath(expectedDirectoryName);\n+        List<String> fsChildBaseNames;\n+        try (DirectoryStream<Path> paths = Files.newDirectoryStream(modulesRoot.resolve(fsRelPath))) {\n+            fsChildBaseNames = StreamSupport.stream(paths.spliterator(), false)\n+                    .map(Path::getFileName)\n+                    .map(Path::toString)\n+                    .toList();\n+        }\n+        List<String> nodeChildBaseNames = node.getChildNames()\n+                .map(s -> s.substring(node.getName().length() + 1))\n+                .toList();\n+        assertEquals(fsChildBaseNames, nodeChildBaseNames, \"expected same child names\");\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/packages\/java\/java.base\",\n+            \"\/packages\/java\/java.logging\",\n+            \"\/packages\/java.util\/java.base\",\n+            \"\/packages\/java.util\/java.logging\",\n+            \"\/packages\/java.util.zip\/java.base\"})\n+    public void basicLookupPackageLinks(String expectedLinkName) throws IOException {\n+        ImageReader.Node node = assertLinkNode(expectedLinkName);\n+        ImageReader.Node resolved = node.resolveLink();\n+        assertSame(explodedImage.findNode(resolved.getName()), resolved);\n+        String moduleName = expectedLinkName.substring(expectedLinkName.lastIndexOf('\/') + 1);\n+        assertEquals(\"\/modules\/\" + moduleName, resolved.getName());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/packages\/java\",\n+            \"\/packages\/java.util\",\n+            \"\/packages\/java.util.zip\"})\n+    public void packageDirectories(String expectedDirectoryName) throws IOException {\n+        ImageReader.Node node = assertDirectoryNode(expectedDirectoryName);\n+        assertTrue(node.getChildNames().findFirst().isPresent(),\n+                \"Package directories should not be empty: \" + node);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\",\n+            \".\",\n+            \"\/.\",\n+            \"modules\",\n+            \"packages\",\n+            \"\/modules\/\",\n+            \"\/modules\/xxxx\",\n+            \"\/modules\/java.base\/java\/lang\/Xxxx.class\",\n+            \"\/packages\/\",\n+            \"\/packages\/xxxx\",\n+            \"\/packages\/java.xxxx\",\n+            \"\/packages\/java.util.\",\n+            \/\/ Mismatched module.\n+            \"\/packages\/java.util.logging\/java.base\",\n+            \"\/packages\/java.util.zip\/java.logging\",\n+            \/\/ Links are not resolved as they are fetched (old\/broken behaviour).\n+            \"\/packages\/java.util\/java.base\/java\/util\/Vector.class\",\n+    })\n+    public void invalidNames(String invalidName) throws IOException {\n+        assertNull(explodedImage.findNode(invalidName), \"No node expected for: \" + invalidName);\n+    }\n+\n+    private ImageReader.Node assertResourceNode(String name) throws IOException {\n+        ImageReader.Node node = explodedImage.findNode(name);\n+        assertNotNull(node);\n+        assertEquals(name, node.getName(), \"expected node name: \" + name);\n+        assertTrue(node.isResource(), \"expected a resource: \" + node);\n+        assertFalse(node.isDirectory(), \"resources are not directories: \" + node);\n+        assertFalse(node.isLink(), \"resources are not links: \" + node);\n+        return node;\n+    }\n+\n+    private ImageReader.Node assertDirectoryNode(String name) throws IOException {\n+        ImageReader.Node node = explodedImage.findNode(name);\n+        assertNotNull(node);\n+        assertEquals(name, node.getName(), \"expected node name: \" + name);\n+        assertTrue(node.isDirectory(), \"expected a directory: \" + node);\n+        assertFalse(node.isResource(), \"directories are not resources: \" + node);\n+        assertFalse(node.isLink(), \"directories are not links: \" + node);\n+        return node;\n+    }\n+\n+    private ImageReader.Node assertLinkNode(String name) throws IOException {\n+        ImageReader.Node node = explodedImage.findNode(name);\n+        assertNotNull(node);\n+        assertEquals(name, node.getName(), \"expected node name: \" + name);\n+        assertTrue(node.isLink(), \"expected a link: \" + node);\n+        assertFalse(node.isResource(), \"links are not resources: \" + node);\n+        assertFalse(node.isDirectory(), \"links are not directories: \" + node);\n+        return node;\n+    }\n+\n+    private Path getRelativePath(String name) {\n+        return Path.of(name.substring(\"\/modules\/\".length()).replace(\"\/\", pathSeparator));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/java.base\/jdk\/internal\/jrtfs\/ExplodedImageTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main TestDockerMemoryMetricsSubgroup\n+ * @run main\/timeout=480 TestDockerMemoryMetricsSubgroup\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetricsSubgroup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run driver TestGetFreeSwapSpaceSize\n+ * @run driver\/timeout=480 TestGetFreeSwapSpaceSize\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestGetFreeSwapSpaceSize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run driver TestLimitsUpdating\n+ * @run driver\/timeout=480 TestLimitsUpdating\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestLimitsUpdating.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver TestPidsLimit\n+ * @run driver\/timeout=480 TestPidsLimit\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestPidsLimit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,2 @@\n- * @run main jdk.internal.reflect.constantPool.ConstantPoolTest\n+ * @compile ConstantPoolTest.java\n+ * @run junit ConstantPoolTest\n@@ -35,2 +36,1 @@\n-package jdk.internal.reflect.constantPool;\n-\n+import java.lang.classfile.ClassFile;\n@@ -42,0 +42,5 @@\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -49,3 +54,11 @@\n-    public static void main(String[] s) {\n-        for (TestCase testCase : TestCase.values()) {\n-            testCase.test();\n+    @ParameterizedTest\n+    @EnumSource(TestCase.class)\n+    void runTestCases(TestCase testCase) {\n+        testCase.test();\n+    }\n+\n+    @Test\n+    void testSize() throws Throwable {\n+        byte[] data;\n+        try (var in = ConstantPoolTest.class.getResourceAsStream(\"\/ConstantPoolTestDummy.class\")) {\n+            data = in.readAllBytes();\n@@ -53,0 +66,2 @@\n+        var testClass = ClassFile.of().parse(data);\n+        assertEquals(testClass.constantPool().size(), CP.getSize());\n@@ -55,1 +70,1 @@\n-    public static enum TestCase {\n+    public enum TestCase {\n","filename":"test\/jdk\/jdk\/internal\/reflect\/constantPool\/ConstantPoolTest.java","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-package  jdk\/internal\/reflect\/constantPool;\n-\n@@ -44,1 +42,1 @@\n-const #11 = Asciz   \"jdk\/internal\/reflect\/constantPool\/ConstantPoolTestDummy\";\n+const #11 = Asciz   \"ConstantPoolTestDummy\";\n@@ -79,1 +77,1 @@\n-const #48 = Field    #2.#49;    \/\/  jdk\/internal\/reflect\/constantPool\/ConstantPoolTestDummy.myField:\"I\"\n+const #48 = Field    #2.#49;    \/\/  ConstantPoolTestDummy.myField:\"I\"\n","filename":"test\/jdk\/jdk\/internal\/reflect\/constantPool\/ConstantPoolTestDummy.jasm","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n- * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -176,1 +176,1 @@\n- * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -196,1 +196,1 @@\n- * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/BasicExt.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n- * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                               Fuzz\n+ * @run main\/othervm\/timeout=1200 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                                Fuzz\n@@ -54,3 +54,3 @@\n- * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                               -XX:+PreserveFramePointer\n- *                               Fuzz\n+ * @run main\/othervm\/timeout=1200 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                                -XX:+PreserveFramePointer\n+ *                                Fuzz\n@@ -87,2 +87,1 @@\n-    static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    static int COMPILATION_TIMEOUT = (int)(5_000 * timeoutFactor); \/\/ ms\n+    static int COMPILATION_TIMEOUT = (int)(5_000 * Utils.TIMEOUT_FACTOR); \/\/ ms\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm -Xlog:jfr+streaming+system=trace jdk.jfr.api.consumer.recordingstream.TestClose\n+ * @run main\/othervm\/timeout=480 -Xlog:jfr+streaming+system=trace jdk.jfr.api.consumer.recordingstream.TestClose\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestClose.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.jfr.StackTrace;\n@@ -41,0 +42,1 @@\n+    @StackTrace(false)\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestFilledChunks.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    @Period(\"10 s\")\n+    @Period(\"2 s\")\n@@ -68,1 +68,1 @@\n-        CountDownLatch zebraLatch = new CountDownLatch(3);\n+        CountDownLatch zebraLatch = new CountDownLatch(2);\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/streaming\/TestStartMultiChunk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm -Xlog:jfr=warning jdk.jfr.api.metadata.annotations.TestStackFilter\n+ * @run main\/othervm\/timeout=480 -Xlog:jfr=warning jdk.jfr.api.metadata.annotations.TestStackFilter\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/TestStackFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+ * @comment Asan changes memory layout and we get a different coops mode\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/configuration\/TestGCHeapConfigurationEventWith32BitOops.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+ * @comment Asan changes memory layout and we get a different coops mode\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/configuration\/TestGCHeapConfigurationEventWithZeroBasedOops.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-* @run main\/othervm jdk.jfr.event.oldobject.TestEmergencyDumpAtOOM\n+* @run main\/othervm\/timeout=480 jdk.jfr.event.oldobject.TestEmergencyDumpAtOOM\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestEmergencyDumpAtOOM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @run main\/othervm -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectDescription\n+ * @run main\/othervm\/timeout=960 -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectDescription\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestObjectDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main jdk.jfr.event.profiling.TestCPUTimeSampleMultipleRecordings\n+ * @run main\/timeout=480 jdk.jfr.event.profiling.TestCPUTimeSampleMultipleRecordings\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleMultipleRecordings.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    static final int RUN_TIME_MS = 10000;\n+    static final int RUN_TIME_MS = 5000;\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/StressJavaMonitorEvents.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,2 +146,0 @@\n-        Asserts.assertGT((long) re.getValue(\"elements\"), 0L, \"No elements\");\n-        Asserts.assertGT((long) re.getValue(\"size\"), 0L, \"Empty size\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFlush.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.jfr.StackTrace;\n@@ -48,0 +49,1 @@\n+    @StackTrace(false)\n@@ -95,1 +97,1 @@\n-        Thread.sleep(1000);\n+        Thread.sleep(100);\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestMaxSize.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    private static List<RecordedEvent> recordWithPolicy(String filename, Consumer<RemoteRecordingStream> policy) throws Exception {\n+    private static List<RecordedEvent> recordWithPolicy(String filename, boolean awaitEvents, Consumer<RemoteRecordingStream> policy) throws Exception {\n@@ -114,1 +114,3 @@\n-            latch1.await();\n+            if (awaitEvents) {\n+                latch1.await();\n+            }\n@@ -121,1 +123,3 @@\n-            latch2.await();\n+            if (awaitEvents) {\n+                latch2.await();\n+            }\n@@ -132,1 +136,1 @@\n-        var events = recordWithPolicy(\"max-size.jfr\", rs -> {\n+        var events = recordWithPolicy(\"max-size.jfr\", false, rs -> {\n@@ -143,1 +147,1 @@\n-        var events = recordWithPolicy(\"max-age.jfr\", rs -> {\n+        var events = recordWithPolicy(\"max-age.jfr\", false, rs -> {\n@@ -154,1 +158,1 @@\n-        var events = recordWithPolicy(\"no-policy.jfr\", rs -> {\n+        var events = recordWithPolicy(\"no-policy.jfr\", true, rs -> {\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestRemoteDump.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run main\/othervm jdk.jfr.jvm.TestModularImage\n+ * @run main\/othervm\/timeout=480 jdk.jfr.jvm.TestModularImage\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestModularImage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-             .with(\"cutoff\", \"infinity\")\n+             .with(\"cutoff\", \"2 s\")\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestWaste.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,7 +77,0 @@\n-    private static void testDefault() throws Exception {\n-        System.out.println(\"testDefault\");\n-        launchUnary(null);\n-        launchBinary(null, null);\n-        launchTernary(null, null, null);\n-    }\n-\n@@ -102,1 +95,0 @@\n-        testDefault();\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestMultipleStartupRecordings.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -413,0 +413,1 @@\n+        launcher.addToolArg(\"--exact\");\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestPrintContextual.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-\/**\n+\/*\n@@ -759,1 +759,1 @@\n-        try (JarFile jf = new JarFile(ZIP_FILE.toFile())) {\n+        try (JarFile jf = new JarFile(JAR_FILE.toFile())) {\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/TestPosix.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Point;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.awt.image.ColorModel;\n+import java.awt.image.SampleModel;\n+import java.awt.image.WritableRaster;\n+import java.io.File;\n+\n+import javax.imageio.ImageIO;\n+\n+import static java.awt.image.BufferedImage.TYPE_3BYTE_BGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_BGR;\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_GRAY;\n+\n+\/**\n+ * @test\n+ * @bug 8366208\n+ * @summary Verifies ColorConvertOp works correctly with BufferedImage and\n+ *          semi-custom raster\n+ *\/\n+public final class FilterSemiCustomImages {\n+\n+    private static final int W = 144;\n+    private static final int H = 123;\n+\n+    private static final int[] TYPES = {\n+            TYPE_INT_RGB, TYPE_INT_ARGB, TYPE_INT_ARGB_PRE, TYPE_INT_BGR,\n+            TYPE_3BYTE_BGR, TYPE_4BYTE_ABGR, TYPE_4BYTE_ABGR_PRE,\n+            TYPE_USHORT_GRAY\n+    };\n+\n+    private static final int[] CSS = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY, ColorSpace.CS_LINEAR_RGB,\n+            ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    private static final class CustomRaster extends WritableRaster {\n+        CustomRaster(SampleModel sampleModel, Point origin) {\n+            super(sampleModel, origin);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int fromIndex : CSS) {\n+            for (int toIndex : CSS) {\n+                if (fromIndex != toIndex) {\n+                    for (int type : TYPES) {\n+                        test(fromIndex, toIndex, type);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void test(int fromIndex, int toIndex, int type)\n+            throws Exception\n+    {\n+        ColorSpace fromCS = ColorSpace.getInstance(fromIndex);\n+        ColorSpace toCS = ColorSpace.getInstance(toIndex);\n+        ColorConvertOp op = new ColorConvertOp(fromCS, toCS, null);\n+\n+        \/\/ standard source -> standard dst\n+        BufferedImage srcGold = new BufferedImage(W, H, type);\n+        fill(srcGold);\n+        BufferedImage dstGold = new BufferedImage(W, H, type);\n+        op.filter(srcGold, dstGold);\n+\n+        \/\/ custom source -> standard dst\n+        BufferedImage srcCustom = makeCustomBI(srcGold);\n+        fill(srcCustom);\n+        BufferedImage dst = new BufferedImage(W, H, type);\n+        op.filter(srcCustom, dst);\n+        verify(dstGold, dst);\n+\n+        \/\/ standard source -> custom dst\n+        BufferedImage src = new BufferedImage(W, H, type);\n+        fill(src);\n+        BufferedImage dstCustom = makeCustomBI(dstGold);\n+        op.filter(src, dstCustom);\n+        verify(dstGold, dstCustom);\n+\n+        \/\/ custom source -> custom dst\n+        srcCustom = makeCustomBI(srcGold);\n+        fill(srcCustom);\n+        dstCustom = makeCustomBI(dstGold);\n+        op.filter(srcCustom, dstCustom);\n+        verify(dstGold, dstCustom);\n+    }\n+\n+    private static BufferedImage makeCustomBI(BufferedImage bi) {\n+        ColorModel cm = bi.getColorModel();\n+        SampleModel sm = bi.getSampleModel();\n+        CustomRaster cr = new CustomRaster(sm, new Point());\n+        return new BufferedImage(cm, cr, bi.isAlphaPremultiplied(), null) {\n+            @Override\n+            public int getType() {\n+                return bi.getType();\n+            }\n+        };\n+    }\n+\n+    private static void fill(BufferedImage image) {\n+        int width = image.getWidth();\n+        int height = image.getHeight();\n+        for (int x = 0; x < width; ++x) {\n+            for (int y = 0; y < height; ++y) {\n+                \/\/ alpha channel may be calculated slightly differently on\n+                \/\/ different code paths, so only check fully transparent and\n+                \/\/ fully opaque pixels\n+                Color c = new Color(y * 255 \/ (height - 1),\n+                                    x * 255 \/ (width - 1),\n+                                    x % 255,\n+                                    (x % 2 == 0) ? 0 : 255);\n+                image.setRGB(x, y, c.getRGB());\n+            }\n+        }\n+    }\n+\n+    private static void verify(BufferedImage dstGold, BufferedImage dst)\n+            throws Exception\n+    {\n+        for (int x = 0; x < W; ++x) {\n+            for (int y = 0; y < H; ++y) {\n+                if (dst.getRGB(x, y) != dstGold.getRGB(x, y)) {\n+                    ImageIO.write(dst, \"png\", new File(\"custom.png\"));\n+                    ImageIO.write(dstGold, \"png\", new File(\"gold.png\"));\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/FilterSemiCustomImages.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.test.lib.Utils;\n@@ -72,1 +73,1 @@\n- * @run main\/othervm MonitorVmStartTerminate\n+ * @run main\/othervm\/timeout=240 MonitorVmStartTerminate\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/MonitoredVm\/MonitorVmStartTerminate.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,5 +37,8 @@\n-import java.net.*;\n-import java.util.*;\n-import java.io.*;\n-import javax.net.ssl.*;\n-import java.security.Security;\n+\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.URL;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n@@ -43,1 +46,4 @@\n-import java.security.KeyFactory;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.cert.X509Certificate;\n+\n@@ -45,3 +51,0 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n@@ -50,355 +53,16 @@\n-\n-\/*\n- * Certificates and key used in the test.\n- *\n- * TLS server certificate:\n- * server private key:\n- * -----BEGIN RSA PRIVATE KEY-----\n- * Proc-Type: 4,ENCRYPTED\n- * DEK-Info: DES-EDE3-CBC,D9AE407F6D0E389A\n- *\n- * WPrA7TFol\/cQCcp9oHnXWNpYlvRbbIcQj0m+RKT2Iuzfus+DHt3Zadf8nJpKfX2e\n- * h2rnhlzCN9M7djRDooZKDOPCsdBn51Au7HlZF3S3Opgo7D8XFM1a8t1Je4ke14oI\n- * nw6QKYsBblRziPnP2PZ0zvX24nOv7bbY8beynlJHGs00VWSFdoH2DS0aE1p6D+3n\n- * ptJuJ75dVfZFK4X7162APlNXevX8D6PEQpSiRw1rjjGGcnvQ4HdWk3BxDVDcCNJb\n- * Y1aGNRxsjTDvPi3R9Qx2M+W03QzEPx4SR3ZHVskeSJHaetM0TM\/w\/45Paq4GokXP\n- * ZeTnbEx1xmjkA7h+t4doLL4watx5F6yLsJzu8xB3lt\/1EtmkYtLz1t7X4BetPAXz\n- * zS69X\/VwhKfsOI3qXBWuL2oHPyhDmT1gcaUQwEPSV6ogHEEQEDXdiUS8heNK13KF\n- * TCQYFkETvV2BLxUhV1hypPzRQ6tUpJiAbD5KmoK2lD9slshG2QtvKQq0\/bgkDY5J\n- * LhDHV2dtcZ3kDPkkZXpbcJQvoeH3d09C5sIsuTFo2zgNR6oETHUc5TzP6FY2YYRa\n- * QcK5HcmtsRRiXFm01ac+aMejJUIujjFt84SiKWT\/73vC8AmY4tYcJBLjCg4XIxSH\n- * fdDFLL1YZENNO5ivlp8mdiHqcawx+36L7DrEZQ8RZt6cqST5t\/+XTdM74s6k81GT\n- * pNsa82P2K2zmIUZ\/DL2mKjW1vfRByw1NQFEBkN3vdyZxYfM\/JyUzX4hbjXBEkh9Q\n- * QYrcwLKLjis2QzSvK04B3bvRzRb+4ocWiso8ZPAXAIxZFBWDpTMM2A==\n- * -----END RSA PRIVATE KEY-----\n- *\n- * -----BEGIN RSA PRIVATE KEY-----\n- * MIICXAIBAAKBgQClrFscN6LdmYktsnm4j9VIpecchBeNaZzGrG358h0fORna03Ie\n- * buxEzHCk3LoAMPagTz1UemFqzFfQCn+VKBg\/mtmU8hvIJIh+\/p0PPftXUwizIDPU\n- * PxdHFNHN6gjYDnVOr77M0uyvqXpJ38LZrLgkQJCmA1Yq0DAFQCxPq9l0iQIDAQAB\n- * AoGAbqcbg1E1mkR99uOJoNeQYKFOJyGiiXTMnXV1TseC4+PDfQBU7Dax35GcesBi\n- * CtapIpFKKS5D+ozY6b7ZT8ojxuQ\/uHLPAvz0WDR3ds4iRF8tyu71Q1ZHcQsJa17y\n- * yO7UbkSSKn\/Mp9Rb+\/dKqftUGNXVFLqgHBOzN2s3We3bbbECQQDYBPKOg3hkaGHo\n- * OhpHKqtQ6EVkldihG\/3i4WejRonelXN+HRh1KrB2HBx0M8D\/qAzP1i3rNSlSHer4\n- * 59YRTJnHAkEAxFX\/sVYSn07BHv9Zhn6XXct\/Cj43z\/tKNbzlNbcxqQwQerw3IH51\n- * 8UH2YOA+GD3lXbKp+MytoFLWv8zg4YT\/LwJAfqan75Z1R6lLffRS49bIiq8jwE16\n- * rTrUJ+kv8jKxMqc9B3vXkxpsS1M\/+4E8bqgAmvpgAb8xcsvHsBd9ErdukQJBAKs2\n- * j67W75BrPjBI34pQ1LEfp56IGWXOrq1kF8IbCjxv3+MYRT6Z6UJFkpRymNPNDjsC\n- * dgUYgITiGJHUGXuw3lMCQHEHqo9ZtXz92yFT+VhsNc29B8m\/sqUJdtCcMd\/jGpAF\n- * u6GHufjqIZBpQsk63wbwESAPZZ+kk1O1kS5GIRLX608=\n- * -----END RSA PRIVATE KEY-----\n- *\n- * Private-Key: (1024 bit)\n- * modulus:\n- *     00:a5:ac:5b:1c:37:a2:dd:99:89:2d:b2:79:b8:8f:\n- *     d5:48:a5:e7:1c:84:17:8d:69:9c:c6:ac:6d:f9:f2:\n- *     1d:1f:39:19:da:d3:72:1e:6e:ec:44:cc:70:a4:dc:\n- *     ba:00:30:f6:a0:4f:3d:54:7a:61:6a:cc:57:d0:0a:\n- *     7f:95:28:18:3f:9a:d9:94:f2:1b:c8:24:88:7e:fe:\n- *     9d:0f:3d:fb:57:53:08:b3:20:33:d4:3f:17:47:14:\n- *     d1:cd:ea:08:d8:0e:75:4e:af:be:cc:d2:ec:af:a9:\n- *     7a:49:df:c2:d9:ac:b8:24:40:90:a6:03:56:2a:d0:\n- *     30:05:40:2c:4f:ab:d9:74:89\n- * publicExponent: 65537 (0x10001)\n- * privateExponent:\n- *     6e:a7:1b:83:51:35:9a:44:7d:f6:e3:89:a0:d7:90:\n- *     60:a1:4e:27:21:a2:89:74:cc:9d:75:75:4e:c7:82:\n- *     e3:e3:c3:7d:00:54:ec:36:b1:df:91:9c:7a:c0:62:\n- *     0a:d6:a9:22:91:4a:29:2e:43:fa:8c:d8:e9:be:d9:\n- *     4f:ca:23:c6:e4:3f:b8:72:cf:02:fc:f4:58:34:77:\n- *     76:ce:22:44:5f:2d:ca:ee:f5:43:56:47:71:0b:09:\n- *     6b:5e:f2:c8:ee:d4:6e:44:92:2a:7f:cc:a7:d4:5b:\n- *     fb:f7:4a:a9:fb:54:18:d5:d5:14:ba:a0:1c:13:b3:\n- *     37:6b:37:59:ed:db:6d:b1\n- * prime1:\n- *     00:d8:04:f2:8e:83:78:64:68:61:e8:3a:1a:47:2a:\n- *     ab:50:e8:45:64:95:d8:a1:1b:fd:e2:e1:67:a3:46:\n- *     89:de:95:73:7e:1d:18:75:2a:b0:76:1c:1c:74:33:\n- *     c0:ff:a8:0c:cf:d6:2d:eb:35:29:52:1d:ea:f8:e7:\n- *     d6:11:4c:99:c7\n- * prime2:\n- *     00:c4:55:ff:b1:56:12:9f:4e:c1:1e:ff:59:86:7e:\n- *     97:5d:cb:7f:0a:3e:37:cf:fb:4a:35:bc:e5:35:b7:\n- *     31:a9:0c:10:7a:bc:37:20:7e:75:f1:41:f6:60:e0:\n- *     3e:18:3d:e5:5d:b2:a9:f8:cc:ad:a0:52:d6:bf:cc:\n- *     e0:e1:84:ff:2f\n- * exponent1:\n- *     7e:a6:a7:ef:96:75:47:a9:4b:7d:f4:52:e3:d6:c8:\n- *     8a:af:23:c0:4d:7a:ad:3a:d4:27:e9:2f:f2:32:b1:\n- *     32:a7:3d:07:7b:d7:93:1a:6c:4b:53:3f:fb:81:3c:\n- *     6e:a8:00:9a:fa:60:01:bf:31:72:cb:c7:b0:17:7d:\n- *     12:b7:6e:91\n- * exponent2:\n- *     00:ab:36:8f:ae:d6:ef:90:6b:3e:30:48:df:8a:50:\n- *     d4:b1:1f:a7:9e:88:19:65:ce:ae:ad:64:17:c2:1b:\n- *     0a:3c:6f:df:e3:18:45:3e:99:e9:42:45:92:94:72:\n- *     98:d3:cd:0e:3b:02:76:05:18:80:84:e2:18:91:d4:\n- *     19:7b:b0:de:53\n- * coefficient:\n- *     71:07:aa:8f:59:b5:7c:fd:db:21:53:f9:58:6c:35:\n- *     cd:bd:07:c9:bf:b2:a5:09:76:d0:9c:31:df:e3:1a:\n- *     90:05:bb:a1:87:b9:f8:ea:21:90:69:42:c9:3a:df:\n- *     06:f0:11:20:0f:65:9f:a4:93:53:b5:91:2e:46:21:\n- *     12:d7:eb:4f\n- *\n- *\n- * server certificate:\n- * Data:\n- *     Version: 3 (0x2)\n- *     Serial Number: 7 (0x7)\n- *     Signature Algorithm: md5WithRSAEncryption\n- *     Issuer: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Validity\n- *         Not Before: Dec  8 03:27:57 2008 GMT\n- *         Not After : Aug 25 03:27:57 2028 GMT\n- *     Subject: C=US, ST=Some-State, L=Some-City, O=Some-Org, OU=SSL-Server, CN=localhost\n- *     Subject Public Key Info:\n- *         Public Key Algorithm: rsaEncryption\n- *         RSA Public Key: (1024 bit)\n- *             Modulus (1024 bit):\n- *                 00:a5:ac:5b:1c:37:a2:dd:99:89:2d:b2:79:b8:8f:\n- *                 d5:48:a5:e7:1c:84:17:8d:69:9c:c6:ac:6d:f9:f2:\n- *                 1d:1f:39:19:da:d3:72:1e:6e:ec:44:cc:70:a4:dc:\n- *                 ba:00:30:f6:a0:4f:3d:54:7a:61:6a:cc:57:d0:0a:\n- *                 7f:95:28:18:3f:9a:d9:94:f2:1b:c8:24:88:7e:fe:\n- *                 9d:0f:3d:fb:57:53:08:b3:20:33:d4:3f:17:47:14:\n- *                 d1:cd:ea:08:d8:0e:75:4e:af:be:cc:d2:ec:af:a9:\n- *                 7a:49:df:c2:d9:ac:b8:24:40:90:a6:03:56:2a:d0:\n- *                 30:05:40:2c:4f:ab:d9:74:89\n- *             Exponent: 65537 (0x10001)\n- *     X509v3 extensions:\n- *         X509v3 Basic Constraints:\n- *             CA:FALSE\n- *         X509v3 Key Usage:\n- *             Digital Signature, Non Repudiation, Key Encipherment\n- *         X509v3 Subject Key Identifier:\n- *             ED:6E:DB:F4:B5:56:C8:FB:1A:06:61:3F:0F:08:BB:A6:04:D8:16:54\n- *         X509v3 Authority Key Identifier:\n- *             keyid:FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *\n- *         X509v3 Subject Alternative Name: critical\n- *             IP Address:127.0.0.1\n- * Signature Algorithm: md5WithRSAEncryption\n- *\n- * -----BEGIN CERTIFICATE-----\n- * MIICnzCCAgigAwIBAgIBBzANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n- * MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n- * EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3NTdaFw0yODA4MjUwMzI3NTdaMHIxCzAJ\n- * BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n- * dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtU2VydmVyMRIwEAYD\n- * VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKWsWxw3\n- * ot2ZiS2yebiP1Uil5xyEF41pnMasbfnyHR85GdrTch5u7ETMcKTcugAw9qBPPVR6\n- * YWrMV9AKf5UoGD+a2ZTyG8gkiH7+nQ89+1dTCLMgM9Q\/F0cU0c3qCNgOdU6vvszS\n- * 7K+peknfwtmsuCRAkKYDVirQMAVALE+r2XSJAgMBAAGjbjBsMAkGA1UdEwQCMAAw\n- * CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTtbtv0tVbI+xoGYT8PCLumBNgWVDAfBgNV\n- * HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\n- * MA0GCSqGSIb3DQEBBAUAA4GBAFJjItCtCBZcjD69wdqfIbKmRFa6eJAjR6LcoDva\n- * cKC\/sDOLelpspiZ66Zb0Xdv5qQ7QrfOXt3K8QqJKRMdZLF9WfUfy0gJDM32ub91h\n- * pu+TmcGPs+6RdrAQcuvU1ZDV9X8SMj7BtKaim4d5sqFw1npncKiA5xFn8vOYwdun\n- * nZif\n- * -----END CERTIFICATE-----\n- *\n- *\n- * TLS client certificate:\n- * client private key:\n- * ----BEGIN RSA PRIVATE KEY-----\n- * Proc-Type: 4,ENCRYPTED\n- * DEK-Info: DES-EDE3-CBC,FA2A435CD35A9390\n- *\n- * Z+Y2uaETbsUWIyJUyVu1UV2G4rgFYJyACZT6Tp1KjRtxflSh2kXkJ9MpuXMXA0V4\n- * Yy3fDzPqCL9NJmQAYRlAx\/W\/+j4F5EyMWDIx8fUxzONRZyoiwF7jLm+KscAfv6Pf\n- * q7ItWOdj3z7IYrwlB8YIGd3F2cDKT3S+lYRk7rKb\/qT7itbuHnY4Ardh3yl+MZak\n- * jBp+ELUlRsUqSr1V0LoM+0rCCykarpyfhpxEcqsrl0v9Cyi5uhU50\/oKv5zql3SH\n- * l2ImgDjp3batAs8+Bd4NF2aqi0a7Hy44JUHxRm4caZryU\/i\/D9N1MbuM6882HLat\n- * 5N0G+NaIUfywa8mjwq2D5aiit18HqKA6XeRRYeJ5Dvu9DCO4GeFSwcUFIBMI0L46\n- * 7s114+oDodg57pMgITi+04vmUxvqlN9aiyd7f5Fgd7PeHGeOdbMz1NaJLJaPI9++\n- * NakK8eK9iwT\/Gdq0Uap5\/CHW7vCT5PO+h3HY0STH0lWStXhdWnFO04zTdywsbSp+\n- * DLpHeFT66shfeUlxR0PsCbG9vPRt\/QmGLeYQZITppWo\/ylSq4j+pRIuXvuWHdBRN\n- * rTZ8QF4Y7AxQUXVz1j1++s6ZMHTzaK2i9HrhmDs1MbJl+QwWre3Xpv3LvTVz3k5U\n- * wX8kuY1m3STt71QCaRWENq5sRaMImLxZbxc\/ivFl9RAzUqo4NCxLod\/QgA4iLqtO\n- * ztnlpzwlC\/F8HbQ1oqYWwnZAPhzU\/cULtstl+Yrws2c2atO323LbPXZqbASySgig\n- * sNpFXQMObdfP6LN23bY+1SvtK7V4NUTNhpdIc6INQAQ=\n- * -----END RSA PRIVATE KEY-----\n- *\n- * -----BEGIN RSA PRIVATE KEY-----\n- * MIICWwIBAAKBgQC78EA2rCZUTvSjWgAvaSFvuXo6k+yi9uGOx2PYLxIwmS6w8o\/4\n- * Jy0keCiE9wG\/jUR53TvSVfPOPLJbIX3v\/TNKsaP\/xsibuQ98QTWX+ds6BWAFFa9Z\n- * F5KjEK0WHOQHU6+odqJWKpLT+SjgeM9eH0irXBnd4WdDunWN9YKsQ5JEGwIDAQAB\n- * AoGAEbdqNj0wN85hnWyEi\/ObJU8UyKTdL9eaF72QGfcF\/fLSxfd3vurihIeXOkGW\n- * tpn4lIxYcVGM9CognhqgJpl11jFTQzn1KqZ+NEJRKkCHA4hDabKJbSC9fXHvRwrf\n- * BsFpZqgiNxp3HseUTiwnaUVeyPgMt\/jAj5nB5Sib+UyUxrECQQDnNQBiF2aifEg6\n- * zbJOOC7he5CHAdkFxSxWVFVHL6EfXfqdLVkUohMbgZv+XxyIeU2biOExSg49Kds3\n- * FOKgTau1AkEA0Bd1haj6QuCo8I0AXm2WO+MMTZMTvtHD\/bGjKNM+fT4I8rKYnQRX\n- * 1acHdqS9Xx2rNJqZgkMmpESIdPR2fc4yjwJALFeM6EMmqvj8\/VIf5UJ\/Mz14fXwM\n- * PEARfckUxd9LnnFutCBTWlKvKXJVEZb6KO5ixPaegc57Jp3Vbh3yTN44lQJADD\/1\n- * SSMDaIB1MYP7a5Oj7m6VQNPRq8AJe5vDcRnOae0G9dKRrVyeFxO4GsHj6\/+BHp2j\n- * P8nYMn9eURQ7DXjf\/QJAAQzMlWnKGSO8pyTDtnQx3hRMoUkOEhmNq4bQhLkYqtnY\n- * FcqpUQ2qMjW+NiNWk5HnTrMS3L9EdJobMUzaNZLy4w==\n- * -----END RSA PRIVATE KEY-----\n- *\n- * Private-Key: (1024 bit)\n- * modulus:\n- *     00:bb:f0:40:36:ac:26:54:4e:f4:a3:5a:00:2f:69:\n- *     21:6f:b9:7a:3a:93:ec:a2:f6:e1:8e:c7:63:d8:2f:\n- *     12:30:99:2e:b0:f2:8f:f8:27:2d:24:78:28:84:f7:\n- *     01:bf:8d:44:79:dd:3b:d2:55:f3:ce:3c:b2:5b:21:\n- *     7d:ef:fd:33:4a:b1:a3:ff:c6:c8:9b:b9:0f:7c:41:\n- *     35:97:f9:db:3a:05:60:05:15:af:59:17:92:a3:10:\n- *     ad:16:1c:e4:07:53:af:a8:76:a2:56:2a:92:d3:f9:\n- *     28:e0:78:cf:5e:1f:48:ab:5c:19:dd:e1:67:43:ba:\n- *     75:8d:f5:82:ac:43:92:44:1b\n- * publicExponent: 65537 (0x10001)\n- * privateExponent:\n- *     11:b7:6a:36:3d:30:37:ce:61:9d:6c:84:8b:f3:9b:\n- *     25:4f:14:c8:a4:dd:2f:d7:9a:17:bd:90:19:f7:05:\n- *     fd:f2:d2:c5:f7:77:be:ea:e2:84:87:97:3a:41:96:\n- *     b6:99:f8:94:8c:58:71:51:8c:f4:2a:20:9e:1a:a0:\n- *     26:99:75:d6:31:53:43:39:f5:2a:a6:7e:34:42:51:\n- *     2a:40:87:03:88:43:69:b2:89:6d:20:bd:7d:71:ef:\n- *     47:0a:df:06:c1:69:66:a8:22:37:1a:77:1e:c7:94:\n- *     4e:2c:27:69:45:5e:c8:f8:0c:b7:f8:c0:8f:99:c1:\n- *     e5:28:9b:f9:4c:94:c6:b1\n- * prime1:\n- *     00:e7:35:00:62:17:66:a2:7c:48:3a:cd:b2:4e:38:\n- *     2e:e1:7b:90:87:01:d9:05:c5:2c:56:54:55:47:2f:\n- *     a1:1f:5d:fa:9d:2d:59:14:a2:13:1b:81:9b:fe:5f:\n- *     1c:88:79:4d:9b:88:e1:31:4a:0e:3d:29:db:37:14:\n- *     e2:a0:4d:ab:b5\n- * prime2:\n- *     00:d0:17:75:85:a8:fa:42:e0:a8:f0:8d:00:5e:6d:\n- *     96:3b:e3:0c:4d:93:13:be:d1:c3:fd:b1:a3:28:d3:\n- *     3e:7d:3e:08:f2:b2:98:9d:04:57:d5:a7:07:76:a4:\n- *     bd:5f:1d:ab:34:9a:99:82:43:26:a4:44:88:74:f4:\n- *     76:7d:ce:32:8f\n- * exponent1:\n- *     2c:57:8c:e8:43:26:aa:f8:fc:fd:52:1f:e5:42:7f:\n- *     33:3d:78:7d:7c:0c:3c:40:11:7d:c9:14:c5:df:4b:\n- *     9e:71:6e:b4:20:53:5a:52:af:29:72:55:11:96:fa:\n- *     28:ee:62:c4:f6:9e:81:ce:7b:26:9d:d5:6e:1d:f2:\n- *     4c:de:38:95\n- * exponent2:\n- *     0c:3f:f5:49:23:03:68:80:75:31:83:fb:6b:93:a3:\n- *     ee:6e:95:40:d3:d1:ab:c0:09:7b:9b:c3:71:19:ce:\n- *     69:ed:06:f5:d2:91:ad:5c:9e:17:13:b8:1a:c1:e3:\n- *     eb:ff:81:1e:9d:a3:3f:c9:d8:32:7f:5e:51:14:3b:\n- *     0d:78:df:fd\n- * coefficient:\n- *     01:0c:cc:95:69:ca:19:23:bc:a7:24:c3:b6:74:31:\n- *     de:14:4c:a1:49:0e:12:19:8d:ab:86:d0:84:b9:18:\n- *     aa:d9:d8:15:ca:a9:51:0d:aa:32:35:be:36:23:56:\n- *     93:91:e7:4e:b3:12:dc:bf:44:74:9a:1b:31:4c:da:\n- *     35:92:f2:e3\n- *\n- * client certificate:\n- * Data:\n- *     Version: 3 (0x2)\n- *     Serial Number: 6 (0x6)\n- *     Signature Algorithm: md5WithRSAEncryption\n- *     Issuer: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Validity\n- *         Not Before: Dec  8 03:27:34 2008 GMT\n- *         Not After : Aug 25 03:27:34 2028 GMT\n- *     Subject: C=US, ST=Some-State, L=Some-City, O=Some-Org, OU=SSL-Client, CN=localhost\n- *     Subject Public Key Info:\n- *         Public Key Algorithm: rsaEncryption\n- *         RSA Public Key: (1024 bit)\n- *             Modulus (1024 bit):\n- *                 00:bb:f0:40:36:ac:26:54:4e:f4:a3:5a:00:2f:69:\n- *                 21:6f:b9:7a:3a:93:ec:a2:f6:e1:8e:c7:63:d8:2f:\n- *                 12:30:99:2e:b0:f2:8f:f8:27:2d:24:78:28:84:f7:\n- *                 01:bf:8d:44:79:dd:3b:d2:55:f3:ce:3c:b2:5b:21:\n- *                 7d:ef:fd:33:4a:b1:a3:ff:c6:c8:9b:b9:0f:7c:41:\n- *                 35:97:f9:db:3a:05:60:05:15:af:59:17:92:a3:10:\n- *                 ad:16:1c:e4:07:53:af:a8:76:a2:56:2a:92:d3:f9:\n- *                 28:e0:78:cf:5e:1f:48:ab:5c:19:dd:e1:67:43:ba:\n- *                 75:8d:f5:82:ac:43:92:44:1b\n- *             Exponent: 65537 (0x10001)\n- *     X509v3 extensions:\n- *         X509v3 Basic Constraints:\n- *             CA:FALSE\n- *         X509v3 Key Usage:\n- *             Digital Signature, Non Repudiation, Key Encipherment\n- *         X509v3 Subject Key Identifier:\n- *             CD:BB:C8:85:AA:91:BD:FD:1D:BE:CD:67:7C:FF:B3:E9:4C:A8:22:E6\n- *         X509v3 Authority Key Identifier:\n- *             keyid:FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *\n- *         X509v3 Subject Alternative Name: critical\n- *             IP Address:127.0.0.1\n- * Signature Algorithm: md5WithRSAEncryption\n- *\n- * -----BEGIN CERTIFICATE-----\n- * MIICnzCCAgigAwIBAgIBBjANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n- * MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n- * EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3MzRaFw0yODA4MjUwMzI3MzRaMHIxCzAJ\n- * BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n- * dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtQ2xpZW50MRIwEAYD\n- * VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALvwQDas\n- * JlRO9KNaAC9pIW+5ejqT7KL24Y7HY9gvEjCZLrDyj\/gnLSR4KIT3Ab+NRHndO9JV\n- * 8848slshfe\/9M0qxo\/\/GyJu5D3xBNZf52zoFYAUVr1kXkqMQrRYc5AdTr6h2olYq\n- * ktP5KOB4z14fSKtcGd3hZ0O6dY31gqxDkkQbAgMBAAGjbjBsMAkGA1UdEwQCMAAw\n- * CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTNu8iFqpG9\/R2+zWd8\/7PpTKgi5jAfBgNV\n- * HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\n- * MA0GCSqGSIb3DQEBBAUAA4GBACjj9PS+W6XOF7toFMwMOv\/AemZeBOpcEF1Ei1Hx\n- * HjvB6EOHkMY8tFm5OPzkiWiK3+s3awpSW0jWdzMYwrQJ3\/klMsPDpI7PEuirqwHP\n- * i5Wyl\/vk7jmfWVcBO9MVhPUo4BYl4vS9aj6JA5QbkbkB95LOgT\/BowY0WmHeVsXC\n- * I9aw\n- * -----END CERTIFICATE-----\n- *\n- *\n- *\n- * Trusted CA certificate:\n- * Certificate:\n- *   Data:\n- *     Version: 3 (0x2)\n- *     Serial Number: 0 (0x0)\n- *     Signature Algorithm: md5WithRSAEncryption\n- *     Issuer: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Validity\n- *         Not Before: Dec  8 02:43:36 2008 GMT\n- *         Not After : Aug 25 02:43:36 2028 GMT\n- *     Subject: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Subject Public Key Info:\n- *         Public Key Algorithm: rsaEncryption\n- *         RSA Public Key: (1024 bit)\n- *             Modulus (1024 bit):\n- *                 00:cb:c4:38:20:07:be:88:a7:93:b0:a1:43:51:2d:\n- *                 d7:8e:85:af:54:dd:ad:a2:7b:23:5b:cf:99:13:53:\n- *                 99:45:7d:ee:6d:ba:2d:bf:e3:ad:6e:3d:9f:1a:f9:\n- *                 03:97:e0:17:55:ae:11:26:57:de:01:29:8e:05:3f:\n- *                 21:f7:e7:36:e8:2e:37:d7:48:ac:53:d6:60:0e:c7:\n- *                 50:6d:f6:c5:85:f7:8b:a6:c5:91:35:72:3c:94:ee:\n- *                 f1:17:f0:71:e3:ec:1b:ce:ca:4e:40:42:b0:6d:ee:\n- *                 6a:0e:d6:e5:ad:3c:0f:c9:ba:82:4f:78:f8:89:97:\n- *                 89:2a:95:12:4c:d8:09:2a:e9\n- *             Exponent: 65537 (0x10001)\n- *     X509v3 extensions:\n- *         X509v3 Subject Key Identifier:\n- *             FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *         X509v3 Authority Key Identifier:\n- *             keyid:FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *             DirName:\/C=US\/ST=Some-State\/L=Some-City\/O=Some-Org\n- *             serial:00\n- *\n- *         X509v3 Basic Constraints:\n- *             CA:TRUE\n- *  Signature Algorithm: md5WithRSAEncryption\n- *\n- * -----BEGIN CERTIFICATE-----\n- * MIICrDCCAhWgAwIBAgIBADANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n- * MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n- * EwhTb21lLU9yZzAeFw0wODEyMDgwMjQzMzZaFw0yODA4MjUwMjQzMzZaMEkxCzAJ\n- * BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n- * dHkxETAPBgNVBAoTCFNvbWUtT3JnMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n- * gQDLxDggB76Ip5OwoUNRLdeOha9U3a2ieyNbz5kTU5lFfe5tui2\/461uPZ8a+QOX\n- * 4BdVrhEmV94BKY4FPyH35zboLjfXSKxT1mAOx1Bt9sWF94umxZE1cjyU7vEX8HHj\n- * 7BvOyk5AQrBt7moO1uWtPA\/JuoJPePiJl4kqlRJM2Akq6QIDAQABo4GjMIGgMB0G\n- * A1UdDgQWBBT6uVG\/TOfZhpgz+efLHvEzSfeoFDBxBgNVHSMEajBogBT6uVG\/TOfZ\n- * hpgz+efLHvEzSfeoFKFNpEswSTELMAkGA1UEBhMCVVMxEzARBgNVBAgTClNvbWUt\n- * U3RhdGUxEjAQBgNVBAcTCVNvbWUtQ2l0eTERMA8GA1UEChMIU29tZS1PcmeCAQAw\n- * DAYDVR0TBAUwAwEB\/zANBgkqhkiG9w0BAQQFAAOBgQBcIm534U123Hz+rtyYO5uA\n- * ofd81G6FnTfEAV8Kw9fGyyEbQZclBv34A9JsFKeMvU4OFIaixD7nLZ\/NZ+IWbhmZ\n- * LovmJXyCkOufea73pNiZ+f\/4\/ScZaIlM\/PRycQSqbFNd4j9Wott+08qxHPLpsf3P\n- * 6Mvf0r1PNTY2hwTJLJmKtg==\n- * -----END CERTIFICATE---\n- *\/\n+import jdk.test.lib.security.CertificateBuilder;\n+import jdk.test.lib.security.CertificateBuilder.KeyUsage;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -408,2 +72,0 @@\n-    static Map cookies;\n-    ServerSocket ss;\n@@ -424,202 +86,8 @@\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    static String trusedCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICrDCCAhWgAwIBAgIBADANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\\n\" +\n-        \"MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\\n\" +\n-        \"EwhTb21lLU9yZzAeFw0wODEyMDgwMjQzMzZaFw0yODA4MjUwMjQzMzZaMEkxCzAJ\\n\" +\n-        \"BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\\n\" +\n-        \"dHkxETAPBgNVBAoTCFNvbWUtT3JnMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\\n\" +\n-        \"gQDLxDggB76Ip5OwoUNRLdeOha9U3a2ieyNbz5kTU5lFfe5tui2\/461uPZ8a+QOX\\n\" +\n-        \"4BdVrhEmV94BKY4FPyH35zboLjfXSKxT1mAOx1Bt9sWF94umxZE1cjyU7vEX8HHj\\n\" +\n-        \"7BvOyk5AQrBt7moO1uWtPA\/JuoJPePiJl4kqlRJM2Akq6QIDAQABo4GjMIGgMB0G\\n\" +\n-        \"A1UdDgQWBBT6uVG\/TOfZhpgz+efLHvEzSfeoFDBxBgNVHSMEajBogBT6uVG\/TOfZ\\n\" +\n-        \"hpgz+efLHvEzSfeoFKFNpEswSTELMAkGA1UEBhMCVVMxEzARBgNVBAgTClNvbWUt\\n\" +\n-        \"U3RhdGUxEjAQBgNVBAcTCVNvbWUtQ2l0eTERMA8GA1UEChMIU29tZS1PcmeCAQAw\\n\" +\n-        \"DAYDVR0TBAUwAwEB\/zANBgkqhkiG9w0BAQQFAAOBgQBcIm534U123Hz+rtyYO5uA\\n\" +\n-        \"ofd81G6FnTfEAV8Kw9fGyyEbQZclBv34A9JsFKeMvU4OFIaixD7nLZ\/NZ+IWbhmZ\\n\" +\n-        \"LovmJXyCkOufea73pNiZ+f\/4\/ScZaIlM\/PRycQSqbFNd4j9Wott+08qxHPLpsf3P\\n\" +\n-        \"6Mvf0r1PNTY2hwTJLJmKtg==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    static String serverCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICnzCCAgigAwIBAgIBBzANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\\n\" +\n-        \"MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\\n\" +\n-        \"EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3NTdaFw0yODA4MjUwMzI3NTdaMHIxCzAJ\\n\" +\n-        \"BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\\n\" +\n-        \"dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtU2VydmVyMRIwEAYD\\n\" +\n-        \"VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKWsWxw3\\n\" +\n-        \"ot2ZiS2yebiP1Uil5xyEF41pnMasbfnyHR85GdrTch5u7ETMcKTcugAw9qBPPVR6\\n\" +\n-        \"YWrMV9AKf5UoGD+a2ZTyG8gkiH7+nQ89+1dTCLMgM9Q\/F0cU0c3qCNgOdU6vvszS\\n\" +\n-        \"7K+peknfwtmsuCRAkKYDVirQMAVALE+r2XSJAgMBAAGjbjBsMAkGA1UdEwQCMAAw\\n\" +\n-        \"CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTtbtv0tVbI+xoGYT8PCLumBNgWVDAfBgNV\\n\" +\n-        \"HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\\n\" +\n-        \"MA0GCSqGSIb3DQEBBAUAA4GBAFJjItCtCBZcjD69wdqfIbKmRFa6eJAjR6LcoDva\\n\" +\n-        \"cKC\/sDOLelpspiZ66Zb0Xdv5qQ7QrfOXt3K8QqJKRMdZLF9WfUfy0gJDM32ub91h\\n\" +\n-        \"pu+TmcGPs+6RdrAQcuvU1ZDV9X8SMj7BtKaim4d5sqFw1npncKiA5xFn8vOYwdun\\n\" +\n-        \"nZif\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    static String clientCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICnzCCAgigAwIBAgIBBjANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\\n\" +\n-        \"MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\\n\" +\n-        \"EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3MzRaFw0yODA4MjUwMzI3MzRaMHIxCzAJ\\n\" +\n-        \"BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\\n\" +\n-        \"dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtQ2xpZW50MRIwEAYD\\n\" +\n-        \"VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALvwQDas\\n\" +\n-        \"JlRO9KNaAC9pIW+5ejqT7KL24Y7HY9gvEjCZLrDyj\/gnLSR4KIT3Ab+NRHndO9JV\\n\" +\n-        \"8848slshfe\/9M0qxo\/\/GyJu5D3xBNZf52zoFYAUVr1kXkqMQrRYc5AdTr6h2olYq\\n\" +\n-        \"ktP5KOB4z14fSKtcGd3hZ0O6dY31gqxDkkQbAgMBAAGjbjBsMAkGA1UdEwQCMAAw\\n\" +\n-        \"CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTNu8iFqpG9\/R2+zWd8\/7PpTKgi5jAfBgNV\\n\" +\n-        \"HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\\n\" +\n-        \"MA0GCSqGSIb3DQEBBAUAA4GBACjj9PS+W6XOF7toFMwMOv\/AemZeBOpcEF1Ei1Hx\\n\" +\n-        \"HjvB6EOHkMY8tFm5OPzkiWiK3+s3awpSW0jWdzMYwrQJ3\/klMsPDpI7PEuirqwHP\\n\" +\n-        \"i5Wyl\/vk7jmfWVcBO9MVhPUo4BYl4vS9aj6JA5QbkbkB95LOgT\/BowY0WmHeVsXC\\n\" +\n-        \"I9aw\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-\n-    static byte serverPrivateExponent[] = {\n-        (byte)0x6e, (byte)0xa7, (byte)0x1b, (byte)0x83,\n-        (byte)0x51, (byte)0x35, (byte)0x9a, (byte)0x44,\n-        (byte)0x7d, (byte)0xf6, (byte)0xe3, (byte)0x89,\n-        (byte)0xa0, (byte)0xd7, (byte)0x90, (byte)0x60,\n-        (byte)0xa1, (byte)0x4e, (byte)0x27, (byte)0x21,\n-        (byte)0xa2, (byte)0x89, (byte)0x74, (byte)0xcc,\n-        (byte)0x9d, (byte)0x75, (byte)0x75, (byte)0x4e,\n-        (byte)0xc7, (byte)0x82, (byte)0xe3, (byte)0xe3,\n-        (byte)0xc3, (byte)0x7d, (byte)0x00, (byte)0x54,\n-        (byte)0xec, (byte)0x36, (byte)0xb1, (byte)0xdf,\n-        (byte)0x91, (byte)0x9c, (byte)0x7a, (byte)0xc0,\n-        (byte)0x62, (byte)0x0a, (byte)0xd6, (byte)0xa9,\n-        (byte)0x22, (byte)0x91, (byte)0x4a, (byte)0x29,\n-        (byte)0x2e, (byte)0x43, (byte)0xfa, (byte)0x8c,\n-        (byte)0xd8, (byte)0xe9, (byte)0xbe, (byte)0xd9,\n-        (byte)0x4f, (byte)0xca, (byte)0x23, (byte)0xc6,\n-        (byte)0xe4, (byte)0x3f, (byte)0xb8, (byte)0x72,\n-        (byte)0xcf, (byte)0x02, (byte)0xfc, (byte)0xf4,\n-        (byte)0x58, (byte)0x34, (byte)0x77, (byte)0x76,\n-        (byte)0xce, (byte)0x22, (byte)0x44, (byte)0x5f,\n-        (byte)0x2d, (byte)0xca, (byte)0xee, (byte)0xf5,\n-        (byte)0x43, (byte)0x56, (byte)0x47, (byte)0x71,\n-        (byte)0x0b, (byte)0x09, (byte)0x6b, (byte)0x5e,\n-        (byte)0xf2, (byte)0xc8, (byte)0xee, (byte)0xd4,\n-        (byte)0x6e, (byte)0x44, (byte)0x92, (byte)0x2a,\n-        (byte)0x7f, (byte)0xcc, (byte)0xa7, (byte)0xd4,\n-        (byte)0x5b, (byte)0xfb, (byte)0xf7, (byte)0x4a,\n-        (byte)0xa9, (byte)0xfb, (byte)0x54, (byte)0x18,\n-        (byte)0xd5, (byte)0xd5, (byte)0x14, (byte)0xba,\n-        (byte)0xa0, (byte)0x1c, (byte)0x13, (byte)0xb3,\n-        (byte)0x37, (byte)0x6b, (byte)0x37, (byte)0x59,\n-        (byte)0xed, (byte)0xdb, (byte)0x6d, (byte)0xb1\n-    };\n-\n-    static byte serverModulus[] = {\n-        (byte)0x00,\n-        (byte)0xa5, (byte)0xac, (byte)0x5b, (byte)0x1c,\n-        (byte)0x37, (byte)0xa2, (byte)0xdd, (byte)0x99,\n-        (byte)0x89, (byte)0x2d, (byte)0xb2, (byte)0x79,\n-        (byte)0xb8, (byte)0x8f, (byte)0xd5, (byte)0x48,\n-        (byte)0xa5, (byte)0xe7, (byte)0x1c, (byte)0x84,\n-        (byte)0x17, (byte)0x8d, (byte)0x69, (byte)0x9c,\n-        (byte)0xc6, (byte)0xac, (byte)0x6d, (byte)0xf9,\n-        (byte)0xf2, (byte)0x1d, (byte)0x1f, (byte)0x39,\n-        (byte)0x19, (byte)0xda, (byte)0xd3, (byte)0x72,\n-        (byte)0x1e, (byte)0x6e, (byte)0xec, (byte)0x44,\n-        (byte)0xcc, (byte)0x70, (byte)0xa4, (byte)0xdc,\n-        (byte)0xba, (byte)0x00, (byte)0x30, (byte)0xf6,\n-        (byte)0xa0, (byte)0x4f, (byte)0x3d, (byte)0x54,\n-        (byte)0x7a, (byte)0x61, (byte)0x6a, (byte)0xcc,\n-        (byte)0x57, (byte)0xd0, (byte)0x0a, (byte)0x7f,\n-        (byte)0x95, (byte)0x28, (byte)0x18, (byte)0x3f,\n-        (byte)0x9a, (byte)0xd9, (byte)0x94, (byte)0xf2,\n-        (byte)0x1b, (byte)0xc8, (byte)0x24, (byte)0x88,\n-        (byte)0x7e, (byte)0xfe, (byte)0x9d, (byte)0x0f,\n-        (byte)0x3d, (byte)0xfb, (byte)0x57, (byte)0x53,\n-        (byte)0x08, (byte)0xb3, (byte)0x20, (byte)0x33,\n-        (byte)0xd4, (byte)0x3f, (byte)0x17, (byte)0x47,\n-        (byte)0x14, (byte)0xd1, (byte)0xcd, (byte)0xea,\n-        (byte)0x08, (byte)0xd8, (byte)0x0e, (byte)0x75,\n-        (byte)0x4e, (byte)0xaf, (byte)0xbe, (byte)0xcc,\n-        (byte)0xd2, (byte)0xec, (byte)0xaf, (byte)0xa9,\n-        (byte)0x7a, (byte)0x49, (byte)0xdf, (byte)0xc2,\n-        (byte)0xd9, (byte)0xac, (byte)0xb8, (byte)0x24,\n-        (byte)0x40, (byte)0x90, (byte)0xa6, (byte)0x03,\n-        (byte)0x56, (byte)0x2a, (byte)0xd0, (byte)0x30,\n-        (byte)0x05, (byte)0x40, (byte)0x2c, (byte)0x4f,\n-        (byte)0xab, (byte)0xd9, (byte)0x74, (byte)0x89\n-    };\n-\n-    static byte clientPrivateExponent[] = {\n-        (byte)0x11, (byte)0xb7, (byte)0x6a, (byte)0x36,\n-        (byte)0x3d, (byte)0x30, (byte)0x37, (byte)0xce,\n-        (byte)0x61, (byte)0x9d, (byte)0x6c, (byte)0x84,\n-        (byte)0x8b, (byte)0xf3, (byte)0x9b, (byte)0x25,\n-        (byte)0x4f, (byte)0x14, (byte)0xc8, (byte)0xa4,\n-        (byte)0xdd, (byte)0x2f, (byte)0xd7, (byte)0x9a,\n-        (byte)0x17, (byte)0xbd, (byte)0x90, (byte)0x19,\n-        (byte)0xf7, (byte)0x05, (byte)0xfd, (byte)0xf2,\n-        (byte)0xd2, (byte)0xc5, (byte)0xf7, (byte)0x77,\n-        (byte)0xbe, (byte)0xea, (byte)0xe2, (byte)0x84,\n-        (byte)0x87, (byte)0x97, (byte)0x3a, (byte)0x41,\n-        (byte)0x96, (byte)0xb6, (byte)0x99, (byte)0xf8,\n-        (byte)0x94, (byte)0x8c, (byte)0x58, (byte)0x71,\n-        (byte)0x51, (byte)0x8c, (byte)0xf4, (byte)0x2a,\n-        (byte)0x20, (byte)0x9e, (byte)0x1a, (byte)0xa0,\n-        (byte)0x26, (byte)0x99, (byte)0x75, (byte)0xd6,\n-        (byte)0x31, (byte)0x53, (byte)0x43, (byte)0x39,\n-        (byte)0xf5, (byte)0x2a, (byte)0xa6, (byte)0x7e,\n-        (byte)0x34, (byte)0x42, (byte)0x51, (byte)0x2a,\n-        (byte)0x40, (byte)0x87, (byte)0x03, (byte)0x88,\n-        (byte)0x43, (byte)0x69, (byte)0xb2, (byte)0x89,\n-        (byte)0x6d, (byte)0x20, (byte)0xbd, (byte)0x7d,\n-        (byte)0x71, (byte)0xef, (byte)0x47, (byte)0x0a,\n-        (byte)0xdf, (byte)0x06, (byte)0xc1, (byte)0x69,\n-        (byte)0x66, (byte)0xa8, (byte)0x22, (byte)0x37,\n-        (byte)0x1a, (byte)0x77, (byte)0x1e, (byte)0xc7,\n-        (byte)0x94, (byte)0x4e, (byte)0x2c, (byte)0x27,\n-        (byte)0x69, (byte)0x45, (byte)0x5e, (byte)0xc8,\n-        (byte)0xf8, (byte)0x0c, (byte)0xb7, (byte)0xf8,\n-        (byte)0xc0, (byte)0x8f, (byte)0x99, (byte)0xc1,\n-        (byte)0xe5, (byte)0x28, (byte)0x9b, (byte)0xf9,\n-        (byte)0x4c, (byte)0x94, (byte)0xc6, (byte)0xb1\n-    };\n-\n-    static byte clientModulus[] = {\n-        (byte)0x00,\n-        (byte)0xbb, (byte)0xf0, (byte)0x40, (byte)0x36,\n-        (byte)0xac, (byte)0x26, (byte)0x54, (byte)0x4e,\n-        (byte)0xf4, (byte)0xa3, (byte)0x5a, (byte)0x00,\n-        (byte)0x2f, (byte)0x69, (byte)0x21, (byte)0x6f,\n-        (byte)0xb9, (byte)0x7a, (byte)0x3a, (byte)0x93,\n-        (byte)0xec, (byte)0xa2, (byte)0xf6, (byte)0xe1,\n-        (byte)0x8e, (byte)0xc7, (byte)0x63, (byte)0xd8,\n-        (byte)0x2f, (byte)0x12, (byte)0x30, (byte)0x99,\n-        (byte)0x2e, (byte)0xb0, (byte)0xf2, (byte)0x8f,\n-        (byte)0xf8, (byte)0x27, (byte)0x2d, (byte)0x24,\n-        (byte)0x78, (byte)0x28, (byte)0x84, (byte)0xf7,\n-        (byte)0x01, (byte)0xbf, (byte)0x8d, (byte)0x44,\n-        (byte)0x79, (byte)0xdd, (byte)0x3b, (byte)0xd2,\n-        (byte)0x55, (byte)0xf3, (byte)0xce, (byte)0x3c,\n-        (byte)0xb2, (byte)0x5b, (byte)0x21, (byte)0x7d,\n-        (byte)0xef, (byte)0xfd, (byte)0x33, (byte)0x4a,\n-        (byte)0xb1, (byte)0xa3, (byte)0xff, (byte)0xc6,\n-        (byte)0xc8, (byte)0x9b, (byte)0xb9, (byte)0x0f,\n-        (byte)0x7c, (byte)0x41, (byte)0x35, (byte)0x97,\n-        (byte)0xf9, (byte)0xdb, (byte)0x3a, (byte)0x05,\n-        (byte)0x60, (byte)0x05, (byte)0x15, (byte)0xaf,\n-        (byte)0x59, (byte)0x17, (byte)0x92, (byte)0xa3,\n-        (byte)0x10, (byte)0xad, (byte)0x16, (byte)0x1c,\n-        (byte)0xe4, (byte)0x07, (byte)0x53, (byte)0xaf,\n-        (byte)0xa8, (byte)0x76, (byte)0xa2, (byte)0x56,\n-        (byte)0x2a, (byte)0x92, (byte)0xd3, (byte)0xf9,\n-        (byte)0x28, (byte)0xe0, (byte)0x78, (byte)0xcf,\n-        (byte)0x5e, (byte)0x1f, (byte)0x48, (byte)0xab,\n-        (byte)0x5c, (byte)0x19, (byte)0xdd, (byte)0xe1,\n-        (byte)0x67, (byte)0x43, (byte)0xba, (byte)0x75,\n-        (byte)0x8d, (byte)0xf5, (byte)0x82, (byte)0xac,\n-        (byte)0x43, (byte)0x92, (byte)0x44, (byte)0x1b\n-    };\n+    static X509Certificate trustedCert;\n+\n+    static X509Certificate serverCert;\n+\n+    static X509Certificate clientCert;\n+\n+    static KeyPair serverKeys;\n+    static KeyPair clientKeys;\n@@ -642,1 +110,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -653,2 +121,2 @@\n-        SSLContext context = getSSLContext(trusedCertStr, serverCertStr,\n-            serverModulus, serverPrivateExponent, passphrase);\n+        SSLContext context = getSSLContext(trustedCert, serverCert,\n+            serverKeys, passphrase);\n@@ -709,2 +177,2 @@\n-            SSLContext context = getSSLContext(trusedCertStr, clientCertStr,\n-                clientModulus, clientPrivateExponent, passphrase);\n+            SSLContext context = getSSLContext(trustedCert, clientCert,\n+                    clientKeys, passphrase);\n@@ -758,0 +226,59 @@\n+    private static X509Certificate createTrustedCert(KeyPair caKeys) throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(random.nextLong(1000000)+1);\n+        return CertificateBuilder.newCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .setOneHourValidity()\n+                .build(null, caKeys.getPrivate(), \"MD5WithRSA\");\n+    }\n+\n+    private static void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        serverKeys = kpg.generateKeyPair();\n+        clientKeys = kpg.generateKeyPair();\n+\n+        trustedCert = createTrustedCert(caKeys);\n+        if (debug) {\n+            System.out.println(\"----------- Trusted Cert -----------\");\n+            CertificateBuilder.printCertificate(trustedCert, System.out);\n+        }\n+\n+        serverCert = CertificateBuilder.newCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic(),\n+                KeyUsage.DIGITAL_SIGNATURE, KeyUsage.NONREPUDIATION, KeyUsage.KEY_ENCIPHERMENT)\n+                .addBasicConstraintsExt(false, false, -1)\n+                .addExtension(CertificateBuilder.createIPSubjectAltNameExt(true, \"127.0.0.1\"))\n+                .setOneHourValidity()\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+        if (debug) {\n+            System.out.println(\"----------- Server Cert -----------\");\n+            CertificateBuilder.printCertificate(serverCert, System.out);\n+        }\n+\n+        clientCert = CertificateBuilder.newCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic(),\n+                KeyUsage.DIGITAL_SIGNATURE, KeyUsage.NONREPUDIATION, KeyUsage.KEY_ENCIPHERMENT)\n+                .addExtension(CertificateBuilder.createIPSubjectAltNameExt(true, \"127.0.0.1\"))\n+                .addBasicConstraintsExt(false, false, -1)\n+                .setOneHourValidity()\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+        if (debug) {\n+            System.out.println(\"----------- Client Cert -----------\");\n+            CertificateBuilder.printCertificate(clientCert, System.out);\n+        }\n+    }\n+\n@@ -765,1 +292,1 @@\n-        if (debug)\n+        if (debug) {\n@@ -767,0 +294,3 @@\n+        }\n+\n+        setupCertificates();\n@@ -858,11 +388,2 @@\n-    private static SSLContext getSSLContext(String trusedCertStr,\n-            String keyCertStr, byte[] modulus,\n-            byte[] privateExponent, char[] passphrase) throws Exception {\n-\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n+    private static SSLContext getSSLContext(X509Certificate trustedCert,\n+            X509Certificate keyCert, KeyPair key, char[] passphrase) throws Exception {\n@@ -871,1 +392,1 @@\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n@@ -875,15 +396,1 @@\n-        ks.setCertificateEntry(\"RSA Export Signer\", trusedCert);\n-\n-        if (keyCertStr != null) {\n-            \/\/ generate the private key.\n-            RSAPrivateKeySpec priKeySpec = new RSAPrivateKeySpec(\n-                                            new BigInteger(modulus),\n-                                            new BigInteger(privateExponent));\n-            KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n-            RSAPrivateKey priKey =\n-                    (RSAPrivateKey)kf.generatePrivate(priKeySpec);\n-\n-            \/\/ generate certificate chain\n-            is = new ByteArrayInputStream(keyCertStr.getBytes());\n-            Certificate keyCert = cf.generateCertificate(is);\n-            is.close();\n+        ks.setCertificateEntry(\"RSA Export Signer\", trustedCert);\n@@ -891,0 +398,1 @@\n+        if (keyCert != null) {\n@@ -893,1 +401,1 @@\n-            chain[1] = trusedCert;\n+            chain[1] = trustedCert;\n@@ -896,1 +404,1 @@\n-            ks.setKeyEntry(\"Whatever\", priKey, passphrase, chain);\n+            ks.setKeyEntry(\"Whatever\", key.getPrivate(), passphrase, chain);\n@@ -905,1 +413,1 @@\n-        if (keyCertStr != null) {\n+        if (keyCert != null) {\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/IPIdentities.java","additions":112,"deletions":604,"binary":false,"changes":716,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+modules = \\\n+    java.base\/sun.security.util \\\n+    java.base\/sun.security.x509\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/TEST.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,5 +47,5 @@\n- * @run main\/othervm\/timeout=150 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=0 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=2000 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=100000 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=10000000 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=0 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=2000 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=100000 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=10000000 TestMaxCachedBufferSize\n","filename":"test\/jdk\/sun\/nio\/ch\/TestMaxCachedBufferSize.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n- * @run junit\/timeout=10 TestEncoderReplaceUTF16\n- * @run junit\/timeout=10\/othervm -XX:-CompactStrings TestEncoderReplaceUTF16\n+ * @run junit\/timeout=40 TestEncoderReplaceUTF16\n+ * @run junit\/timeout=40\/othervm -XX:-CompactStrings TestEncoderReplaceUTF16\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceUTF16.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run main EdDSATest\n+ * @run main\/timeout=480 EdDSATest\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EdDSATest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm IncludeRandom\n+ * @run main\/othervm\/timeout=480 IncludeRandom\n@@ -56,1 +56,1 @@\n-        for (var i = 0; i < 10_000; i++) {\n+        for (var i = 0; i < 1000; i++) {\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeRandom.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm Constructors\n+ * @run main\/othervm\/timeout=480 Constructors\n","filename":"test\/jdk\/sun\/security\/krb5\/name\/Constructors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jtreg.SkippedException;\n+\n@@ -49,2 +51,1 @@\n-            System.out.println(\"Not supported by provider, skipping\");\n-            return;\n+            throw new SkippedException(\"Algorithm ARCFOUR is not supported by provider, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/ReinitCipher.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n-import java.io.PrintStream;\n-import java.security.*;\n-import java.security.spec.*;\n-import java.util.Random;\n+import jtreg.SkippedException;\n@@ -37,2 +34,6 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -40,0 +41,1 @@\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -51,3 +53,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/Test4512704.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,14 @@\n-import java.security.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-import java.math.*;\n-import java.io.*;\n+import jtreg.SkippedException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherInputStream;\n+import javax.crypto.CipherOutputStream;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.util.Arrays;\n+import java.util.Random;\n@@ -40,1 +49,0 @@\n-import java.util.*;\n@@ -58,3 +66,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCICOWithGCM.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -47,1 +49,0 @@\n-\/\/        test(\"CCM\", p);\n@@ -56,3 +57,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCICOWithGCMAndAAD.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-import jdk.test.lib.Utils;\n+import jtreg.SkippedException;\n@@ -73,2 +73,1 @@\n-            System.out.println(\"Skip; no support for \" + ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPoly.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @build jdk.test.lib.Convert\n@@ -34,1 +33,2 @@\n-import java.util.*;\n+import jtreg.SkippedException;\n+\n@@ -39,1 +39,0 @@\n-import javax.crypto.spec.ChaCha20ParameterSpec;\n@@ -44,1 +43,5 @@\n-import jdk.test.lib.Convert;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n@@ -129,2 +132,1 @@\n-            System.out.println(\"Skip; no support for \" + ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyKAT.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-import java.util.*;\n+import jtreg.SkippedException;\n+\n@@ -38,1 +39,0 @@\n-import javax.crypto.spec.ChaCha20ParameterSpec;\n@@ -41,1 +41,0 @@\n-import javax.crypto.AEADBadTagException;\n@@ -45,0 +44,5 @@\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n@@ -241,2 +245,1 @@\n-            System.out.println(\"Skip; no support for \" + CIPHER_ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + CIPHER_ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyNoReuse.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -35,1 +37,0 @@\n-import java.security.Key;\n@@ -40,1 +41,0 @@\n-import javax.crypto.spec.ChaCha20ParameterSpec;\n@@ -63,2 +63,1 @@\n-            System.out.println(\"Skip; no support for \" + ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyOutputSize.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -41,0 +43,1 @@\n+import java.util.ArrayList;\n@@ -42,0 +45,1 @@\n+import java.util.List;\n@@ -48,3 +52,3 @@\n-    private static String[] TRANSFORMATIONS = {\n-        \"AES\/ECB\/PKCS5Padding\", \"AES\/GCM\/NoPadding\",\n-        \"RSA\/ECB\/PKCS1Padding\"\n+    private static final String[] TRANSFORMATIONS = {\n+            \"AES\/ECB\/PKCS5Padding\", \"AES\/GCM\/NoPadding\",\n+            \"RSA\/ECB\/PKCS1Padding\"\n@@ -53,2 +57,2 @@\n-    private static byte[] BYTES16 =\n-            Arrays.copyOf(TRANSFORMATIONS[0].getBytes(), 16);\n+    private static final byte[] BYTES16 =\n+            Arrays.copyOf(\"AES\/ECB\/PKCS5Padding\".getBytes(), 16);\n@@ -100,2 +104,15 @@\n-        for (String t : TRANSFORMATIONS) {\n-            checkModes(t, p);\n+        List<String> skipped = new ArrayList<>();\n+        for (final String t : TRANSFORMATIONS) {\n+            try {\n+                checkModes(t, p);\n+            } catch (SkippedException skippedException) {\n+                \/\/ printing to System.out, so it's easier to see which test it relates to\n+                skippedException.printStackTrace(System.out);\n+                skipped.add(t);\n+            }\n+        }\n+\n+        if (!skipped.isEmpty()) {\n+            throw new SkippedException(\"Some tests skipped: \" + skipped);\n+        } else {\n+            System.out.println(\"All tests passed\");\n@@ -103,1 +120,0 @@\n-        System.out.println(\"All tests passed\");\n@@ -110,2 +126,1 @@\n-            System.out.println(\"Skip \" + t + \" due to \" + e.getMessage());\n-            return;\n+            throw new SkippedException(\"Skip \" + t + \" due to \" + e.getMessage());\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherMode.java","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,7 @@\n-import java.security.*;\n+import jtreg.SkippedException;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Provider;\n@@ -36,3 +42,5 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-import java.math.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -40,1 +48,1 @@\n-import java.util.*;\n+import java.util.Arrays;\n@@ -80,3 +88,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestGCMKeyAndIvCheck.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -314,3 +316,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + transformation);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + transformation);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestKATForGCM.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jtreg.SkippedException;\n@@ -58,2 +59,1 @@\n-            System.out.println(\"Not supported by provider, skipping\");\n-            return;\n+            throw new SkippedException(\"Algorithm \" + RSA_ALGOS[0] + \" is not supported by provider, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestRSACipher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import jtreg.SkippedException;\n@@ -57,2 +58,1 @@\n-            System.out.println(RSA_ALGOS[0] + \" unsupported, skipping\");\n-            return;\n+            throw new SkippedException(RSA_ALGOS[0] + \" unsupported, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestRSACipherWrap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jtreg.SkippedException;\n@@ -52,2 +53,1 @@\n-            System.out.println(\"Not supported by provider, skipping\");\n-            return;\n+            throw new SkippedException(\"Algorithm RSA\/ECB\/NoPadding is not supported by provider, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestRawRSACipher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jtreg.SkippedException;\n+\n@@ -40,0 +42,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -47,5 +51,1 @@\n-    private static class CI { \/\/ class for holding Cipher Information\n-\n-        String transformation;\n-        String keyAlgo;\n-        int dataSize;\n+    private record CI (String transformation, String keyAlgo, int dataSize){}  \/\/ record for holding Cipher Information\n@@ -53,6 +53,0 @@\n-        CI(String transformation, String keyAlgo, int dataSize) {\n-            this.transformation = transformation;\n-            this.keyAlgo = keyAlgo;\n-            this.dataSize = dataSize;\n-        }\n-    }\n@@ -60,24 +54,24 @@\n-        new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n-        new CI(\"RC4\", \"RC4\", 401),\n-        new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n-        new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n-        new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n-        new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n-        new CI(\"DES\/cbc\/PKCS5Padding\", \"DES\", 6401),\n-        new CI(\"DESede\/CBC\/PKCS5Padding\", \"DESede\", 402),\n-        new CI(\"AES\/CBC\/PKCS5Padding\", \"AES\", 30),\n-        new CI(\"Blowfish\/CBC\/PKCS5Padding\", \"Blowfish\", 19),\n-        new CI(\"DES\/ECB\/NoPadding\", \"DES\", 400),\n-        new CI(\"DESede\/ECB\/NoPadding\", \"DESede\", 160),\n-        new CI(\"AES\/ECB\/NoPadding\", \"AES\", 4800),\n-        new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 32),\n-        new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 6400),\n-        new CI(\"DESede\/ECB\/PKCS5Padding\", \"DESede\", 400),\n-        new CI(\"AES\/ECB\/PKCS5Padding\", \"AES\", 64),\n-\n-        new CI(\"DES\", \"DES\", 6400),\n-        new CI(\"DESede\", \"DESede\", 408),\n-        new CI(\"AES\", \"AES\", 128),\n-\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n-        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n+            new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n+            new CI(\"RC4\", \"RC4\", 401),\n+            new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n+            new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n+            new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n+            new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n+            new CI(\"DES\/cbc\/PKCS5Padding\", \"DES\", 6401),\n+            new CI(\"DESede\/CBC\/PKCS5Padding\", \"DESede\", 402),\n+            new CI(\"AES\/CBC\/PKCS5Padding\", \"AES\", 30),\n+            new CI(\"Blowfish\/CBC\/PKCS5Padding\", \"Blowfish\", 19),\n+            new CI(\"DES\/ECB\/NoPadding\", \"DES\", 400),\n+            new CI(\"DESede\/ECB\/NoPadding\", \"DESede\", 160),\n+            new CI(\"AES\/ECB\/NoPadding\", \"AES\", 4800),\n+            new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 32),\n+            new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 6400),\n+            new CI(\"DESede\/ECB\/PKCS5Padding\", \"DESede\", 400),\n+            new CI(\"AES\/ECB\/PKCS5Padding\", \"AES\", 64),\n+\n+            new CI(\"DES\", \"DES\", 6400),\n+            new CI(\"DESede\", \"DESede\", 408),\n+            new CI(\"AES\", \"AES\", 128),\n+\n+            new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n+            new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n@@ -93,1 +87,1 @@\n-        boolean status = true;\n+        List<CI> skippedList = new ArrayList<>();\n@@ -96,2 +90,1 @@\n-            for (int i = 0; i < TEST_LIST.length; i++) {\n-                CI currTest = TEST_LIST[i];\n+            for (CI currTest : TEST_LIST) {\n@@ -126,1 +119,2 @@\n-                            nsae);\n+                                       nsae);\n+                    skippedList.add(currTest);\n@@ -134,0 +128,4 @@\n+\n+        if (!skippedList.isEmpty()){\n+            throw new SkippedException(\"Some tests skipped: \" + skippedList);\n+        }\n@@ -137,2 +135,2 @@\n-            AlgorithmParameters params, int firstBlkSize,\n-            byte[] in, byte[] answer) throws Exception {\n+                             AlgorithmParameters params, int firstBlkSize,\n+                             byte[] in, byte[] answer) throws Exception {\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphers.java","additions":40,"deletions":42,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jtreg.SkippedException;\n+\n@@ -42,0 +44,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -50,4 +54,1 @@\n-    private static class CI { \/\/ class for holding Cipher Information\n-        String transformation;\n-        String keyAlgo;\n-        int dataSize;\n+    private record CI (String transformation, String keyAlgo, int dataSize){}  \/\/ record for holding Cipher Information\n@@ -55,6 +56,1 @@\n-        CI(String transformation, String keyAlgo, int dataSize) {\n-            this.transformation = transformation;\n-            this.keyAlgo = keyAlgo;\n-            this.dataSize = dataSize;\n-        }\n-    }\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -62,11 +58,11 @@\n-    private static final CI TEST_LIST[] = {\n-        new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n-        new CI(\"RC4\", \"RC4\", 401),\n-        new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n-        new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n-        new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n-        new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 1600),\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n-        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n-        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n+    private static final CI[] TEST_LIST = {\n+            new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n+            new CI(\"RC4\", \"RC4\", 401),\n+            new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n+            new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n+            new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n+            new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n+            new CI(\"AES\/CTR\/NoPadding\", \"AES\", 1600),\n+            new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n+            new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n+            new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n@@ -75,2 +71,0 @@\n-    private static final StringBuffer debugBuf = new StringBuffer();\n-\n@@ -79,1 +73,1 @@\n-        boolean status = true;\n+        List<CI> skippedList = new ArrayList<>();\n@@ -82,2 +76,1 @@\n-            for (int i = 0; i < TEST_LIST.length; i++) {\n-                CI currTest = TEST_LIST[i];\n+            for (CI currTest : TEST_LIST) {\n@@ -87,1 +80,1 @@\n-                        KeyGenerator.getInstance(currTest.keyAlgo, p);\n+                            KeyGenerator.getInstance(currTest.keyAlgo, p);\n@@ -91,1 +84,1 @@\n-                               System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+                            System.getProperty(\"test.provider.name\", \"SunJCE\"));\n@@ -101,1 +94,1 @@\n-                         plainTxt, answer);\n+                            plainTxt, answer);\n@@ -106,1 +99,1 @@\n-                         answer, answer2);\n+                            answer, answer2);\n@@ -111,0 +104,1 @@\n+                    skippedList.add(currTest);\n@@ -118,0 +112,4 @@\n+\n+        if (!skippedList.isEmpty()){\n+            throw new SkippedException(\"Some tests skipped: \" + skippedList);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphersNoPad.java","additions":29,"deletions":31,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @run main\/othervm\/timeout=30 TestHKDF\n+ * @run main\/othervm\/timeout=120 TestHKDF\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KDF\/TestHKDF.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -65,2 +67,1 @@\n-            System.out.println(\"No support of DH KeyPairGenerator, skipping\");\n-            return;\n+           throw new SkippedException(\"No support of DH KeyPairGenerator, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/SupportedDHKeys.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jtreg.SkippedException;\n@@ -47,2 +48,1 @@\n-            System.out.println(\"DH not supported, skipping\");\n-            return;\n+            throw new SkippedException(\"DH not supported, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/TestDH.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jtreg.SkippedException;\n@@ -79,2 +80,1 @@\n-            System.out.println(\"DH not supported, skipping\");\n-            return;\n+            throw new SkippedException(\"DH not supported, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/TestInterop.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import jtreg.SkippedException;\n+\n@@ -93,2 +95,1 @@\n-            System.out.println(\"DH not supported, skipping\");\n-            return;\n+            throw new SkippedException(\"DH not supported, skipping\");\n@@ -96,0 +97,1 @@\n+\n@@ -97,2 +99,0 @@\n-            DHPublicKeySpec publicSpec;\n-            DHPrivateKeySpec privateSpec;\n@@ -109,1 +109,1 @@\n-            if (Arrays.equals(s2, n2) == false) {\n+            if (!Arrays.equals(s2, n2)) {\n@@ -117,1 +117,1 @@\n-            if (Arrays.equals(s3, n3) == false) {\n+            if (!Arrays.equals(s3, n3)) {\n@@ -126,21 +126,0 @@\n-\n-\/*\n-        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DH\", provider);\n-        kpg.initialize(512);\n-\/\/        KeyPair kp1 = kpg.generateKeyPair();\n-\/\/      System.out.println(kp1.getPublic());\n-\/\/      System.out.println(kp1.getPrivate());\n-        while (true) {\n-            KeyAgreement ka = KeyAgreement.getInstance(\"DH\", provider);\n-            ka.init(pr1);\n-            KeyPair kp2 = kpg.generateKeyPair();\n-            ka.doPhase(kp2.getPublic(), true);\n-            byte[] sec = ka.generateSecret();\n-            if (sec.length == 64) {\n-                System.out.println(kp2.getPrivate());\n-                System.out.println(kp2.getPublic());\n-                System.out.println(toString(sec));\n-                break;\n-            }\n-        }\n-\/**\/\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/TestShort.java","additions":7,"deletions":28,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -62,2 +64,1 @@\n-            System.out.println(\"No supported of DH KeyPairGenerator, skipping\");\n-            return;\n+            throw new SkippedException(\"DH (DiffieHellman) is not supported in KeyPairGenerator, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyAgreement\/UnsupportedDHKeys.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main TestDefaultSize\n+ * @run main\/timeout=480 TestDefaultSize\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyPairGenerator\/TestDefaultSize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm\/timeout=30 ImportKeyToP12\n+ * @run main\/othervm\/timeout=120 ImportKeyToP12\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/ImportKeyToP12.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=30 -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt TestLargeSecretKeys\n+ * @run main\/othervm\/timeout=120 -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt TestLargeSecretKeys\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/TestLargeSecretKeys.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main\/othervm KeytoolOpensslInteropTest true\n+ * @run main\/othervm\/timeout=480 KeytoolOpensslInteropTest true\n@@ -51,1 +51,1 @@\n- * @run main\/othervm KeytoolOpensslInteropTest false\n+ * @run main\/othervm\/timeout=480 KeytoolOpensslInteropTest false\n","filename":"test\/jdk\/sun\/security\/pkcs12\/KeytoolOpensslInteropTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main Launcher\n+ * @run main\/timeout=480 Launcher\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xcomp Launcher\n+ * @run main\/othervm\/timeout=480 -Xcomp Launcher\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/Launcher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @enablePreview\n@@ -38,3 +39,2 @@\n-import java.io.*;\n-import java.net.SocketException;\n-import java.util.*;\n+import java.io.ByteArrayInputStream;\n+import java.security.PEMDecoder;\n@@ -42,2 +42,16 @@\n-import java.security.cert.*;\n-import java.security.cert.CertPathValidatorException.*;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.CertPathValidatorException;\n+import java.security.cert.CertPathValidatorException.BasicReason;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Set;\n@@ -47,0 +61,2 @@\n+    private static final PEMDecoder pemDecoder = java.security.PEMDecoder.of();\n+\n@@ -107,2 +123,0 @@\n-        \/\/ generate certificate from cert strings\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -110,1 +124,1 @@\n-        ByteArrayInputStream is;\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -112,2 +126,2 @@\n-        is = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        \/\/ generate certificate from cert strings\n+        Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -116,2 +130,1 @@\n-        List<Certificate> list = Arrays.asList(new Certificate[] {\n-                        selfSignedCert});\n+        List<Certificate> list = Collections.singletonList(selfSignedCert);\n@@ -122,4 +135,1 @@\n-    private static Set<TrustAnchor> generateTrustAnchors()\n-            throws CertificateException {\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+    private static Set<TrustAnchor> generateTrustAnchors() {\n@@ -127,3 +137,2 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+        \/\/ generate certificate from cert string\n+        X509Certificate selfSignedCert = pemDecoder.decode(selfSignedCertStr, X509Certificate.class);\n@@ -133,1 +142,1 @@\n-            new TrustAnchor((X509Certificate)selfSignedCert, null);\n+            new TrustAnchor(selfSignedCert, null);\n@@ -167,1 +176,1 @@\n-            throws CertPathValidatorException, Exception {\n+            throws Exception {\n@@ -179,1 +188,5 @@\n-        params.setDate(new Date(109, 9, 1));   \/\/ 2009-09-01\n+        final Calendar calendar = Calendar.getInstance();\n+        calendar.set(Calendar.YEAR, 2009);\n+        calendar.set(Calendar.MONTH, 9);\n+        calendar.set(Calendar.DATE, 1);\n+        params.setDate(calendar.getTime());   \/\/ 2009-09-01\n","filename":"test\/jdk\/sun\/security\/provider\/certpath\/DisabledAlgorithms\/CPValidatorTrustAnchor.java","additions":36,"deletions":23,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -29,2 +30,1 @@\n-import java.io.InputStream;\n-import java.io.ByteArrayInputStream;\n+import java.security.PEMDecoder;\n@@ -32,1 +32,0 @@\n-import java.security.cert.CertificateFactory;\n@@ -35,0 +34,1 @@\n+import java.security.cert.X509Certificate;\n@@ -90,3 +90,3 @@\n-    public static void main(String args[]) throws Exception {\n-\n-        Certificate signer = generate(signerCertStr);\n+    public static void main(String[] args) throws Exception {\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n+        Certificate signer = pemDecoder.decode(signerCertStr, X509Certificate.class);\n@@ -95,1 +95,1 @@\n-        Certificate normal = generate(normalCertStr);\n+        Certificate normal = pemDecoder.decode(normalCertStr, X509Certificate.class);\n@@ -97,1 +97,1 @@\n-        Certificate longer = generate(longerCertStr);\n+        Certificate longer = pemDecoder.decode(longerCertStr, X509Certificate.class);\n@@ -99,1 +99,1 @@\n-        Certificate shorter = generate(shorterCertStr);\n+        Certificate shorter = pemDecoder.decode(shorterCertStr, X509Certificate.class);\n@@ -108,13 +108,0 @@\n-    private static Certificate generate(String certStr) throws Exception {\n-        InputStream is = null;\n-        try {\n-            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-            is = new ByteArrayInputStream(certStr.getBytes());\n-            return cf.generateCertificate(is);\n-        } finally {\n-            if (is != null) {\n-                is.close();\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/rsa\/InvalidBitString.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @enablePreview\n@@ -200,2 +201,3 @@\n-import java.io.*;\n-import java.net.*;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.security.PEMDecoder;\n@@ -206,4 +208,7 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n-import javax.net.ssl.*;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -211,0 +216,3 @@\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.spec.RSAPrivateKeySpec;\n@@ -315,1 +323,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -389,1 +397,1 @@\n-            String enabledSuites[] = {\n+            String[] enabledSuites = {\n@@ -474,14 +482,12 @@\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\" + e);\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n+            serverThread = new Thread(() -> {\n+                try {\n+                    doServerSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our server thread just died.\n+                     *\n+                     * Release the client, if not active already...\n+                     *\/\n+                    System.err.println(\"Server died...\" + e);\n+                    serverReady = true;\n+                    serverException = e;\n@@ -489,1 +495,1 @@\n-            };\n+            });\n@@ -498,11 +504,9 @@\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n+            clientThread = new Thread(() -> {\n+                try {\n+                    doClientSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our client thread just died.\n+                     *\/\n+                    System.err.println(\"Client died...\");\n+                    clientException = e;\n@@ -510,1 +514,1 @@\n-            };\n+            });\n@@ -520,1 +524,0 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -522,3 +525,3 @@\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trustedCert = cf.generateCertificate(is);\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n+        Certificate trustedCert = pemDecoder.decode(trusedCertStr, X509Certificate.class);\n@@ -543,2 +546,1 @@\n-            is = new ByteArrayInputStream(serverCertStr.getBytes());\n-            Certificate serverCert = cf.generateCertificate(is);\n+            Certificate serverCert = pemDecoder.decode(serverCertStr, X509Certificate.class);\n","filename":"test\/jdk\/sun\/security\/ssl\/ClientHandshaker\/RSAExport.java","additions":44,"deletions":42,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -42,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -140,2 +142,1 @@\n-        float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-        baseSocket.setSoTimeout((int)(1000 * timeoutFactor));\n+        baseSocket.setSoTimeout((int)(1000 * Utils.TIMEOUT_FACTOR));\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketCloseHang.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,4 +65,4 @@\n- * @run main\/othervm CertChecking false SunX509\n- * @run main\/othervm CertChecking true SunX509\n- * @run main\/othervm CertChecking false PKIX\n- * @run main\/othervm CertChecking true PKIX\n+ * @run main\/othervm\/timeout=480 CertChecking false SunX509\n+ * @run main\/othervm\/timeout=480 CertChecking true SunX509\n+ * @run main\/othervm\/timeout=480 CertChecking false PKIX\n+ * @run main\/othervm\/timeout=480 CertChecking true PKIX\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/CertChecking.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ * @enablePreview\n@@ -38,3 +39,18 @@\n-import java.util.*;\n-import java.io.*;\n-import javax.net.ssl.*;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.security.PEMDecoder;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -43,3 +59,0 @@\n-import java.security.cert.*;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n@@ -47,1 +60,1 @@\n-import java.util.Base64;\n+import java.util.Arrays;\n@@ -99,27 +112,0 @@\n-    static String trustedPrivateKey = \/\/ Private key in the format of PKCS#8\n-        \"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDUJ3hT\/9jY\/i8i\\n\" +\n-        \"70EEaL6mbrhhdg\/Ys1E0r97n+dZaY0olqkIBhh1r8UkKWtvOkj8WBFQ0sz0HhSjT\\n\" +\n-        \"rkVEisGLW+7zPJiDBPtQrRawvCDpnzUofnQ98zQKUTHji1OqhxgNzsKCy9vIh5Mh\\n\" +\n-        \"tX0CdGUScEDXlYUkAkxMKCVo2V5dRn34D+1rNGEeWxGnQ5vyPi0IwlpEOkYxhPLV\\n\" +\n-        \"dsb5aoLzBc\/rdrrdzCM+svm7O38LhbVuA0F9NHAgdJRKE2F91ztkk1KvY0U9zCh1\\n\" +\n-        \"3u5WV7kl481qDujKGM4UURoEarbV2Xr+jNVGSpJZYCLU\/sxFrL15iPeYtmJlovo2\\n\" +\n-        \"VbFed\/NXAgMBAAECggEAUZvlQ5q1VbNhenTCc+m+\/NK2hncd3WQNJtFIU7\/dXuO2\\n\" +\n-        \"0ApQXbmzc6RbTmppB2tmbRe5NJSGM3BbpiHxb05Y6TyyDEsQ98Vgz0Xl5pJXrsaZ\\n\" +\n-        \"cjxChtoY+KcHI9qikoRpElaoqBu3LcpJJLxlnB4eCxu3NbbEgneH1fvTeCO1kvcp\\n\" +\n-        \"i3DDdyfY7WB9RW1yWAveiuqvtnbsPfJJLKEhFvZL2ArYCRTm\/oIw64yukNe\/QLR5\\n\" +\n-        \"bGzEJMT2ZNQMld1f+CW9tOrUKrnnPCGfMa351T5we+8B6sujWfftPutgEVx5TmHs\\n\" +\n-        \"AOW1SntMapbgg46K9EC\/C5YQa5D1aNOH9ZTEMkgUMQKBgQDrpPQIHFozeeyZ0iiq\\n\" +\n-        \"HtReLPcqpkwr\/9ELc3SjgUypSvpu0l\/m++um0yLinlXMn25km\/BP6Mv3t\/+1uzAc\\n\" +\n-        \"qpopkcyek8X1hzNRhDkWuMv4KDOKk5c6qLx8FGSm6q8PYm5KbsiyeCM7CJoeoqJ5\\n\" +\n-        \"74IZjOIw7UrYLckCb6W8xGQLIwKBgQDmew3vGRR3JmCCSumtJQOqhF6bBYrNb6Qc\\n\" +\n-        \"r4vrng+QhNIquwGqHKPorAI1J8J1jOS+dkDWTxSz2xQKQ83nsOspzVPskpDh5mWL\\n\" +\n-        \"gGk5QCkX87jFsXfhvZFLksZMbIdpWze997Zs2fe\/PWfPaH6o3erqo2zAhQV0eA9q\\n\" +\n-        \"C7tfImREPQKBgQDi2Xq\/8CN52M9IScQx+dnyC5Gqckt0NCKXxn8sBIa7l129oDMI\\n\" +\n-        \"187FXA8CYPEyOu14V5KiKvdos66s0daAUlB04lI8+v+g3ZYuzH50\/FQHwxPTPUBi\\n\" +\n-        \"DRzeyncXJWiAA\/8vErWM8hDgfOh5w5Fsl4EEfdcmyNm7gWA4Qyknr1ysRwKBgQDC\\n\" +\n-        \"JSPepUy09VHUTxA59nT5HRmoEeoTFRizxTfi2LkZrphuwCotxoRXiRUu+3f1lyJU\\n\" +\n-        \"Qb5qCCFTQ5bE8squgTwGcVxhajC66V3ePePlAuPatkWN2ek28X1DoLaDR+Rk3h69\\n\" +\n-        \"Wb2EQbNMl4grkUUoMA8jaVhBb4vhyQSK+qjyAUFerQKBgQDXZPuflfsjH\/d\/O2yw\\n\" +\n-        \"qZbssKe9AKORjv795teblAc3vmsSlNwwVnPdS2aq1LHyoNbetc\/OaZV151hTQ\/9z\\n\" +\n-        \"bsA48oOojgrDD07Ovg3uDcNEIufxR0aGeSSvqhElp1r7wAYj8bAr6W\/RH6MS16WW\\n\" +\n-        \"dRd+PH6hsap8BD2RlVCnrT3vIQ==\";\n@@ -159,27 +145,0 @@\n-    static String caSignerPrivateKey = \/\/ Private key in the format of PKCS#8\n-        \"MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDAvGeLKlW1ljae\\n\" +\n-        \"eu8NvDCjfW5BNK2c0C4ry7Is+1mM4PC7FA4bRpMaQHKIjLsZ5D1hoA9183cv3p1a\\n\" +\n-        \"P75\/ZYMOyx1id\/hXmbd3jp8BR0wbvrKxa53+4lO0S5AL5dOpU2AVhcdeQ7+DwoL6\\n\" +\n-        \"iAuHqNcABg3CijrIcFeZHcPMwaZMd9YxJG6YrnNHMWjbXTGKpma02NMB1UnRxsdN\\n\" +\n-        \"phqfRt2gkUs18l6697sSJ7eblvSWEWw1Bmtrg9No28UUsiF8q0m9i\/G0QzYOrS6v\\n\" +\n-        \"ghum5bpHAixxfA9Z\/ozHrN8gf8gNDTRnG6phDwVb1Uj9nO2f9yTArx7Kz5EtRNmD\\n\" +\n-        \"x9SNMS9rAgMBAAECggEAZk6cF\/8s5+sIqy9OXdgbaW1XbT1tOuQ23gCOX9o8Os\/c\\n\" +\n-        \"eTG4GzpnM3QqV9l8J85D1uKD0nSeO8bLd\/CGSlG0M9IVkwNjy\/xIqyoFtUQHXmLn\\n\" +\n-        \"r84UXAv\/qqDBoc8pf6RGSKZuodcMfgBuTlaQ6D3zgou0GiQN9\/\/KP\/jQyouwnr3A\\n\" +\n-        \"LyXQekxriwPuSYAPak8s5XLfugOebbSRm2UdGEgX3yrT9FVu9rtgeMKdRaCOU8T4\\n\" +\n-        \"G2UdpGaiDfm5yrR+2XEIv4oaH3WFxmmfQCxVcOFJ1iRvfKBbLb1UCgtJuCBD067y\\n\" +\n-        \"dq5PrwUTeAvd7hwZd0lxCSnWY7VvYFNr7iJfyElowQKBgQD8eosot+Th03hpkYDs\\n\" +\n-        \"BIVsw7oqhJmcrPV1bSZ+aQwqqrOGypNmb7nLGTC8Cj1sT+EzfGs7GqxiLOEn4NXr\\n\" +\n-        \"TYV\/\/RUPBSEXVp2y+2dot1a9oq0BJ8FwGTYL0qSwJrIXJfkQFrYhVVz3JLIWJbwV\\n\" +\n-        \"cy4YCQr094BhXTS7joJOUDRsYwKBgQDDbI3Lv+bBK8lLfIBll1RY1k5Gqy\/H+qxp\\n\" +\n-        \"sMN8FmadmIGzHhe9xml6b5EfAZphAUF4vZJhQXloT5Wm+NNIAf6X6dRjvzyw7N9B\\n\" +\n-        \"d48EFJF4ChqNGBocsQRNr2wPRzQ+k2caw9YyYMIjbhktDzO1U\/FJGYW6\/Vgr2v4K\\n\" +\n-        \"siROnXfLWQKBgBOVAZQP5z2opC8z7NbhZuPPrnG7xRpEw+jupUyqoxnwEWqD7bjF\\n\" +\n-        \"M5jQBFqhRLBQ5buTi9GSuQoIRxJLuuu8IH2TyH1YvX9M5YBLRXL2vVCJ\/HcZeURT\\n\" +\n-        \"gECcfs92wNtQw6d+y3N8ZnB4tSNIm\/Th8RJGKUZkp91lWECvxeWDDP3XAoGASfNq\\n\" +\n-        \"NRAJYlAPfGFAtTDu2i8+r79X9XUGiXg6gVp4umpbqkxY75eFkq9lWzZgFRVEkUwr\\n\" +\n-        \"eGIubyquluDSEw2uKg5yMMzNSqZYVY3IsOKXqbUpFvtn5jOWTU90tNNdEdD100sI\\n\" +\n-        \"Y0f6Ly4amNKH3rZFOERQNtJn6zCTsbh3xMgR7QECgYBhQTqxLU5eIu38MKobzRue\\n\" +\n-        \"RoUkMcoY3DePkKPSYjilFhkUDozIXf\/xUGnB8kERZKO+44wUkuPGljiFL1\/P\/RO9\\n\" +\n-        \"zhHAV94Kw2ddtfxy05GVtUZ99miBmsMb2m8vumGJqfR8h2xpfc1Ra0zfrsPgLNru\\n\" +\n-        \"xDTDW+bNbM7XyPvg9mOf7Q==\";\n@@ -219,27 +178,0 @@\n-    static String certIssuerPrivateKey = \/\/ Private key in the format of PKCS#8\n-        \"MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQC1lDVpzmzwbKOL\\n\" +\n-        \"yFWkjPjqtX9xLMq7SVqobvhBv+VChMGGjQbNQPbtczOcXNOcuMFyXxY++eXY7c37\\n\" +\n-        \"MzhbdZHv4Y4aWEn+A3EiX2\/fTAbxx165qxKiHbD2EmlKk\/Q6yIvi9M9EXXr\/viEC\\n\" +\n-        \"Y4\/Sdtd4KYtfETa0FpfF5\/ZpZMYQo8I9RqBQOmhfvXL1l\/Lodla5elZtvIUyp5k2\\n\" +\n-        \"nRQe58AxeP5hrilbIgfmEySf9mOkaTalRf2epBE\/wRNA7Qi5Sr2O4pY2x3PPdmMy\\n\" +\n-        \"NL4cZaOJTgdyeDYbEMSW6vpiJW26ma\/qeFgPIXZ8COFJZLSOEu310M4QOdSR1Y2c\\n\" +\n-        \"l3\/V2E0VAgMBAAECggEBAJjfVrjl2kHwtSCSYchQB6FTfSBDnctgTrtP8iMo9FO0\\n\" +\n-        \"gVpOkVNtRndTbjhOzro7smIgPBJ5QlIIpErBLMmTinJza7gybNk2\/KD7yKwuzgnw\\n\" +\n-        \"2IdoyB9E8B+8EHmBZzW2ck953KaqLUvzPsdMG2IOPAomr\/gx\/eRQwScVzBefiEGo\\n\" +\n-        \"sN+rGfUt\/RNAHwWje1KuNDj21S84agQhN6hdYUnIMsvJLu\/9mOwUb9ff+AzTUfFr\\n\" +\n-        \"zyx2MJL4Cx59DkUUMESCfinlHUc21llQjFWmX\/zOoGY0X0qV\/YM\/GRsv1ZDFHw9o\\n\" +\n-        \"hQ6m8Ov7D9wB3TKZBI97sCyggjBfSeuYQlNbs99KWQECgYEA7IKNL0ME7FuIrKYu\\n\" +\n-        \"FCQ\/Duz1N3oQXLzrTGKUSU1qSbrU2Jwk4SfJ8ZYCW1TP6vZkaQsTXmXun3yyCAqZ\\n\" +\n-        \"hcOtDBhI+b7Wpmmyf6nb83oYJtzHMRQZ5qS+9vOBfV9Uf1za8XI4p90EqkFHByCF\\n\" +\n-        \"tHfjVbjK39zN4CvaO3tqpOaYtL0CgYEAxIrTAhGWy9nBsxf8QeqDou0rV5Cw50Kl\\n\" +\n-        \"kQsE7KLmjvrMaFFpUc5lgWoC+pm\/69VpNBUuN\/38YozwxVjVi\/nMJuuK150mhdWI\\n\" +\n-        \"B28FI7ORnFmVeSvTrP4mBX1ct2Tny9zpchXn3rpHR5NZUs7oBhjudHSfRMrHxeBs\\n\" +\n-        \"Kv2pr2s6uzkCgYAtrEh3iAm7WzHZpX3ghd9nknsIa5odTp5h8eeRAFI2Ss4vxneY\\n\" +\n-        \"w4ZMERwDZy1\/wnVBk9H5uNWMFxiKVQGww0j3vPjawe\/R0zeVT8gaDMn9N0WARNF7\\n\" +\n-        \"qPT3265196LptZTSa6xlPllYR6LfzXgEkeJk+3qyIIHheJZ8RikiDyYOQQKBgQC\/\\n\" +\n-        \"rxlegiMNC4KDldf7vanGxAKqcz5lPbXWQOX7mGC+f9HNx+Cs3VxYHDltiXgJnOju\\n\" +\n-        \"191s1HRK9WR5REt5KhY2uzB9WxJQItJ5VYiwqhhQYXqLY\/gdVv1kC0DayDndtMWk\\n\" +\n-        \"88JhklGkeAv83DikgbpGr9sJr6+oyFkWkLDmmfD82QKBgQCMgkZJzrdSNNlB0n5x\\n\" +\n-        \"xC3MzlsQ5aBJuUctnMfuyDi+11yLAuP1oLzGEJ7qEfFoGRO0V8zJWmHAfNhmVYEX\\n\" +\n-        \"ow5g0WbPT16GoRCiOAzq+ewH+TEELMF6HWqnDuTnCg28Jg0dw2kdVTqeyzKOQlLG\\n\" +\n-        \"ua9c2DY3PUTXQPNqLVhz+XxZKA==\";\n@@ -280,0 +212,1 @@\n+        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -305,1 +238,2 @@\n-        \"TiSXLpQ1Q9GvDpzngDzJzzY=\";\n+        \"TiSXLpQ1Q9GvDpzngDzJzzY=\\n\" +\n+        \"-----END PRIVATE KEY-----\";\n@@ -340,0 +274,1 @@\n+        \"-----BEGIN PRIVATE KEY-----\\n\" +\n@@ -365,1 +300,2 @@\n-        \"i1pnyMPaloBOhz3Y07sWXxCz\";\n+        \"i1pnyMPaloBOhz3Y07sWXxCz\\n\" +\n+        \"-----END PRIVATE KEY-----\";\n@@ -367,1 +303,1 @@\n-    static char passphrase[] = \"passphrase\".toCharArray();\n+    static char[] passphrase = \"passphrase\".toCharArray();\n@@ -377,1 +313,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -450,2 +386,1 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -457,5 +392,1 @@\n-        \/\/ import the trused cert\n-        ByteArrayInputStream is =\n-            new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n+        \/\/ generate certificate from cert string\n@@ -463,0 +394,3 @@\n+        Certificate trusedCert = pemDecoder.decode(trusedCertStr, X509Certificate.class);\n+\n+        \/\/ import the trused cert\n@@ -468,3 +402,1 @@\n-        is = new ByteArrayInputStream(caSignerStr.getBytes());\n-        Certificate caSignerCert = cf.generateCertificate(is);\n-        is.close();\n+        Certificate caSignerCert =pemDecoder.decode(caSignerStr, X509Certificate.class);\n@@ -473,3 +405,1 @@\n-        is = new ByteArrayInputStream(certIssuerStr.getBytes());\n-        Certificate certIssuerCert = cf.generateCertificate(is);\n-        is.close();\n+        Certificate certIssuerCert =pemDecoder.decode(certIssuerStr, X509Certificate.class);\n@@ -478,1 +408,2 @@\n-        PKCS8EncodedKeySpec priKeySpec = null;\n+        PKCS8EncodedKeySpec priKeySpec;\n+        Certificate keyCert;\n@@ -480,3 +411,2 @@\n-            priKeySpec = new PKCS8EncodedKeySpec(\n-                            Base64.getMimeDecoder().decode(serverPrivateKey));\n-            is = new ByteArrayInputStream(serverCertStr.getBytes());\n+            priKeySpec =pemDecoder.decode(serverPrivateKey, PKCS8EncodedKeySpec.class);\n+            keyCert = pemDecoder.decode(serverCertStr, X509Certificate.class);\n@@ -484,3 +414,2 @@\n-            priKeySpec = new PKCS8EncodedKeySpec(\n-                            Base64.getMimeDecoder().decode(clientPrivateKey));\n-            is = new ByteArrayInputStream(clientCertStr.getBytes());\n+            priKeySpec = pemDecoder.decode(clientPrivateKey, PKCS8EncodedKeySpec.class);\n+            keyCert = pemDecoder.decode(clientCertStr, X509Certificate.class);\n@@ -490,2 +419,0 @@\n-        Certificate keyCert = cf.generateCertificate(is);\n-        is.close();\n@@ -499,1 +426,2 @@\n-        CertPath path = cf.generateCertPath(Arrays.asList(chain));\n+        CertPath path = CertificateFactory.getInstance(\"X.509\")\n+                .generateCertPath(Arrays.asList(chain));\n@@ -534,1 +462,1 @@\n-    public static void main(String args[]) throws Exception {\n+    public static void main(String[] args) throws Exception {\n@@ -589,14 +517,12 @@\n-            serverThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\");\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n+            serverThread = new Thread(() -> {\n+                try {\n+                    doServerSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our server thread just died.\n+                     *\n+                     * Release the client, if not active already...\n+                     *\/\n+                    System.err.println(\"Server died...\");\n+                    serverReady = true;\n+                    serverException = e;\n@@ -604,1 +530,1 @@\n-            };\n+            });\n@@ -613,11 +539,9 @@\n-            clientThread = new Thread() {\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n+            clientThread = new Thread(() -> {\n+                try {\n+                    doClientSide();\n+                } catch (Exception e) {\n+                    \/*\n+                     * Our client thread just died.\n+                     *\/\n+                    System.err.println(\"Client died...\");\n+                    clientException = e;\n@@ -625,1 +549,1 @@\n-            };\n+            });\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/BasicConstraints.java","additions":68,"deletions":144,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -32,4 +33,2 @@\n-import java.net.*;\n-import java.util.*;\n-import java.io.*;\n-import javax.net.ssl.*;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n@@ -37,0 +36,1 @@\n+import java.security.PEMDecoder;\n@@ -38,1 +38,0 @@\n-import java.security.cert.CertificateFactory;\n@@ -41,2 +40,0 @@\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n@@ -216,0 +213,2 @@\n+    private static final PEMDecoder pemDecoder = PEMDecoder.of();\n+\n@@ -256,2 +255,0 @@\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n@@ -263,0 +260,2 @@\n+        \/\/ generate certificate from cert string\n+        Certificate trustedCert = pemDecoder.decode(trustedCertStr, X509Certificate.class);\n@@ -264,5 +263,1 @@\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(trustedCertStr.getBytes())) {\n-            Certificate trustedCert = cf.generateCertificate(is);\n-            ks.setCertificateEntry(\"RSA Export Signer\", trustedCert);\n-        }\n+        ks.setCertificateEntry(\"RSA Export Signer\", trustedCert);\n@@ -279,2 +274,0 @@\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n@@ -282,19 +275,4 @@\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(targetCertStr.getBytes())) {\n-            chain[0] = (X509Certificate)cf.generateCertificate(is);\n-        }\n-\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(intermediateCertStr.getBytes())) {\n-            chain[1] = (X509Certificate)cf.generateCertificate(is);\n-        }\n-\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(compromisedCertStr.getBytes())) {\n-            chain[2] = (X509Certificate)cf.generateCertificate(is);\n-        }\n-\n-        try (ByteArrayInputStream is =\n-                new ByteArrayInputStream(untrustedCrossCertStr.getBytes())) {\n-            chain[3] = (X509Certificate)cf.generateCertificate(is);\n-        }\n+        chain[0] = pemDecoder.decode(targetCertStr, X509Certificate.class);\n+        chain[1] = pemDecoder.decode(intermediateCertStr, X509Certificate.class);\n+        chain[2] = pemDecoder.decode(compromisedCertStr, X509Certificate.class);\n+        chain[3] = pemDecoder.decode(untrustedCrossCertStr, X509Certificate.class);\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/ComodoHacker.java","additions":14,"deletions":36,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/timeout=240 ConciseJarsigner\n+ * @run main\/timeout=960 ConciseJarsigner\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/ConciseJarsigner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run testng InsufficientSectionDelimiter\n+ * @run testng\/timeout=480 InsufficientSectionDelimiter\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/InsufficientSectionDelimiter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8309841\n+ * @bug 8309841 8365559\n@@ -43,0 +43,2 @@\n+    private static final String WEAK_UNSIGNED\n+            = \"The jar will be treated as unsigned, because it is signed with a weak algorithm that is now disabled\";\n@@ -45,0 +47,5 @@\n+        t8309841();\n+        t8365559();\n+    }\n+\n+    static void t8309841() throws Exception {\n@@ -92,0 +99,8 @@\n+    }\n+\n+    static void t8365559() throws Exception {\n+        JarUtils.createJarFile(\n+                Path.of(\"c.jar\"),\n+                Path.of(\".\"),\n+                Files.writeString(Path.of(\"c\"), \"c\"));\n+        SecurityTools.keytool(\"-genkeypair -storepass changeit -keystore ks -alias w -dname CN=w -keyalg ec\");\n@@ -93,0 +108,12 @@\n+        \/\/ Sign the JAR using an already disabled signature algorithm SHA1withECDSA.\n+        \/\/ The file can still be signed but verification will treat it as unsigned.\n+        SecurityTools.jarsigner(\"-storepass changeit -keystore ks c.jar w -sigalg SHA1withECDSA\")\n+                        .shouldContain(\"the -sigalg option is considered a security risk and is disabled.\");\n+\n+        SecurityTools.jarsigner(\"-verify c.jar\")\n+                .shouldContain(WEAK_UNSIGNED)\n+                .shouldNotContain(NONEXISTENT_ENTRIES_FOUND);\n+        SecurityTools.jarsigner(\"-verify -verbose c.jar\")\n+                .shouldContain(WEAK_UNSIGNED)\n+                .shouldNotContain(NONEXISTENT_ENTRIES_FOUND)\n+                .shouldNotContain(\"Warning: nonexistent signed entries:\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/RemovedFiles.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n- * @run main\/othervm RestrictedAlgo RESTRICT\n- * @run main\/othervm RestrictedAlgo NO_RESTRICT\n+ * @run main\/othervm\/timeout=480 RestrictedAlgo RESTRICT\n+ * @run main\/othervm\/timeout=480 RestrictedAlgo NO_RESTRICT\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/RestrictedAlgo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run testng SectionNameContinuedVsLineBreak\n+ * @run testng\/timeout=480 SectionNameContinuedVsLineBreak\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/SectionNameContinuedVsLineBreak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n- * @run main\/timeout=600 TimestampCheck\n+ * @run main\/timeout=2400 TimestampCheck\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/TimestampCheck.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/timeout=300 GenerateAll\n+ * @run testng\/timeout=1200 GenerateAll\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/GenerateAll.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main ReadJar\n+ * @run main\/timeout=480 ReadJar\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/ReadJar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main TrustedCert\n+ * @run main\/timeout=480 TrustedCert\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakecacerts\/TrustedCert.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @enablePreview\n@@ -30,3 +31,10 @@\n-import java.io.ByteArrayInputStream;\n-import java.security.*;\n-import java.security.cert.*;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PEMDecoder;\n+import java.security.Provider;\n+import java.security.PublicKey;\n+import java.security.Security;\n+import java.security.SignatureException;\n+import java.security.cert.CRLException;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n@@ -147,2 +155,1 @@\n-    private static void setup() throws CertificateException, CRLException {\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+    private static void setup() {\n@@ -150,0 +157,1 @@\n+        final PEMDecoder pemDecoder = PEMDecoder.of();\n@@ -151,3 +159,1 @@\n-        ByteArrayInputStream inputStream =\n-                new ByteArrayInputStream(crlStr.getBytes());\n-        crl = (X509CRL)cf.generateCRL(inputStream);\n+        crl = pemDecoder.decode(crlStr, X509CRL.class);\n@@ -156,4 +162,3 @@\n-        inputStream = new ByteArrayInputStream(crlIssuerCertStr.getBytes());\n-        X509Certificate cert\n-                = (X509Certificate)cf.generateCertificate(inputStream);\n-        crlIssuerCertPubKey = cert.getPublicKey();\n+        crlIssuerCertPubKey = pemDecoder.decode(crlIssuerCertStr, X509Certificate.class)\n+                .getPublicKey();\n+\n@@ -162,2 +167,3 @@\n-        inputStream = new ByteArrayInputStream(selfSignedCertStr.getBytes());\n-        selfSignedCertPubKey = cf.generateCertificate(inputStream).getPublicKey();\n+        selfSignedCertPubKey = pemDecoder.decode(selfSignedCertStr, X509Certificate.class)\n+                .getPublicKey();\n+\n","filename":"test\/jdk\/sun\/security\/x509\/X509CRLImpl\/Verify.java","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -XX:+UsePerfData TestJcmdSanity\n+ * @run main\/othervm\/timeout=480 -XX:+UsePerfData TestJcmdSanity\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdSanity.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main BasicLauncherTest\n+ * @run main\/timeout=480 BasicLauncherTest\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/BasicLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,6 +165,1 @@\n-            if (doSleep) {\n-                launcher.addVMArgs(Utils.getTestJavaOpts());\n-            } else {\n-                \/\/ Don't allow use of SerialGC. See JDK-8313655.\n-                launcher.addVMArgs(Utils.getFilteredTestJavaOpts(\"-XX:\\\\+UseSerialGC\"));\n-            }\n+            launcher.addVMArgs(Utils.getTestJavaOpts());\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/JShellHeapDumpTest.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng Bug8139107\n+ * @run testng\/timeout=480 Bug8139107\n@@ -59,1 +59,0 @@\n-\n","filename":"test\/jdk\/sun\/util\/resources\/TimeZone\/Bug8139107.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-            final List<ImageReader.Node> children = parent.getChildren();\n-            if (children == null || children.isEmpty()) {\n+            final List<String> childNames = parent.getChildNames().toList();\n+            if (childNames.isEmpty()) {\n@@ -77,2 +77,2 @@\n-            for (final ImageReader.Node child : children) {\n-                final boolean unique = uniqueChildren.add(child);\n+            for (final String childName : childNames) {\n+                final boolean unique = uniqueChildren.add(reader.findNode(childName));\n@@ -81,1 +81,1 @@\n-                            + child + \" under \" + parent + \" from image \" + imagePath);\n+                            + childName + \" under \" + parent + \" from image \" + imagePath);\n","filename":"test\/jdk\/tools\/jimage\/ImageReaderDuplicateChildNodesTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink100Modules\n+ * @run main\/othervm\/timeout=480 -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink100Modules\n","filename":"test\/jdk\/tools\/jlink\/JLink100Modules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,9 @@\n+import tests.JImageGenerator;\n+\n+import java.io.BufferedOutputStream;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n@@ -27,3 +36,4 @@\n-import java.util.Arrays;\n-import java.util.StringJoiner;\n-import java.util.spi.ToolProvider;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n@@ -31,1 +41,5 @@\n-import tests.JImageGenerator;\n+import static java.lang.classfile.ClassFile.ACC_MANDATED;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_void;\n@@ -39,2 +53,1 @@\n- * @library ..\/lib\n- * @enablePreview\n+ * @library ..\/lib \/test\/lib\n@@ -42,3 +55,0 @@\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jmod\n@@ -46,1 +56,0 @@\n- *          jdk.compiler\n@@ -48,1 +57,1 @@\n- * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink20000Packages\n+ * @run main\/othervm -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink20000Packages\n@@ -51,11 +60,3 @@\n-    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n-            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n-\n-    static void report(String command, String[] args) {\n-        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n-    }\n-\n-    static void javac(String[] args) {\n-        report(\"javac\", args);\n-        JAVAC_TOOL.run(System.out, System.err, args);\n-    }\n+    private static final ClassDesc CD_System = ClassDesc.of(\"java.lang.System\");\n+    private static final ClassDesc CD_PrintStream = ClassDesc.of(\"java.io.PrintStream\");\n+    private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n@@ -64,1 +65,4 @@\n-        Path src = Paths.get(\"bug8321413\");\n+        String moduleName = \"bug8321413x\";\n+        Path src = Paths.get(moduleName);\n+        Files.createDirectories(src);\n+        Path jarPath = src.resolve(moduleName +\".jar\");\n@@ -66,7 +70,0 @@\n-        Path mainModulePath = src.resolve(\"bug8321413x\");\n-\n-        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n-\n-        for (int i = 0; i < 20000; i++) {\n-            String packageName = \"p\" + i;\n-            String className = \"C\" + i;\n@@ -74,8 +71,27 @@\n-            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n-\n-            StringBuilder classContent = new StringBuilder(\"package \");\n-            classContent.append(packageName).append(\";\\n\");\n-            classContent.append(\"class \").append(className).append(\" {}\\n\");\n-            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n-\n-            mainModuleInfoContent.add(packageName);\n+        \/\/ Generate module with 20000 classes in unique packages\n+        try (JarOutputStream out = new JarOutputStream(new BufferedOutputStream(Files.newOutputStream(jarPath)))) {\n+            Set<String> packageNames = new HashSet<>();\n+            for (int i = 0; i < 20_000; i++) {\n+                String packageName = \"p\" + i;\n+                packageNames.add(packageName);\n+\n+                \/\/ Generate a class file for this package\n+                String className = \"C\" + i;\n+                byte[] classData = ClassFile.of().build(ClassDesc.of(packageName, className), cb -> {});\n+                out.putNextEntry(new JarEntry(packageName + \"\/\" + className +\".class\"));\n+                out.write(classData);\n+            }\n+\n+            \/\/ Write the main class\n+            out.putNextEntry(new JarEntry(\"testpackage\/JLink20000PackagesTest.class\"));\n+            out.write(generateMainClass());\n+            packageNames.add(\"testpackage\");\n+\n+            \/\/ Write the module descriptor\n+            byte[] moduleInfo = ClassFile.of().buildModule(ModuleAttribute.of(\n+                    ModuleDesc.of(moduleName), mab -> {\n+                        mab.requires(ModuleDesc.of(\"java.base\"), ACC_MANDATED, null);\n+                        packageNames.forEach(pkgName -> mab.exports(PackageDesc.of(pkgName), 0));\n+                    }));\n+            out.putNextEntry(new JarEntry(\"module-info.class\"));\n+            out.write(moduleInfo);\n@@ -84,24 +100,0 @@\n-        \/\/ create module reading the generated modules\n-        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n-        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n-\n-        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n-        Files.createDirectories(mainClassDir);\n-\n-        Files.writeString(mainClassDir.resolve(\"JLink20000PackagesTest.java\"), \"\"\"\n-                package testpackage;\n-\n-                public class JLink20000PackagesTest {\n-                    public static void main(String[] args) throws Exception {\n-                        System.out.println(\"JLink20000PackagesTest started.\");\n-                    }\n-                }\n-                \"\"\");\n-\n-        String out = src.resolve(\"out\").toString();\n-        javac(new String[]{\n-                \"-d\", out,\n-                \"--module-source-path\", src.toString(),\n-                \"--module\", \"bug8321413x\"\n-        });\n-\n@@ -109,1 +101,0 @@\n-                .modulePath(out)\n@@ -111,1 +102,2 @@\n-                .addMods(\"bug8321413x\")\n+                .addJars(jarPath)\n+                .addMods(moduleName)\n@@ -120,0 +112,1 @@\n+                \/\/ Option is useful to verify build image\n@@ -121,1 +114,1 @@\n-                \"-m\", \"bug8321413x\/testpackage.JLink20000PackagesTest\");\n+                \"-m\", moduleName + \"\/testpackage.JLink20000PackagesTest\");\n@@ -129,0 +122,18 @@\n+\n+    \/**\n+     * Generate test class with main() does\n+     * System.out.println(\"JLink20000PackagesTest started.\");\n+     *\/\n+    private static byte[] generateMainClass() {\n+        return ClassFile.of().build(ClassDesc.of(\"testpackage\", \"JLink20000PackagesTest\"),\n+                cb -> {\n+                    cb.withMethod(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                            ACC_PUBLIC | ACC_STATIC, mb -> {\n+                                mb.withCode(cob -> cob.getstatic(CD_System, \"out\", CD_PrintStream)\n+                                        .ldc(\"JLink20000PackagesTest started.\")\n+                                        .invokevirtual(CD_PrintStream, \"println\", MTD_void_String)\n+                                        .return_()\n+                                );\n+                            });\n+                });\n+    }\n","filename":"test\/jdk\/tools\/jlink\/JLink20000Packages.java","additions":77,"deletions":66,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n- * @run main\/othervm -Xmx1g JLinkTest\n+ * @run main\/othervm\/timeout=480 -Xmx1g JLinkTest\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n- * @run junit\/othervm\/timeout=180 -Xmx1g IncludeLocalesPluginTest\n+ * @run junit\/othervm\/timeout=720 -Xmx1g IncludeLocalesPluginTest\n","filename":"test\/jdk\/tools\/jlink\/plugins\/IncludeLocalesPluginTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n+ * @run main\/othervm\/timeout=480 -Xmx1g JavaSEReproducibleTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JavaSEReproducibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/helpers-test\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,5 +45,4 @@\n-    public static void testClassFilePath(String... args) {\n-        var appDesc = args[0];\n-        var expectedClassFilePath = Path.of(args[1]);\n-        TKit.assertEquals(expectedClassFilePath.toString(), JavaAppDesc.parse(\n-                appDesc).classFilePath().toString(), null);\n+    public static void testClassFilePath(String appDesc, String expectedClassFile) {\n+        var expectedClassFilePath = Path.of(expectedClassFile);\n+        TKit.assertEquals(expectedClassFilePath.toString(),\n+                JavaAppDesc.parse(appDesc).classFilePath().toString(), null);\n@@ -58,0 +57,6 @@\n+            createTestCase(\"bye.jar:!\", appDesc -> {\n+                return appDesc\n+                        .setBundleFileName(\"bye.jar\")\n+                        .setClassName(\"Hello\")\n+                        .setWithMainClass(true);\n+            }),\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JavaAppDescTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+    public String name() {\n+        return name;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.OptionalInt;\n@@ -814,0 +815,4 @@\n+    public Executor.Result executeIgnoreExitCode() {\n+        return execute(OptionalInt.empty());\n+    }\n+\n@@ -819,0 +824,4 @@\n+        return execute(OptionalInt.of(expectedExitCode));\n+    }\n+\n+    private Executor.Result execute(OptionalInt expectedExitCode) {\n@@ -855,1 +864,2 @@\n-        if (expectedExitCode == 0 && !isImagePackageType()) {\n+        if (expectedExitCode.isPresent() && expectedExitCode.orElseThrow() == 0\n+                && !isImagePackageType()) {\n@@ -863,1 +873,6 @@\n-        Executor.Result result = copy.createExecutor().execute(expectedExitCode);\n+        Executor.Result result;\n+        if (expectedExitCode.isEmpty()) {\n+            result = copy.createExecutor().executeWithoutExitCodeCheck();\n+        } else {\n+            result = copy.createExecutor().execute(expectedExitCode.orElseThrow());\n+        }\n@@ -867,1 +882,2 @@\n-        if (expectedExitCode == 0 && isImagePackageType()) {\n+        if (expectedExitCode.isPresent() && expectedExitCode.orElseThrow() == 0\n+                && isImagePackageType()) {\n@@ -875,1 +891,1 @@\n-        if (result.exitCode() == 0) {\n+        if (result.exitCode() == 0 && expectedExitCode.isPresent()) {\n@@ -1177,4 +1193,9 @@\n-            TKit.assertStringListEquals(\n-                    addLauncherNames().stream().sorted().toList(),\n-                    aif.addLaunchers().keySet().stream().sorted().toList(),\n-                    \"Check additional launcher names\");\n+            \/\/ Don't compare the add launchers configured on the command line with the\n+            \/\/ add launchers listed in the `.jpackage.xml` file if the latter comes from\n+            \/\/ a predefined app image.\n+            if (!hasArgument(\"--app-image\")) {\n+                TKit.assertStringListEquals(\n+                        addLauncherNames().stream().sorted().toList(),\n+                        aif.addLaunchers().keySet().stream().sorted().toList(),\n+                        \"Check additional launcher names\");\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+        APP_DIR(\"app-dir\"),\n@@ -82,1 +83,1 @@\n-        private final static Map<String, StartupDirectory> VALUE_MAP =\n+        private static final Map<String, StartupDirectory> VALUE_MAP =\n@@ -150,1 +151,8 @@\n-            return Optional.of(StartupDirectory.DEFAULT);\n+            var value = Optional.ofNullable(cmd.getArgumentValue(optionName())).filter(optionValue -> {\n+                return !optionValue.startsWith(\"-\");\n+            });\n+            if (value.isPresent()) {\n+                return value.flatMap(StartupDirectory::parse);\n+            } else {\n+                return Optional.of(StartupDirectory.DEFAULT);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -517,0 +517,3 @@\n+                case APP_DIR -> {\n+                    return cmd.pathToPackageFile(appLayout.appDirectory());\n+                }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -216,1 +216,11 @@\n-            return installDir;\n+            switch (startupDirectory) {\n+                case DEFAULT -> {\n+                    return installDir;\n+                }\n+                case APP_DIR -> {\n+                    return ApplicationLayout.windowsAppImage().resolveAt(installDir).appDirectory();\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WinShortcutVerifier.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class LinuxApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static LinuxApplicationLayout createLayout() {\n+        return LinuxApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"libapplauncher.so\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test LinuxApplicationLayout\n+ * @requires (os.family == \"linux\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LinuxApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class MacApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static MacApplicationLayout createLayout() {\n+        return MacApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"Contents\/runtime\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test MacApplicationLayoutTest\n+ * @requires (os.family == \"mac\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/MacApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.MacApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class BuildEnvTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"image\"})\n+    public void testUnresolvedAppImageLayout(Path appImageDir) {\n+        final var rootDir = Path.of(\"\");\n+\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory());\n+\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @Test\n+    public void testResolvedAppImageLayout() {\n+        final var rootDir = Path.of(\"\/oof\");\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final var layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true, BuildEnvTest.class, layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\/foo\/bar\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"\/foo\/bar\"})\n+    public void test_withAppImageDir(Path appImageDir) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var layout = RuntimeLayout.DEFAULT;\n+        final var env = BuildEnv.withAppImageDir(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, layout), appImageDir);\n+\n+        assertNotSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(appImageDir, env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_withAppImageLayout(boolean resolved) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final AppImageLayout layout;\n+        if (resolved) {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        } else {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory();\n+        }\n+\n+        final var env = BuildEnv.withAppImageLayout(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, RuntimeLayout.DEFAULT), layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @Test\n+    public void test_asApplicationLayout() {\n+        final var rootDir = Path.of(\"r\");\n+\n+        assertTrue(BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT).asApplicationLayout().isEmpty());\n+\n+        var layout = ApplicationLayout.build().setAll(\"foo\").create();\n+        assertSame(layout, BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, layout).asApplicationLayout().orElseThrow());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/BuildEnvTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,872 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.CopyAppImageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.NoArgTaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.TaskContext;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class PackagingPipelineTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testBuildApplication(boolean withRuntimeBuilder, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1, withRuntimeBuilder ? Optional.of(TestRuntimeBuilder.INSTANCE) : Optional.empty());\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(app).create();\n+\n+        \/\/ Build application image in `env.appImageDir()` directory.\n+        final var builder = buildPipeline();\n+        if (app.runtimeBuilder().isEmpty()) {\n+            builder.task(BuildApplicationTaskID.RUNTIME).noaction().add();\n+        }\n+\n+        builder.create().execute(env, app);\n+\n+        assertEquals(app.appImageDirName(), env.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, app);\n+        }));\n+\n+        List<TaskID> expectedActions = new ArrayList<>();\n+        if (app.runtimeBuilder().isPresent()) {\n+            expectedActions.add(BuildApplicationTaskID.RUNTIME);\n+        }\n+        expectedActions.addAll(List.of(BuildApplicationTaskID.LAUNCHERS, BuildApplicationTaskID.CONTENT));\n+\n+        assertEquals(expectedActions, executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage;\n+        if (withRuntimeBuilder) {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT)\n+                    .file(\"runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+        } else {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT);\n+        }\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCopyApplication(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var srcApp = createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE);\n+\n+        final var srcEnv = buildEnv(workDir.resolve(\"build\")).appImageDirFor(srcApp).create();\n+\n+        \/\/ Build application image in `srcEnv.appImageDir()` directory.\n+        buildPipeline().create().execute(srcEnv, srcApp);\n+\n+        final var dstApp = createApp(TEST_LAYOUT_2, TestRuntimeBuilder.INSTANCE);\n+\n+        final var dstEnv = buildEnv(workDir.resolve(\"build-2\"))\n+                .appImageLayout(dstApp.imageLayout().resolveAt(workDir.resolve(\"a\/b\/c\")))\n+                .create();\n+\n+        \/\/ Copy application image from `srcEnv.appImageDir()` into `dstEnv.appImageDir()`\n+        \/\/ with layout transformation.\n+        \/\/ This test exercises flexibility of the packaging pipeline.\n+        final var builder = buildPipeline()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).applicationAction(cfg -> {\n+                    assertSame(dstApp, cfg.app());\n+                    assertEquals(dstEnv.appImageDir(), cfg.env().appImageLayout().rootDirectory());\n+                    assertFalse(Files.exists(dstEnv.appImageDir()));\n+                    PackagingPipeline.copyAppImage(srcEnv.appImageLayout(), cfg.env().appImageLayout(), false);\n+                }).add();\n+\n+        \/\/ Disable the default \"build application image\" actions of the tasks which\n+        \/\/ are the dependencies of `PrimaryTaskID.BUILD_APPLICATION_IMAGE` task as\n+        \/\/ their output will be overwritten in the custom action of this task.\n+        builder.taskGraphSnapshot().getAllTailsOf(PrimaryTaskID.BUILD_APPLICATION_IMAGE).forEach(taskId -> {\n+            builder.task(taskId).noaction().add();\n+        });\n+\n+        builder.create().execute(dstEnv, dstApp);\n+\n+        AppImageLayout.toPathGroup(dstEnv.appImageLayout()).paths().forEach(path -> {\n+            assertTrue(Files.exists(path));\n+        });\n+\n+        assertEquals(Path.of(\"c\"), dstEnv.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dstEnv, dstApp);\n+        }));\n+\n+        assertEquals(List.of(PrimaryTaskID.BUILD_APPLICATION_IMAGE), executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(\"q\/launchers\/my-launcher\", TestLauncher.CONTENT)\n+                .file(\"qqq\/runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(dstEnv.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCreatePackage(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(pkg).create();\n+\n+        final var builder = buildPipeline();\n+\n+        \/\/ Will create an app image in `env.appImageDir()` directory with `pkg.appImageLayout()` layout.\n+        \/\/ Will convert the created app image into a package.\n+        builder.create().execute(env, pkg, outputDir);\n+\n+        final var expected = createTestPackageFileContents(env.appImageLayout());\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"testCreatePackage:\\n---\\n%s\\n---\", actual));\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, pkg, outputDir);\n+        }));\n+\n+        assertEquals(List.of(\n+                BuildApplicationTaskID.RUNTIME,\n+                BuildApplicationTaskID.LAUNCHERS,\n+                BuildApplicationTaskID.CONTENT,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE\n+        ), executedTaskActions);\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testCreateRuntimeInstaller(boolean transformLayout, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final AppImageLayout srcLayout;\n+        if (transformLayout) {\n+            \/\/ Create an application layout such that the runtime directory doesn't\n+            \/\/ have a common parent with other directories otherwise the runtime directory\n+            \/\/ will be skipped when copying the app image layout as path groups because\n+            \/\/ the destination app image layout is of type RuntimeLayout and have only\n+            \/\/ the runtime directory.\n+            srcLayout = ApplicationLayout.build()\n+                    .launchersDirectory(\"launchers\")\n+                    .appDirectory(\"lib\")\n+                    .runtimeDirectory(\"runtime\")\n+                    .appModsDirectory(\"lib\")\n+                    .contentDirectory(\"lib\")\n+                    .desktopIntegrationDirectory(\"lib\")\n+                    .create();\n+        } else {\n+            srcLayout = RuntimeLayout.DEFAULT;\n+        }\n+\n+        \/\/ Create a runtime image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(srcLayout)\n+                .appImageDir(workDir.resolve(\"rt\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+\n+        final var pipeline = buildPackage(createApp(\n+                RuntimeLayout.DEFAULT.resolveAt(TEST_INSTALL_DIR).resetRootDirectory())).create();\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        createAndVerifyPackage(buildPipeline(), pipeline, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreateRuntimeInstaller(%s)\", transformLayout), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    private enum ExternalAppImageMode {\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant equals to `Package.appImageLayout()`.\n+        COPY_FROM_BUILD_ENV,\n+\n+        \/\/ Copy predefined app image from some directory.\n+        \/\/ Layout of the predefined app image is `Package.appImageLayout()`.\n+        COPY,\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant is NOT equal to `Package.appImageLayout()`.\n+        TRANSFORM_FROM_BUILD_ENV,\n+        ;\n+\n+        static final Set<ExternalAppImageMode> FROM_BUILD_ENV = Set.of(\n+                COPY_FROM_BUILD_ENV, TRANSFORM_FROM_BUILD_ENV);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ExternalAppImageMode.class)\n+    void testCreatePackageFromExternalAppImage(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout;\n+        final ExpectedAppImage expectedAppImage;\n+        if (ExternalAppImageMode.TRANSFORM_FROM_BUILD_ENV == mode) {\n+            appLayout = TEST_LAYOUT_2_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"q\/launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"qqq\/runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        } else {\n+            appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        }\n+\n+        final BuildEnv env;\n+        final Path predefinedAppImage;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImage = env.appImageDir();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            final var externalAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(externalAppImageLayout);\n+            TestLauncher.INSTANCE.create(externalAppImageLayout);\n+            predefinedAppImage = externalAppImageLayout.rootDirectory();\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImage)\n+                .create();\n+\n+        createAndVerifyPackage(buildPipeline(), pkg, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names={\"COPY\", \"COPY_FROM_BUILD_ENV\"})\n+    void testCreatePackageFromExternalAppImageNoCopyAction(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+\n+        final BuildEnv env;\n+        final ApplicationLayout predefinedAppImageLayout;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImageLayout = env.asApplicationLayout().orElseThrow();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            predefinedAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(predefinedAppImageLayout);\n+            TestLauncher.INSTANCE.create(predefinedAppImageLayout);\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImageLayout.rootDirectory())\n+                .create();\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+\n+        final var builder = buildPipeline().configuredTasks().filter(task -> {\n+            return CopyAppImageTaskID.COPY.equals(task.task());\n+        }).findFirst().orElseThrow().noaction().add();\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        builder.create().execute(startupParameters);\n+\n+        final var expected = createTestPackageFileContents(predefinedAppImageLayout);\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\",\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), actual));\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(predefinedAppImageLayout.unresolve().launchersDirectory().resolve(\"my-launcher\"), TestLauncher.CONTENT)\n+                .file(predefinedAppImageLayout.unresolve().runtimeDirectory().resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(pkg.predefinedAppImage().orElseThrow()));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+        assertEquals(List.of(\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE), actualExecutedTaskActions);\n+    }\n+\n+    @Test\n+    void testCreatePackageFromExternalAppImageWithoutExternalAppImageError(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var env = setupBuildEnvForExternalAppImage(workDir);\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR)).create();\n+        final var pipeline = buildPipeline().create();\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, pkg, workDir));\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_RuntimeException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new RuntimeException(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_PackagerException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new PackagerException(\"param.vendor.default\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_Exception() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new Exception(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, PackagerException.class, () -> {\n+            rethrowUnchecked(expectedException);\n+        });\n+        assertSame(expectedException, ex.getCause());\n+    }\n+\n+    @Test\n+    void testAppImageAction() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).appImageAction(ctx -> {\n+                    assertSame(app, ctx.app());\n+                    assertSame(env, ctx.env());\n+                    executed[0] = true;\n+                }).add().create().execute(env, app);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testAppImageActionWithPackage() throws PackagerException, IOException {\n+\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        final var builder = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.PACKAGE).add();\n+\n+        final var startupParameters = builder.createStartupParameters(env,  pkg,  Path.of(\"\"));\n+\n+        builder.task(PrimaryTaskID.PACKAGE).appImageAction(ctx -> {\n+            assertSame(pkg.app(), ctx.app());\n+            assertSame(startupParameters.packagingEnv(), ctx.env());\n+            executed[0] = true;\n+        }).add().create().execute(startupParameters);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testPackageActionWithApplication() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).packageAction(ctx -> {\n+                    throw new AssertionError();\n+                }).add().create();\n+\n+        \/\/ If the pipeline is building an application, it can not execute actions that take a package as an argument.\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, app));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testContextMapper(boolean allowAll) throws PackagerException, IOException {\n+\n+        var builder = PackagingPipeline.buildStandard().contextMapper(ctx -> {\n+            return new TaskContext() {\n+                @Override\n+                public boolean test(TaskID task) {\n+                    return allowAll;\n+                }\n+\n+                @Override\n+                public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+                    if (!allowAll) {\n+                        throw new AssertionError();\n+                    }\n+                    ctx.execute(taskAction);\n+                }\n+            };\n+        });\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dummyBuildEnv(), createApp(TEST_LAYOUT_1));\n+        }));\n+\n+        List<TaskID> expectedExecutedTaskActions;\n+\n+        if (allowAll) {\n+            expectedExecutedTaskActions = List.of(\n+                    BuildApplicationTaskID.RUNTIME,\n+                    BuildApplicationTaskID.LAUNCHERS,\n+                    BuildApplicationTaskID.CONTENT,\n+                    BuildApplicationTaskID.APP_IMAGE_FILE,\n+                    CopyAppImageTaskID.COPY,\n+                    PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT);\n+        } else {\n+            expectedExecutedTaskActions = List.of();\n+        }\n+\n+        assertEquals(expectedExecutedTaskActions, actualExecutedTaskActions);\n+    }\n+\n+    public static List<PackagingPipeline.TaskID> dryRun(PackagingPipeline.Builder builder,\n+            Consumer<PackagingPipeline.Builder> callback) {\n+\n+        List<PackagingPipeline.TaskID> executedTaskActions = new ArrayList<>();\n+        builder.configuredTasks().filter(PackagingPipeline.Builder.TaskBuilder::hasAction).forEach(taskBuilder -> {\n+            var taskId = taskBuilder.task();\n+            taskBuilder.action(() -> {\n+                executedTaskActions.add(taskId);\n+            }).add();\n+        });\n+\n+        callback.accept(builder);\n+\n+        return executedTaskActions;\n+    }\n+\n+    private static Exception testExceptionRethrow(Exception expectedException,\n+            Class<? extends Exception> expectedCatchExceptionType,\n+            NoArgTaskAction throwAction) throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).action(throwAction).add().create();\n+\n+        return assertThrowsExactly(expectedCatchExceptionType, () -> pipeline.execute(env,  app));\n+    }\n+\n+    private static BuildEnv setupBuildEnvForExternalAppImage(Path workDir) throws ConfigException {\n+        \/\/ Create an app image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(TEST_LAYOUT_1.resolveAt(Path.of(\"a\/b\/c\")).resetRootDirectory())\n+                .appImageDir(workDir.resolve(\"app-image\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+        TestLauncher.INSTANCE.create((ApplicationLayout)env.appImageLayout());\n+\n+        return env;\n+    }\n+\n+    private static void createAndVerifyPackage(PackagingPipeline.Builder builder, Package pkg,\n+            BuildEnv env, Path outputDir, String logMsgHeader, ExpectedAppImage expectedAppImage,\n+            TaskID... expectedExecutedTaskActions) throws PackagerException, IOException {\n+        Objects.requireNonNull(logMsgHeader);\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        assertNotSameAppImageDirs(env, startupParameters.packagingEnv());\n+\n+        \/\/ Will create an app image in `startupParameters.packagingEnv().appImageDir()` directory\n+        \/\/ with `pkg.appImageLayout()` layout using an app image (runtime image) from `env.appImageDir()` as input.\n+        \/\/ Will convert the created app image into a package.\n+        \/\/ Will not overwrite the contents of `env.appImageDir()` directory.\n+        builder.create().execute(startupParameters);\n+\n+        final var packagingAppImageDir = startupParameters.packagingEnv().appImageDir();\n+\n+        final var expected = createTestPackageFileContents(pkg.appImageLayout().resolveAt(packagingAppImageDir));\n+\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\", logMsgHeader, actual));\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(packagingAppImageDir));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+\n+        assertEquals(List.of(expectedExecutedTaskActions), actualExecutedTaskActions);\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout) {\n+        return createApp(appImageLayout, Optional.empty());\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, RuntimeBuilder runtimeBuilder) {\n+        return createApp(appImageLayout, Optional.of(runtimeBuilder));\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, Optional<RuntimeBuilder> runtimeBuilder) {\n+        Objects.requireNonNull(appImageLayout);\n+        Objects.requireNonNull(runtimeBuilder);\n+        if (appImageLayout.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new Application.Stub(\n+                \"foo\",\n+                \"My app\",\n+                \"1.0\",\n+                \"Acme\",\n+                \"copyright\",\n+                Optional.empty(),\n+                List.of(),\n+                appImageLayout,\n+                runtimeBuilder,\n+                List.of(),\n+                Map.of());\n+    }\n+\n+\n+    private static final class PackageBuilder {\n+        PackageBuilder(Application app) {\n+            this.app = Objects.requireNonNull(app);\n+        }\n+\n+        Package create() {\n+            return new Package.Stub(\n+                    app,\n+                    new PackageType() {},\n+                    \"the-package\",\n+                    \"My package\",\n+                    \"1.0\",\n+                    Optional.empty(),\n+                    Optional.empty(),\n+                    Optional.ofNullable(predefinedAppImage),\n+                    null,\n+                    TEST_INSTALL_DIR);\n+        }\n+\n+        PackageBuilder predefinedAppImage(Path v) {\n+            predefinedAppImage = v;\n+            return this;\n+        }\n+\n+        private Path predefinedAppImage;\n+        private final Application app;\n+    }\n+\n+\n+    private static PackageBuilder buildPackage(Application app) {\n+        return new PackageBuilder(app);\n+    }\n+\n+    private static BuildEnvBuilder buildEnv(Path rootDir) {\n+        return new BuildEnvBuilder(rootDir);\n+    }\n+\n+    private static BuildEnv dummyBuildEnv() {\n+        return BuildEnv.create(Path.of(\"foo\"), Optional.empty(), false, PackagingPipeline.class, RuntimeLayout.DEFAULT);\n+    }\n+\n+    private static PackagingPipeline.Builder buildPipeline() {\n+        return PackagingPipeline.buildStandard()\n+                \/\/ Disable building the app image file (.jpackage.xml) as we don't have launchers in the test app.\n+                .task(BuildApplicationTaskID.APP_IMAGE_FILE).noaction().add()\n+                .task(BuildApplicationTaskID.LAUNCHERS).applicationAction(cfg -> {\n+                    TestLauncher.INSTANCE.create(cfg.resolvedLayout());\n+                }).add()\n+                .task(PrimaryTaskID.PACKAGE).packageAction(cfg -> {\n+                    var str = createTestPackageFileContents(cfg.resolvedLayout());\n+                    var packageFile = cfg.outputDir().resolve(cfg.pkg().packageFileNameWithSuffix());\n+                    Files.createDirectories(packageFile.getParent());\n+                    Files.writeString(packageFile, str);\n+                }).add();\n+    }\n+\n+    private static String createTestPackageFileContents(AppImageLayout pkgLayout) throws IOException {\n+        return ExpectedAppImage.load(pkgLayout.rootDirectory()).toString();\n+    }\n+\n+    private static void assertNotSameAppImageDirs(BuildEnv a, BuildEnv b) {\n+        assertNotEquals(a.appImageDir(), b.appImageDir());\n+        assertEquals(a.buildRoot(), b.buildRoot());\n+        assertEquals(a.configDir(), b.configDir());\n+        assertEquals(a.resourceDir(), b.resourceDir());\n+    }\n+\n+\n+    private static final class TestRuntimeBuilder implements RuntimeBuilder {\n+        @Override\n+        public void create(AppImageLayout appImageLayout) {\n+            assertTrue(appImageLayout.isResolved());\n+            try {\n+                Files.createDirectories(appImageLayout.runtimeDirectory());\n+                Files.writeString(runtimeFile(appImageLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path runtimeFile(AppImageLayout appImageLayout) {\n+            return appImageLayout.runtimeDirectory().resolve(\"my-runtime\");\n+        }\n+\n+        static final String CONTENT = \"this is the runtime\";\n+\n+        static final TestRuntimeBuilder INSTANCE = new TestRuntimeBuilder();\n+    }\n+\n+\n+    private static final class TestLauncher {\n+        public void create(ApplicationLayout appLayout) {\n+            assertTrue(appLayout.isResolved());\n+            try {\n+                Files.createDirectories(appLayout.launchersDirectory());\n+                Files.writeString(launcherFile(appLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path launcherFile(ApplicationLayout appLayout) {\n+            return appLayout.launchersDirectory().resolve(\"my-launcher\");\n+        }\n+\n+        static final String CONTENT = \"this is the launcher\";\n+\n+        static final TestLauncher INSTANCE = new TestLauncher();\n+    }\n+\n+\n+    private static final class ExpectedAppImage {\n+\n+        static ExpectedAppImage build() {\n+            return new ExpectedAppImage(new HashSet<>());\n+        }\n+\n+        static ExpectedAppImage load(Path appImageRoot) throws IOException {\n+            try (var walk = Files.walk(appImageRoot)) {\n+                return new ExpectedAppImage(walk.sorted().map(path -> {\n+                    var relativePath = appImageRoot.relativize(path);\n+                    if (Files.isDirectory(path)) {\n+                        return new Directory(relativePath);\n+                    } else {\n+                        return new File(relativePath, toSupplier(() -> Files.readString(path)).get());\n+                    }\n+                }).collect(Collectors.toSet()));\n+            }\n+        }\n+\n+        ExpectedAppImage file(Path path, String content) {\n+            return add(new File(path, content));\n+        }\n+\n+        ExpectedAppImage file(String path, String content) {\n+            return file(Path.of(path), content);\n+        }\n+\n+        ExpectedAppImage dir(Path path) {\n+            return add(new Directory(path));\n+        }\n+\n+        ExpectedAppImage dir(String path) {\n+            return dir(Path.of(path));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return items.stream().map(AppImageItem::toString).sorted().collect(Collectors.joining(\"\\n\"));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(items);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if ((obj == null) || (getClass() != obj.getClass())) {\n+                return false;\n+            }\n+            ExpectedAppImage other = (ExpectedAppImage) obj;\n+            return Objects.equals(items, other.items);\n+        }\n+\n+        private ExpectedAppImage(Set<AppImageItem> items) {\n+            this.items = Objects.requireNonNull(items);\n+        }\n+\n+        private ExpectedAppImage add(AppImageItem v) {\n+            var path = v.path();\n+            if (path.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            items.add(v);\n+            while (path.getNameCount() > 1) {\n+                items.add(new Directory(path = path.getParent()));\n+            }\n+            return this;\n+        }\n+\n+        private interface AppImageItem {\n+            Path path();\n+        }\n+\n+        private record File(Path path, String content) implements AppImageItem {\n+\n+            File {\n+                Objects.requireNonNull(path);\n+                Objects.requireNonNull(content);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return String.format(\"%s[%s]\", path, content);\n+            }\n+        }\n+\n+        private record Directory(Path path) implements AppImageItem {\n+\n+            Directory {\n+                Objects.requireNonNull(path);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return path.toString();\n+            }\n+        }\n+\n+        private final Set<AppImageItem> items;\n+    }\n+\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1 = ApplicationLayout.build()\n+            .launchersDirectory(\"launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2 = ApplicationLayout.build()\n+            .launchersDirectory(\"q\/launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"qqq\/runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final Path TEST_INSTALL_DIR = Path.of(\"Acme\/My app\");\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_1.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_2.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":872,"deletions":0,"binary":false,"changes":872,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -27,1 +28,1 @@\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n@@ -32,0 +33,1 @@\n+import jdk.jpackage.internal.util.PathGroup;\n@@ -51,1 +53,1 @@\n-        final var pathGroup = AppImageLayout.toPathGroup(layout);\n+        final var pathGroup = toPathGroup(layout);\n@@ -59,1 +61,28 @@\n-        final var dir = Path.of(\"foo\/bar\");\n+        testResolveAt(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        testResolveAtRepeat(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        testUnresolve(new AppImageLayout.Stub(Path.of(\"runtime\")));\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        testEmptyRootDirectory(new AppImageLayout.Stub(Path.of(\"rt\")));\n+    }\n+\n+    public static void testResolveAt(AppImageLayout testee) {\n+\n+        var dir = Path.of(\"foo\/bar\");\n+\n+        assertLayout(testee.resolveAt(dir), true, testee, dir);\n+    }\n+\n+    public static void testResolveAtRepeat(AppImageLayout testee) {\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"b\/c\")).resolveAt(Path.of(\"a\"));\n@@ -61,1 +90,20 @@\n-        final var layout = new AppImageLayout.Stub(Path.of(\"\"), Path.of(\"runtime\"));\n+        assertLayout(resolvedLayout, true, testee, Path.of(\"a\/b\/c\"));\n+    }\n+\n+    public static void testUnresolve(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"foo\/bar\"));\n+        var layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        resolvedLayout = testee.resolveAt(Path.of(\"\").toAbsolutePath());\n+        layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        assertSame(testee, testee.unresolve());\n+    }\n@@ -63,1 +111,4 @@\n-        final var resolvedLayout = layout.resolveAt(dir);\n+    public static void testEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -65,1 +116,1 @@\n-        assertNotSame(layout, resolvedLayout);\n+        assertEmptyRootDirectory(testee);\n@@ -67,2 +118,25 @@\n-        assertEquals(dir.resolve(layout.rootDirectory()), resolvedLayout.rootDirectory());\n-        assertEquals(dir.resolve(layout.runtimeDirectory()), resolvedLayout.runtimeDirectory());\n+        final var resolved = testee.resolveAt(Path.of(\"t\"));\n+\n+        assertEmptyRootDirectory(resolved);\n+    }\n+\n+    private static void assertEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            var newLayout = testee.resetRootDirectory();\n+            assertLayout(newLayout, false, Path.of(\"\"), toPathGroup(testee));\n+        } else {\n+            assertSame(testee, testee.resetRootDirectory());\n+        }\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            AppImageLayout base, Path baseResolveAt) {\n+        assertLayout(actual, expectedResolved, baseResolveAt.resolve(base.rootDirectory()),\n+                toPathGroup(base).resolveAt(baseResolveAt));\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            Path expectedRootDir, PathGroup expectedPaths) {\n+        assertEquals(expectedResolved, actual.isResolved());\n+        assertEquals(expectedRootDir, actual.rootDirectory());\n+        assertEquals(expectedPaths, toPathGroup(actual));\n@@ -70,0 +144,1 @@\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java","additions":83,"deletions":8,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n@@ -31,2 +34,0 @@\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -39,1 +40,31 @@\n-    public void test(boolean move, Path tempDir) throws IOException {\n+    @Test\n+    public void testMove(@TempDir Path tempDir) throws IOException {\n+        test(true, tempDir);\n+    }\n+\n+    @Test\n+    public void testCopy(@TempDir Path tempDir) throws IOException {\n+        test(false, tempDir);\n+    }\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    private static void test(boolean move, Path tempDir) throws IOException {\n@@ -58,8 +89,1 @@\n-        final var layout = ApplicationLayout.build()\n-                .launchersDirectory(\"bin\")\n-                .appDirectory(\"lib\/app\")\n-                .runtimeDirectory(\"runtime\")\n-                .appModsDirectory(\"mods\")\n-                .contentDirectory(\"content\")\n-                .desktopIntegrationDirectory(\"lib\/apps\")\n-                .create();\n+        final var layout = createLayout();\n@@ -103,8 +127,9 @@\n-    @Test\n-    public void testMove(@TempDir Path tempDir) throws IOException {\n-        test(true, tempDir);\n-    }\n-\n-    @Test\n-    public void testCopy(@TempDir Path tempDir) throws IOException {\n-        test(false, tempDir);\n+    public static ApplicationLayout createLayout() {\n+        return ApplicationLayout.build()\n+                .launchersDirectory(\"bin\")\n+                .appDirectory(\"lib\/app\")\n+                .runtimeDirectory(\"runtime\")\n+                .appModsDirectory(\"mods\")\n+                .contentDirectory(\"content\")\n+                .desktopIntegrationDirectory(\"lib\/apps\")\n+                .create();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java","additions":44,"deletions":19,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -68,0 +68,8 @@\n+    @Test\n+    public void equals() {\n+        assertEquals(new PathGroup(Map.of()), new PathGroup(Map.of()));\n+        assertEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"rab\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"Foo\", Path.of(\"bar\"))));\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PathGroupTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,4 +43,6 @@\n-    static {\n-        if (System.getProperty(\"test.src\") == null) {\n-            \/\/ Was called by somebody else but not by jtreg\n-            System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+    public static class TestSrcInitializer {\n+        static {\n+            if (System.getProperty(\"test.src\") == null) {\n+                \/\/ Was called by somebody else but not by jtreg\n+                System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+            }\n@@ -87,0 +89,4 @@\n+    static {\n+        new TestSrcInitializer();\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitAdapter.java","additions":10,"deletions":4,"binary":false,"changes":14,"previous_filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JUnitAdapter.java","status":"renamed"},{"patch":"@@ -27,1 +27,2 @@\n- * @compile\/module=jdk.jpackage jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n","filename":"test\/jdk\/tools\/jpackage\/junit\/windows\/junit.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/DmgContentTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacFileAssociationsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.LinkedHashMap;\n@@ -32,0 +33,1 @@\n+import java.util.Map;\n@@ -34,0 +36,1 @@\n+import java.util.stream.Collectors;\n@@ -40,0 +43,1 @@\n+import jdk.jpackage.test.HelloApp;\n@@ -41,0 +45,1 @@\n+import jdk.jpackage.test.JavaAppDesc;\n@@ -66,0 +71,1 @@\n+ * @requires (os.family != \"mac\")\n@@ -79,0 +85,1 @@\n+ * @requires (os.family != \"mac\")\n@@ -88,1 +95,1 @@\n-    @Test\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n@@ -96,0 +103,2 @@\n+        final var packageName = MethodHandles.lookup().lookupClass().getSimpleName();\n+\n@@ -105,0 +114,5 @@\n+\n+            cmd.setArgumentValue(\"--name\", packageName);\n+\n+            var addLauncherApp = TKit.TEST_SRC_ROOT.resolve(\"apps\/PrintEnv.java\");\n+            HelloApp.createBundle(JavaAppDesc.parse(addLauncherApp + \"*another.jar:Welcome\"), cmd.inputDir());\n@@ -107,3 +121,1 @@\n-        new FileAssociations(\n-                MethodHandles.lookup().lookupClass().getSimpleName()).applyTo(\n-                packageTest);\n+        new FileAssociations(packageName).applyTo(packageTest);\n@@ -134,2 +146,2 @@\n-        new AdditionalLauncher(\"Launcher5\")\n-                .setDefaultArguments()\n+        var launcher5 = new AdditionalLauncher(\"Launcher5\")\n+                .setDefaultArguments(\"--print-workdir\")\n@@ -137,2 +149,7 @@\n-                .setShortcuts(false, true)\n-                .applyTo(packageTest);\n+                .setShortcut(LauncherShortcut.LINUX_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_DESKTOP_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_START_MENU_SHORTCUT, null)\n+                .setProperty(\"main-jar\", \"another.jar\")\n+                .setProperty(\"main-class\", \"Welcome\");\n+\n+        new ShortcutStartupDirectoryVerifier(packageName).add(launcher5).applyTo(packageTest);\n@@ -193,0 +210,1 @@\n+            cfgs[0].applyToMainLauncher(cmd);\n@@ -196,1 +214,40 @@\n-            cfgs[0].applyToMainLauncher(cmd);\n+        }).run(RunnablePackageTest.Action.CREATE_AND_UNPACK);\n+    }\n+\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @Parameter(value = \"DEFAULT\")\n+    @Parameter(value = \"APP_DIR\")\n+    public void testLastArg(StartupDirectory startupDirectory) {\n+        final List<String> shortcutArgs = new ArrayList<>();\n+        if (TKit.isLinux()) {\n+            shortcutArgs.add(\"--linux-shortcut\");\n+        } else if (TKit.isWindows()) {\n+            shortcutArgs.add(\"--win-shortcut\");\n+        } else {\n+            TKit.assertUnexpected(\"Unsupported platform\");\n+        }\n+\n+        if (startupDirectory == StartupDirectory.APP_DIR) {\n+            shortcutArgs.add(startupDirectory.asStringValue());\n+        }\n+\n+        Path[] predefinedAppImage = new Path[1];\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            var cmd = JPackageCommand.helloAppImage()\n+                    .setArgumentValue(\"--name\", \"foo\")\n+                    .setFakeRuntime();\n+\n+            cmd.execute();\n+\n+            predefinedAppImage[0] = cmd.outputBundle();\n+        }).addInitializer(cmd -> {\n+            cmd.removeArgumentWithValue(\"--input\");\n+            cmd.setArgumentValue(\"--name\", \"AddLShortcutDir3Test\");\n+            cmd.addArguments(\"--app-image\", predefinedAppImage[0]);\n+            cmd.ignoreDefaultVerbose(true);\n+        }).addInitializer(cmd -> {\n+            cmd.addArguments(shortcutArgs);\n+        }).addBundleVerifier(cmd -> {\n+            TKit.assertEquals(shortcutArgs.getLast(), cmd.getAllArguments().getLast(),\n+                    \"Check the last argument of jpackage command line\");\n@@ -210,0 +267,1 @@\n+    @Parameter(value = \"APP_DIR\")\n@@ -222,17 +280,1 @@\n-        var shortcutStartupDirectoryVerifier = new ShortcutStartupDirectoryVerifier(name, \"a\");\n-\n-        shortcutStartupDirectoryVerifier.applyTo(test, startupDirectory);\n-\n-        test.addInstallVerifier(cmd -> {\n-            if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n-                Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n-                if (TKit.isLinux()) {\n-                    invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n-                } else if (TKit.isWindows()) {\n-                    invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n-                } else {\n-                    throw new UnsupportedOperationException();\n-                }\n-                shortcutStartupDirectoryVerifier.verify(invokeShortcutSpecs);\n-            }\n-        });\n+        new ShortcutStartupDirectoryVerifier(name).add(\"a\", startupDirectory).applyTo(test);\n@@ -244,4 +286,4 @@\n-    private record ShortcutStartupDirectoryVerifier(String packageName, String launcherName) {\n-        ShortcutStartupDirectoryVerifier {\n-            Objects.requireNonNull(packageName);\n-            Objects.requireNonNull(launcherName);\n+    private static final class ShortcutStartupDirectoryVerifier {\n+\n+        ShortcutStartupDirectoryVerifier(String packageName) {\n+            this.packageName = Objects.requireNonNull(packageName);\n@@ -250,6 +292,22 @@\n-        void applyTo(PackageTest test, StartupDirectory startupDirectory) {\n-            var al = new AdditionalLauncher(launcherName);\n-            al.setShortcut(shortcut(), Objects.requireNonNull(startupDirectory));\n-            al.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n-                    outputDirVarName(), expectedOutputFilename()));\n-            al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+        void applyTo(PackageTest test) {\n+            verifiers.values().forEach(verifier -> {\n+                verifier.applyTo(test);\n+            });\n+            test.addInstallVerifier(cmd -> {\n+                if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n+                    Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n+                    if (TKit.isLinux()) {\n+                        invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n+                    } else if (TKit.isWindows()) {\n+                        invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+\n+                    var invokeShortcutSpecsMap = invokeShortcutSpecs.stream().collect(Collectors.groupingBy(InvokeShortcutSpec::launcherName));\n+\n+                    for (var e : verifiers.entrySet()) {\n+                        e.getValue().verify(invokeShortcutSpecsMap.get(e.getKey()));\n+                    }\n+                }\n+            });\n@@ -258,1 +316,4 @@\n-        void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n+        ShortcutStartupDirectoryVerifier add(String launcherName, StartupDirectory startupDirectory) {\n+            return add(new AdditionalLauncher(launcherName)\n+                    .setShortcut(shortcut(), Objects.requireNonNull(Objects.requireNonNull(startupDirectory))));\n+        }\n@@ -260,1 +321,5 @@\n-            TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName));\n+        ShortcutStartupDirectoryVerifier add(AdditionalLauncher addLauncher) {\n+            var launcherVerifier = new LauncherVerifier(addLauncher);\n+            verifiers.put(launcherVerifier.launcherName(), launcherVerifier);\n+            return this;\n+        }\n@@ -262,1 +327,0 @@\n-            var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n@@ -264,1 +328,1 @@\n-            TKit.deleteIfExists(expectedOutputFile);\n+        private final class LauncherVerifier {\n@@ -266,3 +330,3 @@\n-            var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n-                return launcherName.equals(v.launcherName());\n-            }).findAny().orElseThrow();\n+            private LauncherVerifier(AdditionalLauncher addLauncher) {\n+                this.addLauncher = Objects.requireNonNull(addLauncher);\n+            }\n@@ -270,1 +334,3 @@\n-            invokeShortcutSpec.execute();\n+            private String launcherName() {\n+                return addLauncher.name();\n+            }\n@@ -272,3 +338,5 @@\n-            \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n-            \/\/ way to make it wait for exit of a process it triggers.\n-            TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n+            private void applyTo(PackageTest test) {\n+                addLauncher.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n+                        outputDirVarName(), expectedOutputFilename()));\n+                addLauncher.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+            }\n@@ -276,2 +344,5 @@\n-            TKit.assertFileExists(expectedOutputFile);\n-            var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n+            private void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n+                Objects.requireNonNull(invokeShortcutSpecs);\n+                if (invokeShortcutSpecs.isEmpty()) {\n+                    throw new IllegalArgumentException();\n+                }\n@@ -279,1 +350,1 @@\n-            var outputPrefix = \"$CD=\";\n+                TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName()));\n@@ -281,1 +352,1 @@\n-            TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+                var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n@@ -283,9 +354,16 @@\n-            invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n-                TKit.assertEquals(\n-                        expectedWorkDirectory,\n-                        Path.of(actualStr.substring(outputPrefix.length())),\n-                        String.format(\"Check work directory of %s of launcher [%s]\",\n-                                invokeShortcutSpec.shortcut().propertyName(),\n-                                invokeShortcutSpec.launcherName()));\n-            });\n-        }\n+                TKit.deleteIfExists(expectedOutputFile);\n+\n+                var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n+                    return launcherName().equals(v.launcherName());\n+                }).findAny().orElseThrow();\n+\n+                invokeShortcutSpec.execute();\n+\n+                \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n+                \/\/ way to make it wait for exit of a process it triggers.\n+                TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n+\n+                TKit.assertFileExists(expectedOutputFile);\n+                var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n+\n+                var outputPrefix = \"$CD=\";\n@@ -293,2 +371,17 @@\n-        private String expectedOutputFilename() {\n-            return String.format(\"%s-%s.out\", packageName, launcherName);\n+                TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+\n+                invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n+                    TKit.assertEquals(\n+                            expectedWorkDirectory,\n+                            Path.of(actualStr.substring(outputPrefix.length())),\n+                            String.format(\"Check work directory of %s of launcher [%s]\",\n+                                    invokeShortcutSpec.shortcut().propertyName(),\n+                                    invokeShortcutSpec.launcherName()));\n+                });\n+            }\n+\n+            private String expectedOutputFilename() {\n+                return String.format(\"%s-%s.out\", packageName, launcherName());\n+            }\n+\n+            private final AdditionalLauncher addLauncher;\n@@ -297,1 +390,2 @@\n-        private String outputDirVarName() {\n+\n+        private static String outputDirVarName() {\n@@ -307,1 +401,1 @@\n-        private LauncherShortcut shortcut() {\n+        private static LauncherShortcut shortcut() {\n@@ -316,0 +410,4 @@\n+\n+        private final String packageName;\n+        \/\/ Keep the order\n+        private final Map<String, LauncherVerifier> verifiers = new LinkedHashMap<>();\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":162,"deletions":64,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m\n+ * @run main\/othervm\/timeout=1440 -Xmx512m\n@@ -66,1 +66,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m\n+ * @run main\/othervm\/timeout=2160 -Xmx512m\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.Collection;\n@@ -42,0 +41,1 @@\n+import jdk.jpackage.test.JPackageStringBundle;\n@@ -119,0 +119,14 @@\n+    @Test(ifOS = MACOS)\n+    @Parameter({TEST_DIR, \"warning.non.standard.contents.sub.dir\"})\n+    @Parameter({TEST_DUKE, \"warning.app.content.is.not.dir\"})\n+    public void testWarnings(String testPath, String warningId) throws Exception {\n+        final var appContentValue = TKit.TEST_SRC_ROOT.resolve(testPath);\n+        final var expectedWarning = JPackageStringBundle.MAIN.cannedFormattedString(\n+                warningId, appContentValue);\n+\n+        JPackageCommand.helloAppImage()\n+            .addArguments(\"--app-content\", appContentValue)\n+            .validateOutput(expectedWarning)\n+            .executeIgnoreExitCode();\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppLauncherSubstTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppVersionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2880 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -579,0 +579,3 @@\n+        invalidShortcut(testCases::add, \"--win-menu\");\n+        invalidShortcut(testCases::add, \"--win-shortcut\");\n+\n@@ -645,0 +648,2 @@\n+        invalidShortcut(testCases::add, \"--linux-shortcut\");\n+\n@@ -700,0 +705,7 @@\n+    private static void invalidShortcut(Consumer<TestSpec> accumulator, String shortcutOption) {\n+        Objects.requireNonNull(shortcutOption);\n+        Stream.of(\"true\", \"false\", \"\").map(value -> {\n+            return testSpec().nativeType().addArgs(shortcutOption, value).error(\"error.invalid-option-value\", value, shortcutOption).create();\n+        }).forEach(accumulator);\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n","filename":"test\/jdk\/tools\/jpackage\/share\/IconTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2880 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=4000 -Xmx512m jdk.jpackage.test.Main\n@@ -81,1 +81,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=4000 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/InstallDirTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2840 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/JavaOptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2880 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/MainClassTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2160 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/MultiNameTwoPhaseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n","filename":"test\/jdk\/tools\/jpackage\/share\/PostImageScriptTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main InstanceMainTest\n+ * @run main\/timeout=480 InstanceMainTest\n","filename":"test\/jdk\/tools\/launcher\/InstanceMainTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+ * @comment VM fails to launch with minimum allowed stack size of 136k when asan is enabled\n+ * @requires !vm.asan\n","filename":"test\/jdk\/tools\/launcher\/TooSmallStackSize.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -426,1 +426,1 @@\n-            return linkableRuntime ? jars : jmods + File.pathSeparator + jars;\n+            return (linkableRuntime || jmods.isEmpty()) ? jars : jmods + File.pathSeparator + jars;\n@@ -657,1 +657,1 @@\n-            return jmods + File.pathSeparator + jars;\n+            return jmods.isEmpty() ? jars : jmods + File.pathSeparator + jars;\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -300,1 +300,0 @@\n-                elements.getModuleElement(\"java.base\");\n","filename":"test\/jdk\/tools\/sincechecker\/SinceChecker.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+        map.put(\"vm.cds.nocoops.archive.available\", this::vmCDSNocoopsArchiveAvailable);\n@@ -425,1 +426,6 @@\n-        return \"\" + WB.isCDSIncluded();\n+        boolean noJvmtiAdded = allFlags()\n+                .filter(s -> s.startsWith(\"-agentpath\"))\n+                .findAny()\n+                .isEmpty();\n+\n+        return \"\" + (noJvmtiAdded && WB.isCDSIncluded());\n@@ -438,0 +444,10 @@\n+    \/**\n+     * Check for CDS no compressed oops archive existence.\n+     *\n+     * @return true if CDS archive classes_nocoops.jsa exists in the JDK to be tested.\n+     *\/\n+    protected String vmCDSNocoopsArchiveAvailable() {\n+        Path archive = Paths.get(System.getProperty(\"java.home\"), \"lib\", \"server\", \"classes_nocoops.jsa\");\n+        return \"\" + (\"true\".equals(vmCDS()) && Files.exists(archive));\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+jdk\/jshell\/ToolSimpleTest.java                                                  8366582    generic-all\n+jdk\/jshell\/ToolLocalSimpleTest.java                                             8366582    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,0 +146,3 @@\n+        \/\/ used for themes\n+        removeAll(styleSheetNames, \"theme-dark\", \"theme-light\", \"theme-os\");\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/checkStylesheetClasses\/CheckStylesheetClasses.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-                <code><a href=\"PubJ.html#testJ()\" title=\"testJ()\">testJ<\/a><\/code><\/div>\n+                <code><a href=\"PubJ.html#testJ()\" title=\"testJ()\">testJ<\/a><\/code>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDuplicateMethodsWarn\/TestDuplicateMethods.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+        checkOutput(\"resource-files\/stylesheet.css\", true,\n+                \"@import url('fonts\/dejavu.css');\");\n@@ -118,0 +120,2 @@\n+        checkOutput(\"resource-files\/stylesheet.css\", false,\n+                \"@import url('fonts\/dejavu.css');\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testFonts\/TestFonts.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                    InnerExtendsInvisibleInner<\/a><\/code><\/div>\n+                    InnerExtendsInvisibleInner<\/a><\/code>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHiddenTag\/TestHiddenTag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-                    <footer role=\"contentinfo\"> \"\"\",\n+                    <footer> \"\"\",\n@@ -116,1 +116,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -153,1 +153,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlLandmarkRegions\/TestHtmlLandmarkRegions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -112,1 +112,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -153,1 +153,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -174,1 +174,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -202,1 +202,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -223,1 +223,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -246,1 +246,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -282,1 +282,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -302,1 +302,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -340,1 +340,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -390,1 +390,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -431,1 +431,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -463,1 +463,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -490,1 +490,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -517,1 +517,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -555,1 +555,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n@@ -584,1 +584,1 @@\n-                    <footer role=\"contentinfo\">\"\"\",\n+                    <footer>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlVersion\/TestHtmlVersion.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-             8186332 8186703 8182765 8187288 8261976 8303349 8319988\n+             8186332 8186703 8182765 8187288 8261976 8303349 8319988 8350920\n@@ -214,1 +214,34 @@\n-                code><\/div>\"\"\");\n+                code>\n+                <div class=\"summary-table three-column-summary\">\n+                <div class=\"table-header col-first\">Modifier and Type<\/div>\n+                <div class=\"table-header col-second\">Interface<\/div>\n+                <div class=\"table-header col-last\">Description<\/div>\n+                <div class=\"col-first even-row-color\"><code>static interface&nbsp;<\/code><\/div>\n+                <div class=\"col-second even-row-color\"><code><a href=\"Spliterator.OfDouble.html\"\\\n+                 class=\"type-name-link\" title=\"interface in pkg2\">Spliterator.OfDouble<\/a><\/code\\\n+                ><\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                <div class=\"col-first odd-row-color\"><code>static interface&nbsp;<\/code><\/div>\n+                <div class=\"col-second odd-row-color\"><code><a href=\"Spliterator.OfInt.html\" cla\\\n+                ss=\"type-name-link\" title=\"interface in pkg2\">Spliterator.OfInt<\/a>&lt;<a href=\"\\\n+                Spliterator.OfInt.html#type-param-Integer\" title=\"type parameter in Spliterator.\\\n+                OfInt\">Integer<\/a>&gt;<\/code><\/div>\n+                <div class=\"col-last odd-row-color\">&nbsp;<\/div>\n+                <div class=\"col-first even-row-color\"><code>static interface&nbsp;<\/code><\/div>\n+                <div class=\"col-second even-row-color\"><code><a href=\"Spliterator.OfPrimitive.ht\\\n+                ml\" class=\"type-name-link\" title=\"interface in pkg2\">Spliterator.OfPrimitive<\/a>\\\n+                &lt;<a href=\"Spliterator.OfPrimitive.html#type-param-T\" title=\"type parameter in\\\n+                 Spliterator.OfPrimitive\">T<\/a>, <a href=\"Spliterator.OfPrimitive.html#type-para\\\n+                m-T_CONS\" title=\"type parameter in Spliterator.OfPrimitive\">T_CONS<\/a>, <a href\\\n+                =\"Spliterator.OfPrimitive.html#type-param-T_SPLITR\" title=\"type parameter in Sp\\\n+                literator.OfPrimitive\">T_SPLITR<\/a> extends <a href=\"Spliterator.OfPrimitive.ht\\\n+                ml\" title=\"interface in pkg2\">Spliterator.OfPrimitive<\/a>&lt;<a href=\"Spliterat\\\n+                or.OfPrimitive.html#type-param-T\" title=\"type parameter in Spliterator.OfPrimit\\\n+                ive\">T<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html#type-param-T_CONS\" title=\\\n+                \"type parameter in Spliterator.OfPrimitive\">T_CONS<\/a>,<wbr><a href=\"Spliterato\\\n+                r.OfPrimitive.html#type-param-T_SPLITR\" title=\"type parameter in Spliterator.Of\\\n+                Primitive\">T_SPLITR<\/a>&gt;&gt;<\/code><\/div>\n+                <div class=\"col-last even-row-color\">&nbsp;<\/div>\n+                <\/div>\n+                <\/div>\n+                <\/section>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *      8203791 8184205 8249633 8261976\n+ *      8203791 8184205 8249633 8261976 8350920\n@@ -244,1 +244,23 @@\n-                    <code><a href=\"C.html#pausedProperty\">paused<\/a>, <a href=\"C.html#rateProperty\">rate<\/a><\/code><\/div>\"\"\");\n+                    <code><a href=\"C.html#pausedProperty\">paused<\/a>, <a href=\"C.html#rateProperty\">rate<\/a><\/code>\n+                    <div class=\"summary-table three-column-summary\">\n+                    <div class=\"table-header col-first\">Type<\/div>\n+                    <div class=\"table-header col-second\">Property<\/div>\n+                    <div class=\"table-header col-last\">Description<\/div>\n+                    <div class=\"col-first even-row-color\"><code>final <a href=\"C.BooleanProperty.htm\\\n+                    l\" title=\"class in pkg1\">C.BooleanProperty<\/a><\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"C.html#pausedProperty\" cla\\\n+                    ss=\"member-name-link\">paused<\/a><\/code><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <div class=\"block\">Defines if paused.<\/div>\n+                    <\/div>\n+                    <div class=\"col-first odd-row-color\"><code>final <a href=\"C.DoubleProperty.html\"\\\n+                     title=\"class in pkg1\">C.DoubleProperty<\/a><\/code><\/div>\n+                    <div class=\"col-second odd-row-color\"><code><a href=\"C.html#rateProperty\" class=\\\n+                    \"member-name-link\">rate<\/a><\/code><\/div>\n+                    <div class=\"col-last odd-row-color\">\n+                    <div class=\"block\">Defines the direction\/speed at which the <code>Timeline<\/code> is expected to\n+                    be played.<\/div>\n+                    <\/div>\n+                    <\/div>\n+                    <\/div>\n+                    <\/section>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testJavaFX\/TestJavaFX.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main TestRedirectLinks\n+ * @run main\/timeout=480 TestRedirectLinks\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestRedirectLinks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8196027 8196202 8320458\n+ * @bug 8196027 8196202 8320458 8342705\n@@ -90,0 +90,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -101,0 +104,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -112,0 +118,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -123,0 +132,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -134,0 +146,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -145,0 +160,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -157,0 +175,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/..\/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/..\/resour\\\n+                    ce-files\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -169,0 +190,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/..\/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/..\/resour\\\n+                    ce-files\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNavigation\/TestModuleNavigation.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *           8342705\n@@ -73,0 +74,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -84,0 +88,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -95,0 +102,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -106,0 +116,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -117,0 +130,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -342,0 +358,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -353,0 +372,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -364,0 +386,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -375,0 +400,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"..\\\n+                    \/resource-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"..\/resource-fil\\\n+                    es\/moon.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -414,0 +442,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -429,0 +460,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNavigation\/TestNavigation.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8157000 8192850 8182765 8223607 8261976 8281376 8313204 8345777\n+ * @bug 8157000 8192850 8182765 8223607 8261976 8281376 8313204 8345777 8350920\n@@ -88,0 +88,11 @@\n+                \/\/ Check summary table for inherited nested classes\n+                \"summary-table three-column-summary\",\n+                \"Modifier and Type\",\n+                \"Class\",\n+                \"Description\",\n+                \"class&nbsp;\",\n+                \"Classes.P.PN.html\",\n+                \"Classes.P.PN.html#type-param-K\",\n+                \"Classes.P.PN.html#type-param-V\",\n+                \"A nested class in parent\",\n+\n@@ -95,0 +106,9 @@\n+                \/\/ Check summary table for inherited properties\n+                \"summary-table three-column-summary\",\n+                \"Type\",\n+                \"Property\",\n+                \"Description\",\n+                \"Classes.DoubleProperty\",\n+                \"Classes.P.html#rateProperty\",\n+                \"rate\",\n+\n@@ -101,0 +121,9 @@\n+                \/\/ Check summary table for inherited fields\n+                \"summary-table three-column-summary\",\n+                \"Modifier and Type\",\n+                \"Field\",\n+                \"Description\",\n+                \"int\",\n+                \"Classes.P.html#field0\",\n+                \"field0\",\n+\n@@ -121,0 +150,10 @@\n+                \/\/ Check summary table for inherited methods\n+                \"summary-table three-column-summary\",\n+                \"Modifier and Type\",\n+                \"Method\",\n+                \"Description\",\n+                \"void\",\n+                \"Classes.GP.html#m0()\",\n+                \"m0\",\n+                \"m0 in grand parent\",\n+\n@@ -123,3 +162,5 @@\n-                    Methods declared in class&nbsp;java.lang.Object\"\"\",\n-                \"\"\"\n-                    clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait\"\"\",\n+                    <h3 id=\"methods-inherited-from-class-java.lang.Object\">Methods declared in clas\\\n+                    s&nbsp;java.lang.Object<\/h3>\n+                    <code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString,\\\n+                     wait, wait, wait<\/code><\/div>\n+                    <\/section>\"\"\",\n@@ -193,0 +234,15 @@\n+        checkOrder(\"pkg5\/Classes.P.html\",\n+                \/\/ Check table of contents for inherited members\n+                \"\"\"\n+                    <li><a href=\"#nested-class-summary\" tabindex=\"0\">Nested Class Summary<\/a><\/li>\n+                    <li><a href=\"#property-summary\" tabindex=\"0\">Property Summary<\/a><\/li>\n+                    <li><a href=\"#field-summary\" tabindex=\"0\">Field Summary<\/a><\/li>\n+                    <li><a href=\"#constructor-summary\" tabindex=\"0\">Constructor Summary<\/a><\/li>\n+                    <li><a href=\"#method-summary\" tabindex=\"0\">Method Summary<\/a>\n+                    <ol class=\"toc-list\">\n+                    <li><a href=\"#methods-inherited-from-class-pkg5.Classes.GP\" tabindex=\"0\">Method\\\n+                    s declared in class&nbsp;Classes.GP<\/a><\/li>\n+                    <li><a href=\"#methods-inherited-from-class-java.lang.Object\" tabindex=\"0\">Metho\\\n+                    ds declared in class&nbsp;java.lang.Object<\/a><\/li>\n+                    <\/ol>\"\"\");\n+\n@@ -394,2 +450,26 @@\n-                    le=\"m3()\">m3<\/a>, <a href=\"Base.html#m9()\" title=\"m9()\">m9<\/a><\/code><\/div>\n-                    \"\"\");\n+                    le=\"m3()\">m3<\/a>, <a href=\"Base.html#m9()\" title=\"m9()\">m9<\/a><\/code>\n+                    <div class=\"summary-table three-column-summary\">\n+                    <div class=\"table-header col-first\">Modifier and Type<\/div>\n+                    <div class=\"table-header col-second\">Method<\/div>\n+                    <div class=\"table-header col-last\">Description<\/div>\n+                    <div class=\"col-first even-row-color\"><code>java.lang.Object<\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"Base.html#m1()\" class=\"mem\\\n+                    ber-name-link\">m1<\/a>()<\/code><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <div class=\"block\">This is Base::m1.<\/div>\n+                    <\/div>\n+                    <div class=\"col-first odd-row-color\"><code><a href=\"#type-param-T\" title=\"type p\\\n+                    arameter in Sub\">T<\/a><\/code><\/div>\n+                    <div class=\"col-second odd-row-color\"><code><a href=\"Base.html#m3()\" class=\"memb\\\n+                    er-name-link\">m3<\/a>()<\/code><\/div>\n+                    <div class=\"col-last odd-row-color\">\n+                    <div class=\"block\">This is Base::m3.<\/div>\n+                    <\/div>\n+                    <div class=\"col-first even-row-color\"><code>abstract java.lang.Object<\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"Base.html#m9()\" class=\"mem\\\n+                    ber-name-link\">m9<\/a>()<\/code><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <div class=\"block\">This is Base::m9.<\/div>\n+                    <\/div>\n+                    <\/div>\n+                    <\/div>\"\"\");\n@@ -418,1 +498,16 @@\n-                    , int[])\">m1<\/a><\/code><\/div>\"\"\");\n+                    , int[])\">m1<\/a><\/code>\n+                    <div class=\"summary-table three-column-summary\">\n+                    <div class=\"table-header col-first\">Modifier and Type<\/div>\n+                    <div class=\"table-header col-second\">Method<\/div>\n+                    <div class=\"table-header col-last\">Description<\/div>\n+                    <div class=\"col-first even-row-color\"><code>java.lang.Iterable<wbr>&lt;java.lang\\\n+                    .String&gt;<\/code><\/div>\n+                    <div class=\"col-second even-row-color\"><code><a href=\"AnnotatedBase.html#m1(java\\\n+                    .lang.Class,int%5B%5D)\" class=\"member-name-link\">m1<\/a><wbr>(java.lang.Class&lt;\\\n+                    ? extends java.lang.CharSequence&gt;&nbsp;p1,\n+                     int[]&nbsp;p2)<\/code><\/div>\n+                    <div class=\"col-last even-row-color\">\n+                    <div class=\"block\">This is AnnotatedBase::m1.<\/div>\n+                    <\/div>\n+                    <\/div>\n+                    <\/div>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/TestOverrideMethods.java","additions":103,"deletions":8,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -129,0 +129,3 @@\n+                    <li><button id=\"theme-button\" aria-label=\"Select Theme\" title=\"Select Theme\"><img src=\"re\\\n+                    source-files\/sun.svg\" alt=\"Select Theme\" class=\"theme-light\"><img src=\"resource-files\/moo\\\n+                    n.svg\" alt=\"Select Theme\" class=\"theme-dark\"><\/button><\/li>\n@@ -130,12 +133,0 @@\n-                    <\/div>\n-                    <\/div>\n-                    <div class=\"sub-nav\">\n-                    <div class=\"nav-content\">\n-                    <ol class=\"sub-nav-list\"><\/ol>\n-                    <div class=\"nav-list-search\"><input type=\"text\" id=\"search-input\" disabled place\\\n-                    holder=\"Search documentation (type \/)\" aria-label=\"Search in documentation\" auto\\\n-                    complete=\"off\" spellcheck=\"false\"><input type=\"reset\" id=\"reset-search\" disabled\\\n-                     value=\"Reset\"><\/div>\n-                    <\/div>\n-                    <\/div>\n-                    <!-- ========= END OF TOP NAVBAR ========= -->\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSpecTag\/TestSpecTag.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+        setUseDefaultOptions(false);\n@@ -89,1 +90,1 @@\n-                        padding: 8px 3px 3px 7px;\n+                        padding: 8px 5px 3px 7px;\n@@ -95,1 +96,2 @@\n-                        background-color:var(--search-tag-highlight-color);\n+                        background-color:var(--search-tag-background-color);\n+                        color:var(--search-tag-text-color);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testStylesheet\/TestStylesheet.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-                    <code><a href=\"internal\/InternalClass.html#p()\" title=\"p()\">p<\/a><\/code><\/div>\n+                    <code><a href=\"internal\/InternalClass.html#p()\" title=\"p()\">p<\/a><\/code>\n@@ -267,1 +267,1 @@\n-                    <code><a href=\"internal\/InternalInterface.html#m()\" title=\"m()\">m<\/a><\/code><\/div>\n+                    <code><a href=\"internal\/InternalInterface.html#m()\" title=\"m()\">m<\/a><\/code>\n@@ -289,1 +289,1 @@\n-                    <code><a href=\"..\/..\/ma\/pa\/internal\/InternalClass.html#p()\" title=\"p()\">p<\/a><\/code><\/div>\n+                    <code><a href=\"..\/..\/ma\/pa\/internal\/InternalClass.html#p()\" title=\"p()\">p<\/a><\/code>\n@@ -295,1 +295,1 @@\n-                    <code><a href=\"..\/..\/ma\/pa\/internal\/InternalInterface.html#m()\" title=\"m()\">m<\/a><\/code><\/div>\n+                    <code><a href=\"..\/..\/ma\/pa\/internal\/InternalInterface.html#m()\" title=\"m()\">m<\/a><\/code>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnexported\/TestUnexported.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -208,0 +208,1 @@\n+            \"resource-files\/down.svg\",\n@@ -212,0 +213,1 @@\n+            \"resource-files\/moon.svg\",\n@@ -214,0 +216,1 @@\n+            \"resource-files\/sun.svg\",\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n","filename":"test\/langtools\/jdk\/jshell\/AbstractStopExecutionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng AnalysisTest\n+ * @run junit AnalysisTest\n@@ -31,1 +31,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -33,1 +33,0 @@\n-@Test\n@@ -36,0 +35,1 @@\n+    @Test\n@@ -44,0 +44,1 @@\n+    @Test\n@@ -52,0 +53,1 @@\n+    @Test\n@@ -57,0 +59,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/AnalysisTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng AnalyzeSnippetTest\n+ * @run junit AnalyzeSnippetTest\n@@ -39,1 +39,0 @@\n-import org.testng.annotations.Test;\n@@ -43,5 +42,3 @@\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.assertEquals;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -58,0 +55,3 @@\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -59,1 +59,0 @@\n-@Test\n@@ -65,1 +64,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -75,1 +74,1 @@\n-    @AfterMethod\n+    @AfterEach\n@@ -84,0 +83,1 @@\n+    @Test\n@@ -87,1 +87,1 @@\n-        assertEquals(sn.name(), \"List\");\n+        assertEquals(\"List\", sn.name());\n@@ -93,0 +93,1 @@\n+    @Test\n@@ -96,1 +97,1 @@\n-        assertEquals(sn.name(), \"C\");\n+        assertEquals(\"C\", sn.name());\n@@ -101,0 +102,1 @@\n+    @Test\n@@ -104,2 +106,2 @@\n-        assertEquals(sn.name(), \"m\");\n-        assertEquals(sn.signature(), \"(int)int\");\n+        assertEquals(\"m\", sn.name());\n+        assertEquals(\"(int)int\", sn.signature());\n@@ -108,0 +110,1 @@\n+    @Test\n@@ -111,2 +114,2 @@\n-        assertEquals(sn.name(), \"i\");\n-        assertEquals(sn.typeName(), \"int\");\n+        assertEquals(\"i\", sn.name());\n+        assertEquals(\"int\", sn.typeName());\n@@ -119,0 +122,1 @@\n+    @Test\n@@ -123,2 +127,2 @@\n-        assertEquals(sn.name(), \"aa\");\n-        assertEquals(sn.typeName(), \"int\");\n+        assertEquals(\"aa\", sn.name());\n+        assertEquals(\"int\", sn.typeName());\n@@ -127,2 +131,2 @@\n-        assertEquals(sn.name(), \"aa\");\n-        assertEquals(sn.typeName(), \"int\");\n+        assertEquals(\"aa\", sn.name());\n+        assertEquals(\"int\", sn.typeName());\n@@ -133,0 +137,1 @@\n+    @Test\n@@ -140,0 +145,1 @@\n+    @Test\n@@ -147,0 +153,1 @@\n+    @Test\n@@ -167,0 +174,1 @@\n+    @Test\n@@ -174,9 +182,9 @@\n-        assertEquals(wrapped, \"\"\"\n-                              package REPL;\n-\n-                              class $JShell$DOESNOTMATTER {\n-                                  public static java.lang.Object do_it$() throws java.lang.Throwable {\n-                                      return unknown();\n-                                  }\n-                              }\n-                              \"\"\");\n+        assertEquals(\"\"\"\n+                     package REPL;\n+\n+                     class $JShell$DOESNOTMATTER {\n+                         public static java.lang.Object do_it$() throws java.lang.Throwable {\n+                             return unknown();\n+                         }\n+                     }\n+                     \"\"\", wrapped);\n@@ -185,2 +193,2 @@\n-            assertEquals(wrapped.charAt(wrappedPos), code.charAt(pos));\n-            assertEquals(wrapper.wrappedToSourcePosition(wrappedPos), pos);\n+            assertEquals(code.charAt(pos), wrapped.charAt(wrappedPos));\n+            assertEquals(pos, wrapper.wrappedToSourcePosition(wrappedPos));\n@@ -190,0 +198,1 @@\n+    @Test\n@@ -195,1 +204,1 @@\n-        assertEquals(state.varValue(vsn), \"10\");\n+        assertEquals(\"10\", state.varValue(vsn));\n@@ -202,1 +211,1 @@\n-        assertEquals(sns.size(), 1, \"snippet count\");\n+        assertEquals(1, sns.size(), \"snippet count\");\n@@ -204,2 +213,2 @@\n-        assertEquals(sn.id(), \"*UNASSOCIATED*\");\n-        assertEquals(sn.subKind(), sk);\n+        assertEquals(\"*UNASSOCIATED*\", sn.id());\n+        assertEquals(sk, sn.subKind());\n@@ -216,1 +225,1 @@\n-        assertEquals(actual, expected);\n+        assertEquals(expected, actual);\n","filename":"test\/langtools\/jdk\/jshell\/AnalyzeSnippetTest.java","additions":46,"deletions":37,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run testng BadExecutionControlSpecTest\n+ * @run junit BadExecutionControlSpecTest\n@@ -41,1 +41,0 @@\n-import org.testng.annotations.Test;\n@@ -44,1 +43,2 @@\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n@@ -46,1 +46,0 @@\n-@Test\n@@ -83,0 +82,1 @@\n+    @Test\n@@ -90,0 +90,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/BadExecutionControlSpecTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/timeout=600 ClassMembersTest\n+ * @run junit\/timeout=600 ClassMembersTest\n@@ -39,3 +39,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n@@ -45,0 +42,5 @@\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -46,0 +48,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -48,1 +51,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -54,1 +57,2 @@\n-    @Test(dataProvider = \"memberTestCase\")\n+    @ParameterizedTest\n+    @MethodSource(\"memberTestCaseGenerator\")\n@@ -81,1 +85,2 @@\n-    @Test(dataProvider = \"memberTestCase\")\n+    @ParameterizedTest\n+    @MethodSource(\"memberTestCaseGenerator\")\n@@ -154,1 +159,2 @@\n-    @Test(dataProvider = \"retentionPolicyTestCase\")\n+    @ParameterizedTest\n+    @MethodSource(\"retentionPolicyTestCaseGenerator\")\n@@ -177,1 +183,0 @@\n-    @DataProvider(name = \"retentionPolicyTestCase\")\n@@ -186,1 +191,0 @@\n-    @DataProvider(name = \"memberTestCase\")\n","filename":"test\/langtools\/jdk\/jshell\/ClassMembersTest.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng ClassPathTest\n+ * @run junit ClassPathTest\n@@ -39,1 +39,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -41,1 +41,0 @@\n-@Test\n@@ -47,0 +46,1 @@\n+    @Test\n@@ -55,0 +55,1 @@\n+    @Test\n@@ -65,0 +66,1 @@\n+    @Test\n@@ -85,0 +87,1 @@\n+    @Test\n@@ -107,0 +110,1 @@\n+    @Test\n@@ -112,0 +116,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ClassPathTest.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng ClassesTest\n+ * @run junit\/timeout=480 ClassesTest\n@@ -40,2 +40,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -54,4 +52,8 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-@Test\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -60,0 +62,1 @@\n+    @Test\n@@ -64,0 +67,1 @@\n+    @Test\n@@ -85,0 +89,1 @@\n+    @Test\n@@ -95,0 +100,1 @@\n+    @Test\n@@ -101,0 +107,1 @@\n+    @Test\n@@ -106,0 +113,1 @@\n+    @Test\n@@ -111,0 +119,1 @@\n+    @Test\n@@ -116,0 +125,1 @@\n+    @Test\n@@ -131,0 +141,1 @@\n+    @Test\n@@ -152,0 +163,1 @@\n+    @Test\n@@ -183,0 +195,1 @@\n+    @Test\n@@ -204,0 +217,1 @@\n+    @Test\n@@ -224,2 +238,2 @@\n-        assertEquals(diags.size(), 1, \"Expected one error\");\n-        assertEquals(diags.get(0).getCode(), \"compiler.err.cyclic.inheritance\", \"Expected cyclic inheritance error\");\n+        assertEquals(1, diags.size(), \"Expected one error\");\n+        assertEquals(\"compiler.err.cyclic.inheritance\", diags.get(0).getCode(), \"Expected cyclic inheritance error\");\n@@ -229,0 +243,1 @@\n+    @Test\n@@ -237,0 +252,1 @@\n+    @Test\n@@ -250,0 +266,1 @@\n+    @Test\n@@ -257,0 +274,1 @@\n+    @Test\n@@ -265,0 +283,1 @@\n+    @Test\n@@ -272,0 +291,1 @@\n+    @Test\n@@ -280,1 +300,0 @@\n-    @DataProvider(name = \"innerClasses\")\n@@ -291,1 +310,2 @@\n-    @Test(dataProvider = \"innerClasses\")\n+    @ParameterizedTest\n+    @MethodSource(\"innerClasses\")\n@@ -302,0 +322,1 @@\n+    @Test\n@@ -312,0 +333,1 @@\n+    @Test\n@@ -314,1 +336,1 @@\n-        assertEquals(varKey(assertEval(\"A a = new A();\")).name(), \"a\");\n+        assertEquals(\"a\", varKey(assertEval(\"A a = new A();\")).name());\n@@ -316,1 +338,1 @@\n-        assertEquals(variableKey.typeName(), \"A.B\");\n+        assertEquals(\"A.B\", variableKey.typeName());\n@@ -319,0 +341,1 @@\n+    @Test\n@@ -321,1 +344,1 @@\n-        assertEquals(varKey(assertEval(\"A a = new A();\")).name(), \"a\");\n+        assertEquals(\"a\", varKey(assertEval(\"A a = new A();\")).name());\n@@ -323,1 +346,1 @@\n-        assertEquals(variableKey.typeName(), \"A.I1\");\n+        assertEquals(\"A.I1\", variableKey.typeName());\n@@ -326,0 +349,1 @@\n+    @Test\n@@ -345,0 +369,1 @@\n+    @Test\n@@ -363,0 +388,1 @@\n+    @Test\n@@ -377,0 +403,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ClassesTest.java","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run testng CommandCompletionTest\n+ * @run junit CommandCompletionTest\n@@ -49,2 +49,0 @@\n-import org.testng.SkipException;\n-import org.testng.annotations.Test;\n@@ -56,3 +54,5 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.Test;\n@@ -97,1 +97,1 @@\n-        assertEquals(completions, expectedL, \"Command: \" + code + \", output: \" +\n+        assertEquals(expectedL, completions, \"Command: \" + code + \", output: \" +\n@@ -359,3 +359,1 @@\n-        if (selectedFile == null) {\n-            throw new SkipException(\"No suitable file(s) found for this test in \" + home);\n-        }\n+        Assumptions.assumeFalse(selectedFile == null, \"No suitable file(s) found for this test in \" + home);\n","filename":"test\/langtools\/jdk\/jshell\/CommandCompletionTest.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -75,0 +75,7 @@\n+        Path classDirPath = getClassDir();\n+        Path baseDir = classDirPath.resolve(directory);\n+        Path jarPath = baseDir.resolve(jarName);\n+        jar(directory, jarPath, files);\n+    }\n+\n+    public void jar(Path directory, Path jarPath, String...files) {\n@@ -79,1 +86,0 @@\n-        Path jarPath = baseDir.resolve(jarName);\n","filename":"test\/langtools\/jdk\/jshell\/Compiler.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng CompilerOptionsTest\n+ * @run junit CompilerOptionsTest\n@@ -33,2 +33,0 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n@@ -36,0 +34,2 @@\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -37,1 +37,0 @@\n-@Test\n@@ -40,1 +39,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -46,0 +45,1 @@\n+    @Test\n@@ -51,0 +51,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/CompilerOptionsTest.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,2 +67,0 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n@@ -73,0 +71,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -102,1 +102,0 @@\n-    @DataProvider(name = \"crawler\")\n@@ -124,1 +123,2 @@\n-    @Test(dataProvider = \"crawler\")\n+    @ParameterizedTest\n+    @MethodSource(\"dataProvider\")\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessStressTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng CompletenessTest\n+ * @run junit CompletenessTest\n@@ -38,1 +38,0 @@\n-import org.testng.annotations.Test;\n@@ -42,1 +41,1 @@\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.Test;\n@@ -44,1 +43,0 @@\n-@Test\n@@ -281,0 +279,1 @@\n+    @Test\n@@ -285,0 +284,1 @@\n+    @Test\n@@ -289,0 +289,1 @@\n+    @Test\n@@ -293,0 +294,1 @@\n+    @Test\n@@ -297,0 +299,1 @@\n+    @Test\n@@ -301,0 +304,1 @@\n+    @Test\n@@ -305,0 +309,1 @@\n+    @Test\n@@ -312,0 +317,1 @@\n+    @Test\n@@ -319,0 +325,1 @@\n+    @Test\n@@ -335,0 +342,1 @@\n+    @Test\n@@ -341,0 +349,1 @@\n+    @Test\n@@ -348,0 +357,1 @@\n+    @Test\n@@ -355,0 +365,1 @@\n+    @Test\n@@ -362,0 +373,1 @@\n+    @Test\n@@ -366,0 +378,1 @@\n+    @Test\n@@ -371,0 +384,1 @@\n+    @Test\n@@ -385,0 +399,1 @@\n+    @Test\n@@ -393,0 +408,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run testng CompletionSuggestionTest\n+ * @run junit\/timeout=480 CompletionSuggestionTest\n@@ -54,2 +54,0 @@\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n@@ -61,0 +59,3 @@\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -62,1 +63,0 @@\n-@Test\n@@ -68,0 +68,1 @@\n+    @Test\n@@ -117,0 +118,1 @@\n+    @Test\n@@ -123,0 +125,1 @@\n+    @Test\n@@ -127,0 +130,1 @@\n+    @Test\n@@ -160,0 +164,1 @@\n+    @Test\n@@ -172,0 +177,1 @@\n+    @Test\n@@ -204,0 +210,1 @@\n+    @Test\n@@ -214,0 +221,1 @@\n+    @Test\n@@ -229,0 +237,1 @@\n+    @Test\n@@ -249,0 +258,1 @@\n+    @Test\n@@ -277,0 +287,1 @@\n+    @Test\n@@ -281,0 +292,1 @@\n+    @Test\n@@ -286,0 +298,1 @@\n+    @Test\n@@ -304,0 +317,1 @@\n+    @Test\n@@ -308,0 +322,1 @@\n+    @Test\n@@ -317,0 +332,1 @@\n+    @Test\n@@ -345,0 +361,1 @@\n+    @Test\n@@ -360,0 +377,1 @@\n+    @Test\n@@ -365,0 +383,1 @@\n+    @Test\n@@ -372,0 +391,1 @@\n+    @Test\n@@ -383,0 +403,1 @@\n+    @Test\n@@ -390,0 +411,1 @@\n+    @Test\n@@ -400,0 +422,1 @@\n+    @Test\n@@ -420,0 +443,1 @@\n+    @Test\n@@ -485,0 +509,1 @@\n+    @Test\n@@ -496,0 +521,1 @@\n+    @Test\n@@ -508,0 +534,1 @@\n+    @Test\n@@ -512,0 +539,1 @@\n+    @Test\n@@ -525,0 +553,1 @@\n+    @Test\n@@ -540,0 +569,1 @@\n+    @Test\n@@ -551,0 +581,1 @@\n+    @Test\n@@ -557,0 +588,1 @@\n+    @Test\n@@ -573,0 +605,1 @@\n+    @Test\n@@ -627,0 +660,1 @@\n+    @Test\n@@ -652,0 +686,1 @@\n+    @Test\n@@ -663,0 +698,1 @@\n+    @Test\n@@ -672,0 +708,1 @@\n+    @Test\n@@ -679,0 +716,1 @@\n+    @Test\n@@ -683,0 +721,1 @@\n+    @Test\n@@ -706,0 +745,1 @@\n+    @Test\n@@ -727,1 +767,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -759,1 +799,2 @@\n-    @Test(enabled = false) \/\/TODO 8171829\n+    @Test \/\/TODO 8171829\n+    @Disabled\n@@ -782,0 +823,1 @@\n+    @Test\n@@ -794,0 +836,1 @@\n+    @Test\n@@ -799,0 +842,1 @@\n+    @Test\n@@ -805,0 +849,1 @@\n+    @Test\n@@ -816,0 +861,1 @@\n+    @Test\n@@ -829,0 +875,1 @@\n+    @Test\n@@ -837,0 +884,17 @@\n+\n+    @Test\n+    public void testCustomClassPathIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"package p1.p2;\\n\" +\n+                \"public class Test {\\n\" +\n+                \"}\",\n+                \"package p1.p3;\\n\" +\n+                \"public class Test {\\n\" +\n+                \"}\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+        addToClasspath(compiler.getPath(p1.resolve(jarName)));\n+\n+        assertCompletion(\"p1.|\", \"p2.\", \"p3.\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":70,"deletions":6,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng ComputeFQNsTest\n+ * @run junit ComputeFQNsTest\n@@ -44,2 +44,3 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -47,1 +48,0 @@\n-@Test\n@@ -53,0 +53,1 @@\n+    @Test\n@@ -80,1 +81,2 @@\n-    @Test(enabled = false) \/\/TODO 8161165\n+    @Test \/\/TODO 8161165\n+    @Disabled\n@@ -130,2 +132,2 @@\n-        assertEquals(candidates.getNames(), Arrays.asList(), \"Input: \" + code + \", candidates=\" + candidates.getNames());\n-        assertEquals(candidates.isUpToDate(), false, \"Input: \" + code + \", up-to-date=\" + candidates.isUpToDate());\n+        assertEquals(Arrays.asList(), candidates.getNames(), \"Input: \" + code + \", candidates=\" + candidates.getNames());\n+        assertEquals(false, candidates.isUpToDate(), \"Input: \" + code + \", up-to-date=\" + candidates.isUpToDate());\n@@ -139,1 +141,1 @@\n-        assertEquals(candidates.getNames(), Arrays.asList(\"test.FQNTest\"), \"Input: \" + code + \", candidates=\" + candidates.getNames());\n+        assertEquals(Arrays.asList(\"test.FQNTest\"), candidates.getNames(), \"Input: \" + code + \", candidates=\" + candidates.getNames());\n","filename":"test\/langtools\/jdk\/jshell\/ComputeFQNsTest.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run testng ConsoleTest\n+ * @run junit ConsoleTest\n@@ -48,2 +48,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n@@ -65,1 +65,1 @@\n-                assertEquals(prompt, \"expected\");\n+                assertEquals(\"expected\", prompt);\n@@ -73,1 +73,1 @@\n-                assertEquals(prompt, \"expected\");\n+                assertEquals(\"expected\", prompt);\n@@ -121,1 +121,1 @@\n-                assertEquals(prompt, \"expected\");\n+                assertEquals(\"expected\", prompt);\n@@ -149,1 +149,1 @@\n-        assertEquals(sb.toString(), expected);\n+        assertEquals(expected, sb.toString());\n@@ -174,1 +174,1 @@\n-        assertEquals(sb.toString(), expected);\n+        assertEquals(expected, sb.toString());\n@@ -210,1 +210,1 @@\n-        assertEquals(sb.toString(), expected);\n+        assertEquals(expected, sb.toString());\n","filename":"test\/langtools\/jdk\/jshell\/ConsoleTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run testng ConsoleToolTest\n+ * @run junit ConsoleToolTest\n@@ -35,1 +35,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n","filename":"test\/langtools\/jdk\/jshell\/ConsoleToolTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng CustomInputToolBuilder\n+ * @run junit CustomInputToolBuilder\n@@ -41,1 +41,2 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -43,3 +44,0 @@\n-import static org.testng.Assert.assertTrue;\n-\n-@Test\n@@ -50,0 +48,1 @@\n+    @Test\n@@ -105,0 +104,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/CustomInputToolBuilder.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng DropTest\n+ * @run junit DropTest\n@@ -36,1 +36,0 @@\n-import org.testng.annotations.Test;\n@@ -39,0 +38,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -40,1 +40,0 @@\n-@Test\n@@ -43,0 +42,1 @@\n+    @Test\n@@ -91,0 +91,1 @@\n+    @Test\n@@ -104,0 +105,1 @@\n+    @Test\n@@ -109,0 +111,1 @@\n+    @Test\n@@ -126,0 +129,1 @@\n+    @Test\n@@ -142,0 +146,1 @@\n+    @Test\n@@ -153,0 +158,1 @@\n+    @Test\n@@ -168,0 +174,1 @@\n+    @Test\n@@ -182,0 +189,1 @@\n+    @Test\n@@ -207,0 +215,1 @@\n+    @Test\n@@ -231,0 +240,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/DropTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,4 @@\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -64,1 +64,1 @@\n-        assertEditInput(after, cmd, s -> assertEquals(s, input, \"Input\"), action);\n+        assertEditInput(after, cmd, s -> assertEquals(input, s, \"Input\"), action);\n@@ -68,1 +68,1 @@\n-        assertEditOutput(after, cmd, s -> assertEquals(s.trim(), output.trim(), \"command\"), action);\n+        assertEditOutput(after, cmd, s -> assertEquals(output.trim(), s.trim(), \"command\"), action);\n@@ -222,2 +222,1 @@\n-        testEditor(\n-                a -> assertVariable(a, \"int\", \"a\"),\n+        testEditor(a -> assertVariable(a, \"int\", \"a\"),\n@@ -228,4 +227,4 @@\n-                    assertEquals(ss.length, 3, \"Expected 3 lines: \" + s);\n-                    assertEquals(ss[0], \"int a;\");\n-                    assertEquals(ss[1], \"void f() {}\");\n-                    assertEquals(ss[2], \"class A {}\");\n+                    assertEquals(3, ss.length, \"Expected 3 lines: \" + s);\n+                    assertEquals(\"int a;\", ss[0]);\n+                    assertEquals(\"void f() {}\", ss[1]);\n+                    assertEquals(\"class A {}\", ss[2]);\n@@ -266,1 +265,2 @@\n-    @Test(enabled = false) \/\/ TODO JDK-8191875\n+    @Test \/\/ TODO JDK-8191875\n+    @Disabled\n","filename":"test\/langtools\/jdk\/jshell\/EditorTestBase.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng EmptyTest\n+ * @run junit EmptyTest\n@@ -31,1 +31,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -33,1 +33,0 @@\n-@Test\n@@ -36,0 +35,1 @@\n+    @Test\n@@ -40,0 +40,1 @@\n+    @Test\n@@ -44,0 +45,1 @@\n+    @Test\n@@ -48,0 +50,1 @@\n+    @Test\n@@ -52,0 +55,1 @@\n+    @Test\n@@ -56,0 +60,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/EmptyTest.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng ErrorRecoveryTest\n+ * @run junit ErrorRecoveryTest\n@@ -37,1 +37,0 @@\n-import org.testng.annotations.Test;\n@@ -41,0 +40,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -42,1 +42,0 @@\n-@Test\n@@ -45,0 +44,1 @@\n+    @Test\n@@ -54,0 +54,1 @@\n+    @Test\n@@ -61,0 +62,1 @@\n+    @Test\n@@ -70,0 +72,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ErrorRecoveryTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng ErrorTranslationTest\n+ * @run junit ErrorTranslationTest\n@@ -44,1 +44,4 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -46,4 +49,0 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-@Test\n@@ -52,1 +51,2 @@\n-    @Test(enabled = false) \/\/ TODO 8080353\n+    @Test \/\/ TODO 8080353\n+    @Disabled\n@@ -63,0 +63,1 @@\n+    @Test\n@@ -70,0 +71,1 @@\n+    @Test\n@@ -76,1 +78,2 @@\n-    @Test(enabled = false) \/\/ TODO 8132147\n+    @Test \/\/ TODO 8132147\n+    @Disabled\n@@ -118,1 +121,1 @@\n-            assertEquals(lines[0], kind);\n+            assertEquals(kind, lines[0]);\n@@ -122,1 +125,1 @@\n-                    assertEquals(lines[i + 1], expectedMarkingLine, \"Input: \" + expectedSource + \", marking line: \");\n+                    assertEquals(expectedMarkingLine, lines[i + 1], \"Input: \" + expectedSource + \", marking line: \");\n@@ -149,0 +152,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ErrorTranslationTest.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng ExceptionMessageTest\n+ * @run junit ExceptionMessageTest\n@@ -45,4 +45,3 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -50,1 +49,0 @@\n-@Test\n@@ -53,0 +51,1 @@\n+    @Test\n@@ -57,0 +56,1 @@\n+    @Test\n@@ -61,0 +61,1 @@\n+    @Test\n@@ -88,1 +89,1 @@\n-        assertEquals(result.size(), 1, \"Expected only one event\");\n+        assertEquals(1, result.size(), \"Expected only one event\");\n@@ -92,1 +93,1 @@\n-        assertEquals(out, expected, \"Exception message not as expected: \" +\n+        assertEquals(expected, out, \"Exception message not as expected: \" +\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionMessageTest.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng ExceptionsTest\n+ * @run junit ExceptionsTest\n@@ -49,1 +49,3 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -51,3 +53,0 @@\n-import static org.testng.Assert.*;\n-\n-@Test\n@@ -59,0 +58,1 @@\n+    @Test\n@@ -67,0 +67,1 @@\n+    @Test\n@@ -75,0 +76,1 @@\n+    @Test\n@@ -87,0 +89,1 @@\n+    @Test\n@@ -99,0 +102,1 @@\n+    @Test\n@@ -125,0 +129,1 @@\n+    @Test\n@@ -147,0 +152,1 @@\n+    @Test\n@@ -159,0 +165,1 @@\n+    @Test\n@@ -171,0 +178,1 @@\n+    @Test\n@@ -185,0 +193,1 @@\n+    @Test\n@@ -201,0 +210,1 @@\n+    @Test\n@@ -222,0 +232,1 @@\n+    @Test\n@@ -235,0 +246,1 @@\n+    @Test\n@@ -253,0 +265,1 @@\n+    @Test\n@@ -264,0 +277,1 @@\n+    @Test\n@@ -295,1 +309,2 @@\n-    @Test(enabled = false) \/\/ TODO 8129427\n+    @Test \/\/ TODO 8129427\n+    @Disabled\n@@ -302,0 +317,1 @@\n+    @Test\n@@ -364,1 +380,1 @@\n-            assertEquals(actualException, expectedException,\n+            assertEquals(expectedException, actualException,\n@@ -368,1 +384,1 @@\n-                assertEquals(ex.getMessage(), exceptionInfo.message,\n+                assertEquals(exceptionInfo.message, ex.getMessage(),\n@@ -398,1 +414,1 @@\n-            assertEquals(ure.getSnippet(), uei.sn);\n+            assertEquals(uei.sn, ure.getSnippet());\n@@ -408,1 +424,1 @@\n-                assertEquals(actual.length, expected.length, message + \" : arrays do not have the same size\");\n+                assertEquals(expected.length, actual.length, message + \" : arrays do not have the same size\");\n@@ -412,1 +428,1 @@\n-                    assertEquals(actualElement.getClassName(), expectedElement.getClassName(), message + \" : class names [\" + i + \"]\");\n+                    assertEquals(expectedElement.getClassName(), actualElement.getClassName(), message + \" : class names [\" + i + \"]\");\n@@ -417,1 +433,1 @@\n-                        assertEquals(actualElement.getMethodName(), expectedElement.getMethodName(), message + \" : method names [\" + i + \"]\");\n+                        assertEquals(expectedElement.getMethodName(), actualElement.getMethodName(), message + \" : method names [\" + i + \"]\");\n@@ -419,1 +435,1 @@\n-                    assertEquals(actualElement.getFileName(), expectedElement.getFileName(), message + \" : file names [\" + i + \"]\");\n+                    assertEquals(expectedElement.getFileName(), actualElement.getFileName(), message + \" : file names [\" + i + \"]\");\n@@ -421,1 +437,1 @@\n-                        assertEquals(actualElement.getLineNumber(), expectedElement.getLineNumber(), message + \" : line numbers [\" + i + \"]\"\n+                        assertEquals(expectedElement.getLineNumber(), actualElement.getLineNumber(), message + \" : line numbers [\" + i + \"]\"\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run testng ExecutionControlSpecTest\n+ * @run junit ExecutionControlSpecTest\n@@ -42,3 +42,3 @@\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -50,1 +50,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -89,1 +89,1 @@\n-    @AfterMethod\n+    @AfterEach\n","filename":"test\/langtools\/jdk\/jshell\/ExecutionControlSpecTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import org.testng.annotations.Test;\n@@ -31,0 +30,1 @@\n+import org.junit.jupiter.api.Test;\n","filename":"test\/langtools\/jdk\/jshell\/ExecutionControlTestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -82,2 +82,2 @@\n-        assertEquals(code, this.code, \"Expected error: \" + this.code + \", got: \" + code);\n-        assertEquals(diagnostic.isError(), kind == Diagnostic.Kind.ERROR);\n+        assertEquals(this.code, code, \"Expected error: \" + this.code + \", got: \" + code);\n+        assertEquals(kind == Diagnostic.Kind.ERROR, diagnostic.isError());\n@@ -85,1 +85,1 @@\n-            assertEquals(diagnostic.getStartPosition(), startPosition, \"Start position\");\n+            assertEquals(startPosition, diagnostic.getStartPosition(), \"Start position\");\n@@ -88,1 +88,1 @@\n-            assertEquals(diagnostic.getEndPosition(), endPosition, \"End position\");\n+            assertEquals(endPosition, diagnostic.getEndPosition(), \"End position\");\n@@ -91,1 +91,1 @@\n-            assertEquals(diagnostic.getPosition(), position, \"Position\");\n+            assertEquals(position, diagnostic.getPosition(), \"Position\");\n","filename":"test\/langtools\/jdk\/jshell\/ExpectedDiagnostic.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng ExternalEditorTest\n+ * @run junit ExternalEditorTest\n@@ -50,8 +50,9 @@\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import org.junit.jupiter.api.AfterAll;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n@@ -59,0 +60,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -136,2 +138,1 @@\n-        testEditor(\n-                a -> assertCommand(a, \"if (true) {}\", \"\"),\n+        testEditor(a -> assertCommand(a, \"if (true) {}\", \"\"),\n@@ -144,2 +145,1 @@\n-                    assertEquals(getSource(),\n-                            \"if (true) {}\\n\" +\n+                    assertEquals(                            \"if (true) {}\\n\" +\n@@ -150,1 +150,1 @@\n-                            \"System.err.flush();\\n\");\n+                            \"System.err.flush();\\n\", getSource());\n@@ -176,1 +176,1 @@\n-    @BeforeClass\n+    @BeforeAll\n@@ -253,1 +253,2 @@\n-    @Test(enabled = false) \/\/ TODO 8159229\n+    @Test \/\/ TODO 8159229\n+    @Disabled\n@@ -267,1 +268,1 @@\n-    @AfterClass\n+    @AfterAll\n","filename":"test\/langtools\/jdk\/jshell\/ExternalEditorTest.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run testng FailOverDirectExecutionControlTest\n+ * @run junit FailOverDirectExecutionControlTest\n@@ -51,3 +51,0 @@\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n@@ -56,3 +53,6 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNull;\n-import static org.testng.Assert.assertTrue;\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -60,1 +60,0 @@\n-@Test\n@@ -96,1 +95,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -137,1 +136,1 @@\n-    @AfterMethod\n+    @AfterEach\n@@ -147,0 +146,1 @@\n+    @Test\n@@ -149,3 +149,3 @@\n-        assertEquals(logged.get(Level.FINEST).size(), 1);\n-        assertEquals(logged.get(Level.FINE).size(), 2);\n-        assertEquals(logged.get(Level.WARNING).size(), 2);\n+        assertEquals(1, logged.get(Level.FINEST).size());\n+        assertEquals(2, logged.get(Level.FINE).size());\n+        assertEquals(2, logged.get(Level.WARNING).size());\n","filename":"test\/langtools\/jdk\/jshell\/FailOverDirectExecutionControlTest.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng FailOverExecutionControlDyingLaunchTest\n+ * @run junit FailOverExecutionControlDyingLaunchTest\n@@ -35,2 +35,1 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -38,1 +37,0 @@\n-@Test\n@@ -41,1 +39,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/FailOverExecutionControlDyingLaunchTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng FailOverExecutionControlHangingLaunchTest\n+ * @run junit FailOverExecutionControlHangingLaunchTest\n@@ -34,2 +34,1 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -37,1 +36,0 @@\n-@Test\n@@ -40,1 +38,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/FailOverExecutionControlHangingLaunchTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng FailOverExecutionControlHangingListenTest\n+ * @run junit FailOverExecutionControlHangingListenTest\n@@ -36,2 +36,1 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -39,1 +38,0 @@\n-@Test\n@@ -42,1 +40,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/FailOverExecutionControlHangingListenTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng FailOverExecutionControlTest\n+ * @run junit FailOverExecutionControlTest\n@@ -34,2 +34,1 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -37,1 +36,0 @@\n-@Test\n@@ -40,1 +38,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/FailOverExecutionControlTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng FileManagerTest\n+ * @run junit FileManagerTest\n@@ -40,2 +40,3 @@\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -43,3 +44,0 @@\n-import static org.testng.Assert.assertTrue;\n-\n-@Test\n@@ -103,1 +101,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -109,0 +107,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/FileManagerTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng ForwardReferenceImportTest\n+ * @run junit ForwardReferenceImportTest\n@@ -33,1 +33,0 @@\n-import org.testng.annotations.Test;\n@@ -36,0 +35,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -37,1 +37,0 @@\n-@Test\n@@ -40,0 +39,1 @@\n+    @Test\n@@ -60,0 +60,1 @@\n+    @Test\n@@ -79,0 +80,1 @@\n+    @Test\n@@ -98,0 +100,1 @@\n+    @Test\n@@ -117,0 +120,1 @@\n+    @Test\n@@ -136,0 +140,1 @@\n+    @Test\n@@ -156,0 +161,1 @@\n+    @Test\n@@ -176,0 +182,1 @@\n+    @Test\n@@ -198,0 +205,1 @@\n+    @Test\n@@ -222,0 +230,1 @@\n+    @Test\n@@ -244,0 +253,1 @@\n+    @Test\n@@ -264,0 +274,1 @@\n+    @Test\n@@ -285,0 +296,1 @@\n+    @Test\n@@ -308,0 +320,1 @@\n+    @Test\n@@ -329,0 +342,1 @@\n+    @Test\n@@ -350,0 +364,1 @@\n+    @Test\n@@ -371,0 +386,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ForwardReferenceImportTest.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng ForwardReferenceTest\n+ * @run junit ForwardReferenceTest\n@@ -36,1 +36,0 @@\n-import org.testng.annotations.Test;\n@@ -40,1 +39,1 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -42,1 +41,2 @@\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -44,1 +44,0 @@\n-@Test\n@@ -47,0 +46,1 @@\n+    @Test\n@@ -59,0 +59,1 @@\n+    @Test\n@@ -71,0 +72,1 @@\n+    @Test\n@@ -90,0 +92,1 @@\n+    @Test\n@@ -112,0 +115,1 @@\n+    @Test\n@@ -136,0 +140,1 @@\n+    @Test\n@@ -153,0 +158,1 @@\n+    @Test\n@@ -162,3 +168,3 @@\n-        assertEquals(unsn.name(), \"A\", \"Wrong with unresolved\");\n-        assertEquals(getState().unresolvedDependencies(unsn).count(), 1, \"Wrong size unresolved\");\n-        assertEquals(getState().diagnostics(unsn).count(), 0L, \"Expected no diagnostics\");\n+        assertEquals(\"A\", unsn.name(), \"Wrong with unresolved\");\n+        assertEquals(1, getState().unresolvedDependencies(unsn).count(), \"Wrong size unresolved\");\n+        assertEquals(0L, getState().diagnostics(unsn).count(), \"Expected no diagnostics\");\n@@ -177,0 +183,1 @@\n+    @Test\n@@ -203,0 +210,1 @@\n+    @Test\n@@ -218,0 +226,1 @@\n+    @Test\n@@ -235,0 +244,1 @@\n+    @Test\n@@ -254,0 +264,1 @@\n+    @Test\n@@ -272,0 +283,1 @@\n+    @Test\n@@ -290,0 +302,1 @@\n+    @Test\n@@ -308,0 +321,1 @@\n+    @Test\n@@ -314,0 +328,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ForwardReferenceTest.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng GetResourceTest\n+ * @run junit GetResourceTest\n@@ -36,1 +36,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -39,1 +39,0 @@\n-@Test\n@@ -42,0 +41,1 @@\n+    @Test\n@@ -60,0 +60,1 @@\n+    @Test\n@@ -88,0 +89,1 @@\n+    @Test\n@@ -100,0 +102,1 @@\n+    @Test\n@@ -141,0 +144,1 @@\n+    @Test\n@@ -157,0 +161,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/GetResourceTest.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,1 @@\n-    private static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-\n-    private static final int TIMEOUT = (int)(2000 * timeoutFactor);\n+    private static final int TIMEOUT = (int)(2000 * Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\")));\n","filename":"test\/langtools\/jdk\/jshell\/HangingRemoteAgent.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run testng HighlightUITest\n+ * @run junit HighlightUITest\n@@ -41,1 +41,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -43,1 +43,0 @@\n-@Test\n@@ -50,0 +49,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/HighlightUITest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng HistoryTest\n+ * @run junit HistoryTest\n@@ -40,1 +40,0 @@\n-import org.testng.annotations.Test;\n@@ -44,2 +43,3 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.BeforeMethod;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -183,10 +183,10 @@\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_00\"), \"\/debug 0\");\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_01\"), \"void test() {\\\\\");\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_02\"), \"    System.err.println(1);\\\\\");\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_03\"), \"    System.err.println(`\\\\\\\\\\\\\\\\\\\\\");\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_04\"), \"    \\\\\\\\\\\\\");\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_05\"), \"`);\\\\\");\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_06\"), \"} \/\/test\");\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_07\"), \"\/debug 0\");\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_08\"), \"int i\");\n-        assertEquals(prefsMap.get(\"HISTORY_LINE_09\"), \"\/exit\");\n+        assertEquals(\"\/debug 0\", prefsMap.get(\"HISTORY_LINE_00\"));\n+        assertEquals(\"void test() {\\\\\", prefsMap.get(\"HISTORY_LINE_01\"));\n+        assertEquals(\"    System.err.println(1);\\\\\", prefsMap.get(\"HISTORY_LINE_02\"));\n+        assertEquals(\"    System.err.println(`\\\\\\\\\\\\\\\\\\\\\", prefsMap.get(\"HISTORY_LINE_03\"));\n+        assertEquals(\"    \\\\\\\\\\\\\", prefsMap.get(\"HISTORY_LINE_04\"));\n+        assertEquals(\"`);\\\\\", prefsMap.get(\"HISTORY_LINE_05\"));\n+        assertEquals(\"} \/\/test\", prefsMap.get(\"HISTORY_LINE_06\"));\n+        assertEquals(\"\/debug 0\", prefsMap.get(\"HISTORY_LINE_07\"));\n+        assertEquals(\"int i\", prefsMap.get(\"HISTORY_LINE_08\"));\n+        assertEquals(\"\/exit\", prefsMap.get(\"HISTORY_LINE_09\"));\n@@ -207,1 +207,1 @@\n-        assertEquals(history.current().toString(), expected);\n+        assertEquals(expected, history.current().toString());\n@@ -210,1 +210,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/HistoryTest.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng HistoryUITest\n+ * @run junit HistoryUITest\n@@ -41,1 +41,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -43,1 +43,0 @@\n-@Test\n@@ -50,0 +49,1 @@\n+    @Test\n@@ -81,0 +81,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/HistoryUITest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng IOTest\n+ * @run junit IOTest\n@@ -31,1 +31,2 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Test;\n@@ -33,3 +34,0 @@\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n@@ -40,0 +38,1 @@\n+    @Test\n@@ -42,1 +41,1 @@\n-        assertEquals(getOutput(), \"Test\" + LINE_SEPARATOR);\n+        assertEquals(\"Test\" + LINE_SEPARATOR, getOutput());\n@@ -45,0 +44,1 @@\n+    @Test\n@@ -47,1 +47,1 @@\n-        assertEquals(getErrorOutput(), \"Oops\" + LINE_SEPARATOR);\n+        assertEquals(\"Oops\" + LINE_SEPARATOR, getErrorOutput());\n@@ -50,0 +50,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/IOTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng IdGeneratorTest\n+ * @run junit IdGeneratorTest\n@@ -41,1 +41,3 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -43,4 +45,0 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-@Test\n@@ -49,0 +47,1 @@\n+    @Test\n@@ -60,0 +59,1 @@\n+    @Test\n@@ -72,1 +72,1 @@\n-                assertEquals(\"temp\" + (i + 1), v.name(), \"Custom id: \");\n+                assertEquals(v.name(), \"temp\" + (i + 1), \"Custom id: \");\n@@ -77,0 +77,1 @@\n+    @Test\n@@ -86,0 +87,1 @@\n+    @Test\n@@ -102,0 +104,1 @@\n+    @Test\n@@ -119,0 +122,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/IdGeneratorTest.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng IgnoreTest\n+ * @run junit IgnoreTest\n@@ -32,1 +32,0 @@\n-import org.testng.annotations.Test;\n@@ -39,0 +38,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -40,1 +40,0 @@\n-@Test\n@@ -43,0 +42,1 @@\n+    @Test\n@@ -61,0 +61,1 @@\n+    @Test\n@@ -74,0 +75,1 @@\n+    @Test\n@@ -88,0 +90,1 @@\n+    @Test\n@@ -101,0 +104,1 @@\n+    @Test\n@@ -107,0 +111,1 @@\n+    @Test\n@@ -114,0 +119,1 @@\n+    @Test\n@@ -122,0 +128,1 @@\n+    @Test\n@@ -129,0 +136,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/IgnoreTest.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng IllegalArgumentExceptionTest\n+ * @run junit IllegalArgumentExceptionTest\n@@ -36,3 +36,1 @@\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -40,0 +38,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -41,1 +40,0 @@\n-@Test\n@@ -57,0 +55,1 @@\n+    @Test\n@@ -61,0 +60,1 @@\n+    @Test\n@@ -65,0 +65,1 @@\n+    @Test\n@@ -69,0 +70,1 @@\n+    @Test\n@@ -73,0 +75,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/IllegalArgumentExceptionTest.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng ImportTest\n+ * @run junit ImportTest\n@@ -45,1 +45,0 @@\n-import org.testng.annotations.Test;\n@@ -54,0 +53,3 @@\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n@@ -55,1 +57,0 @@\n-@Test\n@@ -58,0 +59,1 @@\n+    @Test\n@@ -66,0 +68,1 @@\n+    @Test\n@@ -73,0 +76,1 @@\n+    @Test\n@@ -78,0 +82,1 @@\n+    @Test\n@@ -83,0 +88,1 @@\n+    @Test\n@@ -90,0 +96,1 @@\n+    @Test\n@@ -96,0 +103,1 @@\n+    @Test\n@@ -101,0 +109,1 @@\n+    @Test\n@@ -106,0 +115,1 @@\n+    @Test\n@@ -146,0 +156,1 @@\n+    @Test\n@@ -170,0 +181,1 @@\n+    @Test\n@@ -175,0 +187,1 @@\n+    @Test\n@@ -180,3 +193,3 @@\n-    @org.testng.annotations.BeforeMethod\n-    public void setUp(Method m) {\n-        switch (m.getName()) {\n+    @BeforeEach\n+    public void setUp(TestInfo testInfo) {\n+        switch (testInfo.getTestMethod().orElseThrow().getName()) {\n","filename":"test\/langtools\/jdk\/jshell\/ImportTest.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run testng InaccessibleExpressionTest\n+ * @run junit InaccessibleExpressionTest\n@@ -39,1 +39,0 @@\n-import org.testng.annotations.BeforeMethod;\n@@ -41,1 +40,3 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -43,3 +44,0 @@\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n@@ -48,1 +46,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -79,0 +77,1 @@\n+    @Test\n@@ -82,1 +81,1 @@\n-        assertEquals(down.typeName(), \"priv.Packp\");\n+        assertEquals(\"priv.Packp\", down.typeName());\n@@ -85,1 +84,1 @@\n-        assertEquals(list.typeName(), \"priv.MyList\");\n+        assertEquals(\"priv.MyList\", list.typeName());\n@@ -88,1 +87,1 @@\n-        assertEquals(one.typeName(), \"priv.GetPriv.Count\");\n+        assertEquals(\"priv.GetPriv.Count\", one.typeName());\n@@ -93,0 +92,1 @@\n+    @Test\n@@ -101,1 +101,1 @@\n-        assertEquals(n.typeName(), \"Top.Inner\");\n+        assertEquals(\"Top.Inner\", n.typeName());\n","filename":"test\/langtools\/jdk\/jshell\/InaccessibleExpressionTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng IndentUITest\n+ * @run junit IndentUITest\n@@ -41,1 +41,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -43,1 +43,0 @@\n-@Test\n@@ -50,0 +49,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/IndentUITest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng InferTypeTest\n+ * @run junit InferTypeTest\n@@ -36,1 +36,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -38,1 +38,0 @@\n-@Test\n@@ -41,0 +40,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/InferTypeTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @run testng\/othervm -Dstderr.encoding=UTF-8 -Dstdin.encoding=UTF-8 -Dstdout.encoding=UTF-8 InputUITest\n+ * @run junit\/othervm -Dstderr.encoding=UTF-8 -Dstdin.encoding=UTF-8 -Dstdout.encoding=UTF-8 InputUITest\n@@ -43,1 +43,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -45,1 +45,0 @@\n-@Test\n@@ -56,0 +55,1 @@\n+    @Test\n@@ -71,0 +71,1 @@\n+    @Test\n@@ -88,0 +89,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/InputUITest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng JLCollisionTest\n+ * @run junit JLCollisionTest\n@@ -34,1 +34,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -36,1 +36,0 @@\n-@Test\n@@ -39,0 +38,1 @@\n+    @Test\n@@ -46,0 +46,1 @@\n+    @Test\n@@ -53,0 +54,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JLCollisionTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng JShellQueryTest\n+ * @run junit JShellQueryTest\n@@ -32,1 +32,0 @@\n-import org.testng.annotations.Test;\n@@ -39,1 +38,2 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Test;\n@@ -41,1 +41,0 @@\n-@Test\n@@ -44,0 +43,1 @@\n+    @Test\n@@ -57,0 +57,1 @@\n+    @Test\n@@ -70,0 +71,1 @@\n+    @Test\n@@ -82,0 +84,1 @@\n+    @Test\n@@ -94,0 +97,1 @@\n+    @Test\n@@ -106,0 +110,1 @@\n+    @Test\n@@ -113,1 +118,1 @@\n-        assertEquals(res, \"compiler.err.cant.resolve.location.args+compiler.err.prob.found.req\");\n+        assertEquals(\"compiler.err.cant.resolve.location.args+compiler.err.prob.found.req\", res);\n@@ -116,0 +121,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JShellQueryTest.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng JShellStateClosedTest\n+ * @run junit JShellStateClosedTest\n@@ -39,1 +39,2 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n@@ -41,3 +42,0 @@\n-import static org.testng.Assert.fail;\n-\n-@Test\n@@ -56,0 +54,1 @@\n+    @Test\n@@ -63,0 +62,1 @@\n+    @Test\n@@ -70,0 +70,1 @@\n+    @Test\n@@ -77,0 +78,1 @@\n+    @Test\n@@ -83,0 +85,1 @@\n+    @Test\n@@ -95,0 +98,1 @@\n+    @Test\n@@ -120,0 +124,1 @@\n+    @Test\n@@ -124,0 +129,1 @@\n+    @Test\n@@ -128,0 +134,1 @@\n+    @Test\n@@ -132,0 +139,1 @@\n+    @Test\n@@ -136,0 +144,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JShellStateClosedTest.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng JavadocTest\n+ * @run junit JavadocTest\n@@ -46,1 +46,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -48,1 +48,0 @@\n-@Test\n@@ -53,0 +52,1 @@\n+    @Test\n@@ -68,0 +68,1 @@\n+    @Test\n@@ -110,0 +111,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JavadocTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng JdiBadOptionLaunchExecutionControlTest\n+ * @run junit JdiBadOptionLaunchExecutionControlTest\n@@ -34,1 +34,0 @@\n-import org.testng.annotations.Test;\n@@ -36,2 +35,3 @@\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n@@ -39,1 +39,0 @@\n-@Test\n@@ -45,0 +44,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JdiBadOptionLaunchExecutionControlTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng JdiBadOptionListenExecutionControlTest\n+ * @run junit JdiBadOptionListenExecutionControlTest\n@@ -34,1 +34,0 @@\n-import org.testng.annotations.Test;\n@@ -36,2 +35,3 @@\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n@@ -39,1 +39,0 @@\n-@Test\n@@ -45,0 +44,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JdiBadOptionListenExecutionControlTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng JdiBogusHostListenExecutionControlTest\n+ * @run junit JdiBogusHostListenExecutionControlTest\n@@ -34,1 +34,0 @@\n-import org.testng.annotations.Test;\n@@ -36,2 +35,3 @@\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n@@ -39,1 +39,0 @@\n-@Test\n@@ -47,0 +46,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JdiBogusHostListenExecutionControlTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng JdiFailingLaunchExecutionControlTest\n+ * @run junit JdiFailingLaunchExecutionControlTest\n@@ -33,3 +33,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n@@ -37,1 +37,0 @@\n-@Test\n@@ -43,0 +42,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JdiFailingLaunchExecutionControlTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng JdiFailingListenExecutionControlTest\n+ * @run junit JdiFailingListenExecutionControlTest\n@@ -33,3 +33,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n@@ -37,1 +37,0 @@\n-@Test\n@@ -43,0 +42,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JdiFailingListenExecutionControlTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng JdiHangingLaunchExecutionControlTest\n+ * @run junit\/timeout=480 JdiHangingLaunchExecutionControlTest\n@@ -33,3 +33,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n@@ -37,1 +37,0 @@\n-@Test\n@@ -43,0 +42,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JdiHangingLaunchExecutionControlTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng JdiHangingListenExecutionControlTest\n+ * @run junit\/timeout=480 JdiHangingListenExecutionControlTest\n@@ -34,3 +34,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Test;\n@@ -38,1 +38,0 @@\n-@Test\n@@ -44,0 +43,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/JdiHangingListenExecutionControlTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng JdiLaunchingExecutionControlTest\n+ * @run junit JdiLaunchingExecutionControlTest\n@@ -35,2 +35,1 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -38,1 +37,0 @@\n-@Test\n@@ -41,1 +39,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/JdiLaunchingExecutionControlTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng JdiListeningExecutionControlTest\n+ * @run junit JdiListeningExecutionControlTest\n@@ -35,2 +35,1 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -38,1 +37,0 @@\n-@Test\n@@ -41,1 +39,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/JdiListeningExecutionControlTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng JdiListeningLocalhostExecutionControlTest\n+ * @run junit JdiListeningLocalhostExecutionControlTest\n@@ -35,2 +35,1 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -38,1 +37,0 @@\n-@Test\n@@ -41,1 +39,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/JdiListeningLocalhostExecutionControlTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng JdiStarterTest\n+ * @run junit JdiStarterTest\n@@ -37,1 +37,0 @@\n-import org.testng.annotations.Test;\n@@ -44,1 +43,2 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Test;\n@@ -46,1 +46,0 @@\n-@Test\n@@ -49,0 +48,1 @@\n+    @Test\n@@ -53,4 +53,4 @@\n-            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_HOST_NAME), \"\");\n-            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_LAUNCH), \"false\");\n-            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_REMOTE_AGENT), \"jdk.jshell.execution.RemoteExecutionControl\");\n-            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_TIMEOUT), \"5000\");\n+            assertEquals(\"\", parameters.get(JdiExecutionControlProvider.PARAM_HOST_NAME));\n+            assertEquals(\"false\", parameters.get(JdiExecutionControlProvider.PARAM_LAUNCH));\n+            assertEquals(\"jdk.jshell.execution.RemoteExecutionControl\", parameters.get(JdiExecutionControlProvider.PARAM_REMOTE_AGENT));\n+            assertEquals(\"5000\", parameters.get(JdiExecutionControlProvider.PARAM_TIMEOUT));\n","filename":"test\/langtools\/jdk\/jshell\/JdiStarterTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng KullaCompletenessStressTest\n+ * @run junit KullaCompletenessStressTest\n@@ -34,1 +34,3 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n@@ -36,1 +38,1 @@\n-@Test\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -39,0 +41,1 @@\n+    @Test\n@@ -47,6 +50,5 @@\n-        if (!file.exists()) {\n-            System.out.println(\"jdk.jshell sources are not exist. Test has been skipped. Path: \" + file.toString());\n-            return new File[]{};\n-        }else {\n-            return new File[]{file};\n-        }\n+\n+        Assumptions.assumeTrue(file.exists(),\n+                               \"jdk.jshell sources are not exist. Test has been skipped. Path: \" + file.toString());\n+\n+        return new File[]{file};\n","filename":"test\/langtools\/jdk\/jshell\/KullaCompletenessStressTest.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,0 @@\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n@@ -83,1 +81,1 @@\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -86,0 +84,2 @@\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -169,1 +169,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -205,1 +205,1 @@\n-    @AfterMethod\n+    @AfterEach\n@@ -229,1 +229,1 @@\n-        assertEquals(unresolved.size(), unresolvedSize, \"Input: \" + key.source() + \", checking unresolved: \");\n+        assertEquals(unresolvedSize, unresolved.size(), \"Input: \" + key.source() + \", checking unresolved: \");\n@@ -236,3 +236,3 @@\n-        assertEquals(unresolved.size(), 1, \"Given input: \" + input + \", checking unresolved\");\n-        assertEquals(unresolved.get(0), name, \"Given input: \" + input + \", checking unresolved: \");\n-        assertEquals(getState().status(key), status, \"Given input: \" + input + \", checking status: \");\n+        assertEquals(1, unresolved.size(), \"Given input: \" + input + \", checking unresolved\");\n+        assertEquals(name, unresolved.get(0), \"Given input: \" + input + \", checking unresolved: \");\n+        assertEquals(status, getState().status(key), \"Given input: \" + input + \", checking status: \");\n@@ -246,3 +246,3 @@\n-        assertEquals(sn.name(), name, \"Given input: \" + input + \", checking name\");\n-        assertEquals(getState().unresolvedDependencies(sn).count(), unresolvedSize, \"Given input: \" + input + \", checking unresolved\");\n-        assertEquals(getState().diagnostics(sn).count(), (long) diagnosticsSize, \"Given input: \" + input + \", checking diagnostics\");\n+        assertEquals(name, sn.name(), \"Given input: \" + input + \", checking name\");\n+        assertEquals(unresolvedSize, getState().unresolvedDependencies(sn).count(), \"Given input: \" + input + \", checking unresolved\");\n+        assertEquals((long) diagnosticsSize, getState().diagnostics(sn).count(), \"Given input: \" + input + \", checking diagnostics\");\n@@ -255,1 +255,1 @@\n-        assertEquals(source, input, \"Key \\\"\" + input + \"\\\" source mismatch, got: \" + source + \", expected: \" + input);\n+        assertEquals(input, source, \"Key \\\"\" + input + \"\\\" source mismatch, got: \" + source + \", expected: \" + input);\n@@ -257,1 +257,1 @@\n-        assertEquals(subkind, expectedSubKind, \"Key \\\"\" + input + \"\\\" subkind mismatch, got: \"\n+        assertEquals(expectedSubKind, subkind, \"Key \\\"\" + input + \"\\\" subkind mismatch, got: \"\n@@ -259,1 +259,1 @@\n-        assertEquals(subkind.isExecutable(), isExecutable, \"Key \\\"\" + input + \"\\\", expected isExecutable: \"\n+        assertEquals(isExecutable, subkind.isExecutable(), \"Key \\\"\" + input + \"\\\", expected isExecutable: \"\n@@ -262,2 +262,2 @@\n-        assertEquals(key.kind(), expectedKind, \"Checking kind: \");\n-        assertEquals(expectedSubKind.kind(), expectedKind, \"Checking kind: \");\n+        assertEquals(expectedKind, key.kind(), \"Checking kind: \");\n+        assertEquals(expectedKind, expectedSubKind.kind(), \"Checking kind: \");\n@@ -313,1 +313,1 @@\n-        assertEquals(importKey.name(), name, \"Input \\\"\" + input +\n+        assertEquals(name, importKey.name(), \"Input \\\"\" + input +\n@@ -315,1 +315,1 @@\n-        assertEquals(importKey.kind(), Kind.IMPORT, \"Checking kind: \");\n+        assertEquals(Kind.IMPORT, importKey.kind(), \"Checking kind: \");\n@@ -324,1 +324,1 @@\n-        assertEquals(declKey.name(), name, \"Input \\\"\" + input +\n+        assertEquals(name, declKey.name(), \"Input \\\"\" + input +\n@@ -334,1 +334,1 @@\n-        assertEquals(signature, typeName, \"Key \\\"\" + input +\n+        assertEquals(typeName, signature, \"Key \\\"\" + input +\n@@ -336,1 +336,1 @@\n-        assertEquals(variableKey.kind(), Kind.VAR, \"Checking kind: \");\n+        assertEquals(Kind.VAR, variableKey.kind(), \"Checking kind: \");\n@@ -344,1 +344,1 @@\n-        assertEquals(exprKey.name(), name, \"Input \\\"\" + input +\n+        assertEquals(name, exprKey.name(), \"Input \\\"\" + input +\n@@ -346,1 +346,1 @@\n-        assertEquals(exprKey.typeName(), typeName, \"Key \\\"\" + input +\n+        assertEquals(typeName, exprKey.typeName(), \"Key \\\"\" + input +\n@@ -348,1 +348,1 @@\n-        assertEquals(exprKey.kind(), Kind.EXPRESSION, \"Checking kind: \");\n+        assertEquals(Kind.EXPRESSION, exprKey.kind(), \"Checking kind: \");\n@@ -406,1 +406,1 @@\n-        assertEquals(sns, exp);\n+        assertEquals(exp, sns);\n@@ -487,1 +487,1 @@\n-        assertEquals(dispatched.size(), events.size(), \"dispatched event size not the same as event size\");\n+        assertEquals(events.size(), dispatched.size(), \"dispatched event size not the same as event size\");\n@@ -489,1 +489,1 @@\n-            assertEquals(dispatched.get(i), events.get(i), \"Event element \" + i + \" does not match\");\n+            assertEquals(events.get(i), dispatched.get(i), \"Event element \" + i + \" does not match\");\n@@ -503,1 +503,1 @@\n-                            assertEquals(old, evt.snippet(),\n+                            assertEquals(evt.snippet(), old,\n@@ -507,1 +507,1 @@\n-                            assertEquals(old, evt.snippet(),\n+                            assertEquals(evt.snippet(), old,\n@@ -515,1 +515,1 @@\n-                                assertNotEquals(old, evt.snippet(),\n+                                assertNotEquals(evt.snippet(), old,\n@@ -520,1 +520,1 @@\n-                                assertEquals(old, evt.snippet(),\n+                                assertEquals(evt.snippet(), old,\n@@ -560,1 +560,1 @@\n-        assertEquals(groupedEvents.size(), eventChains.length, \"Number of main events\");\n+        assertEquals(eventChains.length, groupedEvents.size(), \"Number of main events\");\n@@ -583,1 +583,1 @@\n-                assertEquals(main.value(), eventChain.value, \"Expected execution value of: \" + eventChain.value +\n+                assertEquals(eventChain.value, main.value(), \"Expected execution value of: \" + eventChain.value +\n@@ -588,1 +588,1 @@\n-                    assertEquals(eventChain.exceptionClass, null, \"Expected an exception of class \"\n+                    assertEquals(null, eventChain.exceptionClass, \"Expected an exception of class \"\n@@ -601,1 +601,1 @@\n-                    assertEquals(diagnostics.size(), 0, \"Expected no diagnostics, got: \" + diagnosticsToString(diagnostics));\n+                    assertEquals(0, diagnostics.size(), \"Expected no diagnostics, got: \" + diagnosticsToString(diagnostics));\n@@ -615,1 +615,1 @@\n-                            assertEquals(diagnostics.size(), 0, \"Expected no diagnostics, got: \" + diagnosticsToString(diagnostics));\n+                            assertEquals(0, diagnostics.size(), \"Expected no diagnostics, got: \" + diagnosticsToString(diagnostics));\n@@ -630,1 +630,1 @@\n-        assertEquals(events.size(), 0, \"Expected no events, got: \" + events.size());\n+        assertEquals(0, events.size(), \"Expected no events, got: \" + events.size());\n@@ -664,1 +664,1 @@\n-        assertEquals(value, expected, \"Expected var value of: \" + expected + \", but got: \" + value);\n+        assertEquals(expected, value, \"Expected var value of: \" + expected + \", but got: \" + value);\n@@ -688,1 +688,1 @@\n-        assertEquals(getState().status(key), REJECTED);\n+        assertEquals(REJECTED, getState().status(key));\n@@ -731,1 +731,1 @@\n-        assertEquals(signature, expectedSignature,\n+        assertEquals(expectedSignature, signature,\n@@ -743,1 +743,1 @@\n-        assertEquals(signature, expectedTypeName,\n+        assertEquals(expectedTypeName, signature,\n@@ -754,1 +754,1 @@\n-        assertEquals(declarationKey.name(), expectedName,\n+        assertEquals(expectedName, declarationKey.name(),\n@@ -757,1 +757,1 @@\n-        assertEquals(unresolved, unressz, \"Expected \" + source + \" to have \" + unressz\n+        assertEquals(unressz, unresolved, \"Expected \" + source + \" to have \" + unressz\n@@ -760,1 +760,1 @@\n-        assertEquals(otherCorralledErrorsCount, othersz, \"Expected \" + source + \" to have \" + othersz\n+        assertEquals(othersz, otherCorralledErrorsCount, \"Expected \" + source + \" to have \" + othersz\n@@ -767,1 +767,1 @@\n-        assertEquals(actualSubKind, expectedSubKind,\n+        assertEquals(expectedSubKind, actualSubKind,\n@@ -770,1 +770,1 @@\n-        assertEquals(status, expectedStatus, \"Expected \" + source + \" to be \"\n+        assertEquals(expectedStatus, status, \"Expected \" + source + \" to be \"\n@@ -773,2 +773,2 @@\n-        assertEquals(key.kind(), expectedKind, \"Checking kind: \");\n-        assertEquals(expectedSubKind.kind(), expectedKind, \"Checking kind: \");\n+        assertEquals(expectedKind, key.kind(), \"Checking kind: \");\n+        assertEquals(expectedKind, expectedSubKind.kind(), \"Checking kind: \");\n@@ -799,3 +799,3 @@\n-        if (status != null) assertEquals(ci.completeness(), status, \"Input : \" + input + \", status: \");\n-        assertEquals(ci.source(), source, \"Input : \" + input + \", source: \");\n-        if (remaining != null) assertEquals(ci.remaining(), remaining, \"Input : \" + input + \", remaining: \");\n+        if (status != null) assertEquals(status, ci.completeness(), \"Input : \" + input + \", status: \");\n+        assertEquals(source, ci.source(), \"Input : \" + input + \", source: \");\n+        if (remaining != null) assertEquals(remaining, ci.remaining(), \"Input : \" + input + \", remaining: \");\n@@ -804,1 +804,1 @@\n-            assertEquals(ci.completeness().isComplete(), isExpectedComplete, \"Input : \" + input + \", isComplete: \");\n+            assertEquals(isExpectedComplete, ci.completeness().isComplete(), \"Input : \" + input + \", isComplete: \");\n@@ -809,1 +809,1 @@\n-        assertEquals(getState().variables().count(), cnt, \"Variables : \" + getState().variables().collect(toList()));\n+        assertEquals(cnt, getState().variables().count(), \"Variables : \" + getState().variables().collect(toList()));\n@@ -813,1 +813,1 @@\n-        assertEquals(getState().methods().count(), cnt, \"Methods : \" + getState().methods().collect(toList()));\n+        assertEquals(cnt, getState().methods().count(), \"Methods : \" + getState().methods().collect(toList()));\n@@ -817,1 +817,1 @@\n-        assertEquals(getState().types().count(), cnt, \"Types : \" + getState().types().collect(toList()));\n+        assertEquals(cnt, getState().types().count(), \"Types : \" + getState().types().collect(toList()));\n@@ -823,1 +823,1 @@\n-        assertEquals(allSnippets.size(), snippets.size());\n+        assertEquals(snippets.size(), allSnippets.size());\n@@ -828,1 +828,1 @@\n-                assertEquals(actual, exp, String.format(\"Difference in #%d. Expected: %s, actual: %s\",\n+                assertEquals(exp, actual, String.format(\"Difference in #%d. Expected: %s, actual: %s\",\n@@ -844,1 +844,1 @@\n-                assertEquals(expected[index], key, String.format(\"Difference in #%d. Expected: %s, actual: %s\", index, key, expected[index]));\n+                assertEquals(key, expected[index], String.format(\"Difference in #%d. Expected: %s, actual: %s\", index, key, expected[index]));\n@@ -856,1 +856,1 @@\n-        assertEquals(active, got, label);\n+        assertEquals(got, active, label);\n@@ -876,2 +876,2 @@\n-        assertEquals(got.size(), expected.size(), \"Expected : \" + expected + \", actual : \" + members);\n-        assertEquals(got, expected);\n+        assertEquals(expected.size(), got.size(), \"Expected : \" + expected + \", actual : \" + members);\n+        assertEquals(expected, got);\n@@ -895,1 +895,1 @@\n-            assertEquals(methodKey.parameterTypes(), expectedInfo.type.substring(1, lastIndexOf), \"Parameter types\");\n+            assertEquals(expectedInfo.type.substring(1, lastIndexOf), methodKey.parameterTypes(), \"Parameter types\");\n@@ -909,1 +909,1 @@\n-        assertEquals(completions, Arrays.asList(expected), \"Input: \" + code + \", \" + completions.toString());\n+        assertEquals(Arrays.asList(expected), completions, \"Input: \" + code + \", \" + completions.toString());\n@@ -943,1 +943,1 @@\n-        assertEquals(inferredType, expectedType, \"Input: \" + code + \", \" + inferredType);\n+        assertEquals(expectedType, inferredType, \"Input: \" + code + \", \" + inferredType);\n@@ -955,3 +955,3 @@\n-        assertEquals(candidates.getNames(), Arrays.asList(fqns), \"Input: \" + code + \", candidates=\" + candidates.getNames());\n-        assertEquals(candidates.getSimpleNameLength(), simpleNameLen, \"Input: \" + code + \", simpleNameLen=\" + candidates.getSimpleNameLength());\n-        assertEquals(candidates.isResolvable(), resolvable, \"Input: \" + code + \", resolvable=\" + candidates.isResolvable());\n+        assertEquals(Arrays.asList(fqns), candidates.getNames(), \"Input: \" + code + \", candidates=\" + candidates.getNames());\n+        assertEquals(simpleNameLen, candidates.getSimpleNameLength(), \"Input: \" + code + \", simpleNameLen=\" + candidates.getSimpleNameLength());\n+        assertEquals(resolvable, candidates.isResolvable(), \"Input: \" + code + \", resolvable=\" + candidates.isResolvable());\n@@ -978,1 +978,1 @@\n-        assertEquals(docSet, expectedSet, \"Input: \" + code);\n+        assertEquals(expectedSet, docSet, \"Input: \" + code);\n@@ -990,1 +990,1 @@\n-        assertEquals(docSet, expectedSet, \"Input: \" + code);\n+        assertEquals(expectedSet, docSet, \"Input: \" + code);\n@@ -1186,1 +1186,1 @@\n-                assertEquals(ste.isSignatureChange(), isSignatureChange(),\n+                assertEquals(isSignatureChange(), ste.isSignatureChange(),\n@@ -1209,1 +1209,1 @@\n-                    assertEquals(sn.id(), testKey.id(), \"Expected IDs to match: \" + testKey + \", got: \" + sn\n+                    assertEquals(testKey.id(), sn.id(), \"Expected IDs to match: \" + testKey + \", got: \" + sn\n@@ -1212,1 +1212,1 @@\n-                    assertEquals(sn, testKey, \"Expected key to be: \" + testKey + \", got: \" + sn\n+                    assertEquals(testKey, sn, \"Expected key to be: \" + testKey + \", got: \" + sn\n@@ -1220,1 +1220,1 @@\n-                assertEquals(status, expected, \"Expected status to be: \" + expected + \", got: \" + status +\n+                assertEquals(expected, status, \"Expected status to be: \" + expected + \", got: \" + status +\n","filename":"test\/langtools\/jdk\/jshell\/KullaTesting.java","additions":75,"deletions":75,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng\/othervm LocalExecutionClassPathTest\n+ * @run junit\/othervm LocalExecutionClassPathTest\n@@ -37,1 +37,2 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n@@ -39,0 +40,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n","filename":"test\/langtools\/jdk\/jshell\/LocalExecutionClassPathTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng\/othervm LocalExecutionContextLoaderParentTest\n+ * @run junit\/othervm LocalExecutionContextLoaderParentTest\n@@ -52,2 +52,3 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeTest;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n@@ -55,0 +56,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -57,1 +59,1 @@\n-    @BeforeTest\n+    @BeforeAll\n","filename":"test\/langtools\/jdk\/jshell\/LocalExecutionContextLoaderParentTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import org.testng.annotations.BeforeTest;\n+import org.junit.jupiter.api.BeforeAll;\n@@ -52,1 +52,1 @@\n-    @BeforeTest\n+    @BeforeAll\n","filename":"test\/langtools\/jdk\/jshell\/LocalExecutionTestSupport.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng LocalStopExecutionTest\n+ * @run junit LocalStopExecutionTest\n@@ -43,2 +43,3 @@\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -46,3 +47,0 @@\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n@@ -51,1 +49,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/LocalStopExecutionTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng MethodsTest\n+ * @run junit MethodsTest\n@@ -37,1 +37,0 @@\n-import org.testng.annotations.Test;\n@@ -43,1 +42,3 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -45,1 +46,0 @@\n-@Test\n@@ -48,0 +48,1 @@\n+    @Test\n@@ -52,0 +53,1 @@\n+    @Test\n@@ -61,0 +63,1 @@\n+    @Test\n@@ -70,1 +73,2 @@\n-    @Test(enabled = false) \/\/ TODO 8081690\n+    @Test \/\/ TODO 8081690\n+    @Disabled\n@@ -82,0 +86,1 @@\n+    @Test\n@@ -90,0 +95,1 @@\n+    @Test\n@@ -98,0 +104,1 @@\n+    @Test\n@@ -142,0 +149,1 @@\n+    @Test\n@@ -161,0 +169,1 @@\n+    @Test\n@@ -182,0 +191,1 @@\n+    @Test\n@@ -195,0 +205,1 @@\n+    @Test\n@@ -207,0 +218,1 @@\n+    @Test\n@@ -223,0 +235,1 @@\n+    @Test\n@@ -226,2 +239,1 @@\n-        assertEquals(getState().unresolvedDependencies(m1).collect(Collectors.toList()),\n-                List.of(\"method f()\"));\n+        assertEquals(                List.of(\"method f()\"), getState().unresolvedDependencies(m1).collect(Collectors.toList()));\n@@ -231,1 +243,1 @@\n-        assertEquals(unr.size(), 2);\n+        assertEquals(2, unr.size());\n@@ -234,1 +246,1 @@\n-        assertEquals(unr.size(), 0, \"unexpected entry: \" + unr);\n+        assertEquals(0, unr.size(), \"unexpected entry: \" + unr);\n@@ -239,0 +251,1 @@\n+    @Test\n@@ -270,0 +283,1 @@\n+    @Test\n@@ -289,0 +303,1 @@\n+    @Test\n@@ -308,0 +323,1 @@\n+    @Test\n@@ -321,0 +337,1 @@\n+    @Test\n@@ -333,1 +350,2 @@\n-    @Test(enabled = false) \/\/ TODO 8081689\n+    @Test \/\/ TODO 8081689\n+    @Disabled\n@@ -354,0 +372,1 @@\n+    @Test\n@@ -379,0 +398,1 @@\n+    @Test\n@@ -381,1 +401,1 @@\n-        assertEquals(m1.parameterTypes(), \"int...\");\n+        assertEquals(\"int...\", m1.parameterTypes());\n@@ -383,1 +403,1 @@\n-        assertEquals(m2.parameterTypes(), \"int[]...\");\n+        assertEquals(\"int[]...\", m2.parameterTypes());\n@@ -385,1 +405,1 @@\n-        assertEquals(m3.parameterTypes(), \"int[][]\");\n+        assertEquals(\"int[][]\", m3.parameterTypes());\n@@ -388,0 +408,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/MethodsTest.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng ModifiersTest\n+ * @run junit ModifiersTest\n@@ -37,2 +37,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -40,1 +42,1 @@\n-@Test\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -43,1 +45,0 @@\n-    @DataProvider(name = \"ignoredModifiers\")\n@@ -80,1 +81,2 @@\n-    @Test(dataProvider = \"ignoredModifiers\")\n+    @ParameterizedTest\n+    @MethodSource(\"getTestCases\")\n@@ -98,0 +100,1 @@\n+    @Test\n@@ -111,0 +114,1 @@\n+    @Test\n@@ -122,0 +126,1 @@\n+    @Test\n@@ -137,0 +142,1 @@\n+    @Test\n@@ -143,0 +149,1 @@\n+    @Test\n@@ -151,0 +158,1 @@\n+    @Test\n@@ -158,0 +166,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ModifiersTest.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Test;\n@@ -42,1 +42,1 @@\n- * @run testng MultipleDocumentationTest\n+ * @run junit MultipleDocumentationTest\n@@ -44,1 +44,0 @@\n-@Test\n@@ -47,0 +46,1 @@\n+    @Test\n@@ -71,1 +71,1 @@\n-                assertEquals(javadocs2, javadocs1);\n+                assertEquals(javadocs1, javadocs2);\n","filename":"test\/langtools\/jdk\/jshell\/MultipleDocumentationTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n","filename":"test\/langtools\/jdk\/jshell\/MyExecutionControl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng NullTest\n+ * @run junit NullTest\n@@ -31,1 +31,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -33,1 +33,0 @@\n-@Test\n@@ -36,0 +35,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/NullTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run testng\/othervm PasteAndMeasurementsUITest\n+ * @run junit\/othervm PasteAndMeasurementsUITest\n@@ -49,1 +49,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -51,1 +51,0 @@\n-@Test\n@@ -58,0 +57,1 @@\n+    @Test\n@@ -80,0 +80,1 @@\n+    @Test\n@@ -94,0 +95,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/PasteAndMeasurementsUITest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng PipeInputStreamTest\n+ * @run junit PipeInputStreamTest\n@@ -37,1 +37,0 @@\n-import org.testng.annotations.Test;\n@@ -41,1 +40,2 @@\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n@@ -43,1 +43,0 @@\n-@Test\n@@ -46,0 +45,1 @@\n+    @Test\n@@ -52,2 +52,2 @@\n-        assertEquals(in.read(data), 1);\n-        assertEquals(data[0], 'a');\n+        assertEquals(1, in.read(data));\n+        assertEquals('a', data[0]);\n@@ -55,4 +55,4 @@\n-        assertEquals(in.read(data), 3);\n-        assertEquals(data[0], 'a');\n-        assertEquals(data[1], 'b');\n-        assertEquals(data[2], 'c');\n+        assertEquals(3, in.read(data));\n+        assertEquals('a', data[0]);\n+        assertEquals('b', data[1]);\n+        assertEquals('c', data[2]);\n","filename":"test\/langtools\/jdk\/jshell\/PipeInputStreamTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng PrimitiveInstanceOfTest\n+ * @run junit PrimitiveInstanceOfTest\n@@ -31,1 +31,0 @@\n-import org.testng.annotations.Test;\n@@ -35,1 +34,3 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -37,1 +38,0 @@\n-@Test\n@@ -40,0 +40,1 @@\n+    @Test\n@@ -46,0 +47,1 @@\n+    @Test\n@@ -52,0 +54,1 @@\n+    @Test\n@@ -58,0 +61,1 @@\n+    @Test\n@@ -63,1 +67,1 @@\n-    @org.testng.annotations.BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/PrimitiveInstanceOfTest.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng RecordsTest\n+ * @run junit RecordsTest\n@@ -33,1 +33,0 @@\n-import org.testng.annotations.Test;\n@@ -38,2 +37,2 @@\n-import static org.testng.Assert.assertEquals;\n-import org.testng.annotations.BeforeMethod;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Test;\n@@ -41,1 +40,0 @@\n-@Test\n@@ -44,0 +42,1 @@\n+    @Test\n@@ -46,1 +45,1 @@\n-        assertEquals(varKey(assertEval(\"R r = new R(\\\"r\\\", 42);\")).name(), \"r\");\n+        assertEquals(\"r\", varKey(assertEval(\"R r = new R(\\\"r\\\", 42);\")).name());\n@@ -51,0 +50,1 @@\n+    @Test\n@@ -69,0 +69,1 @@\n+    @Test\n@@ -70,1 +71,1 @@\n-        assertEquals(varKey(assertEval(\"String record = \\\"\\\";\")).name(), \"record\");\n+        assertEquals(\"record\", varKey(assertEval(\"String record = \\\"\\\";\")).name());\n@@ -74,0 +75,1 @@\n+    @Test\n@@ -75,1 +77,1 @@\n-        assertEquals(methodKey(assertEval(\"String record(String record) { return record + record; }\")).name(), \"record\");\n+        assertEquals(\"record\", methodKey(assertEval(\"String record(String record) { return record + record; }\")).name());\n","filename":"test\/langtools\/jdk\/jshell\/RecordsTest.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng RejectedFailedTest\n+ * @run junit RejectedFailedTest\n@@ -34,1 +34,0 @@\n-import org.testng.annotations.Test;\n@@ -43,2 +42,3 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -46,1 +46,0 @@\n-@Test\n@@ -51,1 +50,1 @@\n-        assertEquals(events.size(), 1, \"Expected one event, got: \" + events.size());\n+        assertEquals(1, events.size(), \"Expected one event, got: \" + events.size());\n@@ -55,2 +54,2 @@\n-        assertEquals(e.exception(), null, \"Expected exception to be null.\");\n-        assertEquals(e.value(), null, \"Expected value to be null.\");\n+        assertEquals(null, e.exception(), \"Expected exception to be null.\");\n+        assertEquals(null, e.value(), \"Expected value to be null.\");\n@@ -60,1 +59,1 @@\n-        assertEquals(key.kind(), kind, \"Expected kind: \" + kind + \", got: \" + key.kind());\n+        assertEquals(kind, key.kind(), \"Expected kind: \" + kind + \", got: \" + key.kind());\n@@ -62,1 +61,1 @@\n-        assertEquals(key.subKind(), expectedSubKind, \"SubKind: \");\n+        assertEquals(expectedSubKind, key.subKind(), \"SubKind: \");\n@@ -64,2 +63,2 @@\n-        assertEquals(getState().diagnostics(key).collect(toList()), diagnostics, \"Expected retrieved diagnostics to match, but didn't.\");\n-        assertEquals(key.source(), input, \"Expected retrieved source: \" +\n+        assertEquals(diagnostics, getState().diagnostics(key).collect(toList()), \"Expected retrieved diagnostics to match, but didn't.\");\n+        assertEquals(input, key.source(), \"Expected retrieved source: \" +\n@@ -67,1 +66,1 @@\n-        assertEquals(getState().status(key), Status.REJECTED, \"Expected status of REJECTED, got: \" + getState().status(key));\n+        assertEquals(Status.REJECTED, getState().status(key), \"Expected status of REJECTED, got: \" + getState().status(key));\n@@ -78,0 +77,1 @@\n+    @Test\n@@ -89,0 +89,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/RejectedFailedTest.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -48,1 +49,0 @@\n-import org.testng.annotations.BeforeMethod;\n@@ -52,4 +52,5 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNotNull;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -134,1 +135,1 @@\n-            assertEquals(lines.size(), keys.size(), \"Number of keys\");\n+            assertEquals(keys.size(), lines.size(), \"Number of keys\");\n@@ -157,1 +158,1 @@\n-            assertEquals(lines.size(), set.size(), message + \" : expected: \" + set.keySet() + \"\\ngot:\\n\" + lines);\n+            assertEquals(set.size(), lines.size(), message + \" : expected: \" + set.keySet() + \"\\ngot:\\n\" + lines);\n@@ -273,1 +274,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -333,2 +334,1 @@\n-        assertEquals(ceos,\n-                     expectedErrorOutput,\n+        assertEquals(                     expectedErrorOutput, ceos,\n@@ -565,1 +565,31 @@\n-            assertEquals(got, expected, display + \".\\n\");\n+            assertEquals(expected, got, display + \".\\n\");\n+        }\n+    }\n+\n+    public void assertCompletions(boolean after, String input, String expectedCompletionsPattern) {\n+        if (!after) {\n+            try {\n+                Class<?> sourceCodeAnalysisImpl = Class.forName(\"jdk.jshell.SourceCodeAnalysisImpl\");\n+                Method waitBackgroundTaskFinished = sourceCodeAnalysisImpl.getDeclaredMethod(\"waitCurrentBackgroundTasksFinished\");\n+\n+                waitBackgroundTaskFinished.setAccessible(true);\n+                waitBackgroundTaskFinished.invoke(null);\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(ex.getMessage(), ex);\n+            }\n+\n+            setCommandInput(input + \"\\t\");\n+        } else {\n+            assertOutput(getCommandOutput().trim(), \"\", \"command output: \" + input);\n+            assertOutput(getCommandErrorOutput(), \"\", \"command error: \" + input);\n+            assertOutput(getUserOutput(), \"\", \"user output: \" + input);\n+            assertOutput(getUserErrorOutput(), \"\", \"user error: \" + input);\n+            String actualOutput = getTerminalOutput();\n+            Pattern compiledPattern =\n+                    Pattern.compile(expectedCompletionsPattern, Pattern.DOTALL);\n+            if (!compiledPattern.asMatchPredicate().test(actualOutput)) {\n+                throw new AssertionError(\"Actual output:\\n\" +\n+                                         actualOutput + \"\\n\" +\n+                                         \"does not match expected pattern: \" +\n+                                         expectedCompletionsPattern);\n+            }\n","filename":"test\/langtools\/jdk\/jshell\/ReplToolTesting.java","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng ReplaceTest\n+ * @run junit ReplaceTest\n@@ -37,3 +37,1 @@\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -42,1 +40,3 @@\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -44,1 +44,0 @@\n-@Test\n@@ -47,0 +46,1 @@\n+    @Test\n@@ -72,0 +72,1 @@\n+    @Test\n@@ -95,0 +96,1 @@\n+    @Test\n@@ -109,0 +111,1 @@\n+    @Test\n@@ -122,0 +125,1 @@\n+    @Test\n@@ -133,0 +137,1 @@\n+    @Test\n@@ -147,0 +152,1 @@\n+    @Test\n@@ -162,0 +168,1 @@\n+    @Test\n@@ -181,0 +188,1 @@\n+    @Test\n@@ -196,0 +204,1 @@\n+    @Test\n@@ -216,1 +225,2 @@\n-    @Test(enabled = false) \/\/ TODO 8129420\n+    @Test \/\/ TODO 8129420\n+    @Disabled\n@@ -230,0 +240,1 @@\n+    @Test\n@@ -241,0 +252,1 @@\n+    @Test\n@@ -252,0 +264,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ReplaceTest.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng SealedClassesTest\n+ * @run junit SealedClassesTest\n@@ -38,2 +38,0 @@\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n@@ -42,0 +40,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -43,1 +42,0 @@\n-@Test\n@@ -46,0 +44,1 @@\n+    @Test\n@@ -56,0 +55,1 @@\n+    @Test\n@@ -66,0 +66,1 @@\n+    @Test\n@@ -77,0 +78,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/SealedClassesTest.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng ShutdownTest\n+ * @run junit ShutdownTest\n@@ -40,5 +40,7 @@\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n@@ -54,1 +56,2 @@\n-    @Test(enabled = false) \/\/TODO 8139873\n+    @Test \/\/TODO 8139873\n+    @Disabled\n@@ -59,1 +62,1 @@\n-        assertEquals(shutdownCount, 1);\n+        assertEquals(1, shutdownCount);\n@@ -67,1 +70,1 @@\n-        assertEquals(shutdownCount, 1);\n+        assertEquals(1, shutdownCount);\n@@ -76,1 +79,1 @@\n-        assertEquals(shutdownCount, 0);\n+        assertEquals(0, shutdownCount);\n@@ -88,2 +91,2 @@\n-        assertEquals(listener1.getEvents(), 0, \"Checking got events\");\n-        assertEquals(listener2.getEvents(), 1, \"Checking got events\");\n+        assertEquals(0, listener1.getEvents(), \"Checking got events\");\n+        assertEquals(1, listener2.getEvents(), \"Checking got events\");\n@@ -93,2 +96,2 @@\n-        assertEquals(listener1.getEvents(), 0, \"Checking got events\");\n-        assertEquals(listener2.getEvents(), 1, \"Checking got events\");\n+        assertEquals(0, listener1.getEvents(), \"Checking got events\");\n+        assertEquals(1, listener2.getEvents(), \"Checking got events\");\n@@ -99,1 +102,1 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n+    @Test\n@@ -101,2 +104,4 @@\n-        getState().close();\n-        getState().eval(\"45\");\n+        Assertions.assertThrows(IllegalStateException.class, () -> {\n+            getState().close();\n+            getState().eval(\"45\");\n+        });\n@@ -105,2 +110,2 @@\n-    @Test(expectedExceptions = IllegalStateException.class,\n-          enabled = false) \/\/TODO 8139873\n+    @Test \/\/TODO 8139873\n+    @Disabled\n@@ -108,2 +113,4 @@\n-        assertEval(\"System.exit(0);\");\n-        getState().eval(\"45\");\n+        Assertions.assertThrows(IllegalStateException.class, () -> {\n+            assertEval(\"System.exit(0);\");\n+            getState().eval(\"45\");\n+        });\n@@ -112,1 +119,1 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n+    @Test\n@@ -114,1 +121,3 @@\n-        getState().onShutdown(null);\n+        Assertions.assertThrows(NullPointerException.class, () -> {\n+            getState().onShutdown(null);\n+        });\n@@ -117,1 +126,1 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n+    @Test\n@@ -119,2 +128,4 @@\n-        getState().close();\n-        getState().onShutdown(e -> {});\n+        Assertions.assertThrows(IllegalStateException.class, () -> {\n+            getState().close();\n+            getState().onShutdown(e -> {});\n+        });\n@@ -123,2 +134,2 @@\n-    @Test(expectedExceptions = IllegalStateException.class,\n-          enabled = false) \/\/TODO 8139873\n+    @Test \/\/TODO 8139873\n+    @Disabled\n@@ -126,2 +137,4 @@\n-        assertEval(\"System.exit(0);\");\n-        getState().onShutdown(e -> {});\n+        Assertions.assertThrows(IllegalStateException.class, () -> {\n+            assertEval(\"System.exit(0);\");\n+            getState().onShutdown(e -> {});\n+        });\n@@ -153,3 +166,3 @@\n-    @BeforeMethod\n-    public void setUp(Method testMethod) {\n-        currentTestMethod = testMethod;\n+    @BeforeEach\n+    public void setUp(TestInfo testInfo) {\n+        currentTestMethod = testInfo.getTestMethod().orElseThrow();\n@@ -159,1 +172,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/ShutdownTest.java","additions":48,"deletions":35,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng SimpleRegressionTest\n+ * @run junit SimpleRegressionTest\n@@ -39,5 +39,3 @@\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -47,1 +45,2 @@\n-import org.testng.annotations.BeforeMethod;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -49,1 +48,0 @@\n-@Test\n@@ -52,1 +50,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -58,0 +56,1 @@\n+    @Test\n@@ -64,0 +63,1 @@\n+    @Test\n@@ -70,0 +70,1 @@\n+    @Test\n@@ -74,0 +75,1 @@\n+    @Test\n@@ -80,3 +82,3 @@\n-        assertEquals(events.get(0).value(), \"3\");\n-        assertEquals(events.get(1).value(), \"6\");\n-        assertEquals(events.get(2).value(), \"600\");\n+        assertEquals(\"3\", events.get(0).value());\n+        assertEquals(\"6\", events.get(1).value());\n+        assertEquals(\"600\", events.get(2).value());\n@@ -86,0 +88,1 @@\n+    @Test\n@@ -95,0 +98,1 @@\n+    @Test\n@@ -99,0 +103,1 @@\n+    @Test\n@@ -103,0 +108,1 @@\n+    @Test\n@@ -107,0 +113,1 @@\n+    @Test\n@@ -114,0 +121,1 @@\n+    @Test\n@@ -118,1 +126,1 @@\n-        assertEquals(sne.typeName(), \"Integer\");\n+        assertEquals(\"Integer\", sne.typeName());\n@@ -121,0 +129,1 @@\n+    @Test\n@@ -130,1 +139,1 @@\n-            assertEquals(el.size(), 1, \"Excepted one event\");\n+            assertEquals(1, el.size(), \"Excepted one event\");\n@@ -136,0 +145,1 @@\n+    @Test\n@@ -146,1 +156,1 @@\n-            assertEquals(el.size(), 1, \"Excepted one event\");\n+            assertEquals(1, el.size(), \"Excepted one event\");\n@@ -153,0 +163,1 @@\n+    @Test\n@@ -164,0 +175,1 @@\n+    @Test\n@@ -169,0 +181,1 @@\n+    @Test\n@@ -186,0 +199,1 @@\n+    @Test\n@@ -202,0 +216,1 @@\n+    @Test\n@@ -223,0 +238,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/SimpleRegressionTest.java","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng SnippetEventToStringTest\n+ * @run junit SnippetEventToStringTest\n@@ -38,3 +38,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -42,0 +43,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -44,1 +46,0 @@\n-    @DataProvider(name = \"cases\")\n@@ -53,2 +54,3 @@\n-    @Test(dataProvider = \"cases\")\n-    private void verifySnippetEvent(String source, String match) {\n+    @ParameterizedTest\n+    @MethodSource(\"sourceLevels\")\n+    void verifySnippetEvent(String source, String match) {\n@@ -57,1 +59,1 @@\n-            assertEquals(result.size(), 1);\n+            assertEquals(1, result.size());\n","filename":"test\/langtools\/jdk\/jshell\/SnippetEventToStringTest.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8274148 8301580\n+ * @bug 8274148 8301580 8359497\n@@ -35,1 +35,1 @@\n- * @run testng SnippetHighlightTest\n+ * @run junit SnippetHighlightTest\n@@ -42,1 +42,0 @@\n-import org.testng.annotations.Test;\n@@ -46,1 +45,2 @@\n-import static org.testng.Assert.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n@@ -48,1 +48,0 @@\n-@Test\n@@ -51,0 +50,1 @@\n+    @Test\n@@ -102,0 +102,1 @@\n+    @Test\n@@ -117,0 +118,7 @@\n+    @Test\n+    public void testNoCrashOnLexicalErrors() { \/\/JDK-8359497\n+        assertHighlights(\"\"\"\n+                         \"\n+                         \"\"\");\n+    }\n+\n@@ -119,1 +127,1 @@\n-        assertEquals(completions, Arrays.asList(expected), \"Input: \" + code + \", \" + completions.toString());\n+        assertEquals(Arrays.asList(expected), completions, \"Input: \" + code + \", \" + completions.toString());\n","filename":"test\/langtools\/jdk\/jshell\/SnippetHighlightTest.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng SnippetStatusListenerTest\n+ * @run junit SnippetStatusListenerTest\n@@ -40,1 +40,0 @@\n-import org.testng.annotations.Test;\n@@ -43,1 +42,4 @@\n-import static org.testng.Assert.assertEquals;\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -45,1 +47,0 @@\n-@Test\n@@ -48,0 +49,1 @@\n+    @Test\n@@ -64,1 +66,1 @@\n-        assertEquals(events1, listener2.getEvents(), \"Checking got events\");\n+        assertEquals(listener2.getEvents(), events1, \"Checking got events\");\n@@ -70,1 +72,1 @@\n-        assertEquals(listener1.getEvents(), events1, \"Checking that unsubscribed listener does not get events\");\n+        assertEquals(events1, listener1.getEvents(), \"Checking that unsubscribed listener does not get events\");\n@@ -75,1 +77,1 @@\n-        assertEquals(events2.size(), 3, \"The second listener got events\");\n+        assertEquals(3, events2.size(), \"The second listener got events\");\n@@ -78,1 +80,1 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n+    @Test\n@@ -80,1 +82,3 @@\n-        getState().onSnippetEvent(null);\n+        Assertions.assertThrows(NullPointerException.class, () -> {\n+            getState().onSnippetEvent(null);\n+        });\n@@ -83,1 +87,1 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n+    @Test\n@@ -85,2 +89,4 @@\n-        getState().close();\n-        getState().onSnippetEvent(e -> {});\n+        Assertions.assertThrows(IllegalStateException.class, () -> {\n+            getState().close();\n+            getState().onSnippetEvent(e -> {});\n+        });\n@@ -89,2 +95,2 @@\n-    @Test(expectedExceptions = IllegalStateException.class,\n-          enabled = false) \/\/TODO 8139873\n+    @Test \/\/TODO 8139873\n+    @Disabled\n@@ -92,2 +98,4 @@\n-        assertEval(\"System.exit(0);\");\n-        getState().onSnippetEvent(e -> {});\n+        Assertions.assertThrows(IllegalStateException.class, () -> {\n+            assertEval(\"System.exit(0);\");\n+            getState().onSnippetEvent(e -> {});\n+        });\n@@ -96,0 +104,1 @@\n+    @Test\n@@ -102,1 +111,1 @@\n-        assertEquals(Collections.emptyList(), listener.getEvents(), \"No events\");\n+        assertEquals(listener.getEvents(), Collections.emptyList(), \"No events\");\n","filename":"test\/langtools\/jdk\/jshell\/SnippetStatusListenerTest.java","additions":27,"deletions":18,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng SnippetTest\n+ * @run junit SnippetTest\n@@ -34,1 +34,0 @@\n-import org.testng.annotations.Test;\n@@ -38,2 +37,2 @@\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -45,0 +44,2 @@\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -46,1 +47,0 @@\n-@Test\n@@ -49,0 +49,1 @@\n+    @Test\n@@ -55,0 +56,1 @@\n+    @Test\n@@ -59,0 +61,1 @@\n+    @Test\n@@ -63,0 +66,1 @@\n+    @Test\n@@ -67,0 +71,1 @@\n+    @Test\n@@ -71,0 +76,1 @@\n+    @Test\n@@ -75,0 +81,1 @@\n+    @Test\n@@ -79,0 +86,1 @@\n+    @Test\n@@ -83,0 +91,1 @@\n+    @Test\n@@ -87,0 +96,1 @@\n+    @Test\n@@ -92,0 +102,1 @@\n+    @Test\n@@ -97,0 +108,1 @@\n+    @Test\n@@ -104,0 +116,1 @@\n+    @Test\n@@ -108,0 +121,1 @@\n+    @Test\n@@ -119,1 +133,2 @@\n-    @Test(enabled = false) \/\/ TODO 8081689\n+    @Test \/\/ TODO 8081689\n+    @Disabled\n@@ -139,0 +154,1 @@\n+    @Test\n@@ -157,0 +173,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/SnippetTest.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng SourceLevelTest\n+ * @run junit SourceLevelTest\n@@ -32,2 +32,3 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -35,0 +36,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -37,1 +39,0 @@\n-    @DataProvider(name=\"sourceLevels\")\n@@ -45,1 +46,2 @@\n-    @Test(dataProvider=\"sourceLevels\")\n+    @ParameterizedTest\n+    @MethodSource(\"sourceLevels\")\n","filename":"test\/langtools\/jdk\/jshell\/SourceLevelTest.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run testng\/othervm --patch-module jdk.jshell=${test.src}\/StartOptionTest-module-patch StartOptionTest\n+ * @run junit\/othervm --patch-module jdk.jshell=${test.src}\/StartOptionTest-module-patch StartOptionTest\n@@ -55,3 +55,0 @@\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n@@ -59,4 +56,7 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -64,1 +64,0 @@\n-@Test\n@@ -119,1 +118,1 @@\n-                assertEquals(out, \"\", label + \": Expected empty -- \");\n+                assertEquals(\"\", out, label + \": Expected empty -- \");\n@@ -142,1 +141,1 @@\n-            assertEquals(ec, 0, \"Expected standard exit code (0), but found: \" + ec);\n+            assertEquals(0, ec, \"Expected standard exit code (0), but found: \" + ec);\n@@ -191,2 +190,1 @@\n-        StartOptionTest.this.startExCoUoCeCn(\n-                (Integer ec) -> assertEquals((int) ec, eec,\n+        StartOptionTest.this.startExCoUoCeCn((Integer ec) -> assertEquals(eec, (int) ec,\n@@ -205,1 +203,1 @@\n-                : s -> assertEquals(s.replaceAll(\"\\\\r\\\\n?\", \"\\n\").trim(), expected.trim(), label);\n+                : s -> assertEquals(expected.trim(), s.replaceAll(\"\\\\r\\\\n?\", \"\\n\").trim(), label);\n@@ -216,2 +214,1 @@\n-        startExCoUoCeCn(\n-                expectedExitCode == 0\n+        startExCoUoCeCn(expectedExitCode == 0\n@@ -219,1 +216,1 @@\n-                        : (Integer i) -> assertEquals((int) i, expectedExitCode,\n+                        : (Integer i) -> assertEquals(expectedExitCode, (int) i,\n@@ -243,1 +240,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -270,0 +267,1 @@\n+    @Test\n@@ -284,0 +282,1 @@\n+    @Test\n@@ -296,0 +295,1 @@\n+    @Test\n@@ -308,0 +308,1 @@\n+    @Test\n@@ -314,0 +315,1 @@\n+    @Test\n@@ -330,0 +332,1 @@\n+    @Test\n@@ -344,0 +347,1 @@\n+    @Test\n@@ -349,0 +353,1 @@\n+    @Test\n@@ -358,0 +363,1 @@\n+    @Test\n@@ -364,0 +370,1 @@\n+    @Test\n@@ -370,0 +377,1 @@\n+    @Test\n@@ -378,0 +386,1 @@\n+    @Test\n@@ -384,0 +393,1 @@\n+    @Test\n@@ -398,0 +408,1 @@\n+    @Test\n@@ -404,0 +415,1 @@\n+    @Test\n@@ -413,0 +425,1 @@\n+    @Test\n@@ -425,0 +438,1 @@\n+    @Test\n@@ -433,1 +447,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"prefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"prefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\", s),\n@@ -440,1 +454,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"test\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"test\\n\", s),\n@@ -442,1 +456,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"test\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"test\\n\", s),\n@@ -444,1 +458,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"test\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"test\\n\", s),\n@@ -454,1 +468,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"prefix\\ntest\\nsuffix\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"prefix\\ntest\\nsuffix\\n\", s),\n@@ -465,1 +479,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"prefix\\nHello!\\nsuffix\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"prefix\\nHello!\\nsuffix\\n\", s),\n@@ -485,1 +499,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"Custom start script\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"Custom start script\\n\", s),\n@@ -501,3 +515,3 @@\n-        startCheckCommandUserOutput(s -> assertEquals(s, \"\/set start -retain -default\\n\"),\n-                                    s -> assertEquals(s, \"prefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\"),\n-                                    s -> assertEquals(s, \"\/set start -retain -default\\nprefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\"),\n+        startCheckCommandUserOutput(s -> assertEquals(\"\/set start -retain -default\\n\", s),\n+                                    s -> assertEquals(\"prefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\", s),\n+                                    s -> assertEquals(\"\/set start -retain -default\\nprefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\", s),\n@@ -510,1 +524,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"test\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"test\\n\", s),\n@@ -529,3 +543,3 @@\n-        startCheckCommandUserOutput(s -> assertEquals(s, \"\/set start -retain -default\\n\"),\n-                                    s -> assertEquals(s, \"prefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\"),\n-                                    s -> assertEquals(s, \"\/set start -retain -default\\nprefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\"),\n+        startCheckCommandUserOutput(s -> assertEquals(\"\/set start -retain -default\\n\", s),\n+                                    s -> assertEquals(\"prefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\", s),\n+                                    s -> assertEquals(\"\/set start -retain -default\\nprefix\\njava.lang.invoke.MethodHandle\\nsuffix\\n\", s),\n@@ -535,0 +549,1 @@\n+    @Test\n@@ -543,1 +558,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"prompt: null\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"prompt: null\\n\", s),\n@@ -552,1 +567,1 @@\n-        startCheckUserOutput(s -> assertEquals(s, \"prompt: null\\n\"),\n+        startCheckUserOutput(s -> assertEquals(\"prompt: null\\n\", s),\n@@ -556,0 +571,1 @@\n+    @Test\n@@ -570,1 +586,1 @@\n-        startCheckError(s -> assertEquals(s, expectedError),\n+        startCheckError(s -> assertEquals(expectedError, s),\n@@ -575,1 +591,1 @@\n-    @AfterMethod\n+    @AfterEach\n","filename":"test\/langtools\/jdk\/jshell\/StartOptionTest.java","additions":52,"deletions":36,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng StartupWithFormatSpecifierTest\n+ * @run junit StartupWithFormatSpecifierTest\n@@ -39,1 +39,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -41,1 +41,0 @@\n-@Test\n@@ -44,0 +43,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/StartupWithFormatSpecifierTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng StopExecutionTest\n+ * @run junit StopExecutionTest\n@@ -42,1 +42,3 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -44,3 +46,0 @@\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n@@ -49,1 +48,2 @@\n-    @Test(enabled = false) \/\/ TODO 8129546\n+    @Test \/\/ TODO 8129546\n+    @Disabled\n@@ -54,1 +54,2 @@\n-    @Test(enabled = false) \/\/ TODO 8129546\n+    @Test \/\/ TODO 8129546\n+    @Disabled\n@@ -59,1 +60,2 @@\n-    @Test(enabled = false) \/\/ TODO 8129546\n+    @Test \/\/ TODO 8129546\n+    @Disabled\n@@ -64,0 +66,1 @@\n+    @Test\n@@ -89,1 +92,1 @@\n-            assertEquals(read, c);\n+            assertEquals(c, read);\n@@ -93,0 +96,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/StopExecutionTest.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/othervm -Duser.language=ja JShellTest8146368\n+ * @run junit\/othervm -Duser.language=ja JShellTest8146368\n@@ -34,1 +34,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -36,1 +36,0 @@\n-@Test\n@@ -38,0 +37,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/T8146368\/JShellTest8146368.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm -Duser.language=ja JShellToolTest8146368\n+ * @run junit\/othervm -Duser.language=ja JShellToolTest8146368\n@@ -34,1 +34,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -36,1 +36,0 @@\n-@Test\n@@ -38,0 +37,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/T8146368\/JShellToolTest8146368.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng Test8294583\n+ * @run junit Test8294583\n@@ -32,2 +32,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -35,1 +36,0 @@\n-@Test\n@@ -38,0 +38,1 @@\n+    @Test\n@@ -44,1 +45,1 @@\n-    @org.testng.annotations.BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/Test8294583.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng Test8296012\n+ * @run junit Test8296012\n@@ -32,2 +32,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -35,1 +36,0 @@\n-@Test\n@@ -38,0 +38,1 @@\n+    @Test\n@@ -43,1 +44,1 @@\n-    @org.testng.annotations.BeforeMethod\n+    @BeforeEach\n","filename":"test\/langtools\/jdk\/jshell\/Test8296012.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run testng\/timeout=600 ToolBasicTest\n+ * @run junit\/timeout=600 ToolBasicTest\n@@ -60,1 +60,6 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -62,6 +67,0 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.fail;\n-\n-@Test\n@@ -70,0 +69,1 @@\n+    @Test\n@@ -71,2 +71,1 @@\n-        test(\n-                (a) -> assertCommandOutputContains(a, \"123\", \"==> 123\"),\n+        test((a) -> assertCommandOutputContains(a, \"123\", \"==> 123\"),\n@@ -84,1 +83,1 @@\n-                    assertEquals(cnt, 1, \"Expected only one listed line\");\n+                    assertEquals(1, cnt, \"Expected only one listed line\");\n@@ -89,0 +88,1 @@\n+    @Test\n@@ -97,1 +97,1 @@\n-            assertEquals(lines.count(), 1, \"Expected only one saved line\");\n+            assertEquals(1, lines.count(), \"Expected only one saved line\");\n@@ -101,0 +101,1 @@\n+    @Test\n@@ -135,0 +136,1 @@\n+    @Test\n@@ -196,0 +198,1 @@\n+    @Test\n@@ -203,0 +206,1 @@\n+    @Test\n@@ -224,1 +228,1 @@\n-                assertEquals(ss[0], codes[finalI]);\n+                assertEquals(codes[finalI], ss[0]);\n@@ -234,1 +238,1 @@\n-                assertEquals(ss[0], codes[codes.length - finalI - 1]);\n+                assertEquals(codes[codes.length - finalI - 1], ss[0]);\n@@ -244,0 +248,1 @@\n+    @Test\n@@ -248,1 +253,1 @@\n-                            assertEquals(ss[0], code);\n+                            assertEquals(code, ss[0]);\n@@ -259,1 +264,1 @@\n-                (a) -> assertCommandCheckOutput(a, \"add(ONE)\", s -> assertEquals(s.split(\"\\n\")[0], \"|  Error:\")), \/\/ id: e1\n+                (a) -> assertCommandCheckOutput(a, \"add(ONE)\", s -> assertEquals(\"|  Error:\", s.split(\"\\n\")[0])), \/\/ id: e1\n@@ -273,0 +278,1 @@\n+    @Test\n@@ -288,0 +294,1 @@\n+    @Test\n@@ -323,0 +330,1 @@\n+    @Test\n@@ -335,0 +343,1 @@\n+    @Test\n@@ -349,0 +358,1 @@\n+    @Test\n@@ -376,0 +386,1 @@\n+    @Test\n@@ -394,0 +405,1 @@\n+    @Test\n@@ -409,0 +421,1 @@\n+    @Test\n@@ -418,0 +431,1 @@\n+    @Test\n@@ -428,0 +442,1 @@\n+    @Test\n@@ -443,0 +458,1 @@\n+    @Test\n@@ -453,0 +469,1 @@\n+    @Test\n@@ -473,0 +490,1 @@\n+    @Test\n@@ -507,0 +525,1 @@\n+    @Test\n@@ -521,0 +540,1 @@\n+    @Test\n@@ -552,0 +572,1 @@\n+    @Test\n@@ -562,0 +583,1 @@\n+    @Test\n@@ -576,1 +598,1 @@\n-            assertEquals(Files.readAllLines(path), list);\n+            assertEquals(list, Files.readAllLines(path));\n@@ -592,1 +614,1 @@\n-            assertEquals(Files.readAllLines(path), output);\n+            assertEquals(output, Files.readAllLines(path));\n@@ -609,1 +631,1 @@\n-            assertEquals(Files.readAllLines(path), output);\n+            assertEquals(output, Files.readAllLines(path));\n@@ -624,1 +646,1 @@\n-            assertEquals(Files.readAllLines(path), output);\n+            assertEquals(output, Files.readAllLines(path));\n@@ -628,0 +650,1 @@\n+    @Test\n@@ -658,0 +681,1 @@\n+    @Test\n@@ -665,1 +689,1 @@\n-        assertEquals(lines, START_UP);\n+        assertEquals(START_UP, lines);\n@@ -668,0 +692,1 @@\n+    @Test\n@@ -677,0 +702,1 @@\n+    @Test\n@@ -689,0 +715,1 @@\n+    @Test\n@@ -694,0 +721,1 @@\n+    @Test\n@@ -705,0 +733,1 @@\n+    @Test\n@@ -731,0 +760,1 @@\n+    @Test\n@@ -738,0 +768,1 @@\n+    @Test\n@@ -770,0 +801,1 @@\n+    @Test\n@@ -828,1 +860,2 @@\n-    @Test(enabled = false) \/\/ TODO 8158197\n+    @Test \/\/ TODO 8158197\n+    @Disabled\n@@ -841,0 +874,1 @@\n+    @Test\n@@ -857,0 +891,1 @@\n+    @Test\n@@ -868,0 +903,1 @@\n+    @Test\n@@ -879,0 +915,1 @@\n+    @Test\n@@ -890,0 +927,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolBasicTest.java","additions":61,"deletions":23,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng ToolCommandOptionTest\n+ * @run junit ToolCommandOptionTest\n@@ -36,3 +36,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -40,1 +40,0 @@\n-@Test\n@@ -43,0 +42,1 @@\n+    @Test\n@@ -70,0 +70,1 @@\n+    @Test\n@@ -95,0 +96,1 @@\n+    @Test\n@@ -123,0 +125,1 @@\n+    @Test\n@@ -160,0 +163,1 @@\n+    @Test\n@@ -214,0 +218,1 @@\n+    @Test\n@@ -247,0 +252,1 @@\n+    @Test\n@@ -291,0 +297,1 @@\n+    @Test\n@@ -340,0 +347,1 @@\n+    @Test\n@@ -402,0 +410,1 @@\n+    @Test\n@@ -431,0 +440,1 @@\n+    @Test\n@@ -534,0 +544,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolCommandOptionTest.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8177650\n+ * @summary Verify JShell tool code completion\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ *          jdk.jshell\/jdk.jshell:+open\n+ *          jdk.jshell\/jdk.internal.jshell.tool\n+ *          java.desktop\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @build ReplToolTesting TestingInputStream Compiler\n+ * @run junit ToolCompletionTest\n+ *\/\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class ToolCompletionTest extends ReplToolTesting {\n+\n+    private final Compiler compiler = new Compiler();\n+    private final Path outDir = Paths.get(\"tool_completion_test\");\n+\n+    @Test\n+    public void testClassPathOnCmdLineIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--class-path\", compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testClassPathViaEnvIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\"},\n+                (a) -> assertCommand(a, \"\/env --class-path \" + compiler.getPath(p1.resolve(jarName)).toString(), null),\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testClassPathChangeIndexing() {\n+        \/\/verify that changing the classpath has effect:\n+        Path dir1 = outDir.resolve(\"dir1\");\n+        compiler.compile(dir1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName1 = \"test1.jar\";\n+        compiler.jar(dir1, jarName1, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        Path dir2 = outDir.resolve(\"dir2\");\n+        compiler.compile(dir2,\n+                \"\"\"\n+                package p1.p5;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p6;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName2 = \"test2.jar\";\n+        compiler.jar(dir2, jarName2, \"p1\/p5\/Test.class\", \"p1\/p6\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--class-path\", compiler.getPath(dir1.resolve(jarName1)).toString()},\n+                (a) -> assertCommand(a, \"1\", null),\n+                (a) -> assertCommand(a, \"\/env --class-path \" + compiler.getPath(dir2.resolve(jarName2)).toString(), null),\n+                (a) -> assertCompletions(a, \"p1.\", \".*p5\\\\..*p6\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testModulePathOnCmdLineIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--module-path\", compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testModulePathOnCmdLineIndexing2() throws IOException {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        Path lib = outDir.resolve(\"lib\");\n+        Files.createDirectories(lib);\n+        compiler.jar(p1, lib.resolve(jarName), \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--module-path\", lib.toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testUpgradeModulePathIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"-C--upgrade-module-path\", \"-C\" + compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testBootClassPathPrepend() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"-C-Xbootclasspath\/p:\" + compiler.getPath(p1.resolve(jarName)).toString(), \"-C--source=8\"},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/ToolCompletionTest.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng ToolEnableNativeAccessTest\n+ * @run junit ToolEnableNativeAccessTest\n@@ -32,3 +32,2 @@\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnableNativeAccessTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng ToolEnablePreviewTest\n+ * @run junit ToolEnablePreviewTest\n@@ -36,3 +36,2 @@\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnablePreviewTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng ToolFormatTest\n+ * @run junit ToolFormatTest\n@@ -41,4 +41,5 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -46,1 +47,0 @@\n-@Test\n@@ -49,0 +49,1 @@\n+    @Test\n@@ -89,0 +90,1 @@\n+    @Test\n@@ -141,0 +143,1 @@\n+    @Test\n@@ -200,1 +203,2 @@\n-    @Test(enabled = false)\n+    @Test\n+    @Disabled\n@@ -281,0 +285,1 @@\n+    @Test\n@@ -312,0 +317,1 @@\n+    @Test\n@@ -334,0 +340,1 @@\n+    @Test\n@@ -335,2 +342,1 @@\n-        test(\n-                (a) -> assertCommand(a, \"\/set mode tp -quiet\", \"|  Created new feedback mode: tp\"),\n+        test((a) -> assertCommand(a, \"\/set mode tp -quiet\", \"|  Created new feedback mode: tp\"),\n@@ -350,1 +356,1 @@\n-                                assertEquals(rdr.readLine(), \"|  \/set mode tp -quiet\",\n+                                assertEquals(\"|  \/set mode tp -quiet\", rdr.readLine(),\n@@ -352,1 +358,1 @@\n-                                assertEquals(rdr.readLine(), \"|  \/set prompt tp \\\"aaa\\\" \\\"bbb\\\"\",\n+                                assertEquals(\"|  \/set prompt tp \\\"aaa\\\" \\\"bbb\\\"\", rdr.readLine(),\n@@ -358,1 +364,1 @@\n-                                assertEquals(l, \"|  \/set mode -retain tp\",\n+                                assertEquals(\"|  \/set mode -retain tp\", l,\n@@ -360,1 +366,1 @@\n-                                assertEquals(rdr.readLine(), \"|  \",\n+                                assertEquals(\"|  \", rdr.readLine(),\n@@ -362,1 +368,1 @@\n-                                assertEquals(rdr.readLine(), \"|  \/set mode tp -quiet\",\n+                                assertEquals(\"|  \/set mode tp -quiet\", rdr.readLine(),\n@@ -364,1 +370,1 @@\n-                                assertEquals(rdr.readLine(), \"|  \/set prompt tp \\\"ccc\\\" \\\"ddd\\\"\",\n+                                assertEquals(\"|  \/set prompt tp \\\"ccc\\\" \\\"ddd\\\"\", rdr.readLine(),\n@@ -373,0 +379,1 @@\n+    @Test\n@@ -379,0 +386,1 @@\n+    @Test\n@@ -399,0 +407,1 @@\n+    @Test\n@@ -476,0 +485,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolFormatTest.java","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng\/othervm ToolLocalSimpleTest\n+ * @run junit\/othervm\/timeout=480 ToolLocalSimpleTest\n@@ -37,2 +37,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Test;\n@@ -54,1 +54,1 @@\n-        assertEquals(System.getProperty(\"LOCAL_CHECK\"), \"Here\");\n+        assertEquals(\"Here\", System.getProperty(\"LOCAL_CHECK\"));\n@@ -59,1 +59,1 @@\n-        assertEquals(System.getProperty(\"LOCAL_CHECK\"), \"After\");\n+        assertEquals(\"After\", System.getProperty(\"LOCAL_CHECK\"));\n","filename":"test\/langtools\/jdk\/jshell\/ToolLocalSimpleTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng ToolLocaleMessageTest\n+ * @run junit ToolLocaleMessageTest\n@@ -39,3 +39,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -43,1 +43,0 @@\n-@Test\n@@ -70,0 +69,1 @@\n+    @Test\n@@ -76,0 +76,1 @@\n+    @Test\n@@ -101,0 +102,1 @@\n+    @Test\n@@ -135,0 +137,1 @@\n+    @Test\n@@ -156,0 +159,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolLocaleMessageTest.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng ToolMultilineSnippetHistoryTest\n+ * @run junit ToolMultilineSnippetHistoryTest\n@@ -37,1 +37,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -39,1 +39,0 @@\n-@Test\n@@ -46,0 +45,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolMultilineSnippetHistoryTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -46,1 +46,1 @@\n- * @run testng\/othervm --patch-module jdk.jshell=${test.src}\/StartOptionTest-module-patch ToolProviderTest\n+ * @run junit\/othervm --patch-module jdk.jshell=${test.src}\/StartOptionTest-module-patch ToolProviderTest\n@@ -48,1 +48,0 @@\n-@Test\n@@ -105,0 +104,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolProviderTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run testng ToolReloadTest\n+ * @run junit ToolReloadTest\n@@ -42,2 +42,2 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -46,1 +46,0 @@\n-@Test\n@@ -49,0 +48,1 @@\n+    @Test\n@@ -66,0 +66,1 @@\n+    @Test\n@@ -92,0 +93,1 @@\n+    @Test\n@@ -115,0 +117,1 @@\n+    @Test\n@@ -132,0 +135,1 @@\n+    @Test\n@@ -152,0 +156,1 @@\n+    @Test\n@@ -165,0 +170,1 @@\n+    @Test\n@@ -183,0 +189,1 @@\n+    @Test\n@@ -203,0 +210,1 @@\n+    @Test\n@@ -224,0 +232,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolReloadTest.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng ToolRetainTest\n+ * @run junit ToolRetainTest\n@@ -34,1 +34,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -36,1 +36,0 @@\n-@Test\n@@ -39,0 +38,1 @@\n+    @Test\n@@ -56,0 +56,1 @@\n+    @Test\n@@ -84,0 +85,1 @@\n+    @Test\n@@ -98,0 +100,1 @@\n+    @Test\n@@ -119,0 +122,1 @@\n+    @Test\n@@ -133,0 +137,1 @@\n+    @Test\n@@ -145,0 +150,1 @@\n+    @Test\n@@ -154,0 +160,1 @@\n+    @Test\n@@ -170,0 +177,1 @@\n+    @Test\n@@ -185,0 +193,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolRetainTest.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng\/timeout=300 ToolShiftTabTest\n+ * @run junit\/timeout=300 ToolShiftTabTest\n@@ -38,1 +38,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -40,1 +40,0 @@\n-@Test\n@@ -46,0 +45,1 @@\n+    @Test\n@@ -57,0 +57,1 @@\n+    @Test\n@@ -71,0 +72,1 @@\n+    @Test\n@@ -84,0 +86,1 @@\n+    @Test\n@@ -109,0 +112,1 @@\n+    @Test\n@@ -129,0 +133,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolShiftTabTest.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng ToolSimpleTest\n+ * @run junit\/timeout=480 ToolSimpleTest\n@@ -50,4 +50,3 @@\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n@@ -546,1 +545,1 @@\n-        assertEquals(res.length, match.size(), \"Got: \" + Arrays.asList(res));\n+        assertEquals(match.size(), res.length, \"Got: \" + Arrays.asList(res));\n@@ -622,1 +621,1 @@\n-                        s -> assertEquals(s.trim().split(\"\\n\").length, 10)),\n+                        s -> assertEquals(10, s.trim().split(\"\\n\").length)),\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run testng ToolTabCommandTest\n+ * @run junit ToolTabCommandTest\n@@ -40,1 +40,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -42,1 +42,0 @@\n-@Test\n@@ -49,0 +48,1 @@\n+    @Test\n@@ -136,0 +136,1 @@\n+    @Test\n@@ -173,0 +174,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolTabCommandTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run testng\/timeout=300 ToolTabSnippetTest\n+ * @run junit\/timeout=300 ToolTabSnippetTest\n@@ -51,1 +51,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -53,1 +53,0 @@\n-@Test\n@@ -60,0 +59,1 @@\n+    @Test\n@@ -211,0 +211,1 @@\n+    @Test\n@@ -244,0 +245,1 @@\n+    @Test\n@@ -269,0 +271,1 @@\n+    @Test\n@@ -334,0 +337,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/ToolTabSnippetTest.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8306560\n+ * @bug 8306560 8365878\n@@ -33,1 +33,1 @@\n- * @run testng ToolingTest\n+ * @run junit ToolingTest\n@@ -36,2 +36,1 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -82,0 +81,27 @@\n+\n+    @Test\n+    public void testDisassembleBuiltinInnerClass() {\n+        test(\n+            a -> assertCommand(a, \"\/open TOOLING\",\n+                        \"\"),\n+            a -> assertCommandUserOutputContains(a, \"javap(Base64.Decoder.class)\",\n+                        \"Classfile jrt:\/java.base\/java\/util\/Base64$Decoder.class\",\n+                        \"class java.util.Base64$Decoder\",\n+                        \"SourceFile: \\\"Base64.java\\\"\")\n+        );\n+    }\n+\n+    @Test\n+    public void testDisassembleAnonymousClass() {\n+        test(\n+            a -> assertCommand(a, \"Object o() {return new ArrayList<>(){ };}\", \/\/ must be in a method or it won't be anonymous\n+                        \"|  created method o()\"),\n+            a -> assertCommand(a, \"\/open TOOLING\",\n+                        \"\"),\n+            a -> assertCommandUserOutputContains(a, \"javap(o().getClass())\",\n+                        \"Classfile \", \/\/ Classfile \/...\/TOOLING-16063368030094702464.class\n+                        \" extends java.util.ArrayList<java.lang.Object>\", \/\/ class REPL.$JShell$22$1 extends java.util.ArrayList<java.lang.Object>\n+                        \"SourceFile: \\\"$JShell$\" \/\/ SourceFile: \"$JShell$22.java\"\n+            )\n+        );\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/ToolingTest.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng TypeNameTest\n+ * @run junit TypeNameTest\n@@ -32,1 +32,2 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.Test;\n@@ -34,3 +35,0 @@\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n@@ -45,1 +43,1 @@\n-        assertEquals(varKey(assertEval(expr)).typeName(), type);\n+        assertEquals(type, varKey(assertEval(expr)).typeName());\n@@ -49,0 +47,1 @@\n+    @Test\n@@ -78,0 +77,1 @@\n+    @Test\n@@ -98,0 +98,1 @@\n+    @Test\n@@ -147,0 +148,1 @@\n+    @Test\n@@ -200,0 +202,1 @@\n+    @Test\n@@ -216,0 +219,1 @@\n+    @Test\n@@ -221,0 +225,1 @@\n+    @Test\n@@ -227,0 +232,1 @@\n+    @Test\n@@ -232,0 +238,1 @@\n+    @Test\n@@ -236,0 +243,1 @@\n+    @Test\n@@ -240,0 +248,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/TypeNameTest.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    protected void doRunTest(Test test) throws Exception {\n+    protected void doRunTest(UITest test) throws Exception {\n@@ -70,1 +70,1 @@\n-    protected void doRunTest(Test test, boolean setUserInput) throws Exception {\n+    protected void doRunTest(UITest test, boolean setUserInput) throws Exception {\n@@ -144,1 +144,1 @@\n-    protected interface Test {\n+    protected interface UITest {\n@@ -148,12 +148,1 @@\n-    private static final long TIMEOUT;\n-\n-    static {\n-        long factor;\n-\n-        try {\n-            factor = (long) Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1\"));\n-        } catch (NumberFormatException ex) {\n-            factor = 1;\n-        }\n-        TIMEOUT = 60_000 * factor;\n-    }\n+    private static final long TIMEOUT = (long) (60_000 * Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\")));\n","filename":"test\/langtools\/jdk\/jshell\/UITesting.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng UndefinedClassTest\n+ * @run junit UndefinedClassTest\n@@ -41,1 +41,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -43,1 +43,0 @@\n-@Test\n@@ -50,0 +49,1 @@\n+    @Test\n@@ -65,0 +65,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/UndefinedClassTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng UnicodeTest\n+ * @run junit UnicodeTest\n@@ -34,1 +34,0 @@\n-import org.testng.annotations.Test;\n@@ -37,2 +36,2 @@\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -41,0 +40,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -42,1 +42,0 @@\n-@Test\n@@ -45,0 +44,1 @@\n+    @Test\n@@ -50,0 +50,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/UnicodeTest.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng UnnamedTest\n+ * @run junit UnnamedTest\n@@ -40,2 +40,0 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n@@ -47,0 +45,2 @@\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n@@ -54,2 +54,2 @@\n-        Assert.assertEquals(getState().varValue(sn1), \"0\");\n-        Assert.assertEquals(getState().varValue(sn2), \"\\\"x\\\"\");\n+        Assertions.assertEquals(\"0\", getState().varValue(sn1));\n+        Assertions.assertEquals(\"\\\"x\\\"\", getState().varValue(sn2));\n","filename":"test\/langtools\/jdk\/jshell\/UnnamedTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng UserExecutionControlTest\n+ * @run junit UserExecutionControlTest\n@@ -33,3 +33,3 @@\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-import org.testng.annotations.BeforeMethod;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -37,1 +37,0 @@\n-@Test\n@@ -40,1 +39,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -46,0 +45,1 @@\n+    @Test\n@@ -48,1 +48,1 @@\n-        assertEquals(System.getProperty(\"LOCAL_CHECK\"), \"TBD\");\n+        assertEquals(\"TBD\", System.getProperty(\"LOCAL_CHECK\"));\n@@ -51,1 +51,1 @@\n-        assertEquals(System.getProperty(\"LOCAL_CHECK\"), \"local\");\n+        assertEquals(\"local\", System.getProperty(\"LOCAL_CHECK\"));\n","filename":"test\/langtools\/jdk\/jshell\/UserExecutionControlTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng UserInputTest\n+ * @run junit UserInputTest\n@@ -36,1 +36,1 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n@@ -38,1 +38,0 @@\n-@Test\n@@ -41,0 +40,1 @@\n+    @Test\n@@ -48,0 +48,1 @@\n+    @Test\n@@ -55,0 +56,1 @@\n+    @Test\n@@ -76,0 +78,1 @@\n+    @Test\n@@ -102,0 +105,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/UserInputTest.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng UserJdiUserRemoteTest\n+ * @run junit UserJdiUserRemoteTest\n@@ -33,2 +33,0 @@\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeMethod;\n@@ -41,1 +39,3 @@\n-import static org.testng.Assert.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -43,1 +43,0 @@\n-@Test\n@@ -49,1 +48,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -56,0 +55,1 @@\n+    @Test\n@@ -59,2 +59,2 @@\n-        assertEquals(vd, \"1.5\");\n-        assertEquals(auxStream.toString(), \"aDouble\");\n+        assertEquals(\"1.5\", vd);\n+        assertEquals(\"aDouble\", auxStream.toString());\n@@ -63,0 +63,1 @@\n+    @Test\n@@ -66,1 +67,1 @@\n-        assertEquals(res, \"ribbit\");\n+        assertEquals(\"ribbit\", res);\n@@ -69,0 +70,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/UserJdiUserRemoteTest.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng VariablesTest\n+ * @run junit\/timeout=480 VariablesTest\n@@ -47,2 +47,0 @@\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n@@ -53,2 +51,5 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n@@ -56,1 +57,0 @@\n-@Test\n@@ -59,0 +59,1 @@\n+    @Test\n@@ -72,0 +73,1 @@\n+    @Test\n@@ -92,0 +94,1 @@\n+    @Test\n@@ -100,0 +103,1 @@\n+    @Test\n@@ -119,0 +123,1 @@\n+    @Test\n@@ -129,0 +134,1 @@\n+    @Test\n@@ -140,0 +146,1 @@\n+    @Test\n@@ -142,1 +149,1 @@\n-        assertEquals(sn.typeName(), \"int[]\");\n+        assertEquals(\"int[]\", sn.typeName());\n@@ -148,0 +155,1 @@\n+    @Test\n@@ -150,1 +158,1 @@\n-        assertEquals(sn.typeName(), \"int[]\");\n+        assertEquals(\"int[]\", sn.typeName());\n@@ -156,0 +164,1 @@\n+    @Test\n@@ -173,0 +182,1 @@\n+    @Test\n@@ -183,0 +193,1 @@\n+    @Test\n@@ -197,0 +208,1 @@\n+    @Test\n@@ -207,0 +219,1 @@\n+    @Test\n@@ -226,0 +239,1 @@\n+    @Test\n@@ -232,0 +246,1 @@\n+    @Test\n@@ -240,0 +255,1 @@\n+    @Test\n@@ -246,0 +262,1 @@\n+    @Test\n@@ -264,1 +281,2 @@\n-    @Test(enabled = false) \/\/ TODO 8081689\n+    @Test \/\/ TODO 8081689\n+    @Disabled\n@@ -286,1 +304,2 @@\n-    @Test(enabled = false) \/\/ TODO 8081689\n+    @Test \/\/ TODO 8081689\n+    @Disabled\n@@ -306,0 +325,1 @@\n+    @Test\n@@ -327,0 +347,1 @@\n+    @Test\n@@ -333,0 +354,1 @@\n+    @Test\n@@ -342,1 +364,1 @@\n-        assertEquals(getState().status(undefKey), RECOVERABLE_NOT_DEFINED);\n+        assertEquals(RECOVERABLE_NOT_DEFINED, getState().status(undefKey));\n@@ -344,2 +366,2 @@\n-        assertEquals(unr.size(), 1);\n-        assertEquals(unr.get(0), \"class undefined\");\n+        assertEquals(1, unr.size());\n+        assertEquals(\"class undefined\", unr.get(0));\n@@ -349,0 +371,1 @@\n+    @Test\n@@ -413,0 +436,1 @@\n+    @Test\n@@ -419,0 +443,1 @@\n+    @Test\n@@ -431,0 +456,1 @@\n+    @Test\n@@ -435,0 +461,1 @@\n+    @Test\n@@ -440,0 +467,1 @@\n+    @Test\n@@ -446,0 +474,1 @@\n+    @Test\n@@ -452,0 +481,1 @@\n+    @Test\n@@ -469,0 +499,1 @@\n+    @Test\n@@ -481,0 +512,1 @@\n+    @Test\n@@ -490,0 +522,1 @@\n+    @Test\n@@ -503,0 +536,1 @@\n+    @Test\n@@ -516,0 +550,1 @@\n+    @Test\n@@ -548,1 +583,1 @@\n-        assertEquals(vs.typeName(), typeName);\n+        assertEquals(typeName, vs.typeName());\n@@ -554,1 +589,1 @@\n-        assertEquals(varKey(assertEval(var)).typeName(), typeName);\n+        assertEquals(typeName, varKey(assertEval(var)).typeName());\n@@ -557,1 +592,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -614,0 +649,1 @@\n+    @Test\n@@ -620,0 +656,1 @@\n+    @Test\n@@ -624,0 +661,1 @@\n+    @Test\n@@ -630,0 +668,1 @@\n+    @Test\n","filename":"test\/langtools\/jdk\/jshell\/VariablesTest.java","additions":56,"deletions":17,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng WrapperTest\n+ * @run junit WrapperTest\n@@ -35,1 +35,0 @@\n-import org.testng.annotations.Test;\n@@ -40,2 +39,2 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -44,0 +43,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -45,1 +45,0 @@\n-@Test\n@@ -48,0 +47,1 @@\n+    @Test\n@@ -51,1 +51,1 @@\n-        assertEquals(swl.size(), 1, \"unexpected list length\");\n+        assertEquals(1, swl.size(), \"unexpected list length\");\n@@ -66,0 +66,1 @@\n+    @Test\n@@ -78,0 +79,1 @@\n+    @Test\n@@ -94,0 +96,1 @@\n+    @Test\n@@ -112,0 +115,1 @@\n+    @Test\n@@ -133,0 +137,1 @@\n+    @Test\n@@ -150,0 +155,1 @@\n+    @Test\n@@ -185,0 +191,1 @@\n+    @Test\n@@ -188,1 +195,1 @@\n-        assertEquals(swl.size(), 1, \"unexpected list length\");\n+        assertEquals(1, swl.size(), \"unexpected list length\");\n@@ -193,2 +200,2 @@\n-        assertEquals(f.kind(), Kind.ERRONEOUS);\n-        assertEquals(((ErroneousSnippet)f).probableKind(), Kind.METHOD);\n+        assertEquals(Kind.ERRONEOUS, f.kind());\n+        assertEquals(Kind.METHOD, ((ErroneousSnippet)f).probableKind());\n@@ -200,0 +207,1 @@\n+    @Test\n@@ -203,1 +211,1 @@\n-        assertEquals(swl.size(), 1, \"unexpected list length\");\n+        assertEquals(1, swl.size(), \"unexpected list length\");\n@@ -213,0 +221,1 @@\n+    @Test\n@@ -216,1 +225,1 @@\n-        assertEquals(swl.size(), 1, \"unexpected list length\");\n+        assertEquals(1, swl.size(), \"unexpected list length\");\n@@ -221,2 +230,2 @@\n-        assertEquals(f.kind(), Kind.ERRONEOUS);\n-        assertEquals(((ErroneousSnippet)f).probableKind(), Kind.VAR);\n+        assertEquals(Kind.ERRONEOUS, f.kind());\n+        assertEquals(Kind.VAR, ((ErroneousSnippet)f).probableKind());\n@@ -228,0 +237,1 @@\n+    @Test\n@@ -231,1 +241,1 @@\n-        assertEquals(swl.size(), 1, \"unexpected list length\");\n+        assertEquals(1, swl.size(), \"unexpected list length\");\n@@ -241,0 +251,1 @@\n+    @Test\n@@ -244,1 +255,1 @@\n-        assertEquals(swl.size(), 1, \"unexpected list length\");\n+        assertEquals(1, swl.size(), \"unexpected list length\");\n@@ -249,2 +260,2 @@\n-        assertEquals(f.kind(), Kind.ERRONEOUS);\n-        assertEquals(((ErroneousSnippet)f).probableKind(), Kind.IMPORT);\n+        assertEquals(Kind.ERRONEOUS, f.kind());\n+        assertEquals(Kind.IMPORT, ((ErroneousSnippet)f).probableKind());\n@@ -256,0 +267,1 @@\n+    @Test\n@@ -259,1 +271,1 @@\n-        assertEquals(swl.size(), 1, \"unexpected list length\");\n+        assertEquals(1, swl.size(), \"unexpected list length\");\n@@ -264,2 +276,2 @@\n-        assertEquals(f.kind(), Kind.ERRONEOUS);\n-        assertEquals(((ErroneousSnippet)f).probableKind(), Kind.ERRONEOUS);\n+        assertEquals(Kind.ERRONEOUS, f.kind());\n+        assertEquals(Kind.ERRONEOUS, ((ErroneousSnippet)f).probableKind());\n@@ -271,0 +283,1 @@\n+    @Test\n@@ -274,1 +287,1 @@\n-        assertEquals(swl.size(), 0, \"expected empty list\");\n+        assertEquals(0, swl.size(), \"expected empty list\");\n@@ -277,0 +290,1 @@\n+    @Test\n@@ -283,1 +297,1 @@\n-        assertEquals(dep.size(), 0);\n+        assertEquals(0, dep.size());\n@@ -285,1 +299,1 @@\n-        assertEquals(dep.size(), 1);\n+        assertEquals(1, dep.size());\n@@ -288,1 +302,1 @@\n-        assertEquals(dep.size(), 2);\n+        assertEquals(2, dep.size());\n@@ -294,2 +308,2 @@\n-        assertEquals(sw.source(), source);\n-        assertEquals(sw.kind(), kind);\n+        assertEquals(source, sw.source());\n+        assertEquals(kind, sw.kind());\n@@ -325,1 +339,1 @@\n-        assertEquals(wrappedPart, sourcePart,\n+        assertEquals(sourcePart, wrappedPart,\n@@ -327,1 +341,1 @@\n-        assertEquals(sw.wrappedToSourcePosition(wpg), start);\n+        assertEquals(start, sw.wrappedToSourcePosition(wpg));\n","filename":"test\/langtools\/jdk\/jshell\/WrapperTest.java","additions":43,"deletions":29,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -133,4 +133,5 @@\n-            log.warning(LintWarnings.DivZero);\n-            log.warning(tree.pos, LintWarnings.DivZero);\n-            log.warning(tree.pos(), LintWarnings.DivZero);\n-            log.warning(nil, LintWarnings.DivZero);\n+            \/\/ some warnings that will be emitted during parsing\n+            log.warning(Warnings.ExtraneousSemicolon);\n+            log.warning(tree.pos, Warnings.ExtraneousSemicolon);\n+            log.warning(tree.pos(), Warnings.ExtraneousSemicolon);\n+            log.warning(nil, Warnings.ExtraneousSemicolon);\n","filename":"test\/langtools\/tools\/javac\/6304921\/TestLog.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -733,1 +733,0 @@\n-                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n@@ -735,0 +734,1 @@\n+                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-T6400189a.java:14:35: compiler.warn.unchecked.call.mbr.of.raw.type: <T>getAnnotation(java.lang.Class<T>), java.lang.reflect.Constructor\n@@ -3,0 +2,1 @@\n+T6400189a.java:14:35: compiler.warn.unchecked.call.mbr.of.raw.type: <T>getAnnotation(java.lang.Class<T>), java.lang.reflect.Constructor\n","filename":"test\/langtools\/tools\/javac\/OverrideChecks\/6400189\/T6400189a.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-T6400189b.java:24:24: compiler.warn.unchecked.call.mbr.of.raw.type: <T>m(T6400189b<T>), T6400189b.B\n@@ -3,0 +2,1 @@\n+T6400189b.java:24:24: compiler.warn.unchecked.call.mbr.of.raw.type: <T>m(T6400189b<T>), T6400189b.B\n","filename":"test\/langtools\/tools\/javac\/OverrideChecks\/6400189\/T6400189b.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main MineField\n+ * @run main\/timeout=480 MineField\n","filename":"test\/langtools\/tools\/javac\/Paths\/MineField.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main WildcardMineField\n+ * @run main\/timeout=480 WildcardMineField\n","filename":"test\/langtools\/tools\/javac\/Paths\/WildcardMineField.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+DanglingDocCommentsClass.java:15:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:19:5: compiler.warn.dangling.doc.comment\n@@ -5,2 +7,0 @@\n-DanglingDocCommentsClass.java:15:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass.java:19:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass.enabled.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+DanglingDocCommentsClass_Line.java:21:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Line.java:26:5: compiler.warn.dangling.doc.comment\n@@ -5,2 +7,0 @@\n-DanglingDocCommentsClass_Line.java:21:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass_Line.java:26:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Line.enabled.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-DanglingDocCommentsClass_Mixed.java:13:1: compiler.warn.dangling.doc.comment\n@@ -4,0 +3,1 @@\n+DanglingDocCommentsClass_Mixed.java:13:1: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Mixed.enabled.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+DanglingDocCommentsEnum.java:16:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:22:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:28:5: compiler.warn.dangling.doc.comment\n@@ -5,3 +8,0 @@\n-DanglingDocCommentsEnum.java:16:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:22:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:28:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsEnum.enabled.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import com.sun.tools.javac.code.Flags.Flag;\n+import com.sun.tools.javac.code.FlagsEnum;\n@@ -306,1 +306,1 @@\n-        if (o instanceof Flag)\n+        if (o instanceof FlagsEnum)\n","filename":"test\/langtools\/tools\/javac\/diags\/ArgTypeCompilerFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm CheckExamples\n+ * @run main\/othervm\/timeout=480 CheckExamples\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckExamples.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm RunExamples\n+ * @run main\/othervm\/timeout=480 RunExamples\n","filename":"test\/langtools\/tools\/javac\/diags\/RunExamples.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-    public DocCommentTester(boolean useBreakIterator, boolean useIdentityTtransformer) {\n+    public DocCommentTester(boolean useBreakIterator, boolean useIdentityTransformer) {\n@@ -133,1 +133,1 @@\n-        this.useIdentityTransformer = useIdentityTtransformer;\n+        this.useIdentityTransformer = useIdentityTransformer;\n","filename":"test\/langtools\/tools\/javac\/doctree\/DocCommentTester.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8298405\n+ * @bug 8298405 8356411\n@@ -662,0 +662,24 @@\n+    \/\/\/ @see Ref label\n+    \/\/\/ @see <a href=\"..\">link<a>\n+    \/\/\/ @see \"Text\"\n+    void seeTags() { }\n+\/*\n+DocComment[DOC_COMMENT, pos:0\n+  firstSentence: empty\n+  body: empty\n+  block tags: 3\n+    See[SEE, pos:0\n+      reference: 2\n+        Reference[REFERENCE, pos:5, Ref]\n+        RawText[MARKDOWN, pos:9, label]\n+    ]\n+    See[SEE, pos:15\n+      reference: 1\n+        RawText[MARKDOWN, pos:20, <a_href=\"..\">link<a>]\n+    ]\n+    See[SEE, pos:41\n+      reference: 1\n+        Text[TEXT, pos:46, \"Text\"]\n+    ]\n+]\n+*\/\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTest.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8332858\n+ * @bug 8332858 8356411\n@@ -56,0 +56,1 @@\n+        t.testSeeTags();\n@@ -86,0 +87,13 @@\n+    private void testSeeTags() throws Exception {\n+        \/\/ @see \"Text\" does not produce a Markdown text\n+        runTest(\"\"\"\n+                \/\/\/ @see Ref label\n+                \/\/\/ @see <a href=\"..\">link<a>\n+                \/\/\/ @see \"Text\"\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"label\",\n+                \"<a href=\\\"..\\\">link<a>\");\n+    }\n+\n@@ -181,1 +195,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/tools\/javac\/doctree\/MarkdownTransformerPositionTest.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main CheckAttributedTree -q -r -et ERRONEOUS .\n+ * @run main\/timeout=480 CheckAttributedTree -q -r -et ERRONEOUS .\n","filename":"test\/langtools\/tools\/javac\/failover\/CheckAttributedTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng MultiReleaseJarTest\n+ * @run testng\/timeout=480 MultiReleaseJarTest\n","filename":"test\/langtools\/tools\/javac\/file\/MultiReleaseJar\/MultiReleaseJarTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +27,1 @@\n- * @bug 8211138\n+ * @bug 8211138 8362885\n@@ -30,1 +31,2 @@\n- * @run main FlagsTest\n+ * @compile FlagsTest.java\n+ * @run main\/manual FlagsTest\n@@ -33,0 +35,3 @@\n+import com.sun.tools.javac.code.Flags.FlagTarget;\n+import com.sun.tools.javac.code.Flags.NotFlag;\n+import com.sun.tools.javac.code.Flags.Use;\n@@ -34,1 +39,4 @@\n-import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n@@ -37,1 +45,19 @@\n-    public static void main(String[] args) throws IllegalAccessException {\n+\n+    private static final int U2_SIZE = 16;\n+\n+    public static void main(String[] args) throws Throwable {\n+        findFreeFlags();\n+    }\n+\n+    private static void findFreeFlags() throws Throwable {\n+        Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields = computeTarget2Flag2Fields();\n+\n+        for (FlagTarget target : FlagTarget.values()) {\n+            long freeFlags = ~collectFlags(target2Flag2Fields, target);\n+\n+            printFreeFlags(target.name(), freeFlags);\n+        }\n+    }\n+\n+    private static Map<FlagTarget, Map<Long, List<Field>>> computeTarget2Flag2Fields() throws Throwable {\n+        Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields = new HashMap<>();\n@@ -39,1 +65,1 @@\n-            if (!Modifier.isStatic(f.getModifiers())) {\n+            if (f.isAnnotationPresent(NotFlag.class)) {\n@@ -42,5 +68,13 @@\n-            long flag = ((Number) f.get(null)).longValue();\n-            try {\n-                Flags.asFlagSet(flag);\n-            } catch (AssertionError e) {\n-                throw new AssertionError(\"missing Flags enum constant for: \" + f.getName(), e);\n+\n+            Use use = f.getAnnotation(Use.class);\n+\n+            if (use == null) {\n+                throw new AssertionError(\"No @Use and no @NotFlag for: \" + f.getName());\n+            }\n+\n+            long flagValue = ((Number) f.get(null)).longValue();\n+\n+            for (FlagTarget target : use.value()) {\n+                target2Flag2Fields.computeIfAbsent(target, _ -> new HashMap<>())\n+                        .computeIfAbsent(flagValue, _ -> new ArrayList<>())\n+                        .add(f);\n@@ -49,0 +83,23 @@\n+        return target2Flag2Fields;\n+    }\n+\n+    private static void printFreeFlags(String comment, long freeFlags) {\n+            System.err.print(\"free flags for \" + comment + \": \");\n+            for (int bit = U2_SIZE; bit < Long.SIZE; bit++) { \/\/lowest 16 bits are used in classfiles, never suggest adding anything there\n+                if ((freeFlags & (1L << bit)) != 0) {\n+                    System.err.print(\"1L<<\" + bit + \" \");\n+                }\n+            }\n+            System.err.println();\n+    }\n+\n+    private static long collectFlags(Map<FlagTarget, Map<Long, List<Field>>> target2Flag2Fields, FlagTarget... forTargets) {\n+        long flags = 0;\n+\n+        for (FlagTarget target : forTargets) {\n+            for (long used : target2Flag2Fields.get(target).keySet()) {\n+                flags |= used;\n+            }\n+        }\n+\n+        return flags;\n","filename":"test\/langtools\/tools\/javac\/flags\/FlagsTest.java","additions":67,"deletions":10,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480 GenericConstructorAndDiamondTest\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/7030150\/GenericConstructorAndDiamondTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -4,1 +3,0 @@\n-T7188968.java:21:29: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -6,0 +4,3 @@\n+T7188968.java:23:24: compiler.err.cant.resolve.location: kindname.variable, unknown, , , (compiler.misc.location: kindname.class, T7188968, null)\n+T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n+T7188968.java:21:29: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -8,1 +9,0 @@\n-T7188968.java:23:24: compiler.err.cant.resolve.location: kindname.variable, unknown, , , (compiler.misc.location: kindname.class, T7188968, null)\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/7188968\/T7188968.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main NegativeCyclicDependencyTest\n+ * @run main\/timeout=480 NegativeCyclicDependencyTest\n","filename":"test\/langtools\/tools\/javac\/importscope\/NegativeCyclicDependencyTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main LambdaParserTest\n+ * @run main\/timeout=480 LambdaParserTest\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaParserTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-TargetType22.java:29:21: compiler.warn.unchecked.varargs.non.reifiable.type: A\n@@ -3,0 +2,1 @@\n+TargetType22.java:29:21: compiler.warn.unchecked.varargs.non.reifiable.type: A\n","filename":"test\/langtools\/tools\/javac\/lambda\/TargetType22.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -9,0 +9,2 @@\n+\n+timeout.default.seconds=480\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480  IntersectionTargetTypeTest\n","filename":"test\/langtools\/tools\/javac\/lambda\/intersection\/IntersectionTargetTypeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8362237\n- * @summary Test source launcher with specific VM behaviors\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.launcher\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          java.base\/jdk.internal.module\n- * @build toolbox.JavaTask toolbox.JavacTask toolbox.TestRunner toolbox.ToolBox\n- * @run main\/othervm -XX:-StackTraceInThrowable SourceLauncherStackTraceTest\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.List;\n-\n-import toolbox.TestRunner;\n-\n-\/\/\/ SourceLauncherTest runs the source launcher in the same VM, so we must\n-\/\/\/ use another test to run specific tests with specific VM flags\n-public class SourceLauncherStackTraceTest extends TestRunner {\n-\n-    \/\/ Inheritance will shadow all parent tests\n-    SourceLauncherTest parent = new SourceLauncherTest();\n-\n-    SourceLauncherStackTraceTest() {\n-        super(System.err);\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        SourceLauncherStackTraceTest t = new SourceLauncherStackTraceTest();\n-        t.runTests(m -> new Object[] { Paths.get(m.getName()) });\n-    }\n-\n-    \/*\n-     * Tests in which main throws an exception without a stacktrace.\n-     *\/\n-    @Test\n-    public void testTargetException2(Path base) throws IOException {\n-        parent.tb.writeJavaFiles(base, \"\"\"\n-                public class TestLauncher {\n-                    public static TestLauncher test() {\n-                        throw new RuntimeException(\"No trace\");\n-                    }\n-\n-                    public static void main(String[] args) {\n-                        \/\/ This will throw a RuntimeException without\n-                        \/\/ a stack trace due to VM options\n-                        test();\n-                    }\n-                }\n-                \"\"\");\n-        Path file = base.resolve(\"TestLauncher.java\");\n-        SourceLauncherTest.Result r = parent.run(file, List.of(), List.of(\"3\"));\n-        parent.checkEmpty(\"stdout\", r.stdOut());\n-        parent.checkEmpty(\"stderr\", r.stdErr());\n-        parent.checkTrace(\"exception\", r.exception(), \"java.lang.RuntimeException: No trace\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherStackTraceTest.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+ *      8362237\n@@ -717,0 +718,23 @@\n+    \/*\n+     * Tests in which main throws a traceless exception.\n+     *\/\n+    @Test\n+    public void testTracelessTargetException(Path base) throws IOException {\n+        tb.writeJavaFiles(base, \"\"\"\n+            class TestLauncherException extends RuntimeException {\n+                TestLauncherException() {\n+                    super(\"No trace\", null, true, false); \/\/ No writable trace\n+                }\n+\n+                public static void main(String... args) {\n+                    throw new TestLauncherException();\n+                }\n+            }\n+            \"\"\");\n+        Path file = base.resolve(\"TestLauncherException.java\");\n+        SourceLauncherTest.Result r = run(file, List.of(), List.of(\"3\"));\n+        checkEmpty(\"stdout\", r.stdOut());\n+        checkEmpty(\"stderr\", r.stdErr());\n+        checkTrace(\"exception\", r.exception(), \"TestLauncherException: No trace\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify lexical lint warnings handle nested declarations with SuppressWarnings correctly\n+ * @compile\/fail\/ref=LexicalLintNesting.out -XDrawDiagnostics -Xlint:text-blocks -Werror LexicalLintNesting.java\n+ *\/\n+\n+\/\/@SuppressWarnings(\"text-blocks\")\n+public class LexicalLintNesting {\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s1 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s2 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    public static class Nested1 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s3 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s4 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested1A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s5 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s6 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s7 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s8 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested1B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s9 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            \/* WARNING HERE *\/ String s10 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s11 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s12 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s13 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s14 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Nested2 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s15 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s16 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested2A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s17 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s18 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s19 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s20 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested2B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s21 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s22 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s23 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s24 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s25 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s26 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+LexicalLintNesting.java:12:36: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:30:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:55:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:68:45: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:80:41: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:92:37: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:162:37: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+7 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.out","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify SuppressWarnings works for LintCategore.TEXT_BLOCKS\n+ * @compile\/fail\/ref=TextBlockSuppress.out -XDrawDiagnostics -Xlint:text-blocks -Werror TextBlockSuppress.java\n+ *\/\n+\n+public class TextBlockSuppress {\n+\n+    public static class Example1 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example2 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example3 {\n+        @SuppressWarnings(\"text-blocks\")\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example4 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example5 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example6 {\n+        public void method() {\n+            @SuppressWarnings(\"text-blocks\")\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+TextBlockSuppress.java:12:24: compiler.warn.trailing.white.space.will.be.removed\n+TextBlockSuppress.java:38:24: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -1,1 +0,0 @@\n-Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n@@ -3,0 +2,1 @@\n+Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n","filename":"test\/langtools\/tools\/javac\/mandatoryWarnings\/deprecated\/Test5.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n@@ -3,0 +2,1 @@\n+Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n","filename":"test\/langtools\/tools\/javac\/mandatoryWarnings\/deprecated\/Test5b.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -602,1 +602,0 @@\n-                        \"module-info.java:1:19: compiler.warn.missing.deprecated.annotation\",\n@@ -604,0 +603,1 @@\n+                        \"module-info.java:1:19: compiler.warn.missing.deprecated.annotation\",\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationsOnModules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    public static void checkEndPosition(Class<? extends JCTree> nodeType, String input, String marker) throws IOException {\n+    public static void checkPositions(Class<? extends JCTree> nodeType, String input, String markers) throws IOException {\n@@ -74,3 +74,9 @@\n-                    int actual = TreeInfo.getEndPos(tree, unit.endPositions);\n-                    int expected = marker.indexOf('^') + 1;\n-                    if (actual != expected) {\n+\n+                    \/\/ Verify declaration start and end positions\n+                    int start = tree.getStartPosition();\n+                    if (markers.charAt(start) != '<') {\n+                        throw new AssertionError(String.format(\n+                          \"wrong %s pos %d for \\\"%s\\\" in \\\"%s\\\"\", \"start\", start, tree, input));\n+                    }\n+                    int end = TreeInfo.getEndPos(tree, unit.endPositions);\n+                    if (markers.charAt(end - 1) != '>') {\n@@ -78,1 +84,10 @@\n-                          \"wrong end pos %d != %d for \\\"%s\\\" @ %d\", actual, expected, input, tree.pos));\n+                          \"wrong %s pos %d for \\\"%s\\\" in \\\"%s\\\"\", \"end\", end, tree, input));\n+                    }\n+\n+                    \/\/ For variable declarations using \"var\", verify the \"var\" position\n+                    if (tree instanceof JCVariableDecl varDecl && varDecl.declaredUsingVar()) {\n+                        int vpos = varDecl.typePos;\n+                        if (!input.substring(vpos).startsWith(\"var\")) {\n+                            throw new AssertionError(String.format(\n+                              \"wrong %s pos %d for \\\"%s\\\" in \\\"%s\\\"\", \"var\", vpos, tree, input));\n+                        }\n@@ -89,1 +104,1 @@\n-        checkEndPosition(JCModuleDecl.class,\n+        checkPositions(JCModuleDecl.class,\n@@ -91,1 +106,1 @@\n-           \"                                          ^              \");\n+           \"              <--------------------------->              \");\n@@ -94,1 +109,1 @@\n-        checkEndPosition(JCPackageDecl.class,\n+        checkPositions(JCPackageDecl.class,\n@@ -96,1 +111,1 @@\n-           \"                          ^              \");\n+           \"              <----------->              \");\n@@ -99,1 +114,1 @@\n-        checkEndPosition(JCClassDecl.class,\n+        checkPositions(JCClassDecl.class,\n@@ -101,1 +116,1 @@\n-           \"                                         ^              \");\n+           \"              <-------------------------->              \");\n@@ -104,1 +119,1 @@\n-        checkEndPosition(JCMethodDecl.class,\n+        checkPositions(JCMethodDecl.class,\n@@ -106,1 +121,1 @@\n-           \"                                                    ^                \");\n+           \"                           <------------------------>                \");\n@@ -109,1 +124,1 @@\n-        checkEndPosition(JCVariableDecl.class,\n+        checkPositions(JCVariableDecl.class,\n@@ -111,2 +126,2 @@\n-           \"                                ^                \");\n-        checkEndPosition(JCVariableDecl.class,\n+           \"                           <---->                \");\n+        checkPositions(JCVariableDecl.class,\n@@ -114,2 +129,2 @@\n-           \"                                      ^                \");\n-        checkEndPosition(JCVariableDecl.class,\n+           \"                           <---------->                \");\n+        checkPositions(JCVariableDecl.class,\n@@ -117,1 +132,41 @@\n-           \"                                              ^                    \");\n+           \"                                      <------->                    \");\n+        checkPositions(JCVariableDecl.class,\n+           \"\/* comment *\/ class Fred { final int x = 123; } \/* comment *\/\",\n+           \"                           <---------------->                \");\n+        checkPositions(JCVariableDecl.class,\n+           \"\/* comment *\/ class Fred { final int x = 123, y = 456; } \/* comment *\/\",\n+           \"                           <---------------->-------->                \");\n+        checkPositions(JCVariableDecl.class,\n+           \"\/* comment *\/ class A { void m() { try {} catch (Error err) {} } } \/* comment *\/\",\n+           \"                                                 <------->                    \");\n+\n+        \/\/ JCVariableDecl with \"var\" declarations\n+        checkPositions(JCVariableDecl.class,\n+           \"class A { void m() { var foo; } }\",\n+           \"                     <------>    \");\n+        checkPositions(JCVariableDecl.class,\n+           \"class A { void m() { var foo = 42; } }\",\n+           \"                     <----------->    \");\n+        checkPositions(JCVariableDecl.class,\n+           \"class A { void m() { final var foo = 42; } }\",\n+           \"                     <----------------->    \");\n+\n+        checkPositions(JCVariableDecl.class,\n+           \"class A { void m() { java.util.function.Consumer<Byte> = foo -> { } } }\",\n+           \"                                                         <->           \");\n+        checkPositions(JCVariableDecl.class,\n+           \"class A { void m() { java.util.function.Consumer<Byte> = (foo) -> { } } }\",\n+           \"                                                          <->            \");\n+        checkPositions(JCVariableDecl.class,\n+           \"class A { void m() { java.util.function.Consumer<Byte> = (var foo) -> { } } }\",\n+           \"                                                          <----->            \");\n+        checkPositions(JCVariableDecl.class,\n+           \"class A { void m() { java.util.function.Consumer<Byte> = (final var foo) -> { } } }\",\n+           \"                                                          <----------->            \");\n+\n+        checkPositions(JCVariableDecl.class,\n+           \"class A { record R(int x) { } void m() { switch (null) { case R(var x) -> {} default -> {} } } }\",\n+           \"                   <--->                                        <--->                           \");\n+        checkPositions(JCVariableDecl.class,\n+           \"class A { record R(int x) { } void m() { switch (null) { case R(final var x) -> {} default -> {} } } }\",\n+           \"                   <--->                                        <--------->                           \");\n","filename":"test\/langtools\/tools\/javac\/parser\/DeclarationEndPositions.java","additions":74,"deletions":19,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859 8344706\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859 8344706 8351260\n@@ -3016,0 +3016,63 @@\n+    @Test \/\/JDK-8351260\n+    void testVeryBrokenTypeWithAnnotations() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      class ListUtilsTest {\n+                          void test(List<@AlphaChars <@StringLength(int value = 5)String> s){\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testVeryBrokenTypeWithAnnotations: \" + codes,\n+                     List.of(\"3:32:compiler.err.illegal.start.of.type\",\n+                             \"3:51:compiler.err.dot.class.expected\",\n+                             \"3:57:compiler.err.expected2\",\n+                             \"3:60:compiler.err.expected2\",\n+                             \"3:61:compiler.err.expected2\",\n+                             \"3:67:compiler.err.not.stmt\",\n+                             \"3:70:compiler.err.expected\",\n+                             \"5:2:compiler.err.premature.eof\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     class ListUtilsTest {\n+                         \\n\\\n+                         void test(List<@AlphaChars (ERROR: (ERROR)<@StringLength(int) value, (ERROR)> = 5), (ERROR: )> <error>) {\n+                             (ERROR: String > s);\n+                             {\n+                             }\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8351260\n+    void testVeryBrokenTypeWithAnnotationsMinimal() throws IOException {\n+        String code = \"\"\"\n+                      B<@C<@D(e f=\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        \/\/no exceptions:\n+        ct.parse().iterator().next();\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -75,3 +75,3 @@\n-                        b = o instanceof R(\/*missing*\/ s);\n-                        b = o instanceof R2(R(\/*missing*\/ s), String t);\n-                        b = o instanceof R2(R(\/*missing*\/ s), \/*missing*\/ t);\n+                        b = o instanceof R(var s);\n+                        b = o instanceof R2(R(var s), String t);\n+                        b = o instanceof R2(R(var s), var t);\n@@ -79,2 +79,2 @@\n-                        b = o instanceof R2(R(\/*missing*\/ _), \/*missing*\/ _);\n-                        b = o instanceof R2(R(_), \/*missing*\/ t);\n+                        b = o instanceof R2(R(var _), var _);\n+                        b = o instanceof R2(R(_), var t);\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrettyTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run junit CreateSymbolsReproducibleTest\n+ * @run junit\/timeout=480 CreateSymbolsReproducibleTest\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsReproducibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,1 +327,3 @@\n-                            if (lint == Lint.ENABLE_PREVIEW) {\n+                            if (suppress == Suppress.YES) {\n+                                expected = Set.of();\n+                            } else if (lint == Lint.ENABLE_PREVIEW) {\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -590,1 +590,0 @@\n-                        \"Test.java:24:11: compiler.warn.is.preview.reflective: test()\",\n@@ -596,0 +595,1 @@\n+                        \"Test.java:24:11: compiler.warn.is.preview.reflective: test()\",\n@@ -795,0 +795,93 @@\n+    @Test \/\/JDK-8224228:\n+    public void testSuppressWarnings(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public static int test() {\n+                                return 0;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.Preview;\n+                          public class Test {\n+\n+                            public static class Example1 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example2 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example3 {\n+                                @SuppressWarnings(\"preview\")\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example4 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example5 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example6 {\n+                                @SuppressWarnings(\"preview\")\n+                                int x = Preview.test();     \/\/ SHOULD NOT get a warning here\n+                            }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"--enable-preview\",\n+                         \"-Xlint:preview\",\n+                         \"-source\", String.valueOf(Runtime.version().feature()),\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:7:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"Test.java:27:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"2 warnings\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found: \" + log);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":95,"deletions":2,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8341342\n+ * @summary Test Elements methods programmatically\n+ * @modules jdk.compiler\n+ * @run junit TestElementsProgrammatic\n+ *\/\n+\n+import com.sun.source.util.JavacTask;\n+import java.net.URI;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/**\n+ * Programmatically test workings of various methods of Elements.\n+ *\/\n+public class TestElementsProgrammatic {\n+\n+    private final JavaCompiler systemCompiler = ToolProvider.getSystemJavaCompiler();\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void automaticallyEnter(Consumer<JavacTask> verify) {\n+        \/\/make sure the get{All,}{Module,Package,Type}Element{s,} methods will automatically enter:\n+        JavaFileObject input =\n+                SimpleJavaFileObject.forSource(URI.create(\"mem:\/\/Test.java\"), \"\");\n+        List<JavaFileObject> inputs = List.of(input);\n+        JavacTask task = (JavacTask) systemCompiler.getTask(null, null, null, null, null, inputs);\n+        verify.accept(task);\n+    }\n+\n+    private static List<Consumer<JavacTask>> automaticallyEnter() {\n+        return List.of(\n+            task -> assertFalse(task.getElements().getAllModuleElements().isEmpty()),\n+            task -> assertNotNull(task.getElements().getModuleElement(\"java.base\")),\n+            task -> assertNotNull(task.getElements().getPackageElement(\"java.lang\")),\n+            task -> assertFalse(task.getElements().getAllPackageElements(\"java.lang\").isEmpty()),\n+            task -> assertNotNull(task.getElements().getTypeElement(\"java.lang.Object\")),\n+            task -> assertFalse(task.getElements().getAllTypeElements(\"java.lang.Object\").isEmpty())\n+        );\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestElementsProgrammatic.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8270139 8361445\n+ * @bug 8270139 8361445 8365314\n@@ -227,0 +227,24 @@\n+    @Test \/\/JDK-8365314\n+    public void testSuppressWarningsMissingAttribute() throws Exception {\n+        String code = \"\"\"\n+                      @SuppressWarnings\n+                      public class Test {\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"Test.java:1:1: compiler.err.annotation.missing.default.value: java.lang.SuppressWarnings, value\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/recovery\/AnnotationRecovery.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230 8338678\n+ * @bug 8301580 8322159 8333107 8332230 8338678 8351260\n@@ -325,0 +325,18 @@\n+    @Test \/\/JDK-8351260\n+    public void testVeryBrokenAnnotation() throws Exception {\n+        String code = \"\"\"\n+                      class ListUtilsTest {\n+                          void test(List<@AlphaChars <@StringLength(int value = 5)String> s){\n+                          }\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        \/\/should not fail with an exception:\n+        new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"-XDshould-stop.at=FLOW\")\n+            .sources(code)\n+            .outdir(curPath)\n+            .run(Expect.FAIL)\n+            .writeAll();\n+    }\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main JavacTreeScannerTest -q -r .\n+ * @run main\/timeout=480 JavacTreeScannerTest -q -r .\n","filename":"test\/langtools\/tools\/javac\/tree\/JavacTreeScannerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run main SourceDocTreeScannerTest -q -r .\n+ * @run main\/timeout=480 SourceDocTreeScannerTest -q -r .\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceDocTreeScannerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main SourceTreeScannerTest -q -r .\n+ * @run main\/timeout=480 SourceTreeScannerTest -q -r .\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceTreeScannerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,0 +70,6 @@\n+        test.run(\"java.util.function.Consumer<String> c = (|final var testVar|) -> {};\",\n+                 \"final java.lang.String testVar\");\n+        test.run(\"record Rec(int x) { }; switch (null) { case Rec(|var testVar|) -> {} default -> {} };\",\n+                 \"int testVar\");\n+        test.run(\"record Rec(int x) { }; switch (null) { case Rec(|final var testVar|) -> {} default -> {} };\",\n+                 \"final int testVar\");\n","filename":"test\/langtools\/tools\/javac\/tree\/VarTree.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+\n+        \/\/ Test 4\n+        Consumer<Depr> c3 = (final var d) -> { };\n","filename":"test\/langtools\/tools\/javac\/tree\/VarWarnPosition.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,1 +6,3 @@\n-5 warnings\n+VarWarnPosition.java:27:18: compiler.warn.has.been.deprecated: Depr, compiler.misc.unnamed.package\n+VarWarnPosition.java:27:36: compiler.warn.has.been.deprecated: Depr, compiler.misc.unnamed.package\n+7 warnings\n","filename":"test\/langtools\/tools\/javac\/tree\/VarWarnPosition.out","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480 TestComparisons\n","filename":"test\/langtools\/tools\/javac\/types\/TestComparisons.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run junit IteratorsTest\n+ * @run junit\/timeout=480 IteratorsTest\n","filename":"test\/langtools\/tools\/javac\/util\/IteratorsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-T7097436.java:13:20: compiler.warn.varargs.unsafe.use.varargs.param: ls\n-T7097436.java:14:25: compiler.warn.varargs.unsafe.use.varargs.param: ls\n@@ -5,0 +3,2 @@\n+T7097436.java:13:20: compiler.warn.varargs.unsafe.use.varargs.param: ls\n+T7097436.java:14:25: compiler.warn.varargs.unsafe.use.varargs.param: ls\n","filename":"test\/langtools\/tools\/javac\/varargs\/7097436\/T7097436.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm Warn5\n+ * @run main\/othervm\/timeout=480 Warn5\n","filename":"test\/langtools\/tools\/javac\/varargs\/warning\/Warn5.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+T6594914a.java:16:52: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n@@ -5,1 +6,0 @@\n-T6594914a.java:16:52: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n","filename":"test\/langtools\/tools\/javac\/warnings\/6594914\/T6594914a.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+T7090499.java:26:10: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:27:10: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:28:17: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:28:10: compiler.err.improperly.formed.type.inner.raw.param\n@@ -6,2 +10,0 @@\n-T7090499.java:26:10: compiler.err.improperly.formed.type.inner.raw.param\n-T7090499.java:27:10: compiler.err.improperly.formed.type.inner.raw.param\n@@ -9,1 +11,0 @@\n-T7090499.java:28:17: compiler.err.improperly.formed.type.inner.raw.param\n@@ -11,1 +12,0 @@\n-T7090499.java:28:10: compiler.err.improperly.formed.type.inner.raw.param\n","filename":"test\/langtools\/tools\/javac\/warnings\/7090499\/T7090499.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,0 @@\n-                               \"UnneededStrictfpWarning1.java:16:28: compiler.warn.strictfp\",\n@@ -121,0 +120,1 @@\n+                               \"UnneededStrictfpWarning1.java:16:28: compiler.warn.strictfp\",\n","filename":"test\/langtools\/tools\/javac\/warnings\/UnneededStrictfpWarningToolBox.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+T6480588.java:18:35: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n@@ -6,0 +7,4 @@\n+T6480588.java:30:5: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:33:25: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:33:52: compiler.warn.has.been.deprecated: DeprecatedInterface, compiler.misc.unnamed.package\n+T6480588.java:32:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -7,1 +12,1 @@\n-T6480588.java:18:35: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:29:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -13,2 +18,0 @@\n-T6480588.java:30:5: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n-T6480588.java:29:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -16,3 +19,0 @@\n-T6480588.java:33:25: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n-T6480588.java:33:52: compiler.warn.has.been.deprecated: DeprecatedInterface, compiler.misc.unnamed.package\n-T6480588.java:32:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n","filename":"test\/langtools\/tools\/javac\/warnings\/suppress\/T6480588.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,6 +105,0 @@\n-    \/** The timeout factor for slow systems. *\/\n-    public static final float timeoutFactor;\n-    static {\n-        String ttf = System.getProperty(\"test.timeout.factor\");\n-        timeoutFactor = (ttf == null) ? 1.0f : Float.parseFloat(ttf);\n-    }\n@@ -485,2 +479,2 @@\n-    private static final int RETRY_DELETE_MILLIS = isWindows() ? (int)(500 * timeoutFactor): 0;\n-    private static final int MAX_RETRY_DELETE_MILLIS = isWindows() ? (int)(15 * 1000 * timeoutFactor) : 0;\n+    private static final int RETRY_DELETE_MILLIS = isWindows() ? 500 : 0;\n+    private static final int MAX_RETRY_DELETE_MILLIS = isWindows() ? 60 * 1000 : 0;\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-                    \"apx_f\",        \"avx10_1\",          \"avx10_2\"\n+                    \"apx_f\",        \"avx10_1\",          \"avx10_2\",           \"avx512_fp16\",\n+                    \"sha512\",       \"hybrid\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    private static final String FLAG_NAME = \"LargePageSizeInBytes\";\n+    private static final String FLAG_NAME = \"LargePageHeapSizeThreshold\";\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/SizeTTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -405,2 +405,0 @@\n-                                                   \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                   \"-XX:VerifyArchivedFields=2\", \/\/ make sure archived heap objects are good.\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    private static long alignment;                 \/\/ MetaspaceShared::core_region_alignment\n+    private static long alignment;                 \/\/ AOTMetaspace::core_region_alignment\n@@ -72,1 +72,1 @@\n-    \/\/ The following should be consistent with the enum in the C++ MetaspaceShared class\n+    \/\/ The following should be consistent with the enum in the C++ AOTMetaspace class\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,3 +231,0 @@\n-    \/\/ This property is passed to child test processes\n-    public static final String TestTimeoutFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-\n@@ -436,1 +433,1 @@\n-        cmd.add(\"-Dtest.timeout.factor=\" + TestTimeoutFactor);\n+        cmd.add(\"-Dtest.timeout.factor=\" + Utils.TIMEOUT_FACTOR);\n@@ -443,1 +440,0 @@\n-        addVerifyArchivedFields(cmd);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,987 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+\/*\n+*\n+ * The jtreg tests might be executed with this agent to ensure that corresponding\n+ * JDK functionality is not broken.\n+ *\n+ * IMPORTANT\n+ * The tests that are incompatible with agent should be placed\n+ * into ProblemList-jvmti-stress-agent.txt with 000000 bug.\n+ *\n+ * Test supports 2 modes:\n+ *   - standard, where the agent doesn't require debugging capabilities\n+ *   - debug, where the agent additionally test debug-related functionality\n+ *   The debug mode is incompatible with debugger tests and debug jvmti tests.\n+ *   The standard mode should be compatible with all tests except problemlisted.\n+ *\n+ *   The JVMTI agent starts jvmti agent tread that enable\/disable different\n+ *   events and call different jvmti functions concurrently with test execution.\n+ *\n+ *   The main requirement is to don't change test behaviour.\n+ *\n+ *\/\n+\n+#define JVMTI_AGENT_NAME \"JvmtiStressAgent\"\n+\n+\/* Global settings and some statistics counters *\/\n+typedef struct {\n+\n+  \/* Verbose logging support *\/\n+  jboolean is_verbose;\n+\n+  \/* If debugging functionality could be used. Set from agent args.*\/\n+  jboolean is_debugger_enabled;\n+\n+  \/* Monitor and flags to synchronize agent completion.*\/\n+  jrawMonitorID finished_lock;\n+  volatile jboolean request_agent_thread_stop;\n+  volatile jboolean is_agent_finished;\n+\n+  \/* Some settings configured in gdata_init(). *\/\n+\n+  \/* If agent enabled or not. *\/\n+  jboolean is_tracing_enabled;\n+\n+  \/* If events testing is enabled. *\/\n+  jboolean are_events_enabled;\n+\n+  \/* If interponly and frequent events testing is enabled. *\/\n+  jboolean are_frequent_events_enabled;\n+\n+  \/* Should we iterate heap *\/\n+  jboolean is_heap_iterate_enabled;\n+\n+  \/* Is Heap sampling enabled *\/\n+  jboolean is_heap_sampling_enabled;\n+\n+  jint heap_sampling_interval;\n+  jint events_interval;\n+  jint frequent_events_interval;\n+\n+  \/* Excluded events *\/\n+  jint* events_excluded;\n+  jsize events_excluded_size;\n+\n+  \/* Event statistics *\/\n+\n+  \/* The counters are racy intentionally to avoid synchronization. *\/\n+  jlong cbBreakpoint;\n+  jlong cbClassFileLoadHook;\n+  jlong cbClassLoad;\n+  jlong cbClassPrepare;\n+  jlong cbCompiledMethodLoad;\n+  jlong cbCompiledMethodUnload;\n+  jlong cbDataDumpRequest;\n+  jlong cbDynamicCodeGenerated;\n+  jlong cbException;\n+  jlong cbExceptionCatch;\n+  jlong cbFieldAccess;\n+  jlong cbFieldModification;\n+  jlong cbFramePop;\n+  jlong cbGarbageCollectionFinish;\n+  jlong cbGarbageCollectionStart;\n+  jlong cbMethodEntry;\n+  jlong cbMethodExit;\n+  jlong cbMonitorContendedEnter;\n+  jlong cbMonitorContendedEntered;\n+  jlong cbMonitorWait;\n+  jlong cbMonitorWaited;\n+  jlong cbNativeMethodBind;\n+  jlong cbObjectFree;\n+  jlong cbResourceExhausted;\n+  jlong cbSampledObjectAlloc;\n+  jlong cbSingleStep;\n+  jlong cbThreadEnd;\n+  jlong cbThreadStart;\n+  jlong cbVirtualThreadEnd;\n+  jlong cbVirtualThreadStart;\n+  jlong cbVMDeath;\n+  jlong cbVMInit;\n+  jlong cbVMObjectAlloc;\n+\n+  \/* Inspector statistics are intentionally racy. *\/\n+  jlong inspectedMethods;\n+  jlong inspectedVariables;\n+\n+  \/* File for debug output, agent shouldn't write into stdout. *\/\n+  FILE* log_file;\n+} GlobalData;\n+\n+GlobalData *gdata;\n+\n+static GlobalData*\n+gdata_init(jboolean is_debugger_enabled, jboolean is_verbose) {\n+  static GlobalData data;\n+  (void) memset(&data, 0, sizeof (GlobalData));\n+\n+  data.is_debugger_enabled = is_debugger_enabled;\n+  data.is_verbose = is_verbose;\n+\n+  data.request_agent_thread_stop = JNI_FALSE;\n+  data.is_agent_finished = JNI_FALSE;\n+\n+  \/* Set jvmti stress properties *\/\n+  data.heap_sampling_interval = 1000;\n+  data.frequent_events_interval = 10;\n+\n+  data.is_tracing_enabled = JNI_TRUE;\n+  data.are_events_enabled = JNI_TRUE;\n+  data.are_frequent_events_enabled = JNI_TRUE;\n+  \/\/ disabled so far\n+  data.is_heap_iterate_enabled = JNI_FALSE;\n+  data.is_heap_sampling_enabled = JNI_FALSE;\n+\n+\n+  if (data.is_debugger_enabled) {\n+    data.events_excluded_size = 0;\n+    data.events_excluded = nullptr;\n+  } else {\n+    data.events_excluded_size = 4;\n+    data.events_excluded = new jint[4] {\n+      JVMTI_EVENT_BREAKPOINT,\n+      JVMTI_EVENT_FIELD_ACCESS,\n+      JVMTI_EVENT_FIELD_MODIFICATION,\n+      JVMTI_EVENT_SAMPLED_OBJECT_ALLOC,\n+    };\n+  }\n+  if (data.is_verbose) {\n+    data.log_file = fopen(\"JvmtiStressAgent.out\", \"w\");\n+  }\n+\n+  return &data;\n+}\n+\n+void\n+gdata_close() {\n+  free(gdata->events_excluded);\n+  if (gdata->is_verbose) {\n+    fclose(gdata->log_file);\n+  }\n+}\n+\n+\/\/ Internal buffer length for all messages\n+#define MESSAGE_LIMIT 16384\n+\n+void\n+debug(const char* format, ...) {\n+  if (!gdata->is_verbose) {\n+    return;\n+  }\n+  char dest[MESSAGE_LIMIT];\n+  va_list argptr;\n+  va_start(argptr, format);\n+  vsnprintf(dest, MESSAGE_LIMIT, format, argptr);\n+  va_end(argptr);\n+  \/\/ Enable if needed, tests might fail with unexpected output\n+  \/\/printf(\"%s\\n\", dest);\n+  fprintf(gdata->log_file, \"%s\\n\", dest);\n+  fflush(gdata->log_file);\n+}\n+\n+\/* Some helper functions to start\/stop jvmti stress agent thread. *\/\n+void\n+check_jni_exception(JNIEnv *jni, const char *message) {\n+  jobject exception = jni->ExceptionOccurred();\n+  if (exception != nullptr) {\n+    jni->ExceptionDescribe();\n+    fatal(jni, message);\n+  }\n+}\n+\n+jclass\n+find_class(JNIEnv *jni, const char *name) {\n+  char message[MESSAGE_LIMIT];\n+  jclass clazz = jni->FindClass(name);\n+  snprintf(message, MESSAGE_LIMIT, \"Failed to find class %s.\", name);\n+  check_jni_exception(jni, message);\n+  return clazz;\n+}\n+\n+jmethodID\n+get_method_id(JNIEnv *jni, jclass clazz, const char *name, const char *sig) {\n+  char message[MESSAGE_LIMIT];\n+  jmethodID method = jni->GetMethodID(clazz, name, sig);\n+  snprintf(message, MESSAGE_LIMIT, \"Failed to find method %s.\", name);\n+  check_jni_exception(jni, message);\n+  return method;\n+}\n+\n+void\n+create_agent_thread(jvmtiEnv *jvmti, JNIEnv *jni, const char *name, jvmtiStartFunction func) {\n+\n+  check_jni_exception(jni, \"JNIException before creating Agent Thread.\");\n+  jclass clazz = find_class(jni, \"java\/lang\/Thread\");\n+  jmethodID thread_ctor = get_method_id(jni, clazz, \"<init>\",\n+                                    \"(Ljava\/lang\/String;)V\");\n+\n+  jstring name_utf = jni->NewStringUTF(name);\n+  check_jni_exception(jni, \"Error creating utf name of thread.\");\n+\n+  jthread thread = jni->NewObject(clazz, thread_ctor, name_utf);\n+  check_jni_exception(jni, \"Error during instantiation of Thread object.\");\n+  jvmtiError err = jvmti->RunAgentThread(\n+                     thread, func, nullptr, JVMTI_THREAD_NORM_PRIORITY);\n+  check_jvmti_status(jni, err, \"RunAgentThread\");\n+}\n+\n+\/*\n+ * The method blocks execution until agent thread finishes.\n+ * Should be executed during VMDeath to don't run JVMTI functionality\n+ * during dead phase.\n+ *\/\n+void\n+request_agent_thread_stop_and_wait(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  RawMonitorLocker rml(jvmti, jni, gdata->finished_lock);\n+  gdata->request_agent_thread_stop = JNI_TRUE;\n+  while (!gdata->is_agent_finished) {\n+    rml.wait(1000);\n+  }\n+  debug(\"Native agent stopped\");\n+}\n+\n+\/*\n+ * The method is called by agent thread to ensure that thread correctly exits.\n+ *\/\n+static jboolean\n+should_stop(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  jboolean should_stop = JNI_FALSE;\n+  RawMonitorLocker rml(jvmti, jni, gdata->finished_lock);\n+  should_stop = gdata->request_agent_thread_stop;\n+  if (should_stop == JNI_TRUE) {\n+    gdata->is_agent_finished = JNI_TRUE;\n+    rml.notify_all();\n+  }\n+  return should_stop;\n+}\n+\n+\/*\n+ * Agent stress functions. The agent is stopped in VMDeath only and should be\n+ * always ready to get JVMTI_ERROR_THREAD_NOT_ALIVE error.\n+ *\/\n+\n+\/* Read stack, frames, method, variables, etc. *\/\n+static void\n+walk_stack(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  debug(\"In walk_stack: %p\", thread);\n+\n+  jvmtiFrameInfo frames[5];\n+  jint count = 0;\n+  err = jvmti->GetStackTrace(thread, 0, 5, frames, &count);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE || err == JVMTI_ERROR_WRONG_PHASE) {\n+    return;\n+  }\n+  check_jvmti_error(err, \"GetStackTrace\");\n+\n+  debug(\"Stack depth: %d\", count);\n+\n+  for (int frame_index = 0; frame_index < count; frame_index++) {\n+    char *method_name = nullptr;\n+    jint method_modifiers = 0;\n+    err = jvmti->GetMethodName(frames[frame_index].method, &method_name, nullptr, nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetMethodName\");\n+\n+    err = jvmti->GetMethodModifiers(frames[frame_index].method, &method_modifiers);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetMethodModifiers\");\n+\n+    debug(\"Inspecting method: %s, %d\", method_name, method_modifiers);\n+    deallocate(jvmti, jni, method_name);\n+\n+    jvmtiLocalVariableEntry* table = nullptr;\n+    jint entry_count = 0;\n+    err = jvmti->GetLocalVariableTable(frames[frame_index].method, &entry_count, &table);\n+    if (err == JVMTI_ERROR_NATIVE_METHOD || err == JVMTI_ERROR_ABSENT_INFORMATION\n+            || err == JVMTI_ERROR_WRONG_PHASE) {\n+      continue;\n+    }\n+    check_jvmti_status(jni, err, \"GetLocalVariableTable\");\n+\n+    gdata->inspectedMethods += 1;\n+    gdata->inspectedVariables += entry_count;\n+\n+    debug(\"Variables: \");\n+    for (int cnt = 0; cnt < entry_count; cnt++) {\n+      debug(\" %s  %d\", table[cnt].name, table[cnt].slot);\n+      deallocate(jvmti, jni, table[cnt].name);\n+      deallocate(jvmti, jni, table[cnt].signature);\n+      deallocate(jvmti, jni, table[cnt].generic_signature);\n+    }\n+    deallocate(jvmti, jni, table);\n+  }\n+  debug(\"---- End of stack inspection %d -----\", count);\n+}\n+\n+\/* Iterate with walk_stack through all thread. *\/\n+static void JNICALL\n+walk_all_threads_stacks(jvmtiEnv *jvmti, JNIEnv *jni) {\n+    jint threads_count = 0;\n+    jthread *threads = nullptr;\n+    jvmtiError err = JVMTI_ERROR_NONE;\n+    debug(\"Inspect:  Starting cycle...\");\n+    err = jvmti->GetAllThreads(&threads_count, &threads);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_status(jni, err, \"GetAllThreads\");\n+    for (int t = 0; t < (int)threads_count; t++) {\n+      jvmtiThreadInfo info;\n+      debug(\"Inspecting thread num %d at addr [%p]\",t, threads[t]);\n+      err = jvmti->GetThreadInfo(threads[t], &info);\n+      if (err == JVMTI_ERROR_WRONG_PHASE) {\n+        return;\n+      }\n+      check_jvmti_status(jni, err, \"GetThreadInfo\");\n+      \/\/ Skip agent thread itself and JFR threads to avoid potential deadlocks\n+      if (strstr(info.name, JVMTI_AGENT_NAME) == nullptr\n+          && strstr(info.name, \"JFR\") == nullptr) {\n+        \/\/ The non-intrusive actions are allowed to ensure that results of target\n+        \/\/ thread are not affected.\n+        jthread thread = threads[t];\n+        walk_stack(jvmti, jni, thread);\n+\n+        \/\/ Suspend\/resume are solo capabilities and are treated like debugging\n+        if (gdata->is_debugger_enabled) {\n+          debug(\"Inspect: Trying to suspend thread %s\", info.name);\n+          err = jvmti->SuspendThread(thread);\n+          if (err == JVMTI_ERROR_WRONG_PHASE) {\n+            return;\n+          }\n+          if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+            debug(\"Inspect:  thread %s is not alive. Skipping.\", info.name);\n+            continue;\n+          }\n+          check_jvmti_status(jni, err, \"SuspendThread\");\n+          debug(\"Inspect:  Suspended thread %s\", info.name);\n+\n+          walk_stack(jvmti, jni, thread);\n+\n+          debug(\"Inspect: Trying to resume thread %s\", info.name);\n+          err = jvmti->ResumeThread(thread);\n+          if (err == JVMTI_ERROR_WRONG_PHASE) {\n+            return;\n+          }\n+          check_jvmti_status(jni, err, \"ResumeThread\");\n+          debug(\"Inspect:  Resumed thread %s\", info.name);\n+        }\n+\n+      }\n+      deallocate(jvmti, jni, info.name);\n+      jni->DeleteLocalRef(info.thread_group);\n+      jni->DeleteLocalRef(info.context_class_loader);\n+      jni->DeleteLocalRef(threads[t]);\n+    }\n+    deallocate(jvmti, jni, threads);\n+}\n+\n+\/* Heap inspection helpers. *\/\n+static jint JNICALL\n+heap_iteration_callback(jlong class_tag, jlong size, jlong* tag_ptr, jint length, void* user_data) {\n+  int* count = (int*) user_data;\n+  *count += 1;\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+static jint\n+get_heap_info(jvmtiEnv *jvmti, JNIEnv *jni, jclass klass) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  int count = 0;\n+  jvmtiHeapCallbacks callbacks;\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  callbacks.heap_iteration_callback = &heap_iteration_callback;\n+  err = jvmti->IterateThroughHeap(0, klass, &callbacks, &count);\n+  if (err == JVMTI_ERROR_WRONG_PHASE) {\n+    return count;\n+  }\n+  check_jvmti_status(jni, err, \"IterateThroughHeap\");\n+  return count;\n+}\n+\n+\n+\/*\n+ * Events testing helper functions.\n+ *\/\n+\n+\n+int\n+is_event_frequent(int event) {\n+  \/\/ Should include all interpreter-only events and all frequent events.\n+  return event == JVMTI_EVENT_SINGLE_STEP\n+      || event == JVMTI_EVENT_METHOD_ENTRY\n+      || event == JVMTI_EVENT_METHOD_EXIT\n+      || event == JVMTI_EVENT_FRAME_POP\n+      || event == JVMTI_EVENT_FIELD_ACCESS\n+      || event == JVMTI_EVENT_FIELD_MODIFICATION\n+      || event == JVMTI_EVENT_EXCEPTION_CATCH\n+      || event == JVMTI_EVENT_EXCEPTION\n+  ;\n+}\n+\n+int\n+is_event_excluded(int event) {\n+  for (int i = 0; i < gdata->events_excluded_size; i++) {\n+    if (event == gdata->events_excluded[i]) {\n+      return JNI_TRUE;\n+    }\n+  }\n+  return JNI_FALSE;\n+}\n+\n+static void\n+enable_events(jvmtiEnv *jvmti, jboolean update_frequent_events) {\n+ debug(\"Enabling events\\n\");\n+  for(int event = JVMTI_MIN_EVENT_TYPE_VAL; event < JVMTI_MAX_EVENT_TYPE_VAL; event++) {\n+    if (is_event_excluded(event)) {\n+      debug(\"Event %d excluded.\", event);\n+      continue;\n+    }\n+    if (is_event_frequent(event) != update_frequent_events ) {\n+      debug(\"Event %d is not enabled as frequent\/slow.\", event);\n+      continue;\n+    }\n+    jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+        static_cast<jvmtiEvent>(event), nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_error(err, \"SetEventNotificationMode\");\n+  }\n+  debug(\"Enabling events done\\n\");\n+}\n+\n+static void\n+enable_frequent_events(jvmtiEnv *jvmti) {\n+  enable_events(jvmti, JNI_TRUE);\n+}\n+\n+static void\n+enable_common_events(jvmtiEnv *jvmti) {\n+  enable_events(jvmti,JNI_FALSE);\n+}\n+\n+\n+static void\n+disable_all_events(jvmtiEnv *jvmti) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  for (int event = JVMTI_MIN_EVENT_TYPE_VAL; event < JVMTI_MAX_EVENT_TYPE_VAL; event++) {\n+    \/\/ VM_DEATH is used to stop agent\n+    if (event == JVMTI_EVENT_VM_DEATH) {\n+      continue;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, static_cast<jvmtiEvent>(event), nullptr);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    check_jvmti_error(err, \"SetEventNotificationMode\");\n+  }\n+}\n+\n+\/*\n+ * The JVMTI agent main loop.\n+ *\/\n+\n+static void JNICALL\n+stress_agent(jvmtiEnv *jvmti, JNIEnv *jni, void *p) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  debug(\"Debugger: Thread started.\");\n+  while (!should_stop(jvmti, jni)) {\n+\n+    if (gdata->are_events_enabled) {\n+      enable_common_events(jvmti);\n+    }\n+\n+    \/\/ Iterate through heap and get some statistics\n+    if (gdata->is_heap_iterate_enabled) {\n+      jclass kls = find_class(jni, \"java\/lang\/String\");\n+      jlong obj_count = get_heap_info(jvmti, jni, kls);\n+      debug(\"Debugger: Heap info: %d\", obj_count);\n+    }\n+\n+\n+    \/\/ requires can_generate_sampled_object_alloc_events\n+    \/\/ which is solo capability\n+    if (gdata->is_heap_sampling_enabled) {\n+      err = jvmti->SetHeapSamplingInterval(gdata->heap_sampling_interval);\n+      if (err == JVMTI_ERROR_WRONG_PHASE) {\n+        return;\n+      }\n+      check_jvmti_status(jni, err, \"SetHeapSamplingInterval\");\n+    }\n+\n+    if (gdata->is_tracing_enabled) {\n+      walk_all_threads_stacks(jvmti, jni);\n+    }\n+\n+    sleep_ms(gdata->events_interval);\n+\n+    err = jvmti->SetHeapSamplingInterval(0);\n+    if (err == JVMTI_ERROR_WRONG_PHASE) {\n+      return;\n+    }\n+    if (gdata->is_heap_sampling_enabled) {\n+      check_jvmti_status(jni, err, \"SetHeapSamplingInterval\");\n+    }\n+\n+    if (gdata->are_frequent_events_enabled) {\n+      enable_frequent_events(jvmti);\n+      sleep_ms(gdata->frequent_events_interval);\n+    }\n+    disable_all_events(jvmti);\n+    sleep_ms(gdata->events_interval);\n+  }\n+  debug(\"Debugger: Thread finished.\");\n+}\n+\n+\n+\/*\n+ *  Events section.\n+ *  Most of the events just increase counter and print debug info.\n+ *  The VMInit\/VMDeath are also start and stop jvmti stress agent.\n+ *\/\n+\n+static void\n+register_event(jlong *event) {\n+  (*event)++;\n+}\n+\n+static void JNICALL\n+cbVMInit(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbVMInit);\n+  debug(\"Event cbVMInit\\n\");\n+  create_agent_thread(jvmti, jni, JVMTI_AGENT_NAME, &stress_agent);\n+}\n+\n+static void JNICALL\n+cbVMDeath(jvmtiEnv *jvmti, JNIEnv *jni) {\n+  register_event(&gdata->cbVMDeath);\n+  debug(\"Event cbVMDeath\\n\");\n+  request_agent_thread_stop_and_wait(jvmti, jni);\n+  destroy_raw_monitor(jvmti, jni, gdata->finished_lock);\n+}\n+\n+static void JNICALL\n+cbThreadStart(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadStart);\n+  debug(\"Event cbThreadStart\\n\");\n+}\n+\n+static void JNICALL\n+cbThreadEnd(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadEnd);\n+  debug(\"Event cbThreadEnd\\n\");\n+}\n+\n+static void JNICALL\n+cbVirtualThreadStart(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadStart);\n+  debug(\"Event cbThreadStart\\n\");\n+}\n+\n+static void JNICALL\n+cbVirtualThreadEnd(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread) {\n+  register_event(&gdata->cbThreadEnd);\n+  debug(\"Event cbThreadEnd\\n\");\n+}\n+\n+static void JNICALL\n+cbClassFileLoadHook(jvmtiEnv *jvmti, JNIEnv* jni,\n+                    jclass class_being_redefined, jobject loader,\n+                    const char* name, jobject protection_domain,\n+                    jint class_data_len, const unsigned char *class_data,\n+                    jint *new_class_data_len, unsigned char **new_class_data) {\n+  \/* TODO uncomment for more stress\n+  unsigned char* new_class_data_copy = (unsigned char*) malloc(class_data_len);\n+  memcpy(new_class_data_copy, class_data, class_data_len);\n+  *new_class_data_len = class_data_len;\n+  *new_class_data = new_class_data_copy;\n+  *\/\n+  register_event(&gdata->cbClassFileLoadHook);\n+  debug(\"Event cbClassFileLoadHook\\n\");\n+}\n+\n+static void JNICALL\n+cbClassLoad(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jclass klass) {\n+  register_event(&gdata->cbClassLoad);\n+  debug(\"Event cbClassLoad\\n\");\n+}\n+\n+static void JNICALL\n+cbClassPrepare(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread, jclass klass) {\n+  register_event(&gdata->cbClassPrepare);\n+  debug(\"Event cbClassPrepare\\n\");\n+}\n+\n+static void JNICALL\n+cbDataDumpRequest(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbDataDumpRequest);\n+  debug(\"Event cbDataDumpRequest\\n\");\n+}\n+\n+static void JNICALL\n+cbException(jvmtiEnv *jvmti,\n+            JNIEnv *jni,\n+            jthread thread,\n+            jmethodID method,\n+            jlocation location,\n+            jobject exception,\n+            jmethodID catch_method,\n+            jlocation catch_location) {\n+  register_event(&gdata->cbException);\n+  debug(\"Event cbException\\n\");\n+}\n+\n+static void JNICALL\n+cbExceptionCatch(jvmtiEnv *jvmti, JNIEnv *jni,\n+                 jthread thread, jmethodID method, jlocation location,\n+                 jobject exception) {\n+  register_event(&gdata->cbExceptionCatch);\n+  debug(\"Event cbExceptionCatch\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorWait(jvmtiEnv *jvmti, JNIEnv *jni,\n+              jthread thread, jobject object, jlong timeout) {\n+  register_event(&gdata->cbMonitorWait);\n+  debug(\"Event cbMonitorWait\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorWaited(jvmtiEnv *jvmti, JNIEnv *jni,\n+                jthread thread, jobject object, jboolean timed_out) {\n+  register_event(&gdata->cbMonitorWaited);\n+  debug(\"Event cbMonitorWaited\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv *jni,\n+                        jthread thread, jobject object) {\n+  register_event(&gdata->cbMonitorContendedEnter);\n+  debug(\"Event cbMonitorContendedEnter\\n\");\n+}\n+\n+static void JNICALL\n+cbMonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv* jni,\n+                          jthread thread, jobject object) {\n+  register_event(&gdata->cbMonitorContendedEntered);\n+  debug(\"Event cbMonitorContendedEntered\\n\");\n+}\n+\n+static void JNICALL\n+cbGarbageCollectionStart(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbGarbageCollectionStart);\n+  debug(\"Event cbGarbageCollectionStart\\n\");\n+}\n+\n+static void JNICALL\n+cbGarbageCollectionFinish(jvmtiEnv *jvmti) {\n+  register_event(&gdata->cbGarbageCollectionFinish);\n+  debug(\"Event cbGarbageCollectionFinish\\n\");\n+}\n+\n+static void JNICALL\n+cbObjectFree(jvmtiEnv *jvmti, jlong tag) {\n+  register_event(&gdata->cbObjectFree);\n+  debug(\"Event cbObjectFree\\n\");\n+}\n+\n+static void JNICALL\n+cbBreakpoint(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jlocation location) {\n+  register_event(&gdata->cbBreakpoint);\n+  debug(\"Event cbBreakpoint\\n\");\n+}\n+\n+static void JNICALL\n+cbSingleStep(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jlocation location) {\n+  register_event(&gdata->cbSingleStep);\n+  debug(\"Event cbSingleStep\\n\");\n+}\n+\n+static void JNICALL\n+cbFieldAccess(jvmtiEnv *jvmti,\n+              JNIEnv *jni,\n+              jthread thread,\n+              jmethodID method,\n+              jlocation location,\n+              jclass field_klass,\n+              jobject object,\n+              jfieldID field) {\n+  register_event(&gdata->cbFieldAccess);\n+  debug(\"Event cbFieldAccess\\n\");\n+}\n+\n+static void JNICALL\n+cbFieldModification(jvmtiEnv *jvmti,\n+                    JNIEnv *jni,\n+                    jthread thread,\n+                    jmethodID method,\n+                    jlocation location,\n+                    jclass field_klass,\n+                    jobject object,\n+                    jfieldID field,\n+                    char signature_type,\n+                    jvalue new_value) {\n+  register_event(&gdata->cbFieldModification);\n+  debug(\"Event cbFieldModification\\n\");\n+}\n+\n+static void JNICALL\n+cbFramePop(jvmtiEnv *jvmti,\n+           JNIEnv *jni,\n+           jthread thread,\n+           jmethodID method,\n+           jboolean was_popped_by_exception) {\n+  register_event(&gdata->cbFramePop);\n+  debug(\"Event cbFramePop\\n\");\n+}\n+\n+static void JNICALL\n+cbMethodEntry(jvmtiEnv *jvmti,\n+              JNIEnv *jni,\n+              jthread thread,\n+              jmethodID method) {\n+  register_event(&gdata->cbMethodEntry);\n+  debug(\"Event cbMethodEntry\\n\");\n+}\n+\n+static void JNICALL\n+cbMethodExit(jvmtiEnv *jvmti,\n+             JNIEnv *jni,\n+             jthread thread,\n+             jmethodID method,\n+             jboolean was_popped_by_exception,\n+             jvalue return_value) {\n+  register_event(&gdata->cbMethodExit);\n+  debug(\"Event cbMethodExit\\n\");\n+}\n+\n+static void JNICALL\n+cbNativeMethodBind(jvmtiEnv *jvmti,\n+                   JNIEnv *jni,\n+                   jthread thread,\n+                   jmethodID method,\n+                   void* address,\n+                   void** new_address_ptr) {\n+  register_event(&gdata->cbNativeMethodBind);\n+  debug(\"Event cbNativeMethodBind\\n\");\n+}\n+\n+static void JNICALL\n+cbCompiledMethodLoad(jvmtiEnv *jvmti,\n+                     jmethodID method,\n+                     jint code_size,\n+                     const void* code_addr,\n+                     jint map_length,\n+                     const jvmtiAddrLocationMap* map,\n+                     const void* compile_info) {\n+  register_event(&gdata->cbCompiledMethodLoad);\n+  debug(\"Event cbCompiledMethodLoad\\n\");\n+}\n+\n+static void JNICALL\n+cbCompiledMethodUnload(jvmtiEnv *jvmti,\n+                       jmethodID method,\n+                       const void* code_addr) {\n+  register_event(&gdata->cbCompiledMethodUnload);\n+  debug(\"Event cbCompiledMethodUnload\\n\");\n+}\n+\n+static void JNICALL\n+cbDynamicCodeGenerated(jvmtiEnv *jvmti,\n+                       const char* name,\n+                       const void* address,\n+                       jint length) {\n+  register_event(&gdata->cbDynamicCodeGenerated);\n+  debug(\"Event cbDynamicCodeGenerated\\n\");\n+}\n+\n+static void JNICALL\n+cbResourceExhausted(jvmtiEnv *jvmti,\n+                    JNIEnv *jni,\n+                    jint flags,\n+                    const void* reserved,\n+                    const char* description) {\n+  register_event(&gdata->cbResourceExhausted);\n+  debug(\"Event cbResourceExhausted\\n\");\n+}\n+\n+static void JNICALL\n+cbVMObjectAlloc(jvmtiEnv *jvmti,\n+                JNIEnv *jni,\n+                jthread thread,\n+                jobject object,\n+                jclass object_klass,\n+                jlong size) {\n+  register_event(&gdata->cbVMObjectAlloc);\n+  debug(\"Event cbVMObjectAlloc\\n\");\n+}\n+\n+static void JNICALL\n+cbSampledObjectAlloc(jvmtiEnv *jvmti,\n+                     JNIEnv *jni,\n+                     jthread thread,\n+                     jobject object,\n+                     jclass object_klass,\n+                     jlong size) {\n+  register_event(&gdata->cbSampledObjectAlloc);\n+  debug(\"Event cbSampledObjectAlloc\\n\");\n+}\n+\n+\n+\n+static void\n+set_callbacks(jvmtiEnv *jvmti, jboolean on) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiEventCallbacks callbacks;\n+\n+  (void) memset(&callbacks, 0, sizeof (callbacks));\n+  if (on == JNI_FALSE) {\n+    err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+    check_jvmti_error(err, \"SetEventCallbacks\");\n+    return;\n+  }\n+  callbacks.Breakpoint = &cbBreakpoint;\n+  callbacks.ClassFileLoadHook = &cbClassFileLoadHook;\n+  callbacks.ClassLoad = &cbClassLoad;\n+  callbacks.ClassPrepare = &cbClassPrepare;\n+  callbacks.CompiledMethodLoad = &cbCompiledMethodLoad;\n+  callbacks.CompiledMethodUnload = &cbCompiledMethodUnload;\n+  callbacks.DataDumpRequest = &cbDataDumpRequest;\n+  callbacks.DynamicCodeGenerated = &cbDynamicCodeGenerated;\n+  callbacks.Exception = &cbException;\n+  callbacks.ExceptionCatch = &cbExceptionCatch;\n+  callbacks.FieldAccess = &cbFieldAccess;\n+  callbacks.FieldModification = &cbFieldModification;\n+  callbacks.FramePop = &cbFramePop;\n+  callbacks.GarbageCollectionFinish = &cbGarbageCollectionFinish;\n+  callbacks.GarbageCollectionStart = &cbGarbageCollectionStart;\n+  callbacks.MethodEntry = &cbMethodEntry;\n+  callbacks.MethodExit = &cbMethodExit;\n+  callbacks.MonitorContendedEnter = &cbMonitorContendedEnter;\n+  callbacks.MonitorContendedEntered = &cbMonitorContendedEntered;\n+  callbacks.MonitorWait = &cbMonitorWait;\n+  callbacks.MonitorWaited = &cbMonitorWaited;\n+  callbacks.NativeMethodBind = &cbNativeMethodBind;\n+  callbacks.ObjectFree = &cbObjectFree;\n+  callbacks.ResourceExhausted = &cbResourceExhausted;\n+  callbacks.SampledObjectAlloc = &cbSampledObjectAlloc;\n+  callbacks.SingleStep = &cbSingleStep;\n+  callbacks.ThreadEnd = &cbThreadEnd;\n+  callbacks.ThreadStart = &cbThreadStart;\n+  callbacks.VirtualThreadEnd = &cbVirtualThreadEnd;\n+  callbacks.VirtualThreadStart = &cbVirtualThreadStart;\n+  callbacks.VMDeath = &cbVMDeath;\n+  callbacks.VMInit = &cbVMInit;\n+  callbacks.VMObjectAlloc = &cbVMObjectAlloc;\n+  err = jvmti->SetEventCallbacks(&callbacks, (int) sizeof (jvmtiEventCallbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+}\n+\n+static\n+void get_capabilities(jvmtiEnv *jvmti) {\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  jvmtiCapabilities capabilities;\n+  (void) memset(&capabilities, 0, sizeof (capabilities));\n+  err = jvmti->GetPotentialCapabilities(&capabilities);\n+\n+  if (!gdata->is_debugger_enabled) {\n+    \/\/init_always_solo_capabilities\n+    capabilities.can_suspend = false;\n+\n+    \/\/ onload_solo\n+    capabilities.can_generate_breakpoint_events = false;\n+    capabilities.can_generate_field_access_events = false;\n+    capabilities.can_generate_field_modification_events = false;\n+  }\n+\n+  capabilities.can_generate_early_vmstart = false;\n+\n+  check_jvmti_error(err, \"GetPotentialCapabilities\");\n+  err = jvmti->AddCapabilities(&capabilities);\n+  check_jvmti_error(err, \"AddCapabilities\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti = nullptr;\n+  jint res = vm->GetEnv((void **) &jvmti, JVMTI_VERSION_21);\n+  if (res != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  jboolean is_debugger_enabled = JNI_TRUE;\n+  jboolean is_verbose = JNI_FALSE;\n+\n+  if (options != nullptr) {\n+    char *opts = strdup(options);\n+    char *token = strtok(opts, \",\");\n+\n+    while (token != nullptr) {\n+      if (strncmp(token, \"debugger=\", 9) == 0) {\n+        if (strcmp(token + 9, \"true\") == 0) {\n+          is_debugger_enabled = JNI_TRUE;\n+        } else {\n+          is_debugger_enabled = JNI_FALSE;\n+        }\n+      }\n+      if (strncmp(token, \"verbose\", 7) == 0) {\n+        is_verbose = JNI_TRUE;\n+      }\n+      token = strtok(nullptr, \",\");\n+    }\n+    free(opts);\n+  }\n+  gdata = gdata_init(is_debugger_enabled, is_verbose);\n+  get_capabilities(jvmti);\n+  gdata->finished_lock = create_raw_monitor(jvmti, \"Finished lock\");\n+  set_callbacks(jvmti, JNI_TRUE);\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+    JVMTI_EVENT_VM_INIT, nullptr);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM *vm) {\n+  if (!gdata->request_agent_thread_stop) {\n+    printf(\"Agent_OnUnload happened before requested stop.\\n\");\n+  }\n+  gdata_close();\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/libJvmtiStressAgent.cpp","additions":987,"deletions":0,"binary":false,"changes":987,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import java.security.cert.*;\n+import java.security.cert.Extension;\n@@ -29,4 +31,0 @@\n-import java.security.cert.X509Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.Extension;\n@@ -59,0 +57,1 @@\n+\n@@ -103,0 +102,83 @@\n+    public enum KeyUsage {\n+        DIGITAL_SIGNATURE,\n+        NONREPUDIATION,\n+        KEY_ENCIPHERMENT,\n+        DATA_ENCIPHERMENT,\n+        KEY_AGREEMENT,\n+        KEY_CERT_SIGN,\n+        CRL_SIGN,\n+        ENCIPHER_ONLY,\n+        DECIPHER_ONLY;\n+    }\n+\n+    \/**\n+     * Create a new CertificateBuilder instance. This method sets the subject name,\n+     * public key, authority key id, and serial number.\n+     *\n+     * @param subjectName entity associated with the public key\n+     * @param publicKey the entity's public key\n+     * @param caKey public key of certificate signer\n+     * @param keyUsages list of key uses\n+     * @return\n+     * @throws CertificateException\n+     * @throws IOException\n+     *\/\n+    public static CertificateBuilder newCertificateBuilder(String subjectName,\n+                           PublicKey publicKey, PublicKey caKey, KeyUsage... keyUsages)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        boolean [] keyUsage = new boolean[KeyUsage.values().length];\n+        for (KeyUsage ku : keyUsages) {\n+            keyUsage[ku.ordinal()] = true;\n+        }\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setSerialNumber(BigInteger.valueOf(random.nextLong(1000000)+1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        if (keyUsages.length != 0) {\n+            builder.addKeyUsageExt(keyUsage);\n+        }\n+        return builder;\n+    }\n+\n+    \/**\n+     * Create a Subject Alternative Name extension for the given DNS name\n+     * @param critical Sets the extension to critical or non-critical\n+     * @param dnsName DNS name to use in the extension\n+     * @throws IOException\n+     *\/\n+    public static SubjectAlternativeNameExtension createDNSSubjectAltNameExt(\n+            boolean critical, String dnsName) throws IOException {\n+        GeneralNames gns = new GeneralNames();\n+        gns.add(new GeneralName(new DNSName(dnsName)));\n+        return new SubjectAlternativeNameExtension(critical, gns);\n+    }\n+\n+    \/**\n+     * Create a Subject Alternative Name extension for the given IP address\n+     * @param critical Sets the extension to critical or non-critical\n+     * @param ipAddress IP address to use in the extension\n+     * @throws IOException\n+     *\/\n+    public static SubjectAlternativeNameExtension createIPSubjectAltNameExt(\n+            boolean critical, String ipAddress) throws IOException {\n+        GeneralNames gns = new GeneralNames();\n+        gns.add(new GeneralName(new IPAddressName(ipAddress)));\n+        return new SubjectAlternativeNameExtension(critical, gns);\n+    }\n+\n+    public static void printCertificate(X509Certificate certificate, PrintStream ps) {\n+        try {\n+            Base64.Encoder encoder = Base64.getEncoder();\n+            ps.println(\"-----BEGIN CERTIFICATE-----\");\n+            ps.println(encoder.encodeToString(certificate.getEncoded()));\n+            ps.println(\"-----END CERTIFICATE-----\");\n+        } catch (CertificateEncodingException exc) {\n+            exc.printStackTrace(ps);\n+        }\n+    }\n+\n@@ -180,0 +262,5 @@\n+    public CertificateBuilder setOneHourValidity() {\n+        return setNotBefore(Date.from(Instant.now().minus(5, ChronoUnit.MINUTES)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)));\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertificateBuilder.java","additions":91,"deletions":4,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    private static final String OPENSSL_BUNDLE_VERSION = \"3.0.14\";\n+    private static final String OPENSSL_BUNDLE_VERSION = \"3.5.1\";\n","filename":"test\/lib\/jdk\/test\/lib\/security\/OpensslArtifactFetcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.lib.Utils;\n@@ -35,4 +36,0 @@\n-    \/\/ The jtreg testing timeout factor.\n-    private static final double TIMEOUT_FACTOR = Double.valueOf(\n-            System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-\n@@ -60,1 +57,1 @@\n-        return waitFor(booleanSupplier, Math.round(1000L * TIMEOUT_FACTOR));\n+        return waitFor(booleanSupplier, Math.round(1000L * Utils.TIMEOUT_FACTOR));\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ForceGC.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include MakeFileStart.gmk\n+\n+################################################################################\n+\n+include Execute.gmk\n+include UtilsForTests.gmk\n+\n+THIS_FILE := $(TOPDIR)\/test\/make\/TestExecute.gmk\n+DEPS := $(THIS_FILE) \\\n+    $(TOPDIR)\/make\/common\/MakeBase.gmk \\\n+    #\n+\n+OUTPUT_DIR := $(TESTMAKE_OUTPUTDIR)\/execute\n+$(call MakeDir, $(OUTPUT_DIR))\n+\n+################################################################################\n+# Test SetupExecute\n+\n+$(eval $(call SetupExecute, EXEC_1, \\\n+    INFO := Testing that SetupExecute runs from SUPPORT_DIR, \\\n+    OUTPUT_DIR := $(OUTPUT_DIR)\/exec_1, \\\n+    SUPPORT_DIR := $(OUTPUT_DIR)\/exec_1\/support, \\\n+    COMMAND := $(ECHO) \"Generating junk file\" > .\/junkfile, \\\n+))\n+\n+run-test1: $(EXEC_1)\n+\ttest -f $(OUTPUT_DIR)\/exec_1\/support\/junkfile\n+\n+$(eval $(call SetupExecute, EXEC_2, \\\n+    INFO := Testing that SetupExecute runs from SUPPORT_DIR, \\\n+    OUTPUT_DIR := $(OUTPUT_DIR)\/exec_2, \\\n+    SUPPORT_DIR := $(OUTPUT_DIR)\/exec_2\/support, \\\n+    WORKING_DIR := $(OUTPUT_DIR)\/exec_2\/special, \\\n+    COMMAND := $(ECHO) \"Generating special file\" > .\/specialfile, \\\n+))\n+\n+run-test2: $(EXEC_2)\n+\ttest -f $(OUTPUT_DIR)\/exec_2\/special\/specialfile\n+\n+\n+TEST_TARGETS += run-test1 run-test2\n+\n+.PHONY: run-test1 run-test2\n+\n+################################################################################\n+\n+all: $(TEST_TARGETS)\n+\n+################################################################################\n+\n+include MakeFileEnd.gmk\n","filename":"test\/make\/TestExecute.gmk","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -37,0 +37,3 @@\n+execute:\n+\t+$(MAKE) -f TestExecute.gmk $(TEST_SUBTARGET)\n+\n@@ -50,1 +53,1 @@\n-TARGETS += make-base java-compilation copy-files fix-deps-file idea \\\n+TARGETS += make-base java-compilation copy-files execute fix-deps-file idea \\\n","filename":"test\/make\/TestMake.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio;\n+\n+import java.nio.CharBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+\/**\n+ * Benchmark for bulk get methods of a {@code CharBuffer} created from a\n+ * {@code CharSequence}.\n+ *\/\n+\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(1)\n+public class StringCharBufferBulkTransfer {\n+    private static final int LENGTH = 16384;\n+\n+    char[] buf = new char[LENGTH];\n+    CharBuffer cb = CharBuffer.wrap(new String(buf));\n+    char[] dst = new char[LENGTH];\n+    CharBuffer cbw = CharBuffer.allocate(LENGTH);\n+\n+    @Benchmark\n+    public void absoluteBulkGet() {\n+        cb.get(0, dst, 0, dst.length);\n+    }\n+\n+    @Benchmark\n+    public void relativeBulkGet() {\n+        cb.get(dst, 0, dst.length);\n+        cb.position(0);\n+    }\n+\n+    @Benchmark\n+    public void getChars() {\n+        cb.getChars(0, LENGTH, dst, 0);\n+    }\n+\n+    @Benchmark\n+    public void absoluteBulkPut() {\n+        cbw.put(0, cb, 0, dst.length);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/StringCharBufferBulkTransfer.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -198,1 +198,1 @@\n-            count += node.getChildren().stream().mapToLong(n -> {\n+            count += node.getChildNames().mapToLong(n -> {\n@@ -200,1 +200,1 @@\n-                    return countAllNodes(reader, reader.findNode(n.getName()));\n+                    return countAllNodes(reader, reader.findNode(n));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/internal\/jrtfs\/ImageReaderBenchmark.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n@@ -265,0 +266,14 @@\n+    @Benchmark\n+    public void convertD2LBits() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = Double.doubleToLongBits(doubles[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertD2LBitsRaw() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = Double.doubleToRawLongBits(doubles[i]);\n+        }\n+    }\n+\n@@ -272,0 +287,14 @@\n+    @Benchmark\n+    public void convertF2IBits() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = Float.floatToIntBits(floats[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertF2IBitsRaw() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) Float.floatToRawIntBits(floats[i]);\n+        }\n+    }\n+\n@@ -307,0 +336,7 @@\n+    @Benchmark\n+    public void convertIBits2F() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = Float.intBitsToFloat(ints[i]);\n+        }\n+    }\n+\n@@ -328,0 +364,7 @@\n+    @Benchmark\n+    public void convertLBits2D() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = Double.longBitsToDouble(longs[i]);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1)\n+public abstract class VectorAliasing {\n+    @Param({\/*\"512\",  \"1024\", *\/  \"10000\"})\n+    public int SIZE;\n+\n+    public static int INVAR_ZERO = 0;\n+\n+    \/\/ For all types we have an \"a\" and \"b\" series. Each series is an alias to the same array.\n+    private byte[] aB;\n+    private byte[] bB;\n+\n+    private int[] aI;\n+    private int[] bI;\n+\n+    private long[] aL;\n+    private long[] bL;\n+\n+    private int iteration = 0;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        aB = new byte[SIZE];\n+        bB = new byte[SIZE];\n+\n+        aI = new int[SIZE];\n+        bI = new int[SIZE];\n+\n+        aL = new long[SIZE];\n+        bL = new long[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            aB[i] = (byte) r.nextInt();\n+            bB[i] = (byte) r.nextInt();\n+\n+            aI[i] = r.nextInt();\n+            bI[i] = r.nextInt();\n+\n+            aL[i] = r.nextLong();\n+            bL[i] = r.nextLong();\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_B(byte[] a, byte b[]) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_B(byte[] a, byte b[], int aOffset, int bOffset, int size) {\n+        for (int i = 0; i < size; i++) {\n+            b[i + bOffset] = a[i + aOffset];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_I(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_I(int[] a, int[] b, int aOffset, int bOffset, int size) {\n+        for (int i = 0; i < size; i++) {\n+            b[i + bOffset] = a[i + aOffset];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_L(long[] a, long[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_L(long[] a, long[] b, int aOffset, int bOffset, int size) {\n+        for (int i = 0; i < size; i++) {\n+            b[i + bOffset] = a[i + aOffset];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_B_sameIndex_noalias() {\n+        copy_B(bB, aB);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_B_sameIndex_alias() {\n+        copy_B(aB, aB);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    public void bench_copy_array_B_differentIndex_noalias() {\n+        copy_B(bB, aB, 0, 0, aB.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ never vectorizes, with our without runtime check\n+    public void bench_copy_array_B_differentIndex_alias() {\n+        copy_B(aB, aB, 0, 0, aB.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ Requires multiversioning for vectorization.\n+    \/\/ With only the predicate, we will eventually deopt and compile without vectorization.\n+    public void bench_copy_array_B_differentIndex_mixed() {\n+        if ((iteration++) % 2 == 0) {\n+            copy_B(bB, aB, 0, 0, aB.length); \/\/ noalias\n+        } else {\n+            copy_B(aB, aB, 0, 0, aB.length); \/\/ alias\n+        }\n+    }\n+\n+    \/\/ No overlap -> expect vectoirzation.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_B_half() {\n+        copy_B(aB, aB, 0, aB.length \/ 2, aB.length \/ 2);\n+    }\n+\n+    \/\/ Overlap, but never alias -> expect vectorization.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_B_partial_overlap() {\n+        copy_B(aB, aB, 0, aB.length \/ 4, aB.length \/ 4 * 3);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_I_sameIndex_noalias() {\n+        copy_I(bI, aI);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_I_sameIndex_alias() {\n+        copy_I(aI, aI);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    public void bench_copy_array_I_differentIndex_noalias() {\n+        copy_I(bI, aI, 0, 0, aI.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ never vectorizes, with our without runtime check\n+    public void bench_copy_array_I_differentIndex_alias() {\n+        copy_I(aI, aI, 0, 0, aI.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ Requires multiversioning for vectorization.\n+    \/\/ With only the predicate, we will eventually deopt and compile without vectorization.\n+    public void bench_copy_array_I_differentIndex_mixed() {\n+        if ((iteration++) % 2 == 0) {\n+            copy_I(bI, aI, 0, 0, aI.length); \/\/ noalias\n+        } else {\n+            copy_I(aI, aI, 0, 0, aI.length); \/\/ alias\n+        }\n+    }\n+\n+    \/\/ No overlap -> expect vectoirzation.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_I_half() {\n+        copy_I(aI, aI, 0, aI.length \/ 2, aI.length \/ 2);\n+    }\n+\n+    \/\/ Overlap, but never alias -> expect vectorization.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_I_partial_overlap() {\n+        copy_I(aI, aI, 0, aI.length \/ 4, aI.length \/ 4 * 3);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_L_sameIndex_noalias() {\n+        copy_L(bL, aL);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_L_sameIndex_alias() {\n+        copy_L(aL, aL);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    public void bench_copy_array_L_differentIndex_noalias() {\n+        copy_L(bL, aL, 0, 0, aL.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ never vectorizes, with our without runtime check\n+    public void bench_copy_array_L_differentIndex_alias() {\n+        copy_L(aL, aL, 0, 0, aL.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ Requires multiversioning for vectorization.\n+    \/\/ With only the predicate, we will eventually deopt and compile without vectorization.\n+    public void bench_copy_array_L_differentIndex_mixed() {\n+        if ((iteration++) % 2 == 0) {\n+            copy_L(bL, aL, 0, 0, aL.length); \/\/ noalias\n+        } else {\n+            copy_L(aL, aL, 0, 0, aL.length); \/\/ alias\n+        }\n+    }\n+\n+    \/\/ No overlap -> expect vectoirzation.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_L_half() {\n+        copy_L(aL, aL, 0, aL.length \/ 2, aL.length \/ 2);\n+    }\n+\n+    \/\/ Overlap, but never alias -> expect vectorization.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_L_partial_overlap() {\n+        copy_L(aL, aL, 0, aL.length \/ 4, aL.length \/ 4 * 3);\n+    }\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"\n+    })\n+    public static class VectorAliasingSuperWordWithoutSpeculativeAliasingChecks extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:-UseAutoVectorizationPredicate\"\n+    })\n+    public static class VectorAliasingSuperWordWithoutAutoVectorizationPredicate extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:-LoopMultiversioning\"\n+    })\n+    public static class VectorAliasingSuperWordWithoutMultiversioning extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:AutoVectorizationOverrideProfitability=0\"\n+    })\n+    public static class VectorAliasingSuperWordPretendNotProfitable extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\"\n+    })\n+    public static class VectorAliasingSuperWord extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:-UseSuperWord\"\n+    })\n+    public static class VectorAliasingNoSuperWord extends VectorAliasing {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAliasing.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"}]}