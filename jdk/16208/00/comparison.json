{"files":[{"patch":"@@ -56,1 +56,1 @@\n-    DISABLED_WARNINGS := fallthrough this-escape, \\\n+    DISABLED_WARNINGS := fallthrough, \\\n","filename":"make\/CompileModuleTools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,26 +0,0 @@\n-#\n-# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/java.net.http\/Java.gmk","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/java.sql.rowset\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.charsets\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    DISABLED_WARNINGS := options this-escape, \\\n+    DISABLED_WARNINGS := options, \\\n","filename":"make\/modules\/jdk.compiler\/Gendata.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,26 +0,0 @@\n-#\n-# Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-DISABLED_WARNINGS_java += this-escape\n","filename":"make\/modules\/jdk.crypto.ec\/Java.gmk","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -59,1 +59,1 @@\n-    DISABLED_WARNINGS := options this-escape, \\\n+    DISABLED_WARNINGS := options, \\\n","filename":"make\/modules\/jdk.javadoc\/Gendata.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.javadoc\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jcmd\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jconsole\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jdeps\/Gensrc.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jdeps\/Launcher.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jdi\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.jpackage\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.localedata\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-DISABLED_WARNINGS_java += this-escape\n-\n","filename":"make\/modules\/jdk.sctp\/Java.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-        new ThisEscapeAnalyzer(names, syms, types, log, lint).analyzeTree(env);\n+        new ThisEscapeAnalyzer(names, syms, types, rs, log, lint).analyzeTree(env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.EnumSet;\n@@ -42,0 +43,2 @@\n+import java.util.function.Predicate;\n+import java.util.stream.Collector;\n@@ -75,3 +78,10 @@\n- * A 'this' escape is when a constructor invokes a method that could be overridden in a\n- * subclass, in which case the method will execute before the subclass constructor has\n- * finished initializing the instance.\n+ * A 'this' escape occurs in the following scenario:\n+ * <ul>\n+ *  <li>There is some class {@code A} and some subclass {@code B} that extends it\n+ *  <li>{@code A} defines an instance method {@code m()} which is overridden in {@code B}\n+ *  <li>Some constructor {@code B()} invokes some superclass constructor {@code A()}\n+ *  <li>At some point during the execution of {@code A()}, method {@code m()} is invoked and the\n+ *      reciever for the instance method is the new instance being constructed by {@code B()}\n+ * <\/ul>\n+ * This represents a problem because the method {@code B.m()} will execute before the constructor\n+ * {@code B()} has performed any of its own initialization.\n@@ -86,3 +96,10 @@\n- * As we analyze constructors and the methods they invoke, we track the various things in scope\n- * that could possibly reference the 'this' instance we are following. Such references are\n- * represented by {@link Ref} instances, of which there are these varieties:\n+ * As we analyze constructors and the methods they invoke, we track the various object references that\n+ * might reference the 'this' instance we are watching (i.e., the one under construction). Such object\n+ * references are represented by the {@link Ref} class hierarchy, which models the various ways in which,\n+ * at any point during the execution of a constructor or some other method or constructor that it invokes,\n+ * there can live references to the object under construction lying around. In a nutshell, the analyzer\n+ * keeps track of these references and watches what happens to them as the code executes so it can catch\n+ * them in the act of trying to \"escape\".\n+ *\n+ * <p>\n+ * The {@link Ref} sub-types are:\n@@ -90,6 +107,5 @@\n- *  <li>The current 'this' reference; see {@link ThisRef}\n- *  <li>The current outer 'this' reference; see {@link OuterRef}\n- *  <li>Local variables and method parameters; see {@link VarRef}\n- *  <li>The current expression being evaluated, i.e.,what's on top of the Java stack; see {@link ExprRef}\n- *  <li>The current switch expressions's yield value; see {@link YieldRef}\n- *  <li>The current method's return value; see {@link ReturnRef}\n+ *  <li>{@link ThisRef} - The current 'this' instance of the (instance) method being analyzed\n+ *  <li>{@link ExprRef} - The current expression being evaluated, i.e., what's on top of the Java stack\n+ *  <li>{@link VarRef} - Local variables and method parameters currently in scope\n+ *  <li>{@link YieldRef} - The current switch expression's yield value(s)\n+ *  <li>{@link ReturnRef} - The current method's return value(s)\n@@ -99,4 +115,1 @@\n- * For each type of reference, we distinguish between <i>direct<\/i> and <i>indirect<\/i> references.\n- * A direct reference means the reference directly refers to the 'this' instance we are tracking.\n- * An indirect reference means the reference refers to the 'this' instance we are tracking through\n- * at least one level of indirection.\n+ * Currently we don't attempt to explicitly track references stored in fields (for future study).\n@@ -105,1 +118,3 @@\n- * Currently we do not attempt to explicitly track references stored in fields (for future study).\n+ * For each object reference represented by a {@link Ref}, we track up to three distinct ways in which\n+ * it might refer to the new 'this' instance: the reference can be direct, indirect, or via an associated\n+ * enclosing instance (see {@link Indirection}).\n@@ -110,4 +125,6 @@\n- *  <li>We \"execute\" constructors and track where the 'this' reference goes as the constructor executes.\n- *  <li>We use a very simplified flow analysis that you might call a \"flood analysis\", where the union\n- *      of every possible code branch is taken.\n- *  <li>A \"leak\" is defined as the possible passing of a subclassed 'this' reference to code defined\n+ *  <li>We \"execute\" constructors and track how the {@link Ref}'s evolve as the constructor executes.\n+ *  <li>We use a simplified \"flooding\" flow analysis where every possible code branch is taken and\n+ *      we take the union of the resulting {@link Ref}'s that are generated.\n+ *  <li>Loops are repeated until the set of {@link Ref}'s stabilizes; the maximum number of iterations\n+ *      possible is proportional to the number of variables in scope.\n+ *  <li>An \"escape\" is defined as the possible passing of a subclassed 'this' reference to code defined\n@@ -134,0 +151,1 @@\n+    private final Resolve rs;\n@@ -139,0 +157,4 @@\n+    \/** Environment for symbol lookup.\n+     *\/\n+    private Env<AttrContext> attrEnv;\n+\n@@ -147,0 +169,4 @@\n+    \/** Contains classes whose outer instance (if any) is non-public.\n+     *\/\n+    private final Set<ClassSymbol> nonPublicOuters = new HashSet<>();\n+\n@@ -192,1 +218,1 @@\n-    ThisEscapeAnalyzer(Names names, Symtab syms, Types types, Log log, Lint lint) {\n+    ThisEscapeAnalyzer(Names names, Symtab syms, Types types, Resolve rs, Log log, Lint lint) {\n@@ -196,0 +222,1 @@\n+        this.rs = rs;\n@@ -224,10 +251,0 @@\n-        \/\/ Build a set of symbols for classes declared in this file\n-        final Set<Symbol> classSyms = new HashSet<>();\n-        new TreeScanner() {\n-            @Override\n-            public void visitClassDef(JCClassDecl tree) {\n-                classSyms.add(tree.sym);\n-                super.visitClassDef(tree);\n-            }\n-        }.scan(env.tree);\n-\n@@ -237,0 +254,1 @@\n+        \/\/ Record classes whose outer instance (if any) is non-public.\n@@ -251,0 +269,2 @@\n+\n+                    \/\/ Track which clases have non-public outer instances\n@@ -253,0 +273,2 @@\n+                    if (nonPublicOuter)\n+                        nonPublicOuters.add(currentClass.sym);\n@@ -338,1 +360,1 @@\n-                    visitTopLevel(klass, () -> {\n+                    visitTopLevel(env, klass, () -> {\n@@ -347,1 +369,1 @@\n-                    visitTopLevel(klass, () -> analyzeStatements(block.stats));\n+                    visitTopLevel(env, klass, () -> analyzeStatements(block.stats));\n@@ -357,1 +379,1 @@\n-            visitTopLevel(methodInfo.declaringClass(),\n+            visitTopLevel(env, methodInfo.declaringClass(),\n@@ -483,0 +505,4 @@\n+        visitVarDef(tree.sym, tree.init);\n+    }\n+\n+    private void visitVarDef(VarSymbol sym, JCExpression expr) {\n@@ -485,1 +511,1 @@\n-        if (suppressed.contains(tree.sym))\n+        if (suppressed.contains(sym))\n@@ -489,3 +515,3 @@\n-        scan(tree.init);\n-        if (isParamOrVar(tree.sym))\n-            refs.replaceExprs(depth, direct -> new VarRef(tree.sym, direct));\n+        scan(expr);\n+        if (isParamOrVar(sym))\n+            refs.replaceExprs(depth, ref -> new VarRef(sym, ref));\n@@ -511,1 +537,1 @@\n-        \/\/ Recurse on method expression\n+        \/\/ Recurse on method expression and gather references from the method itself (if non-static)\n@@ -513,4 +539,0 @@\n-        boolean direct = refs.remove(ExprRef.direct(depth));\n-        boolean indirect = refs.remove(ExprRef.indirect(depth));\n-\n-        \/\/ Determine if method receiver represents a possible reference\n@@ -519,5 +541,5 @@\n-            if (direct)\n-                receiverRefs.add(ThisRef.direct());\n-            if (indirect)\n-                receiverRefs.add(ThisRef.indirect());\n-        }\n+            refs.removeExprs(depth)\n+              .map(ThisRef::new)\n+              .forEach(receiverRefs::add);\n+        } else\n+            refs.discardExprs(depth);\n@@ -533,1 +555,1 @@\n-    private void invoke(JCTree site, MethodSymbol sym, List<JCExpression> args, RefSet<?> receiverRefs) {\n+    private void invoke(JCTree site, MethodSymbol sym, List<JCExpression> args, RefSet<ThisRef> receiverRefs) {\n@@ -547,1 +569,1 @@\n-        \/\/ Analyze method if possible, otherwise assume nothing\n+        \/\/ See if this method is known because it's declared somewhere in our file\n@@ -549,0 +571,24 @@\n+\n+        \/\/ If the method is not matched exactly, look a little harder. This especially helps\n+        \/\/ with anonymous interface classes, where the method symbols won't match.\n+        \/\/\n+        \/\/ For example:\n+        \/\/\n+        \/\/  public Leaker() {\n+        \/\/      Runnable r = new Runnable() {\n+        \/\/          public void run() {\n+        \/\/              Leaker.this.mightLeak();\n+        \/\/          }\n+        \/\/      };\n+        \/\/      r.run();    \/\/ \"r\" has type Runnable, but we know it's really a Leaker$1\n+        \/\/  }\n+        \/\/\n+        if (methodInfo == null && receiverRefs.size() == 1) {\n+            ThisRef receiverRef = receiverRefs.iterator().next();\n+            methodInfo = methodMap.values().stream()\n+              .filter(info -> isTargetMethod(info, sym, receiverRef.tsym))\n+              .findFirst()\n+              .orElse(null);\n+        }\n+\n+        \/\/ Analyze method if possible, otherwise assume nothing\n@@ -555,0 +601,9 @@\n+    \/\/ Can we conclude that \"info\" represents the actual method invoked?\n+    private boolean isTargetMethod(MethodInfo info, MethodSymbol method, TypeSymbol receiverType) {\n+        return info.declaration.name == method.name &&                          \/\/ method name matches\n+          info.declaringClass.sym == receiverType &&                            \/\/ same class as receiver\n+          !info.declaration.sym.isConstructor() &&                              \/\/ not a constructor\n+          (info.declaration.sym.flags() & Flags.STATIC) == 0 &&                 \/\/ not a static method\n+          info.declaration.sym.overrides(method, receiverType, types, false);   \/\/ method overrides\n+    }\n+\n@@ -557,1 +612,1 @@\n-        RefSet<?> receiverRefs, MethodInfo methodInfo) {\n+            RefSet<ThisRef> receiverRefs, MethodInfo methodInfo) {\n@@ -567,1 +622,3 @@\n-            refs.removeExprs(depth, direct -> paramRefs.add(new VarRef(sym, direct)));\n+            refs.removeExprs(depth)\n+              .map(ref -> new VarRef(sym, ref))\n+              .forEach(paramRefs::add);\n@@ -604,2 +661,11 @@\n-            \/\/ \"Return\" any references from method return value\n-            refs.mapInto(refsPrev, ReturnRef.class, direct -> new ExprRef(depthPrev, direct));\n+            \/\/ Constructors \"return\" their new instances\n+            if (TreeInfo.isConstructor(methodInfo.declaration)) {\n+                refs.remove(ThisRef.class)\n+                  .map(ReturnRef::new)\n+                  .forEach(refs::add);\n+            }\n+\n+            \/\/ \"Return\" any references from method return statements\n+            refs.remove(ReturnRef.class)\n+              .map(ref -> new ExprRef(depthPrev, ref))\n+              .forEach(refsPrev::add);\n@@ -614,2 +680,2 @@\n-    \/\/ Handle invocation of an unknown or overridable method or constructor\n-    private void invokeUnknown(JCTree invoke, List<JCExpression> args, RefSet<?> receiverRefs) {\n+    \/\/ Handle invocation of an unknown or overridable method or constructor.\n+    private void invokeUnknown(JCTree invoke, List<JCExpression> args, RefSet<ThisRef> receiverRefs) {\n@@ -618,1 +684,1 @@\n-        if (!receiverRefs.isEmpty())\n+        if (receiverRefs.stream().anyMatch(this::triggersUnknownInvokeLeak))\n@@ -621,1 +687,1 @@\n-        \/\/ Detect leaks via method parameters\n+        \/\/ Detect leaks via method parameters (except via non-public outer instance)\n@@ -624,1 +690,1 @@\n-            if (refs.discardExprs(depth))\n+            if (refs.removeExprs(depth).anyMatch(this::triggersUnknownInvokeLeak))\n@@ -627,0 +693,14 @@\n+\n+        \/\/ Constructors \"return\" their new instance, so we should return the receiver refs\n+        if (invoke.hasTag(NEWCLASS)) {\n+            receiverRefs.stream()\n+              .map(ref -> new ExprRef(depth, ref))\n+              .forEach(refs::add);\n+        }\n+    }\n+\n+    \/\/ Determine if a reference should qualify as a leak if it's passed to an unknown method.\n+    \/\/ To avoid false positives, we exclude references from non-public outer instances.\n+    private boolean triggersUnknownInvokeLeak(Ref ref) {\n+        return !nonPublicOuters.contains(ref.tsym) ||\n+          ref.indirections.stream().anyMatch(i -> i != Indirection.OUTER);\n@@ -636,0 +716,6 @@\n+        TypeSymbol tsym = tree.def != null ? tree.def.sym : tree.clazz.type.tsym;\n+\n+        \/\/ Gather 'this' reference that the new instance itself will have\n+        RefSet<ThisRef> receiverRefs = receiverRefsForConstructor(tree.encl, tsym);\n+\n+        \/\/ \"Invoke\" the constructor\n@@ -637,1 +723,1 @@\n-            invokeInvokable(tree, tree.args, outerThisRefs(tree.encl, tree.clazz.type), methodInfo);\n+            invokeInvokable(tree, tree.args, receiverRefs, methodInfo);\n@@ -639,1 +725,1 @@\n-            invokeUnknown(tree, tree.args, outerThisRefs(tree.encl, tree.clazz.type));\n+            invokeUnknown(tree, tree.args, receiverRefs);\n@@ -642,3 +728,4 @@\n-    \/\/ Determine 'this' references passed to a constructor via the outer 'this' instance\n-    private RefSet<OuterRef> outerThisRefs(JCExpression explicitOuterThis, Type type) {\n-        RefSet<OuterRef> outerRefs = RefSet.newEmpty();\n+    \/\/ Determine the references a constructor will inherit from its outer 'this' instance, if any\n+    private RefSet<ThisRef> receiverRefsForConstructor(JCExpression explicitOuterThis, TypeSymbol tsym) {\n+\n+        \/\/ Create references based on explicit outer instance, if any\n@@ -647,3 +734,12 @@\n-            refs.removeExprs(depth, direct -> outerRefs.add(new OuterRef(direct)));\n-        } else if (type.tsym != methodClass.sym && type.tsym.isEnclosedBy(methodClass.sym)) {\n-            refs.mapInto(outerRefs, ThisRef.class, OuterRef::new);\n+            return refs.removeExprs(depth)\n+              .map(ref -> ref.toOuter(explicitOuterThis.type.tsym))\n+              .flatMap(Optional::stream)\n+              .collect(RefSet.collector());\n+        }\n+\n+        \/\/ Create references based on current outer instance, if any\n+        if (hasImplicitOuterInstance(tsym)) {\n+            return refs.find(ThisRef.class)\n+              .map(ref -> ref.toOuter(tsym))\n+              .flatMap(Optional::stream)\n+              .collect(RefSet.collector());\n@@ -651,1 +747,10 @@\n-        return outerRefs;\n+\n+        \/\/ None\n+        return RefSet.newEmpty();\n+    }\n+\n+    \/\/ Determine if an unqualified \"new Foo()\" constructor gets 'this' as an implicit outer instance\n+    private boolean hasImplicitOuterInstance(TypeSymbol tsym) {\n+        return tsym != methodClass.sym\n+          && tsym.hasOuterInstance()\n+          && tsym.isEnclosedBy(methodClass.sym);\n@@ -681,0 +786,28 @@\n+\n+        \/\/ Check for loop on array\n+        Type elemType = types.elemtype(tree.expr.type);\n+\n+        \/\/ If not array, resolve the Iterable and Iterator methods\n+        record ForeachMethods(MethodSymbol iterator, MethodSymbol hasNext, MethodSymbol next) { };\n+        MethodSymbol iterator = null;\n+        MethodSymbol hasNext = null;\n+        MethodSymbol next = null;\n+        if (elemType == null) {\n+            Symbol iteratorSym = rs.resolveQualifiedMethod(tree.expr.pos(), attrEnv,\n+              tree.expr.type, names.iterator, List.nil(), List.nil());\n+            if (iteratorSym instanceof MethodSymbol) {\n+                iterator = (MethodSymbol)iteratorSym;\n+                Symbol hasNextSym = rs.resolveQualifiedMethod(tree.expr.pos(), attrEnv,\n+                  iterator.getReturnType(), names.hasNext, List.nil(), List.nil());\n+                Symbol nextSym = rs.resolveQualifiedMethod(tree.expr.pos(), attrEnv,\n+                  iterator.getReturnType(), names.next, List.nil(), List.nil());\n+                if (hasNextSym instanceof MethodSymbol)\n+                    hasNext = (MethodSymbol)hasNextSym;\n+                if (nextSym instanceof MethodSymbol)\n+                    next = (MethodSymbol)nextSym;\n+            }\n+        }\n+        ForeachMethods foreachMethods = iterator != null && hasNext != null && next != null ?\n+          new ForeachMethods(iterator, hasNext, next) : null;\n+\n+        \/\/ Iterate loop\n@@ -682,0 +815,2 @@\n+\n+            \/\/ Scan iteration target\n@@ -683,1 +818,34 @@\n-            refs.discardExprs(depth);       \/\/ we don't handle iterator() yet\n+            if (elemType != null) {                     \/\/ array iteration\n+                if (isParamOrVar(foreach.var.sym)) {\n+                    refs.removeExprs(depth)\n+                      .map(ref -> ref.toIndirect(elemType.tsym))\n+                      .flatMap(Optional::stream)\n+                      .map(ref -> new VarRef(foreach.var.sym, ref))\n+                      .forEach(refs::add);\n+                } else\n+                    refs.discardExprs(depth);           \/\/ we don't track fields yet\n+            } else if (foreachMethods != null) {        \/\/ Iterable iteration\n+\n+                \/\/ \"Invoke\" the iterator() method\n+                RefSet<ThisRef> receiverRefs = refs.removeExprs(depth)\n+                  .map(ThisRef::new)\n+                  .collect(RefSet.collector());\n+                invoke(foreach.expr, foreachMethods.iterator, List.nil(), receiverRefs);\n+\n+                \/\/ \"Invoke\" the hasNext() method\n+                receiverRefs = refs.removeExprs(depth)\n+                  .map(ThisRef::new)\n+                  .collect(RefSet.collector());\n+                invoke(foreach.expr, foreachMethods.hasNext, List.nil(), receiverRefs);\n+                refs.discardExprs(depth);\n+\n+                \/\/ \"Invoke\" the next() method\n+                invoke(foreach.expr, foreachMethods.next, List.nil(), receiverRefs);\n+                if (isParamOrVar(foreach.var.sym))\n+                    refs.replaceExprs(depth, ref -> new VarRef(foreach.var.sym, ref));\n+                else\n+                    refs.discardExprs(depth);           \/\/ we don't track fields yet\n+            } else                                      \/\/ what is it???\n+                refs.discardExprs(depth);\n+\n+            \/\/ Scan loop body\n@@ -702,1 +870,1 @@\n-            RefSet<ExprRef> combinedRefs = new RefSet<>();\n+            RefSet<ExprRef> combinedRefs = RefSet.newEmpty();\n@@ -705,2 +873,5 @@\n-                refs.replace(YieldRef.class, direct -> new ExprRef(depth, direct));\n-                combinedRefs.addAll(refs.removeExprs(depth));\n+                refs.remove(YieldRef.class)\n+                  .map(ref -> new ExprRef(depth, ref))\n+                  .forEach(combinedRefs::add);\n+                refs.removeExprs(depth)\n+                  .forEach(combinedRefs::add);\n@@ -736,4 +907,1 @@\n-        visitDeferred(() -> visitScoped(false, () -> {\n-            scan(lambda.body);\n-            refs.discardExprs(depth);       \/\/ needed in case body is a JCExpression\n-        }));\n+        visitDeferred(() -> visitScoped(true, () -> scan(lambda.body)));\n@@ -744,0 +912,1 @@\n+        VarSymbol sym = (VarSymbol)TreeInfo.symbolFor(tree.lhs);\n@@ -747,1 +916,0 @@\n-        VarSymbol sym = (VarSymbol)TreeInfo.symbolFor(tree.lhs);\n@@ -749,1 +917,1 @@\n-            refs.replaceExprs(depth, direct -> new VarRef(sym, direct));\n+            refs.replaceExprs(depth, ref -> new VarRef(sym, ref));\n@@ -756,3 +924,0 @@\n-        scan(tree.indexed);\n-        refs.remove(ExprRef.direct(depth));\n-        boolean indirectRef = refs.remove(ExprRef.indirect(depth));\n@@ -761,4 +926,5 @@\n-        if (indirectRef) {\n-            refs.add(ExprRef.direct(depth));\n-            refs.add(ExprRef.indirect(depth));\n-        }\n+        scan(tree.indexed);\n+        refs.removeExprs(depth)\n+          .map(ref -> ref.toDirect(tree.type.tsym))\n+          .flatMap(Optional::stream)\n+          .forEach(refs::add);\n@@ -770,1 +936,1 @@\n-        \/\/ Scan the selected thing\n+        \/\/ Scan the selection target (i.e., the method)\n@@ -772,2 +938,1 @@\n-        boolean selectedDirectRef = refs.remove(ExprRef.direct(depth));\n-        boolean selectedIndirectRef = refs.remove(ExprRef.indirect(depth));\n+        Stream<ExprRef> methodRefs = refs.removeExprs(depth);\n@@ -775,1 +940,1 @@\n-        \/\/ Explicit 'this' reference?\n+        \/\/ Explicit 'this' reference? The expression references whatever 'this' references\n@@ -778,1 +943,3 @@\n-            refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n+            refs.find(ThisRef.class)\n+              .map(ref -> new ExprRef(depth, ref))\n+              .forEach(refs::add);\n@@ -782,22 +949,6 @@\n-        \/\/ Explicit outer 'this' reference?\n-        Type selectedType = types.erasure(tree.selected.type);\n-        if (selectedType.hasTag(CLASS)) {\n-            ClassSymbol currentClassSym = (ClassSymbol)currentClassType.tsym;\n-            ClassSymbol selectedTypeSym = (ClassSymbol)selectedType.tsym;\n-            if (tree.name == names._this &&\n-                    selectedTypeSym != currentClassSym &&\n-                    currentClassSym.isEnclosedBy(selectedTypeSym)) {\n-                refs.mapInto(refs, OuterRef.class, direct -> new ExprRef(depth, direct));\n-                return;\n-            }\n-        }\n-\n-        \/\/ Methods - the \"value\" of a non-static method is a reference to its instance\n-        Symbol sym = tree.sym;\n-        if (sym.kind == MTH) {\n-            if ((sym.flags() & Flags.STATIC) == 0) {\n-                if (selectedDirectRef)\n-                    refs.add(ExprRef.direct(depth));\n-                if (selectedIndirectRef)\n-                    refs.add(ExprRef.indirect(depth));\n-            }\n+        \/\/ Explicit outer 'this' reference? The expression references whatever the outer 'this' references\n+        if (isExplicitOuterThisReference(types, currentClassType, tree)) {\n+            refs.find(ThisRef.class)\n+              .map(ref -> ref.fromOuter(depth))\n+              .flatMap(Optional::stream)\n+              .forEach(refs::add);\n@@ -807,2 +958,3 @@\n-        \/\/ Unknown\n-        return;\n+        \/\/ For regular non-static methods, our expression \"value\" is the method's target instance\n+        if (tree.sym.kind == MTH && (tree.sym.flags() & Flags.STATIC) == 0)\n+            methodRefs.forEach(refs::add);\n@@ -816,2 +968,0 @@\n-        boolean direct = refs.remove(ExprRef.direct(depth));\n-        boolean indirect = refs.remove(ExprRef.indirect(depth));\n@@ -820,1 +970,1 @@\n-        RefSet<Ref> receiverRefs = RefSet.newEmpty();\n+        RefSet<ThisRef> receiverRefs = RefSet.newEmpty();\n@@ -826,0 +976,1 @@\n+            refs.discardExprs(depth);\n@@ -828,2 +979,0 @@\n-            refs.mapInto(receiverRefs, ThisRef.class, ThisRef::new);\n-            break;\n@@ -831,4 +980,3 @@\n-            if (direct)\n-                receiverRefs.add(ThisRef.direct());\n-            if (indirect)\n-                receiverRefs.add(ThisRef.indirect());\n+            refs.removeExprs(depth)\n+              .map(ThisRef::new)\n+              .forEach(receiverRefs::add);\n@@ -837,1 +985,2 @@\n-            receiverRefs.addAll(outerThisRefs(null, tree.expr.type));\n+            receiverRefsForConstructor(null, tree.expr.type.tsym)\n+              .forEach(receiverRefs::add);\n@@ -850,1 +999,1 @@\n-        \/\/ Reference to this?\n+        \/\/ Explicit 'this' reference? The expression references whatever 'this' references\n@@ -852,1 +1001,3 @@\n-            refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n+            refs.find(ThisRef.class)\n+              .map(ref -> new ExprRef(depth, ref))\n+              .forEach(refs::add);\n@@ -856,1 +1007,1 @@\n-        \/\/ Parameter or local variable?\n+        \/\/ Parameter or local variable? The expression references whatever the variable references\n@@ -859,4 +1010,3 @@\n-            if (refs.contains(VarRef.direct(sym)))\n-                refs.add(ExprRef.direct(depth));\n-            if (refs.contains(VarRef.indirect(sym)))\n-                refs.add(ExprRef.indirect(depth));\n+            refs.find(VarRef.class, ref -> ref.sym == sym)\n+              .map(ref -> new ExprRef(depth, ref))\n+              .forEach(refs::add);\n@@ -867,1 +1017,1 @@\n-        \/\/ The \"value\" of a non-static method is a reference to its instance.\n+        \/\/ The expression \"value\" of a non-static method is a reference to its target instance.\n@@ -874,1 +1024,3 @@\n-                refs.mapInto(refs, ThisRef.class, direct -> new ExprRef(depth, direct));\n+                refs.find(ThisRef.class)\n+                  .map(ref -> new ExprRef(depth, ref))\n+                  .forEach(refs::add);\n@@ -880,1 +1032,4 @@\n-                refs.mapInto(refs, OuterRef.class, direct -> new ExprRef(depth, direct));\n+                refs.find(ThisRef.class)\n+                  .map(ref -> ref.fromOuter(depth))\n+                  .flatMap(Optional::stream)\n+                  .forEach(refs::add);\n@@ -904,1 +1059,1 @@\n-        RefSet<ExprRef> combinedRefs = new RefSet<>();\n+        RefSet<ExprRef> combinedRefs = RefSet.newEmpty();\n@@ -906,1 +1061,2 @@\n-        combinedRefs.addAll(refs.removeExprs(depth));\n+        refs.removeExprs(depth)\n+          .forEach(combinedRefs::add);\n@@ -908,1 +1064,2 @@\n-        combinedRefs.addAll(refs.removeExprs(depth));\n+        refs.removeExprs(depth)\n+          .forEach(combinedRefs::add);\n@@ -943,1 +1100,1 @@\n-        boolean ref = false;\n+        RefSet<ExprRef> combinedRefs = RefSet.newEmpty();\n@@ -947,1 +1104,4 @@\n-                ref |= refs.discardExprs(depth);\n+                refs.removeExprs(depth)\n+                  .map(ref -> ref.toIndirect(tree.type.tsym))\n+                  .flatMap(Optional::stream)\n+                  .forEach(combinedRefs::add);\n@@ -950,2 +1110,2 @@\n-        if (ref)\n-            refs.add(ExprRef.indirect(depth));\n+        combinedRefs.stream()\n+          .forEach(refs::add);\n@@ -957,0 +1117,1 @@\n+        refs.replaceExprs(depth, ref -> ref.withType(tree.expr.type.tsym));\n@@ -1045,1 +1206,2 @@\n-    private void visitTopLevel(JCClassDecl klass, Runnable action) {\n+    private void visitTopLevel(Env<AttrContext> env, JCClassDecl klass, Runnable action) {\n+        Assert.check(attrEnv == null);\n@@ -1050,0 +1212,1 @@\n+        attrEnv = env;\n@@ -1056,1 +1219,1 @@\n-            refs.add(ThisRef.direct());\n+            refs.add(new ThisRef(targetClass.sym, EnumSet.of(Indirection.DIRECT)));\n@@ -1062,0 +1225,1 @@\n+            attrEnv = null;\n@@ -1074,1 +1238,1 @@\n-    private <T extends JCTree> void visitDeferred(Runnable recurse) {\n+    private <T extends JCTree> void visitDeferred(Runnable deferredCode) {\n@@ -1080,1 +1244,1 @@\n-            recurse.run();\n+            deferredCode.run();\n@@ -1082,0 +1246,4 @@\n+\n+            \/\/ There can be ExprRef's if the deferred code returns something.\n+            \/\/ Don't let them escape unnoticed.\n+            deferredCodeLeaks |= refs.discardExprs(depth);\n@@ -1087,1 +1255,1 @@\n-            refs.add(ExprRef.indirect(depth));\n+            refs.add(new ExprRef(depth, syms.objectType.tsym, EnumSet.of(Indirection.INDIRECT)));\n@@ -1115,1 +1283,3 @@\n-                refs.removeExprs(depth, direct -> refs.add(new ExprRef(depth - 1, direct)));\n+                refs.removeExprs(depth)\n+                  .map(ref -> new ExprRef(depth - 1, ref))\n+                  .forEach(refs::add);\n@@ -1128,0 +1298,1 @@\n+        refs.discardExprs(depth);\n@@ -1129,1 +1300,0 @@\n-        refs.removeIf(ref -> ref.getDepth() > depth);\n@@ -1168,27 +1338,27 @@\n-    private boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n-        switch (tree.getTag()) {\n-            case PARENS:\n-                return isExplicitThisReference(types, currentClass, TreeInfo.skipParens(tree));\n-            case IDENT:\n-            {\n-                JCIdent ident = (JCIdent)tree;\n-                Names names = ident.name.table.names;\n-                return ident.name == names._this;\n-            }\n-            case SELECT:\n-            {\n-                JCFieldAccess select = (JCFieldAccess)tree;\n-                Type selectedType = types.erasure(select.selected.type);\n-                if (!selectedType.hasTag(CLASS))\n-                    return false;\n-                ClassSymbol currentClassSym = (ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n-                ClassSymbol selectedClassSym = (ClassSymbol)((Type.ClassType)selectedType).tsym;\n-                Names names = select.name.table.names;\n-                return currentClassSym.isSubClass(selectedClassSym, types) &&\n-                        (select.name == names._super ||\n-                        (select.name == names._this &&\n-                            (currentClassSym == selectedClassSym ||\n-                            !currentClassSym.isEnclosedBy(selectedClassSym))));\n-            }\n-            default:\n-                return false;\n+    private boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCFieldAccess select) {\n+        Type selectedType = types.erasure(select.selected.type);\n+        if (!selectedType.hasTag(CLASS))\n+            return false;\n+        ClassSymbol currentClassSym = (ClassSymbol)((Type.ClassType)types.erasure(currentClass)).tsym;\n+        ClassSymbol selectedClassSym = (ClassSymbol)((Type.ClassType)selectedType).tsym;\n+        Names names = select.name.table.names;\n+        return currentClassSym.isSubClass(selectedClassSym, types) &&\n+                (select.name == names._super ||\n+                (select.name == names._this &&\n+                    (currentClassSym == selectedClassSym ||\n+                    !currentClassSym.isEnclosedBy(selectedClassSym))));\n+    }\n+\n+    \/** Check if the given tree is an explicit reference to the outer 'this' instance of the\n+     *  class currently being compiled. This is true if tree is 'Foo.this' where 'Foo' is\n+     *  the immediately enclosing class of the current class.\n+     *\/\n+    private boolean isExplicitOuterThisReference(Types types, Type.ClassType currentClass, JCFieldAccess select) {\n+        Type selectedType = types.erasure(select.selected.type);\n+        if (selectedType.hasTag(CLASS)) {\n+            ClassSymbol currentClassSym = (ClassSymbol)currentClass.tsym;\n+            ClassSymbol selectedTypeSym = (ClassSymbol)selectedType.tsym;\n+            if (select.name == names._this &&\n+                    currentClassSym.hasOuterInstance() &&\n+                    currentClassSym.owner.enclClass() == selectedTypeSym)\n+                return true;\n@@ -1196,0 +1366,1 @@\n+        return false;\n@@ -1215,3 +1386,2 @@\n-            Assert.check(refs.stream().noneMatch(ref -> ref.getDepth() > depth));\n-            Assert.check(allowExpr || !refs.contains(ExprRef.direct(depth)));\n-            Assert.check(allowExpr || !refs.contains(ExprRef.indirect(depth)));\n+            Assert.check(refs.find(ExprRef.class)\n+              .allMatch(ref -> allowExpr && ref.depth <= depth));\n@@ -1231,4 +1401,16 @@\n-    \/** Represents a location that could possibly hold a 'this' reference.\n-     *\n-     *  <p>\n-     *  If not \"direct\", the reference is found through at least one indirection.\n+    \/** Describes how the 'this' we care about is referenced by a {@link Ref} that is being tracked.\n+     *\/\n+    enum Indirection {\n+\n+        \/** The {@link Ref} directly references 'this'. *\/\n+        DIRECT,\n+\n+        \/** The {@link Ref} references 'this' via its outer instance. *\/\n+        OUTER,\n+\n+        \/** The {@link Ref} references 'this' indirectly somehow through\n+            at least one level of indirection. *\/\n+        INDIRECT;\n+    }\n+\n+    \/** Represents an object reference that could refer to the 'this' we care about.\n@@ -1238,2 +1420,2 @@\n-        private final int depth;\n-        private final boolean direct;\n+        final TypeSymbol tsym;\n+        final EnumSet<Indirection> indirections;\n@@ -1241,3 +1423,2 @@\n-        Ref(int depth, boolean direct) {\n-            this.depth = depth;\n-            this.direct = direct;\n+        Ref(Ref ref) {\n+            this(ref.tsym, ref.indirections);\n@@ -1246,2 +1427,5 @@\n-        public int getDepth() {\n-            return depth;\n+        Ref(TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            Assert.check(tsym != null);\n+            Assert.check(indirections != null);\n+            this.tsym = tsym;\n+            this.indirections = EnumSet.copyOf(indirections);\n@@ -1250,3 +1434,1 @@\n-        public boolean isDirect() {\n-            return direct;\n-        }\n+        public abstract Ref withType(TypeSymbol tsym);\n@@ -1257,2 +1439,2 @@\n-                ^ Integer.hashCode(depth)\n-                ^ Boolean.hashCode(direct);\n+                ^ tsym.hashCode()\n+                ^ indirections.hashCode();\n@@ -1268,2 +1450,2 @@\n-            return depth == that.depth\n-              && direct == that.direct;\n+            return tsym == that.tsym\n+              && indirections.equals(that.indirections);\n@@ -1273,1 +1455,1 @@\n-        public String toString() {\n+        public final String toString() {\n@@ -1275,0 +1457,1 @@\n+            properties.add(\"tsym=\" + tsym);\n@@ -1276,0 +1459,3 @@\n+            properties.add(indirections.stream()\n+              .map(Indirection::name)\n+              .collect(Collectors.joining(\",\")));\n@@ -1281,2 +1467,22 @@\n-            properties.add(\"depth=\" + depth);\n-            properties.add(direct ? \"direct\" : \"indirect\");\n+        }\n+\n+        \/\/ Return a modified copy of this Ref's Indirections. The modified set must not be empty.\n+        public EnumSet<Indirection> modifiedIndirections(Consumer<? super EnumSet<Indirection>> modifier) {\n+            EnumSet<Indirection> newIndirections = EnumSet.copyOf(indirections);\n+            modifier.accept(newIndirections);\n+            Assert.check(!newIndirections.isEmpty());\n+            return newIndirections;\n+        }\n+\n+        \/\/ Add one level of indirection through an outer instance\n+        \/\/  - DIRECT references become OUTER\n+        \/\/  - OUTER references disappear (we don't try to track indirect outer 'this' references)\n+        \/\/  - INDIRECT references disappear (we don't try to track outer indirect 'this' references)\n+        public Optional<ThisRef> toOuter(TypeSymbol tsym) {\n+            return Optional.of(this)\n+              .filter(ref -> ref.indirections.contains(Indirection.DIRECT))\n+              .map(ref -> new ThisRef(tsym, ref.modifiedIndirections(indirections -> {\n+                indirections.remove(Indirection.DIRECT);\n+                indirections.remove(Indirection.INDIRECT);\n+                indirections.add(Indirection.OUTER);\n+              })));\n@@ -1286,1 +1492,1 @@\n-    \/** A reference from the current 'this' instance.\n+    \/** A reference originating from the current 'this' instance.\n@@ -1290,2 +1496,2 @@\n-        ThisRef(boolean direct) {\n-            super(0, direct);\n+        ThisRef(Ref ref) {\n+            super(ref);\n@@ -1294,2 +1500,2 @@\n-        public static ThisRef direct() {\n-            return new ThisRef(true);\n+        ThisRef(TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n@@ -1298,2 +1504,3 @@\n-        public static ThisRef indirect() {\n-            return new ThisRef(false);\n+        @Override\n+        public ThisRef withType(TypeSymbol tsym) {\n+            return new ThisRef(tsym, indirections);\n@@ -1301,1 +1508,0 @@\n-    }\n@@ -1303,6 +1509,17 @@\n-    \/** A reference from the current outer 'this' instance.\n-     *\/\n-    private static class OuterRef extends Ref {\n-\n-        OuterRef(boolean direct) {\n-            super(0, direct);\n+        \/\/ Remove one level of indirection through the outer instance\n+        \/\/  - DIRECT references disappear\n+        \/\/  - OUTER references become DIRECT\n+        \/\/  - INDIRECT references disappear\n+        public Optional<ExprRef> fromOuter(int depth) {\n+            ClassSymbol outerType = Optional.of(tsym.owner)\n+              .map(Symbol::enclClass)\n+              .orElse(null);\n+            if (outerType == null)\n+                return Optional.empty();        \/\/ weird\n+            return Optional.of(this)\n+              .filter(ref -> ref.indirections.contains(Indirection.OUTER))\n+              .map(ref -> new ExprRef(depth, outerType, ref.modifiedIndirections(indirections -> {\n+                indirections.remove(Indirection.OUTER);\n+                indirections.remove(Indirection.INDIRECT);\n+                indirections.add(Indirection.DIRECT);\n+              })));\n@@ -1312,1 +1529,1 @@\n-    \/** A reference from the expression that was just evaluated.\n+    \/** A reference originating from the expression that was just evaluated.\n@@ -1317,2 +1534,43 @@\n-        ExprRef(int depth, boolean direct) {\n-            super(depth, direct);\n+        final int depth;\n+\n+        ExprRef(int depth, Ref ref) {\n+            super(ref);\n+            this.depth = depth;\n+        }\n+\n+        ExprRef(int depth, TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n+            this.depth = depth;\n+        }\n+\n+        @Override\n+        public ExprRef withType(TypeSymbol tsym) {\n+            return new ExprRef(depth, tsym, indirections);\n+        }\n+\n+        \/\/ Add one level of indirection\n+        \/\/  - DIRECT references convert to INDIRECT\n+        \/\/  - OUTER references disappear (we don't try to track indirect outer 'this' references)\n+        \/\/  - INDIRECT references stay INDIRECT\n+        public Optional<ExprRef> toIndirect(TypeSymbol indirectType) {\n+            return Optional.of(this)\n+              .filter(ref -> ref.indirections.contains(Indirection.DIRECT) ||\n+                             ref.indirections.contains(Indirection.INDIRECT))\n+              .map(ref -> new ExprRef(depth, indirectType, ref.modifiedIndirections(indirections -> {\n+                indirections.remove(Indirection.DIRECT);\n+                indirections.remove(Indirection.OUTER);\n+                indirections.add(Indirection.INDIRECT);\n+              })));\n+        }\n+\n+        \/\/ Remove one level of indirection\n+        \/\/  - DIRECT references disappear\n+        \/\/  - OUTER references disappear\n+        \/\/  - INDIRECT references become both DIRECT and INDIRECT\n+        public Optional<ExprRef> toDirect(TypeSymbol directType) {\n+            return Optional.of(this)\n+              .filter(ref -> ref.indirections.contains(Indirection.INDIRECT))\n+              .map(ref -> new ExprRef(depth, directType, ref.modifiedIndirections(indirections -> {\n+                indirections.remove(Indirection.OUTER);\n+                indirections.add(Indirection.DIRECT);\n+              })));\n@@ -1321,2 +1579,4 @@\n-        public static ExprRef direct(int depth) {\n-            return new ExprRef(depth, true);\n+        @Override\n+        public int hashCode() {\n+            return super.hashCode()\n+                ^ Integer.hashCode(depth);\n@@ -1325,2 +1585,14 @@\n-        public static ExprRef indirect(int depth) {\n-            return new ExprRef(depth, false);\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj == this)\n+                return true;\n+            if (!super.equals(obj))\n+                return false;\n+            ExprRef that = (ExprRef)obj;\n+            return depth == that.depth;\n+        }\n+\n+        @Override\n+        protected void addProperties(ArrayList<String> properties) {\n+            super.addProperties(properties);\n+            properties.add(\"depth=\" + depth);\n@@ -1334,2 +1606,11 @@\n-        ReturnRef(boolean direct) {\n-            super(0, direct);\n+        ReturnRef(Ref ref) {\n+            super(ref);\n+        }\n+\n+        ReturnRef(TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n+        }\n+\n+        @Override\n+        public ReturnRef withType(TypeSymbol tsym) {\n+            return new ReturnRef(tsym, indirections);\n@@ -1343,2 +1624,11 @@\n-        YieldRef(boolean direct) {\n-            super(0, direct);\n+        YieldRef(Ref ref) {\n+            super(ref);\n+        }\n+\n+        YieldRef(TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n+        }\n+\n+        @Override\n+        public YieldRef withType(TypeSymbol tsym) {\n+            return new YieldRef(tsym, indirections);\n@@ -1352,1 +1642,1 @@\n-        private final VarSymbol sym;\n+        final VarSymbol sym;\n@@ -1354,2 +1644,2 @@\n-        VarRef(VarSymbol sym, boolean direct) {\n-            super(0, direct);\n+        VarRef(VarSymbol sym, Ref ref) {\n+            super(ref);\n@@ -1359,6 +1649,3 @@\n-        public VarSymbol getSymbol() {\n-            return sym;\n-        }\n-\n-        public static VarRef direct(VarSymbol sym) {\n-            return new VarRef(sym, true);\n+        VarRef(VarSymbol sym, TypeSymbol tsym, EnumSet<Indirection> indirections) {\n+            super(tsym, indirections);\n+            this.sym = sym;\n@@ -1367,2 +1654,3 @@\n-        public static VarRef indirect(VarSymbol sym) {\n-            return new VarRef(sym, false);\n+        @Override\n+        public VarRef withType(TypeSymbol tsym) {\n+            return new VarRef(sym, tsym, indirections);\n@@ -1397,0 +1685,1 @@\n+     *  All methods that return Stream return a copy to avoid ConcurrentModificationException.\n@@ -1401,0 +1690,4 @@\n+        private RefSet() {\n+            super(8);\n+        }\n+\n@@ -1405,3 +1698,1 @@\n-        \/**\n-         * Discard any {@link ExprRef}'s at the specified depth.\n-         * Do this when discarding whatever is on top of the stack.\n+        \/** Find all {@link Ref}'s of the given type.\n@@ -1409,2 +1700,2 @@\n-        public boolean discardExprs(int depth) {\n-            return remove(ExprRef.direct(depth)) | remove(ExprRef.indirect(depth));\n+        public <T extends Ref> Stream<T> find(Class<T> refType) {\n+            return find(refType, ref -> true);\n@@ -1413,2 +1704,1 @@\n-        \/**\n-         * Extract any {@link ExprRef}'s at the specified depth.\n+        \/** Find all {@link Ref}'s of the given type and matching the given predicate.\n@@ -1416,4 +1706,7 @@\n-        public RefSet<ExprRef> removeExprs(int depth) {\n-            return Stream.of(ExprRef.direct(depth), ExprRef.indirect(depth))\n-              .filter(this::remove)\n-              .collect(Collectors.toCollection(RefSet::new));\n+        public <T extends Ref> Stream<T> find(Class<T> refType, Predicate<? super T> filter) {\n+            return stream()\n+              .filter(refType::isInstance)\n+              .map(refType::cast)\n+              .filter(filter)\n+              .collect(Collectors.toList())         \/\/ avoid ConcurrentModificationException\n+              .stream();\n@@ -1422,2 +1715,1 @@\n-        \/**\n-         * Extract any {@link ExprRef}'s at the specified depth and do something with them.\n+        \/** Find the {@link ExprRef} at the given depth, if any.\n@@ -1425,5 +1717,2 @@\n-        public void removeExprs(int depth, Consumer<? super Boolean> handler) {\n-            Stream.of(ExprRef.direct(depth), ExprRef.indirect(depth))\n-              .filter(this::remove)\n-              .map(ExprRef::isDirect)\n-              .forEach(handler);\n+        public Stream<ExprRef> findExprs(int depth) {\n+            return find(ExprRef.class, ref -> ref.depth == depth);\n@@ -1432,2 +1721,1 @@\n-        \/**\n-         * Replace any references of the given type.\n+        \/** Extract (i.e., find and remove) all {@link Ref}'s of the given type.\n@@ -1435,9 +1723,2 @@\n-        public void replace(Class<? extends Ref> type, Function<Boolean, ? extends T> mapper) {\n-            final List<Ref> oldRefs = this.stream()\n-              .filter(type::isInstance)\n-              .collect(List.collector());             \/\/ avoid ConcurrentModificationException\n-            this.removeAll(oldRefs);\n-            oldRefs.stream()\n-              .map(Ref::isDirect)\n-              .map(mapper)\n-              .forEach(this::add);\n+        public <T extends Ref> Stream<T> remove(Class<T> refType) {\n+            return remove(refType, ref -> true);\n@@ -1446,2 +1727,2 @@\n-        \/**\n-         * Replace any {@link ExprRef}'s at the specified depth.\n+        \/** Extract (i.e., find and remove) all {@link Ref}'s of the given type\n+         *  and matching the given predicate.\n@@ -1449,2 +1730,8 @@\n-        public void replaceExprs(int depth, Function<Boolean, ? extends T> mapper) {\n-            removeExprs(depth, direct -> add(mapper.apply(direct)));\n+        public <T extends Ref> Stream<T> remove(Class<T> refType, Predicate<? super T> filter) {\n+            ArrayList<T> list = stream()\n+              .filter(refType::isInstance)\n+              .map(refType::cast)\n+              .filter(filter)\n+              .collect(Collectors.toCollection(ArrayList::new)); \/\/ avoid ConcurrentModificationException\n+            removeAll(list);\n+            return list.stream();\n@@ -1453,2 +1740,1 @@\n-        \/**\n-         * Find references of the given type, map them, and add them to {@code dest}.\n+        \/** Extract (i.e., find and remove) all {@link ExprRef}'s at the given depth.\n@@ -1456,5 +1742,14 @@\n-        public <S extends Ref> void mapInto(RefSet<S> dest, Class<? extends Ref> type,\n-                Function<Boolean, ? extends S> mapper) {\n-            final List<S> newRefs = this.stream()\n-              .filter(type::isInstance)\n-              .map(Ref::isDirect)\n+        public Stream<ExprRef> removeExprs(int depth) {\n+            return remove(ExprRef.class, ref -> ref.depth == depth);\n+        }\n+\n+        \/** Discard all {@link ExprRef}'s at the given depth.\n+         *\/\n+        public boolean discardExprs(int depth) {\n+            return removeIf(ref -> ref instanceof ExprRef exprRef && exprRef.depth == depth);\n+        }\n+\n+        \/** Replace all {@link ExprRef}'s at the given depth after mapping them somehow.\n+         *\/\n+        public void replaceExprs(int depth, Function<? super ExprRef, ? extends T> mapper) {\n+            removeExprs(depth)\n@@ -1462,2 +1757,1 @@\n-              .collect(List.collector());             \/\/ avoid ConcurrentModificationException\n-            dest.addAll(newRefs);\n+              .forEach(this::add);\n@@ -1471,0 +1765,5 @@\n+\n+        \/\/ Return a collector that builds a RefSet\n+        public static <T extends Ref> Collector<T, ?, RefSet<T>> collector() {\n+            return Collectors.toCollection(RefSet::new);\n+        }\n@@ -1481,0 +1780,9 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"MethodInfo\"\n+              + \"[method=\" + declaringClass.sym.flatname + \".\" + declaration.sym\n+              + \",analyzable=\" + analyzable\n+              + \",invokable=\" + invokable\n+              + \"]\";\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":586,"deletions":278,"binary":false,"changes":864,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-            public class Inner2 {\n+            public static class Inner2 {\n@@ -588,0 +588,118 @@\n+    \/\/ Verify 'this' escape correctly follows outer instances through member classes\n+    public static class ThisEscapeOuterRef1 {\n+        class Inner {\n+            void foo() {\n+                ThisEscapeOuterRef1.this.hashCode();\n+            }\n+        }\n+        public ThisEscapeOuterRef1() {\n+            new Inner().foo();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape correctly follows outer instances through local classes\n+    public static class ThisEscapeOuterRef2 {\n+        public ThisEscapeOuterRef2() {\n+            class Inner {\n+                void foo() {\n+                    ThisEscapeOuterRef2.this.hashCode();\n+                }\n+            }\n+            new Inner().foo();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape correctly follows outer instances through anonymous classes\n+    public static class ThisEscapeOuterRef3 {\n+        public ThisEscapeOuterRef3() {\n+            new Runnable() {\n+                public void run() {\n+                    ThisEscapeOuterRef3.this.hashCode();    \/\/ leak here\n+                }\n+            }.run();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape knows that enhanced for loops invoke iterator(), etc.\n+    public static class ThisEscapeForeach1 implements Iterable<Object> {\n+        public ThisEscapeForeach1() {\n+            for (Object v : this)\n+                v.hashCode();           \/\/ possible leak here\n+        }\n+        @Override\n+        public final java.util.Iterator<Object> iterator() {\n+            return new java.util.Iterator<Object>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return true;\n+                }\n+                @Override\n+                public Object next() {\n+                    return ThisEscapeForeach1.this;\n+                }\n+            };\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape tracks deferred return values\n+    public static class DeferredReturn {\n+\n+        public DeferredReturn(int x) {\n+            ((Supplier<DeferredReturn>)this::self).get().mightLeak();  \/\/ leak here\n+        }\n+\n+        public DeferredReturn(float x) {\n+            ((Supplier<DeferredReturn>)() -> this).get().mightLeak();  \/\/ leak here\n+        }\n+\n+        private final DeferredReturn self() {\n+            return this;\n+        }\n+\n+        protected void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape properly tracks variable types\n+    public static class TypeTracking {\n+\n+        public TypeTracking() {\n+            Runnable r = new Runnable() {\n+                public void run() {\n+                    TypeTracking.this.mightLeak();\n+                }\n+            };\n+            r.run();        \/\/ leak here - we know \"r\" has type TypeTracking$1\n+        }\n+\n+        protected void mightLeak() {\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape doesn't warn for outer instances of anonymous classes that don't use them\n+    public static class ThisEscapeOuterRef4 {\n+        public ThisEscapeOuterRef4() {\n+            new Runnable() {\n+                public void run() {\n+                    \/\/ there is no leak in here\n+                }\n+            }.run();\n+        }\n+    }\n+\n+    \/\/ Verify 'this' escape doesn't warn for doubly-outer instance references\n+    public static class ThisEscapeDoubleOuter {\n+        public class Inner1 {\n+\n+            public Inner1() {\n+                new Inner2().foo();     \/\/ NOT a 'this' leak\n+            }\n+\n+            class Inner2 {\n+                void foo() {\n+                    ThisEscapeDoubleOuter.this.hashCode();\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.java","additions":119,"deletions":1,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,1 +26,13 @@\n-25 warnings\n+ThisEscape.java:596:28: compiler.warn.possible.this.escape\n+ThisEscape.java:592:50: compiler.warn.possible.this.escape.location\n+ThisEscape.java:608:28: compiler.warn.possible.this.escape\n+ThisEscape.java:605:54: compiler.warn.possible.this.escape.location\n+ThisEscape.java:619:18: compiler.warn.possible.this.escape\n+ThisEscape.java:617:54: compiler.warn.possible.this.escape.location\n+ThisEscape.java:627:27: compiler.warn.possible.this.escape\n+ThisEscape.java:648:55: compiler.warn.possible.this.escape\n+ThisEscape.java:652:55: compiler.warn.possible.this.escape\n+ThisEscape.java:672:18: compiler.warn.possible.this.escape\n+ThisEscape.java:669:48: compiler.warn.possible.this.escape.location\n+ThisEscape.java:726:32: compiler.warn.possible.this.escape\n+37 warnings\n","filename":"test\/langtools\/tools\/javac\/warnings\/ThisEscape.out","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}