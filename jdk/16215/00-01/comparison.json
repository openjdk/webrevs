{"files":[{"patch":"@@ -144,5 +144,11 @@\n-#ifdef _LP64\n-  return CompressedKlassPointers::is_valid_base((address)shared_base);\n-#else\n-  return true;\n-#endif\n+  \/\/ We check user input for SharedBaseAddress at dumptime. We must weed out values\n+  \/\/ we know will be invalid at runtime.\n+\n+  \/\/ At CDS runtime, \"shared_base\" will be the (attempted) mapping start. It will also\n+  \/\/ be the encoding base, since the pre-computed narrow Klass IDs in the headers of\n+  \/\/ archived objects refer to the mapping start as base.\n+  \/\/\n+  \/\/ Therefore, \"shared_base\" must be usable as encoding base. The only platform not\n+  \/\/ accepting arbitrary immediates as encoding base is aarch64. Here, we require the\n+  \/\/ base to be 32-bit aligned since such immediates can be used with 16-bit moves.\n+  return AARCH64_ONLY(is_aligned(shared_base, nth_bit(32))) NOT_AARCH64(true);\n@@ -1260,6 +1266,0 @@\n-#ifdef _LP64\n-    if (Metaspace::using_class_space()) {\n-      assert(CompressedKlassPointers::is_valid_base(base_address),\n-             \"Archive base address invalid: \" PTR_FORMAT \".\", p2i(base_address));\n-    }\n-#endif\n@@ -1351,1 +1351,0 @@\n-    assert(CompressedKlassPointers::is_valid_base((address)total_space_rs.base()), \"Sanity\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -626,2 +626,2 @@\n-      \/\/ If that failed, attempt to allocate at any 4G aligned address. The disadvantage to the\n-      \/\/ approach taken above is that os::reserve_memory_aligned needs to overallocate to guarantee\n+      \/\/ If that failed, attempt to allocate at any 4G-aligned address. The disadvantage to the\n+      \/\/ approach taken above is that os::reserve_memory_aligned needs to over-allocate to guarantee\n@@ -638,1 +638,1 @@\n-    \/\/ Fallback: reserve anywhere and (for aarch64) hope the resulting block is usable.\n+    \/\/ Fallback: reserve anywhere and hope the resulting block is usable.\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  assert(is_valid_base(requested_base), \"Address must be a valid encoding base (\" PTR_FORMAT \")\", p2i(requested_base));\n@@ -92,17 +91,0 @@\n-\n-  assert(is_valid_base(_base), \"Address must be a valid encoding base (\" PTR_FORMAT \")\", p2i(_base));\n-}\n-\n-\/\/ Given an address p, return true if p can be used as an encoding base.\n-\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n-bool CompressedKlassPointers::is_valid_base(address p) {\n-#ifdef AARCH64\n-  \/\/ Any base that is 4G aligned (including null) can probably be made to work.\n-  \/\/ Without knowing the location and size of the range-to-be-encoded in relation\n-  \/\/  to the base it is not possible to say more. If the base is not 0, we assume\n-  \/\/  the range starts at the specified encoding base and its size will not be\n-  \/\/  larger than 4GB).\n-  return is_aligned(p, 4 * G);\n-#else\n-  return true;\n-#endif\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -65,5 +65,0 @@\n-  \/\/ Given an address p, return true if p can be used as an encoding base.\n-  \/\/  (Some platforms have restrictions of what constitutes a valid base\n-  \/\/   address).\n-  static bool is_valid_base(address p);\n-\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}