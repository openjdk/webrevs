{"files":[{"patch":"@@ -346,1 +346,1 @@\n-  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,\n+  assert(is_aligned(alignment, os::vm_allocation_granularity()),\n@@ -348,1 +348,2 @@\n-  assert((size & (alignment -1)) == 0, \"size must be 'alignment' aligned\");\n+  assert(is_aligned(size, os::vm_allocation_granularity()),\n+      \"Size must be a multiple of allocation granularity (page size)\");\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3331,3 +3331,4 @@\n-  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,\n-         \"Alignment must be a multiple of allocation granularity (page size)\");\n-  assert((size & (alignment -1)) == 0, \"size must be 'alignment' aligned\");\n+  assert(is_aligned(alignment, os::vm_allocation_granularity()),\n+      \"Alignment must be a multiple of allocation granularity (page size)\");\n+  assert(is_aligned(size, os::vm_allocation_granularity()),\n+      \"Size must be a multiple of allocation granularity (page size)\");\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,5 +144,11 @@\n-#ifdef _LP64\n-  return CompressedKlassPointers::is_valid_base((address)shared_base);\n-#else\n-  return true;\n-#endif\n+  \/\/ We check user input for SharedBaseAddress at dumptime. We must weed out values\n+  \/\/ we know will be invalid at runtime.\n+\n+  \/\/ At CDS runtime, \"shared_base\" will be the (attempted) mapping start. It will also\n+  \/\/ be the encoding base, since the pre-computed narrow Klass IDs in the headers of\n+  \/\/ archived objects refer to the mapping start as base.\n+  \/\/\n+  \/\/ Therefore, \"shared_base\" must be usable as encoding base. The only platform not\n+  \/\/ accepting arbitrary immediates as encoding base is aarch64. Here, we require the\n+  \/\/ base to be 32-bit aligned since such immediates can be used with 16-bit moves.\n+  return AARCH64_ONLY(is_aligned(shared_base, nth_bit(32))) NOT_AARCH64(true);\n@@ -1260,6 +1266,0 @@\n-#ifdef _LP64\n-    if (Metaspace::using_class_space()) {\n-      assert(CompressedKlassPointers::is_valid_base(base_address),\n-             \"Archive base address invalid: \" PTR_FORMAT \".\", p2i(base_address));\n-    }\n-#endif\n@@ -1351,1 +1351,0 @@\n-    assert(CompressedKlassPointers::is_valid_base((address)total_space_rs.base()), \"Sanity\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -585,0 +585,4 @@\n+  \/\/ We try, in various ways, to reserve a memory region that is both optimized for fast narrow Klass encoding\n+  \/\/ and still randomly located to provide a form of ASLR. These attempts may fail if the address space is\n+  \/\/ very fragmented.\n+\n@@ -623,0 +627,12 @@\n+\n+#ifdef AARCH64\n+    if (result == nullptr) {\n+      \/\/ If that failed, attempt to allocate at any 4G-aligned address but let the system decide\n+      \/\/ where. For ASLR we now rely on the system.\n+      \/\/ Since this will lead to temporary over-reservation of address space, it will spike the\n+      \/\/ vsize of the process and therefore may fail if a vsize limit is in place (e.g. ulimit -v)\n+      const size_t alignment2 = 4 * G;\n+      log_debug(metaspace, map)(\"Trying to allocate at any \" SIZE_FORMAT_X \"-aligned address\", alignment2);\n+      result = os::reserve_memory_aligned(size, alignment2, false);\n+    }\n+#endif \/\/ AARCH64\n@@ -635,0 +651,1 @@\n+    log_debug(metaspace, map)(\"Mapped at \" PTR_FORMAT, p2i(result));\n@@ -639,0 +656,1 @@\n+    log_debug(metaspace, map)(\"Failed to map.\");\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  assert(is_valid_base(requested_base), \"Address must be a valid encoding base\");\n@@ -92,17 +91,0 @@\n-\n-  assert(is_valid_base(_base), \"Address must be a valid encoding base\");\n-}\n-\n-\/\/ Given an address p, return true if p can be used as an encoding base.\n-\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n-bool CompressedKlassPointers::is_valid_base(address p) {\n-#ifdef AARCH64\n-  \/\/ Below 32G, base must be aligned to 4G.\n-  \/\/ Above that point, base must be aligned to 32G\n-  if (p < (address)(32 * G)) {\n-    return is_aligned(p, 4 * G);\n-  }\n-  return is_aligned(p, (4 << LogKlassAlignmentInBytes) * G);\n-#else\n-  return true;\n-#endif\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -65,5 +65,0 @@\n-  \/\/ Given an address p, return true if p can be used as an encoding base.\n-  \/\/  (Some platforms have restrictions of what constitutes a valid base\n-  \/\/   address).\n-  static bool is_valid_base(address p);\n-\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}