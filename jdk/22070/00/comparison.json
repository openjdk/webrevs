{"files":[{"patch":"@@ -0,0 +1,436 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+\/\/ Note: I commented out the short, char, float and double benchmarks, so it only takes 5h instead of 12h.\n+\/\/ The goal is to track the performance of various loop sizes, and see the effect of pre\/post loops.\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 2, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 3, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 1)\n+public abstract class VectorThroughputForIterationCount {\n+    @Param({  \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",\n+             \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n+             \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n+             \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n+             \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n+             \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n+             \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n+             \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n+             \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n+             \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\",\n+            \"100\",\"101\",\"102\",\"103\",\"104\",\"105\",\"106\",\"107\",\"108\",\"109\",\n+            \"110\",\"111\",\"112\",\"113\",\"114\",\"115\",\"116\",\"117\",\"118\",\"119\",\n+            \"120\",\"121\",\"122\",\"123\",\"124\",\"125\",\"126\",\"127\",\"128\",\"129\",\n+            \"130\",\"131\",\"132\",\"133\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\n+            \"140\",\"141\",\"142\",\"143\",\"144\",\"145\",\"146\",\"147\",\"148\",\"149\",\n+            \"150\",\"151\",\"152\",\"153\",\"154\",\"155\",\"156\",\"157\",\"158\",\"159\",\n+            \"160\",\"161\",\"162\",\"163\",\"164\",\"165\",\"166\",\"167\",\"168\",\"169\",\n+            \"170\",\"171\",\"172\",\"173\",\"174\",\"175\",\"176\",\"177\",\"178\",\"179\",\n+            \"180\",\"181\",\"182\",\"183\",\"184\",\"185\",\"186\",\"187\",\"188\",\"189\",\n+            \"190\",\"191\",\"192\",\"193\",\"194\",\"195\",\"196\",\"197\",\"198\",\"199\",\n+            \"200\",\"201\",\"202\",\"203\",\"204\",\"205\",\"206\",\"207\",\"208\",\"209\",\n+            \"210\",\"211\",\"212\",\"213\",\"214\",\"215\",\"216\",\"217\",\"218\",\"219\",\n+            \"220\",\"221\",\"222\",\"223\",\"224\",\"225\",\"226\",\"227\",\"228\",\"229\",\n+            \"230\",\"231\",\"232\",\"233\",\"234\",\"235\",\"236\",\"237\",\"238\",\"239\",\n+            \"240\",\"241\",\"242\",\"243\",\"244\",\"245\",\"246\",\"247\",\"248\",\"249\",\n+            \"250\",\"251\",\"252\",\"253\",\"254\",\"255\",\"256\",\"257\",\"258\",\"259\",\n+            \"260\",\"261\",\"262\",\"263\",\"264\",\"265\",\"266\",\"267\",\"268\",\"269\",\n+            \"270\",\"271\",\"272\",\"273\",\"274\",\"275\",\"276\",\"277\",\"278\",\"279\",\n+            \"280\",\"281\",\"282\",\"283\",\"284\",\"285\",\"286\",\"287\",\"288\",\"289\",\n+            \"290\",\"291\",\"292\",\"293\",\"294\",\"295\",\"296\",\"297\",\"298\",\"299\",\n+            \"300\",\n+            \/\/ Above, the \"small loops\".\n+            \/\/ Below, some \"medium\" to \"large\" loops.\n+            \"1000\", \"3000\", \"10000\"})\n+    \/\/ Number of iterations spent in a loop.\n+    public static int ITERATION_COUNT;\n+\n+    \/\/ Add enough slack so we can play with offsets \/ alignment.\n+    public static int CONTAINER_SIZE = 20_000;\n+\n+    private byte[] aB;\n+    private byte[] bB;\n+    private byte[] rB;\n+\n+    private short[] aS;\n+    private short[] bS;\n+    private short[] rS;\n+\n+    private char[] aC;\n+    private char[] bC;\n+    private char[] rC;\n+\n+    private int[] aI;\n+    private int[] bI;\n+    private int[] rI;\n+\n+    private long[] aL;\n+    private long[] bL;\n+    private long[] rL;\n+\n+    private float[] aF;\n+    private float[] bF;\n+    private float[] rF;\n+\n+    private double[] aD;\n+    private double[] bD;\n+    private double[] rD;\n+\n+    @Param({\"1024\"})\n+    \/\/ Number of times we run the loop, possibly with different offsets.\n+    public static int REPETITIONS;\n+\n+    @Param({\"true\", \"false\"})\n+    public static boolean RANDOMIZE_OFFSETS;\n+\n+    @Param({\"0\"})\n+    \/\/ If RANDOMIZE_OFFSETS is disabled, use this offset:\n+    public static int FIXED_OFFSET;\n+\n+    \/\/ A different offset for each repetition of the loop. Depending on\n+    \/\/ RANDOMIZE_OFFSETS, the values are random or all FIXED_OFFSET.\n+    private int[] offsets;\n+\n+    @Param(\"42\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        aI = new int[CONTAINER_SIZE];\n+        bI = new int[CONTAINER_SIZE];\n+        rI = new int[CONTAINER_SIZE];\n+\n+        aL = new long[CONTAINER_SIZE];\n+        bL = new long[CONTAINER_SIZE];\n+        rL = new long[CONTAINER_SIZE];\n+\n+        aS = new short[CONTAINER_SIZE];\n+        bS = new short[CONTAINER_SIZE];\n+        rS = new short[CONTAINER_SIZE];\n+\n+        aC = new char[CONTAINER_SIZE];\n+        bC = new char[CONTAINER_SIZE];\n+        rC = new char[CONTAINER_SIZE];\n+\n+        aB = new byte[CONTAINER_SIZE];\n+        bB = new byte[CONTAINER_SIZE];\n+        rB = new byte[CONTAINER_SIZE];\n+\n+        aF = new float[CONTAINER_SIZE];\n+        bF = new float[CONTAINER_SIZE];\n+        rF = new float[CONTAINER_SIZE];\n+\n+        aD = new double[CONTAINER_SIZE];\n+        bD = new double[CONTAINER_SIZE];\n+        rD = new double[CONTAINER_SIZE];\n+\n+        for (int i = 0; i < CONTAINER_SIZE; i++) {\n+            aB[i] = (byte) r.nextInt();\n+            bB[i] = (byte) r.nextInt();\n+\n+            aS[i] = (short) r.nextInt();\n+            bS[i] = (short) r.nextInt();\n+\n+            aC[i] = (char) r.nextInt();\n+            bC[i] = (char) r.nextInt();\n+\n+            aI[i] = r.nextInt();\n+            bI[i] = r.nextInt();\n+\n+            aL[i] = r.nextLong();\n+            bL[i] = r.nextLong();\n+\n+            aF[i] = r.nextFloat();\n+            bF[i] = r.nextFloat();\n+\n+            aD[i] = r.nextDouble();\n+            bD[i] = r.nextDouble();\n+        }\n+\n+        offsets = new int[REPETITIONS];\n+        if (RANDOMIZE_OFFSETS) {\n+            for (int i = 0; i < REPETITIONS; i++) {\n+                \/\/ Make sure it is predictable and uniform.\n+                offsets[i] = i % 64;\n+            }\n+        } else {\n+            for (int i = 0; i < REPETITIONS; i++) {\n+                offsets[i] = FIXED_OFFSET;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench001B_aligned_computeBound() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int init = offsets[r];\n+            int limit = init + ITERATION_COUNT;\n+            for (int i = init; i < limit; i++) {\n+                \/\/ Have multiple MUL operations to make loop compute bound (more compute than load\/store)\n+                rB[i] = (byte)(aB[i] * aB[i] * aB[i] * aB[i]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench011B_aligned_memoryBound() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int init = offsets[r];\n+            int limit = init + ITERATION_COUNT;\n+            for (int i = init; i < limit; i++) {\n+                rB[i] = (byte)(aB[i] + bB[i]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench021B_unaligned_memoryBound() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int init = offsets[r];\n+            int limit = init + ITERATION_COUNT;\n+            for (int i = init; i < limit; i++) {\n+                rB[i] = (byte)(aB[i+1] + bB[i+2]);\n+            }\n+        }\n+    }\n+\n+\/\/    @Benchmark\n+\/\/    public void bench002S_aligned_computeBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                \/\/ Have multiple MUL operations to make loop compute bound (more compute than load\/store)\n+\/\/                rS[i] = (short)(aS[i] * aS[i] * aS[i] * aS[i]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench012S_aligned_memoryBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                rS[i] = (short)(aS[i] + bS[i]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench022S_unaligned_memoryBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                rS[i] = (short)(aS[i+1] + bS[i+2]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench003C_aligned_computeBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                \/\/ Have multiple MUL operations to make loop compute bound (more compute than load\/store)\n+\/\/                rC[i] = (char)(aC[i] * aC[i] * aC[i] * aC[i]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench013C_aligned_memoryBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                rC[i] = (char)(aC[i] + bC[i]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench023C_unaligned_memoryBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                rC[i] = (char)(aC[i+1] + bC[i+2]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\n+    @Benchmark\n+    public void bench004I_aligned_computeBound() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int init = offsets[r];\n+            int limit = init + ITERATION_COUNT;\n+            for (int i = init; i < limit; i++) {\n+                \/\/ Have multiple MUL operations to make loop compute bound (more compute than load\/store)\n+                rI[i] = (int)(aI[i] * aI[i] * aI[i] * aI[i]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench014I_aligned_memoryBound() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int init = offsets[r];\n+            int limit = init + ITERATION_COUNT;\n+            for (int i = init; i < limit; i++) {\n+                rI[i] = (int)(aI[i] + bI[i]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench024I_unaligned_memoryBound() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int init = offsets[r];\n+            int limit = init + ITERATION_COUNT;\n+            for (int i = init; i < limit; i++) {\n+                rI[i] = (int)(aI[i+1] + bI[i+2]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench005L_aligned_computeBound() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int init = offsets[r];\n+            int limit = init + ITERATION_COUNT;\n+            for (int i = init; i < limit; i++) {\n+                \/\/ Have multiple MUL operations to make loop compute bound (more compute than load\/store)\n+                rL[i] = (long)(aL[i] * aL[i] * aL[i] * aL[i]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench015L_aligned_memoryBound() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int init = offsets[r];\n+            int limit = init + ITERATION_COUNT;\n+            for (int i = init; i < limit; i++) {\n+                rL[i] = (long)(aL[i] + bL[i]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void bench025L_unaligned_memoryBound() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int init = offsets[r];\n+            int limit = init + ITERATION_COUNT;\n+            for (int i = init; i < limit; i++) {\n+                rL[i] = (long)(aL[i+1] + bL[i+2]);\n+            }\n+        }\n+    }\n+\n+\/\/    @Benchmark\n+\/\/    public void bench006F_aligned_computeBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                \/\/ Have multiple MUL operations to make loop compute bound (more compute than load\/store)\n+\/\/                rF[i] = (float)(aF[i] * aF[i] * aF[i] * aF[i]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench016F_aligned_memoryBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                rF[i] = (float)(aF[i] + bF[i]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench026F_unaligned_memoryBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                rF[i] = (float)(aF[i+1] + bF[i+2]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench007D_aligned_computeBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                \/\/ Have multiple MUL operations to make loop compute bound (more compute than load\/store)\n+\/\/                rD[i] = (double)(aD[i] * aD[i] * aD[i] * aD[i]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench017D_aligned_memoryBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                rD[i] = (double)(aD[i] + bD[i]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\/\/\n+\/\/    @Benchmark\n+\/\/    public void bench027D_unaligned_memoryBound() {\n+\/\/        for (int r = 0; r < REPETITIONS; r++) {\n+\/\/            int init = offsets[r];\n+\/\/            int limit = init + ITERATION_COUNT;\n+\/\/            for (int i = init; i < limit; i++) {\n+\/\/                rD[i] = (double)(aD[i+1] + bD[i+2]);\n+\/\/            }\n+\/\/        }\n+\/\/    }\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\"\n+    })\n+    public static class SuperWord extends VectorThroughputForIterationCount {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorThroughputForIterationCount.java","additions":436,"deletions":0,"binary":false,"changes":436,"status":"added"}]}