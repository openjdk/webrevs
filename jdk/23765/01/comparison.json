{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.NoInitSegmentAllocator;\n@@ -723,2 +724,2 @@\n-        return this instanceof ArenaImpl arenaImpl ?\n-                arenaImpl.allocateNoInit(byteSize, 1) :\n+        return this instanceof NoInitSegmentAllocator noInit ?\n+                noInit.allocateNoInit(byteSize, 1) :\n@@ -730,2 +731,2 @@\n-        return this instanceof ArenaImpl arenaImpl ?\n-                arenaImpl.allocateNoInit(layout.byteSize(), layout.byteAlignment()) :\n+        return this instanceof NoInitSegmentAllocator noInit ?\n+                noInit.allocateNoInit(layout.byteSize(), layout.byteAlignment()) :\n@@ -737,2 +738,2 @@\n-        return this instanceof ArenaImpl arenaImpl ?\n-                arenaImpl.allocateNoInit(layout.byteSize() * size, layout.byteAlignment()) :\n+        return this instanceof NoInitSegmentAllocator noInit ?\n+                noInit.allocateNoInit(layout.byteSize() * size, layout.byteAlignment()) :\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+\n@@ -31,1 +33,1 @@\n-public final class ArenaImpl implements Arena {\n+public final class ArenaImpl implements Arena, NoInitSegmentAllocator {\n@@ -50,0 +52,2 @@\n+    @ForceInline\n+    @Override\n@@ -55,0 +59,1 @@\n+    @ForceInline\n@@ -57,3 +62,1 @@\n-        NativeMemorySegmentImpl segment = allocateNoInit(byteSize, byteAlignment);\n-        segment.fill((byte)0);\n-        return segment;\n+        return NoInitSegmentAllocator.super.allocate(byteSize, byteAlignment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.invoke.MhUtil;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+\/**\n+ * An internal utility class that can be used to adapt system-call-styled method handles\n+ * for efficient and easy use.\n+ *\/\n+public final class CaptureStateUtil {\n+\n+    private static final StructLayout CAPTURE_LAYOUT = Linker.Option.captureStateLayout();\n+    private static final CarrierLocalArenaPools POOL = CarrierLocalArenaPools.create(CAPTURE_LAYOUT);\n+\n+    \/\/ The `BASIC_HANDLE_CACHE` contains the common \"basic handles\" that can be reused for\n+    \/\/ all adapted method handles. Keeping as much as possible reusable reduces the number\n+    \/\/ of combinators needed to form an adapted method handle.\n+    \/\/ The map is lazily computed.\n+    \/\/\n+    private static final Map<BasicKey, MethodHandle> BASIC_HANDLE_CACHE =\n+            new ConcurrentHashMap<>();\n+\n+    \/\/ A key that holds both the `returnType` and the `stateName` needed to look up a\n+    \/\/ specific \"basic handle\" in the `BASIC_HANDLE_CACHE`.\n+    \/\/   returnType in {int.class | long.class}\n+    \/\/   stateName can be anything non-null but should be in {\"GetLastError\" | \"WSAGetLastError\"} | \"errno\")}\n+    private record BasicKey(Class<?> returnType, String stateName) {\n+\n+        BasicKey(MethodHandle target, String stateName) {\n+            this(returnType(target), Objects.requireNonNull(stateName));\n+        }\n+\n+        static Class<?> returnType(MethodHandle target) {\n+            \/\/ Implicit null check\n+            final Class<?> returnType = target.type().returnType();\n+\n+            if (!(returnType.equals(int.class) || returnType.equals(long.class))) {\n+                throw illegalArgDoesNot(target, \"return an int or a long\");\n+            }\n+            if (target.type().parameterCount() == 0 || target.type().parameterType(0) != MemorySegment.class) {\n+                throw illegalArgDoesNot(target, \"have a MemorySegment as the first parameter\");\n+            }\n+            return returnType;\n+        }\n+\n+        private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n+            return new IllegalArgumentException(\"The provided target \" + target\n+                    + \" does not \" + info);\n+        }\n+\n+    }\n+\n+    private CaptureStateUtil() {}\n+\n+    \/**\n+     * {@return a new MethodHandle that adapts the provided {@code target} so that it\n+     * directly returns the same value as the {@code target} if it is non-negative,\n+     * otherwise returns the negated captured state defined by the provided\n+     * {@code stateName}}\n+     * <p>\n+     * This method is suitable for adapting system-call method handles(e.g.\n+     * {@code open()}, {@code read()}, and {@code close()}). Clients can check the return\n+     * value as shown in this example:\n+     * {@snippet lang = java:\n+     *       \/\/ (MemorySegment capture, MemorySegment pathname, int flags)int\n+     *       static final MethodHandle CAPTURING_OPEN = ...\n+     *\n+     *      \/\/ (MemorySegment pathname, int flags)int\n+     *      static final MethodHandle OPEN = CaptureStateUtil\n+     *             .adaptSystemCall(CAPTURING_OPEN, \"errno\");\n+     *\n+     *      try {\n+     *         int fh = (int)OPEN.invokeExact(pathName, flags);\n+     *         if (fh < 0) {\n+     *             throw new IOException(\"Error opening file: errno = \" + (-fh));\n+     *         }\n+     *         processFile(fh);\n+     *      } catch (Throwable t) {\n+     *           throw new RuntimeException(t);\n+     *      }\n+     *\n+     *}\n+     *\n+     * For a {@code target} method handle that takes a {@code MemorySegment} and two\n+     * {@code int} parameters and returns an {@code int} value, the method returns a new\n+     * method handle that is doing the equivalent of:\n+     * <p>\n+     * {@snippet lang = java:\n+     *         private static final MemoryLayout CAPTURE_LAYOUT =\n+     *                 Linker.Option.captureStateLayout();\n+     *         private static final CarrierLocalArenaPools POOL =\n+     *                 CarrierLocalArenaPools.create(CAPTURE_LAYOUT);\n+     *\n+     *         public int invoke(MethodHandle target,\n+     *                           String stateName,\n+     *                           int a, int b) {\n+     *             try (var arena = POOL.take()) {\n+     *                 final MemorySegment segment = arena.allocate(CAPTURE_LAYOUT);\n+     *                 final int result = (int) handle.invoke(segment, a, b);\n+     *                 if (result >= 0) {\n+     *                     return result;\n+     *                 }\n+     *                 return -(int) CAPTURE_LAYOUT\n+     *                     .varHandle(MemoryLayout.PathElement.groupElement(stateName))\n+     *                         .get(segment, 0);\n+     *             }\n+     *         }\n+     *}\n+     * except it is more performant. In the above {@code stateName} is the name of the\n+     * captured state (e.g. {@code errno}). The static {@code CAPTURE_LAYOUT} is shared\n+     * across all target method handles adapted by this method.\n+     *\n+     * @param target    method handle that returns an {@code int} or a {@code long} and\n+     *                  has a capturing state MemorySegment as its first parameter\n+     * @param stateName the name of the capturing state member layout (i.e. \"errno\",\n+     *                  \"GetLastError\", or \"WSAGetLastError\")\n+     * @throws IllegalArgumentException if the provided {@code target}'s return type is\n+     *                                  not {@code int} or {@code long}\n+     * @throws IllegalArgumentException if the provided {@code target}'s first parameter\n+     *                                  type is not {@linkplain MemorySegment}\n+     * @throws IllegalArgumentException if the provided {@code stateName} is unknown on\n+     *                                  the current platform\n+     *\/\n+    public static MethodHandle adaptSystemCall(MethodHandle target,\n+                                               String stateName) {\n+        \/\/ Invariants checked in the BasicKey record\n+        final BasicKey basicKey = new BasicKey(target, stateName);\n+\n+        \/\/ ((int | long), MemorySegment)(int | long)\n+        final MethodHandle basicHandle = BASIC_HANDLE_CACHE\n+                \/\/ Do not use a lambda in order to allow early use in the init sequence\n+                \/\/ This is equivalent to:\n+                \/\/   computeIfAbsent(basicKey, CaptureStateUtil::basicHandleFor);\n+                .computeIfAbsent(basicKey, new Function<>() {\n+                    @Override\n+                    public MethodHandle apply(BasicKey basicKey) {\n+                        return basicHandleFor(basicKey);\n+                    }\n+                });\n+\n+        \/\/ Make `target` specific adaptations of the basic handle\n+\n+        \/\/ Pre-pend all the parameters from the `target` MH.\n+        \/\/ (C0=MemorySegment, C1-Cn, MemorySegment)(int|long)\n+        MethodHandle innerAdapted = MethodHandles.collectArguments(basicHandle, 0, target);\n+\n+        final int[] perm = new int[target.type().parameterCount() + 1];\n+        for (int i = 0; i < target.type().parameterCount(); i++) {\n+            perm[i] = i;\n+        }\n+        \/\/ Last takes first\n+        perm[target.type().parameterCount()] = 0;\n+        \/\/ Deduplicate the first and last coordinate and only use the first one.\n+        \/\/ (C0=MemorySegment, C1-Cn)(int|long)\n+        innerAdapted = MethodHandles.permuteArguments(innerAdapted, target.type(), perm);\n+\n+        \/\/ Use an `Arena` for the first argument instead and extract a segment from it.\n+        \/\/ (C0=Arena, C1-Cn)(int|long)\n+        innerAdapted = MethodHandles.collectArguments(innerAdapted, 0, handleFor(ALLOCATE));\n+\n+        \/\/ Add an identity function for the result of the cleanup action.\n+        \/\/ ((int|long))(int|long)\n+        MethodHandle cleanup = MethodHandles.identity(basicKey.returnType());\n+        \/\/ Add a dummy `Throwable` argument for the cleanup action.\n+        \/\/ This means, anything thrown will just be propagated.\n+        \/\/ (Throwable, (int|long))(int|long)\n+        cleanup = MethodHandles.dropArguments(cleanup, 0, Throwable.class);\n+        \/\/ Add the first `Arena` parameter of the `innerAdapted` method handle to the\n+        \/\/ cleanup action and invoke `Arena::close` when it is run. The `cleanup` handle\n+        \/\/ does not have to have all parameters. It can have zero or more.\n+        \/\/ (Throwable, (int|long), Arena)(int|long)\n+        cleanup = MethodHandles.collectArguments(cleanup, 2, handleFor(ARENA_CLOSE));\n+\n+        \/\/ Combine the `innerAdapted` and `cleanup` action into a try\/finally block.\n+        \/\/ (Arena, C1-Cn)(int|long)\n+        final MethodHandle tryFinally = MethodHandles.tryFinally(innerAdapted, cleanup);\n+\n+        \/\/ Acquire the arena from the global pool.\n+        \/\/ With this, we finally arrive at the intended method handle:\n+        \/\/ (C1-Cn)(int|long)\n+        return MethodHandles.collectArguments(tryFinally, 0, handleFor(ACQUIRE_ARENA));\n+    }\n+\n+    private static MethodHandle basicHandleFor(BasicKey basicKey) {\n+        final VarHandle vh = CAPTURE_LAYOUT.varHandle(\n+                MemoryLayout.PathElement.groupElement(basicKey.stateName()));\n+        \/\/ This MH is used to extract the named captured state\n+        \/\/ from the capturing `MemorySegment`.\n+        \/\/ (MemorySegment, long)int\n+        MethodHandle intExtractor = vh.toMethodHandle(VarHandle.AccessMode.GET);\n+        \/\/ As the MH is already adapted to use the appropriate\n+        \/\/ offset, we just insert `0L` for the offset.\n+        \/\/ (MemorySegment)int\n+        intExtractor = MethodHandles.insertArguments(intExtractor, 1, 0L);\n+\n+        \/\/ If X is the `returnType` (either `int` or `long`) then\n+        \/\/ the code below is equivalent to:\n+        \/\/\n+        \/\/ X handle(X returnValue, MemorySegment segment)\n+        \/\/     if (returnValue >= 0) {\n+        \/\/         \/\/ Ignore the segment\n+        \/\/         return returnValue;\n+        \/\/     } else {\n+        \/\/         \/\/ ignore the returnValue\n+        \/\/         return -(X)intExtractor.invokeExact(segment);\n+        \/\/     }\n+        \/\/ }\n+        if (basicKey.returnType().equals(int.class)) {\n+            \/\/ (int, MemorySegment)int\n+            return MethodHandles.guardWithTest(\n+                    handleFor(NON_NEGATIVE_INT),\n+                    handleFor(SUCCESS_INT),\n+                    handleFor(ERROR_INT).bindTo(intExtractor));\n+        } else {\n+            \/\/ (long, MemorySegment)long\n+            return MethodHandles.guardWithTest(\n+                    handleFor(NON_NEGATIVE_LONG),\n+                    handleFor(SUCCESS_LONG),\n+                    handleFor(ERROR_LONG).bindTo(intExtractor));\n+        }\n+    }\n+\n+    \/\/ The methods below are reflective used via static MethodHandles\n+\n+    @ForceInline\n+    private static Arena acquireArena() {\n+        return POOL.take();\n+    }\n+\n+    @ForceInline\n+    private static MemorySegment allocate(Arena arena) {\n+        \/\/ We do not need to zero out the segment.\n+        return ((NoInitSegmentAllocator) arena)\n+                .allocateNoInit(CAPTURE_LAYOUT.byteSize(), CAPTURE_LAYOUT.byteAlignment());\n+    }\n+\n+    @ForceInline\n+    private static boolean nonNegative(int value) {\n+        return value >= 0;\n+    }\n+\n+    @ForceInline\n+    private static int success(int value,\n+                               MemorySegment segment) {\n+        return value;\n+    }\n+\n+    @ForceInline\n+    private static int error(MethodHandle errorHandle,\n+                             int value,\n+                             MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+    @ForceInline\n+    private static boolean nonNegative(long value) {\n+        return value >= 0L;\n+    }\n+\n+    @ForceInline\n+    private static long success(long value,\n+                                MemorySegment segment) {\n+        return value;\n+    }\n+\n+    @ForceInline\n+    private static long error(MethodHandle errorHandle,\n+                              long value,\n+                              MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+    \/\/ The method handles below are bound to static methods residing in this class\n+\n+    \/\/ Todo: Replace the cache below with a stable value Map\n+\n+    private static final int\n+            NON_NEGATIVE_INT  = 0,\n+            SUCCESS_INT       = 1,\n+            ERROR_INT         = 2,\n+            NON_NEGATIVE_LONG = 3,\n+            SUCCESS_LONG      = 4,\n+            ERROR_LONG        = 5,\n+            ACQUIRE_ARENA     = 6,\n+            ALLOCATE          = 7,\n+            ARENA_CLOSE       = 8;\n+\n+    private static final @Stable MethodHandle[] HANDLES = new MethodHandle[ARENA_CLOSE + 1];\n+\n+    private static MethodHandle handleFor(int index) {\n+        MethodHandle handle = HANDLES[index];\n+        if (handle == null) {\n+            synchronized (HANDLES) {\n+                handle = HANDLES[index];\n+                if (handle == null) {\n+                    HANDLES[index] = (handle = makeHandle(index));\n+                }\n+            }\n+        }\n+        return handle;\n+    }\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    private static MethodHandle makeHandle(int index) {\n+        switch (index) {\n+            case NON_NEGATIVE_INT:\n+                return MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                        MethodType.methodType(boolean.class, int.class));\n+            case SUCCESS_INT:\n+                return MhUtil.findStatic(LOOKUP, \"success\",\n+                        MethodType.methodType(int.class, int.class, MemorySegment.class));\n+            case ERROR_INT:\n+                return MhUtil.findStatic(LOOKUP, \"error\",\n+                        MethodType.methodType(int.class, MethodHandle.class, int.class, MemorySegment.class));\n+            case NON_NEGATIVE_LONG:\n+                return MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                        MethodType.methodType(boolean.class, long.class));\n+            case SUCCESS_LONG:\n+                return MhUtil.findStatic(LOOKUP, \"success\",\n+                        MethodType.methodType(long.class, long.class, MemorySegment.class));\n+            case ERROR_LONG:\n+                return MhUtil.findStatic(LOOKUP, \"error\",\n+                        MethodType.methodType(long.class, MethodHandle.class, long.class, MemorySegment.class));\n+            case ACQUIRE_ARENA:\n+                return MhUtil.findStatic(LOOKUP, \"acquireArena\",\n+                        MethodType.methodType(Arena.class));\n+            case ALLOCATE:\n+                return MhUtil.findStatic(LOOKUP, \"allocate\",\n+                        MethodType.methodType(MemorySegment.class, Arena.class));\n+            case ARENA_CLOSE:\n+                return MhUtil.findVirtual(LOOKUP, Arena.class, \"close\",\n+                        MethodType.methodType(void.class));\n+        }\n+        throw new InternalError(\"Unknown index: \" + index);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"},{"patch":"@@ -0,0 +1,371 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.CarrierThread;\n+import jdk.internal.misc.TerminatingThreadLocal;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.ref.Reference;\n+import java.util.Objects;\n+\n+public final class CarrierLocalArenaPools {\n+\n+    @Stable\n+    private final TerminatingThreadLocal<LocalArenaPoolImpl> tl;\n+\n+    private CarrierLocalArenaPools(long byteSize, long byteAlignment) {\n+        this.tl = new TerminatingThreadLocal<>() {\n+\n+            private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+            \/\/ This method can be invoked by either a virtual thread, a platform thread\n+            \/\/ , or a carrier thread (e.g. ForkJoinPool-1-worker-1).\n+            @Override\n+            protected LocalArenaPoolImpl initialValue() {\n+                if (JLA.currentCarrierThread() instanceof CarrierThread) {\n+                    \/\/ Only a carrier thread that is an instance of `CarrierThread` can\n+                    \/\/ ever carry virtual threads. (Notably, a `CarrierThread` can also\n+                    \/\/ carry a platform thread.) This means a `CarrierThread` can carry\n+                    \/\/ any number of virtual threads, and they can be mounted\/unmounted\n+                    \/\/ from the carrier thread at almost any time. Therefore, we must use\n+                    \/\/ stronger-than-plain semantics when dealing with mutual exclusion\n+                    \/\/ of thread local resources.\n+                    return new LocalArenaPoolImpl.OfCarrier(Arena.ofAuto(), byteSize, byteAlignment);\n+                } else {\n+                    \/\/ A carrier thread that is not an instance of `CarrierThread` can\n+                    \/\/ never carry a virtual thread. Because of this, only one thread will\n+                    \/\/ be mounted on such a carrier thread. Therefore, we can use plain\n+                    \/\/ memory semantics when dealing with mutual exclusion of thread local\n+                    \/\/ resources.\n+                    return new LocalArenaPoolImpl.OfPlatform(Arena.ofConfined(), byteSize, byteAlignment);\n+                }\n+            }\n+\n+            \/\/ This method is never invoked by a virtual thread but can be invoked by\n+            \/\/ a platform thread or a carrier thread (e.g. ForkJoinPool-1-worker-1).\n+            \/\/ Note: the fork join pool can expand\/contract dynamically\n+            \/\/ We do not use the method here as we are using an automatic arena.\n+            @Override\n+            protected void threadTerminated(LocalArenaPoolImpl pool) {\n+                pool.close();\n+            }\n+        };\n+    }\n+\n+    @ForceInline\n+    public Arena take() {\n+        return tl.get()\n+                .take();\n+    }\n+\n+    private static sealed abstract class LocalArenaPoolImpl {\n+\n+        \/\/ Hold a reference so that the arena is not GC:ed before the thread dies.\n+        @Stable\n+        final Arena originalArena;\n+        @Stable\n+        final MemorySegment recyclableSegment;\n+\n+        long sp;\n+\n+        private LocalArenaPoolImpl(Arena originalArena,\n+                                   long byteSize,\n+                                   long byteAlignment) {\n+            this.originalArena = originalArena;\n+            this.recyclableSegment = originalArena.allocate(byteSize, byteAlignment);\n+        }\n+\n+        abstract Arena take();\n+\n+        void close() {\n+            \/\/ Do not close an automatic arena\n+            if (((MemorySessionImpl) originalArena).isCloseable()) {\n+                originalArena.close();\n+            }\n+        }\n+\n+        abstract void arenaClosed();\n+\n+        \/**\n+         * Thread safe implementation.\n+         *\/\n+        private static final class OfCarrier\n+                extends LocalArenaPoolImpl {\n+\n+            static final int AVAILABLE = 0;\n+            static final int TAKEN = 1;\n+\n+            \/\/ Unsafe allows earlier use in the init sequence and\n+            \/\/ better start and warmup properties.\n+            static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+            static final long SEG_AVAIL_OFFSET =\n+                    UNSAFE.objectFieldOffset(OfCarrier.class, \"segmentAvailability\");\n+\n+            \/\/ Used reflectively\n+            private int segmentAvailability;\n+\n+            private OfCarrier(Arena originalArena,\n+                             long byteSize,\n+                             long byteAlignment) {\n+                super(originalArena, byteSize, byteAlignment);\n+            }\n+\n+            \/\/ If we are on a carrier thread, we can only provide a single arena that\n+            \/\/ is using the recyclable segment. This is because a VT might be re-mounted\n+            \/\/ on another carrier thread at any time. Keeping track of the open\/closed\n+            \/\/ arenas in such situation is slow.\n+            @ForceInline\n+            @Override\n+            public Arena take() {\n+                final Arena delegate = Arena.ofConfined();\n+                return tryAcquireSegment()\n+                        ? new CarrierSlicingArena(originalArena, (ArenaImpl) delegate, recyclableSegment)\n+                        : delegate;\n+            }\n+\n+            \/**\n+             * {@return {@code true } if the segment was acquired for exclusive use, {@code\n+             * false} otherwise}\n+             *\/\n+            @ForceInline\n+            boolean tryAcquireSegment() {\n+                return UNSAFE.compareAndSetInt(this, SEG_AVAIL_OFFSET, AVAILABLE, TAKEN);\n+            }\n+\n+            \/**\n+             * Unconditionally releases the acquired segment if it was previously acquired,\n+             * otherwise this is a no-op.\n+             *\/\n+            @ForceInline\n+            void arenaClosed() {\n+                UNSAFE.putIntVolatile(this, SEG_AVAIL_OFFSET, AVAILABLE);\n+            }\n+        }\n+\n+        \/**\n+         * No need for thread-safe implementation here as a platform thread is exclusively\n+         * mounted on a particular carrier thread.\n+         *\/\n+        private static final class OfPlatform\n+                extends LocalArenaPoolImpl {\n+\n+            private int openArenas;\n+\n+            private OfPlatform(Arena originalArena,\n+                              long byteSize,\n+                              long byteAlignment) {\n+                super(originalArena, byteSize, byteAlignment);\n+            }\n+\n+            \/\/ If we are on a non-carrier thread, several arenas can share the same\n+            \/\/ recyclable segment as the current thread will never move.\n+            @ForceInline\n+            public Arena take() {\n+                final Arena delegate = Arena.ofConfined();\n+                openArenas++;\n+                return new SlicingArena(originalArena, (ArenaImpl) delegate, recyclableSegment);\n+            }\n+\n+            @ForceInline\n+            @Override\n+            void arenaClosed() {\n+                if (--openArenas == 0) {\n+                    sp = 0;\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * A SlicingArena is similar to a {@linkplain SlicingAllocator} but if the backing\n+         * segment cannot be used for allocation, a fall-back arena is used instead. This\n+         * means allocation never fails due to the size and alignment of the backing\n+         * segment.\n+         *\/\n+        private sealed class SlicingArena implements Arena, NoInitSegmentAllocator {\n+\n+            \/\/ In order to prevent use-after-free issues, we make sure the original arena\n+            \/\/ is reachable until the dying moments of a carrier thread AND remains\n+            \/\/ reachable whenever a carved out segment can be reached. The reason for\n+            \/\/ this is reinterpreted segments carved out from the original arena can be\n+            \/\/ used independently of the original arena but are freed when the\n+            \/\/ original arena is collected.\n+            \/\/\n+            \/\/ To solve this, we also hold a reference to the original arena from which we\n+            \/\/ carved out the `segment`. This covers the case when a VT was remounted on\n+            \/\/ another CarrierThread and the original CarrierThread\n+            \/\/ died and therefore the original arena was not referenced anymore.\n+            @Stable\n+            private final Arena originalArena;\n+            @Stable\n+            private final ArenaImpl delegate;\n+            @Stable\n+            private final MemorySegment segment;\n+\n+            @ForceInline\n+            private SlicingArena(Arena originalArena,\n+                                 ArenaImpl delegate,\n+                                 MemorySegment segment) {\n+                this.originalArena = originalArena;\n+                this.delegate = delegate;\n+                this.segment = segment;\n+            }\n+\n+            @ForceInline\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return delegate.scope();\n+            }\n+\n+            @ForceInline\n+            @Override\n+            public NativeMemorySegmentImpl allocate(long byteSize, long byteAlignment) {\n+                return NoInitSegmentAllocator.super.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @SuppressWarnings(\"restricted\")\n+            @ForceInline\n+            public NativeMemorySegmentImpl allocateNoInit(long byteSize, long byteAlignment) {\n+                final long min = segment.address();\n+                final long start = Utils.alignUp(min + sp(), byteAlignment) - min;\n+                if (start + byteSize <= segment.byteSize()) {\n+                    Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+                    final MemorySegment slice = segment.asSlice(start, byteSize, byteAlignment);\n+\n+                    \/\/ We only need to do this once for VTs\n+                    if (sp() == 0 && !(scope() instanceof ConfinedSession)) {\n+                        \/\/ This prevents the automatic original arena from being collected before\n+                        \/\/ the SlicingArena is closed. This case might otherwise happen if a reference\n+                        \/\/ is held to a reusable segment and its arena is not closed.\n+                        ((MemorySessionImpl) scope())\n+                                .addCloseAction(new ReferenceHolder(originalArena));\n+                    }\n+                    sp(start + byteSize);\n+                    return fastReinterpret(delegate, (NativeMemorySegmentImpl) slice, byteSize);\n+                } else {\n+                    return delegate.allocateNoInit(byteSize, byteAlignment);\n+                }\n+            }\n+\n+            @ForceInline\n+            @Override\n+            public void close() {\n+                delegate.close();\n+                \/\/ Intentionally do not releaseSegment() in a finally clause as\n+                \/\/ the segment still is in play if close() initially fails (e.g. is closed\n+                \/\/ from a non-owner thread). Later on the close() method might be\n+                \/\/ successfully re-invoked (e.g. from its owner thread).\n+                LocalArenaPoolImpl.this.arenaClosed();\n+            }\n+\n+            @ForceInline\n+            long sp() {\n+                return LocalArenaPoolImpl.this.sp;\n+            }\n+\n+            @ForceInline\n+            void sp(long sp) {\n+                LocalArenaPoolImpl.this.sp = sp;\n+            }\n+\n+        }\n+\n+        private final class CarrierSlicingArena extends SlicingArena {\n+\n+            \/\/ Use a local stack pointer here as this state cannot be held in\n+            \/\/ a carrier thread local (a VT may be remounted at any time).\n+            private long sp;\n+\n+            @ForceInline\n+            private CarrierSlicingArena(Arena originalArena,\n+                                        ArenaImpl delegate,\n+                                        MemorySegment segment) {\n+                super(originalArena, delegate, segment);\n+            }\n+\n+            @ForceInline\n+            @Override\n+            long sp() {\n+                return this.sp;\n+            }\n+\n+            @ForceInline\n+            @Override\n+            void sp(long sp) {\n+                this.sp = sp;\n+            }\n+        }\n+\n+    }\n+\n+    private record ReferenceHolder(Object ref) implements Runnable {\n+        @Override public void run() { Reference.reachabilityFence(ref);}\n+    }\n+\n+    \/\/ Equivalent to but faster than:\n+    \/\/     return (NativeMemorySegmentImpl) slice\n+    \/\/             .reinterpret(byteSize, delegate, null); *\/\n+    @ForceInline\n+    static NativeMemorySegmentImpl fastReinterpret(ArenaImpl arena,\n+                                                   NativeMemorySegmentImpl segment,\n+                                                   long byteSize) {\n+        \/\/ We already know the segment:\n+        \/\/  * is native\n+        \/\/  * we have native access\n+        \/\/  * there is no cleanup action\n+        \/\/  * the segment is read\/write\n+        return SegmentFactories.makeNativeSegmentUnchecked(segment.address(), byteSize,\n+                MemorySessionImpl.toMemorySession(arena), false, null);\n+    }\n+\n+    \/\/ Factories\n+\n+    public static CarrierLocalArenaPools create(long byteSize) {\n+        if (byteSize < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return new CarrierLocalArenaPools(byteSize, 1L);\n+    }\n+\n+    public static CarrierLocalArenaPools create(long byteSize,\n+                                                long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return new CarrierLocalArenaPools(byteSize, byteAlignment);\n+    }\n+\n+    public static CarrierLocalArenaPools create(MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return new CarrierLocalArenaPools(layout.byteSize(), layout.byteAlignment());\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CarrierLocalArenaPools.java","additions":371,"deletions":0,"binary":false,"changes":371,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.SegmentAllocator;\n+\n+public interface NoInitSegmentAllocator extends SegmentAllocator {\n+\n+    NativeMemorySegmentImpl allocateNoInit(long byteSize, long byteAlignment);\n+\n+    @ForceInline\n+    @Override\n+    default NativeMemorySegmentImpl allocate(long byteSize, long byteAlignment) {\n+        NativeMemorySegmentImpl segment = allocateNoInit(byteSize, byteAlignment);\n+        segment.fill((byte)0);\n+        return segment;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NoInitSegmentAllocator.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,10 @@\n+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,\n+                                           String name,\n+                                           MethodType type) {\n+        try {\n+            return lookup.findStatic(lookup.lookupClass(), name, type);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/MhUtil.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test CaptureStateUtil\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCaptureStateUtil\n+ *\/\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestCaptureStateUtil {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+            .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final MethodHandle INT_DUMMY_HANDLE;\n+    private static final MethodHandle LONG_DUMMY_HANDLE;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            INT_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+            LONG_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(long.class, MemorySegment.class, long.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static final MethodHandle ADAPTED_INT = CaptureStateUtil\n+            .adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n+    private static final MethodHandle ADAPTED_LONG = CaptureStateUtil\n+            .adaptSystemCall(LONG_DUMMY_HANDLE, ERRNO_NAME);\n+\n+    @Test\n+    void successfulInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invokeExact(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    private static final int EACCES = 13; \/* Permission denied *\/\n+\n+    @Test\n+    void errorInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invokeExact(-1, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void successfulLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invokeExact(1L, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    @Test\n+    void errorLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invokeExact(-1L, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void successfulIntPerHandle() throws Throwable {\n+        MethodHandle handle = CaptureStateUtil\n+                .adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n+        int r = (int) handle.invokeExact(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    @Test\n+    void invariants() throws Throwable {\n+        MethodHandle noSegment = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(long.class, long.class, int.class));\n+\n+        var noSegEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, ERRNO_NAME));\n+        assertTrue(noSegEx.getMessage().contains(\"does not have a MemorySegment as the first parameter\"));\n+\n+        MethodHandle noArgMH = MethodHandles.empty(MethodType.methodType(int.class));\n+        var emptyEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noArgMH, ERRNO_NAME));\n+        assertTrue(emptyEx.getMessage().contains(\"does not have a MemorySegment as the first parameter\"));\n+\n+        MethodHandle wrongReturnType = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(short.class, MemorySegment.class, long.class, int.class));\n+\n+        var wrongRetEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(wrongReturnType, ERRNO_NAME));\n+        assertTrue(wrongRetEx.getMessage().contains(\"does not return an int or a long\"));\n+\n+        var wrongCaptureName = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(LONG_DUMMY_HANDLE, \"foo\"));\n+        assertTrue(wrongCaptureName.getMessage().startsWith(\"Bad layout path: cannot resolve 'foo' in layout [\"), wrongCaptureName.getMessage());\n+\n+        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(null, ERRNO_NAME));\n+        assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, null));\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static long dummy(MemorySegment segment, long result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    private static long wrongType(long result, int errno) {\n+        return 0;\n+    }\n+\n+    private static short wrongType(MemorySegment segment, long result, int errno) {\n+        return 0;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,363 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test TestCarrierLocalArenaPools\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCarrierLocalArenaPools\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import jdk.test.lib.thread.VThreadRunner;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestCarrierLocalArenaPools {\n+\n+    private static final long POOL_SIZE = 64;\n+    private static final long SMALL_ALLOC_SIZE = 8;\n+    private static final long VERY_LARGE_ALLOC_SIZE = 1L << 10;\n+\n+    @Test\n+    void invariants1LongArg() {\n+        assertThrows(IllegalArgumentException.class, () -> CarrierLocalArenaPools.create(-1));\n+        CarrierLocalArenaPools pool = CarrierLocalArenaPools.create(0);\n+        try (var arena = pool.take()) {\n+            \/\/ This should come from the underlying arena and not from recyclable memory\n+            assertDoesNotThrow(() -> arena.allocate(1));\n+            try (var arena2 = pool.take()) {\n+                assertDoesNotThrow(() -> arena.allocate(1));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void invariants2LongArgs() {\n+        assertThrows(IllegalArgumentException.class, () -> CarrierLocalArenaPools.create(-1, 2));\n+        assertThrows(IllegalArgumentException.class, () -> CarrierLocalArenaPools.create(1, -1));\n+        assertThrows(IllegalArgumentException.class, () -> CarrierLocalArenaPools.create(1, 3));\n+        CarrierLocalArenaPools pool = CarrierLocalArenaPools.create(0, 16);\n+        try (var arena = pool.take()) {\n+            \/\/ This should come from the underlying arena and not from recyclable memory\n+            assertDoesNotThrow(() -> arena.allocate(1));\n+            try (var arena2 = pool.take()) {\n+                assertDoesNotThrow(() -> arena.allocate(1));\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void negativeAlloc(CarrierLocalArenaPools pool) {\n+        Consumer<Arena> action = arena ->\n+                assertThrows(IllegalArgumentException.class, () -> arena.allocate(-1));\n+        doInTwoStackedArenas(pool, action, action);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void negativeAllocVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> negativeAlloc(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void allocateConfinement(CarrierLocalArenaPools pool) {\n+        Consumer<Arena> allocateAction = arena ->\n+                assertThrows(WrongThreadException.class, () -> {\n+                    CompletableFuture<Arena> future = CompletableFuture.supplyAsync(pool::take);\n+                    var otherThreadArena = future.get();\n+                    otherThreadArena.allocate(SMALL_ALLOC_SIZE);\n+                    \/\/ Intentionally do not close the otherThreadArena here.\n+                });\n+        doInTwoStackedArenas(pool, allocateAction, allocateAction);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void allocateConfinementVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> allocateConfinement(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void closeConfinement(CarrierLocalArenaPools pool) {\n+        Consumer<Arena> closeAction = arena -> {\n+            \/\/ Do not use CompletableFuture here as it might accidentally run on the\n+            \/\/ same carrier thread as a virtual thread.\n+            AtomicReference<Arena> otherThreadArena = new AtomicReference<>();\n+            var thread = Thread.ofPlatform().start(() -> {\n+                otherThreadArena.set(pool.take());\n+            });\n+            try {\n+                thread.join();\n+            } catch (InterruptedException ie) {\n+                fail(ie);\n+            }\n+            assertThrows(WrongThreadException.class, otherThreadArena.get()::close);\n+        };\n+        doInTwoStackedArenas(pool, closeAction, closeAction);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void closeConfinementVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> closeConfinement(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void reuse(CarrierLocalArenaPools pool) {\n+        MemorySegment firstSegment;\n+        MemorySegment secondSegment;\n+        try (var arena = pool.take()) {\n+            firstSegment = arena.allocate(SMALL_ALLOC_SIZE);\n+        }\n+        try (var arena = pool.take()) {\n+            secondSegment = arena.allocate(SMALL_ALLOC_SIZE);\n+        }\n+        assertNotSame(firstSegment, secondSegment);\n+        assertNotSame(firstSegment.scope(), secondSegment.scope());\n+        assertEquals(firstSegment.address(), secondSegment.address());\n+        assertThrows(IllegalStateException.class, () -> firstSegment.get(JAVA_BYTE, 0));\n+        assertThrows(IllegalStateException.class, () -> secondSegment.get(JAVA_BYTE, 0));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void reuseVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> reuse(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void largeAlloc(CarrierLocalArenaPools pool) {\n+        try (var arena = pool.take()) {\n+            var segment = arena.allocate(VERY_LARGE_ALLOC_SIZE);\n+            assertEquals(VERY_LARGE_ALLOC_SIZE, segment.byteSize());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void largeAllocSizeVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> largeAlloc(pool));\n+    }\n+\n+    @Test\n+    void allocationSameAsPoolSize() {\n+        var pool = CarrierLocalArenaPools.create(4);\n+        long firstAddress;\n+        try (var arena = pool.take()) {\n+            var segment = arena.allocate(4);\n+            firstAddress = segment.address();\n+        }\n+        try (var arena = pool.take()) {\n+            var segment = arena.allocate(4 + 1);\n+            assertNotEquals(firstAddress, segment.address());\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            try (var arena = pool.take()) {\n+                var segment = arena.allocate(4);\n+                assertEquals(firstAddress, segment.address());\n+                var segmentTwo = arena.allocate(4);\n+                assertNotEquals(firstAddress, segmentTwo.address());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void allocationCaptureStateLayout() {\n+        var layout = Linker.Option.captureStateLayout();\n+        var pool = CarrierLocalArenaPools.create(layout);\n+        long firstAddress;\n+        try (var arena = pool.take()) {\n+            var segment = arena.allocate(layout);\n+            firstAddress = segment.address();\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            try (var arena = pool.take()) {\n+                var segment = arena.allocate(layout);\n+                assertEquals(firstAddress, segment.address());\n+                var segmentTwo = arena.allocate(layout);\n+                assertNotEquals(firstAddress, segmentTwo.address());\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void outOfOrderUse(CarrierLocalArenaPools pool) {\n+        Arena firstArena = pool.take();\n+        long first = firstArena.allocate(SMALL_ALLOC_SIZE).address();\n+        Arena secondArena = pool.take();\n+        long second = firstArena.allocate(SMALL_ALLOC_SIZE).address();\n+        firstArena.close();\n+        Arena thirdArena = pool.take();\n+        long third = thirdArena.allocate(SMALL_ALLOC_SIZE).address();\n+\n+        assertInOrder(first, second, third);\n+        secondArena.close();\n+        thirdArena.close();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void outOfOrderUseVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> outOfOrderUseVtTask(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void outOfOrderUse2(CarrierLocalArenaPools pool) {\n+        Arena firstArena = pool.take();\n+        long first = firstArena.allocate(SMALL_ALLOC_SIZE).address();\n+        Arena secondArena = pool.take();\n+        long second = firstArena.allocate(SMALL_ALLOC_SIZE).address();\n+        long thirdFromFirstArena = firstArena.allocate(SMALL_ALLOC_SIZE).address();\n+\n+        assertInOrder(first, second, thirdFromFirstArena);\n+        firstArena.close();\n+        secondArena.close();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void outOfOrderUseVt2(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> outOfOrderUseVtTask(pool));\n+    }\n+\n+    void outOfOrderUseVtTask(CarrierLocalArenaPools pool) {\n+        Arena firstArena = pool.take();\n+        long first = firstArena.allocate(SMALL_ALLOC_SIZE).address();\n+        Arena secondArena = pool.take();\n+        long second = firstArena.allocate(SMALL_ALLOC_SIZE).address();\n+        firstArena.close();\n+        Arena thirdArena = pool.take();\n+        long third = thirdArena.allocate(SMALL_ALLOC_SIZE).address();\n+\n+        assertNotEquals(first, second);\n+        assertEquals(first, third);\n+        secondArena.close();\n+        thirdArena.close();\n+    }\n+\n+    void assertInOrder(long first, long... rest) {\n+        long current = first;\n+        for (long x : rest) {\n+            \/\/ Does x belong to the recycled segment?\n+            if (x >= first && x < first + POOL_SIZE) {\n+                \/\/ Is x in an area that's already handed out?\n+                if (x <= current) {\n+                    long[] deltas = Arrays.stream(rest)\n+                            .map(v -> v - first)\n+                            .toArray();\n+                    throw new AssertionError(\"The value \" + x + \" is equal or less than \" + current + \". Deltas: \" + Arrays.toString(deltas));\n+                }\n+                current = x;\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void zeroing(CarrierLocalArenaPools pool) {\n+        try (var arena = pool.take()) {\n+            var seg = arena.allocate(SMALL_ALLOC_SIZE);\n+            seg.fill((byte) 1);\n+        }\n+        try (var arena = pool.take()) {\n+            var seg = arena.allocate(SMALL_ALLOC_SIZE);\n+            for (int i = 0; i < SMALL_ALLOC_SIZE; i++) {\n+                assertEquals((byte) 0, seg.get(JAVA_BYTE, i));\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void zeroingVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> zeroing(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void useAfterFree(CarrierLocalArenaPools pool) {\n+        MemorySegment segment = null;\n+        try (var arena = pool.take()){\n+            segment = arena.allocate(SMALL_ALLOC_SIZE);\n+        }\n+        final var closedSegment = segment;\n+        var e = assertThrows(IllegalStateException.class, () -> closedSegment.get(ValueLayout.JAVA_INT, 0));\n+        assertEquals(\"Already closed\", e.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void toStringTest(CarrierLocalArenaPools pool) {\n+        assertTrue(pool.toString().contains(\"ArenaPool\"));\n+        try (var arena = pool.take()) {\n+            assertTrue(arena.toString().contains(\"SlicingArena\"));\n+        }\n+    }\n+\n+    \/\/ Factories and helper methods\n+\n+    static Stream<CarrierLocalArenaPools> pools() {\n+        return Stream.of(\n+                CarrierLocalArenaPools.create(POOL_SIZE),\n+                CarrierLocalArenaPools.create(POOL_SIZE, 16),\n+                CarrierLocalArenaPools.create(MemoryLayout.sequenceLayout(POOL_SIZE, JAVA_BYTE))\n+        );\n+    }\n+\n+    static void doInTwoStackedArenas(CarrierLocalArenaPools pool,\n+                                     Consumer<Arena> firstAction,\n+                                     Consumer<Arena> secondAction) {\n+        try (var firstArena = pool.take()) {\n+            firstAction.accept(firstArena);\n+            try (var secondArena = pool.take()) {\n+                secondAction.accept(secondArena);\n+            }\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/TestCarrierLocalArenaPools.java","additions":363,"deletions":0,"binary":false,"changes":363,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test TestCarrierLocalArenaPoolsStress\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCarrierLocalArenaPoolsStress\n+ *\/\n+\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.FileDescriptor;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+final class TestCarrierLocalArenaPoolsMovingVt {\n+\n+    private static final long POOL_SIZE = 64;\n+    private static final long SMALL_ALLOC_SIZE = 8;\n+\n+    \/**\n+     * The objective with this test is to test the case when a virtual thread VT0 is\n+     * mounted on a carrier thread CT0; VT0 is then suspended; The pool of carrier threads\n+     * are then contracted; VT0 is then remounted on another carrier thread C1. VT0 runs\n+     * for a while when there is a lot of GC activity.\n+     * In other words, we are trying to establish that there is no use-after-free and that\n+     * the original arena, from which reusable segments are initially allocated from, is\n+     * not closed underneath.\n+     *\/\n+    @Test\n+    void movingVirtualThreadWithGc() throws InterruptedException {\n+        final long begin = System.nanoTime();\n+        var pool = CarrierLocalArenaPools.create(POOL_SIZE);\n+\n+        System.setProperty(\"jdk.virtualThreadScheduler.parallelism\", \"1\");\n+\n+        var done = new AtomicBoolean();\n+        var quiescent = new Object();\n+\n+        var executor = Executors.newVirtualThreadPerTaskExecutor();\n+\n+        executor.submit(() -> {\n+            while (!done.get()) {\n+                FileDescriptor.out.sync();\n+            }\n+            return null;\n+        });\n+\n+        executor.submit(() -> {\n+            System.out.println(duration(begin) + \"ALLOCATING = \" + Thread.currentThread());\n+            try (Arena arena = pool.take()) {\n+                MemorySegment segment = arena.allocate(SMALL_ALLOC_SIZE);\n+                done.set(true);\n+                synchronized (quiescent) {\n+                    try {\n+                        quiescent.wait();\n+                    } catch (Throwable ex) {\n+                        throw new AssertionError(ex);\n+                    }\n+                }\n+                System.out.println(duration(begin) + \"ACCESSING SEGMENT\");\n+\n+                for (int i = 0; i < 100_000; i++) {\n+                    if (i % 100 == 0) {\n+                        System.gc();\n+                    }\n+                    segment.get(ValueLayout.JAVA_BYTE, i);\n+                }\n+                System.out.println(duration(begin) + \"DONE ACCESSING SEGMENT\");\n+            }\n+            System.out.println(duration(begin) + \"VT DONE\");\n+        });\n+\n+        long count;\n+        do {\n+            Thread.sleep(1000);\n+            count = Thread.getAllStackTraces().keySet().stream()\n+                    .filter(t -> t instanceof ForkJoinWorkerThread)\n+                    .count();\n+        } while (count > 0);\n+\n+        System.out.println(duration(begin) + \"FJP HAS CONTRACTED\");\n+\n+        synchronized (quiescent) {\n+            quiescent.notify();\n+        }\n+\n+        System.out.println(duration(begin) + \"CLOSING EXECUTOR\");\n+        executor.close();\n+        System.out.println(duration(begin) + \"EXECUTOR CLOSED\");\n+    }\n+\n+    private static String duration(Long begin) {\n+        var duration = Duration.of(System.nanoTime() - begin, ChronoUnit.NANOS);\n+        long seconds = duration.toSeconds();\n+        int nanos = duration.toNanosPart();\n+        return (Thread.currentThread().isVirtual() ? \"VT: \" : \"PT: \") +\n+                String.format(\"%3d:%09d \", seconds, nanos);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCarrierLocalArenaPoolsMovingVt.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test TestCarrierLocalArenaPoolsStress\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCarrierLocalArenaPoolsStress\n+ *\/\n+\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.VarHandle;\n+import java.time.Duration;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestCarrierLocalArenaPoolsStress {\n+\n+    private static final long POOL_SIZE = 64;\n+    private static final VarHandle LONG_HANDLE = JAVA_LONG.varHandle();\n+\n+    \/**\n+     * The objective of this test is to try to provoke a situation where threads are\n+     * competing to use allocated pooled memory and then trying to make sure no thread\n+     * can see the same shared memory another thread is using.\n+     *\/\n+    @Test\n+    void stress() throws InterruptedException {\n+        final long begin = System.nanoTime();\n+\n+        System.out.println(duration(begin) + \"EXPANDING VT FJP\");\n+\n+        \/\/ Encourage the VT ForkJoin pool to expand\/contract so that VT:s will be allocated\n+        \/\/ on FJP threads that are later terminated.\n+        LongStream.range(0, Runtime.getRuntime().availableProcessors() * 2L)\n+                .parallel()\n+                \/\/ Using a CompletableFuture expands the FJP\n+                .forEach(_ -> Thread.ofVirtual().start(() -> {\n+                    try {\n+                        TimeUnit.SECONDS.sleep(1);\n+                    } catch (InterruptedException ie) {\n+                        throw new RuntimeException(ie);\n+                    }\n+                }));\n+\n+        System.out.println(duration(begin) + \"DONE EXPANDING\");\n+\n+        \/\/ Just use one pool variant as testing here is fairly expensive.\n+        final CarrierLocalArenaPools pool = CarrierLocalArenaPools.create(POOL_SIZE);\n+        \/\/ Make sure it works for both virtual and platform threads (as they are handled differently)\n+        for (var threadBuilder : List.of(Thread.ofVirtual(), Thread.ofPlatform())) {\n+            final int noThreads = threadBuilder instanceof Thread.Builder.OfVirtual ? 1024 : 32;\n+            System.out.println(duration(begin) + \"CREATING \" + noThreads + \" THREADS USING \" + threadBuilder);\n+            final Thread[] threads = IntStream.range(0, noThreads).mapToObj(_ ->\n+                    threadBuilder.start(() -> {\n+                        final long threadId = Thread.currentThread().threadId();\n+                        while (!Thread.interrupted()) {\n+                            for (int i = 0; i < 1_000_000; i++) {\n+                                try (Arena arena = pool.take()) {\n+                                    \/\/ Try to assert no two threads get allocated the same memory region.\n+\n+                                    final MemorySegment segment = arena.allocate(JAVA_LONG);\n+                                    LONG_HANDLE.setVolatile(segment, 0L, threadId);\n+                                    assertEquals(threadId, (long) LONG_HANDLE.getVolatile(segment, 0L));\n+\n+                               }\n+                            }\n+                            Thread.yield(); \/\/ make sure the driver thread gets a chance.\n+                        }\n+                    })).toArray(Thread[]::new);\n+            System.out.println(duration(begin) + \"SLEEPING\");\n+            Thread.sleep(Duration.of(10, SECONDS));\n+            System.out.println(duration(begin) + \"INTERRUPTING\");\n+            Arrays.stream(threads).forEach(\n+                    thread -> {\n+                        assertTrue(thread.isAlive());\n+                        thread.interrupt();\n+                    });\n+            System.out.println(duration(begin) + \"DONE INTERRUPTING\");\n+\n+            \/\/ VTs are daemon threads ...\n+            Arrays.stream(threads).forEach(t -> {\n+                try {\n+                    t.join();\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            System.out.println(duration(begin) + \"ALL THREADS COMPLETED\");\n+        }\n+        System.out.println(duration(begin) + \"DONE\");\n+    }\n+\n+    private static String duration(Long begin) {\n+        var duration = Duration.of(System.nanoTime() - begin, ChronoUnit.NANOS);\n+        long seconds = duration.toSeconds();\n+        int nanos = duration.toNanosPart();\n+        return (Thread.currentThread().isVirtual() ? \"VT: \" : \"PT: \") +\n+                String.format(\"%3d:%09d \", seconds, nanos);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCarrierLocalArenaPoolsStress.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\n+        \"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class ArenaPoolBench {\n+\n+    private static final CarrierLocalArenaPools POOLS = CarrierLocalArenaPools.create(32, 8);\n+\n+    @Param({\"4\", \"64\"})\n+    public int ELEM_SIZE;\n+\n+    @Benchmark\n+    public long confined() {\n+        try (var arena = Arena.ofConfined()) {\n+            return arena.allocate(ELEM_SIZE).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long pooled() {\n+        try (var arena = POOLS.take()) {\n+            return arena.allocate(ELEM_SIZE).address();\n+        }\n+\n+    }\n+\n+    @Benchmark\n+    public long confined2() {\n+        long x;\n+        try (var arena = Arena.ofConfined()) {\n+            x = arena.allocate(ELEM_SIZE).address();\n+            try (var arena2 = Arena.ofConfined()) {\n+                x += arena2.allocate(ELEM_SIZE).address();\n+            }\n+        }\n+        return x;\n+    }\n+\n+    @Benchmark\n+    public long pooled2() {\n+        long x;\n+        try (var arena = POOLS.take()) {\n+            x = arena.allocate(ELEM_SIZE).address();\n+            try (var arena2 = POOLS.take()) {\n+                x += arena2.allocate(ELEM_SIZE).address();\n+            }\n+        }\n+        return x;\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends ArenaPoolBench {\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ArenaPoolBench.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\n+        \"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class ArenaPoolFromBench {\n+\n+    private static final CarrierLocalArenaPools POOLS = CarrierLocalArenaPools.create(32);\n+\n+    private static final String TEXT = \"The quick brown fox\";\n+\n+    @Benchmark\n+    public long confinedInt() {\n+        try (var arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_INT, 42).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long confinedSting() {\n+        try (var arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(TEXT).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long pooledInt() {\n+        try (var arena = POOLS.take()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_INT, 42).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long pooledString() {\n+        try (var arena = POOLS.take()) {\n+            return arena.allocateFrom(TEXT).address();\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends ArenaPoolFromBench {\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ArenaPoolFromBench.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class CaptureStateUtilBench {\n+\n+    private static final CarrierLocalArenaPools POOLS = CarrierLocalArenaPools.create(16);\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+            .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n+\n+    private static final MethodHandle DUMMY_EXPLICIT_ALLOC = dummyExplicitAlloc();\n+    private static final MethodHandle DUMMY_TL_ALLOC = dummyTlAlloc();\n+\n+    @Benchmark\n+    public int explicitAllocationSuccess() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), 0, 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int explicitAllocationFail() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), -1, 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int tlAllocationSuccess() throws Throwable {\n+        try (var arena = POOLS.take()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), 0, 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int tlAllocationFail() throws Throwable {\n+        try (var arena = POOLS.take()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), -1, 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int adaptedSysCallSuccess() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invokeExact(0, 0);\n+    }\n+\n+    @Benchmark\n+    public int adaptedSysCallFail() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invokeExact( -1, 1);\n+    }\n+\n+    private static MethodHandle dummyExplicitAlloc() {\n+        try {\n+            return MethodHandles.lookup().findStatic(CaptureStateUtilBench.class,\n+                    \"dummy\", MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+    }\n+\n+    private static MethodHandle dummyTlAlloc() {\n+        final MethodHandle handle = dummyExplicitAlloc();\n+        return CaptureStateUtil.adaptSystemCall(handle, ERRNO_NAME);\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        if (errno != 0) {\n+            \/\/ Assuming the capture state is only modified upon detecting an error.\n+            ERRNO_HANDLE.set(segment, 0, errno);\n+        }\n+        return result;\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends CaptureStateUtilBench {}\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CaptureStateUtilBench.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}