{"files":[{"patch":"@@ -83,1 +83,1 @@\n-  NMTPreInit::pre_to_post();\n+  NMTPreInit::pre_to_post(level == NMT_off);\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,12 @@\n+NMTPreInitAllocationTable::~NMTPreInitAllocationTable() {\n+  \/\/ clear LU entries, but let payloads live!\n+  for (int i = 0; i < table_size; i++) {\n+    NMTPreInitAllocation* a = _entries[i];\n+    while (a != nullptr) {\n+      NMTPreInitAllocation* a2 = a->next;\n+      delete a;\n+      a = a2;\n+    }\n+  }\n+}\n+\n@@ -195,1 +207,2 @@\n-void NMTPreInit::pre_to_post() {\n+void NMTPreInit::pre_to_post(bool nmt_off) {\n+\n@@ -198,1 +211,1 @@\n-  if (MemTracker::tracking_level() == NMT_off) {\n+  if (nmt_off) {\n@@ -208,1 +221,0 @@\n-    assert(_table != (NMTPreInitAllocationTable*)-1, \"just once\");\n@@ -210,1 +222,1 @@\n-    _table = (NMTPreInitAllocationTable*)-1;\n+    _table = nullptr;\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+  ~NMTPreInitAllocationTable();\n@@ -260,1 +261,1 @@\n-  static void pre_to_post();\n+  static void pre_to_post(bool nmt_off);\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -176,40 +176,40 @@\n-        String regex = \".*entries: (\\\\d+).*sum bytes: (\\\\d+).*longest chain length: (\\\\d+).*\";\n-        output.shouldMatch(regex);\n-        String line = output.firstMatch(regex, 0);\n-        if (line == null) {\n-            throw new RuntimeException(\"expected: \" + regex);\n-        }\n-        System.out.println(line);\n-        Pattern p = Pattern.compile(regex);\n-        Matcher mat = p.matcher(line);\n-        mat.matches();\n-        int entries = Integer.parseInt(mat.group(1));\n-        int sum_bytes = Integer.parseInt(mat.group(2));\n-        int longest_chain = Integer.parseInt(mat.group(3));\n-        System.out.println(\"found: \" + entries + \" - \" + sum_bytes + longest_chain + \".\");\n-\n-        \/\/ Now we test the state of the internal lookup table, and through our assumptions about\n-        \/\/   early pre-NMT-init allocations:\n-        \/\/ The normal allocation count of surviving pre-init allocations is around 300-500, with the sum of allocated\n-        \/\/   bytes of a few dozen KB. We check these boundaries (with a very generous overhead) to see if the numbers are\n-        \/\/   way off. If they are, we may either have a leak or just a lot more allocations than we thought before\n-        \/\/   NMT initialization. Both cases should be investigated. Even if the allocations are valid, too many of them\n-        \/\/   stretches the limits of the lookup map, and therefore may cause slower lookup. We should then either change\n-        \/\/   the coding, reducing the number of allocations. Or enlarge the lookup table.\n-\n-        \/\/ Apply some sensible assumptions\n-        if (entries > testMode.num_command_line_args + 2000) { \/\/ Note: normal baseline is 400-500\n-            throw new RuntimeException(\"Suspiciously high number of pre-init allocations.\");\n-        }\n-        if (sum_bytes > 128 * 1024 * 1024) { \/\/ Note: normal baseline is ~30-40KB\n-            throw new RuntimeException(\"Suspiciously high pre-init memory usage.\");\n-        }\n-        if (longest_chain > testMode.expected_max_chain_len) {\n-            \/\/ Under normal circumstances, load factor of the map should be about 0.1. With a good hash distribution, we\n-            \/\/ should rarely see even a chain > 1. Warn if we see exceedingly long bucket chains, since this indicates\n-            \/\/ either that the hash algorithm is inefficient or we have a bug somewhere.\n-            throw new RuntimeException(\"Suspiciously long bucket chains in lookup table.\");\n-        }\n-\n-        \/\/ Finally, check that we see our final NMT report:\n-        if (nmtMode != NMTMode.off) {\n+        if (nmtMode != NMTMode.off) { \/\/ in OFF mode LU table is deleted after VM initialization, nothing to see there\n+            String regex = \".*entries: (\\\\d+).*sum bytes: (\\\\d+).*longest chain length: (\\\\d+).*\";\n+            output.shouldMatch(regex);\n+            String line = output.firstMatch(regex, 0);\n+            if (line == null) {\n+                throw new RuntimeException(\"expected: \" + regex);\n+            }\n+            System.out.println(line);\n+            Pattern p = Pattern.compile(regex);\n+            Matcher mat = p.matcher(line);\n+            mat.matches();\n+            int entries = Integer.parseInt(mat.group(1));\n+            int sum_bytes = Integer.parseInt(mat.group(2));\n+            int longest_chain = Integer.parseInt(mat.group(3));\n+            System.out.println(\"found: \" + entries + \" - \" + sum_bytes + longest_chain + \".\");\n+\n+            \/\/ Now we test the state of the internal lookup table, and through our assumptions about\n+            \/\/   early pre-NMT-init allocations:\n+            \/\/ The normal allocation count of surviving pre-init allocations is around 300-500, with the sum of allocated\n+            \/\/   bytes of a few dozen KB. We check these boundaries (with a very generous overhead) to see if the numbers are\n+            \/\/   way off. If they are, we may either have a leak or just a lot more allocations than we thought before\n+            \/\/   NMT initialization. Both cases should be investigated. Even if the allocations are valid, too many of them\n+            \/\/   stretches the limits of the lookup map, and therefore may cause slower lookup. We should then either change\n+            \/\/   the coding, reducing the number of allocations. Or enlarge the lookup table.\n+\n+            \/\/ Apply some sensible assumptions\n+            if (entries > testMode.num_command_line_args + 2000) { \/\/ Note: normal baseline is 400-500\n+                throw new RuntimeException(\"Suspiciously high number of pre-init allocations.\");\n+            }\n+            if (sum_bytes > 128 * 1024 * 1024) { \/\/ Note: normal baseline is ~30-40KB\n+                throw new RuntimeException(\"Suspiciously high pre-init memory usage.\");\n+            }\n+            if (longest_chain > testMode.expected_max_chain_len) {\n+                \/\/ Under normal circumstances, load factor of the map should be about 0.1. With a good hash distribution, we\n+                \/\/ should rarely see even a chain > 1. Warn if we see exceedingly long bucket chains, since this indicates\n+                \/\/ either that the hash algorithm is inefficient or we have a bug somewhere.\n+                throw new RuntimeException(\"Suspiciously long bucket chains in lookup table.\");\n+            }\n+\n+            \/\/ Finally, check that we see our final NMT report:\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTInitializationTest.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"}]}