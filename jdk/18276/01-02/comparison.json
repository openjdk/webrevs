{"files":[{"patch":"@@ -1114,1 +1114,1 @@\n-      if (estimate_cost_savings_when_packing_pair(t1, t2) >= 0) {\n+      if (estimate_cost_savings_when_packing_as_pair(t1, t2) >= 0) {\n@@ -1144,1 +1144,0 @@\n-  bool changed = false;\n@@ -1165,1 +1164,1 @@\n-        int my_savings = estimate_cost_savings_when_packing_pair(t1, t2);\n+        int my_savings = estimate_cost_savings_when_packing_as_pair(t1, t2);\n@@ -1184,1 +1183,1 @@\n-    changed = true;\n+    return true; \/\/ changed\n@@ -1186,1 +1185,1 @@\n-  return changed;\n+  return false; \/\/ no change\n@@ -1228,5 +1227,1 @@\n-\/\/ 2: Inputs of (use1, use2) already match (def1, def2), i.e. for all input indices i:\n-\/\/\n-\/\/    use1->in(i) == def1 || use2->in(def2)   ->    use1->in(i) == def1 && use2->in(def2)\n-\/\/\n-\/\/ 3: Add\/Mul (use1, use2): we can try to swap edges:\n+\/\/ 2: Commutative operations, just as Add\/Mul and their subclasses: we can try to swap edges:\n@@ -1238,1 +1233,1 @@\n-\/\/ 4: MulAddS2I (use1, use2): we can try to swap edges:\n+\/\/ 3: MulAddS2I (use1, use2): we can try to swap edges:\n@@ -1240,3 +1235,3 @@\n-\/\/    (x1 * x2) + (x3 * x4)    ==>  4.a: (x2 * x1) + (x4 * x3)\n-\/\/                                  4.b: (x4 * x3) + (x2 * x1)\n-\/\/                                  4.c: (x3 * x4) + (x1 * x2)\n+\/\/    (x1 * x2) + (x3 * x4)    ==>  3.a: (x2 * x1) + (x4 * x3)\n+\/\/                                  3.b: (x4 * x3) + (x2 * x1)\n+\/\/                                  3.c: (x3 * x4) + (x1 * x2)\n@@ -1249,0 +1244,4 @@\n+\/\/ 4: Otherwise, check if the inputs of (use1, use2) already match (def1, def2), i.e. for all input indices i:\n+\/\/\n+\/\/    use1->in(i) == def1 || use2->in(i) == def2   ->    use1->in(i) == def1 && use2->in(i) == def2\n+\/\/\n@@ -1254,2 +1253,2 @@\n-    Node* first = use1->in(2);\n-    if (first->is_Phi() || is_marked_reduction(first)) {\n+    Node* use1_in2 = use1->in(2);\n+    if (use1_in2->is_Phi() || is_marked_reduction(use1_in2)) {\n@@ -1258,2 +1257,2 @@\n-    first = use2->in(2);\n-    if (first->is_Phi() || is_marked_reduction(first)) {\n+    Node* use2_in2 = use2->in(2);\n+    if (use2_in2->is_Phi() || is_marked_reduction(use2_in2)) {\n@@ -1274,1 +1273,1 @@\n-        \/\/ 3. Add\/Mul: swap edges, and hope the other position matches too.\n+        \/\/ 2. Commutative: swap edges, and hope the other position matches too.\n@@ -1277,1 +1276,1 @@\n-        \/\/ 4.a\/b: MulAddS2I.\n+        \/\/ 3.a\/b: MulAddS2I.\n@@ -1288,1 +1287,1 @@\n-        \/\/ The inputs are not ordered, and we cannot do anything about it.\n+        \/\/ 4. The inputs are not ordered, and we cannot do anything about it.\n@@ -1292,1 +1291,1 @@\n-      \/\/ 4.c: MulAddS2I.\n+      \/\/ 3.c: MulAddS2I.\n@@ -1299,1 +1298,1 @@\n-  \/\/ 2. All inputs match.\n+  \/\/ 4. All inputs match.\n@@ -1304,1 +1303,1 @@\n-int SuperWord::estimate_cost_savings_when_packing_pair(const Node* s1, const Node* s2) const {\n+int SuperWord::estimate_cost_savings_when_packing_as_pair(const Node* s1, const Node* s2) const {\n@@ -1307,1 +1306,1 @@\n-  auto adjacent_profit = [&] (Node* s1, Node* s2) { return 2; };\n+  auto adjacent_profit = [&] () { return 2; };\n@@ -1317,1 +1316,1 @@\n-        save_in += adjacent_profit(x1, x2);\n+        save_in += adjacent_profit();\n@@ -1338,0 +1337,6 @@\n+        \/\/ We have pattern:\n+        \/\/\n+        \/\/   s1    s2\n+        \/\/    |    |\n+        \/\/ [use1, use2]\n+        \/\/\n@@ -1340,1 +1345,1 @@\n-          save_use += adjacent_profit(use1, use2);\n+          save_use += adjacent_profit();\n@@ -1365,0 +1370,1 @@\n+      assert(pack == nullptr, \"no unfinished pack\");\n@@ -1368,0 +1374,1 @@\n+    assert(pack != nullptr, \"must have unfinished pack\");\n@@ -1374,1 +1381,1 @@\n-  assert(pack == nullptr, \"finished the last pack\");\n+  assert(pack == nullptr, \"no unfinished pack\");\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -548,1 +548,1 @@\n-  int estimate_cost_savings_when_packing_pair(const Node* s1, const Node* s2) const;\n+  int estimate_cost_savings_when_packing_as_pair(const Node* s1, const Node* s2) const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}