{"files":[{"patch":"@@ -1130,0 +1130,3 @@\n+\/\/ Note: we only extend with a single pair (the one with most savings) for every call. Since we keep\n+\/\/       calling this method as long as there are some changes, we will eventually pack all pairs that\n+\/\/       can be packed.\n@@ -1188,1 +1191,1 @@\n-\/\/ For a pair (def1. def2), find all use packs (use1, use2), and ensure that their inputs have an order\n+\/\/ For a pair (def1, def2), find all use packs (use1, use2), and ensure that their inputs have an order\n@@ -1306,3 +1309,3 @@\n-  auto adjacent_profit = [&] () { return 2; };\n-  auto pack_cost       = [&] (int ct) { return ct; };\n-  auto unpack_cost     = [&] (int ct) { return ct; };\n+  const int adjacent_profit = 2;\n+  auto pack_cost       = [&] (const int size) { return size; };\n+  auto unpack_cost     = [&] (const int size) { return size; };\n@@ -1316,1 +1319,1 @@\n-        save_in += adjacent_profit();\n+        save_in += adjacent_profit;\n@@ -1326,1 +1329,1 @@\n-  uint ct = 0;\n+  uint number_of_packed_use_pairs = 0;\n@@ -1343,1 +1346,1 @@\n-        ct++;\n+        number_of_packed_use_pairs++;\n@@ -1345,1 +1348,1 @@\n-          save_use += adjacent_profit();\n+          save_use += adjacent_profit;\n@@ -1351,2 +1354,2 @@\n-  if (ct < s1->outcnt()) save_use += unpack_cost(1);\n-  if (ct < s2->outcnt()) save_use += unpack_cost(1);\n+  if (number_of_packed_use_pairs < s1->outcnt()) save_use += unpack_cost(1);\n+  if (number_of_packed_use_pairs < s2->outcnt()) save_use += unpack_cost(1);\n@@ -1411,4 +1414,1 @@\n-    for (uint i = 0; i < pack_size; i++) {\n-      Node* n = pack->at(i);\n-      set_pack(n, nullptr);\n-    }\n+    unmap_all_nodes_in_pack(pack);\n@@ -1444,4 +1444,1 @@\n-    for (uint i = 0; i < pack_size; i++) {\n-      Node* n = pack->at(i);\n-      set_pack(n, nullptr);\n-    }\n+    unmap_all_nodes_in_pack(pack);\n@@ -1455,1 +1452,1 @@\n-    set_pack(n, nullptr);\n+    unmap_node_in_pack(n);\n@@ -1471,1 +1468,1 @@\n-    set_pack(n, nullptr);\n+    unmap_node_in_pack(n);\n@@ -1489,1 +1486,1 @@\n-    set_pack(n, new_pack);\n+    remap_node_in_pack(n, new_pack);\n@@ -1764,1 +1761,1 @@\n-bool SuperWord::implemented(const Node_List* pack, uint size) const {\n+bool SuperWord::implemented(const Node_List* pack, const uint size) const {\n@@ -1874,1 +1871,1 @@\n-    Node_List* second_pk = _packset.pack(second_in);\n+    Node_List* second_pk = get_pack(second_in);\n@@ -1887,1 +1884,1 @@\n-    Node_List* cnt_pk = _packset.pack(cnt);\n+    Node_List* cnt_pk = get_pack(cnt);\n@@ -1940,1 +1937,1 @@\n-    if (bol == nullptr || _packset.pack(bol) == nullptr) {\n+    if (bol == nullptr || get_pack(bol) == nullptr) {\n@@ -1945,1 +1942,1 @@\n-    if (cmp == nullptr || _packset.pack(cmp) == nullptr) {\n+    if (cmp == nullptr || get_pack(cmp) == nullptr) {\n@@ -1994,1 +1991,1 @@\n-      assert(pack(n) == p, \"n has consisten packset info\");\n+      assert(get_pack(n) == p, \"n has consisten packset info\");\n@@ -2003,1 +2000,1 @@\n-      assert(pack(n) == nullptr, \"should not have pack if not in packset\");\n+      assert(get_pack(n) == nullptr, \"should not have pack if not in packset\");\n@@ -2093,1 +2090,1 @@\n-        assert(packset.pack(n) == p, \"matching packset\");\n+        assert(packset.get_pack(n) == p, \"matching packset\");\n@@ -2109,1 +2106,1 @@\n-        assert(packset.pack(n) == nullptr, \"no packset\");\n+        assert(packset.get_pack(n) == nullptr, \"no packset\");\n@@ -2175,1 +2172,1 @@\n-      Node_List* p = _slp->packset().pack(n);\n+      Node_List* p = _slp->packset().get_pack(n);\n@@ -2404,1 +2401,1 @@\n-    Node_List* p = _packset.pack(n);\n+    Node_List* p = get_pack(n);\n@@ -2494,1 +2491,1 @@\n-        Node_List* p_bol = _packset.pack(bol);\n+        Node_List* p_bol = get_pack(bol);\n@@ -2507,1 +2504,1 @@\n-        Node_List* p_cmp = _packset.pack(cmp);\n+        Node_List* p_cmp = get_pack(cmp);\n@@ -2826,1 +2823,1 @@\n-    if (_packset.pack(in) != nullptr) {\n+    if (get_pack(in) != nullptr) {\n@@ -2834,1 +2831,1 @@\n-      if (_packset.pack(in2) != nullptr) {\n+      if (get_pack(in2) != nullptr) {\n@@ -2867,1 +2864,1 @@\n-            Node_List* p_use = _packset.pack(use);\n+            Node_List* p_use = get_pack(use);\n@@ -2880,2 +2877,2 @@\n-  Node_List* pack = _packset.pack(n_super);\n-  assert(pack != nullptr && pack == _packset.pack(n_sub), \"must have the same pack\");\n+  Node_List* pack = get_pack(n_super);\n+  assert(pack != nullptr && pack == get_pack(n_sub), \"must have the same pack\");\n@@ -2886,1 +2883,1 @@\n-    Node_List* pack_use_sub = _packset.pack(use_sub);\n+    Node_List* pack_use_sub = get_pack(use_sub);\n@@ -2899,1 +2896,1 @@\n-        Node_List* pack_use_super = _packset.pack(use_super);\n+        Node_List* pack_use_super = get_pack(use_super);\n@@ -2948,1 +2945,1 @@\n-      if (_packset.pack(n0_in) != _packset.pack(n1_in) &&\n+      if (get_pack(n0_in) != get_pack(n1_in) &&\n@@ -2969,1 +2966,1 @@\n-  Node_List* u_pk = _packset.pack(use);\n+  Node_List* u_pk = get_pack(use);\n@@ -2973,1 +2970,1 @@\n-  Node_List* d_pk = _packset.pack(def);\n+  Node_List* d_pk = get_pack(def);\n@@ -3754,1 +3751,1 @@\n-void PackSet::print_pack(Node_List* pack) const {\n+void PackSet::print_pack(Node_List* pack) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":42,"deletions":45,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -291,1 +291,20 @@\n-  void set_pack(const Node* n, Node_List* pack) { _node_to_pack.at_put(_body.bb_idx(n), pack); }\n+  void map_node_in_pack(const Node* n, Node_List* new_pack) {\n+    assert(get_pack(n) == nullptr, \"was previously unmapped\");\n+    _node_to_pack.at_put(_body.bb_idx(n), new_pack);\n+  }\n+\n+  void remap_node_in_pack(const Node* n, Node_List* new_pack) {\n+    assert(get_pack(n) != nullptr && new_pack != nullptr && get_pack(n) != new_pack, \"was previously mapped\");\n+    _node_to_pack.at_put(_body.bb_idx(n), new_pack);\n+  }\n+\n+  void unmap_node_in_pack(const Node* n) {\n+    assert(get_pack(n) != nullptr, \"was previously mapped\");\n+    _node_to_pack.at_put(_body.bb_idx(n), nullptr);\n+  }\n+\n+  void unmap_all_nodes_in_pack(Node_List* old_pack) {\n+    for (uint i = 0; i < old_pack->size(); i++) {\n+      unmap_node_in_pack(old_pack->at(i));\n+    }\n+  }\n@@ -293,1 +312,1 @@\n-  Node_List* pack(const Node* n) const { return !_vloop.in_bb(n) ? nullptr : _node_to_pack.at(_body.bb_idx(n)); }\n+  Node_List* get_pack(const Node* n) const { return !_vloop.in_bb(n) ? nullptr : _node_to_pack.at(_body.bb_idx(n)); }\n@@ -299,2 +318,1 @@\n-      assert(this->pack(n) == nullptr, \"not yet in a pack\");\n-      set_pack(n, pack);\n+      map_node_in_pack(n, pack);\n@@ -323,1 +341,1 @@\n-  NOT_PRODUCT(void print_pack(Node_List* pack) const;)\n+  NOT_PRODUCT(static void print_pack(Node_List* pack);)\n@@ -488,1 +506,3 @@\n-  const PackSet& packset()   const { return _packset; }\n+  const PackSet& packset() const { return _packset; }\n+  Node_List* get_pack(const Node* n) const { return _packset.get_pack(n); }\n+\n@@ -576,1 +596,1 @@\n-  bool implemented(const Node_List* pack, uint size) const;\n+  bool implemented(const Node_List* pack, const uint size) const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"}]}