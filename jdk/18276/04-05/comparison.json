{"files":[{"patch":"@@ -843,1 +843,1 @@\n-      if (!_pairset.has_left(s1) && !_pairset.has_right(s2)) {\n+      if (!_pairset.is_left(s1) && !_pairset.is_right(s2)) {\n@@ -1044,2 +1044,2 @@\n-      Node* left  = _pairset.left_at(i);\n-      Node* right = _pairset.right_at(i);\n+      Node* left  = _pairset.left_at_in_insertion_order(i);\n+      Node* right = _pairset.right_at_in_insertion_order(i);\n@@ -1089,1 +1089,1 @@\n-  assert(_pairset.has_pair(s1, s2), \"(s1, s2) must be a pair\");\n+  assert(_pairset.is_pair(s1, s2), \"(s1, s2) must be a pair\");\n@@ -1134,1 +1134,1 @@\n-  assert(_pairset.has_pair(s1, s2), \"(s1, s2) must be a pair\");\n+  assert(_pairset.is_pair(s1, s2), \"(s1, s2) must be a pair\");\n@@ -1194,1 +1194,1 @@\n-  assert(_pairset.has_pair(def1, def2), \"(def1, def2) must be a pair\");\n+  assert(_pairset.is_pair(def1, def2), \"(def1, def2) must be a pair\");\n@@ -1252,1 +1252,1 @@\n-  assert(_pairset.has_pair(def1, def2), \"(def1, def2) must be a pair\");\n+  assert(_pairset.is_pair(def1, def2), \"(def1, def2) must be a pair\");\n@@ -1320,1 +1320,1 @@\n-      } else if (!_pairset.has_pair(x1, x2)) {\n+      } else if (!_pairset.is_pair(x1, x2)) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -70,0 +70,34 @@\n+  \/\/ Example:\n+  \/\/\n+  \/\/   Pairs: (n1, n2) and (n2, n3)\n+  \/\/   bb_idx(n1) = 1\n+  \/\/   bb_idx(n2) = 3\n+  \/\/   bb_idx(n3) = 5\n+  \/\/\n+  \/\/   index \/ bb_idx:   0   1   2   3   4   5   6\n+  \/\/\n+  \/\/   left_to_right:  |   | 3 |   | 5 |   |   |   |\n+  \/\/                         n1----->\n+  \/\/                                 n2----->\n+  \/\/\n+  \/\/   right_to_left:  |   |   |   | 1 |   | 3 |   |\n+  \/\/                          <------n2\n+  \/\/                                  <------n3\n+  \/\/\n+  \/\/   Nodes with bb_idx 0, 2, 4, and 6 are in no pair, they are thus neither left nor right elements,\n+  \/\/   and hence have no entries in the mapping.\n+  \/\/\n+  \/\/   Nodes with bb_idx 1 and 3 (n1 and n2) are both a left element in some pair. Therefore, they both\n+  \/\/   have an entry in the left_to_right mapping. This mapping indicates which right element they are\n+  \/\/   paired with, namely the nodes with bb_idx 3 and 5 (n2 and n3), respectively.\n+  \/\/\n+  \/\/   Nodes with bb_idx 3 and 5 (n2 and n4) are both a right element in some pair. Therefore, they both\n+  \/\/   have an entry in the right_to_left mapping. This mapping indicates which left element they are\n+  \/\/   paired with, namely the nodes with bb_idx 1 and 3 (n1 and n2), respectively.\n+  \/\/\n+  \/\/   Node n1 with bb_idx 1 is not a right element in any pair, thus its right_to_left is empty.\n+  \/\/\n+  \/\/   Node n2 with bb_idx 3 is both a left element of pair (n2, n3), and a right element of pair (n1, n2).\n+  \/\/   Thus it has entries in both left_to_right (mapping n2->n3) and right_to_left (mapping n2->n1).\n+  \/\/\n+  \/\/   Node n3 with bb_idx 5 is not a left element in any pair, thus its left_to_right is empty.\n@@ -84,0 +118,1 @@\n+\n@@ -85,7 +120,10 @@\n-  bool has_left(int i)  const { return _left_to_right.at(i) != -1; }\n-  bool has_right(int i) const { return _right_to_left.at(i) != -1; }\n-  bool has_left(const Node* n)  const { return _vloop.in_bb(n) && has_left( _body.bb_idx(n)); }\n-  bool has_right(const Node* n) const { return _vloop.in_bb(n) && has_right(_body.bb_idx(n)); }\n-  bool has_pair(const Node* n1, const Node* n2) const { return has_left(n1) && get_right_for(n1) == n2; }\n-  bool is_left_in_a_left_most_pair(int i)   const { return has_left(i) && !has_right(i); }\n-  bool is_right_in_a_right_most_pair(int i) const { return !has_left(i) && has_right(i); }\n+\n+  bool is_left(int i)  const { return _left_to_right.at(i) != -1; }\n+  bool is_right(int i) const { return _right_to_left.at(i) != -1; }\n+  bool is_left(const Node* n)  const { return _vloop.in_bb(n) && is_left( _body.bb_idx(n)); }\n+  bool is_right(const Node* n) const { return _vloop.in_bb(n) && is_right(_body.bb_idx(n)); }\n+\n+  bool is_pair(const Node* n1, const Node* n2) const { return is_left(n1) && get_right_for(n1) == n2; }\n+\n+  bool is_left_in_a_left_most_pair(int i)   const { return is_left(i) && !is_right(i); }\n+  bool is_right_in_a_right_most_pair(int i) const { return !is_left(i) && is_right(i); }\n@@ -94,0 +132,1 @@\n+\n@@ -96,1 +135,1 @@\n-  Node* get_right_or_null_for(const Node* n) const { return has_left(n) ? get_right_for(n) : nullptr; }\n+  Node* get_right_or_null_for(const Node* n) const { return is_left(n) ? get_right_for(n) : nullptr; }\n@@ -100,2 +139,2 @@\n-  Node* left_at(int i)  const { return _body.body().at(_lefts_in_insertion_order.at(i)); }\n-  Node* right_at(int i) const { return _body.body().at(get_right_for(_lefts_in_insertion_order.at(i))); }\n+  Node* left_at_in_insertion_order(int i)  const { return _body.body().at(_lefts_in_insertion_order.at(i)); }\n+  Node* right_at_in_insertion_order(int i) const { return _body.body().at(get_right_for(_lefts_in_insertion_order.at(i))); }\n@@ -105,1 +144,1 @@\n-    assert(!has_left(n1) && !has_right(n2), \"cannot be left twice, or right twice\");\n+    assert(!is_left(n1) && !is_right(n2), \"cannot be left twice, or right twice\");\n@@ -111,1 +150,1 @@\n-    assert(has_left(n1) && has_right(n2), \"must be set now\");\n+    assert(is_left(n1) && is_right(n2), \"must be set now\");\n@@ -133,2 +172,4 @@\n-    _pairset(pairset), _body(pairset.body()),\n-    _chain_start_bb_idx(-1), _current_bb_idx(-1),\n+    _pairset(pairset),\n+    _body(pairset.body()),\n+    _chain_start_bb_idx(-1),\n+    _current_bb_idx(-1),\n@@ -140,1 +181,3 @@\n-  bool done() const { return _chain_start_bb_idx >= _end_bb_idx; }\n+  bool done() const {\n+    return _chain_start_bb_idx >= _end_bb_idx;\n+  }\n@@ -153,1 +196,1 @@\n-    assert(_pairset.has_left(_current_bb_idx), \"current was valid\");\n+    assert(_pairset.is_left(_current_bb_idx), \"current was valid\");\n@@ -155,1 +198,1 @@\n-    if (!_pairset.has_left(_current_bb_idx)) {\n+    if (!_pairset.is_left(_current_bb_idx)) {\n@@ -263,1 +306,1 @@\n-  \/\/ The \"packset\" proper: an array of \"packs\"\n+  \/\/ Set of all packs:\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":61,"deletions":18,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8310886\n+ * @bug 8310886 8325252\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}