{"files":[{"patch":"@@ -396,0 +396,2 @@\n+ -runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java \\\n+ -runtime\/Monitor\/TestRecursiveLocking.java \\\n@@ -593,0 +595,1 @@\n+ -runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Xint_outer_inner\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib \/runtime\/Monitor\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\/\n+\n+\/*\n+ * @test id=Xint_alternate_AB\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib \/runtime\/Monitor\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\/\n+\n+\/*\n+ * @test id=C1_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib \/runtime\/Monitor\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\/\n+\n+\/*\n+ * @test id=C1_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib \/runtime\/Monitor\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\/\n+\n+\/*\n+ * @test id=C2_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib \/runtime\/Monitor\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\/\n+\n+\/*\n+ * @test id=C2_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib \/runtime\/Monitor\n+ * @build jdk.test.whitebox.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=0\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=1\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=2\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\/\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -0,0 +1,529 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Xint_outer_inner\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\/\n+\n+\/*\n+ * @test id=Xint_alternate_AB\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\/\n+\n+\/*\n+ * @test id=C1_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\/\n+\n+\/*\n+ * @test id=C1_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\/\n+\n+\/*\n+ * @test id=C2_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\/\n+\n+\/*\n+ * @test id=C2_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=0\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=1\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=2\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+public class TestRecursiveLocking {\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    static final int LockingMode = WB.getIntVMFlag(\"LockingMode\").intValue();\n+    static final int LockStackCapacity = WB.getLockStackCapacity();\n+    static final int LM_MONITOR = 0;\n+    static final int LM_LEGACY = 1;\n+    static final int LM_LIGHTWEIGHT = 2;\n+    static final SyncThread syncThread = new SyncThread();\n+\n+    \/\/ This SynchronizedObject class and the OUTER followed by INNER testing\n+    \/\/ model is adapted from runtime\/lockStack\/TestLockStackCapacity.java.\n+    static class SynchronizedObject {\n+        private int counter;\n+\n+        synchronized void runInner(int depth, SynchronizedObject outer) {\n+            counter++;\n+\n+            if (LockingMode != LM_LEGACY) {\n+                outer.assertInflated();\n+            }\n+\n+            if (LockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            }\n+            if (depth == 1) {\n+                return;\n+            } else {\n+                runInner(depth - 1, outer);\n+            }\n+            if (LockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            }\n+        }\n+\n+        synchronized void runOuter(int depth, SynchronizedObject inner) {\n+            counter++;\n+            if (LockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            }\n+            if (depth == 1) {\n+                inner.runInner(LockStackCapacity, this);\n+            } else {\n+                runOuter(depth - 1, inner);\n+            }\n+            if (LockingMode != LM_LEGACY) {\n+                assertInflated();\n+            }\n+        }\n+\n+        public void runOuterInnerTest() {\n+            final SynchronizedObject OUTER = new SynchronizedObject();\n+            final SynchronizedObject INNER = new SynchronizedObject();\n+\n+            \/\/ Just checking since they are new objects:\n+            OUTER.assertNotInflated();\n+            INNER.assertNotInflated();\n+\n+            synchronized(OUTER) {\n+                OUTER.counter++;\n+\n+                if (LockingMode != LM_MONITOR) {\n+                    OUTER.assertNotInflated();\n+                }\n+                INNER.assertNotInflated();\n+                OUTER.runOuter(LockStackCapacity - 1, INNER);\n+\n+                if (LockingMode != LM_LEGACY) {\n+                    OUTER.assertInflated();\n+                }\n+                if (LockingMode != LM_MONITOR) {\n+                    INNER.assertNotInflated();\n+                }\n+            }\n+\n+            \/\/ Verify that the nested monitors have been properly released:\n+            syncThread.verifyCanBeSynced(OUTER);\n+            syncThread.verifyCanBeSynced(INNER);\n+\n+            Asserts.assertEquals(OUTER.counter, LockStackCapacity);\n+            Asserts.assertEquals(INNER.counter, LockStackCapacity);\n+        }\n+\n+        synchronized void runA(int depth, SynchronizedObject B) {\n+            counter++;\n+\n+            if (LockingMode == LM_LIGHTWEIGHT) {\n+                if (counter > LockStackCapacity \/ 2) {\n+                    assertInflated();\n+                }\n+            } else if (LockingMode == LM_MONITOR) {\n+                assertInflated();\n+            }\n+\n+            \/\/ Call runB() at the same depth as runA's depth:\n+            B.runB(depth, this);\n+        }\n+\n+        synchronized void runB(int depth, SynchronizedObject A) {\n+            counter++;\n+\n+            if (LockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            } else {\n+                assertInflated();\n+            }\n+\n+            if (depth == 1) {\n+                \/\/ Reached LockStackCapacity in depth so we're done.\n+                return;\n+            } else {\n+                A.runA(depth - 1, this);\n+            }\n+        }\n+\n+        public void runAlternateABTest() {\n+            final SynchronizedObject A = new SynchronizedObject();\n+            final SynchronizedObject B = new SynchronizedObject();\n+\n+            \/\/ Just checking since they are new objects:\n+            A.assertNotInflated();\n+            B.assertNotInflated();\n+\n+            A.runA(LockStackCapacity, B);\n+\n+            \/\/ Verify that the nested monitors have been properly released:\n+            syncThread.verifyCanBeSynced(A);\n+            syncThread.verifyCanBeSynced(B);\n+\n+            Asserts.assertEquals(A.counter, LockStackCapacity);\n+            Asserts.assertEquals(B.counter, LockStackCapacity);\n+            if (LockingMode == LM_LEGACY) {\n+                A.assertNotInflated();\n+            }\n+            \/\/ Implied else: for LM_MONITOR or LM_LIGHTWEIGHT it can be\n+            \/\/ either inflated or not point because A is not locked anymore\n+            \/\/ and subject to deflation.\n+\n+            if (LockingMode != LM_MONITOR) {\n+                B.assertNotInflated();\n+            }\n+        }\n+\n+        void assertNotInflated() {\n+            Asserts.assertFalse(WB.isMonitorInflated(this));\n+        }\n+\n+        void assertInflated() {\n+            Asserts.assertTrue(WB.isMonitorInflated(this));\n+        }\n+    }\n+\n+    static void usage() {\n+        System.err.println();\n+        System.err.println(\"Usage: java TestRecursiveLocking [n_secs]\");\n+        System.err.println(\"       java TestRecursiveLocking n_secs [mode]\");\n+        System.err.println();\n+        System.err.println(\"where:\");\n+        System.err.println(\"    n_secs  ::= > 0\");\n+        System.err.println(\"            Default n_secs is 15.\");\n+        System.err.println(\"    mode    ::= 1 - outer and inner\");\n+        System.err.println(\"            ::= 2 - alternate A and B\");\n+        System.err.println(\"            Default mode is 1.\");\n+        System.exit(1);\n+    }\n+\n+    public static void main(String... argv) throws Exception {\n+        int mode = 2;\n+        int n_secs = 30;\n+\n+        if (argv.length != 0 && argv.length != 1 && argv.length != 2) {\n+            usage();\n+        } else if (argv.length > 0) {\n+            try {\n+                n_secs = Integer.parseInt(argv[0]);\n+                if (n_secs <= 0) {\n+                    throw new NumberFormatException(\"Not > 0: '\" + argv[0]\n+                                                    + \"'\");\n+                }\n+            } catch (NumberFormatException nfe) {\n+                System.err.println();\n+                System.err.println(nfe);\n+                System.err.println(\"ERROR: '\" + argv[0]\n+                                   + \"': invalid n_secs value.\");\n+                usage();\n+            }\n+\n+            if (argv.length > 1) {\n+                try {\n+                    mode = Integer.parseInt(argv[1]);\n+                    if (mode != 1 && mode != 2) {\n+                        throw new NumberFormatException(\"Not 1 -> 2: '\"\n+                                                        + argv[1] + \"'\");\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println();\n+                    System.err.println(nfe);\n+                    System.err.println(\"ERROR: '\" + argv[1]\n+                                       + \"': invalid mode value.\");\n+                    usage();\n+                }\n+            }\n+        }\n+\n+        System.out.println(\"INFO: LockingMode=\" + LockingMode);\n+        System.out.println(\"INFO: LockStackCapacity=\" + LockStackCapacity);\n+        System.out.println(\"INFO: n_secs=\" + n_secs);\n+        System.out.println(\"INFO: mode=\" + mode);\n+\n+        long loopCount = 0;\n+        long endTime = System.currentTimeMillis() + n_secs * 1000;\n+\n+        syncThread.waitForStart();\n+\n+        while (System.currentTimeMillis() < endTime) {\n+            loopCount++;\n+            SynchronizedObject syncObj = new SynchronizedObject();\n+            switch (mode) {\n+            case 1:\n+                syncObj.runOuterInnerTest();\n+                break;\n+\n+            case 2:\n+                syncObj.runAlternateABTest();\n+                break;\n+\n+            default:\n+                throw new RuntimeException(\"bad mode parameter: \" + mode);\n+            }\n+        }\n+\n+        syncThread.setDone();\n+        try {\n+            syncThread.join();\n+        } catch (InterruptedException ie) {\n+            \/\/ This should not happen.\n+            ie.printStackTrace();\n+        }\n+\n+        System.out.println(\"INFO: main executed \" + loopCount + \" loops in \"\n+                           + n_secs + \" seconds.\");\n+    }\n+}\n+\n+class SyncThread extends Thread {\n+    static final boolean verbose = false;  \/\/ set to true for debugging\n+    private boolean done = false;\n+    private boolean haveWork = false;\n+    private Object obj;\n+    private Object waiter = new Object();\n+\n+    public void run() {\n+        if (verbose) System.out.println(\"SyncThread: running.\");\n+        synchronized(waiter) {\n+            \/\/ Let main know that we are running:\n+            if (verbose) System.out.println(\"SyncThread: notify main running.\");\n+            waiter.notify();\n+\n+            while (!done) {\n+                if (verbose) System.out.println(\"SyncThread: waiting.\");\n+                try {\n+                    waiter.wait();\n+                } catch (InterruptedException ie) {\n+                }\n+                if (haveWork) {\n+                    if (verbose) System.out.println(\"SyncThread: working.\");\n+                    synchronized(obj) {\n+                    }\n+                    if (verbose) System.out.println(\"SyncThread: worked.\");\n+                    haveWork = false;\n+                    waiter.notify();\n+                    if (verbose) System.out.println(\"SyncThread: notified.\");\n+                }\n+                else if (verbose) {\n+                    System.out.println(\"SyncThread: notified without work.\");\n+                }\n+            }\n+        }\n+        if (verbose) System.out.println(\"SyncThread: exiting.\");\n+    }\n+\n+    public void setDone() {\n+        synchronized(waiter) {\n+            if (verbose) System.out.println(\"main: set done.\");\n+            done = true;\n+            waiter.notify();\n+        }\n+    }\n+\n+    public void verifyCanBeSynced(Object obj) {\n+        synchronized(waiter) {\n+            if (verbose) System.out.println(\"main: queueing up work.\");\n+            this.obj = obj;\n+            haveWork = true;\n+            if (verbose) System.out.println(\"main: notifying SyncThread.\");\n+            waiter.notify();\n+            if (verbose) System.out.println(\"main: waiting for SyncThread.\");\n+            while (haveWork) {\n+                try {\n+                    waiter.wait();\n+                } catch (InterruptedException ie) {\n+                }\n+            }\n+            if (verbose) System.out.println(\"main: waited for SyncThread.\");\n+        }\n+    }\n+\n+    public void waitForStart() {\n+        synchronized(waiter) {\n+            this.start();\n+\n+            \/\/ Wait for SyncThread to actually get running:\n+            if (verbose) System.out.println(\"main: wait for SyncThread start.\");\n+            try {\n+                waiter.wait();\n+            } catch (InterruptedException ie) {\n+            }\n+            if (verbose) System.out.println(\"main: waited for SyncThread start.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/TestRecursiveLocking.java","additions":529,"deletions":0,"binary":false,"changes":529,"status":"added"}]}