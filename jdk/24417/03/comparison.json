{"files":[{"patch":"@@ -103,1 +103,1 @@\n-    --override-methods=summary\n+    --override-methods=summary --syntax-highlight\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,0 +314,6 @@\n+        var syntaxHighlight = options.syntaxHighlight();\n+        if (syntaxHighlight) {\n+            copyResource(DocPaths.HIGHLIGHT_CSS, DocPaths.RESOURCE_FILES.resolve(DocPaths.HIGHLIGHT_CSS), true);\n+            copyResource(DocPaths.HIGHLIGHT_JS, DocPaths.SCRIPT_FILES.resolve(DocPaths.HIGHLIGHT_JS), true);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -514,0 +514,1 @@\n+                .setSyntaxHighlight(options.syntaxHighlight())\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,0 +201,5 @@\n+    \/**\n+     * Argument for command line option {@code --syntax-highlight}.\n+     *\/\n+    private boolean syntaxHighlight = false;\n+\n@@ -426,0 +431,8 @@\n+                new Option(resources, \"--syntax-highlight\") {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        syntaxHighlight = true;\n+                        return true;\n+                    }\n+                },\n+\n@@ -809,0 +822,7 @@\n+    \/**\n+     * Argument for command line option {@code --syntax-highlight}.\n+     * True if command line option \"--syntax-highlight\" is used and syntax\n+     * highlighting should be enabled. Default value is false.\n+     *\/\n+    public boolean syntaxHighlight() { return syntaxHighlight; }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlOptions.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+    private boolean syntaxHighlight = false;\n@@ -241,0 +242,10 @@\n+    \/**\n+     * Enables or disables support for syntax highlighting.\n+     * @param value {@code true} to enable syntax highligting\n+     * @return this object\n+     *\/\n+    public Head setSyntaxHighlight(boolean value) {\n+        this.syntaxHighlight = value;\n+        return this;\n+    }\n+\n@@ -342,0 +353,5 @@\n+        if (syntaxHighlight) {\n+            addStylesheet(head, DocPaths.RESOURCE_FILES.resolve(DocPaths.HIGHLIGHT_CSS));\n+            addScriptElement(head, DocPaths.HIGHLIGHT_JS);\n+        }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Head.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * Licensed under the Universal Permissive License v 1.0 as shown at https:\/\/oss.oracle.com\/licenses\/upl\/\n+ *\/\n+\/* Syntax highlight style sheet *\/\n+.hljs-title.function_,\n+.hljs-template-variable {\n+    color: #00738F;\n+}\n+.hljs-code,\n+.hljs-comment,\n+.hljs-quote {\n+    color: #6e6e71;\n+    font-style: italic;\n+}\n+.hljs-meta {\n+    color: #836F00;\n+}\n+.hljs-symbol,\n+.hljs-template-tag,\n+.hljs-keyword,\n+.hljs-literal,\n+.hljs-name,\n+.hljs-built_in,\n+.hljs-char.escape_ {\n+    color: #0C40C2;\n+}\n+.hljs-variable,\n+.hljs-property,\n+.hljs-attr,\n+.hljs-section {\n+    color: #841191;\n+}\n+.hljs-attribute {\n+    color: #164ad9;\n+}\n+.hljs-regexp,\n+.hljs-number {\n+    color: #104BEB;\n+}\n+.hljs-link {\n+    color: #47688a;\n+}\n+.hljs-string {\n+    color: #008313;\n+}\n+.hljs-doctag {\n+    text-decoration: underline;\n+}\n+.hljs-emphasis {\n+    font-style: italic;\n+}\n+.hljs-strong {\n+    font-weight: bold;\n+}\n+.hljs-subst,\n+.hljs-title,\n+.hljs-params,\n+.hljs-bullet,\n+.hljs-formula,\n+.hljs-tag,\n+.hljs-type {\n+    \/* ignored *\/\n+}\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/highlight.css","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,3278 @@\n+\/*!\n+  Highlight.js v11.11.1 (git: 08cb242e7d)\n+  (c) 2006-2025 Josh Goebel <hello@joshgoebel.com> and other contributors\n+  License: BSD-3-Clause\n+ *\/\n+var hljs = (function () {\n+  'use strict';\n+\n+  \/* eslint-disable no-multi-assign *\/\n+\n+  function deepFreeze(obj) {\n+    if (obj instanceof Map) {\n+      obj.clear =\n+        obj.delete =\n+        obj.set =\n+          function () {\n+            throw new Error('map is read-only');\n+          };\n+    } else if (obj instanceof Set) {\n+      obj.add =\n+        obj.clear =\n+        obj.delete =\n+          function () {\n+            throw new Error('set is read-only');\n+          };\n+    }\n+\n+    \/\/ Freeze self\n+    Object.freeze(obj);\n+\n+    Object.getOwnPropertyNames(obj).forEach((name) => {\n+      const prop = obj[name];\n+      const type = typeof prop;\n+\n+      \/\/ Freeze prop if it is an object or function and also not already frozen\n+      if ((type === 'object' || type === 'function') && !Object.isFrozen(prop)) {\n+        deepFreeze(prop);\n+      }\n+    });\n+\n+    return obj;\n+  }\n+\n+  \/** @typedef {import('highlight.js').CallbackResponse} CallbackResponse *\/\n+  \/** @typedef {import('highlight.js').CompiledMode} CompiledMode *\/\n+  \/** @implements CallbackResponse *\/\n+\n+  class Response {\n+    \/**\n+     * @param {CompiledMode} mode\n+     *\/\n+    constructor(mode) {\n+      \/\/ eslint-disable-next-line no-undefined\n+      if (mode.data === undefined) mode.data = {};\n+\n+      this.data = mode.data;\n+      this.isMatchIgnored = false;\n+    }\n+\n+    ignoreMatch() {\n+      this.isMatchIgnored = true;\n+    }\n+  }\n+\n+  \/**\n+   * @param {string} value\n+   * @returns {string}\n+   *\/\n+  function escapeHTML(value) {\n+    return value\n+      .replace(\/&\/g, '&amp;')\n+      .replace(\/<\/g, '&lt;')\n+      .replace(\/>\/g, '&gt;')\n+      .replace(\/\"\/g, '&quot;')\n+      .replace(\/'\/g, '&#x27;');\n+  }\n+\n+  \/**\n+   * performs a shallow merge of multiple objects into one\n+   *\n+   * @template T\n+   * @param {T} original\n+   * @param {Record<string,any>[]} objects\n+   * @returns {T} a single new object\n+   *\/\n+  function inherit$1(original, ...objects) {\n+    \/** @type Record<string,any> *\/\n+    const result = Object.create(null);\n+\n+    for (const key in original) {\n+      result[key] = original[key];\n+    }\n+    objects.forEach(function(obj) {\n+      for (const key in obj) {\n+        result[key] = obj[key];\n+      }\n+    });\n+    return \/** @type {T} *\/ (result);\n+  }\n+\n+  \/**\n+   * @typedef {object} Renderer\n+   * @property {(text: string) => void} addText\n+   * @property {(node: Node) => void} openNode\n+   * @property {(node: Node) => void} closeNode\n+   * @property {() => string} value\n+   *\/\n+\n+  \/** @typedef {{scope?: string, language?: string, sublanguage?: boolean}} Node *\/\n+  \/** @typedef {{walk: (r: Renderer) => void}} Tree *\/\n+  \/** *\/\n+\n+  const SPAN_CLOSE = '<\/span>';\n+\n+  \/**\n+   * Determines if a node needs to be wrapped in <span>\n+   *\n+   * @param {Node} node *\/\n+  const emitsWrappingTags = (node) => {\n+    \/\/ rarely we can have a sublanguage where language is undefined\n+    \/\/ TODO: track down why\n+    return !!node.scope;\n+  };\n+\n+  \/**\n+   *\n+   * @param {string} name\n+   * @param {{prefix:string}} options\n+   *\/\n+  const scopeToCSSClass = (name, { prefix }) => {\n+    \/\/ sub-language\n+    if (name.startsWith(\"language:\")) {\n+      return name.replace(\"language:\", \"language-\");\n+    }\n+    \/\/ tiered scope: comment.line\n+    if (name.includes(\".\")) {\n+      const pieces = name.split(\".\");\n+      return [\n+        `${prefix}${pieces.shift()}`,\n+        ...(pieces.map((x, i) => `${x}${\"_\".repeat(i + 1)}`))\n+      ].join(\" \");\n+    }\n+    \/\/ simple scope\n+    return `${prefix}${name}`;\n+  };\n+\n+  \/** @type {Renderer} *\/\n+  class HTMLRenderer {\n+    \/**\n+     * Creates a new HTMLRenderer\n+     *\n+     * @param {Tree} parseTree - the parse tree (must support `walk` API)\n+     * @param {{classPrefix: string}} options\n+     *\/\n+    constructor(parseTree, options) {\n+      this.buffer = \"\";\n+      this.classPrefix = options.classPrefix;\n+      parseTree.walk(this);\n+    }\n+\n+    \/**\n+     * Adds texts to the output stream\n+     *\n+     * @param {string} text *\/\n+    addText(text) {\n+      this.buffer += escapeHTML(text);\n+    }\n+\n+    \/**\n+     * Adds a node open to the output stream (if needed)\n+     *\n+     * @param {Node} node *\/\n+    openNode(node) {\n+      if (!emitsWrappingTags(node)) return;\n+\n+      const className = scopeToCSSClass(node.scope,\n+        { prefix: this.classPrefix });\n+      this.span(className);\n+    }\n+\n+    \/**\n+     * Adds a node close to the output stream (if needed)\n+     *\n+     * @param {Node} node *\/\n+    closeNode(node) {\n+      if (!emitsWrappingTags(node)) return;\n+\n+      this.buffer += SPAN_CLOSE;\n+    }\n+\n+    \/**\n+     * returns the accumulated buffer\n+    *\/\n+    value() {\n+      return this.buffer;\n+    }\n+\n+    \/\/ helpers\n+\n+    \/**\n+     * Builds a span element\n+     *\n+     * @param {string} className *\/\n+    span(className) {\n+      this.buffer += `<span class=\"${className}\">`;\n+    }\n+  }\n+\n+  \/** @typedef {{scope?: string, language?: string, children: Node[]} | string} Node *\/\n+  \/** @typedef {{scope?: string, language?: string, children: Node[]} } DataNode *\/\n+  \/** @typedef {import('highlight.js').Emitter} Emitter *\/\n+  \/**  *\/\n+\n+  \/** @returns {DataNode} *\/\n+  const newNode = (opts = {}) => {\n+    \/** @type DataNode *\/\n+    const result = { children: [] };\n+    Object.assign(result, opts);\n+    return result;\n+  };\n+\n+  class TokenTree {\n+    constructor() {\n+      \/** @type DataNode *\/\n+      this.rootNode = newNode();\n+      this.stack = [this.rootNode];\n+    }\n+\n+    get top() {\n+      return this.stack[this.stack.length - 1];\n+    }\n+\n+    get root() { return this.rootNode; }\n+\n+    \/** @param {Node} node *\/\n+    add(node) {\n+      this.top.children.push(node);\n+    }\n+\n+    \/** @param {string} scope *\/\n+    openNode(scope) {\n+      \/** @type Node *\/\n+      const node = newNode({ scope });\n+      this.add(node);\n+      this.stack.push(node);\n+    }\n+\n+    closeNode() {\n+      if (this.stack.length > 1) {\n+        return this.stack.pop();\n+      }\n+      \/\/ eslint-disable-next-line no-undefined\n+      return undefined;\n+    }\n+\n+    closeAllNodes() {\n+      while (this.closeNode());\n+    }\n+\n+    toJSON() {\n+      return JSON.stringify(this.rootNode, null, 4);\n+    }\n+\n+    \/**\n+     * @typedef { import(\".\/html_renderer\").Renderer } Renderer\n+     * @param {Renderer} builder\n+     *\/\n+    walk(builder) {\n+      \/\/ this does not\n+      return this.constructor._walk(builder, this.rootNode);\n+      \/\/ this works\n+      \/\/ return TokenTree._walk(builder, this.rootNode);\n+    }\n+\n+    \/**\n+     * @param {Renderer} builder\n+     * @param {Node} node\n+     *\/\n+    static _walk(builder, node) {\n+      if (typeof node === \"string\") {\n+        builder.addText(node);\n+      } else if (node.children) {\n+        builder.openNode(node);\n+        node.children.forEach((child) => this._walk(builder, child));\n+        builder.closeNode(node);\n+      }\n+      return builder;\n+    }\n+\n+    \/**\n+     * @param {Node} node\n+     *\/\n+    static _collapse(node) {\n+      if (typeof node === \"string\") return;\n+      if (!node.children) return;\n+\n+      if (node.children.every(el => typeof el === \"string\")) {\n+        \/\/ node.text = node.children.join(\"\");\n+        \/\/ delete node.children;\n+        node.children = [node.children.join(\"\")];\n+      } else {\n+        node.children.forEach((child) => {\n+          TokenTree._collapse(child);\n+        });\n+      }\n+    }\n+  }\n+\n+  \/**\n+    Currently this is all private API, but this is the minimal API necessary\n+    that an Emitter must implement to fully support the parser.\n+\n+    Minimal interface:\n+\n+    - addText(text)\n+    - __addSublanguage(emitter, subLanguageName)\n+    - startScope(scope)\n+    - endScope()\n+    - finalize()\n+    - toHTML()\n+\n+  *\/\n+\n+  \/**\n+   * @implements {Emitter}\n+   *\/\n+  class TokenTreeEmitter extends TokenTree {\n+    \/**\n+     * @param {*} options\n+     *\/\n+    constructor(options) {\n+      super();\n+      this.options = options;\n+    }\n+\n+    \/**\n+     * @param {string} text\n+     *\/\n+    addText(text) {\n+      if (text === \"\") { return; }\n+\n+      this.add(text);\n+    }\n+\n+    \/** @param {string} scope *\/\n+    startScope(scope) {\n+      this.openNode(scope);\n+    }\n+\n+    endScope() {\n+      this.closeNode();\n+    }\n+\n+    \/**\n+     * @param {Emitter & {root: DataNode}} emitter\n+     * @param {string} name\n+     *\/\n+    __addSublanguage(emitter, name) {\n+      \/** @type DataNode *\/\n+      const node = emitter.root;\n+      if (name) node.scope = `language:${name}`;\n+\n+      this.add(node);\n+    }\n+\n+    toHTML() {\n+      const renderer = new HTMLRenderer(this, this.options);\n+      return renderer.value();\n+    }\n+\n+    finalize() {\n+      this.closeAllNodes();\n+      return true;\n+    }\n+  }\n+\n+  \/**\n+   * @param {string} value\n+   * @returns {RegExp}\n+   * *\/\n+\n+  \/**\n+   * @param {RegExp | string } re\n+   * @returns {string}\n+   *\/\n+  function source(re) {\n+    if (!re) return null;\n+    if (typeof re === \"string\") return re;\n+\n+    return re.source;\n+  }\n+\n+  \/**\n+   * @param {RegExp | string } re\n+   * @returns {string}\n+   *\/\n+  function lookahead(re) {\n+    return concat('(?=', re, ')');\n+  }\n+\n+  \/**\n+   * @param {RegExp | string } re\n+   * @returns {string}\n+   *\/\n+  function anyNumberOfTimes(re) {\n+    return concat('(?:', re, ')*');\n+  }\n+\n+  \/**\n+   * @param {RegExp | string } re\n+   * @returns {string}\n+   *\/\n+  function optional(re) {\n+    return concat('(?:', re, ')?');\n+  }\n+\n+  \/**\n+   * @param {...(RegExp | string) } args\n+   * @returns {string}\n+   *\/\n+  function concat(...args) {\n+    const joined = args.map((x) => source(x)).join(\"\");\n+    return joined;\n+  }\n+\n+  \/**\n+   * @param { Array<string | RegExp | Object> } args\n+   * @returns {object}\n+   *\/\n+  function stripOptionsFromArgs(args) {\n+    const opts = args[args.length - 1];\n+\n+    if (typeof opts === 'object' && opts.constructor === Object) {\n+      args.splice(args.length - 1, 1);\n+      return opts;\n+    } else {\n+      return {};\n+    }\n+  }\n+\n+  \/** @typedef { {capture?: boolean} } RegexEitherOptions *\/\n+\n+  \/**\n+   * Any of the passed expresssions may match\n+   *\n+   * Creates a huge this | this | that | that match\n+   * @param {(RegExp | string)[] | [...(RegExp | string)[], RegexEitherOptions]} args\n+   * @returns {string}\n+   *\/\n+  function either(...args) {\n+    \/** @type { object & {capture?: boolean} }  *\/\n+    const opts = stripOptionsFromArgs(args);\n+    const joined = '('\n+      + (opts.capture ? \"\" : \"?:\")\n+      + args.map((x) => source(x)).join(\"|\") + \")\";\n+    return joined;\n+  }\n+\n+  \/**\n+   * @param {RegExp | string} re\n+   * @returns {number}\n+   *\/\n+  function countMatchGroups(re) {\n+    return (new RegExp(re.toString() + '|')).exec('').length - 1;\n+  }\n+\n+  \/**\n+   * Does lexeme start with a regular expression match at the beginning\n+   * @param {RegExp} re\n+   * @param {string} lexeme\n+   *\/\n+  function startsWith(re, lexeme) {\n+    const match = re && re.exec(lexeme);\n+    return match && match.index === 0;\n+  }\n+\n+  \/\/ BACKREF_RE matches an open parenthesis or backreference. To avoid\n+  \/\/ an incorrect parse, it additionally matches the following:\n+  \/\/ - [...] elements, where the meaning of parentheses and escapes change\n+  \/\/ - other escape sequences, so we do not misparse escape sequences as\n+  \/\/   interesting elements\n+  \/\/ - non-matching or lookahead parentheses, which do not capture. These\n+  \/\/   follow the '(' with a '?'.\n+  const BACKREF_RE = \/\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\.\/;\n+\n+  \/\/ **INTERNAL** Not intended for outside usage\n+  \/\/ join logically computes regexps.join(separator), but fixes the\n+  \/\/ backreferences so they continue to match.\n+  \/\/ it also places each individual regular expression into it's own\n+  \/\/ match group, keeping track of the sequencing of those match groups\n+  \/\/ is currently an exercise for the caller. :-)\n+  \/**\n+   * @param {(string | RegExp)[]} regexps\n+   * @param {{joinWith: string}} opts\n+   * @returns {string}\n+   *\/\n+  function _rewriteBackreferences(regexps, { joinWith }) {\n+    let numCaptures = 0;\n+\n+    return regexps.map((regex) => {\n+      numCaptures += 1;\n+      const offset = numCaptures;\n+      let re = source(regex);\n+      let out = '';\n+\n+      while (re.length > 0) {\n+        const match = BACKREF_RE.exec(re);\n+        if (!match) {\n+          out += re;\n+          break;\n+        }\n+        out += re.substring(0, match.index);\n+        re = re.substring(match.index + match[0].length);\n+        if (match[0][0] === '\\\\' && match[1]) {\n+          \/\/ Adjust the backreference.\n+          out += '\\\\' + String(Number(match[1]) + offset);\n+        } else {\n+          out += match[0];\n+          if (match[0] === '(') {\n+            numCaptures++;\n+          }\n+        }\n+      }\n+      return out;\n+    }).map(re => `(${re})`).join(joinWith);\n+  }\n+\n+  \/** @typedef {import('highlight.js').Mode} Mode *\/\n+  \/** @typedef {import('highlight.js').ModeCallback} ModeCallback *\/\n+\n+  \/\/ Common regexps\n+  const MATCH_NOTHING_RE = \/\\b\\B\/;\n+  const IDENT_RE = '[a-zA-Z]\\\\w*';\n+  const UNDERSCORE_IDENT_RE = '[a-zA-Z_]\\\\w*';\n+  const NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\n+  const C_NUMBER_RE = '(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; \/\/ 0x..., 0..., decimal, float\n+  const BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; \/\/ 0b...\n+  const RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|\/=|\/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\n+\n+  \/**\n+  * @param { Partial<Mode> & {binary?: string | RegExp} } opts\n+  *\/\n+  const SHEBANG = (opts = {}) => {\n+    const beginShebang = \/^#![ ]*\\\/\/;\n+    if (opts.binary) {\n+      opts.begin = concat(\n+        beginShebang,\n+        \/.*\\b\/,\n+        opts.binary,\n+        \/\\b.*\/);\n+    }\n+    return inherit$1({\n+      scope: 'meta',\n+      begin: beginShebang,\n+      end: \/$\/,\n+      relevance: 0,\n+      \/** @type {ModeCallback} *\/\n+      \"on:begin\": (m, resp) => {\n+        if (m.index !== 0) resp.ignoreMatch();\n+      }\n+    }, opts);\n+  };\n+\n+  \/\/ Common modes\n+  const BACKSLASH_ESCAPE = {\n+    begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\n+  };\n+  const APOS_STRING_MODE = {\n+    scope: 'string',\n+    begin: '\\'',\n+    end: '\\'',\n+    illegal: '\\\\n',\n+    contains: [BACKSLASH_ESCAPE]\n+  };\n+  const QUOTE_STRING_MODE = {\n+    scope: 'string',\n+    begin: '\"',\n+    end: '\"',\n+    illegal: '\\\\n',\n+    contains: [BACKSLASH_ESCAPE]\n+  };\n+  const PHRASAL_WORDS_MODE = {\n+    begin: \/\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b\/\n+  };\n+  \/**\n+   * Creates a comment mode\n+   *\n+   * @param {string | RegExp} begin\n+   * @param {string | RegExp} end\n+   * @param {Mode | {}} [modeOptions]\n+   * @returns {Partial<Mode>}\n+   *\/\n+  const COMMENT = function(begin, end, modeOptions = {}) {\n+    const mode = inherit$1(\n+      {\n+        scope: 'comment',\n+        begin,\n+        end,\n+        contains: []\n+      },\n+      modeOptions\n+    );\n+    mode.contains.push({\n+      scope: 'doctag',\n+      \/\/ hack to avoid the space from being included. the space is necessary to\n+      \/\/ match here to prevent the plain text rule below from gobbling up doctags\n+      begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',\n+      end: \/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):\/,\n+      excludeBegin: true,\n+      relevance: 0\n+    });\n+    const ENGLISH_WORD = either(\n+      \/\/ list of common 1 and 2 letter words in English\n+      \"I\",\n+      \"a\",\n+      \"is\",\n+      \"so\",\n+      \"us\",\n+      \"to\",\n+      \"at\",\n+      \"if\",\n+      \"in\",\n+      \"it\",\n+      \"on\",\n+      \/\/ note: this is not an exhaustive list of contractions, just popular ones\n+      \/[A-Za-z]+['](d|ve|re|ll|t|s|n)\/, \/\/ contractions - can't we'd they're let's, etc\n+      \/[A-Za-z]+[-][a-z]+\/, \/\/ `no-way`, etc.\n+      \/[A-Za-z][a-z]{2,}\/ \/\/ allow capitalized words at beginning of sentences\n+    );\n+    \/\/ looking like plain text, more likely to be a comment\n+    mode.contains.push(\n+      {\n+        \/\/ TODO: how to include \", (, ) without breaking grammars that use these for\n+        \/\/ comment delimiters?\n+        \/\/ begin: \/[ ]+([()\"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()\":]?([.][ ]|[ ]|\\))){3}\/\n+        \/\/ ---\n+\n+        \/\/ this tries to find sequences of 3 english words in a row (without any\n+        \/\/ \"programming\" type syntax) this gives us a strong signal that we've\n+        \/\/ TRULY found a comment - vs perhaps scanning with the wrong language.\n+        \/\/ It's possible to find something that LOOKS like the start of the\n+        \/\/ comment - but then if there is no readable text - good chance it is a\n+        \/\/ false match and not a comment.\n+        \/\/\n+        \/\/ for a visual example please see:\n+        \/\/ https:\/\/github.com\/highlightjs\/highlight.js\/issues\/2827\n+\n+        begin: concat(\n+          \/[ ]+\/, \/\/ necessary to prevent us gobbling up doctags like \/* @author Bob Mcgill *\/\n+          '(',\n+          ENGLISH_WORD,\n+          \/[.]?[:]?([.][ ]|[ ])\/,\n+          '){3}') \/\/ look for 3 words in a row\n+      }\n+    );\n+    return mode;\n+  };\n+  const C_LINE_COMMENT_MODE = COMMENT('\/\/', '$');\n+  const C_BLOCK_COMMENT_MODE = COMMENT('\/\\\\*', '\\\\*\/');\n+  const HASH_COMMENT_MODE = COMMENT('#', '$');\n+  const NUMBER_MODE = {\n+    scope: 'number',\n+    begin: NUMBER_RE,\n+    relevance: 0\n+  };\n+  const C_NUMBER_MODE = {\n+    scope: 'number',\n+    begin: C_NUMBER_RE,\n+    relevance: 0\n+  };\n+  const BINARY_NUMBER_MODE = {\n+    scope: 'number',\n+    begin: BINARY_NUMBER_RE,\n+    relevance: 0\n+  };\n+  const REGEXP_MODE = {\n+    scope: \"regexp\",\n+    begin: \/\\\/(?=[^\/\\n]*\\\/)\/,\n+    end: \/\\\/[gimuy]*\/,\n+    contains: [\n+      BACKSLASH_ESCAPE,\n+      {\n+        begin: \/\\[\/,\n+        end: \/\\]\/,\n+        relevance: 0,\n+        contains: [BACKSLASH_ESCAPE]\n+      }\n+    ]\n+  };\n+  const TITLE_MODE = {\n+    scope: 'title',\n+    begin: IDENT_RE,\n+    relevance: 0\n+  };\n+  const UNDERSCORE_TITLE_MODE = {\n+    scope: 'title',\n+    begin: UNDERSCORE_IDENT_RE,\n+    relevance: 0\n+  };\n+  const METHOD_GUARD = {\n+    \/\/ excludes method names from keyword processing\n+    begin: '\\\\.\\\\s*' + UNDERSCORE_IDENT_RE,\n+    relevance: 0\n+  };\n+\n+  \/**\n+   * Adds end same as begin mechanics to a mode\n+   *\n+   * Your mode must include at least a single () match group as that first match\n+   * group is what is used for comparison\n+   * @param {Partial<Mode>} mode\n+   *\/\n+  const END_SAME_AS_BEGIN = function(mode) {\n+    return Object.assign(mode,\n+      {\n+        \/** @type {ModeCallback} *\/\n+        'on:begin': (m, resp) => { resp.data._beginMatch = m[1]; },\n+        \/** @type {ModeCallback} *\/\n+        'on:end': (m, resp) => { if (resp.data._beginMatch !== m[1]) resp.ignoreMatch(); }\n+      });\n+  };\n+\n+  var MODES = \/*#__PURE__*\/Object.freeze({\n+    __proto__: null,\n+    APOS_STRING_MODE: APOS_STRING_MODE,\n+    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,\n+    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,\n+    BINARY_NUMBER_RE: BINARY_NUMBER_RE,\n+    COMMENT: COMMENT,\n+    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,\n+    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,\n+    C_NUMBER_MODE: C_NUMBER_MODE,\n+    C_NUMBER_RE: C_NUMBER_RE,\n+    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN,\n+    HASH_COMMENT_MODE: HASH_COMMENT_MODE,\n+    IDENT_RE: IDENT_RE,\n+    MATCH_NOTHING_RE: MATCH_NOTHING_RE,\n+    METHOD_GUARD: METHOD_GUARD,\n+    NUMBER_MODE: NUMBER_MODE,\n+    NUMBER_RE: NUMBER_RE,\n+    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,\n+    QUOTE_STRING_MODE: QUOTE_STRING_MODE,\n+    REGEXP_MODE: REGEXP_MODE,\n+    RE_STARTERS_RE: RE_STARTERS_RE,\n+    SHEBANG: SHEBANG,\n+    TITLE_MODE: TITLE_MODE,\n+    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,\n+    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE\n+  });\n+\n+  \/**\n+  @typedef {import('highlight.js').CallbackResponse} CallbackResponse\n+  @typedef {import('highlight.js').CompilerExt} CompilerExt\n+  *\/\n+\n+  \/\/ Grammar extensions \/ plugins\n+  \/\/ See: https:\/\/github.com\/highlightjs\/highlight.js\/issues\/2833\n+\n+  \/\/ Grammar extensions allow \"syntactic sugar\" to be added to the grammar modes\n+  \/\/ without requiring any underlying changes to the compiler internals.\n+\n+  \/\/ `compileMatch` being the perfect small example of now allowing a grammar\n+  \/\/ author to write `match` when they desire to match a single expression rather\n+  \/\/ than being forced to use `begin`.  The extension then just moves `match` into\n+  \/\/ `begin` when it runs.  Ie, no features have been added, but we've just made\n+  \/\/ the experience of writing (and reading grammars) a little bit nicer.\n+\n+  \/\/ ------\n+\n+  \/\/ TODO: We need negative look-behind support to do this properly\n+  \/**\n+   * Skip a match if it has a preceding dot\n+   *\n+   * This is used for `beginKeywords` to prevent matching expressions such as\n+   * `bob.keyword.do()`. The mode compiler automatically wires this up as a\n+   * special _internal_ 'on:begin' callback for modes with `beginKeywords`\n+   * @param {RegExpMatchArray} match\n+   * @param {CallbackResponse} response\n+   *\/\n+  function skipIfHasPrecedingDot(match, response) {\n+    const before = match.input[match.index - 1];\n+    if (before === \".\") {\n+      response.ignoreMatch();\n+    }\n+  }\n+\n+  \/**\n+   *\n+   * @type {CompilerExt}\n+   *\/\n+  function scopeClassName(mode, _parent) {\n+    \/\/ eslint-disable-next-line no-undefined\n+    if (mode.className !== undefined) {\n+      mode.scope = mode.className;\n+      delete mode.className;\n+    }\n+  }\n+\n+  \/**\n+   * `beginKeywords` syntactic sugar\n+   * @type {CompilerExt}\n+   *\/\n+  function beginKeywords(mode, parent) {\n+    if (!parent) return;\n+    if (!mode.beginKeywords) return;\n+\n+    \/\/ for languages with keywords that include non-word characters checking for\n+    \/\/ a word boundary is not sufficient, so instead we check for a word boundary\n+    \/\/ or whitespace - this does no harm in any case since our keyword engine\n+    \/\/ doesn't allow spaces in keywords anyways and we still check for the boundary\n+    \/\/ first\n+    mode.begin = '\\\\b(' + mode.beginKeywords.split(' ').join('|') + ')(?!\\\\.)(?=\\\\b|\\\\s)';\n+    mode.__beforeBegin = skipIfHasPrecedingDot;\n+    mode.keywords = mode.keywords || mode.beginKeywords;\n+    delete mode.beginKeywords;\n+\n+    \/\/ prevents double relevance, the keywords themselves provide\n+    \/\/ relevance, the mode doesn't need to double it\n+    \/\/ eslint-disable-next-line no-undefined\n+    if (mode.relevance === undefined) mode.relevance = 0;\n+  }\n+\n+  \/**\n+   * Allow `illegal` to contain an array of illegal values\n+   * @type {CompilerExt}\n+   *\/\n+  function compileIllegal(mode, _parent) {\n+    if (!Array.isArray(mode.illegal)) return;\n+\n+    mode.illegal = either(...mode.illegal);\n+  }\n+\n+  \/**\n+   * `match` to match a single expression for readability\n+   * @type {CompilerExt}\n+   *\/\n+  function compileMatch(mode, _parent) {\n+    if (!mode.match) return;\n+    if (mode.begin || mode.end) throw new Error(\"begin & end are not supported with match\");\n+\n+    mode.begin = mode.match;\n+    delete mode.match;\n+  }\n+\n+  \/**\n+   * provides the default 1 relevance to all modes\n+   * @type {CompilerExt}\n+   *\/\n+  function compileRelevance(mode, _parent) {\n+    \/\/ eslint-disable-next-line no-undefined\n+    if (mode.relevance === undefined) mode.relevance = 1;\n+  }\n+\n+  \/\/ allow beforeMatch to act as a \"qualifier\" for the match\n+  \/\/ the full match begin must be [beforeMatch][begin]\n+  const beforeMatchExt = (mode, parent) => {\n+    if (!mode.beforeMatch) return;\n+    \/\/ starts conflicts with endsParent which we need to make sure the child\n+    \/\/ rule is not matched multiple times\n+    if (mode.starts) throw new Error(\"beforeMatch cannot be used with starts\");\n+\n+    const originalMode = Object.assign({}, mode);\n+    Object.keys(mode).forEach((key) => { delete mode[key]; });\n+\n+    mode.keywords = originalMode.keywords;\n+    mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));\n+    mode.starts = {\n+      relevance: 0,\n+      contains: [\n+        Object.assign(originalMode, { endsParent: true })\n+      ]\n+    };\n+    mode.relevance = 0;\n+\n+    delete originalMode.beforeMatch;\n+  };\n+\n+  \/\/ keywords that should have no default relevance value\n+  const COMMON_KEYWORDS = [\n+    'of',\n+    'and',\n+    'for',\n+    'in',\n+    'not',\n+    'or',\n+    'if',\n+    'then',\n+    'parent', \/\/ common variable name\n+    'list', \/\/ common variable name\n+    'value' \/\/ common variable name\n+  ];\n+\n+  const DEFAULT_KEYWORD_SCOPE = \"keyword\";\n+\n+  \/**\n+   * Given raw keywords from a language definition, compile them.\n+   *\n+   * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords\n+   * @param {boolean} caseInsensitive\n+   *\/\n+  function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {\n+    \/** @type {import(\"highlight.js\/private\").KeywordDict} *\/\n+    const compiledKeywords = Object.create(null);\n+\n+    \/\/ input can be a string of keywords, an array of keywords, or a object with\n+    \/\/ named keys representing scopeName (which can then point to a string or array)\n+    if (typeof rawKeywords === 'string') {\n+      compileList(scopeName, rawKeywords.split(\" \"));\n+    } else if (Array.isArray(rawKeywords)) {\n+      compileList(scopeName, rawKeywords);\n+    } else {\n+      Object.keys(rawKeywords).forEach(function(scopeName) {\n+        \/\/ collapse all our objects back into the parent object\n+        Object.assign(\n+          compiledKeywords,\n+          compileKeywords(rawKeywords[scopeName], caseInsensitive, scopeName)\n+        );\n+      });\n+    }\n+    return compiledKeywords;\n+\n+    \/\/ ---\n+\n+    \/**\n+     * Compiles an individual list of keywords\n+     *\n+     * Ex: \"for if when while|5\"\n+     *\n+     * @param {string} scopeName\n+     * @param {Array<string>} keywordList\n+     *\/\n+    function compileList(scopeName, keywordList) {\n+      if (caseInsensitive) {\n+        keywordList = keywordList.map(x => x.toLowerCase());\n+      }\n+      keywordList.forEach(function(keyword) {\n+        const pair = keyword.split('|');\n+        compiledKeywords[pair[0]] = [scopeName, scoreForKeyword(pair[0], pair[1])];\n+      });\n+    }\n+  }\n+\n+  \/**\n+   * Returns the proper score for a given keyword\n+   *\n+   * Also takes into account comment keywords, which will be scored 0 UNLESS\n+   * another score has been manually assigned.\n+   * @param {string} keyword\n+   * @param {string} [providedScore]\n+   *\/\n+  function scoreForKeyword(keyword, providedScore) {\n+    \/\/ manual scores always win over common keywords\n+    \/\/ so you can force a score of 1 if you really insist\n+    if (providedScore) {\n+      return Number(providedScore);\n+    }\n+\n+    return commonKeyword(keyword) ? 0 : 1;\n+  }\n+\n+  \/**\n+   * Determines if a given keyword is common or not\n+   *\n+   * @param {string} keyword *\/\n+  function commonKeyword(keyword) {\n+    return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n+  }\n+\n+  \/*\n+\n+  For the reasoning behind this please see:\n+  https:\/\/github.com\/highlightjs\/highlight.js\/issues\/2880#issuecomment-747275419\n+\n+  *\/\n+\n+  \/**\n+   * @type {Record<string, boolean>}\n+   *\/\n+  const seenDeprecations = {};\n+\n+  \/**\n+   * @param {string} message\n+   *\/\n+  const error = (message) => {\n+    console.error(message);\n+  };\n+\n+  \/**\n+   * @param {string} message\n+   * @param {any} args\n+   *\/\n+  const warn = (message, ...args) => {\n+    console.log(`WARN: ${message}`, ...args);\n+  };\n+\n+  \/**\n+   * @param {string} version\n+   * @param {string} message\n+   *\/\n+  const deprecated = (version, message) => {\n+    if (seenDeprecations[`${version}\/${message}`]) return;\n+\n+    console.log(`Deprecated as of ${version}. ${message}`);\n+    seenDeprecations[`${version}\/${message}`] = true;\n+  };\n+\n+  \/* eslint-disable no-throw-literal *\/\n+\n+  \/**\n+  @typedef {import('highlight.js').CompiledMode} CompiledMode\n+  *\/\n+\n+  const MultiClassError = new Error();\n+\n+  \/**\n+   * Renumbers labeled scope names to account for additional inner match\n+   * groups that otherwise would break everything.\n+   *\n+   * Lets say we 3 match scopes:\n+   *\n+   *   { 1 => ..., 2 => ..., 3 => ... }\n+   *\n+   * So what we need is a clean match like this:\n+   *\n+   *   (a)(b)(c) => [ \"a\", \"b\", \"c\" ]\n+   *\n+   * But this falls apart with inner match groups:\n+   *\n+   * (a)(((b)))(c) => [\"a\", \"b\", \"b\", \"b\", \"c\" ]\n+   *\n+   * Our scopes are now \"out of alignment\" and we're repeating `b` 3 times.\n+   * What needs to happen is the numbers are remapped:\n+   *\n+   *   { 1 => ..., 2 => ..., 5 => ... }\n+   *\n+   * We also need to know that the ONLY groups that should be output\n+   * are 1, 2, and 5.  This function handles this behavior.\n+   *\n+   * @param {CompiledMode} mode\n+   * @param {Array<RegExp | string>} regexes\n+   * @param {{key: \"beginScope\"|\"endScope\"}} opts\n+   *\/\n+  function remapScopeNames(mode, regexes, { key }) {\n+    let offset = 0;\n+    const scopeNames = mode[key];\n+    \/** @type Record<number,boolean> *\/\n+    const emit = {};\n+    \/** @type Record<number,string> *\/\n+    const positions = {};\n+\n+    for (let i = 1; i <= regexes.length; i++) {\n+      positions[i + offset] = scopeNames[i];\n+      emit[i + offset] = true;\n+      offset += countMatchGroups(regexes[i - 1]);\n+    }\n+    \/\/ we use _emit to keep track of which match groups are \"top-level\" to avoid double\n+    \/\/ output from inside match groups\n+    mode[key] = positions;\n+    mode[key]._emit = emit;\n+    mode[key]._multi = true;\n+  }\n+\n+  \/**\n+   * @param {CompiledMode} mode\n+   *\/\n+  function beginMultiClass(mode) {\n+    if (!Array.isArray(mode.begin)) return;\n+\n+    if (mode.skip || mode.excludeBegin || mode.returnBegin) {\n+      error(\"skip, excludeBegin, returnBegin not compatible with beginScope: {}\");\n+      throw MultiClassError;\n+    }\n+\n+    if (typeof mode.beginScope !== \"object\" || mode.beginScope === null) {\n+      error(\"beginScope must be object\");\n+      throw MultiClassError;\n+    }\n+\n+    remapScopeNames(mode, mode.begin, { key: \"beginScope\" });\n+    mode.begin = _rewriteBackreferences(mode.begin, { joinWith: \"\" });\n+  }\n+\n+  \/**\n+   * @param {CompiledMode} mode\n+   *\/\n+  function endMultiClass(mode) {\n+    if (!Array.isArray(mode.end)) return;\n+\n+    if (mode.skip || mode.excludeEnd || mode.returnEnd) {\n+      error(\"skip, excludeEnd, returnEnd not compatible with endScope: {}\");\n+      throw MultiClassError;\n+    }\n+\n+    if (typeof mode.endScope !== \"object\" || mode.endScope === null) {\n+      error(\"endScope must be object\");\n+      throw MultiClassError;\n+    }\n+\n+    remapScopeNames(mode, mode.end, { key: \"endScope\" });\n+    mode.end = _rewriteBackreferences(mode.end, { joinWith: \"\" });\n+  }\n+\n+  \/**\n+   * this exists only to allow `scope: {}` to be used beside `match:`\n+   * Otherwise `beginScope` would necessary and that would look weird\n+\n+    {\n+      match: [ \/def\/, \/\\w+\/ ]\n+      scope: { 1: \"keyword\" , 2: \"title\" }\n+    }\n+\n+   * @param {CompiledMode} mode\n+   *\/\n+  function scopeSugar(mode) {\n+    if (mode.scope && typeof mode.scope === \"object\" && mode.scope !== null) {\n+      mode.beginScope = mode.scope;\n+      delete mode.scope;\n+    }\n+  }\n+\n+  \/**\n+   * @param {CompiledMode} mode\n+   *\/\n+  function MultiClass(mode) {\n+    scopeSugar(mode);\n+\n+    if (typeof mode.beginScope === \"string\") {\n+      mode.beginScope = { _wrap: mode.beginScope };\n+    }\n+    if (typeof mode.endScope === \"string\") {\n+      mode.endScope = { _wrap: mode.endScope };\n+    }\n+\n+    beginMultiClass(mode);\n+    endMultiClass(mode);\n+  }\n+\n+  \/**\n+  @typedef {import('highlight.js').Mode} Mode\n+  @typedef {import('highlight.js').CompiledMode} CompiledMode\n+  @typedef {import('highlight.js').Language} Language\n+  @typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n+  @typedef {import('highlight.js').CompiledLanguage} CompiledLanguage\n+  *\/\n+\n+  \/\/ compilation\n+\n+  \/**\n+   * Compiles a language definition result\n+   *\n+   * Given the raw result of a language definition (Language), compiles this so\n+   * that it is ready for highlighting code.\n+   * @param {Language} language\n+   * @returns {CompiledLanguage}\n+   *\/\n+  function compileLanguage(language) {\n+    \/**\n+     * Builds a regex with the case sensitivity of the current language\n+     *\n+     * @param {RegExp | string} value\n+     * @param {boolean} [global]\n+     *\/\n+    function langRe(value, global) {\n+      return new RegExp(\n+        source(value),\n+        'm'\n+        + (language.case_insensitive ? 'i' : '')\n+        + (language.unicodeRegex ? 'u' : '')\n+        + (global ? 'g' : '')\n+      );\n+    }\n+\n+    \/**\n+      Stores multiple regular expressions and allows you to quickly search for\n+      them all in a string simultaneously - returning the first match.  It does\n+      this by creating a huge (a|b|c) regex - each individual item wrapped with ()\n+      and joined by `|` - using match groups to track position.  When a match is\n+      found checking which position in the array has content allows us to figure\n+      out which of the original regexes \/ match groups triggered the match.\n+\n+      The match object itself (the result of `Regex.exec`) is returned but also\n+      enhanced by merging in any meta-data that was registered with the regex.\n+      This is how we keep track of which mode matched, and what type of rule\n+      (`illegal`, `begin`, end, etc).\n+    *\/\n+    class MultiRegex {\n+      constructor() {\n+        this.matchIndexes = {};\n+        \/\/ @ts-ignore\n+        this.regexes = [];\n+        this.matchAt = 1;\n+        this.position = 0;\n+      }\n+\n+      \/\/ @ts-ignore\n+      addRule(re, opts) {\n+        opts.position = this.position++;\n+        \/\/ @ts-ignore\n+        this.matchIndexes[this.matchAt] = opts;\n+        this.regexes.push([opts, re]);\n+        this.matchAt += countMatchGroups(re) + 1;\n+      }\n+\n+      compile() {\n+        if (this.regexes.length === 0) {\n+          \/\/ avoids the need to check length every time exec is called\n+          \/\/ @ts-ignore\n+          this.exec = () => null;\n+        }\n+        const terminators = this.regexes.map(el => el[1]);\n+        this.matcherRe = langRe(_rewriteBackreferences(terminators, { joinWith: '|' }), true);\n+        this.lastIndex = 0;\n+      }\n+\n+      \/** @param {string} s *\/\n+      exec(s) {\n+        this.matcherRe.lastIndex = this.lastIndex;\n+        const match = this.matcherRe.exec(s);\n+        if (!match) { return null; }\n+\n+        \/\/ eslint-disable-next-line no-undefined\n+        const i = match.findIndex((el, i) => i > 0 && el !== undefined);\n+        \/\/ @ts-ignore\n+        const matchData = this.matchIndexes[i];\n+        \/\/ trim off any earlier non-relevant match groups (ie, the other regex\n+        \/\/ match groups that make up the multi-matcher)\n+        match.splice(0, i);\n+\n+        return Object.assign(match, matchData);\n+      }\n+    }\n+\n+    \/*\n+      Created to solve the key deficiently with MultiRegex - there is no way to\n+      test for multiple matches at a single location.  Why would we need to do\n+      that?  In the future a more dynamic engine will allow certain matches to be\n+      ignored.  An example: if we matched say the 3rd regex in a large group but\n+      decided to ignore it - we'd need to started testing again at the 4th\n+      regex... but MultiRegex itself gives us no real way to do that.\n+\n+      So what this class creates MultiRegexs on the fly for whatever search\n+      position they are needed.\n+\n+      NOTE: These additional MultiRegex objects are created dynamically.  For most\n+      grammars most of the time we will never actually need anything more than the\n+      first MultiRegex - so this shouldn't have too much overhead.\n+\n+      Say this is our search group, and we match regex3, but wish to ignore it.\n+\n+        regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0\n+\n+      What we need is a new MultiRegex that only includes the remaining\n+      possibilities:\n+\n+        regex4 | regex5                               ' ie, startAt = 3\n+\n+      This class wraps all that complexity up in a simple API... `startAt` decides\n+      where in the array of expressions to start doing the matching. It\n+      auto-increments, so if a match is found at position 2, then startAt will be\n+      set to 3.  If the end is reached startAt will return to 0.\n+\n+      MOST of the time the parser will be setting startAt manually to 0.\n+    *\/\n+    class ResumableMultiRegex {\n+      constructor() {\n+        \/\/ @ts-ignore\n+        this.rules = [];\n+        \/\/ @ts-ignore\n+        this.multiRegexes = [];\n+        this.count = 0;\n+\n+        this.lastIndex = 0;\n+        this.regexIndex = 0;\n+      }\n+\n+      \/\/ @ts-ignore\n+      getMatcher(index) {\n+        if (this.multiRegexes[index]) return this.multiRegexes[index];\n+\n+        const matcher = new MultiRegex();\n+        this.rules.slice(index).forEach(([re, opts]) => matcher.addRule(re, opts));\n+        matcher.compile();\n+        this.multiRegexes[index] = matcher;\n+        return matcher;\n+      }\n+\n+      resumingScanAtSamePosition() {\n+        return this.regexIndex !== 0;\n+      }\n+\n+      considerAll() {\n+        this.regexIndex = 0;\n+      }\n+\n+      \/\/ @ts-ignore\n+      addRule(re, opts) {\n+        this.rules.push([re, opts]);\n+        if (opts.type === \"begin\") this.count++;\n+      }\n+\n+      \/** @param {string} s *\/\n+      exec(s) {\n+        const m = this.getMatcher(this.regexIndex);\n+        m.lastIndex = this.lastIndex;\n+        let result = m.exec(s);\n+\n+        \/\/ The following is because we have no easy way to say \"resume scanning at the\n+        \/\/ existing position but also skip the current rule ONLY\". What happens is\n+        \/\/ all prior rules are also skipped which can result in matching the wrong\n+        \/\/ thing. Example of matching \"booger\":\n+\n+        \/\/ our matcher is [string, \"booger\", number]\n+        \/\/\n+        \/\/ ....booger....\n+\n+        \/\/ if \"booger\" is ignored then we'd really need a regex to scan from the\n+        \/\/ SAME position for only: [string, number] but ignoring \"booger\" (if it\n+        \/\/ was the first match), a simple resume would scan ahead who knows how\n+        \/\/ far looking only for \"number\", ignoring potential string matches (or\n+        \/\/ future \"booger\" matches that might be valid.)\n+\n+        \/\/ So what we do: We execute two matchers, one resuming at the same\n+        \/\/ position, but the second full matcher starting at the position after:\n+\n+        \/\/     \/--- resume first regex match here (for [number])\n+        \/\/     |\/---- full match here for [string, \"booger\", number]\n+        \/\/     vv\n+        \/\/ ....booger....\n+\n+        \/\/ Which ever results in a match first is then used. So this 3-4 step\n+        \/\/ process essentially allows us to say \"match at this position, excluding\n+        \/\/ a prior rule that was ignored\".\n+        \/\/\n+        \/\/ 1. Match \"booger\" first, ignore. Also proves that [string] does non match.\n+        \/\/ 2. Resume matching for [number]\n+        \/\/ 3. Match at index + 1 for [string, \"booger\", number]\n+        \/\/ 4. If #2 and #3 result in matches, which came first?\n+        if (this.resumingScanAtSamePosition()) {\n+          if (result && result.index === this.lastIndex) ; else { \/\/ use the second matcher result\n+            const m2 = this.getMatcher(0);\n+            m2.lastIndex = this.lastIndex + 1;\n+            result = m2.exec(s);\n+          }\n+        }\n+\n+        if (result) {\n+          this.regexIndex += result.position + 1;\n+          if (this.regexIndex === this.count) {\n+            \/\/ wrap-around to considering all matches again\n+            this.considerAll();\n+          }\n+        }\n+\n+        return result;\n+      }\n+    }\n+\n+    \/**\n+     * Given a mode, builds a huge ResumableMultiRegex that can be used to walk\n+     * the content and find matches.\n+     *\n+     * @param {CompiledMode} mode\n+     * @returns {ResumableMultiRegex}\n+     *\/\n+    function buildModeRegex(mode) {\n+      const mm = new ResumableMultiRegex();\n+\n+      mode.contains.forEach(term => mm.addRule(term.begin, { rule: term, type: \"begin\" }));\n+\n+      if (mode.terminatorEnd) {\n+        mm.addRule(mode.terminatorEnd, { type: \"end\" });\n+      }\n+      if (mode.illegal) {\n+        mm.addRule(mode.illegal, { type: \"illegal\" });\n+      }\n+\n+      return mm;\n+    }\n+\n+    \/** skip vs abort vs ignore\n+     *\n+     * @skip   - The mode is still entered and exited normally (and contains rules apply),\n+     *           but all content is held and added to the parent buffer rather than being\n+     *           output when the mode ends.  Mostly used with `sublanguage` to build up\n+     *           a single large buffer than can be parsed by sublanguage.\n+     *\n+     *             - The mode begin ands ends normally.\n+     *             - Content matched is added to the parent mode buffer.\n+     *             - The parser cursor is moved forward normally.\n+     *\n+     * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it\n+     *           never matched) but DOES NOT continue to match subsequent `contains`\n+     *           modes.  Abort is bad\/suboptimal because it can result in modes\n+     *           farther down not getting applied because an earlier rule eats the\n+     *           content but then aborts.\n+     *\n+     *             - The mode does not begin.\n+     *             - Content matched by `begin` is added to the mode buffer.\n+     *             - The parser cursor is moved forward accordingly.\n+     *\n+     * @ignore - Ignores the mode (as if it never matched) and continues to match any\n+     *           subsequent `contains` modes.  Ignore isn't technically possible with\n+     *           the current parser implementation.\n+     *\n+     *             - The mode does not begin.\n+     *             - Content matched by `begin` is ignored.\n+     *             - The parser cursor is not moved forward.\n+     *\/\n+\n+    \/**\n+     * Compiles an individual mode\n+     *\n+     * This can raise an error if the mode contains certain detectable known logic\n+     * issues.\n+     * @param {Mode} mode\n+     * @param {CompiledMode | null} [parent]\n+     * @returns {CompiledMode | never}\n+     *\/\n+    function compileMode(mode, parent) {\n+      const cmode = \/** @type CompiledMode *\/ (mode);\n+      if (mode.isCompiled) return cmode;\n+\n+      [\n+        scopeClassName,\n+        \/\/ do this early so compiler extensions generally don't have to worry about\n+        \/\/ the distinction between match\/begin\n+        compileMatch,\n+        MultiClass,\n+        beforeMatchExt\n+      ].forEach(ext => ext(mode, parent));\n+\n+      language.compilerExtensions.forEach(ext => ext(mode, parent));\n+\n+      \/\/ __beforeBegin is considered private API, internal use only\n+      mode.__beforeBegin = null;\n+\n+      [\n+        beginKeywords,\n+        \/\/ do this later so compiler extensions that come earlier have access to the\n+        \/\/ raw array if they wanted to perhaps manipulate it, etc.\n+        compileIllegal,\n+        \/\/ default to 1 relevance if not specified\n+        compileRelevance\n+      ].forEach(ext => ext(mode, parent));\n+\n+      mode.isCompiled = true;\n+\n+      let keywordPattern = null;\n+      if (typeof mode.keywords === \"object\" && mode.keywords.$pattern) {\n+        \/\/ we need a copy because keywords might be compiled multiple times\n+        \/\/ so we can't go deleting $pattern from the original on the first\n+        \/\/ pass\n+        mode.keywords = Object.assign({}, mode.keywords);\n+        keywordPattern = mode.keywords.$pattern;\n+        delete mode.keywords.$pattern;\n+      }\n+      keywordPattern = keywordPattern || \/\\w+\/;\n+\n+      if (mode.keywords) {\n+        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n+      }\n+\n+      cmode.keywordPatternRe = langRe(keywordPattern, true);\n+\n+      if (parent) {\n+        if (!mode.begin) mode.begin = \/\\B|\\b\/;\n+        cmode.beginRe = langRe(cmode.begin);\n+        if (!mode.end && !mode.endsWithParent) mode.end = \/\\B|\\b\/;\n+        if (mode.end) cmode.endRe = langRe(cmode.end);\n+        cmode.terminatorEnd = source(cmode.end) || '';\n+        if (mode.endsWithParent && parent.terminatorEnd) {\n+          cmode.terminatorEnd += (mode.end ? '|' : '') + parent.terminatorEnd;\n+        }\n+      }\n+      if (mode.illegal) cmode.illegalRe = langRe(\/** @type {RegExp | string} *\/ (mode.illegal));\n+      if (!mode.contains) mode.contains = [];\n+\n+      mode.contains = [].concat(...mode.contains.map(function(c) {\n+        return expandOrCloneMode(c === 'self' ? mode : c);\n+      }));\n+      mode.contains.forEach(function(c) { compileMode(\/** @type Mode *\/ (c), cmode); });\n+\n+      if (mode.starts) {\n+        compileMode(mode.starts, parent);\n+      }\n+\n+      cmode.matcher = buildModeRegex(cmode);\n+      return cmode;\n+    }\n+\n+    if (!language.compilerExtensions) language.compilerExtensions = [];\n+\n+    \/\/ self is not valid at the top-level\n+    if (language.contains && language.contains.includes('self')) {\n+      throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n+    }\n+\n+    \/\/ we need a null object, which inherit will guarantee\n+    language.classNameAliases = inherit$1(language.classNameAliases || {});\n+\n+    return compileMode(\/** @type Mode *\/ (language));\n+  }\n+\n+  \/**\n+   * Determines if a mode has a dependency on it's parent or not\n+   *\n+   * If a mode does have a parent dependency then often we need to clone it if\n+   * it's used in multiple places so that each copy points to the correct parent,\n+   * where-as modes without a parent can often safely be re-used at the bottom of\n+   * a mode chain.\n+   *\n+   * @param {Mode | null} mode\n+   * @returns {boolean} - is there a dependency on the parent?\n+   * *\/\n+  function dependencyOnParent(mode) {\n+    if (!mode) return false;\n+\n+    return mode.endsWithParent || dependencyOnParent(mode.starts);\n+  }\n+\n+  \/**\n+   * Expands a mode or clones it if necessary\n+   *\n+   * This is necessary for modes with parental dependenceis (see notes on\n+   * `dependencyOnParent`) and for nodes that have `variants` - which must then be\n+   * exploded into their own individual modes at compile time.\n+   *\n+   * @param {Mode} mode\n+   * @returns {Mode | Mode[]}\n+   * *\/\n+  function expandOrCloneMode(mode) {\n+    if (mode.variants && !mode.cachedVariants) {\n+      mode.cachedVariants = mode.variants.map(function(variant) {\n+        return inherit$1(mode, { variants: null }, variant);\n+      });\n+    }\n+\n+    \/\/ EXPAND\n+    \/\/ if we have variants then essentially \"replace\" the mode with the variants\n+    \/\/ this happens in compileMode, where this function is called from\n+    if (mode.cachedVariants) {\n+      return mode.cachedVariants;\n+    }\n+\n+    \/\/ CLONE\n+    \/\/ if we have dependencies on parents then we need a unique\n+    \/\/ instance of ourselves, so we can be reused with many\n+    \/\/ different parents without issue\n+    if (dependencyOnParent(mode)) {\n+      return inherit$1(mode, { starts: mode.starts ? inherit$1(mode.starts) : null });\n+    }\n+\n+    if (Object.isFrozen(mode)) {\n+      return inherit$1(mode);\n+    }\n+\n+    \/\/ no special dependency issues, just return ourselves\n+    return mode;\n+  }\n+\n+  var version = \"11.11.1\";\n+\n+  class HTMLInjectionError extends Error {\n+    constructor(reason, html) {\n+      super(reason);\n+      this.name = \"HTMLInjectionError\";\n+      this.html = html;\n+    }\n+  }\n+\n+  \/*\n+  Syntax highlighting with language autodetection.\n+  https:\/\/highlightjs.org\/\n+  *\/\n+\n+\n+\n+  \/**\n+  @typedef {import('highlight.js').Mode} Mode\n+  @typedef {import('highlight.js').CompiledMode} CompiledMode\n+  @typedef {import('highlight.js').CompiledScope} CompiledScope\n+  @typedef {import('highlight.js').Language} Language\n+  @typedef {import('highlight.js').HLJSApi} HLJSApi\n+  @typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n+  @typedef {import('highlight.js').PluginEvent} PluginEvent\n+  @typedef {import('highlight.js').HLJSOptions} HLJSOptions\n+  @typedef {import('highlight.js').LanguageFn} LanguageFn\n+  @typedef {import('highlight.js').HighlightedHTMLElement} HighlightedHTMLElement\n+  @typedef {import('highlight.js').BeforeHighlightContext} BeforeHighlightContext\n+  @typedef {import('highlight.js\/private').MatchType} MatchType\n+  @typedef {import('highlight.js\/private').KeywordData} KeywordData\n+  @typedef {import('highlight.js\/private').EnhancedMatch} EnhancedMatch\n+  @typedef {import('highlight.js\/private').AnnotatedError} AnnotatedError\n+  @typedef {import('highlight.js').AutoHighlightResult} AutoHighlightResult\n+  @typedef {import('highlight.js').HighlightOptions} HighlightOptions\n+  @typedef {import('highlight.js').HighlightResult} HighlightResult\n+  *\/\n+\n+\n+  const escape = escapeHTML;\n+  const inherit = inherit$1;\n+  const NO_MATCH = Symbol(\"nomatch\");\n+  const MAX_KEYWORD_HITS = 7;\n+\n+  \/**\n+   * @param {any} hljs - object that is extended (legacy)\n+   * @returns {HLJSApi}\n+   *\/\n+  const HLJS = function(hljs) {\n+    \/\/ Global internal variables used within the highlight.js library.\n+    \/** @type {Record<string, Language>} *\/\n+    const languages = Object.create(null);\n+    \/** @type {Record<string, string>} *\/\n+    const aliases = Object.create(null);\n+    \/** @type {HLJSPlugin[]} *\/\n+    const plugins = [];\n+\n+    \/\/ safe\/production mode - swallows more errors, tries to keep running\n+    \/\/ even if a single syntax or parse hits a fatal error\n+    let SAFE_MODE = true;\n+    const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load\/include a language module?\";\n+    \/** @type {Language} *\/\n+    const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: 'Plain text', contains: [] };\n+\n+    \/\/ Global options used when within external APIs. This is modified when\n+    \/\/ calling the `hljs.configure` function.\n+    \/** @type HLJSOptions *\/\n+    let options = {\n+      ignoreUnescapedHTML: false,\n+      throwUnescapedHTML: false,\n+      noHighlightRe: \/^(no-?highlight)$\/i,\n+      languageDetectRe: \/\\blang(?:uage)?-([\\w-]+)\\b\/i,\n+      classPrefix: 'hljs-',\n+      cssSelector: 'pre code',\n+      languages: null,\n+      \/\/ beta configuration options, subject to change, welcome to discuss\n+      \/\/ https:\/\/github.com\/highlightjs\/highlight.js\/issues\/1086\n+      __emitter: TokenTreeEmitter\n+    };\n+\n+    \/* Utility functions *\/\n+\n+    \/**\n+     * Tests a language name to see if highlighting should be skipped\n+     * @param {string} languageName\n+     *\/\n+    function shouldNotHighlight(languageName) {\n+      return options.noHighlightRe.test(languageName);\n+    }\n+\n+    \/**\n+     * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n+     *\/\n+    function blockLanguage(block) {\n+      let classes = block.className + ' ';\n+\n+      classes += block.parentNode ? block.parentNode.className : '';\n+\n+      \/\/ language-* takes precedence over non-prefixed class names.\n+      const match = options.languageDetectRe.exec(classes);\n+      if (match) {\n+        const language = getLanguage(match[1]);\n+        if (!language) {\n+          warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n+          warn(\"Falling back to no-highlight mode for this block.\", block);\n+        }\n+        return language ? match[1] : 'no-highlight';\n+      }\n+\n+      return classes\n+        .split(\/\\s+\/)\n+        .find((_class) => shouldNotHighlight(_class) || getLanguage(_class));\n+    }\n+\n+    \/**\n+     * Core highlighting function.\n+     *\n+     * OLD API\n+     * highlight(lang, code, ignoreIllegals, continuation)\n+     *\n+     * NEW API\n+     * highlight(code, {lang, ignoreIllegals})\n+     *\n+     * @param {string} codeOrLanguageName - the language to use for highlighting\n+     * @param {string | HighlightOptions} optionsOrCode - the code to highlight\n+     * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n+     *\n+     * @returns {HighlightResult} Result - an object that represents the result\n+     * @property {string} language - the language name\n+     * @property {number} relevance - the relevance score\n+     * @property {string} value - the highlighted HTML code\n+     * @property {string} code - the original raw code\n+     * @property {CompiledMode} top - top of the current mode stack\n+     * @property {boolean} illegal - indicates whether any illegal matches were found\n+    *\/\n+    function highlight(codeOrLanguageName, optionsOrCode, ignoreIllegals) {\n+      let code = \"\";\n+      let languageName = \"\";\n+      if (typeof optionsOrCode === \"object\") {\n+        code = codeOrLanguageName;\n+        ignoreIllegals = optionsOrCode.ignoreIllegals;\n+        languageName = optionsOrCode.language;\n+      } else {\n+        \/\/ old API\n+        deprecated(\"10.7.0\", \"highlight(lang, code, ...args) has been deprecated.\");\n+        deprecated(\"10.7.0\", \"Please use highlight(code, options) instead.\\nhttps:\/\/github.com\/highlightjs\/highlight.js\/issues\/2277\");\n+        languageName = codeOrLanguageName;\n+        code = optionsOrCode;\n+      }\n+\n+      \/\/ https:\/\/github.com\/highlightjs\/highlight.js\/issues\/3149\n+      \/\/ eslint-disable-next-line no-undefined\n+      if (ignoreIllegals === undefined) { ignoreIllegals = true; }\n+\n+      \/** @type {BeforeHighlightContext} *\/\n+      const context = {\n+        code,\n+        language: languageName\n+      };\n+      \/\/ the plugin can change the desired language or the code to be highlighted\n+      \/\/ just be changing the object it was passed\n+      fire(\"before:highlight\", context);\n+\n+      \/\/ a before plugin can usurp the result completely by providing it's own\n+      \/\/ in which case we don't even need to call highlight\n+      const result = context.result\n+        ? context.result\n+        : _highlight(context.language, context.code, ignoreIllegals);\n+\n+      result.code = context.code;\n+      \/\/ the plugin can change anything in result to suite it\n+      fire(\"after:highlight\", result);\n+\n+      return result;\n+    }\n+\n+    \/**\n+     * private highlight that's used internally and does not fire callbacks\n+     *\n+     * @param {string} languageName - the language to use for highlighting\n+     * @param {string} codeToHighlight - the code to highlight\n+     * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n+     * @param {CompiledMode?} [continuation] - current continuation mode, if any\n+     * @returns {HighlightResult} - result of the highlight operation\n+    *\/\n+    function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n+      const keywordHits = Object.create(null);\n+\n+      \/**\n+       * Return keyword data if a match is a keyword\n+       * @param {CompiledMode} mode - current mode\n+       * @param {string} matchText - the textual match\n+       * @returns {KeywordData | false}\n+       *\/\n+      function keywordData(mode, matchText) {\n+        return mode.keywords[matchText];\n+      }\n+\n+      function processKeywords() {\n+        if (!top.keywords) {\n+          emitter.addText(modeBuffer);\n+          return;\n+        }\n+\n+        let lastIndex = 0;\n+        top.keywordPatternRe.lastIndex = 0;\n+        let match = top.keywordPatternRe.exec(modeBuffer);\n+        let buf = \"\";\n+\n+        while (match) {\n+          buf += modeBuffer.substring(lastIndex, match.index);\n+          const word = language.case_insensitive ? match[0].toLowerCase() : match[0];\n+          const data = keywordData(top, word);\n+          if (data) {\n+            const [kind, keywordRelevance] = data;\n+            emitter.addText(buf);\n+            buf = \"\";\n+\n+            keywordHits[word] = (keywordHits[word] || 0) + 1;\n+            if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;\n+            if (kind.startsWith(\"_\")) {\n+              \/\/ _ implied for relevance only, do not highlight\n+              \/\/ by applying a class name\n+              buf += match[0];\n+            } else {\n+              const cssClass = language.classNameAliases[kind] || kind;\n+              emitKeyword(match[0], cssClass);\n+            }\n+          } else {\n+            buf += match[0];\n+          }\n+          lastIndex = top.keywordPatternRe.lastIndex;\n+          match = top.keywordPatternRe.exec(modeBuffer);\n+        }\n+        buf += modeBuffer.substring(lastIndex);\n+        emitter.addText(buf);\n+      }\n+\n+      function processSubLanguage() {\n+        if (modeBuffer === \"\") return;\n+        \/** @type HighlightResult *\/\n+        let result = null;\n+\n+        if (typeof top.subLanguage === 'string') {\n+          if (!languages[top.subLanguage]) {\n+            emitter.addText(modeBuffer);\n+            return;\n+          }\n+          result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);\n+          continuations[top.subLanguage] = \/** @type {CompiledMode} *\/ (result._top);\n+        } else {\n+          result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);\n+        }\n+\n+        \/\/ Counting embedded language score towards the host language may be disabled\n+        \/\/ with zeroing the containing mode relevance. Use case in point is Markdown that\n+        \/\/ allows XML everywhere and makes every XML snippet to have a much larger Markdown\n+        \/\/ score.\n+        if (top.relevance > 0) {\n+          relevance += result.relevance;\n+        }\n+        emitter.__addSublanguage(result._emitter, result.language);\n+      }\n+\n+      function processBuffer() {\n+        if (top.subLanguage != null) {\n+          processSubLanguage();\n+        } else {\n+          processKeywords();\n+        }\n+        modeBuffer = '';\n+      }\n+\n+      \/**\n+       * @param {string} text\n+       * @param {string} scope\n+       *\/\n+      function emitKeyword(keyword, scope) {\n+        if (keyword === \"\") return;\n+\n+        emitter.startScope(scope);\n+        emitter.addText(keyword);\n+        emitter.endScope();\n+      }\n+\n+      \/**\n+       * @param {CompiledScope} scope\n+       * @param {RegExpMatchArray} match\n+       *\/\n+      function emitMultiClass(scope, match) {\n+        let i = 1;\n+        const max = match.length - 1;\n+        while (i <= max) {\n+          if (!scope._emit[i]) { i++; continue; }\n+          const klass = language.classNameAliases[scope[i]] || scope[i];\n+          const text = match[i];\n+          if (klass) {\n+            emitKeyword(text, klass);\n+          } else {\n+            modeBuffer = text;\n+            processKeywords();\n+            modeBuffer = \"\";\n+          }\n+          i++;\n+        }\n+      }\n+\n+      \/**\n+       * @param {CompiledMode} mode - new mode to start\n+       * @param {RegExpMatchArray} match\n+       *\/\n+      function startNewMode(mode, match) {\n+        if (mode.scope && typeof mode.scope === \"string\") {\n+          emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);\n+        }\n+        if (mode.beginScope) {\n+          \/\/ beginScope just wraps the begin match itself in a scope\n+          if (mode.beginScope._wrap) {\n+            emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);\n+            modeBuffer = \"\";\n+          } else if (mode.beginScope._multi) {\n+            \/\/ at this point modeBuffer should just be the match\n+            emitMultiClass(mode.beginScope, match);\n+            modeBuffer = \"\";\n+          }\n+        }\n+\n+        top = Object.create(mode, { parent: { value: top } });\n+        return top;\n+      }\n+\n+      \/**\n+       * @param {CompiledMode } mode - the mode to potentially end\n+       * @param {RegExpMatchArray} match - the latest match\n+       * @param {string} matchPlusRemainder - match plus remainder of content\n+       * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n+       *\/\n+      function endOfMode(mode, match, matchPlusRemainder) {\n+        let matched = startsWith(mode.endRe, matchPlusRemainder);\n+\n+        if (matched) {\n+          if (mode[\"on:end\"]) {\n+            const resp = new Response(mode);\n+            mode[\"on:end\"](match, resp);\n+            if (resp.isMatchIgnored) matched = false;\n+          }\n+\n+          if (matched) {\n+            while (mode.endsParent && mode.parent) {\n+              mode = mode.parent;\n+            }\n+            return mode;\n+          }\n+        }\n+        \/\/ even if on:end fires an `ignore` it's still possible\n+        \/\/ that we might trigger the end node because of a parent mode\n+        if (mode.endsWithParent) {\n+          return endOfMode(mode.parent, match, matchPlusRemainder);\n+        }\n+      }\n+\n+      \/**\n+       * Handle matching but then ignoring a sequence of text\n+       *\n+       * @param {string} lexeme - string containing full match text\n+       *\/\n+      function doIgnore(lexeme) {\n+        if (top.matcher.regexIndex === 0) {\n+          \/\/ no more regexes to potentially match here, so we move the cursor forward one\n+          \/\/ space\n+          modeBuffer += lexeme[0];\n+          return 1;\n+        } else {\n+          \/\/ no need to move the cursor, we still have additional regexes to try and\n+          \/\/ match at this very spot\n+          resumeScanAtSamePosition = true;\n+          return 0;\n+        }\n+      }\n+\n+      \/**\n+       * Handle the start of a new potential mode match\n+       *\n+       * @param {EnhancedMatch} match - the current match\n+       * @returns {number} how far to advance the parse cursor\n+       *\/\n+      function doBeginMatch(match) {\n+        const lexeme = match[0];\n+        const newMode = match.rule;\n+\n+        const resp = new Response(newMode);\n+        \/\/ first internal before callbacks, then the public ones\n+        const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];\n+        for (const cb of beforeCallbacks) {\n+          if (!cb) continue;\n+          cb(match, resp);\n+          if (resp.isMatchIgnored) return doIgnore(lexeme);\n+        }\n+\n+        if (newMode.skip) {\n+          modeBuffer += lexeme;\n+        } else {\n+          if (newMode.excludeBegin) {\n+            modeBuffer += lexeme;\n+          }\n+          processBuffer();\n+          if (!newMode.returnBegin && !newMode.excludeBegin) {\n+            modeBuffer = lexeme;\n+          }\n+        }\n+        startNewMode(newMode, match);\n+        return newMode.returnBegin ? 0 : lexeme.length;\n+      }\n+\n+      \/**\n+       * Handle the potential end of mode\n+       *\n+       * @param {RegExpMatchArray} match - the current match\n+       *\/\n+      function doEndMatch(match) {\n+        const lexeme = match[0];\n+        const matchPlusRemainder = codeToHighlight.substring(match.index);\n+\n+        const endMode = endOfMode(top, match, matchPlusRemainder);\n+        if (!endMode) { return NO_MATCH; }\n+\n+        const origin = top;\n+        if (top.endScope && top.endScope._wrap) {\n+          processBuffer();\n+          emitKeyword(lexeme, top.endScope._wrap);\n+        } else if (top.endScope && top.endScope._multi) {\n+          processBuffer();\n+          emitMultiClass(top.endScope, match);\n+        } else if (origin.skip) {\n+          modeBuffer += lexeme;\n+        } else {\n+          if (!(origin.returnEnd || origin.excludeEnd)) {\n+            modeBuffer += lexeme;\n+          }\n+          processBuffer();\n+          if (origin.excludeEnd) {\n+            modeBuffer = lexeme;\n+          }\n+        }\n+        do {\n+          if (top.scope) {\n+            emitter.closeNode();\n+          }\n+          if (!top.skip && !top.subLanguage) {\n+            relevance += top.relevance;\n+          }\n+          top = top.parent;\n+        } while (top !== endMode.parent);\n+        if (endMode.starts) {\n+          startNewMode(endMode.starts, match);\n+        }\n+        return origin.returnEnd ? 0 : lexeme.length;\n+      }\n+\n+      function processContinuations() {\n+        const list = [];\n+        for (let current = top; current !== language; current = current.parent) {\n+          if (current.scope) {\n+            list.unshift(current.scope);\n+          }\n+        }\n+        list.forEach(item => emitter.openNode(item));\n+      }\n+\n+      \/** @type {{type?: MatchType, index?: number, rule?: Mode}}} *\/\n+      let lastMatch = {};\n+\n+      \/**\n+       *  Process an individual match\n+       *\n+       * @param {string} textBeforeMatch - text preceding the match (since the last match)\n+       * @param {EnhancedMatch} [match] - the match itself\n+       *\/\n+      function processLexeme(textBeforeMatch, match) {\n+        const lexeme = match && match[0];\n+\n+        \/\/ add non-matched text to the current mode buffer\n+        modeBuffer += textBeforeMatch;\n+\n+        if (lexeme == null) {\n+          processBuffer();\n+          return 0;\n+        }\n+\n+        \/\/ we've found a 0 width match and we're stuck, so we need to advance\n+        \/\/ this happens when we have badly behaved rules that have optional matchers to the degree that\n+        \/\/ sometimes they can end up matching nothing at all\n+        \/\/ Ref: https:\/\/github.com\/highlightjs\/highlight.js\/issues\/2140\n+        if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n+          \/\/ spit the \"skipped\" character that our regex choked on back into the output sequence\n+          modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n+          if (!SAFE_MODE) {\n+            \/** @type {AnnotatedError} *\/\n+            const err = new Error(`0 width match regex (${languageName})`);\n+            err.languageName = languageName;\n+            err.badRule = lastMatch.rule;\n+            throw err;\n+          }\n+          return 1;\n+        }\n+        lastMatch = match;\n+\n+        if (match.type === \"begin\") {\n+          return doBeginMatch(match);\n+        } else if (match.type === \"illegal\" && !ignoreIllegals) {\n+          \/\/ illegal match, we do not continue processing\n+          \/** @type {AnnotatedError} *\/\n+          const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.scope || '<unnamed>') + '\"');\n+          err.mode = top;\n+          throw err;\n+        } else if (match.type === \"end\") {\n+          const processed = doEndMatch(match);\n+          if (processed !== NO_MATCH) {\n+            return processed;\n+          }\n+        }\n+\n+        \/\/ edge case for when illegal matches $ (end of line) which is technically\n+        \/\/ a 0 width match but not a begin\/end match so it's not caught by the\n+        \/\/ first handler (when ignoreIllegals is true)\n+        if (match.type === \"illegal\" && lexeme === \"\") {\n+          \/\/ advance so we aren't stuck in an infinite loop\n+          modeBuffer += \"\\n\";\n+          return 1;\n+        }\n+\n+        \/\/ infinite loops are BAD, this is a last ditch catch all. if we have a\n+        \/\/ decent number of iterations yet our index (cursor position in our\n+        \/\/ parsing) still 3x behind our index then something is very wrong\n+        \/\/ so we bail\n+        if (iterations > 100000 && iterations > match.index * 3) {\n+          const err = new Error('potential infinite loop, way more iterations than matches');\n+          throw err;\n+        }\n+\n+        \/*\n+        Why might be find ourselves here?  An potential end match that was\n+        triggered but could not be completed.  IE, `doEndMatch` returned NO_MATCH.\n+        (this could be because a callback requests the match be ignored, etc)\n+\n+        This causes no real harm other than stopping a few times too many.\n+        *\/\n+\n+        modeBuffer += lexeme;\n+        return lexeme.length;\n+      }\n+\n+      const language = getLanguage(languageName);\n+      if (!language) {\n+        error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n+        throw new Error('Unknown language: \"' + languageName + '\"');\n+      }\n+\n+      const md = compileLanguage(language);\n+      let result = '';\n+      \/** @type {CompiledMode} *\/\n+      let top = continuation || md;\n+      \/** @type Record<string,CompiledMode> *\/\n+      const continuations = {}; \/\/ keep continuations for sub-languages\n+      const emitter = new options.__emitter(options);\n+      processContinuations();\n+      let modeBuffer = '';\n+      let relevance = 0;\n+      let index = 0;\n+      let iterations = 0;\n+      let resumeScanAtSamePosition = false;\n+\n+      try {\n+        if (!language.__emitTokens) {\n+          top.matcher.considerAll();\n+\n+          for (;;) {\n+            iterations++;\n+            if (resumeScanAtSamePosition) {\n+              \/\/ only regexes not matched previously will now be\n+              \/\/ considered for a potential match\n+              resumeScanAtSamePosition = false;\n+            } else {\n+              top.matcher.considerAll();\n+            }\n+            top.matcher.lastIndex = index;\n+\n+            const match = top.matcher.exec(codeToHighlight);\n+            \/\/ console.log(\"match\", match[0], match.rule && match.rule.begin)\n+\n+            if (!match) break;\n+\n+            const beforeMatch = codeToHighlight.substring(index, match.index);\n+            const processedCount = processLexeme(beforeMatch, match);\n+            index = match.index + processedCount;\n+          }\n+          processLexeme(codeToHighlight.substring(index));\n+        } else {\n+          language.__emitTokens(codeToHighlight, emitter);\n+        }\n+\n+        emitter.finalize();\n+        result = emitter.toHTML();\n+\n+        return {\n+          language: languageName,\n+          value: result,\n+          relevance,\n+          illegal: false,\n+          _emitter: emitter,\n+          _top: top\n+        };\n+      } catch (err) {\n+        if (err.message && err.message.includes('Illegal')) {\n+          return {\n+            language: languageName,\n+            value: escape(codeToHighlight),\n+            illegal: true,\n+            relevance: 0,\n+            _illegalBy: {\n+              message: err.message,\n+              index,\n+              context: codeToHighlight.slice(index - 100, index + 100),\n+              mode: err.mode,\n+              resultSoFar: result\n+            },\n+            _emitter: emitter\n+          };\n+        } else if (SAFE_MODE) {\n+          return {\n+            language: languageName,\n+            value: escape(codeToHighlight),\n+            illegal: false,\n+            relevance: 0,\n+            errorRaised: err,\n+            _emitter: emitter,\n+            _top: top\n+          };\n+        } else {\n+          throw err;\n+        }\n+      }\n+    }\n+\n+    \/**\n+     * returns a valid highlight result, without actually doing any actual work,\n+     * auto highlight starts with this and it's possible for small snippets that\n+     * auto-detection may not find a better match\n+     * @param {string} code\n+     * @returns {HighlightResult}\n+     *\/\n+    function justTextHighlightResult(code) {\n+      const result = {\n+        value: escape(code),\n+        illegal: false,\n+        relevance: 0,\n+        _top: PLAINTEXT_LANGUAGE,\n+        _emitter: new options.__emitter(options)\n+      };\n+      result._emitter.addText(code);\n+      return result;\n+    }\n+\n+    \/**\n+    Highlighting with language detection. Accepts a string with the code to\n+    highlight. Returns an object with the following properties:\n+\n+    - language (detected language)\n+    - relevance (int)\n+    - value (an HTML string with highlighting markup)\n+    - secondBest (object with the same structure for second-best heuristically\n+      detected language, may be absent)\n+\n+      @param {string} code\n+      @param {Array<string>} [languageSubset]\n+      @returns {AutoHighlightResult}\n+    *\/\n+    function highlightAuto(code, languageSubset) {\n+      languageSubset = languageSubset || options.languages || Object.keys(languages);\n+      const plaintext = justTextHighlightResult(code);\n+\n+      const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>\n+        _highlight(name, code, false)\n+      );\n+      results.unshift(plaintext); \/\/ plaintext is always an option\n+\n+      const sorted = results.sort((a, b) => {\n+        \/\/ sort base on relevance\n+        if (a.relevance !== b.relevance) return b.relevance - a.relevance;\n+\n+        \/\/ always award the tie to the base language\n+        \/\/ ie if C++ and Arduino are tied, it's more likely to be C++\n+        if (a.language && b.language) {\n+          if (getLanguage(a.language).supersetOf === b.language) {\n+            return 1;\n+          } else if (getLanguage(b.language).supersetOf === a.language) {\n+            return -1;\n+          }\n+        }\n+\n+        \/\/ otherwise say they are equal, which has the effect of sorting on\n+        \/\/ relevance while preserving the original ordering - which is how ties\n+        \/\/ have historically been settled, ie the language that comes first always\n+        \/\/ wins in the case of a tie\n+        return 0;\n+      });\n+\n+      const [best, secondBest] = sorted;\n+\n+      \/** @type {AutoHighlightResult} *\/\n+      const result = best;\n+      result.secondBest = secondBest;\n+\n+      return result;\n+    }\n+\n+    \/**\n+     * Builds new class name for block given the language name\n+     *\n+     * @param {HTMLElement} element\n+     * @param {string} [currentLang]\n+     * @param {string} [resultLang]\n+     *\/\n+    function updateClassName(element, currentLang, resultLang) {\n+      const language = (currentLang && aliases[currentLang]) || resultLang;\n+\n+      element.classList.add(\"hljs\");\n+      element.classList.add(`language-${language}`);\n+    }\n+\n+    \/**\n+     * Applies highlighting to a DOM node containing code.\n+     *\n+     * @param {HighlightedHTMLElement} element - the HTML element to highlight\n+    *\/\n+    function highlightElement(element) {\n+      \/** @type HTMLElement *\/\n+      let node = null;\n+      const language = blockLanguage(element);\n+\n+      if (shouldNotHighlight(language)) return;\n+\n+      fire(\"before:highlightElement\",\n+        { el: element, language });\n+\n+      if (element.dataset.highlighted) {\n+        console.log(\"Element previously highlighted. To highlight again, first unset `dataset.highlighted`.\", element);\n+        return;\n+      }\n+\n+      \/\/ we should be all text, no child nodes (unescaped HTML) - this is possibly\n+      \/\/ an HTML injection attack - it's likely too late if this is already in\n+      \/\/ production (the code has likely already done its damage by the time\n+      \/\/ we're seeing it)... but we yell loudly about this so that hopefully it's\n+      \/\/ more likely to be caught in development before making it to production\n+      if (element.children.length > 0) {\n+        if (!options.ignoreUnescapedHTML) {\n+          console.warn(\"One of your code blocks includes unescaped HTML. This is a potentially serious security risk.\");\n+          console.warn(\"https:\/\/github.com\/highlightjs\/highlight.js\/wiki\/security\");\n+          console.warn(\"The element with unescaped HTML:\");\n+          console.warn(element);\n+        }\n+        if (options.throwUnescapedHTML) {\n+          const err = new HTMLInjectionError(\n+            \"One of your code blocks includes unescaped HTML.\",\n+            element.innerHTML\n+          );\n+          throw err;\n+        }\n+      }\n+\n+      node = element;\n+      const text = node.textContent;\n+      const result = language ? highlight(text, { language, ignoreIllegals: true }) : highlightAuto(text);\n+\n+      element.innerHTML = result.value;\n+      element.dataset.highlighted = \"yes\";\n+      updateClassName(element, language, result.language);\n+      element.result = {\n+        language: result.language,\n+        \/\/ TODO: remove with version 11.0\n+        re: result.relevance,\n+        relevance: result.relevance\n+      };\n+      if (result.secondBest) {\n+        element.secondBest = {\n+          language: result.secondBest.language,\n+          relevance: result.secondBest.relevance\n+        };\n+      }\n+\n+      fire(\"after:highlightElement\", { el: element, result, text });\n+    }\n+\n+    \/**\n+     * Updates highlight.js global options with the passed options\n+     *\n+     * @param {Partial<HLJSOptions>} userOptions\n+     *\/\n+    function configure(userOptions) {\n+      options = inherit(options, userOptions);\n+    }\n+\n+    \/\/ TODO: remove v12, deprecated\n+    const initHighlighting = () => {\n+      highlightAll();\n+      deprecated(\"10.6.0\", \"initHighlighting() deprecated.  Use highlightAll() now.\");\n+    };\n+\n+    \/\/ TODO: remove v12, deprecated\n+    function initHighlightingOnLoad() {\n+      highlightAll();\n+      deprecated(\"10.6.0\", \"initHighlightingOnLoad() deprecated.  Use highlightAll() now.\");\n+    }\n+\n+    let wantsHighlight = false;\n+\n+    \/**\n+     * auto-highlights all pre>code elements on the page\n+     *\/\n+    function highlightAll() {\n+      function boot() {\n+        \/\/ if a highlight was requested before DOM was loaded, do now\n+        highlightAll();\n+      }\n+\n+      \/\/ if we are called too early in the loading process\n+      if (document.readyState === \"loading\") {\n+        \/\/ make sure the event listener is only added once\n+        if (!wantsHighlight) {\n+          window.addEventListener('DOMContentLoaded', boot, false);\n+        }\n+        wantsHighlight = true;\n+        return;\n+      }\n+\n+      const blocks = document.querySelectorAll(options.cssSelector);\n+      blocks.forEach(highlightElement);\n+    }\n+\n+    \/**\n+     * Register a language grammar module\n+     *\n+     * @param {string} languageName\n+     * @param {LanguageFn} languageDefinition\n+     *\/\n+    function registerLanguage(languageName, languageDefinition) {\n+      let lang = null;\n+      try {\n+        lang = languageDefinition(hljs);\n+      } catch (error$1) {\n+        error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n+        \/\/ hard or soft error\n+        if (!SAFE_MODE) { throw error$1; } else { error(error$1); }\n+        \/\/ languages that have serious errors are replaced with essentially a\n+        \/\/ \"plaintext\" stand-in so that the code blocks will still get normal\n+        \/\/ css classes applied to them - and one bad language won't break the\n+        \/\/ entire highlighter\n+        lang = PLAINTEXT_LANGUAGE;\n+      }\n+      \/\/ give it a temporary name if it doesn't have one in the meta-data\n+      if (!lang.name) lang.name = languageName;\n+      languages[languageName] = lang;\n+      lang.rawDefinition = languageDefinition.bind(null, hljs);\n+\n+      if (lang.aliases) {\n+        registerAliases(lang.aliases, { languageName });\n+      }\n+    }\n+\n+    \/**\n+     * Remove a language grammar module\n+     *\n+     * @param {string} languageName\n+     *\/\n+    function unregisterLanguage(languageName) {\n+      delete languages[languageName];\n+      for (const alias of Object.keys(aliases)) {\n+        if (aliases[alias] === languageName) {\n+          delete aliases[alias];\n+        }\n+      }\n+    }\n+\n+    \/**\n+     * @returns {string[]} List of language internal names\n+     *\/\n+    function listLanguages() {\n+      return Object.keys(languages);\n+    }\n+\n+    \/**\n+     * @param {string} name - name of the language to retrieve\n+     * @returns {Language | undefined}\n+     *\/\n+    function getLanguage(name) {\n+      name = (name || '').toLowerCase();\n+      return languages[name] || languages[aliases[name]];\n+    }\n+\n+    \/**\n+     *\n+     * @param {string|string[]} aliasList - single alias or list of aliases\n+     * @param {{languageName: string}} opts\n+     *\/\n+    function registerAliases(aliasList, { languageName }) {\n+      if (typeof aliasList === 'string') {\n+        aliasList = [aliasList];\n+      }\n+      aliasList.forEach(alias => { aliases[alias.toLowerCase()] = languageName; });\n+    }\n+\n+    \/**\n+     * Determines if a given language has auto-detection enabled\n+     * @param {string} name - name of the language\n+     *\/\n+    function autoDetection(name) {\n+      const lang = getLanguage(name);\n+      return lang && !lang.disableAutodetect;\n+    }\n+\n+    \/**\n+     * Upgrades the old highlightBlock plugins to the new\n+     * highlightElement API\n+     * @param {HLJSPlugin} plugin\n+     *\/\n+    function upgradePluginAPI(plugin) {\n+      \/\/ TODO: remove with v12\n+      if (plugin[\"before:highlightBlock\"] && !plugin[\"before:highlightElement\"]) {\n+        plugin[\"before:highlightElement\"] = (data) => {\n+          plugin[\"before:highlightBlock\"](\n+            Object.assign({ block: data.el }, data)\n+          );\n+        };\n+      }\n+      if (plugin[\"after:highlightBlock\"] && !plugin[\"after:highlightElement\"]) {\n+        plugin[\"after:highlightElement\"] = (data) => {\n+          plugin[\"after:highlightBlock\"](\n+            Object.assign({ block: data.el }, data)\n+          );\n+        };\n+      }\n+    }\n+\n+    \/**\n+     * @param {HLJSPlugin} plugin\n+     *\/\n+    function addPlugin(plugin) {\n+      upgradePluginAPI(plugin);\n+      plugins.push(plugin);\n+    }\n+\n+    \/**\n+     * @param {HLJSPlugin} plugin\n+     *\/\n+    function removePlugin(plugin) {\n+      const index = plugins.indexOf(plugin);\n+      if (index !== -1) {\n+        plugins.splice(index, 1);\n+      }\n+    }\n+\n+    \/**\n+     *\n+     * @param {PluginEvent} event\n+     * @param {any} args\n+     *\/\n+    function fire(event, args) {\n+      const cb = event;\n+      plugins.forEach(function(plugin) {\n+        if (plugin[cb]) {\n+          plugin[cb](args);\n+        }\n+      });\n+    }\n+\n+    \/**\n+     * DEPRECATED\n+     * @param {HighlightedHTMLElement} el\n+     *\/\n+    function deprecateHighlightBlock(el) {\n+      deprecated(\"10.7.0\", \"highlightBlock will be removed entirely in v12.0\");\n+      deprecated(\"10.7.0\", \"Please use highlightElement now.\");\n+\n+      return highlightElement(el);\n+    }\n+\n+    \/* Interface definition *\/\n+    Object.assign(hljs, {\n+      highlight,\n+      highlightAuto,\n+      highlightAll,\n+      highlightElement,\n+      \/\/ TODO: Remove with v12 API\n+      highlightBlock: deprecateHighlightBlock,\n+      configure,\n+      initHighlighting,\n+      initHighlightingOnLoad,\n+      registerLanguage,\n+      unregisterLanguage,\n+      listLanguages,\n+      getLanguage,\n+      registerAliases,\n+      autoDetection,\n+      inherit,\n+      addPlugin,\n+      removePlugin\n+    });\n+\n+    hljs.debugMode = function() { SAFE_MODE = false; };\n+    hljs.safeMode = function() { SAFE_MODE = true; };\n+    hljs.versionString = version;\n+\n+    hljs.regex = {\n+      concat: concat,\n+      lookahead: lookahead,\n+      either: either,\n+      optional: optional,\n+      anyNumberOfTimes: anyNumberOfTimes\n+    };\n+\n+    for (const key in MODES) {\n+      \/\/ @ts-ignore\n+      if (typeof MODES[key] === \"object\") {\n+        \/\/ @ts-ignore\n+        deepFreeze(MODES[key]);\n+      }\n+    }\n+\n+    \/\/ merge all the modes\/regexes into our main object\n+    Object.assign(hljs, MODES);\n+\n+    return hljs;\n+  };\n+\n+  \/\/ Other names for the variable may break build script\n+  const highlight = HLJS({});\n+\n+  \/\/ returns a new instance of the highlighter to be used for extensions\n+  \/\/ check https:\/\/github.com\/wooorm\/lowlight\/issues\/47\n+  highlight.newInstance = () => HLJS({});\n+\n+  \/\/ https:\/\/docs.oracle.com\/javase\/specs\/jls\/se15\/html\/jls-3.html#jls-3.10\n+  var decimalDigits = '[0-9](_*[0-9])*';\n+  var frac = `\\\\.(${decimalDigits})`;\n+  var hexDigits = '[0-9a-fA-F](_*[0-9a-fA-F])*';\n+  var NUMERIC = {\n+    className: 'number',\n+    variants: [\n+      \/\/ DecimalFloatingPointLiteral\n+      \/\/ including ExponentPart\n+      { begin: `(\\\\b(${decimalDigits})((${frac})|\\\\.)?|(${frac}))` +\n+        `[eE][+-]?(${decimalDigits})[fFdD]?\\\\b` },\n+      \/\/ excluding ExponentPart\n+      { begin: `\\\\b(${decimalDigits})((${frac})[fFdD]?\\\\b|\\\\.([fFdD]\\\\b)?)` },\n+      { begin: `(${frac})[fFdD]?\\\\b` },\n+      { begin: `\\\\b(${decimalDigits})[fFdD]\\\\b` },\n+\n+      \/\/ HexadecimalFloatingPointLiteral\n+      { begin: `\\\\b0[xX]((${hexDigits})\\\\.?|(${hexDigits})?\\\\.(${hexDigits}))` +\n+        `[pP][+-]?(${decimalDigits})[fFdD]?\\\\b` },\n+\n+      \/\/ DecimalIntegerLiteral\n+      { begin: '\\\\b(0|[1-9](_*[0-9])*)[lL]?\\\\b' },\n+\n+      \/\/ HexIntegerLiteral\n+      { begin: `\\\\b0[xX](${hexDigits})[lL]?\\\\b` },\n+\n+      \/\/ OctalIntegerLiteral\n+      { begin: '\\\\b0(_*[0-7])*[lL]?\\\\b' },\n+\n+      \/\/ BinaryIntegerLiteral\n+      { begin: '\\\\b0[bB][01](_*[01])*[lL]?\\\\b' },\n+    ],\n+    relevance: 0\n+  };\n+\n+  \/*\n+  Language: Java\n+  Author: Vsevolod Solovyov <vsevolod.solovyov@gmail.com>\n+  Category: common, enterprise\n+  Website: https:\/\/www.java.com\/\n+  *\/\n+\n+\n+  \/**\n+   * Allows recursive regex expressions to a given depth\n+   *\n+   * ie: recurRegex(\"(abc~~~)\", \/~~~\/g, 2) becomes:\n+   * (abc(abc(abc)))\n+   *\n+   * @param {string} re\n+   * @param {RegExp} substitution (should be a g mode regex)\n+   * @param {number} depth\n+   * @returns {string}``\n+   *\/\n+  function recurRegex(re, substitution, depth) {\n+    if (depth === -1) return \"\";\n+\n+    return re.replace(substitution, _ => {\n+      return recurRegex(re, substitution, depth - 1);\n+    });\n+  }\n+\n+  \/** @type LanguageFn *\/\n+  function java(hljs) {\n+    const regex = hljs.regex;\n+    const JAVA_IDENT_RE = '[\\u00C0-\\u02B8a-zA-Z_$][\\u00C0-\\u02B8a-zA-Z_$0-9]*';\n+    const TYPE_ARG_RE = '(?:(?:' + JAVA_IDENT_RE + '~~~)|(?:\\\\?\\\\s+(?:extends|super)\\\\s+' + JAVA_IDENT_RE + '~~~)|(?:\\\\?))';\n+    const GENERIC_RE = recurRegex('(?:<' + TYPE_ARG_RE + '(?:\\\\s*,\\\\s*' + TYPE_ARG_RE + ')*>)?', \/~~~\/g, 2);\n+    const ARRAY_RE = '(?:(?:\\\\[])+)?';\n+    const MAIN_KEYWORDS = [\n+      'synchronized',\n+      'abstract',\n+      'private',\n+      'var',\n+      'static',\n+      'if',\n+      'const ',\n+      'for',\n+      'while',\n+      'strictfp',\n+      'finally',\n+      'protected',\n+      'import',\n+      'native',\n+      'final',\n+      'void',\n+      'enum',\n+      'else',\n+      'break',\n+      'transient',\n+      'catch',\n+      'instanceof',\n+      'volatile',\n+      'case',\n+      'assert',\n+      'package',\n+      'default',\n+      'public',\n+      'try',\n+      'switch',\n+      'continue',\n+      'throws',\n+      'protected',\n+      'public',\n+      'private',\n+      'module',\n+      'requires',\n+      'exports',\n+      'do',\n+      'sealed',\n+      'yield',\n+      'permits',\n+      'goto',\n+      'when'\n+    ];\n+\n+    const BUILT_INS = [\n+      'super',\n+      'this'\n+    ];\n+\n+    const LITERALS = [\n+      'false',\n+      'true',\n+      'null'\n+    ];\n+\n+    const TYPES = [\n+      'char',\n+      'boolean',\n+      'long',\n+      'float',\n+      'int',\n+      'byte',\n+      'short',\n+      'double'\n+    ];\n+\n+    const KEYWORDS = {\n+      keyword: MAIN_KEYWORDS,\n+      literal: LITERALS,\n+      type: TYPES,\n+      built_in: BUILT_INS\n+    };\n+\n+    const ANNOTATION = {\n+      className: 'meta',\n+      begin: '@' + JAVA_IDENT_RE,\n+      contains: [\n+        {\n+          begin: \/\\(\/,\n+          end: \/\\)\/,\n+          contains: [ \"self\" ] \/\/ allow nested () inside our annotation\n+        }\n+      ]\n+    };\n+    const PARAMS = {\n+      className: 'params',\n+      begin: \/\\(\/,\n+      end: \/\\)\/,\n+      keywords: KEYWORDS,\n+      relevance: 0,\n+      contains: [ hljs.C_BLOCK_COMMENT_MODE ],\n+      endsParent: true\n+    };\n+\n+    return {\n+      name: 'Java',\n+      aliases: [ 'jsp' ],\n+      keywords: KEYWORDS,\n+      illegal: \/<\\\/|#\/,\n+      contains: [\n+        hljs.COMMENT(\n+          '\/\\\\*\\\\*',\n+          '\\\\*\/',\n+          {\n+            relevance: 0,\n+            contains: [\n+              {\n+                \/\/ eat up @'s in emails to prevent them to be recognized as doctags\n+                begin: \/\\w+@\/,\n+                relevance: 0\n+              },\n+              {\n+                className: 'doctag',\n+                begin: '@[A-Za-z]+'\n+              }\n+            ]\n+          }\n+        ),\n+        \/\/ relevance boost\n+        {\n+          begin: \/import java\\.[a-z]+\\.\/,\n+          keywords: \"import\",\n+          relevance: 2\n+        },\n+        hljs.C_LINE_COMMENT_MODE,\n+        hljs.C_BLOCK_COMMENT_MODE,\n+        {\n+          begin: \/\"\"\"\/,\n+          end: \/\"\"\"\/,\n+          className: \"string\",\n+          contains: [ hljs.BACKSLASH_ESCAPE ]\n+        },\n+        hljs.APOS_STRING_MODE,\n+        hljs.QUOTE_STRING_MODE,\n+        {\n+          match: [\n+            \/\\b(?:class|interface|enum|extends|implements|new)\/,\n+            \/\\s+\/,\n+            JAVA_IDENT_RE\n+          ],\n+          className: {\n+            1: \"keyword\",\n+            3: \"title.class\"\n+          }\n+        },\n+        {\n+          \/\/ Exceptions for hyphenated keywords\n+          match: \/non-sealed\/,\n+          scope: \"keyword\"\n+        },\n+        {\n+          begin: [\n+            regex.concat(\/(?!else)\/, JAVA_IDENT_RE),\n+            GENERIC_RE,\n+            ARRAY_RE,\n+            \/\\s+\/,\n+            JAVA_IDENT_RE,\n+            \/\\s+\/,\n+            \/=(?!=)\/\n+          ],\n+          className: {\n+            1: \"type\",\n+            5: \"variable\",\n+            7: \"operator\"\n+          }\n+        },\n+        {\n+          begin: [\n+            \/record\/,\n+            \/\\s+\/,\n+            JAVA_IDENT_RE\n+          ],\n+          className: {\n+            1: \"keyword\",\n+            3: \"title.class\"\n+          },\n+          contains: [\n+            PARAMS,\n+            hljs.C_LINE_COMMENT_MODE,\n+            hljs.C_BLOCK_COMMENT_MODE\n+          ]\n+        },\n+        {\n+          \/\/ Expression keywords prevent 'keyword Name(...)' from being\n+          \/\/ recognized as a function definition\n+          beginKeywords: 'new throw return else',\n+          relevance: 0\n+        },\n+        {\n+          begin: [\n+            '(?:' + JAVA_IDENT_RE + GENERIC_RE + ARRAY_RE + '\\\\s+)',\n+            hljs.UNDERSCORE_IDENT_RE,\n+            \/\\s*(?=\\()\/\n+          ],\n+          className: { 2: \"title.function\" },\n+          keywords: KEYWORDS,\n+          contains: [\n+            {\n+              className: 'params',\n+              begin: \/\\(\/,\n+              end: \/\\)\/,\n+              keywords: KEYWORDS,\n+              relevance: 0,\n+              contains: [\n+                ANNOTATION,\n+                hljs.APOS_STRING_MODE,\n+                hljs.QUOTE_STRING_MODE,\n+                NUMERIC,\n+                hljs.C_BLOCK_COMMENT_MODE\n+              ]\n+            },\n+            hljs.C_LINE_COMMENT_MODE,\n+            hljs.C_BLOCK_COMMENT_MODE\n+          ]\n+        },\n+        NUMERIC,\n+        ANNOTATION\n+      ]\n+    };\n+  }\n+\n+  \/*\n+  Language: .properties\n+  Contributors: Valentin Aitken <valentin@nalisbg.com>, Egor Rogov <e.rogov@postgrespro.ru>\n+  Website: https:\/\/en.wikipedia.org\/wiki\/.properties\n+  Category: config\n+  *\/\n+\n+  \/** @type LanguageFn *\/\n+  function properties(hljs) {\n+    \/\/ whitespaces: space, tab, formfeed\n+    const WS0 = '[ \\\\t\\\\f]*';\n+    const WS1 = '[ \\\\t\\\\f]+';\n+    \/\/ delimiter\n+    const EQUAL_DELIM = WS0 + '[:=]' + WS0;\n+    const WS_DELIM = WS1;\n+    const DELIM = '(' + EQUAL_DELIM + '|' + WS_DELIM + ')';\n+    const KEY = '([^\\\\\\\\:= \\\\t\\\\f\\\\n]|\\\\\\\\.)+';\n+\n+    const DELIM_AND_VALUE = {\n+      \/\/ skip DELIM\n+      end: DELIM,\n+      relevance: 0,\n+      starts: {\n+        \/\/ value: everything until end of line (again, taking into account backslashes)\n+        className: 'string',\n+        end: \/$\/,\n+        relevance: 0,\n+        contains: [\n+          { begin: '\\\\\\\\\\\\\\\\' },\n+          { begin: '\\\\\\\\\\\\n' }\n+        ]\n+      }\n+    };\n+\n+    return {\n+      name: '.properties',\n+      disableAutodetect: true,\n+      case_insensitive: true,\n+      illegal: \/\\S\/,\n+      contains: [\n+        hljs.COMMENT('^\\\\s*[!#]', '$'),\n+        \/\/ key: everything until whitespace or = or : (taking into account backslashes)\n+        \/\/ case of a key-value pair\n+        {\n+          returnBegin: true,\n+          variants: [\n+            { begin: KEY + EQUAL_DELIM },\n+            { begin: KEY + WS_DELIM }\n+          ],\n+          contains: [\n+            {\n+              className: 'attr',\n+              begin: KEY,\n+              endsParent: true\n+            }\n+          ],\n+          starts: DELIM_AND_VALUE\n+        },\n+        \/\/ case of an empty key\n+        {\n+          className: 'attr',\n+          begin: KEY + WS0 + '$'\n+        }\n+      ]\n+    };\n+  }\n+\n+  \/*\n+  Language: HTML, XML\n+  Website: https:\/\/www.w3.org\/XML\/\n+  Category: common, web\n+  Audit: 2020\n+  *\/\n+\n+  \/** @type LanguageFn *\/\n+  function xml(hljs) {\n+    const regex = hljs.regex;\n+    \/\/ XML names can have the following additional letters: https:\/\/www.w3.org\/TR\/xml\/#NT-NameChar\n+    \/\/ OTHER_NAME_CHARS = \/[:\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]\/;\n+    \/\/ Element names start with NAME_START_CHAR followed by optional other Unicode letters, ASCII digits, hyphens, underscores, and periods\n+    \/\/ const TAG_NAME_RE = regex.concat(\/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]\/, regex.optional(\/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*:\/), \/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*\/);;\n+    \/\/ const XML_IDENT_RE = \/[A-Z_a-z:\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]+\/;\n+    \/\/ const TAG_NAME_RE = regex.concat(\/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]\/, regex.optional(\/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*:\/), \/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*\/);\n+    \/\/ however, to cater for performance and more Unicode support rely simply on the Unicode letter class\n+    const TAG_NAME_RE = regex.concat(\/[\\p{L}_]\/u, regex.optional(\/[\\p{L}0-9_.-]*:\/u), \/[\\p{L}0-9_.-]*\/u);\n+    const XML_IDENT_RE = \/[\\p{L}0-9._:-]+\/u;\n+    const XML_ENTITIES = {\n+      className: 'symbol',\n+      begin: \/&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;\/\n+    };\n+    const XML_META_KEYWORDS = {\n+      begin: \/\\s\/,\n+      contains: [\n+        {\n+          className: 'keyword',\n+          begin: \/#?[a-z_][a-z1-9_-]+\/,\n+          illegal: \/\\n\/\n+        }\n+      ]\n+    };\n+    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n+      begin: \/\\(\/,\n+      end: \/\\)\/\n+    });\n+    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, { className: 'string' });\n+    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, { className: 'string' });\n+    const TAG_INTERNALS = {\n+      endsWithParent: true,\n+      illegal: \/<\/,\n+      relevance: 0,\n+      contains: [\n+        {\n+          className: 'attr',\n+          begin: XML_IDENT_RE,\n+          relevance: 0\n+        },\n+        {\n+          begin: \/=\\s*\/,\n+          relevance: 0,\n+          contains: [\n+            {\n+              className: 'string',\n+              endsParent: true,\n+              variants: [\n+                {\n+                  begin: \/\"\/,\n+                  end: \/\"\/,\n+                  contains: [ XML_ENTITIES ]\n+                },\n+                {\n+                  begin: \/'\/,\n+                  end: \/'\/,\n+                  contains: [ XML_ENTITIES ]\n+                },\n+                { begin: \/[^\\s\"'=<>`]+\/ }\n+              ]\n+            }\n+          ]\n+        }\n+      ]\n+    };\n+    return {\n+      name: 'HTML, XML',\n+      aliases: [\n+        'html',\n+        'xhtml',\n+        'rss',\n+        'atom',\n+        'xjb',\n+        'xsd',\n+        'xsl',\n+        'plist',\n+        'wsf',\n+        'svg'\n+      ],\n+      case_insensitive: true,\n+      unicodeRegex: true,\n+      contains: [\n+        {\n+          className: 'meta',\n+          begin: \/<![a-z]\/,\n+          end: \/>\/,\n+          relevance: 10,\n+          contains: [\n+            XML_META_KEYWORDS,\n+            QUOTE_META_STRING_MODE,\n+            APOS_META_STRING_MODE,\n+            XML_META_PAR_KEYWORDS,\n+            {\n+              begin: \/\\[\/,\n+              end: \/\\]\/,\n+              contains: [\n+                {\n+                  className: 'meta',\n+                  begin: \/<![a-z]\/,\n+                  end: \/>\/,\n+                  contains: [\n+                    XML_META_KEYWORDS,\n+                    XML_META_PAR_KEYWORDS,\n+                    QUOTE_META_STRING_MODE,\n+                    APOS_META_STRING_MODE\n+                  ]\n+                }\n+              ]\n+            }\n+          ]\n+        },\n+        hljs.COMMENT(\n+          \/<!--\/,\n+          \/-->\/,\n+          { relevance: 10 }\n+        ),\n+        {\n+          begin: \/<!\\[CDATA\\[\/,\n+          end: \/\\]\\]>\/,\n+          relevance: 10\n+        },\n+        XML_ENTITIES,\n+        \/\/ xml processing instructions\n+        {\n+          className: 'meta',\n+          end: \/\\?>\/,\n+          variants: [\n+            {\n+              begin: \/<\\?xml\/,\n+              relevance: 10,\n+              contains: [\n+                QUOTE_META_STRING_MODE\n+              ]\n+            },\n+            {\n+              begin: \/<\\?[a-z][a-z0-9]+\/,\n+            }\n+          ]\n+\n+        },\n+        {\n+          className: 'tag',\n+          \/*\n+          The lookahead pattern (?=...) ensures that 'begin' only matches\n+          '<style' as a single word, followed by a whitespace or an\n+          ending bracket.\n+          *\/\n+          begin: \/<style(?=\\s|>)\/,\n+          end: \/>\/,\n+          keywords: { name: 'style' },\n+          contains: [ TAG_INTERNALS ],\n+          starts: {\n+            end: \/<\\\/style>\/,\n+            returnEnd: true,\n+            subLanguage: [\n+              'css',\n+              'xml'\n+            ]\n+          }\n+        },\n+        {\n+          className: 'tag',\n+          \/\/ See the comment in the <style tag about the lookahead pattern\n+          begin: \/<script(?=\\s|>)\/,\n+          end: \/>\/,\n+          keywords: { name: 'script' },\n+          contains: [ TAG_INTERNALS ],\n+          starts: {\n+            end: \/<\\\/script>\/,\n+            returnEnd: true,\n+            subLanguage: [\n+              'javascript',\n+              'handlebars',\n+              'xml'\n+            ]\n+          }\n+        },\n+        \/\/ we need this for now for jSX\n+        {\n+          className: 'tag',\n+          begin: \/<>|<\\\/>\/\n+        },\n+        \/\/ open tag\n+        {\n+          className: 'tag',\n+          begin: regex.concat(\n+            \/<\/,\n+            regex.lookahead(regex.concat(\n+              TAG_NAME_RE,\n+              \/\/ <tag\/>\n+              \/\/ <tag>\n+              \/\/ <tag ...\n+              regex.either(\/\\\/>\/, \/>\/, \/\\s\/)\n+            ))\n+          ),\n+          end: \/\\\/?>\/,\n+          contains: [\n+            {\n+              className: 'name',\n+              begin: TAG_NAME_RE,\n+              relevance: 0,\n+              starts: TAG_INTERNALS\n+            }\n+          ]\n+        },\n+        \/\/ close tag\n+        {\n+          className: 'tag',\n+          begin: regex.concat(\n+            \/<\\\/\/,\n+            regex.lookahead(regex.concat(\n+              TAG_NAME_RE, \/>\/\n+            ))\n+          ),\n+          contains: [\n+            {\n+              className: 'name',\n+              begin: TAG_NAME_RE,\n+              relevance: 0\n+            },\n+            {\n+              begin: \/>\/,\n+              relevance: 0,\n+              endsParent: true\n+            }\n+          ]\n+        }\n+      ]\n+    };\n+  }\n+\n+  \/*\n+  Language: JSON\n+  Description: JSON (JavaScript Object Notation) is a lightweight data-interchange format.\n+  Author: Ivan Sagalaev <maniac@softwaremaniacs.org>\n+  Website: http:\/\/www.json.org\n+  Category: common, protocols, web\n+  *\/\n+\n+  function json(hljs) {\n+    const ATTRIBUTE = {\n+      className: 'attr',\n+      begin: \/\"(\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)\/,\n+      relevance: 1.01\n+    };\n+    const PUNCTUATION = {\n+      match: \/[{}[\\],:]\/,\n+      className: \"punctuation\",\n+      relevance: 0\n+    };\n+    const LITERALS = [\n+      \"true\",\n+      \"false\",\n+      \"null\"\n+    ];\n+    \/\/ NOTE: normally we would rely on `keywords` for this but using a mode here allows us\n+    \/\/ - to use the very tight `illegal: \\S` rule later to flag any other character\n+    \/\/ - as illegal indicating that despite looking like JSON we do not truly have\n+    \/\/ - JSON and thus improve false-positively greatly since JSON will try and claim\n+    \/\/ - all sorts of JSON looking stuff\n+    const LITERALS_MODE = {\n+      scope: \"literal\",\n+      beginKeywords: LITERALS.join(\" \"),\n+    };\n+\n+    return {\n+      name: 'JSON',\n+      aliases: ['jsonc'],\n+      keywords:{\n+        literal: LITERALS,\n+      },\n+      contains: [\n+        ATTRIBUTE,\n+        PUNCTUATION,\n+        hljs.QUOTE_STRING_MODE,\n+        LITERALS_MODE,\n+        hljs.C_NUMBER_MODE,\n+        hljs.C_LINE_COMMENT_MODE,\n+        hljs.C_BLOCK_COMMENT_MODE\n+      ],\n+      illegal: '\\\\S'\n+    };\n+  }\n+\n+  var builtIns = \/*#__PURE__*\/Object.freeze({\n+    __proto__: null,\n+    grmr_java: java,\n+    grmr_json: json,\n+    grmr_properties: properties,\n+    grmr_xml: xml\n+  });\n+\n+  const hljs = highlight;\n+\n+  for (const key of Object.keys(builtIns)) {\n+    \/\/ our builtInLanguages Rollup plugin has to use `_` to allow identifiers to be\n+    \/\/ compatible with `export` naming conventions, so we need to convert the\n+    \/\/ identifiers back into the more typical dash style that we use for language\n+    \/\/ naming via the API\n+    const languageName = key.replace(\"grmr_\", \"\").replace(\"_\", \"-\");\n+    hljs.registerLanguage(languageName, builtIns[key]);\n+  }\n+\n+  return hljs;\n+\n+})();\n+if (typeof exports === 'object' && typeof module !== 'undefined') { module.exports = hljs; }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/highlight.js","additions":3278,"deletions":0,"binary":false,"changes":3278,"status":"added"},{"patch":"@@ -24,0 +24,4 @@\n+if (hljs) {\n+    hljs.highlightAll();\n+}\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -736,0 +736,4 @@\n+doclet.usage.syntax-highlight.description=\\\n+    Enable syntax highlighting for code fragments in {@snippet} tags\\n\\\n+    and <pre><code> elements.\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-    --code-font-size: 14px;\n+    --code-font-size: 13.9px;\n@@ -30,1 +30,1 @@\n-    --code-line-height: 1.55;\n+    --code-line-height: 1.6;\n@@ -66,1 +66,1 @@\n-    --snippet-background-color: #f0f0f2;\n+    --snippet-background-color: #f2f2f4;\n@@ -69,1 +69,1 @@\n-    --pre-background-color: #f3f3f5;\n+    --pre-background-color: var(--snippet-background-color);\n@@ -568,3 +568,0 @@\n-div.inheritance {\n-    font-size: 0.99em;\n-}\n@@ -1392,2 +1389,2 @@\n-    top: 2px;\n-    right: 2px;\n+    top: 4px;\n+    right: 1px;\n@@ -1656,1 +1653,1 @@\n-    padding: 10px;\n+    padding: 12px;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,6 @@\n+    \/** The name of the syntax highlighting style sheet. *\/\n+    public static final DocPath HIGHLIGHT_CSS = DocPath.create(\"highlight.css\");\n+\n+    \/** The name of the syntax highlighting script file. *\/\n+    public static final DocPath HIGHLIGHT_JS = DocPath.create(\"highlight.js\");\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -870,0 +870,17 @@\n+<span id=\"option-syntax-highlight\">`--syntax-highlight`<\/span>\n+:   Enables syntax highlighting for code fragments in `{@snippet}` tags and\n+    `<pre><code>` elements. For snippets, the `lang` attribute is used to\n+    determine the language of code fragments, which defaults to \"java\" for\n+    inline snippets and is derived from the file extension for external\n+    snippets. In HTML `<pre><code>` tags, the `class` attribute can be used\n+    to specify the language of the contained code fragment as shown below:\n+\n+    ```\n+    <pre><code class=\"language-java\">...<\/code><\/pre>\n+    ```\n+\n+    If neither of these attributes is available automatic language detection is\n+    applied. To disable syntax highlighting for a code fragment set the language\n+    to \"text\" using one of the mechanisms described above. The languages and\n+    formats supported by this option are Java, Properties, JSON, HTML and XML.\n+\n","filename":"src\/jdk.javadoc\/share\/man\/javadoc.md","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8348282\n+ * @summary Add option for syntax highlighting in javadoc snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestSyntaxHighlightOption\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestSyntaxHighlightOption extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestSyntaxHighlightOption();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+    Path src = Path.of(\"src\");\n+\n+\n+    TestSyntaxHighlightOption() throws IOException {\n+        tb.writeJavaFiles(src, \"\"\"\n+                    package p;\n+                    \/** Class C. *\/\n+                    public class C {\n+                        \/**\n+                         * Method m.\n+                         *\/\n+                        public void m() {\n+                        }\n+                    }\n+                    \"\"\");\n+\n+    }\n+\n+    @Test\n+    public void testSyntaxHighlightOption(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"--syntax-highlight\",\n+                \"p\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"resource-files\/highlight.css\", true, \"Syntax highlight style sheet\");\n+        checkOutput(\"script-files\/highlight.js\", true, \"Highlight.js v11.11.1 (git: 08cb242e7d)\");\n+        checkOutput(\"index-all.html\", true, \"\"\"\n+                <link rel=\"stylesheet\" type=\"text\/css\" href=\"resource-files\/highlight.css\">\n+                <script type=\"text\/javascript\" src=\"script-files\/highlight.js\"><\/script>\"\"\");\n+        checkOutput(\"p\/package-summary.html\", true, \"\"\"\n+                <link rel=\"stylesheet\" type=\"text\/css\" href=\"..\/resource-files\/highlight.css\">\n+                <script type=\"text\/javascript\" src=\"..\/script-files\/highlight.js\"><\/script>\"\"\");\n+        checkOutput(\"p\/C.html\", true, \"\"\"\n+                <link rel=\"stylesheet\" type=\"text\/css\" href=\"..\/resource-files\/highlight.css\">\n+                <script type=\"text\/javascript\" src=\"..\/script-files\/highlight.js\"><\/script>\"\"\");\n+    }\n+\n+    @Test\n+    public void testNoSyntaxHighlightOption(Path base) {\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+        checkFiles(false, \"resource-files\/highlight.css\", \"script-files\/highlight.js\");\n+        checkOutput(\"index-all.html\", false, \"highlight.css\", \"highlight.js\");\n+        checkOutput(\"p\/package-summary.html\", false, \"highlight.css\", \"highlight.js\");\n+        checkOutput(\"p\/C.html\", false, \"highlight.css\", \"highlight.js\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSyntaxHighlightOption\/TestSyntaxHighlightOption.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}