{"files":[{"patch":"@@ -116,0 +116,7 @@\n+  inline HeapWord* allocate_in_young_gen(Klass* klass,\n+                                         size_t obj_size,\n+                                         uint age);\n+  inline HeapWord* allocate_in_old_gen(Klass* klass,\n+                                       size_t obj_size,\n+                                       uint age);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -156,0 +156,74 @@\n+inline HeapWord* PSPromotionManager::allocate_in_young_gen(Klass* klass,\n+                                                           size_t obj_size,\n+                                                           uint age) {\n+  HeapWord* result = _young_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_young_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (YoungPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = young_space()->cas_allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _young_lab.flush();\n+\n+    HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n+    if (lab_base != nullptr) {\n+      _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n+      \/\/ Try the young lab allocation again.\n+      result = _young_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, &_young_lab);\n+    } else {\n+      _young_gen_is_full = true;\n+    }\n+  }\n+  if (result == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n+    _young_gen_has_alloc_failure = true;\n+  }\n+  return result;\n+}\n+\n+inline HeapWord* PSPromotionManager::allocate_in_old_gen(Klass* klass,\n+                                                         size_t obj_size,\n+                                                         uint age) {\n+#ifndef PRODUCT\n+  if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    return nullptr;\n+  }\n+#endif  \/\/ #ifndef PRODUCT\n+\n+  HeapWord* result = _old_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_old_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (OldPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = old_gen()->allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _old_lab.flush();\n+\n+    HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n+    if (lab_base != nullptr) {\n+      _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n+      \/\/ Try the old lab allocation again.\n+      result = _old_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, &_old_lab);\n+    }\n+  }\n+  if (result == nullptr) {\n+    _old_gen_is_full = true;\n+  }\n+  return result;\n+}\n+\n@@ -189,25 +263,1 @@\n-      new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-      if (new_obj == nullptr && !_young_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (YoungPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(young_space()->cas_allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, false, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _young_lab.flush();\n-\n-          HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n-          if (lab_base != nullptr) {\n-            _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n-            \/\/ Try the young lab allocation again.\n-            new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, false, &_young_lab);\n-          } else {\n-            _young_gen_is_full = true;\n-          }\n-        }\n-        if (new_obj == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n-          _young_gen_has_alloc_failure = true;\n-        }\n-      }\n+      new_obj = cast_to_oop(allocate_in_young_gen(klass, new_obj_size, age));\n@@ -219,2 +269,2 @@\n-#ifndef PRODUCT\n-    if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    new_obj = cast_to_oop(allocate_in_old_gen(klass, new_obj_size, age));\n+    if (new_obj == nullptr) {\n@@ -223,3 +273,0 @@\n-#endif  \/\/ #ifndef PRODUCT\n-\n-    new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n@@ -227,33 +274,0 @@\n-\n-    if (new_obj == nullptr) {\n-      if (!_old_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (OldPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(old_gen()->allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, true, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _old_lab.flush();\n-\n-          HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n-          if(lab_base != nullptr) {\n-            _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n-            \/\/ Try the old lab allocation again.\n-            new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, true, &_old_lab);\n-          }\n-        }\n-      }\n-\n-      \/\/ This is the promotion failed test, and code handling.\n-      \/\/ The code belongs here for two reasons. It is slightly\n-      \/\/ different than the code below, and cannot share the\n-      \/\/ CAS testing code. Keeping the code here also minimizes\n-      \/\/ the impact on the common case fast path code.\n-\n-      if (new_obj == nullptr) {\n-        _old_gen_is_full = true;\n-        return oop_promotion_failed(o, test_mark);\n-      }\n-    }\n@@ -290,1 +304,1 @@\n-    \/\/ So, the is->objArray() test would be very infrequent.\n+    \/\/ So, the objArray test would be very infrequent.\n@@ -292,1 +306,1 @@\n-        new_obj->is_objArray() &&\n+        klass->is_objArray_klass() &&\n@@ -299,2 +313,1 @@\n-      if (StringDedup::is_enabled() &&\n-          java_lang_String::is_instance(new_obj) &&\n+      if (StringDedup::is_enabled_string(klass) &&\n@@ -308,1 +321,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":80,"deletions":68,"binary":false,"changes":148,"status":"modified"}]}