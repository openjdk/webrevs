{"files":[{"patch":"@@ -433,0 +433,6 @@\n+int HeapShared::archive_exception_instance(oop exception) {\n+  bool success = archive_reachable_objects_from(1, _default_subgraph_info, exception);\n+  assert(success, \"sanity\");\n+  return append_root(exception);\n+}\n+\n@@ -592,0 +598,1 @@\n+  Universe::archive_exception_instances();\n@@ -1390,5 +1397,9 @@\n-    guarantee(subgraph_k->name()->equals(\"java\/lang\/Class\") ||\n-              subgraph_k->name()->equals(\"java\/lang\/String\") ||\n-              subgraph_k->name()->equals(\"[Ljava\/lang\/Object;\") ||\n-              subgraph_k->name()->equals(\"[C\") ||\n-              subgraph_k->name()->equals(\"[B\"),\n+    Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n+    guarantee(name == vmSymbols::java_lang_Class() ||\n+              name == vmSymbols::java_lang_String() ||\n+              name == vmSymbols::java_lang_ArithmeticException() ||\n+              name == vmSymbols::java_lang_NullPointerException() ||\n+              name == vmSymbols::java_lang_VirtualMachineError() ||\n+              name == vmSymbols::object_array_signature() ||\n+              name == vmSymbols::byte_array_signature() ||\n+              name == vmSymbols::char_array_signature(),\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -368,0 +368,1 @@\n+  static int archive_exception_instance(oop exception);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1469,2 +1469,1 @@\n-\n-  CDS_JAVA_HEAP_ONLY(Universe::update_archived_basic_type_mirrors());\n+  Universe::load_archived_object_instances();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -129,4 +129,0 @@\n-OopHandle Universe::_null_ptr_exception_instance;\n-OopHandle Universe::_arithmetic_exception_instance;\n-OopHandle Universe::_virtual_machine_error_instance;\n-\n@@ -171,0 +167,46 @@\n+\/\/ These are the exceptions that are always created and are guatanteed to exist.\n+\/\/ If possible, they can be stored as CDS archived objects to speed up AOT code.\n+class BuiltinException {\n+  OopHandle _instance;\n+  CDS_JAVA_HEAP_ONLY(int _archived_root_index;)\n+\n+public:\n+  BuiltinException() : _instance{} {\n+    CDS_JAVA_HEAP_ONLY(_archived_root_index = 0);\n+  }\n+\n+  void init_if_empty(Symbol* symbol, TRAPS) {\n+    if (_instance.is_empty()) {\n+      Klass* k = SystemDictionary::resolve_or_fail(symbol, true, CHECK);\n+      oop obj = InstanceKlass::cast(k)->allocate_instance(CHECK);\n+      _instance = OopHandle(Universe::vm_global(), obj);\n+    }\n+  }\n+\n+  oop instance() {\n+    return _instance.resolve();\n+  }\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  void store_in_cds() {\n+    _archived_root_index = HeapShared::archive_exception_instance(instance());\n+  }\n+\n+  void load_from_cds() {\n+    if (_archived_root_index >= 0) {\n+      oop obj = HeapShared::get_root(_archived_root_index);\n+      assert(obj != nullptr, \"must be\");\n+      _instance = OopHandle(Universe::vm_global(), obj);\n+    }\n+  }\n+\n+  void serialize(SerializeClosure *f) {\n+    f->do_int(&_archived_root_index);\n+  }\n+#endif\n+};\n+\n+static BuiltinException _null_ptr_exception;\n+static BuiltinException _arithmetic_exception;\n+static BuiltinException _virtual_machine_error;\n+\n@@ -184,3 +226,3 @@\n-oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception_instance.resolve(); }\n-oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception_instance.resolve(); }\n-oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error_instance.resolve(); }\n+oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception.instance(); }\n+oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception.instance(); }\n+oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error.instance(); }\n@@ -249,1 +291,7 @@\n-void Universe::update_archived_basic_type_mirrors() {\n+void Universe::archive_exception_instances() {\n+  _null_ptr_exception.store_in_cds();\n+  _arithmetic_exception.store_in_cds();\n+  _virtual_machine_error.store_in_cds();\n+}\n+\n+void Universe::load_archived_object_instances() {\n@@ -259,0 +307,4 @@\n+\n+    _null_ptr_exception.load_from_cds();\n+    _arithmetic_exception.load_from_cds();\n+    _virtual_machine_error.load_from_cds();\n@@ -270,1 +322,1 @@\n-    \/\/ updated later in Universe::update_archived_basic_type_mirrors().\n+    \/\/ updated later in Universe::load_archived_object_instances().\n@@ -272,0 +324,3 @@\n+  _null_ptr_exception.serialize(f);\n+  _arithmetic_exception.serialize(f);\n+  _virtual_machine_error.serialize(f);\n@@ -1013,11 +1068,4 @@\n-  \/\/ Setup preallocated NullPointerException\n-  \/\/ (this is currently used for a cheap & dirty solution in compiler exception handling)\n-  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_NullPointerException(), true, CHECK_false);\n-  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n-  Universe::_null_ptr_exception_instance = OopHandle(Universe::vm_global(), instance);\n-\n-  \/\/ Setup preallocated ArithmeticException\n-  \/\/ (this is currently used for a cheap & dirty solution in compiler exception handling)\n-  k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ArithmeticException(), true, CHECK_false);\n-  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n-  Universe::_arithmetic_exception_instance = OopHandle(Universe::vm_global(), instance);\n+  \/\/ Setup preallocated NullPointerException\/ArithmeticException\n+  \/\/ (used for a cheap & dirty solution in compiler exception handling)\n+  _null_ptr_exception.init_if_empty(vmSymbols::java_lang_NullPointerException(), CHECK_false);\n+  _arithmetic_exception.init_if_empty(vmSymbols::java_lang_ArithmeticException(), CHECK_false);\n@@ -1026,1 +1074,1 @@\n-  k = vmClasses::VirtualMachineError_klass();\n+  Klass* k = vmClasses::VirtualMachineError_klass();\n@@ -1032,2 +1080,1 @@\n-  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n-  Universe::_virtual_machine_error_instance = OopHandle(Universe::vm_global(), instance);\n+  _virtual_machine_error.init_if_empty(vmSymbols::java_lang_VirtualMachineError(), CHECK_false);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":70,"deletions":23,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,4 +142,0 @@\n-  static OopHandle    _null_ptr_exception_instance;   \/\/ preallocated exception object\n-  static OopHandle    _arithmetic_exception_instance; \/\/ preallocated exception object\n-  static OopHandle    _virtual_machine_error_instance; \/\/ preallocated exception object\n-\n@@ -247,0 +243,1 @@\n+  static void load_archived_object_instances() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -249,1 +246,1 @@\n-  static void update_archived_basic_type_mirrors();\n+  static void archive_exception_instances();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"}]}