{"files":[{"patch":"@@ -884,0 +884,74 @@\n+#ifdef __APPLE__\n+\n+\/\/ macOS has a secure per-user temporary directory.\n+\/\/ Root can attach to a non-root process, hence it needs\n+\/\/ to lookup \/var\/folders for the user specific temporary directory\n+\/\/ of the form \/var\/folders\/*\/*\/T, that contains PERFDATA_NAME_user\n+\/\/ directory.\n+\/\/\n+static const char VAR_FOLDERS[] = \"\/var\/folders\/\";\n+int os::Bsd::get_user_tmp_dir_macos(const char* user, int vmid, char *output_path, int output_size \/* = PATH_MAX *\/) {\n+\n+  \/\/ read the var\/folders directory\n+  DIR* varfolders_dir = os::opendir(VAR_FOLDERS);\n+  if (varfolders_dir != nullptr) {\n+\n+    \/\/ var\/folders directory contains 2-characters subdirectories (buckets)\n+    struct dirent* bucket_de;\n+\n+    \/\/ loop until the PERFDATA_NAME_user directory has been found\n+    while ((bucket_de = os::readdir(varfolders_dir)) != nullptr) {\n+\n+      \/\/ skip over files and special \".\" and \"..\"\n+      if (bucket_de->d_type != DT_DIR || bucket_de->d_name[0] == '.') {\n+        continue;\n+      }\n+\n+      \/\/ absolute path to the bucket\n+      char bucket[PATH_MAX];\n+      int b = snprintf(bucket, PATH_MAX, \"%s%s\/\", VAR_FOLDERS, bucket_de->d_name);\n+\n+      \/\/ the total length of the absolute path must not exceed the buffer size\n+      if (b >= PATH_MAX || b < 0) {\n+        continue;\n+      }\n+\n+      \/\/ each bucket contains next level subdirectories\n+      DIR* bucket_dir = os::opendir(bucket);\n+      if (bucket_dir == nullptr) {\n+        continue;\n+      }\n+\n+      \/\/ read each subdirectory, skipping over regular files\n+      struct dirent* subbucket_de;\n+      while ((subbucket_de = os::readdir(bucket_dir)) != nullptr) {\n+        if (subbucket_de->d_type != DT_DIR || subbucket_de->d_name[0] == '.') {\n+          continue;\n+        }\n+\n+        \/\/ if the PERFDATA_NAME_user directory exists in the T subdirectory,\n+        \/\/ this means the subdirectory is the temporary directory of the user.\n+        \/\/\n+        char perfdata_path[PATH_MAX];\n+        int p = snprintf(perfdata_path, PATH_MAX, \"%s%s\/T\/%s_%s\/\", bucket, subbucket_de->d_name, PERFDATA_NAME, user);\n+\n+        \/\/ the total length must not exceed the output buffer size\n+        if (p >= PATH_MAX || p < 0) {\n+          continue;\n+        }\n+\n+        \/\/ check if the subdirectory exists\n+        if (os::file_exists(perfdata_path)) {\n+\n+          \/\/ the return value of snprintf is not checked for the second time\n+          return snprintf(output_path, output_size, \"%s%s\/T\", bucket, subbucket_de->d_name);\n+        }\n+      }\n+      os::closedir(bucket_dir);\n+    }\n+    os::closedir(varfolders_dir);\n+  }\n+  return -1;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -67,0 +67,4 @@\n+#ifdef __APPLE__\n+  static int get_user_tmp_dir_macos(const char* user, int vmid, char *output_buffer, int buffer_size \/* = PATH_MAX *\/);\n+#endif\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,74 +133,0 @@\n-#ifdef __APPLE__\n-\n-\/\/ macOS has a secure per-user temporary directory.\n-\/\/ Root can attach to a non-root process, hence it needs\n-\/\/ to lookup \/var\/folders for the user specific temporary directory\n-\/\/ of the form \/var\/folders\/*\/*\/T, that contains PERFDATA_NAME_user\n-\/\/ directory.\n-\/\/\n-static const char VAR_FOLDERS[] = \"\/var\/folders\/\";\n-static int get_user_tmp_dir_macos(const char* user, int vmid, char *output_path \/* size = PATH_MAX *\/) {\n-\n-  \/\/ read the var\/folders directory\n-  DIR* varfolders_dir = os::opendir(VAR_FOLDERS);\n-  if (varfolders_dir != nullptr) {\n-\n-    \/\/ var\/folders directory contains 2-characters subdirectories (buckets)\n-    struct dirent* bucket_de;\n-\n-    \/\/ loop until the PERFDATA_NAME_user directory has been found\n-    while ((bucket_de = os::readdir(varfolders_dir)) != nullptr) {\n-\n-      \/\/ skip over files and special \".\" and \"..\"\n-      if (bucket_de->d_type != DT_DIR || bucket_de->d_name[0] == '.') {\n-        continue;\n-      }\n-\n-      \/\/ absolute path to the bucket\n-      char bucket[PATH_MAX];\n-      int b = snprintf(bucket, PATH_MAX, \"%s%s\/\", VAR_FOLDERS, bucket_de->d_name);\n-\n-      \/\/ the total length of the absolute path must not exceed the buffer size\n-      if (b >= PATH_MAX || b < 0) {\n-        continue;\n-      }\n-\n-      \/\/ each bucket contains next level subdirectories\n-      DIR* bucket_dir = os::opendir(bucket);\n-      if (bucket_dir == nullptr) {\n-        continue;\n-      }\n-\n-      \/\/ read each subdirectory, skipping over regular files\n-      struct dirent* subbucket_de;\n-      while ((subbucket_de = os::readdir(bucket_dir)) != nullptr) {\n-        if (subbucket_de->d_type != DT_DIR || subbucket_de->d_name[0] == '.') {\n-          continue;\n-        }\n-\n-        \/\/ if the PERFDATA_NAME_user directory exists in the T subdirectory,\n-        \/\/ this means the subdirectory is the temporary directory of the user.\n-        \/\/\n-        char perfdata_path[PATH_MAX];\n-        int p = snprintf(perfdata_path, PATH_MAX, \"%s%s\/T\/%s_%s\/\", bucket, subbucket_de->d_name, PERFDATA_NAME, user);\n-\n-        \/\/ the total length must not exceed the output buffer size\n-        if (p >= PATH_MAX || p < 0) {\n-          continue;\n-        }\n-\n-        \/\/ check if the subdirectory exists\n-        if (os::file_exists(perfdata_path)) {\n-\n-          \/\/ the return value of snprintf is not checked for the second time\n-          return snprintf(output_path, PATH_MAX, \"%s%s\/T\", bucket, subbucket_de->d_name);\n-        }\n-      }\n-      os::closedir(bucket_dir);\n-    }\n-    os::closedir(varfolders_dir);\n-  }\n-  return -1;\n-}\n-#endif\n-\n@@ -231,1 +157,2 @@\n-    if (get_user_tmp_dir_macos(user, vmid, buffer) != -1) {\n+    int path_size = os::Bsd::get_user_tmp_dir_macos(user, vmid, buffer, sizeof buffer);\n+    if (path_size > 0 && (size_t)path_size < sizeof buffer) {\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":2,"deletions":75,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-                    if(Files.exists(fullPath)) {\n+                    if (Files.exists(fullPath)) {\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}