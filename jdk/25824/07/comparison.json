{"files":[{"patch":"@@ -864,0 +864,93 @@\n+\/\/ Returns the uid of a process or -1 on error.\n+uid_t os::Bsd::get_process_uid(pid_t pid) {\n+  struct kinfo_proc kp;\n+  size_t size = sizeof kp;\n+  int mib_kern[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PID, pid};\n+  if (sysctl(mib_kern, 4, &kp, &size, nullptr, 0) == 0) {\n+    if (size > 0 && kp.kp_proc.p_pid == pid) {\n+      return kp.kp_eproc.e_ucred.cr_uid;\n+    }\n+  }\n+  return (uid_t)-1;\n+}\n+\n+\/\/ Returns true if the process is running as root.\n+bool os::Bsd::is_process_root(pid_t pid) {\n+  uid_t uid = get_process_uid(pid);\n+  return (uid != (uid_t)-1) ? os::Posix::is_root(uid) : false;\n+}\n+\n+#ifdef __APPLE__\n+\n+\/\/ macOS has a secure per-user temporary directory.\n+\/\/ Root can attach to a non-root process, hence it needs\n+\/\/ to lookup \/var\/folders for the user specific temporary directory\n+\/\/ of the form \/var\/folders\/*\/*\/T, that contains PERFDATA_NAME_user\n+\/\/ directory.\n+\/\/\n+static const char VAR_FOLDERS[] = \"\/var\/folders\/\";\n+int os::Bsd::get_user_tmp_dir_macos(const char* user, int vmid, char* output_path, int output_size) {\n+\n+  \/\/ read the var\/folders directory\n+  DIR* varfolders_dir = os::opendir(VAR_FOLDERS);\n+  if (varfolders_dir != nullptr) {\n+\n+    \/\/ var\/folders directory contains 2-characters subdirectories (buckets)\n+    struct dirent* bucket_de;\n+\n+    \/\/ loop until the PERFDATA_NAME_user directory has been found\n+    while ((bucket_de = os::readdir(varfolders_dir)) != nullptr) {\n+\n+      \/\/ skip over files and special \".\" and \"..\"\n+      if (bucket_de->d_type != DT_DIR || bucket_de->d_name[0] == '.') {\n+        continue;\n+      }\n+\n+      \/\/ absolute path to the bucket\n+      char bucket[PATH_MAX];\n+      int b = os::snprintf(bucket, PATH_MAX, \"%s%s\/\", VAR_FOLDERS, bucket_de->d_name);\n+\n+      \/\/ the total length of the absolute path must not exceed the buffer size\n+      if (b >= PATH_MAX || b < 0) {\n+        continue;\n+      }\n+\n+      \/\/ each bucket contains next level subdirectories\n+      DIR* bucket_dir = os::opendir(bucket);\n+      if (bucket_dir == nullptr) {\n+        continue;\n+      }\n+\n+      \/\/ read each subdirectory, skipping over regular files\n+      struct dirent* subbucket_de;\n+      while ((subbucket_de = os::readdir(bucket_dir)) != nullptr) {\n+        if (subbucket_de->d_type != DT_DIR || subbucket_de->d_name[0] == '.') {\n+          continue;\n+        }\n+\n+        \/\/ if the PERFDATA_NAME_user directory exists in the T subdirectory,\n+        \/\/ this means the subdirectory is the temporary directory of the user.\n+        \/\/\n+        char perfdata_path[PATH_MAX];\n+        int p = os::snprintf(perfdata_path, PATH_MAX, \"%s%s\/T\/%s_%s\/\", bucket, subbucket_de->d_name, PERFDATA_NAME, user);\n+\n+        \/\/ the total length must not exceed the output buffer size\n+        if (p >= PATH_MAX || p < 0) {\n+          continue;\n+        }\n+\n+        \/\/ check if the subdirectory exists\n+        if (os::file_exists(perfdata_path)) {\n+\n+          \/\/ the return value of snprintf is not checked for the second time\n+          return os::snprintf(output_path, output_size, \"%s%s\/T\", bucket, subbucket_de->d_name);\n+        }\n+      }\n+      os::closedir(bucket_dir);\n+    }\n+    os::closedir(varfolders_dir);\n+  }\n+  return -1;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,6 @@\n+  static uid_t get_process_uid(pid_t pid);\n+  static bool is_process_root(pid_t pid);\n+\n+#ifdef __APPLE__\n+  static int get_user_tmp_dir_macos(const char* user, int vmid, char* output_buffer, int buffer_size);\n+#endif\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1354,0 +1354,4 @@\n+bool os::Posix::is_current_user_root(){\n+    return is_root(geteuid());\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+  \/\/ Returns true if the current user is root.\n+  static bool is_current_user_root();\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+#if defined(BSD)\n+#include \"os_bsd.hpp\"\n+#endif\n@@ -145,0 +148,12 @@\n+#endif\n+#ifdef __APPLE__\n+  char buffer[PATH_MAX] = {0};\n+  \/\/ Check if the current user is root and the target VM is running as non-root.\n+  \/\/ Otherwise the output of os::get_temp_directory() is used.\n+  \/\/\n+  if (os::Posix::is_current_user_root() && !os::Bsd::is_process_root(vmid)) {\n+    int path_size = os::Bsd::get_user_tmp_dir_macos(user, vmid, buffer, sizeof buffer);\n+    if (path_size > 0 && (size_t)path_size < sizeof buffer) {\n+      tmpdir = buffer;\n+    }\n+  }\n@@ -1141,1 +1156,2 @@\n-  const char* luser = get_user_name(vmid, &nspid, CHECK);\n+  const char* luser = NOT_MACOS(get_user_name(vmid, &nspid, CHECK))\n+                      MACOS_ONLY(get_user_name(os::Bsd::get_process_uid(vmid)));\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import sun.jvmstat.PlatformSupport;\n+\n@@ -34,0 +36,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -42,8 +46,11 @@\n-    \/\/ \"tmpdir\" is used as a global well-known location for the files\n-    \/\/ .java_pid<pid>. and .attach_pid<pid>. It is important that this\n-    \/\/ location is the same for all processes, otherwise the tools\n-    \/\/ will not be able to find all Hotspot processes.\n-    \/\/ This is intentionally not the same as java.io.tmpdir, since\n-    \/\/ the latter can be changed by the user.\n-    \/\/ Any changes to this needs to be synchronized with HotSpot.\n-    private static final String tmpdir;\n+\n+    \/**\n+     * HotSpot PerfData file prefix\n+     *\/\n+    private static final String HSPERFDATA_PREFIX = \"hsperfdata_\";\n+\n+    \/**\n+     * Use platform specific methods for looking up temporary directories.\n+     *\/\n+    private static final PlatformSupport platformSupport = PlatformSupport.getInstance();\n+\n@@ -70,1 +77,3 @@\n-        File socket_file = new File(tmpdir, \".java_pid\" + pid);\n+        \/\/ In macOS the socket file is located in per-user temp directory.\n+        String tempdir = getTempDirFromPid(pid);\n+        File socket_file = new File(tempdir, \".java_pid\" + pid);\n@@ -73,1 +82,1 @@\n-            File f = createAttachFile(pid);\n+            File f = createAttachFile(tempdir, pid);\n@@ -214,1 +223,1 @@\n-    private File createAttachFile(int pid) throws IOException {\n+    private File createAttachFile(String tmpdir, int pid) throws IOException {\n@@ -220,0 +229,22 @@\n+    \/*\n+     * Returns a platform-specific temporary directory for a given process.\n+     * In VMs running as unprivileged user it returns the default platform-specific\n+     * temporary directory. In VMs running as root it searches over the list of\n+     * temporary directories for one containing HotSpot PerfData directory.\n+     *\/\n+    private String getTempDirFromPid(int pid) {\n+        ProcessHandle ph = ProcessHandle.of(pid).orElse(null);\n+        if (ph != null) {\n+            String user = ph.info().user().orElse(null);\n+            if (user != null) {\n+                for (String dir : platformSupport.getTemporaryDirectories(pid)) {\n+                    Path fullPath = Path.of(dir, HSPERFDATA_PREFIX + user, String.valueOf(pid));\n+                    if (Files.exists(fullPath)) {\n+                        return dir;\n+                    }\n+                }\n+            }\n+        }\n+        return PlatformSupport.getTemporaryDirectory();\n+    }\n+\n@@ -238,2 +269,0 @@\n-    static native String getTempDir();\n-\n@@ -242,1 +271,0 @@\n-        tmpdir = getTempDir();\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":42,"deletions":14,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -338,24 +338,0 @@\n-\n-\/*\n- * Class:     sun_tools_attach_BSDVirtualMachine\n- * Method:    getTempDir\n- * Signature: (V)Ljava.lang.String;\n- *\/\n-JNIEXPORT jstring JNICALL Java_sun_tools_attach_VirtualMachineImpl_getTempDir(JNIEnv *env, jclass cls)\n-{\n-    \/\/ This must be hard coded because it's the system's temporary\n-    \/\/ directory not the java application's temp directory, ala java.io.tmpdir.\n-\n-#ifdef __APPLE__\n-    \/\/ macosx has a secure per-user temporary directory.\n-    \/\/ Don't cache the result as this is only called once.\n-    char path[PATH_MAX];\n-    int pathSize = confstr(_CS_DARWIN_USER_TEMP_DIR, path, PATH_MAX);\n-    if (pathSize == 0 || pathSize > PATH_MAX) {\n-        strlcpy(path, \"\/tmp\", sizeof(path));\n-    }\n-    return JNU_NewStringPlatform(env, path);\n-#else \/* __APPLE__ *\/\n-    return (*env)->NewStringUTF(env, \"\/tmp\");\n-#endif \/* __APPLE__ *\/\n-}\n","filename":"src\/jdk.attach\/macosx\/native\/libattach\/VirtualMachineImpl.c","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.jvmstat;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/*\n+ * macOS specific implementation of the PlatformSupport routines\n+ * providing temporary directory support.\n+ *\/\n+public class PlatformSupportImpl extends PlatformSupport {\n+\n+    private static final String VAR_FOLDERS_PATH = \"\/var\/folders\";\n+    private static final String USER_NAME_SYSTEM_PROPERTY = \"user.name\";\n+    private static final String USER_NAME_ROOT = \"root\";\n+    private static final String DIRHELPER_TEMP_STR = \"T\";\n+\n+    private static final boolean isCurrentUserRoot =\n+            System.getProperty(USER_NAME_SYSTEM_PROPERTY).equals(USER_NAME_ROOT);\n+\n+    public PlatformSupportImpl() {\n+        super();\n+    }\n+\n+    \/*\n+     * Return a list of the temporary directories that the VM uses\n+     * for the attach and perf data files.\n+     *\n+     * This function returns the traditional temp directory. Additionally,\n+     * when called by root, it returns other temporary directories of non-root\n+     * users.\n+     *\n+     * macOS per-user temp directories are located under \/var\/folders\n+     * and have the form \/var\/folders\/<BUCKET>\/<ENCODED_UUID_UID>\/T\n+     *\/\n+    @Override\n+    public List<String> getTemporaryDirectories(int pid) {\n+        if (!isCurrentUserRoot) {\n+            \/\/ early exit for non-root\n+            return List.of(PlatformSupport.getTemporaryDirectory());\n+        }\n+        List<String> result = new ArrayList<>();\n+        try (DirectoryStream<Path> bs = Files.newDirectoryStream(Path.of(VAR_FOLDERS_PATH))) {\n+            for (Path bucket : bs) {\n+                try (DirectoryStream<Path> encUuids = Files.newDirectoryStream(bucket)) {\n+                    for (Path encUuid : encUuids) {\n+                        try {\n+                            Path tempDir = encUuid.resolve(DIRHELPER_TEMP_STR);\n+                            if (Files.isDirectory(tempDir) && Files.isReadable(tempDir)) {\n+                                result.add(tempDir.toString());\n+                            }\n+                        } catch (Exception ignore) { \/\/ ignored unreadable bucket\/encUuid, continue\n+                        }\n+                    }\n+                } catch (IOException ignore) { \/\/ IOException ignored, continue to the next bucket\n+                }\n+            }\n+        } catch (Exception ignore) { \/\/ var\/folders directory is inaccessible \/ other errors\n+        }\n+        return result.isEmpty() ? List.of(PlatformSupport.getTemporaryDirectory()) : result;\n+    }\n+}\n","filename":"src\/jdk.internal.jvmstat\/macosx\/classes\/sun\/jvmstat\/PlatformSupportImpl.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+    exports sun.jvmstat to\n+        jdk.attach;\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}