{"files":[{"patch":"@@ -2790,1 +2790,1 @@\n-        DirectiveSet* directive = DirectivesStack::getDefaultDirective(CompileBroker::compiler(CompLevel_simple));\n+        DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, CompileBroker::compiler(CompLevel_simple));\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * @bug 8329126\n- * @summary check that native methods get compiled\n+ * @bug 8329126 8329421\n+ * @summary check that native methods get compiled and printed\n@@ -33,12 +33,1 @@\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *    -Xbatch -XX:-UseOnStackReplacement -XX:+TieredCompilation compiler.calls.NativeCalls\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *    -Xbatch -XX:-UseOnStackReplacement -XX:-TieredCompilation compiler.calls.NativeCalls\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *    -Xbatch -XX:-UseOnStackReplacement -XX:+TieredCompilation -XX:TieredStopAtLevel=1 compiler.calls.NativeCalls\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *    -Xbatch -XX:-UseOnStackReplacement -XX:+TieredCompilation -XX:TieredStopAtLevel=2 compiler.calls.NativeCalls\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *    -Xbatch -XX:-UseOnStackReplacement -XX:+TieredCompilation -XX:TieredStopAtLevel=3 compiler.calls.NativeCalls\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *    -Xbatch -XX:-UseOnStackReplacement -XX:+TieredCompilation -XX:TieredStopAtLevel=4 compiler.calls.NativeCalls\n+ * @run main\/othervm\/native compiler.calls.NativeCalls\n@@ -50,0 +39,4 @@\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.regex.Pattern;\n@@ -51,0 +44,2 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -56,1 +51,0 @@\n-    static WhiteBox wb;\n@@ -62,1 +56,0 @@\n-        wb = WhiteBox.getWhiteBox();\n@@ -77,3 +70,58 @@\n-    static public void main(String[] args) {\n-        for (int i = 0; i < 20_000; i++) {\n-            callNative();\n+    static public void main(String[] args) throws Exception {\n+\n+        ArrayList<String> baseOptions = new ArrayList<String>();\n+        baseOptions.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        baseOptions.add(\"-XX:+WhiteBoxAPI\");\n+        baseOptions.add(\"-Xbootclasspath\/a:.\");\n+        baseOptions.add(\"-Xbatch\");\n+        baseOptions.add(\"-XX:-UseOnStackReplacement\");\n+        baseOptions.add(\"-XX:+PrintCompilation\");\n+        baseOptions.add(Executor.class.getName());\n+        String nativeMethodName = NativeCalls.class.getName() + \"::\" + emptyStaticNativeMethod.getName();\n+        List<Variant> variants = List.of(new Variant(List.of(\"-XX:+TieredCompilation\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\",\n+                                                             \"-XX:+PreferInterpreterNativeStubs\"), \"false\", \"false\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:+PreferInterpreterNativeStubs\"), \"false\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=2\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=3\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=4\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\",\n+                                                             \"-XX:CompileCommand=print,\" + nativeMethodName), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:CompileCommand=print,\" + nativeMethodName), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintAssembly\"), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintNativeNMethods\"), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\",\n+                                                             \"-XX:CompileCommand=exclude,\" + nativeMethodName), \"false\", \"false\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:CompileCommand=exclude,\" + nativeMethodName), \"false\", \"false\"));\n+        for (Variant v : variants) {\n+            ArrayList<String> command = new ArrayList<String>(v.options);\n+            command.addAll(baseOptions);\n+            command.add(v.compile);\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(command);\n+            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+            analyzer.shouldHaveExitValue(0);\n+            System.out.println(analyzer.getOutput());\n+            if (Boolean.valueOf(v.print).booleanValue() &&\n+                analyzer.asLines().stream().\n+                filter(Pattern.compile(\"Compiled method.+\" + nativeMethodName + \".*\").asPredicate()).\n+                findAny().isEmpty()) {\n+                throw new Error(nativeMethodName + \" not printed\");\n+            }\n+        }\n+    }\n+\n+    public static class Variant {\n+        Collection<String> options;\n+        String compile;\n+        String print;\n+        public Variant(Collection<String> options, String compile, String print) {\n+            this.options = options;\n+            this. compile = compile;\n+            this. print = print;\n@@ -81,3 +129,22 @@\n-        if (wb.getMethodCompilationLevel(callNativeMethod) > 0) {\n-            if (!wb.isMethodCompiled(emptyStaticNativeMethod)) {\n-                throw new Error(\"TEST BUG: '\" + emptyStaticNativeMethod + \"' should be compiled\");\n+    }\n+\n+    public static class Executor {\n+\n+        static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+        static public void main(String[] args) {\n+\n+            if (args.length != 1) {\n+                throw new Error(\"Expected two arguments\");\n+            }\n+            boolean compile = Boolean.valueOf(args[0]);\n+            for (int i = 0; i < 20_000; i++) {\n+                callNative();\n+            }\n+            if (wb.getMethodCompilationLevel(callNativeMethod) > 0) {\n+                if (compile && !wb.isMethodCompiled(emptyStaticNativeMethod)) {\n+                    throw new Error(\"TEST BUG: '\" + emptyStaticNativeMethod + \"' should be compiled\");\n+                }\n+                if (!compile && wb.isMethodCompiled(emptyStaticNativeMethod)) {\n+                    throw new Error(\"TEST BUG: '\" + emptyStaticNativeMethod + \"' should not be compiled\");\n+                }\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/NativeCalls.java","additions":89,"deletions":22,"binary":false,"changes":111,"status":"modified"}]}