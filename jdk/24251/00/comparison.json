{"files":[{"patch":"@@ -1404,3 +1404,0 @@\n-void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) { ; }\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -306,2 +306,0 @@\n-  \/\/ only if +VerifyFPU  && (state == ftos || state == dtos)\n-  void verify_FPU(int stack_depth, TosState state = ftos);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,4 +201,0 @@\n-  void verify_FPU(int stack_depth, TosState state = ftos) {\n-    \/\/ No VFP state verification is required for ARM\n-  }\n-\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -268,1 +268,0 @@\n-  void verify_FPU(int stack_depth, TosState state = ftos);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2384,6 +2384,0 @@\n-void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {\n-  if (VerifyFPU) {\n-    unimplemented(\"verfiyFPU\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1434,2 +1434,0 @@\n-void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) { ; }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,4 +287,0 @@\n-  \/\/ Debugging\n-  \/\/ only if +VerifyFPU  && (state == ftos || state == dtos)\n-  void verify_FPU(int stack_depth, TosState state = ftos);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,2 +96,0 @@\n-  verify_FPU(1, state);\n-\n@@ -2192,6 +2190,0 @@\n-\n-void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {\n-  if (VerifyFPU) {\n-    unimplemented(\"verifyFPU\");\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -316,1 +316,0 @@\n-  void verify_FPU(int stack_depth, TosState state = ftos);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-#ifdef _LP64\n@@ -58,3 +57,0 @@\n-#else\n-  assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n-#endif\n@@ -75,1 +71,0 @@\n-#ifdef _LP64\n@@ -77,1 +72,0 @@\n-#endif\n@@ -92,1 +86,1 @@\n-#ifdef _LP64\n+\n@@ -100,1 +94,0 @@\n-#endif\n@@ -317,1 +310,0 @@\n-  NOT_LP64(assert(java_thread == noreg , \"not expecting a precomputed java thread\");)\n@@ -338,1 +330,0 @@\n-#ifdef _LP64\n@@ -390,7 +381,0 @@\n-#else\n-void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n-                         address entry_point,\n-                         Register arg_1) {\n-  MacroAssembler::call_VM(oop_result, entry_point, arg_1);\n-}\n-#endif  \/\/ _LP64\n@@ -407,2 +391,1 @@\n-    Register pop_cond = NOT_LP64(java_thread) \/\/ Not clear if any other register is available on 32 bit\n-                        LP64_ONLY(c_rarg0);\n+    Register pop_cond = c_rarg0;\n@@ -419,1 +402,0 @@\n-    NOT_LP64(get_thread(java_thread);)\n@@ -424,3 +406,1 @@\n-  Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n-  NOT_LP64(get_thread(thread);)\n-  movptr(rcx, Address(thread, JavaThread::jvmti_thread_state_offset()));\n+  movptr(rcx, Address(r15_thread, JavaThread::jvmti_thread_state_offset()));\n@@ -430,1 +410,1 @@\n-#ifdef _LP64\n+\n@@ -446,23 +426,1 @@\n-  \/\/ Clean up tos value in the thread object\n-  movl(tos_addr, ilgl);\n-  movl(val_addr, NULL_WORD);\n-#else\n-  const Address val_addr1(rcx, JvmtiThreadState::earlyret_value_offset()\n-                             + in_ByteSize(wordSize));\n-  switch (state) {\n-    case atos: movptr(rax, oop_addr);\n-               movptr(oop_addr, NULL_WORD);\n-               interp_verify_oop(rax, state);         break;\n-    case ltos:\n-               movl(rdx, val_addr1);               \/\/ fall through\n-    case btos:                                     \/\/ fall through\n-    case ztos:                                     \/\/ fall through\n-    case ctos:                                     \/\/ fall through\n-    case stos:                                     \/\/ fall through\n-    case itos: movl(rax, val_addr);                   break;\n-    case ftos: load_float(val_addr);                  break;\n-    case dtos: load_double(val_addr);                 break;\n-    case vtos: \/* nothing to do *\/                    break;\n-    default  : ShouldNotReachHere();\n-  }\n-#endif \/\/ _LP64\n+\n@@ -472,1 +430,0 @@\n-  NOT_LP64(movptr(val_addr1, NULL_WORD);)\n@@ -479,2 +436,2 @@\n-    Register tmp = LP64_ONLY(c_rarg0) NOT_LP64(java_thread);\n-    Register rthread = LP64_ONLY(r15_thread) NOT_LP64(java_thread);\n+    Register tmp = c_rarg0;\n+    Register rthread = r15_thread;\n@@ -495,1 +452,0 @@\n-    NOT_LP64(get_thread(java_thread);)\n@@ -497,1 +453,0 @@\n-#ifdef _LP64\n@@ -500,4 +455,0 @@\n-#else\n-    pushl(Address(tmp, JvmtiThreadState::earlyret_tos_offset()));\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, Interpreter::remove_activation_early_entry), 1);\n-#endif \/\/ _LP64\n@@ -506,1 +457,0 @@\n-    NOT_LP64(get_thread(java_thread);)\n@@ -585,17 +535,0 @@\n-#ifndef _LP64\n-void InterpreterMacroAssembler::f2ieee() {\n-  if (IEEEPrecision) {\n-    fstp_s(Address(rsp, 0));\n-    fld_s(Address(rsp, 0));\n-  }\n-}\n-\n-\n-void InterpreterMacroAssembler::d2ieee() {\n-  if (IEEEPrecision) {\n-    fstp_d(Address(rsp, 0));\n-    fld_d(Address(rsp, 0));\n-  }\n-}\n-#endif \/\/ _LP64\n-\n@@ -640,1 +573,0 @@\n-#ifdef _LP64\n@@ -691,99 +623,0 @@\n-#else\n-void InterpreterMacroAssembler::pop_i(Register r) {\n-  pop(r);\n-}\n-\n-void InterpreterMacroAssembler::pop_l(Register lo, Register hi) {\n-  pop(lo);\n-  pop(hi);\n-}\n-\n-void InterpreterMacroAssembler::pop_f() {\n-  fld_s(Address(rsp, 0));\n-  addptr(rsp, 1 * wordSize);\n-}\n-\n-void InterpreterMacroAssembler::pop_d() {\n-  fld_d(Address(rsp, 0));\n-  addptr(rsp, 2 * wordSize);\n-}\n-\n-\n-void InterpreterMacroAssembler::pop(TosState state) {\n-  switch (state) {\n-    case atos: pop_ptr(rax);                                 break;\n-    case btos:                                               \/\/ fall through\n-    case ztos:                                               \/\/ fall through\n-    case ctos:                                               \/\/ fall through\n-    case stos:                                               \/\/ fall through\n-    case itos: pop_i(rax);                                   break;\n-    case ltos: pop_l(rax, rdx);                              break;\n-    case ftos:\n-      if (UseSSE >= 1) {\n-        pop_f(xmm0);\n-      } else {\n-        pop_f();\n-      }\n-      break;\n-    case dtos:\n-      if (UseSSE >= 2) {\n-        pop_d(xmm0);\n-      } else {\n-        pop_d();\n-      }\n-      break;\n-    case vtos: \/* nothing to do *\/                           break;\n-    default  : ShouldNotReachHere();\n-  }\n-  interp_verify_oop(rax, state);\n-}\n-\n-\n-void InterpreterMacroAssembler::push_l(Register lo, Register hi) {\n-  push(hi);\n-  push(lo);\n-}\n-\n-void InterpreterMacroAssembler::push_f() {\n-  \/\/ Do not schedule for no AGI! Never write beyond rsp!\n-  subptr(rsp, 1 * wordSize);\n-  fstp_s(Address(rsp, 0));\n-}\n-\n-void InterpreterMacroAssembler::push_d() {\n-  \/\/ Do not schedule for no AGI! Never write beyond rsp!\n-  subptr(rsp, 2 * wordSize);\n-  fstp_d(Address(rsp, 0));\n-}\n-\n-\n-void InterpreterMacroAssembler::push(TosState state) {\n-  interp_verify_oop(rax, state);\n-  switch (state) {\n-    case atos: push_ptr(rax); break;\n-    case btos:                                               \/\/ fall through\n-    case ztos:                                               \/\/ fall through\n-    case ctos:                                               \/\/ fall through\n-    case stos:                                               \/\/ fall through\n-    case itos: push_i(rax);                                    break;\n-    case ltos: push_l(rax, rdx);                               break;\n-    case ftos:\n-      if (UseSSE >= 1) {\n-        push_f(xmm0);\n-      } else {\n-        push_f();\n-      }\n-      break;\n-    case dtos:\n-      if (UseSSE >= 2) {\n-        push_d(xmm0);\n-      } else {\n-        push_d();\n-      }\n-      break;\n-    case vtos: \/* nothing to do *\/                             break;\n-    default  : ShouldNotReachHere();\n-  }\n-}\n-#endif \/\/ _LP64\n-\n@@ -824,3 +657,1 @@\n-    LP64_ONLY(temp = r15_thread;)\n-    NOT_LP64(get_thread(temp);)\n-    cmpb(Address(temp, JavaThread::interp_only_mode_offset()), 0);\n+    cmpb(Address(r15_thread, JavaThread::interp_only_mode_offset()), 0);\n@@ -849,1 +680,0 @@\n-  verify_FPU(1, state);\n@@ -867,1 +697,0 @@\n-#ifdef _LP64\n@@ -882,21 +711,0 @@\n-\n-#else\n-  Address index(noreg, rbx, Address::times_ptr);\n-  if (table != safepoint_table && generate_poll) {\n-    NOT_PRODUCT(block_comment(\"Thread-local Safepoint poll\"));\n-    Label no_safepoint;\n-    const Register thread = rcx;\n-    get_thread(thread);\n-    testb(Address(thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n-\n-    jccb(Assembler::zero, no_safepoint);\n-    ArrayAddress dispatch_addr(ExternalAddress((address)safepoint_table), index);\n-    jump(dispatch_addr, noreg);\n-    bind(no_safepoint);\n-  }\n-\n-  {\n-    ArrayAddress dispatch_addr(ExternalAddress((address)table), index);\n-    jump(dispatch_addr, noreg);\n-  }\n-#endif \/\/ _LP64\n@@ -954,3 +762,1 @@\n-  LP64_ONLY(movsbl(result, result);)\n-  NOT_LP64(shll(result, 24);)      \/\/ truncate upper 24 bits\n-  NOT_LP64(sarl(result, 24);)      \/\/ and sign-extend byte\n+  movsbl(result, result);\n@@ -962,2 +768,1 @@\n-  LP64_ONLY(movzwl(result, result);)\n-  NOT_LP64(andl(result, 0xFFFF);)  \/\/ truncate upper 16 bits\n+  movzwl(result, result);\n@@ -969,3 +774,1 @@\n-  LP64_ONLY(movswl(result, result);)\n-  NOT_LP64(shll(result, 16);)      \/\/ truncate upper 16 bits\n-  NOT_LP64(sarl(result, 16);)      \/\/ and sign-extend short\n+  movswl(result, result);\n@@ -1001,6 +804,3 @@\n-  const Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n-  const Register robj    = LP64_ONLY(c_rarg1) NOT_LP64(rdx);\n-  const Register rmon    = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n-                              \/\/ monitor pointers need different register\n-                              \/\/ because rdx may have the result in it\n-  NOT_LP64(get_thread(rthread);)\n+  const Register rthread = r15_thread;\n+  const Register robj    = c_rarg1;\n+  const Register rmon    = c_rarg1;\n@@ -1019,1 +819,0 @@\n-  NOT_LP64(get_thread(rthread);) \/\/ call_VM clobbered it, restore\n@@ -1060,1 +859,0 @@\n-    NOT_LP64(empty_FPU_stack();)  \/\/ remove possible return value from FPU-stack, otherwise stack could overflow\n@@ -1069,1 +867,0 @@\n-      NOT_LP64(empty_FPU_stack();)\n@@ -1111,1 +908,0 @@\n-      NOT_LP64(empty_FPU_stack();)\n@@ -1127,1 +923,0 @@\n-        NOT_LP64(empty_FPU_stack();)\n@@ -1162,1 +957,1 @@\n-    Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n+    Register rthread = r15_thread;\n@@ -1165,2 +960,0 @@\n-    NOT_LP64(get_thread(rthread);)\n-\n@@ -1212,2 +1005,1 @@\n-  assert(lock_reg == LP64_ONLY(c_rarg1) NOT_LP64(rdx),\n-         \"The argument is only for looks. It must be c_rarg1\");\n+  assert(lock_reg == c_rarg1, \"The argument is only for looks. It must be c_rarg1\");\n@@ -1224,1 +1016,1 @@\n-    const Register obj_reg = LP64_ONLY(c_rarg3) NOT_LP64(rcx); \/\/ Will contain the oop\n+    const Register obj_reg = c_rarg3; \/\/ Will contain the oop\n@@ -1242,1 +1034,0 @@\n-#ifdef _LP64\n@@ -1245,4 +1036,0 @@\n-#else\n-      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n-      jmp(slow_case);\n-#endif\n@@ -1266,1 +1053,1 @@\n-      const int zero_bits = LP64_ONLY(7) NOT_LP64(3);\n+      const int zero_bits = 7;\n@@ -1331,2 +1118,1 @@\n-  assert(lock_reg == LP64_ONLY(c_rarg1) NOT_LP64(rdx),\n-         \"The argument is only for looks. It must be c_rarg1\");\n+  assert(lock_reg == c_rarg1, \"The argument is only for looks. It must be c_rarg1\");\n@@ -1340,2 +1126,2 @@\n-    const Register header_reg = LP64_ONLY(c_rarg2) NOT_LP64(rbx);  \/\/ Will contain the old oopMark\n-    const Register obj_reg    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);  \/\/ Will contain the oop\n+    const Register header_reg = c_rarg2;  \/\/ Will contain the old oopMark\n+    const Register obj_reg    = c_rarg3;  \/\/ Will contain the oop\n@@ -1358,1 +1144,0 @@\n-#ifdef _LP64\n@@ -1360,4 +1145,0 @@\n-#else\n-      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n-      jmp(slow_case);\n-#endif\n@@ -1439,2 +1220,2 @@\n-  Register arg3_reg = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n-  Register arg2_reg = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n+  Register arg3_reg = c_rarg3;\n+  Register arg2_reg = c_rarg2;\n@@ -1898,2 +1679,0 @@\n-      NOT_LP64(assert(reg2 == rdi, \"we know how to fix this blown reg\");)\n-      NOT_LP64(restore_locals();)         \/\/ Restore EDI\n@@ -1967,8 +1746,0 @@\n-void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {\n-#ifndef _LP64\n-  if ((state == ftos && UseSSE < 1) ||\n-      (state == dtos && UseSSE < 2)) {\n-    MacroAssembler::verify_FPU(stack_depth);\n-  }\n-#endif\n-}\n@@ -1995,2 +1766,2 @@\n-  Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n-  Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rbx);\n+  Register rthread = r15_thread;\n+  Register rarg = c_rarg1;\n@@ -1999,1 +1770,0 @@\n-    NOT_LP64(get_thread(rthread);)\n@@ -2009,1 +1779,0 @@\n-    NOT_LP64(get_thread(rthread);)\n@@ -2017,1 +1786,0 @@\n-    NOT_LP64(get_thread(rthread);)\n@@ -2031,2 +1799,2 @@\n-  Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n-  Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rbx);\n+  Register rthread = r15_thread;\n+  Register rarg = c_rarg1;\n@@ -2042,1 +1810,0 @@\n-    NOT_LP64(get_thread(rthread);)\n@@ -2054,1 +1821,0 @@\n-    NOT_LP64(get_thread(rthread);)\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":27,"deletions":261,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-    _locals_register(LP64_ONLY(r14) NOT_LP64(rdi)),\n-    _bcp_register(LP64_ONLY(r13) NOT_LP64(rsi)) {}\n+    _locals_register(r14),\n+    _bcp_register(r13) {}\n@@ -124,3 +124,0 @@\n-  NOT_LP64(void f2ieee();)        \/\/ truncate ftos to 32bits\n-  NOT_LP64(void d2ieee();)        \/\/ truncate dtos to 64bits\n-\n@@ -146,1 +143,0 @@\n-#ifdef _LP64\n@@ -149,9 +145,0 @@\n-#else\n-  void pop_l(Register lo = rax, Register hi = rdx);\n-  void pop_f();\n-  void pop_d();\n-\n-  void push_l(Register lo = rax, Register hi = rdx);\n-  void push_d();\n-  void push_f();\n-#endif \/\/ _LP64\n@@ -171,1 +158,0 @@\n-    NOT_LP64(empty_FPU_stack());\n@@ -276,2 +262,0 @@\n-  \/\/ only if +VerifyFPU  && (state == ftos || state == dtos)\n-  void verify_FPU(int stack_depth, TosState state = ftos);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#ifdef AMD64\n@@ -44,4 +43,0 @@\n-#else\n-  void move(int from_offset, int to_offset);\n-  void box(int from_offset, int to_offset);\n-#endif \/\/ AMD64\n@@ -52,1 +47,0 @@\n-#ifdef AMD64\n@@ -54,1 +48,0 @@\n-#endif \/\/ AMD64\n","filename":"src\/hotspot\/cpu\/x86\/interpreterRT_x86.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-#ifdef AMD64\n@@ -68,3 +67,0 @@\n-#else\n-int TemplateInterpreter::InterpreterCodeSize = 224 * 1024;\n-#endif \/\/ AMD64\n@@ -73,2 +69,2 @@\n-static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);\n-static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);\n+static const Register rbcp     = r13;\n+static const Register rlocals  = r14;\n@@ -123,1 +119,0 @@\n-  Register rarg = NOT_LP64(rax) LP64_ONLY(c_rarg1);\n@@ -128,1 +123,1 @@\n-             rarg, rbx);\n+             c_rarg1, rbx);\n@@ -136,2 +131,1 @@\n-  Register rarg = NOT_LP64(rax) LP64_ONLY(c_rarg1);\n-  __ pop(rarg);\n+  __ pop(c_rarg1);\n@@ -147,1 +141,1 @@\n-             rarg);\n+             c_rarg1);\n@@ -156,3 +150,0 @@\n-  Register rarg = NOT_LP64(rax) LP64_ONLY(c_rarg1);\n-  Register rarg2 = NOT_LP64(rbx) LP64_ONLY(c_rarg2);\n-\n@@ -161,1 +152,1 @@\n-    __ pop(rarg2);\n+    __ pop(c_rarg2);\n@@ -167,1 +158,1 @@\n-  __ lea(rarg, ExternalAddress((address)name));\n+  __ lea(c_rarg1, ExternalAddress((address)name));\n@@ -172,1 +163,1 @@\n-               rarg, rarg2);\n+               c_rarg1, c_rarg2);\n@@ -174,1 +165,1 @@\n-    __ lea(rarg2, ExternalAddress((address)message));\n+    __ lea(c_rarg2, ExternalAddress((address)message));\n@@ -177,1 +168,1 @@\n-               rarg, rarg2);\n+               c_rarg1, c_rarg2);\n@@ -187,24 +178,0 @@\n-#ifndef _LP64\n-#ifdef COMPILER2\n-  \/\/ The FPU stack is clean if UseSSE >= 2 but must be cleaned in other cases\n-  if ((state == ftos && UseSSE < 1) || (state == dtos && UseSSE < 2)) {\n-    for (int i = 1; i < 8; i++) {\n-        __ ffree(i);\n-    }\n-  } else if (UseSSE < 2) {\n-    __ empty_FPU_stack();\n-  }\n-#endif \/\/ COMPILER2\n-  if ((state == ftos && UseSSE < 1) || (state == dtos && UseSSE < 2)) {\n-    __ MacroAssembler::verify_FPU(1, \"generate_return_entry_for compiled\");\n-  } else {\n-    __ MacroAssembler::verify_FPU(0, \"generate_return_entry_for compiled\");\n-  }\n-\n-  if (state == ftos) {\n-    __ MacroAssembler::verify_FPU(UseSSE >= 1 ? 0 : 1, \"generate_return_entry_for in interpreter\");\n-  } else if (state == dtos) {\n-    __ MacroAssembler::verify_FPU(UseSSE >= 2 ? 0 : 1, \"generate_return_entry_for in interpreter\");\n-  }\n-#endif \/\/ _LP64\n-\n@@ -239,1 +206,0 @@\n-   const Register java_thread = NOT_LP64(rcx) LP64_ONLY(r15_thread);\n@@ -241,2 +207,1 @@\n-     NOT_LP64(__ get_thread(java_thread));\n-     __ check_and_handle_popframe(java_thread);\n+     __ check_and_handle_popframe(r15_thread);\n@@ -245,2 +210,1 @@\n-     NOT_LP64(__ get_thread(java_thread));\n-     __ check_and_handle_earlyret(java_thread);\n+     __ check_and_handle_earlyret(r15_thread);\n@@ -258,8 +222,0 @@\n-#ifndef _LP64\n-  if (state == ftos) {\n-    __ MacroAssembler::verify_FPU(UseSSE >= 1 ? 0 : 1, \"generate_deopt_entry_for in interpreter\");\n-  } else if (state == dtos) {\n-    __ MacroAssembler::verify_FPU(UseSSE >= 2 ? 0 : 1, \"generate_deopt_entry_for in interpreter\");\n-  }\n-#endif \/\/ _LP64\n-\n@@ -270,2 +226,1 @@\n-  const Register thread = NOT_LP64(rcx) LP64_ONLY(r15_thread);\n-  NOT_LP64(__ get_thread(thread));\n+  const Register thread = r15_thread;\n@@ -322,3 +277,0 @@\n-#ifndef _LP64\n-  case T_CHAR   : __ andptr(rax, 0xFFFF);    break;\n-#else\n@@ -326,1 +278,0 @@\n-#endif \/\/ _LP64\n@@ -332,27 +283,0 @@\n-#ifndef _LP64\n-  case T_DOUBLE :\n-  case T_FLOAT  :\n-    { const Register t = InterpreterRuntime::SignatureHandlerGenerator::temp();\n-      __ pop(t);                            \/\/ remove return address first\n-      \/\/ Must return a result for interpreter or compiler. In SSE\n-      \/\/ mode, results are returned in xmm0 and the FPU stack must\n-      \/\/ be empty.\n-      if (type == T_FLOAT && UseSSE >= 1) {\n-        \/\/ Load ST0\n-        __ fld_d(Address(rsp, 0));\n-        \/\/ Store as float and empty fpu stack\n-        __ fstp_s(Address(rsp, 0));\n-        \/\/ and reload\n-        __ movflt(xmm0, Address(rsp, 0));\n-      } else if (type == T_DOUBLE && UseSSE >= 2 ) {\n-        __ movdbl(xmm0, Address(rsp, 0));\n-      } else {\n-        \/\/ restore ST0\n-        __ fld_d(Address(rsp, 0));\n-      }\n-      \/\/ and pop the temp\n-      __ addptr(rsp, 2 * wordSize);\n-      __ push(t);                           \/\/ restore return address\n-    }\n-    break;\n-#else\n@@ -361,1 +285,0 @@\n-#endif \/\/ _LP64\n@@ -470,2 +393,1 @@\n-  Register rarg = NOT_LP64(rax) LP64_ONLY(c_rarg1);\n-  __ movl(rarg, 0);\n+  __ movl(c_rarg1, 0);\n@@ -475,1 +397,1 @@\n-             rarg);\n+             c_rarg1);\n@@ -526,5 +448,0 @@\n-  const Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);\n-#ifndef _LP64\n-  __ push(thread);\n-  __ get_thread(thread);\n-#endif\n@@ -532,1 +449,1 @@\n-  const Address stack_limit(thread, JavaThread::stack_overflow_limit_offset());\n+  const Address stack_limit(r15_thread, JavaThread::stack_overflow_limit_offset());\n@@ -555,1 +472,0 @@\n-  NOT_LP64(__ pop(rsi));  \/\/ get saved bcp\n@@ -571,1 +487,0 @@\n-  NOT_LP64(__ pop(rsi));\n@@ -634,3 +549,2 @@\n-  const Register lockreg = NOT_LP64(rdx) LP64_ONLY(c_rarg1);\n-  __ movptr(lockreg, rsp); \/\/ object address\n-  __ lock_object(lockreg);\n+  __ movptr(c_rarg1, rsp); \/\/ object address\n+  __ lock_object(c_rarg1);\n@@ -731,4 +645,0 @@\n-  \/\/ Preserve the sender sp in case the load barrier\n-  \/\/ calls the runtime\n-  NOT_LP64(__ push(rsi));\n-\n@@ -740,2 +650,0 @@\n-  const Register sender_sp = NOT_LP64(rsi) LP64_ONLY(r13);\n-  NOT_LP64(__ pop(rsi));      \/\/ get sender sp\n@@ -743,1 +651,1 @@\n-  __ mov(rsp, sender_sp);     \/\/ set sp to sender sp\n+  __ mov(rsp, r13);           \/\/ set sp to sender sp\n@@ -767,5 +675,1 @@\n-  const Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);\n-#ifndef _LP64\n-  __ push(thread);\n-  __ get_thread(thread);\n-#endif\n+  const Register thread = r15_thread;\n@@ -803,4 +707,0 @@\n-\n-#ifndef _LP64\n-  __ pop(thread);\n-#endif\n@@ -880,3 +780,1 @@\n-  const Register thread1 = NOT_LP64(rax) LP64_ONLY(r15_thread);\n-  NOT_LP64(__ get_thread(thread1));\n-  const Address do_not_unlock_if_synchronized(thread1,\n+  const Address do_not_unlock_if_synchronized(r15_thread,\n@@ -898,1 +796,0 @@\n-  NOT_LP64(__ get_thread(thread1));\n@@ -940,2 +837,2 @@\n-  const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread);\n-  const Register t      = NOT_LP64(rcx) LP64_ONLY(r11);\n+  const Register thread = r15_thread;\n+  const Register t      = r11;\n@@ -948,6 +845,0 @@\n-#ifndef _LP64\n-  __ shlptr(t, Interpreter::logStackElementSize); \/\/ Convert parameter count to bytes.\n-  __ addptr(t, 2*wordSize);     \/\/ allocate two more slots for JNIEnv and possible mirror\n-  __ subptr(rsp, t);\n-  __ andptr(rsp, -(StackAlignmentInBytes)); \/\/ gcc needs 16 byte aligned stacks to do XMM intrinsics\n-#else\n@@ -959,1 +850,0 @@\n-#endif \/\/ _LP64\n@@ -981,1 +871,1 @@\n-  assert(InterpreterRuntime::SignatureHandlerGenerator::temp() == NOT_LP64(t) LP64_ONLY(rscratch1),\n+  assert(InterpreterRuntime::SignatureHandlerGenerator::temp() == rscratch1,\n@@ -1010,4 +900,0 @@\n-#ifndef _LP64\n-    __ lea(t, Address(rbp, frame::interpreter_frame_oop_temp_offset * wordSize));\n-    __ movptr(Address(rsp, wordSize), t);\n-#else\n@@ -1016,1 +902,0 @@\n-#endif \/\/ _LP64\n@@ -1037,10 +922,0 @@\n-#ifndef _LP64\n-   __ get_thread(thread);\n-   __ lea(t, Address(thread, JavaThread::jni_environment_offset()));\n-   __ movptr(Address(rsp, 0), t);\n-\n-   \/\/ set_last_Java_frame_before_call\n-   \/\/ It is enough that the pc()\n-   \/\/ points into the right code segment. It does not have to be the correct return pc.\n-   __ set_last_Java_frame(thread, noreg, rbp, __ pc(), noreg);\n-#else\n@@ -1055,1 +930,0 @@\n-#endif \/\/ _LP64\n@@ -1091,26 +965,0 @@\n-#ifndef _LP64\n-  \/\/ save potential result in ST(0) & rdx:rax\n-  \/\/ (if result handler is the T_FLOAT or T_DOUBLE handler, result must be in ST0 -\n-  \/\/ the check is necessary to avoid potential Intel FPU overflow problems by saving\/restoring 'empty' FPU registers)\n-  \/\/ It is safe to do this push because state is _thread_in_native and return address will be found\n-  \/\/ via _last_native_pc and not via _last_jave_sp\n-\n-  \/\/ NOTE: the order of these push(es) is known to frame::interpreter_frame_result.\n-  \/\/ If the order changes or anything else is added to the stack the code in\n-  \/\/ interpreter_frame_result will have to be changed.\n-\n-  { Label L;\n-    Label push_double;\n-    ExternalAddress float_handler(AbstractInterpreter::result_handler(T_FLOAT));\n-    ExternalAddress double_handler(AbstractInterpreter::result_handler(T_DOUBLE));\n-    __ cmpptr(Address(rbp, (frame::interpreter_frame_result_handler_offset)*wordSize),\n-              float_handler.addr(), noreg);\n-    __ jcc(Assembler::equal, push_double);\n-    __ cmpptr(Address(rbp, (frame::interpreter_frame_result_handler_offset)*wordSize),\n-              double_handler.addr(), noreg);\n-    __ jcc(Assembler::notEqual, L);\n-    __ bind(push_double);\n-    __ push_d(); \/\/ FP values are returned using the FPU, so push FPU contents (even if UseSSE > 0).\n-    __ bind(L);\n-  }\n-#else\n@@ -1118,2 +966,0 @@\n-#endif \/\/ _LP64\n-\n@@ -1123,1 +969,0 @@\n-  NOT_LP64(__ get_thread(thread));\n@@ -1133,6 +978,0 @@\n-#ifndef _LP64\n-  if (AlwaysRestoreFPU) {\n-    \/\/  Make sure the control word is correct.\n-    __ fldcw(ExternalAddress(StubRoutines::x86::addr_fpu_cntrl_wrd_std()));\n-  }\n-#endif \/\/ _LP64\n@@ -1158,7 +997,0 @@\n-#ifndef _LP64\n-    __ push(thread);\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address,\n-                                            JavaThread::check_special_condition_for_native_trans)));\n-    __ increment(rsp, wordSize);\n-    __ get_thread(thread);\n-#else\n@@ -1172,1 +1004,0 @@\n-#endif \/\/ _LP64\n@@ -1179,1 +1010,0 @@\n-#ifdef _LP64\n@@ -1195,1 +1025,0 @@\n-#endif \/\/ _LP64\n@@ -1237,4 +1066,0 @@\n-#ifndef _LP64\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n-    __ popa();\n-#else\n@@ -1248,1 +1073,0 @@\n-#endif \/\/ _LP64\n@@ -1296,1 +1120,1 @@\n-      const Register regmon = NOT_LP64(rdx) LP64_ONLY(c_rarg1);\n+      const Register regmon = c_rarg1;\n@@ -1328,1 +1152,1 @@\n-  LP64_ONLY( __ pop(dtos));\n+  __ pop(dtos);\n@@ -1457,3 +1281,1 @@\n-  const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);\n-  NOT_LP64(__ get_thread(thread));\n-  const Address do_not_unlock_if_synchronized(thread,\n+  const Address do_not_unlock_if_synchronized(r15_thread,\n@@ -1477,1 +1299,0 @@\n-  NOT_LP64(__ get_thread(thread));\n@@ -1544,1 +1365,1 @@\n-  LP64_ONLY(__ reinit_heapbase());  \/\/ restore r12 as heapbase.\n+  __ reinit_heapbase();  \/\/ restore r12 as heapbase.\n@@ -1551,2 +1372,1 @@\n-  Register rarg = NOT_LP64(rax) LP64_ONLY(c_rarg1);\n-  LP64_ONLY(__ mov(c_rarg1, rax));\n+  __ mov(c_rarg1, rax);\n@@ -1561,1 +1381,1 @@\n-             rarg);\n+             c_rarg1);\n@@ -1591,2 +1411,1 @@\n-  const Register thread = NOT_LP64(rcx) LP64_ONLY(r15_thread);\n-  NOT_LP64(__ get_thread(thread));\n+  const Register thread = r15_thread;\n@@ -1609,2 +1428,1 @@\n-    Register rarg = NOT_LP64(rdx) LP64_ONLY(c_rarg1);\n-    __ movptr(rarg, Address(rbp, frame::return_addr_offset * wordSize));\n+    __ movptr(c_rarg1, Address(rbp, frame::return_addr_offset * wordSize));\n@@ -1612,1 +1430,1 @@\n-                               InterpreterRuntime::interpreter_contains), rarg);\n+                               InterpreterRuntime::interpreter_contains), c_rarg1);\n@@ -1627,1 +1445,0 @@\n-    NOT_LP64(__ get_thread(thread));\n@@ -1640,1 +1457,0 @@\n-    NOT_LP64(__ get_thread(thread));\n@@ -1666,10 +1482,0 @@\n-#ifndef _LP64\n-  __ mov(rax, rsp);\n-  __ movptr(rbx, Address(rbp, frame::interpreter_frame_last_sp_offset * wordSize));\n-  __ lea(rbx, Address(rbp, rbx, Address::times_ptr));\n-  __ get_thread(thread);\n-  \/\/ PC must point into interpreter here\n-  __ set_last_Java_frame(thread, noreg, rbp, __ pc(), noreg);\n-  __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::popframe_move_outgoing_args), thread, rax, rbx);\n-  __ get_thread(thread);\n-#else\n@@ -1682,1 +1488,0 @@\n-#endif\n@@ -1699,1 +1504,0 @@\n-  NOT_LP64(__ get_thread(thread));\n@@ -1733,1 +1537,0 @@\n-  NOT_LP64(__ get_thread(thread));\n@@ -1738,1 +1541,0 @@\n-  NOT_LP64(__ get_thread(thread));\n@@ -1774,3 +1576,1 @@\n-  const Register thread = NOT_LP64(rcx) LP64_ONLY(r15_thread);\n-  NOT_LP64(__ get_thread(thread));\n-  __ movptr(rcx, Address(thread, JavaThread::jvmti_thread_state_offset()));\n+  __ movptr(rcx, Address(r15_thread, JavaThread::jvmti_thread_state_offset()));\n@@ -1807,8 +1607,0 @@\n-#ifndef _LP64\n-  fep = __ pc();     \/\/ ftos entry point\n-      __ push(ftos);\n-      __ jmpb(L);\n-  dep = __ pc();     \/\/ dtos entry point\n-      __ push(dtos);\n-      __ jmpb(L);\n-#else\n@@ -1821,1 +1613,0 @@\n-#endif \/\/ _LP64\n@@ -1840,13 +1631,0 @@\n-#ifndef _LP64\n-  \/\/ prepare expression stack\n-  __ pop(rcx);          \/\/ pop return address so expression stack is 'pure'\n-  __ push(state);       \/\/ save tosca\n-\n-  \/\/ pass tosca registers as arguments & call tracer\n-  __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::trace_bytecode), rcx, rax, rdx);\n-  __ mov(rcx, rax);     \/\/ make sure return address is not destroyed by pop(state)\n-  __ pop(state);        \/\/ restore tosca\n-\n-  \/\/ return\n-  __ jmp(rcx);\n-#else\n@@ -1871,1 +1649,0 @@\n-#endif \/\/ _LP64\n@@ -1877,3 +1654,0 @@\n-  #ifndef _LP64\n-  __ incrementl(ExternalAddress((address) &BytecodeCounter::_counter_value), rscratch1);\n-  #else\n@@ -1881,1 +1655,0 @@\n-  #endif\n@@ -1907,3 +1680,0 @@\n-#ifndef _LP64\n-  __ call(RuntimeAddress(Interpreter::trace_code(t->tos_in())));\n-#else\n@@ -1915,1 +1685,0 @@\n-#endif \/\/ _LP64\n@@ -1921,5 +1690,0 @@\n-  #ifndef _LP64\n-  __ cmp32(ExternalAddress((address) &BytecodeCounter::_counter_value),\n-           StopInterpreterAt,\n-           rscratch1);\n-  #else\n@@ -1928,1 +1692,0 @@\n-  #endif\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":34,"deletions":271,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-static const Register rbcp     = LP64_ONLY(r13) NOT_LP64(rsi);\n-static const Register rlocals  = LP64_ONLY(r14) NOT_LP64(rdi);\n+static const Register rbcp     = r13;\n+static const Register rlocals  = r14;\n@@ -66,6 +66,0 @@\n-#ifndef _LP64\n-static inline Address haddress(int n) {\n-  return iaddress(n + 0);\n-}\n-#endif\n-\n@@ -92,6 +86,0 @@\n-#ifndef _LP64\n-static inline Address haddress(Register r)       {\n-  return Address(rlocals, r, Interpreter::stackElementScale(), Interpreter::local_offset_in_bytes(0));\n-}\n-#endif\n-\n@@ -159,4 +147,1 @@\n-  __ store_heap_oop(dst, val,\n-                    NOT_LP64(rdx) LP64_ONLY(rscratch2),\n-                    NOT_LP64(rbx) LP64_ONLY(r9),\n-                    NOT_LP64(rsi) LP64_ONLY(r8), decorators);\n+  __ store_heap_oop(dst, val, rscratch2, r9, r8, decorators);\n@@ -288,4 +273,0 @@\n-#ifndef _LP64\n-  assert(value >= 0, \"check this code\");\n-  __ xorptr(rdx, rdx);\n-#endif\n@@ -315,1 +296,0 @@\n-#ifdef _LP64\n@@ -317,7 +297,0 @@\n-#else\n-           if (value == 0) { __ fldz();\n-    } else if (value == 1) { __ fld1();\n-    } else if (value == 2) { __ fld1(); __ fld1(); __ faddp(); \/\/ should do a better solution here\n-    } else                 { ShouldNotReachHere();\n-    }\n-#endif \/\/ _LP64\n@@ -343,1 +316,0 @@\n-#ifdef _LP64\n@@ -345,6 +317,0 @@\n-#else\n-           if (value == 0) { __ fldz();\n-    } else if (value == 1) { __ fld1();\n-    } else                 { ShouldNotReachHere();\n-    }\n-#endif\n@@ -368,1 +334,1 @@\n-  Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);\n+  Register rarg = c_rarg1;\n@@ -436,1 +402,1 @@\n-  Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);\n+  Register rarg = c_rarg1;\n@@ -499,1 +465,0 @@\n-  NOT_LP64(__ movptr(rdx, Address(rcx, rbx, Address::times_ptr, base_offset + 1 * wordSize)));\n@@ -513,1 +478,1 @@\n-  const Register rarg = NOT_LP64(rcx) LP64_ONLY(c_rarg1);\n+  const Register rarg = c_rarg1;\n@@ -516,6 +481,0 @@\n-#ifndef _LP64\n-  \/\/ borrow rdi from locals\n-  __ get_thread(rdi);\n-  __ get_vm_result_2(flags, rdi);\n-  __ restore_locals();\n-#else\n@@ -523,1 +482,0 @@\n-#endif\n@@ -598,1 +556,0 @@\n-      NOT_LP64(__ movptr(rdx, field.plus_disp(4)));\n@@ -639,2 +596,2 @@\n-    const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n-    LP64_ONLY(assert(rbx != bc, \"register damaged\"));\n+    const Register bc = c_rarg3;\n+    assert(rbx != bc, \"register damaged\");\n@@ -696,1 +653,0 @@\n-  NOT_LP64(__ movl(rdx, haddress(rbx)));\n@@ -734,1 +690,0 @@\n-  NOT_LP64(__ movl(rdx, haddress(rbx)));\n@@ -775,1 +730,1 @@\n-  __ mov(NOT_LP64(rax) LP64_ONLY(c_rarg1), array);\n+  __ mov(c_rarg1, array);\n@@ -796,1 +751,0 @@\n-  NOT_LP64(__ mov(rbx, rax));\n@@ -897,1 +851,0 @@\n-  NOT_LP64(__ movptr(rdx, haddress(n)));\n@@ -949,2 +902,2 @@\n-    const Register bc = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n-    LP64_ONLY(assert(rbx != bc, \"register damaged\"));\n+    const Register bc = c_rarg3;\n+    assert(rbx != bc, \"register damaged\");\n@@ -1004,1 +957,0 @@\n-  NOT_LP64(__ movptr(haddress(rbx), rdx));\n@@ -1035,2 +987,1 @@\n-  NOT_LP64(__ pop_l(rax, rdx));\n-  LP64_ONLY(__ pop_l());\n+  __ pop_l();\n@@ -1039,1 +990,0 @@\n-  NOT_LP64(__ movl(haddress(rbx), rdx));\n@@ -1043,1 +993,0 @@\n-#ifdef _LP64\n@@ -1048,3 +997,0 @@\n-#else\n-  wide_istore();\n-#endif\n@@ -1054,1 +1000,0 @@\n-#ifdef _LP64\n@@ -1059,3 +1004,0 @@\n-#else\n-  wide_lstore();\n-#endif\n@@ -1227,1 +1169,0 @@\n-  NOT_LP64(__ movptr(haddress(n), rdx));\n@@ -1366,1 +1307,0 @@\n-#ifdef _LP64\n@@ -1375,12 +1315,0 @@\n-#else\n-  __ pop_l(rbx, rcx);\n-  switch (op) {\n-    case add  : __ addl(rax, rbx); __ adcl(rdx, rcx); break;\n-    case sub  : __ subl(rbx, rax); __ sbbl(rcx, rdx);\n-                __ mov (rax, rbx); __ mov (rdx, rcx); break;\n-    case _and : __ andl(rax, rbx); __ andl(rdx, rcx); break;\n-    case _or  : __ orl (rax, rbx); __ orl (rdx, rcx); break;\n-    case _xor : __ xorl(rax, rbx); __ xorl(rdx, rcx); break;\n-    default   : ShouldNotReachHere();\n-  }\n-#endif\n@@ -1414,1 +1342,0 @@\n-#ifdef _LP64\n@@ -1417,7 +1344,0 @@\n-#else\n-  __ pop_l(rbx, rcx);\n-  __ push(rcx); __ push(rbx);\n-  __ push(rdx); __ push(rax);\n-  __ lmul(2 * wordSize, 0);\n-  __ addptr(rsp, 4 * wordSize);  \/\/ take off temporaries\n-#endif\n@@ -1428,1 +1348,0 @@\n-#ifdef _LP64\n@@ -1440,11 +1359,0 @@\n-#else\n-  __ pop_l(rbx, rcx);\n-  __ push(rcx); __ push(rbx);\n-  __ push(rdx); __ push(rax);\n-  \/\/ check if y = 0\n-  __ orl(rax, rdx);\n-  __ jump_cc(Assembler::zero,\n-             RuntimeAddress(Interpreter::_throw_ArithmeticException_entry));\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::ldiv));\n-  __ addptr(rsp, 4 * wordSize);  \/\/ take off temporaries\n-#endif\n@@ -1455,1 +1363,0 @@\n-#ifdef _LP64\n@@ -1467,11 +1374,0 @@\n-#else\n-  __ pop_l(rbx, rcx);\n-  __ push(rcx); __ push(rbx);\n-  __ push(rdx); __ push(rax);\n-  \/\/ check if y = 0\n-  __ orl(rax, rdx);\n-  __ jump_cc(Assembler::zero,\n-             RuntimeAddress(Interpreter::_throw_ArithmeticException_entry));\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::lrem));\n-  __ addptr(rsp, 4 * wordSize);\n-#endif\n@@ -1483,1 +1379,0 @@\n-  #ifdef _LP64\n@@ -1486,4 +1381,0 @@\n-#else\n-  __ pop_l(rax, rdx);                            \/\/ get shift value\n-  __ lshl(rdx, rax);\n-#endif\n@@ -1493,1 +1384,0 @@\n-#ifdef _LP64\n@@ -1498,6 +1388,0 @@\n-#else\n-  transition(itos, ltos);\n-  __ mov(rcx, rax);                              \/\/ get shift count\n-  __ pop_l(rax, rdx);                            \/\/ get shift value\n-  __ lshr(rdx, rax, true);\n-#endif\n@@ -1508,1 +1392,0 @@\n-#ifdef _LP64\n@@ -1512,5 +1395,0 @@\n-#else\n-  __ mov(rcx, rax);                              \/\/ get shift count\n-  __ pop_l(rax, rdx);                            \/\/ get shift value\n-  __ lshr(rdx, rax);\n-#endif\n@@ -1548,7 +1426,0 @@\n-      \/\/\n-      \/\/ On x86_32 platforms the FPU is used to perform the modulo operation. The\n-      \/\/ reason is that on 32-bit Windows the sign of modulo operations diverges from\n-      \/\/ what is considered the standard (e.g., -0.0f % -3.14f is 0.0f (and not -0.0f).\n-      \/\/ The fprem instruction used on x86_32 is functionally equivalent to\n-      \/\/ SharedRuntime::frem in that it returns a NaN.\n-#ifdef _LP64\n@@ -1558,10 +1429,0 @@\n-#else \/\/ !_LP64\n-      __ push_f(xmm0);\n-      __ pop_f();\n-      __ fld_s(at_rsp());\n-      __ fremr(rax);\n-      __ f2ieee();\n-      __ pop(rax);  \/\/ pop second operand off the stack\n-      __ push_f();\n-      __ pop_f(xmm0);\n-#endif \/\/ _LP64\n@@ -1574,1 +1435,0 @@\n-#ifdef _LP64\n@@ -1576,12 +1436,0 @@\n-#else \/\/ !_LP64\n-    switch (op) {\n-    case add: __ fadd_s (at_rsp());                break;\n-    case sub: __ fsubr_s(at_rsp());                break;\n-    case mul: __ fmul_s (at_rsp());                break;\n-    case div: __ fdivr_s(at_rsp());                break;\n-    case rem: __ fld_s  (at_rsp()); __ fremr(rax); break;\n-    default : ShouldNotReachHere();\n-    }\n-    __ f2ieee();\n-    __ pop(rax);  \/\/ pop second operand off the stack\n-#endif \/\/ _LP64\n@@ -1615,3 +1463,2 @@\n-      \/\/ SharedRuntime::drem method (on x86_64 platforms) or using the\n-      \/\/ FPU (on x86_32 platforms) for the same reasons as mentioned in fop2().\n-#ifdef _LP64\n+      \/\/ SharedRuntime::drem method on x86_64 platforms for the same reasons\n+      \/\/ as mentioned in fop2().\n@@ -1621,11 +1468,0 @@\n-#else \/\/ !_LP64\n-      __ push_d(xmm0);\n-      __ pop_d();\n-      __ fld_d(at_rsp());\n-      __ fremr(rax);\n-      __ d2ieee();\n-      __ pop(rax);\n-      __ pop(rdx);\n-      __ push_d();\n-      __ pop_d(xmm0);\n-#endif \/\/ _LP64\n@@ -1638,1 +1474,0 @@\n-#ifdef _LP64\n@@ -1640,30 +1475,0 @@\n-#else \/\/ !_LP64\n-    switch (op) {\n-    case add: __ fadd_d (at_rsp());                break;\n-    case sub: __ fsubr_d(at_rsp());                break;\n-    case mul: {\n-      \/\/ strict semantics\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n-      __ fmulp();\n-      __ fmul_d (at_rsp());\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n-      __ fmulp();\n-      break;\n-    }\n-    case div: {\n-      \/\/ strict semantics\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias1()));\n-      __ fmul_d (at_rsp());\n-      __ fdivrp();\n-      __ fld_x(ExternalAddress(StubRoutines::x86::addr_fpu_subnormal_bias2()));\n-      __ fmulp();\n-      break;\n-    }\n-    case rem: __ fld_d  (at_rsp()); __ fremr(rax); break;\n-    default : ShouldNotReachHere();\n-    }\n-    __ d2ieee();\n-    \/\/ Pop double precision number from rsp.\n-    __ pop(rax);\n-    __ pop(rdx);\n-#endif \/\/ _LP64\n@@ -1680,2 +1485,1 @@\n-  LP64_ONLY(__ negq(rax));\n-  NOT_LP64(__ lneg(rdx, rax));\n+  __ negq(rax);\n@@ -1705,2 +1509,1 @@\n-    LP64_ONLY(ShouldNotReachHere());\n-    NOT_LP64(__ fchs());\n+    ShouldNotReachHere();\n@@ -1717,1 +1520,0 @@\n-#ifdef _LP64\n@@ -1719,3 +1521,0 @@\n-#else\n-    __ fchs();\n-#endif\n@@ -1744,1 +1543,0 @@\n-#ifdef _LP64\n@@ -1872,192 +1670,0 @@\n-#else \/\/ !_LP64\n-  \/\/ Checking\n-#ifdef ASSERT\n-  { TosState tos_in  = ilgl;\n-    TosState tos_out = ilgl;\n-    switch (bytecode()) {\n-      case Bytecodes::_i2l: \/\/ fall through\n-      case Bytecodes::_i2f: \/\/ fall through\n-      case Bytecodes::_i2d: \/\/ fall through\n-      case Bytecodes::_i2b: \/\/ fall through\n-      case Bytecodes::_i2c: \/\/ fall through\n-      case Bytecodes::_i2s: tos_in = itos; break;\n-      case Bytecodes::_l2i: \/\/ fall through\n-      case Bytecodes::_l2f: \/\/ fall through\n-      case Bytecodes::_l2d: tos_in = ltos; break;\n-      case Bytecodes::_f2i: \/\/ fall through\n-      case Bytecodes::_f2l: \/\/ fall through\n-      case Bytecodes::_f2d: tos_in = ftos; break;\n-      case Bytecodes::_d2i: \/\/ fall through\n-      case Bytecodes::_d2l: \/\/ fall through\n-      case Bytecodes::_d2f: tos_in = dtos; break;\n-      default             : ShouldNotReachHere();\n-    }\n-    switch (bytecode()) {\n-      case Bytecodes::_l2i: \/\/ fall through\n-      case Bytecodes::_f2i: \/\/ fall through\n-      case Bytecodes::_d2i: \/\/ fall through\n-      case Bytecodes::_i2b: \/\/ fall through\n-      case Bytecodes::_i2c: \/\/ fall through\n-      case Bytecodes::_i2s: tos_out = itos; break;\n-      case Bytecodes::_i2l: \/\/ fall through\n-      case Bytecodes::_f2l: \/\/ fall through\n-      case Bytecodes::_d2l: tos_out = ltos; break;\n-      case Bytecodes::_i2f: \/\/ fall through\n-      case Bytecodes::_l2f: \/\/ fall through\n-      case Bytecodes::_d2f: tos_out = ftos; break;\n-      case Bytecodes::_i2d: \/\/ fall through\n-      case Bytecodes::_l2d: \/\/ fall through\n-      case Bytecodes::_f2d: tos_out = dtos; break;\n-      default             : ShouldNotReachHere();\n-    }\n-    transition(tos_in, tos_out);\n-  }\n-#endif \/\/ ASSERT\n-\n-  \/\/ Conversion\n-  \/\/ (Note: use push(rcx)\/pop(rcx) for 1\/2-word stack-ptr manipulation)\n-  switch (bytecode()) {\n-    case Bytecodes::_i2l:\n-      __ extend_sign(rdx, rax);\n-      break;\n-    case Bytecodes::_i2f:\n-      if (UseSSE >= 1) {\n-        __ cvtsi2ssl(xmm0, rax);\n-      } else {\n-        __ push(rax);          \/\/ store int on tos\n-        __ fild_s(at_rsp());   \/\/ load int to ST0\n-        __ f2ieee();           \/\/ truncate to float size\n-        __ pop(rcx);           \/\/ adjust rsp\n-      }\n-      break;\n-    case Bytecodes::_i2d:\n-      if (UseSSE >= 2) {\n-        __ cvtsi2sdl(xmm0, rax);\n-      } else {\n-      __ push(rax);          \/\/ add one slot for d2ieee()\n-      __ push(rax);          \/\/ store int on tos\n-      __ fild_s(at_rsp());   \/\/ load int to ST0\n-      __ d2ieee();           \/\/ truncate to double size\n-      __ pop(rcx);           \/\/ adjust rsp\n-      __ pop(rcx);\n-      }\n-      break;\n-    case Bytecodes::_i2b:\n-      __ shll(rax, 24);      \/\/ truncate upper 24 bits\n-      __ sarl(rax, 24);      \/\/ and sign-extend byte\n-      LP64_ONLY(__ movsbl(rax, rax));\n-      break;\n-    case Bytecodes::_i2c:\n-      __ andl(rax, 0xFFFF);  \/\/ truncate upper 16 bits\n-      LP64_ONLY(__ movzwl(rax, rax));\n-      break;\n-    case Bytecodes::_i2s:\n-      __ shll(rax, 16);      \/\/ truncate upper 16 bits\n-      __ sarl(rax, 16);      \/\/ and sign-extend short\n-      LP64_ONLY(__ movswl(rax, rax));\n-      break;\n-    case Bytecodes::_l2i:\n-      \/* nothing to do *\/\n-      break;\n-    case Bytecodes::_l2f:\n-      \/\/ On 64-bit platforms, the cvtsi2ssq instruction is used to convert\n-      \/\/ 64-bit long values to floats. On 32-bit platforms it is not possible\n-      \/\/ to use that instruction with 64-bit operands, therefore the FPU is\n-      \/\/ used to perform the conversion.\n-      __ push(rdx);          \/\/ store long on tos\n-      __ push(rax);\n-      __ fild_d(at_rsp());   \/\/ load long to ST0\n-      __ f2ieee();           \/\/ truncate to float size\n-      __ pop(rcx);           \/\/ adjust rsp\n-      __ pop(rcx);\n-      if (UseSSE >= 1) {\n-        __ push_f();\n-        __ pop_f(xmm0);\n-      }\n-      break;\n-    case Bytecodes::_l2d:\n-      \/\/ On 32-bit platforms the FPU is used for conversion because on\n-      \/\/ 32-bit platforms it is not not possible to use the cvtsi2sdq\n-      \/\/ instruction with 64-bit operands.\n-      __ push(rdx);          \/\/ store long on tos\n-      __ push(rax);\n-      __ fild_d(at_rsp());   \/\/ load long to ST0\n-      __ d2ieee();           \/\/ truncate to double size\n-      __ pop(rcx);           \/\/ adjust rsp\n-      __ pop(rcx);\n-      if (UseSSE >= 2) {\n-        __ push_d();\n-        __ pop_d(xmm0);\n-      }\n-      break;\n-    case Bytecodes::_f2i:\n-      \/\/ SharedRuntime::f2i does not differentiate between sNaNs and qNaNs\n-      \/\/ as it returns 0 for any NaN.\n-      if (UseSSE >= 1) {\n-        __ push_f(xmm0);\n-      } else {\n-        __ push(rcx);          \/\/ reserve space for argument\n-        __ fstp_s(at_rsp());   \/\/ pass float argument on stack\n-      }\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2i), 1);\n-      break;\n-    case Bytecodes::_f2l:\n-      \/\/ SharedRuntime::f2l does not differentiate between sNaNs and qNaNs\n-      \/\/ as it returns 0 for any NaN.\n-      if (UseSSE >= 1) {\n-       __ push_f(xmm0);\n-      } else {\n-        __ push(rcx);          \/\/ reserve space for argument\n-        __ fstp_s(at_rsp());   \/\/ pass float argument on stack\n-      }\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::f2l), 1);\n-      break;\n-    case Bytecodes::_f2d:\n-      if (UseSSE < 1) {\n-        \/* nothing to do *\/\n-      } else if (UseSSE == 1) {\n-        __ push_f(xmm0);\n-        __ pop_f();\n-      } else { \/\/ UseSSE >= 2\n-        __ cvtss2sd(xmm0, xmm0);\n-      }\n-      break;\n-    case Bytecodes::_d2i:\n-      if (UseSSE >= 2) {\n-        __ push_d(xmm0);\n-      } else {\n-        __ push(rcx);          \/\/ reserve space for argument\n-        __ push(rcx);\n-        __ fstp_d(at_rsp());   \/\/ pass double argument on stack\n-      }\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2i), 2);\n-      break;\n-    case Bytecodes::_d2l:\n-      if (UseSSE >= 2) {\n-        __ push_d(xmm0);\n-      } else {\n-        __ push(rcx);          \/\/ reserve space for argument\n-        __ push(rcx);\n-        __ fstp_d(at_rsp());   \/\/ pass double argument on stack\n-      }\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::d2l), 2);\n-      break;\n-    case Bytecodes::_d2f:\n-      if (UseSSE <= 1) {\n-        __ push(rcx);          \/\/ reserve space for f2ieee()\n-        __ f2ieee();           \/\/ truncate to float size\n-        __ pop(rcx);           \/\/ adjust rsp\n-        if (UseSSE == 1) {\n-          \/\/ The cvtsd2ss instruction is not available if UseSSE==1, therefore\n-          \/\/ the conversion is performed using the FPU in this case.\n-          __ push_f();\n-          __ pop_f(xmm0);\n-        }\n-      } else { \/\/ UseSSE >= 2\n-        __ cvtsd2ss(xmm0, xmm0);\n-      }\n-      break;\n-    default             :\n-      ShouldNotReachHere();\n-  }\n-#endif \/\/ _LP64\n@@ -2068,1 +1674,0 @@\n-#ifdef _LP64\n@@ -2077,7 +1682,0 @@\n-#else\n-\n-  \/\/ y = rdx:rax\n-  __ pop_l(rbx, rcx);             \/\/ get x = rcx:rbx\n-  __ lcmp2int(rcx, rbx, rdx, rax);\/\/ rcx := cmp(x, y)\n-  __ mov(rax, rcx);\n-#endif\n@@ -2115,1 +1713,0 @@\n-#ifdef _LP64\n@@ -2117,10 +1714,0 @@\n-#else \/\/ !_LP64\n-    if (is_float) {\n-      __ fld_s(at_rsp());\n-    } else {\n-      __ fld_d(at_rsp());\n-      __ pop(rdx);\n-    }\n-    __ pop(rcx);\n-    __ fcmp2int(rax, unordered_result < 0);\n-#endif \/\/ _LP64\n@@ -2151,1 +1738,1 @@\n-  LP64_ONLY(__ movl2ptr(rdx, rdx));\n+  __ movl2ptr(rdx, rdx);\n@@ -2270,2 +1857,0 @@\n-      NOT_LP64(__ get_thread(rcx));\n-\n@@ -2275,2 +1860,1 @@\n-      LP64_ONLY(__ mov(j_rarg0, rax));\n-      NOT_LP64(__ mov(rcx, rax));\n+      __ mov(j_rarg0, rax);\n@@ -2281,2 +1865,2 @@\n-      const Register retaddr   = LP64_ONLY(j_rarg2) NOT_LP64(rdi);\n-      const Register sender_sp = LP64_ONLY(j_rarg1) NOT_LP64(rdx);\n+      const Register retaddr   = j_rarg2;\n+      const Register sender_sp = j_rarg1;\n@@ -2353,2 +1937,1 @@\n-  LP64_ONLY(__ movslq(rbx, iaddress(rbx))); \/\/ get return bci, compute return bcp\n-  NOT_LP64(__ movptr(rbx, iaddress(rbx)));\n+  __ movslq(rbx, iaddress(rbx)); \/\/ get return bci, compute return bcp\n@@ -2398,1 +1981,1 @@\n-  LP64_ONLY(__ movl2ptr(rdx, rdx));\n+  __ movl2ptr(rdx, rdx);\n@@ -2488,2 +2071,0 @@\n-  NOT_LP64(__ save_bcp());\n-\n@@ -2546,4 +2127,1 @@\n-  LP64_ONLY(__ movslq(j, j));\n-\n-  NOT_LP64(__ restore_bcp());\n-  NOT_LP64(__ restore_locals());                           \/\/ restore rdi\n+  __ movslq(j, j);\n@@ -2560,4 +2138,1 @@\n-  LP64_ONLY(__ movslq(j, j));\n-\n-  NOT_LP64(__ restore_bcp());\n-  NOT_LP64(__ restore_locals());\n+  __ movslq(j, j);\n@@ -2578,1 +2153,1 @@\n-    Register robj = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n+    Register robj = c_rarg1;\n@@ -2593,1 +2168,0 @@\n-#ifdef _LP64\n@@ -2595,5 +2169,0 @@\n-#else\n-    const Register thread = rdi;\n-    __ get_thread(thread);\n-    __ testb(Address(thread, JavaThread::polling_word_offset()), SafepointMechanism::poll_bit());\n-#endif\n@@ -2697,1 +2266,1 @@\n-    const Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);\n+    const Register thread = r15_thread;\n@@ -2824,1 +2393,0 @@\n-#ifdef _LP64\n@@ -2827,3 +2395,0 @@\n-#else\n-    __ movptr(index, ArrayAddress(table, Address(noreg, index, Address::times_ptr)));\n-#endif \/\/ _LP64\n@@ -2982,1 +2547,1 @@\n-  const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n+  const Register obj   = c_rarg3;\n@@ -2988,1 +2553,1 @@\n-  const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx); \/\/ uses same reg as obj, so don't mix them\n+  const Register bc    = c_rarg3; \/\/ uses same reg as obj, so don't mix them\n@@ -3084,1 +2649,1 @@\n-  LP64_ONLY(if (!is_static && rc == may_rewrite) patch_bytecode(Bytecodes::_fast_lgetfield, bc, rbx));\n+  if (!is_static && rc == may_rewrite) patch_bytecode(Bytecodes::_fast_lgetfield, bc, rbx);\n@@ -3144,3 +2709,3 @@\n-  const Register entry = LP64_ONLY(c_rarg2) NOT_LP64(rax); \/\/ ResolvedFieldEntry\n-  const Register obj = LP64_ONLY(c_rarg1) NOT_LP64(rbx);   \/\/ Object pointer\n-  const Register value = LP64_ONLY(c_rarg3) NOT_LP64(rcx); \/\/ JValue object\n+  const Register entry = c_rarg2; \/\/ ResolvedFieldEntry\n+  const Register obj = c_rarg1;   \/\/ Object pointer\n+  const Register value = c_rarg3; \/\/ JValue object\n@@ -3168,3 +2733,0 @@\n-#ifndef _LP64\n-      Label two_word, valsize_known;\n-#endif\n@@ -3172,1 +2734,0 @@\n-#ifdef _LP64\n@@ -3180,16 +2741,0 @@\n-#else\n-      __ mov(obj, rsp);\n-      __ cmpl(value, ltos);\n-      __ jccb(Assembler::equal, two_word);\n-      __ cmpl(value, dtos);\n-      __ jccb(Assembler::equal, two_word);\n-      __ addptr(obj, Interpreter::expr_offset_in_bytes(1)); \/\/ one word jvalue (not ltos, dtos)\n-      __ jmpb(valsize_known);\n-\n-      __ bind(two_word);\n-      __ addptr(obj, Interpreter::expr_offset_in_bytes(2)); \/\/ two words jvalue\n-\n-      __ bind(valsize_known);\n-      \/\/ setup object pointer\n-      __ movptr(obj, Address(obj, 0));\n-#endif\n@@ -3254,1 +2799,0 @@\n-  NOT_LP64( const Address hi(obj, off, Address::times_1, 1*wordSize);)\n@@ -3260,1 +2804,1 @@\n-  const Register bc    = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n+  const Register bc    = c_rarg3;\n@@ -3363,1 +2907,0 @@\n-#ifdef _LP64\n@@ -3367,1 +2910,0 @@\n-#endif \/\/ _LP64\n@@ -3428,1 +2970,1 @@\n-  const Register scratch = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n+  const Register scratch = c_rarg3;\n@@ -3459,2 +3001,1 @@\n-    LP64_ONLY(__ load_field_entry(c_rarg2, rax));\n-    NOT_LP64(__ load_field_entry(rax, rdx));\n+    __ load_field_entry(c_rarg2, rax);\n@@ -3465,2 +3006,1 @@\n-    LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3));\n-    NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, rax, rcx));\n+    __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_modification), rbx, c_rarg2, c_rarg3);\n@@ -3529,1 +3069,0 @@\n-#ifdef _LP64\n@@ -3531,3 +3070,0 @@\n-#else\n-  __ stop(\"should not be rewritten\");\n-#endif\n@@ -3573,2 +3109,1 @@\n-    LP64_ONLY(__ load_field_entry(c_rarg2, rcx));\n-    NOT_LP64(__ load_field_entry(rcx, rdx));\n+    __ load_field_entry(c_rarg2, rcx);\n@@ -3577,1 +3112,1 @@\n-    LP64_ONLY(__ mov(c_rarg1, rax));\n+    __ mov(c_rarg1, rax);\n@@ -3580,2 +3115,1 @@\n-    LP64_ONLY(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2));\n-    NOT_LP64(__ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), rax, rcx));\n+    __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_field_access), c_rarg1, c_rarg2);\n@@ -3602,1 +3136,0 @@\n-#ifdef _LP64\n@@ -3604,3 +3137,0 @@\n-#else\n-  __ stop(\"should not be rewritten\");\n-#endif\n@@ -3711,1 +3241,0 @@\n-#ifdef _LP64\n@@ -3714,3 +3243,0 @@\n-#else\n-    __ movptr(flags, ArrayAddress(table, Address(noreg, flags, Address::times_ptr)));\n-#endif \/\/ _LP64\n@@ -3948,1 +3474,0 @@\n-#ifdef _LP64\n@@ -3953,4 +3478,0 @@\n-#else\n-  recvKlass = rdx;\n-  Register method    = rcx;\n-#endif\n@@ -3968,1 +3489,3 @@\n-  LP64_ONLY( if (recvKlass != rdx) { __ movq(recvKlass, rdx); } )\n+  if (recvKlass != rdx) {\n+    __ movq(recvKlass, rdx);\n+  }\n@@ -4051,1 +3574,0 @@\n-#ifdef _LP64\n@@ -4054,4 +3576,0 @@\n-#else\n-  __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);\n-  __ jcc(Assembler::notEqual, slow_case);\n-#endif\n@@ -4074,2 +3592,0 @@\n-  const Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n-\n@@ -4077,2 +3593,1 @@\n-    NOT_LP64(__ get_thread(thread);)\n-    __ tlab_allocate(thread, rax, rdx, 0, rcx, rbx, slow_case);\n+    __ tlab_allocate(r15_thread, rax, rdx, 0, rcx, rbx, slow_case);\n@@ -4116,1 +3631,0 @@\n-    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, header_size_bytes - 2*oopSize), rcx));\n@@ -4131,1 +3645,0 @@\n-#ifdef _LP64\n@@ -4134,1 +3647,0 @@\n-#endif\n@@ -4154,6 +3666,3 @@\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n-  Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n-\n-  __ get_constant_pool(rarg1);\n-  __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), rarg1, rarg2);\n+  __ get_constant_pool(c_rarg1);\n+  __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n@@ -4168,2 +3677,1 @@\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rdx);\n-  __ load_unsigned_byte(rarg1, at_bcp(1));\n+  __ load_unsigned_byte(c_rarg1, at_bcp(1));\n@@ -4171,1 +3679,1 @@\n-          rarg1, rax);\n+          c_rarg1, rax);\n@@ -4177,5 +3685,2 @@\n-  Register rarg1 = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n-  Register rarg2 = LP64_ONLY(c_rarg2) NOT_LP64(rdx);\n-\n-  __ get_unsigned_2_byte_index_at_bcp(rarg2, 1);\n-  __ get_constant_pool(rarg1);\n+  __ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);\n+  __ get_constant_pool(c_rarg1);\n@@ -4183,1 +3688,1 @@\n-          rarg1, rarg2, rax);\n+          c_rarg1, c_rarg2, rax);\n@@ -4210,6 +3715,0 @@\n-#ifndef _LP64\n-  \/\/ borrow rdi from locals\n-  __ get_thread(rdi);\n-  __ get_vm_result_2(rax, rdi);\n-  __ restore_locals();\n-#else\n@@ -4217,1 +3716,0 @@\n-#endif\n@@ -4274,6 +3772,0 @@\n-#ifndef _LP64\n-  \/\/ borrow rdi from locals\n-  __ get_thread(rdi);\n-  __ get_vm_result_2(rax, rdi);\n-  __ restore_locals();\n-#else\n@@ -4281,1 +3773,0 @@\n-#endif\n@@ -4329,2 +3820,0 @@\n-  Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rcx);\n-\n@@ -4332,1 +3821,1 @@\n-  __ get_method(rarg);\n+  __ get_method(c_rarg1);\n@@ -4336,1 +3825,1 @@\n-             rarg, rbcp);\n+             c_rarg1, rbcp);\n@@ -4340,1 +3829,1 @@\n-  __ get_method(rarg);\n+  __ get_method(c_rarg1);\n@@ -4343,1 +3832,1 @@\n-             rarg, rbcp);\n+             c_rarg1, rbcp);\n@@ -4389,3 +3878,3 @@\n-  Register rtop = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n-  Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);\n-  Register rmon = LP64_ONLY(c_rarg1) NOT_LP64(rdx);\n+  Register rtop = c_rarg3;\n+  Register rbot = c_rarg2;\n+  Register rmon = c_rarg1;\n@@ -4487,2 +3976,2 @@\n-  Register rtop = LP64_ONLY(c_rarg1) NOT_LP64(rdx);\n-  Register rbot = LP64_ONLY(c_rarg2) NOT_LP64(rbx);\n+  Register rtop = c_rarg1;\n+  Register rbot = c_rarg2;\n@@ -4542,1 +4031,0 @@\n-  Register rarg = LP64_ONLY(c_rarg1) NOT_LP64(rax);\n@@ -4547,2 +4035,2 @@\n-  __ lea(rarg, Address(rsp, rax, Interpreter::stackElementScale(), -wordSize));\n-  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray), rarg);\n+  __ lea(c_rarg1, Address(rsp, rax, Interpreter::stackElementScale(), -wordSize));\n+  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::multianewarray), c_rarg1);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":62,"deletions":574,"binary":false,"changes":636,"status":"modified"},{"patch":"@@ -379,1 +379,0 @@\n-  __ verify_FPU(1, t->tos_in());\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}