{"files":[{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -140,1 +141,1 @@\n-                    return new StableList<>(size, mapper);\n+                    return new StableList<>(size, new UnderlyingHolder<>(mapper, size));\n@@ -144,1 +145,1 @@\n-                    return new StableMap<>(keys, mapper);\n+                    return new StableMap<>(keys, new UnderlyingHolder<>(mapper, keys.size()));\n@@ -797,2 +798,0 @@\n-        @Stable\n-        private final IntFunction<? extends E> mapper;\n@@ -801,0 +800,2 @@\n+        @Stable\n+        private final UnderlyingHolder<IntFunction<? extends E>> underlyingHolder;\n@@ -802,2 +803,2 @@\n-        StableList(int size, IntFunction<? extends E> mapper) {\n-            this.mapper = mapper;\n+        StableList(int size, UnderlyingHolder<IntFunction<? extends E>> underlyingHolder) {\n+            this.underlyingHolder = underlyingHolder;\n@@ -821,1 +822,1 @@\n-                        @Override  public E get() { return mapper.apply(i); }});\n+                        @Override  public E get() { return underlyingHolder.underlying().apply(i); }}, underlyingHolder);\n@@ -1609,2 +1610,0 @@\n-        @Stable\n-        private final Function<? super K, ? extends V> mapper;\n@@ -1613,0 +1612,2 @@\n+        @Stable\n+        private final UnderlyingHolder<Function<? super K, ? extends V>> underlyingHolder;\n@@ -1614,2 +1615,1 @@\n-        StableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n-            this.mapper = mapper;\n+        StableMap(Set<K> keys, UnderlyingHolder<Function<? super K, ? extends V>> underlyingHolder) {\n@@ -1617,0 +1617,1 @@\n+            this.underlyingHolder = underlyingHolder;\n@@ -1639,1 +1640,1 @@\n-                @Override public V get() { return mapper.apply(k); }});\n+                @Override public V get() { return underlyingHolder.underlying().apply(k); }}, underlyingHolder);\n@@ -1695,1 +1696,1 @@\n-                        @Override public V get() { return outer.outer.mapper.apply(k); }});\n+                        @Override public V get() { return outer.outer.underlyingHolder.underlying().apply(k); }}, outer.outer.underlyingHolder);\n@@ -1706,1 +1707,1 @@\n-                                        @Override public V get() { return outer.outer.mapper.apply(k); }}));\n+                                        @Override public V get() { return outer.outer.underlyingHolder.underlying().apply(k); }}, outer.outer.underlyingHolder));\n@@ -1722,1 +1723,2 @@\n-                                         Supplier<? extends V> supplier) implements Map.Entry<K, V> {\n+                                         Supplier<? extends V> supplier,\n+                                         UnderlyingHolder<?> underlyingHolder) implements Map.Entry<K, V> {\n@@ -1725,1 +1727,1 @@\n-            @Override public V getValue() { return stableValue.orElseSet(supplier); }\n+            @Override public V getValue() { return stableValue.orElseSet(supplier, underlyingHolder); }\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.EnumSet;\n@@ -49,8 +48,8 @@\n- * @param enumType     the class type of the Enum\n- * @param firstOrdinal the lowest ordinal used\n- * @param member       an int predicate that can be used to test if an enum is a member\n- *                     of the valid inputs (as there might be \"holes\")\n- * @param delegates    a delegate array of inputs to StableValue mappings\n- * @param original     the original Function\n- * @param <E>          the type of the input to the function\n- * @param <R>          the type of the result of the function\n+ * @param enumType         the class type of the Enum\n+ * @param firstOrdinal     the lowest ordinal used\n+ * @param member           an int predicate that can be used to test if an enum is a member\n+ *                         of the valid inputs (as there might be \"holes\")\n+ * @param delegates        a delegate array of inputs to StableValue mappings\n+ * @param underlyingHolder of the original underlying Function\n+ * @param <E>              the type of the input to the function\n+ * @param <R>              the type of the result of the function\n@@ -62,1 +61,2 @@\n-                                                       Function<? super E, ? extends R> original) implements Function<E, R> {\n+                                                       UnderlyingHolder<Function<? super E, ? extends R>> underlyingHolder) implements Function<E, R> {\n+\n@@ -72,1 +72,1 @@\n-                    @Override public R get() { return original.apply(value); }});\n+            @Override public R get() { return underlyingHolder.underlying().apply(value); }}, underlyingHolder);\n@@ -99,0 +99,1 @@\n+\n@@ -101,1 +102,1 @@\n-                                                              Function<? super T, ? extends R> original) {\n+                                                              Function<? super T, ? extends R> underlying) {\n@@ -115,1 +116,1 @@\n-        return (Function<T, R>) new StableEnumFunction<E, R>(enumType, min, member, StableUtil.array(size), (Function<E, R>) original);\n+        return (Function<T, R>) new StableEnumFunction<E, R>(enumType, min, member, StableUtil.array(size), new UnderlyingHolder<>((Function<E, R>) underlying, bitSet.cardinality()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+\n@@ -44,4 +45,4 @@\n- * @param values   a delegate map of inputs to StableValue mappings\n- * @param original the original Function\n- * @param <T>      the type of the input to the function\n- * @param <R>      the type of the result of the function\n+ * @param values           a delegate map of inputs to StableValue mappings\n+ * @param underlyingHolder of the original underlying Function\n+ * @param <T>              the type of the input to the function\n+ * @param <R>              the type of the result of the function\n@@ -50,1 +51,1 @@\n-                                   Function<? super T, ? extends R> original) implements Function<T, R> {\n+                                   UnderlyingHolder<Function<? super T, ? extends R>> underlyingHolder) implements Function<T, R> {\n@@ -60,1 +61,1 @@\n-            @Override  public R get() { return original.apply(value); }});\n+            @Override public R get() { return underlyingHolder.underlying().apply(value); }}, underlyingHolder);\n@@ -79,2 +80,2 @@\n-                                                 Function<? super T, ? extends R> original) {\n-        return new StableFunction<>(StableUtil.map(inputs), original);\n+                                                 Function<? super T, ? extends R> underlying) {\n+        return new StableFunction<>(StableUtil.map(inputs), new UnderlyingHolder<>(underlying, inputs.size()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-                                   IntFunction<? extends R> original) implements IntFunction<R> {\n+                                   UnderlyingHolder<IntFunction<? extends R>> underlyingHolder) implements IntFunction<R> {\n@@ -53,1 +53,1 @@\n-            delegate =  delegates[index];\n+            delegate = delegates[index];\n@@ -58,1 +58,1 @@\n-                    @Override public R get() { return original.apply(index); }});\n+            @Override public R get() { return underlyingHolder.underlying().apply(index); }}, underlyingHolder);\n@@ -76,2 +76,2 @@\n-    public static <R> StableIntFunction<R> of(int size, IntFunction<? extends R> original) {\n-        return new StableIntFunction<>(StableUtil.array(size), original);\n+    public static <R> StableIntFunction<R> of(int size, IntFunction<? extends R> underlying) {\n+        return new StableIntFunction<>(StableUtil.array(size), new UnderlyingHolder<>(underlying, size));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                                Supplier<? extends T> original) implements Supplier<T> {\n+                                UnderlyingHolder<Supplier<? extends T>> underlyingHolder) implements Supplier<T> {\n@@ -46,1 +46,1 @@\n-        return delegate.orElseSet(original);\n+        return delegate.orElseSet(underlyingHolder.underlying(), underlyingHolder);\n@@ -65,2 +65,2 @@\n-    public static <T> StableSupplier<T> of(Supplier<? extends T> original) {\n-        return new StableSupplier<>(StableValueImpl.of(), original);\n+    public static <T> StableSupplier<T> of(Supplier<? extends T> underlying) {\n+        return new StableSupplier<>(StableValueImpl.of(), new UnderlyingHolder<>(underlying, 1));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -129,0 +129,7 @@\n+        return orElseSet(supplier, null);\n+    }\n+\n+    \/\/ `supplier` can be null if the `underlyingHolder` released it.\n+    @ForceInline\n+    public T orElseSet(Supplier<? extends T> supplier,\n+                       UnderlyingHolder<?> underlyingHolder) {\n@@ -130,1 +137,1 @@\n-        return (t == null) ? orElseSetSlowPath(supplier) : unwrap(t);\n+        return (t == null) ? orElseSetSlowPath(supplier, underlyingHolder) : unwrap(t);\n@@ -134,1 +141,2 @@\n-    private T orElseSetSlowPath(Supplier<? extends T> supplier) {\n+    private T orElseSetSlowPath(Supplier<? extends T> supplier,\n+                                UnderlyingHolder<?> underlyingHolder) {\n@@ -142,0 +150,5 @@\n+                if (underlyingHolder != null) {\n+                    \/\/ Reduce the counter and if it reaches zero, clear the reference\n+                    \/\/ to the underlying holder.\n+                    underlyingHolder.countDown();\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+\/**\n+ * This class is thread safe.\n+ *\n+ * @param <U> the underlying type\n+ *\/\n+public final class UnderlyingHolder<U> {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    private static final long COUNTER_OFFSET =\n+            UNSAFE.objectFieldOffset(UnderlyingHolder.class, \"counter\");\n+\n+    \/\/ Used reflectively. This field can only transition at most once from being set to a\n+    \/\/ non-null reference to being `null`. Once `null`, it is never read. This allows\n+    \/\/ the field to be non-volatile, which is crucial for getting optimum performance.\n+    private U underlying;\n+\n+    \/\/ Used reflectively\n+    private int counter;\n+\n+    public UnderlyingHolder(U underlying, int counter) {\n+        this.underlying = underlying;\n+        this.counter = counter;\n+        \/\/ Safe publication\n+        UNSAFE.storeStoreFence();\n+    }\n+\n+    @ForceInline\n+    public U underlying() {\n+        return underlying;\n+    }\n+\n+    \/\/ For testing only\n+    public int counter() {\n+        return UNSAFE.getIntVolatile(this, COUNTER_OFFSET);\n+    }\n+\n+    public void countDown() {\n+        if (UNSAFE.getAndAddInt(this, COUNTER_OFFSET, -1) == 1) {\n+            \/\/ Do not reference the underlying function anymore so it can be collected.\n+            underlying = null;\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/UnderlyingHolder.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -27,1 +27,2 @@\n- * @run junit StableFunctionTest\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED StableFunctionTest\n@@ -30,0 +31,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -212,0 +214,20 @@\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void underlyingRef(Set<Value> inputs) {\n+        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(MAPPER);\n+        Function<Value, Integer> f1 = StableValue.function(inputs, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+\n+        int i = 0;\n+        for (Value input : inputs) {\n+            assertEquals(inputs.size() - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = f1.apply(input);\n+            int v2 = f1.apply(input);\n+            i++;\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules java.base\/jdk.internal.lang.stable\n@@ -27,1 +28,1 @@\n- * @run junit StableIntFunctionTest\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED StableIntFunctionTest\n@@ -30,0 +31,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -109,0 +111,16 @@\n+    @Test\n+    void underlyingRef() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(MAPPER);\n+        IntFunction<Integer> f1 = StableValue.intFunction(SIZE, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+        for (int i = 0; i < SIZE; i++) {\n+            assertEquals(SIZE - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = f1.apply(i);\n+            int v2 = f1.apply(i);\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableIntFunctionTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run junit StableListTest\n+ * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED StableListTest\n@@ -33,0 +33,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -436,0 +437,16 @@\n+    @Test\n+    void underlyingRef() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(IDENTITY);\n+        List<Integer> f1 = StableValue.list(SIZE, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+        for (int i = 0; i < SIZE; i++) {\n+            assertEquals(SIZE - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = f1.get(i);\n+            int v2 = f1.get(i);\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run junit StableMapTest\n+ * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED StableMapTest\n@@ -33,0 +33,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -43,0 +44,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -343,0 +345,57 @@\n+    @Test\n+    void underlyingRef() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cif = new StableTestUtil.CountingFunction<>(IDENTITY);\n+        Map<Integer, Integer> f1 = StableValue.map(KEYS, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+\n+        int i = 0;\n+        for (Integer input : KEYS) {\n+            assertEquals(KEYS.size() - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = f1.get(input);\n+            int v2 = f1.get(input);\n+            i++;\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n+    @Test\n+    void underlyingRefViaEntrySet() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cif = new StableTestUtil.CountingFunction<>(IDENTITY);\n+        Map<Integer, Integer> f1 = StableValue.map(KEYS, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+\n+        int i = 0;\n+        for (Map.Entry<Integer, Integer> e : f1.entrySet()) {\n+            assertEquals(KEYS.size() - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = e.getValue();\n+            int v2 = e.getValue();\n+            i++;\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n+    @Test\n+    void underlyingRefViaEntrySetForEach() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cif = new StableTestUtil.CountingFunction<>(IDENTITY);\n+        Map<Integer, Integer> f1 = StableValue.map(KEYS, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+\n+        final AtomicInteger i = new AtomicInteger();\n+        f1.entrySet().forEach(e -> {\n+            assertEquals(KEYS.size() - i.get(), holder.counter());\n+            assertSame(cif, holder.underlying());\n+            Integer val = e.getValue();\n+            Integer val2 = e.getValue();\n+            i.incrementAndGet();\n+        });\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @run junit StableSupplierTest\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED StableSupplierTest\n@@ -30,0 +31,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -34,0 +36,1 @@\n+import java.util.function.IntFunction;\n@@ -104,0 +107,33 @@\n+    @Test\n+    void underlyingRef() {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(SUPPLIER);\n+        var f1 = StableValue.supplier(cs);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+        assertEquals(1, holder.counter());\n+        assertSame(cs, holder.underlying());\n+        int v = f1.get();\n+        int v2 = f1.get();\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n+    @Test\n+    void underlyingRefException() {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var f1 = StableValue.supplier(cs);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+        assertEquals(1, holder.counter());\n+        assertSame(cs, holder.underlying());\n+        try {\n+            int v = f1.get();\n+        } catch (UnsupportedOperationException _) {\n+            \/\/ Expected\n+        }\n+        assertEquals(1, holder.counter());\n+        assertSame(cs, holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableSupplierTest.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n+\n+import java.lang.reflect.Field;\n@@ -120,0 +123,10 @@\n+    static UnderlyingHolder<?> underlyingHolder(Object o) {\n+        try {\n+            final Field field = o.getClass().getDeclaredField(\"underlyingHolder\");\n+            field.setAccessible(true);\n+            return (UnderlyingHolder<?>) field.get(o);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableTestUtil.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules java.base\/jdk.internal.lang.stable\n@@ -32,1 +33,0 @@\n-import java.util.ArrayList;\n@@ -40,1 +40,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -42,1 +41,0 @@\n-import java.util.concurrent.locks.LockSupport;\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}