{"files":[{"patch":"@@ -41,1 +41,0 @@\n-import java.util.function.Supplier;\n@@ -48,0 +47,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -140,1 +140,1 @@\n-                    return new StableList<>(size, mapper);\n+                    return new StableList<>(size, new UnderlyingHolder<>(mapper, size));\n@@ -144,1 +144,1 @@\n-                    return new StableMap<>(keys, mapper);\n+                    return new StableMap<>(keys, new UnderlyingHolder<>(mapper, keys.size()));\n@@ -797,2 +797,0 @@\n-        @Stable\n-        private final IntFunction<? extends E> mapper;\n@@ -801,0 +799,2 @@\n+        @Stable\n+        private final UnderlyingHolder<IntFunction<? extends E>> underlyingHolder;\n@@ -802,2 +802,2 @@\n-        StableList(int size, IntFunction<? extends E> mapper) {\n-            this.mapper = mapper;\n+        StableList(int size, UnderlyingHolder<IntFunction<? extends E>> underlyingHolder) {\n+            this.underlyingHolder = underlyingHolder;\n@@ -820,2 +820,1 @@\n-            return delegate.orElseSet(new Supplier<E>() {\n-                        @Override  public E get() { return mapper.apply(i); }});\n+            return delegate.orElseSet(i, underlyingHolder);\n@@ -1609,2 +1608,0 @@\n-        @Stable\n-        private final Function<? super K, ? extends V> mapper;\n@@ -1613,0 +1610,2 @@\n+        @Stable\n+        private final UnderlyingHolder<Function<? super K, ? extends V>> underlyingHolder;\n@@ -1614,2 +1613,1 @@\n-        StableMap(Set<K> keys, Function<? super K, ? extends V> mapper) {\n-            this.mapper = mapper;\n+        StableMap(Set<K> keys, UnderlyingHolder<Function<? super K, ? extends V>> underlyingHolder) {\n@@ -1617,0 +1615,1 @@\n+            this.underlyingHolder = underlyingHolder;\n@@ -1636,4 +1635,1 @@\n-            @SuppressWarnings(\"unchecked\")\n-            final K k = (K) key;\n-            return stable.orElseSet(new Supplier<V>() {\n-                @Override public V get() { return mapper.apply(k); }});\n+            return stable.orElseSet(key, underlyingHolder);\n@@ -1675,2 +1671,0 @@\n-                \/\/ Use a separate field for the outer class in order to facilitate\n-                \/\/ a @Stable annotation.\n@@ -1678,2 +1672,1 @@\n-                private final StableMapEntrySet<K, V> outer;\n-\n+                private final UnderlyingHolder<Function<? super K, ? extends V>> underlyingHolder;\n@@ -1684,1 +1677,4 @@\n-                    this.outer = outer;\n+                    \/\/ We need to drill down two levels in order to obtain\n+                    \/\/ the original underlying holder.\n+                    \/\/ I.e., StableMapEntrySet.StableMap.underlyingHolder\n+                    this.underlyingHolder = outer.outer.underlyingHolder;\n@@ -1694,2 +1690,1 @@\n-                    return new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n-                        @Override public V get() { return outer.outer.mapper.apply(k); }});\n+                    return new StableEntry<>(k, inner.getValue(), underlyingHolder);\n@@ -1705,2 +1700,1 @@\n-                                    action.accept(new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n-                                        @Override public V get() { return outer.outer.mapper.apply(k); }}));\n+                                    action.accept(new StableEntry<>(k, inner.getValue(), underlyingHolder));\n@@ -1722,1 +1716,1 @@\n-                                         Supplier<? extends V> supplier) implements Map.Entry<K, V> {\n+                                         UnderlyingHolder<?> underlyingHolder) implements Map.Entry<K, V> {\n@@ -1725,1 +1719,1 @@\n-            @Override public V getValue() { return stableValue.orElseSet(supplier); }\n+            @Override public V getValue() { return stableValue.orElseSet(getKey, underlyingHolder); }\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":22,"deletions":28,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.EnumSet;\n@@ -41,1 +40,0 @@\n-import java.util.function.Supplier;\n@@ -49,8 +47,8 @@\n- * @param enumType     the class type of the Enum\n- * @param firstOrdinal the lowest ordinal used\n- * @param member       an int predicate that can be used to test if an enum is a member\n- *                     of the valid inputs (as there might be \"holes\")\n- * @param delegates    a delegate array of inputs to StableValue mappings\n- * @param original     the original Function\n- * @param <E>          the type of the input to the function\n- * @param <R>          the type of the result of the function\n+ * @param enumType         the class type of the Enum\n+ * @param firstOrdinal     the lowest ordinal used\n+ * @param member           an int predicate that can be used to test if an enum is a member\n+ *                         of the valid inputs (as there might be \"holes\")\n+ * @param delegates        a delegate array of inputs to StableValue mappings\n+ * @param underlyingHolder the holder of the original underlying Function\n+ * @param <E>              the type of the input to the function\n+ * @param <R>              the type of the result of the function\n@@ -62,1 +60,2 @@\n-                                                       Function<? super E, ? extends R> original) implements Function<E, R> {\n+                                                       UnderlyingHolder<Function<? super E, ? extends R>> underlyingHolder) implements Function<E, R> {\n+\n@@ -71,3 +70,1 @@\n-        return delegates[index].orElseSet(new Supplier<R>() {\n-                    @Override public R get() { return original.apply(value); }});\n-\n+        return delegates[index].orElseSet(value, underlyingHolder);\n@@ -99,0 +96,1 @@\n+\n@@ -101,1 +99,1 @@\n-                                                              Function<? super T, ? extends R> original) {\n+                                                              Function<? super T, ? extends R> underlying) {\n@@ -115,1 +113,1 @@\n-        return (Function<T, R>) new StableEnumFunction<E, R>(enumType, min, member, StableUtil.array(size), (Function<E, R>) original);\n+        return (Function<T, R>) new StableEnumFunction<E, R>(enumType, min, member, StableUtil.array(size), new UnderlyingHolder<>((Function<E, R>) underlying, bitSet.cardinality()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.function.Supplier;\n@@ -38,0 +37,1 @@\n+\n@@ -44,4 +44,4 @@\n- * @param values   a delegate map of inputs to StableValue mappings\n- * @param original the original Function\n- * @param <T>      the type of the input to the function\n- * @param <R>      the type of the result of the function\n+ * @param values           a delegate map of inputs to StableValue mappings\n+ * @param underlyingHolder the holder of the original underlying Function\n+ * @param <T>              the type of the input to the function\n+ * @param <R>              the type of the result of the function\n@@ -50,1 +50,1 @@\n-                                   Function<? super T, ? extends R> original) implements Function<T, R> {\n+                                   UnderlyingHolder<Function<? super T, ? extends R>> underlyingHolder) implements Function<T, R> {\n@@ -59,2 +59,1 @@\n-        return stable.orElseSet(new Supplier<R>() {\n-            @Override  public R get() { return original.apply(value); }});\n+        return stable.orElseSet(value, underlyingHolder);\n@@ -79,2 +78,2 @@\n-                                                 Function<? super T, ? extends R> original) {\n-        return new StableFunction<>(StableUtil.map(inputs), original);\n+                                                 Function<? super T, ? extends R> underlying) {\n+        return new StableFunction<>(StableUtil.map(inputs), new UnderlyingHolder<>(underlying, inputs.size()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -32,1 +33,0 @@\n-import java.util.function.Supplier;\n@@ -46,1 +46,1 @@\n-                                   IntFunction<? extends R> original) implements IntFunction<R> {\n+                                   UnderlyingHolder<IntFunction<? extends R>> underlyingHolder) implements IntFunction<R> {\n@@ -53,1 +53,1 @@\n-            delegate =  delegates[index];\n+            delegate = delegates[index];\n@@ -57,2 +57,1 @@\n-        return delegate.orElseSet(new Supplier<R>() {\n-                    @Override public R get() { return original.apply(index); }});\n+        return delegate.orElseSet(index, underlyingHolder);\n@@ -76,2 +75,2 @@\n-    public static <R> StableIntFunction<R> of(int size, IntFunction<? extends R> original) {\n-        return new StableIntFunction<>(StableUtil.array(size), original);\n+    public static <R> StableIntFunction<R> of(int size, IntFunction<? extends R> underlying) {\n+        return new StableIntFunction<>(StableUtil.array(size), new UnderlyingHolder<>(underlying, size));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-                                Supplier<? extends T> original) implements Supplier<T> {\n+                                UnderlyingHolder<Supplier<? extends T>> underlyingHolder) implements Supplier<T> {\n@@ -46,1 +46,1 @@\n-        return delegate.orElseSet(original);\n+        return delegate.orElseSet(null, underlyingHolder);\n@@ -65,2 +65,2 @@\n-    public static <T> StableSupplier<T> of(Supplier<? extends T> original) {\n-        return new StableSupplier<>(StableValueImpl.of(), original);\n+    public static <T> StableSupplier<T> of(Supplier<? extends T> underlying) {\n+        return new StableSupplier<>(StableValueImpl.of(), new UnderlyingHolder<>(underlying, 1));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n@@ -129,0 +131,9 @@\n+        \/\/ We are using the suppler as `input` here. A trick so that we do not have\n+        \/\/ to create an UnderlyingHolder.\n+        return orElseSet(supplier, null);\n+    }\n+\n+\n+    @ForceInline\n+    public T orElseSet(final int input,\n+                       final UnderlyingHolder<?> underlyingHolder) {\n@@ -130,1 +141,1 @@\n-        return (t == null) ? orElseSetSlowPath(supplier) : unwrap(t);\n+        return (t == null) ? orElseSetSlowPath(input, underlyingHolder) : unwrap(t);\n@@ -133,0 +144,8 @@\n+    @ForceInline\n+    public T orElseSet(final Object input,\n+                       final UnderlyingHolder<?> underlyingHolder) {\n+        final Object t = wrappedContentsAcquire();\n+        return (t == null) ? orElseSetSlowPath(input, underlyingHolder) : unwrap(t);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n@@ -134,1 +153,2 @@\n-    private T orElseSetSlowPath(Supplier<? extends T> supplier) {\n+    private T orElseSetSlowPath(final Object input,\n+                                final UnderlyingHolder<?> underlyingHolder) {\n@@ -139,1 +159,17 @@\n-                final T newValue = supplier.get();\n+                final T newValue;\n+                if (underlyingHolder == null) {\n+                    \/\/ If there is no underlyingHolder, the input must be a\n+                    \/\/ `Supplier` because we were called from `.orElseSet(Supplier)`\n+                    newValue = ((Supplier<T>) input).get();\n+                } else {\n+                    final Object u = underlyingHolder.underlying();\n+                    newValue = switch (u) {\n+                        case Supplier<?> sup     -> (T) sup.get();\n+                        case IntFunction<?> iFun -> (T) iFun.apply((int) input);\n+                        case Function<?, ?> fun  -> ((Function<Object, T>) fun).apply(input);\n+                        default -> throw new InternalError(\"can not reach here\");\n+                    };\n+                    \/\/ Reduce the counter and if it reaches zero, clear the reference\n+                    \/\/ to the underlying holder.\n+                    underlyingHolder.countDown();\n+                }\n@@ -208,1 +244,1 @@\n-    private static <T> T unwrap(Object t) {\n+    static <T> T unwrap(Object t) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+package jdk.internal.lang.stable;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * This class is not thread safe. However, fields are only accessed within a block that\n+ * is guarded by the same synchronization object. Still, it can be instantiated from\n+ * any thread with no synchronization. Hence, the constructor must safely publish fields.\n+ *\n+ * @param <U> the underlying type\n+ *\/\n+public final class UnderlyingHolder<U> {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ This field can only transition at most once from being set to a\n+    \/\/ non-null reference to being `null`. Once `null`, it is never read.\n+    private U underlying;\n+    private int counter;\n+\n+    public UnderlyingHolder(U underlying, int counter) {\n+        this.underlying = underlying;\n+        this.counter = counter;\n+        \/\/ Safe publication\n+        UNSAFE.storeStoreFence();\n+    }\n+\n+    @ForceInline\n+    public U underlying() {\n+        return underlying;\n+    }\n+\n+    \/\/ For testing only\n+    public int counter() {\n+        return counter;\n+    }\n+\n+    public void countDown() {\n+        if (--counter == 0) {\n+            \/\/ Do not reference the underlying function anymore so it can be collected.\n+            underlying = null;\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/UnderlyingHolder.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -27,1 +27,2 @@\n- * @run junit StableFunctionTest\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED StableFunctionTest\n@@ -30,0 +31,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -212,0 +214,20 @@\n+    @ParameterizedTest\n+    @MethodSource(\"nonEmptySets\")\n+    void underlyingRef(Set<Value> inputs) {\n+        StableTestUtil.CountingFunction<Value, Integer> cif = new StableTestUtil.CountingFunction<>(MAPPER);\n+        Function<Value, Integer> f1 = StableValue.function(inputs, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+\n+        int i = 0;\n+        for (Value input : inputs) {\n+            assertEquals(inputs.size() - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = f1.apply(input);\n+            int v2 = f1.apply(input);\n+            i++;\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @modules java.base\/jdk.internal.lang.stable\n@@ -27,1 +28,1 @@\n- * @run junit StableIntFunctionTest\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED StableIntFunctionTest\n@@ -30,0 +31,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -109,0 +111,16 @@\n+    @Test\n+    void underlyingRef() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(MAPPER);\n+        IntFunction<Integer> f1 = StableValue.intFunction(SIZE, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+        for (int i = 0; i < SIZE; i++) {\n+            assertEquals(SIZE - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = f1.apply(i);\n+            int v2 = f1.apply(i);\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableIntFunctionTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run junit StableListTest\n+ * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED StableListTest\n@@ -33,0 +33,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -436,0 +437,16 @@\n+    @Test\n+    void underlyingRef() {\n+        StableTestUtil.CountingIntFunction<Integer> cif = new StableTestUtil.CountingIntFunction<>(IDENTITY);\n+        List<Integer> f1 = StableValue.list(SIZE, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+        for (int i = 0; i < SIZE; i++) {\n+            assertEquals(SIZE - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = f1.get(i);\n+            int v2 = f1.get(i);\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run junit StableMapTest\n+ * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED StableMapTest\n@@ -33,0 +33,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -43,0 +44,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -343,0 +345,57 @@\n+    @Test\n+    void underlyingRef() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cif = new StableTestUtil.CountingFunction<>(IDENTITY);\n+        Map<Integer, Integer> f1 = StableValue.map(KEYS, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+\n+        int i = 0;\n+        for (Integer input : KEYS) {\n+            assertEquals(KEYS.size() - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = f1.get(input);\n+            int v2 = f1.get(input);\n+            i++;\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n+    @Test\n+    void underlyingRefViaEntrySet() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cif = new StableTestUtil.CountingFunction<>(IDENTITY);\n+        Map<Integer, Integer> f1 = StableValue.map(KEYS, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+\n+        int i = 0;\n+        for (Map.Entry<Integer, Integer> e : f1.entrySet()) {\n+            assertEquals(KEYS.size() - i, holder.counter());\n+            assertSame(cif, holder.underlying());\n+            int v = e.getValue();\n+            int v2 = e.getValue();\n+            i++;\n+        }\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n+    @Test\n+    void underlyingRefViaEntrySetForEach() {\n+        StableTestUtil.CountingFunction<Integer, Integer> cif = new StableTestUtil.CountingFunction<>(IDENTITY);\n+        Map<Integer, Integer> f1 = StableValue.map(KEYS, cif);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+\n+        final AtomicInteger i = new AtomicInteger();\n+        f1.entrySet().forEach(e -> {\n+            assertEquals(KEYS.size() - i.get(), holder.counter());\n+            assertSame(cif, holder.underlying());\n+            Integer val = e.getValue();\n+            Integer val2 = e.getValue();\n+            i.incrementAndGet();\n+        });\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @run junit StableSupplierTest\n+ * @modules java.base\/jdk.internal.lang.stable\n+ * @run junit\/othervm --add-opens java.base\/jdk.internal.lang.stable=ALL-UNNAMED StableSupplierTest\n@@ -30,0 +31,1 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n@@ -34,0 +36,1 @@\n+import java.util.function.IntFunction;\n@@ -104,0 +107,33 @@\n+    @Test\n+    void underlyingRef() {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(SUPPLIER);\n+        var f1 = StableValue.supplier(cs);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+        assertEquals(1, holder.counter());\n+        assertSame(cs, holder.underlying());\n+        int v = f1.get();\n+        int v2 = f1.get();\n+        assertEquals(0, holder.counter());\n+        assertNull(holder.underlying());\n+    }\n+\n+    @Test\n+    void underlyingRefException() {\n+        StableTestUtil.CountingSupplier<Integer> cs = new StableTestUtil.CountingSupplier<>(() -> {\n+            throw new UnsupportedOperationException();\n+        });\n+        var f1 = StableValue.supplier(cs);\n+\n+        UnderlyingHolder<?> holder = StableTestUtil.underlyingHolder(f1);\n+        assertEquals(1, holder.counter());\n+        assertSame(cs, holder.underlying());\n+        try {\n+            int v = f1.get();\n+        } catch (UnsupportedOperationException _) {\n+            \/\/ Expected\n+        }\n+        assertEquals(1, holder.counter());\n+        assertSame(cs, holder.underlying());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableSupplierTest.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import jdk.internal.lang.stable.UnderlyingHolder;\n+\n+import java.lang.reflect.Field;\n@@ -120,0 +123,10 @@\n+    static UnderlyingHolder<?> underlyingHolder(Object o) {\n+        try {\n+            final Field field = o.getClass().getDeclaredField(\"underlyingHolder\");\n+            field.setAccessible(true);\n+            return (UnderlyingHolder<?>) field.get(o);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableTestUtil.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @modules java.base\/jdk.internal.lang.stable\n@@ -32,1 +33,0 @@\n-import java.util.ArrayList;\n@@ -40,1 +40,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -42,1 +41,0 @@\n-import java.util.concurrent.locks.LockSupport;\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}