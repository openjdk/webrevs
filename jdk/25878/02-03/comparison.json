{"files":[{"patch":"@@ -41,1 +41,0 @@\n-import java.util.function.Supplier;\n@@ -821,2 +820,1 @@\n-            return delegate.orElseSet(new Supplier<E>() {\n-                        @Override  public E get() { return underlyingHolder.underlying().apply(i); }}, underlyingHolder);\n+            return delegate.orElseSet(i, underlyingHolder);\n@@ -1637,4 +1635,1 @@\n-            @SuppressWarnings(\"unchecked\")\n-            final K k = (K) key;\n-            return stable.orElseSet(new Supplier<V>() {\n-                @Override public V get() { return underlyingHolder.underlying().apply(k); }}, underlyingHolder);\n+            return stable.orElseSet(key, underlyingHolder);\n@@ -1676,2 +1671,0 @@\n-                \/\/ Use a separate field for the outer class in order to facilitate\n-                \/\/ a @Stable annotation.\n@@ -1679,2 +1672,1 @@\n-                private final StableMapEntrySet<K, V> outer;\n-\n+                private final UnderlyingHolder<Function<? super K, ? extends V>> underlyingHolder;\n@@ -1685,1 +1677,1 @@\n-                    this.outer = outer;\n+                    this.underlyingHolder = outer.outer.underlyingHolder;\n@@ -1695,2 +1687,1 @@\n-                    return new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n-                        @Override public V get() { return outer.outer.underlyingHolder.underlying().apply(k); }}, outer.outer.underlyingHolder);\n+                    return new StableEntry<>(k, inner.getValue(), underlyingHolder);\n@@ -1706,2 +1697,1 @@\n-                                    action.accept(new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n-                                        @Override public V get() { return outer.outer.underlyingHolder.underlying().apply(k); }}, outer.outer.underlyingHolder));\n+                                    action.accept(new StableEntry<>(k, inner.getValue(), underlyingHolder));\n@@ -1723,1 +1713,0 @@\n-                                         Supplier<? extends V> supplier,\n@@ -1727,1 +1716,1 @@\n-            @Override public V getValue() { return stableValue.orElseSet(supplier, underlyingHolder); }\n+            @Override public V getValue() { return stableValue.orElseSet(getKey, underlyingHolder); }\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.util.function.Supplier;\n@@ -71,3 +70,1 @@\n-        return delegates[index].orElseSet(new Supplier<R>() {\n-            @Override public R get() { return underlyingHolder.underlying().apply(value); }}, underlyingHolder);\n-\n+        return delegates[index].orElseSet(value, underlyingHolder);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.function.Supplier;\n@@ -60,2 +59,1 @@\n-        return stable.orElseSet(new Supplier<R>() {\n-            @Override public R get() { return underlyingHolder.underlying().apply(value); }}, underlyingHolder);\n+        return stable.orElseSet(value, underlyingHolder);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -32,1 +33,0 @@\n-import java.util.function.Supplier;\n@@ -57,2 +57,1 @@\n-        return delegate.orElseSet(new Supplier<R>() {\n-            @Override public R get() { return underlyingHolder.underlying().apply(index); }}, underlyingHolder);\n+        return delegate.orElseSet(index, underlyingHolder);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        return delegate.orElseSet(underlyingHolder.underlying(), underlyingHolder);\n+        return delegate.orElseSet(null, underlyingHolder);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.function.Function;\n+import java.util.function.IntFunction;\n@@ -129,0 +131,2 @@\n+        \/\/ We are using the suppler as `input` here. A trick so that we do not have\n+        \/\/ to create an UnderlyingHolder.\n@@ -132,1 +136,8 @@\n-    \/\/ `supplier` can be null if the `underlyingHolder` released it.\n+\n+    @ForceInline\n+    public T orElseSet(final int input,\n+                       final UnderlyingHolder<?> underlyingHolder) {\n+        final Object t = wrappedContentsAcquire();\n+        return (t == null) ? orElseSetSlowPath(input, underlyingHolder) : unwrap(t);\n+    }\n+\n@@ -134,2 +145,2 @@\n-    public T orElseSet(Supplier<? extends T> supplier,\n-                       UnderlyingHolder<?> underlyingHolder) {\n+    public T orElseSet(final Object input,\n+                       final UnderlyingHolder<?> underlyingHolder) {\n@@ -137,1 +148,1 @@\n-        return (t == null) ? orElseSetSlowPath(supplier, underlyingHolder) : unwrap(t);\n+        return (t == null) ? orElseSetSlowPath(input, underlyingHolder) : unwrap(t);\n@@ -140,0 +151,1 @@\n+    @SuppressWarnings(\"unchecked\")\n@@ -141,2 +153,2 @@\n-    private T orElseSetSlowPath(Supplier<? extends T> supplier,\n-                                UnderlyingHolder<?> underlyingHolder) {\n+    private T orElseSetSlowPath(final Object input,\n+                                final UnderlyingHolder<?> underlyingHolder) {\n@@ -147,4 +159,13 @@\n-                final T newValue = supplier.get();\n-                \/\/ The mutex is not reentrant so we know newValue should be returned\n-                wrapAndSet(newValue);\n-                if (underlyingHolder != null) {\n+                final T newValue;\n+                if (underlyingHolder == null) {\n+                    \/\/ If there is no underlyingHolder, the input must be a\n+                    \/\/ `Supplier` because we were called from `.orElseSet(Supplier)`\n+                    newValue = ((Supplier<T>) input).get();\n+                } else {\n+                    final Object u = underlyingHolder.underlying();\n+                    newValue = switch (u) {\n+                        case Supplier<?> sup     -> (T) sup.get();\n+                        case IntFunction<?> iFun -> (T) iFun.apply((int) input);\n+                        case Function<?, ?> fun  -> ((Function<Object, T>) fun).apply(input);\n+                        default -> throw new InternalError(\"can not reach here\");\n+                    };\n@@ -155,0 +176,2 @@\n+                \/\/ The mutex is not reentrant so we know newValue should be returned\n+                wrapAndSet(newValue);\n@@ -221,1 +244,1 @@\n-    private static <T> T unwrap(Object t) {\n+    static <T> T unwrap(Object t) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":34,"deletions":11,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -6,5 +6,0 @@\n-import java.util.Objects;\n-import java.util.stream.Stream;\n-\n-import static java.util.stream.Collectors.joining;\n-\n@@ -12,1 +7,3 @@\n- * This class is thread safe.\n+ * This class is not thread safe. However, fields are only accessed within a block that\n+ * is guarded by the same synchronization object. Still, it can be instantiated from\n+ * any thread with no synchronization. Hence, the constructor must safely publish fields.\n@@ -20,6 +17,2 @@\n-    private static final long COUNTER_OFFSET =\n-            UNSAFE.objectFieldOffset(UnderlyingHolder.class, \"counter\");\n-\n-    \/\/ Used reflectively. This field can only transition at most once from being set to a\n-    \/\/ non-null reference to being `null`. Once `null`, it is never read. This allows\n-    \/\/ the field to be non-volatile, which is crucial for getting optimum performance.\n+    \/\/ This field can only transition at most once from being set to a\n+    \/\/ non-null reference to being `null`. Once `null`, it is never read.\n@@ -27,2 +20,0 @@\n-\n-    \/\/ Used reflectively\n@@ -45,1 +36,1 @@\n-        return UNSAFE.getIntVolatile(this, COUNTER_OFFSET);\n+        return counter;\n@@ -49,1 +40,1 @@\n-        if (UNSAFE.getAndAddInt(this, COUNTER_OFFSET, -1) == 1) {\n+        if (--counter == 0) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/UnderlyingHolder.java","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"}]}