{"files":[{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * Object wrapper implementing {@link Object#equals(Object)} such that it\n+ * returns {@code true} only when the argument is another instance of this class\n+ * wrapping the same object.\n+ * <p>\n+ * The class guarantees that {@link Object#equals(Object)} and\n+ * {@link Object#hashCode()} methods of the wrapped object will never be called\n+ * inside of the class methods.\n+ *\n+ * @param <T> the type of the wrapped value\n+ *\/\n+public final class IdentityWrapper<T> {\n+\n+    public IdentityWrapper(T value) {\n+        this.value = Objects.requireNonNull(value);\n+    }\n+\n+    public T value() {\n+        return value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if ((obj == null) || (getClass() != obj.getClass())) {\n+            return false;\n+        }\n+        var other = (IdentityWrapper<?>) obj;\n+        return value == other.value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Identity[%s]\", value);\n+    }\n+\n+    private final T value;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/IdentityWrapper.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.Map;\n+import org.junit.jupiter.api.Test;\n+\n+public class JUnitUtilsTest {\n+\n+    @Test\n+    public void test_assertArrayEquals() {\n+        JUnitUtils.assertArrayEquals(new int[] {1, 2, 3}, new int[] {1, 2, 3});\n+        JUnitUtils.assertArrayEquals(new long[] {1, 2, 3}, new long[] {1, 2, 3});\n+        JUnitUtils.assertArrayEquals(new boolean[] {true, true}, new boolean[] {true, true});\n+    }\n+\n+    @Test\n+    public void test_assertArrayEquals_negative() {\n+        assertThrows(AssertionError.class, () -> {\n+            JUnitUtils.assertArrayEquals(new int[] {1, 2, 3}, new int[] {2, 3});\n+        });\n+    }\n+\n+    @Test\n+    public void test_exceptionAsPropertyMapWithMessageWithoutCause() {\n+\n+        var ex = new Exception(\"foo\");\n+\n+        var map = JUnitUtils.exceptionAsPropertyMap(ex);\n+\n+        assertEquals(Map.of(\"getClass\", Exception.class.getName(), \"getMessage\", \"foo\"), map);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JUnitUtilsTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,731 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import org.junit.jupiter.api.Test;\n+\n+public class ObjectMapperTest {\n+\n+    @Test\n+    public void test_String() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(\"foo\");\n+\n+        assertEquals(\"foo\", map);\n+    }\n+\n+    @Test\n+    public void test_int() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(100);\n+\n+        assertEquals(100, map);\n+    }\n+\n+    @Test\n+    public void test_null() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(null);\n+\n+        assertNull(map);\n+    }\n+\n+    @Test\n+    public void test_Object() {\n+        var obj = new Object();\n+        assertSame(obj, ObjectMapper.blank().create().map(obj));\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_Path() {\n+        var obj = Path.of(\"foo\/bar\");\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_UUID() {\n+        var obj = UUID.randomUUID();\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_BigInteger() {\n+        var obj = BigInteger.TEN;\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_Enum() {\n+\n+        var expected = Map.of(\n+                \"name\", TestEnum.BAR.name(),\n+                \"ordinal\", TestEnum.BAR.ordinal(),\n+                \"a\", \"A\",\n+                \"b\", 123,\n+                \"num\", 100\n+        );\n+\n+        assertEquals(expected, ObjectMapper.standard().create().map(TestEnum.BAR));\n+    }\n+\n+    @Test\n+    public void test_array_int() {\n+\n+        var obj = new int[] { 1, 4, 5 };\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_String() {\n+\n+        var obj = new String[] { \"Hello\", \"Bye\" };\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_empty() {\n+\n+        var obj = new Thread[0];\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_nulls() {\n+\n+        var obj = new Thread[10];\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_Path() {\n+\n+        var obj = new Path[] { Path.of(\"foo\/bar\"), null, Path.of(\"\").toAbsolutePath() };\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_Object() {\n+\n+        var obj = new Object[] { Path.of(\"foo\/bar\"), null, 145, new Simple.Stub(\"Hello\", 738), \"foo\" };\n+\n+        var expected = new Object[] { Path.of(\"foo\/bar\"), null, 145, Map.of(\"a\", \"Hello\", \"b\", 738), \"foo\" };\n+\n+        assertArrayEquals(expected, (Object[])ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_functional() {\n+        assertWrappedIdentity(new Function<Object, Integer>() {\n+\n+            @Override\n+            public Integer apply(Object o) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new BiFunction<Object, String, Integer>() {\n+\n+            @Override\n+            public Integer apply(Object a, String b) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Consumer<>() {\n+\n+            @Override\n+            public void accept(Object o) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new BiConsumer<>() {\n+\n+            @Override\n+            public void accept(Object a, Object b) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Predicate<>() {\n+\n+            @Override\n+            public boolean test(Object o) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Supplier<>() {\n+\n+            @Override\n+            public Object get() {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+    }\n+\n+    @Test\n+    public void testIdentityWrapper() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var a = new Object() {};\n+        var b = new Object() {};\n+\n+        var amap = om.map(a);\n+        var amap2 = om.map(a);\n+\n+        assertEquals(amap, amap2);\n+        assertEquals(ObjectMapper.wrapIdentity(a), amap);\n+\n+        var bmap = om.map(b);\n+\n+        assertNotEquals(amap, bmap);\n+        assertEquals(ObjectMapper.wrapIdentity(b), bmap);\n+    }\n+\n+    @Test\n+    public void test_wrapIdentity() {\n+\n+        assertThrowsExactly(NullPointerException.class, () -> ObjectMapper.wrapIdentity(null));\n+\n+        var iw = ObjectMapper.wrapIdentity(new Object());\n+\n+        assertSame(iw, ObjectMapper.wrapIdentity(iw));\n+\n+        var simpleStubA = new Simple.Stub(\"Hello\", 77);\n+        var simpleStubB = new Simple.Stub(\"Hello\", 77);\n+\n+        assertEquals(simpleStubA, simpleStubB);\n+        assertNotEquals(ObjectMapper.wrapIdentity(simpleStubA), ObjectMapper.wrapIdentity(simpleStubB));\n+        assertEquals(ObjectMapper.wrapIdentity(simpleStubA), ObjectMapper.wrapIdentity(simpleStubA));\n+    }\n+\n+    @Test\n+    public void test_empty_List() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(List.of());\n+\n+        assertEquals(List.of(), map);\n+    }\n+\n+    @Test\n+    public void test_List() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(List.of(100, \"foo\"));\n+\n+        assertEquals(List.of(100, \"foo\"), map);\n+    }\n+\n+    @Test\n+    public void test_empty_Map() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(Map.of());\n+\n+        assertEquals(Map.of(), map);\n+    }\n+\n+    @Test\n+    public void test_Map() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(Map.of(100, \"foo\"));\n+\n+        assertEquals(Map.of(100, \"foo\"), map);\n+    }\n+\n+    @Test\n+    public void test_MapSimple() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Map.of(123, \"foo\", 321, new Simple.Stub(\"Hello\", 567)));\n+\n+        assertEquals(Map.of(123, \"foo\", 321, Map.of(\"a\", \"Hello\", \"b\", 567)), map);\n+    }\n+\n+    @Test\n+    public void test_ListSimple() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(List.of(100, new Simple.Stub(\"Hello\", 567), \"bar\", new Simple() {}));\n+\n+        assertEquals(List.of(100, Map.of(\"a\", \"Hello\", \"b\", 567), \"bar\", Map.of(\"a\", \"foo\", \"b\", 123)), map);\n+    }\n+\n+    @Test\n+    public void test_Simple() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(new Simple() {});\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), map);\n+    }\n+\n+    @Test\n+    public void test_Proxy() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Proxy.newProxyInstance(Simple.class.getClassLoader(), new Class<?>[] { Simple.class }, new InvocationHandler() {\n+\n+            @Override\n+            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                switch (method.getName()) {\n+                    case \"a\" -> {\n+                        return \"Bye\";\n+                    }\n+                    case \"b\" -> {\n+                        return 335;\n+                    }\n+                    default -> {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                }\n+            }\n+\n+        }));\n+\n+        assertEquals(Map.of(\"a\", \"Bye\", \"b\", 335), map);\n+    }\n+\n+    @Test\n+    public void test_Simple_null_property() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(new Simple.Stub(null, 123));\n+\n+        assertEquals(Map.of(\"b\", 123, \"a\", ObjectMapper.NULL), map);\n+    }\n+\n+    @Test\n+    public void test_Optional_String() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Optional.of(\"foo\"));\n+\n+        assertEquals(Map.of(\"get\", \"foo\"), map);\n+    }\n+\n+    @Test\n+    public void test_Optional_empty() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Optional.empty());\n+\n+        assertEquals(Map.of(\"get\", ObjectMapper.NULL), map);\n+    }\n+\n+    @Test\n+    public void test_toMap() {\n+        var om = ObjectMapper.standard().create();\n+\n+        assertNull(om.toMap(null));\n+        assertEquals(Map.of(\"value\", \"Hello\"), om.toMap(\"Hello\"));\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+    }\n+\n+    @Test\n+    public void test_getter_throws() {\n+        var om = ObjectMapper.blank()\n+                .mutate(ObjectMapper.configureObject())\n+                .mutate(ObjectMapper.configureLeafClasses())\n+                .mutate(ObjectMapper.configureException())\n+                .create();\n+\n+        var expected = Map.of(\"get\", om.toMap(new UnsupportedOperationException(\"Not for you!\")));\n+\n+        var actual = om.toMap(new Supplier<>() {\n+            @Override\n+            public Object get() {\n+                throw new UnsupportedOperationException(\"Not for you!\");\n+            }\n+        });\n+\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void test_exception_with_message_with_cause() {\n+\n+        var ex = new Exception(\"foo\", new IllegalArgumentException(\"Cause\", new RuntimeException(\"Ops!\")));\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\n+                \"getClass\", Exception.class.getName(),\n+                \"getMessage\", \"foo\",\n+                \"getCause\", Map.of(\n+                        \"getClass\", IllegalArgumentException.class.getName(),\n+                        \"getMessage\", \"Cause\",\n+                        \"getCause\", Map.of(\n+                                \"getClass\", RuntimeException.class.getName(),\n+                                \"getMessage\", \"Ops!\"\n+                        )\n+                )\n+        ), map);\n+    }\n+\n+    @Test\n+    public void test_exception_without_message_with_cause() {\n+\n+        var ex = new RuntimeException(null, new UnknownError(\"Ops!\"));\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\n+                \"getClass\", RuntimeException.class.getName(),\n+                \"getCause\", Map.of(\n+                        \"getMessage\", \"Ops!\",\n+                        \"getCause\", ObjectMapper.NULL\n+                )\n+        ), map);\n+    }\n+\n+    @Test\n+    public void test_exception_without_message_without_cause() {\n+\n+        var ex = new UnsupportedOperationException();\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\"getClass\", UnsupportedOperationException.class.getName()), map);\n+    }\n+\n+    @Test\n+    public void test_exception_CustomException() {\n+\n+        var ex = new CustomException(\"Hello\", Path.of(\"\"), Optional.empty(), null);\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\n+                \"getClass\", CustomException.class.getName(),\n+                \"getMessage\", \"Hello\",\n+                \"op\", Map.of(\"get\", ObjectMapper.NULL),\n+                \"path2\", Path.of(\"\")\n+        ), map);\n+    }\n+\n+    @Test\n+    public void test_Builder_accessPackageMethods() {\n+\n+        var obj = new TestType().foo(\"Hello\").bar(81);\n+\n+        var map = ObjectMapper.standard().create().toMap(obj);\n+\n+        assertEquals(Map.of(\"foo\", \"Hello\"), map);\n+\n+        map = ObjectMapper.standard().accessPackageMethods(TestType.class.getPackage()).create().toMap(obj);\n+\n+        assertEquals(Map.of(\"foo\", \"Hello\", \"bar\", 81), map);\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_Simple() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleStub() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.Stub.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\", \"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.Stub.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\", \"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleDefault() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.Default.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.Default.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleDefaultExt() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.DefaultExt.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.DefaultExt.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleStub_and_SimpleDefault() {\n+\n+        var om = ObjectMapper.standard()\n+                .exceptSomeMethods(Simple.Stub.class).add(\"a\").apply()\n+                .exceptSomeMethods(Simple.Default.class).add(\"a\").apply()\n+                .create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard()\n+                .exceptSomeMethods(Simple.Stub.class).add(\"b\").apply()\n+                .exceptSomeMethods(Simple.Default.class).add(\"b\").apply()\n+                .create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_all_excluded() {\n+\n+        var om = ObjectMapper.standard()\n+                .exceptSomeMethods(Simple.class).add(\"a\").apply()\n+                .exceptSomeMethods(Simple.Stub.class).add(\"b\").apply()\n+                .create();\n+\n+        var obj = new Simple.Stub(\"Hello\", 345);\n+\n+        assertEquals(ObjectMapper.wrapIdentity(obj), om.map(obj));\n+    }\n+\n+    interface Simple {\n+        default String a() {\n+            return \"foo\";\n+        }\n+\n+        default int b() {\n+            return 123;\n+        }\n+\n+        record Stub(String a, int b) implements Simple {}\n+\n+        static class Default implements Simple {\n+            Default(String a) {\n+                this.a = a;\n+            }\n+\n+            @Override\n+            public String a() {\n+                return a;\n+            }\n+\n+            private final String a;\n+        }\n+\n+        static class DefaultExt extends Default {\n+            DefaultExt(String a, int b) {\n+                super(a);\n+                this.b = b;\n+            }\n+\n+            @Override\n+            public String a() {\n+                return \"[\" + super.a() + \"]\";\n+            }\n+\n+            @Override\n+            public int b() {\n+                return 10 + b;\n+            }\n+\n+            private final int b;\n+        }\n+    }\n+\n+    final class TestType {\n+\n+        public String foo() {\n+            return foo;\n+        }\n+\n+        public TestType foo(String v) {\n+            foo = v;\n+            return this;\n+        }\n+\n+        int bar() {\n+            return bar;\n+        }\n+\n+        TestType bar(int v) {\n+            bar = v;\n+            return this;\n+        }\n+\n+        private String foo;\n+        private int bar;\n+    }\n+\n+    enum TestEnum implements Simple {\n+        FOO,\n+        BAR;\n+\n+        public int num() {\n+            return 100;\n+        }\n+\n+        public int num(int v) {\n+            return v;\n+        }\n+\n+        @Override\n+        public String a() {\n+            return \"A\";\n+        }\n+    }\n+\n+    static final class CustomException extends Exception {\n+\n+        CustomException(String message, Path path, Optional<Object> optional, Throwable cause) {\n+            super(message, cause);\n+            this.path = path;\n+            this.optional = optional;\n+        }\n+\n+        Path path() {\n+            return path;\n+        }\n+\n+        public Path path2() {\n+            return path;\n+        }\n+\n+        public Optional<Object> op() {\n+            return optional;\n+        }\n+\n+        private final Path path;\n+        private final Optional<Object> optional;\n+\n+        private static final long serialVersionUID = 1L;\n+\n+    }\n+\n+    private static void assertWrappedIdentity(ObjectMapper om, Object obj) {\n+        var map = om.toMap(obj);\n+        assertEquals(Map.of(\"value\", ObjectMapper.wrapIdentity(obj)), map);\n+    }\n+\n+    private static void assertWrappedIdentity(Object obj) {\n+        assertWrappedIdentity(ObjectMapper.standard().create(), obj);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/ObjectMapperTest.java","additions":731,"deletions":0,"binary":false,"changes":731,"status":"added"},{"patch":"@@ -344,1 +344,1 @@\n-                    JPackageCommand assertAppLayout() {\n+                    JPackageCommand runStandardAsserts() {\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-    static PropertyFile getAdditionalLauncherProperties(\n+    public static PropertyFile getAdditionalLauncherProperties(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,7 @@\n-    public static ApplicationLayout javaRuntime() {\n+    public static ApplicationLayout platformJavaRuntime() {\n+        Path runtime = Path.of(\"\");\n+        Path runtimeHome = runtime;\n+        if (TKit.isOSX()) {\n+            runtimeHome = Path.of(\"Contents\/Home\");\n+        }\n+\n@@ -105,2 +111,2 @@\n-                Path.of(\"\"),\n-                null,\n+                runtime,\n+                runtimeHome,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ApplicationLayout.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Provides uniform way to configure {@code JPackageCommand} and\n+ * {@code PackageTest} instances.\n+ *\/\n+public record ConfigurationTarget(Optional<JPackageCommand> cmd, Optional<PackageTest> test) {\n+\n+    public ConfigurationTarget {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(test);\n+        if (cmd.isEmpty() == test.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public ConfigurationTarget(JPackageCommand target) {\n+        this(Optional.of(target), Optional.empty());\n+    }\n+\n+    public ConfigurationTarget(PackageTest target) {\n+        this(Optional.empty(), Optional.of(target));\n+    }\n+\n+    public ConfigurationTarget apply(Consumer<JPackageCommand> a, Consumer<PackageTest> b) {\n+        cmd.ifPresent(Objects.requireNonNull(a));\n+        test.ifPresent(Objects.requireNonNull(b));\n+        return this;\n+    }\n+\n+    public ConfigurationTarget addInitializer(Consumer<JPackageCommand> initializer) {\n+        cmd.ifPresent(Objects.requireNonNull(initializer));\n+        test.ifPresent(v -> {\n+            v.addInitializer(initializer::accept);\n+        });\n+        return this;\n+    }\n+\n+    public ConfigurationTarget add(AdditionalLauncher addLauncher) {\n+        return apply(addLauncher::applyTo, addLauncher::applyTo);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigurationTarget.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -128,0 +128,2 @@\n+        \/\/ Use an old release number to make test app classes runnable on older runtimes.\n+        builder.setRelease(11);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -73,0 +74,1 @@\n+        excludeStandardAsserts(StandardAssert.MAIN_LAUNCHER_DESCRIPTION);\n@@ -88,1 +90,1 @@\n-        appLayoutAsserts = cmd.appLayoutAsserts;\n+        standardAsserts = cmd.standardAsserts;\n@@ -462,1 +464,1 @@\n-            layout = ApplicationLayout.javaRuntime();\n+            layout = ApplicationLayout.platformJavaRuntime();\n@@ -936,1 +938,1 @@\n-        assertAppLayout();\n+        runStandardAsserts();\n@@ -979,4 +981,4 @@\n-                final var snapshopGroup = snapshots.get(a);\n-                final var newSnapshopGroup = newSnapshots.get(a);\n-                for (int i = 0; i < snapshopGroup.size(); i++) {\n-                    TKit.PathSnapshot.assertEquals(snapshopGroup.get(i), newSnapshopGroup.get(i),\n+                final var snapshotGroup = snapshots.get(a);\n+                final var newSnapshotGroup = newSnapshots.get(a);\n+                for (int i = 0; i < snapshotGroup.size(); i++) {\n+                    snapshotGroup.get(i).assertEquals(newSnapshotGroup.get(i),\n@@ -1097,1 +1099,1 @@\n-    public static enum AppLayoutAssert {\n+    public static enum StandardAssert {\n@@ -1117,0 +1119,5 @@\n+        MAIN_LAUNCHER_DESCRIPTION(cmd -> {\n+            if (!cmd.isRuntime()) {\n+                new LauncherVerifier(cmd).verify(cmd, LauncherVerifier.Action.VERIFY_DESCRIPTION);\n+            }\n+        }),\n@@ -1141,1 +1148,1 @@\n-        AppLayoutAssert(Consumer<JPackageCommand> action) {\n+        StandardAssert(Consumer<JPackageCommand> action) {\n@@ -1159,1 +1166,1 @@\n-    public JPackageCommand setAppLayoutAsserts(AppLayoutAssert ... asserts) {\n+    public JPackageCommand setStandardAsserts(StandardAssert ... asserts) {\n@@ -1161,1 +1168,1 @@\n-        appLayoutAsserts = Set.of(asserts);\n+        standardAsserts = Set.of(asserts);\n@@ -1165,1 +1172,1 @@\n-    public JPackageCommand excludeAppLayoutAsserts(AppLayoutAssert... asserts) {\n+    public JPackageCommand excludeStandardAsserts(StandardAssert... asserts) {\n@@ -1167,2 +1174,2 @@\n-        return setAppLayoutAsserts(appLayoutAsserts.stream().filter(Predicate.not(\n-                asSet::contains)).toArray(AppLayoutAssert[]::new));\n+        return setStandardAsserts(standardAsserts.stream().filter(Predicate.not(\n+                asSet::contains)).toArray(StandardAssert[]::new));\n@@ -1171,3 +1178,3 @@\n-    JPackageCommand assertAppLayout() {\n-        for (var appLayoutAssert : appLayoutAsserts.stream().sorted().toList()) {\n-            appLayoutAssert.action.accept(this);\n+    JPackageCommand runStandardAsserts() {\n+        for (var standardAssert : standardAsserts.stream().sorted().toList()) {\n+            standardAssert.action.accept(this);\n@@ -1523,1 +1530,1 @@\n-    private Set<AppLayoutAssert> appLayoutAsserts = Set.of(AppLayoutAssert.values());\n+    private Set<StandardAssert> standardAsserts = Set.of(StandardAssert.values());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":25,"deletions":18,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -51,0 +52,5 @@\n+    public JarBuilder setRelease(int v) {\n+        release = v;\n+        return this;\n+    }\n+\n@@ -64,1 +70,1 @@\n-                new Executor()\n+                var exec = new Executor()\n@@ -66,3 +72,7 @@\n-                        .addArguments(\"-d\", workDir.toString())\n-                        .addPathArguments(sourceFiles)\n-                        .execute();\n+                        .addArguments(\"-d\", workDir.toString());\n+\n+                Optional.ofNullable(release).ifPresent(r -> {\n+                    exec.addArguments(\"--release\", r.toString());\n+                });\n+\n+                exec.addPathArguments(sourceFiles).execute();\n@@ -95,0 +105,1 @@\n+    private Integer release;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JarBuilder.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Optional;\n@@ -40,0 +41,1 @@\n+        expectedDefault = false;\n@@ -44,0 +46,1 @@\n+        expectedIcon = null;\n@@ -48,0 +51,4 @@\n+    public LauncherIconVerifier setExpectedNoIcon() {\n+        return setExpectedIcon(null);\n+    }\n+\n@@ -53,0 +60,8 @@\n+    public boolean expectDefaultIcon() {\n+        return expectedDefault;\n+    }\n+\n+    public Optional<Path> expectIcon() {\n+        return Optional.ofNullable(expectedIcon);\n+    }\n+\n@@ -73,1 +88,1 @@\n-            TKit.assertPathExists(iconPath, true);\n+            TKit.assertFileExists(iconPath);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n@@ -26,0 +27,3 @@\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n@@ -48,1 +52,0 @@\n-import java.util.stream.Collectors;\n@@ -167,2 +170,1 @@\n-                        \"Depends\").split(\",\")).map(String::strip).collect(\n-                        Collectors.toList());\n+                        \"Depends\").split(\",\")).map(String::strip).toList();\n@@ -329,1 +331,1 @@\n-                    runtimeDir::resolve).collect(Collectors.toSet());\n+                    runtimeDir::resolve).collect(toSet());\n@@ -331,2 +333,1 @@\n-                    expectedCriticalRuntimePaths::contains).collect(\n-                            Collectors.toSet());\n+                    expectedCriticalRuntimePaths::contains).collect(toSet());\n@@ -378,2 +379,1 @@\n-                Set<String> words = Stream.of(line.split(\"\\\\s+\")).collect(\n-                        Collectors.toSet());\n+                Set<String> words = Stream.of(line.split(\"\\\\s+\")).collect(toSet());\n@@ -457,0 +457,1 @@\n+\n@@ -458,0 +459,16 @@\n+\n+        return relativePackageFilesInSubdirectory(cmd, ApplicationLayout::desktopIntegrationDirectory)\n+                .filter(path -> {\n+                    return path.getNameCount() == 1;\n+                })\n+                .filter(path -> {\n+                    return \".desktop\".equals(PathUtils.getSuffix(path));\n+                })\n+                .map(unpackedDir::resolve)\n+                .toList();\n+    }\n+\n+    private static Stream<Path> relativePackageFilesInSubdirectory(\n+            JPackageCommand cmd, Function<ApplicationLayout, Path> subdirFunc) {\n+\n+        var unpackedDir = subdirFunc.apply(cmd.appLayout());\n@@ -459,0 +476,1 @@\n+\n@@ -460,2 +478,2 @@\n-            return packageDir.equals(path.getParent()) && path.getFileName().toString().endsWith(\".desktop\");\n-        }).map(Path::getFileName).map(unpackedDir::resolve).toList();\n+            return path.startsWith(packageDir);\n+        }).map(packageDir::relativize);\n@@ -499,1 +517,14 @@\n-        for (var e : List.of(Map.entry(\"Type\", \"Application\"), Map.entry(\"Terminal\", \"false\"))) {\n+        final String launcherDescription;\n+        if (cmd.name().equals(launcherName) || predefinedAppImage.isPresent()) {\n+            launcherDescription = Optional.ofNullable(cmd.getArgumentValue(\"--description\")).orElseGet(cmd::name);\n+        } else {\n+            launcherDescription = getAdditionalLauncherProperties(cmd, launcherName).findProperty(\"description\").or(() -> {\n+                return Optional.ofNullable(cmd.getArgumentValue(\"--description\"));\n+            }).orElseGet(cmd::name);\n+        }\n+\n+        for (var e : List.of(\n+                Map.entry(\"Type\", \"Application\"),\n+                Map.entry(\"Terminal\", \"false\"),\n+                Map.entry(\"Comment\", launcherDescription)\n+        )) {\n@@ -771,1 +802,1 @@\n-                        v -> v.rpm).collect(Collectors.joining(\"|\"))));\n+                        v -> v.rpm).collect(joining(\"|\"))));\n@@ -774,1 +805,1 @@\n-                Collectors.toMap(v -> v.rpm, v -> v));\n+                toMap(v -> v.rpm, v -> v));\n@@ -851,1 +882,1 @@\n-                }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+                }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,780 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntPredicate;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.xml.stream.XMLStreamWriter;\n+import jdk.jpackage.internal.util.IdentityWrapper;\n+\n+public final class ObjectMapper {\n+\n+    private ObjectMapper(\n+            Predicate<String> classFilter,\n+            Predicate<List<String>> methodFilter,\n+            Predicate<String> leafClassFilter,\n+            Map<Method, Function<?, Object>> substitutes,\n+            Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators,\n+            Set<String> accessPackageMethods) {\n+\n+        this.classFilter = Objects.requireNonNull(classFilter);\n+        this.methodFilter = Objects.requireNonNull(methodFilter);\n+        this.leafClassFilter = Objects.requireNonNull(leafClassFilter);\n+        this.substitutes = Objects.requireNonNull(substitutes);\n+        this.mutators = Objects.requireNonNull(mutators);\n+        this.accessPackageMethods = accessPackageMethods;\n+    }\n+\n+    public static Builder blank() {\n+        return new Builder().allowAllLeafClasses(false).exceptLeafClasses().add(Stream.of(\n+                Object.class,\n+                String.class, String[].class,\n+                boolean.class, Boolean.class, boolean[].class, Boolean[].class,\n+                byte.class, Byte.class, byte[].class, Byte[].class,\n+                char.class, Character.class, char[].class, Character[].class,\n+                short.class, Short.class, short[].class, Short[].class,\n+                int.class, Integer.class, int[].class, Integer[].class,\n+                long.class, Long.class, long[].class, Long[].class,\n+                float.class, Float.class, float[].class, Float[].class,\n+                double.class, Double.class, double[].class, Double[].class,\n+                void.class, Void.class, Void[].class\n+        ).map(Class::getName).toList()).apply();\n+    }\n+\n+    public static Builder standard() {\n+        return blank()\n+                .mutate(configureObject())\n+                .mutate(configureLeafClasses())\n+                .mutate(configureOptional())\n+                .mutate(configureFunctionalTypes())\n+                .mutate(configureEnum())\n+                .mutate(configureException());\n+    }\n+\n+    public static Consumer<Builder> configureObject() {\n+        \/\/ Exclude all method of Object class.\n+        return builder -> {\n+            builder.exceptMethods().add(OBJECT_METHODS).apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureLeafClasses() {\n+        return builder -> {\n+            builder.exceptLeafClasses().add(Stream.of(\n+                    IdentityWrapper.class,\n+                    Class.class,\n+                    Path.class,\n+                    Path.of(\"\").getClass(),\n+                    UUID.class,\n+                    BigInteger.class\n+            ).map(Class::getName).toList()).apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureOptional() {\n+        return builder -> {\n+            \/\/ Filter out all but \"get()\" methods of \"Optional\" class.\n+            builder.exceptAllMethods(Optional.class).remove(\"get\").apply();\n+            \/\/ Substitute \"Optional.get()\" with the function that will return \"null\" if the value is \"null\".\n+            builder.subst(Optional.class, \"get\", opt -> {\n+                if (opt.isPresent()) {\n+                    return opt.get();\n+                } else {\n+                    return null;\n+                }\n+            });\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureFunctionalTypes() {\n+        \/\/ Remove all getters from the standard functional types.\n+        return builder -> {\n+            builder.exceptAllMethods(Predicate.class).apply();\n+            builder.exceptAllMethods(Supplier.class).apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureEnum() {\n+        return builder -> {\n+            \/\/ Filter out \"getDeclaringClass()\" and \"describeConstable()\" methods of \"Enum\" class.\n+            builder.exceptSomeMethods(Enum.class).add(\"getDeclaringClass\", \"describeConstable\").apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureException() {\n+        return builder -> {\n+            \/\/ Include only \"getMessage()\" and \"getCause()\" methods of \"Exception\" class.\n+            builder.exceptAllMethods(Exception.class).remove(\"getMessage\", \"getCause\").apply();\n+            builder.mutator(Exception.class, (ex, map) -> {\n+                var eit = map.entrySet().iterator();\n+                while (eit.hasNext()) {\n+                    var e = eit.next();\n+                    if (e.getValue() == NULL) {\n+                        \/\/ Remove property with the \"null\" value.\n+                        eit.remove();\n+                    }\n+                }\n+                map.put(\"getClass\", ex.getClass().getName());\n+            });\n+        };\n+    }\n+\n+    public static String lookupFullMethodName(Method m) {\n+        return lookupFullMethodName(m.getDeclaringClass(), m.getName());\n+    }\n+\n+    public static String lookupFullMethodName(Class<?> c, String m) {\n+        return Objects.requireNonNull(c).getName() + lookupMethodName(m);\n+    }\n+\n+    public static String lookupMethodName(Method m) {\n+        return lookupMethodName(m.getName());\n+    }\n+\n+    public static String lookupMethodName(String m) {\n+        return \"#\" + Objects.requireNonNull(m);\n+    }\n+\n+    public static Object wrapIdentity(Object v) {\n+        if (v instanceof IdentityWrapper<?> wrapper) {\n+            return wrapper;\n+        } else {\n+            return new IdentityWrapper<Object>(v);\n+        }\n+    }\n+\n+    public static void store(Map<String, Object> map, XMLStreamWriter xml) {\n+        XmlWriter.writePropertyMap(map, xml);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Optional<T> findNonNullProperty(Map<String, Object> map, String propertyName) {\n+        Objects.requireNonNull(propertyName);\n+        Objects.requireNonNull(map);\n+\n+        return Optional.ofNullable(map.get(propertyName)).filter(Predicate.not(NULL::equals)).map(v -> {\n+            return (T)v;\n+        });\n+    }\n+\n+    public Object map(Object obj) {\n+        if (obj != null) {\n+            return mapObject(obj).orElseGet(Map::of);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<String, Object> toMap(Object obj) {\n+        if (obj == null) {\n+            return null;\n+        } else {\n+            var mappedObj = map(obj);\n+            if (mappedObj instanceof Map<?, ?> m) {\n+                return (Map<String, Object>)m;\n+            } else {\n+                return Map.of(\"value\", mappedObj);\n+            }\n+        }\n+    }\n+\n+    public Optional<Object> mapObject(Object obj) {\n+        if (obj == null) {\n+            return Optional.empty();\n+        }\n+\n+        if (leafClassFilter.test(obj.getClass().getName())) {\n+            return Optional.of(obj);\n+        }\n+\n+        if (!filter(obj.getClass())) {\n+            return Optional.empty();\n+        }\n+\n+        if (obj instanceof Iterable<?> col) {\n+            return Optional.of(mapIterable(col));\n+        }\n+\n+        if (obj instanceof Map<?, ?> map) {\n+            return Optional.of(mapMap(map));\n+        }\n+\n+        if (obj.getClass().isArray()) {\n+            return Optional.of(mapArray(obj));\n+        }\n+\n+        var theMap = getMethods(obj).map(m -> {\n+            final Object propertyValue;\n+            final var subst = substitutes.get(m);\n+            if (subst != null) {\n+                propertyValue = applyGetter(obj, subst);\n+            } else {\n+                propertyValue = invoke(m, obj);\n+            }\n+            return Map.entry(m.getName(), mapObject(propertyValue).orElse(NULL));\n+        }).collect(toMutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        mutators.entrySet().stream().filter(m -> {\n+            return m.getKey().isInstance(obj);\n+        }).findFirst().ifPresent(m -> {\n+            m.getValue().accept(obj, theMap);\n+        });\n+\n+        if (theMap.isEmpty()) {\n+            return Optional.of(wrapIdentity(obj));\n+        }\n+\n+        return Optional.of(theMap);\n+    }\n+\n+    private Object invoke(Method m, Object obj) {\n+        try {\n+            return m.invoke(obj);\n+        } catch (IllegalAccessException ex) {\n+            throw rethrowUnchecked(ex);\n+        } catch (InvocationTargetException ex) {\n+            return map(ex.getTargetException());\n+        }\n+    }\n+\n+    private Collection<Object> mapIterable(Iterable<?> col) {\n+        final List<Object> list = new ArrayList<>();\n+        for (var obj : col) {\n+            list.add(mapObject(obj).orElse(NULL));\n+        }\n+        return list;\n+    }\n+\n+    private Map<Object, Object> mapMap(Map<?, ?> map) {\n+        return map.entrySet().stream().collect(toMutableMap(e -> {\n+            return mapObject(e.getKey()).orElse(NULL);\n+        }, e -> {\n+            return mapObject(e.getValue()).orElse(NULL);\n+        }));\n+    }\n+\n+    private Object mapArray(Object arr) {\n+        final var len = Array.getLength(arr);\n+\n+        if (len == 0) {\n+            return arr;\n+        }\n+\n+        Object[] buf = null;\n+\n+        for (int i = 0; i != len; i++) {\n+            var from = Array.get(arr, i);\n+            if (from != null) {\n+                var to = mapObject(from).orElseThrow();\n+                if (from != to || buf != null) {\n+                    if (buf == null) {\n+                        buf = (Object[])Array.newInstance(Object.class, len);\n+                        System.arraycopy(arr, 0, buf, 0, i);\n+                    }\n+                    buf[i] = to;\n+                }\n+            }\n+        }\n+\n+        return Optional.ofNullable((Object)buf).orElse(arr);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> Object applyGetter(Object obj, Function<T, Object> getter) {\n+        return getter.apply((T)obj);\n+    }\n+\n+    private boolean filter(Class<?> type) {\n+        return classFilter.test(type.getName());\n+    }\n+\n+    private boolean filter(Method m) {\n+        return methodFilter.test(List.of(lookupMethodName(m), lookupFullMethodName(m)));\n+    }\n+\n+    private Stream<Method> getMethods(Object obj) {\n+        return MethodGroups.create(obj.getClass(), accessPackageMethods).filter(this::filter).map(MethodGroup::callable);\n+    }\n+\n+    private static boolean defaultFilter(Method m) {\n+        if (Modifier.isStatic(m.getModifiers()) || (m.getParameterCount() > 0) || void.class.equals(m.getReturnType())) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static <T, K, U>\n+    Collector<T, ?, Map<K,U>> toMutableMap(Function<? super T, ? extends K> keyMapper,\n+            Function<? super T, ? extends U> valueMapper) {\n+        return Collectors.toMap(keyMapper, valueMapper, (x , y) -> {\n+            throw new UnsupportedOperationException(\n+                    String.format(\"Enries with the same key and different values [%s] and [%s]\", x, y));\n+        }, HashMap::new);\n+    }\n+\n+    public static final class Builder {\n+\n+        private Builder() {\n+            allowAllClasses();\n+            allowAllLeafClasses();\n+            allowAllMethods();\n+        }\n+\n+        public ObjectMapper create() {\n+            return new ObjectMapper(\n+                    classFilter.createPredicate(),\n+                    methodFilter.createMultiPredicate(),\n+                    leafClassFilter.createPredicate(),\n+                    Map.copyOf(substitutes),\n+                    Map.copyOf(mutators),\n+                    accessPackageMethods);\n+        }\n+\n+\n+        public final class NamePredicateBuilder {\n+\n+            NamePredicateBuilder(Filter sink) {\n+                this.sink = Objects.requireNonNull(sink);\n+            }\n+\n+            public Builder apply() {\n+                sink.addAll(items);\n+                return Builder.this;\n+            }\n+\n+            public NamePredicateBuilder add(String... v) {\n+                return add(List.of(v));\n+            }\n+\n+            public NamePredicateBuilder add(Collection<String> v) {\n+                items.addAll(v);\n+                return this;\n+            }\n+\n+            private final Filter sink;\n+            private final Set<String> items = new HashSet<>();\n+        }\n+\n+\n+        public final class AllMethodPredicateBuilder {\n+\n+            AllMethodPredicateBuilder(Class<?> type) {\n+                impl = new MethodPredicateBuilder(type, false);\n+            }\n+\n+            public AllMethodPredicateBuilder remove(String... v) {\n+                return remove(List.of(v));\n+            }\n+\n+            public AllMethodPredicateBuilder remove(Collection<String> v) {\n+                impl.add(v);\n+                return this;\n+            }\n+\n+            public Builder apply() {\n+                return impl.apply();\n+            }\n+\n+            private final MethodPredicateBuilder impl;\n+        }\n+\n+\n+        public final class SomeMethodPredicateBuilder {\n+\n+            SomeMethodPredicateBuilder(Class<?> type) {\n+                impl = new MethodPredicateBuilder(type, true);\n+            }\n+\n+            public SomeMethodPredicateBuilder add(String... v) {\n+                return add(List.of(v));\n+            }\n+\n+            public SomeMethodPredicateBuilder add(Collection<String> v) {\n+                impl.add(v);\n+                return this;\n+            }\n+\n+            public Builder apply() {\n+                return impl.apply();\n+            }\n+\n+            private final MethodPredicateBuilder impl;\n+        }\n+\n+\n+        public Builder allowAllClasses(boolean v) {\n+            classFilter.negate(v);\n+            return this;\n+        }\n+\n+        public Builder allowAllClasses() {\n+            return allowAllClasses(true);\n+        }\n+\n+        public Builder allowAllMethods(boolean v) {\n+            methodFilter.negate(v);\n+            return this;\n+        }\n+\n+        public Builder allowAllMethods() {\n+            return allowAllMethods(true);\n+        }\n+\n+        public Builder allowAllLeafClasses(boolean v) {\n+            leafClassFilter.negate(v);\n+            return this;\n+        }\n+\n+        public Builder allowAllLeafClasses() {\n+            return allowAllLeafClasses(true);\n+        }\n+\n+        public NamePredicateBuilder exceptClasses() {\n+            return new NamePredicateBuilder(classFilter);\n+        }\n+\n+        public AllMethodPredicateBuilder exceptAllMethods(Class<?> type) {\n+            return new AllMethodPredicateBuilder(type);\n+        }\n+\n+        public SomeMethodPredicateBuilder exceptSomeMethods(Class<?> type) {\n+            return new SomeMethodPredicateBuilder(type);\n+        }\n+\n+        public NamePredicateBuilder exceptMethods() {\n+            return new NamePredicateBuilder(methodFilter);\n+        }\n+\n+        public NamePredicateBuilder exceptLeafClasses() {\n+            return new NamePredicateBuilder(leafClassFilter);\n+        }\n+\n+        public Builder subst(Method target, Function<?, Object> substitute) {\n+            substitutes.put(Objects.requireNonNull(target), Objects.requireNonNull(substitute));\n+            return this;\n+        }\n+\n+        public <T> Builder subst(Class<? extends T> targetClass, String targetMethodName, Function<T, Object> substitute) {\n+            var method = toSupplier(() -> targetClass.getMethod(targetMethodName)).get();\n+            return subst(method, substitute);\n+        }\n+\n+        public Builder mutator(Class<?> targetClass, BiConsumer<Object, Map<String, Object>> mutator) {\n+            mutators.put(Objects.requireNonNull(targetClass), Objects.requireNonNull(mutator));\n+            return this;\n+        }\n+\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        public Builder accessPackageMethods(Package... packages) {\n+            Stream.of(packages).map(Package::getName).forEach(accessPackageMethods::add);\n+            return this;\n+        }\n+\n+\n+        private final class MethodPredicateBuilder {\n+\n+            MethodPredicateBuilder(Class<?> type, boolean negate) {\n+                this.type = Objects.requireNonNull(type);\n+                buffer.negate(negate);\n+            }\n+\n+            void add(Collection<String> v) {\n+                buffer.addAll(v);\n+            }\n+\n+            Builder apply() {\n+                var pred = buffer.createPredicate();\n+\n+                var items = MethodGroups.create(type, accessPackageMethods).groups().stream().map(MethodGroup::primary).filter(m -> {\n+                    return !OBJECT_METHODS.contains(ObjectMapper.lookupMethodName(m));\n+                }).filter(m -> {\n+                    return !pred.test(m.getName());\n+                }).map(ObjectMapper::lookupFullMethodName).toList();\n+\n+                return exceptMethods().add(items).apply();\n+            }\n+\n+            private final Class<?> type;\n+            private final Filter buffer = new Filter();\n+        }\n+\n+\n+        private static final class Filter {\n+            Predicate<List<String>> createMultiPredicate() {\n+                if (items.isEmpty()) {\n+                    var match = negate;\n+                    return v -> match;\n+                } else if (negate) {\n+                    return v -> {\n+                        return v.stream().noneMatch(Set.copyOf(items)::contains);\n+                    };\n+                } else {\n+                    return v -> {\n+                        return v.stream().anyMatch(Set.copyOf(items)::contains);\n+                    };\n+                }\n+            }\n+\n+            Predicate<String> createPredicate() {\n+                if (items.isEmpty()) {\n+                    var match = negate;\n+                    return v -> match;\n+                } else if (negate) {\n+                    return Predicate.not(Set.copyOf(items)::contains);\n+                } else {\n+                    return Set.copyOf(items)::contains;\n+                }\n+            }\n+\n+            void addAll(Collection<String> v) {\n+                items.addAll(v);\n+            }\n+\n+            void negate(boolean v) {\n+                negate = v;\n+            }\n+\n+            private boolean negate;\n+            private final Set<String> items = new HashSet<>();\n+        }\n+\n+\n+        private final Filter classFilter = new Filter();\n+        private final Filter methodFilter = new Filter();\n+        private final Filter leafClassFilter = new Filter();\n+        private final Map<Method, Function<?, Object>> substitutes = new HashMap<>();\n+        private final Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators = new HashMap<>();\n+        private final Set<String> accessPackageMethods = new HashSet<>();\n+    }\n+\n+\n+    private record MethodGroup(List<Method> methods) {\n+\n+        MethodGroup {\n+            Objects.requireNonNull(methods);\n+\n+            if (methods.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            methods.stream().map(Method::getName).reduce((a, b) -> {\n+                if (!a.equals(b)) {\n+                    throw new IllegalArgumentException();\n+                } else {\n+                    return a;\n+                }\n+            });\n+        }\n+\n+        Method callable() {\n+            var primary = primary();\n+            if (!primary.getDeclaringClass().isInterface()) {\n+                primary = methods.stream().filter(m -> {\n+                    return m.getDeclaringClass().isInterface();\n+                }).findFirst().orElse(primary);\n+            }\n+            return primary;\n+        }\n+\n+        Method primary() {\n+            return methods.getFirst();\n+        }\n+\n+        boolean match(Predicate<Method> predicate) {\n+            Objects.requireNonNull(predicate);\n+            return methods.stream().allMatch(predicate);\n+        }\n+    }\n+\n+\n+    private record MethodGroups(Collection<MethodGroup> groups) {\n+\n+        MethodGroups {\n+            Objects.requireNonNull(groups);\n+        }\n+\n+        Stream<MethodGroup> filter(Predicate<Method> predicate) {\n+            Objects.requireNonNull(predicate);\n+\n+            return groups.stream().filter(g -> {\n+                return g.match(predicate);\n+            });\n+        }\n+\n+        static MethodGroups create(Class<?> type, Set<String> accessPackageMethods) {\n+            List<Class<?>> types = new ArrayList<>();\n+\n+            collectSuperclassAndInterfaces(type, types::add);\n+\n+            final var methodGroups = types.stream()\n+                    .map(c -> {\n+                        if (accessPackageMethods.contains(c.getPackageName())) {\n+                            return PUBLIC_AND_PACKAGE_METHODS_GETTER.apply(c);\n+                        } else {\n+                            return PUBLIC_METHODS_GETTER.apply(c);\n+                        }\n+                    })\n+                    .flatMap(x -> x)\n+                    .filter(ObjectMapper::defaultFilter)\n+                    .collect(groupingBy(Method::getName));\n+\n+            return new MethodGroups(methodGroups.values().stream().distinct().map(MethodGroup::new).toList());\n+        }\n+\n+        private static void collectSuperclassAndInterfaces(Class<?> type, Consumer<Class<?>> sink) {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(sink);\n+\n+            for (; type != null; type = type.getSuperclass()) {\n+                sink.accept(type);\n+                for (var i : type.getInterfaces()) {\n+                    collectSuperclassAndInterfaces(i, sink);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private static final class XmlWriter {\n+        static void write(Object obj,  XMLStreamWriter xml) {\n+            if (obj instanceof Map<?, ?> map) {\n+                writePropertyMap(map, xml);\n+            } else if (obj instanceof Collection<?> col) {\n+                writeCollection(col, xml);\n+            } else if (obj.getClass().isArray()) {\n+                writeArray(obj, xml);\n+            } else {\n+                toRunnable(() -> xml.writeCharacters(obj.toString())).run();\n+            }\n+        }\n+\n+        private static void writePropertyMap(Map<?, ?> map, XMLStreamWriter xml) {\n+            map.entrySet().stream().sorted(Comparator.comparing(e -> e.getKey().toString())).forEach(toConsumer(e -> {\n+                xml.writeStartElement(\"property\");\n+                xml.writeAttribute(\"name\", e.getKey().toString());\n+                write(e.getValue(), xml);\n+                xml.writeEndElement();\n+            }));\n+        }\n+\n+        private static void writeCollection(Collection<?> col, XMLStreamWriter xml) {\n+            try {\n+                xml.writeStartElement(\"collection\");\n+                xml.writeAttribute(\"size\", Integer.toString(col.size()));\n+                for (var item : col) {\n+                    xml.writeStartElement(\"item\");\n+                    write(item, xml);\n+                    xml.writeEndElement();\n+                }\n+                xml.writeEndElement();\n+            } catch (Exception ex) {\n+                rethrowUnchecked(ex);\n+            }\n+        }\n+\n+        private static void writeArray(Object arr, XMLStreamWriter xml) {\n+            var len = Array.getLength(arr);\n+            try {\n+                xml.writeStartElement(\"array\");\n+                xml.writeAttribute(\"size\", Integer.toString(len));\n+                for (int i = 0; i != len; i++) {\n+                    xml.writeStartElement(\"item\");\n+                    write(Array.get(arr, i), xml);\n+                    xml.writeEndElement();\n+                }\n+                xml.writeEndElement();\n+            } catch (Exception ex) {\n+                rethrowUnchecked(ex);\n+            }\n+        }\n+    }\n+\n+\n+    private final Predicate<String> classFilter;\n+    private final Predicate<List<String>> methodFilter;\n+    private final Predicate<String> leafClassFilter;\n+    private final Map<Method, Function<?, Object>> substitutes;\n+    private final Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators;\n+    private final Set<String> accessPackageMethods;\n+\n+    static final Object NULL = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"<null>\";\n+        }\n+    };\n+\n+    private static final Set<String> OBJECT_METHODS =\n+            Stream.of(Object.class.getMethods()).map(ObjectMapper::lookupMethodName).collect(toSet());\n+\n+    private static final Function<Class<?>, Stream<Method>> PUBLIC_METHODS_GETTER = type -> {\n+        return Stream.of(type.getMethods());\n+    };\n+\n+    private static final Function<Class<?>, Stream<Method>> PUBLIC_AND_PACKAGE_METHODS_GETTER = type -> {\n+        return Stream.of(type.getDeclaredMethods()).filter(m -> {\n+            return Stream.<IntPredicate>of(Modifier::isPrivate, Modifier::isProtected).map(p -> {\n+                return p.test(m.getModifiers());\n+            }).allMatch(v -> !v);\n+        }).map(m -> {\n+            m.setAccessible(true);\n+            return m;\n+        });\n+    };\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ObjectMapper.java","additions":780,"deletions":0,"binary":false,"changes":780,"status":"added"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Collections;\n@@ -321,0 +320,5 @@\n+    public PackageTest mutate(Consumer<PackageTest> mutator) {\n+        mutator.accept(this);\n+        return this;\n+    }\n+\n@@ -337,1 +341,5 @@\n-        return forTypes(List.of(type), () -> action.accept(this));\n+        return forTypes(List.of(type), action);\n+    }\n+\n+    public PackageTest forTypes(Collection<PackageType> types, Consumer<PackageTest> action) {\n+        return forTypes(types, () -> action.accept(this));\n@@ -351,1 +359,5 @@\n-        return notForTypes(List.of(type), () -> action.accept(this));\n+        return notForTypes(List.of(type), action);\n+    }\n+\n+    public PackageTest notForTypes(Collection<PackageType> types, Consumer<PackageTest> action) {\n+        return notForTypes(types, () -> action.accept(this));\n@@ -783,1 +795,1 @@\n-            cmd.assertAppLayout();\n+            cmd.runStandardAsserts();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1263,2 +1263,2 @@\n-        public static void assertEquals(PathSnapshot a, PathSnapshot b, String msg) {\n-            assertStringListEquals(a.contentHashes(), b.contentHashes(), msg);\n+        public void assertEquals(PathSnapshot other, String msg) {\n+            assertStringListEquals(contentHashes(), other.contentHashes(), msg);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class IdentityWrapperTest {\n+\n+    @Test\n+    public void test_null() {\n+        assertThrows(NullPointerException.class, () -> identityOf(null));\n+    }\n+\n+    @Test\n+    public void test_equals() {\n+        var obj = new TestRecord(10);\n+        assertEquals(identityOf(obj), identityOf(obj));\n+    }\n+\n+    @Test\n+    public void test_not_equals() {\n+        var identity = identityOf(new TestRecord(10));\n+        var identity2 = identityOf(new TestRecord(10));\n+        assertNotEquals(identity, identity2);\n+        assertEquals(identity.value(), identity2.value());\n+    }\n+\n+    @Test\n+    public void test_Foo() {\n+        var foo = new Foo(10);\n+        assertFalse(foo.accessed());\n+\n+        foo.hashCode();\n+        assertTrue(foo.accessed());\n+        assertTrue(foo.hashCodeCalled());\n+        assertFalse(foo.equalsCalled());\n+\n+        foo = new Foo(1);\n+        foo.equals(null);\n+        assertTrue(foo.accessed());\n+        assertFalse(foo.hashCodeCalled());\n+        assertTrue(foo.equalsCalled());\n+    }\n+\n+    @Test\n+    public void test_wrappedValue_not_accessed() {\n+        var identity = identityOf(new Foo(10));\n+        var identity2 = identityOf(new Foo(10));\n+        assertNotEquals(identity, identity2);\n+\n+        assertFalse(identity.value().accessed());\n+        assertFalse(identity2.value().accessed());\n+\n+        assertEquals(identity.value(), identity2.value());\n+        assertEquals(identity2.value(), identity.value());\n+\n+        assertTrue(identity.value().accessed());\n+        assertTrue(identity2.value().accessed());\n+    }\n+\n+    @Test\n+    public void test_wrappedValue_not_accessed_in_set() {\n+        var identitySet = Set.of(identityOf(new Foo(10)), identityOf(new Foo(10)), identityOf(new Foo(10)));\n+        assertEquals(3, identitySet.size());\n+\n+        var valueSet = identitySet.stream().peek(identity -> {\n+            assertFalse(identity.value().accessed());\n+        }).map(IdentityWrapper::value).collect(Collectors.toSet());\n+\n+        assertEquals(1, valueSet.size());\n+    }\n+\n+    private static <T> IdentityWrapper<T> identityOf(T obj) {\n+        return new IdentityWrapper<>(obj);\n+    }\n+\n+    private record TestRecord(int v) {}\n+\n+    private final static class Foo {\n+\n+        Foo(int v) {\n+            this.v = v;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            try {\n+                return Objects.hash(v);\n+            } finally {\n+                hashCodeCalled = true;\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            try {\n+                if (this == obj)\n+                    return true;\n+                if (obj == null)\n+                    return false;\n+                if (getClass() != obj.getClass())\n+                    return false;\n+                Foo other = (Foo) obj;\n+                return v == other.v;\n+            } finally {\n+                equalsCalled = true;\n+            }\n+        }\n+\n+        boolean equalsCalled() {\n+            return equalsCalled;\n+        }\n+\n+        boolean hashCodeCalled() {\n+            return hashCodeCalled;\n+        }\n+\n+        boolean accessed() {\n+            return equalsCalled() || hashCodeCalled();\n+        }\n+\n+        private final int v;\n+        private boolean equalsCalled;\n+        private boolean hashCodeCalled;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/IdentityWrapperTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import org.junit.jupiter.api.Assertions;\n+\n+\n+public final class JUnitUtils {\n+\n+    \/**\n+     * Convenience adapter for {@link Assertions#assertArrayEquals(byte[], byte[])},\n+     * {@link Assertions#assertArrayEquals(int[], int[])},\n+     * {@link Assertions#assertArrayEquals(Object[], Object[])}, etc. methods.\n+     *\n+     * @param expected the expected array to test for equality\n+     * @param actual   the actual array to test for equality\n+     *\/\n+    public static void assertArrayEquals(Object expected, Object actual) {\n+        ARRAY_ASSERTERS.getOrDefault(expected.getClass().componentType(), OBJECT_ARRAY_ASSERTER).acceptUnchecked(expected, actual);\n+    }\n+\n+    \/**\n+     * Converts the given exception object to a property map.\n+     * <p>\n+     * Values returned by public getters are added to the map. Names of getters are\n+     * the keys in the returned map. The values are property map representations of\n+     * the objects returned by the getters. Only {@link Throwable#getMessage()} and\n+     * {@link Throwable#getCause()} getters are picked for the property map by\n+     * default. If the exception class has additional getters, they will be added to\n+     * the map. {@code null} is permitted.\n+     *\n+     * @param ex the exception to convert into a property map\n+     * @return the property map view of the given exception object\n+     *\/\n+    public static Map<String, Object> exceptionAsPropertyMap(Exception ex) {\n+        return EXCEPTION_OM.toMap(ex);\n+    }\n+\n+\n+    public static final class ExceptionPattern {\n+\n+        public ExceptionPattern() {\n+        }\n+\n+        public boolean match(Exception ex) {\n+            Objects.requireNonNull(ex);\n+\n+            if (expectedType != null && !expectedType.isInstance(ex)) {\n+                return false;\n+            }\n+\n+            if (expectedMessage != null && !expectedMessage.equals(ex.getMessage())) {\n+                return false;\n+            }\n+\n+            if (expectedCauseType != null && !expectedCauseType.isInstance(ex.getCause())) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        public ExceptionPattern hasMessage(String v) {\n+            expectedMessage = v;\n+            return this;\n+        }\n+\n+        public ExceptionPattern isInstanceOf(Class<? extends Exception> v) {\n+            expectedType = v;\n+            return this;\n+        }\n+\n+        public ExceptionPattern isCauseInstanceOf(Class<? extends Throwable> v) {\n+            expectedCauseType = v;\n+            return this;\n+        }\n+\n+        public ExceptionPattern hasCause(boolean v) {\n+            return isCauseInstanceOf(v ? Exception.class : null);\n+        }\n+\n+        public ExceptionPattern hasCause() {\n+            return hasCause(true);\n+        }\n+\n+        private String expectedMessage;\n+        private Class<? extends Exception> expectedType;\n+        private Class<? extends Throwable> expectedCauseType;\n+    }\n+\n+\n+    @FunctionalInterface\n+    private interface ArrayEqualsAsserter<T> {\n+        void accept(T expected, T actual);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        default void acceptUnchecked(Object expected, Object actual) {\n+            accept((T)expected, (T)actual);\n+        }\n+    }\n+\n+\n+    private static final Map<Class<?>, ArrayEqualsAsserter<?>> ARRAY_ASSERTERS = Map.of(\n+            boolean.class, (ArrayEqualsAsserter<boolean[]>)Assertions::assertArrayEquals,\n+            byte.class, (ArrayEqualsAsserter<byte[]>)Assertions::assertArrayEquals,\n+            char.class, (ArrayEqualsAsserter<char[]>)Assertions::assertArrayEquals,\n+            double.class, (ArrayEqualsAsserter<double[]>)Assertions::assertArrayEquals,\n+            float.class, (ArrayEqualsAsserter<float[]>)Assertions::assertArrayEquals,\n+            int.class, (ArrayEqualsAsserter<int[]>)Assertions::assertArrayEquals,\n+            long.class, (ArrayEqualsAsserter<long[]>)Assertions::assertArrayEquals,\n+            short.class, (ArrayEqualsAsserter<short[]>)Assertions::assertArrayEquals\n+    );\n+\n+    private static final ArrayEqualsAsserter<Object[]> OBJECT_ARRAY_ASSERTER = Assertions::assertArrayEquals;\n+\n+    private static final ObjectMapper EXCEPTION_OM = ObjectMapper.standard().create();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitUtils.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -167,1 +167,1 @@\n-                            \"Comment=\",\n+                            \"Comment=APPLICATION_DESCRIPTION\",\n","filename":"test\/jdk\/tools\/jpackage\/linux\/ShortcutHintTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,0 +121,6 @@\n+        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n+            \/\/ Ensure launchers are executable because the output bundle will be installed\n+            \/\/ and launchers will be attempted to be executed through their shortcuts.\n+            packageTest.addInitializer(JPackageCommand::ignoreFakeRuntime);\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import java.nio.file.Path;\n-import java.util.Map;\n@@ -27,2 +25,3 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.FileAssociations;\n+import java.nio.file.Path;\n+import java.util.function.Consumer;\n+import jdk.internal.util.OperatingSystem;\n@@ -30,0 +29,5 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.CfgFile;\n+import jdk.jpackage.test.ConfigurationTarget;\n+import jdk.jpackage.test.FileAssociations;\n@@ -32,0 +36,3 @@\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n@@ -33,3 +40,0 @@\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.CfgFile;\n@@ -236,0 +240,55 @@\n+    \/**\n+     * Test --description option\n+     *\/\n+    @Test(ifNotOS = OperatingSystem.MACOS) \/\/ Don't run on macOS as launcher description is ignored on this platform\n+    @Parameter(\"true\")\n+    @Parameter(\"fase\")\n+    public void testDescription(boolean withPredefinedAppImage) {\n+\n+        ConfigurationTarget target;\n+        if (TKit.isWindows() || withPredefinedAppImage) {\n+            target = new ConfigurationTarget(JPackageCommand.helloAppImage());\n+        } else {\n+            target = new ConfigurationTarget(new PackageTest().configureHelloApp());\n+        }\n+\n+        target.addInitializer(cmd -> {\n+            cmd.setArgumentValue(\"--name\", \"Foo\").setArgumentValue(\"--description\", \"Hello\");\n+            cmd.setFakeRuntime();\n+            cmd.setStandardAsserts(JPackageCommand.StandardAssert.MAIN_LAUNCHER_DESCRIPTION);\n+        });\n+\n+        target.add(new AdditionalLauncher(\"x\"));\n+        target.add(new AdditionalLauncher(\"bye\").setProperty(\"description\", \"Bye\"));\n+\n+        target.test().ifPresent(test -> {\n+            \/\/ Make all launchers have shortcuts and thus .desktop files.\n+            \/\/ Launcher description is recorded in a desktop file and verified automatically.\n+            test.mutate(addLinuxShortcuts());\n+        });\n+\n+        target.cmd().ifPresent(withPredefinedAppImage ? JPackageCommand::execute : JPackageCommand::executeAndAssertImageCreated);\n+        target.test().ifPresent(test -> {\n+            test.run(Action.CREATE_AND_UNPACK);\n+        });\n+\n+        if (withPredefinedAppImage) {\n+            new PackageTest().addInitializer(cmd -> {\n+                cmd.setArgumentValue(\"--name\", \"Bar\");\n+                \/\/ Should not have impact of launcher descriptions, but it does.\n+                cmd.setArgumentValue(\"--description\", \"Installer\");\n+                cmd.removeArgumentWithValue(\"--input\").setArgumentValue(\"--app-image\", target.cmd().orElseThrow().outputBundle());\n+            }).mutate(addLinuxShortcuts()).run(Action.CREATE_AND_UNPACK);\n+        }\n+    }\n+\n+    private static Consumer<PackageTest> addLinuxShortcuts() {\n+        return test -> {\n+            test.forTypes(PackageType.LINUX, () -> {\n+                test.addInitializer(cmd -> {\n+                    cmd.addArgument(\"--linux-shortcut\");\n+                });\n+            });\n+        };\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":66,"deletions":7,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import java.nio.file.Path;\n-import java.nio.file.Files;\n@@ -27,1 +25,3 @@\n-import java.util.List;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n@@ -29,1 +29,0 @@\n-import jdk.jpackage.test.AppImageFile;\n@@ -31,0 +30,2 @@\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.AppImageFile;\n@@ -32,1 +33,0 @@\n-import jdk.jpackage.test.TKit;\n@@ -34,0 +34,1 @@\n+import jdk.jpackage.test.JPackageCommand.StandardAssert;\n@@ -37,1 +38,1 @@\n-import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.TKit;\n@@ -58,0 +59,3 @@\n+    \/**\n+     * Create a native bundle from a valid predefined app image produced by jpackage.\n+     *\/\n@@ -60,1 +64,0 @@\n-        Path appimageOutput = TKit.workDir().resolve(\"appimage\");\n@@ -62,2 +65,2 @@\n-        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", appimageOutput);\n+        var appImageCmd = JPackageCommand.helloAppImage()\n+                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n@@ -66,1 +69,1 @@\n-        .addRunOnceInitializer(() -> appImageCmd.execute())\n+        .addRunOnceInitializer(appImageCmd::execute)\n@@ -73,0 +76,7 @@\n+    \/**\n+     * Create a native bundle from a predefined app image not produced by jpackage\n+     * but having a valid \".jpackage.xml\" file.\n+     *\n+     * @param withIcon {@code true} if jpackage command line should have \"--icon\"\n+     *                 option\n+     *\/\n@@ -77,3 +87,0 @@\n-        final String name = \"EmptyAppImagePackageTest\";\n-        final String imageName = name + (TKit.isOSX() ? \".app\" : \"\");\n-        Path appImageDir = TKit.createTempDirectory(\"appimage\").resolve(imageName);\n@@ -81,4 +88,4 @@\n-        Files.createDirectories(appImageDir.resolve(\"bin\"));\n-        Path libDir = Files.createDirectories(appImageDir.resolve(\"lib\"));\n-        TKit.createTextFile(libDir.resolve(\"README\"),\n-                List.of(\"This is some arbitrary text for the README file\\n\"));\n+        var appImageCmd = JPackageCommand.helloAppImage()\n+                .setFakeRuntime()\n+                .setArgumentValue(\"--name\", \"EmptyAppImagePackageTest\")\n+                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n@@ -87,0 +94,25 @@\n+        .addRunOnceInitializer(appImageCmd::execute)\n+        .addRunOnceInitializer(() -> {\n+            var layout = appImageCmd.appLayout();\n+            if (!TKit.isOSX()) {\n+                \/\/ Delete the launcher if not on macOS.\n+                \/\/ On macOS, deleting the launcher will render the app bundle invalid.\n+                TKit.deleteIfExists(appImageCmd.appLauncherPath());\n+            }\n+            \/\/ Delete the runtime.\n+            TKit.deleteDirectoryRecursive(layout.runtimeDirectory());\n+            \/\/ Delete the \"app\" dir.\n+            TKit.deleteDirectoryRecursive(layout.appDirectory());\n+\n+            new AppImageFile(appImageCmd.name(), \"PhonyMainClass\").save(appImageCmd.outputBundle());\n+            var appImageDir = appImageCmd.outputBundle();\n+\n+            TKit.trace(String.format(\"Files in [%s] app image:\", appImageDir));\n+            try (var files = Files.walk(appImageDir)) {\n+                files.sequential()\n+                        .filter(Predicate.isEqual(appImageDir).negate())\n+                        .map(path -> String.format(\"[%s]\", appImageDir.relativize(path)))\n+                        .forEachOrdered(TKit::trace);\n+                TKit.trace(\"Done\");\n+            }\n+        })\n@@ -88,1 +120,1 @@\n-            cmd.addArguments(\"--app-image\", appImageDir);\n+            cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n@@ -93,1 +125,0 @@\n-            new AppImageFile(\"EmptyAppImagePackageTest\", \"Hello\").save(appImageDir);\n@@ -95,5 +126,5 @@\n-            \/\/ on mac, with --app-image and without --mac-package-identifier,\n-            \/\/ will try to infer it from the image, so foreign image needs it.\n-            if (TKit.isOSX()) {\n-                cmd.addArguments(\"--mac-package-identifier\", name);\n-            }\n+            cmd.excludeStandardAsserts(\n+                    StandardAssert.MAIN_JAR_FILE,\n+                    StandardAssert.MAIN_LAUNCHER_FILES,\n+                    StandardAssert.MAC_BUNDLE_STRUCTURE,\n+                    StandardAssert.RUNTIME_DIRECTORY);\n@@ -101,5 +132,1 @@\n-        \/\/ On macOS we always signing app image and signing will fail, since\n-        \/\/ test produces invalid app bundle.\n-        .setExpectedExitCode(TKit.isOSX() ? 1 : 0)\n-        .run(Action.CREATE, Action.UNPACK);\n-        \/\/ default: {CREATE, UNPACK, VERIFY}, but we can't verify foreign image\n+        .run(Action.CREATE_AND_UNPACK);\n@@ -108,0 +135,4 @@\n+    \/**\n+     * Bad predefined app image - not an output of jpackage.\n+     * jpackage command using the bad predefined app image doesn't have \"--name\" option.\n+     *\/\n@@ -117,0 +148,3 @@\n+    \/**\n+     * Bad predefined app image - not an output of jpackage.\n+     *\/\n@@ -124,0 +158,3 @@\n+    \/**\n+     * Bad predefined app image - valid app image missing \".jpackage.xml\" file.\n+     *\/\n@@ -125,1 +162,1 @@\n-    public static void testBadAppImage3() throws IOException {\n+    public static void testBadAppImage3() {\n@@ -137,0 +174,3 @@\n+    \/**\n+     * Bad predefined app image - valid app image with invalid \".jpackage.xml\" file.\n+     *\/\n@@ -138,1 +178,1 @@\n-    public static void testBadAppImageFile() throws IOException {\n+    public static void testBadAppImageFile() {\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":71,"deletions":31,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.jpackage.test.JPackageCommand.AppLayoutAssert;\n+import jdk.jpackage.test.JPackageCommand.StandardAssert;\n@@ -180,1 +180,1 @@\n-                cmd.excludeAppLayoutAsserts(AppLayoutAssert.APP_IMAGE_FILE);\n+                cmd.excludeStandardAsserts(StandardAssert.APP_IMAGE_FILE);\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-                expectedLicensePath)).findFirst().orElse(null) != null,\n+                expectedLicensePath)).findFirst().isPresent(),\n","filename":"test\/jdk\/tools\/jpackage\/share\/LicenseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,5 +138,1 @@\n-            Path dest = cmd.appRuntimeDirectory();\n-            if (TKit.isOSX()) {\n-                dest = dest.resolve(\"Contents\/Home\");\n-            }\n-\n+            var dest = cmd.appLayout().runtimeHomeDirectory();\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimePackageTest.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}