{"files":[{"patch":"@@ -1843,0 +1843,2 @@\n+     * @see {@link Long#divideUnsigned(long, long)}\n+     * @see {@link Long#remainderUnsigned(long, long)}\n@@ -1845,23 +1847,18 @@\n-        long dLong = d & LONG_MASK;\n-        long r;\n-        long q;\n-        if (dLong == 1) {\n-            q = (int)n;\n-            r = 0;\n-            return (r << 32) | (q & LONG_MASK);\n-        }\n-\n-        \/\/ Approximate the quotient and remainder\n-        q = (n >>> 1) \/ (dLong >>> 1);\n-        r = n - q*dLong;\n-\n-        \/\/ Correct the approximation\n-        while (r < 0) {\n-            r += dLong;\n-            q--;\n-        }\n-        while (r >= dLong) {\n-            r -= dLong;\n-            q++;\n-        }\n-        \/\/ n - q*dlong == r && 0 <= r <dLong, hence we're done.\n+        \/* See Hacker's Delight (2nd ed), section 9.3 *\/\n+        final long dLong = d & LONG_MASK;\n+        final long q0 = (n >>> 1) \/ dLong << 1;\n+        final long r0 = n - q0 * dLong;\n+        \/*\n+         * Here, 0 <= r0 < 2 * dLong\n+         * (1) When 0 <= r0 < dLong, the remainder is simply r0.\n+         * (2) Otherwise the remainder is r0 - dLong.\n+         *\n+         * In case (1), r0 - dLong < 0. Applying ~ produces a long with\n+         * sign bit 0, so >> produces 0. The remainder is thus r0.\n+         *\n+         * In case (2), a similar reasoning shows that >> produces -1,\n+         * so the remainder is r0 - dLong.\n+         *\/\n+        long correction = ~(r0 - dLong);\n+        long q = q0 + ((r0 | correction) >>> 63);\n+        long r = r0 - ((correction >> 63) & dLong);\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"}]}