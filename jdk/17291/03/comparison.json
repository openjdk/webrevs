{"files":[{"patch":"@@ -1843,0 +1843,2 @@\n+     * @see {@link Long#divideUnsigned(long, long)}\n+     * @see {@link Long#remainderUnsigned(long, long)}\n@@ -1845,23 +1847,18 @@\n-        long dLong = d & LONG_MASK;\n-        long r;\n-        long q;\n-        if (dLong == 1) {\n-            q = (int)n;\n-            r = 0;\n-            return (r << 32) | (q & LONG_MASK);\n-        }\n-\n-        \/\/ Approximate the quotient and remainder\n-        q = (n >>> 1) \/ (dLong >>> 1);\n-        r = n - q*dLong;\n-\n-        \/\/ Correct the approximation\n-        while (r < 0) {\n-            r += dLong;\n-            q--;\n-        }\n-        while (r >= dLong) {\n-            r -= dLong;\n-            q++;\n-        }\n-        \/\/ n - q*dlong == r && 0 <= r <dLong, hence we're done.\n+        \/* See Hacker's Delight (2nd ed), section 9.3 *\/\n+        final long dLong = d & LONG_MASK;\n+        final long q0 = (n >>> 1) \/ dLong << 1;\n+        final long r0 = n - q0 * dLong;\n+        \/*\n+         * Here, 0 <= r0 < 2 * dLong\n+         * (1) When 0 <= r0 < dLong, the remainder is simply r0.\n+         * (2) Otherwise the remainder is r0 - dLong.\n+         *\n+         * In case (1), r0 - dLong < 0. Applying ~ produces a long with\n+         * sign bit 0, so >> produces 0. The remainder is thus r0.\n+         *\n+         * In case (2), a similar reasoning shows that >> produces -1,\n+         * so the remainder is r0 - dLong.\n+         *\/\n+        long correction = ~(r0 - dLong);\n+        long q = q0 + ((r0 | correction) >>> 63);\n+        long r = r0 - ((correction >> 63) & dLong);\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+import java.math.Accessor;\n+import java.time.Duration;\n+import java.util.Random;\n+\n+public class TestDivWord {\n+\n+    private static void checkResult(long n, int d, long res) {\n+        final long LONG_MASK = 0xffffffffL;\n+        final long dLong = d & LONG_MASK;\n+        final long q = res & LONG_MASK, r = res >>> 32;\n+\n+        if (!(0 <= r && r < dLong && n == q * dLong + r))\n+            System.err.println(\"Incorrect result with n = \" + Long.toUnsignedString(n) + \", d = \" + dLong + \": q = \" + q + \", r = \" + r);\n+    }\n+\n+    private static void randomCaseTests() {\n+        final int MAX_DIVISIONS = 1 << 30;\n+        Random rnd = new Random();\n+\n+        for (int nDivs = 1; nDivs <= MAX_DIVISIONS; nDivs <<= 1) {\n+            Duration elapsed = Duration.ZERO;\n+\n+            for (int i = 0; i < nDivs; i++) {\n+                \/\/ divWord(n, d) is used when n < 0\n+                long n = rnd.nextLong() & (1L << 63);\n+                int d = rnd.nextInt();\n+                \/\/ Avoid d == 0\n+                if (d == 0)\n+                    d = 1;\n+\n+                long t0 = System.nanoTime();\n+                long res = Accessor.divWord(n, d);\n+                long t1 = System.nanoTime();\n+\n+                checkResult(n, d, res);\n+                elapsed = elapsed.plusNanos(t1 - t0);\n+            }\n+\n+            System.out.println(\"Time to do \" + nDivs + \" divisions: \" + elapsed);\n+            System.out.println(\"Average time for division: \" + elapsed.dividedBy(nDivs) + \"\\n\");\n+        }\n+    }\n+\n+    private static void oldImplementationWorstCaseTest() {\n+        long n = 0xfffffffffffffffeL;\n+        int d = 3;\n+        System.out.println(Long.toUnsignedString(n) + \" \/ \" + d + \" = \" + Long.divideUnsigned(n, d));\n+        long res = Accessor.divWord(n, d);\n+        checkResult(n, d, res);\n+    }\n+\n+    public static void main(String[] args) {\n+        randomCaseTests();\n+        \/\/oldImplementationWorstCaseTest();\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/TestDivWord.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -32,0 +32,4 @@\n+    public static long divWord(long n, int d) {\n+        return MutableBigInteger.divWord(n, d);\n+    }\n+\n","filename":"test\/jdk\/java\/math\/BigInteger\/java.base\/java\/math\/Accessor.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}