{"files":[{"patch":"@@ -371,0 +371,30 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+void TraceIdLoadBarrierStub::emit_code(LIR_Assembler* ce) {\n+  __ bind(_entry);\n+\n+  __ push(RegSet::range(r0, r29), sp);         \/\/ integer registers except lr & sp\n+\n+  for (int i = 31; i>= 0; i -= 4) {\n+    __ sub(sp, sp, 4 * wordSize); \/\/ no pre-increment for st1. Emulate it without modifying other registers\n+    __ st1(as_FloatRegister(i-3), as_FloatRegister(i-2), as_FloatRegister(i-1),\n+           as_FloatRegister(i), __ T1D, Address(sp));\n+  }\n+\n+\n+  __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::trace_id_load_barrier)));\n+  __ blr(rscratch1);\n+\n+  for (int i = 0; i < 32; i += 4) {\n+    __ ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n+           as_FloatRegister(i+3), __ T1D, Address(__ post(sp, 4 * wordSize)));\n+  }\n+\n+  __ pop(RegSet::range(r0, r29), sp);\n+\n+  ce->add_call_info_here(_info);\n+  ce->verify_oop_map(_info);\n+\n+  __ b(_continuation);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -552,0 +552,17 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+void TraceIdLoadBarrierStub::emit_code(LIR_Assembler* ce) {\n+  __ bind(_entry);\n+\n+  __ save_live_registers_no_oop_map(true);\n+\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::trace_id_load_barrier)));\n+\n+  __ restore_live_registers(true);\n+\n+  ce->add_call_info_here(_info);\n+  ce->verify_oop_map(_info);\n+\n+  __ jmp(_continuation);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -564,0 +564,20 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+class TraceIdLoadBarrierStub: public CodeStub {\n+ private:\n+  CodeEmitInfo* _info;\n+\n+ public:\n+  TraceIdLoadBarrierStub(CodeEmitInfo* info) : _info(info) {}\n+  virtual CodeEmitInfo* info() const             { return _info; }\n+  virtual void visit(LIR_OpVisitState* visitor) {\n+    visitor->do_slow_case(_info);\n+  }\n+\n+  virtual void emit_code(LIR_Assembler* e);\n+\n+#ifndef PRODUCT\n+  virtual void print_name(outputStream* out) const { out->print(\"TraceIdLoadBarrierStub\"); }\n+#endif \/\/ PRODUCT\n+};\n+#endif\n+\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-#if defined(_LP64) || !defined(TRACE_ID_SHIFT)\n+#if (defined AARCH64 || defined X86)\n@@ -229,1 +229,0 @@\n-    break;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,4 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#endif\n+\n@@ -3046,4 +3050,3 @@\n-  CodeEmitInfo* info = state_for(x);\n-  CodeEmitInfo* info2 = new CodeEmitInfo(info); \/\/ Clone for the second null check\n-\n-  assert(info != NULL, \"must have info\");\n+#if !(defined AARCH64 || defined X86)\n+  \/\/ TODO: arm, ppc, s390\n+#else\n@@ -3053,0 +3056,7 @@\n+\n+  LIR_Opr cls = arg.result();\n+  LIR_Opr result = new_register(T_LONG);\n+\n+  LabelObj* L_signal = new LabelObj();\n+  LabelObj* L_end = new LabelObj();\n+\n@@ -3054,2 +3064,16 @@\n-  __ move(new LIR_Address(arg.result(), java_lang_Class::klass_offset(), T_ADDRESS), klass, info);\n-  LIR_Opr id = new_register(T_LONG);\n+\n+  __ move(new LIR_Address(cls, java_lang_Class::klass_offset(), T_ADDRESS), klass);\n+\n+  LabelObj* klass_not_null = new LabelObj();\n+\n+  __ cmp(lir_cond_notEqual, klass, LIR_OprFact::metadataConst(0));\n+  __ branch(lir_cond_notEqual, klass_not_null->label());\n+\n+  LIR_Opr array_klass = new_register(T_METADATA);\n+  __ move(new LIR_Address(cls, java_lang_Class::array_klass_offset(), T_ADDRESS), array_klass);\n+\n+  LabelObj* L_void = new LabelObj();\n+  __ move(LIR_OprFact::longConst(LAST_TYPE_ID + 1), result);\n+  __ cmp(lir_cond_equal, array_klass, LIR_OprFact::metadataConst(0));\n+  __ branch(lir_cond_equal, L_signal->label());\n+\n@@ -3057,0 +3081,10 @@\n+  LIR_Address* prim_trace_id_addr = new LIR_Address(array_klass, in_bytes(offset), T_LONG);\n+  LIR_Opr prim_trace_id = new_register(T_LONG);\n+  __ move(prim_trace_id_addr, prim_trace_id);\n+  __ shift_right(prim_trace_id, TRACE_ID_SHIFT, prim_trace_id);\n+  __ add(prim_trace_id, LIR_OprFact::longConst(1), prim_trace_id);\n+  __ move(prim_trace_id, result);\n+  __ branch(lir_cond_always, L_signal->label());\n+\n+  __ branch_destination(klass_not_null->label());\n+  LIR_Opr trace_id_raw = new_register(T_LONG);\n@@ -3058,0 +3092,37 @@\n+  __ move(trace_id_addr, trace_id_raw);\n+\n+  LIR_Opr epoch = new_register(T_INT);\n+  LIR_Opr epoch_address = new_register(T_LONG);\n+  __ move(LIR_OprFact::intptrConst(JfrTraceIdEpoch::epoch_address()), epoch_address);\n+  __ move(new LIR_Address(epoch_address, (intx)0, T_INT), epoch);\n+  __ cmp(lir_cond_equal, epoch, LIR_OprFact::intConst(0));\n+  LIR_Opr this_epoch_bit = new_register(T_LONG);\n+  __ cmove(lir_cond_equal, LIR_OprFact::longConst(EPOCH_0_BIT),\n+           LIR_OprFact::longConst(EPOCH_1_BIT), this_epoch_bit, T_LONG);\n+  LIR_Opr mask = new_register(T_LONG);\n+  __ move(this_epoch_bit, mask);\n+  __ shift_left(mask, META_SHIFT, mask);\n+  __ logical_or(mask, this_epoch_bit, mask);\n+  LIR_Opr trace_id_raw_and_mask = new_register(T_LONG);\n+  __ move(trace_id_raw, trace_id_raw_and_mask);\n+  __ logical_and(trace_id_raw_and_mask, mask, trace_id_raw_and_mask);\n+\n+  __ move(trace_id_raw, result);\n+  __ shift_right(result, TRACE_ID_SHIFT, result);\n+  __ cmp(lir_cond_equal, this_epoch_bit, trace_id_raw_and_mask);\n+  __ branch(lir_cond_equal, L_end->label());\n+\n+#ifdef VM_LITTLE_ENDIAN\n+  LIR_Address* trace_id_low_addr = new LIR_Address(klass, in_bytes(offset), T_BYTE);\n+#else\n+  LIR_Address* trace_id_low_addr = new LIR_Address(klass, in_bytes(offset) + 7, T_BYTE);\n+#endif\n+  LIR_Opr current_value = new_register(T_INT);\n+  __ move(trace_id_low_addr, current_value);\n+  LIR_Opr epoch_i = new_register(T_INT);\n+  __ convert(Bytecodes::_l2i, this_epoch_bit, epoch_i);\n+  LIR_Opr new_value = new_register(T_INT);\n+  __ logical_or(current_value, epoch_i, current_value);\n+  __ move(current_value, new_value);\n+  __ move(new_value, trace_id_low_addr);\n+  __ membar_storestore();\n@@ -3059,3 +3130,4 @@\n-  __ move(trace_id_addr, id);\n-  __ logical_or(id, LIR_OprFact::longConst(0x01l), id);\n-  __ store(id, trace_id_addr);\n+  BasicTypeList signature;\n+  signature.append(T_METADATA); \/\/ Klass*\n+  LIR_OprList* args = new LIR_OprList();\n+  args->append(klass);\n@@ -3063,6 +3135,2 @@\n-#ifdef TRACE_ID_META_BITS\n-  __ logical_and(id, LIR_OprFact::longConst(~TRACE_ID_META_BITS), id);\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  __ unsigned_shift_right(id, TRACE_ID_SHIFT, id);\n-#endif\n+  \/\/ move the arguments into the correct location\n+  CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n@@ -3070,1 +3138,37 @@\n-  __ move(id, rlock_result(x));\n+  assert(cc->length() == args->length(), \"argument mismatch\");\n+  for (int i = 0; i < args->length(); i++) {\n+    LIR_Opr arg = args->at(i);\n+    LIR_Opr loc = cc->at(i);\n+    if (loc->is_register()) {\n+      __ move(arg, loc);\n+    } else {\n+      LIR_Address* addr = loc->as_address_ptr();\n+      if (addr->type() == T_LONG || addr->type() == T_DOUBLE) {\n+        __ unaligned_move(arg, addr);\n+      } else {\n+        __ move(arg, addr);\n+      }\n+    }\n+  }\n+\n+  CodeEmitInfo *info = state_for(x, x->state());\n+  CodeStub* stub = new TraceIdLoadBarrierStub(info);\n+  __ jump(stub);\n+  __ branch_destination(stub->continuation());\n+\n+  __ branch_destination(L_signal->label());\n+  LIR_Opr signal = new_register(T_INT);\n+  LIR_Opr signal_addr = new_register(T_LONG);\n+  __ move(LIR_OprFact::intptrConst(JfrTraceIdEpoch::signal_address()), signal_addr);\n+  __ move(new LIR_Address(signal_addr, (intx)0, T_BOOLEAN), signal);\n+  __ membar_acquire();\n+  __ cmp(lir_cond_equal, signal, 1);\n+  __ branch(lir_cond_equal, L_end->label());\n+  __ move(LIR_OprFact::intConst(1), signal);\n+  __ membar_storestore();\n+  __ move(signal, new LIR_Address(signal_addr, (intx)0, T_BOOLEAN));\n+\n+  __ branch_destination(L_end->label());\n+\n+  __ move(result, rlock_result(x));\n+#endif\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":120,"deletions":16,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+  case trace_id_load_barrier_id:\n@@ -338,0 +339,1 @@\n+  FUNCTION_CASE(entry, SharedRuntime::trace_id_load_barrier);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  stub(trace_id_load_barrier)        \\\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+      (char*)\"getClassId\", (char*)\"(Ljava\/lang\/Class;)J\", (void*)jfr_class_id,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-  static jlong epoch_address() {\n-    return (jlong)&_epoch_state;\n+  static address epoch_address() {\n+    return (address)&_epoch_state;\n@@ -117,0 +117,4 @@\n+\n+  static address signal_address() {\n+    return _tag_state.signaled_address();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  friend class SharedRuntime;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+\n+  address signaled_address() { return (address)&_signaled; }\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSignal.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -354,1 +354,2 @@\n-                     bool require_atomic_access) {\n+                     bool require_atomic_access,\n+                     MemNode::MemOrd mo) {\n@@ -362,1 +363,1 @@\n-    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, MemNode::unordered);\n+    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo);\n@@ -364,1 +365,1 @@\n-    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, MemNode::unordered);\n+    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-             bool require_atomic_access = false);\n+             bool require_atomic_access = false, MemNode::MemOrd mo = MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#endif\n+\n@@ -2753,5 +2757,17 @@\n-\/*\n-* oop -> myklass\n-* myklass->trace_id |= USED\n-* return myklass->trace_id & ~0x3\n-*\/\n+\/**\n+ * if oop->klass != null\n+ *   epoch = _epoch_state ? 2 : 1\n+ *   if oop->klass->trace_id & ((epoch << META_SHIFT) | epoch)) != epoch\n+ *     SET_USED_THIS_EPOCH\n+ *     enqueue klass\n+ *     if (!signaled) \/\/ JfrSignal::signal\n+ *       signaled = true\n+ *   id = oop->klass->trace_id >> TRACE_ID_SHIFT \/\/ normal class path\n+ * else\n+ *   if oop->array_klass != null\n+ *     id = (oop->array_klass->trace_id >> TRACE_ID_SHIFT) + 1 \/\/ primitive class path\n+ *   else\n+ *     id = LAST_TYPE_ID + 1 \/\/ void class path\n+ *   if (!signaled)\n+ *     signaled = true\n+ *\/\n@@ -2760,6 +2776,0 @@\n-  Node* kls = load_klass_from_mirror(cls, false, NULL, 0);\n-  kls = null_check(kls, T_OBJECT);\n-\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  Node* insp = basic_plus_adr(kls, in_bytes(offset));\n-  Node* tvalue = make_load(NULL, insp, TypeLong::LONG, T_LONG, MemNode::unordered);\n@@ -2767,12 +2777,25 @@\n-  Node* clsused = longcon(0x01l); \/\/ set the class bit\n-  Node* orl = _gvn.transform(new OrLNode(tvalue, clsused));\n-  const TypePtr *adr_type = _gvn.type(insp)->isa_ptr();\n-  store_to_memory(control(), insp, orl, T_LONG, adr_type, MemNode::unordered);\n-\n-#ifdef TRACE_ID_META_BITS\n-  Node* mbits = longcon(~TRACE_ID_META_BITS);\n-  tvalue = _gvn.transform(new AndLNode(tvalue, mbits));\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  Node* cbits = intcon(TRACE_ID_SHIFT);\n-  tvalue = _gvn.transform(new URShiftLNode(tvalue, cbits));\n+  IdealKit ideal(this);\n+#define __ ideal.\n+  IdealVariable result(ideal); __ declarations_done();\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                 basic_plus_adr(cls, java_lang_Class::klass_offset()),\n+                                                 TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+\n+  Node* signaled_flag_address = makecon(TypeRawPtr::make(JfrTraceIdEpoch::signal_address()));\n+\n+  __ if_then(kls, BoolTest::ne, null()); {\n+    Node* kls_trace_id_addr = basic_plus_adr(kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+    Node* kls_trace_id_raw = ideal.load(ideal.ctrl(), kls_trace_id_addr,TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+\n+    Node* epoch_address = makecon(TypeRawPtr::make(JfrTraceIdEpoch::epoch_address()));\n+    Node* epoch = ideal.load(ideal.ctrl(), epoch_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+    epoch = _gvn.transform(new LShiftLNode(longcon(1), epoch));\n+    Node* mask = _gvn.transform(new LShiftLNode(epoch, intcon(META_SHIFT)));\n+    mask = _gvn.transform(new OrLNode(mask, epoch));\n+    Node* kls_trace_id_raw_and_mask = _gvn.transform(new AndLNode(kls_trace_id_raw, mask));\n+\n+    __ if_then(kls_trace_id_raw_and_mask, BoolTest::ne, epoch); {\n+#ifdef VM_LITTLE_ENDIAN\n+      Node* kls_trace_id_low_addr = basic_plus_adr(kls_trace_id_addr, (intptr_t)0);\n+#else\n+      Node* kls_trace_id_low_addr = basic_plus_adr(kls_trace_id_addr, (intptr_t)7);\n@@ -2780,2 +2803,46 @@\n-\n-  set_result(tvalue);\n+      Node* current_value = ideal.load(ideal.ctrl(), kls_trace_id_low_addr, TypeInt::BYTE, T_BYTE, Compile::AliasIdxRaw);\n+      Node* new_value = _gvn.transform(new OrINode(current_value, _gvn.transform(new ConvL2INode(epoch, TypeInt::BYTE))));\n+      Node* store_trace_id = ideal.store(ideal.ctrl(), kls_trace_id_low_addr, new_value, T_BYTE, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+      sync_kit(ideal);\n+      insert_mem_bar(Op_MemBarStoreStore, store_trace_id);\n+\n+      make_runtime_call(RC_LEAF,\n+                        OptoRuntime::trace_id_load_barrier_Type(),\n+                        CAST_FROM_FN_PTR(address, SharedRuntime::trace_id_load_barrier),\n+                        \"SharedRuntime::trace_id_load_barrier\",\n+                        TypePtr::BOTTOM,\n+                        kls);\n+\n+      ideal.sync_kit(this);\n+\n+      Node* signaled = ideal.load(ideal.ctrl(), signaled_flag_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw, true, MemNode::acquire);\n+      __ if_then(signaled, BoolTest::ne, ideal.ConI(1)); {\n+        ideal.store(ideal.ctrl(), signaled_flag_address, ideal.ConI(1), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n+      } __ end_if();\n+    } __ end_if();\n+\n+    ideal.set(result,  _gvn.transform(new URShiftLNode(kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT))));\n+  } __ else_(); {\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                   basic_plus_adr(cls, java_lang_Class::array_klass_offset()),\n+                                                   TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+    __ if_then(array_kls, BoolTest::ne, null()); {\n+      Node* array_kls_trace_id_addr = basic_plus_adr(array_kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+      Node* array_kls_trace_id_raw = ideal.load(ideal.ctrl(), array_kls_trace_id_addr, TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+      Node* array_kls_trace_id = _gvn.transform(new URShiftLNode(array_kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT)));\n+      ideal.set(result, _gvn.transform(new AddLNode(array_kls_trace_id, longcon(1))));\n+    } __ else_(); {\n+      \/\/ void class case\n+      ideal.set(result, _gvn.transform(longcon(LAST_TYPE_ID + 1)));\n+    } __ end_if();\n+\n+    Node* signaled = ideal.load(ideal.ctrl(), signaled_flag_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw, true, MemNode::acquire);\n+    __ if_then(signaled, BoolTest::ne, ideal.ConI(1)); {\n+      ideal.store(ideal.ctrl(), signaled_flag_address, ideal.ConI(1), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n+    } __ end_if();\n+  } __ end_if();\n+\n+  final_sync(ideal);\n+  set_result(ideal.value(result));\n+#undef __\n@@ -2783,1 +2850,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":92,"deletions":26,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -1502,0 +1502,13 @@\n+const TypeFunc *OptoRuntime::trace_id_load_barrier_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::KLASS;\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms + 0, fields);\n+\n+  return TypeFunc::make(domain,range);\n+}\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -307,0 +307,2 @@\n+  static const TypeFunc* trace_id_load_barrier_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -988,1 +988,0 @@\n-\n@@ -1884,0 +1883,6 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+JRT_LEAF(void, SharedRuntime::trace_id_load_barrier(Klass * klass))\n+  JfrTraceIdLoadBarrier::enqueue(klass);\n+JRT_END\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -525,0 +525,4 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+  static void trace_id_load_barrier(Klass* klass);\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-            putLong(JVM.getClassIdNonIntrinsic(aClass));\n+            putLong(JVM.getClassId(aClass));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-        \/*\n-        Temporarily excluded until getClassId is reworked to accommodate epoch shift tagging\n+        JVM.getJVM().createNativeJFR();\n+        TestJFRIntrinsic ti = new TestJFRIntrinsic();\n@@ -66,2 +66,0 @@\n-        *\/\n-        TestJFRIntrinsic ti = new TestJFRIntrinsic();\n@@ -72,1 +70,0 @@\n-    \/*\n@@ -79,1 +76,0 @@\n-    *\/\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJFRIntrinsic.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}