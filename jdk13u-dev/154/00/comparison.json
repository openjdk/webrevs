{"files":[{"patch":"@@ -1771,26 +1771,15 @@\n-        \/*\n-         *  Since the double format has more than twice the precision\n-         *  of the float format, the multiply of a * b is exact in\n-         *  double. The add of c to the product then incurs one\n-         *  rounding error. Since the double format moreover has more\n-         *  than (2p + 2) precision bits compared to the p bits of the\n-         *  float format, the two roundings of (a * b + c), first to\n-         *  the double format and then secondarily to the float format,\n-         *  are equivalent to rounding the intermediate result directly\n-         *  to the float format.\n-         *\n-         * In terms of strictfp vs default-fp concerns related to\n-         * overflow and underflow, since\n-         *\n-         * (Float.MAX_VALUE * Float.MAX_VALUE) << Double.MAX_VALUE\n-         * (Float.MIN_VALUE * Float.MIN_VALUE) >> Double.MIN_VALUE\n-         *\n-         * neither the multiply nor add will overflow or underflow in\n-         * double. Therefore, it is not necessary for this method to\n-         * be declared strictfp to have reproducible\n-         * behavior. However, it is necessary to explicitly store down\n-         * to a float variable to avoid returning a value in the float\n-         * extended value set.\n-         *\/\n-        float result = (float)(((double) a * (double) b ) + (double) c);\n-        return result;\n+        if (Float.isFinite(a) && Float.isFinite(b) && Float.isFinite(c)) {\n+            if (a == 0.0 || b == 0.0) {\n+                return a * b + c; \/\/ Handled signed zero cases\n+            } else {\n+                return (new BigDecimal((double)a * (double)b) \/\/ Exact multiply\n+                        .add(new BigDecimal((double)c)))      \/\/ Exact sum\n+                    .floatValue();                            \/\/ One rounding\n+                                                              \/\/ to a float value\n+            }\n+        } else {\n+            \/\/ At least one of a,b, and c is non-finite. The result\n+            \/\/ will be non-finite as well and will be the same\n+            \/\/ non-finite value under double as float arithmetic.\n+            return (float)fma((double)a, (double)b, (double)c);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4851642\n+ * @bug 4851642 8253409\n@@ -31,0 +31,1 @@\n+ * @run main\/othervm -XX:-UseFMA FusedMultiplyAddTests\n@@ -353,0 +354,3 @@\n+\n+            \/\/ Double-rounding if done in double precision\n+            {0x1.fffffep23f, 0x1.000004p28f, 0x1.fep5f, 0x1.000002p52f}\n","filename":"test\/jdk\/java\/lang\/Math\/FusedMultiplyAddTests.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}