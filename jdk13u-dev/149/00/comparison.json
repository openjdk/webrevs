{"files":[{"patch":"@@ -4679,0 +4679,144 @@\n+  void generate_base64_encode_simdround(Register src, Register dst,\n+        FloatRegister codec, u8 size) {\n+\n+    FloatRegister in0  = v4,  in1  = v5,  in2  = v6;\n+    FloatRegister out0 = v16, out1 = v17, out2 = v18, out3 = v19;\n+    FloatRegister ind0 = v20, ind1 = v21, ind2 = v22, ind3 = v23;\n+\n+    Assembler::SIMD_Arrangement arrangement = size == 16 ? __ T16B : __ T8B;\n+\n+    __ ld3(in0, in1, in2, arrangement, __ post(src, 3 * size));\n+\n+    __ ushr(ind0, arrangement, in0,  2);\n+\n+    __ ushr(ind1, arrangement, in1,  2);\n+    __ shl(in0,   arrangement, in0,  6);\n+    __ orr(ind1,  arrangement, ind1, in0);\n+    __ ushr(ind1, arrangement, ind1, 2);\n+\n+    __ ushr(ind2, arrangement, in2,  4);\n+    __ shl(in1,   arrangement, in1,  4);\n+    __ orr(ind2,  arrangement, in1,  ind2);\n+    __ ushr(ind2, arrangement, ind2, 2);\n+\n+    __ shl(ind3,  arrangement, in2,  2);\n+    __ ushr(ind3, arrangement, ind3, 2);\n+\n+    __ tbl(out0,  arrangement, codec,  4, ind0);\n+    __ tbl(out1,  arrangement, codec,  4, ind1);\n+    __ tbl(out2,  arrangement, codec,  4, ind2);\n+    __ tbl(out3,  arrangement, codec,  4, ind3);\n+\n+    __ st4(out0,  out1, out2, out3, arrangement, __ post(dst, 4 * size));\n+  }\n+\n+   \/**\n+   *  Arguments:\n+   *\n+   *  Input:\n+   *  c_rarg0   - src_start\n+   *  c_rarg1   - src_offset\n+   *  c_rarg2   - src_length\n+   *  c_rarg3   - dest_start\n+   *  c_rarg4   - dest_offset\n+   *  c_rarg5   - isURL\n+   *\n+   *\/\n+  address generate_base64_encodeBlock() {\n+\n+    static const char toBase64[64] = {\n+      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '\/'\n+    };\n+\n+    static const char toBase64URL[64] = {\n+      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"encodeBlock\");\n+    address start = __ pc();\n+\n+    Register src   = c_rarg0;  \/\/ source array\n+    Register soff  = c_rarg1;  \/\/ source start offset\n+    Register send  = c_rarg2;  \/\/ source end offset\n+    Register dst   = c_rarg3;  \/\/ dest array\n+    Register doff  = c_rarg4;  \/\/ position for writing to dest array\n+    Register isURL = c_rarg5;  \/\/ Base64 or URL chracter set\n+\n+    \/\/ c_rarg6 and c_rarg7 are free to use as temps\n+    Register codec  = c_rarg6;\n+    Register length = c_rarg7;\n+\n+    Label ProcessData, Process48B, Process24B, Process3B, SIMDExit, Exit;\n+\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+    __ sub(length, send, soff);\n+\n+    \/\/ load the codec base address\n+    __ lea(codec, ExternalAddress((address) toBase64));\n+    __ cbz(isURL, ProcessData);\n+    __ lea(codec, ExternalAddress((address) toBase64URL));\n+\n+    __ BIND(ProcessData);\n+\n+    \/\/ too short to formup a SIMD loop, roll back\n+    __ cmp(length, (u1)24);\n+    __ br(Assembler::LT, Process3B);\n+\n+    __ ld1(v0, v1, v2, v3, __ T16B, Address(codec));\n+\n+    __ BIND(Process48B);\n+    __ cmp(length, (u1)48);\n+    __ br(Assembler::LT, Process24B);\n+    generate_base64_encode_simdround(src, dst, v0, 16);\n+    __ sub(length, length, 48);\n+    __ b(Process48B);\n+\n+    __ BIND(Process24B);\n+    __ cmp(length, (u1)24);\n+    __ br(Assembler::LT, SIMDExit);\n+    generate_base64_encode_simdround(src, dst, v0, 8);\n+    __ sub(length, length, 24);\n+\n+    __ BIND(SIMDExit);\n+    __ cbz(length, Exit);\n+\n+    __ BIND(Process3B);\n+    \/\/  3 src bytes, 24 bits\n+    __ ldrb(r10, __ post(src, 1));\n+    __ ldrb(r11, __ post(src, 1));\n+    __ ldrb(r12, __ post(src, 1));\n+    __ orrw(r11, r11, r10, Assembler::LSL, 8);\n+    __ orrw(r12, r12, r11, Assembler::LSL, 8);\n+    \/\/ codec index\n+    __ ubfmw(r15, r12, 18, 23);\n+    __ ubfmw(r14, r12, 12, 17);\n+    __ ubfmw(r13, r12, 6,  11);\n+    __ andw(r12,  r12, 63);\n+    \/\/ get the code based on the codec\n+    __ ldrb(r15, Address(codec, r15, Address::uxtw(0)));\n+    __ ldrb(r14, Address(codec, r14, Address::uxtw(0)));\n+    __ ldrb(r13, Address(codec, r13, Address::uxtw(0)));\n+    __ ldrb(r12, Address(codec, r12, Address::uxtw(0)));\n+    __ strb(r15, __ post(dst, 1));\n+    __ strb(r14, __ post(dst, 1));\n+    __ strb(r13, __ post(dst, 1));\n+    __ strb(r12, __ post(dst, 1));\n+    __ sub(length, length, 3);\n+    __ cbnz(length, Process3B);\n+\n+    __ BIND(Exit);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -5732,0 +5876,4 @@\n+    if (UseBASE64Intrinsics) {\n+        StubRoutines::_base64_encodeBlock = generate_base64_encodeBlock();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -390,0 +390,4 @@\n+  if (FLAG_IS_DEFAULT(UseBASE64Intrinsics)) {\n+    UseBASE64Intrinsics = true;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2020, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.micro.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Base64;\n+import java.util.Random;\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class Base64Encode {\n+\n+    private Base64.Encoder encoder;\n+    private ArrayList<byte[]> unencoded;\n+    private byte[] encoded;\n+\n+    private static final int TESTSIZE = 1000;\n+\n+    @Param({\"1\", \"2\", \"3\", \"6\", \"7\", \"9\", \"10\", \"48\", \"512\", \"1000\", \"20000\"})\n+    private int maxNumBytes;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+\n+        int dstLen = ((maxNumBytes + 16) \/ 3) * 4;\n+\n+        encoder = Base64.getEncoder();\n+        unencoded = new ArrayList<byte[]> ();\n+        encoded = new byte[dstLen];\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            int srcLen = 1 + r.nextInt(maxNumBytes);\n+            byte[] src = new byte[srcLen];\n+            r.nextBytes(src);\n+            unencoded.add(src);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testBase64Encode(Blackhole bh) {\n+        for (byte[] s : unencoded) {\n+            encoder.encode(s, encoded);\n+            bh.consume(encoded);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Encode.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}