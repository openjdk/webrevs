{"files":[{"patch":"@@ -238,3 +238,6 @@\n-            finish();\n-            if (usesDefaultDeflater)\n-                def.end();\n+            try {\n+                finish();\n+            } finally {\n+                if (usesDefaultDeflater)\n+                    def.end();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/DeflaterOutputStream.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -158,9 +158,13 @@\n-            def.finish();\n-            while (!def.finished()) {\n-                int len = def.deflate(buf, 0, buf.length);\n-                if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n-                    \/\/ last deflater buffer. Fit trailer at the end\n-                    writeTrailer(buf, len);\n-                    len = len + TRAILER_SIZE;\n-                    out.write(buf, 0, len);\n-                    return;\n+            try {\n+                def.finish();\n+                while (!def.finished()) {\n+                    int len = def.deflate(buf, 0, buf.length);\n+                    if (def.finished() && len <= buf.length - TRAILER_SIZE) {\n+                        \/\/ last deflater buffer. Fit trailer at the end\n+                        writeTrailer(buf, len);\n+                        len = len + TRAILER_SIZE;\n+                        out.write(buf, 0, len);\n+                        return;\n+                    }\n+                    if (len > 0)\n+                        out.write(buf, 0, len);\n@@ -168,2 +172,9 @@\n-                if (len > 0)\n-                    out.write(buf, 0, len);\n+                \/\/ if we can't fit the trailer at the end of the last\n+                \/\/ deflater buffer, we write it separately\n+                byte[] trailer = new byte[TRAILER_SIZE];\n+                writeTrailer(trailer, 0);\n+                out.write(trailer);\n+            } catch (IOException e) {\n+                if (usesDefaultDeflater)\n+                    def.end();\n+                throw e;\n@@ -171,5 +182,0 @@\n-            \/\/ if we can't fit the trailer at the end of the last\n-            \/\/ deflater buffer, we write it separately\n-            byte[] trailer = new byte[TRAILER_SIZE];\n-            writeTrailer(trailer, 0);\n-            out.write(trailer);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPOutputStream.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -251,6 +251,51 @@\n-            ZipEntry e = current.entry;\n-            switch (e.method) {\n-            case DEFLATED:\n-                def.finish();\n-                while (!def.finished()) {\n-                    deflate();\n+            try {\n+                ZipEntry e = current.entry;\n+                switch (e.method) {\n+                    case DEFLATED:\n+                        def.finish();\n+                        while (!def.finished()) {\n+                            deflate();\n+                        }\n+                        if ((e.flag & 8) == 0) {\n+                            \/\/ verify size, compressed size, and crc-32 settings\n+                            if (e.size != def.getBytesRead()) {\n+                                throw new ZipException(\n+                                    \"invalid entry size (expected \" + e.size +\n+                                    \" but got \" + def.getBytesRead() + \" bytes)\");\n+                            }\n+                            if (e.csize != def.getBytesWritten()) {\n+                                throw new ZipException(\n+                                    \"invalid entry compressed size (expected \" +\n+                                    e.csize + \" but got \" + def.getBytesWritten() + \" bytes)\");\n+                            }\n+                            if (e.crc != crc.getValue()) {\n+                                throw new ZipException(\n+                                    \"invalid entry CRC-32 (expected 0x\" +\n+                                    Long.toHexString(e.crc) + \" but got 0x\" +\n+                                    Long.toHexString(crc.getValue()) + \")\");\n+                            }\n+                        } else {\n+                            e.size = def.getBytesRead();\n+                            e.csize = def.getBytesWritten();\n+                            e.crc = crc.getValue();\n+                            writeEXT(e);\n+                        }\n+                        def.reset();\n+                        written += e.csize;\n+                        break;\n+                    case STORED:\n+                        \/\/ we already know that both e.size and e.csize are the same\n+                        if (e.size != written - locoff) {\n+                            throw new ZipException(\n+                                \"invalid entry size (expected \" + e.size +\n+                                \" but got \" + (written - locoff) + \" bytes)\");\n+                        }\n+                        if (e.crc != crc.getValue()) {\n+                            throw new ZipException(\n+                                \"invalid entry crc-32 (expected 0x\" +\n+                                Long.toHexString(e.crc) + \" but got 0x\" +\n+                                Long.toHexString(crc.getValue()) + \")\");\n+                        }\n+                        break;\n+                    default:\n+                        throw new ZipException(\"invalid compression method\");\n@@ -258,43 +303,6 @@\n-                if ((e.flag & 8) == 0) {\n-                    \/\/ verify size, compressed size, and crc-32 settings\n-                    if (e.size != def.getBytesRead()) {\n-                        throw new ZipException(\n-                            \"invalid entry size (expected \" + e.size +\n-                            \" but got \" + def.getBytesRead() + \" bytes)\");\n-                    }\n-                    if (e.csize != def.getBytesWritten()) {\n-                        throw new ZipException(\n-                            \"invalid entry compressed size (expected \" +\n-                            e.csize + \" but got \" + def.getBytesWritten() + \" bytes)\");\n-                    }\n-                    if (e.crc != crc.getValue()) {\n-                        throw new ZipException(\n-                            \"invalid entry CRC-32 (expected 0x\" +\n-                            Long.toHexString(e.crc) + \" but got 0x\" +\n-                            Long.toHexString(crc.getValue()) + \")\");\n-                    }\n-                } else {\n-                    e.size  = def.getBytesRead();\n-                    e.csize = def.getBytesWritten();\n-                    e.crc = crc.getValue();\n-                    writeEXT(e);\n-                }\n-                def.reset();\n-                written += e.csize;\n-                break;\n-            case STORED:\n-                \/\/ we already know that both e.size and e.csize are the same\n-                if (e.size != written - locoff) {\n-                    throw new ZipException(\n-                        \"invalid entry size (expected \" + e.size +\n-                        \" but got \" + (written - locoff) + \" bytes)\");\n-                }\n-                if (e.crc != crc.getValue()) {\n-                    throw new ZipException(\n-                         \"invalid entry crc-32 (expected 0x\" +\n-                         Long.toHexString(e.crc) + \" but got 0x\" +\n-                         Long.toHexString(crc.getValue()) + \")\");\n-                }\n-                break;\n-            default:\n-                throw new ZipException(\"invalid compression method\");\n+                crc.reset();\n+                current = null;\n+            } catch (IOException e) {\n+                if (usesDefaultDeflater && !(e instanceof ZipException))\n+                    def.end();\n+                throw e;\n@@ -302,2 +310,0 @@\n-            crc.reset();\n-            current = null;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":57,"deletions":51,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193682\n+ * @summary Test Infinite loop while writing on closed GZipOutputStream , ZipOutputStream and JarOutputStream.\n+ * @run testng CloseDeflaterTest\n+ *\/\n+import java.io.*;\n+import java.util.Random;\n+import java.util.jar.JarOutputStream;\n+import java.util.zip.GZIPOutputStream;\n+import java.util.zip.ZipOutputStream;\n+import java.util.zip.ZipEntry;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.fail;\n+\n+\n+public class CloseDeflaterTest {\n+\n+    \/\/number of bytes to write\n+    private static final int INPUT_LENGTH= 512;\n+    \/\/OutputStream that will throw an exception during a write operation\n+    private static OutputStream outStream = new OutputStream() {\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            \/\/throw exception during write\n+            throw new IOException();\n+        }\n+        @Override\n+        public void write(byte b[]) throws IOException {}\n+        @Override\n+        public void write(int b) throws IOException {}\n+    };\n+    private static byte[] inputBytes = new byte[INPUT_LENGTH];\n+    private static Random rand = new Random();\n+\n+    @DataProvider(name = \"testgzipinput\")\n+    public Object[][] testGZipInput() {\n+     \/\/testGZip will close the GZipOutputStream using close() method when the boolean\n+     \/\/useCloseMethod is set to true and finish() method if the value is set to false\n+     return new Object[][] {\n+      { GZIPOutputStream.class, true },\n+      { GZIPOutputStream.class, false },\n+     };\n+    }\n+\n+    @DataProvider(name = \"testzipjarinput\")\n+    public Object[][] testZipAndJarInput() {\n+     \/\/testZipAndJarInput will perfrom write\/closeEntry operations on JarOutputStream when the boolean\n+     \/\/useJar is set to true and on ZipOutputStream if the value is set to false\n+     return new Object[][] {\n+      { JarOutputStream.class, true },\n+      { ZipOutputStream.class, false },\n+     };\n+    }\n+\n+    @BeforeTest\n+    public void before_test()\n+    {\n+       \/\/add inputBytes array with random bytes to write into Zip\n+       rand.nextBytes(inputBytes);\n+    }\n+\n+    \/\/Test for infinite loop by writing bytes to closed GZIPOutputStream\n+    @Test(dataProvider = \"testgzipinput\")\n+    public void testGZip(Class<?> type, boolean useCloseMethod) throws IOException {\n+        GZIPOutputStream zip = new GZIPOutputStream(outStream);\n+        try {\n+            zip.write(inputBytes, 0, INPUT_LENGTH);\n+            \/\/close zip\n+            if(useCloseMethod) {\n+               zip.close();\n+            } else {\n+               zip.finish();\n+            }\n+        } catch (IOException e) {\n+            \/\/expected\n+        }\n+        for (int i = 0; i < 3; i++) {\n+            try {\n+                \/\/write on a closed GZIPOutputStream\n+                zip.write(inputBytes, 0, INPUT_LENGTH);\n+                fail(\"Deflater closed exception not thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/expected , Deflater has been closed exception\n+            }\n+        }\n+    }\n+\n+    \/\/Test for infinite loop by writing bytes to closed ZipOutputStream\/JarOutputStream\n+    @Test(dataProvider = \"testzipjarinput\")\n+    public void testZipCloseEntry(Class<?> type,boolean useJar) throws IOException {\n+        ZipOutputStream zip = null;\n+        if(useJar) {\n+           zip = new JarOutputStream(outStream);\n+        } else {\n+           zip = new ZipOutputStream(outStream);\n+        }\n+        try {\n+            zip.putNextEntry(new ZipEntry(\"\"));\n+        } catch (IOException e) {\n+            \/\/expected to throw IOException since putNextEntry calls write method\n+        }\n+        try {\n+            zip.write(inputBytes, 0, INPUT_LENGTH);\n+            \/\/close zip entry\n+            zip.closeEntry();\n+        } catch (IOException e) {\n+            \/\/expected\n+        }\n+        for (int i = 0; i < 3; i++) {\n+            try {\n+                \/\/write on a closed ZipOutputStream\n+                zip.write(inputBytes, 0, INPUT_LENGTH);\n+                fail(\"Deflater closed exception not thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/expected , Deflater has been closed exception\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/zip\/CloseDeflaterTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}