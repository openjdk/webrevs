{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## Harfbuzz v2.8\n+## Harfbuzz v4.4.1\n","filename":"src\/java.desktop\/share\/legal\/harfbuzz.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+#ifndef OT_LAYOUT_GPOS_HH\n+#define OT_LAYOUT_GPOS_HH\n+\n+#include \"..\/..\/hb-ot-layout-common.hh\"\n+#include \"..\/..\/hb-ot-layout-gsubgpos.hh\"\n+#include \"GPOS\/Common.hh\"\n+#include \"GPOS\/PosLookup.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+\n+static void\n+propagate_attachment_offsets (hb_glyph_position_t *pos,\n+                              unsigned int len,\n+                              unsigned int i,\n+                              hb_direction_t direction,\n+                              unsigned nesting_level = HB_MAX_NESTING_LEVEL);\n+\n+\/*\n+ * GPOS -- Glyph Positioning\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gpos\n+ *\/\n+\n+struct GPOS : GSUBGPOS\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_GPOS;\n+\n+  using Lookup = GPOS_impl::PosLookup;\n+\n+  const GPOS_impl::PosLookup& get_lookup (unsigned int i) const\n+  { return static_cast<const GPOS_impl::PosLookup &> (GSUBGPOS::get_lookup (i)); }\n+\n+  static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);\n+  static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);\n+  static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    hb_subset_layout_context_t l (c, tableTag, c->plan->gpos_lookups, c->plan->gpos_langsys, c->plan->gpos_features);\n+    return GSUBGPOS::subset<GPOS_impl::PosLookup> (&l);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  { return GSUBGPOS::sanitize<GPOS_impl::PosLookup> (c); }\n+\n+  HB_INTERNAL bool is_blocklisted (hb_blob_t *blob,\n+                                   hb_face_t *face) const;\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    for (unsigned i = 0; i < GSUBGPOS::get_lookup_count (); i++)\n+    {\n+      if (!c->gpos_lookups->has (i)) continue;\n+      const GPOS_impl::PosLookup &l = get_lookup (i);\n+      l.dispatch (c);\n+    }\n+  }\n+\n+  void closure_lookups (hb_face_t      *face,\n+                        const hb_set_t *glyphs,\n+                        hb_set_t       *lookup_indexes \/* IN\/OUT *\/) const\n+  { GSUBGPOS::closure_lookups<GPOS_impl::PosLookup> (face, glyphs, lookup_indexes); }\n+\n+  typedef GSUBGPOS::accelerator_t<GPOS> accelerator_t;\n+};\n+\n+\n+static void\n+propagate_attachment_offsets (hb_glyph_position_t *pos,\n+                              unsigned int len,\n+                              unsigned int i,\n+                              hb_direction_t direction,\n+                              unsigned nesting_level)\n+{\n+  \/* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate\n+   * offset of glyph they are attached to. *\/\n+  int chain = pos[i].attach_chain(), type = pos[i].attach_type();\n+  if (likely (!chain))\n+    return;\n+\n+  pos[i].attach_chain() = 0;\n+\n+  unsigned int j = (int) i + chain;\n+\n+  if (unlikely (j >= len))\n+    return;\n+\n+  if (unlikely (!nesting_level))\n+    return;\n+\n+  propagate_attachment_offsets (pos, len, j, direction, nesting_level - 1);\n+\n+  assert (!!(type & GPOS_impl::ATTACH_TYPE_MARK) ^ !!(type & GPOS_impl::ATTACH_TYPE_CURSIVE));\n+\n+  if (type & GPOS_impl::ATTACH_TYPE_CURSIVE)\n+  {\n+    if (HB_DIRECTION_IS_HORIZONTAL (direction))\n+      pos[i].y_offset += pos[j].y_offset;\n+    else\n+      pos[i].x_offset += pos[j].x_offset;\n+  }\n+  else \/*if (type & GPOS_impl::ATTACH_TYPE_MARK)*\/\n+  {\n+    pos[i].x_offset += pos[j].x_offset;\n+    pos[i].y_offset += pos[j].y_offset;\n+\n+    assert (j < i);\n+    if (HB_DIRECTION_IS_FORWARD (direction))\n+      for (unsigned int k = j; k < i; k++) {\n+        pos[i].x_offset -= pos[k].x_advance;\n+        pos[i].y_offset -= pos[k].y_advance;\n+      }\n+    else\n+      for (unsigned int k = j + 1; k < i + 1; k++) {\n+        pos[i].x_offset += pos[k].x_advance;\n+        pos[i].y_offset += pos[k].y_advance;\n+      }\n+  }\n+}\n+\n+void\n+GPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n+{\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+    buffer->pos[i].attach_chain() = buffer->pos[i].attach_type() = 0;\n+}\n+\n+void\n+GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)\n+{\n+  \/\/_hb_buffer_assert_gsubgpos_vars (buffer);\n+}\n+\n+void\n+GPOS::position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer)\n+{\n+  _hb_buffer_assert_gsubgpos_vars (buffer);\n+\n+  unsigned int len;\n+  hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &len);\n+  hb_direction_t direction = buffer->props.direction;\n+\n+  \/* Handle attachments *\/\n+  if (buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)\n+    for (unsigned i = 0; i < len; i++)\n+      propagate_attachment_offsets (pos, len, i, direction);\n+\n+  if (unlikely (font->slant))\n+  {\n+    for (unsigned i = 0; i < len; i++)\n+      if (unlikely (pos[i].y_offset))\n+        pos[i].x_offset += _hb_roundf (font->slant_xy * pos[i].y_offset);\n+  }\n+}\n+\n+}\n+\n+struct GPOS_accelerator_t : Layout::GPOS::accelerator_t {\n+  GPOS_accelerator_t (hb_face_t *face) : Layout::GPOS::accelerator_t (face) {}\n+};\n+\n+}\n+\n+#endif  \/* OT_LAYOUT_GPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS.hh","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+#ifndef OT_LAYOUT_GPOS_ANCHOR_HH\n+#define OT_LAYOUT_GPOS_ANCHOR_HH\n+\n+#include \"AnchorFormat1.hh\"\n+#include \"AnchorFormat2.hh\"\n+#include \"AnchorFormat3.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct Anchor\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  AnchorFormat1         format1;\n+  AnchorFormat2         format2;\n+  AnchorFormat3         format3;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    case 2: return_trace (u.format2.sanitize (c));\n+    case 3: return_trace (u.format3.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,\n+                   float *x, float *y) const\n+  {\n+    *x = *y = 0;\n+    switch (u.format) {\n+    case 1: u.format1.get_anchor (c, glyph_id, x, y); return;\n+    case 2: u.format2.get_anchor (c, glyph_id, x, y); return;\n+    case 3: u.format3.get_anchor (c, glyph_id, x, y); return;\n+    default:                                          return;\n+    }\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    switch (u.format) {\n+    case 1: return_trace (bool (reinterpret_cast<Anchor *> (u.format1.copy (c->serializer))));\n+    case 2:\n+      if (c->plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n+      {\n+        \/\/ AnchorFormat 2 just containins extra hinting information, so\n+        \/\/ if hints are being dropped convert to format 1.\n+        return_trace (bool (reinterpret_cast<Anchor *> (u.format1.copy (c->serializer))));\n+      }\n+      return_trace (bool (reinterpret_cast<Anchor *> (u.format2.copy (c->serializer))));\n+    case 3: return_trace (bool (reinterpret_cast<Anchor *> (u.format3.copy (c->serializer,\n+                                                                            c->plan->layout_variation_idx_map))));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    switch (u.format) {\n+    case 1: case 2:\n+      return;\n+    case 3:\n+      u.format3.collect_variation_indices (c);\n+      return;\n+    default: return;\n+    }\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_ANCHOR_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/Anchor.hh","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+#ifndef OT_LAYOUT_GPOS_ANCHORFORMAT1_HH\n+#define OT_LAYOUT_GPOS_ANCHORFORMAT1_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct AnchorFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  FWORD         xCoordinate;            \/* Horizontal value--in design units *\/\n+  FWORD         yCoordinate;            \/* Vertical value--in design units *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,\n+                   float *x, float *y) const\n+  {\n+    hb_font_t *font = c->font;\n+    *x = font->em_fscale_x (xCoordinate);\n+    *y = font->em_fscale_y (yCoordinate);\n+  }\n+\n+  AnchorFormat1* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    AnchorFormat1* out = c->embed<AnchorFormat1> (this);\n+    if (!out) return_trace (out);\n+    out->format = 1;\n+    return_trace (out);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_ANCHORFORMAT1_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/AnchorFormat1.hh","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+#ifndef OT_LAYOUT_GPOS_ANCHORFORMAT2_HH\n+#define OT_LAYOUT_GPOS_ANCHORFORMAT2_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct AnchorFormat2\n+{\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  FWORD         xCoordinate;            \/* Horizontal value--in design units *\/\n+  FWORD         yCoordinate;            \/* Vertical value--in design units *\/\n+  HBUINT16      anchorPoint;            \/* Index to glyph contour point *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,\n+                   float *x, float *y) const\n+  {\n+    hb_font_t *font = c->font;\n+\n+#ifdef HB_NO_HINTING\n+    *x = font->em_fscale_x (xCoordinate);\n+    *y = font->em_fscale_y (yCoordinate);\n+    return;\n+#endif\n+\n+    unsigned int x_ppem = font->x_ppem;\n+    unsigned int y_ppem = font->y_ppem;\n+    hb_position_t cx = 0, cy = 0;\n+    bool ret;\n+\n+    ret = (x_ppem || y_ppem) &&\n+          font->get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &cx, &cy);\n+    *x = ret && x_ppem ? cx : font->em_fscale_x (xCoordinate);\n+    *y = ret && y_ppem ? cy : font->em_fscale_y (yCoordinate);\n+  }\n+\n+  AnchorFormat2* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (c->embed<AnchorFormat2> (this));\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_ANCHORFORMAT2_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/AnchorFormat2.hh","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+#ifndef OT_LAYOUT_GPOS_ANCHORFORMAT3_HH\n+#define OT_LAYOUT_GPOS_ANCHORFORMAT3_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct AnchorFormat3\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 3 *\/\n+  FWORD         xCoordinate;            \/* Horizontal value--in design units *\/\n+  FWORD         yCoordinate;            \/* Vertical value--in design units *\/\n+  Offset16To<Device>\n+                xDeviceTable;           \/* Offset to Device table for X\n+                                         * coordinate-- from beginning of\n+                                         * Anchor table (may be NULL) *\/\n+  Offset16To<Device>\n+                yDeviceTable;           \/* Offset to Device table for Y\n+                                         * coordinate-- from beginning of\n+                                         * Anchor table (may be NULL) *\/\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && xDeviceTable.sanitize (c, this) && yDeviceTable.sanitize (c, this));\n+  }\n+\n+  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,\n+                   float *x, float *y) const\n+  {\n+    hb_font_t *font = c->font;\n+    *x = font->em_fscale_x (xCoordinate);\n+    *y = font->em_fscale_y (yCoordinate);\n+\n+    if (font->x_ppem || font->num_coords)\n+      *x += (this+xDeviceTable).get_x_delta (font, c->var_store, c->var_store_cache);\n+    if (font->y_ppem || font->num_coords)\n+      *y += (this+yDeviceTable).get_y_delta (font, c->var_store, c->var_store_cache);\n+  }\n+\n+  AnchorFormat3* copy (hb_serialize_context_t *c,\n+                       const hb_map_t *layout_variation_idx_map) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (!layout_variation_idx_map) return_trace (nullptr);\n+\n+    auto *out = c->embed<AnchorFormat3> (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+\n+    out->xDeviceTable.serialize_copy (c, xDeviceTable, this, 0, hb_serialize_context_t::Head, layout_variation_idx_map);\n+    out->yDeviceTable.serialize_copy (c, yDeviceTable, this, 0, hb_serialize_context_t::Head, layout_variation_idx_map);\n+    return_trace (out);\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    (this+xDeviceTable).collect_variation_indices (c->layout_variation_indices);\n+    (this+yDeviceTable).collect_variation_indices (c->layout_variation_indices);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_ANCHORFORMAT3_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/AnchorFormat3.hh","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+#ifndef OT_LAYOUT_GPOS_ANCHORMATRIX_HH\n+#define OT_LAYOUT_GPOS_ANCHORMATRIX_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct AnchorMatrix\n+{\n+  HBUINT16      rows;                   \/* Number of rows *\/\n+  UnsizedArrayOf<Offset16To<Anchor>>\n+                matrixZ;                \/* Matrix of offsets to Anchor tables--\n+                                         * from beginning of AnchorMatrix table *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, matrixZ);\n+\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!c->check_struct (this)) return_trace (false);\n+    if (unlikely (hb_unsigned_mul_overflows (rows, cols))) return_trace (false);\n+    unsigned int count = rows * cols;\n+    if (!c->check_array (matrixZ.arrayZ, count)) return_trace (false);\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!matrixZ[i].sanitize (c, this)) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  const Anchor& get_anchor (unsigned int row, unsigned int col,\n+                            unsigned int cols, bool *found) const\n+  {\n+    *found = false;\n+    if (unlikely (row >= rows || col >= cols)) return Null (Anchor);\n+    *found = !matrixZ[row * cols + col].is_null ();\n+    return this+matrixZ[row * cols + col];\n+  }\n+\n+  template <typename Iterator,\n+            hb_requires (hb_is_iterator (Iterator))>\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n+                                  Iterator index_iter) const\n+  {\n+    for (unsigned i : index_iter)\n+      (this+matrixZ[i]).collect_variation_indices (c);\n+  }\n+\n+  template <typename Iterator,\n+      hb_requires (hb_is_iterator (Iterator))>\n+  bool subset (hb_subset_context_t *c,\n+               unsigned             num_rows,\n+               Iterator             index_iter) const\n+  {\n+    TRACE_SUBSET (this);\n+\n+    auto *out = c->serializer->start_embed (this);\n+\n+    if (!index_iter) return_trace (false);\n+    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n+\n+    out->rows = num_rows;\n+    for (const unsigned i : index_iter)\n+    {\n+      auto *offset = c->serializer->embed (matrixZ[i]);\n+      if (!offset) return_trace (false);\n+      offset->serialize_subset (c, matrixZ[i], this);\n+    }\n+\n+    return_trace (true);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_ANCHORMATRIX_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/AnchorMatrix.hh","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+#ifndef OT_LAYOUT_GPOS_CHAINCONTEXTPOS_HH\n+#define OT_LAYOUT_GPOS_CHAINCONTEXTPOS_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct ChainContextPos : ChainContext {};\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_CHAINCONTEXTPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/ChainContextPos.hh","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#ifndef OT_LAYOUT_GPOS_COMMON_HH\n+#define OT_LAYOUT_GPOS_COMMON_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+enum attach_type_t {\n+  ATTACH_TYPE_NONE      = 0X00,\n+\n+  \/* Each attachment should be either a mark or a cursive; can't be both. *\/\n+  ATTACH_TYPE_MARK      = 0X01,\n+  ATTACH_TYPE_CURSIVE   = 0X02,\n+};\n+\n+\/* buffer **position** var allocations *\/\n+#define attach_chain() var.i16[0] \/* glyph to which this attaches to, relative to current glyphs; negative for going back, positive for forward. *\/\n+#define attach_type() var.u8[2] \/* attachment type *\/\n+\/* Note! if attach_chain() is zero, the value of attach_type() is irrelevant. *\/\n+\n+template<typename Iterator, typename SrcLookup>\n+static void SinglePos_serialize (hb_serialize_context_t *c,\n+                                 const SrcLookup *src,\n+                                 Iterator it,\n+                                 const hb_map_t *layout_variation_idx_map);\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_COMMON_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/Common.hh","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+#ifndef OT_LAYOUT_GPOS_CONTEXTPOS_HH\n+#define OT_LAYOUT_GPOS_CONTEXTPOS_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct ContextPos : Context {};\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_CONTEXTPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/ContextPos.hh","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+#ifndef OT_LAYOUT_GPOS_CURSIVEPOS_HH\n+#define OT_LAYOUT_GPOS_CURSIVEPOS_HH\n+\n+#include \"CursivePosFormat1.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct CursivePos\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  CursivePosFormat1     format1;\n+  } u;\n+\n+  public:\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_CURSIVEPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/CursivePos.hh","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,281 @@\n+#ifndef OT_LAYOUT_GPOS_CURSIVEPOSFORMAT1_HH\n+#define OT_LAYOUT_GPOS_CURSIVEPOSFORMAT1_HH\n+\n+#include \"Anchor.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct EntryExitRecord\n+{\n+  friend struct CursivePosFormat1;\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (entryAnchor.sanitize (c, base) && exitAnchor.sanitize (c, base));\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n+                                  const void *src_base) const\n+  {\n+    (src_base+entryAnchor).collect_variation_indices (c);\n+    (src_base+exitAnchor).collect_variation_indices (c);\n+  }\n+\n+  EntryExitRecord* subset (hb_subset_context_t *c,\n+                           const void *src_base) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+\n+    out->entryAnchor.serialize_subset (c, entryAnchor, src_base);\n+    out->exitAnchor.serialize_subset (c, exitAnchor, src_base);\n+    return_trace (out);\n+  }\n+\n+  protected:\n+  Offset16To<Anchor>\n+                entryAnchor;            \/* Offset to EntryAnchor table--from\n+                                         * beginning of CursivePos\n+                                         * subtable--may be NULL *\/\n+  Offset16To<Anchor>\n+                exitAnchor;             \/* Offset to ExitAnchor table--from\n+                                         * beginning of CursivePos\n+                                         * subtable--may be NULL *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+static void\n+reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent) {\n+  int chain = pos[i].attach_chain(), type = pos[i].attach_type();\n+  if (likely (!chain || 0 == (type & ATTACH_TYPE_CURSIVE)))\n+    return;\n+\n+  pos[i].attach_chain() = 0;\n+\n+  unsigned int j = (int) i + chain;\n+\n+  \/* Stop if we see new parent in the chain. *\/\n+  if (j == new_parent)\n+    return;\n+\n+  reverse_cursive_minor_offset (pos, j, direction, new_parent);\n+\n+  if (HB_DIRECTION_IS_HORIZONTAL (direction))\n+    pos[j].y_offset = -pos[i].y_offset;\n+  else\n+    pos[j].x_offset = -pos[i].x_offset;\n+\n+  pos[j].attach_chain() = -chain;\n+  pos[j].attach_type() = type;\n+}\n+\n+\n+struct CursivePosFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  Array16Of<EntryExitRecord>\n+                entryExitRecord;        \/* Array of EntryExit records--in\n+                                         * Coverage Index order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, entryExitRecord);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && entryExitRecord.sanitize (c, this));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    + hb_zip (this+coverage, entryExitRecord)\n+    | hb_filter (c->glyph_set, hb_first)\n+    | hb_map (hb_second)\n+    | hb_apply ([&] (const EntryExitRecord& record) { record.collect_variation_indices (c, this); })\n+    ;\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { if (unlikely (!(this+coverage).collect_coverage (c->input))) return; }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+\n+    const EntryExitRecord &this_record = entryExitRecord[(this+coverage).get_coverage  (buffer->cur().codepoint)];\n+    if (!this_record.entryAnchor) return_trace (false);\n+\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    unsigned unsafe_from;\n+    if (!skippy_iter.prev (&unsafe_from))\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (unsafe_from, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    const EntryExitRecord &prev_record = entryExitRecord[(this+coverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint)];\n+    if (!prev_record.exitAnchor)\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    unsigned int i = skippy_iter.idx;\n+    unsigned int j = buffer->idx;\n+\n+    buffer->unsafe_to_break (i, j);\n+    float entry_x, entry_y, exit_x, exit_y;\n+    (this+prev_record.exitAnchor).get_anchor (c, buffer->info[i].codepoint, &exit_x, &exit_y);\n+    (this+this_record.entryAnchor).get_anchor (c, buffer->info[j].codepoint, &entry_x, &entry_y);\n+\n+    hb_glyph_position_t *pos = buffer->pos;\n+\n+    hb_position_t d;\n+    \/* Main-direction adjustment *\/\n+    switch (c->direction) {\n+      case HB_DIRECTION_LTR:\n+        pos[i].x_advance  = roundf (exit_x) + pos[i].x_offset;\n+\n+        d = roundf (entry_x) + pos[j].x_offset;\n+        pos[j].x_advance -= d;\n+        pos[j].x_offset  -= d;\n+        break;\n+      case HB_DIRECTION_RTL:\n+        d = roundf (exit_x) + pos[i].x_offset;\n+        pos[i].x_advance -= d;\n+        pos[i].x_offset  -= d;\n+\n+        pos[j].x_advance  = roundf (entry_x) + pos[j].x_offset;\n+        break;\n+      case HB_DIRECTION_TTB:\n+        pos[i].y_advance  = roundf (exit_y) + pos[i].y_offset;\n+\n+        d = roundf (entry_y) + pos[j].y_offset;\n+        pos[j].y_advance -= d;\n+        pos[j].y_offset  -= d;\n+        break;\n+      case HB_DIRECTION_BTT:\n+        d = roundf (exit_y) + pos[i].y_offset;\n+        pos[i].y_advance -= d;\n+        pos[i].y_offset  -= d;\n+\n+        pos[j].y_advance  = roundf (entry_y);\n+        break;\n+      case HB_DIRECTION_INVALID:\n+      default:\n+        break;\n+    }\n+\n+    \/* Cross-direction adjustment *\/\n+\n+    \/* We attach child to parent (think graph theory and rooted trees whereas\n+     * the root stays on baseline and each node aligns itself against its\n+     * parent.\n+     *\n+     * Optimize things for the case of RightToLeft, as that's most common in\n+     * Arabic. *\/\n+    unsigned int child  = i;\n+    unsigned int parent = j;\n+    hb_position_t x_offset = entry_x - exit_x;\n+    hb_position_t y_offset = entry_y - exit_y;\n+    if  (!(c->lookup_props & LookupFlag::RightToLeft))\n+    {\n+      unsigned int k = child;\n+      child = parent;\n+      parent = k;\n+      x_offset = -x_offset;\n+      y_offset = -y_offset;\n+    }\n+\n+    \/* If child was already connected to someone else, walk through its old\n+     * chain and reverse the link direction, such that the whole tree of its\n+     * previous connection now attaches to new parent.  Watch out for case\n+     * where new parent is on the path from old chain...\n+     *\/\n+    reverse_cursive_minor_offset (pos, child, c->direction, parent);\n+\n+    pos[child].attach_type() = ATTACH_TYPE_CURSIVE;\n+    pos[child].attach_chain() = (int) parent - (int) child;\n+    buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n+    if (likely (HB_DIRECTION_IS_HORIZONTAL (c->direction)))\n+      pos[child].y_offset = y_offset;\n+    else\n+      pos[child].x_offset = x_offset;\n+\n+    \/* If parent was attached to child, separate them.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2469\n+     *\/\n+    if (unlikely (pos[parent].attach_chain() == -pos[child].attach_chain()))\n+      pos[parent].attach_chain() = 0;\n+\n+    buffer->idx++;\n+    return_trace (true);\n+  }\n+\n+  template <typename Iterator,\n+            hb_requires (hb_is_iterator (Iterator))>\n+  void serialize (hb_subset_context_t *c,\n+                  Iterator it,\n+                  const void *src_base)\n+  {\n+    if (unlikely (!c->serializer->extend_min ((*this)))) return;\n+    this->format = 1;\n+    this->entryExitRecord.len = it.len ();\n+\n+    for (const EntryExitRecord& entry_record : + it\n+                                               | hb_map (hb_second))\n+      entry_record.subset (c, src_base);\n+\n+    auto glyphs =\n+    + it\n+    | hb_map_retains_sorting (hb_first)\n+    ;\n+\n+    coverage.serialize_serialize (c->serializer, glyphs);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    auto it =\n+    + hb_zip (this+coverage, entryExitRecord)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_map_retains_sorting ([&] (hb_pair_t<hb_codepoint_t, const EntryExitRecord&> p) -> hb_pair_t<hb_codepoint_t, const EntryExitRecord&>\n+                              { return hb_pair (glyph_map[p.first], p.second);})\n+    ;\n+\n+    bool ret = bool (it);\n+    out->serialize (c, it, this);\n+    return_trace (ret);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_CURSIVEPOSFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/CursivePosFormat1.hh","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+#ifndef OT_LAYOUT_GPOS_EXTENSIONPOS_HH\n+#define OT_LAYOUT_GPOS_EXTENSIONPOS_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct ExtensionPos : Extension<ExtensionPos>\n+{\n+  typedef struct PosLookupSubTable SubTable;\n+};\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_EXTENSIONPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/ExtensionPos.hh","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+#ifndef OT_LAYOUT_GPOS_MARKARRAY_HH\n+#define OT_LAYOUT_GPOS_MARKARRAY_HH\n+\n+#include \"AnchorMatrix.hh\"\n+#include \"MarkRecord.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct MarkArray : Array16Of<MarkRecord>        \/* Array of MarkRecords--in Coverage order *\/\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (Array16Of<MarkRecord>::sanitize (c, this));\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c,\n+              unsigned int mark_index, unsigned int glyph_index,\n+              const AnchorMatrix &anchors, unsigned int class_count,\n+              unsigned int glyph_pos) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    const MarkRecord &record = Array16Of<MarkRecord>::operator[](mark_index);\n+    unsigned int mark_class = record.klass;\n+\n+    const Anchor& mark_anchor = this + record.markAnchor;\n+    bool found;\n+    const Anchor& glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count, &found);\n+    \/* If this subtable doesn't have an anchor for this base and this class,\n+     * return false such that the subsequent subtables have a chance at it. *\/\n+    if (unlikely (!found)) return_trace (false);\n+\n+    float mark_x, mark_y, base_x, base_y;\n+\n+    buffer->unsafe_to_break (glyph_pos, buffer->idx + 1);\n+    mark_anchor.get_anchor (c, buffer->cur().codepoint, &mark_x, &mark_y);\n+    glyph_anchor.get_anchor (c, buffer->info[glyph_pos].codepoint, &base_x, &base_y);\n+\n+    hb_glyph_position_t &o = buffer->cur_pos();\n+    o.x_offset = roundf (base_x - mark_x);\n+    o.y_offset = roundf (base_y - mark_y);\n+    o.attach_type() = ATTACH_TYPE_MARK;\n+    o.attach_chain() = (int) glyph_pos - (int) buffer->idx;\n+    buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n+\n+    buffer->idx++;\n+    return_trace (true);\n+  }\n+\n+  template <typename Iterator,\n+      hb_requires (hb_is_iterator (Iterator))>\n+  bool subset (hb_subset_context_t *c,\n+               Iterator             coverage,\n+               const hb_map_t      *klass_mapping) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+\n+    auto* out = c->serializer->start_embed (this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    auto mark_iter =\n+    + hb_zip (coverage, this->iter ())\n+    | hb_filter (glyphset, hb_first)\n+    | hb_map (hb_second)\n+    ;\n+\n+    unsigned new_length = 0;\n+    for (const auto& mark_record : mark_iter) {\n+      if (unlikely (!mark_record.subset (c, this, klass_mapping)))\n+        return_trace (false);\n+      new_length++;\n+    }\n+\n+    if (unlikely (!c->serializer->check_assign (out->len, new_length,\n+                                                HB_SERIALIZE_ERROR_ARRAY_OVERFLOW)))\n+      return_trace (false);\n+\n+    return_trace (true);\n+  }\n+};\n+\n+static void Markclass_closure_and_remap_indexes (const Coverage  &mark_coverage,\n+                                                 const MarkArray &mark_array,\n+                                                 const hb_set_t  &glyphset,\n+                                                 hb_map_t*        klass_mapping \/* INOUT *\/)\n+{\n+  hb_set_t orig_classes;\n+\n+  + hb_zip (mark_coverage, mark_array)\n+  | hb_filter (glyphset, hb_first)\n+  | hb_map (hb_second)\n+  | hb_map (&MarkRecord::get_class)\n+  | hb_sink (orig_classes)\n+  ;\n+\n+  unsigned idx = 0;\n+  for (auto klass : orig_classes.iter ())\n+  {\n+    if (klass_mapping->has (klass)) continue;\n+    klass_mapping->set (klass, idx);\n+    idx++;\n+  }\n+}\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_MARKARRAY_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkArray.hh","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+#ifndef OT_LAYOUT_GPOS_MARKBASEPOS_HH\n+#define OT_LAYOUT_GPOS_MARKBASEPOS_HH\n+\n+#include \"MarkBasePosFormat1.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct MarkBasePos\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MarkBasePosFormat1    format1;\n+  } u;\n+\n+  public:\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_MARKBASEPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkBasePos.hh","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+#ifndef OT_LAYOUT_GPOS_MARKBASEPOSFORMAT1_HH\n+#define OT_LAYOUT_GPOS_MARKBASEPOSFORMAT1_HH\n+\n+#include \"MarkArray.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+typedef AnchorMatrix BaseArray;         \/* base-major--\n+                                         * in order of BaseCoverage Index--,\n+                                         * mark-minor--\n+                                         * ordered by class--zero-based. *\/\n+\n+struct MarkBasePosFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                markCoverage;           \/* Offset to MarkCoverage table--from\n+                                         * beginning of MarkBasePos subtable *\/\n+  Offset16To<Coverage>\n+                baseCoverage;           \/* Offset to BaseCoverage table--from\n+                                         * beginning of MarkBasePos subtable *\/\n+  HBUINT16      classCount;             \/* Number of classes defined for marks *\/\n+  Offset16To<MarkArray>\n+                markArray;              \/* Offset to MarkArray table--from\n+                                         * beginning of MarkBasePos subtable *\/\n+  Offset16To<BaseArray>\n+                baseArray;              \/* Offset to BaseArray table--from\n+                                         * beginning of MarkBasePos subtable *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+\n+    bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  markCoverage.sanitize (c, this) &&\n+                  baseCoverage.sanitize (c, this) &&\n+                  markArray.sanitize (c, this) &&\n+                  baseArray.sanitize (c, this, (unsigned int) classCount));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    return (this+markCoverage).intersects (glyphs) &&\n+           (this+baseCoverage).intersects (glyphs);\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    + hb_zip (this+markCoverage, this+markArray)\n+    | hb_filter (c->glyph_set, hb_first)\n+    | hb_map (hb_second)\n+    | hb_apply ([&] (const MarkRecord& record) { record.collect_variation_indices (c, &(this+markArray)); })\n+    ;\n+\n+    hb_map_t klass_mapping;\n+    Markclass_closure_and_remap_indexes (this+markCoverage, this+markArray, *c->glyph_set, &klass_mapping);\n+\n+    unsigned basecount = (this+baseArray).rows;\n+    auto base_iter =\n+    + hb_zip (this+baseCoverage, hb_range (basecount))\n+    | hb_filter (c->glyph_set, hb_first)\n+    | hb_map (hb_second)\n+    ;\n+\n+    hb_sorted_vector_t<unsigned> base_indexes;\n+    for (const unsigned row : base_iter)\n+    {\n+      + hb_range ((unsigned) classCount)\n+      | hb_filter (klass_mapping)\n+      | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n+      | hb_sink (base_indexes)\n+      ;\n+    }\n+    (this+baseArray).collect_variation_indices (c, base_indexes.iter ());\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+markCoverage).collect_coverage (c->input))) return;\n+    if (unlikely (!(this+baseCoverage).collect_coverage (c->input))) return;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+markCoverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (mark_index == NOT_COVERED)) return_trace (false);\n+\n+    \/* Now we search backwards for a non-mark glyph *\/\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n+    do {\n+      unsigned unsafe_from;\n+      if (!skippy_iter.prev (&unsafe_from))\n+      {\n+        buffer->unsafe_to_concat_from_outbuffer (unsafe_from, buffer->idx + 1);\n+        return_trace (false);\n+      }\n+\n+      \/* We only want to attach to the first of a MultipleSubst sequence.\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/740\n+       * Reject others...\n+       * ...but stop if we find a mark in the MultipleSubst sequence:\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1020 *\/\n+      if (!_hb_glyph_info_multiplied (&buffer->info[skippy_iter.idx]) ||\n+          0 == _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]) ||\n+          (skippy_iter.idx == 0 ||\n+           _hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx - 1]) ||\n+           _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx]) !=\n+           _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx - 1]) ||\n+           _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]) !=\n+           _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx - 1]) + 1\n+           ))\n+        break;\n+      skippy_iter.reject ();\n+    } while (true);\n+\n+    \/* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled *\/\n+    \/\/if (!_hb_glyph_info_is_base_glyph (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n+\n+    unsigned int base_index = (this+baseCoverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint);\n+    if (base_index == NOT_COVERED)\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->format = format;\n+\n+    hb_map_t klass_mapping;\n+    Markclass_closure_and_remap_indexes (this+markCoverage, this+markArray, glyphset, &klass_mapping);\n+\n+    if (!klass_mapping.get_population ()) return_trace (false);\n+    out->classCount = klass_mapping.get_population ();\n+\n+    auto mark_iter =\n+    + hb_zip (this+markCoverage, this+markArray)\n+    | hb_filter (glyphset, hb_first)\n+    ;\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+    + mark_iter\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+\n+    if (!out->markCoverage.serialize_serialize (c->serializer, new_coverage.iter ()))\n+      return_trace (false);\n+\n+    out->markArray.serialize_subset (c, markArray, this,\n+                                     (this+markCoverage).iter (),\n+                                     &klass_mapping);\n+\n+    unsigned basecount = (this+baseArray).rows;\n+    auto base_iter =\n+    + hb_zip (this+baseCoverage, hb_range (basecount))\n+    | hb_filter (glyphset, hb_first)\n+    ;\n+\n+    new_coverage.reset ();\n+    + base_iter\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+\n+    if (!out->baseCoverage.serialize_serialize (c->serializer, new_coverage.iter ()))\n+      return_trace (false);\n+\n+    hb_sorted_vector_t<unsigned> base_indexes;\n+    for (const unsigned row : + base_iter\n+                              | hb_map (hb_second))\n+    {\n+      + hb_range ((unsigned) classCount)\n+      | hb_filter (klass_mapping)\n+      | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n+      | hb_sink (base_indexes)\n+      ;\n+    }\n+\n+    out->baseArray.serialize_subset (c, baseArray, this,\n+                                     base_iter.len (),\n+                                     base_indexes.iter ());\n+\n+    return_trace (true);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_MARKBASEPOSFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkBasePosFormat1.hh","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+#ifndef OT_LAYOUT_GPOS_MARKLIGPOS_HH\n+#define OT_LAYOUT_GPOS_MARKLIGPOS_HH\n+\n+#include \"MarkLigPosFormat1.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct MarkLigPos\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MarkLigPosFormat1     format1;\n+  } u;\n+\n+  public:\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_MARKLIGPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkLigPos.hh","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+#ifndef OT_LAYOUT_GPOS_MARKLIGPOSFORMAT1_HH\n+#define OT_LAYOUT_GPOS_MARKLIGPOSFORMAT1_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+typedef AnchorMatrix LigatureAttach;    \/* component-major--\n+                                         * in order of writing direction--,\n+                                         * mark-minor--\n+                                         * ordered by class--zero-based. *\/\n+\n+\/* Array of LigatureAttach tables ordered by LigatureCoverage Index *\/\n+struct LigatureArray : List16OfOffset16To<LigatureAttach>\n+{\n+  template <typename Iterator,\n+            hb_requires (hb_is_iterator (Iterator))>\n+  bool subset (hb_subset_context_t *c,\n+               Iterator             coverage,\n+               unsigned             class_count,\n+               const hb_map_t      *klass_mapping) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n+\n+    for (const auto _ : + hb_zip (coverage, *this)\n+                  | hb_filter (glyphset, hb_first))\n+    {\n+      auto *matrix = out->serialize_append (c->serializer);\n+      if (unlikely (!matrix)) return_trace (false);\n+\n+      const LigatureAttach& src = (this + _.second);\n+      auto indexes =\n+          + hb_range (src.rows * class_count)\n+          | hb_filter ([=] (unsigned index) { return klass_mapping->has (index % class_count); })\n+          ;\n+      matrix->serialize_subset (c,\n+                                _.second,\n+                                this,\n+                                src.rows,\n+                                indexes);\n+    }\n+    return_trace (this->len);\n+  }\n+};\n+\n+struct MarkLigPosFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                markCoverage;           \/* Offset to Mark Coverage table--from\n+                                         * beginning of MarkLigPos subtable *\/\n+  Offset16To<Coverage>\n+                ligatureCoverage;       \/* Offset to Ligature Coverage\n+                                         * table--from beginning of MarkLigPos\n+                                         * subtable *\/\n+  HBUINT16      classCount;             \/* Number of defined mark classes *\/\n+  Offset16To<MarkArray>\n+                markArray;              \/* Offset to MarkArray table--from\n+                                         * beginning of MarkLigPos subtable *\/\n+  Offset16To<LigatureArray>\n+                ligatureArray;          \/* Offset to LigatureArray table--from\n+                                         * beginning of MarkLigPos subtable *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  markCoverage.sanitize (c, this) &&\n+                  ligatureCoverage.sanitize (c, this) &&\n+                  markArray.sanitize (c, this) &&\n+                  ligatureArray.sanitize (c, this, (unsigned int) classCount));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    return (this+markCoverage).intersects (glyphs) &&\n+           (this+ligatureCoverage).intersects (glyphs);\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    + hb_zip (this+markCoverage, this+markArray)\n+    | hb_filter (c->glyph_set, hb_first)\n+    | hb_map (hb_second)\n+    | hb_apply ([&] (const MarkRecord& record) { record.collect_variation_indices (c, &(this+markArray)); })\n+    ;\n+\n+    hb_map_t klass_mapping;\n+    Markclass_closure_and_remap_indexes (this+markCoverage, this+markArray, *c->glyph_set, &klass_mapping);\n+\n+    unsigned ligcount = (this+ligatureArray).len;\n+    auto lig_iter =\n+    + hb_zip (this+ligatureCoverage, hb_range (ligcount))\n+    | hb_filter (c->glyph_set, hb_first)\n+    | hb_map (hb_second)\n+    ;\n+\n+    const LigatureArray& lig_array = this+ligatureArray;\n+    for (const unsigned i : lig_iter)\n+    {\n+      hb_sorted_vector_t<unsigned> lig_indexes;\n+      unsigned row_count = lig_array[i].rows;\n+      for (unsigned row : + hb_range (row_count))\n+      {\n+        + hb_range ((unsigned) classCount)\n+        | hb_filter (klass_mapping)\n+        | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n+        | hb_sink (lig_indexes)\n+        ;\n+      }\n+\n+      lig_array[i].collect_variation_indices (c, lig_indexes.iter ());\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+markCoverage).collect_coverage (c->input))) return;\n+    if (unlikely (!(this+ligatureCoverage).collect_coverage (c->input))) return;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+markCoverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (mark_index == NOT_COVERED)) return_trace (false);\n+\n+    \/* Now we search backwards for a non-mark glyph *\/\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n+    unsigned unsafe_from;\n+    if (!skippy_iter.prev (&unsafe_from))\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (unsafe_from, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    \/* Checking that matched glyph is actually a ligature by GDEF is too strong; disabled *\/\n+    \/\/if (!_hb_glyph_info_is_ligature (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n+\n+    unsigned int j = skippy_iter.idx;\n+    unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer->info[j].codepoint);\n+    if (lig_index == NOT_COVERED)\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    const LigatureArray& lig_array = this+ligatureArray;\n+    const LigatureAttach& lig_attach = lig_array[lig_index];\n+\n+    \/* Find component to attach to *\/\n+    unsigned int comp_count = lig_attach.rows;\n+    if (unlikely (!comp_count))\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    \/* We must now check whether the ligature ID of the current mark glyph\n+     * is identical to the ligature ID of the found ligature.  If yes, we\n+     * can directly use the component index.  If not, we attach the mark\n+     * glyph to the last component of the ligature. *\/\n+    unsigned int comp_index;\n+    unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n+    unsigned int mark_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n+    unsigned int mark_comp = _hb_glyph_info_get_lig_comp (&buffer->cur());\n+    if (lig_id && lig_id == mark_id && mark_comp > 0)\n+      comp_index = hb_min (comp_count, _hb_glyph_info_get_lig_comp (&buffer->cur())) - 1;\n+    else\n+      comp_index = comp_count - 1;\n+\n+    return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->format = format;\n+\n+    hb_map_t klass_mapping;\n+    Markclass_closure_and_remap_indexes (this+markCoverage, this+markArray, glyphset, &klass_mapping);\n+\n+    if (!klass_mapping.get_population ()) return_trace (false);\n+    out->classCount = klass_mapping.get_population ();\n+\n+    auto mark_iter =\n+    + hb_zip (this+markCoverage, this+markArray)\n+    | hb_filter (glyphset, hb_first)\n+    ;\n+\n+    auto new_mark_coverage =\n+    + mark_iter\n+    | hb_map_retains_sorting (hb_first)\n+    | hb_map_retains_sorting (glyph_map)\n+    ;\n+\n+    if (!out->markCoverage.serialize_serialize (c->serializer, new_mark_coverage))\n+      return_trace (false);\n+\n+    out->markArray.serialize_subset (c, markArray, this,\n+                                     (this+markCoverage).iter (),\n+                                     &klass_mapping);\n+\n+    auto new_ligature_coverage =\n+    + hb_iter (this + ligatureCoverage)\n+    | hb_filter (glyphset)\n+    | hb_map_retains_sorting (glyph_map)\n+    ;\n+\n+    if (!out->ligatureCoverage.serialize_serialize (c->serializer, new_ligature_coverage))\n+      return_trace (false);\n+\n+    out->ligatureArray.serialize_subset (c, ligatureArray, this,\n+                                         hb_iter (this+ligatureCoverage), classCount, &klass_mapping);\n+\n+    return_trace (true);\n+  }\n+\n+};\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_MARKLIGPOSFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkLigPosFormat1.hh","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+#ifndef OT_LAYOUT_GPOS_MARKMARKPOS_HH\n+#define OT_LAYOUT_GPOS_MARKMARKPOS_HH\n+\n+#include \"MarkMarkPosFormat1.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct MarkMarkPos\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MarkMarkPosFormat1    format1;\n+  } u;\n+\n+  public:\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_MARKMARKPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkMarkPos.hh","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+#ifndef OT_LAYOUT_GPOS_MARKMARKPOSFORMAT1_HH\n+#define OT_LAYOUT_GPOS_MARKMARKPOSFORMAT1_HH\n+\n+#include \"MarkMarkPosFormat1.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+typedef AnchorMatrix Mark2Array;        \/* mark2-major--\n+                                         * in order of Mark2Coverage Index--,\n+                                         * mark1-minor--\n+                                         * ordered by class--zero-based. *\/\n+\n+struct MarkMarkPosFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                mark1Coverage;          \/* Offset to Combining Mark1 Coverage\n+                                         * table--from beginning of MarkMarkPos\n+                                         * subtable *\/\n+  Offset16To<Coverage>\n+                mark2Coverage;          \/* Offset to Combining Mark2 Coverage\n+                                         * table--from beginning of MarkMarkPos\n+                                         * subtable *\/\n+  HBUINT16      classCount;             \/* Number of defined mark classes *\/\n+  Offset16To<MarkArray>\n+                mark1Array;             \/* Offset to Mark1Array table--from\n+                                         * beginning of MarkMarkPos subtable *\/\n+  Offset16To<Mark2Array>\n+                mark2Array;             \/* Offset to Mark2Array table--from\n+                                         * beginning of MarkMarkPos subtable *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  mark1Coverage.sanitize (c, this) &&\n+                  mark2Coverage.sanitize (c, this) &&\n+                  mark1Array.sanitize (c, this) &&\n+                  mark2Array.sanitize (c, this, (unsigned int) classCount));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    return (this+mark1Coverage).intersects (glyphs) &&\n+           (this+mark2Coverage).intersects (glyphs);\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    + hb_zip (this+mark1Coverage, this+mark1Array)\n+    | hb_filter (c->glyph_set, hb_first)\n+    | hb_map (hb_second)\n+    | hb_apply ([&] (const MarkRecord& record) { record.collect_variation_indices (c, &(this+mark1Array)); })\n+    ;\n+\n+    hb_map_t klass_mapping;\n+    Markclass_closure_and_remap_indexes (this+mark1Coverage, this+mark1Array, *c->glyph_set, &klass_mapping);\n+\n+    unsigned mark2_count = (this+mark2Array).rows;\n+    auto mark2_iter =\n+    + hb_zip (this+mark2Coverage, hb_range (mark2_count))\n+    | hb_filter (c->glyph_set, hb_first)\n+    | hb_map (hb_second)\n+    ;\n+\n+    hb_sorted_vector_t<unsigned> mark2_indexes;\n+    for (const unsigned row : mark2_iter)\n+    {\n+      + hb_range ((unsigned) classCount)\n+      | hb_filter (klass_mapping)\n+      | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n+      | hb_sink (mark2_indexes)\n+      ;\n+    }\n+    (this+mark2Array).collect_variation_indices (c, mark2_indexes.iter ());\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+mark1Coverage).collect_coverage (c->input))) return;\n+    if (unlikely (!(this+mark2Coverage).collect_coverage (c->input))) return;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+mark1Coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (mark1_index == NOT_COVERED)) return_trace (false);\n+\n+    \/* now we search backwards for a suitable mark glyph until a non-mark glyph *\/\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    skippy_iter.set_lookup_props (c->lookup_props & ~LookupFlag::IgnoreFlags);\n+    unsigned unsafe_from;\n+    if (!skippy_iter.prev (&unsafe_from))\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (unsafe_from, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    if (!_hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx]))\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    unsigned int j = skippy_iter.idx;\n+\n+    unsigned int id1 = _hb_glyph_info_get_lig_id (&buffer->cur());\n+    unsigned int id2 = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n+    unsigned int comp1 = _hb_glyph_info_get_lig_comp (&buffer->cur());\n+    unsigned int comp2 = _hb_glyph_info_get_lig_comp (&buffer->info[j]);\n+\n+    if (likely (id1 == id2))\n+    {\n+      if (id1 == 0) \/* Marks belonging to the same base. *\/\n+        goto good;\n+      else if (comp1 == comp2) \/* Marks belonging to the same ligature component. *\/\n+        goto good;\n+    }\n+    else\n+    {\n+      \/* If ligature ids don't match, it may be the case that one of the marks\n+       * itself is a ligature.  In which case match. *\/\n+      if ((id1 > 0 && !comp1) || (id2 > 0 && !comp2))\n+        goto good;\n+    }\n+\n+    \/* Didn't match. *\/\n+    buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+    return_trace (false);\n+\n+    good:\n+    unsigned int mark2_index = (this+mark2Coverage).get_coverage  (buffer->info[j].codepoint);\n+    if (mark2_index == NOT_COVERED)\n+    {\n+      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      return_trace (false);\n+    }\n+\n+    return_trace ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->format = format;\n+\n+    hb_map_t klass_mapping;\n+    Markclass_closure_and_remap_indexes (this+mark1Coverage, this+mark1Array, glyphset, &klass_mapping);\n+\n+    if (!klass_mapping.get_population ()) return_trace (false);\n+    out->classCount = klass_mapping.get_population ();\n+\n+    auto mark1_iter =\n+    + hb_zip (this+mark1Coverage, this+mark1Array)\n+    | hb_filter (glyphset, hb_first)\n+    ;\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+    + mark1_iter\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+\n+    if (!out->mark1Coverage.serialize_serialize (c->serializer, new_coverage.iter ()))\n+      return_trace (false);\n+\n+    out->mark1Array.serialize_subset (c, mark1Array, this,\n+                                      (this+mark1Coverage).iter (),\n+                                      &klass_mapping);\n+\n+    unsigned mark2count = (this+mark2Array).rows;\n+    auto mark2_iter =\n+    + hb_zip (this+mark2Coverage, hb_range (mark2count))\n+    | hb_filter (glyphset, hb_first)\n+    ;\n+\n+    new_coverage.reset ();\n+    + mark2_iter\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+\n+    if (!out->mark2Coverage.serialize_serialize (c->serializer, new_coverage.iter ()))\n+      return_trace (false);\n+\n+    hb_sorted_vector_t<unsigned> mark2_indexes;\n+    for (const unsigned row : + mark2_iter\n+                              | hb_map (hb_second))\n+    {\n+      + hb_range ((unsigned) classCount)\n+      | hb_filter (klass_mapping)\n+      | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n+      | hb_sink (mark2_indexes)\n+      ;\n+    }\n+\n+    out->mark2Array.serialize_subset (c, mark2Array, this, mark2_iter.len (), mark2_indexes.iter ());\n+\n+    return_trace (true);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_MARKMARKPOSFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkMarkPosFormat1.hh","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+#ifndef OT_LAYOUT_GPOS_MARKRECORD_HH\n+#define OT_LAYOUT_GPOS_MARKRECORD_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct MarkRecord\n+{\n+  friend struct MarkArray;\n+\n+  protected:\n+  HBUINT16      klass;                  \/* Class defined for this mark *\/\n+  Offset16To<Anchor>\n+                markAnchor;             \/* Offset to Anchor table--from\n+                                         * beginning of MarkArray table *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+\n+  unsigned get_class () const { return (unsigned) klass; }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && markAnchor.sanitize (c, base));\n+  }\n+\n+  MarkRecord *subset (hb_subset_context_t    *c,\n+                      const void             *src_base,\n+                      const hb_map_t         *klass_mapping) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+\n+    out->klass = klass_mapping->get (klass);\n+    out->markAnchor.serialize_subset (c, markAnchor, src_base);\n+    return_trace (out);\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n+                                  const void *src_base) const\n+  {\n+    (src_base+markAnchor).collect_variation_indices (c);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_MARKRECORD_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkRecord.hh","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+#ifndef OT_LAYOUT_GPOS_PAIRPOS_HH\n+#define OT_LAYOUT_GPOS_PAIRPOS_HH\n+\n+#include \"PairPosFormat1.hh\"\n+#include \"PairPosFormat2.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct PairPos\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  PairPosFormat1        format1;\n+  PairPosFormat2        format2;\n+  } u;\n+\n+  public:\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_PAIRPOS_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairPos.hh","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,420 @@\n+#ifndef OT_LAYOUT_GPOS_PAIRPOSFORMAT1_HH\n+#define OT_LAYOUT_GPOS_PAIRPOSFORMAT1_HH\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct PairValueRecord\n+{\n+  friend struct PairSet;\n+\n+  int cmp (hb_codepoint_t k) const\n+  { return secondGlyph.cmp (k); }\n+\n+  struct context_t\n+  {\n+    const void          *base;\n+    const ValueFormat   *valueFormats;\n+    const ValueFormat   *newFormats;\n+    unsigned            len1; \/* valueFormats[0].get_len() *\/\n+    const hb_map_t      *glyph_map;\n+    const hb_map_t      *layout_variation_idx_map;\n+  };\n+\n+  bool subset (hb_subset_context_t *c,\n+               context_t *closure) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *s = c->serializer;\n+    auto *out = s->start_embed (*this);\n+    if (unlikely (!s->extend_min (out))) return_trace (false);\n+\n+    out->secondGlyph = (*closure->glyph_map)[secondGlyph];\n+\n+    closure->valueFormats[0].copy_values (s,\n+                                          closure->newFormats[0],\n+                                          closure->base, &values[0],\n+                                          closure->layout_variation_idx_map);\n+    closure->valueFormats[1].copy_values (s,\n+                                          closure->newFormats[1],\n+                                          closure->base,\n+                                          &values[closure->len1],\n+                                          closure->layout_variation_idx_map);\n+\n+    return_trace (true);\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n+                                  const ValueFormat *valueFormats,\n+                                  const void *base) const\n+  {\n+    unsigned record1_len = valueFormats[0].get_len ();\n+    unsigned record2_len = valueFormats[1].get_len ();\n+    const hb_array_t<const Value> values_array = values.as_array (record1_len + record2_len);\n+\n+    if (valueFormats[0].has_device ())\n+      valueFormats[0].collect_variation_indices (c, base, values_array.sub_array (0, record1_len));\n+\n+    if (valueFormats[1].has_device ())\n+      valueFormats[1].collect_variation_indices (c, base, values_array.sub_array (record1_len, record2_len));\n+  }\n+\n+  bool intersects (const hb_set_t& glyphset) const\n+  {\n+    return glyphset.has(secondGlyph);\n+  }\n+\n+  const Value* get_values_1 () const\n+  {\n+    return &values[0];\n+  }\n+\n+  const Value* get_values_2 (ValueFormat format1) const\n+  {\n+    return &values[format1.get_len ()];\n+  }\n+\n+  protected:\n+  HBGlyphID16   secondGlyph;            \/* GlyphID of second glyph in the\n+                                         * pair--first glyph is listed in the\n+                                         * Coverage table *\/\n+  ValueRecord   values;                 \/* Positioning data for the first glyph\n+                                         * followed by for second glyph *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, values);\n+};\n+\n+struct PairSet\n+{\n+  friend struct PairPosFormat1;\n+\n+  bool intersects (const hb_set_t *glyphs,\n+                   const ValueFormat *valueFormats) const\n+  {\n+    unsigned int len1 = valueFormats[0].get_len ();\n+    unsigned int len2 = valueFormats[1].get_len ();\n+    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    unsigned int count = len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (glyphs->has (record->secondGlyph))\n+        return true;\n+      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n+    }\n+    return false;\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c,\n+                       const ValueFormat *valueFormats) const\n+  {\n+    unsigned int len1 = valueFormats[0].get_len ();\n+    unsigned int len2 = valueFormats[1].get_len ();\n+    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    c->input->add_array (&record->secondGlyph, len, record_size);\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n+                                  const ValueFormat *valueFormats) const\n+  {\n+    unsigned len1 = valueFormats[0].get_len ();\n+    unsigned len2 = valueFormats[1].get_len ();\n+    unsigned record_size = HBUINT16::static_size * (1 + len1 + len2);\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    unsigned count = len;\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      if (c->glyph_set->has (record->secondGlyph))\n+      { record->collect_variation_indices (c, valueFormats, this); }\n+\n+      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n+    }\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c,\n+              const ValueFormat *valueFormats,\n+              unsigned int pos) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int len1 = valueFormats[0].get_len ();\n+    unsigned int len2 = valueFormats[1].get_len ();\n+    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n+\n+    const PairValueRecord *record = hb_bsearch (buffer->info[pos].codepoint,\n+                                                &firstPairValueRecord,\n+                                                len,\n+                                                record_size);\n+    if (record)\n+    {\n+      bool applied_first = valueFormats[0].apply_value (c, this, &record->values[0], buffer->cur_pos());\n+      bool applied_second = valueFormats[1].apply_value (c, this, &record->values[len1], buffer->pos[pos]);\n+      if (applied_first || applied_second)\n+        buffer->unsafe_to_break (buffer->idx, pos + 1);\n+      if (len2)\n+        pos++;\n+      buffer->idx = pos;\n+      return_trace (true);\n+    }\n+    buffer->unsafe_to_concat (buffer->idx, pos + 1);\n+    return_trace (false);\n+  }\n+\n+  bool subset (hb_subset_context_t *c,\n+               const ValueFormat valueFormats[2],\n+               const ValueFormat newFormats[2]) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto snap = c->serializer->snapshot ();\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->len = 0;\n+\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    unsigned len1 = valueFormats[0].get_len ();\n+    unsigned len2 = valueFormats[1].get_len ();\n+    unsigned record_size = HBUINT16::static_size + Value::static_size * (len1 + len2);\n+\n+    PairValueRecord::context_t context =\n+    {\n+      this,\n+      valueFormats,\n+      newFormats,\n+      len1,\n+      &glyph_map,\n+      c->plan->layout_variation_idx_map\n+    };\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    unsigned count = len, num = 0;\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      if (glyphset.has (record->secondGlyph)\n+         && record->subset (c, &context)) num++;\n+      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n+    }\n+\n+    out->len = num;\n+    if (!num) c->serializer->revert (snap);\n+    return_trace (num);\n+  }\n+\n+  struct sanitize_closure_t\n+  {\n+    const ValueFormat *valueFormats;\n+    unsigned int len1; \/* valueFormats[0].get_len() *\/\n+    unsigned int stride; \/* 1 + len1 + len2 *\/\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!(c->check_struct (this)\n+       && c->check_range (&firstPairValueRecord,\n+                          len,\n+                          HBUINT16::static_size,\n+                          closure->stride))) return_trace (false);\n+\n+    unsigned int count = len;\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    return_trace (closure->valueFormats[0].sanitize_values_stride_unsafe (c, this, &record->values[0], count, closure->stride) &&\n+                  closure->valueFormats[1].sanitize_values_stride_unsafe (c, this, &record->values[closure->len1], count, closure->stride));\n+  }\n+\n+  protected:\n+  HBUINT16              len;    \/* Number of PairValueRecords *\/\n+  PairValueRecord       firstPairValueRecord;\n+                                \/* Array of PairValueRecords--ordered\n+                                 * by GlyphID of the second glyph *\/\n+  public:\n+  DEFINE_SIZE_MIN (2);\n+};\n+\n+struct PairPosFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  ValueFormat   valueFormat[2];         \/* [0] Defines the types of data in\n+                                         * ValueRecord1--for the first glyph\n+                                         * in the pair--may be zero (0) *\/\n+                                        \/* [1] Defines the types of data in\n+                                         * ValueRecord2--for the second glyph\n+                                         * in the pair--may be zero (0) *\/\n+  Array16OfOffset16To<PairSet>\n+                pairSet;                \/* Array of PairSet tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (10, pairSet);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    if (!c->check_struct (this)) return_trace (false);\n+\n+    unsigned int len1 = valueFormat[0].get_len ();\n+    unsigned int len2 = valueFormat[1].get_len ();\n+    PairSet::sanitize_closure_t closure =\n+    {\n+      valueFormat,\n+      len1,\n+      1 + len1 + len2\n+    };\n+\n+    return_trace (coverage.sanitize (c, this) && pairSet.sanitize (c, this, &closure));\n+  }\n+\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    return\n+    + hb_zip (this+coverage, pairSet)\n+    | hb_filter (*glyphs, hb_first)\n+    | hb_map (hb_second)\n+    | hb_map ([glyphs, this] (const Offset16To<PairSet> &_)\n+              { return (this+_).intersects (glyphs, valueFormat); })\n+    | hb_any\n+    ;\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    if ((!valueFormat[0].has_device ()) && (!valueFormat[1].has_device ())) return;\n+\n+    auto it =\n+    + hb_zip (this+coverage, pairSet)\n+    | hb_filter (c->glyph_set, hb_first)\n+    | hb_map (hb_second)\n+    ;\n+\n+    if (!it) return;\n+    + it\n+    | hb_map (hb_add (this))\n+    | hb_apply ([&] (const PairSet& _) { _.collect_variation_indices (c, valueFormat); })\n+    ;\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n+    unsigned int count = pairSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      (this+pairSet[i]).collect_glyphs (c, valueFormat);\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    unsigned unsafe_to;\n+    if (!skippy_iter.next (&unsafe_to))\n+    {\n+      buffer->unsafe_to_concat (buffer->idx, unsafe_to);\n+      return_trace (false);\n+    }\n+\n+    return_trace ((this+pairSet[index]).apply (c, valueFormat, skippy_iter.idx));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->format = format;\n+    out->valueFormat[0] = valueFormat[0];\n+    out->valueFormat[1] = valueFormat[1];\n+    if (c->plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n+    {\n+      hb_pair_t<unsigned, unsigned> newFormats = compute_effective_value_formats (glyphset);\n+      out->valueFormat[0] = newFormats.first;\n+      out->valueFormat[1] = newFormats.second;\n+    }\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+\n+    + hb_zip (this+coverage, pairSet)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter ([this, c, out] (const Offset16To<PairSet>& _)\n+                 {\n+                   auto snap = c->serializer->snapshot ();\n+                   auto *o = out->pairSet.serialize_append (c->serializer);\n+                   if (unlikely (!o)) return false;\n+                   bool ret = o->serialize_subset (c, _, this, valueFormat, out->valueFormat);\n+                   if (!ret)\n+                   {\n+                     out->pairSet.pop ();\n+                     c->serializer->revert (snap);\n+                   }\n+                   return ret;\n+                 },\n+                 hb_second)\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n+\n+    return_trace (bool (new_coverage));\n+  }\n+\n+\n+  hb_pair_t<unsigned, unsigned> compute_effective_value_formats (const hb_set_t& glyphset) const\n+  {\n+    unsigned len1 = valueFormat[0].get_len ();\n+    unsigned len2 = valueFormat[1].get_len ();\n+    unsigned record_size = HBUINT16::static_size + Value::static_size * (len1 + len2);\n+\n+    unsigned format1 = 0;\n+    unsigned format2 = 0;\n+    for (const Offset16To<PairSet>& _ :\n+             + hb_zip (this+coverage, pairSet) | hb_filter (glyphset, hb_first) | hb_map (hb_second))\n+    {\n+      const PairSet& set = (this + _);\n+      const PairValueRecord *record = &set.firstPairValueRecord;\n+\n+      for (unsigned i = 0; i < set.len; i++)\n+      {\n+        if (record->intersects (glyphset))\n+        {\n+          format1 = format1 | valueFormat[0].get_effective_format (record->get_values_1 ());\n+          format2 = format2 | valueFormat[1].get_effective_format (record->get_values_2 (valueFormat[0]));\n+        }\n+        record = &StructAtOffset<const PairValueRecord> (record, record_size);\n+      }\n+    }\n+\n+    return hb_pair (format1, format2);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_PAIRPOSFORMAT1_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairPosFormat1.hh","additions":420,"deletions":0,"binary":false,"changes":420,"status":"added"},{"patch":"@@ -0,0 +1,314 @@\n+#ifndef OT_LAYOUT_GPOS_PAIRPOSFORMAT2_HH\n+#define OT_LAYOUT_GPOS_PAIRPOSFORMAT2_HH\n+\n+#include \"ValueFormat.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct PairPosFormat2\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  ValueFormat   valueFormat1;           \/* ValueRecord definition--for the\n+                                         * first glyph of the pair--may be zero\n+                                         * (0) *\/\n+  ValueFormat   valueFormat2;           \/* ValueRecord definition--for the\n+                                         * second glyph of the pair--may be\n+                                         * zero (0) *\/\n+  Offset16To<ClassDef>\n+                classDef1;              \/* Offset to ClassDef table--from\n+                                         * beginning of PairPos subtable--for\n+                                         * the first glyph of the pair *\/\n+  Offset16To<ClassDef>\n+                classDef2;              \/* Offset to ClassDef table--from\n+                                         * beginning of PairPos subtable--for\n+                                         * the second glyph of the pair *\/\n+  HBUINT16      class1Count;            \/* Number of classes in ClassDef1\n+                                         * table--includes Class0 *\/\n+  HBUINT16      class2Count;            \/* Number of classes in ClassDef2\n+                                         * table--includes Class0 *\/\n+  ValueRecord   values;                 \/* Matrix of value pairs:\n+                                         * class1-major, class2-minor,\n+                                         * Each entry has value1 and value2 *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (16, values);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!(c->check_struct (this)\n+       && coverage.sanitize (c, this)\n+       && classDef1.sanitize (c, this)\n+       && classDef2.sanitize (c, this))) return_trace (false);\n+\n+    unsigned int len1 = valueFormat1.get_len ();\n+    unsigned int len2 = valueFormat2.get_len ();\n+    unsigned int stride = len1 + len2;\n+    unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();\n+    unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;\n+    return_trace (c->check_range ((const void *) values,\n+                                  count,\n+                                  record_size) &&\n+                  valueFormat1.sanitize_values_stride_unsafe (c, this, &values[0], count, stride) &&\n+                  valueFormat2.sanitize_values_stride_unsafe (c, this, &values[len1], count, stride));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    return (this+coverage).intersects (glyphs) &&\n+           (this+classDef2).intersects (glyphs);\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    if (!intersects (c->glyph_set)) return;\n+    if ((!valueFormat1.has_device ()) && (!valueFormat2.has_device ())) return;\n+\n+    hb_set_t klass1_glyphs, klass2_glyphs;\n+    if (!(this+classDef1).collect_coverage (&klass1_glyphs)) return;\n+    if (!(this+classDef2).collect_coverage (&klass2_glyphs)) return;\n+\n+    hb_set_t class1_set, class2_set;\n+    for (const unsigned cp : + c->glyph_set->iter () | hb_filter (this + coverage))\n+    {\n+      if (!klass1_glyphs.has (cp)) class1_set.add (0);\n+      else\n+      {\n+        unsigned klass1 = (this+classDef1).get (cp);\n+        class1_set.add (klass1);\n+      }\n+    }\n+\n+    class2_set.add (0);\n+    for (const unsigned cp : + c->glyph_set->iter () | hb_filter (klass2_glyphs))\n+    {\n+      unsigned klass2 = (this+classDef2).get (cp);\n+      class2_set.add (klass2);\n+    }\n+\n+    if (class1_set.is_empty ()\n+        || class2_set.is_empty ()\n+        || (class2_set.get_population() == 1 && class2_set.has(0)))\n+      return;\n+\n+    unsigned len1 = valueFormat1.get_len ();\n+    unsigned len2 = valueFormat2.get_len ();\n+    const hb_array_t<const Value> values_array = values.as_array ((unsigned)class1Count * (unsigned) class2Count * (len1 + len2));\n+    for (const unsigned class1_idx : class1_set.iter ())\n+    {\n+      for (const unsigned class2_idx : class2_set.iter ())\n+      {\n+        unsigned start_offset = (class1_idx * (unsigned) class2Count + class2_idx) * (len1 + len2);\n+        if (valueFormat1.has_device ())\n+          valueFormat1.collect_variation_indices (c, this, values_array.sub_array (start_offset, len1));\n+\n+        if (valueFormat2.has_device ())\n+          valueFormat2.collect_variation_indices (c, this, values_array.sub_array (start_offset+len1, len2));\n+      }\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n+    if (unlikely (!(this+classDef2).collect_coverage (c->input))) return;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    unsigned unsafe_to;\n+    if (!skippy_iter.next (&unsafe_to))\n+    {\n+      buffer->unsafe_to_concat (buffer->idx, unsafe_to);\n+      return_trace (false);\n+    }\n+\n+    unsigned int len1 = valueFormat1.get_len ();\n+    unsigned int len2 = valueFormat2.get_len ();\n+    unsigned int record_len = len1 + len2;\n+\n+    unsigned int klass1 = (this+classDef1).get_class (buffer->cur().codepoint);\n+    unsigned int klass2 = (this+classDef2).get_class (buffer->info[skippy_iter.idx].codepoint);\n+    if (unlikely (klass1 >= class1Count || klass2 >= class2Count))\n+    {\n+      buffer->unsafe_to_concat (buffer->idx, skippy_iter.idx + 1);\n+      return_trace (false);\n+    }\n+\n+    const Value *v = &values[record_len * (klass1 * class2Count + klass2)];\n+\n+    bool applied_first = false, applied_second = false;\n+\n+\n+    \/* Isolate simple kerning and apply it half to each side.\n+     * Results in better cursor positinoing \/ underline drawing.\n+     *\n+     * Disabled, because causes issues... :-(\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3408\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/3235#issuecomment-1029814978\n+     *\/\n+#ifndef HB_SPLIT_KERN\n+    if (0)\n+#endif\n+    {\n+      if (!len2)\n+      {\n+        const hb_direction_t dir = buffer->props.direction;\n+        const bool horizontal = HB_DIRECTION_IS_HORIZONTAL (dir);\n+        const bool backward = HB_DIRECTION_IS_BACKWARD (dir);\n+        unsigned mask = horizontal ? ValueFormat::xAdvance : ValueFormat::yAdvance;\n+        if (backward)\n+          mask |= mask >> 2; \/* Add eg. xPlacement in RTL. *\/\n+        \/* Add Devices. *\/\n+        mask |= mask << 4;\n+\n+        if (valueFormat1 & ~mask)\n+          goto bail;\n+\n+        \/* Is simple kern. Apply value on an empty position slot,\n+         * then split it between sides. *\/\n+\n+        hb_glyph_position_t pos{};\n+        if (valueFormat1.apply_value (c, this, v, pos))\n+        {\n+          hb_position_t *src  = &pos.x_advance;\n+          hb_position_t *dst1 = &buffer->cur_pos().x_advance;\n+          hb_position_t *dst2 = &buffer->pos[skippy_iter.idx].x_advance;\n+          unsigned i = horizontal ? 0 : 1;\n+\n+          hb_position_t kern  = src[i];\n+          hb_position_t kern1 = kern >> 1;\n+          hb_position_t kern2 = kern - kern1;\n+\n+          if (!backward)\n+          {\n+            dst1[i] += kern1;\n+            dst2[i] += kern2;\n+            dst2[i + 2] += kern2;\n+          }\n+          else\n+          {\n+            dst1[i] += kern1;\n+            dst1[i + 2] += src[i + 2] - kern2;\n+            dst2[i] += kern2;\n+          }\n+\n+          applied_first = applied_second = kern != 0;\n+          goto success;\n+        }\n+        goto boring;\n+      }\n+    }\n+    bail:\n+\n+\n+    applied_first = valueFormat1.apply_value (c, this, v, buffer->cur_pos());\n+    applied_second = valueFormat2.apply_value (c, this, v + len1, buffer->pos[skippy_iter.idx]);\n+\n+    success:\n+    if (applied_first || applied_second)\n+      buffer->unsafe_to_break (buffer->idx, skippy_iter.idx + 1);\n+    else\n+    boring:\n+      buffer->unsafe_to_concat (buffer->idx, skippy_iter.idx + 1);\n+\n+\n+    buffer->idx = skippy_iter.idx;\n+    if (len2)\n+      buffer->idx++;\n+\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->format = format;\n+\n+    hb_map_t klass1_map;\n+    out->classDef1.serialize_subset (c, classDef1, this, &klass1_map, true, true, &(this + coverage));\n+    out->class1Count = klass1_map.get_population ();\n+\n+    hb_map_t klass2_map;\n+    out->classDef2.serialize_subset (c, classDef2, this, &klass2_map, true, false);\n+    out->class2Count = klass2_map.get_population ();\n+\n+    unsigned len1 = valueFormat1.get_len ();\n+    unsigned len2 = valueFormat2.get_len ();\n+\n+    hb_pair_t<unsigned, unsigned> newFormats = hb_pair (valueFormat1, valueFormat2);\n+    if (c->plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n+      newFormats = compute_effective_value_formats (klass1_map, klass2_map);\n+\n+    out->valueFormat1 = newFormats.first;\n+    out->valueFormat2 = newFormats.second;\n+\n+    for (unsigned class1_idx : + hb_range ((unsigned) class1Count) | hb_filter (klass1_map))\n+    {\n+      for (unsigned class2_idx : + hb_range ((unsigned) class2Count) | hb_filter (klass2_map))\n+      {\n+        unsigned idx = (class1_idx * (unsigned) class2Count + class2_idx) * (len1 + len2);\n+        valueFormat1.copy_values (c->serializer, newFormats.first, this, &values[idx], c->plan->layout_variation_idx_map);\n+        valueFormat2.copy_values (c->serializer, newFormats.second, this, &values[idx + len1], c->plan->layout_variation_idx_map);\n+      }\n+    }\n+\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto it =\n+    + hb_iter (this+coverage)\n+    | hb_filter (glyphset)\n+    | hb_map_retains_sorting (glyph_map)\n+    ;\n+\n+    out->coverage.serialize_serialize (c->serializer, it);\n+    return_trace (out->class1Count && out->class2Count && bool (it));\n+  }\n+\n+\n+  hb_pair_t<unsigned, unsigned> compute_effective_value_formats (const hb_map_t& klass1_map,\n+                                                                 const hb_map_t& klass2_map) const\n+  {\n+    unsigned len1 = valueFormat1.get_len ();\n+    unsigned len2 = valueFormat2.get_len ();\n+\n+    unsigned format1 = 0;\n+    unsigned format2 = 0;\n+\n+    for (unsigned class1_idx : + hb_range ((unsigned) class1Count) | hb_filter (klass1_map))\n+    {\n+      for (unsigned class2_idx : + hb_range ((unsigned) class2Count) | hb_filter (klass2_map))\n+      {\n+        unsigned idx = (class1_idx * (unsigned) class2Count + class2_idx) * (len1 + len2);\n+        format1 = format1 | valueFormat1.get_effective_format (&values[idx]);\n+        format2 = format2 | valueFormat2.get_effective_format (&values[idx + len1]);\n+      }\n+    }\n+\n+    return hb_pair (format1, format2);\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ OT_LAYOUT_GPOS_PAIRPOSFORMAT2_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairPosFormat2.hh","additions":314,"deletions":0,"binary":false,"changes":314,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+#ifndef OT_LAYOUT_GPOS_POSLOOKUP_HH\n+#define OT_LAYOUT_GPOS_POSLOOKUP_HH\n+\n+#include \"PosLookupSubTable.hh\"\n+#include \"..\/..\/..\/hb-ot-layout-common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct PosLookup : Lookup\n+{\n+  using SubTable = PosLookupSubTable;\n+\n+  const SubTable& get_subtable (unsigned int i) const\n+  { return Lookup::get_subtable<SubTable> (i); }\n+\n+  bool is_reverse () const\n+  {\n+    return false;\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    return_trace (dispatch (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    hb_intersects_context_t c (glyphs);\n+    return dispatch (&c);\n+  }\n+\n+  hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { return dispatch (c); }\n+\n+  hb_closure_lookups_context_t::return_t closure_lookups (hb_closure_lookups_context_t *c, unsigned this_index) const\n+  {\n+    if (c->is_lookup_visited (this_index))\n+      return hb_closure_lookups_context_t::default_return_value ();\n+\n+    c->set_lookup_visited (this_index);\n+    if (!intersects (c->glyphs))\n+    {\n+      c->set_lookup_inactive (this_index);\n+      return hb_closure_lookups_context_t::default_return_value ();\n+    }\n+\n+    hb_closure_lookups_context_t::return_t ret = dispatch (c);\n+    return ret;\n+  }\n+\n+  template <typename set_t>\n+  void collect_coverage (set_t *glyphs) const\n+  {\n+    hb_collect_coverage_context_t<set_t> c (glyphs);\n+    dispatch (&c);\n+  }\n+\n+  template <typename context_t>\n+  static typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  { return Lookup::dispatch<SubTable> (c, std::forward<Ts> (ds)...); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  { return Lookup::subset<SubTable> (c); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  { return Lookup::sanitize<SubTable> (c); }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GPOS_POSLOOKUP_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PosLookup.hh","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+#ifndef OT_LAYOUT_GPOS_POSLOOKUPSUBTABLE_HH\n+#define OT_LAYOUT_GPOS_POSLOOKUPSUBTABLE_HH\n+\n+#include \"SinglePos.hh\"\n+#include \"PairPos.hh\"\n+#include \"CursivePos.hh\"\n+#include \"MarkBasePos.hh\"\n+#include \"MarkLigPos.hh\"\n+#include \"MarkMarkPos.hh\"\n+#include \"ContextPos.hh\"\n+#include \"ChainContextPos.hh\"\n+#include \"ExtensionPos.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct PosLookupSubTable\n+{\n+  friend struct ::OT::Lookup;\n+  friend struct PosLookup;\n+\n+  enum Type {\n+    Single              = 1,\n+    Pair                = 2,\n+    Cursive             = 3,\n+    MarkBase            = 4,\n+    MarkLig             = 5,\n+    MarkMark            = 6,\n+    Context             = 7,\n+    ChainContext        = 8,\n+    Extension           = 9\n+  };\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, lookup_type);\n+    switch (lookup_type) {\n+    case Single:                return_trace (u.single.dispatch (c, std::forward<Ts> (ds)...));\n+    case Pair:                  return_trace (u.pair.dispatch (c, std::forward<Ts> (ds)...));\n+    case Cursive:               return_trace (u.cursive.dispatch (c, std::forward<Ts> (ds)...));\n+    case MarkBase:              return_trace (u.markBase.dispatch (c, std::forward<Ts> (ds)...));\n+    case MarkLig:               return_trace (u.markLig.dispatch (c, std::forward<Ts> (ds)...));\n+    case MarkMark:              return_trace (u.markMark.dispatch (c, std::forward<Ts> (ds)...));\n+    case Context:               return_trace (u.context.dispatch (c, std::forward<Ts> (ds)...));\n+    case ChainContext:          return_trace (u.chainContext.dispatch (c, std::forward<Ts> (ds)...));\n+    case Extension:             return_trace (u.extension.dispatch (c, std::forward<Ts> (ds)...));\n+    default:                    return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs, unsigned int lookup_type) const\n+  {\n+    hb_intersects_context_t c (glyphs);\n+    return dispatch (&c, lookup_type);\n+  }\n+\n+  protected:\n+  union {\n+  SinglePos             single;\n+  PairPos               pair;\n+  CursivePos            cursive;\n+  MarkBasePos           markBase;\n+  MarkLigPos            markLig;\n+  MarkMarkPos           markMark;\n+  ContextPos            context;\n+  ChainContextPos       chainContext;\n+  ExtensionPos          extension;\n+  } u;\n+  public:\n+  DEFINE_SIZE_MIN (0);\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/* HB_OT_LAYOUT_GPOS_POSLOOKUPSUBTABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PosLookupSubTable.hh","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+#ifndef OT_LAYOUT_GPOS_SINGLEPOS_HH\n+#define OT_LAYOUT_GPOS_SINGLEPOS_HH\n+\n+#include \"SinglePosFormat1.hh\"\n+#include \"SinglePosFormat2.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct SinglePos\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  SinglePosFormat1      format1;\n+  SinglePosFormat2      format2;\n+  } u;\n+\n+  public:\n+  template<typename Iterator,\n+           hb_requires (hb_is_iterator (Iterator))>\n+  unsigned get_format (Iterator glyph_val_iter_pairs)\n+  {\n+    hb_array_t<const Value> first_val_iter = hb_second (*glyph_val_iter_pairs);\n+\n+    for (const auto iter : glyph_val_iter_pairs)\n+      for (const auto _ : hb_zip (iter.second, first_val_iter))\n+        if (_.first != _.second)\n+          return 2;\n+\n+    return 1;\n+  }\n+\n+  template<typename Iterator,\n+      typename SrcLookup,\n+      hb_requires (hb_is_iterator (Iterator))>\n+  void serialize (hb_serialize_context_t *c,\n+                  const SrcLookup* src,\n+                  Iterator glyph_val_iter_pairs,\n+                  const hb_map_t *layout_variation_idx_map)\n+  {\n+    if (unlikely (!c->extend_min (u.format))) return;\n+    unsigned format = 2;\n+    ValueFormat new_format = src->get_value_format ();\n+\n+    if (glyph_val_iter_pairs)\n+    {\n+      format = get_format (glyph_val_iter_pairs);\n+      new_format = src->get_value_format ().get_effective_format (+ glyph_val_iter_pairs | hb_map (hb_second));\n+    }\n+\n+    u.format = format;\n+    switch (u.format) {\n+    case 1: u.format1.serialize (c,\n+                                 src,\n+                                 glyph_val_iter_pairs,\n+                                 new_format,\n+                                 layout_variation_idx_map);\n+      return;\n+    case 2: u.format2.serialize (c,\n+                                 src,\n+                                 glyph_val_iter_pairs,\n+                                 new_format,\n+                                 layout_variation_idx_map);\n+      return;\n+    default:return;\n+    }\n+  }\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+};\n+\n+\n+template<typename Iterator, typename SrcLookup>\n+static void\n+SinglePos_serialize (hb_serialize_context_t *c,\n+                     const SrcLookup *src,\n+                     Iterator it,\n+                     const hb_map_t *layout_variation_idx_map)\n+{ c->start_embed<SinglePos> ()->serialize (c, src, it, layout_variation_idx_map); }\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_SINGLEPOS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/SinglePos.hh","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+#ifndef OT_LAYOUT_GPOS_SINGLEPOSFORMAT1_HH\n+#define OT_LAYOUT_GPOS_SINGLEPOSFORMAT1_HH\n+\n+#include \"Common.hh\"\n+#include \"ValueFormat.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct SinglePosFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  ValueFormat   valueFormat;            \/* Defines the types of data in the\n+                                         * ValueRecord *\/\n+  ValueRecord   values;                 \/* Defines positioning\n+                                         * value(s)--applied to all glyphs in\n+                                         * the Coverage table *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, values);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  coverage.sanitize (c, this) &&\n+                  valueFormat.sanitize_value (c, this, values));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    if (!valueFormat.has_device ()) return;\n+\n+    auto it =\n+    + hb_iter (this+coverage)\n+    | hb_filter (c->glyph_set)\n+    ;\n+\n+    if (!it) return;\n+    valueFormat.collect_variation_indices (c, this, values.as_array (valueFormat.get_len ()));\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { if (unlikely (!(this+coverage).collect_coverage (c->input))) return; }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  ValueFormat get_value_format () const { return valueFormat; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    valueFormat.apply_value (c, this, values, buffer->cur_pos());\n+\n+    buffer->idx++;\n+    return_trace (true);\n+  }\n+\n+  template<typename Iterator,\n+      typename SrcLookup,\n+      hb_requires (hb_is_iterator (Iterator))>\n+  void serialize (hb_serialize_context_t *c,\n+                  const SrcLookup *src,\n+                  Iterator it,\n+                  ValueFormat newFormat,\n+                  const hb_map_t *layout_variation_idx_map)\n+  {\n+    if (unlikely (!c->extend_min (this))) return;\n+    if (unlikely (!c->check_assign (valueFormat,\n+                                    newFormat,\n+                                    HB_SERIALIZE_ERROR_INT_OVERFLOW))) return;\n+\n+    for (const hb_array_t<const Value>& _ : + it | hb_map (hb_second))\n+    {\n+      src->get_value_format ().copy_values (c, newFormat, src,  &_, layout_variation_idx_map);\n+      \/\/ Only serialize the first entry in the iterator, the rest are assumed to\n+      \/\/ be the same.\n+      break;\n+    }\n+\n+    auto glyphs =\n+    + it\n+    | hb_map_retains_sorting (hb_first)\n+    ;\n+\n+    coverage.serialize_serialize (c, glyphs);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto it =\n+    + hb_iter (this+coverage)\n+    | hb_filter (glyphset)\n+    | hb_map_retains_sorting (glyph_map)\n+    | hb_zip (hb_repeat (values.as_array (valueFormat.get_len ())))\n+    ;\n+\n+    bool ret = bool (it);\n+    SinglePos_serialize (c->serializer, this, it, c->plan->layout_variation_idx_map);\n+    return_trace (ret);\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_SINGLEPOSFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/SinglePosFormat1.hh","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+#ifndef OT_LAYOUT_GPOS_SINGLEPOSFORMAT2_HH\n+#define OT_LAYOUT_GPOS_SINGLEPOSFORMAT2_HH\n+\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+struct SinglePosFormat2\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  ValueFormat   valueFormat;            \/* Defines the types of data in the\n+                                         * ValueRecord *\/\n+  HBUINT16      valueCount;             \/* Number of ValueRecords *\/\n+  ValueRecord   values;                 \/* Array of ValueRecords--positioning\n+                                         * values applied to glyphs *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, values);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  coverage.sanitize (c, this) &&\n+                  valueFormat.sanitize_values (c, this, values, valueCount));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n+  {\n+    if (!valueFormat.has_device ()) return;\n+\n+    auto it =\n+    + hb_zip (this+coverage, hb_range ((unsigned) valueCount))\n+    | hb_filter (c->glyph_set, hb_first)\n+    ;\n+\n+    if (!it) return;\n+\n+    unsigned sub_length = valueFormat.get_len ();\n+    const hb_array_t<const Value> values_array = values.as_array (valueCount * sub_length);\n+\n+    for (unsigned i : + it\n+                      | hb_map (hb_second))\n+      valueFormat.collect_variation_indices (c, this, values_array.sub_array (i * sub_length, sub_length));\n+\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { if (unlikely (!(this+coverage).collect_coverage (c->input))) return; }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  ValueFormat get_value_format () const { return valueFormat; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    if (likely (index >= valueCount)) return_trace (false);\n+\n+    valueFormat.apply_value (c, this,\n+                             &values[index * valueFormat.get_len ()],\n+                             buffer->cur_pos());\n+\n+    buffer->idx++;\n+    return_trace (true);\n+  }\n+\n+  template<typename Iterator,\n+      typename SrcLookup,\n+      hb_requires (hb_is_iterator (Iterator))>\n+  void serialize (hb_serialize_context_t *c,\n+                  const SrcLookup *src,\n+                  Iterator it,\n+                  ValueFormat newFormat,\n+                  const hb_map_t *layout_variation_idx_map)\n+  {\n+    auto out = c->extend_min (this);\n+    if (unlikely (!out)) return;\n+    if (unlikely (!c->check_assign (valueFormat, newFormat, HB_SERIALIZE_ERROR_INT_OVERFLOW))) return;\n+    if (unlikely (!c->check_assign (valueCount, it.len (), HB_SERIALIZE_ERROR_ARRAY_OVERFLOW))) return;\n+\n+    + it\n+    | hb_map (hb_second)\n+    | hb_apply ([&] (hb_array_t<const Value> _)\n+    { src->get_value_format ().copy_values (c, newFormat, src, &_, layout_variation_idx_map); })\n+    ;\n+\n+    auto glyphs =\n+    + it\n+    | hb_map_retains_sorting (hb_first)\n+    ;\n+\n+    coverage.serialize_serialize (c, glyphs);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    unsigned sub_length = valueFormat.get_len ();\n+    auto values_array = values.as_array (valueCount * sub_length);\n+\n+    auto it =\n+    + hb_zip (this+coverage, hb_range ((unsigned) valueCount))\n+    | hb_filter (glyphset, hb_first)\n+    | hb_map_retains_sorting ([&] (const hb_pair_t<hb_codepoint_t, unsigned>& _)\n+                              {\n+                                return hb_pair (glyph_map[_.first],\n+                                                values_array.sub_array (_.second * sub_length,\n+                                                                        sub_length));\n+                              })\n+    ;\n+\n+    bool ret = bool (it);\n+    SinglePos_serialize (c->serializer, this, it, c->plan->layout_variation_idx_map);\n+    return_trace (ret);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GPOS_SINGLEPOSFORMAT2_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/SinglePosFormat2.hh","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,329 @@\n+#ifndef OT_LAYOUT_GPOS_VALUEFORMAT_HH\n+#define OT_LAYOUT_GPOS_VALUEFORMAT_HH\n+\n+#include \"..\/..\/..\/hb-ot-layout-gsubgpos.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GPOS_impl {\n+\n+typedef HBUINT16 Value;\n+\n+typedef UnsizedArrayOf<Value> ValueRecord;\n+\n+struct ValueFormat : HBUINT16\n+{\n+  enum Flags {\n+    xPlacement  = 0x0001u,      \/* Includes horizontal adjustment for placement *\/\n+    yPlacement  = 0x0002u,      \/* Includes vertical adjustment for placement *\/\n+    xAdvance    = 0x0004u,      \/* Includes horizontal adjustment for advance *\/\n+    yAdvance    = 0x0008u,      \/* Includes vertical adjustment for advance *\/\n+    xPlaDevice  = 0x0010u,      \/* Includes horizontal Device table for placement *\/\n+    yPlaDevice  = 0x0020u,      \/* Includes vertical Device table for placement *\/\n+    xAdvDevice  = 0x0040u,      \/* Includes horizontal Device table for advance *\/\n+    yAdvDevice  = 0x0080u,      \/* Includes vertical Device table for advance *\/\n+    ignored     = 0x0F00u,      \/* Was used in TrueType Open for MM fonts *\/\n+    reserved    = 0xF000u,      \/* For future use *\/\n+\n+    devices     = 0x00F0u       \/* Mask for having any Device table *\/\n+  };\n+\n+\/* All fields are options.  Only those available advance the value pointer. *\/\n+#if 0\n+  HBINT16               xPlacement;     \/* Horizontal adjustment for\n+                                         * placement--in design units *\/\n+  HBINT16               yPlacement;     \/* Vertical adjustment for\n+                                         * placement--in design units *\/\n+  HBINT16               xAdvance;       \/* Horizontal adjustment for\n+                                         * advance--in design units (only used\n+                                         * for horizontal writing) *\/\n+  HBINT16               yAdvance;       \/* Vertical adjustment for advance--in\n+                                         * design units (only used for vertical\n+                                         * writing) *\/\n+  Offset16To<Device>    xPlaDevice;     \/* Offset to Device table for\n+                                         * horizontal placement--measured from\n+                                         * beginning of PosTable (may be NULL) *\/\n+  Offset16To<Device>    yPlaDevice;     \/* Offset to Device table for vertical\n+                                         * placement--measured from beginning\n+                                         * of PosTable (may be NULL) *\/\n+  Offset16To<Device>    xAdvDevice;     \/* Offset to Device table for\n+                                         * horizontal advance--measured from\n+                                         * beginning of PosTable (may be NULL) *\/\n+  Offset16To<Device>    yAdvDevice;     \/* Offset to Device table for vertical\n+                                         * advance--measured from beginning of\n+                                         * PosTable (may be NULL) *\/\n+#endif\n+\n+  IntType& operator = (uint16_t i) { v = i; return *this; }\n+\n+  unsigned int get_len () const  { return hb_popcount ((unsigned int) *this); }\n+  unsigned int get_size () const { return get_len () * Value::static_size; }\n+\n+  bool apply_value (hb_ot_apply_context_t *c,\n+                    const void            *base,\n+                    const Value           *values,\n+                    hb_glyph_position_t   &glyph_pos) const\n+  {\n+    bool ret = false;\n+    unsigned int format = *this;\n+    if (!format) return ret;\n+\n+    hb_font_t *font = c->font;\n+    bool horizontal =\n+#ifndef HB_NO_VERTICAL\n+      HB_DIRECTION_IS_HORIZONTAL (c->direction)\n+#else\n+      true\n+#endif\n+      ;\n+\n+    if (format & xPlacement) glyph_pos.x_offset  += font->em_scale_x (get_short (values++, &ret));\n+    if (format & yPlacement) glyph_pos.y_offset  += font->em_scale_y (get_short (values++, &ret));\n+    if (format & xAdvance) {\n+      if (likely (horizontal)) glyph_pos.x_advance += font->em_scale_x (get_short (values, &ret));\n+      values++;\n+    }\n+    \/* y_advance values grow downward but font-space grows upward, hence negation *\/\n+    if (format & yAdvance) {\n+      if (unlikely (!horizontal)) glyph_pos.y_advance -= font->em_scale_y (get_short (values, &ret));\n+      values++;\n+    }\n+\n+    if (!has_device ()) return ret;\n+\n+    bool use_x_device = font->x_ppem || font->num_coords;\n+    bool use_y_device = font->y_ppem || font->num_coords;\n+\n+    if (!use_x_device && !use_y_device) return ret;\n+\n+    const VariationStore &store = c->var_store;\n+    auto *cache = c->var_store_cache;\n+\n+    \/* pixel -> fractional pixel *\/\n+    if (format & xPlaDevice) {\n+      if (use_x_device) glyph_pos.x_offset  += (base + get_device (values, &ret)).get_x_delta (font, store, cache);\n+      values++;\n+    }\n+    if (format & yPlaDevice) {\n+      if (use_y_device) glyph_pos.y_offset  += (base + get_device (values, &ret)).get_y_delta (font, store, cache);\n+      values++;\n+    }\n+    if (format & xAdvDevice) {\n+      if (horizontal && use_x_device) glyph_pos.x_advance += (base + get_device (values, &ret)).get_x_delta (font, store, cache);\n+      values++;\n+    }\n+    if (format & yAdvDevice) {\n+      \/* y_advance values grow downward but font-space grows upward, hence negation *\/\n+      if (!horizontal && use_y_device) glyph_pos.y_advance -= (base + get_device (values, &ret)).get_y_delta (font, store, cache);\n+      values++;\n+    }\n+    return ret;\n+  }\n+\n+  unsigned int get_effective_format (const Value *values) const\n+  {\n+    unsigned int format = *this;\n+    for (unsigned flag = xPlacement; flag <= yAdvDevice; flag = flag << 1) {\n+      if (format & flag) should_drop (*values++, (Flags) flag, &format);\n+    }\n+\n+    return format;\n+  }\n+\n+  template<typename Iterator,\n+      hb_requires (hb_is_iterator (Iterator))>\n+  unsigned int get_effective_format (Iterator it) const {\n+    unsigned int new_format = 0;\n+\n+    for (const hb_array_t<const Value>& values : it)\n+      new_format = new_format | get_effective_format (&values);\n+\n+    return new_format;\n+  }\n+\n+  void copy_values (hb_serialize_context_t *c,\n+                    unsigned int new_format,\n+                    const void *base,\n+                    const Value *values,\n+                    const hb_map_t *layout_variation_idx_map) const\n+  {\n+    unsigned int format = *this;\n+    if (!format) return;\n+\n+    if (format & xPlacement) copy_value (c, new_format, xPlacement, *values++);\n+    if (format & yPlacement) copy_value (c, new_format, yPlacement, *values++);\n+    if (format & xAdvance)   copy_value (c, new_format, xAdvance, *values++);\n+    if (format & yAdvance)   copy_value (c, new_format, yAdvance, *values++);\n+\n+    if (format & xPlaDevice) copy_device (c, base, values++, layout_variation_idx_map);\n+    if (format & yPlaDevice) copy_device (c, base, values++, layout_variation_idx_map);\n+    if (format & xAdvDevice) copy_device (c, base, values++, layout_variation_idx_map);\n+    if (format & yAdvDevice) copy_device (c, base, values++, layout_variation_idx_map);\n+  }\n+\n+  void copy_value (hb_serialize_context_t *c,\n+                   unsigned int new_format,\n+                   Flags flag,\n+                   Value value) const\n+  {\n+    \/\/ Filter by new format.\n+    if (!(new_format & flag)) return;\n+    c->copy (value);\n+  }\n+\n+  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n+                                  const void *base,\n+                                  const hb_array_t<const Value>& values) const\n+  {\n+    unsigned format = *this;\n+    unsigned i = 0;\n+    if (format & xPlacement) i++;\n+    if (format & yPlacement) i++;\n+    if (format & xAdvance) i++;\n+    if (format & yAdvance) i++;\n+    if (format & xPlaDevice)\n+    {\n+      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n+      i++;\n+    }\n+\n+    if (format & ValueFormat::yPlaDevice)\n+    {\n+      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n+      i++;\n+    }\n+\n+    if (format & ValueFormat::xAdvDevice)\n+    {\n+\n+      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n+      i++;\n+    }\n+\n+    if (format & ValueFormat::yAdvDevice)\n+    {\n+\n+      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n+      i++;\n+    }\n+  }\n+\n+  private:\n+  bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const\n+  {\n+    unsigned int format = *this;\n+\n+    if (format & xPlacement) values++;\n+    if (format & yPlacement) values++;\n+    if (format & xAdvance)   values++;\n+    if (format & yAdvance)   values++;\n+\n+    if ((format & xPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n+    if ((format & yPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n+    if ((format & xAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n+    if ((format & yAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n+\n+    return true;\n+  }\n+\n+  static inline Offset16To<Device>& get_device (Value* value)\n+  {\n+    return *static_cast<Offset16To<Device> *> (value);\n+  }\n+  static inline const Offset16To<Device>& get_device (const Value* value, bool *worked=nullptr)\n+  {\n+    if (worked) *worked |= bool (*value);\n+    return *static_cast<const Offset16To<Device> *> (value);\n+  }\n+\n+  bool copy_device (hb_serialize_context_t *c, const void *base,\n+                    const Value *src_value, const hb_map_t *layout_variation_idx_map) const\n+  {\n+    Value       *dst_value = c->copy (*src_value);\n+\n+    if (!dst_value) return false;\n+    if (*dst_value == 0) return true;\n+\n+    *dst_value = 0;\n+    c->push ();\n+    if ((base + get_device (src_value)).copy (c, layout_variation_idx_map))\n+    {\n+      c->add_link (*dst_value, c->pop_pack ());\n+      return true;\n+    }\n+    else\n+    {\n+      c->pop_discard ();\n+      return false;\n+    }\n+  }\n+\n+  static inline const HBINT16& get_short (const Value* value, bool *worked=nullptr)\n+  {\n+    if (worked) *worked |= bool (*value);\n+    return *reinterpret_cast<const HBINT16 *> (value);\n+  }\n+\n+  public:\n+\n+  bool has_device () const\n+  {\n+    unsigned int format = *this;\n+    return (format & devices) != 0;\n+  }\n+\n+  bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_range (values, get_size ()) && (!has_device () || sanitize_value_devices (c, base, values)));\n+  }\n+\n+  bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    unsigned int len = get_len ();\n+\n+    if (!c->check_range (values, count, get_size ())) return_trace (false);\n+\n+    if (!has_device ()) return_trace (true);\n+\n+    for (unsigned int i = 0; i < count; i++) {\n+      if (!sanitize_value_devices (c, base, values))\n+        return_trace (false);\n+      values += len;\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  \/* Just sanitize referenced Device tables.  Doesn't check the values themselves. *\/\n+  bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    if (!has_device ()) return_trace (true);\n+\n+    for (unsigned int i = 0; i < count; i++) {\n+      if (!sanitize_value_devices (c, base, values))\n+        return_trace (false);\n+      values += stride;\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+ private:\n+\n+  void should_drop (Value value, Flags flag, unsigned int* format) const\n+  {\n+    if (value) return;\n+    *format = *format & ~flag;\n+  }\n+\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/\/ #ifndef OT_LAYOUT_GPOS_VALUEFORMAT_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/ValueFormat.hh","additions":329,"deletions":0,"binary":false,"changes":329,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+#ifndef OT_LAYOUT_GSUB_ALTERNATESET_HH\n+#define OT_LAYOUT_GSUB_ALTERNATESET_HH\n+\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct AlternateSet\n+{\n+  protected:\n+  Array16Of<HBGlyphID16>\n+                alternates;             \/* Array of alternate GlyphIDs--in\n+                                         * arbitrary order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, alternates);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (alternates.sanitize (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return hb_any (alternates, glyphs); }\n+\n+  void closure (hb_closure_context_t *c) const\n+  { c->output->add_array (alternates.arrayZ, alternates.len); }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { c->output->add_array (alternates.arrayZ, alternates.len); }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int count = alternates.len;\n+\n+    if (unlikely (!count)) return_trace (false);\n+\n+    hb_mask_t glyph_mask = c->buffer->cur().mask;\n+    hb_mask_t lookup_mask = c->lookup_mask;\n+\n+    \/* Note: This breaks badly if two features enabled this lookup together. *\/\n+    unsigned int shift = hb_ctz (lookup_mask);\n+    unsigned int alt_index = ((lookup_mask & glyph_mask) >> shift);\n+\n+    \/* If alt_index is MAX_VALUE, randomize feature if it is the rand feature. *\/\n+    if (alt_index == HB_OT_MAP_MAX_VALUE && c->random)\n+    {\n+      \/* Maybe we can do better than unsafe-to-break all; but since we are\n+       * changing random state, it would be hard to track that.  Good 'nough. *\/\n+      c->buffer->unsafe_to_break (0, c->buffer->len);\n+      alt_index = c->random_number () % count + 1;\n+    }\n+\n+    if (unlikely (alt_index > count || alt_index == 0)) return_trace (false);\n+\n+    c->replace_glyph (alternates[alt_index - 1]);\n+\n+    return_trace (true);\n+  }\n+\n+  unsigned\n+  get_alternates (unsigned        start_offset,\n+                  unsigned       *alternate_count  \/* IN\/OUT.  May be NULL. *\/,\n+                  hb_codepoint_t *alternate_glyphs \/* OUT.     May be NULL. *\/) const\n+  {\n+    if (alternates.len && alternate_count)\n+    {\n+      + alternates.sub_array (start_offset, alternate_count)\n+      | hb_sink (hb_array (alternate_glyphs, *alternate_count))\n+      ;\n+    }\n+    return alternates.len;\n+  }\n+\n+  template <typename Iterator,\n+            hb_requires (hb_is_source_of (Iterator, hb_codepoint_t))>\n+  bool serialize (hb_serialize_context_t *c,\n+                  Iterator alts)\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (alternates.serialize (c, alts));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto it =\n+      + hb_iter (alternates)\n+      | hb_filter (glyphset)\n+      | hb_map (glyph_map)\n+      ;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    return_trace (out->serialize (c->serializer, it) &&\n+                  out->alternates);\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+\n+#endif \/* OT_LAYOUT_GSUB_ALTERNATESET_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/AlternateSet.hh","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+#ifndef OT_LAYOUT_GSUB_ALTERNATESUBST_HH\n+#define OT_LAYOUT_GSUB_ALTERNATESUBST_HH\n+\n+#include \"AlternateSubstFormat1.hh\"\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct AlternateSubst\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  AlternateSubstFormat1 format1;\n+  } u;\n+  public:\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_sorted_array_t<const HBGlyphID16> glyphs,\n+                  hb_array_t<const unsigned int> alternate_len_list,\n+                  hb_array_t<const HBGlyphID16> alternate_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n+    unsigned int format = 1;\n+    u.format = format;\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.serialize (c, glyphs, alternate_len_list, alternate_glyphs_list));\n+    default:return_trace (false);\n+    }\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_ALTERNATESUBST_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/AlternateSubst.hh","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+#ifndef OT_LAYOUT_GSUB_ALTERNATESUBSTFORMAT1_HH\n+#define OT_LAYOUT_GSUB_ALTERNATESUBSTFORMAT1_HH\n+\n+#include \"AlternateSet.hh\"\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct AlternateSubstFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  Array16OfOffset16To<AlternateSet>\n+                alternateSet;           \/* Array of AlternateSet tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, alternateSet);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && alternateSet.sanitize (c, this));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  bool may_have_non_1to1 () const\n+  { return false; }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    + hb_zip (this+coverage, alternateSet)\n+    | hb_filter (c->parent_active_glyphs (), hb_first)\n+    | hb_map (hb_second)\n+    | hb_map (hb_add (this))\n+    | hb_apply ([c] (const AlternateSet &_) { _.closure (c); })\n+    ;\n+\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n+    + hb_zip (this+coverage, alternateSet)\n+    | hb_map (hb_second)\n+    | hb_map (hb_add (this))\n+    | hb_apply ([c] (const AlternateSet &_) { _.collect_glyphs (c); })\n+    ;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n+\n+  unsigned\n+  get_glyph_alternates (hb_codepoint_t  gid,\n+                        unsigned        start_offset,\n+                        unsigned       *alternate_count  \/* IN\/OUT.  May be NULL. *\/,\n+                        hb_codepoint_t *alternate_glyphs \/* OUT.     May be NULL. *\/) const\n+  { return (this+alternateSet[(this+coverage).get_coverage (gid)])\n+           .get_alternates (start_offset, alternate_count, alternate_glyphs); }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    return_trace ((this+alternateSet[index]).apply (c));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_sorted_array_t<const HBGlyphID16> glyphs,\n+                  hb_array_t<const unsigned int> alternate_len_list,\n+                  hb_array_t<const HBGlyphID16> alternate_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    if (unlikely (!alternateSet.serialize (c, glyphs.length))) return_trace (false);\n+    for (unsigned int i = 0; i < glyphs.length; i++)\n+    {\n+      unsigned int alternate_len = alternate_len_list[i];\n+      if (unlikely (!alternateSet[i]\n+                        .serialize_serialize (c, alternate_glyphs_list.sub_array (0, alternate_len))))\n+        return_trace (false);\n+      alternate_glyphs_list += alternate_len;\n+    }\n+    return_trace (coverage.serialize_serialize (c, glyphs));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->format = format;\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+    + hb_zip (this+coverage, alternateSet)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter (subset_offset_array (c, out->alternateSet, this), hb_second)\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n+    return_trace (bool (new_coverage));\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_ALTERNATESUBSTFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/AlternateSubstFormat1.hh","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+#ifndef OT_LAYOUT_GSUB_CHAINCONTEXTSUBST_HH\n+#define OT_LAYOUT_GSUB_CHAINCONTEXTSUBST_HH\n+\n+\/\/ TODO(garretrieger): move to new layout.\n+#include \"..\/..\/..\/hb-ot-layout-gsubgpos.hh\"\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct ChainContextSubst : ChainContext {};\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_CHAINCONTEXTSUBST_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ChainContextSubst.hh","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+#ifndef OT_LAYOUT_GSUB_COMMON_HH\n+#define OT_LAYOUT_GSUB_COMMON_HH\n+\n+#include \"..\/..\/..\/hb-serialize.hh\"\n+#include \"..\/..\/..\/hb-ot-layout-gsubgpos.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+typedef hb_pair_t<hb_codepoint_t, hb_codepoint_t> hb_codepoint_pair_t;\n+\n+template<typename Iterator>\n+static void SingleSubst_serialize (hb_serialize_context_t *c,\n+                                   Iterator it);\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GSUB_COMMON_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/Common.hh","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+#ifndef OT_LAYOUT_GSUB_CONTEXTSUBST_HH\n+#define OT_LAYOUT_GSUB_CONTEXTSUBST_HH\n+\n+\/\/ TODO(garretrieger): move to new layout.\n+#include \"..\/..\/..\/hb-ot-layout-gsubgpos.hh\"\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct ContextSubst : Context {};\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_CONTEXTSUBST_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ContextSubst.hh","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,22 @@\n+#ifndef OT_LAYOUT_GSUB_EXTENSIONSUBST_HH\n+#define OT_LAYOUT_GSUB_EXTENSIONSUBST_HH\n+\n+\/\/ TODO(garretrieger): move to new layout.\n+#include \"..\/..\/..\/hb-ot-layout-gsubgpos.hh\"\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct ExtensionSubst : Extension<ExtensionSubst>\n+{\n+  typedef struct SubstLookupSubTable SubTable;\n+  bool is_reverse () const;\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_EXTENSIONSUBST_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ExtensionSubst.hh","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+#ifndef OT_LAYOUT_GSUB_GSUB_HH\n+#define OT_LAYOUT_GSUB_GSUB_HH\n+\n+\/\/ TODO(garretrieger): move to new layout.\n+#include \"..\/..\/..\/hb-ot-layout-gsubgpos.hh\"\n+#include \"Common.hh\"\n+#include \"SubstLookup.hh\"\n+\n+using OT::Layout::GSUB::SubstLookup;\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+\/*\n+ * GSUB -- Glyph Substitution\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gsub\n+ *\/\n+\n+struct GSUB : GSUBGPOS\n+{\n+  using Lookup = SubstLookup;\n+\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_GSUB;\n+\n+  const SubstLookup& get_lookup (unsigned int i) const\n+  { return static_cast<const SubstLookup &> (GSUBGPOS::get_lookup (i)); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    hb_subset_layout_context_t l (c, tableTag, c->plan->gsub_lookups, c->plan->gsub_langsys, c->plan->gsub_features);\n+    return GSUBGPOS::subset<SubstLookup> (&l);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  { return GSUBGPOS::sanitize<SubstLookup> (c); }\n+\n+  HB_INTERNAL bool is_blocklisted (hb_blob_t *blob,\n+                                   hb_face_t *face) const;\n+\n+  void closure_lookups (hb_face_t      *face,\n+                        const hb_set_t *glyphs,\n+                        hb_set_t       *lookup_indexes \/* IN\/OUT *\/) const\n+  { GSUBGPOS::closure_lookups<SubstLookup> (face, glyphs, lookup_indexes); }\n+\n+  typedef GSUBGPOS::accelerator_t<GSUB> accelerator_t;\n+};\n+\n+\n+}\n+}\n+\n+struct GSUB_accelerator_t : Layout::GSUB::GSUB::accelerator_t {\n+  GSUB_accelerator_t (hb_face_t *face) : Layout::GSUB::GSUB::accelerator_t (face) {}\n+};\n+\n+\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_GSUB_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/GSUB.hh","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+#ifndef OT_LAYOUT_GSUB_LIGATURE_HH\n+#define OT_LAYOUT_GSUB_LIGATURE_HH\n+\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct Ligature\n+{\n+  protected:\n+  HBGlyphID16   ligGlyph;               \/* GlyphID of ligature to substitute *\/\n+  HeadlessArrayOf<HBGlyphID16>\n+                component;              \/* Array of component GlyphIDs--start\n+                                         * with the second  component--ordered\n+                                         * in writing direction *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, component);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (ligGlyph.sanitize (c) && component.sanitize (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return hb_all (component, glyphs); }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    if (!intersects (c->glyphs)) return;\n+    c->output->add (ligGlyph);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    c->input->add_array (component.arrayZ, component.get_length ());\n+    c->output->add (ligGlyph);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    if (c->len != component.lenP1)\n+      return false;\n+\n+    for (unsigned int i = 1; i < c->len; i++)\n+      if (likely (c->glyphs[i] != component[i]))\n+        return false;\n+\n+    return true;\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int count = component.lenP1;\n+\n+    if (unlikely (!count)) return_trace (false);\n+\n+    \/* Special-case to make it in-place and not consider this\n+     * as a \"ligated\" substitution. *\/\n+    if (unlikely (count == 1))\n+    {\n+      c->replace_glyph (ligGlyph);\n+      return_trace (true);\n+    }\n+\n+    unsigned int total_component_count = 0;\n+\n+    unsigned int match_end = 0;\n+    unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];\n+\n+    if (likely (!match_input (c, count,\n+                              &component[1],\n+                              match_glyph,\n+                              nullptr,\n+                              &match_end,\n+                              match_positions,\n+                              &total_component_count)))\n+    {\n+      c->buffer->unsafe_to_concat (c->buffer->idx, match_end);\n+      return_trace (false);\n+    }\n+\n+    ligate_input (c,\n+                  count,\n+                  match_positions,\n+                  match_end,\n+                  ligGlyph,\n+                  total_component_count);\n+\n+    return_trace (true);\n+  }\n+\n+  template <typename Iterator,\n+            hb_requires (hb_is_source_of (Iterator, hb_codepoint_t))>\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_codepoint_t ligature,\n+                  Iterator components \/* Starting from second *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    ligGlyph = ligature;\n+    if (unlikely (!component.serialize (c, components))) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c, unsigned coverage_idx) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    if (!intersects (&glyphset) || !glyphset.has (ligGlyph)) return_trace (false);\n+    \/\/ Ensure Coverage table is always packed after this.\n+    c->serializer->add_virtual_link (coverage_idx);\n+\n+    auto it =\n+      + hb_iter (component)\n+      | hb_map (glyph_map)\n+      ;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    return_trace (out->serialize (c->serializer,\n+                                  glyph_map[ligGlyph],\n+                                  it));  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_LIGATURE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/Ligature.hh","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+#ifndef OT_LAYOUT_GSUB_LIGATURESET_HH\n+#define OT_LAYOUT_GSUB_LIGATURESET_HH\n+\n+#include \"Common.hh\"\n+#include \"Ligature.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct LigatureSet\n+{\n+  protected:\n+  Array16OfOffset16To<Ligature>\n+                ligature;               \/* Array LigatureSet tables\n+                                         * ordered by preference *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, ligature);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (ligature.sanitize (c, this));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    return\n+    + hb_iter (ligature)\n+    | hb_map (hb_add (this))\n+    | hb_map ([glyphs] (const Ligature &_) { return _.intersects (glyphs); })\n+    | hb_any\n+    ;\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    + hb_iter (ligature)\n+    | hb_map (hb_add (this))\n+    | hb_apply ([c] (const Ligature &_) { _.closure (c); })\n+    ;\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    + hb_iter (ligature)\n+    | hb_map (hb_add (this))\n+    | hb_apply ([c] (const Ligature &_) { _.collect_glyphs (c); })\n+    ;\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    return\n+    + hb_iter (ligature)\n+    | hb_map (hb_add (this))\n+    | hb_map ([c] (const Ligature &_) { return _.would_apply (c); })\n+    | hb_any\n+    ;\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int num_ligs = ligature.len;\n+    for (unsigned int i = 0; i < num_ligs; i++)\n+    {\n+      const Ligature &lig = this+ligature[i];\n+      if (lig.apply (c)) return_trace (true);\n+    }\n+\n+    return_trace (false);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const HBGlyphID16> ligatures,\n+                  hb_array_t<const unsigned int> component_count_list,\n+                  hb_array_t<const HBGlyphID16> &component_list \/* Starting from second for each ligature *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    if (unlikely (!ligature.serialize (c, ligatures.length))) return_trace (false);\n+    for (unsigned int i = 0; i < ligatures.length; i++)\n+    {\n+      unsigned int component_count = (unsigned) hb_max ((int) component_count_list[i] - 1, 0);\n+      if (unlikely (!ligature[i].serialize_serialize (c,\n+                                                      ligatures[i],\n+                                                      component_list.sub_array (0, component_count))))\n+        return_trace (false);\n+      component_list += component_count;\n+    }\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c, unsigned coverage_idx) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    + hb_iter (ligature)\n+    | hb_filter (subset_offset_array (c, out->ligature, this, coverage_idx))\n+    | hb_drain\n+    ;\n+\n+    if (bool (out->ligature))\n+      \/\/ Ensure Coverage table is always packed after this.\n+      c->serializer->add_virtual_link (coverage_idx);\n+\n+    return_trace (bool (out->ligature));\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_LIGATURESET_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSet.hh","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+#ifndef OT_LAYOUT_GSUB_LIGATURESUBST_HH\n+#define OT_LAYOUT_GSUB_LIGATURESUBST_HH\n+\n+#include \"Common.hh\"\n+#include \"LigatureSubstFormat1.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct LigatureSubst\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  LigatureSubstFormat1  format1;\n+  } u;\n+\n+  public:\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_sorted_array_t<const HBGlyphID16> first_glyphs,\n+                  hb_array_t<const unsigned int> ligature_per_first_glyph_count_list,\n+                  hb_array_t<const HBGlyphID16> ligatures_list,\n+                  hb_array_t<const unsigned int> component_count_list,\n+                  hb_array_t<const HBGlyphID16> component_list \/* Starting from second for each ligature *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n+    unsigned int format = 1;\n+    u.format = format;\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.serialize (c,\n+                                               first_glyphs,\n+                                               ligature_per_first_glyph_count_list,\n+                                               ligatures_list,\n+                                               component_count_list,\n+                                               component_list));\n+    default:return_trace (false);\n+    }\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_LIGATURESUBST_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSubst.hh","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+#ifndef OT_LAYOUT_GSUB_LIGATURESUBSTFORMAT1_HH\n+#define OT_LAYOUT_GSUB_LIGATURESUBSTFORMAT1_HH\n+\n+#include \"Common.hh\"\n+#include \"LigatureSet.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct LigatureSubstFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  Array16OfOffset16To<LigatureSet>\n+                ligatureSet;            \/* Array LigatureSet tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, ligatureSet);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && ligatureSet.sanitize (c, this));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    return\n+    + hb_zip (this+coverage, ligatureSet)\n+    | hb_filter (*glyphs, hb_first)\n+    | hb_map (hb_second)\n+    | hb_map ([this, glyphs] (const Offset16To<LigatureSet> &_)\n+              { return (this+_).intersects (glyphs); })\n+    | hb_any\n+    ;\n+  }\n+\n+  bool may_have_non_1to1 () const\n+  { return true; }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    + hb_zip (this+coverage, ligatureSet)\n+    | hb_filter (c->parent_active_glyphs (), hb_first)\n+    | hb_map (hb_second)\n+    | hb_map (hb_add (this))\n+    | hb_apply ([c] (const LigatureSet &_) { _.closure (c); })\n+    ;\n+\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n+\n+    + hb_zip (this+coverage, ligatureSet)\n+    | hb_map (hb_second)\n+    | hb_map (hb_add (this))\n+    | hb_apply ([c] (const LigatureSet &_) { _.collect_glyphs (c); })\n+    ;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (c->glyphs[0]);\n+    if (likely (index == NOT_COVERED)) return false;\n+\n+    const LigatureSet &lig_set = this+ligatureSet[index];\n+    return lig_set.would_apply (c);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur ().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const LigatureSet &lig_set = this+ligatureSet[index];\n+    return_trace (lig_set.apply (c));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_sorted_array_t<const HBGlyphID16> first_glyphs,\n+                  hb_array_t<const unsigned int> ligature_per_first_glyph_count_list,\n+                  hb_array_t<const HBGlyphID16> ligatures_list,\n+                  hb_array_t<const unsigned int> component_count_list,\n+                  hb_array_t<const HBGlyphID16> component_list \/* Starting from second for each ligature *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    if (unlikely (!ligatureSet.serialize (c, first_glyphs.length))) return_trace (false);\n+    for (unsigned int i = 0; i < first_glyphs.length; i++)\n+    {\n+      unsigned int ligature_count = ligature_per_first_glyph_count_list[i];\n+      if (unlikely (!ligatureSet[i]\n+                        .serialize_serialize (c,\n+                                              ligatures_list.sub_array (0, ligature_count),\n+                                              component_count_list.sub_array (0, ligature_count),\n+                                              component_list))) return_trace (false);\n+      ligatures_list += ligature_count;\n+      component_count_list += ligature_count;\n+    }\n+    return_trace (coverage.serialize_serialize (c, first_glyphs));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->format = format;\n+\n+    \/\/ Due to a bug in some older versions of windows 7 the Coverage table must be\n+    \/\/ packed after the LigatureSet and Ligature tables, so serialize Coverage first\n+    \/\/ which places it last in the packed order.\n+    hb_set_t new_coverage;\n+    + hb_zip (this+coverage, hb_iter (ligatureSet) | hb_map (hb_add (this)))\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter ([&] (const LigatureSet& _) {\n+      return _.intersects (&glyphset);\n+    }, hb_second)\n+    | hb_map (hb_first)\n+    | hb_sink (new_coverage);\n+\n+    if (!c->serializer->push<Coverage> ()\n+        ->serialize (c->serializer,\n+                     + new_coverage.iter () | hb_map_retains_sorting (glyph_map)))\n+    {\n+      c->serializer->pop_discard ();\n+      return_trace (false);\n+    }\n+\n+    unsigned coverage_idx = c->serializer->pop_pack ();\n+     c->serializer->add_link (out->coverage, coverage_idx);\n+\n+    + hb_zip (this+coverage, ligatureSet)\n+    | hb_filter (new_coverage, hb_first)\n+    | hb_map (hb_second)\n+    \/\/ to ensure that the repacker always orders the coverage table after the LigatureSet\n+    \/\/ and LigatureSubtable's they will be linked to the Coverage table via a virtual link\n+    \/\/ the coverage table object idx is passed down to facilitate this.\n+    | hb_apply (subset_offset_array (c, out->ligatureSet, this, coverage_idx))\n+    ;\n+\n+    return_trace (bool (new_coverage));\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_LIGATURESUBSTFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSubstFormat1.hh","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+#ifndef OT_LAYOUT_GSUB_MULTIPLESUBST_HH\n+#define OT_LAYOUT_GSUB_MULTIPLESUBST_HH\n+\n+#include \"Common.hh\"\n+#include \"MultipleSubstFormat1.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct MultipleSubst\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MultipleSubstFormat1  format1;\n+  } u;\n+\n+  public:\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_sorted_array_t<const HBGlyphID16> glyphs,\n+                  hb_array_t<const unsigned int> substitute_len_list,\n+                  hb_array_t<const HBGlyphID16> substitute_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n+    unsigned int format = 1;\n+    u.format = format;\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, substitute_glyphs_list));\n+    default:return_trace (false);\n+    }\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GSUB_MULTIPLESUBST_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/MultipleSubst.hh","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+#ifndef OT_LAYOUT_GSUB_MULTIPLESUBSTFORMAT1_HH\n+#define OT_LAYOUT_GSUB_MULTIPLESUBSTFORMAT1_HH\n+\n+#include \"Common.hh\"\n+#include \"Sequence.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct MultipleSubstFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  Array16OfOffset16To<Sequence>\n+                sequence;               \/* Array of Sequence tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, sequence);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && sequence.sanitize (c, this));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  bool may_have_non_1to1 () const\n+  { return true; }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    + hb_zip (this+coverage, sequence)\n+    | hb_filter (c->parent_active_glyphs (), hb_first)\n+    | hb_map (hb_second)\n+    | hb_map (hb_add (this))\n+    | hb_apply ([c] (const Sequence &_) { _.closure (c); })\n+    ;\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n+    + hb_zip (this+coverage, sequence)\n+    | hb_map (hb_second)\n+    | hb_map (hb_add (this))\n+    | hb_apply ([c] (const Sequence &_) { _.collect_glyphs (c); })\n+    ;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    return_trace ((this+sequence[index]).apply (c));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_sorted_array_t<const HBGlyphID16> glyphs,\n+                  hb_array_t<const unsigned int> substitute_len_list,\n+                  hb_array_t<const HBGlyphID16> substitute_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    if (unlikely (!sequence.serialize (c, glyphs.length))) return_trace (false);\n+    for (unsigned int i = 0; i < glyphs.length; i++)\n+    {\n+      unsigned int substitute_len = substitute_len_list[i];\n+      if (unlikely (!sequence[i]\n+                        .serialize_serialize (c, substitute_glyphs_list.sub_array (0, substitute_len))))\n+        return_trace (false);\n+      substitute_glyphs_list += substitute_len;\n+    }\n+    return_trace (coverage.serialize_serialize (c, glyphs));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    out->format = format;\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+    + hb_zip (this+coverage, sequence)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter (subset_offset_array (c, out->sequence, this), hb_second)\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n+    return_trace (bool (new_coverage));\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+\n+#endif \/* OT_LAYOUT_GSUB_MULTIPLESUBSTFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/MultipleSubstFormat1.hh","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+#ifndef OT_LAYOUT_GSUB_REVERSECHAINSINGLESUBST_HH\n+#define OT_LAYOUT_GSUB_REVERSECHAINSINGLESUBST_HH\n+\n+#include \"Common.hh\"\n+#include \"ReverseChainSingleSubstFormat1.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct ReverseChainSingleSubst\n+{\n+  protected:\n+  union {\n+  HBUINT16                              format;         \/* Format identifier *\/\n+  ReverseChainSingleSubstFormat1        format1;\n+  } u;\n+\n+  public:\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/* HB_OT_LAYOUT_GSUB_REVERSECHAINSINGLESUBST_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ReverseChainSingleSubst.hh","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+#ifndef OT_LAYOUT_GSUB_REVERSECHAINSINGLESUBSTFORMAT1_HH\n+#define OT_LAYOUT_GSUB_REVERSECHAINSINGLESUBSTFORMAT1_HH\n+\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct ReverseChainSingleSubstFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of table *\/\n+  Array16OfOffset16To<Coverage>\n+                backtrack;              \/* Array of coverage tables\n+                                         * in backtracking sequence, in glyph\n+                                         * sequence order *\/\n+  Array16OfOffset16To<Coverage>\n+                lookaheadX;             \/* Array of coverage tables\n+                                         * in lookahead sequence, in glyph\n+                                         * sequence order *\/\n+  Array16Of<HBGlyphID16>\n+                substituteX;            \/* Array of substitute\n+                                         * GlyphIDs--ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_MIN (10);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!(coverage.sanitize (c, this) && backtrack.sanitize (c, this)))\n+      return_trace (false);\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    if (!lookahead.sanitize (c, this))\n+      return_trace (false);\n+    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+    return_trace (substitute.sanitize (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    if (!(this+coverage).intersects (glyphs))\n+      return false;\n+\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+\n+    unsigned int count;\n+\n+    count = backtrack.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!(this+backtrack[i]).intersects (glyphs))\n+        return false;\n+\n+    count = lookahead.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!(this+lookahead[i]).intersects (glyphs))\n+        return false;\n+\n+    return true;\n+  }\n+\n+  bool may_have_non_1to1 () const\n+  { return false; }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    if (!intersects (c->glyphs)) return;\n+\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+\n+    + hb_zip (this+coverage, substitute)\n+    | hb_filter (c->parent_active_glyphs (), hb_first)\n+    | hb_map (hb_second)\n+    | hb_sink (c->output)\n+    ;\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n+\n+    unsigned int count;\n+\n+    count = backtrack.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!(this+backtrack[i]).collect_coverage (c->before))) return;\n+\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    count = lookahead.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!(this+lookahead[i]).collect_coverage (c->after))) return;\n+\n+    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+    count = substitute.len;\n+    c->output->add_array (substitute.arrayZ, substitute.len);\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    if (unlikely (c->nesting_level_left != HB_MAX_NESTING_LEVEL))\n+      return_trace (false); \/* No chaining to this type *\/\n+\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur ().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+\n+    if (unlikely (index >= substitute.len)) return_trace (false);\n+\n+    unsigned int start_index = 0, end_index = 0;\n+    if (match_backtrack (c,\n+                         backtrack.len, (HBUINT16 *) backtrack.arrayZ,\n+                         match_coverage, this,\n+                         &start_index) &&\n+        match_lookahead (c,\n+                         lookahead.len, (HBUINT16 *) lookahead.arrayZ,\n+                         match_coverage, this,\n+                         c->buffer->idx + 1, &end_index))\n+    {\n+      c->buffer->unsafe_to_break_from_outbuffer (start_index, end_index);\n+      c->replace_glyph_inplace (substitute[index]);\n+      \/* Note: We DON'T decrease buffer->idx.  The main loop does it\n+       * for us.  This is useful for preventing surprises if someone\n+       * calls us through a Context lookup. *\/\n+      return_trace (true);\n+    }\n+    else\n+    {\n+      c->buffer->unsafe_to_concat_from_outbuffer (start_index, end_index);\n+      return_trace (false);\n+    }\n+  }\n+\n+  template<typename Iterator,\n+           hb_requires (hb_is_iterator (Iterator))>\n+  bool serialize_coverage_offset_array (hb_subset_context_t *c, Iterator it) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->serializer->start_embed<Array16OfOffset16To<Coverage>> ();\n+\n+    if (unlikely (!c->serializer->allocate_size<HBUINT16> (HBUINT16::static_size)))\n+      return_trace (false);\n+\n+    for (auto& offset : it) {\n+      auto *o = out->serialize_append (c->serializer);\n+      if (unlikely (!o) || !o->serialize_subset (c, offset, this))\n+        return_trace (false);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  template<typename Iterator, typename BacktrackIterator, typename LookaheadIterator,\n+           hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_pair_t)),\n+           hb_requires (hb_is_iterator (BacktrackIterator)),\n+           hb_requires (hb_is_iterator (LookaheadIterator))>\n+  bool serialize (hb_subset_context_t *c,\n+                  Iterator coverage_subst_iter,\n+                  BacktrackIterator backtrack_iter,\n+                  LookaheadIterator lookahead_iter) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!c->serializer->check_success (out))) return_trace (false);\n+    if (unlikely (!c->serializer->embed (this->format))) return_trace (false);\n+    if (unlikely (!c->serializer->embed (this->coverage))) return_trace (false);\n+\n+    if (!serialize_coverage_offset_array (c, backtrack_iter)) return_trace (false);\n+    if (!serialize_coverage_offset_array (c, lookahead_iter)) return_trace (false);\n+\n+    auto *substitute_out = c->serializer->start_embed<Array16Of<HBGlyphID16>> ();\n+    auto substitutes =\n+    + coverage_subst_iter\n+    | hb_map (hb_second)\n+    ;\n+\n+    auto glyphs =\n+    + coverage_subst_iter\n+    | hb_map_retains_sorting (hb_first)\n+    ;\n+    if (unlikely (! c->serializer->check_success (substitute_out->serialize (c->serializer, substitutes))))\n+        return_trace (false);\n+\n+    if (unlikely (!out->coverage.serialize_serialize (c->serializer, glyphs)))\n+      return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const Array16Of<HBGlyphID16> &substitute = StructAfter<Array16Of<HBGlyphID16>> (lookahead);\n+\n+    auto it =\n+    + hb_zip (this+coverage, substitute)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter (glyphset, hb_second)\n+    | hb_map_retains_sorting ([&] (hb_pair_t<hb_codepoint_t, const HBGlyphID16 &> p) -> hb_codepoint_pair_t\n+                              { return hb_pair (glyph_map[p.first], glyph_map[p.second]); })\n+    ;\n+\n+    return_trace (bool (it) && serialize (c, it, backtrack.iter (), lookahead.iter ()));\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif  \/* HB_OT_LAYOUT_GSUB_REVERSECHAINSINGLESUBSTFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/ReverseChainSingleSubstFormat1.hh","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+#ifndef OT_LAYOUT_GSUB_SEQUENCE_HH\n+#define OT_LAYOUT_GSUB_SEQUENCE_HH\n+\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct Sequence\n+{\n+  protected:\n+  Array16Of<HBGlyphID16>\n+                substitute;             \/* String of GlyphIDs to substitute *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, substitute);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (substitute.sanitize (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return hb_all (substitute, glyphs); }\n+\n+  void closure (hb_closure_context_t *c) const\n+  { c->output->add_array (substitute.arrayZ, substitute.len); }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { c->output->add_array (substitute.arrayZ, substitute.len); }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int count = substitute.len;\n+\n+    \/* Special-case to make it in-place and not consider this\n+     * as a \"multiplied\" substitution. *\/\n+    if (unlikely (count == 1))\n+    {\n+      c->replace_glyph (substitute.arrayZ[0]);\n+      return_trace (true);\n+    }\n+    \/* Spec disallows this, but Uniscribe allows it.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/253 *\/\n+    else if (unlikely (count == 0))\n+    {\n+      c->buffer->delete_glyph ();\n+      return_trace (true);\n+    }\n+\n+    unsigned int klass = _hb_glyph_info_is_ligature (&c->buffer->cur()) ?\n+                         HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH : 0;\n+    unsigned lig_id = _hb_glyph_info_get_lig_id (&c->buffer->cur());\n+\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      \/* If is attached to a ligature, don't disturb that.\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3069 *\/\n+      if (!lig_id)\n+        _hb_glyph_info_set_lig_props_for_component (&c->buffer->cur(), i);\n+      c->output_glyph_for_component (substitute.arrayZ[i], klass);\n+    }\n+    c->buffer->skip_glyph ();\n+\n+    return_trace (true);\n+  }\n+\n+  template <typename Iterator,\n+            hb_requires (hb_is_source_of (Iterator, hb_codepoint_t))>\n+  bool serialize (hb_serialize_context_t *c,\n+                  Iterator subst)\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (substitute.serialize (c, subst));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    if (!intersects (&glyphset)) return_trace (false);\n+\n+    auto it =\n+    + hb_iter (substitute)\n+    | hb_map (glyph_map)\n+    ;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    return_trace (out->serialize (c->serializer, it));\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+\n+#endif \/* OT_LAYOUT_GSUB_SEQUENCE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/Sequence.hh","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+#ifndef OT_LAYOUT_GSUB_SINGLESUBST_HH\n+#define OT_LAYOUT_GSUB_SINGLESUBST_HH\n+\n+#include \"Common.hh\"\n+#include \"SingleSubstFormat1.hh\"\n+#include \"SingleSubstFormat2.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct SingleSubst\n+{\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  SingleSubstFormat1    format1;\n+  SingleSubstFormat2    format2;\n+  } u;\n+\n+  public:\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  template<typename Iterator,\n+           hb_requires (hb_is_sorted_source_of (Iterator,\n+                                                const hb_codepoint_pair_t))>\n+  bool serialize (hb_serialize_context_t *c,\n+                  Iterator glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n+    unsigned format = 2;\n+    unsigned delta = 0;\n+    if (glyphs)\n+    {\n+      format = 1;\n+      auto get_delta = [=] (hb_codepoint_pair_t _)\n+                       { return (unsigned) (_.second - _.first) & 0xFFFF; };\n+      delta = get_delta (*glyphs);\n+      if (!hb_all (++(+glyphs), delta, get_delta)) format = 2;\n+    }\n+    u.format = format;\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.serialize (c,\n+                                               + glyphs\n+                                               | hb_map_retains_sorting (hb_first),\n+                                               delta));\n+    case 2: return_trace (u.format2.serialize (c, glyphs));\n+    default:return_trace (false);\n+    }\n+  }\n+};\n+\n+template<typename Iterator>\n+static void\n+SingleSubst_serialize (hb_serialize_context_t *c,\n+                       Iterator it)\n+{ c->start_embed<SingleSubst> ()->serialize (c, it); }\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GSUB_SINGLESUBST_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubst.hh","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+#ifndef OT_LAYOUT_GSUB_SINGLESUBSTFORMAT1_HH\n+#define OT_LAYOUT_GSUB_SINGLESUBSTFORMAT1_HH\n+\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct SingleSubstFormat1\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  HBUINT16      deltaGlyphID;           \/* Add to original GlyphID to get\n+                                         * substitute GlyphID, modulo 0x10000 *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && deltaGlyphID.sanitize (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  bool may_have_non_1to1 () const\n+  { return false; }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    unsigned d = deltaGlyphID;\n+\n+    + hb_iter (this+coverage)\n+    | hb_filter (c->parent_active_glyphs ())\n+    | hb_map ([d] (hb_codepoint_t g) { return (g + d) & 0xFFFFu; })\n+    | hb_sink (c->output)\n+    ;\n+\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n+    unsigned d = deltaGlyphID;\n+    + hb_iter (this+coverage)\n+    | hb_map ([d] (hb_codepoint_t g) { return (g + d) & 0xFFFFu; })\n+    | hb_sink (c->output)\n+    ;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    \/* According to the Adobe Annotated OpenType Suite, result is always\n+     * limited to 16bit. *\/\n+    glyph_id = (glyph_id + deltaGlyphID) & 0xFFFFu;\n+    c->replace_glyph (glyph_id);\n+\n+    return_trace (true);\n+  }\n+\n+  template<typename Iterator,\n+           hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n+  bool serialize (hb_serialize_context_t *c,\n+                  Iterator glyphs,\n+                  unsigned delta)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    if (unlikely (!coverage.serialize_serialize (c, glyphs))) return_trace (false);\n+    c->check_assign (deltaGlyphID, delta, HB_SERIALIZE_ERROR_INT_OVERFLOW);\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    hb_codepoint_t delta = deltaGlyphID;\n+\n+    auto it =\n+    + hb_iter (this+coverage)\n+    | hb_filter (glyphset)\n+    | hb_map_retains_sorting ([&] (hb_codepoint_t g) {\n+                                return hb_codepoint_pair_t (g,\n+                                                            (g + delta) & 0xFFFF); })\n+    | hb_filter (glyphset, hb_second)\n+    | hb_map_retains_sorting ([&] (hb_codepoint_pair_t p) -> hb_codepoint_pair_t\n+                              { return hb_pair (glyph_map[p.first], glyph_map[p.second]); })\n+    ;\n+\n+    bool ret = bool (it);\n+    SingleSubst_serialize (c->serializer, it);\n+    return_trace (ret);\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+\n+#endif \/* OT_LAYOUT_GSUB_SINGLESUBSTFORMAT1_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubstFormat1.hh","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+#ifndef OT_LAYOUT_GSUB_SINGLESUBSTFORMAT2_HH\n+#define OT_LAYOUT_GSUB_SINGLESUBSTFORMAT2_HH\n+\n+#include \"Common.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct SingleSubstFormat2\n+{\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  Offset16To<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  Array16Of<HBGlyphID16>\n+                substitute;             \/* Array of substitute\n+                                         * GlyphIDs--ordered by Coverage Index *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (6, substitute);\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && substitute.sanitize (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  bool may_have_non_1to1 () const\n+  { return false; }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    + hb_zip (this+coverage, substitute)\n+    | hb_filter (c->parent_active_glyphs (), hb_first)\n+    | hb_map (hb_second)\n+    | hb_sink (c->output)\n+    ;\n+\n+  }\n+\n+  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n+    + hb_zip (this+coverage, substitute)\n+    | hb_map (hb_second)\n+    | hb_sink (c->output)\n+    ;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    if (unlikely (index >= substitute.len)) return_trace (false);\n+\n+    c->replace_glyph (substitute[index]);\n+\n+    return_trace (true);\n+  }\n+\n+  template<typename Iterator,\n+           hb_requires (hb_is_sorted_source_of (Iterator,\n+                                                hb_codepoint_pair_t))>\n+  bool serialize (hb_serialize_context_t *c,\n+                  Iterator it)\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto substitutes =\n+      + it\n+      | hb_map (hb_second)\n+      ;\n+    auto glyphs =\n+      + it\n+      | hb_map_retains_sorting (hb_first)\n+      ;\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    if (unlikely (!substitute.serialize (c, substitutes))) return_trace (false);\n+    if (unlikely (!coverage.serialize_serialize (c, glyphs))) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto it =\n+    + hb_zip (this+coverage, substitute)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter (glyphset, hb_second)\n+    | hb_map_retains_sorting ([&] (hb_pair_t<hb_codepoint_t, const HBGlyphID16 &> p) -> hb_codepoint_pair_t\n+                              { return hb_pair (glyph_map[p.first], glyph_map[p.second]); })\n+    ;\n+\n+    bool ret = bool (it);\n+    SingleSubst_serialize (c->serializer, it);\n+    return_trace (ret);\n+  }\n+};\n+\n+}\n+}\n+}\n+\n+#endif \/* OT_LAYOUT_GSUB_SINGLESUBSTFORMAT2_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubstFormat2.hh","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+#ifndef OT_LAYOUT_GSUB_SUBSTLOOKUP_HH\n+#define OT_LAYOUT_GSUB_SUBSTLOOKUP_HH\n+\n+#include \"Common.hh\"\n+#include \"SubstLookupSubTable.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct SubstLookup : Lookup\n+{\n+  using SubTable = SubstLookupSubTable;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  { return Lookup::sanitize<SubTable> (c); }\n+\n+  const SubTable& get_subtable (unsigned int i) const\n+  { return Lookup::get_subtable<SubTable> (i); }\n+\n+  static inline bool lookup_type_is_reverse (unsigned int lookup_type)\n+  { return lookup_type == SubTable::ReverseChainSingle; }\n+\n+  bool is_reverse () const\n+  {\n+    unsigned int type = get_type ();\n+    if (unlikely (type == SubTable::Extension))\n+      return reinterpret_cast<const ExtensionSubst &> (get_subtable (0)).is_reverse ();\n+    return lookup_type_is_reverse (type);\n+  }\n+\n+  bool may_have_non_1to1 () const\n+  {\n+    hb_have_non_1to1_context_t c;\n+    return dispatch (&c);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    return_trace (dispatch (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    hb_intersects_context_t c (glyphs);\n+    return dispatch (&c);\n+  }\n+\n+  hb_closure_context_t::return_t closure (hb_closure_context_t *c, unsigned int this_index) const\n+  {\n+    if (!c->should_visit_lookup (this_index))\n+      return hb_closure_context_t::default_return_value ();\n+\n+    c->set_recurse_func (dispatch_closure_recurse_func);\n+\n+    hb_closure_context_t::return_t ret = dispatch (c);\n+\n+    c->flush ();\n+\n+    return ret;\n+  }\n+\n+  hb_closure_lookups_context_t::return_t closure_lookups (hb_closure_lookups_context_t *c, unsigned this_index) const\n+  {\n+    if (c->is_lookup_visited (this_index))\n+      return hb_closure_lookups_context_t::default_return_value ();\n+\n+    c->set_lookup_visited (this_index);\n+    if (!intersects (c->glyphs))\n+    {\n+      c->set_lookup_inactive (this_index);\n+      return hb_closure_lookups_context_t::default_return_value ();\n+    }\n+\n+    hb_closure_lookups_context_t::return_t ret = dispatch (c);\n+    return ret;\n+  }\n+\n+  hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    c->set_recurse_func (dispatch_recurse_func<hb_collect_glyphs_context_t>);\n+    return dispatch (c);\n+  }\n+\n+  template <typename set_t>\n+  void collect_coverage (set_t *glyphs) const\n+  {\n+    hb_collect_coverage_context_t<set_t> c (glyphs);\n+    dispatch (&c);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c,\n+                    const hb_ot_layout_lookup_accelerator_t *accel) const\n+  {\n+    if (unlikely (!c->len)) return false;\n+    if (!accel->may_have (c->glyphs[0])) return false;\n+      return dispatch (c);\n+  }\n+\n+  bool serialize_single (hb_serialize_context_t *c,\n+                         uint32_t lookup_props,\n+                         hb_sorted_array_t<const HBGlyphID16> glyphs,\n+                         hb_array_t<const HBGlyphID16> substitutes)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!Lookup::serialize (c, SubTable::Single, lookup_props, 1))) return_trace (false);\n+    if (c->push<SubTable> ()->u.single.serialize (c, hb_zip (glyphs, substitutes)))\n+    {\n+      c->add_link (get_subtables<SubTable> ()[0], c->pop_pack ());\n+      return_trace (true);\n+    }\n+    c->pop_discard ();\n+    return_trace (false);\n+  }\n+\n+  bool serialize_multiple (hb_serialize_context_t *c,\n+                           uint32_t lookup_props,\n+                           hb_sorted_array_t<const HBGlyphID16> glyphs,\n+                           hb_array_t<const unsigned int> substitute_len_list,\n+                           hb_array_t<const HBGlyphID16> substitute_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!Lookup::serialize (c, SubTable::Multiple, lookup_props, 1))) return_trace (false);\n+    if (c->push<SubTable> ()->u.multiple.\n+        serialize (c,\n+                   glyphs,\n+                   substitute_len_list,\n+                   substitute_glyphs_list))\n+    {\n+      c->add_link (get_subtables<SubTable> ()[0], c->pop_pack ());\n+      return_trace (true);\n+    }\n+    c->pop_discard ();\n+    return_trace (false);\n+  }\n+\n+  bool serialize_alternate (hb_serialize_context_t *c,\n+                            uint32_t lookup_props,\n+                            hb_sorted_array_t<const HBGlyphID16> glyphs,\n+                            hb_array_t<const unsigned int> alternate_len_list,\n+                            hb_array_t<const HBGlyphID16> alternate_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!Lookup::serialize (c, SubTable::Alternate, lookup_props, 1))) return_trace (false);\n+\n+    if (c->push<SubTable> ()->u.alternate.\n+        serialize (c,\n+                   glyphs,\n+                   alternate_len_list,\n+                   alternate_glyphs_list))\n+    {\n+      c->add_link (get_subtables<SubTable> ()[0], c->pop_pack ());\n+      return_trace (true);\n+    }\n+    c->pop_discard ();\n+    return_trace (false);\n+  }\n+\n+  bool serialize_ligature (hb_serialize_context_t *c,\n+                           uint32_t lookup_props,\n+                           hb_sorted_array_t<const HBGlyphID16> first_glyphs,\n+                           hb_array_t<const unsigned int> ligature_per_first_glyph_count_list,\n+                           hb_array_t<const HBGlyphID16> ligatures_list,\n+                           hb_array_t<const unsigned int> component_count_list,\n+                           hb_array_t<const HBGlyphID16> component_list \/* Starting from second for each ligature *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!Lookup::serialize (c, SubTable::Ligature, lookup_props, 1))) return_trace (false);\n+    if (c->push<SubTable> ()->u.ligature.\n+        serialize (c,\n+                   first_glyphs,\n+                   ligature_per_first_glyph_count_list,\n+                   ligatures_list,\n+                   component_count_list,\n+                   component_list))\n+    {\n+      c->add_link (get_subtables<SubTable> ()[0], c->pop_pack ());\n+      return_trace (true);\n+    }\n+    c->pop_discard ();\n+    return_trace (false);\n+  }\n+\n+  template <typename context_t>\n+  static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n+\n+  static inline typename hb_closure_context_t::return_t closure_glyphs_recurse_func (hb_closure_context_t *c, unsigned lookup_index, hb_set_t *covered_seq_indices, unsigned seq_index, unsigned end_index);\n+\n+  static inline hb_closure_context_t::return_t dispatch_closure_recurse_func (hb_closure_context_t *c, unsigned lookup_index, hb_set_t *covered_seq_indices, unsigned seq_index, unsigned end_index)\n+  {\n+    if (!c->should_visit_lookup (lookup_index))\n+      return hb_empty_t ();\n+\n+    hb_closure_context_t::return_t ret = closure_glyphs_recurse_func (c, lookup_index, covered_seq_indices, seq_index, end_index);\n+\n+    \/* While in theory we should flush here, it will cause timeouts because a recursive\n+     * lookup can keep growing the glyph set.  Skip, and outer loop will retry up to\n+     * HB_CLOSURE_MAX_STAGES time, which should be enough for every realistic font. *\/\n+    \/\/c->flush ();\n+\n+    return ret;\n+  }\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  { return Lookup::dispatch<SubTable> (c, std::forward<Ts> (ds)...); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  { return Lookup::subset<SubTable> (c); }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/* OT_LAYOUT_GSUB_SUBSTLOOKUP_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SubstLookup.hh","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+#ifndef OT_LAYOUT_GSUB_SUBSTLOOKUPSUBTABLE_HH\n+#define OT_LAYOUT_GSUB_SUBSTLOOKUPSUBTABLE_HH\n+\n+#include \"Common.hh\"\n+#include \"SingleSubst.hh\"\n+#include \"MultipleSubst.hh\"\n+#include \"AlternateSubst.hh\"\n+#include \"LigatureSubst.hh\"\n+#include \"ContextSubst.hh\"\n+#include \"ChainContextSubst.hh\"\n+#include \"ExtensionSubst.hh\"\n+#include \"ReverseChainSingleSubst.hh\"\n+\n+namespace OT {\n+namespace Layout {\n+namespace GSUB {\n+\n+struct SubstLookupSubTable\n+{\n+  friend struct ::OT::Lookup;\n+  friend struct SubstLookup;\n+\n+  protected:\n+  union {\n+  SingleSubst                   single;\n+  MultipleSubst                 multiple;\n+  AlternateSubst                alternate;\n+  LigatureSubst                 ligature;\n+  ContextSubst                  context;\n+  ChainContextSubst             chainContext;\n+  ExtensionSubst                extension;\n+  ReverseChainSingleSubst       reverseChainContextSingle;\n+  } u;\n+  public:\n+  DEFINE_SIZE_MIN (0);\n+\n+  enum Type {\n+    Single              = 1,\n+    Multiple            = 2,\n+    Alternate           = 3,\n+    Ligature            = 4,\n+    Context             = 5,\n+    ChainContext        = 6,\n+    Extension           = 7,\n+    ReverseChainSingle  = 8\n+  };\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, lookup_type);\n+    switch (lookup_type) {\n+    case Single:                return_trace (u.single.dispatch (c, std::forward<Ts> (ds)...));\n+    case Multiple:              return_trace (u.multiple.dispatch (c, std::forward<Ts> (ds)...));\n+    case Alternate:             return_trace (u.alternate.dispatch (c, std::forward<Ts> (ds)...));\n+    case Ligature:              return_trace (u.ligature.dispatch (c, std::forward<Ts> (ds)...));\n+    case Context:               return_trace (u.context.dispatch (c, std::forward<Ts> (ds)...));\n+    case ChainContext:          return_trace (u.chainContext.dispatch (c, std::forward<Ts> (ds)...));\n+    case Extension:             return_trace (u.extension.dispatch (c, std::forward<Ts> (ds)...));\n+    case ReverseChainSingle:    return_trace (u.reverseChainContextSingle.dispatch (c, std::forward<Ts> (ds)...));\n+    default:                    return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs, unsigned int lookup_type) const\n+  {\n+    hb_intersects_context_t c (glyphs);\n+    return dispatch (&c, lookup_type);\n+  }\n+};\n+\n+\n+}\n+}\n+}\n+\n+#endif  \/* HB_OT_LAYOUT_GSUB_SUBSTLOOKUPSUBTABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SubstLookupSubTable.hh","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,258 @@\n+#ifndef OT_GLYF_COMPOSITEGLYPH_HH\n+#define OT_GLYF_COMPOSITEGLYPH_HH\n+\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+\n+\n+namespace OT {\n+namespace glyf_impl {\n+\n+\n+struct CompositeGlyphRecord\n+{\n+  protected:\n+  enum composite_glyph_flag_t\n+  {\n+    ARG_1_AND_2_ARE_WORDS       = 0x0001,\n+    ARGS_ARE_XY_VALUES          = 0x0002,\n+    ROUND_XY_TO_GRID            = 0x0004,\n+    WE_HAVE_A_SCALE             = 0x0008,\n+    MORE_COMPONENTS             = 0x0020,\n+    WE_HAVE_AN_X_AND_Y_SCALE    = 0x0040,\n+    WE_HAVE_A_TWO_BY_TWO        = 0x0080,\n+    WE_HAVE_INSTRUCTIONS        = 0x0100,\n+    USE_MY_METRICS              = 0x0200,\n+    OVERLAP_COMPOUND            = 0x0400,\n+    SCALED_COMPONENT_OFFSET     = 0x0800,\n+    UNSCALED_COMPONENT_OFFSET   = 0x1000\n+  };\n+\n+  public:\n+  unsigned int get_size () const\n+  {\n+    unsigned int size = min_size;\n+    \/* arg1 and 2 are int16 *\/\n+    if (flags & ARG_1_AND_2_ARE_WORDS) size += 4;\n+    \/* arg1 and 2 are int8 *\/\n+    else size += 2;\n+\n+    \/* One x 16 bit (scale) *\/\n+    if (flags & WE_HAVE_A_SCALE) size += 2;\n+    \/* Two x 16 bit (xscale, yscale) *\/\n+    else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) size += 4;\n+    \/* Four x 16 bit (xscale, scale01, scale10, yscale) *\/\n+    else if (flags & WE_HAVE_A_TWO_BY_TWO) size += 8;\n+\n+    return size;\n+  }\n+\n+  void drop_instructions_flag ()  { flags = (uint16_t) flags & ~WE_HAVE_INSTRUCTIONS; }\n+  void set_overlaps_flag ()\n+  {\n+    flags = (uint16_t) flags | OVERLAP_COMPOUND;\n+  }\n+\n+  bool has_instructions ()  const { return   flags & WE_HAVE_INSTRUCTIONS; }\n+\n+  bool has_more ()          const { return   flags & MORE_COMPONENTS; }\n+  bool is_use_my_metrics () const { return   flags & USE_MY_METRICS; }\n+  bool is_anchored ()       const { return !(flags & ARGS_ARE_XY_VALUES); }\n+  void get_anchor_points (unsigned int &point1, unsigned int &point2) const\n+  {\n+    const HBUINT8 *p = &StructAfter<const HBUINT8> (glyphIndex);\n+    if (flags & ARG_1_AND_2_ARE_WORDS)\n+    {\n+      point1 = ((const HBUINT16 *) p)[0];\n+      point2 = ((const HBUINT16 *) p)[1];\n+    }\n+    else\n+    {\n+      point1 = p[0];\n+      point2 = p[1];\n+    }\n+  }\n+\n+  void transform_points (contour_point_vector_t &points) const\n+  {\n+    float matrix[4];\n+    contour_point_t trans;\n+    if (get_transformation (matrix, trans))\n+    {\n+      if (scaled_offsets ())\n+      {\n+        points.translate (trans);\n+        points.transform (matrix);\n+      }\n+      else\n+      {\n+        points.transform (matrix);\n+        points.translate (trans);\n+      }\n+    }\n+  }\n+\n+  protected:\n+  bool scaled_offsets () const\n+  { return (flags & (SCALED_COMPONENT_OFFSET | UNSCALED_COMPONENT_OFFSET)) == SCALED_COMPONENT_OFFSET; }\n+\n+  bool get_transformation (float (&matrix)[4], contour_point_t &trans) const\n+  {\n+    matrix[0] = matrix[3] = 1.f;\n+    matrix[1] = matrix[2] = 0.f;\n+\n+    int tx, ty;\n+    const HBINT8 *p = &StructAfter<const HBINT8> (glyphIndex);\n+    if (flags & ARG_1_AND_2_ARE_WORDS)\n+    {\n+      tx = *(const HBINT16 *) p;\n+      p += HBINT16::static_size;\n+      ty = *(const HBINT16 *) p;\n+      p += HBINT16::static_size;\n+    }\n+    else\n+    {\n+      tx = *p++;\n+      ty = *p++;\n+    }\n+    if (is_anchored ()) tx = ty = 0;\n+\n+    trans.init ((float) tx, (float) ty);\n+\n+    {\n+      const F2DOT14 *points = (const F2DOT14 *) p;\n+      if (flags & WE_HAVE_A_SCALE)\n+      {\n+        matrix[0] = matrix[3] = points[0].to_float ();\n+        return true;\n+      }\n+      else if (flags & WE_HAVE_AN_X_AND_Y_SCALE)\n+      {\n+        matrix[0] = points[0].to_float ();\n+        matrix[3] = points[1].to_float ();\n+        return true;\n+      }\n+      else if (flags & WE_HAVE_A_TWO_BY_TWO)\n+      {\n+        matrix[0] = points[0].to_float ();\n+        matrix[1] = points[1].to_float ();\n+        matrix[2] = points[2].to_float ();\n+        matrix[3] = points[3].to_float ();\n+        return true;\n+      }\n+    }\n+    return tx || ty;\n+  }\n+\n+  public:\n+  HBUINT16      flags;\n+  HBGlyphID16   glyphIndex;\n+  public:\n+  DEFINE_SIZE_MIN (4);\n+};\n+\n+struct composite_iter_t : hb_iter_with_fallback_t<composite_iter_t, const CompositeGlyphRecord &>\n+{\n+  typedef const CompositeGlyphRecord *__item_t__;\n+  composite_iter_t (hb_bytes_t glyph_, __item_t__ current_) :\n+      glyph (glyph_), current (nullptr), current_size (0)\n+  {\n+    set_current (current_);\n+  }\n+\n+  composite_iter_t () : glyph (hb_bytes_t ()), current (nullptr), current_size (0) {}\n+\n+  item_t __item__ () const { return *current; }\n+  bool __more__ () const { return current; }\n+  void __next__ ()\n+  {\n+    if (!current->has_more ()) { current = nullptr; return; }\n+\n+    set_current (&StructAtOffset<CompositeGlyphRecord> (current, current_size));\n+  }\n+  composite_iter_t __end__ () const { return composite_iter_t (); }\n+  bool operator != (const composite_iter_t& o) const\n+  { return current != o.current; }\n+\n+\n+  void set_current (__item_t__ current_)\n+  {\n+    if (!glyph.check_range (current_, CompositeGlyphRecord::min_size))\n+    {\n+      current = nullptr;\n+      current_size = 0;\n+      return;\n+    }\n+    unsigned size = current_->get_size ();\n+    if (!glyph.check_range (current_, size))\n+    {\n+      current = nullptr;\n+      current_size = 0;\n+      return;\n+    }\n+\n+    current = current_;\n+    current_size = size;\n+  }\n+\n+  private:\n+  hb_bytes_t glyph;\n+  __item_t__ current;\n+  unsigned current_size;\n+};\n+\n+struct CompositeGlyph\n+{\n+  const GlyphHeader &header;\n+  hb_bytes_t bytes;\n+  CompositeGlyph (const GlyphHeader &header_, hb_bytes_t bytes_) :\n+    header (header_), bytes (bytes_) {}\n+\n+  composite_iter_t iter () const\n+  { return composite_iter_t (bytes, &StructAfter<CompositeGlyphRecord, GlyphHeader> (header)); }\n+\n+  unsigned int instructions_length (hb_bytes_t bytes) const\n+  {\n+    unsigned int start = bytes.length;\n+    unsigned int end = bytes.length;\n+    const CompositeGlyphRecord *last = nullptr;\n+    for (auto &item : iter ())\n+      last = &item;\n+    if (unlikely (!last)) return 0;\n+\n+    if (last->has_instructions ())\n+      start = (char *) last - &bytes + last->get_size ();\n+    if (unlikely (start > end)) return 0;\n+    return end - start;\n+  }\n+\n+  \/* Trimming for composites not implemented.\n+   * If removing hints it falls out of that. *\/\n+  const hb_bytes_t trim_padding () const { return bytes; }\n+\n+  void drop_hints ()\n+  {\n+    for (const auto &_ : iter ())\n+      const_cast<CompositeGlyphRecord &> (_).drop_instructions_flag ();\n+  }\n+\n+  \/* Chop instructions off the end *\/\n+  void drop_hints_bytes (hb_bytes_t &dest_start) const\n+  { dest_start = bytes.sub_array (0, bytes.length - instructions_length (bytes)); }\n+\n+  void set_overlaps_flag ()\n+  {\n+    CompositeGlyphRecord& glyph_chain = const_cast<CompositeGlyphRecord &> (\n+        StructAfter<CompositeGlyphRecord, GlyphHeader> (header));\n+    if (!bytes.check_range(&glyph_chain, CompositeGlyphRecord::min_size))\n+      return;\n+    glyph_chain.set_overlaps_flag ();\n+  }\n+};\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_COMPOSITEGLYPH_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/CompositeGlyph.hh","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+#ifndef OT_GLYF_GLYPH_HH\n+#define OT_GLYF_GLYPH_HH\n+\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+\n+#include \"GlyphHeader.hh\"\n+#include \"SimpleGlyph.hh\"\n+#include \"CompositeGlyph.hh\"\n+\n+\n+namespace OT {\n+\n+struct glyf_accelerator_t;\n+\n+namespace glyf_impl {\n+\n+\n+enum phantom_point_index_t\n+{\n+  PHANTOM_LEFT   = 0,\n+  PHANTOM_RIGHT  = 1,\n+  PHANTOM_TOP    = 2,\n+  PHANTOM_BOTTOM = 3,\n+  PHANTOM_COUNT  = 4\n+};\n+\n+struct Glyph\n+{\n+  enum glyph_type_t { EMPTY, SIMPLE, COMPOSITE };\n+\n+  public:\n+  composite_iter_t get_composite_iterator () const\n+  {\n+    if (type != COMPOSITE) return composite_iter_t ();\n+    return CompositeGlyph (*header, bytes).iter ();\n+  }\n+\n+  const hb_bytes_t trim_padding () const\n+  {\n+    switch (type) {\n+    case COMPOSITE: return CompositeGlyph (*header, bytes).trim_padding ();\n+    case SIMPLE:    return SimpleGlyph (*header, bytes).trim_padding ();\n+    default:        return bytes;\n+    }\n+  }\n+\n+  void drop_hints ()\n+  {\n+    switch (type) {\n+    case COMPOSITE: CompositeGlyph (*header, bytes).drop_hints (); return;\n+    case SIMPLE:    SimpleGlyph (*header, bytes).drop_hints (); return;\n+    default:        return;\n+    }\n+  }\n+\n+  void set_overlaps_flag ()\n+  {\n+    switch (type) {\n+    case COMPOSITE: CompositeGlyph (*header, bytes).set_overlaps_flag (); return;\n+    case SIMPLE:    SimpleGlyph (*header, bytes).set_overlaps_flag (); return;\n+    default:        return;\n+    }\n+  }\n+\n+  void drop_hints_bytes (hb_bytes_t &dest_start, hb_bytes_t &dest_end) const\n+  {\n+    switch (type) {\n+    case COMPOSITE: CompositeGlyph (*header, bytes).drop_hints_bytes (dest_start); return;\n+    case SIMPLE:    SimpleGlyph (*header, bytes).drop_hints_bytes (dest_start, dest_end); return;\n+    default:        return;\n+    }\n+  }\n+\n+  \/* Note: Recursively calls itself.\n+   * all_points includes phantom points\n+   *\/\n+  template <typename accelerator_t>\n+  bool get_points (hb_font_t *font, const accelerator_t &glyf_accelerator,\n+                   contour_point_vector_t &all_points \/* OUT *\/,\n+                   bool phantom_only = false,\n+                   unsigned int depth = 0) const\n+  {\n+    if (unlikely (depth > HB_MAX_NESTING_LEVEL)) return false;\n+    contour_point_vector_t stack_points;\n+    bool inplace = type == SIMPLE && all_points.length == 0;\n+    \/* Load into all_points if it's empty, as an optimization. *\/\n+    contour_point_vector_t &points = inplace ? all_points : stack_points;\n+\n+    switch (type) {\n+    case COMPOSITE:\n+    {\n+      \/* pseudo component points for each component in composite glyph *\/\n+      unsigned num_points = hb_len (CompositeGlyph (*header, bytes).iter ());\n+      if (unlikely (!points.resize (num_points))) return false;\n+      break;\n+    }\n+    case SIMPLE:\n+      if (unlikely (!SimpleGlyph (*header, bytes).get_contour_points (points, phantom_only)))\n+        return false;\n+      break;\n+    }\n+\n+    \/* Init phantom points *\/\n+    if (unlikely (!points.resize (points.length + PHANTOM_COUNT))) return false;\n+    hb_array_t<contour_point_t> phantoms = points.sub_array (points.length - PHANTOM_COUNT, PHANTOM_COUNT);\n+    {\n+      int h_delta = (int) header->xMin -\n+                    glyf_accelerator.hmtx->get_side_bearing (gid);\n+      int v_orig  = (int) header->yMax +\n+#ifndef HB_NO_VERTICAL\n+                    glyf_accelerator.vmtx->get_side_bearing (gid)\n+#else\n+                    0\n+#endif\n+                    ;\n+      unsigned h_adv = glyf_accelerator.hmtx->get_advance (gid);\n+      unsigned v_adv =\n+#ifndef HB_NO_VERTICAL\n+                       glyf_accelerator.vmtx->get_advance (gid)\n+#else\n+                       - font->face->get_upem ()\n+#endif\n+                       ;\n+      phantoms[PHANTOM_LEFT].x = h_delta;\n+      phantoms[PHANTOM_RIGHT].x = h_adv + h_delta;\n+      phantoms[PHANTOM_TOP].y = v_orig;\n+      phantoms[PHANTOM_BOTTOM].y = v_orig - (int) v_adv;\n+    }\n+\n+#ifndef HB_NO_VAR\n+    glyf_accelerator.gvar->apply_deltas_to_points (gid, font, points.as_array ());\n+#endif\n+\n+    switch (type) {\n+    case SIMPLE:\n+      if (!inplace)\n+        all_points.extend (points.as_array ());\n+      break;\n+    case COMPOSITE:\n+    {\n+      contour_point_vector_t comp_points;\n+      unsigned int comp_index = 0;\n+      for (auto &item : get_composite_iterator ())\n+      {\n+        comp_points.reset ();\n+        if (unlikely (!glyf_accelerator.glyph_for_gid (item.glyphIndex)\n+                                       .get_points (font, glyf_accelerator, comp_points,\n+                                                    phantom_only, depth + 1)))\n+          return false;\n+\n+        \/* Copy phantom points from component if USE_MY_METRICS flag set *\/\n+        if (item.is_use_my_metrics ())\n+          for (unsigned int i = 0; i < PHANTOM_COUNT; i++)\n+            phantoms[i] = comp_points[comp_points.length - PHANTOM_COUNT + i];\n+\n+        \/* Apply component transformation & translation *\/\n+        item.transform_points (comp_points);\n+\n+        \/* Apply translation from gvar *\/\n+        comp_points.translate (points[comp_index]);\n+\n+        if (item.is_anchored ())\n+        {\n+          unsigned int p1, p2;\n+          item.get_anchor_points (p1, p2);\n+          if (likely (p1 < all_points.length && p2 < comp_points.length))\n+          {\n+            contour_point_t delta;\n+            delta.init (all_points[p1].x - comp_points[p2].x,\n+                        all_points[p1].y - comp_points[p2].y);\n+\n+            comp_points.translate (delta);\n+          }\n+        }\n+\n+        all_points.extend (comp_points.sub_array (0, comp_points.length - PHANTOM_COUNT));\n+\n+        comp_index++;\n+      }\n+\n+      all_points.extend (phantoms);\n+    } break;\n+    default:\n+      all_points.extend (phantoms);\n+    }\n+\n+    if (depth == 0) \/* Apply at top level *\/\n+    {\n+      \/* Undocumented rasterizer behavior:\n+       * Shift points horizontally by the updated left side bearing\n+       *\/\n+      contour_point_t delta;\n+      delta.init (-phantoms[PHANTOM_LEFT].x, 0.f);\n+      if (delta.x) all_points.translate (delta);\n+    }\n+\n+    return !all_points.in_error ();\n+  }\n+\n+  bool get_extents (hb_font_t *font, const glyf_accelerator_t &glyf_accelerator,\n+                    hb_glyph_extents_t *extents) const\n+  {\n+    if (type == EMPTY) return true; \/* Empty glyph; zero extents. *\/\n+    return header->get_extents (font, glyf_accelerator, gid, extents);\n+  }\n+\n+  hb_bytes_t get_bytes () const { return bytes; }\n+\n+  Glyph (hb_bytes_t bytes_ = hb_bytes_t (),\n+         hb_codepoint_t gid_ = (hb_codepoint_t) -1) : bytes (bytes_),\n+                                                      header (bytes.as<GlyphHeader> ()),\n+                                                      gid (gid_)\n+  {\n+    int num_contours = header->numberOfContours;\n+    if (unlikely (num_contours == 0)) type = EMPTY;\n+    else if (num_contours > 0) type = SIMPLE;\n+    else type = COMPOSITE; \/* negative numbers *\/\n+  }\n+\n+  protected:\n+  hb_bytes_t bytes;\n+  const GlyphHeader *header;\n+  hb_codepoint_t gid;\n+  unsigned type;\n+};\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_GLYPH_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/Glyph.hh","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+#ifndef OT_GLYF_GLYPHHEADER_HH\n+#define OT_GLYF_GLYPHHEADER_HH\n+\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+\n+\n+namespace OT {\n+namespace glyf_impl {\n+\n+\n+struct GlyphHeader\n+{\n+  bool has_data () const { return numberOfContours; }\n+\n+  template <typename accelerator_t>\n+  bool get_extents (hb_font_t *font, const accelerator_t &glyf_accelerator,\n+                    hb_codepoint_t gid, hb_glyph_extents_t *extents) const\n+  {\n+    \/* Undocumented rasterizer behavior: shift glyph to the left by (lsb - xMin), i.e., xMin = lsb *\/\n+    \/* extents->x_bearing = hb_min (glyph_header.xMin, glyph_header.xMax); *\/\n+    extents->x_bearing = font->em_scale_x (glyf_accelerator.hmtx->get_side_bearing (gid));\n+    extents->y_bearing = font->em_scale_y (hb_max (yMin, yMax));\n+    extents->width     = font->em_scale_x (hb_max (xMin, xMax) - hb_min (xMin, xMax));\n+    extents->height    = font->em_scale_y (hb_min (yMin, yMax) - hb_max (yMin, yMax));\n+\n+    return true;\n+  }\n+\n+  HBINT16       numberOfContours;\n+                    \/* If the number of contours is\n+                     * greater than or equal to zero,\n+                     * this is a simple glyph; if negative,\n+                     * this is a composite glyph. *\/\n+  FWORD xMin;   \/* Minimum x for coordinate data. *\/\n+  FWORD yMin;   \/* Minimum y for coordinate data. *\/\n+  FWORD xMax;   \/* Maximum x for coordinate data. *\/\n+  FWORD yMax;   \/* Maximum y for coordinate data. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_GLYPHHEADER_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/GlyphHeader.hh","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+#ifndef OT_GLYF_SIMPLEGLYPH_HH\n+#define OT_GLYF_SIMPLEGLYPH_HH\n+\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+\n+\n+namespace OT {\n+namespace glyf_impl {\n+\n+\n+struct SimpleGlyph\n+{\n+  enum simple_glyph_flag_t\n+  {\n+    FLAG_ON_CURVE       = 0x01,\n+    FLAG_X_SHORT        = 0x02,\n+    FLAG_Y_SHORT        = 0x04,\n+    FLAG_REPEAT         = 0x08,\n+    FLAG_X_SAME         = 0x10,\n+    FLAG_Y_SAME         = 0x20,\n+    FLAG_OVERLAP_SIMPLE = 0x40,\n+    FLAG_RESERVED2      = 0x80\n+  };\n+\n+  const GlyphHeader &header;\n+  hb_bytes_t bytes;\n+  SimpleGlyph (const GlyphHeader &header_, hb_bytes_t bytes_) :\n+    header (header_), bytes (bytes_) {}\n+\n+  unsigned int instruction_len_offset () const\n+  { return GlyphHeader::static_size + 2 * header.numberOfContours; }\n+\n+  unsigned int length (unsigned int instruction_len) const\n+  { return instruction_len_offset () + 2 + instruction_len; }\n+\n+  unsigned int instructions_length () const\n+  {\n+    unsigned int instruction_length_offset = instruction_len_offset ();\n+    if (unlikely (instruction_length_offset + 2 > bytes.length)) return 0;\n+\n+    const HBUINT16 &instructionLength = StructAtOffset<HBUINT16> (&bytes, instruction_length_offset);\n+    \/* Out of bounds of the current glyph *\/\n+    if (unlikely (length (instructionLength) > bytes.length)) return 0;\n+    return instructionLength;\n+  }\n+\n+  const hb_bytes_t trim_padding () const\n+  {\n+    \/* based on FontTools _g_l_y_f.py::trim *\/\n+    const uint8_t *glyph = (uint8_t*) bytes.arrayZ;\n+    const uint8_t *glyph_end = glyph + bytes.length;\n+    \/* simple glyph w\/contours, possibly trimmable *\/\n+    glyph += instruction_len_offset ();\n+\n+    if (unlikely (glyph + 2 >= glyph_end)) return hb_bytes_t ();\n+    unsigned int num_coordinates = StructAtOffset<HBUINT16> (glyph - 2, 0) + 1;\n+    unsigned int num_instructions = StructAtOffset<HBUINT16> (glyph, 0);\n+\n+    glyph += 2 + num_instructions;\n+\n+    unsigned int coord_bytes = 0;\n+    unsigned int coords_with_flags = 0;\n+    while (glyph < glyph_end)\n+    {\n+      uint8_t flag = *glyph;\n+      glyph++;\n+\n+      unsigned int repeat = 1;\n+      if (flag & FLAG_REPEAT)\n+      {\n+        if (unlikely (glyph >= glyph_end)) return hb_bytes_t ();\n+        repeat = *glyph + 1;\n+        glyph++;\n+      }\n+\n+      unsigned int xBytes, yBytes;\n+      xBytes = yBytes = 0;\n+      if (flag & FLAG_X_SHORT) xBytes = 1;\n+      else if ((flag & FLAG_X_SAME) == 0) xBytes = 2;\n+\n+      if (flag & FLAG_Y_SHORT) yBytes = 1;\n+      else if ((flag & FLAG_Y_SAME) == 0) yBytes = 2;\n+\n+      coord_bytes += (xBytes + yBytes) * repeat;\n+      coords_with_flags += repeat;\n+      if (coords_with_flags >= num_coordinates) break;\n+    }\n+\n+    if (unlikely (coords_with_flags != num_coordinates)) return hb_bytes_t ();\n+    return bytes.sub_array (0, bytes.length + coord_bytes - (glyph_end - glyph));\n+  }\n+\n+  \/* zero instruction length *\/\n+  void drop_hints ()\n+  {\n+    GlyphHeader &glyph_header = const_cast<GlyphHeader &> (header);\n+    (HBUINT16 &) StructAtOffset<HBUINT16> (&glyph_header, instruction_len_offset ()) = 0;\n+  }\n+\n+  void drop_hints_bytes (hb_bytes_t &dest_start, hb_bytes_t &dest_end) const\n+  {\n+    unsigned int instructions_len = instructions_length ();\n+    unsigned int glyph_length = length (instructions_len);\n+    dest_start = bytes.sub_array (0, glyph_length - instructions_len);\n+    dest_end = bytes.sub_array (glyph_length, bytes.length - glyph_length);\n+  }\n+\n+  void set_overlaps_flag ()\n+  {\n+    if (unlikely (!header.numberOfContours)) return;\n+\n+    unsigned flags_offset = length (instructions_length ());\n+    if (unlikely (flags_offset + 1 > bytes.length)) return;\n+\n+    HBUINT8 &first_flag = (HBUINT8 &) StructAtOffset<HBUINT16> (&bytes, flags_offset);\n+    first_flag = (uint8_t) first_flag | FLAG_OVERLAP_SIMPLE;\n+  }\n+\n+  static bool read_flags (const HBUINT8 *&p \/* IN\/OUT *\/,\n+                          contour_point_vector_t &points_ \/* IN\/OUT *\/,\n+                          const HBUINT8 *end)\n+  {\n+    unsigned count = points_.length;\n+    for (unsigned int i = 0; i < count;)\n+    {\n+      if (unlikely (p + 1 > end)) return false;\n+      uint8_t flag = *p++;\n+      points_.arrayZ[i++].flag = flag;\n+      if (flag & FLAG_REPEAT)\n+      {\n+        if (unlikely (p + 1 > end)) return false;\n+        unsigned int repeat_count = *p++;\n+        unsigned stop = hb_min (i + repeat_count, count);\n+        for (; i < stop;)\n+          points_.arrayZ[i++].flag = flag;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  static bool read_points (const HBUINT8 *&p \/* IN\/OUT *\/,\n+                           contour_point_vector_t &points_ \/* IN\/OUT *\/,\n+                           const HBUINT8 *end,\n+                           float contour_point_t::*m,\n+                           const simple_glyph_flag_t short_flag,\n+                           const simple_glyph_flag_t same_flag)\n+  {\n+    int v = 0;\n+\n+    unsigned count = points_.length;\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      unsigned flag = points_[i].flag;\n+      if (flag & short_flag)\n+      {\n+        if (unlikely (p + 1 > end)) return false;\n+        if (flag & same_flag)\n+          v += *p++;\n+        else\n+          v -= *p++;\n+      }\n+      else\n+      {\n+        if (!(flag & same_flag))\n+        {\n+          if (unlikely (p + HBINT16::static_size > end)) return false;\n+          v += *(const HBINT16 *) p;\n+          p += HBINT16::static_size;\n+        }\n+      }\n+      points_.arrayZ[i].*m = v;\n+    }\n+    return true;\n+  }\n+\n+  bool get_contour_points (contour_point_vector_t &points_ \/* OUT *\/,\n+                           bool phantom_only = false) const\n+  {\n+    const HBUINT16 *endPtsOfContours = &StructAfter<HBUINT16> (header);\n+    int num_contours = header.numberOfContours;\n+    assert (num_contours);\n+    \/* One extra item at the end, for the instruction-count below. *\/\n+    if (unlikely (!bytes.check_range (&endPtsOfContours[num_contours]))) return false;\n+    unsigned int num_points = endPtsOfContours[num_contours - 1] + 1;\n+\n+    points_.alloc (num_points + 4); \/\/ Allocate for phantom points, to avoid a possible copy\n+    if (!points_.resize (num_points)) return false;\n+    if (phantom_only) return true;\n+\n+    for (int i = 0; i < num_contours; i++)\n+      points_[endPtsOfContours[i]].is_end_point = true;\n+\n+    \/* Skip instructions *\/\n+    const HBUINT8 *p = &StructAtOffset<HBUINT8> (&endPtsOfContours[num_contours + 1],\n+                                                 endPtsOfContours[num_contours]);\n+\n+    if (unlikely ((const char *) p < bytes.arrayZ)) return false; \/* Unlikely overflow *\/\n+    const HBUINT8 *end = (const HBUINT8 *) (bytes.arrayZ + bytes.length);\n+    if (unlikely (p >= end)) return false;\n+\n+    \/* Read x & y coordinates *\/\n+    return read_flags (p, points_, end)\n+        && read_points (p, points_, end, &contour_point_t::x,\n+                        FLAG_X_SHORT, FLAG_X_SAME)\n+        && read_points (p, points_, end, &contour_point_t::y,\n+                        FLAG_Y_SHORT, FLAG_Y_SAME);\n+  }\n+};\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_SIMPLEGLYPH_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/SimpleGlyph.hh","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+#ifndef OT_GLYF_SUBSETGLYPH_HH\n+#define OT_GLYF_SUBSETGLYPH_HH\n+\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+\n+\n+namespace OT {\n+namespace glyf_impl {\n+\n+\n+struct SubsetGlyph\n+{\n+  hb_codepoint_t new_gid;\n+  hb_codepoint_t old_gid;\n+  Glyph source_glyph;\n+  hb_bytes_t dest_start;  \/* region of source_glyph to copy first *\/\n+  hb_bytes_t dest_end;    \/* region of source_glyph to copy second *\/\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  bool use_short_loca,\n+                  const hb_subset_plan_t *plan) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    hb_bytes_t dest_glyph = dest_start.copy (c);\n+    dest_glyph = hb_bytes_t (&dest_glyph, dest_glyph.length + dest_end.copy (c).length);\n+    unsigned int pad_length = use_short_loca ? padding () : 0;\n+    DEBUG_MSG (SUBSET, nullptr, \"serialize %d byte glyph, width %d pad %d\", dest_glyph.length, dest_glyph.length + pad_length, pad_length);\n+\n+    HBUINT8 pad;\n+    pad = 0;\n+    while (pad_length > 0)\n+    {\n+      c->embed (pad);\n+      pad_length--;\n+    }\n+\n+    if (unlikely (!dest_glyph.length)) return_trace (true);\n+\n+    \/* update components gids *\/\n+    for (auto &_ : Glyph (dest_glyph).get_composite_iterator ())\n+    {\n+      hb_codepoint_t new_gid;\n+      if (plan->new_gid_for_old_gid (_.glyphIndex, &new_gid))\n+        const_cast<CompositeGlyphRecord &> (_).glyphIndex = new_gid;\n+    }\n+\n+    if (plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n+      Glyph (dest_glyph).drop_hints ();\n+\n+    if (plan->flags & HB_SUBSET_FLAGS_SET_OVERLAPS_FLAG)\n+      Glyph (dest_glyph).set_overlaps_flag ();\n+\n+    return_trace (true);\n+  }\n+\n+  void drop_hints_bytes ()\n+  { source_glyph.drop_hints_bytes (dest_start, dest_end); }\n+\n+  unsigned int      length () const { return dest_start.length + dest_end.length; }\n+  \/* pad to 2 to ensure 2-byte loca will be ok *\/\n+  unsigned int     padding () const { return length () % 2; }\n+  unsigned int padded_size () const { return length () + padding (); }\n+};\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_SUBSETGLYPH_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/SubsetGlyph.hh","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+#ifndef OT_GLYF_GLYF_HELPERS_HH\n+#define OT_GLYF_GLYF_HELPERS_HH\n+\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+#include \"..\/..\/hb-subset-plan.hh\"\n+\n+#include \"loca.hh\"\n+\n+\n+namespace OT {\n+namespace glyf_impl {\n+\n+\n+template<typename IteratorIn, typename IteratorOut,\n+         hb_requires (hb_is_source_of (IteratorIn, unsigned int)),\n+         hb_requires (hb_is_sink_of (IteratorOut, unsigned))>\n+static void\n+_write_loca (IteratorIn it, bool short_offsets, IteratorOut dest)\n+{\n+  unsigned right_shift = short_offsets ? 1 : 0;\n+  unsigned int offset = 0;\n+  dest << 0;\n+  + it\n+  | hb_map ([=, &offset] (unsigned int padded_size)\n+            {\n+              offset += padded_size;\n+              DEBUG_MSG (SUBSET, nullptr, \"loca entry offset %d\", offset);\n+              return offset >> right_shift;\n+            })\n+  | hb_sink (dest)\n+  ;\n+}\n+\n+static bool\n+_add_head_and_set_loca_version (hb_subset_plan_t *plan, bool use_short_loca)\n+{\n+  hb_blob_t *head_blob = hb_sanitize_context_t ().reference_table<head> (plan->source);\n+  hb_blob_t *head_prime_blob = hb_blob_copy_writable_or_fail (head_blob);\n+  hb_blob_destroy (head_blob);\n+\n+  if (unlikely (!head_prime_blob))\n+    return false;\n+\n+  head *head_prime = (head *) hb_blob_get_data_writable (head_prime_blob, nullptr);\n+  head_prime->indexToLocFormat = use_short_loca ? 0 : 1;\n+  bool success = plan->add_table (HB_OT_TAG_head, head_prime_blob);\n+\n+  hb_blob_destroy (head_prime_blob);\n+  return success;\n+}\n+\n+template<typename Iterator,\n+         hb_requires (hb_is_source_of (Iterator, unsigned int))>\n+static bool\n+_add_loca_and_head (hb_subset_plan_t * plan, Iterator padded_offsets, bool use_short_loca)\n+{\n+  unsigned num_offsets = padded_offsets.len () + 1;\n+  unsigned entry_size = use_short_loca ? 2 : 4;\n+  char *loca_prime_data = (char *) hb_calloc (entry_size, num_offsets);\n+\n+  if (unlikely (!loca_prime_data)) return false;\n+\n+  DEBUG_MSG (SUBSET, nullptr, \"loca entry_size %d num_offsets %d size %d\",\n+             entry_size, num_offsets, entry_size * num_offsets);\n+\n+  if (use_short_loca)\n+    _write_loca (padded_offsets, true, hb_array ((HBUINT16 *) loca_prime_data, num_offsets));\n+  else\n+    _write_loca (padded_offsets, false, hb_array ((HBUINT32 *) loca_prime_data, num_offsets));\n+\n+  hb_blob_t *loca_blob = hb_blob_create (loca_prime_data,\n+                                         entry_size * num_offsets,\n+                                         HB_MEMORY_MODE_WRITABLE,\n+                                         loca_prime_data,\n+                                         hb_free);\n+\n+  bool result = plan->add_table (HB_OT_TAG_loca, loca_blob)\n+             && _add_head_and_set_loca_version (plan, use_short_loca);\n+\n+  hb_blob_destroy (loca_blob);\n+  return result;\n+}\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_GLYF_HELPERS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/glyf-helpers.hh","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,388 @@\n+#ifndef OT_GLYF_GLYF_HH\n+#define OT_GLYF_GLYF_HH\n+\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+#include \"..\/..\/hb-ot-head-table.hh\"\n+#include \"..\/..\/hb-ot-hmtx-table.hh\"\n+#include \"..\/..\/hb-ot-var-gvar-table.hh\"\n+#include \"..\/..\/hb-draw.hh\"\n+\n+#include \"glyf-helpers.hh\"\n+#include \"Glyph.hh\"\n+#include \"SubsetGlyph.hh\"\n+#include \"loca.hh\"\n+#include \"path-builder.hh\"\n+\n+\n+namespace OT {\n+\n+\n+\/*\n+ * glyf -- TrueType Glyph Data\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/glyf\n+ *\/\n+#define HB_OT_TAG_glyf HB_TAG('g','l','y','f')\n+\n+\n+struct glyf\n+{\n+  friend struct glyf_accelerator_t;\n+\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_glyf;\n+\n+  bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* Runtime checks as eager sanitizing each glyph is costy *\/\n+    return_trace (true);\n+  }\n+\n+  \/* requires source of SubsetGlyph complains the identifier isn't declared *\/\n+  template <typename Iterator>\n+  bool serialize (hb_serialize_context_t *c,\n+                  Iterator it,\n+                  bool use_short_loca,\n+                  const hb_subset_plan_t *plan)\n+  {\n+    TRACE_SERIALIZE (this);\n+    unsigned init_len = c->length ();\n+    for (const auto &_ : it) _.serialize (c, use_short_loca, plan);\n+\n+    \/* As a special case when all glyph in the font are empty, add a zero byte\n+     * to the table, so that OTS doesnt reject it, and to make the table work\n+     * on Windows as well.\n+     * See https:\/\/github.com\/khaledhosny\/ots\/issues\/52 *\/\n+    if (init_len == c->length ())\n+    {\n+      HBUINT8 empty_byte;\n+      empty_byte = 0;\n+      c->copy (empty_byte);\n+    }\n+    return_trace (true);\n+  }\n+\n+  \/* Byte region(s) per glyph to output\n+     unpadded, hints removed if so requested\n+     If we fail to process a glyph we produce an empty (0-length) glyph *\/\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+\n+    glyf *glyf_prime = c->serializer->start_embed <glyf> ();\n+    if (unlikely (!c->serializer->check_success (glyf_prime))) return_trace (false);\n+\n+    hb_vector_t<glyf_impl::SubsetGlyph> glyphs;\n+    _populate_subset_glyphs (c->plan, &glyphs);\n+\n+    auto padded_offsets =\n+    + hb_iter (glyphs)\n+    | hb_map (&glyf_impl::SubsetGlyph::padded_size)\n+    ;\n+\n+    unsigned max_offset = + padded_offsets | hb_reduce (hb_add, 0);\n+    bool use_short_loca = max_offset < 0x1FFFF;\n+\n+\n+    glyf_prime->serialize (c->serializer, hb_iter (glyphs), use_short_loca, c->plan);\n+    if (!use_short_loca) {\n+      padded_offsets =\n+          + hb_iter (glyphs)\n+          | hb_map (&glyf_impl::SubsetGlyph::length)\n+          ;\n+    }\n+\n+\n+    if (unlikely (c->serializer->in_error ())) return_trace (false);\n+    return_trace (c->serializer->check_success (glyf_impl::_add_loca_and_head (c->plan,\n+                                                                               padded_offsets,\n+                                                                               use_short_loca)));\n+  }\n+\n+  void\n+  _populate_subset_glyphs (const hb_subset_plan_t   *plan,\n+                           hb_vector_t<glyf_impl::SubsetGlyph> *glyphs \/* OUT *\/) const;\n+\n+  protected:\n+  UnsizedArrayOf<HBUINT8>\n+                dataZ;  \/* Glyphs data. *\/\n+  public:\n+  DEFINE_SIZE_MIN (0);  \/* In reality, this is UNBOUNDED() type; but since we always\n+                         * check the size externally, allow Null() object of it by\n+                         * defining it _MIN instead. *\/\n+};\n+\n+struct glyf_accelerator_t\n+{\n+  glyf_accelerator_t (hb_face_t *face)\n+  {\n+    short_offset = false;\n+    num_glyphs = 0;\n+    loca_table = nullptr;\n+    glyf_table = nullptr;\n+#ifndef HB_NO_VAR\n+    gvar = nullptr;\n+#endif\n+    hmtx = nullptr;\n+#ifndef HB_NO_VERTICAL\n+    vmtx = nullptr;\n+#endif\n+    const OT::head &head = *face->table.head;\n+    if (head.indexToLocFormat > 1 || head.glyphDataFormat > 0)\n+      \/* Unknown format.  Leave num_glyphs=0, that takes care of disabling us. *\/\n+      return;\n+    short_offset = 0 == head.indexToLocFormat;\n+\n+    loca_table = face->table.loca.get_blob (); \/\/ Needs no destruct!\n+    glyf_table = hb_sanitize_context_t ().reference_table<glyf> (face);\n+#ifndef HB_NO_VAR\n+    gvar = face->table.gvar;\n+#endif\n+    hmtx = face->table.hmtx;\n+#ifndef HB_NO_VERTICAL\n+    vmtx = face->table.vmtx;\n+#endif\n+\n+    num_glyphs = hb_max (1u, loca_table.get_length () \/ (short_offset ? 2 : 4)) - 1;\n+    num_glyphs = hb_min (num_glyphs, face->get_num_glyphs ());\n+  }\n+  ~glyf_accelerator_t ()\n+  {\n+    glyf_table.destroy ();\n+  }\n+\n+  bool has_data () const { return num_glyphs; }\n+\n+  protected:\n+  template<typename T>\n+  bool get_points (hb_font_t *font, hb_codepoint_t gid, T consumer) const\n+  {\n+    if (gid >= num_glyphs) return false;\n+\n+    \/* Making this allocfree is not that easy\n+       https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2095\n+       mostly because of gvar handling in VF fonts,\n+       perhaps a separate path for non-VF fonts can be considered *\/\n+    contour_point_vector_t all_points;\n+\n+    bool phantom_only = !consumer.is_consuming_contour_points ();\n+    if (unlikely (!glyph_for_gid (gid).get_points (font, *this, all_points, phantom_only)))\n+      return false;\n+\n+    if (consumer.is_consuming_contour_points ())\n+    {\n+      unsigned count = all_points.length;\n+      assert (count >= glyf_impl::PHANTOM_COUNT);\n+      count -= glyf_impl::PHANTOM_COUNT;\n+      for (unsigned point_index = 0; point_index < count; point_index++)\n+        consumer.consume_point (all_points[point_index]);\n+      consumer.points_end ();\n+    }\n+\n+    \/* Where to write phantoms, nullptr if not requested *\/\n+    contour_point_t *phantoms = consumer.get_phantoms_sink ();\n+    if (phantoms)\n+      for (unsigned i = 0; i < glyf_impl::PHANTOM_COUNT; ++i)\n+        phantoms[i] = all_points[all_points.length - glyf_impl::PHANTOM_COUNT + i];\n+\n+    return true;\n+  }\n+\n+#ifndef HB_NO_VAR\n+  struct points_aggregator_t\n+  {\n+    hb_font_t *font;\n+    hb_glyph_extents_t *extents;\n+    contour_point_t *phantoms;\n+\n+    struct contour_bounds_t\n+    {\n+      contour_bounds_t () { min_x = min_y = FLT_MAX; max_x = max_y = -FLT_MAX; }\n+\n+      void add (const contour_point_t &p)\n+      {\n+        min_x = hb_min (min_x, p.x);\n+        min_y = hb_min (min_y, p.y);\n+        max_x = hb_max (max_x, p.x);\n+        max_y = hb_max (max_y, p.y);\n+      }\n+\n+      bool empty () const { return (min_x >= max_x) || (min_y >= max_y); }\n+\n+      void get_extents (hb_font_t *font, hb_glyph_extents_t *extents)\n+      {\n+        if (unlikely (empty ()))\n+        {\n+          extents->width = 0;\n+          extents->x_bearing = 0;\n+          extents->height = 0;\n+          extents->y_bearing = 0;\n+          return;\n+        }\n+        extents->x_bearing = font->em_scalef_x (min_x);\n+        extents->width = font->em_scalef_x (max_x) - extents->x_bearing;\n+        extents->y_bearing = font->em_scalef_y (max_y);\n+        extents->height = font->em_scalef_y (min_y) - extents->y_bearing;\n+      }\n+\n+      protected:\n+      float min_x, min_y, max_x, max_y;\n+    } bounds;\n+\n+    points_aggregator_t (hb_font_t *font_, hb_glyph_extents_t *extents_, contour_point_t *phantoms_)\n+    {\n+      font = font_;\n+      extents = extents_;\n+      phantoms = phantoms_;\n+      if (extents) bounds = contour_bounds_t ();\n+    }\n+\n+    void consume_point (const contour_point_t &point) { bounds.add (point); }\n+    void points_end () { bounds.get_extents (font, extents); }\n+\n+    bool is_consuming_contour_points () { return extents; }\n+    contour_point_t *get_phantoms_sink () { return phantoms; }\n+  };\n+\n+  public:\n+  unsigned\n+  get_advance_var (hb_font_t *font, hb_codepoint_t gid, bool is_vertical) const\n+  {\n+    if (unlikely (gid >= num_glyphs)) return 0;\n+\n+    bool success = false;\n+\n+    contour_point_t phantoms[glyf_impl::PHANTOM_COUNT];\n+    if (likely (font->num_coords == gvar->get_axis_count ()))\n+      success = get_points (font, gid, points_aggregator_t (font, nullptr, phantoms));\n+\n+    if (unlikely (!success))\n+      return\n+#ifndef HB_NO_VERTICAL\n+        is_vertical ? vmtx->get_advance (gid) :\n+#endif\n+        hmtx->get_advance (gid);\n+\n+    float result = is_vertical\n+                 ? phantoms[glyf_impl::PHANTOM_TOP].y - phantoms[glyf_impl::PHANTOM_BOTTOM].y\n+                 : phantoms[glyf_impl::PHANTOM_RIGHT].x - phantoms[glyf_impl::PHANTOM_LEFT].x;\n+    return hb_clamp (roundf (result), 0.f, (float) UINT_MAX \/ 2);\n+  }\n+\n+  int get_side_bearing_var (hb_font_t *font, hb_codepoint_t gid, bool is_vertical) const\n+  {\n+    if (unlikely (gid >= num_glyphs)) return 0;\n+\n+    hb_glyph_extents_t extents;\n+\n+    contour_point_t phantoms[glyf_impl::PHANTOM_COUNT];\n+    if (unlikely (!get_points (font, gid, points_aggregator_t (font, &extents, phantoms))))\n+      return\n+#ifndef HB_NO_VERTICAL\n+        is_vertical ? vmtx->get_side_bearing (gid) :\n+#endif\n+        hmtx->get_side_bearing (gid);\n+\n+    return is_vertical\n+         ? ceilf (phantoms[glyf_impl::PHANTOM_TOP].y) - extents.y_bearing\n+         : floorf (phantoms[glyf_impl::PHANTOM_LEFT].x);\n+  }\n+#endif\n+\n+  public:\n+  bool get_extents (hb_font_t *font, hb_codepoint_t gid, hb_glyph_extents_t *extents) const\n+  {\n+    if (unlikely (gid >= num_glyphs)) return false;\n+\n+#ifndef HB_NO_VAR\n+    if (font->num_coords)\n+      return get_points (font, gid, points_aggregator_t (font, extents, nullptr));\n+#endif\n+    return glyph_for_gid (gid).get_extents (font, *this, extents);\n+  }\n+\n+  const glyf_impl::Glyph\n+  glyph_for_gid (hb_codepoint_t gid, bool needs_padding_removal = false) const\n+  {\n+    if (unlikely (gid >= num_glyphs)) return glyf_impl::Glyph ();\n+\n+    unsigned int start_offset, end_offset;\n+\n+    if (short_offset)\n+    {\n+      const HBUINT16 *offsets = (const HBUINT16 *) loca_table->dataZ.arrayZ;\n+      start_offset = 2 * offsets[gid];\n+      end_offset   = 2 * offsets[gid + 1];\n+    }\n+    else\n+    {\n+      const HBUINT32 *offsets = (const HBUINT32 *) loca_table->dataZ.arrayZ;\n+      start_offset = offsets[gid];\n+      end_offset   = offsets[gid + 1];\n+    }\n+\n+    if (unlikely (start_offset > end_offset || end_offset > glyf_table.get_length ()))\n+      return glyf_impl::Glyph ();\n+\n+    glyf_impl::Glyph glyph (hb_bytes_t ((const char *) this->glyf_table + start_offset,\n+                             end_offset - start_offset), gid);\n+    return needs_padding_removal ? glyf_impl::Glyph (glyph.trim_padding (), gid) : glyph;\n+  }\n+\n+  bool\n+  get_path (hb_font_t *font, hb_codepoint_t gid, hb_draw_session_t &draw_session) const\n+  { return get_points (font, gid, glyf_impl::path_builder_t (font, draw_session)); }\n+\n+#ifndef HB_NO_VAR\n+  const gvar_accelerator_t *gvar;\n+#endif\n+  const hmtx_accelerator_t *hmtx;\n+#ifndef HB_NO_VERTICAL\n+  const vmtx_accelerator_t *vmtx;\n+#endif\n+\n+  private:\n+  bool short_offset;\n+  unsigned int num_glyphs;\n+  hb_blob_ptr_t<loca> loca_table;\n+  hb_blob_ptr_t<glyf> glyf_table;\n+};\n+\n+\n+inline void\n+glyf::_populate_subset_glyphs (const hb_subset_plan_t   *plan,\n+                               hb_vector_t<glyf_impl::SubsetGlyph> *glyphs \/* OUT *\/) const\n+{\n+  OT::glyf_accelerator_t glyf (plan->source);\n+\n+  + hb_range (plan->num_output_glyphs ())\n+  | hb_map ([&] (hb_codepoint_t new_gid)\n+        {\n+          glyf_impl::SubsetGlyph subset_glyph = {0};\n+          subset_glyph.new_gid = new_gid;\n+\n+          \/* should never fail: all old gids should be mapped *\/\n+          if (!plan->old_gid_for_new_gid (new_gid, &subset_glyph.old_gid))\n+            return subset_glyph;\n+\n+          if (new_gid == 0 &&\n+              !(plan->flags & HB_SUBSET_FLAGS_NOTDEF_OUTLINE))\n+            subset_glyph.source_glyph = glyf_impl::Glyph ();\n+          else\n+            subset_glyph.source_glyph = glyf.glyph_for_gid (subset_glyph.old_gid, true);\n+          if (plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n+            subset_glyph.drop_hints_bytes ();\n+          else\n+            subset_glyph.dest_start = subset_glyph.source_glyph.get_bytes ();\n+          return subset_glyph;\n+        })\n+  | hb_sink (glyphs)\n+  ;\n+}\n+\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_GLYF_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/glyf.hh","additions":388,"deletions":0,"binary":false,"changes":388,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+#ifndef OT_GLYF_LOCA_HH\n+#define OT_GLYF_LOCA_HH\n+\n+\n+#include \"..\/..\/hb-open-type.hh\"\n+\n+\n+namespace OT {\n+\n+\n+\/*\n+ * loca -- Index to Location\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/loca\n+ *\/\n+#define HB_OT_TAG_loca HB_TAG('l','o','c','a')\n+\n+struct loca\n+{\n+  friend struct glyf;\n+  friend struct glyf_accelerator_t;\n+\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_loca;\n+\n+  bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (true);\n+  }\n+\n+  protected:\n+  UnsizedArrayOf<HBUINT8>\n+                dataZ;  \/* Location data. *\/\n+  public:\n+  DEFINE_SIZE_MIN (0);  \/* In reality, this is UNBOUNDED() type; but since we always\n+                         * check the size externally, allow Null() object of it by\n+                         * defining it _MIN instead. *\/\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_LOCA_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/loca.hh","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+#ifndef OT_GLYF_PATH_BUILDER_HH\n+#define OT_GLYF_PATH_BUILDER_HH\n+\n+\n+#include \"..\/..\/hb.hh\"\n+\n+\n+namespace OT {\n+namespace glyf_impl {\n+\n+\n+struct path_builder_t\n+{\n+  hb_font_t *font;\n+  hb_draw_session_t *draw_session;\n+\n+  struct optional_point_t\n+  {\n+    optional_point_t () {}\n+    optional_point_t (float x_, float y_) : has_data (true), x (x_), y (y_) {}\n+    operator bool () const { return has_data; }\n+\n+    bool has_data = false;\n+    float x = 0.;\n+    float y = 0.;\n+\n+    optional_point_t lerp (optional_point_t p, float t)\n+    { return optional_point_t (x + t * (p.x - x), y + t * (p.y - y)); }\n+  } first_oncurve, first_offcurve, last_offcurve;\n+\n+  path_builder_t (hb_font_t *font_, hb_draw_session_t &draw_session_)\n+  {\n+    font = font_;\n+    draw_session = &draw_session_;\n+    first_oncurve = first_offcurve = last_offcurve = optional_point_t ();\n+  }\n+\n+  \/* based on https:\/\/github.com\/RazrFalcon\/ttf-parser\/blob\/4f32821\/src\/glyf.rs#L287\n+     See also:\n+     * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM01\/Chap1.html\n+     * https:\/\/stackoverflow.com\/a\/20772557 *\/\n+  void consume_point (const contour_point_t &point)\n+  {\n+    bool is_on_curve = point.flag & glyf_impl::SimpleGlyph::FLAG_ON_CURVE;\n+    optional_point_t p (font->em_fscalef_x (point.x), font->em_fscalef_y (point.y));\n+    if (!first_oncurve)\n+    {\n+      if (is_on_curve)\n+      {\n+        first_oncurve = p;\n+        draw_session->move_to (p.x, p.y);\n+      }\n+      else\n+      {\n+        if (first_offcurve)\n+        {\n+          optional_point_t mid = first_offcurve.lerp (p, .5f);\n+          first_oncurve = mid;\n+          last_offcurve = p;\n+          draw_session->move_to (mid.x, mid.y);\n+        }\n+        else\n+          first_offcurve = p;\n+      }\n+    }\n+    else\n+    {\n+      if (last_offcurve)\n+      {\n+        if (is_on_curve)\n+        {\n+          draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n+                                     p.x, p.y);\n+          last_offcurve = optional_point_t ();\n+        }\n+        else\n+        {\n+          optional_point_t mid = last_offcurve.lerp (p, .5f);\n+          draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n+                                     mid.x, mid.y);\n+          last_offcurve = p;\n+        }\n+      }\n+      else\n+      {\n+        if (is_on_curve)\n+          draw_session->line_to (p.x, p.y);\n+        else\n+          last_offcurve = p;\n+      }\n+    }\n+\n+    if (point.is_end_point)\n+    {\n+      if (first_offcurve && last_offcurve)\n+      {\n+        optional_point_t mid = last_offcurve.lerp (first_offcurve, .5f);\n+        draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n+                                   mid.x, mid.y);\n+        last_offcurve = optional_point_t ();\n+        \/* now check the rest *\/\n+      }\n+\n+      if (first_offcurve && first_oncurve)\n+        draw_session->quadratic_to (first_offcurve.x, first_offcurve.y,\n+                                   first_oncurve.x, first_oncurve.y);\n+      else if (last_offcurve && first_oncurve)\n+        draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n+                                   first_oncurve.x, first_oncurve.y);\n+      else if (first_oncurve)\n+        draw_session->line_to (first_oncurve.x, first_oncurve.y);\n+      else if (first_offcurve)\n+      {\n+        float x = first_offcurve.x, y = first_offcurve.y;\n+        draw_session->move_to (x, y);\n+        draw_session->quadratic_to (x, y, x, y);\n+      }\n+\n+      \/* Getting ready for the next contour *\/\n+      first_oncurve = first_offcurve = last_offcurve = optional_point_t ();\n+      draw_session->close_path ();\n+    }\n+  }\n+  void points_end () {}\n+\n+  bool is_consuming_contour_points () { return true; }\n+  contour_point_t *get_phantoms_sink () { return nullptr; }\n+};\n+\n+\n+} \/* namespace glyf_impl *\/\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* OT_GLYF_PATH_BUILDER_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/path-builder.hh","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+Tips and tasks when updating harfbuzz sources to a newer version.\n+-----------------------------------------------------------------\n+\n+We only use files from the src directory and even then only the ones we need.\n+So just C++ include and source files and only the ones needed for the library,\n+and even then just the ones we use. Do NOT just copy everything.\n+\n+So one way to update is to\n+\n+- copy over from the updated harfbuzz the exact same files we already have\n+- it isn't a flat directory so watch out for that\n+- any that are no longer available (copy fails) we remove but these may come\n+  back later if they were actually renamed\n+- look for files in the destination that were NOT updated - perhaps they\n+  are gone in the upstream - or renamed. Remove them if they are really\n+  obsolete, or add their replacements\/renames.\n+- iterate over : build and see what new file is missing that causes a build failure\n+- when this is done we have something buildable\n+- make sure it builds on all supported platforms.\n+- Harfbuzz is not modular so it is not easy,\n+- The main thing is we do NOT want any\n+   * \"test\" programs (test in the name, have a main are clues)\n+   * support for (eg) GLib, DirectWrite, Graphite, GDI, ICU, Uniscribe\n+   * aggregators like harfbuzz.cc - since it includes things from the above\n+     as well as hb-ft.cc which we specifically exclude in the Makefile\n+  * but we do use core text support on macOS.\n+  * I really wish that \"src\" were just library source but I expect the authors\n+    have their reasons.\n+\n+- we do not apply any header file changes so this is not an issue\n+- verify the license text is unchanged (extra steps are needed if it is) and update\n+   src\/java.desktop\/share\/legal\/harfbuzz.md with the new version\n+- clean up trailing white space and tabs to follow jcheck rules.\n+  Use \"expand\" and \"sed\" to remove tabs and trailing white space from the\n+  imported sources.\n+- test using all the automated jtreg tests on all platforms\n+- do manual verification of Arabic, Hebrew, Thai, Indic against previous releases. \n+  Look for manual related layout jtreg tests and run on Windows,Linux and Mac.\n+  Use Font2DTest set to TextLayout and check the above languages. Probably\n+  not going to see layout problems a code point at a time but it needs to\n+  be checked.\n+\n+- Update make parameters as needed\n+  Since we don't use configure we need to manually specify the options\n+  we need in the harfbuzz section of Awt2DLibraries.gmk.\n+  As well as adding new options, we may need to clean up obsolete options.\n+  Note there may be platform variations in the flags.\n+\n+- As with other 3rd party libs we do not fix the code to eliminate compiler\n+  warnings unless they are critical and clearly avoiding a bug. Even then\n+  we'd report it upstream. The usual practice is do just disable the warnings\n+\n+- Update THIS UPDATING.txt file too if it is outdated.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/UPDATING.txt","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,860 @@\n+\/*\n+ * Copyright  2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef GRAPH_GRAPH_HH\n+#define GRAPH_GRAPH_HH\n+\n+namespace graph {\n+\n+\/**\n+ * Represents a serialized table in the form of a graph.\n+ * Provides methods for modifying and reordering the graph.\n+ *\/\n+struct graph_t\n+{\n+  struct vertex_t\n+  {\n+    hb_serialize_context_t::object_t obj;\n+    int64_t distance = 0 ;\n+    int64_t space = 0 ;\n+    hb_vector_t<unsigned> parents;\n+    unsigned start = 0;\n+    unsigned end = 0;\n+    unsigned priority = 0;\n+\n+    friend void swap (vertex_t& a, vertex_t& b)\n+    {\n+      hb_swap (a.obj, b.obj);\n+      hb_swap (a.distance, b.distance);\n+      hb_swap (a.space, b.space);\n+      hb_swap (a.parents, b.parents);\n+      hb_swap (a.start, b.start);\n+      hb_swap (a.end, b.end);\n+      hb_swap (a.priority, b.priority);\n+    }\n+\n+    bool is_shared () const\n+    {\n+      return parents.length > 1;\n+    }\n+\n+    unsigned incoming_edges () const\n+    {\n+      return parents.length;\n+    }\n+\n+    void remove_parent (unsigned parent_index)\n+    {\n+      for (unsigned i = 0; i < parents.length; i++)\n+      {\n+        if (parents[i] != parent_index) continue;\n+        parents.remove (i);\n+        break;\n+      }\n+    }\n+\n+    void remap_parents (const hb_vector_t<unsigned>& id_map)\n+    {\n+      for (unsigned i = 0; i < parents.length; i++)\n+        parents[i] = id_map[parents[i]];\n+    }\n+\n+    void remap_parent (unsigned old_index, unsigned new_index)\n+    {\n+      for (unsigned i = 0; i < parents.length; i++)\n+      {\n+        if (parents[i] == old_index)\n+          parents[i] = new_index;\n+      }\n+    }\n+\n+    bool is_leaf () const\n+    {\n+      return !obj.real_links.length && !obj.virtual_links.length;\n+    }\n+\n+    bool raise_priority ()\n+    {\n+      if (has_max_priority ()) return false;\n+      priority++;\n+      return true;\n+    }\n+\n+    bool has_max_priority () const {\n+      return priority >= 3;\n+    }\n+\n+    int64_t modified_distance (unsigned order) const\n+    {\n+      \/\/ TODO(garretrieger): once priority is high enough, should try\n+      \/\/ setting distance = 0 which will force to sort immediately after\n+      \/\/ it's parent where possible.\n+\n+      int64_t modified_distance =\n+          hb_min (hb_max(distance + distance_modifier (), 0), 0x7FFFFFFFFFF);\n+      if (has_max_priority ()) {\n+        modified_distance = 0;\n+      }\n+      return (modified_distance << 18) | (0x003FFFF & order);\n+    }\n+\n+    int64_t distance_modifier () const\n+    {\n+      if (!priority) return 0;\n+      int64_t table_size = obj.tail - obj.head;\n+\n+      if (priority == 1)\n+        return -table_size \/ 2;\n+\n+      return -table_size;\n+    }\n+  };\n+\n+  \/*\n+   * A topological sorting of an object graph. Ordered\n+   * in reverse serialization order (first object in the\n+   * serialization is at the end of the list). This matches\n+   * the 'packed' object stack used internally in the\n+   * serializer\n+   *\/\n+  template<typename T>\n+  graph_t (const T& objects)\n+      : parents_invalid (true),\n+        distance_invalid (true),\n+        positions_invalid (true),\n+        successful (true)\n+  {\n+    num_roots_for_space_.push (1);\n+    bool removed_nil = false;\n+    vertices_.alloc (objects.length);\n+    vertices_scratch_.alloc (objects.length);\n+    for (unsigned i = 0; i < objects.length; i++)\n+    {\n+      \/\/ TODO(grieger): check all links point to valid objects.\n+\n+      \/\/ If this graph came from a serialization buffer object 0 is the\n+      \/\/ nil object. We don't need it for our purposes here so drop it.\n+      if (i == 0 && !objects[i])\n+      {\n+        removed_nil = true;\n+        continue;\n+      }\n+\n+      vertex_t* v = vertices_.push ();\n+      if (check_success (!vertices_.in_error ()))\n+        v->obj = *objects[i];\n+      if (!removed_nil) continue;\n+      \/\/ Fix indices to account for removed nil object.\n+      for (auto& l : v->obj.all_links_writer ()) {\n+        l.objidx--;\n+      }\n+    }\n+  }\n+\n+  ~graph_t ()\n+  {\n+    vertices_.fini ();\n+  }\n+\n+  bool in_error () const\n+  {\n+    return !successful ||\n+        vertices_.in_error () ||\n+        num_roots_for_space_.in_error ();\n+  }\n+\n+  const vertex_t& root () const\n+  {\n+    return vertices_[root_idx ()];\n+  }\n+\n+  unsigned root_idx () const\n+  {\n+    \/\/ Object graphs are in reverse order, the first object is at the end\n+    \/\/ of the vector. Since the graph is topologically sorted it's safe to\n+    \/\/ assume the first object has no incoming edges.\n+    return vertices_.length - 1;\n+  }\n+\n+  const hb_serialize_context_t::object_t& object(unsigned i) const\n+  {\n+    return vertices_[i].obj;\n+  }\n+\n+  \/*\n+   * Generates a new topological sorting of graph ordered by the shortest\n+   * distance to each node.\n+   *\/\n+  void sort_shortest_distance ()\n+  {\n+    positions_invalid = true;\n+\n+    if (vertices_.length <= 1) {\n+      \/\/ Graph of 1 or less doesn't need sorting.\n+      return;\n+    }\n+\n+    update_distances ();\n+\n+    hb_priority_queue_t queue;\n+    hb_vector_t<vertex_t> &sorted_graph = vertices_scratch_;\n+    if (unlikely (!check_success (sorted_graph.resize (vertices_.length)))) return;\n+    hb_vector_t<unsigned> id_map;\n+    if (unlikely (!check_success (id_map.resize (vertices_.length)))) return;\n+\n+    hb_vector_t<unsigned> removed_edges;\n+    if (unlikely (!check_success (removed_edges.resize (vertices_.length)))) return;\n+    update_parents ();\n+\n+    queue.insert (root ().modified_distance (0), root_idx ());\n+    int new_id = root_idx ();\n+    unsigned order = 1;\n+    while (!queue.in_error () && !queue.is_empty ())\n+    {\n+      unsigned next_id = queue.pop_minimum().second;\n+\n+      hb_swap (sorted_graph[new_id], vertices_[next_id]);\n+      const vertex_t& next = sorted_graph[new_id];\n+\n+      id_map[next_id] = new_id--;\n+\n+      for (const auto& link : next.obj.all_links ()) {\n+        removed_edges[link.objidx]++;\n+        if (!(vertices_[link.objidx].incoming_edges () - removed_edges[link.objidx]))\n+          \/\/ Add the order that the links were encountered to the priority.\n+          \/\/ This ensures that ties between priorities objects are broken in a consistent\n+          \/\/ way. More specifically this is set up so that if a set of objects have the same\n+          \/\/ distance they'll be added to the topological order in the order that they are\n+          \/\/ referenced from the parent object.\n+          queue.insert (vertices_[link.objidx].modified_distance (order++),\n+                        link.objidx);\n+      }\n+    }\n+\n+    check_success (!queue.in_error ());\n+    check_success (!sorted_graph.in_error ());\n+    if (!check_success (new_id == -1))\n+      print_orphaned_nodes ();\n+\n+    remap_all_obj_indices (id_map, &sorted_graph);\n+\n+    hb_swap (vertices_, sorted_graph);\n+  }\n+\n+  \/*\n+   * Assign unique space numbers to each connected subgraph of 32 bit offset(s).\n+   *\/\n+  bool assign_32bit_spaces ()\n+  {\n+    unsigned root_index = root_idx ();\n+    hb_set_t visited;\n+    hb_set_t roots;\n+    for (unsigned i = 0; i <= root_index; i++)\n+    {\n+      \/\/ Only real links can form 32 bit spaces\n+      for (auto& l : vertices_[i].obj.real_links)\n+      {\n+        if (l.width == 4 && !l.is_signed)\n+        {\n+          roots.add (l.objidx);\n+          find_subgraph (l.objidx, visited);\n+        }\n+      }\n+    }\n+\n+    \/\/ Mark everything not in the subgraphs of 32 bit roots as visited.\n+    \/\/ This prevents 32 bit subgraphs from being connected via nodes not in the 32 bit subgraphs.\n+    visited.invert ();\n+\n+    if (!roots) return false;\n+\n+    while (roots)\n+    {\n+      unsigned next = HB_SET_VALUE_INVALID;\n+      if (unlikely (!check_success (!roots.in_error ()))) break;\n+      if (!roots.next (&next)) break;\n+\n+      hb_set_t connected_roots;\n+      find_connected_nodes (next, roots, visited, connected_roots);\n+      if (unlikely (!check_success (!connected_roots.in_error ()))) break;\n+\n+      isolate_subgraph (connected_roots);\n+      if (unlikely (!check_success (!connected_roots.in_error ()))) break;\n+\n+      unsigned next_space = this->next_space ();\n+      num_roots_for_space_.push (0);\n+      for (unsigned root : connected_roots)\n+      {\n+        DEBUG_MSG (SUBSET_REPACK, nullptr, \"Subgraph %u gets space %u\", root, next_space);\n+        vertices_[root].space = next_space;\n+        num_roots_for_space_[next_space] = num_roots_for_space_[next_space] + 1;\n+        distance_invalid = true;\n+        positions_invalid = true;\n+      }\n+\n+      \/\/ TODO(grieger): special case for GSUB\/GPOS use extension promotions to move 16 bit space\n+      \/\/                into the 32 bit space as needed, instead of using isolation.\n+    }\n+\n+\n+\n+    return true;\n+  }\n+\n+  \/*\n+   * Isolates the subgraph of nodes reachable from root. Any links to nodes in the subgraph\n+   * that originate from outside of the subgraph will be removed by duplicating the linked to\n+   * object.\n+   *\n+   * Indices stored in roots will be updated if any of the roots are duplicated to new indices.\n+   *\/\n+  bool isolate_subgraph (hb_set_t& roots)\n+  {\n+    update_parents ();\n+    hb_map_t subgraph;\n+\n+    \/\/ incoming edges to root_idx should be all 32 bit in length so we don't need to de-dup these\n+    \/\/ set the subgraph incoming edge count to match all of root_idx's incoming edges\n+    hb_set_t parents;\n+    for (unsigned root_idx : roots)\n+    {\n+      subgraph.set (root_idx, wide_parents (root_idx, parents));\n+      find_subgraph (root_idx, subgraph);\n+    }\n+\n+    unsigned original_root_idx = root_idx ();\n+    hb_map_t index_map;\n+    bool made_changes = false;\n+    for (auto entry : subgraph.iter ())\n+    {\n+      const auto& node = vertices_[entry.first];\n+      unsigned subgraph_incoming_edges = entry.second;\n+\n+      if (subgraph_incoming_edges < node.incoming_edges ())\n+      {\n+        \/\/ Only  de-dup objects with incoming links from outside the subgraph.\n+        made_changes = true;\n+        duplicate_subgraph (entry.first, index_map);\n+      }\n+    }\n+\n+    if (!made_changes)\n+      return false;\n+\n+    if (original_root_idx != root_idx ()\n+        && parents.has (original_root_idx))\n+    {\n+      \/\/ If the root idx has changed since parents was determined, update root idx in parents\n+      parents.add (root_idx ());\n+      parents.del (original_root_idx);\n+    }\n+\n+    auto new_subgraph =\n+        + subgraph.keys ()\n+        | hb_map([&] (unsigned node_idx) {\n+          const unsigned *v;\n+          if (index_map.has (node_idx, &v)) return *v;\n+          return node_idx;\n+        })\n+        ;\n+\n+    remap_obj_indices (index_map, new_subgraph);\n+    remap_obj_indices (index_map, parents.iter (), true);\n+\n+    \/\/ Update roots set with new indices as needed.\n+    unsigned next = HB_SET_VALUE_INVALID;\n+    while (roots.next (&next))\n+    {\n+      const unsigned *v;\n+      if (index_map.has (next, &v))\n+      {\n+        roots.del (next);\n+        roots.add (*v);\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  void find_subgraph (unsigned node_idx, hb_map_t& subgraph)\n+  {\n+    for (const auto& link : vertices_[node_idx].obj.all_links ())\n+    {\n+      const unsigned *v;\n+      if (subgraph.has (link.objidx, &v))\n+      {\n+        subgraph.set (link.objidx, *v + 1);\n+        continue;\n+      }\n+      subgraph.set (link.objidx, 1);\n+      find_subgraph (link.objidx, subgraph);\n+    }\n+  }\n+\n+  void find_subgraph (unsigned node_idx, hb_set_t& subgraph)\n+  {\n+    if (subgraph.has (node_idx)) return;\n+    subgraph.add (node_idx);\n+    for (const auto& link : vertices_[node_idx].obj.all_links ())\n+      find_subgraph (link.objidx, subgraph);\n+  }\n+\n+  \/*\n+   * duplicates all nodes in the subgraph reachable from node_idx. Does not re-assign\n+   * links. index_map is updated with mappings from old id to new id. If a duplication has already\n+   * been performed for a given index, then it will be skipped.\n+   *\/\n+  void duplicate_subgraph (unsigned node_idx, hb_map_t& index_map)\n+  {\n+    if (index_map.has (node_idx))\n+      return;\n+\n+    index_map.set (node_idx, duplicate (node_idx));\n+    for (const auto& l : object (node_idx).all_links ()) {\n+      duplicate_subgraph (l.objidx, index_map);\n+    }\n+  }\n+\n+  \/*\n+   * Creates a copy of node_idx and returns it's new index.\n+   *\/\n+  unsigned duplicate (unsigned node_idx)\n+  {\n+    positions_invalid = true;\n+    distance_invalid = true;\n+\n+    auto* clone = vertices_.push ();\n+    auto& child = vertices_[node_idx];\n+    if (vertices_.in_error ()) {\n+      return -1;\n+    }\n+\n+    clone->obj.head = child.obj.head;\n+    clone->obj.tail = child.obj.tail;\n+    clone->distance = child.distance;\n+    clone->space = child.space;\n+    clone->parents.reset ();\n+\n+    unsigned clone_idx = vertices_.length - 2;\n+    for (const auto& l : child.obj.real_links)\n+    {\n+      clone->obj.real_links.push (l);\n+      vertices_[l.objidx].parents.push (clone_idx);\n+    }\n+    for (const auto& l : child.obj.virtual_links)\n+    {\n+      clone->obj.virtual_links.push (l);\n+      vertices_[l.objidx].parents.push (clone_idx);\n+    }\n+\n+    check_success (!clone->obj.real_links.in_error ());\n+    check_success (!clone->obj.virtual_links.in_error ());\n+\n+    \/\/ The last object is the root of the graph, so swap back the root to the end.\n+    \/\/ The root's obj idx does change, however since it's root nothing else refers to it.\n+    \/\/ all other obj idx's will be unaffected.\n+    hb_swap (vertices_[vertices_.length - 2], *clone);\n+\n+    \/\/ Since the root moved, update the parents arrays of all children on the root.\n+    for (const auto& l : root ().obj.all_links ())\n+      vertices_[l.objidx].remap_parent (root_idx () - 1, root_idx ());\n+\n+    return clone_idx;\n+  }\n+\n+  \/*\n+   * Creates a copy of child and re-assigns the link from\n+   * parent to the clone. The copy is a shallow copy, objects\n+   * linked from child are not duplicated.\n+   *\/\n+  bool duplicate (unsigned parent_idx, unsigned child_idx)\n+  {\n+    update_parents ();\n+\n+    unsigned links_to_child = 0;\n+    for (const auto& l : vertices_[parent_idx].obj.all_links ())\n+    {\n+      if (l.objidx == child_idx) links_to_child++;\n+    }\n+\n+    if (vertices_[child_idx].incoming_edges () <= links_to_child)\n+    {\n+      \/\/ Can't duplicate this node, doing so would orphan the original one as all remaining links\n+      \/\/ to child are from parent.\n+      DEBUG_MSG (SUBSET_REPACK, nullptr, \"  Not duplicating %d => %d\",\n+                 parent_idx, child_idx);\n+      return false;\n+    }\n+\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"  Duplicating %d => %d\",\n+               parent_idx, child_idx);\n+\n+    unsigned clone_idx = duplicate (child_idx);\n+    if (clone_idx == (unsigned) -1) return false;\n+    \/\/ duplicate shifts the root node idx, so if parent_idx was root update it.\n+    if (parent_idx == clone_idx) parent_idx++;\n+\n+    auto& parent = vertices_[parent_idx];\n+    for (auto& l : parent.obj.all_links_writer ())\n+    {\n+      if (l.objidx != child_idx)\n+        continue;\n+\n+      reassign_link (l, parent_idx, clone_idx);\n+    }\n+\n+    return true;\n+  }\n+\n+  \/*\n+   * Raises the sorting priority of all children.\n+   *\/\n+  bool raise_childrens_priority (unsigned parent_idx)\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"  Raising priority of all children of %d\",\n+               parent_idx);\n+    \/\/ This operation doesn't change ordering until a sort is run, so no need\n+    \/\/ to invalidate positions. It does not change graph structure so no need\n+    \/\/ to update distances or edge counts.\n+    auto& parent = vertices_[parent_idx].obj;\n+    bool made_change = false;\n+    for (auto& l : parent.all_links_writer ())\n+      made_change |= vertices_[l.objidx].raise_priority ();\n+    return made_change;\n+  }\n+\n+  void print_orphaned_nodes ()\n+  {\n+    if (!DEBUG_ENABLED(SUBSET_REPACK)) return;\n+\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"Graph is not fully connected.\");\n+    parents_invalid = true;\n+    update_parents();\n+\n+    for (unsigned i = 0; i < root_idx (); i++)\n+    {\n+      const auto& v = vertices_[i];\n+      if (!v.parents)\n+        DEBUG_MSG (SUBSET_REPACK, nullptr, \"Node %u is orphaned.\", i);\n+    }\n+  }\n+\n+  unsigned num_roots_for_space (unsigned space) const\n+  {\n+    return num_roots_for_space_[space];\n+  }\n+\n+  unsigned next_space () const\n+  {\n+    return num_roots_for_space_.length;\n+  }\n+\n+  void move_to_new_space (const hb_set_t& indices)\n+  {\n+    num_roots_for_space_.push (0);\n+    unsigned new_space = num_roots_for_space_.length - 1;\n+\n+    for (unsigned index : indices) {\n+      auto& node = vertices_[index];\n+      num_roots_for_space_[node.space] = num_roots_for_space_[node.space] - 1;\n+      num_roots_for_space_[new_space] = num_roots_for_space_[new_space] + 1;\n+      node.space = new_space;\n+      distance_invalid = true;\n+      positions_invalid = true;\n+    }\n+  }\n+\n+  unsigned space_for (unsigned index, unsigned* root = nullptr) const\n+  {\n+    const auto& node = vertices_[index];\n+    if (node.space)\n+    {\n+      if (root != nullptr)\n+        *root = index;\n+      return node.space;\n+    }\n+\n+    if (!node.parents)\n+    {\n+      if (root)\n+        *root = index;\n+      return 0;\n+    }\n+\n+    return space_for (node.parents[0], root);\n+  }\n+\n+  void err_other_error () { this->successful = false; }\n+\n+  size_t total_size_in_bytes () const {\n+    size_t total_size = 0;\n+    for (unsigned i = 0; i < vertices_.length; i++) {\n+      size_t size = vertices_[i].obj.tail - vertices_[i].obj.head;\n+      total_size += size;\n+    }\n+    return total_size;\n+  }\n+\n+\n+ private:\n+\n+  \/*\n+   * Returns the numbers of incoming edges that are 32bits wide.\n+   *\/\n+  unsigned wide_parents (unsigned node_idx, hb_set_t& parents) const\n+  {\n+    unsigned count = 0;\n+    hb_set_t visited;\n+    for (unsigned p : vertices_[node_idx].parents)\n+    {\n+      if (visited.has (p)) continue;\n+      visited.add (p);\n+\n+      \/\/ Only real links can be wide\n+      for (const auto& l : vertices_[p].obj.real_links)\n+      {\n+        if (l.objidx == node_idx && l.width == 4 && !l.is_signed)\n+        {\n+          count++;\n+          parents.add (p);\n+        }\n+      }\n+    }\n+    return count;\n+  }\n+\n+  bool check_success (bool success)\n+  { return this->successful && (success || ((void) err_other_error (), false)); }\n+\n+ public:\n+  \/*\n+   * Creates a map from objid to # of incoming edges.\n+   *\/\n+  void update_parents ()\n+  {\n+    if (!parents_invalid) return;\n+\n+    for (unsigned i = 0; i < vertices_.length; i++)\n+      vertices_[i].parents.reset ();\n+\n+    for (unsigned p = 0; p < vertices_.length; p++)\n+    {\n+      for (auto& l : vertices_[p].obj.all_links ())\n+      {\n+        vertices_[l.objidx].parents.push (p);\n+      }\n+    }\n+\n+    parents_invalid = false;\n+  }\n+\n+  \/*\n+   * compute the serialized start and end positions for each vertex.\n+   *\/\n+  void update_positions ()\n+  {\n+    if (!positions_invalid) return;\n+\n+    unsigned current_pos = 0;\n+    for (int i = root_idx (); i >= 0; i--)\n+    {\n+      auto& v = vertices_[i];\n+      v.start = current_pos;\n+      current_pos += v.obj.tail - v.obj.head;\n+      v.end = current_pos;\n+    }\n+\n+    positions_invalid = false;\n+  }\n+\n+  \/*\n+   * Finds the distance to each object in the graph\n+   * from the initial node.\n+   *\/\n+  void update_distances ()\n+  {\n+    if (!distance_invalid) return;\n+\n+    \/\/ Uses Dijkstra's algorithm to find all of the shortest distances.\n+    \/\/ https:\/\/en.wikipedia.org\/wiki\/Dijkstra%27s_algorithm\n+    \/\/\n+    \/\/ Implementation Note:\n+    \/\/ Since our priority queue doesn't support fast priority decreases\n+    \/\/ we instead just add new entries into the queue when a priority changes.\n+    \/\/ Redundant ones are filtered out later on by the visited set.\n+    \/\/ According to https:\/\/www3.cs.stonybrook.edu\/~rezaul\/papers\/TR-07-54.pdf\n+    \/\/ for practical performance this is faster then using a more advanced queue\n+    \/\/ (such as a fibonacci queue) with a fast decrease priority.\n+    for (unsigned i = 0; i < vertices_.length; i++)\n+    {\n+      if (i == vertices_.length - 1)\n+        vertices_[i].distance = 0;\n+      else\n+        vertices_[i].distance = hb_int_max (int64_t);\n+    }\n+\n+    hb_priority_queue_t queue;\n+    queue.insert (0, vertices_.length - 1);\n+\n+    hb_vector_t<bool> visited;\n+    visited.resize (vertices_.length);\n+\n+    while (!queue.in_error () && !queue.is_empty ())\n+    {\n+      unsigned next_idx = queue.pop_minimum ().second;\n+      if (visited[next_idx]) continue;\n+      const auto& next = vertices_[next_idx];\n+      int64_t next_distance = vertices_[next_idx].distance;\n+      visited[next_idx] = true;\n+\n+      for (const auto& link : next.obj.all_links ())\n+      {\n+        if (visited[link.objidx]) continue;\n+\n+        const auto& child = vertices_[link.objidx].obj;\n+        unsigned link_width = link.width ? link.width : 4; \/\/ treat virtual offsets as 32 bits wide\n+        int64_t child_weight = (child.tail - child.head) +\n+                               ((int64_t) 1 << (link_width * 8)) * (vertices_[link.objidx].space + 1);\n+        int64_t child_distance = next_distance + child_weight;\n+\n+        if (child_distance < vertices_[link.objidx].distance)\n+        {\n+          vertices_[link.objidx].distance = child_distance;\n+          queue.insert (child_distance, link.objidx);\n+        }\n+      }\n+    }\n+\n+    check_success (!queue.in_error ());\n+    if (!check_success (queue.is_empty ()))\n+    {\n+      print_orphaned_nodes ();\n+      return;\n+    }\n+\n+    distance_invalid = false;\n+  }\n+\n+ private:\n+  \/*\n+   * Updates a link in the graph to point to a different object. Corrects the\n+   * parents vector on the previous and new child nodes.\n+   *\/\n+  void reassign_link (hb_serialize_context_t::object_t::link_t& link,\n+                      unsigned parent_idx,\n+                      unsigned new_idx)\n+  {\n+    unsigned old_idx = link.objidx;\n+    link.objidx = new_idx;\n+    vertices_[old_idx].remove_parent (parent_idx);\n+    vertices_[new_idx].parents.push (parent_idx);\n+  }\n+\n+  \/*\n+   * Updates all objidx's in all links using the provided mapping. Corrects incoming edge counts.\n+   *\/\n+  template<typename Iterator, hb_requires (hb_is_iterator (Iterator))>\n+  void remap_obj_indices (const hb_map_t& id_map,\n+                          Iterator subgraph,\n+                          bool only_wide = false)\n+  {\n+    if (!id_map) return;\n+    for (unsigned i : subgraph)\n+    {\n+      for (auto& link : vertices_[i].obj.all_links_writer ())\n+      {\n+        const unsigned *v;\n+        if (!id_map.has (link.objidx, &v)) continue;\n+        if (only_wide && !(link.width == 4 && !link.is_signed)) continue;\n+\n+        reassign_link (link, i, *v);\n+      }\n+    }\n+  }\n+\n+  \/*\n+   * Updates all objidx's in all links using the provided mapping.\n+   *\/\n+  void remap_all_obj_indices (const hb_vector_t<unsigned>& id_map,\n+                              hb_vector_t<vertex_t>* sorted_graph) const\n+  {\n+    for (unsigned i = 0; i < sorted_graph->length; i++)\n+    {\n+      (*sorted_graph)[i].remap_parents (id_map);\n+      for (auto& link : (*sorted_graph)[i].obj.all_links_writer ())\n+      {\n+        link.objidx = id_map[link.objidx];\n+      }\n+    }\n+  }\n+\n+  \/*\n+   * Finds all nodes in targets that are reachable from start_idx, nodes in visited will be skipped.\n+   * For this search the graph is treated as being undirected.\n+   *\n+   * Connected targets will be added to connected and removed from targets. All visited nodes\n+   * will be added to visited.\n+   *\/\n+  void find_connected_nodes (unsigned start_idx,\n+                             hb_set_t& targets,\n+                             hb_set_t& visited,\n+                             hb_set_t& connected)\n+  {\n+    if (unlikely (!check_success (!visited.in_error ()))) return;\n+    if (visited.has (start_idx)) return;\n+    visited.add (start_idx);\n+\n+    if (targets.has (start_idx))\n+    {\n+      targets.del (start_idx);\n+      connected.add (start_idx);\n+    }\n+\n+    const auto& v = vertices_[start_idx];\n+\n+    \/\/ Graph is treated as undirected so search children and parents of start_idx\n+    for (const auto& l : v.obj.all_links ())\n+      find_connected_nodes (l.objidx, targets, visited, connected);\n+\n+    for (unsigned p : v.parents)\n+      find_connected_nodes (p, targets, visited, connected);\n+  }\n+\n+ public:\n+  \/\/ TODO(garretrieger): make private, will need to move most of offset overflow code into graph.\n+  hb_vector_t<vertex_t> vertices_;\n+  hb_vector_t<vertex_t> vertices_scratch_;\n+ private:\n+  bool parents_invalid;\n+  bool distance_invalid;\n+  bool positions_invalid;\n+  bool successful;\n+  hb_vector_t<unsigned> num_roots_for_space_;\n+};\n+\n+}\n+\n+#endif  \/\/ GRAPH_GRAPH_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/graph.hh","additions":860,"deletions":0,"binary":false,"changes":860,"status":"added"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright  2022  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef GRAPH_SERIALIZE_HH\n+#define GRAPH_SERIALIZE_HH\n+\n+namespace graph {\n+\n+struct overflow_record_t\n+{\n+  unsigned parent;\n+  unsigned child;\n+};\n+\n+inline\n+int64_t compute_offset (\n+    const graph_t& graph,\n+    unsigned parent_idx,\n+    const hb_serialize_context_t::object_t::link_t& link)\n+{\n+  const auto& parent = graph.vertices_[parent_idx];\n+  const auto& child = graph.vertices_[link.objidx];\n+  int64_t offset = 0;\n+  switch ((hb_serialize_context_t::whence_t) link.whence) {\n+    case hb_serialize_context_t::whence_t::Head:\n+      offset = child.start - parent.start; break;\n+    case hb_serialize_context_t::whence_t::Tail:\n+      offset = child.start - parent.end; break;\n+    case hb_serialize_context_t::whence_t::Absolute:\n+      offset = child.start; break;\n+  }\n+\n+  assert (offset >= link.bias);\n+  offset -= link.bias;\n+  return offset;\n+}\n+\n+inline\n+bool is_valid_offset (int64_t offset,\n+                      const hb_serialize_context_t::object_t::link_t& link)\n+{\n+  if (unlikely (!link.width))\n+    \/\/ Virtual links can't overflow.\n+    return link.is_signed || offset >= 0;\n+\n+  if (link.is_signed)\n+  {\n+    if (link.width == 4)\n+      return offset >= -((int64_t) 1 << 31) && offset < ((int64_t) 1 << 31);\n+    else\n+      return offset >= -(1 << 15) && offset < (1 << 15);\n+  }\n+  else\n+  {\n+    if (link.width == 4)\n+      return offset >= 0 && offset < ((int64_t) 1 << 32);\n+    else if (link.width == 3)\n+      return offset >= 0 && offset < ((int32_t) 1 << 24);\n+    else\n+      return offset >= 0 && offset < (1 << 16);\n+  }\n+}\n+\n+\/*\n+ * Will any offsets overflow on graph when it's serialized?\n+ *\/\n+inline bool\n+will_overflow (graph_t& graph,\n+               hb_vector_t<overflow_record_t>* overflows = nullptr)\n+{\n+  if (overflows) overflows->resize (0);\n+  graph.update_positions ();\n+\n+  const auto& vertices = graph.vertices_;\n+  for (int parent_idx = vertices.length - 1; parent_idx >= 0; parent_idx--)\n+  {\n+    \/\/ Don't need to check virtual links for overflow\n+    for (const auto& link : vertices[parent_idx].obj.real_links)\n+    {\n+      int64_t offset = compute_offset (graph, parent_idx, link);\n+      if (is_valid_offset (offset, link))\n+        continue;\n+\n+      if (!overflows) return true;\n+\n+      overflow_record_t r;\n+      r.parent = parent_idx;\n+      r.child = link.objidx;\n+      overflows->push (r);\n+    }\n+  }\n+\n+  if (!overflows) return false;\n+  return overflows->length;\n+}\n+\n+inline\n+void print_overflows (graph_t& graph,\n+                      const hb_vector_t<overflow_record_t>& overflows)\n+{\n+  if (!DEBUG_ENABLED(SUBSET_REPACK)) return;\n+\n+  graph.update_parents ();\n+  int limit = 10;\n+  for (const auto& o : overflows)\n+  {\n+    if (!limit--) break;\n+    const auto& parent = graph.vertices_[o.parent];\n+    const auto& child = graph.vertices_[o.child];\n+    DEBUG_MSG (SUBSET_REPACK, nullptr,\n+               \"  overflow from \"\n+               \"%4d (%4d in, %4d out, space %2d) => \"\n+               \"%4d (%4d in, %4d out, space %2d)\",\n+               o.parent,\n+               parent.incoming_edges (),\n+               parent.obj.real_links.length + parent.obj.virtual_links.length,\n+               graph.space_for (o.parent),\n+               o.child,\n+               child.incoming_edges (),\n+               child.obj.real_links.length + child.obj.virtual_links.length,\n+               graph.space_for (o.child));\n+  }\n+  if (overflows.length > 10) {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"  ... plus %d more overflows.\", overflows.length - 10);\n+  }\n+}\n+\n+template <typename O> inline void\n+serialize_link_of_type (const hb_serialize_context_t::object_t::link_t& link,\n+                        char* head,\n+                        hb_serialize_context_t* c)\n+{\n+  OT::Offset<O>* offset = reinterpret_cast<OT::Offset<O>*> (head + link.position);\n+  *offset = 0;\n+  c->add_link (*offset,\n+               \/\/ serializer has an extra nil object at the start of the\n+               \/\/ object array. So all id's are +1 of what our id's are.\n+               link.objidx + 1,\n+               (hb_serialize_context_t::whence_t) link.whence,\n+               link.bias);\n+}\n+\n+inline\n+void serialize_link (const hb_serialize_context_t::object_t::link_t& link,\n+                     char* head,\n+                     hb_serialize_context_t* c)\n+{\n+  switch (link.width)\n+  {\n+    case 0:\n+      \/\/ Virtual links aren't serialized.\n+      return;\n+    case 4:\n+      if (link.is_signed)\n+      {\n+        serialize_link_of_type<OT::HBINT32> (link, head, c);\n+      } else {\n+        serialize_link_of_type<OT::HBUINT32> (link, head, c);\n+      }\n+      return;\n+    case 2:\n+      if (link.is_signed)\n+      {\n+        serialize_link_of_type<OT::HBINT16> (link, head, c);\n+      } else {\n+        serialize_link_of_type<OT::HBUINT16> (link, head, c);\n+      }\n+      return;\n+    case 3:\n+      serialize_link_of_type<OT::HBUINT24> (link, head, c);\n+      return;\n+    default:\n+      \/\/ Unexpected link width.\n+      assert (0);\n+  }\n+}\n+\n+\/*\n+ * serialize graph into the provided serialization buffer.\n+ *\/\n+inline hb_blob_t* serialize (const graph_t& graph)\n+{\n+  hb_vector_t<char> buffer;\n+  size_t size = graph.total_size_in_bytes ();\n+  if (!buffer.alloc (size)) {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"Unable to allocate output buffer.\");\n+    return nullptr;\n+  }\n+  hb_serialize_context_t c((void *) buffer, size);\n+\n+  c.start_serialize<void> ();\n+  const auto& vertices = graph.vertices_;\n+  for (unsigned i = 0; i < vertices.length; i++) {\n+    c.push ();\n+\n+    size_t size = vertices[i].obj.tail - vertices[i].obj.head;\n+    char* start = c.allocate_size <char> (size);\n+    if (!start) {\n+      DEBUG_MSG (SUBSET_REPACK, nullptr, \"Buffer out of space.\");\n+      return nullptr;\n+    }\n+\n+    memcpy (start, vertices[i].obj.head, size);\n+\n+    \/\/ Only real links needs to be serialized.\n+    for (const auto& link : vertices[i].obj.real_links)\n+      serialize_link (link, start, &c);\n+\n+    \/\/ All duplications are already encoded in the graph, so don't\n+    \/\/ enable sharing during packing.\n+    c.pop_pack (false);\n+  }\n+  c.end_serialize ();\n+\n+  if (c.in_error ()) {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"Error during serialization. Err flag: %d\",\n+               c.errors);\n+    return nullptr;\n+  }\n+\n+  return c.copy_blob ();\n+}\n+\n+} \/\/ namespace graph\n+\n+#endif \/\/ GRAPH_SERIALIZE_HH\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/graph\/serialize.hh","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n-typedef LArrayOf<Anchor> GlyphAnchors;\n+typedef Array32Of<Anchor> GlyphAnchors;\n@@ -67,1 +67,1 @@\n-    const NNOffsetTo<GlyphAnchors> *offset = (this+lookupTable).get_value (glyph_id, num_glyphs);\n+    const NNOffset16To<GlyphAnchors> *offset = (this+lookupTable).get_value (glyph_id, num_glyphs);\n@@ -86,1 +86,1 @@\n-  LOffsetTo<Lookup<NNOffsetTo<GlyphAnchors>>>\n+  Offset32To<Lookup<NNOffset16To<GlyphAnchors>>>\n@@ -88,1 +88,1 @@\n-  LNNOffsetTo<HBUINT8>\n+  NNOffset32To<HBUINT8>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-ankr-table.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  HBGlyphID     stdGlyph;       \/* The specific glyph index number in this\n+  HBGlyphID16   stdGlyph;       \/* The specific glyph index number in this\n@@ -108,1 +108,1 @@\n-  HBGlyphID     stdGlyph;       \/* ditto *\/\n+  HBGlyphID16   stdGlyph;       \/* ditto *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-bsln-table.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+namespace OT {\n+struct GDEF;\n+};\n@@ -96,2 +99,2 @@\n-  HBGlyphID     last;           \/* Last GlyphID in this segment *\/\n-  HBGlyphID     first;          \/* First GlyphID in this segment *\/\n+  HBGlyphID16   last;           \/* Last GlyphID in this segment *\/\n+  HBGlyphID16   first;          \/* First GlyphID in this segment *\/\n@@ -162,1 +165,1 @@\n-                  valuesZ.sanitize (c, base, last - first + 1, hb_forward<Ts> (ds)...));\n+                  valuesZ.sanitize (c, base, last - first + 1, std::forward<Ts> (ds)...));\n@@ -165,3 +168,3 @@\n-  HBGlyphID     last;           \/* Last GlyphID in this segment *\/\n-  HBGlyphID     first;          \/* First GlyphID in this segment *\/\n-  NNOffsetTo<UnsizedArrayOf<T>>\n+  HBGlyphID16   last;           \/* Last GlyphID in this segment *\/\n+  HBGlyphID16   first;          \/* First GlyphID in this segment *\/\n+  NNOffset16To<UnsizedArrayOf<T>>\n@@ -225,1 +228,1 @@\n-  HBGlyphID     glyph;          \/* Last GlyphID *\/\n+  HBGlyphID16   glyph;          \/* Last GlyphID *\/\n@@ -287,1 +290,1 @@\n-  HBGlyphID     firstGlyph;     \/* First glyph index included in the trimmed array. *\/\n+  HBGlyphID16   firstGlyph;     \/* First glyph index included in the trimmed array. *\/\n@@ -329,1 +332,1 @@\n-  HBGlyphID     firstGlyph;     \/* First glyph index included in the trimmed array. *\/\n+  HBGlyphID16   firstGlyph;     \/* First glyph index included in the trimmed array. *\/\n@@ -661,2 +664,2 @@\n-  HBGlyphID             firstGlyph;     \/* First glyph index included in the trimmed array. *\/\n-  ArrayOf<HBUCHAR>      classArray;     \/* The class codes (indexed by glyph index minus\n+  HBGlyphID16           firstGlyph;     \/* First glyph index included in the trimmed array. *\/\n+  Array16Of<HBUCHAR>    classArray;     \/* The class codes (indexed by glyph index minus\n@@ -681,1 +684,2 @@\n-    return (offset - ((const char *) array - (const char *) base)) \/ T::static_size;\n+    \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2816 *\/\n+    return (offset - unsigned ((const char *) array - (const char *) base)) \/ T::static_size;\n@@ -838,1 +842,1 @@\n-      buffer->swap_buffers ();\n+      buffer->sync ();\n@@ -865,0 +869,1 @@\n+  const OT::GDEF *gdef_table;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-common.hh","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<SettingName>>\n+  NNOffset32To<UnsizedArrayOf<SettingName>>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-feat-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  ArrayOf<HBUINT16>\n+  Array16Of<HBUINT16>\n@@ -103,1 +103,1 @@\n-  HBGlyphID     addGlyph;       \/* Glyph that should be added if the distance factor\n+  HBGlyphID16   addGlyph;       \/* Glyph that should be added if the distance factor\n@@ -124,1 +124,1 @@\n-  HBGlyphID     addGlyph;       \/* Glyph to be added as kashida. If this value is\n+  HBGlyphID16   addGlyph;       \/* Glyph to be added as kashida. If this value is\n@@ -128,1 +128,1 @@\n-  HBGlyphID     substGlyph;     \/* Glyph to be substituted for this glyph if the\n+  HBGlyphID16   substGlyph;     \/* Glyph to be substituted for this glyph if the\n@@ -149,1 +149,1 @@\n-  HBFixed       minimumLimit;   \/* The lowest value for the ductility axis tha\n+  HBFixed       minimumLimit;   \/* The lowest value for the ductility axis that\n@@ -173,1 +173,1 @@\n-  HBGlyphID     glyph;          \/* Glyph that should be added if the distance factor\n+  HBGlyphID16   glyph;          \/* Glyph that should be added if the distance factor\n@@ -313,1 +313,1 @@\n-typedef OT::LArrayOf<WidthDeltaPair> WidthDeltaCluster;\n+typedef OT::Array32Of<WidthDeltaPair> WidthDeltaCluster;\n@@ -361,1 +361,1 @@\n-  OffsetTo<JustificationCategory>\n+  Offset16To<JustificationCategory>\n@@ -363,1 +363,1 @@\n-  OffsetTo<WidthDeltaCluster>\n+  Offset16To<WidthDeltaCluster>\n@@ -369,1 +369,1 @@\n-  OffsetTo<PostcompensationActionChain>\n+  Offset16To<PostcompensationActionChain>\n@@ -374,1 +374,1 @@\n-  Lookup<OffsetTo<WidthDeltaCluster>>\n+  Lookup<Offset16To<WidthDeltaCluster>>\n@@ -401,1 +401,1 @@\n-  OffsetTo<JustificationHeader>\n+  Offset16To<JustificationHeader>\n@@ -407,1 +407,1 @@\n-  OffsetTo<JustificationHeader>\n+  Offset16To<JustificationHeader>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-just-table.hh","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -85,2 +85,2 @@\n-  HBGlyphID     left;\n-  HBGlyphID     right;\n+  HBGlyphID16   left;\n+  HBGlyphID16   right;\n@@ -290,1 +290,1 @@\n-                o.attach_type() = ATTACH_TYPE_NONE;\n+                o.attach_type() = OT::Layout::GPOS_impl::ATTACH_TYPE_NONE;\n@@ -313,1 +313,1 @@\n-                o.attach_type() = ATTACH_TYPE_NONE;\n+                o.attach_type() = OT::Layout::GPOS_impl::ATTACH_TYPE_NONE;\n@@ -570,1 +570,1 @@\n-        o.attach_type() = ATTACH_TYPE_MARK;\n+        o.attach_type() = OT::Layout::GPOS_impl::ATTACH_TYPE_MARK;\n@@ -713,3 +713,3 @@\n-      LNNOffsetTo<Lookup<HBUINT32>>             rowIndexTable;\n-      LNNOffsetTo<Lookup<HBUINT32>>             columnIndexTable;\n-      LNNOffsetTo<UnsizedArrayOf<FWORD32>>      array;\n+      NNOffset32To<Lookup<HBUINT32>>            rowIndexTable;\n+      NNOffset32To<Lookup<HBUINT32>>            columnIndexTable;\n+      NNOffset32To<UnsizedArrayOf<FWORD32>>     array;\n@@ -719,3 +719,3 @@\n-      LNNOffsetTo<Lookup<HBUINT16>>             rowIndexTable;\n-      LNNOffsetTo<Lookup<HBUINT16>>             columnIndexTable;\n-      LNNOffsetTo<UnsizedArrayOf<FWORD>>        array;\n+      NNOffset32To<Lookup<HBUINT16>>            rowIndexTable;\n+      NNOffset32To<Lookup<HBUINT16>>            columnIndexTable;\n+      NNOffset32To<UnsizedArrayOf<FWORD>>       array;\n@@ -724,1 +724,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<FWORD>>    vector;\n+  NNOffset32To<UnsizedArrayOf<FWORD>>   vector;\n@@ -778,5 +778,5 @@\n-    case 0:     return_trace (c->dispatch (u.format0, hb_forward<Ts> (ds)...));\n-    case 1:     return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    case 2:     return_trace (c->dispatch (u.format2, hb_forward<Ts> (ds)...));\n-    case 4:     return_trace (c->dispatch (u.format4, hb_forward<Ts> (ds)...));\n-    case 6:     return_trace (c->dispatch (u.format6, hb_forward<Ts> (ds)...));\n+    case 0:     return_trace (c->dispatch (u.format0, std::forward<Ts> (ds)...));\n+    case 1:     return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2:     return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    case 4:     return_trace (c->dispatch (u.format4, std::forward<Ts> (ds)...));\n+    case 6:     return_trace (c->dispatch (u.format6, std::forward<Ts> (ds)...));\n@@ -904,1 +904,1 @@\n-          pos[i].attach_type() = ATTACH_TYPE_CURSIVE;\n+          pos[i].attach_type() = OT::Layout::GPOS_impl::ATTACH_TYPE_CURSIVE;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-kerx-table.hh","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"hb-ot-layout-gdef-table.hh\"\n@@ -125,1 +126,1 @@\n-        if (end - start >= l + r)\n+        if (end - start >= l + r && end-start <= HB_MAX_CONTEXT_LENGTH)\n@@ -218,0 +219,1 @@\n+        gdef (*c->gdef_table),\n@@ -219,0 +221,1 @@\n+        has_glyph_classes (gdef.has_glyph_classes ()),\n@@ -243,1 +246,1 @@\n-      const HBGlyphID *replacement;\n+      const HBGlyphID16 *replacement;\n@@ -250,1 +253,1 @@\n-          const Lookup<HBGlyphID> &lookup = subs[entry.data.markIndex];\n+          const Lookup<HBGlyphID16> &lookup = subs[entry.data.markIndex];\n@@ -257,1 +260,1 @@\n-        const UnsizedArrayOf<HBGlyphID> &subs_old = (const UnsizedArrayOf<HBGlyphID> &) subs;\n+        const UnsizedArrayOf<HBGlyphID16> &subs_old = (const UnsizedArrayOf<HBGlyphID16> &) subs;\n@@ -266,0 +269,3 @@\n+        if (has_glyph_classes)\n+          _hb_glyph_info_set_glyph_props (&buffer->info[mark],\n+                                          gdef.get_glyph_props (*replacement));\n@@ -275,1 +281,1 @@\n-          const Lookup<HBGlyphID> &lookup = subs[entry.data.currentIndex];\n+          const Lookup<HBGlyphID16> &lookup = subs[entry.data.currentIndex];\n@@ -282,1 +288,1 @@\n-        const UnsizedArrayOf<HBGlyphID> &subs_old = (const UnsizedArrayOf<HBGlyphID> &) subs;\n+        const UnsizedArrayOf<HBGlyphID16> &subs_old = (const UnsizedArrayOf<HBGlyphID16> &) subs;\n@@ -290,0 +296,3 @@\n+        if (has_glyph_classes)\n+          _hb_glyph_info_set_glyph_props (&buffer->info[idx],\n+                                          gdef.get_glyph_props (*replacement));\n@@ -304,0 +313,1 @@\n+    const OT::GDEF &gdef;\n@@ -305,0 +315,1 @@\n+    bool has_glyph_classes;\n@@ -307,1 +318,1 @@\n-    const UnsizedOffsetListOf<Lookup<HBGlyphID>, HBUINT, false> &subs;\n+    const UnsizedListOfOffset16To<Lookup<HBGlyphID16>, HBUINT, false> &subs;\n@@ -351,1 +362,1 @@\n-  NNOffsetTo<UnsizedOffsetListOf<Lookup<HBGlyphID>, HBUINT, false>, HBUINT>\n+  NNOffsetTo<UnsizedListOfOffset16To<Lookup<HBGlyphID16>, HBUINT, false>, HBUINT>\n@@ -523,1 +534,1 @@\n-            const HBGlyphID &ligatureData = ligature[ligature_idx];\n+            const HBGlyphID16 &ligatureData = ligature[ligature_idx];\n@@ -557,1 +568,1 @@\n-    const UnsizedArrayOf<HBGlyphID> &ligature;\n+    const UnsizedArrayOf<HBGlyphID16> &ligature;\n@@ -589,1 +600,1 @@\n-  NNOffsetTo<UnsizedArrayOf<HBGlyphID>, HBUINT>\n+  NNOffsetTo<UnsizedArrayOf<HBGlyphID16>, HBUINT>\n@@ -602,0 +613,3 @@\n+    const OT::GDEF &gdef (*c->gdef_table);\n+    bool has_glyph_classes = gdef.has_glyph_classes ();\n+\n@@ -609,1 +623,1 @@\n-      const HBGlyphID *replacement = substitute.get_value (info[i].codepoint, num_glyphs);\n+      const HBGlyphID16 *replacement = substitute.get_value (info[i].codepoint, num_glyphs);\n@@ -613,0 +627,3 @@\n+        if (has_glyph_classes)\n+          _hb_glyph_info_set_glyph_props (&info[i],\n+                                          gdef.get_glyph_props (*replacement));\n@@ -627,1 +644,1 @@\n-  Lookup<HBGlyphID>     substitute;\n+  Lookup<HBGlyphID16>   substitute;\n@@ -730,1 +747,1 @@\n-        const HBGlyphID *glyphs = &insertionAction[start];\n+        const HBGlyphID16 *glyphs = &insertionAction[start];\n@@ -758,1 +775,1 @@\n-        const HBGlyphID *glyphs = &insertionAction[start];\n+        const HBGlyphID16 *glyphs = &insertionAction[start];\n@@ -796,1 +813,1 @@\n-    const UnsizedArrayOf<HBGlyphID> &insertionAction;\n+    const UnsizedArrayOf<HBGlyphID16> &insertionAction;\n@@ -822,1 +839,1 @@\n-  NNOffsetTo<UnsizedArrayOf<HBGlyphID>, HBUINT>\n+  NNOffsetTo<UnsizedArrayOf<HBGlyphID16>, HBUINT>\n@@ -892,5 +909,5 @@\n-    case Rearrangement:         return_trace (c->dispatch (u.rearrangement, hb_forward<Ts> (ds)...));\n-    case Contextual:            return_trace (c->dispatch (u.contextual, hb_forward<Ts> (ds)...));\n-    case Ligature:              return_trace (c->dispatch (u.ligature, hb_forward<Ts> (ds)...));\n-    case Noncontextual:         return_trace (c->dispatch (u.noncontextual, hb_forward<Ts> (ds)...));\n-    case Insertion:             return_trace (c->dispatch (u.insertion, hb_forward<Ts> (ds)...));\n+    case Rearrangement:         return_trace (c->dispatch (u.rearrangement, std::forward<Ts> (ds)...));\n+    case Contextual:            return_trace (c->dispatch (u.contextual, std::forward<Ts> (ds)...));\n+    case Ligature:              return_trace (c->dispatch (u.ligature, std::forward<Ts> (ds)...));\n+    case Noncontextual:         return_trace (c->dispatch (u.noncontextual, std::forward<Ts> (ds)...));\n+    case Insertion:             return_trace (c->dispatch (u.insertion, std::forward<Ts> (ds)...));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-morx-table.hh","additions":39,"deletions":22,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    const OffsetTo<OpticalBounds> *bounds_offset = lookupTable.get_value (glyph_id, font->face->get_num_glyphs ());\n+    const Offset16To<OpticalBounds> *bounds_offset = lookupTable.get_value (glyph_id, font->face->get_num_glyphs ());\n@@ -82,1 +82,1 @@\n-  Lookup<OffsetTo<OpticalBounds>>\n+  Lookup<Offset16To<OpticalBounds>>\n@@ -95,1 +95,1 @@\n-    const OffsetTo<OpticalBounds> *bounds_offset = lookupTable.get_value (glyph_id, font->face->get_num_glyphs ());\n+    const Offset16To<OpticalBounds> *bounds_offset = lookupTable.get_value (glyph_id, font->face->get_num_glyphs ());\n@@ -119,1 +119,1 @@\n-  Lookup<OffsetTo<OpticalBounds>>\n+  Lookup<Offset16To<OpticalBounds>>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-opbd-table.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  NNOffsetTo<UnsizedArrayOf<FWORD>>\n+  NNOffset16To<UnsizedArrayOf<FWORD>>\n@@ -144,1 +144,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<HBFixed>>\n+  NNOffset32To<UnsizedArrayOf<HBFixed>>\n@@ -215,1 +215,1 @@\n-  OffsetTo<TrackData>\n+  Offset16To<TrackData>\n@@ -218,1 +218,1 @@\n-  OffsetTo<TrackData>\n+  Offset16To<TrackData>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-trak-table.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+                                                       gdef_table (face->table.GDEF->table),\n@@ -110,1 +111,1 @@\n-  {HB_TAG ('h','i','s','t'), HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES,               HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_ON,        HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_OFF},\n+  {HB_TAG ('h','i','s','t'), (hb_aat_layout_feature_type_t) 40,                  (hb_aat_layout_feature_selector_t) 0,                          (hb_aat_layout_feature_selector_t) 1},\n@@ -172,0 +173,1 @@\n+  {HB_TAG ('v','r','t','r'), HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION,   (hb_aat_layout_feature_selector_t) 2,                          (hb_aat_layout_feature_selector_t) 3},\n@@ -251,0 +253,1 @@\n+    if (!buffer->message (font, \"start table morx\")) return;\n@@ -252,0 +255,1 @@\n+    (void) buffer->message (font, \"end table morx\");\n@@ -260,0 +264,1 @@\n+    if (!buffer->message (font, \"start table mort\")) return;\n@@ -261,0 +266,1 @@\n+    (void) buffer->message (font, \"end table mort\");\n@@ -316,0 +322,1 @@\n+  if (!buffer->message (font, \"start table kerx\")) return;\n@@ -318,0 +325,1 @@\n+  (void) buffer->message (font, \"end table kerx\");\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout.cc","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  NNOffsetTo<UnsizedArrayOf<HBUINT8>>\n+  NNOffset16To<UnsizedArrayOf<HBUINT8>>\n@@ -83,1 +83,1 @@\n-  LArrayOf<FTStringRange>\n+  Array32Of<FTStringRange>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-ltag-table.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+#include <algorithm>\n+#include <initializer_list>\n+#include <functional>\n+#include <new>\n@@ -58,1 +62,1 @@\n-          static inline constexpr T operator ~ (T r) { return T (~(unsigned int) r); } \\\n+          static inline constexpr unsigned operator ~ (T r) { return (~(unsigned) r); } \\\n@@ -128,1 +132,1 @@\n-  static_assert (!hb_is_signed (Type), \"\");\n+  static_assert (!std::is_signed<Type>::value, \"\");\n@@ -149,4 +153,20 @@\n-  constexpr operator Type () const { return (v[0] << 24)\n-                                          + (v[1] << 16)\n-                                          + (v[2] <<  8)\n-                                          + (v[3]      ); }\n+\n+  struct __attribute__((packed)) packed_uint32_t { uint32_t v; };\n+  constexpr operator Type () const {\n+#if ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n+    defined(__BYTE_ORDER) && \\\n+    (__BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __BIG_ENDIAN)\n+    \/* Spoon-feed the compiler a big-endian integer with alignment 1.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/1398 *\/\n+#if __BYTE_ORDER == __LITTLE_ENDIAN\n+    return __builtin_bswap32 (((packed_uint32_t *) this)->v);\n+#else \/* __BYTE_ORDER == __BIG_ENDIAN *\/\n+    return ((packed_uint32_t *) this)->v;\n+#endif\n+#else\n+    return (v[0] << 24)\n+         + (v[1] << 16)\n+         + (v[2] <<  8)\n+         + (v[3]      );\n+#endif\n+  }\n@@ -182,1 +202,1 @@\n-  operator () (T&& v) const HB_AUTO_RETURN ( hb_forward<T> (v) )\n+  operator () (T&& v) const HB_AUTO_RETURN ( std::forward<T> (v) )\n@@ -206,1 +226,1 @@\n-  operator () (T&& v) const { return bool (hb_forward<T> (v)); }\n+  operator () (T&& v) const { return bool (std::forward<T> (v)); }\n@@ -217,7 +237,13 @@\n-  template <typename T,\n-            hb_enable_if (hb_is_integral (T))> constexpr auto\n-  impl (const T& v, hb_priority<0>) const HB_AUTO_RETURN\n-  (\n-    \/* Knuth's multiplicative method: *\/\n-    (uint32_t) v * 2654435761u\n-  )\n+  template <typename T> constexpr uint32_t\n+  impl (const hb::shared_ptr<T>& v, hb_priority<1>) const\n+  {\n+    return v.get () ? v.get ()->hash () : 0;\n+  }\n+  template <typename T> constexpr uint32_t\n+  impl (const hb::unique_ptr<T>& v, hb_priority<1>) const\n+  {\n+    return v.get () ? v.get ()->hash () : 0;\n+  }\n+\n+  template <typename T> constexpr auto\n+  impl (const T& v, hb_priority<0>) const HB_RETURN (uint32_t, std::hash<hb_decay<decltype (hb_deref (v))>>{} (hb_deref (v)))\n@@ -240,1 +266,1 @@\n-  ((hb_deref (hb_forward<T> (v)).*hb_forward<Appl> (a)) (hb_forward<Ts> (ds)...))\n+  ((hb_deref (std::forward<T> (v)).*std::forward<Appl> (a)) (std::forward<Ts> (ds)...))\n@@ -245,1 +271,1 @@\n-  ((hb_deref (hb_forward<T> (v))).*hb_forward<Appl> (a))\n+  ((hb_deref (std::forward<T> (v))).*std::forward<Appl> (a))\n@@ -250,1 +276,1 @@\n-  (hb_deref (hb_forward<Appl> (a)) (hb_forward<Ts> (ds)...))\n+  (hb_deref (std::forward<Appl> (a)) (std::forward<Ts> (ds)...))\n@@ -257,1 +283,1 @@\n-    impl (hb_forward<Appl> (a),\n+    impl (std::forward<Appl> (a),\n@@ -259,1 +285,1 @@\n-          hb_forward<Ts> (ds)...)\n+          std::forward<Ts> (ds)...)\n@@ -278,3 +304,3 @@\n-    return hb_invoke (hb_forward<Appl> (a),\n-                      hb_forward<V> (v),\n-                      hb_forward<Ts> (ds)...);\n+    return hb_invoke (std::forward<Appl> (a),\n+                      std::forward<V> (v),\n+                      std::forward<Ts> (ds)...);\n@@ -290,4 +316,4 @@\n-    return hb_invoke (hb_forward<Appl> (a),\n-                      hb_forward<T0> (d0),\n-                      hb_forward<V> (v),\n-                      hb_forward<Ts> (ds)...);\n+    return hb_invoke (std::forward<Appl> (a),\n+                      std::forward<T0> (d0),\n+                      std::forward<V> (v),\n+                      std::forward<Ts> (ds)...);\n@@ -327,1 +353,1 @@\n-  { return hb_partial<Pos> (this, hb_forward<_T> (_v)); } \\\n+  { return hb_partial<Pos> (this, std::forward<_T> (_v)); } \\\n@@ -334,1 +360,1 @@\n-  (hb_partial<Pos> (+this, hb_forward<_T> (_v))) \\\n+  (hb_partial<Pos> (+this, std::forward<_T> (_v))) \\\n@@ -346,1 +372,1 @@\n-    hb_deref (hb_forward<Pred> (p)).has (hb_forward<Val> (v))\n+    hb_deref (std::forward<Pred> (p)).has (std::forward<Val> (v))\n@@ -352,2 +378,2 @@\n-    hb_invoke (hb_forward<Pred> (p),\n-               hb_forward<Val> (v))\n+    hb_invoke (std::forward<Pred> (p),\n+               std::forward<Val> (v))\n@@ -360,2 +386,2 @@\n-    impl (hb_forward<Pred> (p),\n-          hb_forward<Val> (v),\n+    impl (std::forward<Pred> (p),\n+          std::forward<Val> (v),\n@@ -374,2 +400,2 @@\n-    hb_has (hb_forward<Pred> (p),\n-            hb_forward<Val> (v))\n+    hb_has (std::forward<Pred> (p),\n+            std::forward<Val> (v))\n@@ -381,1 +407,1 @@\n-    hb_forward<Pred> (p) == hb_forward<Val> (v)\n+    std::forward<Pred> (p) == std::forward<Val> (v)\n@@ -388,2 +414,2 @@\n-    impl (hb_forward<Pred> (p),\n-          hb_forward<Val> (v),\n+    impl (std::forward<Pred> (p),\n+          std::forward<Val> (v),\n@@ -402,1 +428,1 @@\n-    hb_deref (hb_forward<Proj> (f)).get (hb_forward<Val> (v))\n+    hb_deref (std::forward<Proj> (f)).get (std::forward<Val> (v))\n@@ -408,2 +434,2 @@\n-    hb_invoke (hb_forward<Proj> (f),\n-               hb_forward<Val> (v))\n+    hb_invoke (std::forward<Proj> (f),\n+               std::forward<Val> (v))\n@@ -415,1 +441,1 @@\n-    hb_forward<Proj> (f)[hb_forward<Val> (v)]\n+    std::forward<Proj> (f)[std::forward<Val> (v)]\n@@ -423,2 +449,2 @@\n-    impl (hb_forward<Proj> (f),\n-          hb_forward<Val> (v),\n+    impl (std::forward<Proj> (f),\n+          std::forward<Val> (v),\n@@ -434,0 +460,6 @@\n+  template <typename T1, typename T2> auto\n+  impl (T1&& v1, T2 &&v2, hb_priority<3>) const HB_AUTO_RETURN\n+  (\n+    std::forward<T2> (v2).cmp (std::forward<T1> (v1)) == 0\n+  )\n+\n@@ -437,1 +469,1 @@\n-    hb_forward<T2> (v2).cmp (hb_forward<T1> (v1)) == 0\n+    std::forward<T1> (v1).cmp (std::forward<T2> (v2)) == 0\n@@ -443,1 +475,1 @@\n-    hb_forward<T1> (v1).cmp (hb_forward<T2> (v2)) == 0\n+    std::forward<T1> (v1) == std::forward<T2> (v2)\n@@ -449,1 +481,1 @@\n-    hb_forward<T1> (v1) == hb_forward<T2> (v2)\n+    std::forward<T2> (v2) == std::forward<T1> (v1)\n@@ -457,2 +489,2 @@\n-    impl (hb_forward<T1> (v1),\n-          hb_forward<T2> (v2),\n+    impl (std::forward<T1> (v1),\n+          std::forward<T2> (v2),\n@@ -472,0 +504,4 @@\n+  template <typename U1 = T1, typename U2 = T2,\n+            hb_enable_if (std::is_default_constructible<U1>::value &&\n+                          std::is_default_constructible<U2>::value)>\n+  hb_pair_t () : first (), second () {}\n@@ -476,1 +512,1 @@\n-                          hb_is_convertible (T2, T2))>\n+                          hb_is_convertible (T2, Q2))>\n@@ -518,1 +554,1 @@\n-  (a <= b ? hb_forward<T> (a) : hb_forward<T2> (b))\n+  (a <= b ? std::forward<T> (a) : std::forward<T2> (b))\n@@ -525,1 +561,1 @@\n-  (a >= b ? hb_forward<T> (a) : hb_forward<T2> (b))\n+  (a >= b ? std::forward<T> (a) : std::forward<T2> (b))\n@@ -532,1 +568,1 @@\n-  (hb_min (hb_max (hb_forward<T> (x), hb_forward<T2> (min)), hb_forward<T3> (max)))\n+  (hb_min (hb_max (std::forward<T> (x), std::forward<T2> (min)), std::forward<T3> (max)))\n@@ -536,0 +572,10 @@\n+struct\n+{\n+  template <typename T> void\n+  operator () (T& a, T& b) const\n+  {\n+    using std::swap; \/\/ allow ADL\n+    swap (a, b);\n+  }\n+}\n+HB_FUNCOBJ (hb_swap);\n@@ -763,0 +809,8 @@\n+static inline void *\n+hb_memcpy (void *__restrict dst, const void *__restrict src, size_t len)\n+{\n+  \/* It's illegal to pass 0 as size to memcpy. *\/\n+  if (unlikely (!len)) return dst;\n+  return memcpy (dst, src, len);\n+}\n+\n@@ -790,1 +844,1 @@\n-  static_assert (!hb_is_signed<T>::value, \"\");\n+  static_assert (!std::is_signed<T>::value, \"\");\n@@ -806,0 +860,5 @@\n+template <typename T> static inline bool\n+hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2, T lo3, T hi3, T lo4, T hi4)\n+{\n+  return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2) || hb_in_range (u, lo3, hi3) || hb_in_range (u, lo4, hi4);\n+}\n@@ -852,1 +911,1 @@\n-    int c = compar ((const void *) hb_addressof (key), (const void *) p, ds...);\n+    int c = compar ((const void *) std::addressof (key), (const void *) p, ds...);\n@@ -1154,1 +1213,1 @@\n-struct hb_bitwise_and\n+struct\n@@ -1160,1 +1219,1 @@\n-struct hb_bitwise_or\n+struct\n@@ -1166,1 +1225,1 @@\n-struct hb_bitwise_xor\n+struct\n@@ -1172,1 +1231,7 @@\n-struct hb_bitwise_sub\n+struct\n+{ HB_PARTIALIZE(2);\n+  template <typename T> constexpr auto\n+  operator () (const T &a, const T &b) const HB_AUTO_RETURN (~a & b)\n+}\n+HB_FUNCOBJ (hb_bitwise_lt);\n+struct\n@@ -1177,1 +1242,13 @@\n-HB_FUNCOBJ (hb_bitwise_sub);\n+HB_FUNCOBJ (hb_bitwise_gt); \/\/ aka sub\n+struct\n+{ HB_PARTIALIZE(2);\n+  template <typename T> constexpr auto\n+  operator () (const T &a, const T &b) const HB_AUTO_RETURN (~a | b)\n+}\n+HB_FUNCOBJ (hb_bitwise_le);\n+struct\n+{ HB_PARTIALIZE(2);\n+  template <typename T> constexpr auto\n+  operator () (const T &a, const T &b) const HB_AUTO_RETURN (a | ~b)\n+}\n+HB_FUNCOBJ (hb_bitwise_ge);\n@@ -1198,0 +1275,6 @@\n+{ HB_PARTIALIZE(2);\n+  template <typename T, typename T2> constexpr auto\n+  operator () (const T &a, const T2 &b) const HB_AUTO_RETURN (b - a)\n+}\n+HB_FUNCOBJ (hb_rsub);\n+struct\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-algs.hh","additions":144,"deletions":61,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -39,0 +39,8 @@\n+enum hb_not_found_t\n+{\n+  HB_NOT_FOUND_DONT_STORE,\n+  HB_NOT_FOUND_STORE,\n+  HB_NOT_FOUND_STORE_CLOSEST,\n+};\n+\n+\n@@ -45,2 +53,7 @@\n-  hb_array_t () : arrayZ (nullptr), length (0), backwards_length (0) {}\n-  hb_array_t (Type *array_, unsigned int length_) : arrayZ (array_), length (length_), backwards_length (0) {}\n+  hb_array_t () = default;\n+  hb_array_t (const hb_array_t&) = default;\n+  ~hb_array_t () = default;\n+  hb_array_t& operator= (const hb_array_t&) = default;\n+  hb_array_t& operator= (hb_array_t&&) = default;\n+\n+  constexpr hb_array_t (Type *array_, unsigned int length_) : arrayZ (array_), length (length_) {}\n@@ -48,1 +61,1 @@\n-  hb_array_t (Type (&array_)[length_]) : arrayZ (array_), length (length_), backwards_length (0) {}\n+  constexpr hb_array_t (Type (&array_)[length_]) : hb_array_t (array_, length_) {}\n@@ -52,1 +65,1 @@\n-  hb_array_t (const hb_array_t<U> &o) :\n+  constexpr hb_array_t (const hb_array_t<U> &o) :\n@@ -142,1 +155,3 @@\n-  bool lfind (const T &x, unsigned *pos = nullptr) const\n+  bool lfind (const T &x, unsigned *pos = nullptr,\n+              hb_not_found_t not_found = HB_NOT_FOUND_DONT_STORE,\n+              unsigned int to_store = (unsigned int) -1) const\n@@ -152,0 +167,16 @@\n+    if (pos)\n+    {\n+      switch (not_found)\n+      {\n+        case HB_NOT_FOUND_DONT_STORE:\n+          break;\n+\n+        case HB_NOT_FOUND_STORE:\n+          *pos = to_store;\n+          break;\n+\n+        case HB_NOT_FOUND_STORE_CLOSEST:\n+          *pos = length;\n+          break;\n+      }\n+    }\n@@ -222,1 +253,1 @@\n-  { return length < hb_null_size (T) ? &Null (T) : reinterpret_cast<const T *> (arrayZ); }\n+  { return length < hb_min_size (T) ? &Null (T) : reinterpret_cast<const T *> (arrayZ); }\n@@ -234,3 +265,3 @@\n-  \/* Only call if you allocated the underlying array using malloc() or similar. *\/\n-  void free ()\n-  { ::free ((void *) arrayZ); arrayZ = nullptr; length = 0; }\n+  \/* Only call if you allocated the underlying array using hb_malloc() or similar. *\/\n+  void fini ()\n+  { hb_free ((void *) arrayZ); arrayZ = nullptr; length = 0; }\n@@ -258,3 +289,3 @@\n-  Type *arrayZ;\n-  unsigned int length;\n-  unsigned int backwards_length;\n+  Type *arrayZ = nullptr;\n+  unsigned int length = 0;\n+  unsigned int backwards_length = 0;\n@@ -269,7 +300,0 @@\n-enum hb_bfind_not_found_t\n-{\n-  HB_BFIND_NOT_FOUND_DONT_STORE,\n-  HB_BFIND_NOT_FOUND_STORE,\n-  HB_BFIND_NOT_FOUND_STORE_CLOSEST,\n-};\n-\n@@ -286,2 +310,7 @@\n-  hb_sorted_array_t () : hb_array_t<Type> () {}\n-  hb_sorted_array_t (Type *array_, unsigned int length_) : hb_array_t<Type> (array_, length_) {}\n+  hb_sorted_array_t () = default;\n+  hb_sorted_array_t (const hb_sorted_array_t&) = default;\n+  ~hb_sorted_array_t () = default;\n+  hb_sorted_array_t& operator= (const hb_sorted_array_t&) = default;\n+  hb_sorted_array_t& operator= (hb_sorted_array_t&&) = default;\n+\n+  constexpr hb_sorted_array_t (Type *array_, unsigned int length_) : hb_array_t<Type> (array_, length_) {}\n@@ -289,1 +318,1 @@\n-  hb_sorted_array_t (Type (&array_)[length_]) : hb_array_t<Type> (array_) {}\n+  constexpr hb_sorted_array_t (Type (&array_)[length_]) : hb_array_t<Type> (array_) {}\n@@ -293,1 +322,1 @@\n-  hb_sorted_array_t (const hb_array_t<U> &o) :\n+  constexpr hb_sorted_array_t (const hb_array_t<U> &o) :\n@@ -318,1 +347,1 @@\n-  template <typename T>\n+  template <typename T, typename ...Ts>\n@@ -326,1 +355,1 @@\n-              hb_bfind_not_found_t not_found = HB_BFIND_NOT_FOUND_DONT_STORE,\n+              hb_not_found_t not_found = HB_NOT_FOUND_DONT_STORE,\n@@ -342,1 +371,1 @@\n-        case HB_BFIND_NOT_FOUND_DONT_STORE:\n+        case HB_NOT_FOUND_DONT_STORE:\n@@ -345,1 +374,1 @@\n-        case HB_BFIND_NOT_FOUND_STORE:\n+        case HB_NOT_FOUND_STORE:\n@@ -349,1 +378,1 @@\n-        case HB_BFIND_NOT_FOUND_STORE_CLOSEST:\n+        case HB_NOT_FOUND_STORE_CLOSEST:\n@@ -356,2 +385,2 @@\n-  template <typename T>\n-  bool bsearch_impl (const T &x, unsigned *pos) const\n+  template <typename T, typename ...Ts>\n+  bool bsearch_impl (const T &x, unsigned *pos, Ts... ds) const\n@@ -364,1 +393,2 @@\n-                            _hb_cmp_method<T, Type>);\n+                            _hb_cmp_method<T, Type, Ts...>,\n+                            ds...);\n@@ -375,1 +405,1 @@\n-bool hb_array_t<T>::operator == (const hb_array_t<T> &o) const\n+inline bool hb_array_t<T>::operator == (const hb_array_t<T> &o) const\n@@ -383,2 +413,12 @@\n-\n-\/* TODO Specialize opeator== for hb_bytes_t and hb_ubytes_t. *\/\n+template <>\n+inline bool hb_array_t<const char>::operator == (const hb_array_t<const char> &o) const\n+{\n+  if (o.length != this->length) return false;\n+  return 0 == hb_memcmp (arrayZ, o.arrayZ, length);\n+}\n+template <>\n+inline bool hb_array_t<const unsigned char>::operator == (const hb_array_t<const unsigned char> &o) const\n+{\n+  if (o.length != this->length) return false;\n+  return 0 == hb_memcmp (arrayZ, o.arrayZ, length);\n+}\n@@ -393,1 +433,0 @@\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-array.hh","additions":74,"deletions":35,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-#elif defined(HB_NO_MT)\n+#else \/* defined(HB_NO_MT) *\/\n@@ -108,1 +108,0 @@\n-\n@@ -110,1 +109,0 @@\n-\n@@ -113,6 +111,0 @@\n-\n-#else\n-\n-#error \"Could not find any system to define atomic_int macros.\"\n-#error \"Check hb-atomic.hh for possible resolutions.\"\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-atomic.hh","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,15 +36,0 @@\n-  hb_bimap_t () { init (); }\n-  ~hb_bimap_t () { fini (); }\n-\n-  void init ()\n-  {\n-    forw_map.init ();\n-    back_map.init ();\n-  }\n-\n-  void fini ()\n-  {\n-    forw_map.fini ();\n-    back_map.fini ();\n-  }\n-\n@@ -57,0 +42,6 @@\n+  void resize (unsigned pop)\n+  {\n+    forw_map.resize (pop);\n+    back_map.resize (pop);\n+  }\n+\n@@ -61,0 +52,1 @@\n+    if (in_error ()) return;\n@@ -63,0 +55,1 @@\n+\n@@ -64,0 +57,2 @@\n+    if (unlikely (in_error ())) return;\n+\n@@ -65,0 +60,1 @@\n+    if (unlikely (in_error ())) forw_map.del (lhs);\n@@ -71,1 +67,2 @@\n-  bool has (hb_codepoint_t lhs, hb_codepoint_t *vp = nullptr) const { return forw_map.has (lhs, vp); }\n+  bool has (hb_codepoint_t lhs) const { return forw_map.has (lhs); }\n+\n@@ -85,1 +82,1 @@\n-  bool is_empty () const { return get_population () == 0; }\n+  bool is_empty () const { return forw_map.is_empty (); }\n@@ -97,8 +94,0 @@\n-  hb_inc_bimap_t () { init (); }\n-\n-  void init ()\n-  {\n-    hb_bimap_t::init ();\n-    next_value = 0;\n-  }\n-\n@@ -163,1 +152,1 @@\n-  unsigned int  next_value;\n+  unsigned int next_value = 0;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bimap.hh","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright  2012,2017  Google, Inc.\n+ * Copyright  2021 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BIT_PAGE_HH\n+#define HB_BIT_PAGE_HH\n+\n+#include \"hb.hh\"\n+\n+struct hb_bit_page_t\n+{\n+  void init0 () { v.clear (); }\n+  void init1 () { v.clear (0xFF); }\n+\n+  constexpr unsigned len () const\n+  { return ARRAY_LENGTH_CONST (v); }\n+\n+  bool is_empty () const\n+  {\n+    for (unsigned i = 0; i < len (); i++)\n+      if (v[i])\n+        return false;\n+    return true;\n+  }\n+  uint32_t hash () const\n+  {\n+    uint32_t h = 0;\n+    for (unsigned i = 0; i < len (); i++)\n+      h = h * 31 + hb_hash (v[i]);\n+    return h;\n+  }\n+\n+  void add (hb_codepoint_t g) { elt (g) |= mask (g); }\n+  void del (hb_codepoint_t g) { elt (g) &= ~mask (g); }\n+  void set (hb_codepoint_t g, bool v) { if (v) add (g); else del (g); }\n+  bool get (hb_codepoint_t g) const { return elt (g) & mask (g); }\n+\n+  void add_range (hb_codepoint_t a, hb_codepoint_t b)\n+  {\n+    elt_t *la = &elt (a);\n+    elt_t *lb = &elt (b);\n+    if (la == lb)\n+      *la |= (mask (b) << 1) - mask(a);\n+    else\n+    {\n+      *la |= ~(mask (a) - 1);\n+      la++;\n+\n+      memset (la, 0xff, (char *) lb - (char *) la);\n+\n+      *lb |= ((mask (b) << 1) - 1);\n+    }\n+  }\n+  void del_range (hb_codepoint_t a, hb_codepoint_t b)\n+  {\n+    elt_t *la = &elt (a);\n+    elt_t *lb = &elt (b);\n+    if (la == lb)\n+      *la &= ~((mask (b) << 1) - mask(a));\n+    else\n+    {\n+      *la &= mask (a) - 1;\n+      la++;\n+\n+      memset (la, 0, (char *) lb - (char *) la);\n+\n+      *lb &= ~((mask (b) << 1) - 1);\n+    }\n+  }\n+  void set_range (hb_codepoint_t a, hb_codepoint_t b, bool v)\n+  { if (v) add_range (a, b); else del_range (a, b); }\n+\n+\n+  \/\/ Writes out page values to the array p. Returns the number of values\n+  \/\/ written. At most size codepoints will be written.\n+  unsigned int write (uint32_t        base,\n+                      unsigned int    start_value,\n+                      hb_codepoint_t *p,\n+                      unsigned int    size) const\n+  {\n+    unsigned int start_v = start_value >> ELT_BITS_LOG_2;\n+    unsigned int start_bit = start_value & ELT_MASK;\n+    unsigned int count = 0;\n+    for (unsigned i = start_v; i < len () && count < size; i++)\n+    {\n+      elt_t bits = v[i];\n+      uint32_t v_base = base | (i << ELT_BITS_LOG_2);\n+      for (unsigned int j = start_bit; j < ELT_BITS && count < size; j++)\n+      {\n+        if ((elt_t(1) << j) & bits) {\n+          *p++ = v_base | j;\n+          count++;\n+        }\n+      }\n+      start_bit = 0;\n+    }\n+    return count;\n+  }\n+\n+  \/\/ Writes out the values NOT in this page to the array p. Returns the\n+  \/\/ number of values written. At most size codepoints will be written.\n+  \/\/ Returns the number of codepoints written. next_value holds the next value\n+  \/\/ that should be written (if not present in this page). This is used to fill\n+  \/\/ any missing value gaps between this page and the previous page, if any.\n+  \/\/ next_value is updated to one more than the last value present in this page.\n+  unsigned int write_inverted (uint32_t        base,\n+                               unsigned int    start_value,\n+                               hb_codepoint_t *p,\n+                               unsigned int    size,\n+                               hb_codepoint_t *next_value) const\n+  {\n+    unsigned int start_v = start_value >> ELT_BITS_LOG_2;\n+    unsigned int start_bit = start_value & ELT_MASK;\n+    unsigned int count = 0;\n+    for (unsigned i = start_v; i < len () && count < size; i++)\n+    {\n+      elt_t bits = v[i];\n+      uint32_t v_offset = i << ELT_BITS_LOG_2;\n+      for (unsigned int j = start_bit; j < ELT_BITS && count < size; j++)\n+      {\n+        if ((elt_t(1) << j) & bits)\n+        {\n+          hb_codepoint_t value = base | v_offset | j;\n+          \/\/ Emit all the missing values from next_value up to value - 1.\n+          for (hb_codepoint_t k = *next_value; k < value && count < size; k++)\n+          {\n+            *p++ = k;\n+            count++;\n+          }\n+          \/\/ Skip over this value;\n+          *next_value = value + 1;\n+        }\n+      }\n+      start_bit = 0;\n+    }\n+    return count;\n+  }\n+\n+  bool is_equal (const hb_bit_page_t &other) const\n+  {\n+    return 0 == hb_memcmp (&v, &other.v, sizeof (v));\n+  }\n+  bool is_subset (const hb_bit_page_t &larger_page) const\n+  {\n+    for (unsigned i = 0; i < len (); i++)\n+      if (~larger_page.v[i] & v[i])\n+        return false;\n+    return true;\n+  }\n+\n+  unsigned int get_population () const\n+  {\n+    unsigned int pop = 0;\n+    for (unsigned int i = 0; i < len (); i++)\n+      pop += hb_popcount (v[i]);\n+    return pop;\n+  }\n+\n+  bool next (hb_codepoint_t *codepoint) const\n+  {\n+    unsigned int m = (*codepoint + 1) & MASK;\n+    if (!m)\n+    {\n+      *codepoint = INVALID;\n+      return false;\n+    }\n+    unsigned int i = m \/ ELT_BITS;\n+    unsigned int j = m & ELT_MASK;\n+\n+    const elt_t vv = v[i] & ~((elt_t (1) << j) - 1);\n+    for (const elt_t *p = &vv; i < len (); p = &v[++i])\n+      if (*p)\n+      {\n+        *codepoint = i * ELT_BITS + elt_get_min (*p);\n+        return true;\n+      }\n+\n+    *codepoint = INVALID;\n+    return false;\n+  }\n+  bool previous (hb_codepoint_t *codepoint) const\n+  {\n+    unsigned int m = (*codepoint - 1) & MASK;\n+    if (m == MASK)\n+    {\n+      *codepoint = INVALID;\n+      return false;\n+    }\n+    unsigned int i = m \/ ELT_BITS;\n+    unsigned int j = m & ELT_MASK;\n+\n+    \/* Fancy mask to avoid shifting by elt_t bitsize, which is undefined. *\/\n+    const elt_t mask = j < 8 * sizeof (elt_t) - 1 ?\n+                       ((elt_t (1) << (j + 1)) - 1) :\n+                       (elt_t) -1;\n+    const elt_t vv = v[i] & mask;\n+    const elt_t *p = &vv;\n+    while (true)\n+    {\n+      if (*p)\n+      {\n+        *codepoint = i * ELT_BITS + elt_get_max (*p);\n+        return true;\n+      }\n+      if ((int) i <= 0) break;\n+      p = &v[--i];\n+    }\n+\n+    *codepoint = INVALID;\n+    return false;\n+  }\n+  hb_codepoint_t get_min () const\n+  {\n+    for (unsigned int i = 0; i < len (); i++)\n+      if (v[i])\n+        return i * ELT_BITS + elt_get_min (v[i]);\n+    return INVALID;\n+  }\n+  hb_codepoint_t get_max () const\n+  {\n+    for (int i = len () - 1; i >= 0; i--)\n+      if (v[i])\n+        return i * ELT_BITS + elt_get_max (v[i]);\n+    return 0;\n+  }\n+\n+  static constexpr hb_codepoint_t INVALID = HB_SET_VALUE_INVALID;\n+\n+  typedef unsigned long long elt_t;\n+  static constexpr unsigned PAGE_BITS = 512;\n+  static_assert ((PAGE_BITS & ((PAGE_BITS) - 1)) == 0, \"\");\n+  static constexpr unsigned PAGE_BITS_LOG_2 = 9;\n+  static_assert (1 << PAGE_BITS_LOG_2 == PAGE_BITS, \"\");\n+  static constexpr unsigned PAGE_BITMASK = PAGE_BITS - 1;\n+\n+  static unsigned int elt_get_min (const elt_t &elt) { return hb_ctz (elt); }\n+  static unsigned int elt_get_max (const elt_t &elt) { return hb_bit_storage (elt) - 1; }\n+\n+  typedef hb_vector_size_t<elt_t, PAGE_BITS \/ 8> vector_t;\n+\n+  static constexpr unsigned ELT_BITS = sizeof (elt_t) * 8;\n+  static constexpr unsigned ELT_BITS_LOG_2 = 6;\n+  static_assert (1 << ELT_BITS_LOG_2 == ELT_BITS, \"\");\n+  static constexpr unsigned ELT_MASK = ELT_BITS - 1;\n+\n+  static constexpr unsigned BITS = sizeof (vector_t) * 8;\n+  static constexpr unsigned MASK = BITS - 1;\n+  static_assert ((unsigned) PAGE_BITS == (unsigned) BITS, \"\");\n+\n+  elt_t &elt (hb_codepoint_t g) { return v[(g & MASK) \/ ELT_BITS]; }\n+  const elt_t& elt (hb_codepoint_t g) const { return v[(g & MASK) \/ ELT_BITS]; }\n+  static constexpr elt_t mask (hb_codepoint_t g) { return elt_t (1) << (g & ELT_MASK); }\n+\n+  vector_t v;\n+};\n+static_assert (hb_bit_page_t::PAGE_BITS == sizeof (hb_bit_page_t) * 8, \"\");\n+\n+\n+#endif \/* HB_BIT_PAGE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-page.hh","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright  2012,2017  Google, Inc.\n+ * Copyright  2021 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BIT_SET_INVERTIBLE_HH\n+#define HB_BIT_SET_INVERTIBLE_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-bit-set.hh\"\n+\n+\n+struct hb_bit_set_invertible_t\n+{\n+  hb_bit_set_t s;\n+  bool inverted = false;\n+\n+  hb_bit_set_invertible_t () = default;\n+  hb_bit_set_invertible_t (const hb_bit_set_invertible_t& o) = default;\n+  hb_bit_set_invertible_t (hb_bit_set_invertible_t&& other) : hb_bit_set_invertible_t () { hb_swap (*this, other); }\n+  hb_bit_set_invertible_t& operator= (const hb_bit_set_invertible_t& o) = default;\n+  hb_bit_set_invertible_t& operator= (hb_bit_set_invertible_t&& other) { hb_swap (*this, other); return *this; }\n+  friend void swap (hb_bit_set_invertible_t &a, hb_bit_set_invertible_t &b)\n+  {\n+    if (likely (!a.s.successful || !b.s.successful))\n+      return;\n+    hb_swap (a.inverted, b.inverted);\n+    hb_swap (a.s, b.s);\n+  }\n+\n+  void init () { s.init (); inverted = false; }\n+  void fini () { s.fini (); }\n+  void err () { s.err (); }\n+  bool in_error () const { return s.in_error (); }\n+  explicit operator bool () const { return !is_empty (); }\n+\n+  void alloc (unsigned sz) { s.alloc (sz); }\n+  void reset ()\n+  {\n+    s.reset ();\n+    inverted = false;\n+  }\n+  void clear ()\n+  {\n+    s.clear ();\n+    if (likely (s.successful))\n+      inverted = false;\n+  }\n+  void invert ()\n+  {\n+    if (likely (s.successful))\n+      inverted = !inverted;\n+  }\n+\n+  bool is_empty () const\n+  {\n+    hb_codepoint_t v = INVALID;\n+    next (&v);\n+    return v == INVALID;\n+  }\n+  uint32_t hash () const { return s.hash () ^ (uint32_t) inverted; }\n+\n+  hb_codepoint_t get_min () const\n+  {\n+    hb_codepoint_t v = INVALID;\n+    next (&v);\n+    return v;\n+  }\n+  hb_codepoint_t get_max () const\n+  {\n+    hb_codepoint_t v = INVALID;\n+    previous (&v);\n+    return v;\n+  }\n+  unsigned int get_population () const\n+  { return inverted ? INVALID - s.get_population () : s.get_population (); }\n+\n+\n+  void add (hb_codepoint_t g) { unlikely (inverted) ? s.del (g) : s.add (g); }\n+  bool add_range (hb_codepoint_t a, hb_codepoint_t b)\n+  { return unlikely (inverted) ? ((void) s.del_range (a, b), true) : s.add_range (a, b); }\n+\n+  template <typename T>\n+  void add_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  { inverted ? s.del_array (array, count, stride) : s.add_array (array, count, stride); }\n+  template <typename T>\n+  void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }\n+\n+  \/* Might return false if array looks unsorted.\n+   * Used for faster rejection of corrupt data. *\/\n+  template <typename T>\n+  bool add_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  { return inverted ? s.del_sorted_array (array, count, stride) : s.add_sorted_array (array, count, stride); }\n+  template <typename T>\n+  bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }\n+\n+  void del (hb_codepoint_t g) { unlikely (inverted) ? s.add (g) : s.del (g); }\n+  void del_range (hb_codepoint_t a, hb_codepoint_t b)\n+  { unlikely (inverted) ? (void) s.add_range (a, b) : s.del_range (a, b); }\n+\n+  bool get (hb_codepoint_t g) const { return s.get (g) ^ inverted; }\n+\n+  \/* Has interface. *\/\n+  static constexpr bool SENTINEL = false;\n+  typedef bool value_t;\n+  value_t operator [] (hb_codepoint_t k) const { return get (k); }\n+  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }\n+  \/* Predicate. *\/\n+  bool operator () (hb_codepoint_t k) const { return has (k); }\n+\n+  \/* Sink interface. *\/\n+  hb_bit_set_invertible_t& operator << (hb_codepoint_t v)\n+  { add (v); return *this; }\n+  hb_bit_set_invertible_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)\n+  { add_range (range.first, range.second); return *this; }\n+\n+  bool intersects (hb_codepoint_t first, hb_codepoint_t last) const\n+  {\n+    hb_codepoint_t c = first - 1;\n+    return next (&c) && c <= last;\n+  }\n+\n+  void set (const hb_bit_set_invertible_t &other)\n+  {\n+    s.set (other.s);\n+    if (likely (s.successful))\n+      inverted = other.inverted;\n+  }\n+\n+  bool is_equal (const hb_bit_set_invertible_t &other) const\n+  {\n+    if (likely (inverted == other.inverted))\n+      return s.is_equal (other.s);\n+    else\n+    {\n+      \/* TODO Add iter_ranges() and use here. *\/\n+      auto it1 = iter ();\n+      auto it2 = other.iter ();\n+      return hb_all (+ hb_zip (it1, it2)\n+                     | hb_map ([](hb_pair_t<hb_codepoint_t, hb_codepoint_t> _) { return _.first == _.second; }));\n+    }\n+  }\n+\n+  bool is_subset (const hb_bit_set_invertible_t &larger_set) const\n+  {\n+    if (unlikely (inverted != larger_set.inverted))\n+      return hb_all (hb_iter (s) | hb_map (larger_set.s));\n+    else\n+      return unlikely (inverted) ? larger_set.s.is_subset (s) : s.is_subset (larger_set.s);\n+  }\n+\n+  protected:\n+  template <typename Op>\n+  void process (const Op& op, const hb_bit_set_invertible_t &other)\n+  { s.process (op, other.s); }\n+  public:\n+  void union_ (const hb_bit_set_invertible_t &other)\n+  {\n+    if (likely (inverted == other.inverted))\n+    {\n+      if (unlikely (inverted))\n+        process (hb_bitwise_and, other);\n+      else\n+        process (hb_bitwise_or, other); \/* Main branch. *\/\n+    }\n+    else\n+    {\n+      if (unlikely (inverted))\n+        process (hb_bitwise_gt, other);\n+      else\n+        process (hb_bitwise_lt, other);\n+    }\n+    if (likely (s.successful))\n+      inverted = inverted || other.inverted;\n+  }\n+  void intersect (const hb_bit_set_invertible_t &other)\n+  {\n+    if (likely (inverted == other.inverted))\n+    {\n+      if (unlikely (inverted))\n+        process (hb_bitwise_or, other);\n+      else\n+        process (hb_bitwise_and, other); \/* Main branch. *\/\n+    }\n+    else\n+    {\n+      if (unlikely (inverted))\n+        process (hb_bitwise_lt, other);\n+      else\n+        process (hb_bitwise_gt, other);\n+    }\n+    if (likely (s.successful))\n+      inverted = inverted && other.inverted;\n+  }\n+  void subtract (const hb_bit_set_invertible_t &other)\n+  {\n+    if (likely (inverted == other.inverted))\n+    {\n+      if (unlikely (inverted))\n+        process (hb_bitwise_lt, other);\n+      else\n+        process (hb_bitwise_gt, other); \/* Main branch. *\/\n+    }\n+    else\n+    {\n+      if (unlikely (inverted))\n+        process (hb_bitwise_or, other);\n+      else\n+        process (hb_bitwise_and, other);\n+    }\n+    if (likely (s.successful))\n+      inverted = inverted && !other.inverted;\n+  }\n+  void symmetric_difference (const hb_bit_set_invertible_t &other)\n+  {\n+    process (hb_bitwise_xor, other);\n+    if (likely (s.successful))\n+      inverted = inverted ^ other.inverted;\n+  }\n+\n+  bool next (hb_codepoint_t *codepoint) const\n+  {\n+    if (likely (!inverted))\n+      return s.next (codepoint);\n+\n+    auto old = *codepoint;\n+    if (unlikely (old + 1 == INVALID))\n+    {\n+      *codepoint = INVALID;\n+      return false;\n+    }\n+\n+    auto v = old;\n+    s.next (&v);\n+    if (old + 1 < v)\n+    {\n+      *codepoint = old + 1;\n+      return true;\n+    }\n+\n+    v = old;\n+    s.next_range (&old, &v);\n+\n+    *codepoint = v + 1;\n+    return *codepoint != INVALID;\n+  }\n+  bool previous (hb_codepoint_t *codepoint) const\n+  {\n+    if (likely (!inverted))\n+      return s.previous (codepoint);\n+\n+    auto old = *codepoint;\n+    if (unlikely (old - 1 == INVALID))\n+    {\n+      *codepoint = INVALID;\n+      return false;\n+    }\n+\n+    auto v = old;\n+    s.previous (&v);\n+\n+    if (old - 1 > v || v == INVALID)\n+    {\n+      *codepoint = old - 1;\n+      return true;\n+    }\n+\n+    v = old;\n+    s.previous_range (&v, &old);\n+\n+    *codepoint = v - 1;\n+    return *codepoint != INVALID;\n+  }\n+  bool next_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n+  {\n+    if (likely (!inverted))\n+      return s.next_range (first, last);\n+\n+    if (!next (last))\n+    {\n+      *last = *first = INVALID;\n+      return false;\n+    }\n+\n+    *first = *last;\n+    s.next (last);\n+    --*last;\n+    return true;\n+  }\n+  bool previous_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n+  {\n+    if (likely (!inverted))\n+      return s.previous_range (first, last);\n+\n+    if (!previous (first))\n+    {\n+      *last = *first = INVALID;\n+      return false;\n+    }\n+\n+    *last = *first;\n+    s.previous (first);\n+    ++*first;\n+    return true;\n+  }\n+\n+  unsigned int next_many (hb_codepoint_t  codepoint,\n+                          hb_codepoint_t *out,\n+                          unsigned int    size) const\n+  {\n+    return inverted ? s.next_many_inverted (codepoint, out, size)\n+                    : s.next_many (codepoint, out, size);\n+  }\n+\n+  static constexpr hb_codepoint_t INVALID = hb_bit_set_t::INVALID;\n+\n+  \/*\n+   * Iterator implementation.\n+   *\/\n+  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>\n+  {\n+    static constexpr bool is_sorted_iterator = true;\n+    iter_t (const hb_bit_set_invertible_t &s_ = Null (hb_bit_set_invertible_t),\n+            bool init = true) : s (&s_), v (INVALID), l(0)\n+    {\n+      if (init)\n+      {\n+        l = s->get_population () + 1;\n+        __next__ ();\n+      }\n+    }\n+\n+    typedef hb_codepoint_t __item_t__;\n+    hb_codepoint_t __item__ () const { return v; }\n+    bool __more__ () const { return v != INVALID; }\n+    void __next__ () { s->next (&v); if (l) l--; }\n+    void __prev__ () { s->previous (&v); }\n+    unsigned __len__ () const { return l; }\n+    iter_t end () const { return iter_t (*s, false); }\n+    bool operator != (const iter_t& o) const\n+    { return s != o.s || v != o.v; }\n+\n+    protected:\n+    const hb_bit_set_invertible_t *s;\n+    hb_codepoint_t v;\n+    unsigned l;\n+  };\n+  iter_t iter () const { return iter_t (*this); }\n+  operator iter_t () const { return iter (); }\n+};\n+\n+\n+#endif \/* HB_BIT_SET_INVERTIBLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-set-invertible.hh","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,953 @@\n+\/*\n+ * Copyright  2012,2017  Google, Inc.\n+ * Copyright  2021 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BIT_SET_HH\n+#define HB_BIT_SET_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-bit-page.hh\"\n+#include \"hb-machinery.hh\"\n+\n+\n+struct hb_bit_set_t\n+{\n+  hb_bit_set_t () = default;\n+  ~hb_bit_set_t () = default;\n+\n+  hb_bit_set_t (const hb_bit_set_t& other) : hb_bit_set_t () { set (other); }\n+  hb_bit_set_t ( hb_bit_set_t&& other) : hb_bit_set_t () { hb_swap (*this, other); }\n+  hb_bit_set_t& operator= (const hb_bit_set_t& other) { set (other); return *this; }\n+  hb_bit_set_t& operator= (hb_bit_set_t&& other) { hb_swap (*this, other); return *this; }\n+  friend void swap (hb_bit_set_t &a, hb_bit_set_t &b)\n+  {\n+    if (likely (!a.successful || !b.successful))\n+      return;\n+    hb_swap (a.population, b.population);\n+    hb_swap (a.last_page_lookup, b.last_page_lookup);\n+    hb_swap (a.page_map, b.page_map);\n+    hb_swap (a.pages, b.pages);\n+  }\n+\n+  void init ()\n+  {\n+    successful = true;\n+    population = 0;\n+    last_page_lookup.set_relaxed (0);\n+    page_map.init ();\n+    pages.init ();\n+  }\n+  void fini ()\n+  {\n+    page_map.fini ();\n+    pages.fini ();\n+  }\n+\n+  using page_t = hb_bit_page_t;\n+  struct page_map_t\n+  {\n+    int cmp (const page_map_t &o) const { return cmp (o.major); }\n+    int cmp (uint32_t o_major) const { return (int) o_major - (int) major; }\n+\n+    uint32_t major;\n+    uint32_t index;\n+  };\n+\n+  bool successful = true; \/* Allocations successful *\/\n+  mutable unsigned int population = 0;\n+  mutable hb_atomic_int_t last_page_lookup = 0;\n+  hb_sorted_vector_t<page_map_t> page_map;\n+  hb_vector_t<page_t> pages;\n+\n+  void err () { if (successful) successful = false; } \/* TODO Remove *\/\n+  bool in_error () const { return !successful; }\n+\n+  bool resize (unsigned int count)\n+  {\n+    if (unlikely (!successful)) return false;\n+    if (unlikely (!pages.resize (count) || !page_map.resize (count)))\n+    {\n+      pages.resize (page_map.length);\n+      successful = false;\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  void alloc (unsigned sz)\n+  {\n+    sz >>= (page_t::PAGE_BITS_LOG_2 - 1);\n+    pages.alloc (sz);\n+    page_map.alloc (sz);\n+  }\n+\n+  void reset ()\n+  {\n+    successful = true;\n+    clear ();\n+  }\n+\n+  void clear ()\n+  {\n+    resize (0);\n+    if (likely (successful))\n+      population = 0;\n+  }\n+  bool is_empty () const\n+  {\n+    unsigned int count = pages.length;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!pages[i].is_empty ())\n+        return false;\n+    return true;\n+  }\n+  explicit operator bool () const { return !is_empty (); }\n+\n+  uint32_t hash () const\n+  {\n+    uint32_t h = 0;\n+    for (auto &map : page_map)\n+      h = h * 31 + hb_hash (map.major) + hb_hash (pages[map.index]);\n+    return h;\n+  }\n+\n+  private:\n+  void dirty () { population = UINT_MAX; }\n+  public:\n+\n+  void add (hb_codepoint_t g)\n+  {\n+    if (unlikely (!successful)) return;\n+    if (unlikely (g == INVALID)) return;\n+    dirty ();\n+    page_t *page = page_for (g, true); if (unlikely (!page)) return;\n+    page->add (g);\n+  }\n+  bool add_range (hb_codepoint_t a, hb_codepoint_t b)\n+  {\n+    if (unlikely (!successful)) return true; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/657 *\/\n+    if (unlikely (a > b || a == INVALID || b == INVALID)) return false;\n+    dirty ();\n+    unsigned int ma = get_major (a);\n+    unsigned int mb = get_major (b);\n+    if (ma == mb)\n+    {\n+      page_t *page = page_for (a, true); if (unlikely (!page)) return false;\n+      page->add_range (a, b);\n+    }\n+    else\n+    {\n+      page_t *page = page_for (a, true); if (unlikely (!page)) return false;\n+      page->add_range (a, major_start (ma + 1) - 1);\n+\n+      for (unsigned int m = ma + 1; m < mb; m++)\n+      {\n+        page = page_for (major_start (m), true); if (unlikely (!page)) return false;\n+        page->init1 ();\n+      }\n+\n+      page = page_for (b, true); if (unlikely (!page)) return false;\n+      page->add_range (major_start (mb), b);\n+    }\n+    return true;\n+  }\n+\n+  template <typename T>\n+  void set_array (bool v, const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  {\n+    if (unlikely (!successful)) return;\n+    if (!count) return;\n+    dirty ();\n+    hb_codepoint_t g = *array;\n+    while (count)\n+    {\n+      unsigned int m = get_major (g);\n+      page_t *page = page_for (g, v); if (unlikely (v && !page)) return;\n+      unsigned int start = major_start (m);\n+      unsigned int end = major_start (m + 1);\n+      do\n+      {\n+        if (v || page) \/* The v check is to optimize out the page check if v is true. *\/\n+          page->set (g, v);\n+\n+        array = &StructAtOffsetUnaligned<T> (array, stride);\n+        count--;\n+      }\n+      while (count && (g = *array, start <= g && g < end));\n+    }\n+  }\n+\n+  template <typename T>\n+  void add_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  { set_array (true, array, count, stride); }\n+  template <typename T>\n+  void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }\n+\n+  template <typename T>\n+  void del_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  { set_array (false, array, count, stride); }\n+  template <typename T>\n+  void del_array (const hb_array_t<const T>& arr) { del_array (&arr, arr.len ()); }\n+\n+  \/* Might return false if array looks unsorted.\n+   * Used for faster rejection of corrupt data. *\/\n+  template <typename T>\n+  bool set_sorted_array (bool v, const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  {\n+    if (unlikely (!successful)) return true; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/657 *\/\n+    if (unlikely (!count)) return true;\n+    dirty ();\n+    hb_codepoint_t g = *array;\n+    hb_codepoint_t last_g = g;\n+    while (count)\n+    {\n+      unsigned int m = get_major (g);\n+      page_t *page = page_for (g, v); if (unlikely (v && !page)) return false;\n+      unsigned int end = major_start (m + 1);\n+      do\n+      {\n+        \/* If we try harder we can change the following comparison to <=;\n+         * Not sure if it's worth it. *\/\n+        if (g < last_g) return false;\n+        last_g = g;\n+\n+        if (v || page) \/* The v check is to optimize out the page check if v is true. *\/\n+          page->add (g);\n+\n+        array = &StructAtOffsetUnaligned<T> (array, stride);\n+        count--;\n+      }\n+      while (count && (g = *array, g < end));\n+    }\n+    return true;\n+  }\n+\n+  template <typename T>\n+  bool add_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  { return set_sorted_array (true, array, count, stride); }\n+  template <typename T>\n+  bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }\n+\n+  template <typename T>\n+  bool del_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  { return set_sorted_array (false, array, count, stride); }\n+  template <typename T>\n+  bool del_sorted_array (const hb_sorted_array_t<const T>& arr) { return del_sorted_array (&arr, arr.len ()); }\n+\n+  void del (hb_codepoint_t g)\n+  {\n+    if (unlikely (!successful)) return;\n+    page_t *page = page_for (g);\n+    if (!page)\n+      return;\n+    dirty ();\n+    page->del (g);\n+  }\n+\n+  private:\n+  void del_pages (int ds, int de)\n+  {\n+    if (ds <= de)\n+    {\n+      \/\/ Pre-allocate the workspace that compact() will need so we can bail on allocation failure\n+      \/\/ before attempting to rewrite the page map.\n+      hb_vector_t<unsigned> compact_workspace;\n+      if (unlikely (!allocate_compact_workspace (compact_workspace))) return;\n+\n+      unsigned int write_index = 0;\n+      for (unsigned int i = 0; i < page_map.length; i++)\n+      {\n+        int m = (int) page_map[i].major;\n+        if (m < ds || de < m)\n+          page_map[write_index++] = page_map[i];\n+      }\n+      compact (compact_workspace, write_index);\n+      resize (write_index);\n+    }\n+  }\n+\n+\n+  public:\n+  void del_range (hb_codepoint_t a, hb_codepoint_t b)\n+  {\n+    if (unlikely (!successful)) return;\n+    if (unlikely (a > b || a == INVALID)) return;\n+    dirty ();\n+    unsigned int ma = get_major (a);\n+    unsigned int mb = get_major (b);\n+    \/* Delete pages from ds through de if ds <= de. *\/\n+    int ds = (a == major_start (ma))? (int) ma: (int) (ma + 1);\n+    int de = (b + 1 == major_start (mb + 1))? (int) mb: ((int) mb - 1);\n+    if (ds > de || (int) ma < ds)\n+    {\n+      page_t *page = page_for (a);\n+      if (page)\n+      {\n+        if (ma == mb)\n+          page->del_range (a, b);\n+        else\n+          page->del_range (a, major_start (ma + 1) - 1);\n+      }\n+    }\n+    if (de < (int) mb && ma != mb)\n+    {\n+      page_t *page = page_for (b);\n+      if (page)\n+        page->del_range (major_start (mb), b);\n+    }\n+    del_pages (ds, de);\n+  }\n+\n+  bool get (hb_codepoint_t g) const\n+  {\n+    const page_t *page = page_for (g);\n+    if (!page)\n+      return false;\n+    return page->get (g);\n+  }\n+\n+  \/* Has interface. *\/\n+  static constexpr bool SENTINEL = false;\n+  typedef bool value_t;\n+  value_t operator [] (hb_codepoint_t k) const { return get (k); }\n+  bool has (hb_codepoint_t k) const { return (*this)[k] != SENTINEL; }\n+  \/* Predicate. *\/\n+  bool operator () (hb_codepoint_t k) const { return has (k); }\n+\n+  \/* Sink interface. *\/\n+  hb_bit_set_t& operator << (hb_codepoint_t v)\n+  { add (v); return *this; }\n+  hb_bit_set_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)\n+  { add_range (range.first, range.second); return *this; }\n+\n+  bool intersects (hb_codepoint_t first, hb_codepoint_t last) const\n+  {\n+    hb_codepoint_t c = first - 1;\n+    return next (&c) && c <= last;\n+  }\n+  void set (const hb_bit_set_t &other)\n+  {\n+    if (unlikely (!successful)) return;\n+    unsigned int count = other.pages.length;\n+    if (unlikely (!resize (count)))\n+      return;\n+    population = other.population;\n+\n+    page_map = other.page_map;\n+    pages = other.pages;\n+  }\n+\n+  bool is_equal (const hb_bit_set_t &other) const\n+  {\n+    if (has_population () && other.has_population () &&\n+        population != other.population)\n+      return false;\n+\n+    unsigned int na = pages.length;\n+    unsigned int nb = other.pages.length;\n+\n+    unsigned int a = 0, b = 0;\n+    for (; a < na && b < nb; )\n+    {\n+      if (page_at (a).is_empty ()) { a++; continue; }\n+      if (other.page_at (b).is_empty ()) { b++; continue; }\n+      if (page_map[a].major != other.page_map[b].major ||\n+          !page_at (a).is_equal (other.page_at (b)))\n+        return false;\n+      a++;\n+      b++;\n+    }\n+    for (; a < na; a++)\n+      if (!page_at (a).is_empty ()) { return false; }\n+    for (; b < nb; b++)\n+      if (!other.page_at (b).is_empty ()) { return false; }\n+\n+    return true;\n+  }\n+\n+  bool is_subset (const hb_bit_set_t &larger_set) const\n+  {\n+    if (has_population () && larger_set.has_population () &&\n+        population != larger_set.population)\n+      return false;\n+\n+    uint32_t spi = 0;\n+    for (uint32_t lpi = 0; spi < page_map.length && lpi < larger_set.page_map.length; lpi++)\n+    {\n+      uint32_t spm = page_map[spi].major;\n+      uint32_t lpm = larger_set.page_map[lpi].major;\n+      auto sp = page_at (spi);\n+      auto lp = larger_set.page_at (lpi);\n+\n+      if (spm < lpm && !sp.is_empty ())\n+        return false;\n+\n+      if (lpm < spm)\n+        continue;\n+\n+      if (!sp.is_subset (lp))\n+        return false;\n+\n+      spi++;\n+    }\n+\n+    while (spi < page_map.length)\n+      if (!page_at (spi++).is_empty ())\n+        return false;\n+\n+    return true;\n+  }\n+\n+  private:\n+  bool allocate_compact_workspace (hb_vector_t<unsigned>& workspace)\n+  {\n+    if (unlikely (!workspace.resize (pages.length)))\n+    {\n+      successful = false;\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  \/*\n+   * workspace should be a pre-sized vector allocated to hold at exactly pages.length\n+   * elements.\n+   *\/\n+  void compact (hb_vector_t<unsigned>& workspace,\n+                unsigned int length)\n+  {\n+    assert(workspace.length == pages.length);\n+    hb_vector_t<unsigned>& old_index_to_page_map_index = workspace;\n+\n+    hb_fill (old_index_to_page_map_index.writer(), 0xFFFFFFFF);\n+    for (unsigned i = 0; i < length; i++)\n+      old_index_to_page_map_index[page_map[i].index] =  i;\n+\n+    compact_pages (old_index_to_page_map_index);\n+  }\n+  void compact_pages (const hb_vector_t<unsigned>& old_index_to_page_map_index)\n+  {\n+    unsigned int write_index = 0;\n+    for (unsigned int i = 0; i < pages.length; i++)\n+    {\n+      if (old_index_to_page_map_index[i] == 0xFFFFFFFF) continue;\n+\n+      if (write_index < i)\n+        pages[write_index] = pages[i];\n+\n+      page_map[old_index_to_page_map_index[i]].index = write_index;\n+      write_index++;\n+    }\n+  }\n+  public:\n+\n+  template <typename Op>\n+  void process (const Op& op, const hb_bit_set_t &other)\n+  {\n+    const bool passthru_left = op (1, 0);\n+    const bool passthru_right = op (0, 1);\n+\n+    if (unlikely (!successful)) return;\n+\n+    dirty ();\n+\n+    unsigned int na = pages.length;\n+    unsigned int nb = other.pages.length;\n+    unsigned int next_page = na;\n+\n+    unsigned int count = 0, newCount = 0;\n+    unsigned int a = 0, b = 0;\n+    unsigned int write_index = 0;\n+\n+    \/\/ Pre-allocate the workspace that compact() will need so we can bail on allocation failure\n+    \/\/ before attempting to rewrite the page map.\n+    hb_vector_t<unsigned> compact_workspace;\n+    if (!passthru_left && unlikely (!allocate_compact_workspace (compact_workspace))) return;\n+\n+    for (; a < na && b < nb; )\n+    {\n+      if (page_map[a].major == other.page_map[b].major)\n+      {\n+        if (!passthru_left)\n+        {\n+          \/\/ Move page_map entries that we're keeping from the left side set\n+          \/\/ to the front of the page_map vector. This isn't necessary if\n+          \/\/ passthru_left is set since no left side pages will be removed\n+          \/\/ in that case.\n+          if (write_index < a)\n+            page_map[write_index] = page_map[a];\n+          write_index++;\n+        }\n+\n+        count++;\n+        a++;\n+        b++;\n+      }\n+      else if (page_map[a].major < other.page_map[b].major)\n+      {\n+        if (passthru_left)\n+          count++;\n+        a++;\n+      }\n+      else\n+      {\n+        if (passthru_right)\n+          count++;\n+        b++;\n+      }\n+    }\n+    if (passthru_left)\n+      count += na - a;\n+    if (passthru_right)\n+      count += nb - b;\n+\n+    if (!passthru_left)\n+    {\n+      na  = write_index;\n+      next_page = write_index;\n+      compact (compact_workspace, write_index);\n+    }\n+\n+    if (unlikely (!resize (count)))\n+      return;\n+\n+    newCount = count;\n+\n+    \/* Process in-place backward. *\/\n+    a = na;\n+    b = nb;\n+    for (; a && b; )\n+    {\n+      if (page_map[a - 1].major == other.page_map[b - 1].major)\n+      {\n+        a--;\n+        b--;\n+        count--;\n+        page_map[count] = page_map[a];\n+        page_at (count).v = op (page_at (a).v, other.page_at (b).v);\n+      }\n+      else if (page_map[a - 1].major > other.page_map[b - 1].major)\n+      {\n+        a--;\n+        if (passthru_left)\n+        {\n+          count--;\n+          page_map[count] = page_map[a];\n+        }\n+      }\n+      else\n+      {\n+        b--;\n+        if (passthru_right)\n+        {\n+          count--;\n+          page_map[count].major = other.page_map[b].major;\n+          page_map[count].index = next_page++;\n+          page_at (count).v = other.page_at (b).v;\n+        }\n+      }\n+    }\n+    if (passthru_left)\n+      while (a)\n+      {\n+        a--;\n+        count--;\n+        page_map[count] = page_map [a];\n+      }\n+    if (passthru_right)\n+      while (b)\n+      {\n+        b--;\n+        count--;\n+        page_map[count].major = other.page_map[b].major;\n+        page_map[count].index = next_page++;\n+        page_at (count).v = other.page_at (b).v;\n+      }\n+    assert (!count);\n+    resize (newCount);\n+  }\n+\n+  void union_ (const hb_bit_set_t &other) { process (hb_bitwise_or, other); }\n+  void intersect (const hb_bit_set_t &other) { process (hb_bitwise_and, other); }\n+  void subtract (const hb_bit_set_t &other) { process (hb_bitwise_gt, other); }\n+  void symmetric_difference (const hb_bit_set_t &other) { process (hb_bitwise_xor, other); }\n+\n+  bool next (hb_codepoint_t *codepoint) const\n+  {\n+    \/\/ TODO: this should be merged with prev() as both implementations\n+    \/\/       are very similar.\n+    if (unlikely (*codepoint == INVALID)) {\n+      *codepoint = get_min ();\n+      return *codepoint != INVALID;\n+    }\n+\n+    const auto* page_map_array = page_map.arrayZ;\n+    unsigned int major = get_major (*codepoint);\n+    unsigned int i = last_page_lookup.get_relaxed ();\n+\n+    if (unlikely (i >= page_map.length || page_map_array[i].major != major))\n+    {\n+      page_map.bfind (major, &i, HB_NOT_FOUND_STORE_CLOSEST);\n+      if (i >= page_map.length) {\n+        *codepoint = INVALID;\n+        return false;\n+      }\n+    }\n+\n+    const auto* pages_array = pages.arrayZ;\n+    const page_map_t &current = page_map_array[i];\n+    if (likely (current.major == major))\n+    {\n+      if (pages_array[current.index].next (codepoint))\n+      {\n+        *codepoint += current.major * page_t::PAGE_BITS;\n+        last_page_lookup.set_relaxed (i);\n+        return true;\n+      }\n+      i++;\n+    }\n+\n+    for (; i < page_map.length; i++)\n+    {\n+      const page_map_t &current = page_map.arrayZ[i];\n+      hb_codepoint_t m = pages_array[current.index].get_min ();\n+      if (m != INVALID)\n+      {\n+        *codepoint = current.major * page_t::PAGE_BITS + m;\n+        last_page_lookup.set_relaxed (i);\n+        return true;\n+      }\n+    }\n+    last_page_lookup.set_relaxed (0);\n+    *codepoint = INVALID;\n+    return false;\n+  }\n+  bool previous (hb_codepoint_t *codepoint) const\n+  {\n+    if (unlikely (*codepoint == INVALID)) {\n+      *codepoint = get_max ();\n+      return *codepoint != INVALID;\n+    }\n+\n+    page_map_t map = {get_major (*codepoint), 0};\n+    unsigned int i;\n+    page_map.bfind (map, &i, HB_NOT_FOUND_STORE_CLOSEST);\n+    if (i < page_map.length && page_map[i].major == map.major)\n+    {\n+      if (pages[page_map[i].index].previous (codepoint))\n+      {\n+        *codepoint += page_map[i].major * page_t::PAGE_BITS;\n+        return true;\n+      }\n+    }\n+    i--;\n+    for (; (int) i >= 0; i--)\n+    {\n+      hb_codepoint_t m = pages[page_map[i].index].get_max ();\n+      if (m != INVALID)\n+      {\n+        *codepoint = page_map[i].major * page_t::PAGE_BITS + m;\n+        return true;\n+      }\n+    }\n+    *codepoint = INVALID;\n+    return false;\n+  }\n+  bool next_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n+  {\n+    hb_codepoint_t i;\n+\n+    i = *last;\n+    if (!next (&i))\n+    {\n+      *last = *first = INVALID;\n+      return false;\n+    }\n+\n+    \/* TODO Speed up. *\/\n+    *last = *first = i;\n+    while (next (&i) && i == *last + 1)\n+      (*last)++;\n+\n+    return true;\n+  }\n+  bool previous_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n+  {\n+    hb_codepoint_t i;\n+\n+    i = *first;\n+    if (!previous (&i))\n+    {\n+      *last = *first = INVALID;\n+      return false;\n+    }\n+\n+    \/* TODO Speed up. *\/\n+    *last = *first = i;\n+    while (previous (&i) && i == *first - 1)\n+      (*first)--;\n+\n+    return true;\n+  }\n+\n+  unsigned int next_many (hb_codepoint_t  codepoint,\n+                          hb_codepoint_t *out,\n+                          unsigned int    size) const\n+  {\n+    \/\/ By default, start at the first bit of the first page of values.\n+    unsigned int start_page = 0;\n+    unsigned int start_page_value = 0;\n+    if (unlikely (codepoint != INVALID))\n+    {\n+      const auto* page_map_array = page_map.arrayZ;\n+      unsigned int major = get_major (codepoint);\n+      unsigned int i = last_page_lookup.get_relaxed ();\n+      if (unlikely (i >= page_map.length || page_map_array[i].major != major))\n+      {\n+        page_map.bfind (major, &i, HB_NOT_FOUND_STORE_CLOSEST);\n+        if (i >= page_map.length)\n+          return 0;  \/\/ codepoint is greater than our max element.\n+      }\n+      start_page = i;\n+      start_page_value = page_remainder (codepoint + 1);\n+      if (unlikely (start_page_value == 0))\n+      {\n+        \/\/ The export-after value was last in the page. Start on next page.\n+        start_page++;\n+        start_page_value = 0;\n+      }\n+    }\n+\n+    unsigned int initial_size = size;\n+    for (unsigned int i = start_page; i < page_map.length && size; i++)\n+    {\n+      uint32_t base = major_start (page_map[i].major);\n+      unsigned int n = pages[page_map[i].index].write (base, start_page_value, out, size);\n+      out += n;\n+      size -= n;\n+      start_page_value = 0;\n+    }\n+    return initial_size - size;\n+  }\n+\n+  unsigned int next_many_inverted (hb_codepoint_t  codepoint,\n+                                   hb_codepoint_t *out,\n+                                   unsigned int    size) const\n+  {\n+    unsigned int initial_size = size;\n+    \/\/ By default, start at the first bit of the first page of values.\n+    unsigned int start_page = 0;\n+    unsigned int start_page_value = 0;\n+    if (unlikely (codepoint != INVALID))\n+    {\n+      const auto* page_map_array = page_map.arrayZ;\n+      unsigned int major = get_major (codepoint);\n+      unsigned int i = last_page_lookup.get_relaxed ();\n+      if (unlikely (i >= page_map.length || page_map_array[i].major != major))\n+      {\n+        page_map.bfind(major, &i, HB_NOT_FOUND_STORE_CLOSEST);\n+        if (unlikely (i >= page_map.length))\n+        {\n+          \/\/ codepoint is greater than our max element.\n+          while (++codepoint != INVALID && size)\n+          {\n+            *out++ = codepoint;\n+            size--;\n+          }\n+          return initial_size - size;\n+        }\n+      }\n+      start_page = i;\n+      start_page_value = page_remainder (codepoint + 1);\n+      if (unlikely (start_page_value == 0))\n+      {\n+        \/\/ The export-after value was last in the page. Start on next page.\n+        start_page++;\n+        start_page_value = 0;\n+      }\n+    }\n+\n+    hb_codepoint_t next_value = codepoint + 1;\n+    for (unsigned int i=start_page; i<page_map.length && size; i++)\n+    {\n+      uint32_t base = major_start (page_map[i].major);\n+      unsigned int n = pages[page_map[i].index].write_inverted (base, start_page_value, out, size, &next_value);\n+      out += n;\n+      size -= n;\n+      start_page_value = 0;\n+    }\n+    while (next_value < HB_SET_VALUE_INVALID && size) {\n+      *out++ = next_value++;\n+      size--;\n+    }\n+    return initial_size - size;\n+  }\n+\n+  bool has_population () const { return population != UINT_MAX; }\n+  unsigned int get_population () const\n+  {\n+    if (has_population ())\n+      return population;\n+\n+    unsigned int pop = 0;\n+    unsigned int count = pages.length;\n+    for (unsigned int i = 0; i < count; i++)\n+      pop += pages[i].get_population ();\n+\n+    population = pop;\n+    return pop;\n+  }\n+  hb_codepoint_t get_min () const\n+  {\n+    unsigned count = pages.length;\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      const auto& map = page_map[i];\n+      const auto& page = pages[map.index];\n+\n+      if (!page.is_empty ())\n+        return map.major * page_t::PAGE_BITS + page.get_min ();\n+    }\n+    return INVALID;\n+  }\n+  hb_codepoint_t get_max () const\n+  {\n+    unsigned count = pages.length;\n+    for (signed i = count - 1; i >= 0; i--)\n+    {\n+      const auto& map = page_map[(unsigned) i];\n+      const auto& page = pages[map.index];\n+\n+      if (!page.is_empty ())\n+        return map.major * page_t::PAGE_BITS + page.get_max ();\n+    }\n+    return INVALID;\n+  }\n+\n+  static constexpr hb_codepoint_t INVALID = page_t::INVALID;\n+\n+  \/*\n+   * Iterator implementation.\n+   *\/\n+  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>\n+  {\n+    static constexpr bool is_sorted_iterator = true;\n+    iter_t (const hb_bit_set_t &s_ = Null (hb_bit_set_t),\n+            bool init = true) : s (&s_), v (INVALID), l(0)\n+    {\n+      if (init)\n+      {\n+        l = s->get_population () + 1;\n+        __next__ ();\n+      }\n+    }\n+\n+    typedef hb_codepoint_t __item_t__;\n+    hb_codepoint_t __item__ () const { return v; }\n+    bool __more__ () const { return v != INVALID; }\n+    void __next__ () { s->next (&v); if (l) l--; }\n+    void __prev__ () { s->previous (&v); }\n+    unsigned __len__ () const { return l; }\n+    iter_t end () const { return iter_t (*s, false); }\n+    bool operator != (const iter_t& o) const\n+    { return s != o.s || v != o.v; }\n+\n+    protected:\n+    const hb_bit_set_t *s;\n+    hb_codepoint_t v;\n+    unsigned l;\n+  };\n+  iter_t iter () const { return iter_t (*this); }\n+  operator iter_t () const { return iter (); }\n+\n+  protected:\n+\n+  page_t *page_for (hb_codepoint_t g, bool insert = false)\n+  {\n+    unsigned major = get_major (g);\n+\n+    \/* The extra page_map length is necessary; can't just rely on vector here,\n+     * since the next check would be tricked because a null page also has\n+     * major==0, which we can't distinguish from an actualy major==0 page... *\/\n+    unsigned i = last_page_lookup.get_relaxed ();\n+    if (likely (i < page_map.length))\n+    {\n+      auto &cached_page = page_map.arrayZ[i];\n+      if (cached_page.major == major)\n+        return &pages[cached_page.index];\n+    }\n+\n+    page_map_t map = {major, pages.length};\n+    if (!page_map.bfind (map, &i, HB_NOT_FOUND_STORE_CLOSEST))\n+    {\n+      if (!insert)\n+        return nullptr;\n+\n+      if (unlikely (!resize (pages.length + 1)))\n+        return nullptr;\n+\n+      pages[map.index].init0 ();\n+      memmove (page_map + i + 1,\n+               page_map + i,\n+               (page_map.length - 1 - i) * page_map.item_size);\n+      page_map[i] = map;\n+    }\n+\n+    last_page_lookup.set_relaxed (i);\n+    return &pages[page_map[i].index];\n+  }\n+  const page_t *page_for (hb_codepoint_t g) const\n+  {\n+    unsigned major = get_major (g);\n+\n+    \/* The extra page_map length is necessary; can't just rely on vector here,\n+     * since the next check would be tricked because a null page also has\n+     * major==0, which we can't distinguish from an actualy major==0 page... *\/\n+    unsigned i = last_page_lookup.get_relaxed ();\n+    if (likely (i < page_map.length))\n+    {\n+      auto &cached_page = page_map.arrayZ[i];\n+      if (cached_page.major == major)\n+        return &pages[cached_page.index];\n+    }\n+\n+    page_map_t key = {major};\n+    if (!page_map.bfind (key, &i))\n+      return nullptr;\n+\n+    last_page_lookup.set_relaxed (i);\n+    return &pages[page_map[i].index];\n+  }\n+  page_t &page_at (unsigned int i) { return pages[page_map[i].index]; }\n+  const page_t &page_at (unsigned int i) const { return pages[page_map[i].index]; }\n+  unsigned int get_major (hb_codepoint_t g) const { return g >> page_t::PAGE_BITS_LOG_2; }\n+  unsigned int page_remainder (hb_codepoint_t g) const { return g & page_t::PAGE_BITMASK; }\n+  hb_codepoint_t major_start (unsigned int major) const { return major << page_t::PAGE_BITS_LOG_2; }\n+};\n+\n+\n+#endif \/* HB_BIT_SET_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-set.hh","additions":953,"deletions":0,"binary":false,"changes":953,"status":"added"},{"patch":"@@ -74,0 +74,38 @@\n+{\n+  if (!length)\n+  {\n+    if (destroy)\n+      destroy (user_data);\n+    return hb_blob_get_empty ();\n+  }\n+\n+  hb_blob_t *blob = hb_blob_create_or_fail (data, length, mode,\n+                                            user_data, destroy);\n+  return likely (blob) ? blob : hb_blob_get_empty ();\n+}\n+\n+\/**\n+ * hb_blob_create_or_fail: (skip)\n+ * @data: Pointer to blob data.\n+ * @length: Length of @data in bytes.\n+ * @mode: Memory mode for @data.\n+ * @user_data: Data parameter to pass to @destroy.\n+ * @destroy: (nullable): Callback to call when @data is not needed anymore.\n+ *\n+ * Creates a new \"blob\" object wrapping @data.  The @mode parameter is used\n+ * to negotiate ownership and lifecycle of @data.\n+ *\n+ * Note that this function returns a freshly-allocated empty blob even if @length\n+ * is zero. This is in contrast to hb_blob_create(), which returns the singleton\n+ * empty blob (as returned by hb_blob_get_empty()) if @length is zero.\n+ *\n+ * Return value: New blob, or %NULL if failed.  Destroy with hb_blob_destroy().\n+ *\n+ * Since: 2.8.2\n+ **\/\n+hb_blob_t *\n+hb_blob_create_or_fail (const char        *data,\n+                        unsigned int       length,\n+                        hb_memory_mode_t   mode,\n+                        void              *user_data,\n+                        hb_destroy_func_t  destroy)\n@@ -77,3 +115,3 @@\n-  if (!length ||\n-      length >= 1u << 31 ||\n-      !(blob = hb_object_create<hb_blob_t> ())) {\n+  if (length >= 1u << 31 ||\n+      !(blob = hb_object_create<hb_blob_t> ()))\n+  {\n@@ -82,1 +120,1 @@\n-    return hb_blob_get_empty ();\n+    return nullptr;\n@@ -94,1 +132,2 @@\n-    if (!blob->try_make_writable ()) {\n+    if (!blob->try_make_writable ())\n+    {\n@@ -96,1 +135,1 @@\n-      return hb_blob_get_empty ();\n+      return nullptr;\n@@ -229,1 +268,1 @@\n-  free (blob);\n+  hb_free (blob);\n@@ -333,1 +372,1 @@\n- * Returns: (transfer none) (array length=length): the byte data of @blob.\n+ * Returns: (nullable) (transfer none) (array length=length): the byte data of @blob.\n@@ -455,1 +494,1 @@\n-  new_data = (char *) malloc (this->length);\n+  new_data = (char *) hb_malloc (this->length);\n@@ -466,1 +505,1 @@\n-  this->destroy = free;\n+  this->destroy = hb_free;\n@@ -520,1 +559,1 @@\n-  free (file);\n+  hb_free (file);\n@@ -531,1 +570,1 @@\n-  char *rsrc_name = (char *) malloc (len);\n+  char *rsrc_name = (char *) hb_malloc (len);\n@@ -536,1 +575,1 @@\n-           sizeof (_PATH_RSRCFORKSPEC) - 1);\n+           sizeof (_PATH_RSRCFORKSPEC));\n@@ -539,1 +578,1 @@\n-  free (rsrc_name);\n+  hb_free (rsrc_name);\n@@ -564,1 +603,2 @@\n- * Returns: An #hb_blob_t pointer with the content of the file\n+ * Returns: An #hb_blob_t pointer with the content of the file,\n+ * or hb_blob_get_empty() if failed.\n@@ -570,0 +610,19 @@\n+{\n+  hb_blob_t *blob = hb_blob_create_from_file_or_fail (file_name);\n+  return likely (blob) ? blob : hb_blob_get_empty ();\n+}\n+\n+\/**\n+ * hb_blob_create_from_file_or_fail:\n+ * @file_name: A font filename\n+ *\n+ * Creates a new blob containing the data from the\n+ * specified binary font file.\n+ *\n+ * Returns: An #hb_blob_t pointer with the content of the file,\n+ * or %NULL if failed.\n+ *\n+ * Since: 2.8.2\n+ **\/\n+hb_blob_t *\n+hb_blob_create_from_file_or_fail (const char *file_name)\n@@ -574,2 +633,2 @@\n-  hb_mapped_file_t *file = (hb_mapped_file_t *) calloc (1, sizeof (hb_mapped_file_t));\n-  if (unlikely (!file)) return hb_blob_get_empty ();\n+  hb_mapped_file_t *file = (hb_mapped_file_t *) hb_calloc (1, sizeof (hb_mapped_file_t));\n+  if (unlikely (!file)) return nullptr;\n@@ -604,3 +663,3 @@\n-  return hb_blob_create (file->contents, file->length,\n-                         HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,\n-                         (hb_destroy_func_t) _hb_mapped_file_destroy);\n+  return hb_blob_create_or_fail (file->contents, file->length,\n+                                 HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,\n+                                 (hb_destroy_func_t) _hb_mapped_file_destroy);\n@@ -611,1 +670,1 @@\n-  free (file);\n+  hb_free (file);\n@@ -614,2 +673,2 @@\n-  hb_mapped_file_t *file = (hb_mapped_file_t *) calloc (1, sizeof (hb_mapped_file_t));\n-  if (unlikely (!file)) return hb_blob_get_empty ();\n+  hb_mapped_file_t *file = (hb_mapped_file_t *) hb_calloc (1, sizeof (hb_mapped_file_t));\n+  if (unlikely (!file)) return nullptr;\n@@ -619,1 +678,1 @@\n-  wchar_t * wchar_file_name = (wchar_t *) malloc (sizeof (wchar_t) * size);\n+  wchar_t * wchar_file_name = (wchar_t *) hb_malloc (sizeof (wchar_t) * size);\n@@ -639,1 +698,1 @@\n-  free (wchar_file_name);\n+  hb_free (wchar_file_name);\n@@ -664,3 +723,3 @@\n-  return hb_blob_create (file->contents, file->length,\n-                         HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,\n-                         (hb_destroy_func_t) _hb_mapped_file_destroy);\n+  return hb_blob_create_or_fail (file->contents, file->length,\n+                                 HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,\n+                                 (hb_destroy_func_t) _hb_mapped_file_destroy);\n@@ -671,1 +730,1 @@\n-  free (file);\n+  hb_free (file);\n@@ -678,2 +737,2 @@\n-  char *data = (char *) malloc (allocated);\n-  if (unlikely (!data)) return hb_blob_get_empty ();\n+  char *data = (char *) hb_malloc (allocated);\n+  if (unlikely (!data)) return nullptr;\n@@ -692,1 +751,1 @@\n-      char *new_data = (char *) realloc (data, allocated);\n+      char *new_data = (char *) hb_realloc (data, allocated);\n@@ -709,2 +768,2 @@\n-  return hb_blob_create (data, len, HB_MEMORY_MODE_WRITABLE, data,\n-                         (hb_destroy_func_t) free);\n+  return hb_blob_create_or_fail (data, len, HB_MEMORY_MODE_WRITABLE, data,\n+                                 (hb_destroy_func_t) hb_free);\n@@ -715,2 +774,2 @@\n-  free (data);\n-  return hb_blob_get_empty ();\n+  hb_free (data);\n+  return nullptr;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-blob.cc","additions":95,"deletions":36,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -93,0 +93,7 @@\n+HB_EXTERN hb_blob_t *\n+hb_blob_create_or_fail (const char        *data,\n+                        unsigned int       length,\n+                        hb_memory_mode_t   mode,\n+                        void              *user_data,\n+                        hb_destroy_func_t  destroy);\n+\n@@ -96,0 +103,3 @@\n+HB_EXTERN hb_blob_t *\n+hb_blob_create_from_file_or_fail (const char *file_name);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-blob.h","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  void destroy () { hb_blob_destroy (b.get ()); b = nullptr; }\n+  void destroy () { hb_blob_destroy (b.get_raw ()); b = nullptr; }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-blob.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n@@ -3,24 +4,24 @@\n-* Copyright  2013  Google, Inc.\n-*\n-*  This is part of HarfBuzz, a text shaping library.\n-*\n-* Permission is hereby granted, without written agreement and without\n-* license or royalty fees, to use, copy, modify, and distribute this\n-* software and its documentation for any purpose, provided that the\n-* above copyright notice and the following two paragraphs appear in\n-* all copies of this software.\n-*\n-* IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n-* DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n-* ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n-* IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n-* DAMAGE.\n-*\n-* THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n-* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n-* FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n-* ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n-* PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n-*\n-* Google Author(s): Behdad Esfahbod\n-*\/\n+ * Copyright  2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n@@ -34,1 +35,1 @@\n-#line 35 \"hb-buffer-deserialize-json.hh\"\n+#line 36 \"hb-buffer-deserialize-json.hh\"\n@@ -36,14 +37,7 @@\n-        1u, 0u, 0u, 18u, 0u, 2u, 10u, 15u,\n-        16u, 17u, 2u, 2u, 0u, 7u, 0u, 6u,\n-        5u, 6u, 0u, 19u, 0u, 19u, 0u, 19u,\n-        2u, 2u, 0u, 7u, 0u, 6u, 5u, 6u,\n-        0u, 19u, 0u, 19u, 14u, 14u, 2u, 2u,\n-        0u, 7u, 0u, 6u, 0u, 19u, 0u, 19u,\n-        16u, 17u, 2u, 2u, 0u, 7u, 0u, 6u,\n-        5u, 6u, 0u, 19u, 0u, 19u, 2u, 2u,\n-        0u, 7u, 0u, 6u, 5u, 6u, 0u, 19u,\n-        0u, 19u, 2u, 2u, 0u, 7u, 0u, 6u,\n-        2u, 8u, 0u, 19u, 2u, 8u, 0u, 19u,\n-        0u, 19u, 2u, 2u, 0u, 7u, 0u, 6u,\n-        0u, 19u, 0u, 9u, 0u, 18u, 1u, 0u,\n-        0u\n+        0u, 0u, 9u, 123u, 9u, 34u, 97u, 117u, 120u, 121u, 34u, 34u, 9u, 58u, 9u, 57u,\n+        48u, 57u, 9u, 125u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u,\n+        9u, 125u, 9u, 125u, 108u, 108u, 34u, 34u, 9u, 58u, 9u, 57u, 9u, 125u, 9u, 125u,\n+        120u, 121u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 34u, 34u,\n+        9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u,\n+        34u, 92u, 9u, 125u, 34u, 92u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u,\n+        9u, 125u, 9u, 93u, 9u, 123u, 0u, 0u, 0\n@@ -52,16 +46,8 @@\n-static const signed char _deserialize_json_char_class[] = {\n-        0, 0, 0, 0, 0, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 0,\n-        1, 2, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 3, 4, 1, 1, 5,\n-        6, 6, 6, 6, 6, 6, 6, 6,\n-        6, 7, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 8, 9, 1, 1, 1,\n-        10, 1, 11, 12, 1, 1, 13, 1,\n-        1, 1, 1, 14, 1, 1, 1, 1,\n-        1, 1, 1, 1, 15, 1, 1, 16,\n-        17, 1, 18, 1, 19, 0\n+static const char _deserialize_json_key_spans[] = {\n+        0, 115, 26, 21, 2, 1, 50, 49,\n+        10, 117, 117, 117, 1, 50, 49, 10,\n+        117, 117, 1, 1, 50, 49, 117, 117,\n+        2, 1, 50, 49, 10, 117, 117, 1,\n+        50, 49, 10, 117, 117, 1, 50, 49,\n+        59, 117, 59, 117, 117, 1, 50, 49,\n+        117, 85, 115, 0\n@@ -71,7 +57,7 @@\n-        0, 0, 19, 22, 28, 30, 31, 39,\n-        46, 48, 68, 88, 108, 109, 117, 124,\n-        126, 146, 166, 167, 168, 176, 183, 203,\n-        223, 225, 226, 234, 241, 243, 263, 283,\n-        284, 292, 299, 301, 321, 341, 342, 350,\n-        357, 364, 384, 391, 411, 431, 432, 440,\n-        447, 467, 477, 496, 0\n+        0, 0, 116, 143, 165, 168, 170, 221,\n+        271, 282, 400, 518, 636, 638, 689, 739,\n+        750, 868, 986, 988, 990, 1041, 1091, 1209,\n+        1327, 1330, 1332, 1383, 1433, 1444, 1562, 1680,\n+        1682, 1733, 1783, 1794, 1912, 2030, 2032, 2083,\n+        2133, 2193, 2311, 2371, 2489, 2607, 2609, 2660,\n+        2710, 2828, 2914, 3030\n@@ -80,63 +66,380 @@\n-static const signed char _deserialize_json_indicies[] = {\n-        1, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 2, 3, 0, 4, 5, 6,\n-        7, 8, 0, 9, 10, 11, 12, 12,\n-        0, 0, 0, 0, 0, 0, 13, 13,\n-        0, 0, 0, 14, 15, 16, 18, 19,\n-        20, 0, 0, 21, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 22, 23, 0, 0, 3,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 24,\n-        20, 0, 0, 21, 0, 19, 19, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 22, 25, 25, 0, 0,\n-        0, 0, 0, 0, 26, 26, 0, 0,\n-        0, 27, 28, 29, 31, 32, 33, 0,\n-        0, 34, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 35, 33, 0, 0, 34, 0, 32,\n-        32, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 35, 36, 37,\n-        37, 0, 0, 0, 0, 0, 0, 38,\n-        38, 0, 0, 0, 0, 39, 40, 42,\n-        0, 0, 43, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 44, 42, 0, 0, 43, 0,\n-        45, 45, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 44, 46,\n-        47, 48, 48, 0, 0, 0, 0, 0,\n-        0, 49, 49, 0, 0, 0, 50, 51,\n-        52, 54, 55, 56, 0, 0, 57, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 58, 56,\n-        0, 0, 57, 0, 55, 55, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 58, 59, 59, 0, 0, 0,\n-        0, 0, 0, 60, 60, 0, 0, 0,\n-        61, 62, 63, 65, 66, 67, 0, 0,\n-        68, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        69, 67, 0, 0, 68, 0, 66, 66,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 69, 70, 70, 0,\n-        0, 0, 0, 0, 0, 71, 71, 0,\n-        72, 0, 0, 73, 74, 76, 75, 75,\n-        75, 75, 75, 77, 79, 0, 0, 80,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 81,\n-        75, 0, 0, 0, 0, 0, 75, 83,\n-        0, 0, 84, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 85, 83, 0, 0, 84, 0,\n-        87, 87, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 85, 88,\n-        88, 0, 0, 0, 0, 0, 0, 89,\n-        89, 0, 0, 0, 0, 90, 91, 83,\n-        0, 0, 84, 0, 93, 93, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 85, 94, 0, 0, 95, 0,\n-        0, 0, 0, 0, 96, 1, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 2,\n+static const char _deserialize_json_indicies[] = {\n+        0, 0, 0, 0, 0, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        0, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 2, 1, 3, 3, 3,\n+        3, 3, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 3, 1, 4, 1,\n+        5, 1, 6, 7, 1, 1, 8, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 9, 1, 10, 11,\n+        1, 12, 1, 12, 12, 12, 12, 12,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 12, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 13, 1, 13, 13,\n+        13, 13, 13, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 13, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 14, 1, 1, 15, 16, 16,\n+        16, 16, 16, 16, 16, 16, 16, 1,\n+        17, 18, 18, 18, 18, 18, 18, 18,\n+        18, 18, 1, 19, 19, 19, 19, 19,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 19, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 20, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 21,\n+        1, 22, 22, 22, 22, 22, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        22, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 3, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 23, 1, 19,\n+        19, 19, 19, 19, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 19, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 20, 1, 1, 1, 18, 18,\n+        18, 18, 18, 18, 18, 18, 18, 18,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 21, 1, 24, 1, 24,\n+        24, 24, 24, 24, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 24, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        25, 1, 25, 25, 25, 25, 25, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 25, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 26, 1,\n+        1, 27, 28, 28, 28, 28, 28, 28,\n+        28, 28, 28, 1, 29, 30, 30, 30,\n+        30, 30, 30, 30, 30, 30, 1, 31,\n+        31, 31, 31, 31, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 31, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 32, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 33, 1, 31, 31, 31,\n+        31, 31, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 31, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        32, 1, 1, 1, 30, 30, 30, 30,\n+        30, 30, 30, 30, 30, 30, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 33, 1, 34, 1, 35, 1, 35,\n+        35, 35, 35, 35, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 35, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        36, 1, 36, 36, 36, 36, 36, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 36, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 37, 38, 38, 38, 38, 38, 38,\n+        38, 38, 38, 1, 39, 39, 39, 39,\n+        39, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 39, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 40,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        41, 1, 39, 39, 39, 39, 39, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 39, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 40, 1, 1,\n+        1, 42, 42, 42, 42, 42, 42, 42,\n+        42, 42, 42, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 41, 1,\n+        43, 44, 1, 45, 1, 45, 45, 45,\n+        45, 45, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 45, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 46, 1,\n+        46, 46, 46, 46, 46, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 46,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 47, 1, 1, 48,\n+        49, 49, 49, 49, 49, 49, 49, 49,\n+        49, 1, 50, 51, 51, 51, 51, 51,\n+        51, 51, 51, 51, 1, 52, 52, 52,\n+        52, 52, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 52, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        53, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 54, 1, 52, 52, 52, 52, 52,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 52, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 53, 1,\n+        1, 1, 51, 51, 51, 51, 51, 51,\n+        51, 51, 51, 51, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 54,\n+        1, 55, 1, 55, 55, 55, 55, 55,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 55, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 56, 1, 56, 56,\n+        56, 56, 56, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 56, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 57, 1, 1, 58, 59, 59,\n+        59, 59, 59, 59, 59, 59, 59, 1,\n+        60, 61, 61, 61, 61, 61, 61, 61,\n+        61, 61, 1, 62, 62, 62, 62, 62,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 62, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 63, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 64,\n+        1, 62, 62, 62, 62, 62, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        62, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 63, 1, 1, 1,\n+        61, 61, 61, 61, 61, 61, 61, 61,\n+        61, 61, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 64, 1, 65,\n+        1, 65, 65, 65, 65, 65, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        65, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 66, 1, 66, 66, 66, 66,\n+        66, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 66, 1, 67, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 68, 69, 69, 69, 69,\n+        69, 69, 69, 69, 69, 1, 71, 70,\n+        70, 70, 70, 70, 70, 70, 70, 70,\n+        70, 70, 70, 70, 70, 70, 70, 70,\n+        70, 70, 70, 70, 70, 70, 70, 70,\n+        70, 70, 70, 70, 70, 70, 70, 70,\n+        70, 70, 70, 70, 70, 70, 70, 70,\n+        70, 70, 70, 70, 70, 70, 70, 70,\n+        70, 70, 70, 70, 70, 70, 70, 70,\n+        72, 70, 73, 73, 73, 73, 73, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 73, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 74, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 75, 1,\n+        70, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 70, 1, 76, 76, 76, 76,\n+        76, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 76, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 77,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        78, 1, 76, 76, 76, 76, 76, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 76, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 77, 1, 1,\n+        1, 79, 79, 79, 79, 79, 79, 79,\n+        79, 79, 79, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 78, 1,\n+        80, 1, 80, 80, 80, 80, 80, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 80, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 81, 1, 81, 81, 81,\n+        81, 81, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 81, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 82, 83, 83, 83,\n+        83, 83, 83, 83, 83, 83, 1, 76,\n+        76, 76, 76, 76, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 76, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 77, 1, 1, 1, 84, 84,\n+        84, 84, 84, 84, 84, 84, 84, 84,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 78, 1, 85, 85, 85,\n+        85, 85, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 85, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        86, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 87, 1, 0, 0, 0, 0, 0,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 0, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 2, 1, 1,\n@@ -146,12 +449,2 @@\n-static const signed char _deserialize_json_index_defaults[] = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        75, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0\n-};\n-\n-static const signed char _deserialize_json_cond_targs[] = {\n-        0, 1, 2, 2, 3, 4, 18, 24,\n+static const char _deserialize_json_trans_targs[] = {\n+        1, 0, 2, 2, 3, 4, 18, 24,\n@@ -159,11 +452,9 @@\n-        11, 8, 9, 11, 10, 2, 49, 10,\n-        49, 13, 14, 15, 16, 17, 15, 16,\n-        17, 10, 2, 49, 19, 20, 21, 22,\n-        23, 22, 10, 2, 49, 23, 25, 31,\n-        26, 27, 28, 29, 30, 28, 29, 30,\n-        10, 2, 49, 32, 33, 34, 35, 36,\n-        34, 35, 36, 10, 2, 49, 38, 39,\n-        40, 43, 44, 40, 41, 42, 41, 10,\n-        2, 49, 43, 10, 2, 49, 44, 44,\n-        46, 47, 43, 48, 48, 48, 49, 50,\n-        51, 0\n+        11, 9, 11, 10, 2, 49, 10, 49,\n+        13, 14, 15, 16, 17, 16, 17, 10,\n+        2, 49, 19, 20, 21, 22, 23, 10,\n+        2, 49, 23, 25, 31, 26, 27, 28,\n+        29, 30, 29, 30, 10, 2, 49, 32,\n+        33, 34, 35, 36, 35, 36, 10, 2,\n+        49, 38, 39, 40, 43, 44, 40, 41,\n+        42, 10, 2, 49, 10, 2, 49, 44,\n+        46, 47, 43, 48, 48, 49, 50, 51\n@@ -172,1 +463,1 @@\n-static const signed char _deserialize_json_cond_actions[] = {\n+static const char _deserialize_json_trans_actions[] = {\n@@ -175,11 +466,9 @@\n-        2, 0, 0, 0, 3, 3, 4, 0,\n-        5, 0, 0, 2, 2, 2, 0, 0,\n-        0, 6, 6, 7, 0, 0, 0, 2,\n-        2, 0, 8, 8, 9, 0, 0, 0,\n-        0, 0, 2, 2, 2, 0, 0, 0,\n-        10, 10, 11, 0, 0, 2, 2, 2,\n-        0, 0, 0, 12, 12, 13, 0, 0,\n-        2, 14, 14, 0, 15, 0, 0, 16,\n-        16, 17, 0, 18, 18, 19, 0, 15,\n-        0, 0, 20, 20, 0, 21, 0, 0,\n-        0, 0\n+        2, 0, 0, 3, 3, 4, 0, 5,\n+        0, 0, 2, 2, 2, 0, 0, 6,\n+        6, 7, 0, 0, 0, 2, 2, 8,\n+        8, 9, 0, 0, 0, 0, 0, 2,\n+        2, 2, 0, 0, 10, 10, 11, 0,\n+        0, 2, 2, 2, 0, 0, 12, 12,\n+        13, 0, 0, 2, 14, 14, 0, 15,\n+        0, 16, 16, 17, 18, 18, 19, 15,\n+        0, 0, 20, 20, 21, 0, 0, 0\n@@ -200,4 +489,4 @@\n-const char *buf,\n-unsigned int buf_len,\n-const char **end_ptr,\n-hb_font_t *font)\n+                                    const char *buf,\n+                                    unsigned int buf_len,\n+                                    const char **end_ptr,\n+                                    hb_font_t *font)\n@@ -205,1 +494,1 @@\n-        const char *p = buf, *pe = buf + buf_len;\n+  const char *p = buf, *pe = buf + buf_len;\n@@ -207,2 +496,2 @@\n-        \/* Ensure we have positions. *\/\n-        (void) hb_buffer_get_glyph_positions (buffer, nullptr);\n+  \/* Ensure we have positions. *\/\n+  (void) hb_buffer_get_glyph_positions (buffer, nullptr);\n@@ -210,6 +499,6 @@\n-        while (p < pe && ISSPACE (*p))\n-        p++;\n-        if (p < pe && *p == (buffer->len ? ',' : '['))\n-                {\n-                *end_ptr = ++p;\n-        }\n+  while (p < pe && ISSPACE (*p))\n+    p++;\n+  if (p < pe && *p == (buffer->len ? ',' : '['))\n+  {\n+    *end_ptr = ++p;\n+  }\n@@ -217,4 +506,4 @@\n-        const char *tok = nullptr;\n-        int cs;\n-        hb_glyph_info_t info = {0};\n-        hb_glyph_position_t pos = {0};\n+  const char *tok = nullptr;\n+  int cs;\n+  hb_glyph_info_t info = {0};\n+  hb_glyph_position_t pos = {0};\n@@ -222,1 +511,1 @@\n-#line 223 \"hb-buffer-deserialize-json.hh\"\n+#line 512 \"hb-buffer-deserialize-json.hh\"\n@@ -224,1 +513,1 @@\n-                cs = (int)deserialize_json_start;\n+        cs = deserialize_json_start;\n@@ -227,1 +516,1 @@\n-#line 228 \"hb-buffer-deserialize-json.hh\"\n+#line 517 \"hb-buffer-deserialize-json.hh\"\n@@ -229,28 +518,24 @@\n-                unsigned int _trans = 0;\n-                const unsigned char * _keys;\n-                const signed char * _inds;\n-                int _ic;\n-                _resume: {}\n-                if ( p == pe )\n-                        goto _out;\n-                _keys = ( _deserialize_json_trans_keys + ((cs<<1)));\n-                _inds = ( _deserialize_json_indicies + (_deserialize_json_index_offsets[cs]));\n-\n-                if ( ( (*( p))) <= 125 && ( (*( p))) >= 9 ) {\n-                        _ic = (int)_deserialize_json_char_class[(int)( (*( p))) - 9];\n-                        if ( _ic <= (int)(*( _keys+1)) && _ic >= (int)(*( _keys)) )\n-                                _trans = (unsigned int)(*( _inds + (int)( _ic - (int)(*( _keys)) ) ));\n-                        else\n-                                _trans = (unsigned int)_deserialize_json_index_defaults[cs];\n-                }\n-                else {\n-                        _trans = (unsigned int)_deserialize_json_index_defaults[cs];\n-                }\n-\n-                cs = (int)_deserialize_json_cond_targs[_trans];\n-\n-                if ( _deserialize_json_cond_actions[_trans] != 0 ) {\n-\n-                        switch ( _deserialize_json_cond_actions[_trans] ) {\n-                                case 1:  {\n-                                        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+        if ( cs == 0 )\n+                goto _out;\n+_resume:\n+        _keys = _deserialize_json_trans_keys + (cs<<1);\n+        _inds = _deserialize_json_indicies + _deserialize_json_index_offsets[cs];\n+\n+        _slen = _deserialize_json_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=(*p) &&\n+                (*p) <= _keys[1] ?\n+                (*p) - _keys[0] : _slen ];\n+\n+        cs = _deserialize_json_trans_targs[_trans];\n+\n+        if ( _deserialize_json_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _deserialize_json_trans_actions[_trans] ) {\n+        case 1:\n@@ -258,12 +543,6 @@\n-\n-                                                memset (&info, 0, sizeof (info));\n-                                                memset (&pos , 0, sizeof (pos ));\n-                                        }\n-\n-#line 264 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 5:  {\n-                                        {\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n+        break;\n+        case 5:\n@@ -271,15 +550,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 280 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 2:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 2:\n@@ -287,11 +560,5 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 292 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 15:  {\n-                                        {\n+        {\n+        tok = p;\n+}\n+        break;\n+        case 15:\n@@ -299,9 +566,3 @@\n-                                                if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-\n-#line 302 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 21:  {\n-                                        {\n+        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n+        break;\n+        case 21:\n@@ -309,9 +570,3 @@\n-                                                if (unlikely (!buffer->ensure_unicode ())) return false; }\n-\n-#line 312 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 16:  {\n-                                        {\n+        { if (unlikely (!buffer->ensure_unicode ())) return false; }\n+        break;\n+        case 16:\n@@ -319,15 +574,9 @@\n-\n-                                                \/* TODO Unescape \\\" and \\\\ if found. *\/\n-                                                if (!hb_font_glyph_from_string (font,\n-                                                tok, p - tok,\n-                                                &info.codepoint))\n-                                                return false;\n-                                        }\n-\n-#line 328 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 18:  {\n-                                        {\n+        {\n+        \/* TODO Unescape \\\" and \\\\ if found. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+        break;\n+        case 18:\n@@ -335,9 +584,3 @@\n-                                                if (!parse_uint (tok, p, &info.codepoint)) return false; }\n-\n-#line 338 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 8:  {\n-                                        {\n+        { if (!parse_uint (tok, p, &info.codepoint)) return false; }\n+        break;\n+        case 8:\n@@ -345,9 +588,3 @@\n-                                                if (!parse_uint (tok, p, &info.cluster )) return false; }\n-\n-#line 348 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 10:  {\n-                                        {\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+        break;\n+        case 10:\n@@ -355,9 +592,3 @@\n-                                                if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n-\n-#line 358 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 12:  {\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n+        break;\n+        case 12:\n@@ -365,9 +596,3 @@\n-                                                if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-\n-#line 368 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 3:  {\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+        break;\n+        case 3:\n@@ -375,9 +600,3 @@\n-                                                if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-\n-#line 378 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 6:  {\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+        break;\n+        case 6:\n@@ -385,9 +604,3 @@\n-                                                if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-\n-#line 388 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 14:  {\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n+        break;\n+        case 14:\n@@ -395,7 +608,3 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 400 \"hb-buffer-deserialize-json.hh\"\n-\n-                                        {\n+        {\n+        tok = p;\n+}\n@@ -403,9 +612,3 @@\n-                                                if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-\n-#line 406 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 20:  {\n-                                        {\n+        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n+        break;\n+        case 20:\n@@ -413,7 +616,3 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 418 \"hb-buffer-deserialize-json.hh\"\n-\n-                                        {\n+        {\n+        tok = p;\n+}\n@@ -421,9 +620,3 @@\n-                                                if (unlikely (!buffer->ensure_unicode ())) return false; }\n-\n-#line 424 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 17:  {\n-                                        {\n+        { if (unlikely (!buffer->ensure_unicode ())) return false; }\n+        break;\n+        case 17:\n@@ -431,11 +624,7 @@\n-\n-                                                \/* TODO Unescape \\\" and \\\\ if found. *\/\n-                                                if (!hb_font_glyph_from_string (font,\n-                                                tok, p - tok,\n-                                                &info.codepoint))\n-                                                return false;\n-                                        }\n-\n-#line 440 \"hb-buffer-deserialize-json.hh\"\n-\n-                                        {\n+        {\n+        \/* TODO Unescape \\\" and \\\\ if found. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n@@ -443,15 +632,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 452 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 19:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 19:\n@@ -459,5 +642,1 @@\n-                                                if (!parse_uint (tok, p, &info.codepoint)) return false; }\n-\n-#line 462 \"hb-buffer-deserialize-json.hh\"\n-\n-                                        {\n+        { if (!parse_uint (tok, p, &info.codepoint)) return false; }\n@@ -465,15 +644,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 474 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 9:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 9:\n@@ -481,5 +654,1 @@\n-                                                if (!parse_uint (tok, p, &info.cluster )) return false; }\n-\n-#line 484 \"hb-buffer-deserialize-json.hh\"\n-\n-                                        {\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n@@ -487,15 +656,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 496 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 11:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 11:\n@@ -503,5 +666,1 @@\n-                                                if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n-\n-#line 506 \"hb-buffer-deserialize-json.hh\"\n-\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n@@ -509,15 +668,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 518 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 13:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 13:\n@@ -525,5 +678,1 @@\n-                                                if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-\n-#line 528 \"hb-buffer-deserialize-json.hh\"\n-\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n@@ -531,15 +680,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 540 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 4:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 4:\n@@ -547,5 +690,1 @@\n-                                                if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-\n-#line 550 \"hb-buffer-deserialize-json.hh\"\n-\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n@@ -553,15 +692,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 562 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 7:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 7:\n@@ -569,5 +702,1 @@\n-                                                if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-\n-#line 572 \"hb-buffer-deserialize-json.hh\"\n-\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n@@ -575,0 +704,10 @@\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 713 \"hb-buffer-deserialize-json.hh\"\n+        }\n@@ -576,21 +715,7 @@\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 584 \"hb-buffer-deserialize-json.hh\"\n-\n-\n-                                        break;\n-                                }\n-                        }\n-\n-                }\n-\n-                if ( cs != 0 ) {\n-                        p += 1;\n-                        goto _resume;\n-                }\n-                _out: {}\n+_again:\n+        if ( cs == 0 )\n+                goto _out;\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        _out: {}\n@@ -602,1 +727,1 @@\n-        *end_ptr = p;\n+  *end_ptr = p;\n@@ -604,1 +729,1 @@\n-        return p == pe && *(p-1) != ']';\n+  return p == pe && *(p-1) != ']';\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-json.hh","additions":644,"deletions":519,"binary":false,"changes":1163,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n@@ -3,24 +4,24 @@\n-* Copyright  2013  Google, Inc.\n-*\n-*  This is part of HarfBuzz, a text shaping library.\n-*\n-* Permission is hereby granted, without written agreement and without\n-* license or royalty fees, to use, copy, modify, and distribute this\n-* software and its documentation for any purpose, provided that the\n-* above copyright notice and the following two paragraphs appear in\n-* all copies of this software.\n-*\n-* IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n-* DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n-* ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n-* IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n-* DAMAGE.\n-*\n-* THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n-* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n-* FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n-* ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n-* PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n-*\n-* Google Author(s): Behdad Esfahbod\n-*\/\n+ * Copyright  2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n@@ -34,1 +35,1 @@\n-#line 35 \"hb-buffer-deserialize-text.hh\"\n+#line 36 \"hb-buffer-deserialize-text.hh\"\n@@ -36,10 +37,13 @@\n-        1u, 0u, 0u, 13u, 12u, 12u, 2u, 2u,\n-        5u, 11u, 0u, 12u, 5u, 6u, 4u, 6u,\n-        5u, 6u, 5u, 6u, 4u, 6u, 5u, 6u,\n-        3u, 3u, 4u, 6u, 5u, 6u, 3u, 6u,\n-        2u, 16u, 4u, 6u, 5u, 6u, 0u, 16u,\n-        0u, 16u, 1u, 0u, 0u, 12u, 0u, 16u,\n-        0u, 16u, 0u, 16u, 0u, 16u, 0u, 16u,\n-        0u, 16u, 0u, 16u, 0u, 16u, 0u, 16u,\n-        0u, 16u, 0u, 16u, 0u, 16u, 0u, 16u,\n-        0u, 16u, 0u\n+        0u, 0u, 9u, 91u, 85u, 85u, 43u, 43u, 48u, 102u, 9u, 85u, 48u, 57u, 45u, 57u,\n+        48u, 57u, 48u, 57u, 45u, 57u, 48u, 57u, 44u, 44u, 45u, 57u, 48u, 57u, 44u, 57u,\n+        43u, 124u, 45u, 57u, 48u, 57u, 9u, 124u, 9u, 124u, 0u, 0u, 9u, 85u, 9u, 124u,\n+        9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u,\n+        9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 0\n+};\n+\n+static const char _deserialize_text_key_spans[] = {\n+        0, 83, 1, 1, 55, 77, 10, 13,\n+        10, 10, 13, 10, 1, 13, 10, 14,\n+        82, 13, 10, 116, 116, 0, 77, 116,\n+        116, 116, 116, 116, 116, 116, 116, 116,\n+        116, 116, 116, 116, 116\n@@ -48,2 +52,227 @@\n-static const signed char _deserialize_text_char_class[] = {\n-        0, 0, 0, 0, 0, 1, 1, 1,\n+static const short _deserialize_text_index_offsets[] = {\n+        0, 0, 84, 86, 88, 144, 222, 233,\n+        247, 258, 269, 283, 294, 296, 310, 321,\n+        336, 419, 433, 444, 561, 678, 679, 757,\n+        874, 991, 1108, 1225, 1342, 1459, 1576, 1693,\n+        1810, 1927, 2044, 2161, 2278\n+};\n+\n+static const char _deserialize_text_indicies[] = {\n+        0, 0, 0, 0, 0, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        0, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 2, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 3, 1, 4, 1, 5,\n+        1, 6, 6, 6, 6, 6, 6, 6,\n+        6, 6, 6, 1, 1, 1, 1, 1,\n+        1, 1, 6, 6, 6, 6, 6, 6,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 6, 6, 6, 6, 6, 6,\n+        1, 7, 7, 7, 7, 7, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        7, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 4, 1, 8,\n+        9, 9, 9, 9, 9, 9, 9, 9,\n+        9, 1, 10, 1, 1, 11, 12, 12,\n+        12, 12, 12, 12, 12, 12, 12, 1,\n+        13, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 1, 15, 16, 16, 16, 16,\n+        16, 16, 16, 16, 16, 1, 17, 1,\n+        1, 18, 19, 19, 19, 19, 19, 19,\n+        19, 19, 19, 1, 20, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 1, 22,\n+        1, 23, 1, 1, 24, 25, 25, 25,\n+        25, 25, 25, 25, 25, 25, 1, 26,\n+        27, 27, 27, 27, 27, 27, 27, 27,\n+        27, 1, 22, 1, 1, 1, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        1, 28, 28, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 28, 1, 1, 28, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 28, 28, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 28, 1, 29, 1, 1, 30,\n+        31, 31, 31, 31, 31, 31, 31, 31,\n+        31, 1, 32, 33, 33, 33, 33, 33,\n+        33, 33, 33, 33, 1, 34, 34, 34,\n+        34, 34, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 34, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 35, 35, 35, 35,\n+        35, 35, 35, 35, 35, 35, 1, 1,\n+        1, 36, 37, 1, 1, 35, 35, 35,\n+        35, 35, 35, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 35, 35, 35,\n+        35, 35, 35, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        38, 1, 39, 39, 39, 39, 39, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 39, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 40,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 41, 1, 1,\n+        7, 7, 7, 7, 7, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 7,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 4, 1, 42, 42,\n+        42, 42, 42, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 42, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 43, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 44, 1, 42, 42, 42, 42, 42,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 42, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 45, 45, 45, 45, 45, 45,\n+        45, 45, 45, 45, 1, 1, 1, 1,\n+        43, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 44, 1,\n+        47, 47, 47, 47, 47, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 47,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 48, 1, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 49, 46, 46, 50,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 51, 52, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 53, 46, 54, 54, 54,\n+        54, 54, 28, 28, 28, 28, 28, 28,\n+        28, 28, 28, 28, 28, 28, 28, 28,\n+        28, 28, 28, 28, 54, 28, 28, 28,\n+        28, 28, 28, 28, 28, 28, 28, 55,\n+        1, 28, 28, 28, 28, 28, 28, 28,\n+        28, 28, 28, 28, 28, 28, 28, 28,\n+        28, 56, 28, 28, 57, 28, 28, 28,\n+        28, 28, 28, 28, 28, 28, 28, 28,\n+        28, 28, 28, 28, 28, 28, 28, 28,\n+        28, 28, 28, 28, 28, 28, 28, 28,\n+        58, 59, 28, 28, 28, 28, 28, 28,\n+        28, 28, 28, 28, 28, 28, 28, 28,\n+        28, 28, 28, 28, 28, 28, 28, 28,\n+        28, 28, 28, 28, 28, 28, 28, 28,\n+        60, 28, 61, 61, 61, 61, 61, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 61, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 62, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 63, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 64, 1, 65,\n+        65, 65, 65, 65, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 65, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 40, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 66, 1, 67, 67, 67, 67,\n+        67, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 67, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 48, 1,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        49, 46, 46, 50, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 51,\n+        52, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 46,\n+        46, 46, 46, 46, 46, 46, 46, 53,\n+        46, 68, 68, 68, 68, 68, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        68, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 69, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        70, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 43, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 71, 1, 72, 72,\n+        72, 72, 72, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 72, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        73, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n@@ -51,1 +280,0 @@\n-        1, 1, 1, 1, 1, 1, 1, 0,\n@@ -53,4 +281,0 @@\n-        1, 1, 2, 3, 4, 1, 1, 5,\n-        6, 6, 6, 6, 6, 6, 6, 6,\n-        6, 1, 1, 7, 8, 9, 1, 10,\n-        11, 11, 11, 11, 11, 11, 1, 1,\n@@ -58,3 +282,0 @@\n-        1, 1, 1, 1, 12, 1, 1, 1,\n-        1, 1, 13, 14, 15, 1, 1, 1,\n-        11, 11, 11, 11, 11, 11, 1, 1,\n@@ -62,0 +283,1 @@\n+        1, 1, 74, 1, 1, 1, 1, 1,\n@@ -63,1 +285,76 @@\n-        1, 1, 1, 16, 0\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 75, 1, 72, 72, 72, 72, 72,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 72, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 73, 1, 1,\n+        1, 1, 27, 27, 27, 27, 27, 27,\n+        27, 27, 27, 27, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 74,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 75, 1,\n+        68, 68, 68, 68, 68, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 68,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 69, 1, 1, 1, 1, 76,\n+        76, 76, 76, 76, 76, 76, 76, 76,\n+        76, 1, 1, 1, 1, 1, 1, 70,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 43, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 71, 1, 77, 77, 77,\n+        77, 77, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 77, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 78, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        79, 1, 77, 77, 77, 77, 77, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 77, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 33, 33, 33, 33, 33, 33, 33,\n+        33, 33, 33, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 78, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 79, 1, 61,\n+        61, 61, 61, 61, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 61, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 62, 1, 1, 1, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 63, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 64, 1, 0\n@@ -66,6 +363,11 @@\n-static const short _deserialize_text_index_offsets[] = {\n-        0, 0, 14, 15, 16, 23, 36, 38,\n-        41, 43, 45, 48, 50, 51, 54, 56,\n-        60, 75, 78, 80, 97, 114, 114, 127,\n-        144, 161, 178, 195, 212, 229, 246, 263,\n-        280, 297, 314, 331, 348, 0\n+static const char _deserialize_text_trans_targs[] = {\n+        1, 0, 2, 25, 3, 4, 19, 5,\n+        23, 24, 8, 27, 36, 27, 36, 30,\n+        33, 11, 12, 15, 12, 15, 13, 14,\n+        31, 32, 31, 32, 26, 18, 34, 35,\n+        34, 35, 20, 19, 6, 21, 22, 20,\n+        21, 22, 20, 21, 22, 24, 26, 26,\n+        7, 9, 10, 16, 21, 29, 26, 7,\n+        9, 10, 16, 21, 29, 28, 17, 21,\n+        29, 28, 29, 29, 28, 7, 10, 29,\n+        28, 7, 21, 29, 33, 28, 21, 29\n@@ -74,47 +376,11 @@\n-static const signed char _deserialize_text_indicies[] = {\n-        1, 0, 0, 0, 0, 0, 0, 2,\n-        0, 0, 0, 0, 0, 3, 4, 6,\n-        7, 7, 0, 0, 0, 0, 7, 8,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 4, 10, 11, 13, 14,\n-        15, 17, 18, 20, 21, 23, 24, 25,\n-        27, 28, 29, 31, 32, 33, 35, 36,\n-        29, 0, 28, 28, 38, 38, 0, 0,\n-        0, 0, 38, 0, 38, 0, 0, 0,\n-        38, 38, 38, 40, 41, 42, 44, 45,\n-        47, 0, 0, 0, 0, 48, 48, 0,\n-        49, 50, 0, 48, 0, 0, 0, 0,\n-        51, 52, 0, 0, 0, 0, 0, 0,\n-        0, 0, 53, 0, 0, 0, 0, 0,\n-        0, 54, 8, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 4, 56,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        57, 0, 0, 0, 0, 0, 0, 58,\n-        56, 0, 0, 0, 0, 60, 60, 0,\n-        0, 57, 0, 0, 0, 0, 0, 0,\n-        58, 63, 62, 64, 0, 62, 62, 62,\n-        62, 65, 62, 66, 62, 62, 62, 67,\n-        68, 69, 71, 38, 72, 0, 38, 38,\n-        38, 38, 73, 38, 74, 38, 38, 38,\n-        37, 75, 76, 78, 0, 0, 79, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 80, 81, 82, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 53, 83, 84, 62, 64,\n-        0, 62, 62, 62, 62, 65, 62, 66,\n-        62, 62, 62, 67, 68, 69, 86, 0,\n-        87, 0, 0, 0, 0, 0, 0, 0,\n-        88, 0, 0, 0, 0, 57, 89, 91,\n-        0, 92, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 93, 94,\n-        91, 0, 92, 0, 0, 36, 36, 0,\n-        0, 0, 0, 0, 0, 0, 0, 93,\n-        94, 86, 0, 87, 0, 0, 97, 97,\n-        0, 0, 0, 88, 0, 0, 0, 0,\n-        57, 89, 99, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 100, 101, 99, 0, 0, 0, 0,\n-        45, 45, 0, 0, 0, 0, 0, 0,\n-        0, 0, 100, 101, 78, 0, 0, 79,\n-        0, 18, 18, 0, 0, 0, 0, 0,\n-        0, 0, 0, 80, 81, 0\n+static const char _deserialize_text_trans_actions[] = {\n+        0, 0, 0, 0, 1, 0, 2, 0,\n+        2, 2, 3, 4, 4, 5, 5, 4,\n+        4, 3, 3, 3, 0, 0, 6, 3,\n+        4, 4, 5, 5, 5, 3, 4, 4,\n+        5, 5, 7, 8, 9, 7, 7, 0,\n+        0, 0, 10, 10, 10, 8, 12, 13,\n+        14, 14, 14, 15, 11, 11, 17, 18,\n+        18, 18, 0, 16, 16, 19, 20, 19,\n+        19, 0, 0, 13, 10, 21, 21, 10,\n+        22, 23, 22, 22, 5, 24, 24, 24\n@@ -123,1 +389,1 @@\n-static const signed char _deserialize_text_index_defaults[] = {\n+static const char _deserialize_text_eof_actions[] = {\n@@ -126,45 +392,3 @@\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 62, 38, 0, 0, 62, 0, 0,\n-        0, 0, 0, 0, 0, 0\n-};\n-\n-static const signed char _deserialize_text_cond_targs[] = {\n-        0, 1, 2, 25, 3, 3, 4, 19,\n-        5, 6, 23, 24, 7, 8, 27, 36,\n-        8, 27, 36, 9, 30, 33, 10, 11,\n-        12, 15, 11, 12, 15, 13, 13, 14,\n-        31, 32, 14, 31, 32, 16, 26, 17,\n-        18, 34, 35, 18, 34, 35, 19, 20,\n-        19, 6, 21, 22, 20, 21, 22, 23,\n-        20, 21, 22, 24, 24, 25, 26, 26,\n-        7, 9, 10, 16, 21, 29, 26, 26,\n-        7, 9, 10, 21, 29, 27, 28, 17,\n-        21, 29, 28, 29, 29, 30, 28, 7,\n-        10, 29, 31, 28, 7, 21, 29, 32,\n-        33, 33, 34, 28, 21, 29, 35, 36,\n-        0\n-};\n-\n-static const signed char _deserialize_text_cond_actions[] = {\n-        0, 0, 0, 0, 1, 0, 0, 2,\n-        0, 0, 2, 2, 0, 3, 4, 4,\n-        0, 5, 5, 0, 4, 4, 0, 3,\n-        3, 3, 0, 0, 0, 6, 0, 3,\n-        4, 4, 0, 5, 5, 0, 5, 0,\n-        3, 4, 4, 0, 5, 5, 7, 7,\n-        8, 9, 7, 7, 0, 0, 0, 10,\n-        10, 10, 10, 10, 8, 11, 12, 13,\n-        14, 14, 14, 15, 11, 11, 16, 17,\n-        18, 18, 18, 16, 16, 19, 19, 20,\n-        19, 19, 0, 0, 13, 10, 10, 21,\n-        21, 10, 22, 22, 23, 22, 22, 22,\n-        10, 5, 24, 24, 24, 24, 24, 19,\n-        0\n-};\n-\n-static const signed char _deserialize_text_eof_trans[] = {\n-        1, 2, 3, 6, 7, 9, 10, 13,\n-        17, 20, 23, 27, 28, 31, 35, 29,\n-        38, 40, 44, 47, 53, 54, 55, 56,\n-        60, 62, 71, 78, 83, 70, 86, 91,\n-        96, 97, 99, 103, 104, 0\n+        0, 0, 0, 7, 0, 0, 0, 10,\n+        10, 11, 16, 19, 0, 11, 10, 22,\n+        22, 10, 24, 24, 19\n@@ -185,4 +409,4 @@\n-const char *buf,\n-unsigned int buf_len,\n-const char **end_ptr,\n-hb_font_t *font)\n+                                    const char *buf,\n+                                    unsigned int buf_len,\n+                                    const char **end_ptr,\n+                                    hb_font_t *font)\n@@ -190,1 +414,1 @@\n-        const char *p = buf, *pe = buf + buf_len;\n+  const char *p = buf, *pe = buf + buf_len;\n@@ -192,2 +416,2 @@\n-        \/* Ensure we have positions. *\/\n-        (void) hb_buffer_get_glyph_positions (buffer, nullptr);\n+  \/* Ensure we have positions. *\/\n+  (void) hb_buffer_get_glyph_positions (buffer, nullptr);\n@@ -195,2 +419,2 @@\n-        while (p < pe && ISSPACE (*p))\n-        p++;\n+  while (p < pe && ISSPACE (*p))\n+    p++;\n@@ -198,4 +422,4 @@\n-        const char *eof = pe, *tok = nullptr;\n-        int cs;\n-        hb_glyph_info_t info = {0};\n-        hb_glyph_position_t pos = {0};\n+  const char *eof = pe, *tok = nullptr;\n+  int cs;\n+  hb_glyph_info_t info = {0};\n+  hb_glyph_position_t pos = {0};\n@@ -203,1 +427,1 @@\n-#line 204 \"hb-buffer-deserialize-text.hh\"\n+#line 428 \"hb-buffer-deserialize-text.hh\"\n@@ -205,1 +429,1 @@\n-                cs = (int)deserialize_text_start;\n+        cs = deserialize_text_start;\n@@ -208,37 +432,26 @@\n-#line 209 \"hb-buffer-deserialize-text.hh\"\n-        {\n-                unsigned int _trans = 0;\n-                const unsigned char * _keys;\n-                const signed char * _inds;\n-                int _ic;\n-                _resume: {}\n-                if ( p == pe && p != eof )\n-                        goto _out;\n-                if ( p == eof ) {\n-                        if ( _deserialize_text_eof_trans[cs] > 0 ) {\n-                                _trans = (unsigned int)_deserialize_text_eof_trans[cs] - 1;\n-                        }\n-                }\n-                else {\n-                        _keys = ( _deserialize_text_trans_keys + ((cs<<1)));\n-                        _inds = ( _deserialize_text_indicies + (_deserialize_text_index_offsets[cs]));\n-\n-                        if ( ( (*( p))) <= 124 && ( (*( p))) >= 9 ) {\n-                                _ic = (int)_deserialize_text_char_class[(int)( (*( p))) - 9];\n-                                if ( _ic <= (int)(*( _keys+1)) && _ic >= (int)(*( _keys)) )\n-                                        _trans = (unsigned int)(*( _inds + (int)( _ic - (int)(*( _keys)) ) ));\n-                                else\n-                                        _trans = (unsigned int)_deserialize_text_index_defaults[cs];\n-                        }\n-                        else {\n-                                _trans = (unsigned int)_deserialize_text_index_defaults[cs];\n-                        }\n-\n-                }\n-                cs = (int)_deserialize_text_cond_targs[_trans];\n-\n-                if ( _deserialize_text_cond_actions[_trans] != 0 ) {\n-\n-                        switch ( _deserialize_text_cond_actions[_trans] ) {\n-                                case 1:  {\n-                                        {\n+#line 433 \"hb-buffer-deserialize-text.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+        if ( cs == 0 )\n+                goto _out;\n+_resume:\n+        _keys = _deserialize_text_trans_keys + (cs<<1);\n+        _inds = _deserialize_text_indicies + _deserialize_text_index_offsets[cs];\n+\n+        _slen = _deserialize_text_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=(*p) &&\n+                (*p) <= _keys[1] ?\n+                (*p) - _keys[0] : _slen ];\n+\n+        cs = _deserialize_text_trans_targs[_trans];\n+\n+        if ( _deserialize_text_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _deserialize_text_trans_actions[_trans] ) {\n+        case 1:\n@@ -246,12 +459,6 @@\n-\n-                                                memset (&info, 0, sizeof (info));\n-                                                memset (&pos , 0, sizeof (pos ));\n-                                        }\n-\n-#line 252 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 3:  {\n-                                        {\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n+        break;\n+        case 3:\n@@ -259,11 +466,5 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 264 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 5:  {\n-                                        {\n+        {\n+        tok = p;\n+}\n+        break;\n+        case 5:\n@@ -271,9 +472,3 @@\n-                                                if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-\n-#line 274 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 8:  {\n-                                        {\n+        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n+        break;\n+        case 8:\n@@ -281,9 +476,3 @@\n-                                                if (unlikely (!buffer->ensure_unicode ())) return false; }\n-\n-#line 284 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 18:  {\n-                                        {\n+        { if (unlikely (!buffer->ensure_unicode ())) return false; }\n+        break;\n+        case 18:\n@@ -291,15 +480,9 @@\n-\n-                                                \/* TODO Unescape delimeters. *\/\n-                                                if (!hb_font_glyph_from_string (font,\n-                                                tok, p - tok,\n-                                                &info.codepoint))\n-                                                return false;\n-                                        }\n-\n-#line 300 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 9:  {\n-                                        {\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+        break;\n+        case 9:\n@@ -307,9 +490,3 @@\n-                                                if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-\n-#line 310 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 21:  {\n-                                        {\n+        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n+        break;\n+        case 21:\n@@ -317,9 +494,3 @@\n-                                                if (!parse_uint (tok, p, &info.cluster )) return false; }\n-\n-#line 320 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 6:  {\n-                                        {\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+        break;\n+        case 6:\n@@ -327,9 +498,3 @@\n-                                                if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n-\n-#line 330 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 23:  {\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n+        break;\n+        case 23:\n@@ -337,9 +502,3 @@\n-                                                if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-\n-#line 340 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 20:  {\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+        break;\n+        case 20:\n@@ -347,9 +506,3 @@\n-                                                if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-\n-#line 350 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 15:  {\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+        break;\n+        case 15:\n@@ -357,8 +510,4 @@\n-\n-                                                memset (&info, 0, sizeof (info));\n-                                                memset (&pos , 0, sizeof (pos ));\n-                                        }\n-\n-#line 363 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n@@ -366,11 +515,5 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 371 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 4:  {\n-                                        {\n+        {\n+        tok = p;\n+}\n+        break;\n+        case 4:\n@@ -378,7 +521,3 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 383 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        tok = p;\n+}\n@@ -386,9 +525,3 @@\n-                                                if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-\n-#line 389 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 2:  {\n-                                        {\n+        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n+        break;\n+        case 2:\n@@ -396,7 +529,3 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 401 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        tok = p;\n+}\n@@ -404,9 +533,3 @@\n-                                                if (unlikely (!buffer->ensure_unicode ())) return false; }\n-\n-#line 407 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 16:  {\n-                                        {\n+        { if (unlikely (!buffer->ensure_unicode ())) return false; }\n+        break;\n+        case 16:\n@@ -414,11 +537,7 @@\n-\n-                                                \/* TODO Unescape delimeters. *\/\n-                                                if (!hb_font_glyph_from_string (font,\n-                                                tok, p - tok,\n-                                                &info.codepoint))\n-                                                return false;\n-                                        }\n-\n-#line 423 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n@@ -426,15 +545,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 435 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 7:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 7:\n@@ -442,5 +555,1 @@\n-                                                if (!parse_hex (tok, p, &info.codepoint )) return false; }\n-\n-#line 445 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n@@ -448,15 +557,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 457 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 10:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 10:\n@@ -464,5 +567,1 @@\n-                                                if (!parse_uint (tok, p, &info.cluster )) return false; }\n-\n-#line 467 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n@@ -470,15 +569,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 479 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 22:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 22:\n@@ -486,5 +579,1 @@\n-                                                if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n-\n-#line 489 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n@@ -492,15 +581,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 501 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 19:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 19:\n@@ -508,5 +591,1 @@\n-                                                if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n-\n-#line 511 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n@@ -514,15 +593,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 523 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 24:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 24:\n@@ -530,5 +603,1 @@\n-                                                if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n-\n-#line 533 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n@@ -536,15 +605,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 545 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 12:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 12:\n@@ -552,8 +615,4 @@\n-\n-                                                memset (&info, 0, sizeof (info));\n-                                                memset (&pos , 0, sizeof (pos ));\n-                                        }\n-\n-#line 558 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n@@ -561,7 +620,3 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 566 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        tok = p;\n+}\n@@ -569,9 +624,3 @@\n-                                                if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-\n-#line 572 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 14:  {\n-                                        {\n+        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n+        break;\n+        case 14:\n@@ -579,8 +628,4 @@\n-\n-                                                memset (&info, 0, sizeof (info));\n-                                                memset (&pos , 0, sizeof (pos ));\n-                                        }\n-\n-#line 585 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n@@ -588,7 +633,3 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 593 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        tok = p;\n+}\n@@ -596,15 +637,9 @@\n-\n-                                                \/* TODO Unescape delimeters. *\/\n-                                                if (!hb_font_glyph_from_string (font,\n-                                                tok, p - tok,\n-                                                &info.codepoint))\n-                                                return false;\n-                                        }\n-\n-#line 605 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 17:  {\n-                                        {\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+        break;\n+        case 17:\n@@ -612,11 +647,7 @@\n-\n-                                                \/* TODO Unescape delimeters. *\/\n-                                                if (!hb_font_glyph_from_string (font,\n-                                                tok, p - tok,\n-                                                &info.codepoint))\n-                                                return false;\n-                                        }\n-\n-#line 621 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n@@ -624,5 +655,1 @@\n-                                                if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-\n-#line 627 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n@@ -630,15 +657,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 639 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 11:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 11:\n@@ -646,8 +667,4 @@\n-\n-                                                memset (&info, 0, sizeof (info));\n-                                                memset (&pos , 0, sizeof (pos ));\n-                                        }\n-\n-#line 652 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n@@ -655,7 +672,3 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 660 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        tok = p;\n+}\n@@ -663,11 +676,7 @@\n-\n-                                                \/* TODO Unescape delimeters. *\/\n-                                                if (!hb_font_glyph_from_string (font,\n-                                                tok, p - tok,\n-                                                &info.codepoint))\n-                                                return false;\n-                                        }\n-\n-#line 672 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n@@ -675,15 +684,9 @@\n-\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 684 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 13:  {\n-                                        {\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 13:\n@@ -691,8 +694,4 @@\n-\n-                                                memset (&info, 0, sizeof (info));\n-                                                memset (&pos , 0, sizeof (pos ));\n-                                        }\n-\n-#line 697 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n@@ -700,7 +699,3 @@\n-\n-                                                tok = p;\n-                                        }\n-\n-#line 705 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        tok = p;\n+}\n@@ -708,11 +703,7 @@\n-\n-                                                \/* TODO Unescape delimeters. *\/\n-                                                if (!hb_font_glyph_from_string (font,\n-                                                tok, p - tok,\n-                                                &info.codepoint))\n-                                                return false;\n-                                        }\n-\n-#line 717 \"hb-buffer-deserialize-text.hh\"\n-\n-                                        {\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n@@ -720,3 +711,12 @@\n-                                                if (unlikely (!buffer->ensure_glyphs ())) return false; }\n-\n-#line 723 \"hb-buffer-deserialize-text.hh\"\n+        { if (unlikely (!buffer->ensure_glyphs ())) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 722 \"hb-buffer-deserialize-text.hh\"\n+        }\n@@ -724,1 +724,30 @@\n-                                        {\n+_again:\n+        if ( cs == 0 )\n+                goto _out;\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        switch ( _deserialize_text_eof_actions[cs] ) {\n+        case 16:\n+#line 58 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 7:\n+#line 66 \"hb-buffer-deserialize-text.rl\"\n+        {if (!parse_hex (tok, p, &info.codepoint )) return false; }\n@@ -726,0 +755,86 @@\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 10:\n+#line 68 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 22:\n+#line 70 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 19:\n+#line 71 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 24:\n+#line 72 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 11:\n+#line 38 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n+#line 51 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        tok = p;\n+}\n+#line 58 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        \/* TODO Unescape delimiters. *\/\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 839 \"hb-buffer-deserialize-text.hh\"\n+        }\n+        }\n@@ -727,27 +842,1 @@\n-                                                buffer->add_info (info);\n-                                                if (unlikely (!buffer->successful))\n-                                                return false;\n-                                                buffer->pos[buffer->len - 1] = pos;\n-                                                *end_ptr = p;\n-                                        }\n-\n-#line 735 \"hb-buffer-deserialize-text.hh\"\n-\n-\n-                                        break;\n-                                }\n-                        }\n-\n-                }\n-\n-                if ( p == eof ) {\n-                        if ( cs >= 19 )\n-                                goto _out;\n-                }\n-                else {\n-                        if ( cs != 0 ) {\n-                                p += 1;\n-                                goto _resume;\n-                        }\n-                }\n-                _out: {}\n+        _out: {}\n@@ -759,1 +848,1 @@\n-        *end_ptr = p;\n+  *end_ptr = p;\n@@ -761,1 +850,1 @@\n-        return p == pe && *(p-1) != ']';\n+  return p == pe && *(p-1) != ']';\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-deserialize-text.hh","additions":749,"deletions":660,"binary":false,"changes":1409,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-static const char *serialize_formats[] = {\n+static const char *_hb_buffer_serialize_formats[] = {\n@@ -53,1 +53,1 @@\n-  return serialize_formats;\n+  return _hb_buffer_serialize_formats;\n@@ -94,2 +94,2 @@\n-    case HB_BUFFER_SERIALIZE_FORMAT_TEXT: return serialize_formats[0];\n-    case HB_BUFFER_SERIALIZE_FORMAT_JSON: return serialize_formats[1];\n+    case HB_BUFFER_SERIALIZE_FORMAT_TEXT: return _hb_buffer_serialize_formats[0];\n+    case HB_BUFFER_SERIALIZE_FORMAT_JSON: return _hb_buffer_serialize_formats[1];\n@@ -403,1 +403,1 @@\n- * @buf_consumed: (out) (optional): if not %NULL, will be set to the number of byes written into @buf.\n+ * @buf_consumed: (out) (optional): if not %NULL, will be set to the number of bytes written into @buf.\n@@ -405,1 +405,1 @@\n- *        read glyph names and extents. If %NULL, and empty font will be used.\n+ *        read glyph names and extents. If %NULL, an empty font will be used.\n@@ -517,1 +517,1 @@\n- * @buf_consumed: (out) (optional): if not %NULL, will be set to the number of byes written into @buf.\n+ * @buf_consumed: (out) (optional): if not %NULL, will be set to the number of bytes written into @buf.\n@@ -640,1 +640,1 @@\n- * @buf_consumed: (out) (optional): if not %NULL, will be set to the number of byes written into @buf.\n+ * @buf_consumed: (out) (optional): if not %NULL, will be set to the number of bytes written into @buf.\n@@ -642,1 +642,1 @@\n- *        read glyph names and extents. If %NULL, and empty font will be used.\n+ *        read glyph names and extents. If %NULL, an empty font will be used.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-serialize.cc","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,440 @@\n+\/*\n+ * Copyright  2022  Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_BUFFER_VERIFY\n+\n+#include \"hb-buffer.hh\"\n+\n+\n+#define BUFFER_VERIFY_ERROR \"buffer verify error: \"\n+static inline void\n+buffer_verify_error (hb_buffer_t *buffer,\n+                     hb_font_t *font,\n+                     const char *fmt,\n+                     ...) HB_PRINTF_FUNC(3, 4);\n+\n+static inline void\n+buffer_verify_error (hb_buffer_t *buffer,\n+                     hb_font_t *font,\n+                     const char *fmt,\n+                     ...)\n+{\n+  va_list ap;\n+  va_start (ap, fmt);\n+  if (buffer->messaging ())\n+  {\n+    buffer->message_impl (font, fmt, ap);\n+  }\n+  else\n+  {\n+    fprintf (stderr, \"harfbuzz \");\n+    vfprintf (stderr, fmt, ap);\n+    fprintf (stderr, \"\\n\");\n+  }\n+  va_end (ap);\n+}\n+\n+static bool\n+buffer_verify_monotone (hb_buffer_t *buffer,\n+                        hb_font_t   *font)\n+{\n+  \/* Check that clusters are monotone. *\/\n+  if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES ||\n+      buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)\n+  {\n+    bool is_forward = HB_DIRECTION_IS_FORWARD (hb_buffer_get_direction (buffer));\n+\n+    unsigned int num_glyphs;\n+    hb_glyph_info_t *info = hb_buffer_get_glyph_infos (buffer, &num_glyphs);\n+\n+    for (unsigned int i = 1; i < num_glyphs; i++)\n+      if (info[i-1].cluster != info[i].cluster &&\n+          (info[i-1].cluster < info[i].cluster) != is_forward)\n+      {\n+        buffer_verify_error (buffer, font, BUFFER_VERIFY_ERROR \"clusters are not monotone.\");\n+        return false;\n+      }\n+  }\n+\n+  return true;\n+}\n+\n+static bool\n+buffer_verify_unsafe_to_break (hb_buffer_t  *buffer,\n+                               hb_buffer_t  *text_buffer,\n+                               hb_font_t          *font,\n+                               const hb_feature_t *features,\n+                               unsigned int        num_features,\n+                               const char * const *shapers)\n+{\n+  if (buffer->cluster_level != HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES &&\n+      buffer->cluster_level != HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)\n+  {\n+    \/* Cannot perform this check without monotone clusters. *\/\n+    return true;\n+  }\n+\n+  \/* Check that breaking up shaping at safe-to-break is indeed safe. *\/\n+\n+  hb_buffer_t *fragment = hb_buffer_create_similar (buffer);\n+  hb_buffer_set_flags (fragment, (hb_buffer_flags_t (hb_buffer_get_flags (fragment) & ~HB_BUFFER_FLAG_VERIFY)));\n+  hb_buffer_t *reconstruction = hb_buffer_create_similar (buffer);\n+  hb_buffer_set_flags (reconstruction, (hb_buffer_flags_t (hb_buffer_get_flags (reconstruction) & ~HB_BUFFER_FLAG_VERIFY)));\n+\n+  unsigned int num_glyphs;\n+  hb_glyph_info_t *info = hb_buffer_get_glyph_infos (buffer, &num_glyphs);\n+\n+  unsigned int num_chars;\n+  hb_glyph_info_t *text = hb_buffer_get_glyph_infos (text_buffer, &num_chars);\n+\n+  \/* Chop text and shape fragments. *\/\n+  bool forward = HB_DIRECTION_IS_FORWARD (hb_buffer_get_direction (buffer));\n+  unsigned int start = 0;\n+  unsigned int text_start = forward ? 0 : num_chars;\n+  unsigned int text_end = text_start;\n+  for (unsigned int end = 1; end < num_glyphs + 1; end++)\n+  {\n+    if (end < num_glyphs &&\n+        (info[end].cluster == info[end-1].cluster ||\n+         info[end-(forward?0:1)].mask & HB_GLYPH_FLAG_UNSAFE_TO_BREAK))\n+        continue;\n+\n+    \/* Shape segment corresponding to glyphs start..end. *\/\n+    if (end == num_glyphs)\n+    {\n+      if (forward)\n+        text_end = num_chars;\n+      else\n+        text_start = 0;\n+    }\n+    else\n+    {\n+      if (forward)\n+      {\n+        unsigned int cluster = info[end].cluster;\n+        while (text_end < num_chars && text[text_end].cluster < cluster)\n+          text_end++;\n+      }\n+      else\n+      {\n+        unsigned int cluster = info[end - 1].cluster;\n+        while (text_start && text[text_start - 1].cluster >= cluster)\n+          text_start--;\n+      }\n+    }\n+    assert (text_start < text_end);\n+\n+    if (0)\n+      printf(\"start %d end %d text start %d end %d\\n\", start, end, text_start, text_end);\n+\n+    hb_buffer_clear_contents (fragment);\n+\n+    hb_buffer_flags_t flags = hb_buffer_get_flags (fragment);\n+    if (0 < text_start)\n+      flags = (hb_buffer_flags_t) (flags & ~HB_BUFFER_FLAG_BOT);\n+    if (text_end < num_chars)\n+      flags = (hb_buffer_flags_t) (flags & ~HB_BUFFER_FLAG_EOT);\n+    hb_buffer_set_flags (fragment, flags);\n+\n+    hb_buffer_append (fragment, text_buffer, text_start, text_end);\n+    if (!hb_shape_full (font, fragment, features, num_features, shapers))\n+    {\n+      buffer_verify_error (buffer, font, BUFFER_VERIFY_ERROR \"shaping failed while shaping fragment.\");\n+      hb_buffer_destroy (reconstruction);\n+      hb_buffer_destroy (fragment);\n+      return false;\n+    }\n+    else if (!fragment->successful || fragment->shaping_failed)\n+    {\n+      hb_buffer_destroy (reconstruction);\n+      hb_buffer_destroy (fragment);\n+      return true;\n+    }\n+    hb_buffer_append (reconstruction, fragment, 0, -1);\n+\n+    start = end;\n+    if (forward)\n+      text_start = text_end;\n+    else\n+      text_end = text_start;\n+  }\n+\n+  bool ret = true;\n+  hb_buffer_diff_flags_t diff = hb_buffer_diff (reconstruction, buffer, (hb_codepoint_t) -1, 0);\n+  if (diff)\n+  {\n+    buffer_verify_error (buffer, font, BUFFER_VERIFY_ERROR \"unsafe-to-break test failed.\");\n+    ret = false;\n+\n+    \/* Return the reconstructed result instead so it can be inspected. *\/\n+    hb_buffer_set_length (buffer, 0);\n+    hb_buffer_append (buffer, reconstruction, 0, -1);\n+  }\n+\n+  hb_buffer_destroy (reconstruction);\n+  hb_buffer_destroy (fragment);\n+\n+  return ret;\n+}\n+\n+static bool\n+buffer_verify_unsafe_to_concat (hb_buffer_t        *buffer,\n+                                hb_buffer_t        *text_buffer,\n+                                hb_font_t          *font,\n+                                const hb_feature_t *features,\n+                                unsigned int        num_features,\n+                                const char * const *shapers)\n+{\n+  if (buffer->cluster_level != HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES &&\n+      buffer->cluster_level != HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)\n+  {\n+    \/* Cannot perform this check without monotone clusters. *\/\n+    return true;\n+  }\n+\n+  \/* Check that shuffling up text before shaping at safe-to-concat points\n+   * is indeed safe. *\/\n+\n+  \/* This is what we do:\n+   *\n+   * 1. We shape text once. Then segment the text at all the safe-to-concat\n+   *    points;\n+   *\n+   * 2. Then we create two buffers, one containing all the even segments and\n+   *    one all the odd segments.\n+   *\n+   * 3. Because all these segments were safe-to-concat at both ends, we\n+   *    expect that concatenating them and shaping should NOT change the\n+   *    shaping results of each segment.  As such, we expect that after\n+   *    shaping the two buffers, we still get cluster boundaries at the\n+   *    segment boundaries, and that those all are safe-to-concat points.\n+   *    Moreover, that there are NOT any safe-to-concat points within the\n+   *    segments.\n+   *\n+   * 4. Finally, we reconstruct the shaping results of the original text by\n+   *    simply interleaving the shaping results of the segments from the two\n+   *    buffers, and assert that the total shaping results is the same as\n+   *    the one from original buffer in step 1.\n+   *\/\n+\n+  hb_buffer_t *fragments[2] {hb_buffer_create_similar (buffer),\n+                             hb_buffer_create_similar (buffer)};\n+  hb_buffer_set_flags (fragments[0], (hb_buffer_flags_t (hb_buffer_get_flags (fragments[0]) & ~HB_BUFFER_FLAG_VERIFY)));\n+  hb_buffer_set_flags (fragments[1], (hb_buffer_flags_t (hb_buffer_get_flags (fragments[1]) & ~HB_BUFFER_FLAG_VERIFY)));\n+  hb_buffer_t *reconstruction = hb_buffer_create_similar (buffer);\n+  hb_buffer_set_flags (reconstruction, (hb_buffer_flags_t (hb_buffer_get_flags (reconstruction) & ~HB_BUFFER_FLAG_VERIFY)));\n+  hb_segment_properties_t props;\n+  hb_buffer_get_segment_properties (buffer, &props);\n+  hb_buffer_set_segment_properties (fragments[0], &props);\n+  hb_buffer_set_segment_properties (fragments[1], &props);\n+  hb_buffer_set_segment_properties (reconstruction, &props);\n+\n+  unsigned num_glyphs;\n+  hb_glyph_info_t *info = hb_buffer_get_glyph_infos (buffer, &num_glyphs);\n+\n+  unsigned num_chars;\n+  hb_glyph_info_t *text = hb_buffer_get_glyph_infos (text_buffer, &num_chars);\n+\n+  bool forward = HB_DIRECTION_IS_FORWARD (hb_buffer_get_direction (buffer));\n+\n+  if (!forward)\n+    hb_buffer_reverse (buffer);\n+\n+  \/*\n+   * Split text into segments and collect into to fragment streams.\n+   *\/\n+  {\n+    unsigned fragment_idx = 0;\n+    unsigned start = 0;\n+    unsigned text_start = 0;\n+    unsigned text_end = 0;\n+    for (unsigned end = 1; end < num_glyphs + 1; end++)\n+    {\n+      if (end < num_glyphs &&\n+          (info[end].cluster == info[end-1].cluster ||\n+           info[end].mask & HB_GLYPH_FLAG_UNSAFE_TO_CONCAT))\n+          continue;\n+\n+      \/* Accumulate segment corresponding to glyphs start..end. *\/\n+      if (end == num_glyphs)\n+        text_end = num_chars;\n+      else\n+      {\n+        unsigned cluster = info[end].cluster;\n+        while (text_end < num_chars && text[text_end].cluster < cluster)\n+          text_end++;\n+      }\n+      assert (text_start < text_end);\n+\n+      if (0)\n+        printf(\"start %d end %d text start %d end %d\\n\", start, end, text_start, text_end);\n+\n+#if 0\n+      hb_buffer_flags_t flags = hb_buffer_get_flags (fragment);\n+      if (0 < text_start)\n+        flags = (hb_buffer_flags_t) (flags & ~HB_BUFFER_FLAG_BOT);\n+      if (text_end < num_chars)\n+        flags = (hb_buffer_flags_t) (flags & ~HB_BUFFER_FLAG_EOT);\n+      hb_buffer_set_flags (fragment, flags);\n+#endif\n+\n+      hb_buffer_append (fragments[fragment_idx], text_buffer, text_start, text_end);\n+\n+      start = end;\n+      text_start = text_end;\n+      fragment_idx = 1 - fragment_idx;\n+    }\n+  }\n+\n+  bool ret = true;\n+  hb_buffer_diff_flags_t diff;\n+\n+  \/*\n+   * Shape the two fragment streams.\n+   *\/\n+  if (!hb_shape_full (font, fragments[0], features, num_features, shapers))\n+  {\n+    buffer_verify_error (buffer, font, BUFFER_VERIFY_ERROR \"shaping failed while shaping fragment.\");\n+    ret = false;\n+    goto out;\n+  }\n+  else if (!fragments[0]->successful || fragments[0]->shaping_failed)\n+  {\n+    ret = true;\n+    goto out;\n+  }\n+  if (!hb_shape_full (font, fragments[1], features, num_features, shapers))\n+  {\n+    buffer_verify_error (buffer, font, BUFFER_VERIFY_ERROR \"shaping failed while shaping fragment.\");\n+    ret = false;\n+    goto out;\n+  }\n+  else if (!fragments[1]->successful || fragments[1]->shaping_failed)\n+  {\n+    ret = true;\n+    goto out;\n+  }\n+\n+  if (!forward)\n+  {\n+    hb_buffer_reverse (fragments[0]);\n+    hb_buffer_reverse (fragments[1]);\n+  }\n+\n+  \/*\n+   * Reconstruct results.\n+   *\/\n+  {\n+    unsigned fragment_idx = 0;\n+    unsigned fragment_start[2] {0, 0};\n+    unsigned fragment_num_glyphs[2];\n+    hb_glyph_info_t *fragment_info[2];\n+    for (unsigned i = 0; i < 2; i++)\n+      fragment_info[i] = hb_buffer_get_glyph_infos (fragments[i], &fragment_num_glyphs[i]);\n+    while (fragment_start[0] < fragment_num_glyphs[0] ||\n+           fragment_start[1] < fragment_num_glyphs[1])\n+    {\n+      unsigned fragment_end = fragment_start[fragment_idx] + 1;\n+      while (fragment_end < fragment_num_glyphs[fragment_idx] &&\n+             (fragment_info[fragment_idx][fragment_end].cluster == fragment_info[fragment_idx][fragment_end - 1].cluster ||\n+              fragment_info[fragment_idx][fragment_end].mask & HB_GLYPH_FLAG_UNSAFE_TO_CONCAT))\n+        fragment_end++;\n+\n+      hb_buffer_append (reconstruction, fragments[fragment_idx], fragment_start[fragment_idx], fragment_end);\n+\n+      fragment_start[fragment_idx] = fragment_end;\n+      fragment_idx = 1 - fragment_idx;\n+    }\n+  }\n+\n+  if (!forward)\n+  {\n+    hb_buffer_reverse (buffer);\n+    hb_buffer_reverse (reconstruction);\n+  }\n+\n+  \/*\n+   * Diff results.\n+   *\/\n+  diff = hb_buffer_diff (reconstruction, buffer, (hb_codepoint_t) -1, 0);\n+  if (diff)\n+  {\n+    buffer_verify_error (buffer, font, BUFFER_VERIFY_ERROR \"unsafe-to-concat test failed.\");\n+    ret = false;\n+\n+    \/* Return the reconstructed result instead so it can be inspected. *\/\n+    hb_buffer_set_length (buffer, 0);\n+    hb_buffer_append (buffer, reconstruction, 0, -1);\n+  }\n+\n+\n+out:\n+  hb_buffer_destroy (reconstruction);\n+  hb_buffer_destroy (fragments[0]);\n+  hb_buffer_destroy (fragments[1]);\n+\n+  return ret;\n+}\n+\n+bool\n+hb_buffer_t::verify (hb_buffer_t        *text_buffer,\n+                     hb_font_t          *font,\n+                     const hb_feature_t *features,\n+                     unsigned int        num_features,\n+                     const char * const *shapers)\n+{\n+  bool ret = true;\n+  if (!buffer_verify_monotone (this, font))\n+    ret = false;\n+  if (!buffer_verify_unsafe_to_break (this, text_buffer, font, features, num_features, shapers))\n+    ret = false;\n+  if ((flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT) != 0 &&\n+      !buffer_verify_unsafe_to_concat (this, text_buffer, font, features, num_features, shapers))\n+    ret = false;\n+  if (!ret)\n+  {\n+#ifndef HB_NO_BUFFER_SERIALIZE\n+    unsigned len = text_buffer->len;\n+    hb_vector_t<char> bytes;\n+    if (likely (bytes.resize (len * 10 + 16)))\n+    {\n+      hb_buffer_serialize_unicode (text_buffer,\n+                                   0, len,\n+                                   bytes.arrayZ, bytes.length,\n+                                   &len,\n+                                   HB_BUFFER_SERIALIZE_FORMAT_TEXT,\n+                                   HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS);\n+      buffer_verify_error (this, font, BUFFER_VERIFY_ERROR \"text was: %s.\", bytes.arrayZ);\n+    }\n+#endif\n+  }\n+  return ret;\n+}\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer-verify.cc","additions":440,"deletions":0,"binary":false,"changes":440,"status":"added"},{"patch":"@@ -84,2 +84,2 @@\n-  return (unsigned int) p->direction ^\n-         (unsigned int) p->script ^\n+  return ((unsigned int) p->direction * 31 +\n+          (unsigned int) p->script) * 31 +\n@@ -89,0 +89,27 @@\n+\/**\n+ * hb_segment_properties_overlay:\n+ * @p: #hb_segment_properties_t to fill in.\n+ * @src: #hb_segment_properties_t to fill in from.\n+ *\n+ * Fills in missing fields of @p from @src in a considered manner.\n+ *\n+ * First, if @p does not have direction set, direction is copied from @src.\n+ *\n+ * Next, if @p and @src have the same direction (which can be unset), if @p\n+ * does not have script set, script is copied from @src.\n+ *\n+ * Finally, if @p and @src have the same direction and script (which either\n+ * can be unset), if @p does not have language set, language is copied from\n+ * @src.\n+ *\n+ * Since: 3.3.0\n+ **\/\n+void\n+hb_segment_properties_overlay (hb_segment_properties_t *p,\n+                               const hb_segment_properties_t *src)\n+{\n+  if (unlikely (!p || !src))\n+    return;\n+\n+  if (!p->direction)\n+    p->direction = src->direction;\n@@ -90,0 +117,12 @@\n+  if (p->direction != src->direction)\n+    return;\n+\n+  if (!p->script)\n+    p->script = src->script;\n+\n+  if (p->script != src->script)\n+    return;\n+\n+  if (!p->language)\n+    p->language = src->language;\n+}\n@@ -99,2 +138,2 @@\n- * In that case, swap_buffers() is no-op and the glyph operations operate\n- * mostly in-place.\n+ * In that case, sync() is mostly no-op and the glyph operations\n+ * operate mostly in-place.\n@@ -103,1 +142,1 @@\n- * to an alternate buffer (which we reuse the pos buffer for!), and its\n+ * to an alternate buffer (which we reuse the pos buffer for), and its\n@@ -105,2 +144,3 @@\n- * This should all remain transparent to the user.  swap_buffers() then\n- * switches info and out_info.\n+ *\n+ * This should all remain transparent to the user.  sync() then\n+ * switches info over to out_info and does housekeeping.\n@@ -139,2 +179,2 @@\n-  new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));\n-  new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));\n+  new_pos = (hb_glyph_position_t *) hb_realloc (pos, new_allocated * sizeof (pos[0]));\n+  new_info = (hb_glyph_info_t *) hb_realloc (info, new_allocated * sizeof (info[0]));\n@@ -218,0 +258,12 @@\n+void\n+hb_buffer_t::similar (const hb_buffer_t &src)\n+{\n+  hb_unicode_funcs_destroy (unicode);\n+  unicode = hb_unicode_funcs_reference (src.unicode);\n+  flags = src.flags;\n+  cluster_level = src.cluster_level;\n+  replacement = src.invisible;\n+  invisible = src.invisible;\n+  not_found = src.not_found;\n+}\n+\n@@ -224,0 +276,1 @@\n+  cluster_level = HB_BUFFER_CLUSTER_LEVEL_DEFAULT;\n@@ -226,0 +279,1 @@\n+  not_found = 0;\n@@ -233,0 +287,1 @@\n+  content_type = HB_BUFFER_CONTENT_TYPE_INVALID;\n@@ -235,1 +290,0 @@\n-  scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;\n@@ -237,1 +291,0 @@\n-  content_type = HB_BUFFER_CONTENT_TYPE_INVALID;\n@@ -239,0 +292,1 @@\n+  shaping_failed = false;\n@@ -247,2 +301,0 @@\n-  serial = 0;\n-\n@@ -253,0 +305,2 @@\n+  serial = 0;\n+  scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;\n@@ -255,0 +309,29 @@\n+void\n+hb_buffer_t::enter ()\n+{\n+  deallocate_var_all ();\n+  serial = 0;\n+  shaping_failed = false;\n+  scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;\n+  if (likely (!hb_unsigned_mul_overflows (len, HB_BUFFER_MAX_LEN_FACTOR)))\n+  {\n+    max_len = hb_max (len * HB_BUFFER_MAX_LEN_FACTOR,\n+                      (unsigned) HB_BUFFER_MAX_LEN_MIN);\n+  }\n+  if (likely (!hb_unsigned_mul_overflows (len, HB_BUFFER_MAX_OPS_FACTOR)))\n+  {\n+    max_ops = hb_max (len * HB_BUFFER_MAX_OPS_FACTOR,\n+                      (unsigned) HB_BUFFER_MAX_OPS_MIN);\n+  }\n+}\n+void\n+hb_buffer_t::leave ()\n+{\n+  max_len = HB_BUFFER_MAX_LEN_DEFAULT;\n+  max_ops = HB_BUFFER_MAX_OPS_DEFAULT;\n+  deallocate_var_all ();\n+  serial = 0;\n+  \/\/ Intentionally not reseting shaping_failed, such that it can be inspected.\n+}\n+\n+\n@@ -284,10 +367,0 @@\n-void\n-hb_buffer_t::remove_output ()\n-{\n-  have_output = false;\n-  have_positions = false;\n-\n-  out_len = 0;\n-  out_info = info;\n-}\n-\n@@ -300,0 +373,1 @@\n+  idx = 0;\n@@ -317,1 +391,1 @@\n-hb_buffer_t::swap_buffers ()\n+hb_buffer_t::sync ()\n@@ -319,1 +393,1 @@\n-  if (unlikely (!successful)) return;\n+  assert (have_output);\n@@ -322,1 +396,0 @@\n-  if (unlikely (!next_glyphs (len - idx))) return;\n@@ -324,2 +397,2 @@\n-  assert (have_output);\n-  have_output = false;\n+  if (unlikely (!successful || !next_glyphs (len - idx)))\n+    goto reset;\n@@ -329,2 +402,1 @@\n-    hb_glyph_info_t *tmp;\n-    tmp = info;\n+    pos = (hb_glyph_position_t *) info;\n@@ -332,3 +404,0 @@\n-    out_info = tmp;\n-\n-    pos = (hb_glyph_position_t *) out_info;\n@@ -336,3 +405,0 @@\n-\n-  unsigned int tmp;\n-  tmp = len;\n@@ -340,1 +406,0 @@\n-  out_len = tmp;\n@@ -342,0 +407,4 @@\n+reset:\n+  have_output = false;\n+  out_len = 0;\n+  out_info = info;\n@@ -376,1 +445,1 @@\n-     * We used to shift with extra 32 items, instead of the 0 below.\n+     * We used to shift with extra 32 items.\n@@ -378,4 +447,3 @@\n-     * failures.  Setting to zero for now to avoid other problems (see\n-     * comments in shift_forward().  This can cause O(N^2) behavior more\n-     * severely than adding 32 empty slots can... *\/\n-    if (unlikely (idx < count && !shift_forward (count + 0))) return false;\n+     * failures.  See comments in shift_forward().  This can cause O(N^2)\n+     * behavior more severely than adding 32 empty slots can... *\/\n+    if (unlikely (idx < count && !shift_forward (count - idx))) return false;\n@@ -412,46 +480,0 @@\n-void\n-hb_buffer_t::reverse_range (unsigned int start,\n-                            unsigned int end)\n-{\n-  if (end - start < 2)\n-    return;\n-\n-  hb_array_t<hb_glyph_info_t> (info, len).reverse (start, end);\n-\n-  if (have_positions) {\n-    hb_array_t<hb_glyph_position_t> (pos, len).reverse (start, end);\n-  }\n-}\n-\n-void\n-hb_buffer_t::reverse ()\n-{\n-  if (unlikely (!len))\n-    return;\n-\n-  reverse_range (0, len);\n-}\n-\n-void\n-hb_buffer_t::reverse_clusters ()\n-{\n-  unsigned int i, start, count, last_cluster;\n-\n-  if (unlikely (!len))\n-    return;\n-\n-  reverse ();\n-\n-  count = len;\n-  start = 0;\n-  last_cluster = info[0].cluster;\n-  for (i = 1; i < count; i++) {\n-    if (last_cluster != info[i].cluster) {\n-      reverse_range (start, i);\n-      start = i;\n-      last_cluster = info[i].cluster;\n-    }\n-  }\n-  reverse_range (start, i);\n-}\n-\n@@ -526,1 +548,2 @@\n-  if (idx + 1 < len && cluster == info[idx + 1].cluster)\n+  if ((idx + 1 < len && cluster == info[idx + 1].cluster) ||\n+      (out_len && cluster == out_info[out_len - 1].cluster))\n@@ -556,26 +579,0 @@\n-void\n-hb_buffer_t::unsafe_to_break_impl (unsigned int start, unsigned int end)\n-{\n-  unsigned int cluster = UINT_MAX;\n-  cluster = _unsafe_to_break_find_min_cluster (info, start, end, cluster);\n-  _unsafe_to_break_set_mask (info, start, end, cluster);\n-}\n-void\n-hb_buffer_t::unsafe_to_break_from_outbuffer (unsigned int start, unsigned int end)\n-{\n-  if (!have_output)\n-  {\n-    unsafe_to_break_impl (start, end);\n-    return;\n-  }\n-\n-  assert (start <= out_len);\n-  assert (idx <= end);\n-\n-  unsigned int cluster = UINT_MAX;\n-  cluster = _unsafe_to_break_find_min_cluster (out_info, start, out_len, cluster);\n-  cluster = _unsafe_to_break_find_min_cluster (info, idx, end, cluster);\n-  _unsafe_to_break_set_mask (out_info, start, out_len, cluster);\n-  _unsafe_to_break_set_mask (info, idx, end, cluster);\n-}\n-\n@@ -626,3 +623,2 @@\n-  HB_BUFFER_SCRATCH_FLAG_DEFAULT,\n-  HB_BUFFER_MAX_LEN_DEFAULT,\n-  HB_BUFFER_MAX_OPS_DEFAULT,\n+  0, \/* not_found *\/\n+\n@@ -632,0 +628,1 @@\n+\n@@ -633,1 +630,2 @@\n-  true, \/* have_output *\/\n+  true, \/* shaping_failed *\/\n+  false, \/* have_output *\/\n@@ -641,1 +639,1 @@\n- * hb_buffer_create: (Xconstructor)\n+ * hb_buffer_create:\n@@ -670,0 +668,40 @@\n+\/**\n+ * hb_buffer_create_similar:\n+ * @src: An #hb_buffer_t\n+ *\n+ * Creates a new #hb_buffer_t, similar to hb_buffer_create(). The only\n+ * difference is that the buffer is configured similarly to @src.\n+ *\n+ * Return value: (transfer full):\n+ * A newly allocated #hb_buffer_t, similar to hb_buffer_create().\n+ *\n+ * Since: 3.3.0\n+ **\/\n+hb_buffer_t *\n+hb_buffer_create_similar (const hb_buffer_t *src)\n+{\n+  hb_buffer_t *buffer = hb_buffer_create ();\n+\n+  buffer->similar (*src);\n+\n+  return buffer;\n+}\n+\n+\/**\n+ * hb_buffer_reset:\n+ * @buffer: An #hb_buffer_t\n+ *\n+ * Resets the buffer to its initial status, as if it was just newly created\n+ * with hb_buffer_create().\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_reset (hb_buffer_t *buffer)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  buffer->reset ();\n+}\n+\n@@ -720,2 +758,2 @@\n-  free (buffer->info);\n-  free (buffer->pos);\n+  hb_free (buffer->info);\n+  hb_free (buffer->pos);\n@@ -727,1 +765,1 @@\n-  free (buffer);\n+  hb_free (buffer);\n@@ -804,1 +842,1 @@\n-hb_buffer_get_content_type (hb_buffer_t *buffer)\n+hb_buffer_get_content_type (const hb_buffer_t *buffer)\n@@ -846,1 +884,1 @@\n-hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer)\n+hb_buffer_get_unicode_funcs (const hb_buffer_t *buffer)\n@@ -889,1 +927,1 @@\n-hb_buffer_get_direction (hb_buffer_t    *buffer)\n+hb_buffer_get_direction (const hb_buffer_t *buffer)\n@@ -933,1 +971,1 @@\n-hb_buffer_get_script (hb_buffer_t *buffer)\n+hb_buffer_get_script (const hb_buffer_t *buffer)\n@@ -977,1 +1015,1 @@\n-hb_buffer_get_language (hb_buffer_t *buffer)\n+hb_buffer_get_language (const hb_buffer_t *buffer)\n@@ -1013,1 +1051,1 @@\n-hb_buffer_get_segment_properties (hb_buffer_t *buffer,\n+hb_buffer_get_segment_properties (const hb_buffer_t *buffer,\n@@ -1051,1 +1089,1 @@\n-hb_buffer_get_flags (hb_buffer_t *buffer)\n+hb_buffer_get_flags (const hb_buffer_t *buffer)\n@@ -1090,1 +1128,1 @@\n-hb_buffer_get_cluster_level (hb_buffer_t *buffer)\n+hb_buffer_get_cluster_level (const hb_buffer_t *buffer)\n@@ -1131,1 +1169,1 @@\n-hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer)\n+hb_buffer_get_replacement_codepoint (const hb_buffer_t *buffer)\n@@ -1171,1 +1209,1 @@\n-hb_buffer_get_invisible_glyph (hb_buffer_t    *buffer)\n+hb_buffer_get_invisible_glyph (const hb_buffer_t *buffer)\n@@ -1176,1 +1214,0 @@\n-\n@@ -1178,1 +1215,1 @@\n- * hb_buffer_reset:\n+ * hb_buffer_set_not_found_glyph:\n@@ -1180,0 +1217,1 @@\n+ * @not_found: the not-found #hb_codepoint_t\n@@ -1181,2 +1219,2 @@\n- * Resets the buffer to its initial status, as if it was just newly created\n- * with hb_buffer_create().\n+ * Sets the #hb_codepoint_t that replaces characters not found in\n+ * the font during shaping.\n@@ -1184,1 +1222,4 @@\n- * Since: 0.9.2\n+ * The not-found glyph defaults to zero, sometimes knows as the\n+ * \".notdef\" glyph.  This API allows for differentiating the two.\n+ *\n+ * Since: 3.1.0\n@@ -1187,1 +1228,2 @@\n-hb_buffer_reset (hb_buffer_t *buffer)\n+hb_buffer_set_not_found_glyph (hb_buffer_t    *buffer,\n+                               hb_codepoint_t  not_found)\n@@ -1192,1 +1234,1 @@\n-  buffer->reset ();\n+  buffer->not_found = not_found;\n@@ -1195,0 +1237,18 @@\n+\/**\n+ * hb_buffer_get_not_found_glyph:\n+ * @buffer: An #hb_buffer_t\n+ *\n+ * See hb_buffer_set_not_found_glyph().\n+ *\n+ * Return value:\n+ * The @buffer not-found #hb_codepoint_t\n+ *\n+ * Since: 3.1.0\n+ **\/\n+hb_codepoint_t\n+hb_buffer_get_not_found_glyph (const hb_buffer_t *buffer)\n+{\n+  return buffer->not_found;\n+}\n+\n+\n@@ -1329,1 +1389,1 @@\n-hb_buffer_get_length (hb_buffer_t *buffer)\n+hb_buffer_get_length (const hb_buffer_t *buffer)\n@@ -1366,0 +1426,5 @@\n+ * If buffer did not have positions before, the positions will be\n+ * initialized to zeros, unless this function is called from\n+ * within a buffer message callback (see hb_buffer_set_message_func()),\n+ * in which case %NULL is returned.\n+ *\n@@ -1376,3 +1441,0 @@\n-  if (!buffer->have_positions)\n-    buffer->clear_positions ();\n-\n@@ -1382,0 +1444,8 @@\n+  if (!buffer->have_positions)\n+  {\n+    if (unlikely (buffer->message_depth))\n+      return nullptr;\n+\n+    buffer->clear_positions ();\n+  }\n+\n@@ -1727,1 +1797,1 @@\n-                  hb_buffer_t *source,\n+                  const hb_buffer_t *source,\n@@ -1760,0 +1830,2 @@\n+  hb_segment_properties_overlay (&buffer->props, &source->props);\n+\n@@ -1763,0 +1835,22 @@\n+\n+  if (source->content_type == HB_BUFFER_CONTENT_TYPE_UNICODE)\n+  {\n+    \/* See similar logic in add_utf. *\/\n+\n+    \/* pre-context *\/\n+    if (!orig_len && start + source->context_len[0] > 0)\n+    {\n+      buffer->clear_context (0);\n+      while (start > 0 && buffer->context_len[0] < buffer->CONTEXT_LENGTH)\n+        buffer->context[0][buffer->context_len[0]++] = source->info[--start].codepoint;\n+      for (auto i = 0u; i < source->context_len[0] && buffer->context_len[0] < buffer->CONTEXT_LENGTH; i++)\n+        buffer->context[0][buffer->context_len[0]++] = source->context[0][i];\n+    }\n+\n+    \/* post-context *\/\n+    buffer->clear_context (1);\n+    while (end < source->len && buffer->context_len[1] < buffer->CONTEXT_LENGTH)\n+      buffer->context[1][buffer->context_len[1]++] = source->info[end++].codepoint;\n+    for (auto i = 0u; i < source->context_len[1] && buffer->context_len[1] < buffer->CONTEXT_LENGTH; i++)\n+      buffer->context[1][buffer->context_len[1]++] = source->context[1][i];\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.cc","additions":239,"deletions":145,"binary":false,"changes":384,"status":"modified"},{"patch":"@@ -79,12 +79,66 @@\n- *                                 result might be different.  On the flip side,\n- *                                 it means that when this flag is not present,\n- *                                 then it's safe to break the glyph-run at the\n- *                                 beginning of this cluster, and the two sides\n- *                                 represent the exact same result one would get\n- *                                 if breaking input text at the beginning of\n- *                                 this cluster and shaping the two sides\n- *                                 separately.  This can be used to optimize\n- *                                 paragraph layout, by avoiding re-shaping\n- *                                 of each line after line-breaking, or limiting\n- *                                 the reshaping to a small piece around the\n- *                                 breaking point only.\n+ *                                 result might be different.\n+ *                                 On the flip side, it means that when this\n+ *                                 flag is not present, then it is safe to break\n+ *                                 the glyph-run at the beginning of this\n+ *                                 cluster, and the two sides will represent the\n+ *                                 exact same result one would get if breaking\n+ *                                 input text at the beginning of this cluster\n+ *                                 and shaping the two sides separately.\n+ *                                 This can be used to optimize paragraph\n+ *                                 layout, by avoiding re-shaping of each line\n+ *                                 after line-breaking.\n+ * @HB_GLYPH_FLAG_UNSAFE_TO_CONCAT: Indicates that if input text is changed on one\n+ *                                 side of the beginning of the cluster this glyph\n+ *                                 is part of, then the shaping results for the\n+ *                                 other side might change.\n+ *                                 Note that the absence of this flag will NOT by\n+ *                                 itself mean that it IS safe to concat text.\n+ *                                 Only two pieces of text both of which clear of\n+ *                                 this flag can be concatenated safely.\n+ *                                 This can be used to optimize paragraph\n+ *                                 layout, by avoiding re-shaping of each line\n+ *                                 after line-breaking, by limiting the\n+ *                                 reshaping to a small piece around the\n+ *                                 breaking positin only, even if the breaking\n+ *                                 position carries the\n+ *                                 #HB_GLYPH_FLAG_UNSAFE_TO_BREAK or when\n+ *                                 hyphenation or other text transformation\n+ *                                 happens at line-break position, in the following\n+ *                                 way:\n+ *                                 1. Iterate back from the line-break position\n+ *                                 until the first cluster start position that is\n+ *                                 NOT unsafe-to-concat, 2. shape the segment from\n+ *                                 there till the end of line, 3. check whether the\n+ *                                 resulting glyph-run also is clear of the\n+ *                                 unsafe-to-concat at its start-of-text position;\n+ *                                 if it is, just splice it into place and the line\n+ *                                 is shaped; If not, move on to a position further\n+ *                                 back that is clear of unsafe-to-concat and retry\n+ *                                 from there, and repeat.\n+ *                                 At the start of next line a similar algorithm can\n+ *                                 be implemented. That is: 1. Iterate forward from\n+ *                                 the line-break position until the first cluster\n+ *                                 start position that is NOT unsafe-to-concat, 2.\n+ *                                 shape the segment from beginning of the line to\n+ *                                 that position, 3. check whether the resulting\n+ *                                 glyph-run also is clear of the unsafe-to-concat\n+ *                                 at its end-of-text position; if it is, just splice\n+ *                                 it into place and the beginning is shaped; If not,\n+ *                                 move on to a position further forward that is clear\n+ *                                 of unsafe-to-concat and retry up to there, and repeat.\n+ *                                 A slight complication will arise in the\n+ *                                 implementation of the algorithm above,\n+ *                                 because while our buffer API has a way to\n+ *                                 return flags for position corresponding to\n+ *                                 start-of-text, there is currently no position\n+ *                                 corresponding to end-of-text.  This limitation\n+ *                                 can be alleviated by shaping more text than needed\n+ *                                 and looking for unsafe-to-concat flag within text\n+ *                                 clusters.\n+ *                                 The #HB_GLYPH_FLAG_UNSAFE_TO_BREAK flag will\n+ *                                 always imply this flag.\n+ *                                 To use this flag, you must enable the buffer flag\n+ *                                 @HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT during\n+ *                                 shaping, otherwise the buffer flag will not be\n+ *                                 reliably produced.\n+ *                                 Since: 4.0.0\n@@ -99,0 +153,1 @@\n+  HB_GLYPH_FLAG_UNSAFE_TO_CONCAT        = 0x00000002,\n@@ -100,1 +155,1 @@\n-  HB_GLYPH_FLAG_DEFINED                 = 0x00000001 \/* OR of all defined flags *\/\n+  HB_GLYPH_FLAG_DEFINED                 = 0x00000003 \/* OR of all defined flags *\/\n@@ -173,0 +228,3 @@\n+HB_EXTERN void\n+hb_segment_properties_overlay (hb_segment_properties_t *p,\n+                               const hb_segment_properties_t *src);\n@@ -187,0 +245,7 @@\n+HB_EXTERN hb_buffer_t *\n+hb_buffer_create_similar (const hb_buffer_t *src);\n+\n+HB_EXTERN void\n+hb_buffer_reset (hb_buffer_t *buffer);\n+\n+\n@@ -227,1 +292,1 @@\n-hb_buffer_get_content_type (hb_buffer_t *buffer);\n+hb_buffer_get_content_type (const hb_buffer_t *buffer);\n@@ -235,1 +300,1 @@\n-hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer);\n+hb_buffer_get_unicode_funcs (const hb_buffer_t  *buffer);\n@@ -242,1 +307,1 @@\n-hb_buffer_get_direction (hb_buffer_t *buffer);\n+hb_buffer_get_direction (const hb_buffer_t *buffer);\n@@ -249,1 +314,1 @@\n-hb_buffer_get_script (hb_buffer_t *buffer);\n+hb_buffer_get_script (const hb_buffer_t *buffer);\n@@ -257,1 +322,1 @@\n-hb_buffer_get_language (hb_buffer_t *buffer);\n+hb_buffer_get_language (const hb_buffer_t *buffer);\n@@ -264,1 +329,1 @@\n-hb_buffer_get_segment_properties (hb_buffer_t *buffer,\n+hb_buffer_get_segment_properties (const hb_buffer_t *buffer,\n@@ -298,1 +363,14 @@\n- *                      character sequences (such at <0905 093E>). Since: 2.4\n+ *                      character sequences (such at <0905 093E>). Since: 2.4.0\n+ * @HB_BUFFER_FLAG_VERIFY:\n+ *                      flag indicating that the hb_shape() call and its variants\n+ *                      should perform various verification processes on the results\n+ *                      of the shaping operation on the buffer.  If the verification\n+ *                      fails, then either a buffer message is sent, if a message\n+ *                      handler is installed on the buffer, or a message is written\n+ *                      to standard error.  In either case, the shaping result might\n+ *                      be modified to show the failed output. Since: 3.4.0\n+ * @HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT:\n+ *                      flag indicating that the @HB_GLYPH_FLAG_UNSAFE_TO_CONCAT\n+ *                      glyph-flag should be produced by the shaper. By default\n+ *                      it will not be produced since it incurs a cost. Since: 4.0.0\n+ * @HB_BUFFER_FLAG_DEFINED: All currently defined flags: Since: 4.4.0\n@@ -310,1 +388,5 @@\n-  HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE    = 0x00000010u\n+  HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE    = 0x00000010u,\n+  HB_BUFFER_FLAG_VERIFY                         = 0x00000020u,\n+  HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT       = 0x00000040u,\n+\n+  HB_BUFFER_FLAG_DEFINED                        = 0x0000007Fu\n@@ -318,1 +400,1 @@\n-hb_buffer_get_flags (hb_buffer_t *buffer);\n+hb_buffer_get_flags (const hb_buffer_t *buffer);\n@@ -360,1 +442,1 @@\n-hb_buffer_get_cluster_level (hb_buffer_t *buffer);\n+hb_buffer_get_cluster_level (const hb_buffer_t *buffer);\n@@ -377,1 +459,1 @@\n-hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer);\n+hb_buffer_get_replacement_codepoint (const hb_buffer_t *buffer);\n@@ -384,2 +466,1 @@\n-hb_buffer_get_invisible_glyph (hb_buffer_t    *buffer);\n-\n+hb_buffer_get_invisible_glyph (const hb_buffer_t *buffer);\n@@ -388,1 +469,10 @@\n-hb_buffer_reset (hb_buffer_t *buffer);\n+hb_buffer_set_not_found_glyph (hb_buffer_t    *buffer,\n+                               hb_codepoint_t  not_found);\n+\n+HB_EXTERN hb_codepoint_t\n+hb_buffer_get_not_found_glyph (const hb_buffer_t *buffer);\n+\n+\n+\/*\n+ * Content API.\n+ *\/\n@@ -456,1 +546,1 @@\n-                  hb_buffer_t *source,\n+                  const hb_buffer_t *source,\n@@ -465,1 +555,1 @@\n-hb_buffer_get_length (hb_buffer_t *buffer);\n+hb_buffer_get_length (const hb_buffer_t *buffer);\n@@ -499,0 +589,1 @@\n+ * @HB_BUFFER_SERIALIZE_FLAG_DEFINED: All currently defined flags. Since: 4.4.0\n@@ -511,1 +602,3 @@\n-  HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES          = 0x00000020u\n+  HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES          = 0x00000020u,\n+\n+  HB_BUFFER_SERIALIZE_FLAG_DEFINED              = 0x0000003Fu\n@@ -553,7 +646,7 @@\n-                                        unsigned int start,\n-                                        unsigned int end,\n-                                        char *buf,\n-                                        unsigned int buf_size,\n-                                        unsigned int *buf_consumed,\n-                                        hb_buffer_serialize_format_t format,\n-                                        hb_buffer_serialize_flags_t flags);\n+                             unsigned int start,\n+                             unsigned int end,\n+                             char *buf,\n+                             unsigned int buf_size,\n+                             unsigned int *buf_consumed,\n+                             hb_buffer_serialize_format_t format,\n+                             hb_buffer_serialize_flags_t flags);\n@@ -563,8 +656,8 @@\n-                                        unsigned int start,\n-                                        unsigned int end,\n-                                        char *buf,\n-                                        unsigned int buf_size,\n-                                        unsigned int *buf_consumed,\n-                                        hb_font_t *font,\n-                                        hb_buffer_serialize_format_t format,\n-                                        hb_buffer_serialize_flags_t flags);\n+                     unsigned int start,\n+                     unsigned int end,\n+                     char *buf,\n+                     unsigned int buf_size,\n+                     unsigned int *buf_consumed,\n+                     hb_font_t *font,\n+                     hb_buffer_serialize_format_t format,\n+                     hb_buffer_serialize_flags_t flags);\n@@ -582,4 +675,4 @@\n-            const char *buf,\n-            int buf_len,\n-            const char **end_ptr,\n-            hb_buffer_serialize_format_t format);\n+                               const char *buf,\n+                               int buf_len,\n+                               const char **end_ptr,\n+                               hb_buffer_serialize_format_t format);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.h","additions":142,"deletions":49,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+HB_MARK_AS_FLAG_T (hb_glyph_flags_t);\n@@ -70,8 +71,9 @@\n-  HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK            = 0x00000010u,\n-  HB_BUFFER_SCRATCH_FLAG_HAS_CGJ                        = 0x00000020u,\n-\n-  \/* Reserved for complex shapers' internal use. *\/\n-  HB_BUFFER_SCRATCH_FLAG_COMPLEX0                       = 0x01000000u,\n-  HB_BUFFER_SCRATCH_FLAG_COMPLEX1                       = 0x02000000u,\n-  HB_BUFFER_SCRATCH_FLAG_COMPLEX2                       = 0x04000000u,\n-  HB_BUFFER_SCRATCH_FLAG_COMPLEX3                       = 0x08000000u,\n+  HB_BUFFER_SCRATCH_FLAG_HAS_CGJ                        = 0x00000010u,\n+  HB_BUFFER_SCRATCH_FLAG_HAS_GLYPH_FLAGS                = 0x00000020u,\n+  HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE            = 0x00000040u,\n+\n+  \/* Reserved for shapers' internal use. *\/\n+  HB_BUFFER_SCRATCH_FLAG_SHAPER0                        = 0x01000000u,\n+  HB_BUFFER_SCRATCH_FLAG_SHAPER1                        = 0x02000000u,\n+  HB_BUFFER_SCRATCH_FLAG_SHAPER2                        = 0x04000000u,\n+  HB_BUFFER_SCRATCH_FLAG_SHAPER3                        = 0x08000000u,\n@@ -90,1 +92,4 @@\n-  \/* Information about how the text in the buffer should be treated *\/\n+  \/*\n+   * Information about how the text in the buffer should be treated.\n+   *\/\n+\n@@ -96,3 +101,5 @@\n-  hb_buffer_scratch_flags_t scratch_flags; \/* Have space-fallback, etc. *\/\n-  unsigned int max_len; \/* Maximum allowed len. *\/\n-  int max_ops; \/* Maximum allowed operations. *\/\n+  hb_codepoint_t not_found; \/* 0 or something else. *\/\n+\n+  \/*\n+   * Buffer contents\n+   *\/\n@@ -100,1 +107,0 @@\n-  \/* Buffer contents *\/\n@@ -105,0 +111,1 @@\n+  bool shaping_failed; \/* Shaping failure *\/\n@@ -110,1 +117,1 @@\n-  unsigned int out_len; \/* Length of ->out array if have_output *\/\n+  unsigned int out_len; \/* Length of ->out_info array if have_output *\/\n@@ -117,2 +124,0 @@\n-  unsigned int serial;\n-\n@@ -126,1 +131,17 @@\n-  \/* Debugging API *\/\n+\n+  \/*\n+   * Managed by enter \/ leave\n+   *\/\n+\n+  uint8_t allocated_var_bits;\n+  uint8_t serial;\n+  hb_buffer_scratch_flags_t scratch_flags; \/* Have space-fallback, etc. *\/\n+  unsigned int max_len; \/* Maximum allowed len. *\/\n+  int max_ops; \/* Maximum allowed operations. *\/\n+  \/* The bits here reflect current allocations of the bytes in glyph_info_t's var1 and var2. *\/\n+\n+\n+  \/*\n+   * Messaging callback\n+   *\/\n+\n@@ -131,0 +152,3 @@\n+  unsigned message_depth; \/* How deeply are we inside a message callback? *\/\n+#else\n+  static constexpr unsigned message_depth = 0u;\n@@ -133,5 +157,0 @@\n-  \/* Internal debugging. *\/\n-  \/* The bits here reflect current allocations of the bytes in glyph_info_t's var1 and var2. *\/\n-#ifndef HB_NDEBUG\n-  uint8_t allocated_var_bits;\n-#endif\n@@ -146,1 +165,0 @@\n-#ifndef HB_NDEBUG\n@@ -152,1 +170,10 @@\n-#endif\n+  }\n+  bool try_allocate_var (unsigned int start, unsigned int count)\n+  {\n+    unsigned int end = start + count;\n+    assert (end <= 8);\n+    unsigned int bits = (1u<<end) - (1u<<start);\n+    if (allocated_var_bits & bits)\n+      return false;\n+    allocated_var_bits |= bits;\n+    return true;\n@@ -156,1 +183,0 @@\n-#ifndef HB_NDEBUG\n@@ -162,1 +188,0 @@\n-#endif\n@@ -166,1 +191,0 @@\n-#ifndef HB_NDEBUG\n@@ -169,1 +193,1 @@\n-    unsigned int bits = (1u<<end) - (1u<<start);\n+    HB_UNUSED unsigned int bits = (1u<<end) - (1u<<start);\n@@ -171,1 +195,0 @@\n-#endif\n@@ -175,1 +198,0 @@\n-#ifndef HB_NDEBUG\n@@ -177,1 +199,0 @@\n-#endif\n@@ -189,3 +210,1 @@\n-  HB_NODISCARD bool has_separate_output () const { return info != out_info; }\n-\n-\n+  HB_INTERNAL void similar (const hb_buffer_t &src);\n@@ -195,1 +214,19 @@\n-  unsigned int backtrack_len () const { return have_output? out_len : idx; }\n+  \/* Called around shape() *\/\n+  HB_INTERNAL void enter ();\n+  HB_INTERNAL void leave ();\n+\n+#ifndef HB_NO_BUFFER_VERIFY\n+  HB_INTERNAL\n+#endif\n+  bool verify (hb_buffer_t        *text_buffer,\n+               hb_font_t          *font,\n+               const hb_feature_t *features,\n+               unsigned int        num_features,\n+               const char * const *shapers)\n+#ifndef HB_NO_BUFFER_VERIFY\n+  ;\n+#else\n+  { return true; }\n+#endif\n+\n+  unsigned int backtrack_len () const { return have_output ? out_len : idx; }\n@@ -197,1 +234,1 @@\n-  unsigned int next_serial () { return serial++; }\n+  uint8_t next_serial () { return ++serial ? serial : ++serial; }\n@@ -203,3 +240,49 @@\n-  HB_INTERNAL void reverse_range (unsigned int start, unsigned int end);\n-  HB_INTERNAL void reverse ();\n-  HB_INTERNAL void reverse_clusters ();\n+  void reverse_range (unsigned start, unsigned end)\n+  {\n+    hb_array_t<hb_glyph_info_t> (info, len).reverse (start, end);\n+    if (have_positions)\n+      hb_array_t<hb_glyph_position_t> (pos, len).reverse (start, end);\n+  }\n+  void reverse () { reverse_range (0, len); }\n+\n+  template <typename FuncType>\n+  void reverse_groups (const FuncType& group,\n+                       bool merge_clusters = false)\n+  {\n+    if (unlikely (!len))\n+      return;\n+\n+    unsigned start = 0;\n+    unsigned i;\n+    for (i = 1; i < len; i++)\n+    {\n+      if (!group (info[i - 1], info[i]))\n+      {\n+        if (merge_clusters)\n+          this->merge_clusters (start, i);\n+        reverse_range (start, i);\n+        start = i;\n+      }\n+    }\n+    if (merge_clusters)\n+      this->merge_clusters (start, i);\n+    reverse_range (start, i);\n+\n+    reverse ();\n+  }\n+\n+  template <typename FuncType>\n+  unsigned group_end (unsigned start, const FuncType& group) const\n+  {\n+    while (++start < len && group (info[start - 1], info[start]))\n+      ;\n+\n+    return start;\n+  }\n+\n+  static bool _cluster_group_func (const hb_glyph_info_t& a,\n+                                   const hb_glyph_info_t& b)\n+  { return a.cluster == b.cluster; }\n+\n+  void reverse_clusters () { reverse_groups (_cluster_group_func); }\n+\n@@ -208,2 +291,1 @@\n-  HB_INTERNAL void swap_buffers ();\n-  HB_INTERNAL void remove_output ();\n+  HB_INTERNAL void sync ();\n@@ -323,2 +405,9 @@\n-  void unsafe_to_break (unsigned int start,\n-                        unsigned int end)\n+\n+  \/* Adds glyph flags in mask to infos with clusters between start and end.\n+   * The start index will be from out-buffer if from_out_buffer is true.\n+   * If interior is true, then the cluster having the minimum value is skipped. *\/\n+  void _set_glyph_flags (hb_mask_t mask,\n+                         unsigned start = 0,\n+                         unsigned end = (unsigned) -1,\n+                         bool interior = false,\n+                         bool from_out_buffer = false)\n@@ -326,1 +415,52 @@\n-    if (end - start < 2)\n+    end = hb_min (end, len);\n+\n+    if (interior && !from_out_buffer && end - start < 2)\n+      return;\n+\n+    scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GLYPH_FLAGS;\n+\n+    if (!from_out_buffer || !have_output)\n+    {\n+      if (!interior)\n+      {\n+        for (unsigned i = start; i < end; i++)\n+          info[i].mask |= mask;\n+      }\n+      else\n+      {\n+        unsigned cluster = _infos_find_min_cluster (info, start, end);\n+        _infos_set_glyph_flags (info, start, end, cluster, mask);\n+      }\n+    }\n+    else\n+    {\n+      assert (start <= out_len);\n+      assert (idx <= end);\n+\n+      if (!interior)\n+      {\n+        for (unsigned i = start; i < out_len; i++)\n+          out_info[i].mask |= mask;\n+        for (unsigned i = idx; i < end; i++)\n+          info[i].mask |= mask;\n+      }\n+      else\n+      {\n+        unsigned cluster = _infos_find_min_cluster (info, idx, end);\n+        cluster = _infos_find_min_cluster (out_info, start, out_len, cluster);\n+\n+        _infos_set_glyph_flags (out_info, start, out_len, cluster, mask);\n+        _infos_set_glyph_flags (info, idx, end, cluster, mask);\n+      }\n+    }\n+  }\n+\n+  void unsafe_to_break (unsigned int start = 0, unsigned int end = -1)\n+  {\n+    _set_glyph_flags (HB_GLYPH_FLAG_UNSAFE_TO_BREAK | HB_GLYPH_FLAG_UNSAFE_TO_CONCAT,\n+                      start, end,\n+                      true);\n+  }\n+  void unsafe_to_concat (unsigned int start = 0, unsigned int end = -1)\n+  {\n+    if (likely ((flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT) == 0))\n@@ -328,1 +468,17 @@\n-    unsafe_to_break_impl (start, end);\n+    _set_glyph_flags (HB_GLYPH_FLAG_UNSAFE_TO_CONCAT,\n+                      start, end,\n+                      true);\n+  }\n+  void unsafe_to_break_from_outbuffer (unsigned int start = 0, unsigned int end = -1)\n+  {\n+    _set_glyph_flags (HB_GLYPH_FLAG_UNSAFE_TO_BREAK | HB_GLYPH_FLAG_UNSAFE_TO_CONCAT,\n+                      start, end,\n+                      true, true);\n+  }\n+  void unsafe_to_concat_from_outbuffer (unsigned int start = 0, unsigned int end = -1)\n+  {\n+    if (likely ((flags & HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT) == 0))\n+      return;\n+    _set_glyph_flags (HB_GLYPH_FLAG_UNSAFE_TO_CONCAT,\n+                      start, end,\n+                      false, true);\n@@ -330,2 +486,0 @@\n-  HB_INTERNAL void unsafe_to_break_impl (unsigned int start, unsigned int end);\n-  HB_INTERNAL void unsafe_to_break_from_outbuffer (unsigned int start, unsigned int end);\n@@ -401,1 +555,1 @@\n-    if (!messaging ())\n+    if (likely (!messaging ()))\n@@ -403,0 +557,3 @@\n+\n+    message_depth++;\n+\n@@ -407,0 +564,3 @@\n+\n+    message_depth--;\n+\n@@ -416,6 +576,1 @@\n-    {\n-      if (mask & HB_GLYPH_FLAG_UNSAFE_TO_BREAK)\n-        inf.mask |= HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n-      else\n-        inf.mask &= ~HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n-    }\n+      inf.mask = (inf.mask & ~HB_GLYPH_FLAG_DEFINED) | (mask & HB_GLYPH_FLAG_DEFINED);\n@@ -424,10 +579,0 @@\n-\n-  unsigned int\n-  _unsafe_to_break_find_min_cluster (const hb_glyph_info_t *infos,\n-                                     unsigned int start, unsigned int end,\n-                                     unsigned int cluster) const\n-  {\n-    for (unsigned int i = start; i < end; i++)\n-      cluster = hb_min (cluster, infos[i].cluster);\n-    return cluster;\n-  }\n@@ -435,3 +580,4 @@\n-  _unsafe_to_break_set_mask (hb_glyph_info_t *infos,\n-                             unsigned int start, unsigned int end,\n-                             unsigned int cluster)\n+  _infos_set_glyph_flags (hb_glyph_info_t *infos,\n+                          unsigned int start, unsigned int end,\n+                          unsigned int cluster,\n+                          hb_mask_t mask)\n@@ -442,2 +588,2 @@\n-        scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK;\n-        infos[i].mask |= HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n+        scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GLYPH_FLAGS;\n+        infos[i].mask |= mask;\n@@ -446,0 +592,9 @@\n+  static unsigned\n+  _infos_find_min_cluster (const hb_glyph_info_t *infos,\n+                           unsigned start, unsigned end,\n+                           unsigned cluster = UINT_MAX)\n+  {\n+    for (unsigned int i = start; i < end; i++)\n+      cluster = hb_min (cluster, infos[i].cluster);\n+    return cluster;\n+  }\n@@ -447,2 +602,1 @@\n-  void unsafe_to_break_all () { unsafe_to_break_impl (0, len); }\n-  void safe_to_break_all ()\n+  void clear_glyph_flags (hb_mask_t mask = 0)\n@@ -451,1 +605,1 @@\n-      info[i].mask &= ~HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n+      info[i].mask = (info[i].mask & ~HB_GLYPH_FLAG_DEFINED) | (mask & HB_GLYPH_FLAG_DEFINED);\n@@ -457,2 +611,1 @@\n-\/* Loop over clusters. Duplicated in foreach_syllable(). *\/\n-#define foreach_cluster(buffer, start, end) \\\n+#define foreach_group(buffer, start, end, group_func) \\\n@@ -461,1 +614,1 @@\n-       start = 0, end = _count ? _next_cluster (buffer, 0) : 0; \\\n+       start = 0, end = _count ? buffer->group_end (0, group_func) : 0; \\\n@@ -463,1 +616,1 @@\n-       start = end, end = _next_cluster (buffer, start))\n+       start = end, end = buffer->group_end (start, group_func))\n@@ -465,12 +618,2 @@\n-static inline unsigned int\n-_next_cluster (hb_buffer_t *buffer, unsigned int start)\n-{\n-  hb_glyph_info_t *info = buffer->info;\n-  unsigned int count = buffer->len;\n-\n-  unsigned int cluster = info[start].cluster;\n-  while (++start < count && cluster == info[start].cluster)\n-    ;\n-\n-  return start;\n-}\n+#define foreach_cluster(buffer, start, end) \\\n+        foreach_group (buffer, start, end, hb_buffer_t::_cluster_group_func)\n@@ -482,3 +625,4 @@\n-#define HB_BUFFER_ALLOCATE_VAR(b, var)          HB_BUFFER_XALLOCATE_VAR (b, allocate_var,   var ())\n-#define HB_BUFFER_DEALLOCATE_VAR(b, var)        HB_BUFFER_XALLOCATE_VAR (b, deallocate_var, var ())\n-#define HB_BUFFER_ASSERT_VAR(b, var)            HB_BUFFER_XALLOCATE_VAR (b, assert_var,     var ())\n+#define HB_BUFFER_ALLOCATE_VAR(b, var)          HB_BUFFER_XALLOCATE_VAR (b, allocate_var,     var ())\n+#define HB_BUFFER_TRY_ALLOCATE_VAR(b, var)      HB_BUFFER_XALLOCATE_VAR (b, try_allocate_var, var ())\n+#define HB_BUFFER_DEALLOCATE_VAR(b, var)        HB_BUFFER_XALLOCATE_VAR (b, deallocate_var,   var ())\n+#define HB_BUFFER_ASSERT_VAR(b, var)            HB_BUFFER_XALLOCATE_VAR (b, assert_var,       var ())\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.hh","additions":235,"deletions":91,"binary":false,"changes":326,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright  2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_CACHE_HH\n+#define HB_CACHE_HH\n+\n+#include \"hb.hh\"\n+\n+\n+\/* Implements a lockfree cache for int->int functions. *\/\n+\n+template <unsigned int key_bits=16, unsigned int value_bits=8 + 32 - key_bits, unsigned int cache_bits=8>\n+struct hb_cache_t\n+{\n+  static_assert ((key_bits >= cache_bits), \"\");\n+  static_assert ((key_bits + value_bits - cache_bits <= 8 * sizeof (hb_atomic_int_t)), \"\");\n+  static_assert (sizeof (hb_atomic_int_t) == sizeof (unsigned int), \"\");\n+\n+  void init () { clear (); }\n+  void fini () {}\n+\n+  void clear ()\n+  {\n+    for (unsigned i = 0; i < ARRAY_LENGTH (values); i++)\n+      values[i].set_relaxed (-1);\n+  }\n+\n+  bool get (unsigned int key, unsigned int *value) const\n+  {\n+    unsigned int k = key & ((1u<<cache_bits)-1);\n+    unsigned int v = values[k].get_relaxed ();\n+    if ((key_bits + value_bits - cache_bits == 8 * sizeof (hb_atomic_int_t) && v == (unsigned int) -1) ||\n+        (v >> value_bits) != (key >> cache_bits))\n+      return false;\n+    *value = v & ((1u<<value_bits)-1);\n+    return true;\n+  }\n+\n+  bool set (unsigned int key, unsigned int value)\n+  {\n+    if (unlikely ((key >> key_bits) || (value >> value_bits)))\n+      return false; \/* Overflows *\/\n+    unsigned int k = key & ((1u<<cache_bits)-1);\n+    unsigned int v = ((key>>cache_bits)<<value_bits) | value;\n+    values[k].set_relaxed (v);\n+    return true;\n+  }\n+\n+  private:\n+  hb_atomic_int_t values[1u<<cache_bits];\n+};\n+\n+typedef hb_cache_t<21, 16, 8> hb_cmap_cache_t;\n+typedef hb_cache_t<16, 24, 8> hb_advance_cache_t;\n+\n+\n+#endif \/* HB_CACHE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cache.hh","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -220,3 +220,0 @@\n-  void init () { set_real (0.0); }\n-  void fini () {}\n-\n@@ -248,1 +245,1 @@\n-  double value;\n+  double value = 0.;\n@@ -254,0 +251,3 @@\n+  hb_ubytes_t as_ubytes (unsigned l) const\n+  { return hb_ubytes_t ((const unsigned char *) this, l); }\n+\n@@ -266,1 +266,1 @@\n-    return_trace (c->check_assign (*ip, value));\n+    return_trace (c->check_assign (*ip, value, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n@@ -280,3 +280,0 @@\n-   * byte_str_t, a wrapper struct pairing a byte pointer along with its length, always\n-   * checks the length before access. A Null pointer is used as the initial pointer\n-   * along with zero length by the default ctor.\n@@ -287,20 +284,0 @@\n-\/* Holder of a section of byte string within a CFFIndex entry *\/\n-struct byte_str_t : hb_ubytes_t\n-{\n-  byte_str_t ()\n-    : hb_ubytes_t () {}\n-  byte_str_t (const UnsizedByteStr& s, unsigned int l)\n-    : hb_ubytes_t ((const unsigned char*)&s, l) {}\n-  byte_str_t (const unsigned char *s, unsigned int l)\n-    : hb_ubytes_t (s, l) {}\n-  byte_str_t (const hb_ubytes_t &ub)    \/* conversion from hb_ubytes_t *\/\n-    : hb_ubytes_t (ub) {}\n-\n-  \/* sub-string *\/\n-  byte_str_t sub_str (unsigned int offset, unsigned int len_) const\n-  { return byte_str_t (hb_ubytes_t::sub_array (offset, len_)); }\n-\n-  bool check_limit (unsigned int offset, unsigned int count) const\n-  { return (offset + count <= length); }\n-};\n-\n@@ -314,1 +291,1 @@\n-    str = byte_str_t ();\n+    str = hb_ubytes_t ();\n@@ -321,1 +298,1 @@\n-  byte_str_ref_t (const byte_str_t &str_, unsigned int offset_ = 0)\n+  byte_str_ref_t (const hb_ubytes_t &str_, unsigned int offset_ = 0)\n@@ -324,1 +301,1 @@\n-  void reset (const byte_str_t &str_, unsigned int offset_ = 0)\n+  void reset (const hb_ubytes_t &str_, unsigned int offset_ = 0)\n@@ -340,2 +317,2 @@\n-  \/* Conversion to byte_str_t *\/\n-  operator byte_str_t () const { return str.sub_str (offset, str.length - offset); }\n+  \/* Conversion to hb_ubytes_t *\/\n+  operator hb_ubytes_t () const { return str.sub_array (offset, str.length - offset); }\n@@ -343,2 +320,2 @@\n-  byte_str_t sub_str (unsigned int offset_, unsigned int len_) const\n-  { return str.sub_str (offset_, len_); }\n+  hb_ubytes_t sub_array (unsigned int offset_, unsigned int len_) const\n+  { return str.sub_array (offset_, len_); }\n@@ -347,1 +324,1 @@\n-  { return (!in_error () && str.check_limit (offset, count)); }\n+  { return (!in_error () && offset + count <= str.length); }\n@@ -364,1 +341,1 @@\n-  byte_str_t       str;\n+  hb_ubytes_t       str;\n@@ -371,1 +348,1 @@\n-typedef hb_vector_t<byte_str_t> byte_str_array_t;\n+using byte_str_array_t = hb_vector_t<hb_ubytes_t>;\n@@ -377,11 +354,0 @@\n-  void init ()\n-  {\n-    error = false;\n-    count = 0;\n-    elements.init ();\n-    elements.resize (kSizeLimit);\n-    for (unsigned int i = 0; i < elements.length; i++)\n-      elements[i].init ();\n-  }\n-  void fini () { elements.fini_deep (); }\n-\n@@ -390,1 +356,5 @@\n-    if (unlikely (i >= count)) set_error ();\n+    if (unlikely (i >= count))\n+    {\n+      set_error ();\n+      return Crap (ELEM);\n+    }\n@@ -396,1 +366,1 @@\n-    if (likely (count < elements.length))\n+    if (likely (count < LIMIT))\n@@ -403,1 +373,1 @@\n-    if (likely (count < elements.length))\n+    if (likely (count < LIMIT))\n@@ -432,1 +402,1 @@\n-    if (unlikely (count < 0))\n+    if (unlikely (count == 0))\n@@ -442,1 +412,1 @@\n-    if (likely (count < elements.length))\n+    if (likely (count < LIMIT))\n@@ -450,1 +420,1 @@\n-  bool in_error () const { return (error || elements.in_error ()); }\n+  bool in_error () const { return (error); }\n@@ -456,1 +426,2 @@\n-  static constexpr unsigned kSizeLimit = LIMIT;\n+  hb_array_t<const ELEM> sub_array (unsigned start, unsigned length) const\n+  { return hb_array_t<const ELEM> (elements).sub_array (start, length); }\n@@ -458,4 +429,4 @@\n-  protected:\n-  bool error;\n-  unsigned int count;\n-  hb_vector_t<ELEM> elements;\n+  private:\n+  bool error = false;\n+  unsigned int count = 0;\n+  ELEM elements[LIMIT];\n@@ -516,3 +487,0 @@\n-  hb_array_t<const ARG> get_subarray (unsigned int start) const\n-  { return S::elements.sub_array (start); }\n-\n@@ -526,3 +494,1 @@\n-  void init () {}\n-  void fini () {}\n-\n+  hb_ubytes_t str;\n@@ -530,1 +496,0 @@\n-  byte_str_t str;\n@@ -556,1 +521,6 @@\n-  void fini () { values.fini_deep (); }\n+  void fini () { values.fini (); }\n+\n+  void alloc (unsigned n)\n+  {\n+    values.alloc (n);\n+  }\n@@ -562,1 +532,1 @@\n-    val->str = str_ref.str.sub_str (opStart, str_ref.offset - opStart);\n+    val->str = str_ref.str.sub_array (opStart, str_ref.offset - opStart);\n@@ -570,1 +540,1 @@\n-    val->str = str_ref.sub_str ( opStart, str_ref.offset - opStart);\n+    val->str = str_ref.sub_array ( opStart, str_ref.offset - opStart);\n@@ -576,2 +546,2 @@\n-    for (unsigned int i = 0; i < get_count (); i++)\n-      if (get_value (i).op == op) return true;\n+    for (const auto& v : values)\n+      if (v.op == op) return true;\n@@ -592,1 +562,2 @@\n-  void init (const byte_str_t &str_)\n+  interp_env_t () {}\n+  interp_env_t (const hb_ubytes_t &str_)\n@@ -595,2 +566,0 @@\n-    argStack.init ();\n-    error = false;\n@@ -598,2 +567,0 @@\n-  void fini () { argStack.fini (); }\n-\n@@ -633,1 +600,1 @@\n-  bool          error;\n+  bool          error = false;\n@@ -636,1 +603,1 @@\n-typedef interp_env_t<> num_interp_env_t;\n+using num_interp_env_t =  interp_env_t<>;\n@@ -679,5 +646,2 @@\n-  ~interpreter_t() { fini (); }\n-\n-  void fini () { env.fini (); }\n-\n-  ENV env;\n+  interpreter_t (ENV& env_) : env (env_) {}\n+  ENV& env;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff-interp-common.hh","additions":48,"deletions":84,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  byte_str_t operator [] (unsigned int index) const\n+  hb_ubytes_t operator [] (unsigned int index) const\n@@ -85,1 +85,1 @@\n-      return Null (byte_str_t);\n+      return hb_ubytes_t ();\n@@ -97,6 +97,0 @@\n-  void init ()\n-  {\n-    x.init ();\n-    y.init ();\n-  }\n-\n@@ -121,1 +115,2 @@\n-  void init (const byte_str_t &str, const SUBRS *globalSubrs_, const SUBRS *localSubrs_)\n+  cs_interp_env_t (const hb_ubytes_t &str, const SUBRS *globalSubrs_, const SUBRS *localSubrs_) :\n+    interp_env_t<ARG> (str)\n@@ -123,2 +118,0 @@\n-    interp_env_t<ARG>::init (str);\n-\n@@ -131,2 +124,1 @@\n-    pt.init ();\n-    callStack.init ();\n+    pt.set_int (0, 0);\n@@ -136,1 +128,1 @@\n-  void fini ()\n+  ~cs_interp_env_t ()\n@@ -138,3 +130,0 @@\n-    interp_env_t<ARG>::fini ();\n-\n-    callStack.fini ();\n@@ -844,1 +833,0 @@\n-      d.init ();\n@@ -890,0 +878,2 @@\n+  cs_interpreter_t (ENV& env_) : interpreter_t<ENV> (env_) {}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff-interp-cs-common.hh","additions":8,"deletions":18,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -182,0 +182,2 @@\n+  dict_interpreter_t (ENV& env_) : interpreter_t<ENV> (env_) {}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff-interp-dict-common.hh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-  void init (const byte_str_t &str, ACC &acc, unsigned int fd)\n+  cff1_cs_interp_env_t (const hb_ubytes_t &str, ACC &acc, unsigned int fd)\n+    : SUPER (str, acc.globalSubrs, acc.privateDicts[fd].localSubrs)\n@@ -43,1 +44,0 @@\n-    SUPER::init (str, acc.globalSubrs, acc.privateDicts[fd].localSubrs);\n@@ -50,2 +50,0 @@\n-  void fini () { SUPER::fini (); }\n-\n@@ -157,1 +155,1 @@\n-struct cff1_cs_interpreter_t : cs_interpreter_t<cff1_cs_interp_env_t, OPSET, PARAM> {};\n+using cff1_cs_interpreter_t = cs_interpreter_t<cff1_cs_interp_env_t, OPSET, PARAM>;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff1-interp-cs.hh","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,12 +38,0 @@\n-  void init ()\n-  {\n-    number_t::init ();\n-    deltas.init ();\n-  }\n-\n-  void fini ()\n-  {\n-    number_t::fini ();\n-    deltas.fini_deep ();\n-  }\n-\n@@ -79,1 +67,2 @@\n-struct cff2_cs_interp_env_t : cs_interp_env_t<blend_arg_t, CFF2Subrs>\n+template <typename ELEM>\n+struct cff2_cs_interp_env_t : cs_interp_env_t<ELEM, CFF2Subrs>\n@@ -82,2 +71,3 @@\n-  void init (const byte_str_t &str, ACC &acc, unsigned int fd,\n-             const int *coords_=nullptr, unsigned int num_coords_=0)\n+  cff2_cs_interp_env_t (const hb_ubytes_t &str, ACC &acc, unsigned int fd,\n+                        const int *coords_=nullptr, unsigned int num_coords_=0)\n+    : SUPER (str, acc.globalSubrs, acc.privateDicts[fd].localSubrs)\n@@ -85,2 +75,0 @@\n-    SUPER::init (str, acc.globalSubrs, acc.privateDicts[fd].localSubrs);\n-\n@@ -115,1 +103,1 @@\n-  const blend_arg_t& eval_arg (unsigned int i)\n+  const ELEM& eval_arg (unsigned int i)\n@@ -117,3 +105,1 @@\n-    blend_arg_t  &arg = argStack[i];\n-    blend_arg (arg);\n-    return arg;\n+    return SUPER::argStack[i];\n@@ -122,1 +108,1 @@\n-  const blend_arg_t& pop_arg ()\n+  const ELEM& pop_arg ()\n@@ -124,3 +110,1 @@\n-    blend_arg_t  &arg = argStack.pop ();\n-    blend_arg (arg);\n-    return arg;\n+    return SUPER::argStack.pop ();\n@@ -137,1 +121,1 @@\n-          set_error ();\n+          SUPER::set_error ();\n@@ -139,2 +123,2 @@\n-          varStore->varStore.get_scalars (get_ivs (), coords, num_coords,\n-                                          &scalars[0], region_count);\n+          varStore->varStore.get_region_scalars (get_ivs (), coords, num_coords,\n+                                                 &scalars[0], region_count);\n@@ -148,1 +132,1 @@\n-    unsigned int  index = argStack.pop_uint ();\n+    unsigned int  index = SUPER::argStack.pop_uint ();\n@@ -151,1 +135,1 @@\n-      set_error ();\n+     SUPER::set_error ();\n@@ -166,2 +150,1 @@\n-  protected:\n-  void blend_arg (blend_arg_t &arg)\n+  double blend_deltas (hb_array_t<const ELEM> deltas) const\n@@ -169,1 +152,2 @@\n-    if (do_blend && arg.blending ())\n+    double v = 0;\n+    if (do_blend)\n@@ -171,1 +155,1 @@\n-      if (likely (scalars.length == arg.deltas.length))\n+      if (likely (scalars.length == deltas.length))\n@@ -173,1 +157,0 @@\n-        double v = arg.to_real ();\n@@ -175,5 +158,1 @@\n-        {\n-          v += (double)scalars[i] * arg.deltas[i].to_real ();\n-        }\n-        arg.set_real (v);\n-        arg.deltas.resize (0);\n+          v += (double) scalars[i] * deltas[i].to_real ();\n@@ -182,0 +161,1 @@\n+    return v;\n@@ -195,1 +175,1 @@\n-  typedef cs_interp_env_t<blend_arg_t, CFF2Subrs> SUPER;\n+  typedef cs_interp_env_t<ELEM, CFF2Subrs> SUPER;\n@@ -197,2 +177,2 @@\n-template <typename OPSET, typename PARAM, typename PATH=path_procs_null_t<cff2_cs_interp_env_t, PARAM>>\n-struct cff2_cs_opset_t : cs_opset_t<blend_arg_t, OPSET, cff2_cs_interp_env_t, PARAM, PATH>\n+template <typename OPSET, typename PARAM, typename ELEM, typename PATH=path_procs_null_t<cff2_cs_interp_env_t<ELEM>, PARAM>>\n+struct cff2_cs_opset_t : cs_opset_t<ELEM, OPSET, cff2_cs_interp_env_t<ELEM>, PARAM, PATH>\n@@ -200,1 +180,1 @@\n-  static void process_op (op_code_t op, cff2_cs_interp_env_t &env, PARAM& param)\n+  static void process_op (op_code_t op, cff2_cs_interp_env_t<ELEM> &env, PARAM& param)\n@@ -205,1 +185,2 @@\n-        \/* a subroutine number shoudln't be a blended value *\/\n+        \/* a subroutine number shouldn't be a blended value *\/\n+#if 0\n@@ -211,0 +192,1 @@\n+#endif\n@@ -219,0 +201,1 @@\n+#if 0\n@@ -224,0 +207,1 @@\n+#endif\n@@ -232,1 +216,20 @@\n-  static void process_blend (cff2_cs_interp_env_t &env, PARAM& param)\n+  template <typename T = ELEM,\n+            hb_enable_if (hb_is_same (T, blend_arg_t))>\n+  static void process_arg_blend (cff2_cs_interp_env_t<ELEM> &env,\n+                                 ELEM &arg,\n+                                 const hb_array_t<const ELEM> blends,\n+                                 unsigned n, unsigned i)\n+  {\n+    arg.set_blends (n, i, blends.length, blends);\n+  }\n+  template <typename T = ELEM,\n+            hb_enable_if (!hb_is_same (T, blend_arg_t))>\n+  static void process_arg_blend (cff2_cs_interp_env_t<ELEM> &env,\n+                                 ELEM &arg,\n+                                 const hb_array_t<const ELEM> blends,\n+                                 unsigned n, unsigned i)\n+  {\n+    arg.set_real (arg.to_real () + env.blend_deltas (blends));\n+  }\n+\n+  static void process_blend (cff2_cs_interp_env_t<ELEM> &env, PARAM& param)\n@@ -249,2 +252,2 @@\n-      const hb_array_t<const blend_arg_t>       blends = env.argStack.get_subarray (start + n + (i * k));\n-      env.argStack[start + i].set_blends (n, i, k, blends);\n+      const hb_array_t<const ELEM> blends = env.argStack.sub_array (start + n + (i * k), k);\n+      process_arg_blend (env, env.argStack[start + i], blends, n, i);\n@@ -257,1 +260,1 @@\n-  static void process_vsindex (cff2_cs_interp_env_t &env, PARAM& param)\n+  static void process_vsindex (cff2_cs_interp_env_t<ELEM> &env, PARAM& param)\n@@ -264,1 +267,1 @@\n-  typedef cs_opset_t<blend_arg_t, OPSET, cff2_cs_interp_env_t, PARAM, PATH>  SUPER;\n+  typedef cs_opset_t<ELEM, OPSET, cff2_cs_interp_env_t<ELEM>, PARAM, PATH>  SUPER;\n@@ -267,2 +270,2 @@\n-template <typename OPSET, typename PARAM>\n-struct cff2_cs_interpreter_t : cs_interpreter_t<cff2_cs_interp_env_t, OPSET, PARAM> {};\n+template <typename OPSET, typename PARAM, typename ELEM>\n+using cff2_cs_interpreter_t = cs_interpreter_t<cff2_cs_interp_env_t<ELEM>, OPSET, PARAM>;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cff2-interp-cs.hh","additions":55,"deletions":52,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,0 +32,6 @@\n+#if !defined(HB_NO_SETLOCALE) && (!defined(HAVE_NEWLOCALE) || !defined(HAVE_USELOCALE))\n+#define HB_NO_SETLOCALE 1\n+#endif\n+\n+#ifndef HB_NO_SETLOCALE\n+\n@@ -33,0 +39,17 @@\n+#ifdef HAVE_XLOCALE_H\n+#include <xlocale.h> \/\/ Needed on BSD\/OS X for uselocale\n+#endif\n+\n+#ifdef WIN32\n+#define hb_locale_t _locale_t\n+#else\n+#define hb_locale_t locale_t\n+#endif\n+#define hb_setlocale setlocale\n+#define hb_uselocale uselocale\n+\n+#else\n+\n+#define hb_locale_t void *\n+#define hb_setlocale(Category, Locale) \"C\"\n+#define hb_uselocale(Locale) ((hb_locale_t) 0)\n@@ -34,2 +57,0 @@\n-#ifdef HB_NO_SETLOCALE\n-#define setlocale(Category, Locale) \"C\"\n@@ -142,1 +163,1 @@\n-const char direction_strings[][4] = {\n+static const char direction_strings[][4] = {\n@@ -260,5 +281,3 @@\n-  hb_language_item_t & operator = (const char *s) {\n-    \/* If a custom allocated is used calling strdup() pairs\n-    badly with a call to the custom free() in fini() below.\n-    Therefore don't call strdup(), implement its behavior.\n-    *\/\n+  hb_language_item_t & operator = (const char *s)\n+  {\n+    \/* We can't call strdup(), because we allow custom allocators. *\/\n@@ -266,1 +285,1 @@\n-    lang = (hb_language_t) malloc(len);\n+    lang = (hb_language_t) hb_malloc(len);\n@@ -277,1 +296,1 @@\n-  void fini () { free ((void *) lang); }\n+  void fini () { hb_free ((void *) lang); }\n@@ -281,1 +300,1 @@\n-\/* Thread-safe lock-free language list *\/\n+\/* Thread-safe lockfree language list *\/\n@@ -285,2 +304,1 @@\n-#if HB_USE_ATEXIT\n-static void\n+static inline void\n@@ -297,1 +315,1 @@\n-    free (first_lang);\n+    hb_free (first_lang);\n@@ -301,1 +319,0 @@\n-#endif\n@@ -314,1 +331,1 @@\n-  hb_language_item_t *lang = (hb_language_item_t *) calloc (1, sizeof (hb_language_item_t));\n+  hb_language_item_t *lang = (hb_language_item_t *) hb_calloc (1, sizeof (hb_language_item_t));\n@@ -321,1 +338,1 @@\n-    free (lang);\n+    hb_free (lang);\n@@ -328,1 +345,1 @@\n-    free (lang);\n+    hb_free (lang);\n@@ -332,1 +349,0 @@\n-#if HB_USE_ATEXIT\n@@ -334,2 +350,1 @@\n-    atexit (free_langs); \/* First person registers atexit() callback. *\/\n-#endif\n+    hb_atexit (free_langs); \/* First person registers atexit() callback. *\/\n@@ -422,1 +437,1 @@\n-    language = hb_language_from_string (setlocale (LC_CTYPE, nullptr), -1);\n+    language = hb_language_from_string (hb_setlocale (LC_CTYPE, nullptr), -1);\n@@ -604,0 +619,3 @@\n+    \/* Unicode-14.0 additions *\/\n+    case HB_SCRIPT_OLD_UYGHUR:\n+\n@@ -1045,0 +1063,41 @@\n+#ifndef HB_NO_SETLOCALE\n+\n+static inline void free_static_C_locale ();\n+\n+static struct hb_C_locale_lazy_loader_t : hb_lazy_loader_t<hb_remove_pointer<hb_locale_t>,\n+                                                           hb_C_locale_lazy_loader_t>\n+{\n+  static hb_locale_t create ()\n+  {\n+    hb_locale_t l = newlocale (LC_ALL_MASK, \"C\", NULL);\n+    if (!l)\n+      return l;\n+\n+    hb_atexit (free_static_C_locale);\n+\n+    return l;\n+  }\n+  static void destroy (hb_locale_t l)\n+  {\n+    freelocale (l);\n+  }\n+  static hb_locale_t get_null ()\n+  {\n+    return (hb_locale_t) 0;\n+  }\n+} static_C_locale;\n+\n+static inline\n+void free_static_C_locale ()\n+{\n+  static_C_locale.free_instance ();\n+}\n+\n+static hb_locale_t\n+get_C_locale ()\n+{\n+  return static_C_locale.get_unconst ();\n+}\n+\n+#endif\n+\n@@ -1070,0 +1129,3 @@\n+\n+  hb_locale_t oldlocale HB_UNUSED;\n+  oldlocale = hb_uselocale (get_C_locale ());\n@@ -1071,0 +1133,1 @@\n+  (void) hb_uselocale (oldlocale);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-common.cc","additions":85,"deletions":22,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -133,0 +133,10 @@\n+typedef union _hb_var_num_t {\n+  float f;\n+  uint32_t u32;\n+  int32_t i32;\n+  uint16_t u16[2];\n+  int16_t i16[2];\n+  uint8_t u8[4];\n+  int8_t i8[4];\n+} hb_var_num_t;\n+\n@@ -479,0 +489,6 @@\n+ * @HB_SCRIPT_CYPRO_MINOAN: `Cpmn`, Since: 3.0.0\n+ * @HB_SCRIPT_OLD_UYGHUR: `Ougr`, Since: 3.0.0\n+ * @HB_SCRIPT_TANGSA: `Tnsa`, Since: 3.0.0\n+ * @HB_SCRIPT_TOTO: `Toto`, Since: 3.0.0\n+ * @HB_SCRIPT_VITHKUQI: `Vith`, Since: 3.0.0\n+ * @HB_SCRIPT_MATH: `Zmth`, Since: 3.4.0\n@@ -686,0 +702,14 @@\n+  \/*\n+   * Since 3.0.0\n+   *\/\n+  HB_SCRIPT_CYPRO_MINOAN                = HB_TAG ('C','p','m','n'), \/*14.0*\/\n+  HB_SCRIPT_OLD_UYGHUR                  = HB_TAG ('O','u','g','r'), \/*14.0*\/\n+  HB_SCRIPT_TANGSA                      = HB_TAG ('T','n','s','a'), \/*14.0*\/\n+  HB_SCRIPT_TOTO                        = HB_TAG ('T','o','t','o'), \/*14.0*\/\n+  HB_SCRIPT_VITHKUQI                    = HB_TAG ('V','i','t','h'), \/*14.0*\/\n+\n+  \/*\n+   * Since 3.4.0\n+   *\/\n+  HB_SCRIPT_MATH                        = HB_TAG ('Z','m','t','h'),\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-common.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#define HB_NO_BUFFER_VERIFY\n@@ -66,0 +67,1 @@\n+#define HB_NO_LANGUAGE_LONG\n@@ -87,0 +89,1 @@\n+#define HB_NO_BORING_EXPANSION\n@@ -89,0 +92,6 @@\n+#if defined(HAVE_CONFIG_OVERRIDE_H) || defined(HB_CONFIG_OVERRIDE_H)\n+#ifndef HB_CONFIG_OVERRIDE_H\n+#define HB_CONFIG_OVERRIDE_H \"config-override.h\"\n+#endif\n+#include HB_CONFIG_OVERRIDE_H\n+#endif\n@@ -120,1 +129,1 @@\n-#define HB_NO_OT_LAYOUT_BLACKLIST\n+#define HB_NO_OT_LAYOUT_BLOCKLIST\n@@ -140,4 +149,4 @@\n-#define HB_NO_OT_SHAPE_COMPLEX_ARABIC_FALLBACK\n-#define HB_NO_OT_SHAPE_COMPLEX_HEBREW_FALLBACK\n-#define HB_NO_OT_SHAPE_COMPLEX_THAI_FALLBACK\n-#define HB_NO_OT_SHAPE_COMPLEX_VOWEL_CONSTRAINTS\n+#define HB_NO_OT_SHAPER_ARABIC_FALLBACK\n+#define HB_NO_OT_SHAPER_HEBREW_FALLBACK\n+#define HB_NO_OT_SHAPER_THAI_FALLBACK\n+#define HB_NO_OT_SHAPER_VOWEL_CONSTRAINTS\n@@ -158,2 +167,2 @@\n-#ifdef HAVE_CONFIG_OVERRIDE_H\n-#include \"config-override.h\"\n+#ifdef HB_OPTIMIZE_SIZE\n+#define HB_NO_OT_LAYOUT_LOOKUP_CACHE\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-config.hh","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright  2022 Behdad Esfahbod\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_CPLUSPLUS_HH\n+#define HB_CPLUSPLUS_HH\n+\n+#include \"hb.h\"\n+\n+HB_BEGIN_DECLS\n+HB_END_DECLS\n+\n+#ifdef __cplusplus\n+\n+#include <functional>\n+#include <utility>\n+\n+#if 0\n+#if !(__cplusplus >= 201103L)\n+#error \"HarfBuzz C++ helpers require C++11\"\n+#endif\n+#endif\n+\n+namespace hb {\n+\n+\n+template <typename T>\n+struct vtable;\n+\n+template <typename T>\n+struct shared_ptr\n+{\n+  using element_type = T;\n+\n+  using v = vtable<T>;\n+\n+  explicit shared_ptr (T *p = nullptr) : p (p) {}\n+  shared_ptr (const shared_ptr &o) : p (v::reference (o.p)) {}\n+  shared_ptr (shared_ptr &&o) : p (o.p) { o.p = nullptr; }\n+  shared_ptr& operator = (const shared_ptr &o) { if (p != o.p) { destroy (); p = o.p; reference (); } return *this; }\n+  shared_ptr& operator = (shared_ptr &&o) { v::destroy (p); p = o.p; o.p = nullptr; return *this; }\n+  ~shared_ptr () { v::destroy (p); p = nullptr; }\n+\n+  T* get() const { return p; }\n+\n+  void swap (shared_ptr &o) { std::swap (p, o.p); }\n+  friend void swap (shared_ptr &a, shared_ptr &b) { std::swap (a.p, b.p); }\n+\n+  operator T * () const { return p; }\n+  T& operator * () const { return *get (); }\n+  T* operator -> () const { return get (); }\n+  operator bool () { return p; }\n+  bool operator == (const shared_ptr &o) { return p == o.p; }\n+  bool operator != (const shared_ptr &o) { return p != o.p; }\n+\n+  static T* get_empty() { return v::get_empty (); }\n+  T* reference() { return v::reference (p); }\n+  void destroy() { v::destroy (p); }\n+  void set_user_data (hb_user_data_key_t *key,\n+                      void *value,\n+                      hb_destroy_func_t destroy,\n+                      hb_bool_t replace) { v::set_user_data (p, key, value, destroy, replace); }\n+  void * get_user_data (hb_user_data_key_t *key) { return v::get_user_data (p, key); }\n+\n+  private:\n+  T *p;\n+};\n+\n+template<typename T> struct is_shared_ptr : std::false_type {};\n+template<typename T> struct is_shared_ptr<shared_ptr<T>> : std::true_type {};\n+\n+template <typename T>\n+struct unique_ptr\n+{\n+  using element_type = T;\n+\n+  using v = vtable<T>;\n+\n+  explicit unique_ptr (T *p = nullptr) : p (p) {}\n+  unique_ptr (const unique_ptr &o) = delete;\n+  unique_ptr (unique_ptr &&o) : p (o.p) { o.p = nullptr; }\n+  unique_ptr& operator = (const unique_ptr &o) = delete;\n+  unique_ptr& operator = (unique_ptr &&o) { v::destroy (p); p = o.p; o.p = nullptr; return *this; }\n+  ~unique_ptr () { v::destroy (p); p = nullptr; }\n+\n+  T* get() const { return p; }\n+  T* release () { T* v = p; p = nullptr; return v; }\n+\n+  void swap (unique_ptr &o) { std::swap (p, o.p); }\n+  friend void swap (unique_ptr &a, unique_ptr &b) { std::swap (a.p, b.p); }\n+\n+  operator T * () const { return p; }\n+  T& operator * () const { return *get (); }\n+  T* operator -> () const { return get (); }\n+  operator bool () { return p; }\n+\n+  private:\n+  T *p;\n+};\n+\n+template<typename T> struct is_unique_ptr : std::false_type {};\n+template<typename T> struct is_unique_ptr<unique_ptr<T>> : std::true_type {};\n+\n+template <typename T,\n+          T * (*_get_empty) (void),\n+          T * (*_reference) (T *),\n+          void (*_destroy) (T *),\n+          hb_bool_t (*_set_user_data) (T *,\n+                                       hb_user_data_key_t *,\n+                                       void *,\n+                                       hb_destroy_func_t,\n+                                       hb_bool_t),\n+          void * (*_get_user_data) (T *,\n+                                    hb_user_data_key_t *)>\n+struct vtable_t\n+{\n+  static constexpr auto get_empty = _get_empty;\n+  static constexpr auto reference = _reference;\n+  static constexpr auto destroy = _destroy;\n+  static constexpr auto set_user_data = _set_user_data;\n+  static constexpr auto get_user_data = _get_user_data;\n+};\n+\n+#define HB_DEFINE_VTABLE(name) \\\n+        template<> \\\n+        struct vtable<hb_##name##_t> \\\n+             : vtable_t<hb_##name##_t, \\\n+                        &hb_##name##_get_empty, \\\n+                        &hb_##name##_reference, \\\n+                        &hb_##name##_destroy, \\\n+                        &hb_##name##_set_user_data, \\\n+                        &hb_##name##_get_user_data> {}\n+\n+HB_DEFINE_VTABLE (buffer);\n+HB_DEFINE_VTABLE (blob);\n+HB_DEFINE_VTABLE (face);\n+HB_DEFINE_VTABLE (font);\n+HB_DEFINE_VTABLE (font_funcs);\n+HB_DEFINE_VTABLE (map);\n+HB_DEFINE_VTABLE (set);\n+HB_DEFINE_VTABLE (shape_plan);\n+HB_DEFINE_VTABLE (unicode_funcs);\n+\n+#undef HB_DEFINE_VTABLE\n+\n+\n+} \/\/ namespace hb\n+\n+template<typename T>\n+struct std::hash<hb::shared_ptr<T>>\n+{\n+    std::size_t operator()(const hb::shared_ptr<T>& v) const noexcept\n+    {\n+        std::size_t h = std::hash<decltype (v.get ())>{}(v.get ());\n+        return h;\n+    }\n+};\n+\n+template<typename T>\n+struct std::hash<hb::unique_ptr<T>>\n+{\n+    std::size_t operator()(const hb::unique_ptr<T>& v) const noexcept\n+    {\n+        std::size_t h = std::hash<decltype (v.get ())>{}(v.get ());\n+        return h;\n+    }\n+};\n+\n+\n+#endif \/* __cplusplus *\/\n+\n+#endif \/* HB_CPLUSPLUS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cplusplus.hh","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -305,1 +305,1 @@\n-      return hb_forward<T> (v);\n+      return std::forward<T> (v);\n@@ -310,1 +310,1 @@\n-                              hb_printer_t<decltype (v)>().print (v), line);\n+                              hb_printer_t<hb_decay<decltype (v)>>().print (v), line);\n@@ -314,1 +314,1 @@\n-    return hb_forward<T> (v);\n+    return std::forward<T> (v);\n@@ -336,1 +336,1 @@\n-         unsigned int line HB_UNUSED = 0) { return hb_forward<T> (v); }\n+         unsigned int line HB_UNUSED = 0) { return std::forward<T> (v); }\n@@ -346,1 +346,1 @@\n-         unsigned int line HB_UNUSED = 0) { return hb_forward<T> (v); }\n+         unsigned int line HB_UNUSED = 0) { return std::forward<T> (v); }\n@@ -441,0 +441,4 @@\n+#ifndef HB_DEBUG_SUBSET_REPACK\n+#define HB_DEBUG_SUBSET_REPACK (HB_DEBUG+0)\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-debug.hh","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -110,3 +110,0 @@\n-HB_EXTERN HB_DEPRECATED void\n-hb_set_invert (hb_set_t *set);\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-deprecated.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  { return obj.dispatch (thiz (), hb_forward<Ts> (ds)...); }\n+  { return obj.dispatch (thiz (), std::forward<Ts> (ds)...); }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-dispatch.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#ifdef HB_EXPERIMENTAL_API\n@@ -31,4 +30,0 @@\n-#include \"hb-ot.h\"\n-#include \"hb-ot-glyf-table.hh\"\n-#include \"hb-ot-cff1-table.hh\"\n-#include \"hb-ot-cff2-table.hh\"\n@@ -37,3 +32,4 @@\n- * hb_draw_funcs_set_move_to_func:\n- * @funcs: draw functions object\n- * @move_to: move-to callback\n+ * SECTION:hb-draw\n+ * @title: hb-draw\n+ * @short_description: Glyph drawing\n+ * @include: hb.h\n@@ -41,3 +37,1 @@\n- * Sets move-to callback to the draw functions object.\n- *\n- * Since: EXPERIMENTAL\n+ * Functions for drawing (extracting) glyph shapes.\n@@ -45,3 +39,19 @@\n-void\n-hb_draw_funcs_set_move_to_func (hb_draw_funcs_t        *funcs,\n-                                hb_draw_move_to_func_t  move_to)\n+\n+static void\n+hb_draw_move_to_nil (hb_draw_funcs_t *dfuncs HB_UNUSED, void *draw_data HB_UNUSED,\n+                     hb_draw_state_t *st HB_UNUSED,\n+                     float to_x HB_UNUSED, float to_y HB_UNUSED,\n+                     void *user_data HB_UNUSED) {}\n+\n+static void\n+hb_draw_line_to_nil (hb_draw_funcs_t *dfuncs HB_UNUSED, void *draw_data HB_UNUSED,\n+                     hb_draw_state_t *st HB_UNUSED,\n+                     float to_x HB_UNUSED, float to_y HB_UNUSED,\n+                     void *user_data HB_UNUSED) {}\n+\n+static void\n+hb_draw_quadratic_to_nil (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                          hb_draw_state_t *st,\n+                          float control_x, float control_y,\n+                          float to_x, float to_y,\n+                          void *user_data HB_UNUSED)\n@@ -49,2 +59,68 @@\n-  if (unlikely (hb_object_is_immutable (funcs))) return;\n-  funcs->move_to = move_to;\n+#define HB_ONE_THIRD 0.33333333f\n+  dfuncs->emit_cubic_to (draw_data, *st,\n+                         (st->current_x + 2.f * control_x) * HB_ONE_THIRD,\n+                         (st->current_y + 2.f * control_y) * HB_ONE_THIRD,\n+                         (to_x + 2.f * control_x) * HB_ONE_THIRD,\n+                         (to_y + 2.f * control_y) * HB_ONE_THIRD,\n+                         to_x, to_y);\n+#undef HB_ONE_THIRD\n+}\n+\n+static void\n+hb_draw_cubic_to_nil (hb_draw_funcs_t *dfuncs HB_UNUSED, void *draw_data HB_UNUSED,\n+                      hb_draw_state_t *st HB_UNUSED,\n+                      float control1_x HB_UNUSED, float control1_y HB_UNUSED,\n+                      float control2_x HB_UNUSED, float control2_y HB_UNUSED,\n+                      float to_x HB_UNUSED, float to_y HB_UNUSED,\n+                      void *user_data HB_UNUSED) {}\n+\n+static void\n+hb_draw_close_path_nil (hb_draw_funcs_t *dfuncs HB_UNUSED, void *draw_data HB_UNUSED,\n+                        hb_draw_state_t *st HB_UNUSED,\n+                        void *user_data HB_UNUSED) {}\n+\n+\n+#define HB_DRAW_FUNC_IMPLEMENT(name)                                            \\\n+                                                                                \\\n+void                                                                            \\\n+hb_draw_funcs_set_##name##_func (hb_draw_funcs_t         *dfuncs,               \\\n+                                 hb_draw_##name##_func_t  func,                 \\\n+                                 void                    *user_data,            \\\n+                                 hb_destroy_func_t        destroy)              \\\n+{                                                                               \\\n+  if (hb_object_is_immutable (dfuncs))                                          \\\n+    return;                                                                     \\\n+                                                                                \\\n+  if (dfuncs->destroy && dfuncs->destroy->name)                                 \\\n+    dfuncs->destroy->name (!dfuncs->user_data ? nullptr : dfuncs->user_data->name); \\\n+                                                                         \\\n+  if (user_data && !dfuncs->user_data)                                   \\\n+  {                                                                      \\\n+    dfuncs->user_data = (decltype (dfuncs->user_data)) hb_calloc (1, sizeof (*dfuncs->user_data)); \\\n+    if (unlikely (!dfuncs->user_data))                                   \\\n+      goto fail;                                                         \\\n+  }                                                                      \\\n+  if (destroy && !dfuncs->destroy)                                       \\\n+  {                                                                      \\\n+    dfuncs->destroy = (decltype (dfuncs->destroy)) hb_calloc (1, sizeof (*dfuncs->destroy)); \\\n+    if (unlikely (!dfuncs->destroy))                                     \\\n+      goto fail;                                                         \\\n+  }                                                                      \\\n+                                                                        \\\n+  if (func) {                                                           \\\n+    dfuncs->func.name = func;                                           \\\n+    if (dfuncs->user_data)                                              \\\n+      dfuncs->user_data->name = user_data;                              \\\n+    if (dfuncs->destroy)                                                \\\n+      dfuncs->destroy->name = destroy;                                  \\\n+  } else {                                                              \\\n+    dfuncs->func.name = hb_draw_##name##_nil;                           \\\n+    if (dfuncs->user_data)                                              \\\n+      dfuncs->user_data->name = nullptr;                                \\\n+    if (dfuncs->destroy)                                                \\\n+      dfuncs->destroy->name = nullptr;                                  \\\n+  }                                                                     \\\n+                                                                         \\\n+fail:                                                                    \\\n+  if (destroy)                                                           \\\n+    destroy (user_data);                                                 \\\n@@ -53,0 +129,3 @@\n+HB_DRAW_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_DRAW_FUNC_IMPLEMENT\n+\n@@ -54,3 +133,3 @@\n- * hb_draw_funcs_set_line_to_func:\n- * @funcs: draw functions object\n- * @line_to: line-to callback\n+ * hb_draw_funcs_create:\n+ *\n+ * Creates a new draw callbacks object.\n@@ -58,1 +137,6 @@\n- * Sets line-to callback to the draw functions object.\n+ * Return value: (transfer full):\n+ * A newly allocated #hb_draw_funcs_t with a reference count of 1. The initial\n+ * reference count should be released with hb_draw_funcs_destroy when you are\n+ * done using the #hb_draw_funcs_t. This function never returns %NULL. If\n+ * memory cannot be allocated, a special singleton #hb_draw_funcs_t object will\n+ * be returned.\n@@ -60,1 +144,1 @@\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -62,3 +146,2 @@\n-void\n-hb_draw_funcs_set_line_to_func (hb_draw_funcs_t        *funcs,\n-                                hb_draw_line_to_func_t  line_to)\n+hb_draw_funcs_t *\n+hb_draw_funcs_create ()\n@@ -66,2 +149,7 @@\n-  if (unlikely (hb_object_is_immutable (funcs))) return;\n-  funcs->line_to = line_to;\n+  hb_draw_funcs_t *dfuncs;\n+  if (unlikely (!(dfuncs = hb_object_create<hb_draw_funcs_t> ())))\n+    return const_cast<hb_draw_funcs_t *> (&Null (hb_draw_funcs_t));\n+\n+  dfuncs->func =  Null (hb_draw_funcs_t).func;\n+\n+  return dfuncs;\n@@ -70,0 +158,12 @@\n+DEFINE_NULL_INSTANCE (hb_draw_funcs_t) =\n+{\n+  HB_OBJECT_HEADER_STATIC,\n+\n+  {\n+#define HB_DRAW_FUNC_IMPLEMENT(name) hb_draw_##name##_nil,\n+    HB_DRAW_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_DRAW_FUNC_IMPLEMENT\n+  }\n+};\n+\n+\n@@ -71,3 +171,5 @@\n- * hb_draw_funcs_set_quadratic_to_func:\n- * @funcs: draw functions object\n- * @move_to: quadratic-to callback\n+ * hb_draw_funcs_reference: (skip)\n+ * @dfuncs: draw functions\n+ *\n+ * Increases the reference count on @dfuncs by one. This prevents @buffer from\n+ * being destroyed until a matching call to hb_draw_funcs_destroy() is made.\n@@ -75,1 +177,2 @@\n- * Sets quadratic-to callback to the draw functions object.\n+ * Return value: (transfer full):\n+ * The referenced #hb_draw_funcs_t.\n@@ -77,1 +180,1 @@\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -79,3 +182,2 @@\n-void\n-hb_draw_funcs_set_quadratic_to_func (hb_draw_funcs_t             *funcs,\n-                                     hb_draw_quadratic_to_func_t  quadratic_to)\n+hb_draw_funcs_t *\n+hb_draw_funcs_reference (hb_draw_funcs_t *dfuncs)\n@@ -83,3 +185,1 @@\n-  if (unlikely (hb_object_is_immutable (funcs))) return;\n-  funcs->quadratic_to = quadratic_to;\n-  funcs->is_quadratic_to_set = true;\n+  return hb_object_reference (dfuncs);\n@@ -89,3 +189,2 @@\n- * hb_draw_funcs_set_cubic_to_func:\n- * @funcs: draw functions\n- * @cubic_to: cubic-to callback\n+ * hb_draw_funcs_destroy: (skip)\n+ * @dfuncs: draw functions\n@@ -93,1 +192,3 @@\n- * Sets cubic-to callback to the draw functions object.\n+ * Deallocate the @dfuncs.\n+ * Decreases the reference count on @dfuncs by one. If the result is zero, then\n+ * @dfuncs and all associated resources are freed. See hb_draw_funcs_reference().\n@@ -95,1 +196,1 @@\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -98,2 +199,1 @@\n-hb_draw_funcs_set_cubic_to_func (hb_draw_funcs_t         *funcs,\n-                                 hb_draw_cubic_to_func_t  cubic_to)\n+hb_draw_funcs_destroy (hb_draw_funcs_t *dfuncs)\n@@ -101,2 +201,11 @@\n-  if (unlikely (hb_object_is_immutable (funcs))) return;\n-  funcs->cubic_to = cubic_to;\n+  if (!hb_object_destroy (dfuncs)) return;\n+\n+  if (dfuncs->destroy)\n+  {\n+#define HB_DRAW_FUNC_IMPLEMENT(name) \\\n+    if (dfuncs->destroy->name) dfuncs->destroy->name (!dfuncs->user_data ? nullptr : dfuncs->user_data->name);\n+      HB_DRAW_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_DRAW_FUNC_IMPLEMENT\n+  }\n+\n+  hb_free (dfuncs);\n@@ -106,3 +215,2 @@\n- * hb_draw_funcs_set_close_path_func:\n- * @funcs: draw functions object\n- * @close_path: close-path callback\n+ * hb_draw_funcs_make_immutable:\n+ * @dfuncs: draw functions\n@@ -110,1 +218,1 @@\n- * Sets close-path callback to the draw functions object.\n+ * Makes @dfuncs object immutable.\n@@ -112,1 +220,1 @@\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -115,2 +223,1 @@\n-hb_draw_funcs_set_close_path_func (hb_draw_funcs_t           *funcs,\n-                                   hb_draw_close_path_func_t  close_path)\n+hb_draw_funcs_make_immutable (hb_draw_funcs_t *dfuncs)\n@@ -118,20 +225,2 @@\n-  if (unlikely (hb_object_is_immutable (funcs))) return;\n-  funcs->close_path = close_path;\n-}\n-\n-static void\n-_move_to_nil (hb_position_t to_x HB_UNUSED, hb_position_t to_y HB_UNUSED, void *user_data HB_UNUSED) {}\n-\n-static void\n-_line_to_nil (hb_position_t to_x HB_UNUSED, hb_position_t to_y HB_UNUSED, void *user_data HB_UNUSED) {}\n-\n-static void\n-_quadratic_to_nil (hb_position_t control_x HB_UNUSED, hb_position_t control_y HB_UNUSED,\n-                   hb_position_t to_x HB_UNUSED, hb_position_t to_y HB_UNUSED,\n-                   void *user_data HB_UNUSED) {}\n-\n-static void\n-_cubic_to_nil (hb_position_t control1_x HB_UNUSED, hb_position_t control1_y HB_UNUSED,\n-               hb_position_t control2_x HB_UNUSED, hb_position_t control2_y HB_UNUSED,\n-               hb_position_t to_x HB_UNUSED, hb_position_t to_y HB_UNUSED,\n-               void *user_data HB_UNUSED) {}\n+  if (hb_object_is_immutable (dfuncs))\n+    return;\n@@ -139,2 +228,2 @@\n-static void\n-_close_path_nil (void *user_data HB_UNUSED) {}\n+  hb_object_make_immutable (dfuncs);\n+}\n@@ -143,1 +232,2 @@\n- * hb_draw_funcs_create:\n+ * hb_draw_funcs_is_immutable:\n+ * @dfuncs: draw functions\n@@ -145,1 +235,1 @@\n- * Creates a new draw callbacks object.\n+ * Checks whether @dfuncs is immutable.\n@@ -147,1 +237,3 @@\n- * Since: EXPERIMENTAL\n+ * Return value: %true if @dfuncs is immutable, %false otherwise\n+ *\n+ * Since: 4.0.0\n@@ -149,2 +241,2 @@\n-hb_draw_funcs_t *\n-hb_draw_funcs_create ()\n+hb_bool_t\n+hb_draw_funcs_is_immutable (hb_draw_funcs_t *dfuncs)\n@@ -152,11 +244,1 @@\n-  hb_draw_funcs_t *funcs;\n-  if (unlikely (!(funcs = hb_object_create<hb_draw_funcs_t> ())))\n-    return const_cast<hb_draw_funcs_t *> (&Null (hb_draw_funcs_t));\n-\n-  funcs->move_to = (hb_draw_move_to_func_t) _move_to_nil;\n-  funcs->line_to = (hb_draw_line_to_func_t) _line_to_nil;\n-  funcs->quadratic_to = (hb_draw_quadratic_to_func_t) _quadratic_to_nil;\n-  funcs->is_quadratic_to_set = false;\n-  funcs->cubic_to = (hb_draw_cubic_to_func_t) _cubic_to_nil;\n-  funcs->close_path = (hb_draw_close_path_func_t) _close_path_nil;\n-  return funcs;\n+  return hb_object_is_immutable (dfuncs);\n@@ -165,0 +247,1 @@\n+\n@@ -166,2 +249,6 @@\n- * hb_draw_funcs_reference:\n- * @funcs: draw functions\n+ * hb_draw_move_to:\n+ * @dfuncs: draw functions\n+ * @draw_data: associated draw data passed by the caller\n+ * @st: current draw state\n+ * @to_x: X component of target point\n+ * @to_y: Y component of target point\n@@ -169,1 +256,1 @@\n- * Add to callbacks object refcount.\n+ * Perform a \"move-to\" draw operation.\n@@ -171,2 +258,1 @@\n- * Returns: The same object.\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -174,2 +260,4 @@\n-hb_draw_funcs_t *\n-hb_draw_funcs_reference (hb_draw_funcs_t *funcs)\n+void\n+hb_draw_move_to (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                 hb_draw_state_t *st,\n+                 float to_x, float to_y)\n@@ -177,1 +265,2 @@\n-  return hb_object_reference (funcs);\n+  dfuncs->move_to (draw_data, *st,\n+                   to_x, to_y);\n@@ -181,2 +270,6 @@\n- * hb_draw_funcs_destroy:\n- * @funcs: draw functions\n+ * hb_draw_line_to:\n+ * @dfuncs: draw functions\n+ * @draw_data: associated draw data passed by the caller\n+ * @st: current draw state\n+ * @to_x: X component of target point\n+ * @to_y: Y component of target point\n@@ -184,2 +277,1 @@\n- * Decreases refcount of callbacks object and deletes the object if it reaches\n- * to zero.\n+ * Perform a \"line-to\" draw operation.\n@@ -187,1 +279,1 @@\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -190,1 +282,3 @@\n-hb_draw_funcs_destroy (hb_draw_funcs_t *funcs)\n+hb_draw_line_to (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                 hb_draw_state_t *st,\n+                 float to_x, float to_y)\n@@ -192,3 +286,2 @@\n-  if (!hb_object_destroy (funcs)) return;\n-\n-  free (funcs);\n+  dfuncs->line_to (draw_data, *st,\n+                   to_x, to_y);\n@@ -198,2 +291,8 @@\n- * hb_draw_funcs_make_immutable:\n- * @funcs: draw functions\n+ * hb_draw_quadratic_to:\n+ * @dfuncs: draw functions\n+ * @draw_data: associated draw data passed by the caller\n+ * @st: current draw state\n+ * @control_x: X component of control point\n+ * @control_y: Y component of control point\n+ * @to_x: X component of target point\n+ * @to_y: Y component of target point\n@@ -201,1 +300,1 @@\n- * Makes funcs object immutable.\n+ * Perform a \"quadratic-to\" draw operation.\n@@ -203,1 +302,1 @@\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -206,1 +305,4 @@\n-hb_draw_funcs_make_immutable (hb_draw_funcs_t *funcs)\n+hb_draw_quadratic_to (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                      hb_draw_state_t *st,\n+                      float control_x, float control_y,\n+                      float to_x, float to_y)\n@@ -208,4 +310,3 @@\n-  if (hb_object_is_immutable (funcs))\n-    return;\n-\n-  hb_object_make_immutable (funcs);\n+  dfuncs->quadratic_to (draw_data, *st,\n+                        control_x, control_y,\n+                        to_x, to_y);\n@@ -215,2 +316,10 @@\n- * hb_draw_funcs_is_immutable:\n- * @funcs: draw functions\n+ * hb_draw_cubic_to:\n+ * @dfuncs: draw functions\n+ * @draw_data: associated draw data passed by the caller\n+ * @st: current draw state\n+ * @control1_x: X component of first control point\n+ * @control1_y: Y component of first control point\n+ * @control2_x: X component of second control point\n+ * @control2_y: Y component of second control point\n+ * @to_x: X component of target point\n+ * @to_y: Y component of target point\n@@ -218,1 +327,1 @@\n- * Checks whether funcs is immutable.\n+ * Perform a \"cubic-to\" draw operation.\n@@ -220,2 +329,1 @@\n- * Returns: If is immutable.\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -223,2 +331,6 @@\n-hb_bool_t\n-hb_draw_funcs_is_immutable (hb_draw_funcs_t *funcs)\n+void\n+hb_draw_cubic_to (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                  hb_draw_state_t *st,\n+                  float control1_x, float control1_y,\n+                  float control2_x, float control2_y,\n+                  float to_x, float to_y)\n@@ -226,1 +338,4 @@\n-  return hb_object_is_immutable (funcs);\n+  dfuncs->cubic_to (draw_data, *st,\n+                    control1_x, control1_y,\n+                    control2_x, control2_y,\n+                    to_x, to_y);\n@@ -230,5 +345,4 @@\n- * hb_font_draw_glyph:\n- * @font: a font object\n- * @glyph: a glyph id\n- * @funcs: draw callbacks object\n- * @user_data: parameter you like be passed to the callbacks when are called\n+ * hb_draw_close_path:\n+ * @dfuncs: draw functions\n+ * @draw_data: associated draw data passed by the caller\n+ * @st: current draw state\n@@ -236,1 +350,1 @@\n- * Draw a glyph.\n+ * Perform a \"close-path\" draw operation.\n@@ -238,2 +352,1 @@\n- * Returns: Whether the font had the glyph and the operation completed successfully.\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -241,4 +354,3 @@\n-hb_bool_t\n-hb_font_draw_glyph (hb_font_t *font, hb_codepoint_t glyph,\n-                    const hb_draw_funcs_t *funcs,\n-                    void *user_data)\n+void\n+hb_draw_close_path (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                    hb_draw_state_t *st)\n@@ -246,12 +358,1 @@\n-  if (unlikely (funcs == &Null (hb_draw_funcs_t) ||\n-                glyph >= font->face->get_num_glyphs ()))\n-    return false;\n-\n-  draw_helper_t draw_helper (funcs, user_data);\n-  if (font->face->table.glyf->get_path (font, glyph, draw_helper)) return true;\n-#ifndef HB_NO_CFF\n-  if (font->face->table.cff1->get_path (font, glyph, draw_helper)) return true;\n-  if (font->face->table.cff2->get_path (font, glyph, draw_helper)) return true;\n-#endif\n-\n-  return false;\n+  dfuncs->close_path (draw_data, *st);\n@@ -260,1 +361,1 @@\n-#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-draw.cc","additions":251,"deletions":150,"binary":false,"changes":401,"status":"modified"},{"patch":"@@ -36,11 +36,39 @@\n-#ifdef HB_EXPERIMENTAL_API\n-typedef void (*hb_draw_move_to_func_t) (hb_position_t to_x, hb_position_t to_y, void *user_data);\n-typedef void (*hb_draw_line_to_func_t) (hb_position_t to_x, hb_position_t to_y, void *user_data);\n-typedef void (*hb_draw_quadratic_to_func_t) (hb_position_t control_x, hb_position_t control_y,\n-                                             hb_position_t to_x, hb_position_t to_y,\n-                                             void *user_data);\n-typedef void (*hb_draw_cubic_to_func_t) (hb_position_t control1_x, hb_position_t control1_y,\n-                                         hb_position_t control2_x, hb_position_t control2_y,\n-                                         hb_position_t to_x, hb_position_t to_y,\n-                                         void *user_data);\n-typedef void (*hb_draw_close_path_func_t) (void *user_data);\n+\n+\/**\n+ * hb_draw_state_t\n+ * @path_open: Whether there is an open path\n+ * @path_start_x: X component of the start of current path\n+ * @path_start_y: Y component of the start of current path\n+ * @current_x: X component of current point\n+ * @current_y: Y component of current point\n+ *\n+ * Current drawing state.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+typedef struct hb_draw_state_t {\n+  hb_bool_t path_open;\n+\n+  float path_start_x;\n+  float path_start_y;\n+\n+  float current_x;\n+  float current_y;\n+\n+  \/*< private >*\/\n+  hb_var_num_t   reserved1;\n+  hb_var_num_t   reserved2;\n+  hb_var_num_t   reserved3;\n+  hb_var_num_t   reserved4;\n+  hb_var_num_t   reserved5;\n+  hb_var_num_t   reserved6;\n+  hb_var_num_t   reserved7;\n+} hb_draw_state_t;\n+\n+\/**\n+ * HB_DRAW_STATE_DEFAULT:\n+ *\n+ * The default #hb_draw_state_t at the start of glyph drawing.\n+ *\/\n+#define HB_DRAW_STATE_DEFAULT {0, 0.f, 0.f, 0.f, 0.f, {0.}, {0.}, {0.}}\n+\n@@ -53,2 +81,4 @@\n- * _move_to, _line_to and _cubic_to calls are nessecary to be defined but we\n- * translate _quadratic_to calls to _cubic_to if the callback isn't defined.\n+ * #hb_draw_move_to_func_t, #hb_draw_line_to_func_t and\n+ * #hb_draw_cubic_to_func_t calls are necessary to be defined but we translate\n+ * #hb_draw_quadratic_to_func_t calls to #hb_draw_cubic_to_func_t if the\n+ * callback isn't defined.\n@@ -56,1 +86,1 @@\n- * Since: EXPERIMENTAL\n+ * Since: 4.0.0\n@@ -58,0 +88,1 @@\n+\n@@ -60,0 +91,118 @@\n+\n+\/**\n+ * hb_draw_move_to_func_t:\n+ * @dfuncs: draw functions object\n+ * @draw_data: The data accompanying the draw functions\n+ * @st: current draw state\n+ * @to_x: X component of target point\n+ * @to_y: Y component of target point\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_draw_funcs_t to perform a \"move-to\" draw\n+ * operation.\n+ *\n+ * Since: 4.0.0\n+ *\n+ **\/\n+typedef void (*hb_draw_move_to_func_t) (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                                        hb_draw_state_t *st,\n+                                        float to_x, float to_y,\n+                                        void *user_data);\n+\n+\/**\n+ * hb_draw_line_to_func_t:\n+ * @dfuncs: draw functions object\n+ * @draw_data: The data accompanying the draw functions\n+ * @st: current draw state\n+ * @to_x: X component of target point\n+ * @to_y: Y component of target point\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_draw_funcs_t to perform a \"line-to\" draw\n+ * operation.\n+ *\n+ * Since: 4.0.0\n+ *\n+ **\/\n+typedef void (*hb_draw_line_to_func_t) (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                                        hb_draw_state_t *st,\n+                                        float to_x, float to_y,\n+                                        void *user_data);\n+\n+\/**\n+ * hb_draw_quadratic_to_func_t:\n+ * @dfuncs: draw functions object\n+ * @draw_data: The data accompanying the draw functions\n+ * @st: current draw state\n+ * @control_x: X component of control point\n+ * @control_y: Y component of control point\n+ * @to_x: X component of target point\n+ * @to_y: Y component of target point\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_draw_funcs_t to perform a \"quadratic-to\" draw\n+ * operation.\n+ *\n+ * Since: 4.0.0\n+ *\n+ **\/\n+typedef void (*hb_draw_quadratic_to_func_t) (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                                             hb_draw_state_t *st,\n+                                             float control_x, float control_y,\n+                                             float to_x, float to_y,\n+                                             void *user_data);\n+\n+\/**\n+ * hb_draw_cubic_to_func_t:\n+ * @dfuncs: draw functions object\n+ * @draw_data: The data accompanying the draw functions\n+ * @st: current draw state\n+ * @control1_x: X component of first control point\n+ * @control1_y: Y component of first control point\n+ * @control2_x: X component of second control point\n+ * @control2_y: Y component of second control point\n+ * @to_x: X component of target point\n+ * @to_y: Y component of target point\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_draw_funcs_t to perform a \"cubic-to\" draw\n+ * operation.\n+ *\n+ * Since: 4.0.0\n+ *\n+ **\/\n+typedef void (*hb_draw_cubic_to_func_t) (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                                         hb_draw_state_t *st,\n+                                         float control1_x, float control1_y,\n+                                         float control2_x, float control2_y,\n+                                         float to_x, float to_y,\n+                                         void *user_data);\n+\n+\/**\n+ * hb_draw_close_path_func_t:\n+ * @dfuncs: draw functions object\n+ * @draw_data: The data accompanying the draw functions\n+ * @st: current draw state\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_draw_funcs_t to perform a \"close-path\" draw\n+ * operation.\n+ *\n+ * Since: 4.0.0\n+ *\n+ **\/\n+typedef void (*hb_draw_close_path_func_t) (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                                           hb_draw_state_t *st,\n+                                           void *user_data);\n+\n+\/**\n+ * hb_draw_funcs_set_move_to_func:\n+ * @dfuncs: draw functions object\n+ * @func: (closure user_data) (destroy destroy) (scope notified): move-to callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is not needed anymore\n+ *\n+ * Sets move-to callback to the draw functions object.\n+ *\n+ * Since: 4.0.0\n+ **\/\n@@ -61,2 +210,3 @@\n-hb_draw_funcs_set_move_to_func (hb_draw_funcs_t        *funcs,\n-                                hb_draw_move_to_func_t  move_to);\n+hb_draw_funcs_set_move_to_func (hb_draw_funcs_t        *dfuncs,\n+                                hb_draw_move_to_func_t  func,\n+                                void *user_data, hb_destroy_func_t destroy);\n@@ -64,0 +214,11 @@\n+\/**\n+ * hb_draw_funcs_set_line_to_func:\n+ * @dfuncs: draw functions object\n+ * @func: (closure user_data) (destroy destroy) (scope notified): line-to callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is not needed anymore\n+ *\n+ * Sets line-to callback to the draw functions object.\n+ *\n+ * Since: 4.0.0\n+ **\/\n@@ -65,2 +226,3 @@\n-hb_draw_funcs_set_line_to_func (hb_draw_funcs_t        *funcs,\n-                                hb_draw_line_to_func_t  line_to);\n+hb_draw_funcs_set_line_to_func (hb_draw_funcs_t        *dfuncs,\n+                                hb_draw_line_to_func_t  func,\n+                                void *user_data, hb_destroy_func_t destroy);\n@@ -68,0 +230,11 @@\n+\/**\n+ * hb_draw_funcs_set_quadratic_to_func:\n+ * @dfuncs: draw functions object\n+ * @func: (closure user_data) (destroy destroy) (scope notified): quadratic-to callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is not needed anymore\n+ *\n+ * Sets quadratic-to callback to the draw functions object.\n+ *\n+ * Since: 4.0.0\n+ **\/\n@@ -69,2 +242,3 @@\n-hb_draw_funcs_set_quadratic_to_func (hb_draw_funcs_t             *funcs,\n-                                     hb_draw_quadratic_to_func_t  quadratic_to);\n+hb_draw_funcs_set_quadratic_to_func (hb_draw_funcs_t             *dfuncs,\n+                                     hb_draw_quadratic_to_func_t  func,\n+                                     void *user_data, hb_destroy_func_t destroy);\n@@ -72,0 +246,11 @@\n+\/**\n+ * hb_draw_funcs_set_cubic_to_func:\n+ * @dfuncs: draw functions\n+ * @func: (closure user_data) (destroy destroy) (scope notified): cubic-to callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is not needed anymore\n+ *\n+ * Sets cubic-to callback to the draw functions object.\n+ *\n+ * Since: 4.0.0\n+ **\/\n@@ -73,2 +258,3 @@\n-hb_draw_funcs_set_cubic_to_func (hb_draw_funcs_t         *funcs,\n-                                 hb_draw_cubic_to_func_t  cubic_to);\n+hb_draw_funcs_set_cubic_to_func (hb_draw_funcs_t         *dfuncs,\n+                                 hb_draw_cubic_to_func_t  func,\n+                                 void *user_data, hb_destroy_func_t destroy);\n@@ -76,0 +262,11 @@\n+\/**\n+ * hb_draw_funcs_set_close_path_func:\n+ * @dfuncs: draw functions object\n+ * @func: (closure user_data) (destroy destroy) (scope notified): close-path callback\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is not needed anymore\n+ *\n+ * Sets close-path callback to the draw functions object.\n+ *\n+ * Since: 4.0.0\n+ **\/\n@@ -77,2 +274,4 @@\n-hb_draw_funcs_set_close_path_func (hb_draw_funcs_t           *funcs,\n-                                   hb_draw_close_path_func_t  close_path);\n+hb_draw_funcs_set_close_path_func (hb_draw_funcs_t           *dfuncs,\n+                                   hb_draw_close_path_func_t  func,\n+                                   void *user_data, hb_destroy_func_t destroy);\n+\n@@ -84,1 +283,1 @@\n-hb_draw_funcs_reference (hb_draw_funcs_t *funcs);\n+hb_draw_funcs_reference (hb_draw_funcs_t *dfuncs);\n@@ -87,1 +286,1 @@\n-hb_draw_funcs_destroy (hb_draw_funcs_t *funcs);\n+hb_draw_funcs_destroy (hb_draw_funcs_t *dfuncs);\n@@ -90,1 +289,1 @@\n-hb_draw_funcs_make_immutable (hb_draw_funcs_t *funcs);\n+hb_draw_funcs_make_immutable (hb_draw_funcs_t *dfuncs);\n@@ -93,2 +292,30 @@\n-hb_draw_funcs_is_immutable (hb_draw_funcs_t *funcs);\n-#endif\n+hb_draw_funcs_is_immutable (hb_draw_funcs_t *dfuncs);\n+\n+\n+HB_EXTERN void\n+hb_draw_move_to (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                 hb_draw_state_t *st,\n+                 float to_x, float to_y);\n+\n+HB_EXTERN void\n+hb_draw_line_to (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                 hb_draw_state_t *st,\n+                 float to_x, float to_y);\n+\n+HB_EXTERN void\n+hb_draw_quadratic_to (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                      hb_draw_state_t *st,\n+                      float control_x, float control_y,\n+                      float to_x, float to_y);\n+\n+HB_EXTERN void\n+hb_draw_cubic_to (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                  hb_draw_state_t *st,\n+                  float control1_x, float control1_y,\n+                  float control2_x, float control2_y,\n+                  float to_x, float to_y);\n+\n+HB_EXTERN void\n+hb_draw_close_path (hb_draw_funcs_t *dfuncs, void *draw_data,\n+                    hb_draw_state_t *st);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-draw.h","additions":256,"deletions":29,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -30,4 +30,0 @@\n-#ifdef HB_EXPERIMENTAL_API\n-struct hb_draw_funcs_t\n-{\n-  hb_object_header_t header;\n@@ -35,7 +31,11 @@\n-  hb_draw_move_to_func_t move_to;\n-  hb_draw_line_to_func_t line_to;\n-  hb_draw_quadratic_to_func_t quadratic_to;\n-  bool is_quadratic_to_set;\n-  hb_draw_cubic_to_func_t cubic_to;\n-  hb_draw_close_path_func_t close_path;\n-};\n+\/*\n+ * hb_draw_funcs_t\n+ *\/\n+\n+#define HB_DRAW_FUNCS_IMPLEMENT_CALLBACKS \\\n+  HB_DRAW_FUNC_IMPLEMENT (move_to) \\\n+  HB_DRAW_FUNC_IMPLEMENT (line_to) \\\n+  HB_DRAW_FUNC_IMPLEMENT (quadratic_to) \\\n+  HB_DRAW_FUNC_IMPLEMENT (cubic_to) \\\n+  HB_DRAW_FUNC_IMPLEMENT (close_path) \\\n+  \/* ^--- Add new callbacks here *\/\n@@ -43,1 +43,1 @@\n-struct draw_helper_t\n+struct hb_draw_funcs_t\n@@ -45,8 +45,1 @@\n-  draw_helper_t (const hb_draw_funcs_t *funcs_, void *user_data_)\n-  {\n-    funcs = funcs_;\n-    user_data = user_data_;\n-    path_open = false;\n-    path_start_x = current_x = path_start_y = current_y = 0;\n-  }\n-  ~draw_helper_t () { end_path (); }\n+  hb_object_header_t header;\n@@ -54,1 +47,51 @@\n-  void move_to (hb_position_t x, hb_position_t y)\n+  struct {\n+#define HB_DRAW_FUNC_IMPLEMENT(name) hb_draw_##name##_func_t name;\n+    HB_DRAW_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_DRAW_FUNC_IMPLEMENT\n+  } func;\n+\n+  struct {\n+#define HB_DRAW_FUNC_IMPLEMENT(name) void *name;\n+    HB_DRAW_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_DRAW_FUNC_IMPLEMENT\n+  } *user_data;\n+\n+  struct {\n+#define HB_DRAW_FUNC_IMPLEMENT(name) hb_destroy_func_t name;\n+    HB_DRAW_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_DRAW_FUNC_IMPLEMENT\n+  } *destroy;\n+\n+  void emit_move_to (void *draw_data, hb_draw_state_t &st,\n+                     float to_x, float to_y)\n+  { func.move_to (this, draw_data, &st,\n+                  to_x, to_y,\n+                  !user_data ? nullptr : user_data->move_to); }\n+  void emit_line_to (void *draw_data, hb_draw_state_t &st,\n+                     float to_x, float to_y)\n+  { func.line_to (this, draw_data, &st,\n+                  to_x, to_y,\n+                  !user_data ? nullptr : user_data->line_to); }\n+  void emit_quadratic_to (void *draw_data, hb_draw_state_t &st,\n+                          float control_x, float control_y,\n+                          float to_x, float to_y)\n+  { func.quadratic_to (this, draw_data, &st,\n+                       control_x, control_y,\n+                       to_x, to_y,\n+                       !user_data ? nullptr : user_data->quadratic_to); }\n+  void emit_cubic_to (void *draw_data, hb_draw_state_t &st,\n+                      float control1_x, float control1_y,\n+                      float control2_x, float control2_y,\n+                      float to_x, float to_y)\n+  { func.cubic_to (this, draw_data, &st,\n+                   control1_x, control1_y,\n+                   control2_x, control2_y,\n+                   to_x, to_y,\n+                   !user_data ? nullptr : user_data->cubic_to); }\n+  void emit_close_path (void *draw_data, hb_draw_state_t &st)\n+  { func.close_path (this, draw_data, &st,\n+                     !user_data ? nullptr : user_data->close_path); }\n+\n+\n+  void move_to (void *draw_data, hb_draw_state_t &st,\n+                float to_x, float to_y)\n@@ -56,3 +99,3 @@\n-    if (path_open) end_path ();\n-    current_x = path_start_x = x;\n-    current_y = path_start_y = y;\n+    if (st.path_open) close_path (draw_data, st);\n+    st.current_x = to_x;\n+    st.current_y = to_y;\n@@ -61,1 +104,2 @@\n-  void line_to (hb_position_t x, hb_position_t y)\n+  void line_to (void *draw_data, hb_draw_state_t &st,\n+                float to_x, float to_y)\n@@ -63,5 +107,4 @@\n-    if (equal_to_current (x, y)) return;\n-    if (!path_open) start_path ();\n-    funcs->line_to (x, y, user_data);\n-    current_x = x;\n-    current_y = y;\n+    if (!st.path_open) start_path (draw_data, st);\n+    emit_line_to (draw_data, st, to_x, to_y);\n+    st.current_x = to_x;\n+    st.current_y = to_y;\n@@ -71,2 +114,3 @@\n-  quadratic_to (hb_position_t control_x, hb_position_t control_y,\n-                hb_position_t to_x, hb_position_t to_y)\n+  quadratic_to (void *draw_data, hb_draw_state_t &st,\n+                float control_x, float control_y,\n+                float to_x, float to_y)\n@@ -74,13 +118,4 @@\n-    if (equal_to_current (control_x, control_y) && equal_to_current (to_x, to_y))\n-      return;\n-    if (!path_open) start_path ();\n-    if (funcs->is_quadratic_to_set)\n-      funcs->quadratic_to (control_x, control_y, to_x, to_y, user_data);\n-    else\n-      funcs->cubic_to (roundf ((current_x + 2.f * control_x) \/ 3.f),\n-                       roundf ((current_y + 2.f * control_y) \/ 3.f),\n-                       roundf ((to_x + 2.f * control_x) \/ 3.f),\n-                       roundf ((to_y + 2.f * control_y) \/ 3.f),\n-                       to_x, to_y, user_data);\n-    current_x = to_x;\n-    current_y = to_y;\n+    if (!st.path_open) start_path (draw_data, st);\n+    emit_quadratic_to (draw_data, st, control_x, control_y, to_x, to_y);\n+    st.current_x = to_x;\n+    st.current_y = to_y;\n@@ -90,3 +125,4 @@\n-  cubic_to (hb_position_t control1_x, hb_position_t control1_y,\n-            hb_position_t control2_x, hb_position_t control2_y,\n-            hb_position_t to_x, hb_position_t to_y)\n+  cubic_to (void *draw_data, hb_draw_state_t &st,\n+            float control1_x, float control1_y,\n+            float control2_x, float control2_y,\n+            float to_x, float to_y)\n@@ -94,8 +130,4 @@\n-    if (equal_to_current (control1_x, control1_y) &&\n-        equal_to_current (control2_x, control2_y) &&\n-        equal_to_current (to_x, to_y))\n-      return;\n-    if (!path_open) start_path ();\n-    funcs->cubic_to (control1_x, control1_y, control2_x, control2_y, to_x, to_y, user_data);\n-    current_x = to_x;\n-    current_y = to_y;\n+    if (!st.path_open) start_path (draw_data, st);\n+    emit_cubic_to (draw_data, st, control1_x, control1_y, control2_x, control2_y, to_x, to_y);\n+    st.current_x = to_x;\n+    st.current_y = to_y;\n@@ -104,1 +136,2 @@\n-  void end_path ()\n+  void\n+  close_path (void *draw_data, hb_draw_state_t &st)\n@@ -106,1 +139,1 @@\n-    if (path_open)\n+    if (st.path_open)\n@@ -108,3 +141,3 @@\n-      if ((path_start_x != current_x) || (path_start_y != current_y))\n-        funcs->line_to (path_start_x, path_start_y, user_data);\n-      funcs->close_path (user_data);\n+      if ((st.path_start_x != st.current_x) || (st.path_start_y != st.current_y))\n+        emit_line_to (draw_data, st, st.path_start_x, st.path_start_y);\n+      emit_close_path (draw_data, st);\n@@ -112,2 +145,2 @@\n-    path_open = false;\n-    path_start_x = current_x = path_start_y = current_y = 0;\n+    st.path_open = false;\n+    st.path_start_x = st.current_x = st.path_start_y = st.current_y = 0;\n@@ -117,2 +150,0 @@\n-  bool equal_to_current (hb_position_t x, hb_position_t y)\n-  { return current_x == x && current_y == y; }\n@@ -120,1 +151,1 @@\n-  void start_path ()\n+  void start_path (void *draw_data, hb_draw_state_t &st)\n@@ -122,3 +153,5 @@\n-    if (path_open) end_path ();\n-    path_open = true;\n-    funcs->move_to (path_start_x, path_start_y, user_data);\n+    assert (!st.path_open);\n+    emit_move_to (draw_data, st, st.current_x, st.current_y);\n+    st.path_open = true;\n+    st.path_start_x = st.current_x;\n+    st.path_start_y = st.current_y;\n@@ -126,0 +159,2 @@\n+};\n+DECLARE_NULL_INSTANCE (hb_draw_funcs_t);\n@@ -127,2 +162,6 @@\n-  hb_position_t path_start_x;\n-  hb_position_t path_start_y;\n+struct hb_draw_session_t\n+{\n+  hb_draw_session_t (hb_draw_funcs_t *funcs_, void *draw_data_, float slant_ = 0.f)\n+    : slant {slant_}, not_slanted {slant == 0.f},\n+      funcs {funcs_}, draw_data {draw_data_}, st HB_DRAW_STATE_DEFAULT\n+  {}\n@@ -130,2 +169,1 @@\n-  hb_position_t current_x;\n-  hb_position_t current_y;\n+  ~hb_draw_session_t () { close_path (); }\n@@ -133,3 +171,58 @@\n-  bool path_open;\n-  const hb_draw_funcs_t *funcs;\n-  void *user_data;\n+  void move_to (float to_x, float to_y)\n+  {\n+    if (likely (not_slanted))\n+      funcs->move_to (draw_data, st,\n+                      to_x, to_y);\n+    else\n+      funcs->move_to (draw_data, st,\n+                      to_x + to_y * slant, to_y);\n+  }\n+  void line_to (float to_x, float to_y)\n+  {\n+    if (likely (not_slanted))\n+      funcs->line_to (draw_data, st,\n+                      to_x, to_y);\n+    else\n+      funcs->line_to (draw_data, st,\n+                      to_x + to_y * slant, to_y);\n+  }\n+  void\n+  quadratic_to (float control_x, float control_y,\n+                float to_x, float to_y)\n+  {\n+    if (likely (not_slanted))\n+      funcs->quadratic_to (draw_data, st,\n+                           control_x, control_y,\n+                           to_x, to_y);\n+    else\n+      funcs->quadratic_to (draw_data, st,\n+                           control_x + control_y * slant, control_y,\n+                           to_x + to_y * slant, to_y);\n+  }\n+  void\n+  cubic_to (float control1_x, float control1_y,\n+            float control2_x, float control2_y,\n+            float to_x, float to_y)\n+  {\n+    if (likely (not_slanted))\n+      funcs->cubic_to (draw_data, st,\n+                       control1_x, control1_y,\n+                       control2_x, control2_y,\n+                       to_x, to_y);\n+    else\n+      funcs->cubic_to (draw_data, st,\n+                       control1_x + control1_y * slant, control1_y,\n+                       control2_x + control2_y * slant, control2_y,\n+                       to_x + to_y * slant, to_y);\n+  }\n+  void close_path ()\n+  {\n+    funcs->close_path (draw_data, st);\n+  }\n+\n+  protected:\n+  float slant;\n+  bool not_slanted;\n+  hb_draw_funcs_t *funcs;\n+  void *draw_data;\n+  hb_draw_state_t st;\n@@ -137,1 +230,0 @@\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-draw.hh","additions":169,"deletions":77,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"hb-map.hh\"\n@@ -145,1 +146,1 @@\n-  unsigned int  index;\n+  uint16_t  index;\n@@ -153,1 +154,1 @@\n-  closure = (hb_face_for_data_closure_t *) calloc (1, sizeof (hb_face_for_data_closure_t));\n+  closure = (hb_face_for_data_closure_t *) hb_calloc (1, sizeof (hb_face_for_data_closure_t));\n@@ -158,1 +159,1 @@\n-  closure->index = index;\n+  closure->index = (uint16_t) (index & 0xFFFFu);\n@@ -169,1 +170,1 @@\n-  free (closure);\n+  hb_free (closure);\n@@ -192,1 +193,1 @@\n- * hb_face_create: (Xconstructor)\n+ * hb_face_create:\n@@ -197,3 +198,13 @@\n- * a face index into that blob. This is used for blobs of\n- * file formats such as Dfont and TTC that can contain more\n- * than one face.\n+ * a face index into that blob.\n+ *\n+ * The face index is used for blobs of file formats such as TTC and\n+ * and DFont that can contain more than one face.  Face indices within\n+ * such collections are zero-based.\n+ *\n+ * <note>Note: If the blob font format is not a collection, @index\n+ * is ignored.  Otherwise, only the lower 16-bits of @index are used.\n+ * The unmodified @index can be accessed via hb_face_get_index().<\/note>\n+ *\n+ * <note>Note: The high 16-bits of @index, if non-zero, are used by\n+ * hb_font_create() to load named-instances in variable fonts.  See\n+ * hb_font_create() for details.<\/note>\n@@ -284,1 +295,1 @@\n-    free (node);\n+    hb_free (node);\n@@ -294,1 +305,1 @@\n-  free (face);\n+  hb_free (face);\n@@ -334,1 +345,1 @@\n-hb_face_get_user_data (const hb_face_t    *face,\n+hb_face_get_user_data (hb_face_t          *face,\n@@ -422,1 +433,2 @@\n- * <note>Note: face indices within a collection are zero-based.<\/note>\n+ * <note>Note: changing the index has no effect on the face itself\n+ * This only changes the value returned by hb_face_get_index().<\/note>\n@@ -626,14 +638,1 @@\n-  struct table_entry_t\n-  {\n-    int cmp (hb_tag_t t) const\n-    {\n-      if (t < tag) return -1;\n-      if (t > tag) return -1;\n-      return 0;\n-    }\n-\n-    hb_tag_t   tag;\n-    hb_blob_t *blob;\n-  };\n-\n-  hb_vector_t<table_entry_t> tables;\n+  hb_hashmap_t<hb_tag_t, hb_blob_t *> tables;\n@@ -642,0 +641,13 @@\n+static int compare_entries (const void* pa, const void* pb)\n+{\n+  const auto& a = * (const hb_pair_t<hb_tag_t, hb_blob_t*> *) pa;\n+  const auto& b = * (const hb_pair_t<hb_tag_t, hb_blob_t*> *) pb;\n+\n+  \/* Order by blob size first (smallest to largest) and then table tag *\/\n+\n+  if (a.second->length != b.second->length)\n+    return a.second->length < b.second->length ? -1 : +1;\n+\n+  return a.first < b.first ? -1 : a.first == b.first ? 0 : +1;\n+}\n+\n@@ -645,1 +657,1 @@\n-  hb_face_builder_data_t *data = (hb_face_builder_data_t *) calloc (1, sizeof (hb_face_builder_data_t));\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) hb_calloc (1, sizeof (hb_face_builder_data_t));\n@@ -659,2 +671,2 @@\n-  for (unsigned int i = 0; i < data->tables.length; i++)\n-    hb_blob_destroy (data->tables[i].blob);\n+  for (hb_blob_t* b : data->tables.values())\n+    hb_blob_destroy (b);\n@@ -664,1 +676,1 @@\n-  free (data);\n+  hb_free (data);\n@@ -671,1 +683,1 @@\n-  unsigned int table_count = data->tables.length;\n+  unsigned int table_count = data->tables.get_population ();\n@@ -674,2 +686,2 @@\n-  for (unsigned int i = 0; i < table_count; i++)\n-    face_length += hb_ceil_to_4 (hb_blob_get_length (data->tables[i].blob));\n+  for (hb_blob_t* b : data->tables.values())\n+    face_length += hb_ceil_to_4 (hb_blob_get_length (b));\n@@ -677,1 +689,1 @@\n-  char *buf = (char *) malloc (face_length);\n+  char *buf = (char *) hb_malloc (face_length);\n@@ -685,1 +697,2 @@\n-  bool is_cff = data->tables.lsearch (HB_TAG ('C','F','F',' ')) || data->tables.lsearch (HB_TAG ('C','F','F','2'));\n+  bool is_cff = (data->tables.has (HB_TAG ('C','F','F',' '))\n+                 || data->tables.has (HB_TAG ('C','F','F','2')));\n@@ -688,1 +701,11 @@\n-  bool ret = f->serialize_single (&c, sfnt_tag, data->tables.as_array ());\n+  \/\/ Sort the tags so that produced face is deterministic.\n+  hb_vector_t<hb_pair_t <hb_tag_t, hb_blob_t*>> sorted_entries;\n+  data->tables.iter () | hb_sink (sorted_entries);\n+  if (unlikely (sorted_entries.in_error ()))\n+  {\n+    hb_free (buf);\n+    return nullptr;\n+  }\n+\n+  sorted_entries.qsort (compare_entries);\n+  bool ret = f->serialize_single (&c, sfnt_tag, + sorted_entries.iter());\n@@ -694,1 +717,1 @@\n-    free (buf);\n+    hb_free (buf);\n@@ -698,1 +721,1 @@\n-  return hb_blob_create (buf, face_length, HB_MEMORY_MODE_WRITABLE, buf, free);\n+  return hb_blob_create (buf, face_length, HB_MEMORY_MODE_WRITABLE, buf, hb_free);\n@@ -709,5 +732,1 @@\n-  hb_face_builder_data_t::table_entry_t *entry = data->tables.lsearch (tag);\n-  if (entry)\n-    return hb_blob_reference (entry->blob);\n-\n-  return nullptr;\n+  return hb_blob_reference (data->tables[tag]);\n@@ -753,0 +772,3 @@\n+  if (tag == HB_MAP_VALUE_INVALID)\n+    return false;\n+\n@@ -758,2 +780,4 @@\n-  hb_face_builder_data_t::table_entry_t *entry = data->tables.push ();\n-  if (unlikely (data->tables.in_error()))\n+  hb_blob_t* previous = data->tables.get (tag);\n+  if (!data->tables.set (tag, hb_blob_reference (blob)))\n+  {\n+    hb_blob_destroy (blob);\n@@ -761,0 +785,1 @@\n+  }\n@@ -762,3 +787,1 @@\n-  entry->tag = tag;\n-  entry->blob = hb_blob_reference (blob);\n-\n+  hb_blob_destroy (previous);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.cc","additions":71,"deletions":48,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-hb_face_get_user_data (const hb_face_t    *face,\n+hb_face_get_user_data (hb_face_t          *face,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-  buffer->safe_to_break_all ();\n+  buffer->clear_glyph_flags ();\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-fallback-shape.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"hb-draw.hh\"\n@@ -504,1 +505,24 @@\n-DEFINE_NULL_INSTANCE (hb_font_funcs_t) =\n+static void\n+hb_font_get_glyph_shape_nil (hb_font_t       *font HB_UNUSED,\n+                             void            *font_data HB_UNUSED,\n+                             hb_codepoint_t   glyph,\n+                             hb_draw_funcs_t *draw_funcs,\n+                             void            *draw_data,\n+                             void            *user_data HB_UNUSED)\n+{\n+}\n+\n+\n+typedef struct hb_font_get_glyph_shape_default_adaptor_t {\n+  hb_draw_funcs_t *draw_funcs;\n+  void            *draw_data;\n+  float            x_scale;\n+  float            y_scale;\n+} hb_font_get_glyph_shape_default_adaptor_t;\n+\n+static void\n+hb_draw_move_to_default (hb_draw_funcs_t *dfuncs HB_UNUSED,\n+                         void *draw_data,\n+                         hb_draw_state_t *st,\n+                         float to_x, float to_y,\n+                         void *user_data HB_UNUSED)\n@@ -506,0 +530,76 @@\n+  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+  float x_scale = adaptor->x_scale;\n+  float y_scale = adaptor->y_scale;\n+\n+  adaptor->draw_funcs->emit_move_to (adaptor->draw_data, *st,\n+                                     x_scale * to_x, y_scale * to_y);\n+}\n+\n+static void\n+hb_draw_line_to_default (hb_draw_funcs_t *dfuncs HB_UNUSED, void *draw_data,\n+                         hb_draw_state_t *st,\n+                         float to_x, float to_y,\n+                         void *user_data HB_UNUSED)\n+{\n+  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+  float x_scale = adaptor->x_scale;\n+  float y_scale = adaptor->y_scale;\n+\n+  st->current_x *= x_scale;\n+  st->current_y *= y_scale;\n+\n+  adaptor->draw_funcs->emit_line_to (adaptor->draw_data, *st,\n+                                     x_scale * to_x, y_scale * to_y);\n+}\n+\n+static void\n+hb_draw_quadratic_to_default (hb_draw_funcs_t *dfuncs HB_UNUSED, void *draw_data,\n+                              hb_draw_state_t *st,\n+                              float control_x, float control_y,\n+                              float to_x, float to_y,\n+                              void *user_data HB_UNUSED)\n+{\n+  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+  float x_scale = adaptor->x_scale;\n+  float y_scale = adaptor->y_scale;\n+\n+  st->current_x *= x_scale;\n+  st->current_y *= y_scale;\n+\n+  adaptor->draw_funcs->emit_quadratic_to (adaptor->draw_data, *st,\n+                                          x_scale * control_x, y_scale * control_y,\n+                                          x_scale * to_x, y_scale * to_y);\n+}\n+\n+static void\n+hb_draw_cubic_to_default (hb_draw_funcs_t *dfuncs HB_UNUSED, void *draw_data,\n+                          hb_draw_state_t *st,\n+                          float control1_x, float control1_y,\n+                          float control2_x, float control2_y,\n+                          float to_x, float to_y,\n+                          void *user_data HB_UNUSED)\n+{\n+  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+  float x_scale = adaptor->x_scale;\n+  float y_scale = adaptor->y_scale;\n+\n+  st->current_x *= x_scale;\n+  st->current_y *= y_scale;\n+\n+  adaptor->draw_funcs->emit_cubic_to (adaptor->draw_data, *st,\n+                                      x_scale * control1_x, y_scale * control1_y,\n+                                      x_scale * control2_x, y_scale * control2_y,\n+                                      x_scale * to_x, y_scale * to_y);\n+}\n+\n+static void\n+hb_draw_close_path_default (hb_draw_funcs_t *dfuncs HB_UNUSED, void *draw_data,\n+                            hb_draw_state_t *st,\n+                            void *user_data HB_UNUSED)\n+{\n+  hb_font_get_glyph_shape_default_adaptor_t *adaptor = (hb_font_get_glyph_shape_default_adaptor_t *) draw_data;\n+\n+  adaptor->draw_funcs->emit_close_path (adaptor->draw_data, *st);\n+}\n+\n+static const hb_draw_funcs_t _hb_draw_funcs_default = {\n@@ -509,9 +609,32 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) nullptr,\n-    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n-#undef HB_FONT_FUNC_IMPLEMENT\n-  },\n-  {\n-#define HB_FONT_FUNC_IMPLEMENT(name) nullptr,\n-    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n-#undef HB_FONT_FUNC_IMPLEMENT\n-  },\n+#define HB_DRAW_FUNC_IMPLEMENT(name) hb_draw_##name##_default,\n+    HB_DRAW_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_DRAW_FUNC_IMPLEMENT\n+  }\n+};\n+\n+static void\n+hb_font_get_glyph_shape_default (hb_font_t       *font,\n+                                 void            *font_data HB_UNUSED,\n+                                 hb_codepoint_t   glyph,\n+                                 hb_draw_funcs_t *draw_funcs,\n+                                 void            *draw_data,\n+                                 void            *user_data HB_UNUSED)\n+{\n+  hb_font_get_glyph_shape_default_adaptor_t adaptor = {\n+    draw_funcs,\n+    draw_data,\n+    (float) font->x_scale \/ (float) font->parent->x_scale,\n+    (float) font->y_scale \/ (float) font->parent->y_scale\n+  };\n+\n+  font->parent->get_glyph_shape (glyph,\n+                                 const_cast<hb_draw_funcs_t *> (&_hb_draw_funcs_default),\n+                                 &adaptor);\n+}\n+\n+DEFINE_NULL_INSTANCE (hb_font_funcs_t) =\n+{\n+  HB_OBJECT_HEADER_STATIC,\n+\n+  nullptr,\n+  nullptr,\n@@ -530,10 +653,2 @@\n-  {\n-#define HB_FONT_FUNC_IMPLEMENT(name) nullptr,\n-    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n-#undef HB_FONT_FUNC_IMPLEMENT\n-  },\n-  {\n-#define HB_FONT_FUNC_IMPLEMENT(name) nullptr,\n-    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n-#undef HB_FONT_FUNC_IMPLEMENT\n-  },\n+  nullptr,\n+  nullptr,\n@@ -551,1 +666,1 @@\n- * hb_font_funcs_create: (Xconstructor)\n+ * hb_font_funcs_create:\n@@ -618,3 +733,5 @@\n-#define HB_FONT_FUNC_IMPLEMENT(name) if (ffuncs->destroy.name) \\\n-  ffuncs->destroy.name (ffuncs->user_data.name);\n-  HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+  if (ffuncs->destroy)\n+  {\n+#define HB_FONT_FUNC_IMPLEMENT(name) if (ffuncs->destroy->name) \\\n+    ffuncs->destroy->name (!ffuncs->user_data ? nullptr : ffuncs->user_data->name);\n+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n@@ -622,0 +739,4 @@\n+  }\n+\n+  hb_free (ffuncs->destroy);\n+  hb_free (ffuncs->user_data);\n@@ -623,1 +744,1 @@\n-  free (ffuncs);\n+  hb_free (ffuncs);\n@@ -713,0 +834,3 @@\n+    goto fail;                                                           \\\n+                                                                         \\\n+  if (!func)                                                             \\\n@@ -716,1 +840,2 @@\n-    return;                                                              \\\n+    destroy = nullptr;                                                   \\\n+    user_data = nullptr;                                                 \\\n@@ -719,2 +844,15 @@\n-  if (ffuncs->destroy.name)                                              \\\n-    ffuncs->destroy.name (ffuncs->user_data.name);                       \\\n+  if (ffuncs->destroy && ffuncs->destroy->name)                          \\\n+    ffuncs->destroy->name (!ffuncs->user_data ? nullptr : ffuncs->user_data->name); \\\n+                                                                         \\\n+  if (user_data && !ffuncs->user_data)                                   \\\n+  {                                                                      \\\n+    ffuncs->user_data = (decltype (ffuncs->user_data)) hb_calloc (1, sizeof (*ffuncs->user_data)); \\\n+    if (unlikely (!ffuncs->user_data))                                   \\\n+      goto fail;                                                         \\\n+  }                                                                      \\\n+  if (destroy && !ffuncs->destroy)                                       \\\n+  {                                                                      \\\n+    ffuncs->destroy = (decltype (ffuncs->destroy)) hb_calloc (1, sizeof (*ffuncs->destroy)); \\\n+    if (unlikely (!ffuncs->destroy))                                     \\\n+      goto fail;                                                         \\\n+  }                                                                      \\\n@@ -724,2 +862,4 @@\n-    ffuncs->user_data.name = user_data;                                  \\\n-    ffuncs->destroy.name = destroy;                                      \\\n+    if (ffuncs->user_data)                                               \\\n+      ffuncs->user_data->name = user_data;                               \\\n+    if (ffuncs->destroy)                                                 \\\n+      ffuncs->destroy->name = destroy;                                   \\\n@@ -728,2 +868,4 @@\n-    ffuncs->user_data.name = nullptr;                                    \\\n-    ffuncs->destroy.name = nullptr;                                      \\\n+    if (ffuncs->user_data)                                               \\\n+      ffuncs->user_data->name = nullptr;                                 \\\n+    if (ffuncs->destroy)                                                 \\\n+      ffuncs->destroy->name = nullptr;                                   \\\n@@ -731,0 +873,5 @@\n+  return;                                                                \\\n+                                                                         \\\n+fail:                                                                    \\\n+  if (destroy)                                                           \\\n+    destroy (user_data);                                                 \\\n@@ -1171,0 +1318,20 @@\n+\/**\n+ * hb_font_get_glyph_shape:\n+ * @font: #hb_font_t to work upon\n+ * @glyph: : The glyph ID\n+ * @dfuncs: #hb_draw_funcs_t to draw to\n+ * @draw_data: User data to pass to draw callbacks\n+ *\n+ * Fetches the glyph shape that corresponds to a glyph in the specified @font.\n+ * The shape is returned by way of calls to the callsbacks of the @dfuncs\n+ * objects, with @draw_data passed to them.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+void\n+hb_font_get_glyph_shape (hb_font_t *font,\n+                         hb_codepoint_t glyph,\n+                         hb_draw_funcs_t *dfuncs, void *draw_data)\n+{\n+  font->get_glyph_shape (glyph, dfuncs, draw_data);\n+}\n@@ -1193,1 +1360,1 @@\n-  return font->get_extents_for_direction (direction, extents);\n+  font->get_extents_for_direction (direction, extents);\n@@ -1218,1 +1385,1 @@\n-  return font->get_glyph_advance_for_direction (glyph, direction, x, y);\n+  font->get_glyph_advance_for_direction (glyph, direction, x, y);\n@@ -1475,0 +1642,3 @@\n+  0, \/* serial *\/\n+  0, \/* serial_coords *\/\n+\n@@ -1480,0 +1650,4 @@\n+  0., \/* slant *\/\n+  0., \/* slant_xy; *\/\n+  1.f, \/* x_multf *\/\n+  1.f, \/* y_multf *\/\n@@ -1512,1 +1686,2 @@\n-  font->x_scale = font->y_scale = hb_face_get_upem (face);\n+  font->x_scale = font->y_scale = face->get_upem ();\n+  font->x_multf = font->y_multf = 1.f;\n@@ -1519,1 +1694,1 @@\n- * hb_font_create: (Xconstructor)\n+ * hb_font_create:\n@@ -1524,0 +1699,7 @@\n+ * <note>Note: If @face's index value (as passed to hb_face_create()\n+ * has non-zero top 16-bits, those bits minus one are passed to\n+ * hb_font_set_var_named_instance(), effectively loading a named-instance\n+ * of a variable font, instead of the default-instance.  This allows\n+ * specifying which named-instance to load by default when creating the\n+ * face.<\/note>\n+ *\n@@ -1538,0 +1720,5 @@\n+#ifndef HB_NO_VAR\n+  if (face && face->index >> 16)\n+    hb_font_set_var_named_instance (font, (face->index >> 16) - 1);\n+#endif\n+\n@@ -1547,2 +1734,2 @@\n-  free (font->coords);\n-  free (font->design_coords);\n+  hb_free (font->coords);\n+  hb_free (font->design_coords);\n@@ -1553,0 +1740,2 @@\n+\n+  font->mults_changed (); \/\/ Easiest to call this to drop cached data\n@@ -1581,1 +1770,1 @@\n-  font->mults_changed ();\n+  font->slant = parent->slant;\n@@ -1589,2 +1778,2 @@\n-    int *coords = (int *) calloc (num_coords, sizeof (parent->coords[0]));\n-    float *design_coords = (float *) calloc (num_coords, sizeof (parent->design_coords[0]));\n+    int *coords = (int *) hb_calloc (num_coords, sizeof (parent->coords[0]));\n+    float *design_coords = (float *) hb_calloc (num_coords, sizeof (parent->design_coords[0]));\n@@ -1599,2 +1788,2 @@\n-      free (coords);\n-      free (design_coords);\n+      hb_free (coords);\n+      hb_free (design_coords);\n@@ -1604,0 +1793,2 @@\n+  font->mults_changed ();\n+\n@@ -1662,2 +1853,2 @@\n-  free (font->coords);\n-  free (font->design_coords);\n+  hb_free (font->coords);\n+  hb_free (font->design_coords);\n@@ -1665,1 +1856,1 @@\n-  free (font);\n+  hb_free (font);\n@@ -1689,0 +1880,3 @@\n+  if (!hb_object_is_immutable (font))\n+    font->serial++;\n+\n@@ -1747,0 +1941,39 @@\n+\/**\n+ * hb_font_get_serial:\n+ * @font: #hb_font_t to work upon\n+ *\n+ * Returns the internal serial number of the font. The serial\n+ * number is increased every time a setting on the font is\n+ * changed, using a setter function.\n+ *\n+ * Return value: serial number\n+ *\n+ * Since: 4.4.0.\n+ **\/\n+unsigned int\n+hb_font_get_serial (hb_font_t *font)\n+{\n+  return font->serial;\n+}\n+\n+\/**\n+ * hb_font_changed:\n+ * @font: #hb_font_t to work upon\n+ *\n+ * Notifies the @font that underlying font data has changed.\n+ * This has the effect of increasing the serial as returned\n+ * by hb_font_get_serial(), which invalidates internal caches.\n+ *\n+ * Since: 4.4.0.\n+ **\/\n+void\n+hb_font_changed (hb_font_t *font)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  font->serial++;\n+\n+  font->mults_changed ();\n+}\n+\n@@ -1763,0 +1996,5 @@\n+  if (parent == font->parent)\n+    return;\n+\n+  font->serial++;\n+\n@@ -1805,0 +2043,5 @@\n+  if (face == font->face)\n+    return;\n+\n+  font->serial++;\n+\n@@ -1859,0 +2102,2 @@\n+  font->serial++;\n+\n@@ -1896,0 +2141,2 @@\n+  font->serial++;\n+\n@@ -1922,0 +2169,5 @@\n+  if (font->x_scale == x_scale && font->y_scale == y_scale)\n+    return;\n+\n+  font->serial++;\n+\n@@ -1964,0 +2216,5 @@\n+  if (font->x_ppem == x_ppem && font->y_ppem == y_ppem)\n+    return;\n+\n+  font->serial++;\n+\n@@ -2006,0 +2263,5 @@\n+  if (font->ptem == ptem)\n+    return;\n+\n+  font->serial++;\n+\n@@ -2018,1 +2280,1 @@\n- * Since: 0.9.2\n+ * Since: 1.6.0\n@@ -2026,0 +2288,52 @@\n+\/**\n+ * hb_font_set_synthetic_slant:\n+ * @font: #hb_font_t to work upon\n+ * @slant: synthetic slant value.\n+ *\n+ * Sets the \"synthetic slant\" of a font.  By default is zero.\n+ * Synthetic slant is the graphical skew applied to the font\n+ * at rendering time.\n+ *\n+ * HarfBuzz needs to know this value to adjust shaping results,\n+ * metrics, and style values to match the slanted rendering.\n+ *\n+ * <note>Note: The glyph shape fetched via the\n+ * hb_font_get_glyph_shape() is slanted to reflect this value\n+ * as well.<\/note>\n+ *\n+ * <note>Note: The slant value is a ratio.  For example, a\n+ * 20% slant would be represented as a 0.2 value.<\/note>\n+ *\n+ * Since: 3.3.0\n+ **\/\n+HB_EXTERN void\n+hb_font_set_synthetic_slant (hb_font_t *font, float slant)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  if (font->slant == slant)\n+    return;\n+\n+  font->serial++;\n+\n+  font->slant = slant;\n+  font->mults_changed ();\n+}\n+\n+\/**\n+ * hb_font_get_synthetic_slant:\n+ * @font: #hb_font_t to work upon\n+ *\n+ * Fetches the \"synthetic slant\" of a font.\n+ *\n+ * Return value: Synthetic slant.  By default is zero.\n+ *\n+ * Since: 3.3.0\n+ **\/\n+HB_EXTERN float\n+hb_font_get_synthetic_slant (hb_font_t *font)\n+{\n+  return font->slant;\n+}\n+\n@@ -2039,0 +2353,4 @@\n+ * Note that this overrides all existing variations set on @font.\n+ * Axes not included in @variations will be effectively set to their\n+ * default values.\n+ *\n@@ -2049,0 +2367,2 @@\n+  font->serial_coords = ++font->serial;\n+\n@@ -2055,1 +2375,3 @@\n-  unsigned int coords_length = hb_ot_var_get_axis_count (font->face);\n+  const OT::fvar &fvar = *font->face->table.fvar;\n+  auto axes = fvar.get_axes ();\n+  const unsigned coords_length = axes.length;\n@@ -2057,2 +2379,2 @@\n-  int *normalized = coords_length ? (int *) calloc (coords_length, sizeof (int)) : nullptr;\n-  float *design_coords = coords_length ? (float *) calloc (coords_length, sizeof (float)) : nullptr;\n+  int *normalized = coords_length ? (int *) hb_calloc (coords_length, sizeof (int)) : nullptr;\n+  float *design_coords = coords_length ? (float *) hb_calloc (coords_length, sizeof (float)) : nullptr;\n@@ -2062,2 +2384,2 @@\n-    free (normalized);\n-    free (design_coords);\n+    hb_free (normalized);\n+    hb_free (design_coords);\n@@ -2067,1 +2389,0 @@\n-  const OT::fvar &fvar = *font->face->table.fvar;\n@@ -2070,8 +2391,8 @@\n-    hb_ot_var_axis_info_t info;\n-    if (hb_ot_var_find_axis_info (font->face, variations[i].tag, &info) &&\n-        info.axis_index < coords_length)\n-    {\n-      float v = variations[i].value;\n-      design_coords[info.axis_index] = v;\n-      normalized[info.axis_index] = fvar.normalize_axis_value (info.axis_index, v);\n-    }\n+    const auto tag = variations[i].tag;\n+    const auto v = variations[i].value;\n+    for (unsigned axis_index = 0; axis_index < coords_length; axis_index++)\n+      if (axes[axis_index].axisTag == tag)\n+      {\n+        design_coords[axis_index] = v;\n+        normalized[axis_index] = fvar.normalize_axis_value (axis_index, v);\n+      }\n@@ -2093,0 +2414,4 @@\n+ * Note that this overrides all existing variations set on @font.\n+ * Axes not included in @coords will be effectively set to their\n+ * default values.\n+ *\n@@ -2103,2 +2428,4 @@\n-  int *normalized = coords_length ? (int *) calloc (coords_length, sizeof (int)) : nullptr;\n-  float *design_coords = coords_length ? (float *) calloc (coords_length, sizeof (float)) : nullptr;\n+  font->serial_coords = ++font->serial;\n+\n+  int *normalized = coords_length ? (int *) hb_calloc (coords_length, sizeof (int)) : nullptr;\n+  float *design_coords = coords_length ? (float *) hb_calloc (coords_length, sizeof (float)) : nullptr;\n@@ -2108,2 +2435,2 @@\n-    free (normalized);\n-    free (design_coords);\n+    hb_free (normalized);\n+    hb_free (design_coords);\n@@ -2136,0 +2463,2 @@\n+  font->serial_coords = ++font->serial;\n+\n@@ -2138,1 +2467,1 @@\n-  float *coords = coords_length ? (float *) calloc (coords_length, sizeof (float)) : nullptr;\n+  float *coords = coords_length ? (float *) hb_calloc (coords_length, sizeof (float)) : nullptr;\n@@ -2144,1 +2473,1 @@\n-  free (coords);\n+  hb_free (coords);\n@@ -2156,0 +2485,4 @@\n+ * Note that this overrides all existing variations set on @font.\n+ * Axes not included in @coords will be effectively set to their\n+ * default values.\n+ *\n@@ -2168,3 +2501,5 @@\n-  int *copy = coords_length ? (int *) calloc (coords_length, sizeof (coords[0])) : nullptr;\n-  int *unmapped = coords_length ? (int *) calloc (coords_length, sizeof (coords[0])) : nullptr;\n-  float *design_coords = coords_length ? (float *) calloc (coords_length, sizeof (design_coords[0])) : nullptr;\n+  font->serial_coords = ++font->serial;\n+\n+  int *copy = coords_length ? (int *) hb_calloc (coords_length, sizeof (coords[0])) : nullptr;\n+  int *unmapped = coords_length ? (int *) hb_calloc (coords_length, sizeof (coords[0])) : nullptr;\n+  float *design_coords = coords_length ? (float *) hb_calloc (coords_length, sizeof (design_coords[0])) : nullptr;\n@@ -2174,3 +2509,3 @@\n-    free (copy);\n-    free (unmapped);\n-    free (design_coords);\n+    hb_free (copy);\n+    hb_free (unmapped);\n+    hb_free (design_coords);\n@@ -2190,1 +2525,1 @@\n-  free (unmapped);\n+  hb_free (unmapped);\n@@ -2198,1 +2533,1 @@\n- * @length: Number of coordinates retrieved\n+ * @length: (out): Number of coordinates retrieved\n@@ -2203,0 +2538,3 @@\n+ * Note that this returned array may only contain values for some\n+ * (or none) of the axes; omitted axes effectively have zero values.\n+ *\n@@ -2206,0 +2544,2 @@\n+ * Return value: coordinates array\n+ *\n@@ -2218,1 +2558,0 @@\n-#ifdef HB_EXPERIMENTAL_API\n@@ -2222,1 +2561,8 @@\n- * @length: (out): number of coordinates\n+ * @length: (out): Number of coordinates retrieved\n+ *\n+ * Fetches the list of variation coordinates (in design-space units) currently\n+ * set on a font.\n+ *\n+ * Note that this returned array may only contain values for some\n+ * (or none) of the axes; omitted axes effectively have their default\n+ * values.\n@@ -2229,1 +2575,1 @@\n- * Since: EXPERIMENTAL\n+ * Since: 3.3.0\n@@ -2241,1 +2587,0 @@\n-#endif\n@@ -2270,1 +2615,1 @@\n-  trampoline_t *trampoline = (trampoline_t *) calloc (1, sizeof (trampoline_t));\n+  trampoline_t *trampoline = (trampoline_t *) hb_calloc (1, sizeof (trampoline_t));\n@@ -2299,1 +2644,1 @@\n-  free (closure);\n+  hb_free (closure);\n@@ -2363,0 +2708,3 @@\n+  \/* Since we pass it to two destroying functions. *\/\n+  trampoline_reference (&trampoline->closure);\n+\n@@ -2368,1 +2716,0 @@\n-  trampoline_reference (&trampoline->closure);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.cc","additions":429,"deletions":82,"binary":false,"changes":511,"status":"modified"},{"patch":"@@ -514,0 +514,19 @@\n+\/**\n+ * hb_font_get_glyph_shape_func_t:\n+ * @font: #hb_font_t to work upon\n+ * @font_data: @font user data pointer\n+ * @glyph: The glyph ID to query\n+ * @draw_funcs: The draw functions to send the shape data to\n+ * @draw_data: The data accompanying the draw functions\n+ * @user_data: User data pointer passed by the caller\n+ *\n+ * A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n+ *\n+ * Since: 4.0.0\n+ *\n+ **\/\n+typedef void (*hb_font_get_glyph_shape_func_t) (hb_font_t *font, void *font_data,\n+                                                hb_codepoint_t glyph,\n+                                                hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                                                void *user_data);\n+\n@@ -773,0 +792,16 @@\n+\/**\n+ * hb_font_funcs_set_glyph_shape_func:\n+ * @ffuncs: A font-function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n+ * @user_data: Data to pass to @func\n+ * @destroy: (nullable): The function to call when @user_data is not needed anymore\n+ *\n+ * Sets the implementation function for #hb_font_get_glyph_shape_func_t.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_shape_func (hb_font_funcs_t *ffuncs,\n+                                    hb_font_get_glyph_shape_func_t func,\n+                                    void *user_data, hb_destroy_func_t destroy);\n+\n@@ -853,0 +888,5 @@\n+HB_EXTERN void\n+hb_font_get_glyph_shape (hb_font_t *font,\n+                         hb_codepoint_t glyph,\n+                         hb_draw_funcs_t *dfuncs, void *draw_data);\n+\n@@ -965,0 +1005,6 @@\n+HB_EXTERN unsigned int\n+hb_font_get_serial (hb_font_t *font);\n+\n+HB_EXTERN void\n+hb_font_changed (hb_font_t *font);\n+\n@@ -1026,0 +1072,6 @@\n+HB_EXTERN void\n+hb_font_set_synthetic_slant (hb_font_t *font, float slant);\n+\n+HB_EXTERN float\n+hb_font_get_synthetic_slant (hb_font_t *font);\n+\n@@ -1036,1 +1088,0 @@\n-#ifdef HB_EXPERIMENTAL_API\n@@ -1040,1 +1091,0 @@\n-#endif\n@@ -1055,5 +1105,0 @@\n-#ifdef HB_EXPERIMENTAL_API\n-HB_EXTERN hb_bool_t\n-hb_font_draw_glyph (hb_font_t *font, hb_codepoint_t glyph,\n-                    const hb_draw_funcs_t *funcs, void *user_data);\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.h","additions":52,"deletions":7,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  HB_FONT_FUNC_IMPLEMENT (glyph_shape) \\\n@@ -70,1 +71,1 @@\n-  } user_data;\n+  } *user_data;\n@@ -76,1 +77,1 @@\n-  } destroy;\n+  } *destroy;\n@@ -106,0 +107,2 @@\n+  unsigned int serial;\n+  unsigned int serial_coords;\n@@ -112,0 +115,4 @@\n+  float slant;\n+  float slant_xy;\n+  float x_multf;\n+  float y_multf;\n@@ -137,4 +144,6 @@\n-  hb_position_t em_scalef_x (float v) { return em_scalef (v, x_scale); }\n-  hb_position_t em_scalef_y (float v) { return em_scalef (v, y_scale); }\n-  float em_fscale_x (int16_t v) { return em_fscale (v, x_scale); }\n-  float em_fscale_y (int16_t v) { return em_fscale (v, y_scale); }\n+  hb_position_t em_scalef_x (float v) { return em_multf (v, x_multf); }\n+  hb_position_t em_scalef_y (float v) { return em_multf (v, y_multf); }\n+  float em_fscale_x (int16_t v) { return em_fmult (v, x_multf); }\n+  float em_fscale_y (int16_t v) { return em_fmult (v, y_multf); }\n+  float em_fscalef_x (float v) { return em_fmultf (v, x_multf); }\n+  float em_fscalef_y (float v) { return em_fmultf (v, y_multf); }\n@@ -203,1 +212,1 @@\n-                                        klass->user_data.font_h_extents);\n+                                        !klass->user_data ? nullptr : klass->user_data->font_h_extents);\n@@ -210,1 +219,1 @@\n-                                        klass->user_data.font_v_extents);\n+                                        !klass->user_data ? nullptr : klass->user_data->font_v_extents);\n@@ -220,1 +229,2 @@\n-                               hb_codepoint_t *glyph)\n+                               hb_codepoint_t *glyph,\n+                               hb_codepoint_t not_found = 0)\n@@ -222,1 +232,1 @@\n-    *glyph = 0;\n+    *glyph = not_found;\n@@ -225,1 +235,1 @@\n-                                       klass->user_data.nominal_glyph);\n+                                       !klass->user_data ? nullptr : klass->user_data->nominal_glyph);\n@@ -237,1 +247,1 @@\n-                                        klass->user_data.nominal_glyphs);\n+                                        !klass->user_data ? nullptr : klass->user_data->nominal_glyphs);\n@@ -241,1 +251,2 @@\n-                                 hb_codepoint_t *glyph)\n+                                 hb_codepoint_t *glyph,\n+                                 hb_codepoint_t not_found = 0)\n@@ -243,1 +254,1 @@\n-    *glyph = 0;\n+    *glyph = not_found;\n@@ -246,1 +257,1 @@\n-                                         klass->user_data.variation_glyph);\n+                                         !klass->user_data ? nullptr : klass->user_data->variation_glyph);\n@@ -253,1 +264,1 @@\n-                                         klass->user_data.glyph_h_advance);\n+                                         !klass->user_data ? nullptr : klass->user_data->glyph_h_advance);\n@@ -260,1 +271,1 @@\n-                                         klass->user_data.glyph_v_advance);\n+                                         !klass->user_data ? nullptr : klass->user_data->glyph_v_advance);\n@@ -273,1 +284,1 @@\n-                                          klass->user_data.glyph_h_advances);\n+                                          !klass->user_data ? nullptr : klass->user_data->glyph_h_advances);\n@@ -286,1 +297,1 @@\n-                                          klass->user_data.glyph_v_advances);\n+                                          !klass->user_data ? nullptr : klass->user_data->glyph_v_advances);\n@@ -295,1 +306,1 @@\n-                                        klass->user_data.glyph_h_origin);\n+                                        !klass->user_data ? nullptr : klass->user_data->glyph_h_origin);\n@@ -304,1 +315,1 @@\n-                                        klass->user_data.glyph_v_origin);\n+                                        !klass->user_data ? nullptr : klass->user_data->glyph_v_origin);\n@@ -315,1 +326,1 @@\n-                                         klass->user_data.glyph_h_kerning);\n+                                         !klass->user_data ? nullptr : klass->user_data->glyph_h_kerning);\n@@ -327,1 +338,1 @@\n-                                         klass->user_data.glyph_v_kerning);\n+                                         !klass->user_data ? nullptr : klass->user_data->glyph_v_kerning);\n@@ -338,1 +349,1 @@\n-                                       klass->user_data.glyph_extents);\n+                                       !klass->user_data ? nullptr : klass->user_data->glyph_extents);\n@@ -348,1 +359,1 @@\n-                                             klass->user_data.glyph_contour_point);\n+                                             !klass->user_data ? nullptr : klass->user_data->glyph_contour_point);\n@@ -358,1 +369,1 @@\n-                                    klass->user_data.glyph_name);\n+                                    !klass->user_data ? nullptr : klass->user_data->glyph_name);\n@@ -369,1 +380,10 @@\n-                                         klass->user_data.glyph_from_name);\n+                                         !klass->user_data ? nullptr : klass->user_data->glyph_from_name);\n+  }\n+\n+  void get_glyph_shape (hb_codepoint_t glyph,\n+                        hb_draw_funcs_t *draw_funcs, void *draw_data)\n+  {\n+    klass->get.f.glyph_shape (this, user_data,\n+                              glyph,\n+                              draw_funcs, draw_data,\n+                              !klass->user_data ? nullptr : klass->user_data->glyph_shape);\n@@ -431,1 +451,0 @@\n-    \/* TODO cache this somehow?! *\/\n@@ -615,3 +634,10 @@\n-    signed upem = face->get_upem ();\n-    x_mult = ((int64_t) x_scale << 16) \/ upem;\n-    y_mult = ((int64_t) y_scale << 16) \/ upem;\n+    float upem = face->get_upem ();\n+    x_multf = x_scale \/ upem;\n+    y_multf = y_scale \/ upem;\n+    bool x_neg = x_scale < 0;\n+    x_mult = (x_neg ? -((int64_t) -x_scale << 16) : ((int64_t) x_scale << 16)) \/ upem;\n+    bool y_neg = y_scale < 0;\n+    y_mult = (y_neg ? -((int64_t) -y_scale << 16) : ((int64_t) y_scale << 16)) \/ upem;\n+    slant_xy = y_scale ? slant * x_scale \/ y_scale : 0.f;\n+\n+    data.fini ();\n@@ -621,7 +647,7 @@\n-  {\n-    return (hb_position_t) ((v * mult) >> 16);\n-  }\n-  hb_position_t em_scalef (float v, int scale)\n-  { return (hb_position_t) roundf (v * scale \/ face->get_upem ()); }\n-  float em_fscale (int16_t v, int scale)\n-  { return (float) v * scale \/ face->get_upem (); }\n+  { return (hb_position_t) ((v * mult + 32768) >> 16); }\n+  hb_position_t em_multf (float v, float mult)\n+  { return (hb_position_t) roundf (em_fmultf (v, mult)); }\n+  float em_fmultf (float v, float mult)\n+  { return v * mult; }\n+  float em_fmult (int16_t v, float mult)\n+  { return (float) v * mult; }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.hh","additions":64,"deletions":38,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"hb-draw.hh\"\n@@ -39,0 +40,2 @@\n+#include \"hb-ot-os2-table.hh\"\n+#include \"hb-ot-shaper-arabic-pua.hh\"\n@@ -42,0 +45,1 @@\n+#include FT_OUTLINE_H\n@@ -81,2 +85,0 @@\n-  mutable hb_mutex_t lock;\n-  FT_Face ft_face;\n@@ -87,1 +89,3 @@\n-  mutable int cached_x_scale;\n+  mutable hb_mutex_t lock;\n+  FT_Face ft_face;\n+  mutable unsigned cached_serial;\n@@ -94,1 +98,1 @@\n-  hb_ft_font_t *ft_font = (hb_ft_font_t *) calloc (1, sizeof (hb_ft_font_t));\n+  hb_ft_font_t *ft_font = (hb_ft_font_t *) hb_calloc (1, sizeof (hb_ft_font_t));\n@@ -104,1 +108,1 @@\n-  ft_font->cached_x_scale = 0;\n+  ft_font->cached_serial = (unsigned) -1;\n@@ -128,1 +132,37 @@\n-  free (ft_font);\n+  hb_free (ft_font);\n+}\n+\n+\n+\/* hb_font changed, update FT_Face. *\/\n+static void _hb_ft_hb_font_changed (hb_font_t *font, FT_Face ft_face)\n+{\n+\n+  FT_Set_Char_Size (ft_face,\n+                    abs (font->x_scale), abs (font->y_scale),\n+                    0, 0);\n+#if 0\n+                    font->x_ppem * 72 * 64 \/ font->x_scale,\n+                    font->y_ppem * 72 * 64 \/ font->y_scale);\n+#endif\n+  if (font->x_scale < 0 || font->y_scale < 0)\n+  {\n+    FT_Matrix matrix = { font->x_scale < 0 ? -1 : +1, 0,\n+                          0, font->y_scale < 0 ? -1 : +1};\n+    FT_Set_Transform (ft_face, &matrix, nullptr);\n+  }\n+\n+#if defined(HAVE_FT_GET_VAR_BLEND_COORDINATES) && !defined(HB_NO_VAR)\n+  unsigned int num_coords;\n+  const int *coords = hb_font_get_var_coords_normalized (font, &num_coords);\n+  if (num_coords)\n+  {\n+    FT_Fixed *ft_coords = (FT_Fixed *) hb_calloc (num_coords, sizeof (FT_Fixed));\n+    if (ft_coords)\n+    {\n+      for (unsigned int i = 0; i < num_coords; i++)\n+        ft_coords[i] = coords[i] * 4;\n+      FT_Set_Var_Blend_Coordinates (ft_face, num_coords, ft_coords);\n+      hb_free (ft_coords);\n+    }\n+  }\n+#endif\n@@ -131,0 +171,16 @@\n+\/* Check if hb_font changed, update FT_Face. *\/\n+static inline bool\n+_hb_ft_hb_font_check_changed (hb_font_t *font,\n+                              const hb_ft_font_t *ft_font)\n+{\n+  if (font->serial != ft_font->cached_serial)\n+  {\n+    _hb_ft_hb_font_changed (font, ft_font->ft_face);\n+    ft_font->advance_cache.clear ();\n+    ft_font->cached_serial = font->serial;\n+    return true;\n+  }\n+  return false;\n+}\n+\n+\n@@ -182,1 +238,1 @@\n- * hb_ft_font_get_face:\n+ * hb_ft_font_get_face: (skip)\n@@ -204,1 +260,1 @@\n- * hb_ft_font_lock_face:\n+ * hb_ft_font_lock_face: (skip)\n@@ -247,1 +303,1 @@\n-hb_ft_get_nominal_glyph (hb_font_t *font HB_UNUSED,\n+hb_ft_get_nominal_glyph (hb_font_t *font,\n@@ -259,1 +315,1 @@\n-    if (unlikely (ft_font->symbol) && unicode <= 0x00FFu)\n+    if (unlikely (ft_font->symbol))\n@@ -261,6 +317,21 @@\n-      \/* For symbol-encoded OpenType fonts, we duplicate the\n-       * U+F000..F0FF range at U+0000..U+00FF.  That's what\n-       * Windows seems to do, and that's hinted about at:\n-       * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/recom\n-       * under \"Non-Standard (Symbol) Fonts\". *\/\n-      g = FT_Get_Char_Index (ft_font->ft_face, 0xF000u + unicode);\n+      switch ((unsigned) font->face->table.OS2->get_font_page ()) {\n+      case OT::OS2::font_page_t::FONT_PAGE_NONE:\n+        if (unicode <= 0x00FFu)\n+          \/* For symbol-encoded OpenType fonts, we duplicate the\n+           * U+F000..F0FF range at U+0000..U+00FF.  That's what\n+           * Windows seems to do, and that's hinted about at:\n+           * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/recom\n+           * under \"Non-Standard (Symbol) Fonts\". *\/\n+          g = FT_Get_Char_Index (ft_font->ft_face, 0xF000u + unicode);\n+        break;\n+#ifndef HB_NO_OT_SHAPER_ARABIC_FALLBACK\n+      case OT::OS2::font_page_t::FONT_PAGE_SIMP_ARABIC:\n+        g = FT_Get_Char_Index (ft_font->ft_face, _hb_arabic_pua_simp_map (unicode));\n+        break;\n+      case OT::OS2::font_page_t::FONT_PAGE_TRAD_ARABIC:\n+        g = FT_Get_Char_Index (ft_font->ft_face, _hb_arabic_pua_trad_map (unicode));\n+        break;\n+#endif\n+      default:\n+        break;\n+      }\n@@ -338,6 +409,0 @@\n-  if (font->x_scale != ft_font->cached_x_scale)\n-  {\n-    ft_font->advance_cache.clear ();\n-    ft_font->cached_x_scale = font->x_scale;\n-  }\n-\n@@ -364,0 +429,1 @@\n+#ifndef HB_NO_VERTICAL\n@@ -382,0 +448,1 @@\n+\n@@ -384,0 +451,1 @@\n+#endif\n@@ -385,0 +453,1 @@\n+#ifndef HB_NO_VERTICAL\n@@ -412,0 +481,1 @@\n+#endif\n@@ -422,0 +492,1 @@\n+  hb_lock_t lock (ft_font->lock);\n@@ -552,0 +623,1 @@\n+\n@@ -564,2 +636,75 @@\n-#if HB_USE_ATEXIT\n-static void free_static_ft_funcs ();\n+#ifndef HB_NO_DRAW\n+\n+static int\n+_hb_ft_move_to (const FT_Vector *to,\n+                hb_draw_session_t *drawing)\n+{\n+  drawing->move_to (to->x, to->y);\n+  return FT_Err_Ok;\n+}\n+\n+static int\n+_hb_ft_line_to (const FT_Vector *to,\n+                hb_draw_session_t *drawing)\n+{\n+  drawing->line_to (to->x, to->y);\n+  return FT_Err_Ok;\n+}\n+\n+static int\n+_hb_ft_conic_to (const FT_Vector *control,\n+                 const FT_Vector *to,\n+                 hb_draw_session_t *drawing)\n+{\n+  drawing->quadratic_to (control->x, control->y,\n+                         to->x, to->y);\n+  return FT_Err_Ok;\n+}\n+\n+static int\n+_hb_ft_cubic_to (const FT_Vector *control1,\n+                 const FT_Vector *control2,\n+                 const FT_Vector *to,\n+                 hb_draw_session_t *drawing)\n+{\n+  drawing->cubic_to (control1->x, control1->y,\n+                     control2->x, control2->y,\n+                     to->x, to->y);\n+  return FT_Err_Ok;\n+}\n+\n+static void\n+hb_ft_get_glyph_shape (hb_font_t *font HB_UNUSED,\n+                       void *font_data,\n+                       hb_codepoint_t glyph,\n+                       hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                       void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Face ft_face = ft_font->ft_face;\n+\n+  _hb_ft_hb_font_check_changed (font, ft_font);\n+\n+  if (unlikely (FT_Load_Glyph (ft_face, glyph,\n+                               FT_LOAD_NO_BITMAP | ft_font->load_flags)))\n+    return;\n+\n+  if (ft_face->glyph->format != FT_GLYPH_FORMAT_OUTLINE)\n+    return;\n+\n+  const FT_Outline_Funcs outline_funcs = {\n+    (FT_Outline_MoveToFunc) _hb_ft_move_to,\n+    (FT_Outline_LineToFunc) _hb_ft_line_to,\n+    (FT_Outline_ConicToFunc) _hb_ft_conic_to,\n+    (FT_Outline_CubicToFunc) _hb_ft_cubic_to,\n+    0, \/* shift *\/\n+    0, \/* delta *\/\n+  };\n+\n+  hb_draw_session_t draw_session (draw_funcs, draw_data, font->slant_xy);\n+\n+  FT_Outline_Decompose (&ft_face->glyph->outline,\n+                        &outline_funcs,\n+                        &draw_session);\n+}\n@@ -568,0 +713,3 @@\n+\n+static inline void free_static_ft_funcs ();\n+\n@@ -574,2 +722,0 @@\n-    hb_font_funcs_set_font_h_extents_func (funcs, hb_ft_get_font_h_extents, nullptr, nullptr);\n-    \/\/hb_font_funcs_set_font_v_extents_func (funcs, hb_ft_get_font_v_extents, nullptr, nullptr);\n@@ -579,0 +725,2 @@\n+\n+    hb_font_funcs_set_font_h_extents_func (funcs, hb_ft_get_font_h_extents, nullptr, nullptr);\n@@ -580,1 +728,0 @@\n-    hb_font_funcs_set_glyph_v_advance_func (funcs, hb_ft_get_glyph_v_advance, nullptr, nullptr);\n@@ -582,0 +729,4 @@\n+\n+#ifndef HB_NO_VERTICAL\n+    \/\/hb_font_funcs_set_font_v_extents_func (funcs, hb_ft_get_font_v_extents, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_v_advance_func (funcs, hb_ft_get_glyph_v_advance, nullptr, nullptr);\n@@ -583,0 +734,2 @@\n+#endif\n+\n@@ -592,0 +745,4 @@\n+#ifndef HB_NO_DRAW\n+    hb_font_funcs_set_glyph_shape_func (funcs, hb_ft_get_glyph_shape, nullptr, nullptr);\n+#endif\n+\n@@ -594,3 +751,1 @@\n-#if HB_USE_ATEXIT\n-    atexit (free_static_ft_funcs);\n-#endif\n+    hb_atexit (free_static_ft_funcs);\n@@ -602,2 +757,1 @@\n-#if HB_USE_ATEXIT\n-static\n+static inline\n@@ -608,1 +762,0 @@\n-#endif\n@@ -645,1 +798,1 @@\n-  buffer = (FT_Byte *) malloc (length);\n+  buffer = (FT_Byte *) hb_malloc (length);\n@@ -652,1 +805,1 @@\n-    free (buffer);\n+    hb_free (buffer);\n@@ -658,1 +811,1 @@\n-                         buffer, free);\n+                         buffer, hb_free);\n@@ -849,2 +1002,2 @@\n-    FT_Fixed *ft_coords = (FT_Fixed *) calloc (mm_var->num_axis, sizeof (FT_Fixed));\n-    int *coords = (int *) calloc (mm_var->num_axis, sizeof (int));\n+    FT_Fixed *ft_coords = (FT_Fixed *) hb_calloc (mm_var->num_axis, sizeof (FT_Fixed));\n+    int *coords = (int *) hb_calloc (mm_var->num_axis, sizeof (int));\n@@ -869,2 +1022,2 @@\n-    free (coords);\n-    free (ft_coords);\n+    hb_free (coords);\n+    hb_free (ft_coords);\n@@ -874,1 +1027,1 @@\n-    free (mm_var);\n+    hb_free (mm_var);\n@@ -880,0 +1033,25 @@\n+\/**\n+ * hb_ft_hb_font_changed:\n+ * @font: #hb_font_t to work upon\n+ *\n+ * Refreshes the state of the underlying FT_Face of @font when the hb_font_t\n+ * @font has changed.\n+ * This function should be called after changing the size or\n+ * variation-axis settings on the @font.\n+ * This call is fast if nothing has changed on @font.\n+ *\n+ * Return value: true if changed, false otherwise\n+ *\n+ * Since: 4.4.0\n+ **\/\n+hb_bool_t\n+hb_ft_hb_font_changed (hb_font_t *font)\n+{\n+  if (font->destroy != (hb_destroy_func_t) _hb_ft_font_destroy)\n+    return false;\n+\n+  hb_ft_font_t *ft_font = (hb_ft_font_t *) font->user_data;\n+\n+  return _hb_ft_hb_font_check_changed (font, ft_font);\n+}\n+\n@@ -908,3 +1086,1 @@\n-#if HB_USE_ATEXIT\n-static void free_static_ft_library ();\n-#endif\n+static inline void free_static_ft_library ();\n@@ -921,3 +1097,1 @@\n-#if HB_USE_ATEXIT\n-    atexit (free_static_ft_library);\n-#endif\n+    hb_atexit (free_static_ft_library);\n@@ -937,2 +1111,1 @@\n-#if HB_USE_ATEXIT\n-static\n+static inline\n@@ -943,1 +1116,0 @@\n-#endif\n@@ -1004,29 +1176,1 @@\n-  FT_Set_Char_Size (ft_face,\n-                    abs (font->x_scale), abs (font->y_scale),\n-                    0, 0);\n-#if 0\n-                    font->x_ppem * 72 * 64 \/ font->x_scale,\n-                    font->y_ppem * 72 * 64 \/ font->y_scale);\n-#endif\n-  if (font->x_scale < 0 || font->y_scale < 0)\n-  {\n-    FT_Matrix matrix = { font->x_scale < 0 ? -1 : +1, 0,\n-                          0, font->y_scale < 0 ? -1 : +1};\n-    FT_Set_Transform (ft_face, &matrix, nullptr);\n-  }\n-\n-#if defined(HAVE_FT_GET_VAR_BLEND_COORDINATES) && !defined(HB_NO_VAR)\n-  unsigned int num_coords;\n-  const int *coords = hb_font_get_var_coords_normalized (font, &num_coords);\n-  if (num_coords)\n-  {\n-    FT_Fixed *ft_coords = (FT_Fixed *) calloc (num_coords, sizeof (FT_Fixed));\n-    if (ft_coords)\n-    {\n-      for (unsigned int i = 0; i < num_coords; i++)\n-        ft_coords[i] = coords[i] * 4;\n-      FT_Set_Var_Blend_Coordinates (ft_face, num_coords, ft_coords);\n-      free (ft_coords);\n-    }\n-  }\n-#endif\n+  _hb_ft_hb_font_changed (font, ft_face);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ft.cc","additions":223,"deletions":79,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -125,1 +125,2 @@\n-\/* Call when size or variations settings on underlying FT_Face change. *\/\n+\/* Call when size or variations settings on underlying FT_Face changed,\n+ * and you want to update the hb_font_t from it. *\/\n@@ -129,0 +130,6 @@\n+\/* Call when size or variations settings on underlying hb_font_t may have\n+ * changed, and you want to update the FT_Face from it.  This call is fast\n+ * if nothing changed on hb_font_t. Returns true if changed. *\/\n+HB_EXTERN hb_bool_t\n+hb_ft_hb_font_changed (hb_font_t *font);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ft.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,4 +46,2 @@\n- * TODO Document more.\n- *\n- * If iterator implementation implements operator!=, then can be\n- * used in range-based for loop.  That comes free if the iterator\n+ * If iterator implementation implements operator!=, then it can be\n+ * used in range-based for loop.  That already happens if the iterator\n@@ -53,4 +51,1 @@\n- * __end__() method.\n- * TODO When opting in for C++17, address this by changing return\n- * type of .end()?\n- *\/\n+ * __end__() method. *\/\n@@ -78,4 +73,0 @@\n-  \/* TODO:\n-   * Port operators below to use hb_enable_if to sniff which method implements\n-   * an operator and use it, and remove hb_iter_fallback_mixin_t completely. *\/\n-\n@@ -90,2 +81,1 @@\n-   * it will be returning pointer to temporary rvalue.\n-   * TODO Use a wrapper return type to fix for non-reference type. *\/\n+   * it will be returning pointer to temporary rvalue. *\/\n@@ -93,2 +83,2 @@\n-            hb_enable_if (hb_is_reference (T))>\n-  hb_remove_reference<item_t>* operator -> () const { return hb_addressof (**thiz()); }\n+            hb_enable_if (std::is_reference<T>::value)>\n+  hb_remove_reference<item_t>* operator -> () const { return std::addressof (**thiz()); }\n@@ -165,1 +155,1 @@\n-  { return hb_deref (hb_forward<T> (c)).iter (); }\n+  { return hb_deref (std::forward<T> (c)).iter (); }\n@@ -292,1 +282,1 @@\n-            hb_enable_if (hb_is_convertible (typename Iter2::item_t, hb_add_lvalue_reference<hb_add_const<Item>>))>\n+            hb_enable_if (hb_is_convertible (typename Iter2::item_t, hb_add_lvalue_reference<const Item>))>\n@@ -356,1 +346,1 @@\n-operator | (Lhs&& lhs, Rhs&& rhs) HB_AUTO_RETURN (hb_forward<Rhs> (rhs) (hb_forward<Lhs> (lhs)))\n+operator | (Lhs&& lhs, Rhs&& rhs) HB_AUTO_RETURN (std::forward<Rhs> (rhs) (std::forward<Lhs> (lhs)))\n@@ -584,0 +574,85 @@\n+\/* hb_concat() *\/\n+\n+template <typename A, typename B>\n+struct hb_concat_iter_t :\n+    hb_iter_t<hb_concat_iter_t<A, B>, typename A::item_t>\n+{\n+  hb_concat_iter_t () {}\n+  hb_concat_iter_t (A& a, B& b) : a (a), b (b) {}\n+  hb_concat_iter_t (const A& a, const B& b) : a (a), b (b) {}\n+\n+\n+  typedef typename A::item_t __item_t__;\n+  static constexpr bool is_random_access_iterator =\n+    A::is_random_access_iterator &&\n+    B::is_random_access_iterator;\n+  static constexpr bool is_sorted_iterator = false;\n+\n+  __item_t__ __item__ () const\n+  {\n+    if (!a)\n+      return *b;\n+    return *a;\n+  }\n+\n+  __item_t__ __item_at__ (unsigned i) const\n+  {\n+    unsigned a_len = a.len ();\n+    if (i < a_len)\n+      return a[i];\n+    return b[i - a_len];\n+  }\n+\n+  bool __more__ () const { return bool (a) || bool (b); }\n+\n+  unsigned __len__ () const { return a.len () + b.len (); }\n+\n+  void __next__ ()\n+  {\n+    if (a)\n+      ++a;\n+    else\n+      ++b;\n+  }\n+\n+  void __forward__ (unsigned n)\n+  {\n+    if (!n) return;\n+    if (!is_random_access_iterator) {\n+      while (n-- && *this) {\n+        (*this)++;\n+      }\n+      return;\n+    }\n+\n+    unsigned a_len = a.len ();\n+    if (n > a_len) {\n+      n -= a_len;\n+      a.__forward__ (a_len);\n+      b.__forward__ (n);\n+    } else {\n+      a.__forward__ (n);\n+    }\n+  }\n+\n+  hb_concat_iter_t __end__ () const { return hb_concat_iter_t (a.end (), b.end ()); }\n+  bool operator != (const hb_concat_iter_t& o) const\n+  {\n+    return a != o.a\n+        || b != o.b;\n+  }\n+\n+  private:\n+  A a;\n+  B b;\n+};\n+struct\n+{ HB_PARTIALIZE(2);\n+  template <typename A, typename B,\n+            hb_requires (hb_is_iterable (A) && hb_is_iterable (B))>\n+  hb_concat_iter_t<hb_iter_type<A>, hb_iter_type<B>>\n+  operator () (A&& a, B&& b) const\n+  { return hb_concat_iter_t<hb_iter_type<A>, hb_iter_type<B>> (hb_iter (a), hb_iter (b)); }\n+}\n+HB_FUNCOBJ (hb_concat);\n+\n@@ -677,2 +752,2 @@\n-    -> hb_void_t<decltype (hb_invoke (hb_forward<S2> (s), hb_declval<T&> ()))>\n-  { v = hb_invoke (hb_forward<S2> (s), v); }\n+    -> hb_void_t<decltype (hb_invoke (std::forward<S2> (s), hb_declval<T&> ()))>\n+  { v = hb_invoke (std::forward<S2> (s), v); }\n@@ -877,1 +952,1 @@\n-      if (!hb_match (hb_forward<Pred> (p), hb_get (hb_forward<Proj> (f), *it)))\n+      if (!hb_match (std::forward<Pred> (p), hb_get (std::forward<Proj> (f), *it)))\n@@ -894,1 +969,1 @@\n-      if (hb_match (hb_forward<Pred> (p), hb_get (hb_forward<Proj> (f), *it)))\n+      if (hb_match (std::forward<Pred> (p), hb_get (std::forward<Proj> (f), *it)))\n@@ -911,1 +986,1 @@\n-      if (hb_match (hb_forward<Pred> (p), hb_get (hb_forward<Proj> (f), *it)))\n+      if (hb_match (std::forward<Pred> (p), hb_get (std::forward<Proj> (f), *it)))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-iter.hh","additions":99,"deletions":24,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -52,0 +52,4 @@\n+    if (!buffer->message (font, \"start kern\"))\n+      return;\n+\n+    buffer->unsafe_to_concat ();\n@@ -70,1 +74,2 @@\n-      if (!skippy_iter.next ())\n+      unsigned unsafe_to;\n+      if (!skippy_iter.next (&unsafe_to))\n@@ -128,0 +133,2 @@\n+\n+    (void) buffer->message (font, \"end kern\");\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-kern.hh","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  void fini ()  { do_destroy (instance.get ()); }\n+  void fini ()  { do_destroy (instance.get ()); init (); }\n@@ -197,1 +197,2 @@\n-  const Returned & operator * () const  { return *get (); }\n+  template <typename U = Returned, hb_enable_if (!hb_is_same (U, void))>\n+  const U & operator * () const  { return *get (); }\n@@ -245,1 +246,1 @@\n-    Stored *p = (Stored *) calloc (1, sizeof (Stored));\n+    Stored *p = (Stored *) hb_calloc (1, sizeof (Stored));\n@@ -247,1 +248,1 @@\n-      p->init (data);\n+      p = new (p) Stored (data);\n@@ -252,1 +253,1 @@\n-    Stored *p = (Stored *) calloc (1, sizeof (Stored));\n+    Stored *p = (Stored *) hb_calloc (1, sizeof (Stored));\n@@ -254,1 +255,1 @@\n-      p->init ();\n+      p = new (p) Stored ();\n@@ -259,2 +260,2 @@\n-    p->fini ();\n-    free (p);\n+    p->~Stored ();\n+    hb_free (p);\n@@ -275,1 +276,1 @@\n-template <typename T, unsigned int WheresFace>\n+template <typename T, unsigned int WheresFace, bool core=false>\n@@ -277,1 +278,1 @@\n-                                                 hb_table_lazy_loader_t<T, WheresFace>,\n+                                                 hb_table_lazy_loader_t<T, WheresFace, core>,\n@@ -282,1 +283,6 @@\n-  { return hb_sanitize_context_t ().reference_table<T> (face); }\n+  {\n+    auto c = hb_sanitize_context_t ();\n+    if (core)\n+      c.set_num_glyphs (0); \/\/ So we don't recurse ad infinitum...\n+    return c.reference_table<T> (face);\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-machinery.hh","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * hb_map_create: (Xconstructor)\n+ * hb_map_create:\n@@ -112,1 +112,1 @@\n-  free (map);\n+  hb_free (map);\n@@ -175,0 +175,19 @@\n+\/**\n+ * hb_map_copy:\n+ * @map: A map\n+ *\n+ * Allocate a copy of @map.\n+ *\n+ * Return value: Newly-allocated map.\n+ *\n+ * Since: 4.4.0\n+ **\/\n+hb_map_t *\n+hb_map_copy (const hb_map_t *map)\n+{\n+  hb_map_t *copy = hb_map_create ();\n+  if (unlikely (!copy)) return nullptr;\n+  copy->resize (map->population);\n+  hb_copy (*map, *copy);\n+  return copy;\n+}\n@@ -191,0 +210,1 @@\n+  \/* Immutable-safe. *\/\n@@ -223,0 +243,1 @@\n+  \/* Immutable-safe. *\/\n@@ -256,3 +277,0 @@\n-  if (unlikely (hb_object_is_immutable (map)))\n-    return;\n-\n@@ -293,0 +311,37 @@\n+\n+\/**\n+ * hb_map_is_equal:\n+ * @map: A map\n+ * @other: Another map\n+ *\n+ * Tests whether @map and @other are equal (contain the same\n+ * elements).\n+ *\n+ * Return value: %true if the two maps are equal, %false otherwise.\n+ *\n+ * Since: 4.3.0\n+ **\/\n+hb_bool_t\n+hb_map_is_equal (const hb_map_t *map,\n+                 const hb_map_t *other)\n+{\n+  return map->is_equal (*other);\n+}\n+\n+\/**\n+ * hb_map_hash:\n+ * @map: A map\n+ *\n+ * Creates a hash representing @map.\n+ *\n+ * Return value:\n+ * A hash of @map.\n+ *\n+ * Since: 4.4.0\n+ **\/\n+HB_EXTERN unsigned int\n+hb_map_hash (const hb_map_t *map)\n+{\n+  return map->hash ();\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.cc","additions":60,"deletions":5,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -85,0 +85,3 @@\n+HB_EXTERN hb_map_t *\n+hb_map_copy (const hb_map_t *map);\n+\n@@ -94,0 +97,7 @@\n+HB_EXTERN hb_bool_t\n+hb_map_is_equal (const hb_map_t *map,\n+                 const hb_map_t *other);\n+\n+HB_EXTERN unsigned int\n+hb_map_hash (const hb_map_t *map);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.h","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+extern HB_INTERNAL const hb_codepoint_t minus_1;\n+\n@@ -38,2 +40,1 @@\n-          K kINVALID = hb_is_pointer (K) ? 0 : hb_is_signed (K) ? hb_int_min (K) : (K) -1,\n-          V vINVALID = hb_is_pointer (V) ? 0 : hb_is_signed (V) ? hb_int_min (V) : (V) -1>\n+          bool minus_one = false>\n@@ -42,1 +43,0 @@\n-  HB_DELETE_COPY_ASSIGN (hb_hashmap_t);\n@@ -46,2 +46,19 @@\n-  static_assert (hb_is_integral (K) || hb_is_pointer (K), \"\");\n-  static_assert (hb_is_integral (V) || hb_is_pointer (V), \"\");\n+  hb_hashmap_t (const hb_hashmap_t& o) : hb_hashmap_t () { resize (population); hb_copy (o, *this); }\n+  hb_hashmap_t (hb_hashmap_t&& o) : hb_hashmap_t () { hb_swap (*this, o); }\n+  hb_hashmap_t& operator= (const hb_hashmap_t& o)  { resize (population); hb_copy (o, *this); return *this; }\n+  hb_hashmap_t& operator= (hb_hashmap_t&& o)  { hb_swap (*this, o); return *this; }\n+\n+  hb_hashmap_t (std::initializer_list<hb_pair_t<K, V>> lst) : hb_hashmap_t ()\n+  {\n+    for (auto&& item : lst)\n+      set (item.first, item.second);\n+  }\n+  template <typename Iterable,\n+            hb_requires (hb_is_iterable (Iterable))>\n+  hb_hashmap_t (const Iterable &o) : hb_hashmap_t ()\n+  {\n+    auto iter = hb_iter (o);\n+    if (iter.is_random_access_iterator)\n+      resize (hb_len (iter));\n+    hb_copy (iter, *this);\n+  }\n@@ -52,0 +69,3 @@\n+    uint32_t hash : 30;\n+    uint32_t is_used_ : 1;\n+    uint32_t is_tombstone_ : 1;\n@@ -53,1 +73,0 @@\n-    uint32_t hash;\n@@ -55,1 +74,25 @@\n-    void clear () { key = kINVALID; value = vINVALID; hash = 0; }\n+    bool is_used () const { return is_used_; }\n+    void set_used (bool is_used) { is_used_ = is_used; }\n+    bool is_tombstone () const { return is_tombstone_; }\n+    void set_tombstone (bool is_tombstone) { is_tombstone_ = is_tombstone; }\n+    bool is_real () const { return is_used_ && !is_tombstone_; }\n+\n+    template <bool v = minus_one,\n+              hb_enable_if (v == false)>\n+    static inline const V& default_value () { return Null(V); };\n+    template <bool v = minus_one,\n+              hb_enable_if (v == true)>\n+    static inline const V& default_value ()\n+    {\n+      static_assert (hb_is_same (V, hb_codepoint_t), \"\");\n+      return minus_1;\n+    };\n+\n+    void clear ()\n+    {\n+      new (std::addressof (key)) K ();\n+      new (std::addressof (value)) V ();\n+      hash = 0;\n+      is_used_ = false;\n+      is_tombstone_ = false;\n+    }\n@@ -59,3 +102,0 @@\n-    bool is_unused () const    { return key == kINVALID; }\n-    bool is_tombstone () const { return key != kINVALID && value == vINVALID; }\n-    bool is_real () const { return key != kINVALID && value != vINVALID; }\n@@ -63,0 +103,4 @@\n+    hb_pair_t<const K &, const V &> get_pair_ref() const { return hb_pair_t<const K &, const V &> (key, value); }\n+\n+    uint32_t total_hash () const\n+    { return (hash * 31) + hb_hash (value); }\n@@ -73,0 +117,10 @@\n+  friend void swap (hb_hashmap_t& a, hb_hashmap_t& b)\n+  {\n+    if (unlikely (!a.successful || !b.successful))\n+      return;\n+    hb_swap (a.population, b.population);\n+    hb_swap (a.occupancy, b.occupancy);\n+    hb_swap (a.mask, b.mask);\n+    hb_swap (a.prime, b.prime);\n+    hb_swap (a.items, b.items);\n+  }\n@@ -88,2 +142,7 @@\n-    free (items);\n-    items = nullptr;\n+    if (likely (items)) {\n+      unsigned size = mask + 1;\n+      for (unsigned i = 0; i < size; i++)\n+        items[i].~item_t ();\n+      hb_free (items);\n+      items = nullptr;\n+    }\n@@ -106,1 +165,1 @@\n-  bool resize ()\n+  bool resize (unsigned new_population = 0)\n@@ -110,1 +169,1 @@\n-    unsigned int power = hb_bit_storage (population * 2 + 8);\n+    unsigned int power = hb_bit_storage (hb_max (population, new_population) * 2 + 8);\n@@ -112,1 +171,1 @@\n-    item_t *new_items = (item_t *) malloc ((size_t) new_size * sizeof (item_t));\n+    item_t *new_items = (item_t *) hb_malloc ((size_t) new_size * sizeof (item_t));\n@@ -133,0 +192,1 @@\n+      {\n@@ -134,0 +194,1 @@\n+        {\n@@ -136,1 +197,4 @@\n-                         old_items[i].value);\n+                         std::move (old_items[i].value));\n+        }\n+        old_items[i].~item_t ();\n+      }\n@@ -138,1 +202,1 @@\n-    free (old_items);\n+    hb_free (old_items);\n@@ -143,4 +207,2 @@\n-  void set (K key, V value)\n-  {\n-    set_with_hash (key, hb_hash (key), value);\n-  }\n+  template <typename VV>\n+  bool set (K key, VV&& value) { return set_with_hash (key, hb_hash (key), std::forward<VV> (value)); }\n@@ -148,1 +210,1 @@\n-  V get (K key) const\n+  const V& get (K key) const\n@@ -150,1 +212,1 @@\n-    if (unlikely (!items)) return vINVALID;\n+    if (unlikely (!items)) return item_t::default_value ();\n@@ -152,1 +214,1 @@\n-    return items[i].is_real () && items[i] == key ? items[i].value : vINVALID;\n+    return items[i].is_real () && items[i] == key ? items[i].value : item_t::default_value ();\n@@ -155,1 +217,1 @@\n-  void del (K key) { set (key, vINVALID); }\n+  void del (K key) { set_with_hash (key, hb_hash (key), item_t::default_value (), true); }\n@@ -158,2 +220,1 @@\n-  static constexpr V SENTINEL = vINVALID;\n-  typedef V value_t;\n+  typedef const V& value_t;\n@@ -161,1 +222,1 @@\n-  bool has (K k, V *vp = nullptr) const\n+  bool has (K key, const V **vp = nullptr) const\n@@ -163,3 +224,16 @@\n-    V v = (*this)[k];\n-    if (vp) *vp = v;\n-    return v != SENTINEL;\n+    if (unlikely (!items))\n+    {\n+      if (vp) *vp = &item_t::default_value ();\n+      return false;\n+    }\n+    unsigned int i = bucket_for (key);\n+    if (items[i].is_real () && items[i] == key)\n+    {\n+      if (vp) *vp = &items[i].value;\n+      return true;\n+    }\n+    else\n+    {\n+      if (vp) *vp = &item_t::default_value ();\n+      return false;\n+    }\n@@ -172,0 +246,2 @@\n+    if (unlikely (!successful)) return;\n+\n@@ -182,0 +258,22 @@\n+  uint32_t hash () const\n+  {\n+    uint32_t h = 0;\n+    for (const auto &item : + hb_array (items, mask ? mask + 1 : 0)\n+                            | hb_filter (&item_t::is_real))\n+      h ^= item.total_hash ();\n+    return h;\n+  }\n+\n+  bool is_equal (const hb_hashmap_t &other) const\n+  {\n+    if (population != other.population) return false;\n+\n+    for (auto pair : iter ())\n+      if (get (pair.first) != pair.second)\n+        return false;\n+\n+    return true;\n+  }\n+  bool operator == (const hb_hashmap_t &other) const { return is_equal (other); }\n+  bool operator != (const hb_hashmap_t &other) const { return !is_equal (other); }\n+\n@@ -193,0 +291,6 @@\n+  auto iter_ref () const HB_AUTO_RETURN\n+  (\n+    + hb_array (items, mask ? mask + 1 : 0)\n+    | hb_filter (&item_t::is_real)\n+    | hb_map (&item_t::get_pair_ref)\n+  )\n@@ -214,1 +318,2 @@\n-  void set_with_hash (K key, uint32_t hash, V value)\n+  template <typename VV>\n+  bool set_with_hash (K key, uint32_t hash, VV&& value, bool is_delete=false)\n@@ -216,3 +321,2 @@\n-    if (unlikely (!successful)) return;\n-    if (unlikely (key == kINVALID)) return;\n-    if ((occupancy + occupancy \/ 2) >= mask && !resize ()) return;\n+    if (unlikely (!successful)) return false;\n+    if (unlikely ((occupancy + occupancy \/ 2) >= mask && !resize ())) return false;\n@@ -221,2 +325,2 @@\n-    if (value == vINVALID && items[i].key != key)\n-      return; \/* Trying to delete non-existent key. *\/\n+    if (is_delete && items[i].key != key)\n+      return true; \/* Trying to delete non-existent key. *\/\n@@ -224,1 +328,1 @@\n-    if (!items[i].is_unused ())\n+    if (items[i].is_used ())\n@@ -227,1 +331,1 @@\n-      if (items[i].is_tombstone ())\n+      if (!items[i].is_tombstone ())\n@@ -232,1 +336,1 @@\n-    items[i].value = value;\n+    items[i].value = std::forward<VV> (value);\n@@ -234,0 +338,2 @@\n+    items[i].set_used (true);\n+    items[i].set_tombstone (is_delete);\n@@ -236,1 +342,1 @@\n-    if (!items[i].is_tombstone ())\n+    if (!is_delete)\n@@ -238,0 +344,2 @@\n+\n+    return true;\n@@ -240,1 +348,1 @@\n-  unsigned int bucket_for (K key) const\n+  unsigned int bucket_for (const K &key) const\n@@ -245,1 +353,1 @@\n-  unsigned int bucket_for_hash (K key, uint32_t hash) const\n+  unsigned int bucket_for_hash (const K &key, uint32_t hash) const\n@@ -247,0 +355,1 @@\n+    hash &= 0x3FFFFFFF; \/\/ We only store lower 30bit of hash\n@@ -250,1 +359,1 @@\n-    while (!items[i].is_unused ())\n+    while (items[i].is_used ())\n@@ -319,3 +428,17 @@\n-                               HB_MAP_VALUE_INVALID,\n-                               HB_MAP_VALUE_INVALID> {};\n-\n+                               true>\n+{\n+  using hashmap = hb_hashmap_t<hb_codepoint_t,\n+                               hb_codepoint_t,\n+                               true>;\n+\n+  ~hb_map_t () = default;\n+  hb_map_t () : hashmap () {}\n+  hb_map_t (const hb_map_t &o) : hashmap ((hashmap &) o) {}\n+  hb_map_t (hb_map_t &&o) : hashmap (std::move ((hashmap &) o)) {}\n+  hb_map_t& operator= (const hb_map_t&) = default;\n+  hb_map_t& operator= (hb_map_t&&) = default;\n+  hb_map_t (std::initializer_list<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> lst) : hashmap (lst) {}\n+  template <typename Iterable,\n+            hb_requires (hb_is_iterable (Iterable))>\n+  hb_map_t (const Iterable &o) : hashmap (o) {}\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.hh","additions":170,"deletions":47,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+#include <memory>\n+#include <type_traits>\n+#include <utility>\n+\n@@ -85,16 +89,0 @@\n-struct\n-{\n-  template <typename T> constexpr T*\n-  operator () (T& arg) const\n-  {\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wcast-align\"\n-    \/* https:\/\/en.cppreference.com\/w\/cpp\/memory\/addressof *\/\n-    return reinterpret_cast<T*> (\n-             &const_cast<char&> (\n-                reinterpret_cast<const volatile char&> (arg)));\n-#pragma GCC diagnostic pop\n-  }\n-}\n-HB_FUNCOBJ (hb_addressof);\n-\n@@ -104,2 +92,2 @@\n-template <typename T> struct hb_match_const             : hb_type_identity_t<T>, hb_bool_constant<false>{};\n-template <typename T> struct hb_match_const<const T>    : hb_type_identity_t<T>, hb_bool_constant<true> {};\n+template <typename T> struct hb_match_const             : hb_type_identity_t<T>, hb_false_type  {};\n+template <typename T> struct hb_match_const<const T>    : hb_type_identity_t<T>, hb_true_type   {};\n@@ -107,5 +95,4 @@\n-template <typename T> using hb_add_const = const T;\n-#define hb_is_const(T) hb_match_const<T>::value\n-template <typename T> struct hb_match_reference         : hb_type_identity_t<T>, hb_bool_constant<false>{};\n-template <typename T> struct hb_match_reference<T &>    : hb_type_identity_t<T>, hb_bool_constant<true> {};\n-template <typename T> struct hb_match_reference<T &&>   : hb_type_identity_t<T>, hb_bool_constant<true> {};\n+\n+template <typename T> struct hb_match_reference         : hb_type_identity_t<T>, hb_false_type  {};\n+template <typename T> struct hb_match_reference<T &>    : hb_type_identity_t<T>, hb_true_type   {};\n+template <typename T> struct hb_match_reference<T &&>   : hb_type_identity_t<T>, hb_true_type   {};\n@@ -119,3 +106,3 @@\n-#define hb_is_reference(T) hb_match_reference<T>::value\n-template <typename T> struct hb_match_pointer           : hb_type_identity_t<T>, hb_bool_constant<false>{};\n-template <typename T> struct hb_match_pointer<T *>      : hb_type_identity_t<T>, hb_bool_constant<true> {};\n+\n+template <typename T> struct hb_match_pointer           : hb_type_identity_t<T>, hb_false_type  {};\n+template <typename T> struct hb_match_pointer<T *>      : hb_type_identity_t<T>, hb_true_type   {};\n@@ -126,1 +113,0 @@\n-#define hb_is_pointer(T) hb_match_pointer<T>::value\n@@ -132,34 +118,1 @@\n-\n-template<bool B, class T, class F>\n-struct _hb_conditional { typedef T type; };\n-template<class T, class F>\n-struct _hb_conditional<false, T, F> { typedef F type; };\n-template<bool B, class T, class F>\n-using hb_conditional = typename _hb_conditional<B, T, F>::type;\n-\n-\n-template <typename From, typename To>\n-struct hb_is_convertible\n-{\n-  private:\n-  static constexpr bool   from_void = hb_is_same (void, hb_decay<From>);\n-  static constexpr bool     to_void = hb_is_same (void, hb_decay<To>  );\n-  static constexpr bool either_void = from_void || to_void;\n-  static constexpr bool   both_void = from_void && to_void;\n-\n-  static hb_true_type impl2 (hb_conditional<to_void, int, To>);\n-\n-  template <typename T>\n-  static auto impl (hb_priority<1>) -> decltype (impl2 (hb_declval (T)));\n-  template <typename T>\n-  static hb_false_type impl (hb_priority<0>);\n-  public:\n-  static constexpr bool value = both_void ||\n-                       (!either_void &&\n-                        decltype (impl<hb_conditional<from_void, int, From>> (hb_prioritize))::value);\n-};\n-#define hb_is_convertible(From,To) hb_is_convertible<From, To>::value\n-\n-template <typename Base, typename Derived>\n-using hb_is_base_of = hb_is_convertible<hb_decay<Derived> *, hb_decay<Base> *>;\n-#define hb_is_base_of(Base,Derived) hb_is_base_of<Base, Derived>::value\n+#define hb_is_convertible(From,To) std::is_convertible<From, To>::value\n@@ -170,2 +123,2 @@\n-  (!hb_is_const (From) || hb_is_const (To)) &&\n-  (!hb_is_reference (To) || hb_is_const (To) || hb_is_reference (To))\n+  (!std::is_const<From>::value || std::is_const<To>::value) &&\n+  (!std::is_reference<To>::value || std::is_const<To>::value || std::is_reference<To>::value)\n@@ -175,9 +128,0 @@\n-\/* std::move and std::forward *\/\n-\n-template <typename T>\n-static constexpr hb_remove_reference<T>&& hb_move (T&& t) { return (hb_remove_reference<T>&&) (t); }\n-\n-template <typename T>\n-static constexpr T&& hb_forward (hb_remove_reference<T>& t) { return (T&&) t; }\n-template <typename T>\n-static constexpr T&& hb_forward (hb_remove_reference<T>&& t) { return (T&&) t; }\n@@ -188,1 +132,1 @@\n-  operator () (T&& v) const HB_AUTO_RETURN (hb_forward<T> (v))\n+  operator () (T&& v) const HB_AUTO_RETURN (std::forward<T> (v))\n@@ -195,10 +139,0 @@\n-struct\n-{\n-  template <typename T> constexpr auto\n-  operator () (T&& v) const HB_AUTO_RETURN (hb_forward<T> (v))\n-\n-  template <typename T> constexpr auto\n-  operator () (T& v) const HB_AUTO_RETURN (hb_addressof (v))\n-}\n-HB_FUNCOBJ (hb_ref);\n-\n@@ -218,1 +152,1 @@\n-  hb_reference_wrapper (T& v) : v (hb_addressof (v)) {}\n+  hb_reference_wrapper (T& v) : v (std::addressof (v)) {}\n@@ -229,44 +163,0 @@\n-template <typename T>\n-using hb_is_integral = hb_bool_constant<\n-  hb_is_same (hb_decay<T>, char) ||\n-  hb_is_same (hb_decay<T>, signed char) ||\n-  hb_is_same (hb_decay<T>, unsigned char) ||\n-  hb_is_same (hb_decay<T>, signed int) ||\n-  hb_is_same (hb_decay<T>, unsigned int) ||\n-  hb_is_same (hb_decay<T>, signed short) ||\n-  hb_is_same (hb_decay<T>, unsigned short) ||\n-  hb_is_same (hb_decay<T>, signed long) ||\n-  hb_is_same (hb_decay<T>, unsigned long) ||\n-  hb_is_same (hb_decay<T>, signed long long) ||\n-  hb_is_same (hb_decay<T>, unsigned long long) ||\n-  false\n->;\n-#define hb_is_integral(T) hb_is_integral<T>::value\n-template <typename T>\n-using hb_is_floating_point = hb_bool_constant<\n-  hb_is_same (hb_decay<T>, float) ||\n-  hb_is_same (hb_decay<T>, double) ||\n-  hb_is_same (hb_decay<T>, long double) ||\n-  false\n->;\n-#define hb_is_floating_point(T) hb_is_floating_point<T>::value\n-template <typename T>\n-using hb_is_arithmetic = hb_bool_constant<\n-  hb_is_integral (T) ||\n-  hb_is_floating_point (T) ||\n-  false\n->;\n-#define hb_is_arithmetic(T) hb_is_arithmetic<T>::value\n-\n-\n-template <typename T>\n-using hb_is_signed = hb_conditional<hb_is_arithmetic (T),\n-                                    hb_bool_constant<(T) -1 < (T) 0>,\n-                                    hb_false_type>;\n-#define hb_is_signed(T) hb_is_signed<T>::value\n-template <typename T>\n-using hb_is_unsigned = hb_conditional<hb_is_arithmetic (T),\n-                                      hb_bool_constant<(T) 0 < (T) -1>,\n-                                      hb_false_type>;\n-#define hb_is_unsigned(T) hb_is_unsigned<T>::value\n-\n@@ -285,0 +175,1 @@\n+template <typename T> struct hb_int_min<T *>            : hb_integral_constant<T *,                     nullptr>        {};\n@@ -300,0 +191,13 @@\n+#if defined(__GNUC__) && __GNUC__ < 5\n+#define hb_is_trivially_copyable(T) __has_trivial_copy(T)\n+#define hb_is_trivially_copy_assignable(T) __has_trivial_assign(T)\n+#define hb_is_trivially_constructible(T) __has_trivial_constructor(T)\n+#define hb_is_trivially_copy_constructible(T) __has_trivial_copy_constructor(T)\n+#define hb_is_trivially_destructible(T) __has_trivial_destructor(T)\n+#else\n+#define hb_is_trivially_copyable(T) std::is_trivially_copyable<T>::value\n+#define hb_is_trivially_copy_assignable(T) std::is_trivially_copy_assignable<T>::value\n+#define hb_is_trivially_constructible(T) std::is_trivially_constructible<T>::value\n+#define hb_is_trivially_copy_constructible(T) std::is_trivially_copy_constructible<T>::value\n+#define hb_is_trivially_destructible(T) std::is_trivially_destructible<T>::value\n+#endif\n@@ -311,102 +215,0 @@\n-template <typename T, typename>\n-struct _hb_is_destructible : hb_false_type {};\n-template <typename T>\n-struct _hb_is_destructible<T, hb_void_t<decltype (hb_declval (T).~T ())>> : hb_true_type {};\n-template <typename T>\n-using hb_is_destructible = _hb_is_destructible<T, void>;\n-#define hb_is_destructible(T) hb_is_destructible<T>::value\n-\n-template <typename T, typename, typename ...Ts>\n-struct _hb_is_constructible : hb_false_type {};\n-template <typename T, typename ...Ts>\n-struct _hb_is_constructible<T, hb_void_t<decltype (T (hb_declval (Ts)...))>, Ts...> : hb_true_type {};\n-template <typename T, typename ...Ts>\n-using hb_is_constructible = _hb_is_constructible<T, void, Ts...>;\n-#define hb_is_constructible(...) hb_is_constructible<__VA_ARGS__>::value\n-\n-template <typename T>\n-using hb_is_default_constructible = hb_is_constructible<T>;\n-#define hb_is_default_constructible(T) hb_is_default_constructible<T>::value\n-\n-template <typename T>\n-using hb_is_copy_constructible = hb_is_constructible<T, hb_add_lvalue_reference<hb_add_const<T>>>;\n-#define hb_is_copy_constructible(T) hb_is_copy_constructible<T>::value\n-\n-template <typename T>\n-using hb_is_move_constructible = hb_is_constructible<T, hb_add_rvalue_reference<hb_add_const<T>>>;\n-#define hb_is_move_constructible(T) hb_is_move_constructible<T>::value\n-\n-template <typename T, typename U, typename>\n-struct _hb_is_assignable : hb_false_type {};\n-template <typename T, typename U>\n-struct _hb_is_assignable<T, U, hb_void_t<decltype (hb_declval (T) = hb_declval (U))>> : hb_true_type {};\n-template <typename T, typename U>\n-using hb_is_assignable = _hb_is_assignable<T, U, void>;\n-#define hb_is_assignable(T,U) hb_is_assignable<T, U>::value\n-\n-template <typename T>\n-using hb_is_copy_assignable = hb_is_assignable<hb_add_lvalue_reference<T>,\n-                                               hb_add_lvalue_reference<hb_add_const<T>>>;\n-#define hb_is_copy_assignable(T) hb_is_copy_assignable<T>::value\n-\n-template <typename T>\n-using hb_is_move_assignable = hb_is_assignable<hb_add_lvalue_reference<T>,\n-                                               hb_add_rvalue_reference<T>>;\n-#define hb_is_move_assignable(T) hb_is_move_assignable<T>::value\n-\n-\/* Trivial versions. *\/\n-\n-template <typename T> union hb_trivial { T value; };\n-\n-template <typename T>\n-using hb_is_trivially_destructible= hb_is_destructible<hb_trivial<T>>;\n-#define hb_is_trivially_destructible(T) hb_is_trivially_destructible<T>::value\n-\n-\/* Don't know how to do the following. *\/\n-\/\/template <typename T, typename ...Ts>\n-\/\/using hb_is_trivially_constructible= hb_is_constructible<hb_trivial<T>, hb_trivial<Ts>...>;\n-\/\/#define hb_is_trivially_constructible(...) hb_is_trivially_constructible<__VA_ARGS__>::value\n-\n-template <typename T>\n-using hb_is_trivially_default_constructible= hb_is_default_constructible<hb_trivial<T>>;\n-#define hb_is_trivially_default_constructible(T) hb_is_trivially_default_constructible<T>::value\n-\n-template <typename T>\n-using hb_is_trivially_copy_constructible= hb_is_copy_constructible<hb_trivial<T>>;\n-#define hb_is_trivially_copy_constructible(T) hb_is_trivially_copy_constructible<T>::value\n-\n-template <typename T>\n-using hb_is_trivially_move_constructible= hb_is_move_constructible<hb_trivial<T>>;\n-#define hb_is_trivially_move_constructible(T) hb_is_trivially_move_constructible<T>::value\n-\n-\/* Don't know how to do the following. *\/\n-\/\/template <typename T, typename U>\n-\/\/using hb_is_trivially_assignable= hb_is_assignable<hb_trivial<T>, hb_trivial<U>>;\n-\/\/#define hb_is_trivially_assignable(T,U) hb_is_trivially_assignable<T, U>::value\n-\n-template <typename T>\n-using hb_is_trivially_copy_assignable= hb_is_copy_assignable<hb_trivial<T>>;\n-#define hb_is_trivially_copy_assignable(T) hb_is_trivially_copy_assignable<T>::value\n-\n-template <typename T>\n-using hb_is_trivially_move_assignable= hb_is_move_assignable<hb_trivial<T>>;\n-#define hb_is_trivially_move_assignable(T) hb_is_trivially_move_assignable<T>::value\n-\n-template <typename T>\n-using hb_is_trivially_copyable= hb_bool_constant<\n-  hb_is_trivially_destructible (T) &&\n-  (!hb_is_move_assignable (T) || hb_is_trivially_move_assignable (T)) &&\n-  (!hb_is_move_constructible (T) || hb_is_trivially_move_constructible (T)) &&\n-  (!hb_is_copy_assignable (T) || hb_is_trivially_copy_assignable (T)) &&\n-  (!hb_is_copy_constructible (T) || hb_is_trivially_copy_constructible (T)) &&\n-  true\n->;\n-#define hb_is_trivially_copyable(T) hb_is_trivially_copyable<T>::value\n-\n-template <typename T>\n-using hb_is_trivial= hb_bool_constant<\n-  hb_is_trivially_copyable (T) &&\n-  hb_is_trivially_default_constructible (T)\n->;\n-#define hb_is_trivial(T) hb_is_trivial<T>::value\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-meta.hh","additions":32,"deletions":230,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -42,2 +42,1 @@\n-#if defined(HB_MUTEX_IMPL_INIT) \\\n- && defined(hb_mutex_impl_init) \\\n+#if defined(hb_mutex_impl_init) \\\n@@ -51,1 +50,1 @@\n-#elif !defined(HB_NO_MT) && (defined(HAVE_PTHREAD) || defined(__APPLE__))\n+#elif !defined(HB_NO_MT) && !defined(HB_MUTEX_IMPL_STD_MUTEX) && (defined(HAVE_PTHREAD) || defined(__APPLE__))\n@@ -55,1 +54,0 @@\n-#define HB_MUTEX_IMPL_INIT      PTHREAD_MUTEX_INITIALIZER\n@@ -62,1 +60,1 @@\n-#elif !defined(HB_NO_MT) && defined(_WIN32)\n+#elif !defined(HB_NO_MT) && !defined(HB_MUTEX_IMPL_STD_MUTEX) && defined(_WIN32)\n@@ -65,1 +63,0 @@\n-#define HB_MUTEX_IMPL_INIT      {0}\n@@ -76,1 +73,11 @@\n-#elif defined(HB_NO_MT)\n+#elif !defined(HB_NO_MT)\n+\n+#include <mutex>\n+typedef std::mutex              hb_mutex_impl_t;\n+#define hb_mutex_impl_init(M)   HB_STMT_START { new (M) hb_mutex_impl_t; } HB_STMT_END\n+#define hb_mutex_impl_lock(M)   (M)->lock ()\n+#define hb_mutex_impl_unlock(M) (M)->unlock ()\n+#define hb_mutex_impl_finish(M) HB_STMT_START { (M)->~hb_mutex_impl_t(); } HB_STMT_END\n+\n+\n+#else \/* defined(HB_NO_MT) *\/\n@@ -79,1 +86,0 @@\n-#define HB_MUTEX_IMPL_INIT      0\n@@ -86,5 +92,0 @@\n-#else\n-\n-#error \"Could not find any system to define mutex macros.\"\n-#error \"Check hb-mutex.hh for possible resolutions.\"\n-\n@@ -94,2 +95,0 @@\n-#define HB_MUTEX_INIT           {HB_MUTEX_IMPL_INIT}\n-\n@@ -98,6 +97,10 @@\n-  hb_mutex_impl_t m;\n-\n-  void init   () { hb_mutex_impl_init   (&m); }\n-  void lock   () { hb_mutex_impl_lock   (&m); }\n-  void unlock () { hb_mutex_impl_unlock (&m); }\n-  void fini ()   { hb_mutex_impl_finish (&m); }\n+  \/* Create space for, but do not initialize m. *\/\n+  alignas(hb_mutex_impl_t) char m[sizeof (hb_mutex_impl_t)];\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wcast-align\"\n+  void init   () { hb_mutex_impl_init   ((hb_mutex_impl_t *) m); }\n+  void lock   () { hb_mutex_impl_lock   ((hb_mutex_impl_t *) m); }\n+  void unlock () { hb_mutex_impl_unlock ((hb_mutex_impl_t *) m); }\n+  void fini   () { hb_mutex_impl_finish ((hb_mutex_impl_t *) m); }\n+#pragma GCC diagnostic pop\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-mutex.hh","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#define HB_NULL_POOL_SIZE 384\n+#define HB_NULL_POOL_SIZE 448\n@@ -42,2 +42,5 @@\n-\/* Use SFINAE to sniff whether T has min_size; in which case return T::null_size,\n- * otherwise return sizeof(T). *\/\n+\/* Use SFINAE to sniff whether T has min_size; in which case return the larger\n+ * of sizeof(T) and T::null_size, otherwise return sizeof(T).\n+ *\n+ * The main purpose of this is to let structs communicate that they are not nullable,\n+ * by defining min_size but *not* null_size. *\/\n@@ -52,2 +55,3 @@\n-struct _hb_null_size<T, hb_void_t<decltype (T::min_size)>> : hb_integral_constant<unsigned, T::null_size> {};\n-\n+struct _hb_null_size<T, hb_void_t<decltype (T::min_size)>>\n+        : hb_integral_constant<unsigned,\n+                               (sizeof (T) > T::null_size ? sizeof (T) : T::null_size)> {};\n@@ -71,0 +75,8 @@\n+template <typename T, typename>\n+struct _hb_min_size : hb_integral_constant<unsigned, sizeof (T)> {};\n+template <typename T>\n+struct _hb_min_size<T, hb_void_t<decltype (T::min_size)>> : hb_integral_constant<unsigned, T::min_size> {};\n+template <typename T>\n+using hb_min_size = _hb_min_size<T, void>;\n+#define hb_min_size(T) hb_min_size<T>::value\n+\n@@ -99,1 +111,1 @@\n-        extern HB_INTERNAL const unsigned char _hb_Null_##Namespace##_##Type[Namespace::Type::null_size]; \\\n+        extern HB_INTERNAL const unsigned char _hb_Null_##Namespace##_##Type[hb_null_size (Namespace::Type)]; \\\n@@ -109,1 +121,1 @@\n-        const unsigned char _hb_Null_##Namespace##_##Type[Namespace::Type::null_size]\n+        const unsigned char _hb_Null_##Namespace##_##Type[hb_null_size (Namespace::Type)]\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-null.hh","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    item_t *item = items.find (v);\n+    item_t *item = items.lsearch (v);\n@@ -79,1 +79,1 @@\n-    item_t *item = items.find (v);\n+    item_t *item = items.lsearch (v);\n@@ -96,1 +96,1 @@\n-    item_t *item = items.find (v);\n+    item_t *item = items.lsearch (v);\n@@ -143,2 +143,0 @@\n-#define HB_REFERENCE_COUNT_INIT {0}\n-\n@@ -200,0 +198,2 @@\n+\n+  bool is_inert () const { return !ref_count.get_relaxed (); }\n@@ -220,1 +220,1 @@\n-  Type *obj = (Type *) calloc (1, sizeof (Type));\n+  Type *obj = (Type *) hb_calloc (1, sizeof (Type));\n@@ -237,5 +237,0 @@\n-static inline bool hb_object_is_inert (const Type *obj)\n-{\n-  return unlikely (obj->header.ref_count.is_inert ());\n-}\n-template <typename Type>\n@@ -260,1 +255,1 @@\n-  if (unlikely (!obj || hb_object_is_inert (obj)))\n+  if (unlikely (!obj || obj->header.is_inert ()))\n@@ -270,1 +265,1 @@\n-  if (unlikely (!obj || hb_object_is_inert (obj)))\n+  if (unlikely (!obj || obj->header.is_inert ()))\n@@ -287,1 +282,1 @@\n-    free (user_data);\n+    hb_free (user_data);\n@@ -298,1 +293,1 @@\n-  if (unlikely (!obj || hb_object_is_inert (obj)))\n+  if (unlikely (!obj || obj->header.is_inert ()))\n@@ -306,1 +301,1 @@\n-    user_data = (hb_user_data_array_t *) calloc (sizeof (hb_user_data_array_t), 1);\n+    user_data = (hb_user_data_array_t *) hb_calloc (sizeof (hb_user_data_array_t), 1);\n@@ -313,1 +308,1 @@\n-      free (user_data);\n+      hb_free (user_data);\n@@ -325,1 +320,1 @@\n-  if (unlikely (!obj || hb_object_is_inert (obj)))\n+  if (unlikely (!obj || obj->header.is_inert ()))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-object.hh","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n@@ -105,1 +104,7 @@\n-    return tables.bfind (t, table_index, HB_BFIND_NOT_FOUND_STORE, Index::NOT_FOUND_INDEX);\n+    \/* Use lfind for small fonts; there are fonts that have unsorted table entries;\n+     * those tend to work in other tools, so tolerate them.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3065 *\/\n+    if (tables.len < 16)\n+      return tables.lfind (t, table_index, HB_NOT_FOUND_STORE, Index::NOT_FOUND_INDEX);\n+    else\n+      return tables.bfind (t, table_index, HB_NOT_FOUND_STORE, Index::NOT_FOUND_INDEX);\n@@ -116,1 +121,2 @@\n-  template <typename item_t>\n+  template <typename Iterator,\n+            hb_requires ((hb_is_source_of<Iterator, hb_pair_t<hb_tag_t, hb_blob_t *>>::value))>\n@@ -119,1 +125,1 @@\n-                  hb_array_t<item_t> items)\n+                  Iterator it)\n@@ -123,1 +129,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -128,1 +134,2 @@\n-    if (unlikely (!tables.serialize (c, items.length))) return_trace (false);\n+    unsigned num_items = it.len ();\n+    if (unlikely (!tables.serialize (c, num_items))) return_trace (false);\n@@ -134,1 +141,2 @@\n-    for (unsigned int i = 0; i < tables.len; i++)\n+    unsigned i = 0;\n+    for (hb_pair_t<hb_tag_t, hb_blob_t*> entry : it)\n@@ -136,5 +144,2 @@\n-      TableRecord &rec = tables.arrayZ[i];\n-      hb_blob_t *blob = items[i].blob;\n-      rec.tag = items[i].tag;\n-      rec.length = blob->length;\n-      rec.offset.serialize (c, this);\n+      hb_blob_t *blob = entry.second;\n+      unsigned len = blob->length;\n@@ -143,1 +148,1 @@\n-      char *start = (char *) c->allocate_size<void> (rec.length);\n+      char *start = (char *) c->allocate_size<void> (len);\n@@ -146,2 +151,11 @@\n-      if (likely (rec.length))\n-        memcpy (start, blob->data, rec.length);\n+      TableRecord &rec = tables.arrayZ[i];\n+      rec.tag = entry.first;\n+      rec.length = len;\n+      rec.offset = 0;\n+      if (unlikely (!c->check_assign (rec.offset,\n+                                      (unsigned) ((char *) start - (char *) this),\n+                                      HB_SERIALIZE_ERROR_OFFSET_OVERFLOW)))\n+        return_trace (false);\n+\n+      if (likely (len))\n+        memcpy (start, blob->data, len);\n@@ -153,1 +167,1 @@\n-      if (items[i].tag == HB_OT_TAG_head &&\n+      if (entry.first == HB_OT_TAG_head &&\n@@ -162,0 +176,1 @@\n+      i++;\n@@ -173,1 +188,1 @@\n-      for (unsigned int i = 0; i < items.length; i++)\n+      for (unsigned int i = 0; i < num_items; i++)\n@@ -221,1 +236,1 @@\n-  LArrayOf<LOffsetTo<OpenTypeOffsetTable>>\n+  Array32Of<Offset32To<OpenTypeOffsetTable>>\n@@ -298,1 +313,1 @@\n-  NNOffsetTo<LArrayOf<HBUINT8>, HBUINT24>\n+  NNOffset24To<Array32Of<HBUINT8>>\n@@ -333,1 +348,1 @@\n-  NNOffsetTo<UnsizedArrayOf<ResourceRecord>>\n+  NNOffset16To<UnsizedArrayOf<ResourceRecord>>\n@@ -389,1 +404,1 @@\n-  NNOffsetTo<ArrayOfM1<ResourceTypeRecord>>\n+  NNOffset16To<ArrayOfM1<ResourceTypeRecord>>\n@@ -421,1 +436,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<HBUINT8>>\n+  NNOffset32To<UnsizedArrayOf<HBUINT8>>\n@@ -424,1 +439,1 @@\n-  LNNOffsetTo<ResourceMap >\n+  NNOffset32To<ResourceMap >\n@@ -480,1 +495,2 @@\n-  template <typename item_t>\n+  template <typename Iterator,\n+            hb_requires ((hb_is_source_of<Iterator, hb_pair_t<hb_tag_t, hb_blob_t *>>::value))>\n@@ -483,1 +499,1 @@\n-                         hb_array_t<item_t> items)\n+                         Iterator items)\n@@ -487,1 +503,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-open-file.hh","additions":42,"deletions":26,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"hb-meta.hh\"\n@@ -67,1 +68,1 @@\n-  operator hb_conditional<hb_is_signed (Type), signed, unsigned> () const { return v; }\n+  operator typename std::conditional<std::is_signed<Type>::value, signed, unsigned>::type () const { return v; }\n@@ -89,1 +90,1 @@\n-            hb_enable_if (hb_is_integral (Type2) &&\n+            hb_enable_if (std::is_integral<Type2>::value &&\n@@ -125,0 +126,9 @@\n+\/* 15-bit unsigned number; top bit used for extension. *\/\n+struct HBUINT15 : HBUINT16\n+{\n+  \/* TODO Flesh out; actually mask top bit. *\/\n+  HBUINT15& operator = (uint16_t i ) { HBUINT16::operator= (i); return *this; }\n+  public:\n+  DEFINE_SIZE_STATIC (2);\n+};\n+\n@@ -185,1 +195,1 @@\n-struct HBGlyphID : HBUINT16\n+struct HBGlyphID16 : HBUINT16\n@@ -187,1 +197,1 @@\n-  HBGlyphID& operator = (uint16_t i) { HBUINT16::operator= (i); return *this; }\n+  HBGlyphID16& operator = (uint16_t i) { HBUINT16::operator= (i); return *this; }\n@@ -199,0 +209,6 @@\n+struct VarIdx : HBUINT32 {\n+  static constexpr unsigned NO_VARIATION = 0xFFFFFFFFu;\n+  VarIdx& operator = (uint32_t i) { HBUINT32::operator= (i); return *this; }\n+};\n+DECLARE_NULL_NAMESPACE_BYTES (OT, VarIdx);\n+\n@@ -209,7 +225,0 @@\n-  void *serialize (hb_serialize_context_t *c, const void *base)\n-  {\n-    void *t = c->start_embed<void> ();\n-    c->check_assign (*this, (unsigned) ((char *) t - (char *) base));\n-    return t;\n-  }\n-\n@@ -221,0 +230,1 @@\n+typedef Offset<HBUINT24> Offset24;\n@@ -290,1 +300,1 @@\n-template <typename Type, typename OffsetType=HBUINT16, bool has_null=true>\n+template <typename Type, typename OffsetType, bool has_null=true>\n@@ -322,4 +332,0 @@\n-  Type& serialize (hb_serialize_context_t *c, const void *base)\n-  {\n-    return * (Type *) Offset<OffsetType>::serialize (c, base);\n-  }\n@@ -339,1 +345,1 @@\n-    bool ret = c->dispatch (src_base+src, hb_forward<Ts> (ds)...);\n+    bool ret = c->dispatch (src_base+src, std::forward<Ts> (ds)...);\n@@ -349,0 +355,17 @@\n+\n+  template <typename ...Ts>\n+  bool serialize_serialize (hb_serialize_context_t *c, Ts&&... ds)\n+  {\n+    *this = 0;\n+\n+    Type* obj = c->push<Type> ();\n+    bool ret = obj->serialize (c, std::forward<Ts> (ds)...);\n+\n+    if (ret)\n+      c->add_link (*this, c->pop_pack ());\n+    else\n+      c->pop_discard ();\n+\n+    return ret;\n+  }\n+\n@@ -365,1 +388,1 @@\n-    bool ret = c->copy (src_base+src, hb_forward<Ts> (ds)...);\n+    bool ret = c->copy (src_base+src, std::forward<Ts> (ds)...);\n@@ -381,1 +404,1 @@\n-    if (unlikely (!c->check_range (base, *this))) return_trace (false);\n+    if (unlikely ((const char *) base + (unsigned) *this < (const char *) base)) return_trace (false);\n@@ -391,1 +414,1 @@\n-                   c->dispatch (StructAtOffset<Type> (base, *this), hb_forward<Ts> (ds)...) ||\n+                   c->dispatch (StructAtOffset<Type> (base, *this), std::forward<Ts> (ds)...) ||\n@@ -404,6 +427,8 @@\n-template <typename Type, bool has_null=true>\n-using LOffsetTo = OffsetTo<Type, HBUINT32, has_null>;\n-template <typename Type, typename OffsetType=HBUINT16>\n-using NNOffsetTo = OffsetTo<Type, OffsetType, false>;\n-template <typename Type>\n-using LNNOffsetTo = LOffsetTo<Type, false>;\n+template <typename Type, bool has_null=true> using Offset16To = OffsetTo<Type, HBUINT16, has_null>;\n+template <typename Type, bool has_null=true> using Offset24To = OffsetTo<Type, HBUINT24, has_null>;\n+template <typename Type, bool has_null=true> using Offset32To = OffsetTo<Type, HBUINT32, has_null>;\n+\n+template <typename Type, typename OffsetType> using NNOffsetTo = OffsetTo<Type, OffsetType, false>;\n+template <typename Type> using NNOffset16To = Offset16To<Type, false>;\n+template <typename Type> using NNOffset24To = Offset24To<Type, false>;\n+template <typename Type> using NNOffset32To = Offset32To<Type, false>;\n@@ -456,2 +481,4 @@\n-  bool lfind (unsigned int len, const T &x, unsigned *pos = nullptr) const\n-  { return as_array (len).lfind (x, pos); }\n+  bool lfind (unsigned int len, const T &x, unsigned int *i = nullptr,\n+              hb_not_found_t not_found = HB_NOT_FOUND_DONT_STORE,\n+              unsigned int to_store = (unsigned int) -1) const\n+  { return as_array (len).lfind (x, i, not_found, to_store); }\n@@ -465,1 +492,1 @@\n-    if (unlikely (!c->extend (*this, items_len))) return_trace (false);\n+    if (unlikely (!c->extend (this, items_len))) return_trace (false);\n@@ -495,1 +522,1 @@\n-    if (!sizeof... (Ts) && hb_is_trivially_copyable (Type)) return_trace (true);\n+    if (!sizeof... (Ts) && hb_is_trivially_copyable(Type)) return_trace (true);\n@@ -497,1 +524,1 @@\n-      if (unlikely (!c->dispatch (arrayZ[i], hb_forward<Ts> (ds)...)))\n+      if (unlikely (!c->dispatch (arrayZ[i], std::forward<Ts> (ds)...)))\n@@ -516,1 +543,1 @@\n-using UnsizedOffsetArrayOf = UnsizedArrayOf<OffsetTo<Type, OffsetType, has_null>>;\n+using UnsizedArray16OfOffsetTo = UnsizedArrayOf<OffsetTo<Type, OffsetType, has_null>>;\n@@ -520,1 +547,1 @@\n-struct UnsizedOffsetListOf : UnsizedOffsetArrayOf<Type, OffsetType, has_null>\n+struct UnsizedListOfOffset16To : UnsizedArray16OfOffsetTo<Type, OffsetType, has_null>\n@@ -541,2 +568,2 @@\n-    return_trace ((UnsizedOffsetArrayOf<Type, OffsetType, has_null>\n-                   ::sanitize (c, count, this, hb_forward<Ts> (ds)...)));\n+    return_trace ((UnsizedArray16OfOffsetTo<Type, OffsetType, has_null>\n+                   ::sanitize (c, count, this, std::forward<Ts> (ds)...)));\n@@ -565,1 +592,1 @@\n-              hb_bfind_not_found_t not_found = HB_BFIND_NOT_FOUND_DONT_STORE,\n+              hb_not_found_t not_found = HB_NOT_FOUND_DONT_STORE,\n@@ -572,1 +599,1 @@\n-template <typename Type, typename LenType=HBUINT16>\n+template <typename Type, typename LenType>\n@@ -620,1 +647,16 @@\n-  hb_success_t serialize (hb_serialize_context_t *c, unsigned items_len)\n+  template <typename T>\n+  Type &lsearch (const T &x, Type &not_found = Crap (Type))\n+  { return *as_array ().lsearch (x, &not_found); }\n+  template <typename T>\n+  const Type &lsearch (const T &x, const Type &not_found = Null (Type)) const\n+  { return *as_array ().lsearch (x, &not_found); }\n+  template <typename T>\n+  bool lfind (const T &x, unsigned int *i = nullptr,\n+              hb_not_found_t not_found = HB_NOT_FOUND_DONT_STORE,\n+              unsigned int to_store = (unsigned int) -1) const\n+  { return as_array ().lfind (x, i, not_found, to_store); }\n+\n+  void qsort (unsigned int start = 0, unsigned int end = (unsigned int) -1)\n+  { as_array ().qsort (start, end); }\n+\n+  HB_NODISCARD bool serialize (hb_serialize_context_t *c, unsigned items_len)\n@@ -623,3 +665,3 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    c->check_assign (len, items_len);\n-    if (unlikely (!c->extend (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    c->check_assign (len, items_len, HB_SERIALIZE_ERROR_ARRAY_OVERFLOW);\n+    if (unlikely (!c->extend (this))) return_trace (false);\n@@ -630,1 +672,1 @@\n-  hb_success_t serialize (hb_serialize_context_t *c, Iterator items)\n+  HB_NODISCARD bool serialize (hb_serialize_context_t *c, Iterator items)\n@@ -646,1 +688,1 @@\n-    if (unlikely (!len || !c->extend (*this)))\n+    if (unlikely (!len || !c->extend (this)))\n@@ -659,1 +701,1 @@\n-    c->check_assign (out->len, len);\n+    c->check_assign (out->len, len, HB_SERIALIZE_ERROR_ARRAY_OVERFLOW);\n@@ -669,1 +711,1 @@\n-    if (!sizeof... (Ts) && hb_is_trivially_copyable (Type)) return_trace (true);\n+    if (!sizeof... (Ts) && hb_is_trivially_copyable(Type)) return_trace (true);\n@@ -672,1 +714,1 @@\n-      if (unlikely (!c->dispatch (arrayZ[i], hb_forward<Ts> (ds)...)))\n+      if (unlikely (!c->dispatch (arrayZ[i], std::forward<Ts> (ds)...)))\n@@ -677,13 +719,0 @@\n-  template <typename T>\n-  Type &lsearch (const T &x, Type &not_found = Crap (Type))\n-  { return *as_array ().lsearch (x, &not_found); }\n-  template <typename T>\n-  const Type &lsearch (const T &x, const Type &not_found = Null (Type)) const\n-  { return *as_array ().lsearch (x, &not_found); }\n-  template <typename T>\n-  bool lfind (const T &x, unsigned *pos = nullptr) const\n-  { return as_array ().lfind (x, pos); }\n-\n-  void qsort (unsigned int start = 0, unsigned int end = (unsigned int) -1)\n-  { as_array ().qsort (start, end); }\n-\n@@ -702,2 +731,2 @@\n-template <typename Type>\n-using LArrayOf = ArrayOf<Type, HBUINT32>;\n+template <typename Type> using Array16Of = ArrayOf<Type, HBUINT16>;\n+template <typename Type> using Array32Of = ArrayOf<Type, HBUINT32>;\n@@ -707,6 +736,3 @@\n-template <typename Type>\n-using OffsetArrayOf = ArrayOf<OffsetTo<Type, HBUINT16>>;\n-template <typename Type>\n-using LOffsetArrayOf = ArrayOf<OffsetTo<Type, HBUINT32>>;\n-template <typename Type>\n-using LOffsetLArrayOf = ArrayOf<OffsetTo<Type, HBUINT32>, HBUINT32>;\n+template <typename Type> using Array16OfOffset16To = ArrayOf<OffsetTo<Type, HBUINT16>, HBUINT16>;\n+template <typename Type> using Array16OfOffset32To = ArrayOf<OffsetTo<Type, HBUINT32>, HBUINT16>;\n+template <typename Type> using Array32OfOffset32To = ArrayOf<OffsetTo<Type, HBUINT32>, HBUINT32>;\n@@ -716,1 +742,1 @@\n-struct OffsetListOf : OffsetArrayOf<Type>\n+struct List16OfOffset16To : Array16OfOffset16To<Type>\n@@ -734,1 +760,1 @@\n-    struct OffsetListOf<Type> *out = c->serializer->embed (*this);\n+    struct List16OfOffset16To<Type> *out = c->serializer->embed (*this);\n@@ -746,1 +772,1 @@\n-    return_trace (OffsetArrayOf<Type>::sanitize (c, this, hb_forward<Ts> (ds)...));\n+    return_trace (Array16OfOffset16To<Type>::sanitize (c, this, std::forward<Ts> (ds)...));\n@@ -789,3 +815,3 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    c->check_assign (lenP1, items_len + 1);\n-    if (unlikely (!c->extend (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    c->check_assign (lenP1, items_len + 1, HB_SERIALIZE_ERROR_ARRAY_OVERFLOW);\n+    if (unlikely (!c->extend (this))) return_trace (false);\n@@ -813,1 +839,1 @@\n-    if (!sizeof... (Ts) && hb_is_trivially_copyable (Type)) return_trace (true);\n+    if (!sizeof... (Ts) && hb_is_trivially_copyable(Type)) return_trace (true);\n@@ -816,1 +842,1 @@\n-      if (unlikely (!c->dispatch (arrayZ[i], hb_forward<Ts> (ds)...)))\n+      if (unlikely (!c->dispatch (arrayZ[i], std::forward<Ts> (ds)...)))\n@@ -862,0 +888,1 @@\n+    if (!sizeof... (Ts) && hb_is_trivially_copyable(Type)) return_trace (true);\n@@ -864,1 +891,1 @@\n-      if (unlikely (!c->dispatch (arrayZ[i], hb_forward<Ts> (ds)...)))\n+      if (unlikely (!c->dispatch (arrayZ[i], std::forward<Ts> (ds)...)))\n@@ -885,1 +912,1 @@\n-template <typename Type, typename LenType=HBUINT16>\n+template <typename Type, typename LenType>\n@@ -931,1 +958,1 @@\n-              hb_bfind_not_found_t not_found = HB_BFIND_NOT_FOUND_DONT_STORE,\n+              hb_not_found_t not_found = HB_NOT_FOUND_DONT_STORE,\n@@ -936,0 +963,3 @@\n+template <typename Type> using SortedArray16Of = SortedArrayOf<Type, HBUINT16>;\n+template <typename Type> using SortedArray32Of = SortedArrayOf<Type, HBUINT32>;\n+\n@@ -1044,1 +1074,1 @@\n-    if (!sizeof... (Ts) && hb_is_trivially_copyable (Type)) return_trace (true);\n+    if (!sizeof... (Ts) && hb_is_trivially_copyable(Type)) return_trace (true);\n@@ -1047,1 +1077,1 @@\n-      if (unlikely (!(*this)[i].sanitize (c, hb_forward<Ts> (ds)...)))\n+      if (unlikely (!(*this)[i].sanitize (c, std::forward<Ts> (ds)...)))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-open-type.hh","additions":110,"deletions":80,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -49,13 +49,0 @@\n-inline unsigned int calcOffSize (unsigned int dataSize)\n-{\n-  unsigned int size = 1;\n-  unsigned int offset = dataSize + 1;\n-  while (offset & ~0xFF)\n-  {\n-    size++;\n-    offset >>= 8;\n-  }\n-  \/* format does not support size > 4; caller should handle it as an error *\/\n-  return size;\n-}\n-\n@@ -68,16 +55,2 @@\n-typedef hb_vector_t<unsigned char> str_buff_t;\n-struct str_buff_vec_t : hb_vector_t<str_buff_t>\n-{\n-  void fini () { SUPER::fini_deep (); }\n-\n-  unsigned int total_size () const\n-  {\n-    unsigned int size = 0;\n-    for (unsigned int i = 0; i < length; i++)\n-      size += (*this)[i].length;\n-    return size;\n-  }\n-\n-  private:\n-  typedef hb_vector_t<str_buff_t> SUPER;\n-};\n+using str_buff_t = hb_vector_t<unsigned char>;\n+using str_buff_vec_t = hb_vector_t<str_buff_t>;\n@@ -89,3 +62,0 @@\n-  static unsigned int calculate_offset_array_size (unsigned int offSize, unsigned int count)\n-  { return offSize * (count + 1); }\n-\n@@ -93,1 +63,1 @@\n-  { return calculate_offset_array_size (offSize, count); }\n+  { return offSize * (count + 1); }\n@@ -105,10 +75,0 @@\n-  bool serialize (hb_serialize_context_t *c, const CFFIndex &src)\n-  {\n-    TRACE_SERIALIZE (this);\n-    unsigned int size = src.get_size ();\n-    CFFIndex *dest = c->allocate_size<CFFIndex> (size);\n-    if (unlikely (!dest)) return_trace (false);\n-    memcpy (dest, &src, size);\n-    return_trace (true);\n-  }\n-\n@@ -120,0 +80,1 @@\n+\n@@ -125,0 +86,1 @@\n+      return_trace (true);\n@@ -126,8 +88,0 @@\n-    else\n-    {\n-      \/* serialize CFFIndex header *\/\n-      if (unlikely (!c->extend_min (*this))) return_trace (false);\n-      this->count = byteArray.length;\n-      this->offSize = offSize_;\n-      if (unlikely (!c->allocate_size<HBUINT8> (offSize_ * (byteArray.length + 1))))\n-        return_trace (false);\n@@ -135,8 +89,12 @@\n-      \/* serialize indices *\/\n-      unsigned int  offset = 1;\n-      unsigned int  i = 0;\n-      for (; i < byteArray.length; i++)\n-      {\n-        set_offset_at (i, offset);\n-        offset += byteArray[i].get_size ();\n-      }\n+    \/* serialize CFFIndex header *\/\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+    this->count = byteArray.length;\n+    this->offSize = offSize_;\n+    if (unlikely (!c->allocate_size<HBUINT8> (offSize_ * (byteArray.length + 1))))\n+      return_trace (false);\n+\n+    \/* serialize indices *\/\n+    unsigned int  offset = 1;\n+    unsigned int  i = 0;\n+    for (; i < byteArray.length; i++)\n+    {\n@@ -144,0 +102,3 @@\n+      offset += byteArray[i].get_size ();\n+    }\n+    set_offset_at (i, offset);\n@@ -145,8 +106,7 @@\n-      \/* serialize data *\/\n-      for (unsigned int i = 0; i < byteArray.length; i++)\n-      {\n-        const byte_str_t &bs = byteArray[i];\n-        unsigned char *dest = c->allocate_size<unsigned char> (bs.length);\n-        if (unlikely (!dest)) return_trace (false);\n-        memcpy (dest, &bs[0], bs.length);\n-      }\n+    \/* serialize data *\/\n+    for (unsigned int i = 0; i < byteArray.length; i++)\n+    {\n+      const hb_ubytes_t &bs = byteArray[i];\n+      unsigned char *dest = c->allocate_size<unsigned char> (bs.length);\n+      if (unlikely (!dest)) return_trace (false);\n+      memcpy (dest, &bs[0], bs.length);\n@@ -154,0 +114,1 @@\n+\n@@ -165,1 +126,1 @@\n-      byteArray[i] = byte_str_t (buffArray[i].arrayZ, buffArray[i].length);\n+      byteArray[i] = hb_ubytes_t (buffArray[i].arrayZ, buffArray[i].length);\n@@ -177,12 +138,3 @@\n-    if (it.len () == 0)\n-    {\n-      COUNT *dest = c->allocate_min<COUNT> ();\n-      if (unlikely (!dest)) return_trace (false);\n-      *dest = 0;\n-    }\n-    else\n-    {\n-      serialize_header(c, + it | hb_map ([] (const byte_str_t &_) { return _.length; }));\n-      for (const auto &_ : +it)\n-        _.copy (c);\n-    }\n+    serialize_header(c, + it | hb_map ([] (const hb_ubytes_t &_) { return _.length; }));\n+    for (const auto &_ : +it)\n+      _.copy (c);\n@@ -201,1 +153,1 @@\n-    | hb_map ([] (const str_buff_t &_) { return byte_str_t (_.arrayZ, _.length); })\n+    | hb_map ([] (const str_buff_t &_) { return hb_ubytes_t (_.arrayZ, _.length); })\n@@ -214,1 +166,1 @@\n-    unsigned off_size = calcOffSize (total);\n+    unsigned off_size = (hb_bit_storage (total + 1) + 7) \/ 8;\n@@ -217,1 +169,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -219,0 +171,2 @@\n+    if (!this->count) return_trace (true);\n+    if (unlikely (!c->extend (this->offSize))) return_trace (false);\n@@ -220,1 +174,1 @@\n-    if (unlikely (!c->allocate_size<HBUINT8> (off_size * (it.len () + 1))))\n+    if (unlikely (!c->allocate_size<HBUINT8> (off_size * (this->count + 1))))\n@@ -238,0 +192,1 @@\n+    assert (index <= count);\n@@ -248,0 +203,1 @@\n+  private:\n@@ -251,1 +207,1 @@\n-    const HBUINT8 *p = offsets + offSize * index;\n+\n@@ -253,0 +209,1 @@\n+    const HBUINT8 *p = offsets + size * index;\n@@ -261,2 +218,3 @@\n-    if (unlikely ((offset_at (index + 1) < offset_at (index)) ||\n-                  (offset_at (index + 1) > offset_at (count))))\n+    unsigned offset0 = offset_at (index);\n+    unsigned offset1 = offset_at (index + 1);\n+    if (unlikely (offset1 < offset0 || offset1 > offset_at (count)))\n@@ -264,1 +222,1 @@\n-    return offset_at (index + 1) - offset_at (index);\n+    return offset1 - offset0;\n@@ -268,3 +226,2 @@\n-  { return (const unsigned char *) this + min_size + offset_array_size (); }\n-\n-  unsigned int data_size () const { return HBINT8::static_size; }\n+  { return (const unsigned char *) this + min_size + offSize.static_size + offset_array_size (); }\n+  public:\n@@ -272,1 +229,1 @@\n-  byte_str_t operator [] (unsigned int index) const\n+  hb_ubytes_t operator [] (unsigned int index) const\n@@ -274,2 +231,4 @@\n-    if (unlikely (index >= count)) return Null (byte_str_t);\n-    return byte_str_t (data_base () + offset_at (index) - 1, length_at (index));\n+    if (unlikely (index >= count)) return hb_ubytes_t ();\n+    unsigned length = length_at (index);\n+    if (unlikely (!length)) return hb_ubytes_t ();\n+    return hb_ubytes_t (data_base () + offset_at (index) - 1, length);\n@@ -280,4 +239,3 @@\n-    if (this == &Null (CFFIndex)) return 0;\n-    if (count > 0)\n-      return min_size + offset_array_size () + (offset_at (count) - 1);\n-    return count.static_size;  \/* empty CFFIndex contains count only *\/\n+    if (count)\n+      return min_size + offSize.static_size + offset_array_size () + (offset_at (count) - 1);\n+    return min_size;  \/* empty CFFIndex contains count only *\/\n@@ -289,16 +247,6 @@\n-    return_trace (likely ((c->check_struct (this) && count == 0) || \/* empty INDEX *\/\n-                          (c->check_struct (this) && offSize >= 1 && offSize <= 4 &&\n-                           c->check_array (offsets, offSize, count + 1) &&\n-                           c->check_array ((const HBUINT8*) data_base (), 1, max_offset () - 1))));\n-  }\n-\n-  protected:\n-  unsigned int max_offset () const\n-  {\n-    unsigned int max = 0;\n-    for (unsigned int i = 0; i < count + 1u; i++)\n-    {\n-      unsigned int off = offset_at (i);\n-      if (off > max) max = off;\n-    }\n-    return max;\n+    return_trace (likely (c->check_struct (this) &&\n+                          (count == 0 || \/* empty INDEX *\/\n+                           (count < count + 1u &&\n+                            c->check_struct (&offSize) && offSize >= 1 && offSize <= 4 &&\n+                            c->check_array (offsets, offSize, count + 1u) &&\n+                            c->check_array ((const HBUINT8*) data_base (), 1, offset_at (count) - 1)))));\n@@ -309,0 +257,1 @@\n+  private:\n@@ -314,1 +263,1 @@\n-  DEFINE_SIZE_ARRAY (COUNT::static_size + HBUINT8::static_size, offsets);\n+  DEFINE_SIZE_MIN (COUNT::static_size);\n@@ -320,7 +269,0 @@\n-  const byte_str_t operator [] (unsigned int index) const\n-  {\n-    if (likely (index < CFFIndex<COUNT>::count))\n-      return byte_str_t (CFFIndex<COUNT>::data_base () + CFFIndex<COUNT>::offset_at (index) - 1, CFFIndex<COUNT>::length_at (index));\n-    return Null (byte_str_t);\n-  }\n-\n@@ -338,1 +280,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -376,1 +318,1 @@\n-      if (unlikely (!opszr.serialize (c, dictval[i], hb_forward<Ts> (ds)...)))\n+      if (unlikely (!opszr.serialize (c, dictval[i], std::forward<Ts> (ds)...)))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff-common.hh","additions":66,"deletions":124,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-  void init (const OT::cff1::accelerator_t *_cff)\n+  cff1_extents_param_t (const OT::cff1::accelerator_t *_cff) : cff (_cff)\n@@ -316,2 +316,0 @@\n-    path_open = false;\n-    cff = _cff;\n@@ -325,1 +323,1 @@\n-  bool path_open;\n+  bool path_open = false;\n@@ -398,6 +396,5 @@\n-  cff1_cs_interpreter_t<cff1_cs_opset_extents_t, cff1_extents_param_t> interp;\n-  const byte_str_t str = (*cff->charStrings)[glyph];\n-  interp.env.init (str, *cff, fd);\n-  interp.env.set_in_seac (in_seac);\n-  cff1_extents_param_t  param;\n-  param.init (cff);\n+  const hb_ubytes_t str = (*cff->charStrings)[glyph];\n+  cff1_cs_interp_env_t env (str, *cff, fd);\n+  env.set_in_seac (in_seac);\n+  cff1_cs_interpreter_t<cff1_cs_opset_extents_t, cff1_extents_param_t> interp (env);\n+  cff1_extents_param_t param (cff);\n@@ -445,1 +442,0 @@\n-#ifdef HB_EXPERIMENTAL_API\n@@ -449,1 +445,1 @@\n-                     draw_helper_t &draw_helper_, point_t *delta_)\n+                     hb_draw_session_t &draw_session_, point_t *delta_)\n@@ -451,1 +447,1 @@\n-    draw_helper = &draw_helper_;\n+    draw_session = &draw_session_;\n@@ -461,1 +457,1 @@\n-    draw_helper->move_to (font->em_scalef_x (point.x.to_real ()), font->em_scalef_y (point.y.to_real ()));\n+    draw_session->move_to (font->em_fscalef_x (point.x.to_real ()), font->em_fscalef_y (point.y.to_real ()));\n@@ -468,1 +464,1 @@\n-    draw_helper->line_to (font->em_scalef_x (point.x.to_real ()), font->em_scalef_y (point.y.to_real ()));\n+    draw_session->line_to (font->em_fscalef_x (point.x.to_real ()), font->em_fscalef_y (point.y.to_real ()));\n@@ -480,3 +476,3 @@\n-    draw_helper->cubic_to (font->em_scalef_x (point1.x.to_real ()), font->em_scalef_y (point1.y.to_real ()),\n-                           font->em_scalef_x (point2.x.to_real ()), font->em_scalef_y (point2.y.to_real ()),\n-                           font->em_scalef_x (point3.x.to_real ()), font->em_scalef_y (point3.y.to_real ()));\n+    draw_session->cubic_to (font->em_fscalef_x (point1.x.to_real ()), font->em_fscalef_y (point1.y.to_real ()),\n+                           font->em_fscalef_x (point2.x.to_real ()), font->em_fscalef_y (point2.y.to_real ()),\n+                           font->em_fscalef_x (point3.x.to_real ()), font->em_fscalef_y (point3.y.to_real ()));\n@@ -485,1 +481,1 @@\n-  void end_path () { draw_helper->end_path (); }\n+  void end_path () { draw_session->close_path (); }\n@@ -488,1 +484,1 @@\n-  draw_helper_t *draw_helper;\n+  hb_draw_session_t *draw_session;\n@@ -516,1 +512,1 @@\n-                       draw_helper_t &draw_helper, bool in_seac = false, point_t *delta = nullptr);\n+                       hb_draw_session_t &draw_session, bool in_seac = false, point_t *delta = nullptr);\n@@ -533,2 +529,2 @@\n-                    && _get_path (param.cff, param.font, base, *param.draw_helper, true)\n-                    && _get_path (param.cff, param.font, accent, *param.draw_helper, true, &delta))))\n+                    && _get_path (param.cff, param.font, base, *param.draw_session, true)\n+                    && _get_path (param.cff, param.font, accent, *param.draw_session, true, &delta))))\n@@ -540,1 +536,1 @@\n-                draw_helper_t &draw_helper, bool in_seac, point_t *delta)\n+                hb_draw_session_t &draw_session, bool in_seac, point_t *delta)\n@@ -545,5 +541,5 @@\n-  cff1_cs_interpreter_t<cff1_cs_opset_path_t, cff1_path_param_t> interp;\n-  const byte_str_t str = (*cff->charStrings)[glyph];\n-  interp.env.init (str, *cff, fd);\n-  interp.env.set_in_seac (in_seac);\n-  cff1_path_param_t param (cff, font, draw_helper, delta);\n+  const hb_ubytes_t str = (*cff->charStrings)[glyph];\n+  cff1_cs_interp_env_t env (str, *cff, fd);\n+  env.set_in_seac (in_seac);\n+  cff1_cs_interpreter_t<cff1_cs_opset_path_t, cff1_path_param_t> interp (env);\n+  cff1_path_param_t param (cff, font, draw_session, delta);\n@@ -558,1 +554,1 @@\n-bool OT::cff1::accelerator_t::get_path (hb_font_t *font, hb_codepoint_t glyph, draw_helper_t &draw_helper) const\n+bool OT::cff1::accelerator_t::get_path (hb_font_t *font, hb_codepoint_t glyph, hb_draw_session_t &draw_session) const\n@@ -565,1 +561,1 @@\n-  return _get_path (this, font, glyph, draw_helper);\n+  return _get_path (this, font, glyph, draw_session);\n@@ -567,1 +563,0 @@\n-#endif\n@@ -571,6 +566,1 @@\n-  void init (const OT::cff1::accelerator_t *_cff)\n-  {\n-    cff = _cff;\n-    base = 0;\n-    accent = 0;\n-  }\n+  get_seac_param_t (const OT::cff1::accelerator_t *_cff) : cff (_cff) {}\n@@ -581,2 +571,2 @@\n-  hb_codepoint_t  base;\n-  hb_codepoint_t  accent;\n+  hb_codepoint_t  base = 0;\n+  hb_codepoint_t  accent = 0;\n@@ -603,5 +593,4 @@\n-  cff1_cs_interpreter_t<cff1_cs_opset_seac_t, get_seac_param_t> interp;\n-  const byte_str_t str = (*charStrings)[glyph];\n-  interp.env.init (str, *this, fd);\n-  get_seac_param_t  param;\n-  param.init (this);\n+  const hb_ubytes_t str = (*charStrings)[glyph];\n+  cff1_cs_interp_env_t env (str, *this, fd);\n+  cff1_cs_interpreter_t<cff1_cs_opset_seac_t, get_seac_param_t> interp (env);\n+  get_seac_param_t  param (this);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff1-table.cc","additions":34,"deletions":45,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    Encoding *dest = c->extend_min (*this);\n+    Encoding *dest = c->extend_min (this);\n@@ -321,1 +321,1 @@\n-  hb_codepoint_t get_sid (hb_codepoint_t glyph) const\n+  hb_codepoint_t get_sid (hb_codepoint_t glyph, unsigned num_glyphs) const\n@@ -323,0 +323,1 @@\n+    if (unlikely (glyph >= num_glyphs)) return 0;\n@@ -329,0 +330,6 @@\n+  void collect_glyph_to_sid_map (hb_map_t *mapping, unsigned int num_glyphs) const\n+  {\n+    for (hb_codepoint_t gid = 1; gid < num_glyphs; gid++)\n+      mapping->set (gid, sids[gid - 1]);\n+  }\n+\n@@ -384,1 +391,1 @@\n-  hb_codepoint_t get_sid (hb_codepoint_t glyph) const\n+  hb_codepoint_t get_sid (hb_codepoint_t glyph, unsigned num_glyphs) const\n@@ -386,0 +393,1 @@\n+    if (unlikely (glyph >= num_glyphs)) return 0;\n@@ -391,1 +399,1 @@\n-        return (hb_codepoint_t)ranges[i].first + glyph;\n+        return (hb_codepoint_t) ranges[i].first + glyph;\n@@ -398,0 +406,17 @@\n+  void collect_glyph_to_sid_map (hb_map_t *mapping, unsigned int num_glyphs) const\n+  {\n+    hb_codepoint_t gid = 1;\n+    if (gid >= num_glyphs)\n+      return;\n+    for (unsigned i = 0;; i++)\n+    {\n+      hb_codepoint_t sid = ranges[i].first;\n+      unsigned count = ranges[i].nLeft + 1;\n+      for (unsigned j = 0; j < count; j++)\n+        mapping->set (gid++, sid++);\n+\n+      if (gid >= num_glyphs)\n+        break;\n+    }\n+  }\n+\n@@ -460,1 +485,1 @@\n-    Charset *dest = c->extend_min (*this);\n+    Charset *dest = c->extend_min (this);\n@@ -524,1 +549,0 @@\n-    if (unlikely (glyph >= num_glyphs)) return 0;\n@@ -527,3 +551,3 @@\n-    case 0: return u.format0.get_sid (glyph);\n-    case 1: return u.format1.get_sid (glyph);\n-    case 2: return u.format2.get_sid (glyph);\n+    case 0: return u.format0.get_sid (glyph, num_glyphs);\n+    case 1: return u.format1.get_sid (glyph, num_glyphs);\n+    case 2: return u.format2.get_sid (glyph, num_glyphs);\n@@ -534,0 +558,11 @@\n+  void collect_glyph_to_sid_map (hb_map_t *mapping, unsigned int num_glyphs) const\n+  {\n+    switch (format)\n+    {\n+    case 0: u.format0.collect_glyph_to_sid_map (mapping, num_glyphs); return;\n+    case 1: u.format1.collect_glyph_to_sid_map (mapping, num_glyphs); return;\n+    case 2: u.format2.collect_glyph_to_sid_map (mapping, num_glyphs); return;\n+    default:return;\n+    }\n+  }\n+\n@@ -605,0 +640,2 @@\n+  cff1_top_dict_interp_env_t (const hb_ubytes_t &bytes)\n+    : num_interp_env_t(bytes), prev_offset(0), last_offset(0) {}\n@@ -716,0 +753,1 @@\n+      case OpCode_FontName:\n@@ -1026,1 +1064,1 @@\n-        const byte_str_t topDictStr = (*topDictIndex)[0];\n+        const hb_ubytes_t topDictStr = (*topDictIndex)[0];\n@@ -1028,3 +1066,2 @@\n-        cff1_top_dict_interpreter_t top_interp;\n-        top_interp.env.init (topDictStr);\n-        topDict.init ();\n+        cff1_top_dict_interp_env_t env (topDictStr);\n+        cff1_top_dict_interpreter_t top_interp (env);\n@@ -1100,1 +1137,1 @@\n-          byte_str_t fontDictStr = (*fdArray)[i];\n+          hb_ubytes_t fontDictStr = (*fdArray)[i];\n@@ -1103,2 +1140,2 @@\n-          cff1_font_dict_interpreter_t font_interp;\n-          font_interp.env.init (fontDictStr);\n+          cff1_top_dict_interp_env_t env (fontDictStr);\n+          cff1_font_dict_interpreter_t font_interp (env);\n@@ -1106,1 +1143,2 @@\n-          if (unlikely (font == &Crap (cff1_font_dict_values_t))) { fini (); return; }\n+          if (unlikely (fontDicts.in_error ())) { fini (); return; }\n+\n@@ -1110,1 +1148,1 @@\n-          const byte_str_t privDictStr (StructAtOffset<UnsizedByteStr> (cff, font->privateDictInfo.offset), font->privateDictInfo.size);\n+          const hb_ubytes_t privDictStr = StructAtOffset<UnsizedByteStr> (cff, font->privateDictInfo.offset).as_ubytes (font->privateDictInfo.size);\n@@ -1112,2 +1150,2 @@\n-          dict_interpreter_t<PRIVOPSET, PRIVDICTVAL> priv_interp;\n-          priv_interp.env.init (privDictStr);\n+          num_interp_env_t env2 (privDictStr);\n+          dict_interpreter_t<PRIVOPSET, PRIVDICTVAL> priv_interp (env2);\n@@ -1128,1 +1166,1 @@\n-        const byte_str_t privDictStr (StructAtOffset<UnsizedByteStr> (cff, font->privateDictInfo.offset), font->privateDictInfo.size);\n+        const hb_ubytes_t privDictStr = StructAtOffset<UnsizedByteStr> (cff, font->privateDictInfo.offset).as_ubytes (font->privateDictInfo.size);\n@@ -1130,2 +1168,2 @@\n-        dict_interpreter_t<PRIVOPSET, PRIVDICTVAL> priv_interp;\n-        priv_interp.env.init (privDictStr);\n+        num_interp_env_t env (privDictStr);\n+        dict_interpreter_t<PRIVOPSET, PRIVDICTVAL> priv_interp (env);\n@@ -1146,2 +1184,2 @@\n-      fontDicts.fini_deep ();\n-      privateDicts.fini_deep ();\n+      fontDicts.fini ();\n+      privateDicts.fini ();\n@@ -1196,0 +1234,13 @@\n+    hb_map_t *create_glyph_to_sid_map () const\n+    {\n+      if (charset != &Null (Charset))\n+      {\n+        hb_map_t *mapping = hb_map_create ();\n+        mapping->set (0, 0);\n+        charset->collect_glyph_to_sid_map (mapping, num_glyphs);\n+        return mapping;\n+      }\n+      else\n+        return nullptr;\n+    }\n+\n@@ -1247,1 +1298,1 @@\n-    hb_blob_t              *blob;\n+    hb_blob_t              *blob = nullptr;\n@@ -1251,10 +1302,10 @@\n-    const Encoding          *encoding;\n-    const Charset           *charset;\n-    const CFF1NameIndex     *nameIndex;\n-    const CFF1TopDictIndex  *topDictIndex;\n-    const CFF1StringIndex   *stringIndex;\n-    const CFF1Subrs         *globalSubrs;\n-    const CFF1CharStrings   *charStrings;\n-    const CFF1FDArray       *fdArray;\n-    const CFF1FDSelect      *fdSelect;\n-    unsigned int             fdCount;\n+    const Encoding          *encoding = nullptr;\n+    const Charset           *charset = nullptr;\n+    const CFF1NameIndex     *nameIndex = nullptr;\n+    const CFF1TopDictIndex  *topDictIndex = nullptr;\n+    const CFF1StringIndex   *stringIndex = nullptr;\n+    const CFF1Subrs         *globalSubrs = nullptr;\n+    const CFF1CharStrings   *charStrings = nullptr;\n+    const CFF1FDArray       *fdArray = nullptr;\n+    const CFF1FDSelect      *fdSelect = nullptr;\n+    unsigned int             fdCount = 0;\n@@ -1267,1 +1318,1 @@\n-    unsigned int             num_glyphs;\n+    unsigned int             num_glyphs = 0;\n@@ -1272,1 +1323,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -1276,0 +1327,2 @@\n+      glyph_names.set_relaxed (nullptr);\n+\n@@ -1279,17 +1332,0 @@\n-      \/* fill glyph_names *\/\n-      for (hb_codepoint_t gid = 0; gid < num_glyphs; gid++)\n-      {\n-        hb_codepoint_t  sid = glyph_to_sid (gid);\n-        gname_t gname;\n-        gname.sid = sid;\n-        if (sid < cff1_std_strings_length)\n-          gname.name = cff1_std_strings (sid);\n-        else\n-        {\n-          byte_str_t    ustr = (*stringIndex)[sid - cff1_std_strings_length];\n-          gname.name = hb_bytes_t ((const char*)ustr.arrayZ, ustr.length);\n-        }\n-        if (unlikely (!gname.name.arrayZ)) { fini (); return; }\n-        glyph_names.push (gname);\n-      }\n-      glyph_names.qsort ();\n@@ -1297,2 +1333,1 @@\n-\n-    void fini ()\n+    ~accelerator_t ()\n@@ -1300,1 +1335,6 @@\n-      glyph_names.fini ();\n+      hb_sorted_vector_t<gname_t> *names = glyph_names.get_relaxed ();\n+      if (names)\n+      {\n+        names->fini ();\n+        hb_free (names);\n+      }\n@@ -1308,1 +1348,0 @@\n-      if (!buf) return true;\n@@ -1311,0 +1350,1 @@\n+      if (unlikely (!buf_len)) return true;\n@@ -1322,1 +1362,1 @@\n-        byte_str_t ubyte_str = (*stringIndex)[sid - cff1_std_strings_length];\n+        hb_ubytes_t ubyte_str = (*stringIndex)[sid - cff1_std_strings_length];\n@@ -1336,0 +1376,2 @@\n+      if (unlikely (!is_valid ())) return false;\n+      if (is_CID()) return false;\n@@ -1339,0 +1381,40 @@\n+    retry:\n+      hb_sorted_vector_t<gname_t> *names = glyph_names.get ();\n+      if (unlikely (!names))\n+      {\n+        names = (hb_sorted_vector_t<gname_t> *) hb_calloc (sizeof (hb_sorted_vector_t<gname_t>), 1);\n+        if (likely (names))\n+        {\n+          names->init ();\n+          \/* TODO *\/\n+\n+          \/* fill glyph names *\/\n+          for (hb_codepoint_t gid = 0; gid < num_glyphs; gid++)\n+          {\n+            hb_codepoint_t      sid = glyph_to_sid (gid);\n+            gname_t     gname;\n+            gname.sid = sid;\n+            if (sid < cff1_std_strings_length)\n+              gname.name = cff1_std_strings (sid);\n+            else\n+            {\n+              hb_ubytes_t       ustr = (*stringIndex)[sid - cff1_std_strings_length];\n+              gname.name = hb_bytes_t ((const char*) ustr.arrayZ, ustr.length);\n+            }\n+            if (unlikely (!gname.name.arrayZ))\n+              gname.name = hb_bytes_t (\"\", 0); \/* To avoid nullptr. *\/\n+            names->push (gname);\n+          }\n+          names->qsort ();\n+        }\n+        if (unlikely (!glyph_names.cmpexch (nullptr, names)))\n+        {\n+          if (names)\n+          {\n+            names->fini ();\n+            hb_free (names);\n+          }\n+          goto retry;\n+        }\n+      }\n+\n@@ -1340,1 +1422,1 @@\n-      const gname_t *gname = glyph_names.bsearch (key);\n+      const gname_t *gname = names ? names->bsearch (key) : nullptr;\n@@ -1350,3 +1432,1 @@\n-#ifdef HB_EXPERIMENTAL_API\n-    HB_INTERNAL bool get_path (hb_font_t *font, hb_codepoint_t glyph, draw_helper_t &draw_helper) const;\n-#endif\n+    HB_INTERNAL bool get_path (hb_font_t *font, hb_codepoint_t glyph, hb_draw_session_t &draw_session) const;\n@@ -1364,1 +1444,1 @@\n-        int minlen = hb_min (a->name.length, b->name.length);\n+        unsigned minlen = hb_min (a->name.length, b->name.length);\n@@ -1373,1 +1453,1 @@\n-    hb_sorted_vector_t<gname_t> glyph_names;\n+    mutable hb_atomic_ptr_t<hb_sorted_vector_t<gname_t>> glyph_names;\n@@ -1393,1 +1473,1 @@\n-  OffsetTo<CFF1NameIndex, HBUINT8> nameIndex; \/* headerSize = Offset to Name INDEX. *\/\n+  NNOffsetTo<CFF1NameIndex, HBUINT8> nameIndex; \/* headerSize = Offset to Name INDEX. *\/\n@@ -1400,1 +1480,4 @@\n-struct cff1_accelerator_t : cff1::accelerator_t {};\n+struct cff1_accelerator_t : cff1::accelerator_t {\n+  cff1_accelerator_t (hb_face_t *face) : cff1::accelerator_t (face) {}\n+};\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff1-table.hh","additions":151,"deletions":68,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  void init ()\n+  cff2_extents_param_t ()\n@@ -41,1 +41,0 @@\n-    path_open = false;\n@@ -60,1 +59,1 @@\n-  bool  path_open;\n+  bool  path_open = false;\n@@ -67,1 +66,1 @@\n-struct cff2_path_procs_extents_t : path_procs_t<cff2_path_procs_extents_t, cff2_cs_interp_env_t, cff2_extents_param_t>\n+struct cff2_path_procs_extents_t : path_procs_t<cff2_path_procs_extents_t, cff2_cs_interp_env_t<number_t>, cff2_extents_param_t>\n@@ -69,1 +68,1 @@\n-  static void moveto (cff2_cs_interp_env_t &env, cff2_extents_param_t& param, const point_t &pt)\n+  static void moveto (cff2_cs_interp_env_t<number_t> &env, cff2_extents_param_t& param, const point_t &pt)\n@@ -75,1 +74,1 @@\n-  static void line (cff2_cs_interp_env_t &env, cff2_extents_param_t& param, const point_t &pt1)\n+  static void line (cff2_cs_interp_env_t<number_t> &env, cff2_extents_param_t& param, const point_t &pt1)\n@@ -86,1 +85,1 @@\n-  static void curve (cff2_cs_interp_env_t &env, cff2_extents_param_t& param, const point_t &pt1, const point_t &pt2, const point_t &pt3)\n+  static void curve (cff2_cs_interp_env_t<number_t> &env, cff2_extents_param_t& param, const point_t &pt1, const point_t &pt2, const point_t &pt3)\n@@ -101,1 +100,1 @@\n-struct cff2_cs_opset_extents_t : cff2_cs_opset_t<cff2_cs_opset_extents_t, cff2_extents_param_t, cff2_path_procs_extents_t> {};\n+struct cff2_cs_opset_extents_t : cff2_cs_opset_t<cff2_cs_opset_extents_t, cff2_extents_param_t, number_t, cff2_path_procs_extents_t> {};\n@@ -115,3 +114,3 @@\n-  cff2_cs_interpreter_t<cff2_cs_opset_extents_t, cff2_extents_param_t> interp;\n-  const byte_str_t str = (*charStrings)[glyph];\n-  interp.env.init (str, *this, fd, font->coords, font->num_coords);\n+  const hb_ubytes_t str = (*charStrings)[glyph];\n+  cff2_cs_interp_env_t<number_t> env (str, *this, fd, font->coords, font->num_coords);\n+  cff2_cs_interpreter_t<cff2_cs_opset_extents_t, cff2_extents_param_t, number_t> interp (env);\n@@ -119,1 +118,0 @@\n-  param.init ();\n@@ -146,1 +144,0 @@\n-#ifdef HB_EXPERIMENTAL_API\n@@ -149,1 +146,1 @@\n-  cff2_path_param_t (hb_font_t *font_, draw_helper_t &draw_helper_)\n+  cff2_path_param_t (hb_font_t *font_, hb_draw_session_t &draw_session_)\n@@ -151,1 +148,1 @@\n-    draw_helper = &draw_helper_;\n+    draw_session = &draw_session_;\n@@ -156,1 +153,1 @@\n-  { draw_helper->move_to (font->em_scalef_x (p.x.to_real ()), font->em_scalef_y (p.y.to_real ())); }\n+  { draw_session->move_to (font->em_fscalef_x (p.x.to_real ()), font->em_fscalef_y (p.y.to_real ())); }\n@@ -159,1 +156,1 @@\n-  { draw_helper->line_to (font->em_scalef_x (p.x.to_real ()), font->em_scalef_y (p.y.to_real ())); }\n+  { draw_session->line_to (font->em_fscalef_x (p.x.to_real ()), font->em_fscalef_y (p.y.to_real ())); }\n@@ -163,3 +160,3 @@\n-    draw_helper->cubic_to (font->em_scalef_x (p1.x.to_real ()), font->em_scalef_y (p1.y.to_real ()),\n-                           font->em_scalef_x (p2.x.to_real ()), font->em_scalef_y (p2.y.to_real ()),\n-                           font->em_scalef_x (p3.x.to_real ()), font->em_scalef_y (p3.y.to_real ()));\n+    draw_session->cubic_to (font->em_fscalef_x (p1.x.to_real ()), font->em_fscalef_y (p1.y.to_real ()),\n+                           font->em_fscalef_x (p2.x.to_real ()), font->em_fscalef_y (p2.y.to_real ()),\n+                           font->em_fscalef_x (p3.x.to_real ()), font->em_fscalef_y (p3.y.to_real ()));\n@@ -169,1 +166,1 @@\n-  draw_helper_t *draw_helper;\n+  hb_draw_session_t *draw_session;\n@@ -173,1 +170,1 @@\n-struct cff2_path_procs_path_t : path_procs_t<cff2_path_procs_path_t, cff2_cs_interp_env_t, cff2_path_param_t>\n+struct cff2_path_procs_path_t : path_procs_t<cff2_path_procs_path_t, cff2_cs_interp_env_t<number_t>, cff2_path_param_t>\n@@ -175,1 +172,1 @@\n-  static void moveto (cff2_cs_interp_env_t &env, cff2_path_param_t& param, const point_t &pt)\n+  static void moveto (cff2_cs_interp_env_t<number_t> &env, cff2_path_param_t& param, const point_t &pt)\n@@ -181,1 +178,1 @@\n-  static void line (cff2_cs_interp_env_t &env, cff2_path_param_t& param, const point_t &pt1)\n+  static void line (cff2_cs_interp_env_t<number_t> &env, cff2_path_param_t& param, const point_t &pt1)\n@@ -187,1 +184,1 @@\n-  static void curve (cff2_cs_interp_env_t &env, cff2_path_param_t& param, const point_t &pt1, const point_t &pt2, const point_t &pt3)\n+  static void curve (cff2_cs_interp_env_t<number_t> &env, cff2_path_param_t& param, const point_t &pt1, const point_t &pt2, const point_t &pt3)\n@@ -194,1 +191,1 @@\n-struct cff2_cs_opset_path_t : cff2_cs_opset_t<cff2_cs_opset_path_t, cff2_path_param_t, cff2_path_procs_path_t> {};\n+struct cff2_cs_opset_path_t : cff2_cs_opset_t<cff2_cs_opset_path_t, cff2_path_param_t, number_t, cff2_path_procs_path_t> {};\n@@ -196,1 +193,1 @@\n-bool OT::cff2::accelerator_t::get_path (hb_font_t *font, hb_codepoint_t glyph, draw_helper_t &draw_helper) const\n+bool OT::cff2::accelerator_t::get_path (hb_font_t *font, hb_codepoint_t glyph, hb_draw_session_t &draw_session) const\n@@ -206,4 +203,4 @@\n-  cff2_cs_interpreter_t<cff2_cs_opset_path_t, cff2_path_param_t> interp;\n-  const byte_str_t str = (*charStrings)[glyph];\n-  interp.env.init (str, *this, fd, font->coords, font->num_coords);\n-  cff2_path_param_t param (font, draw_helper);\n+  const hb_ubytes_t str = (*charStrings)[glyph];\n+  cff2_cs_interp_env_t<number_t> env (str, *this, fd, font->coords, font->num_coords);\n+  cff2_cs_interpreter_t<cff2_cs_opset_path_t, cff2_path_param_t, number_t> interp (env);\n+  cff2_path_param_t param (font, draw_session);\n@@ -213,1 +210,0 @@\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff2-table.cc","additions":28,"deletions":32,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -250,6 +250,2 @@\n-  void init (const byte_str_t &str)\n-  {\n-    num_interp_env_t::init (str);\n-    ivs = 0;\n-    seen_vsindex = false;\n-  }\n+  cff2_priv_dict_interp_env_t (const hb_ubytes_t &str) :\n+    num_interp_env_t (str) {}\n@@ -270,2 +266,2 @@\n-  unsigned int  ivs;\n-  bool    seen_vsindex;\n+  unsigned int  ivs = 0;\n+  bool    seen_vsindex = false;\n@@ -400,1 +396,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_templ_t (hb_face_t *face)\n@@ -415,1 +411,1 @@\n-      { fini (); return; }\n+        goto fail;\n@@ -418,4 +414,4 @@\n-        byte_str_t topDictStr (cff2 + cff2->topDict, cff2->topDictSize);\n-        if (unlikely (!topDictStr.sanitize (&sc))) { fini (); return; }\n-        cff2_top_dict_interpreter_t top_interp;\n-        top_interp.env.init (topDictStr);\n+        hb_ubytes_t topDictStr = (cff2 + cff2->topDict).as_ubytes (cff2->topDictSize);\n+        if (unlikely (!topDictStr.sanitize (&sc))) goto fail;\n+        num_interp_env_t env (topDictStr);\n+        cff2_top_dict_interpreter_t top_interp (env);\n@@ -423,1 +419,1 @@\n-        if (unlikely (!top_interp.interpret (topDict))) { fini (); return; }\n+        if (unlikely (!top_interp.interpret (topDict))) goto fail;\n@@ -437,1 +433,1 @@\n-      { fini (); return; }\n+        goto fail;\n@@ -441,1 +437,1 @@\n-      { fini (); return; }\n+        goto fail;\n@@ -445,1 +441,1 @@\n-      { fini (); return; }\n+        goto fail;\n@@ -450,2 +446,2 @@\n-        const byte_str_t fontDictStr = (*fdArray)[i];\n-        if (unlikely (!fontDictStr.sanitize (&sc))) { fini (); return; }\n+        const hb_ubytes_t fontDictStr = (*fdArray)[i];\n+        if (unlikely (!fontDictStr.sanitize (&sc))) goto fail;\n@@ -453,2 +449,2 @@\n-        cff2_font_dict_interpreter_t font_interp;\n-        font_interp.env.init (fontDictStr);\n+        num_interp_env_t env (fontDictStr);\n+        cff2_font_dict_interpreter_t font_interp (env);\n@@ -456,1 +452,1 @@\n-        if (unlikely (font == &Crap (cff2_font_dict_values_t))) { fini (); return; }\n+        if (unlikely (font == &Crap (cff2_font_dict_values_t))) goto fail;\n@@ -458,1 +454,1 @@\n-        if (unlikely (!font_interp.interpret (*font))) { fini (); return; }\n+        if (unlikely (!font_interp.interpret (*font))) goto fail;\n@@ -460,4 +456,4 @@\n-        const byte_str_t privDictStr (StructAtOffsetOrNull<UnsizedByteStr> (cff2, font->privateDictInfo.offset), font->privateDictInfo.size);\n-        if (unlikely (!privDictStr.sanitize (&sc))) { fini (); return; }\n-        dict_interpreter_t<PRIVOPSET, PRIVDICTVAL, cff2_priv_dict_interp_env_t>  priv_interp;\n-        priv_interp.env.init(privDictStr);\n+        const hb_ubytes_t privDictStr = StructAtOffsetOrNull<UnsizedByteStr> (cff2, font->privateDictInfo.offset).as_ubytes (font->privateDictInfo.size);\n+        if (unlikely (!privDictStr.sanitize (&sc))) goto fail;\n+        cff2_priv_dict_interp_env_t env2 (privDictStr);\n+        dict_interpreter_t<PRIVOPSET, PRIVDICTVAL, cff2_priv_dict_interp_env_t> priv_interp (env2);\n@@ -465,1 +461,1 @@\n-        if (unlikely (!priv_interp.interpret (privateDicts[i]))) { fini (); return; }\n+        if (unlikely (!priv_interp.interpret (privateDicts[i]))) goto fail;\n@@ -470,1 +466,1 @@\n-        { fini (); return; }\n+          goto fail;\n@@ -472,1 +468,0 @@\n-    }\n@@ -474,1 +469,8 @@\n-    void fini ()\n+\n+      return;\n+\n+      fail:\n+        _fini ();\n+    }\n+    ~accelerator_templ_t () { _fini (); }\n+    void _fini ()\n@@ -478,2 +480,2 @@\n-      fontDicts.fini_deep ();\n-      privateDicts.fini_deep ();\n+      fontDicts.fini ();\n+      privateDicts.fini ();\n@@ -487,1 +489,1 @@\n-    hb_blob_t                   *blob;\n+    hb_blob_t                   *blob = nullptr;\n@@ -492,6 +494,6 @@\n-    const CFF2Subrs             *globalSubrs;\n-    const CFF2VariationStore    *varStore;\n-    const CFF2CharStrings       *charStrings;\n-    const CFF2FDArray           *fdArray;\n-    const CFF2FDSelect          *fdSelect;\n-    unsigned int                fdCount;\n+    const CFF2Subrs             *globalSubrs = nullptr;\n+    const CFF2VariationStore    *varStore = nullptr;\n+    const CFF2CharStrings       *charStrings = nullptr;\n+    const CFF2FDArray           *fdArray = nullptr;\n+    const CFF2FDSelect          *fdSelect = nullptr;\n+    unsigned int                fdCount = 0;\n@@ -502,1 +504,1 @@\n-    unsigned int              num_glyphs;\n+    unsigned int              num_glyphs = 0;\n@@ -507,0 +509,2 @@\n+    accelerator_t (hb_face_t *face) : accelerator_templ_t (face) {}\n+\n@@ -510,3 +514,1 @@\n-#ifdef HB_EXPERIMENTAL_API\n-    HB_INTERNAL bool get_path (hb_font_t *font, hb_codepoint_t glyph, draw_helper_t &draw_helper) const;\n-#endif\n+    HB_INTERNAL bool get_path (hb_font_t *font, hb_codepoint_t glyph, hb_draw_session_t &draw_session) const;\n@@ -528,1 +530,4 @@\n-struct cff2_accelerator_t : cff2::accelerator_t {};\n+struct cff2_accelerator_t : cff2::accelerator_t {\n+  cff2_accelerator_t (hb_face_t *face) : cff2::accelerator_t (face) {}\n+};\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cff2-table.hh","additions":51,"deletions":46,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"hb-ot-os2-table.hh\"\n+#include \"hb-ot-shaper-arabic-pua.hh\"\n@@ -47,1 +49,1 @@\n-    if (!gid)\n+    if (unlikely (!gid))\n@@ -52,0 +54,6 @@\n+\n+  unsigned get_language () const\n+  {\n+    return language;\n+  }\n+\n@@ -90,0 +98,1 @@\n+\n@@ -91,0 +100,1 @@\n+      typename Writer,\n@@ -92,2 +102,1 @@\n-  HBUINT16* serialize_endcode_array (hb_serialize_context_t *c,\n-                                     Iterator it)\n+  void to_ranges (Iterator it, Writer& range_writer)\n@@ -95,2 +104,2 @@\n-    HBUINT16 *endCode = c->start_embed<HBUINT16> ();\n-    hb_codepoint_t prev_endcp = 0xFFFF;\n+    hb_codepoint_t start_cp = 0, prev_run_start_cp = 0, run_start_cp = 0, end_cp = 0, last_gid = 0;\n+    int run_length = 0 , delta = 0, prev_delta = 0;\n@@ -98,3 +107,7 @@\n-    for (const auto& _ : +it)\n-    {\n-      if (prev_endcp != 0xFFFF && prev_endcp + 1u != _.first)\n+    enum {\n+      FIRST_SUB_RANGE,\n+      FOLLOWING_SUB_RANGE,\n+    } mode;\n+\n+    while (it) {\n+      \/\/ Start a new range\n@@ -102,3 +115,8 @@\n-        HBUINT16 end_code;\n-        end_code = prev_endcp;\n-        c->copy<HBUINT16> (end_code);\n+        const auto& pair = *it;\n+        start_cp = pair.first;\n+        prev_run_start_cp = start_cp;\n+        run_start_cp = start_cp;\n+        end_cp = start_cp;\n+        last_gid = pair.second;\n+        run_length = 1;\n+        prev_delta = 0;\n@@ -106,2 +124,0 @@\n-      prev_endcp = _.first;\n-    }\n@@ -109,11 +125,48 @@\n-    {\n-      \/\/ last endCode\n-      HBUINT16 endcode;\n-      endcode = prev_endcp;\n-      if (unlikely (!c->copy<HBUINT16> (endcode))) return nullptr;\n-      \/\/ There must be a final entry with end_code == 0xFFFF.\n-      if (prev_endcp != 0xFFFF)\n-      {\n-        HBUINT16 finalcode;\n-        finalcode = 0xFFFF;\n-        if (unlikely (!c->copy<HBUINT16> (finalcode))) return nullptr;\n+      delta = last_gid - start_cp;\n+      mode = FIRST_SUB_RANGE;\n+      it++;\n+\n+      while (it) {\n+        \/\/ Process range\n+        const auto& pair = *it;\n+        hb_codepoint_t next_cp = pair.first;\n+        hb_codepoint_t next_gid = pair.second;\n+        if (next_cp != end_cp + 1) {\n+          \/\/ Current range is over, stop processing.\n+          break;\n+        }\n+\n+        if (next_gid == last_gid + 1) {\n+          \/\/ The current run continues.\n+          end_cp = next_cp;\n+          run_length++;\n+          last_gid = next_gid;\n+          it++;\n+          continue;\n+        }\n+\n+        \/\/ A new run is starting, decide if we want to commit the current run.\n+        int split_cost = (mode == FIRST_SUB_RANGE) ? 8 : 16;\n+        int run_cost = run_length * 2;\n+        if (run_cost >= split_cost) {\n+          commit_current_range(start_cp,\n+                               prev_run_start_cp,\n+                               run_start_cp,\n+                               end_cp,\n+                               delta,\n+                               prev_delta,\n+                               split_cost,\n+                               range_writer);\n+          start_cp = next_cp;\n+        }\n+\n+        \/\/ Start the new run\n+        mode = FOLLOWING_SUB_RANGE;\n+        prev_run_start_cp = run_start_cp;\n+        run_start_cp = next_cp;\n+        end_cp = next_cp;\n+        prev_delta = delta;\n+        delta = next_gid - run_start_cp;\n+        run_length = 1;\n+        last_gid = next_gid;\n+        it++;\n@@ -121,0 +174,10 @@\n+\n+      \/\/ Finalize range\n+      commit_current_range (start_cp,\n+                            prev_run_start_cp,\n+                            run_start_cp,\n+                            end_cp,\n+                            delta,\n+                            prev_delta,\n+                            8,\n+                            range_writer);\n@@ -123,1 +186,3 @@\n-    return endCode;\n+    if (likely (end_cp != 0xFFFF)) {\n+      range_writer (0xFFFF, 0xFFFF, 1);\n+    }\n@@ -126,15 +191,17 @@\n-  template<typename Iterator,\n-           hb_requires (hb_is_iterator (Iterator))>\n-  HBUINT16* serialize_startcode_array (hb_serialize_context_t *c,\n-                                       Iterator it)\n-  {\n-    HBUINT16 *startCode = c->start_embed<HBUINT16> ();\n-    hb_codepoint_t prev_cp = 0xFFFF;\n-\n-    for (const auto& _ : +it)\n-    {\n-      if (prev_cp == 0xFFFF || prev_cp + 1u != _.first)\n-      {\n-        HBUINT16 start_code;\n-        start_code = _.first;\n-        c->copy<HBUINT16> (start_code);\n+  \/*\n+   * Writes the current range as either one or two ranges depending on what is most efficient.\n+   *\/\n+  template<typename Writer>\n+  void commit_current_range (hb_codepoint_t start,\n+                             hb_codepoint_t prev_run_start,\n+                             hb_codepoint_t run_start,\n+                             hb_codepoint_t end,\n+                             int run_delta,\n+                             int previous_run_delta,\n+                             int split_cost,\n+                             Writer& range_writer) {\n+    bool should_split = false;\n+    if (start < run_start && run_start < end) {\n+      int run_cost = (end - run_start + 1) * 2;\n+      if (run_cost >= split_cost) {\n+        should_split = true;\n@@ -142,0 +209,1 @@\n+    }\n@@ -143,1 +211,8 @@\n-      prev_cp = _.first;\n+    \/\/ TODO(grieger): handle case where delta is legitimately 0, mark range offset array instead?\n+    if (should_split) {\n+      if (start == prev_run_start)\n+        range_writer (start, run_start - 1, previous_run_delta);\n+      else\n+        range_writer (start, run_start - 1, 0);\n+      range_writer (run_start, end, run_delta);\n+      return;\n@@ -146,6 +221,5 @@\n-    \/\/ There must be a final entry with end_code == 0xFFFF.\n-    if (it.len () == 0 || prev_cp != 0xFFFF)\n-    {\n-      HBUINT16 finalcode;\n-      finalcode = 0xFFFF;\n-      if (unlikely (!c->copy<HBUINT16> (finalcode))) return nullptr;\n+\n+    if (start == run_start) {\n+      \/\/ Range is only a run\n+      range_writer (start, end, run_delta);\n+      return;\n@@ -154,1 +228,2 @@\n-    return startCode;\n+    \/\/ Write only a single non-run range.\n+    range_writer (start, end, 0);\n@@ -159,20 +234,8 @@\n-  HBINT16* serialize_idDelta_array (hb_serialize_context_t *c,\n-                                    Iterator it,\n-                                    HBUINT16 *endCode,\n-                                    HBUINT16 *startCode,\n-                                    unsigned segcount)\n-  {\n-    unsigned i = 0;\n-    hb_codepoint_t last_gid = 0, start_gid = 0, last_cp = 0xFFFF;\n-    bool use_delta = true;\n-\n-    HBINT16 *idDelta = c->start_embed<HBINT16> ();\n-    if ((char *)idDelta - (char *)startCode != (int) segcount * (int) HBINT16::static_size)\n-      return nullptr;\n-\n-    for (const auto& _ : +it)\n-    {\n-      if (_.first == startCode[i])\n-      {\n-        use_delta = true;\n-        start_gid = _.second;\n+  unsigned serialize_find_segcount (Iterator it) {\n+    struct Counter {\n+      unsigned segcount = 0;\n+\n+      void operator() (hb_codepoint_t start,\n+                       hb_codepoint_t end,\n+                       int delta) {\n+        segcount++;\n@@ -180,1 +243,5 @@\n-      else if (_.second != last_gid + 1) use_delta = false;\n+    } counter;\n+\n+    to_ranges (+it, counter);\n+    return counter.segcount;\n+  }\n@@ -182,6 +249,0 @@\n-      if (_.first == endCode[i])\n-      {\n-        HBINT16 delta;\n-        if (use_delta) delta = (int)start_gid - (int)startCode[i];\n-        else delta = 0;\n-        c->copy<HBINT16> (delta);\n@@ -189,1 +250,26 @@\n-        i++;\n+  template<typename Iterator,\n+           hb_requires (hb_is_iterator (Iterator))>\n+  bool serialize_start_end_delta_arrays (hb_serialize_context_t *c,\n+                                         Iterator it,\n+                                         int segcount)\n+  {\n+    struct Writer {\n+      hb_serialize_context_t *serializer_;\n+      HBUINT16* end_code_;\n+      HBUINT16* start_code_;\n+      HBINT16* id_delta_;\n+      int index_;\n+\n+      Writer(hb_serialize_context_t *serializer)\n+          : serializer_(serializer),\n+            end_code_(nullptr),\n+            start_code_(nullptr),\n+            id_delta_(nullptr),\n+            index_ (0) {}\n+      void operator() (hb_codepoint_t start,\n+                       hb_codepoint_t end,\n+                       int delta) {\n+        start_code_[index_] = start;\n+        end_code_[index_] = end;\n+        id_delta_[index_] = delta;\n+        index_++;\n@@ -191,0 +277,1 @@\n+    } writer(c);\n@@ -192,3 +279,4 @@\n-      last_gid = _.second;\n-      last_cp = _.first;\n-    }\n+    writer.end_code_ = c->allocate_size<HBUINT16> (HBUINT16::static_size * segcount);\n+    c->allocate_size<HBUINT16> (2); \/\/ padding\n+    writer.start_code_ = c->allocate_size<HBUINT16> (HBUINT16::static_size * segcount);\n+    writer.id_delta_ = c->allocate_size<HBINT16> (HBINT16::static_size * segcount);\n@@ -196,6 +284,1 @@\n-    if (it.len () == 0 || last_cp != 0xFFFF)\n-    {\n-      HBINT16 delta;\n-      delta = 1;\n-      if (unlikely (!c->copy<HBINT16> (delta))) return nullptr;\n-    }\n+    if (unlikely (!writer.end_code_ || !writer.start_code_ || !writer.id_delta_)) return false;\n@@ -203,1 +286,2 @@\n-    return idDelta;\n+    to_ranges (+it, writer);\n+    return true;\n@@ -207,1 +291,1 @@\n-           hb_requires (hb_is_iterator (Iterator))>\n+          hb_requires (hb_is_iterator (Iterator))>\n@@ -215,0 +299,2 @@\n+    hb_map_t cp_to_gid { it };\n+\n@@ -219,19 +305,11 @@\n-    + hb_range (segcount)\n-    | hb_filter ([&] (const unsigned _) { return idDelta[_] == 0; })\n-    | hb_apply ([&] (const unsigned i)\n-                {\n-                  idRangeOffset[i] = 2 * (c->start_embed<HBUINT16> () - idRangeOffset - i);\n-\n-                  + it\n-                  | hb_filter ([&] (const hb_item_type<Iterator> _) { return _.first >= startCode[i] && _.first <= endCode[i]; })\n-                  | hb_apply ([&] (const hb_item_type<Iterator> _)\n-                              {\n-                                HBUINT16 glyID;\n-                                glyID = _.second;\n-                                c->copy<HBUINT16> (glyID);\n-                              })\n-                  ;\n-\n-\n-                })\n-    ;\n+    for (unsigned i : + hb_range (segcount)\n+                      | hb_filter ([&] (const unsigned _) { return idDelta[_] == 0; }))\n+    {\n+      idRangeOffset[i] = 2 * (c->start_embed<HBUINT16> () - idRangeOffset - i);\n+      for (hb_codepoint_t cp = startCode[i]; cp <= endCode[i]; cp++)\n+      {\n+        HBUINT16 gid;\n+        gid = cp_to_gid[cp];\n+        c->copy<HBUINT16> (gid);\n+      }\n+    }\n@@ -253,1 +331,1 @@\n-    if (format4_iter.len () == 0) return;\n+    if (!format4_iter) return;\n@@ -256,1 +334,1 @@\n-    if (unlikely (!c->extend_min (*this))) return;\n+    if (unlikely (!c->extend_min (this))) return;\n@@ -259,8 +337,3 @@\n-    \/\/serialize endCode[]\n-    HBUINT16 *endCode = serialize_endcode_array (c, format4_iter);\n-    if (unlikely (!endCode)) return;\n-\n-    unsigned segcount = (c->length () - min_size) \/ HBUINT16::static_size;\n-\n-    \/\/ 2 bytes of padding.\n-    if (unlikely (!c->allocate_size<HBUINT16> (HBUINT16::static_size))) return; \/\/ 2 bytes of padding.\n+    hb_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> cp_to_gid {\n+      format4_iter\n+    };\n@@ -268,3 +341,5 @@\n-   \/\/ serialize startCode[]\n-    HBUINT16 *startCode = serialize_startcode_array (c, format4_iter);\n-    if (unlikely (!startCode)) return;\n+    \/\/serialize endCode[], startCode[], idDelta[]\n+    HBUINT16* endCode = c->start_embed<HBUINT16> ();\n+    unsigned segcount = serialize_find_segcount (cp_to_gid.iter());\n+    if (unlikely (!serialize_start_end_delta_arrays (c, cp_to_gid.iter(), segcount)))\n+      return;\n@@ -272,3 +347,2 @@\n-    \/\/serialize idDelta[]\n-    HBINT16 *idDelta = serialize_idDelta_array (c, format4_iter, endCode, startCode, segcount);\n-    if (unlikely (!idDelta)) return;\n+    HBUINT16 *startCode = endCode + segcount + 1;\n+    HBINT16 *idDelta = ((HBINT16*)startCode) + segcount;\n@@ -276,1 +350,6 @@\n-    HBUINT16 *idRangeOffset = serialize_rangeoffset_glyid (c, format4_iter, endCode, startCode, idDelta, segcount);\n+    HBUINT16 *idRangeOffset = serialize_rangeoffset_glyid (c,\n+                                                           cp_to_gid.iter (),\n+                                                           endCode,\n+                                                           startCode,\n+                                                           idDelta,\n+                                                           segcount);\n@@ -279,1 +358,11 @@\n-    if (unlikely (!c->check_assign(this->length, c->length () - table_initpos))) return;\n+    this->length = c->length () - table_initpos;\n+    if ((long long) this->length != (long long) c->length () - table_initpos)\n+    {\n+      \/\/ Length overflowed. Discard the current object before setting the error condition, otherwise\n+      \/\/ discard is a noop which prevents the higher level code from reverting the serializer to the\n+      \/\/ pre-error state in cmap4 overflow handling code.\n+      c->pop_discard ();\n+      c->err (HB_SERIALIZE_ERROR_INT_OVERFLOW);\n+      return;\n+    }\n+\n@@ -288,0 +377,5 @@\n+  unsigned get_language () const\n+  {\n+    return language;\n+  }\n+\n@@ -292,1 +386,0 @@\n-    ~accelerator_t () { fini (); }\n@@ -304,1 +397,0 @@\n-    void fini () {}\n@@ -326,1 +418,1 @@\n-      if (!found)\n+      if (unlikely (!found))\n@@ -346,1 +438,1 @@\n-      if (!gid)\n+      if (unlikely (!gid))\n@@ -365,0 +457,1 @@\n+        out->add_range(start, end);\n@@ -371,2 +464,1 @@\n-              continue;\n-            out->add (codepoint);\n+              out->del(codepoint);\n@@ -381,0 +473,2 @@\n+            {\n+              out->del_range (codepoint, end);\n@@ -382,0 +476,1 @@\n+            }\n@@ -384,2 +479,1 @@\n-              continue;\n-            out->add (codepoint);\n+              out->del(codepoint);\n@@ -394,0 +488,2 @@\n+      \/\/ TODO(grieger): optimize similar to collect_unicodes\n+      \/\/ (ie. use add_range())\n@@ -545,1 +641,1 @@\n-    if (!gid)\n+    if (unlikely (!gid))\n@@ -550,0 +646,6 @@\n+\n+  unsigned get_language () const\n+  {\n+    return language;\n+  }\n+\n@@ -585,1 +687,1 @@\n-  ArrayOf<HBGlyphID, UINT>\n+  ArrayOf<HBGlyphID16, UINT>\n@@ -593,1 +695,1 @@\n-struct CmapSubtableFormat10 : CmapSubtableTrimmed<HBUINT32 > {};\n+struct CmapSubtableFormat10 : CmapSubtableTrimmed<HBUINT32> {};\n@@ -603,1 +705,1 @@\n-    if (!gid)\n+    if (unlikely (!gid))\n@@ -609,0 +711,5 @@\n+  unsigned get_language () const\n+  {\n+    return language;\n+  }\n+\n@@ -628,1 +735,1 @@\n-      out->add_range (start, end);\n+      out->add_range (start, hb_min (end, 0x10FFFFu));\n@@ -636,0 +743,1 @@\n+    hb_codepoint_t last_end = 0;\n@@ -641,0 +749,7 @@\n+      if (unlikely (start > end || start < last_end)) {\n+        \/\/ Range is not in order and is invalid, skip it.\n+        continue;\n+      }\n+      last_end = end;\n+\n+\n@@ -673,1 +788,1 @@\n-  SortedArrayOf<CmapSubtableLongGroup, HBUINT32>\n+  SortedArray32Of<CmapSubtableLongGroup>\n@@ -692,1 +807,1 @@\n-    if (it.len () == 0) return;\n+    if (!it) return;\n@@ -694,1 +809,1 @@\n-    if (unlikely (!c->extend_min (*this))) return;\n+    if (unlikely (!c->extend_min (this))) return;\n@@ -696,1 +811,1 @@\n-    hb_codepoint_t startCharCode = 0xFFFF, endCharCode = 0xFFFF;\n+    hb_codepoint_t startCharCode = (hb_codepoint_t) -1, endCharCode = (hb_codepoint_t) -1;\n@@ -701,1 +816,1 @@\n-      if (startCharCode == 0xFFFF)\n+      if (startCharCode == (hb_codepoint_t) -1)\n@@ -732,1 +847,1 @@\n-    this->groups.len = (this->length - min_size)\/CmapSubtableLongGroup::static_size;\n+    this->groups.len = (this->length - min_size) \/ CmapSubtableLongGroup::static_size;\n@@ -787,1 +902,1 @@\n-struct DefaultUVS : SortedArrayOf<UnicodeValueRange, HBUINT32>\n+struct DefaultUVS : SortedArray32Of<UnicodeValueRange>\n@@ -797,1 +912,1 @@\n-      out->add_range (first, last);\n+      out->add_range (first, hb_min (last, 0x10FFFFu));\n@@ -853,1 +968,3 @@\n-      if (unlikely (!c->check_assign (out->len, (c->length () - init_len) \/ UnicodeValueRange::static_size))) return nullptr;\n+      if (unlikely (!c->check_assign (out->len,\n+                                      (c->length () - init_len) \/ UnicodeValueRange::static_size,\n+                                      HB_SERIALIZE_ERROR_INT_OVERFLOW))) return nullptr;\n@@ -874,1 +991,1 @@\n-  HBGlyphID     glyphID;        \/* Glyph ID of the UVS *\/\n+  HBGlyphID16   glyphID;        \/* Glyph ID of the UVS *\/\n@@ -879,1 +996,1 @@\n-struct NonDefaultUVS : SortedArrayOf<UVSMapping, HBUINT32>\n+struct NonDefaultUVS : SortedArray32Of<UVSMapping>\n@@ -883,3 +1000,2 @@\n-    unsigned int count = len;\n-    for (unsigned int i = 0; i < count; i++)\n-      out->add (arrayZ[i].unicodeValue);\n+    for (const auto& a : as_array ())\n+      out->add (a.unicodeValue);\n@@ -891,2 +1007,1 @@\n-    unsigned count = len;\n-    for (unsigned i = 0; i < count; i++)\n+    for (const auto& a : as_array ())\n@@ -894,2 +1009,2 @@\n-      hb_codepoint_t unicode = arrayZ[i].unicodeValue;\n-      hb_codepoint_t glyphid = arrayZ[i].glyphID;\n+      hb_codepoint_t unicode = a.unicodeValue;\n+      hb_codepoint_t glyphid = a.glyphID;\n@@ -1044,1 +1159,1 @@\n-  LOffsetTo<DefaultUVS>\n+  Offset32To<DefaultUVS>\n@@ -1046,1 +1161,1 @@\n-  LOffsetTo<NonDefaultUVS>\n+  Offset32To<NonDefaultUVS>\n@@ -1061,3 +1176,2 @@\n-    unsigned int count = record.len;\n-    for (unsigned int i = 0; i < count; i++)\n-      out->add (record.arrayZ[i].varSelector);\n+    for (const auto& a : record.as_array ())\n+      out->add (a.varSelector);\n@@ -1079,1 +1193,1 @@\n-    if (unlikely (!c->extend_min (*this))) return;\n+    if (unlikely (!c->extend_min (this))) return;\n@@ -1115,1 +1229,2 @@\n-    c->check_assign (this->length, c->length () - table_initpos + tail_len);\n+    c->check_assign (this->length, c->length () - table_initpos + tail_len,\n+                     HB_SERIALIZE_ERROR_INT_OVERFLOW);\n@@ -1118,1 +1233,2 @@\n-                     VariationSelectorRecord::static_size);\n+                     VariationSelectorRecord::static_size,\n+                     HB_SERIALIZE_ERROR_INT_OVERFLOW);\n@@ -1183,1 +1299,1 @@\n-  SortedArrayOf<VariationSelectorRecord, HBUINT32>\n+  SortedArray32Of<VariationSelectorRecord>\n@@ -1238,0 +1354,14 @@\n+  unsigned get_language () const\n+  {\n+    switch (u.format) {\n+    case  0: return u.format0 .get_language ();\n+    case  4: return u.format4 .get_language ();\n+    case  6: return u.format6 .get_language ();\n+    case 10: return u.format10.get_language ();\n+    case 12: return u.format12.get_language ();\n+    case 13: return u.format13.get_language ();\n+    case 14:\n+    default: return 0;\n+    }\n+  }\n+\n@@ -1341,1 +1471,1 @@\n-  LOffsetTo<CmapSubtable>\n+  Offset32To<CmapSubtable>\n@@ -1347,0 +1477,45 @@\n+struct SubtableUnicodesCache {\n+\n+ private:\n+  const void* base;\n+  hb_hashmap_t<intptr_t, hb::unique_ptr<hb_set_t>> cached_unicodes;\n+\n+ public:\n+  SubtableUnicodesCache(const void* cmap_base)\n+      : base(cmap_base), cached_unicodes() {}\n+\n+  hb_set_t* set_for (const EncodingRecord* record)\n+  {\n+    if (!cached_unicodes.has ((intptr_t) record))\n+    {\n+      hb_set_t *s = hb_set_create ();\n+      if (unlikely (s->in_error ()))\n+        return hb_set_get_empty ();\n+\n+      (base+record->subtable).collect_unicodes (s);\n+\n+      if (unlikely (!cached_unicodes.set ((intptr_t) record, hb::unique_ptr<hb_set_t> {s})))\n+        return hb_set_get_empty ();\n+\n+      return s;\n+    }\n+    return cached_unicodes.get ((intptr_t) record);\n+  }\n+\n+};\n+\n+static inline uint_fast16_t\n+_hb_symbol_pua_map (unsigned codepoint)\n+{\n+  if (codepoint <= 0x00FFu)\n+  {\n+    \/* For symbol-encoded OpenType fonts, we duplicate the\n+     * U+F000..F0FF range at U+0000..U+00FF.  That's what\n+     * Windows seems to do, and that's hinted about at:\n+     * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/recom\n+     * under \"Non-Standard (Symbol) Fonts\". *\/\n+    return 0xF000u + codepoint;\n+  }\n+  return 0;\n+}\n+\n@@ -1353,1 +1528,1 @@\n-  void serialize (hb_serialize_context_t *c,\n+  bool serialize (hb_serialize_context_t *c,\n@@ -1357,1 +1532,2 @@\n-                  const hb_subset_plan_t *plan)\n+                  const hb_subset_plan_t *plan,\n+                  bool drop_format_4 = false)\n@@ -1359,1 +1535,1 @@\n-    if (unlikely (!c->extend_min ((*this))))  return;\n+    if (unlikely (!c->extend_min ((*this))))  return false;\n@@ -1363,0 +1539,1 @@\n+    auto snap = c->snapshot ();\n@@ -1364,0 +1541,1 @@\n+    SubtableUnicodesCache unicodes_cache (base);\n@@ -1366,0 +1544,3 @@\n+      if (c->in_error ())\n+        return false;\n+\n@@ -1367,1 +1548,5 @@\n-      if (!plan->glyphs_requested->is_empty ())\n+      if (format != 4 && format != 12 && format != 14) continue;\n+\n+      hb_set_t* unicodes_set = unicodes_cache.set_for (&_);\n+\n+      if (!drop_format_4 && format == 4)\n@@ -1369,21 +1554,11 @@\n-        hb_set_t unicodes_set;\n-        hb_map_t cp_glyphid_map;\n-        (base+_.subtable).collect_mapping (&unicodes_set, &cp_glyphid_map);\n-\n-        auto table_iter =\n-        + hb_zip (unicodes_set.iter(), unicodes_set.iter() | hb_map(cp_glyphid_map))\n-        | hb_filter (plan->_glyphset, hb_second)\n-        | hb_filter ([plan] (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& p)\n-                     {\n-                       return plan->unicodes->has (p.first) ||\n-                              plan->glyphs_requested->has (p.second);\n-                     })\n-        | hb_map ([plan] (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& p_org)\n-                  {\n-                    return hb_pair_t<hb_codepoint_t, hb_codepoint_t> (p_org.first, plan->glyph_map->get(p_org.second));\n-                  })\n-        ;\n-\n-        if (format == 4) c->copy (_, table_iter, 4u, base, plan, &format4objidx);\n-        else if (format == 12) c->copy (_, table_iter, 12u, base, plan, &format12objidx);\n-        else if (format == 14) c->copy (_, table_iter, 14u, base, plan, &format14objidx);\n+        c->copy (_, + it | hb_filter (*unicodes_set, hb_first), 4u, base, plan, &format4objidx);\n+        if (c->in_error () && c->only_overflow ())\n+        {\n+          \/\/ cmap4 overflowed, reset and retry serialization without format 4 subtables.\n+          c->revert (snap);\n+          return serialize (c, it,\n+                            encodingrec_iter,\n+                            base,\n+                            plan,\n+                            true);\n+        }\n@@ -1391,3 +1566,2 @@\n-      \/* when --gids option is not used, we iterate input unicodes instead of\n-       * all codepoints in each subtable, which is more efficient *\/\n-      else\n+\n+      else if (format == 12)\n@@ -1395,2 +1569,49 @@\n-        hb_set_t unicodes_set;\n-        (base+_.subtable).collect_unicodes (&unicodes_set);\n+        if (_can_drop (_, *unicodes_set, base, unicodes_cache, + it | hb_map (hb_first), encodingrec_iter)) continue;\n+        c->copy (_, + it | hb_filter (*unicodes_set, hb_first), 12u, base, plan, &format12objidx);\n+      }\n+      else if (format == 14) c->copy (_, it, 14u, base, plan, &format14objidx);\n+    }\n+    c->check_assign(this->encodingRecord.len,\n+                    (c->length () - cmap::min_size)\/EncodingRecord::static_size,\n+                    HB_SERIALIZE_ERROR_INT_OVERFLOW);\n+\n+    \/\/ Fail if format 4 was dropped and there is no cmap12.\n+    return !drop_format_4 || format12objidx;\n+  }\n+\n+  template<typename Iterator, typename EncodingRecordIterator,\n+      hb_requires (hb_is_iterator (Iterator)),\n+      hb_requires (hb_is_iterator (EncodingRecordIterator))>\n+  bool _can_drop (const EncodingRecord& cmap12,\n+                  const hb_set_t& cmap12_unicodes,\n+                  const void* base,\n+                  SubtableUnicodesCache& unicodes_cache,\n+                  Iterator subset_unicodes,\n+                  EncodingRecordIterator encoding_records)\n+  {\n+    for (auto cp : + subset_unicodes | hb_filter (cmap12_unicodes))\n+    {\n+      if (cp >= 0x10000) return false;\n+    }\n+\n+    unsigned target_platform;\n+    unsigned target_encoding;\n+    unsigned target_language = (base+cmap12.subtable).get_language ();\n+\n+    if (cmap12.platformID == 0 && cmap12.encodingID == 4)\n+    {\n+      target_platform = 0;\n+      target_encoding = 3;\n+    } else if (cmap12.platformID == 3 && cmap12.encodingID == 10) {\n+      target_platform = 3;\n+      target_encoding = 1;\n+    } else {\n+      return false;\n+    }\n+\n+    for (const auto& _ : encoding_records)\n+    {\n+      if (_.platformID != target_platform\n+          || _.encodingID != target_encoding\n+          || (base+_.subtable).get_language() != target_language)\n+        continue;\n@@ -1398,3 +1619,9 @@\n-        if (format == 4) c->copy (_, + it | hb_filter (unicodes_set, hb_first), 4u, base, plan, &format4objidx);\n-        else if (format == 12) c->copy (_, + it | hb_filter (unicodes_set, hb_first), 12u, base, plan, &format12objidx);\n-        else if (format == 14) c->copy (_, it, 14u, base, plan, &format14objidx);\n+      hb_set_t* sibling_unicodes = unicodes_cache.set_for (&_);\n+\n+      auto cmap12 = + subset_unicodes | hb_filter (cmap12_unicodes);\n+      auto sibling = + subset_unicodes | hb_filter (*sibling_unicodes);\n+      for (; cmap12 && sibling; cmap12++, sibling++)\n+      {\n+        unsigned a = *cmap12;\n+        unsigned b = *sibling;\n+        if (a != b) return false;\n@@ -1402,0 +1629,2 @@\n+\n+      return !cmap12 && !sibling;\n@@ -1404,1 +1633,1 @@\n-    c->check_assign(this->encodingRecord.len, (c->length () - cmap::min_size)\/EncodingRecord::static_size);\n+    return false;\n@@ -1450,1 +1679,1 @@\n-      const EncodingRecord *table = hb_addressof (_);\n+      const EncodingRecord *table = std::addressof (_);\n@@ -1461,7 +1690,1 @@\n-    + hb_iter (c->plan->unicodes)\n-    | hb_map ([&] (hb_codepoint_t _)\n-              {\n-                hb_codepoint_t new_gid = HB_MAP_VALUE_INVALID;\n-                c->plan->new_gid_for_codepoint (_, &new_gid);\n-                return hb_pair_t<hb_codepoint_t, hb_codepoint_t> (_, new_gid);\n-              })\n+    + c->plan->unicode_to_new_gid_list.iter ()\n@@ -1471,2 +1694,2 @@\n-    cmap_prime->serialize (c->serializer, it, encodingrec_iter, this, c->plan);\n-    return_trace (true);\n+\n+    return_trace (cmap_prime->serialize (c->serializer, it, encodingrec_iter, this, c->plan));\n@@ -1508,1 +1731,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -1522,1 +1745,18 @@\n-        this->get_glyph_funcZ = get_glyph_from_symbol<CmapSubtable>;\n+      {\n+        switch ((unsigned) face->table.OS2->get_font_page ()) {\n+        case OS2::font_page_t::FONT_PAGE_NONE:\n+          this->get_glyph_funcZ = get_glyph_from_symbol<CmapSubtable, _hb_symbol_pua_map>;\n+          break;\n+#ifndef HB_NO_OT_SHAPER_ARABIC_FALLBACK\n+        case OS2::font_page_t::FONT_PAGE_SIMP_ARABIC:\n+          this->get_glyph_funcZ = get_glyph_from_symbol<CmapSubtable, _hb_arabic_pua_simp_map>;\n+          break;\n+        case OS2::font_page_t::FONT_PAGE_TRAD_ARABIC:\n+          this->get_glyph_funcZ = get_glyph_from_symbol<CmapSubtable, _hb_arabic_pua_trad_map>;\n+          break;\n+#endif\n+        default:\n+          this->get_glyph_funcZ = get_glyph_from<CmapSubtable>;\n+          break;\n+        }\n+      }\n@@ -1543,2 +1783,1 @@\n-\n-    void fini () { this->table.destroy (); }\n+    ~accelerator_t () { this->table.destroy (); }\n@@ -1605,0 +1844,1 @@\n+    typedef uint_fast16_t (*hb_pua_remap_func_t) (unsigned);\n@@ -1615,1 +1855,1 @@\n-    template <typename Type>\n+    template <typename Type, hb_pua_remap_func_t remap>\n@@ -1624,9 +1864,2 @@\n-      if (codepoint <= 0x00FFu)\n-      {\n-        \/* For symbol-encoded OpenType fonts, we duplicate the\n-         * U+F000..F0FF range at U+0000..U+00FF.  That's what\n-         * Windows seems to do, and that's hinted about at:\n-         * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/recom\n-         * under \"Non-Standard (Symbol) Fonts\". *\/\n-        return typed_obj->get_glyph (0xF000u + codepoint, glyph);\n-      }\n+      if (hb_codepoint_t c = remap (codepoint))\n+        return typed_obj->get_glyph (c, glyph);\n@@ -1700,1 +1933,1 @@\n-  SortedArrayOf<EncodingRecord>\n+  SortedArray16Of<EncodingRecord>\n@@ -1706,1 +1939,3 @@\n-struct cmap_accelerator_t : cmap::accelerator_t {};\n+struct cmap_accelerator_t : cmap::accelerator_t {\n+  cmap_accelerator_t (hb_face_t *face) : cmap::accelerator_t (face) {}\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cmap-table.hh","additions":460,"deletions":225,"binary":false,"changes":685,"status":"modified"},{"patch":"@@ -363,0 +363,10 @@\n+  \/* XXX Remove this and fix by not inserting it into vector. *\/\n+  IndexSubtableRecord& operator = (const IndexSubtableRecord &o)\n+  {\n+    firstGlyphIndex = o.firstGlyphIndex;\n+    lastGlyphIndex = o.lastGlyphIndex;\n+    offsetToSubtable = (unsigned) o.offsetToSubtable;\n+    assert (offsetToSubtable.is_null ());\n+    return *this;\n+  }\n+\n@@ -511,3 +521,3 @@\n-  HBGlyphID                     firstGlyphIndex;\n-  HBGlyphID                     lastGlyphIndex;\n-  LOffsetTo<IndexSubtable>      offsetToSubtable;\n+  HBGlyphID16                   firstGlyphIndex;\n+  HBGlyphID16                   lastGlyphIndex;\n+  Offset32To<IndexSubtable>     offsetToSubtable;\n@@ -675,1 +685,1 @@\n-  LNNOffsetTo<IndexSubtableArray>\n+  NNOffset32To<IndexSubtableArray>\n@@ -682,2 +692,2 @@\n-  HBGlyphID             startGlyphIndex;\n-  HBGlyphID             endGlyphIndex;\n+  HBGlyphID16           startGlyphIndex;\n+  HBGlyphID16           endGlyphIndex;\n@@ -700,1 +710,1 @@\n-  LArrayOf<HBUINT8>     data;\n+  Array32Of<HBUINT8>    data;\n@@ -708,1 +718,1 @@\n-  LArrayOf<HBUINT8>     data;\n+  Array32Of<HBUINT8>    data;\n@@ -715,1 +725,1 @@\n-  LArrayOf<HBUINT8>     data;\n+  Array32Of<HBUINT8>    data;\n@@ -741,1 +751,1 @@\n-                                                 free);\n+                                                 hb_free);\n@@ -801,1 +811,1 @@\n-  LArrayOf<BitmapSizeTable>     sizeTables;\n+  Array32Of<BitmapSizeTable>    sizeTables;\n@@ -812,1 +822,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -814,2 +824,2 @@\n-      cblc = hb_sanitize_context_t ().reference_table<CBLC> (face);\n-      cbdt = hb_sanitize_context_t ().reference_table<CBDT> (face);\n+      this->cblc = hb_sanitize_context_t ().reference_table<CBLC> (face);\n+      this->cbdt = hb_sanitize_context_t ().reference_table<CBDT> (face);\n@@ -819,2 +829,1 @@\n-\n-    void fini ()\n+    ~accelerator_t ()\n@@ -981,1 +990,4 @@\n-struct CBDT_accelerator_t : CBDT::accelerator_t {};\n+struct CBDT_accelerator_t : CBDT::accelerator_t {\n+  CBDT_accelerator_t (hb_face_t *face) : CBDT::accelerator_t (face) {}\n+};\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-cbdt-table.hh","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+#include \"hb-ot-layout-common.hh\"\n+#include \"hb-ot-var-common.hh\"\n@@ -39,0 +41,7 @@\n+#ifndef HB_COLRV1_MAX_NESTING_LEVEL\n+#define HB_COLRV1_MAX_NESTING_LEVEL     100\n+#endif\n+\n+#ifndef COLRV1_ENABLE_SUBSETTING\n+#define COLRV1_ENABLE_SUBSETTING 1\n+#endif\n@@ -42,0 +51,708 @@\n+struct COLR;\n+struct hb_colrv1_closure_context_t :\n+       hb_dispatch_context_t<hb_colrv1_closure_context_t>\n+{\n+  template <typename T>\n+  return_t dispatch (const T &obj)\n+  {\n+    if (unlikely (nesting_level_left == 0))\n+      return hb_empty_t ();\n+\n+    if (paint_visited (&obj))\n+      return hb_empty_t ();\n+\n+    nesting_level_left--;\n+    obj.closurev1 (this);\n+    nesting_level_left++;\n+    return hb_empty_t ();\n+  }\n+  static return_t default_return_value () { return hb_empty_t (); }\n+\n+  bool paint_visited (const void *paint)\n+  {\n+    hb_codepoint_t delta = (hb_codepoint_t) ((uintptr_t) paint - (uintptr_t) base);\n+    if (visited_paint.in_error() || visited_paint.has (delta))\n+      return true;\n+\n+    visited_paint.add (delta);\n+    return false;\n+  }\n+\n+  const COLR* get_colr_table () const\n+  { return reinterpret_cast<const COLR *> (base); }\n+\n+  void add_glyph (unsigned glyph_id)\n+  { glyphs->add (glyph_id); }\n+\n+  void add_layer_indices (unsigned first_layer_index, unsigned num_of_layers)\n+  { layer_indices->add_range (first_layer_index, first_layer_index + num_of_layers - 1); }\n+\n+  void add_palette_index (unsigned palette_index)\n+  { palette_indices->add (palette_index); }\n+\n+  public:\n+  const void *base;\n+  hb_set_t visited_paint;\n+  hb_set_t *glyphs;\n+  hb_set_t *layer_indices;\n+  hb_set_t *palette_indices;\n+  unsigned nesting_level_left;\n+\n+  hb_colrv1_closure_context_t (const void *base_,\n+                               hb_set_t *glyphs_,\n+                               hb_set_t *layer_indices_,\n+                               hb_set_t *palette_indices_,\n+                               unsigned nesting_level_left_ = HB_COLRV1_MAX_NESTING_LEVEL) :\n+                          base (base_),\n+                          glyphs (glyphs_),\n+                          layer_indices (layer_indices_),\n+                          palette_indices (palette_indices_),\n+                          nesting_level_left (nesting_level_left_)\n+  {}\n+};\n+\n+struct LayerRecord\n+{\n+  operator hb_ot_color_layer_t () const { return {glyphId, colorIdx}; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBGlyphID16   glyphId;        \/* Glyph ID of layer glyph *\/\n+  Index         colorIdx;       \/* Index value to use with a\n+                                 * selected color palette.\n+                                 * An index value of 0xFFFF\n+                                 * is a special case indicating\n+                                 * that the text foreground\n+                                 * color (defined by a\n+                                 * higher-level client) should\n+                                 * be used and shall not be\n+                                 * treated as actual index\n+                                 * into CPAL ColorRecord array. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct BaseGlyphRecord\n+{\n+  int cmp (hb_codepoint_t g) const\n+  { return g < glyphId ? -1 : g > glyphId ? 1 : 0; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  public:\n+  HBGlyphID16   glyphId;        \/* Glyph ID of reference glyph *\/\n+  HBUINT16      firstLayerIdx;  \/* Index (from beginning of\n+                                 * the Layer Records) to the\n+                                 * layer record. There will be\n+                                 * numLayers consecutive entries\n+                                 * for this base glyph. *\/\n+  HBUINT16      numLayers;      \/* Number of color layers\n+                                 * associated with this glyph *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+template <typename T>\n+struct Variable\n+{\n+  Variable<T>* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (c->embed (this));\n+  }\n+\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { value.closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    if (!value.subset (c)) return_trace (false);\n+    return_trace (c->serializer->embed (varIdxBase));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && value.sanitize (c));\n+  }\n+\n+  protected:\n+  T      value;\n+  VarIdx varIdxBase;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + T::static_size);\n+};\n+\n+template <typename T>\n+struct NoVariable\n+{\n+  NoVariable<T>* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (c->embed (this));\n+  }\n+\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { value.closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    return_trace (value.subset (c));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && value.sanitize (c));\n+  }\n+\n+  T      value;\n+  public:\n+  DEFINE_SIZE_STATIC (T::static_size);\n+};\n+\n+\/\/ Color structures\n+\n+struct ColorStop\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { c->add_palette_index (paletteIndex); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    return_trace (c->serializer->check_assign (out->paletteIndex, c->plan->colr_palettes->get (paletteIndex),\n+                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  F2DOT14       stopOffset;\n+  HBUINT16      paletteIndex;\n+  F2DOT14       alpha;\n+  public:\n+  DEFINE_SIZE_STATIC (2 + 2 * F2DOT14::static_size);\n+};\n+\n+struct Extend : HBUINT8\n+{\n+  enum {\n+    EXTEND_PAD     = 0,\n+    EXTEND_REPEAT  = 1,\n+    EXTEND_REFLECT = 2,\n+  };\n+  public:\n+  DEFINE_SIZE_STATIC (1);\n+};\n+\n+template <template<typename> class Var>\n+struct ColorLine\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  {\n+    for (const auto &stop : stops.iter ())\n+      stop.closurev1 (c);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    if (!c->serializer->check_assign (out->extend, extend, HB_SERIALIZE_ERROR_INT_OVERFLOW)) return_trace (false);\n+    if (!c->serializer->check_assign (out->stops.len, stops.len, HB_SERIALIZE_ERROR_ARRAY_OVERFLOW)) return_trace (false);\n+\n+    for (const auto& stop : stops.iter ())\n+    {\n+      if (!stop.subset (c)) return_trace (false);\n+    }\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  stops.sanitize (c));\n+  }\n+\n+  Extend        extend;\n+  Array16Of<Var<ColorStop>>     stops;\n+  public:\n+  DEFINE_SIZE_ARRAY_SIZED (3, stops);\n+};\n+\n+\/\/ Composition modes\n+\n+\/\/ Compositing modes are taken from https:\/\/www.w3.org\/TR\/compositing-1\/\n+\/\/ NOTE: a brief audit of major implementations suggests most support most\n+\/\/ or all of the specified modes.\n+struct CompositeMode : HBUINT8\n+{\n+  enum {\n+    \/\/ Porter-Duff modes\n+    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators\n+    COMPOSITE_CLEAR          =  0,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_clear\n+    COMPOSITE_SRC            =  1,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_src\n+    COMPOSITE_DEST           =  2,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dst\n+    COMPOSITE_SRC_OVER       =  3,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcover\n+    COMPOSITE_DEST_OVER      =  4,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstover\n+    COMPOSITE_SRC_IN         =  5,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcin\n+    COMPOSITE_DEST_IN        =  6,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstin\n+    COMPOSITE_SRC_OUT        =  7,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcout\n+    COMPOSITE_DEST_OUT       =  8,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstout\n+    COMPOSITE_SRC_ATOP       =  9,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_srcatop\n+    COMPOSITE_DEST_ATOP      = 10,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_dstatop\n+    COMPOSITE_XOR            = 11,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_xor\n+    COMPOSITE_PLUS           = 12,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#porterduffcompositingoperators_plus\n+\n+    \/\/ Blend modes\n+    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blending\n+    COMPOSITE_SCREEN         = 13,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingscreen\n+    COMPOSITE_OVERLAY        = 14,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingoverlay\n+    COMPOSITE_DARKEN         = 15,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingdarken\n+    COMPOSITE_LIGHTEN        = 16,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinglighten\n+    COMPOSITE_COLOR_DODGE    = 17,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolordodge\n+    COMPOSITE_COLOR_BURN     = 18,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolorburn\n+    COMPOSITE_HARD_LIGHT     = 19,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinghardlight\n+    COMPOSITE_SOFT_LIGHT     = 20,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingsoftlight\n+    COMPOSITE_DIFFERENCE     = 21,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingdifference\n+    COMPOSITE_EXCLUSION      = 22,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingexclusion\n+    COMPOSITE_MULTIPLY       = 23,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingmultiply\n+\n+    \/\/ Modes that, uniquely, do not operate on components\n+    \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingnonseparable\n+    COMPOSITE_HSL_HUE        = 24,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendinghue\n+    COMPOSITE_HSL_SATURATION = 25,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingsaturation\n+    COMPOSITE_HSL_COLOR      = 26,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingcolor\n+    COMPOSITE_HSL_LUMINOSITY = 27,  \/\/ https:\/\/www.w3.org\/TR\/compositing-1\/#blendingluminosity\n+  };\n+  public:\n+  DEFINE_SIZE_STATIC (1);\n+};\n+\n+struct Affine2x3\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBFixed xx;\n+  HBFixed yx;\n+  HBFixed xy;\n+  HBFixed yy;\n+  HBFixed dx;\n+  HBFixed dy;\n+  public:\n+  DEFINE_SIZE_STATIC (6 * HBFixed::static_size);\n+};\n+\n+struct PaintColrLayers\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    return_trace (c->serializer->check_assign (out->firstLayerIndex, c->plan->colrv1_layers->get (firstLayerIndex),\n+                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT8       format; \/* format = 1 *\/\n+  HBUINT8       numLayers;\n+  HBUINT32      firstLayerIndex;  \/* index into COLRv1::layerList *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct PaintSolid\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { c->add_palette_index (paletteIndex); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    return_trace (c->serializer->check_assign (out->paletteIndex, c->plan->colr_palettes->get (paletteIndex),\n+                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT8       format; \/* format = 2(noVar) or 3(Var)*\/\n+  HBUINT16      paletteIndex;\n+  F2DOT14       alpha;\n+  public:\n+  DEFINE_SIZE_STATIC (3 + F2DOT14::static_size);\n+};\n+\n+template <template<typename> class Var>\n+struct PaintLinearGradient\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { (this+colorLine).closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n+  }\n+\n+  HBUINT8                       format; \/* format = 4(noVar) or 5 (Var) *\/\n+  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintLinearGradient\n+                                            * table) to ColorLine subtable. *\/\n+  FWORD                 x0;\n+  FWORD                 y0;\n+  FWORD                 x1;\n+  FWORD                 y1;\n+  FWORD                 x2;\n+  FWORD                 y2;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 6 * FWORD::static_size);\n+};\n+\n+template <template<typename> class Var>\n+struct PaintRadialGradient\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { (this+colorLine).closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n+  }\n+\n+  HBUINT8                       format; \/* format = 6(noVar) or 7 (Var) *\/\n+  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintRadialGradient\n+                                            * table) to ColorLine subtable. *\/\n+  FWORD                 x0;\n+  FWORD                 y0;\n+  UFWORD                radius0;\n+  FWORD                 x1;\n+  FWORD                 y1;\n+  UFWORD                radius1;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 6 * FWORD::static_size);\n+};\n+\n+template <template<typename> class Var>\n+struct PaintSweepGradient\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const\n+  { (this+colorLine).closurev1 (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && colorLine.sanitize (c, this));\n+  }\n+\n+  HBUINT8                       format; \/* format = 8(noVar) or 9 (Var) *\/\n+  Offset24To<ColorLine<Var>>    colorLine; \/* Offset (from beginning of PaintSweepGradient\n+                                            * table) to ColorLine subtable. *\/\n+  FWORD                 centerX;\n+  FWORD                 centerY;\n+  F2DOT14               startAngle;\n+  F2DOT14               endAngle;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * FWORD::static_size + 2 * F2DOT14::static_size);\n+};\n+\n+struct Paint;\n+\/\/ Paint a non-COLR glyph, filled as indicated by paint.\n+struct PaintGlyph\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    if (! c->serializer->check_assign (out->gid, c->plan->glyph_map->get (gid),\n+                                       HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+\n+    return_trace (out->paint.serialize_subset (c, paint, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && paint.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 10 *\/\n+  Offset24To<Paint>     paint;  \/* Offset (from beginning of PaintGlyph table) to Paint subtable. *\/\n+  HBUINT16              gid;\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct PaintColrGlyph\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (c->serializer->check_assign (out->gid, c->plan->glyph_map->get (gid),\n+                                               HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT8       format; \/* format = 11 *\/\n+  HBUINT16      gid;\n+  public:\n+  DEFINE_SIZE_STATIC (3);\n+};\n+\n+template <template<typename> class Var>\n+struct PaintTransform\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (!out->transform.serialize_copy (c->serializer, transform, this)) return_trace (false);\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  src.sanitize (c, this) &&\n+                  transform.sanitize (c, this));\n+  }\n+\n+  HBUINT8                       format; \/* format = 12(noVar) or 13 (Var) *\/\n+  Offset24To<Paint>             src; \/* Offset (from beginning of PaintTransform table) to Paint subtable. *\/\n+  Offset24To<Var<Affine2x3>>    transform;\n+  public:\n+  DEFINE_SIZE_STATIC (7);\n+};\n+\n+struct PaintTranslate\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 14(noVar) or 15 (Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintTranslate table) to Paint subtable. *\/\n+  FWORD         dx;\n+  FWORD         dy;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * FWORD::static_size);\n+};\n+\n+struct PaintScale\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 16 (noVar) or 17(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScale table) to Paint subtable. *\/\n+  F2DOT14               scaleX;\n+  F2DOT14               scaleY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size);\n+};\n+\n+struct PaintScaleAroundCenter\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 18 (noVar) or 19(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleAroundCenter table) to Paint subtable. *\/\n+  F2DOT14       scaleX;\n+  F2DOT14       scaleY;\n+  FWORD         centerX;\n+  FWORD         centerY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size + 2 * FWORD::static_size);\n+};\n+\n+struct PaintScaleUniform\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 20 (noVar) or 21(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleUniform table) to Paint subtable. *\/\n+  F2DOT14               scale;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size);\n+};\n+\n+struct PaintScaleUniformAroundCenter\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 22 (noVar) or 23(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintScaleUniformAroundCenter table) to Paint subtable. *\/\n+  F2DOT14       scale;\n+  FWORD         centerX;\n+  FWORD         centerY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size + 2 * FWORD::static_size);\n+};\n+\n+struct PaintRotate\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n@@ -43,1 +760,17 @@\n-struct LayerRecord\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 24 (noVar) or 25(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintRotate table) to Paint subtable. *\/\n+  F2DOT14               angle;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size);\n+};\n+\n+struct PaintRotateAroundCenter\n@@ -45,1 +778,111 @@\n-  operator hb_ot_color_layer_t () const { return {glyphId, colorIdx}; }\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 26 (noVar) or 27(Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintRotateAroundCenter table) to Paint subtable. *\/\n+  F2DOT14       angle;\n+  FWORD         centerX;\n+  FWORD         centerY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + F2DOT14::static_size + 2 * FWORD::static_size);\n+};\n+\n+struct PaintSkew\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 28(noVar) or 29 (Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintSkew table) to Paint subtable. *\/\n+  F2DOT14               xSkewAngle;\n+  F2DOT14               ySkewAngle;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size);\n+};\n+\n+struct PaintSkewAroundCenter\n+{\n+  HB_INTERNAL void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->src.serialize_subset (c, src, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && src.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 30(noVar) or 31 (Var) *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintSkewAroundCenter table) to Paint subtable. *\/\n+  F2DOT14       xSkewAngle;\n+  F2DOT14       ySkewAngle;\n+  FWORD         centerX;\n+  FWORD         centerY;\n+  public:\n+  DEFINE_SIZE_STATIC (4 + 2 * F2DOT14::static_size + 2 * FWORD::static_size);\n+};\n+\n+struct PaintComposite\n+{\n+  void closurev1 (hb_colrv1_closure_context_t* c) const;\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    if (!out->src.serialize_subset (c, src, this)) return_trace (false);\n+    return_trace (out->backdrop.serialize_subset (c, backdrop, this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  src.sanitize (c, this) &&\n+                  backdrop.sanitize (c, this));\n+  }\n+\n+  HBUINT8               format; \/* format = 32 *\/\n+  Offset24To<Paint>     src; \/* Offset (from beginning of PaintComposite table) to source Paint subtable. *\/\n+  CompositeMode         mode;   \/* If mode is unrecognized use COMPOSITE_CLEAR *\/\n+  Offset24To<Paint>     backdrop; \/* Offset (from beginning of PaintComposite table) to backdrop Paint subtable. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n@@ -47,0 +890,2 @@\n+struct ClipBoxFormat1\n+{\n@@ -54,11 +899,5 @@\n-  HBGlyphID     glyphId;        \/* Glyph ID of layer glyph *\/\n-  Index         colorIdx;       \/* Index value to use with a\n-                                 * selected color palette.\n-                                 * An index value of 0xFFFF\n-                                 * is a special case indicating\n-                                 * that the text foreground\n-                                 * color (defined by a\n-                                 * higher-level client) should\n-                                 * be used and shall not be\n-                                 * treated as actual index\n-                                 * into CPAL ColorRecord array. *\/\n+  HBUINT8       format; \/* format = 1(noVar) or 2(Var)*\/\n+  FWORD         xMin;\n+  FWORD         yMin;\n+  FWORD         xMax;\n+  FWORD         yMax;\n@@ -66,1 +905,1 @@\n-  DEFINE_SIZE_STATIC (4);\n+  DEFINE_SIZE_STATIC (1 + 4 * FWORD::static_size);\n@@ -69,1 +908,250 @@\n-struct BaseGlyphRecord\n+struct ClipBoxFormat2 : Variable<ClipBoxFormat1> {};\n+\n+struct ClipBox\n+{\n+  ClipBox* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    switch (u.format) {\n+    case 1: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format1)));\n+    case 2: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format2)));\n+    default:return_trace (nullptr);\n+    }\n+  }\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT8               format;         \/* Format identifier *\/\n+  ClipBoxFormat1        format1;\n+  ClipBoxFormat2        format2;\n+  } u;\n+};\n+\n+struct ClipRecord\n+{\n+  ClipRecord* copy (hb_serialize_context_t *c, const void *base) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+    if (!out->clipBox.serialize_copy (c, clipBox, base)) return_trace (nullptr);\n+    return_trace (out);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && clipBox.sanitize (c, base));\n+  }\n+\n+  public:\n+  HBUINT16              startGlyphID;  \/\/ first gid clip applies to\n+  HBUINT16              endGlyphID;    \/\/ last gid clip applies to, inclusive\n+  Offset24To<ClipBox>   clipBox;   \/\/ Box or VarBox\n+  public:\n+  DEFINE_SIZE_STATIC (7);\n+};\n+\n+struct ClipList\n+{\n+  unsigned serialize_clip_records (hb_serialize_context_t *c,\n+                                   const hb_set_t& gids,\n+                                   const hb_map_t& gid_offset_map) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (gids.is_empty () ||\n+        gid_offset_map.get_population () != gids.get_population ())\n+      return_trace (0);\n+\n+    unsigned count  = 0;\n+\n+    hb_codepoint_t start_gid= gids.get_min ();\n+    hb_codepoint_t prev_gid = start_gid;\n+\n+    unsigned offset = gid_offset_map.get (start_gid);\n+    unsigned prev_offset = offset;\n+    for (const hb_codepoint_t _ : gids.iter ())\n+    {\n+      if (_ == start_gid) continue;\n+\n+      offset = gid_offset_map.get (_);\n+      if (_ == prev_gid + 1 &&  offset == prev_offset)\n+      {\n+        prev_gid = _;\n+        continue;\n+      }\n+\n+      ClipRecord record;\n+      record.startGlyphID = start_gid;\n+      record.endGlyphID = prev_gid;\n+      record.clipBox = prev_offset;\n+\n+      if (!c->copy (record, this)) return_trace (0);\n+      count++;\n+\n+      start_gid = _;\n+      prev_gid = _;\n+      prev_offset = offset;\n+    }\n+\n+    \/\/last one\n+    {\n+      ClipRecord record;\n+      record.startGlyphID = start_gid;\n+      record.endGlyphID = prev_gid;\n+      record.clipBox = prev_offset;\n+      if (!c->copy (record, this)) return_trace (0);\n+      count++;\n+    }\n+    return_trace (count);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    if (!c->serializer->check_assign (out->format, format, HB_SERIALIZE_ERROR_INT_OVERFLOW)) return_trace (false);\n+\n+    const hb_set_t& glyphset = *c->plan->_glyphset_colred;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    hb_map_t new_gid_offset_map;\n+    hb_set_t new_gids;\n+    for (const ClipRecord& record : clips.iter ())\n+    {\n+      unsigned start_gid = record.startGlyphID;\n+      unsigned end_gid = record.endGlyphID;\n+      for (unsigned gid = start_gid; gid <= end_gid; gid++)\n+      {\n+        if (!glyphset.has (gid) || !glyph_map.has (gid)) continue;\n+        unsigned new_gid = glyph_map.get (gid);\n+        new_gid_offset_map.set (new_gid, record.clipBox);\n+        new_gids.add (new_gid);\n+      }\n+    }\n+\n+    unsigned count = serialize_clip_records (c->serializer, new_gids, new_gid_offset_map);\n+    if (!count) return_trace (false);\n+    return_trace (c->serializer->check_assign (out->clips.len, count, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && clips.sanitize (c, this));\n+  }\n+\n+  HBUINT8                       format;  \/\/ Set to 1.\n+  Array32Of<ClipRecord>         clips;  \/\/ Clip records, sorted by startGlyphID\n+  public:\n+  DEFINE_SIZE_ARRAY_SIZED (5, clips);\n+};\n+\n+struct Paint\n+{\n+\n+  template <typename ...Ts>\n+  bool sanitize (hb_sanitize_context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    if (unlikely (!c->check_start_recursion (HB_COLRV1_MAX_NESTING_LEVEL)))\n+      return_trace (c->no_dispatch_return_value ());\n+\n+    return_trace (c->end_recursion (this->dispatch (c, std::forward<Ts> (ds)...)));\n+  }\n+\n+  template <typename context_t, typename ...Ts>\n+  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.paintformat1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.paintformat2, std::forward<Ts> (ds)...));\n+    case 3: return_trace (c->dispatch (u.paintformat3, std::forward<Ts> (ds)...));\n+    case 4: return_trace (c->dispatch (u.paintformat4, std::forward<Ts> (ds)...));\n+    case 5: return_trace (c->dispatch (u.paintformat5, std::forward<Ts> (ds)...));\n+    case 6: return_trace (c->dispatch (u.paintformat6, std::forward<Ts> (ds)...));\n+    case 7: return_trace (c->dispatch (u.paintformat7, std::forward<Ts> (ds)...));\n+    case 8: return_trace (c->dispatch (u.paintformat8, std::forward<Ts> (ds)...));\n+    case 9: return_trace (c->dispatch (u.paintformat9, std::forward<Ts> (ds)...));\n+    case 10: return_trace (c->dispatch (u.paintformat10, std::forward<Ts> (ds)...));\n+    case 11: return_trace (c->dispatch (u.paintformat11, std::forward<Ts> (ds)...));\n+    case 12: return_trace (c->dispatch (u.paintformat12, std::forward<Ts> (ds)...));\n+    case 13: return_trace (c->dispatch (u.paintformat13, std::forward<Ts> (ds)...));\n+    case 14: return_trace (c->dispatch (u.paintformat14, std::forward<Ts> (ds)...));\n+    case 15: return_trace (c->dispatch (u.paintformat15, std::forward<Ts> (ds)...));\n+    case 16: return_trace (c->dispatch (u.paintformat16, std::forward<Ts> (ds)...));\n+    case 17: return_trace (c->dispatch (u.paintformat17, std::forward<Ts> (ds)...));\n+    case 18: return_trace (c->dispatch (u.paintformat18, std::forward<Ts> (ds)...));\n+    case 19: return_trace (c->dispatch (u.paintformat19, std::forward<Ts> (ds)...));\n+    case 20: return_trace (c->dispatch (u.paintformat20, std::forward<Ts> (ds)...));\n+    case 21: return_trace (c->dispatch (u.paintformat21, std::forward<Ts> (ds)...));\n+    case 22: return_trace (c->dispatch (u.paintformat22, std::forward<Ts> (ds)...));\n+    case 23: return_trace (c->dispatch (u.paintformat23, std::forward<Ts> (ds)...));\n+    case 24: return_trace (c->dispatch (u.paintformat24, std::forward<Ts> (ds)...));\n+    case 25: return_trace (c->dispatch (u.paintformat25, std::forward<Ts> (ds)...));\n+    case 26: return_trace (c->dispatch (u.paintformat26, std::forward<Ts> (ds)...));\n+    case 27: return_trace (c->dispatch (u.paintformat27, std::forward<Ts> (ds)...));\n+    case 28: return_trace (c->dispatch (u.paintformat28, std::forward<Ts> (ds)...));\n+    case 29: return_trace (c->dispatch (u.paintformat29, std::forward<Ts> (ds)...));\n+    case 30: return_trace (c->dispatch (u.paintformat30, std::forward<Ts> (ds)...));\n+    case 31: return_trace (c->dispatch (u.paintformat31, std::forward<Ts> (ds)...));\n+    case 32: return_trace (c->dispatch (u.paintformat32, std::forward<Ts> (ds)...));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT8                                       format;\n+  PaintColrLayers                               paintformat1;\n+  PaintSolid                                    paintformat2;\n+  Variable<PaintSolid>                          paintformat3;\n+  PaintLinearGradient<NoVariable>               paintformat4;\n+  Variable<PaintLinearGradient<Variable>>       paintformat5;\n+  PaintRadialGradient<NoVariable>               paintformat6;\n+  Variable<PaintRadialGradient<Variable>>       paintformat7;\n+  PaintSweepGradient<NoVariable>                paintformat8;\n+  Variable<PaintSweepGradient<Variable>>        paintformat9;\n+  PaintGlyph                                    paintformat10;\n+  PaintColrGlyph                                paintformat11;\n+  PaintTransform<NoVariable>                    paintformat12;\n+  PaintTransform<Variable>                      paintformat13;\n+  PaintTranslate                                paintformat14;\n+  Variable<PaintTranslate>                      paintformat15;\n+  PaintScale                                    paintformat16;\n+  Variable<PaintScale>                          paintformat17;\n+  PaintScaleAroundCenter                        paintformat18;\n+  Variable<PaintScaleAroundCenter>              paintformat19;\n+  PaintScaleUniform                             paintformat20;\n+  Variable<PaintScaleUniform>                   paintformat21;\n+  PaintScaleUniformAroundCenter                 paintformat22;\n+  Variable<PaintScaleUniformAroundCenter>       paintformat23;\n+  PaintRotate                                   paintformat24;\n+  Variable<PaintRotate>                         paintformat25;\n+  PaintRotateAroundCenter                       paintformat26;\n+  Variable<PaintRotateAroundCenter>             paintformat27;\n+  PaintSkew                                     paintformat28;\n+  Variable<PaintSkew>                           paintformat29;\n+  PaintSkewAroundCenter                         paintformat30;\n+  Variable<PaintSkewAroundCenter>               paintformat31;\n+  PaintComposite                                paintformat32;\n+  } u;\n+};\n+\n+struct BaseGlyphPaintRecord\n@@ -74,1 +1162,14 @@\n-  bool sanitize (hb_sanitize_context_t *c) const\n+  bool serialize (hb_serialize_context_t *s, const hb_map_t* glyph_map,\n+                  const void* src_base, hb_subset_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = s->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (!s->check_assign (out->glyphId, glyph_map->get (glyphId),\n+                          HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+\n+    return_trace (out->paint.serialize_subset (c, paint, src_base));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n@@ -77,1 +1178,1 @@\n-    return_trace (likely (c->check_struct (this)));\n+    return_trace (likely (c->check_struct (this) && paint.sanitize (c, base)));\n@@ -81,8 +1182,3 @@\n-  HBGlyphID     glyphId;        \/* Glyph ID of reference glyph *\/\n-  HBUINT16      firstLayerIdx;  \/* Index (from beginning of\n-                                 * the Layer Records) to the\n-                                 * layer record. There will be\n-                                 * numLayers consecutive entries\n-                                 * for this base glyph. *\/\n-  HBUINT16      numLayers;      \/* Number of color layers\n-                                 * associated with this glyph *\/\n+  HBGlyphID16           glyphId;    \/* Glyph ID of reference glyph *\/\n+  Offset32To<Paint>     paint;      \/* Offset (from beginning of BaseGlyphPaintRecord array) to Paint,\n+                                     * Typically PaintColrLayers *\/\n@@ -93,0 +1189,57 @@\n+struct BaseGlyphList : SortedArray32Of<BaseGlyphPaintRecord>\n+{\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n+    const hb_set_t* glyphset = c->plan->_glyphset_colred;\n+\n+    for (const auto& _ : as_array ())\n+    {\n+      unsigned gid = _.glyphId;\n+      if (!glyphset->has (gid)) continue;\n+\n+      if (_.serialize (c->serializer, c->plan->glyph_map, this, c)) out->len++;\n+      else return_trace (false);\n+    }\n+\n+    return_trace (out->len != 0);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (SortedArray32Of<BaseGlyphPaintRecord>::sanitize (c, this));\n+  }\n+};\n+\n+struct LayerList : Array32OfOffset32To<Paint>\n+{\n+  const Paint& get_paint (unsigned i) const\n+  { return this+(*this)[i]; }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (this);\n+    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n+\n+    for (const auto& _ : + hb_enumerate (*this)\n+                         | hb_filter (c->plan->colrv1_layers, hb_first))\n+\n+    {\n+      auto *o = out->serialize_append (c->serializer);\n+      if (unlikely (!o) || !o->serialize_subset (c, _.second, this))\n+        return_trace (false);\n+    }\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (Array32OfOffset32To<Paint>::sanitize (c, this));\n+  }\n+};\n+\n@@ -120,4 +1273,1 @@\n-    accelerator_t () {}\n-    ~accelerator_t () { fini (); }\n-\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -125,2 +1275,1 @@\n-\n-    void fini () { this->colr.destroy (); }\n+    ~accelerator_t () { this->colr.destroy (); }\n@@ -134,0 +1283,9 @@\n+    void closure_V0palette_indices (const hb_set_t *glyphs,\n+                                    hb_set_t *palettes \/* OUT *\/) const\n+    { colr->closure_V0palette_indices (glyphs, palettes); }\n+\n+    void closure_forV1 (hb_set_t *glyphset,\n+                        hb_set_t *layer_indices,\n+                        hb_set_t *palette_indices) const\n+    { colr->closure_forV1 (glyphset, layer_indices, palette_indices); }\n+\n@@ -150,0 +1308,44 @@\n+  void closure_V0palette_indices (const hb_set_t *glyphs,\n+                                  hb_set_t *palettes \/* OUT *\/) const\n+  {\n+    if (!numBaseGlyphs || !numLayers) return;\n+    hb_array_t<const BaseGlyphRecord> baseGlyphs = (this+baseGlyphsZ).as_array (numBaseGlyphs);\n+    hb_array_t<const LayerRecord> all_layers = (this+layersZ).as_array (numLayers);\n+\n+    for (const BaseGlyphRecord record : baseGlyphs)\n+    {\n+      if (!glyphs->has (record.glyphId)) continue;\n+      hb_array_t<const LayerRecord> glyph_layers = all_layers.sub_array (record.firstLayerIdx,\n+                                                                   record.numLayers);\n+      for (const LayerRecord layer : glyph_layers)\n+        palettes->add (layer.colorIdx);\n+    }\n+  }\n+\n+  void closure_forV1 (hb_set_t *glyphset,\n+                      hb_set_t *layer_indices,\n+                      hb_set_t *palette_indices) const\n+  {\n+    if (version != 1) return;\n+    hb_set_t visited_glyphs;\n+\n+    hb_colrv1_closure_context_t c (this, &visited_glyphs, layer_indices, palette_indices);\n+    const BaseGlyphList &baseglyph_paintrecords = this+baseGlyphList;\n+\n+    for (const BaseGlyphPaintRecord &baseglyph_paintrecord: baseglyph_paintrecords.iter ())\n+    {\n+      unsigned gid = baseglyph_paintrecord.glyphId;\n+      if (!glyphset->has (gid)) continue;\n+\n+      const Paint &paint = &baseglyph_paintrecords+baseglyph_paintrecord.paint;\n+      paint.dispatch (&c);\n+    }\n+    hb_set_union (glyphset, &visited_glyphs);\n+  }\n+\n+  const LayerList& get_layerList () const\n+  { return (this+layerList); }\n+\n+  const BaseGlyphList& get_baseglyphList () const\n+  { return (this+baseGlyphList); }\n+\n@@ -153,3 +1355,10 @@\n-    return_trace (likely (c->check_struct (this) &&\n-                          (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &&\n-                          (this+layersZ).sanitize (c, numLayers)));\n+    return_trace (c->check_struct (this) &&\n+                  (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &&\n+                  (this+layersZ).sanitize (c, numLayers) &&\n+                  (version == 0 ||\n+                   (COLRV1_ENABLE_SUBSETTING && version == 1 &&\n+                    baseGlyphList.sanitize (c, this) &&\n+                    layerList.sanitize (c, this) &&\n+                    clipList.sanitize (c, this) &&\n+                    varIdxMap.sanitize (c, this) &&\n+                    varStore.sanitize (c, this))));\n@@ -161,4 +1370,4 @@\n-  bool serialize (hb_serialize_context_t *c,\n-                  unsigned version,\n-                  BaseIterator base_it,\n-                  LayerIterator layer_it)\n+  bool serialize_V0 (hb_serialize_context_t *c,\n+                     unsigned version,\n+                     BaseIterator base_it,\n+                     LayerIterator layer_it)\n@@ -170,1 +1379,0 @@\n-    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -174,2 +1382,6 @@\n-    baseGlyphsZ = COLR::min_size;\n-    layersZ = COLR::min_size + numBaseGlyphs * BaseGlyphRecord::min_size;\n+    if (numBaseGlyphs == 0)\n+    {\n+      baseGlyphsZ = 0;\n+      layersZ = 0;\n+      return_trace (true);\n+    }\n@@ -177,0 +1389,1 @@\n+    c->push ();\n@@ -184,0 +1397,1 @@\n+    c->add_link (baseGlyphsZ, c->pop_pack ());\n@@ -185,0 +1399,1 @@\n+    c->push ();\n@@ -188,0 +1403,2 @@\n+    c->add_link (layersZ, c->pop_pack ());\n+\n@@ -193,2 +1410,0 @@\n-    if ((unsigned int) gid == 0) \/\/ Ignore notdef.\n-      return nullptr;\n@@ -196,0 +1411,9 @@\n+    if (record == &Null (BaseGlyphRecord) ||\n+        (record && (hb_codepoint_t) record->glyphId != gid))\n+      record = nullptr;\n+    return record;\n+  }\n+\n+  const BaseGlyphPaintRecord* get_base_glyph_paintrecord (hb_codepoint_t gid) const\n+  {\n+    const BaseGlyphPaintRecord* record = &(this+baseGlyphList).bsearch ((unsigned) gid);\n@@ -206,0 +1430,1 @@\n+    const hb_set_t& glyphset = *c->plan->_glyphset_colred;\n@@ -209,0 +1434,6 @@\n+    | hb_filter ([&](hb_codepoint_t new_gid)\n+                 {\n+                    hb_codepoint_t old_gid = reverse_glyph_map.get (new_gid);\n+                    if (glyphset.has (old_gid)) return true;\n+                    return false;\n+                 })\n@@ -216,1 +1447,0 @@\n-\n@@ -229,0 +1459,1 @@\n+    | hb_filter (glyphset)\n@@ -248,0 +1479,1 @@\n+                                  out_layers[i].colorIdx = c->plan->colr_palettes->get (layers[i].colorIdx);\n@@ -256,1 +1488,1 @@\n-    if (unlikely (!base_it || !layer_it || base_it.len () != layer_it.len ()))\n+    if (version == 0 && (!base_it || !layer_it))\n@@ -260,1 +1492,22 @@\n-    return_trace (colr_prime->serialize (c->serializer, version, base_it, layer_it));\n+    if (unlikely (!c->serializer->extend_min (colr_prime)))  return_trace (false);\n+\n+    if (version == 0)\n+    return_trace (colr_prime->serialize_V0 (c->serializer, version, base_it, layer_it));\n+\n+    auto snap = c->serializer->snapshot ();\n+    if (!c->serializer->allocate_size<void> (5 * HBUINT32::static_size)) return_trace (false);\n+    if (!colr_prime->baseGlyphList.serialize_subset (c, baseGlyphList, this))\n+    {\n+      if (c->serializer->in_error ()) return_trace (false);\n+      \/\/no more COLRv1 glyphs: downgrade to version 0\n+      c->serializer->revert (snap);\n+      return_trace (colr_prime->serialize_V0 (c->serializer, 0, base_it, layer_it));\n+    }\n+\n+    if (!colr_prime->serialize_V0 (c->serializer, version, base_it, layer_it)) return_trace (false);\n+\n+    colr_prime->layerList.serialize_subset (c, layerList, this);\n+    colr_prime->clipList.serialize_subset (c, clipList, this);\n+    colr_prime->varIdxMap.serialize_copy (c->serializer, varIdxMap, this);\n+    \/\/TODO: subset varStore once it's implemented in fonttools\n+    return_trace (true);\n@@ -266,1 +1519,1 @@\n-  LNNOffsetTo<SortedUnsizedArrayOf<BaseGlyphRecord>>\n+  NNOffset32To<SortedUnsizedArrayOf<BaseGlyphRecord>>\n@@ -268,1 +1521,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<LayerRecord>>\n+  NNOffset32To<UnsizedArrayOf<LayerRecord>>\n@@ -271,0 +1524,6 @@\n+  \/\/ Version-1 additions\n+  Offset32To<BaseGlyphList>             baseGlyphList;\n+  Offset32To<LayerList>                 layerList;\n+  Offset32To<ClipList>                  clipList;   \/\/ Offset to ClipList table (may be NULL)\n+  Offset32To<DeltaSetIndexMap>          varIdxMap;  \/\/ Offset to DeltaSetIndexMap table (may be NULL)\n+  Offset32To<VariationStore>            varStore;\n@@ -272,1 +1531,5 @@\n-  DEFINE_SIZE_STATIC (14);\n+  DEFINE_SIZE_MIN (14);\n+};\n+\n+struct COLR_accelerator_t : COLR::accelerator_t {\n+  COLR_accelerator_t (hb_face_t *face) : COLR::accelerator_t (face) {}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-colr-table.hh","additions":1312,"deletions":49,"binary":false,"changes":1361,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright  2018  Ebrahim Byagowi\n+ * Copyright  2020  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ *\/\n+\n+#ifndef HB_OT_COLR_COLRV1_CLOSURE_HH\n+#define HB_OT_COLR_COLRV1_CLOSURE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-layout-common.hh\"\n+#include \"hb-ot-color-colr-table.hh\"\n+\n+\/*\n+ * COLR -- Color\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n+ *\/\n+namespace OT {\n+\n+HB_INTERNAL void PaintColrLayers::closurev1 (hb_colrv1_closure_context_t* c) const\n+{\n+  c->add_layer_indices (firstLayerIndex, numLayers);\n+  const LayerList &paint_offset_lists = c->get_colr_table ()->get_layerList ();\n+  for (unsigned i = firstLayerIndex; i < firstLayerIndex + numLayers; i++)\n+  {\n+    const Paint &paint = std::addressof (paint_offset_lists) + paint_offset_lists[i];\n+    paint.dispatch (c);\n+  }\n+}\n+\n+HB_INTERNAL void PaintGlyph::closurev1 (hb_colrv1_closure_context_t* c) const\n+{\n+  c->add_glyph (gid);\n+  (this+paint).dispatch (c);\n+}\n+\n+HB_INTERNAL void PaintColrGlyph::closurev1 (hb_colrv1_closure_context_t* c) const\n+{\n+  const COLR *colr_table = c->get_colr_table ();\n+  const BaseGlyphPaintRecord* baseglyph_paintrecord = colr_table->get_base_glyph_paintrecord (gid);\n+  if (!baseglyph_paintrecord) return;\n+  c->add_glyph (gid);\n+\n+  const BaseGlyphList &baseglyph_list = colr_table->get_baseglyphList ();\n+  (&baseglyph_list+baseglyph_paintrecord->paint).dispatch (c);\n+}\n+\n+template <template<typename> class Var>\n+HB_INTERNAL void PaintTransform<Var>::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintTranslate::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintScale::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintScaleAroundCenter::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintScaleUniform::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintScaleUniformAroundCenter::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintRotate::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintRotateAroundCenter::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintSkew::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintSkewAroundCenter::closurev1 (hb_colrv1_closure_context_t* c) const\n+{ (this+src).dispatch (c); }\n+\n+HB_INTERNAL void PaintComposite::closurev1 (hb_colrv1_closure_context_t* c) const\n+{\n+  (this+src).dispatch (c);\n+  (this+backdrop).dispatch (c);\n+}\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_COLR_COLRV1_CLOSURE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-colrv1-closure.hh","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -42,1 +42,0 @@\n-\n@@ -77,0 +76,39 @@\n+  bool serialize (hb_serialize_context_t *c,\n+                  unsigned palette_count,\n+                  unsigned color_count,\n+                  const void *base,\n+                  const hb_map_t *color_index_map) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->allocate_size<CPALV1Tail> (static_size);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    out->paletteFlagsZ = 0;\n+    if (paletteFlagsZ)\n+      out->paletteFlagsZ.serialize_copy (c, paletteFlagsZ, base, 0, hb_serialize_context_t::Head, palette_count);\n+\n+    out->paletteLabelsZ = 0;\n+    if (paletteLabelsZ)\n+      out->paletteLabelsZ.serialize_copy (c, paletteLabelsZ, base, 0, hb_serialize_context_t::Head, palette_count);\n+\n+    const hb_array_t<const NameID> colorLabels = (base+colorLabelsZ).as_array (color_count);\n+    if (colorLabelsZ)\n+    {\n+      c->push ();\n+      for (const auto _ : colorLabels)\n+      {\n+        const hb_codepoint_t *v;\n+        if (!color_index_map->has (_, &v)) continue;\n+        NameID new_color_idx;\n+        new_color_idx = *v;\n+        if (!c->copy<NameID> (new_color_idx))\n+        {\n+          c->pop_discard ();\n+          return_trace (false);\n+        }\n+      }\n+      c->add_link (out->colorLabelsZ, c->pop_pack ());\n+    }\n+    return_trace (true);\n+  }\n+\n@@ -90,1 +128,3 @@\n-  LNNOffsetTo<UnsizedArrayOf<HBUINT32>>\n+  \/\/ TODO(garretrieger): these offsets can hold nulls so we should not be using non-null offsets\n+  \/\/                     here. Currently they are needed since UnsizedArrayOf doesn't define null_size\n+  NNOffset32To<UnsizedArrayOf<HBUINT32>>\n@@ -94,1 +134,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<NameID>>\n+  NNOffset32To<UnsizedArrayOf<NameID>>\n@@ -98,1 +138,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<NameID>>\n+  NNOffset32To<UnsizedArrayOf<NameID>>\n@@ -160,0 +200,92 @@\n+  bool serialize (hb_serialize_context_t *c,\n+                  const hb_array_t<const HBUINT16> &color_record_indices,\n+                  const hb_array_t<const BGRAColor> &color_records,\n+                  const hb_vector_t<unsigned>& first_color_index_for_layer,\n+                  const hb_map_t& first_color_to_layer_index,\n+                  const hb_set_t &retained_color_indices) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    \/\/ TODO(grieger): limit total final size.\n+\n+    for (const auto idx : color_record_indices)\n+    {\n+      hb_codepoint_t layer_index = first_color_to_layer_index[idx];\n+\n+      HBUINT16 new_idx;\n+      new_idx = layer_index * retained_color_indices.get_population ();\n+      if (!c->copy<HBUINT16> (new_idx)) return_trace (false);\n+    }\n+\n+    c->push ();\n+    for (unsigned first_color_index : first_color_index_for_layer)\n+    {\n+      for (hb_codepoint_t color_index : retained_color_indices)\n+      {\n+        if (!c->copy<BGRAColor> (color_records[first_color_index + color_index]))\n+        {\n+          c->pop_discard ();\n+          return_trace (false);\n+        }\n+      }\n+    }\n+\n+    c->add_link (colorRecordsZ, c->pop_pack ());\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    if (!numPalettes) return_trace (false);\n+\n+    const hb_map_t *color_index_map = c->plan->colr_palettes;\n+    if (color_index_map->is_empty ()) return_trace (false);\n+\n+    hb_set_t retained_color_indices;\n+    for (const auto _ : color_index_map->keys ())\n+    {\n+      if (_ == 0xFFFF) continue;\n+      retained_color_indices.add (_);\n+    }\n+    if (retained_color_indices.is_empty ()) return_trace (false);\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+\n+    out->version = version;\n+    out->numColors = retained_color_indices.get_population ();\n+    out->numPalettes = numPalettes;\n+\n+    hb_vector_t<unsigned> first_color_index_for_layer;\n+    hb_map_t first_color_to_layer_index;\n+\n+    const hb_array_t<const HBUINT16> colorRecordIndices = colorRecordIndicesZ.as_array (numPalettes);\n+    for (const auto first_color_record_idx : colorRecordIndices)\n+    {\n+      if (first_color_to_layer_index.has (first_color_record_idx)) continue;\n+\n+      first_color_index_for_layer.push (first_color_record_idx);\n+      first_color_to_layer_index.set (first_color_record_idx,\n+                                      first_color_index_for_layer.length - 1);\n+    }\n+\n+    out->numColorRecords = first_color_index_for_layer.length\n+                           * retained_color_indices.get_population ();\n+\n+    const hb_array_t<const BGRAColor> color_records = (this+colorRecordsZ).as_array (numColorRecords);\n+    if (!out->serialize (c->serializer,\n+                         colorRecordIndices,\n+                         color_records,\n+                         first_color_index_for_layer,\n+                         first_color_to_layer_index,\n+                         retained_color_indices))\n+      return_trace (false);\n+\n+    if (version == 1)\n+      return_trace (v1 ().serialize (c->serializer, numPalettes, numColors, this, color_index_map));\n+\n+    return_trace (true);\n+  }\n+\n@@ -176,1 +308,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<BGRAColor>>\n+  NNOffset32To<UnsizedArrayOf<BGRAColor>>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-cpal-table.hh","additions":137,"deletions":5,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-    if (unlikely (!c->serializer->extend (*out, num_output_glyphs + 1))) return_trace (false);\n+    if (unlikely (!c->serializer->extend (out, num_output_glyphs + 1))) return_trace (false);\n@@ -188,1 +188,1 @@\n-  UnsizedArrayOf<LOffsetTo<SBIXGlyph>>\n+  UnsizedArrayOf<Offset32To<SBIXGlyph>>\n@@ -205,1 +205,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -210,1 +210,1 @@\n-    void fini () { table.destroy (); }\n+    ~accelerator_t () { table.destroy (); }\n@@ -301,0 +301,6 @@\n+      if (png.IHDR.height >= 65536 || png.IHDR.width >= 65536)\n+      {\n+        hb_blob_destroy (blob);\n+        return false;\n+      }\n+\n@@ -355,1 +361,1 @@\n-    auto *out = c->serializer->start_embed<LOffsetLArrayOf<SBIXStrike>> ();\n+    auto *out = c->serializer->start_embed<Array32OfOffset32To<SBIXStrike>> ();\n@@ -359,1 +365,1 @@\n-    hb_vector_t<LOffsetTo<SBIXStrike>*> new_strikes;\n+    hb_vector_t<Offset32To<SBIXStrike>*> new_strikes;\n@@ -403,1 +409,1 @@\n-  LOffsetLArrayOf<SBIXStrike>\n+  Array32OfOffset32To<SBIXStrike>\n@@ -410,1 +416,4 @@\n-struct sbix_accelerator_t : sbix::accelerator_t {};\n+struct sbix_accelerator_t : sbix::accelerator_t {\n+  sbix_accelerator_t (hb_face_t *face) : sbix::accelerator_t (face) {}\n+};\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-sbix-table.hh","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<HBUINT8>>\n+  NNOffset32To<UnsizedArrayOf<HBUINT8>>\n@@ -82,1 +82,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -84,1 +84,1 @@\n-    void fini () { table.destroy (); }\n+    ~accelerator_t () { table.destroy (); }\n@@ -110,1 +110,1 @@\n-  LOffsetTo<SortedArrayOf<SVGDocumentIndexEntry>>\n+  Offset32To<SortedArray16Of<SVGDocumentIndexEntry>>\n@@ -119,1 +119,3 @@\n-struct SVG_accelerator_t : SVG::accelerator_t {};\n+struct SVG_accelerator_t : SVG::accelerator_t {\n+  SVG_accelerator_t (hb_face_t *face) : SVG::accelerator_t (face) {}\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color-svg-table.hh","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n- * the specificed color in a face's `CPAL` color palette.\n+ * the specified color in a face's `CPAL` color palette.\n@@ -259,0 +259,2 @@\n+ * If the glyph has no SVG document, the singleton empty blob is returned.\n+ *\n@@ -299,0 +301,2 @@\n+ * If the glyph has no PNG image, the singleton empty blob is returned.\n+ *\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-color.cc","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,0 +53,15 @@\n+\/* https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/3417 *\/\n+\/**\n+ * HB_OT_MATH_SCRIPT:\n+ *\n+ * Use #HB_SCRIPT_MATH or #HB_OT_TAG_MATH_SCRIPT instead.\n+ *\n+ * <note>Previous versions of this documentation recommended passing\n+ * #HB_OT_MATH_SCRIPT to hb_buffer_set_script() to enable math shaping, but this\n+ * usage is no longer supported. Use #HB_SCRIPT_MATH instead.<\/note>\n+ *\n+ * Since: 1.3.3\n+ * Deprecated: 3.4.0\n+ *\/\n+#define HB_OT_MATH_SCRIPT HB_OT_TAG_MATH_SCRIPT\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-deprecated.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+#ifndef HB_OT_CORE_TABLE\n+#define HB_OT_CORE_TABLE(Namespace, Type) HB_OT_TABLE (Namespace, Type)\n+#define _HB_OT_CORE_TABLE_UNDEF\n+#endif\n+\n@@ -43,1 +48,1 @@\n- * exactly free. *\/\n+ * exactly zero-cost. *\/\n@@ -49,1 +54,2 @@\n-HB_OT_TABLE (OT, head)\n+HB_OT_CORE_TABLE (OT, head)\n+HB_OT_CORE_TABLE (OT, maxp)\n@@ -70,0 +76,1 @@\n+#ifndef HB_NO_VERTICAL\n@@ -72,0 +79,2 @@\n+HB_OT_TABLE (OT, VORG)\n+#endif\n@@ -74,0 +83,1 @@\n+HB_OT_CORE_TABLE (OT, loca) \/\/ Also used to determine number of glyphs\n@@ -80,1 +90,0 @@\n-HB_OT_TABLE (OT, VORG)\n@@ -139,0 +148,4 @@\n+\n+#ifdef _HB_OT_CORE_TABLE_UNDEF\n+#undef HB_OT_CORE_TABLE\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-face-table-list.hh","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+#define HB_OT_CORE_TABLE(Namespace, Type) \\\n+  hb_table_lazy_loader_t<Namespace::Type, HB_OT_TABLE_ORDER (Namespace, Type), true> Type;\n@@ -70,0 +72,1 @@\n+#undef HB_OT_CORE_TABLE\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-face.hh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"hb-cache.hh\"\n@@ -61,0 +62,35 @@\n+struct hb_ot_font_t\n+{\n+  const hb_ot_face_t *ot_face;\n+\n+  \/* h_advance caching *\/\n+  mutable hb_atomic_int_t cached_coords_serial;\n+  mutable hb_atomic_ptr_t<hb_advance_cache_t> advance_cache;\n+};\n+\n+static hb_ot_font_t *\n+_hb_ot_font_create (hb_font_t *font)\n+{\n+  hb_ot_font_t *ot_font = (hb_ot_font_t *) hb_calloc (1, sizeof (hb_ot_font_t));\n+  if (unlikely (!ot_font))\n+    return nullptr;\n+\n+  ot_font->ot_face = &font->face->table;\n+\n+  return ot_font;\n+}\n+\n+static void\n+_hb_ot_font_destroy (void *font_data)\n+{\n+  hb_ot_font_t *ot_font = (hb_ot_font_t *) font_data;\n+\n+  auto *cache = ot_font->advance_cache.get_relaxed ();\n+  if (cache)\n+  {\n+    cache->fini ();\n+    hb_free (cache);\n+  }\n+\n+  hb_free (ot_font);\n+}\n@@ -69,1 +105,2 @@\n-  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const hb_ot_font_t *ot_font = (const hb_ot_font_t *) font_data;\n+  const hb_ot_face_t *ot_face = ot_font->ot_face;\n@@ -83,1 +120,2 @@\n-  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const hb_ot_font_t *ot_font = (const hb_ot_font_t *) font_data;\n+  const hb_ot_face_t *ot_face = ot_font->ot_face;\n@@ -97,1 +135,2 @@\n-  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const hb_ot_font_t *ot_font = (const hb_ot_font_t *) font_data;\n+  const hb_ot_face_t *ot_face = ot_font->ot_face;\n@@ -110,1 +149,2 @@\n-  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const hb_ot_font_t *ot_font = (const hb_ot_font_t *) font_data;\n+  const hb_ot_face_t *ot_face = ot_font->ot_face;\n@@ -113,1 +153,37 @@\n-  for (unsigned int i = 0; i < count; i++)\n+#ifndef HB_NO_VAR\n+  const OT::HVARVVAR &HVAR = *hmtx.var_table;\n+  const OT::VariationStore &varStore = &HVAR + HVAR.varStore;\n+  OT::VariationStore::cache_t *varStore_cache = font->num_coords * count >= 128 ? varStore.create_cache () : nullptr;\n+\n+  bool use_cache = font->num_coords;\n+#else\n+  OT::VariationStore::cache_t *varStore_cache = nullptr;\n+  bool use_cache = false;\n+#endif\n+\n+  hb_advance_cache_t *cache = nullptr;\n+  if (use_cache)\n+  {\n+  retry:\n+    cache = ot_font->advance_cache.get ();\n+    if (unlikely (!cache))\n+    {\n+      cache = (hb_advance_cache_t *) hb_malloc (sizeof (hb_advance_cache_t));\n+      if (unlikely (!cache))\n+      {\n+        use_cache = false;\n+        goto out;\n+      }\n+\n+      cache->init ();\n+      if (unlikely (!ot_font->advance_cache.cmpexch (nullptr, cache)))\n+      {\n+        hb_free (cache);\n+        goto retry;\n+      }\n+      ot_font->cached_coords_serial.set (font->serial_coords);\n+    }\n+  }\n+  out:\n+\n+  if (!use_cache)\n@@ -115,3 +191,30 @@\n-    *first_advance = font->em_scale_x (hmtx.get_advance (*first_glyph, font));\n-    first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n-    first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      *first_advance = font->em_scale_x (hmtx.get_advance (*first_glyph, font, varStore_cache));\n+      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    }\n+  }\n+  else\n+  { \/* Use cache. *\/\n+    if (ot_font->cached_coords_serial.get () != (int) font->serial_coords)\n+    {\n+      ot_font->advance_cache->init ();\n+      ot_font->cached_coords_serial.set (font->serial_coords);\n+    }\n+\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      hb_position_t v;\n+      unsigned cv;\n+      if (ot_font->advance_cache->get (*first_glyph, &cv))\n+        v = cv;\n+      else\n+      {\n+        v = hmtx.get_advance (*first_glyph, font, varStore_cache);\n+        ot_font->advance_cache->set (*first_glyph, v);\n+      }\n+      *first_advance = font->em_scale_x (v);\n+      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    }\n@@ -119,0 +222,4 @@\n+\n+#ifndef HB_NO_VAR\n+  OT::VariationStore::destroy_cache (varStore_cache);\n+#endif\n@@ -121,0 +228,1 @@\n+#ifndef HB_NO_VERTICAL\n@@ -130,1 +238,2 @@\n-  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const hb_ot_font_t *ot_font = (const hb_ot_font_t *) font_data;\n+  const hb_ot_face_t *ot_face = ot_font->ot_face;\n@@ -133,1 +242,1 @@\n-  for (unsigned int i = 0; i < count; i++)\n+  if (vmtx.has_data ())\n@@ -135,3 +244,31 @@\n-    *first_advance = font->em_scale_y (-(int) vmtx.get_advance (*first_glyph, font));\n-    first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n-    first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+#ifndef HB_NO_VAR\n+    const OT::HVARVVAR &VVAR = *vmtx.var_table;\n+    const OT::VariationStore &varStore = &VVAR + VVAR.varStore;\n+    OT::VariationStore::cache_t *varStore_cache = font->num_coords ? varStore.create_cache () : nullptr;\n+#else\n+    OT::VariationStore::cache_t *varStore_cache = nullptr;\n+#endif\n+\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      *first_advance = font->em_scale_y (-(int) vmtx.get_advance (*first_glyph, font, varStore_cache));\n+      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    }\n+\n+#ifndef HB_NO_VAR\n+    OT::VariationStore::destroy_cache (varStore_cache);\n+#endif\n+  }\n+  else\n+  {\n+    hb_font_extents_t font_extents;\n+    font->get_h_extents_with_fallback (&font_extents);\n+    hb_position_t advance = -(font_extents.ascender - font_extents.descender);\n+\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      *first_advance = advance;\n+      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    }\n@@ -140,0 +277,1 @@\n+#endif\n@@ -141,0 +279,1 @@\n+#ifndef HB_NO_VERTICAL\n@@ -149,1 +288,2 @@\n-  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const hb_ot_font_t *ot_font = (const hb_ot_font_t *) font_data;\n+  const hb_ot_face_t *ot_face = ot_font->ot_face;\n@@ -153,1 +293,0 @@\n-#ifndef HB_NO_OT_FONT_CFF\n@@ -160,1 +299,0 @@\n-#endif\n@@ -165,3 +303,13 @@\n-    const OT::vmtx_accelerator_t &vmtx = *ot_face->vmtx;\n-    hb_position_t tsb = vmtx.get_side_bearing (font, glyph);\n-    *y = extents.y_bearing + font->em_scale_y (tsb);\n+    if (ot_face->vmtx->has_data ())\n+    {\n+      const OT::vmtx_accelerator_t &vmtx = *ot_face->vmtx;\n+      hb_position_t tsb = vmtx.get_side_bearing (font, glyph);\n+      *y = extents.y_bearing + font->em_scale_y (tsb);\n+      return true;\n+    }\n+\n+    hb_font_extents_t font_extents;\n+    font->get_h_extents_with_fallback (&font_extents);\n+    hb_position_t advance = font_extents.ascender - font_extents.descender;\n+    int diff = advance - -extents.height;\n+    *y = extents.y_bearing + (diff >> 1);\n@@ -177,0 +325,1 @@\n+#endif\n@@ -185,1 +334,2 @@\n-  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const hb_ot_font_t *ot_font = (const hb_ot_font_t *) font_data;\n+  const hb_ot_face_t *ot_face = ot_font->ot_face;\n@@ -211,1 +361,3 @@\n-  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const hb_ot_font_t *ot_font = (const hb_ot_font_t *) font_data;\n+  const hb_ot_face_t *ot_face = ot_font->ot_face;\n+\n@@ -225,1 +377,3 @@\n-  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const hb_ot_font_t *ot_font = (const hb_ot_font_t *) font_data;\n+  const hb_ot_face_t *ot_face = ot_font->ot_face;\n+\n@@ -245,0 +399,1 @@\n+#ifndef HB_NO_VERTICAL\n@@ -255,0 +410,1 @@\n+#endif\n@@ -256,2 +412,13 @@\n-#if HB_USE_ATEXIT\n-static void free_static_ot_funcs ();\n+#ifndef HB_NO_DRAW\n+static void\n+hb_ot_get_glyph_shape (hb_font_t *font,\n+                       void *font_data HB_UNUSED,\n+                       hb_codepoint_t glyph,\n+                       hb_draw_funcs_t *draw_funcs, void *draw_data,\n+                       void *user_data)\n+{\n+  hb_draw_session_t draw_session (draw_funcs, draw_data, font->slant_xy);\n+  if (font->face->table.glyf->get_path (font, glyph, draw_session)) return;\n+#ifndef HB_NO_CFF\n+  if (font->face->table.cff1->get_path (font, glyph, draw_session)) return;\n+  if (font->face->table.cff2->get_path (font, glyph, draw_session)) return;\n@@ -259,0 +426,4 @@\n+}\n+#endif\n+\n+static inline void free_static_ot_funcs ();\n@@ -266,2 +437,0 @@\n-    hb_font_funcs_set_font_h_extents_func (funcs, hb_ot_get_font_h_extents, nullptr, nullptr);\n-    hb_font_funcs_set_font_v_extents_func (funcs, hb_ot_get_font_v_extents, nullptr, nullptr);\n@@ -271,0 +440,2 @@\n+\n+    hb_font_funcs_set_font_h_extents_func (funcs, hb_ot_get_font_h_extents, nullptr, nullptr);\n@@ -272,1 +443,0 @@\n-    hb_font_funcs_set_glyph_v_advances_func (funcs, hb_ot_get_glyph_v_advances, nullptr, nullptr);\n@@ -274,0 +444,4 @@\n+\n+#ifndef HB_NO_VERTICAL\n+    hb_font_funcs_set_font_v_extents_func (funcs, hb_ot_get_font_v_extents, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_v_advances_func (funcs, hb_ot_get_glyph_v_advances, nullptr, nullptr);\n@@ -275,0 +449,6 @@\n+#endif\n+\n+#ifndef HB_NO_DRAW\n+    hb_font_funcs_set_glyph_shape_func (funcs, hb_ot_get_glyph_shape, nullptr, nullptr);\n+#endif\n+\n@@ -277,0 +457,1 @@\n+\n@@ -284,3 +465,1 @@\n-#if HB_USE_ATEXIT\n-    atexit (free_static_ot_funcs);\n-#endif\n+    hb_atexit (free_static_ot_funcs);\n@@ -292,2 +471,1 @@\n-#if HB_USE_ATEXIT\n-static\n+static inline\n@@ -298,1 +476,0 @@\n-#endif\n@@ -318,0 +495,4 @@\n+  hb_ot_font_t *ot_font = _hb_ot_font_create (font);\n+  if (unlikely (!ot_font))\n+    return;\n+\n@@ -320,2 +501,2 @@\n-                     &font->face->table,\n-                     nullptr);\n+                     ot_font,\n+                     _hb_ot_font_destroy);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-font.cc","additions":216,"deletions":35,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  ArrayOf<GaspRange>\n+  Array16Of<GaspRange>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-gasp-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1227 +33,1 @@\n-#include \"hb-open-type.hh\"\n-#include \"hb-ot-head-table.hh\"\n-#include \"hb-ot-hmtx-table.hh\"\n-#include \"hb-ot-var-gvar-table.hh\"\n-#include \"hb-draw.hh\"\n-\n-namespace OT {\n-\n-\n-\/*\n- * loca -- Index to Location\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/loca\n- *\/\n-#define HB_OT_TAG_loca HB_TAG('l','o','c','a')\n-\n-\n-struct loca\n-{\n-  friend struct glyf;\n-\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_loca;\n-\n-  bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (true);\n-  }\n-\n-  protected:\n-  UnsizedArrayOf<HBUINT8>\n-                dataZ;  \/* Location data. *\/\n-  public:\n-  DEFINE_SIZE_MIN (0);  \/* In reality, this is UNBOUNDED() type; but since we always\n-                         * check the size externally, allow Null() object of it by\n-                         * defining it _MIN instead. *\/\n-};\n-\n-\n-\/*\n- * glyf -- TrueType Glyph Data\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/glyf\n- *\/\n-#define HB_OT_TAG_glyf HB_TAG('g','l','y','f')\n-\n-\n-struct glyf\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_glyf;\n-\n-  bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const\n-  {\n-    TRACE_SANITIZE (this);\n-    \/* Runtime checks as eager sanitizing each glyph is costy *\/\n-    return_trace (true);\n-  }\n-\n-  template<typename Iterator,\n-           hb_requires (hb_is_source_of (Iterator, unsigned int))>\n-  static bool\n-  _add_loca_and_head (hb_subset_plan_t * plan, Iterator padded_offsets)\n-  {\n-    unsigned max_offset =\n-    + padded_offsets\n-    | hb_reduce (hb_add, 0)\n-    ;\n-    unsigned num_offsets = padded_offsets.len () + 1;\n-    bool use_short_loca = max_offset < 0x1FFFF;\n-    unsigned entry_size = use_short_loca ? 2 : 4;\n-    char *loca_prime_data = (char *) calloc (entry_size, num_offsets);\n-\n-    if (unlikely (!loca_prime_data)) return false;\n-\n-    DEBUG_MSG (SUBSET, nullptr, \"loca entry_size %d num_offsets %d \"\n-                                \"max_offset %d size %d\",\n-               entry_size, num_offsets, max_offset, entry_size * num_offsets);\n-\n-    if (use_short_loca)\n-      _write_loca (padded_offsets, 1, hb_array ((HBUINT16 *) loca_prime_data, num_offsets));\n-    else\n-      _write_loca (padded_offsets, 0, hb_array ((HBUINT32 *) loca_prime_data, num_offsets));\n-\n-    hb_blob_t *loca_blob = hb_blob_create (loca_prime_data,\n-                                           entry_size * num_offsets,\n-                                           HB_MEMORY_MODE_WRITABLE,\n-                                           loca_prime_data,\n-                                           free);\n-\n-    bool result = plan->add_table (HB_OT_TAG_loca, loca_blob)\n-               && _add_head_and_set_loca_version (plan, use_short_loca);\n-\n-    hb_blob_destroy (loca_blob);\n-    return result;\n-  }\n-\n-  template<typename IteratorIn, typename IteratorOut,\n-           hb_requires (hb_is_source_of (IteratorIn, unsigned int)),\n-           hb_requires (hb_is_sink_of (IteratorOut, unsigned))>\n-  static void\n-  _write_loca (IteratorIn it, unsigned right_shift, IteratorOut dest)\n-  {\n-    unsigned int offset = 0;\n-    dest << 0;\n-    + it\n-    | hb_map ([=, &offset] (unsigned int padded_size)\n-              {\n-                offset += padded_size;\n-                DEBUG_MSG (SUBSET, nullptr, \"loca entry offset %d\", offset);\n-                return offset >> right_shift;\n-              })\n-    | hb_sink (dest)\n-    ;\n-  }\n-\n-  \/* requires source of SubsetGlyph complains the identifier isn't declared *\/\n-  template <typename Iterator>\n-  bool serialize (hb_serialize_context_t *c,\n-                  Iterator it,\n-                  const hb_subset_plan_t *plan)\n-  {\n-    TRACE_SERIALIZE (this);\n-    unsigned init_len = c->length ();\n-    for (const auto &_ : it) _.serialize (c, plan);\n-\n-    \/* As a special case when all glyph in the font are empty, add a zero byte\n-     * to the table, so that OTS doesnt reject it, and to make the table work\n-     * on Windows as well.\n-     * See https:\/\/github.com\/khaledhosny\/ots\/issues\/52 *\/\n-    if (init_len == c->length ())\n-    {\n-      HBUINT8 empty_byte;\n-      empty_byte = 0;\n-      c->copy (empty_byte);\n-    }\n-    return_trace (true);\n-  }\n-\n-  \/* Byte region(s) per glyph to output\n-     unpadded, hints removed if so requested\n-     If we fail to process a glyph we produce an empty (0-length) glyph *\/\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-\n-    glyf *glyf_prime = c->serializer->start_embed <glyf> ();\n-    if (unlikely (!c->serializer->check_success (glyf_prime))) return_trace (false);\n-\n-    hb_vector_t<SubsetGlyph> glyphs;\n-    _populate_subset_glyphs (c->plan, &glyphs);\n-\n-    glyf_prime->serialize (c->serializer, hb_iter (glyphs), c->plan);\n-\n-    auto padded_offsets =\n-    + hb_iter (glyphs)\n-    | hb_map (&SubsetGlyph::padded_size)\n-    ;\n-\n-    if (unlikely (c->serializer->in_error ())) return_trace (false);\n-    return_trace (c->serializer->check_success (_add_loca_and_head (c->plan,\n-                                                                    padded_offsets)));\n-  }\n-\n-  template <typename SubsetGlyph>\n-  void\n-  _populate_subset_glyphs (const hb_subset_plan_t   *plan,\n-                           hb_vector_t<SubsetGlyph> *glyphs \/* OUT *\/) const\n-  {\n-    OT::glyf::accelerator_t glyf;\n-    glyf.init (plan->source);\n-\n-    + hb_range (plan->num_output_glyphs ())\n-    | hb_map ([&] (hb_codepoint_t new_gid)\n-              {\n-                SubsetGlyph subset_glyph = {0};\n-                subset_glyph.new_gid = new_gid;\n-\n-                \/* should never fail: all old gids should be mapped *\/\n-                if (!plan->old_gid_for_new_gid (new_gid, &subset_glyph.old_gid))\n-                  return subset_glyph;\n-\n-                subset_glyph.source_glyph = glyf.glyph_for_gid (subset_glyph.old_gid, true);\n-                if (plan->drop_hints) subset_glyph.drop_hints_bytes ();\n-                else subset_glyph.dest_start = subset_glyph.source_glyph.get_bytes ();\n-\n-                return subset_glyph;\n-              })\n-    | hb_sink (glyphs)\n-    ;\n-\n-    glyf.fini ();\n-  }\n-\n-  static bool\n-  _add_head_and_set_loca_version (hb_subset_plan_t *plan, bool use_short_loca)\n-  {\n-    hb_blob_t *head_blob = hb_sanitize_context_t ().reference_table<head> (plan->source);\n-    hb_blob_t *head_prime_blob = hb_blob_copy_writable_or_fail (head_blob);\n-    hb_blob_destroy (head_blob);\n-\n-    if (unlikely (!head_prime_blob))\n-      return false;\n-\n-    head *head_prime = (head *) hb_blob_get_data_writable (head_prime_blob, nullptr);\n-    head_prime->indexToLocFormat = use_short_loca ? 0 : 1;\n-    bool success = plan->add_table (HB_OT_TAG_head, head_prime_blob);\n-\n-    hb_blob_destroy (head_prime_blob);\n-    return success;\n-  }\n-\n-  struct CompositeGlyphChain\n-  {\n-    protected:\n-    enum composite_glyph_flag_t\n-    {\n-      ARG_1_AND_2_ARE_WORDS     = 0x0001,\n-      ARGS_ARE_XY_VALUES        = 0x0002,\n-      ROUND_XY_TO_GRID          = 0x0004,\n-      WE_HAVE_A_SCALE           = 0x0008,\n-      MORE_COMPONENTS           = 0x0020,\n-      WE_HAVE_AN_X_AND_Y_SCALE  = 0x0040,\n-      WE_HAVE_A_TWO_BY_TWO      = 0x0080,\n-      WE_HAVE_INSTRUCTIONS      = 0x0100,\n-      USE_MY_METRICS            = 0x0200,\n-      OVERLAP_COMPOUND          = 0x0400,\n-      SCALED_COMPONENT_OFFSET   = 0x0800,\n-      UNSCALED_COMPONENT_OFFSET = 0x1000\n-    };\n-\n-    public:\n-    unsigned int get_size () const\n-    {\n-      unsigned int size = min_size;\n-      \/* arg1 and 2 are int16 *\/\n-      if (flags & ARG_1_AND_2_ARE_WORDS) size += 4;\n-      \/* arg1 and 2 are int8 *\/\n-      else size += 2;\n-\n-      \/* One x 16 bit (scale) *\/\n-      if (flags & WE_HAVE_A_SCALE) size += 2;\n-      \/* Two x 16 bit (xscale, yscale) *\/\n-      else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) size += 4;\n-      \/* Four x 16 bit (xscale, scale01, scale10, yscale) *\/\n-      else if (flags & WE_HAVE_A_TWO_BY_TWO) size += 8;\n-\n-      return size;\n-    }\n-\n-    void set_glyph_index (hb_codepoint_t new_gid) { glyphIndex = new_gid; }\n-    hb_codepoint_t get_glyph_index ()       const { return glyphIndex; }\n-\n-    void drop_instructions_flag ()  { flags = (uint16_t) flags & ~WE_HAVE_INSTRUCTIONS; }\n-    bool has_instructions ()  const { return   flags & WE_HAVE_INSTRUCTIONS; }\n-\n-    bool has_more ()          const { return   flags & MORE_COMPONENTS; }\n-    bool is_use_my_metrics () const { return   flags & USE_MY_METRICS; }\n-    bool is_anchored ()       const { return !(flags & ARGS_ARE_XY_VALUES); }\n-    void get_anchor_points (unsigned int &point1, unsigned int &point2) const\n-    {\n-      const HBUINT8 *p = &StructAfter<const HBUINT8> (glyphIndex);\n-      if (flags & ARG_1_AND_2_ARE_WORDS)\n-      {\n-        point1 = ((const HBUINT16 *) p)[0];\n-        point2 = ((const HBUINT16 *) p)[1];\n-      }\n-      else\n-      {\n-        point1 = p[0];\n-        point2 = p[1];\n-      }\n-    }\n-\n-    void transform_points (contour_point_vector_t &points) const\n-    {\n-      float matrix[4];\n-      contour_point_t trans;\n-      if (get_transformation (matrix, trans))\n-      {\n-        if (scaled_offsets ())\n-        {\n-          points.translate (trans);\n-          points.transform (matrix);\n-        }\n-        else\n-        {\n-          points.transform (matrix);\n-          points.translate (trans);\n-        }\n-      }\n-    }\n-\n-    protected:\n-    bool scaled_offsets () const\n-    { return (flags & (SCALED_COMPONENT_OFFSET | UNSCALED_COMPONENT_OFFSET)) == SCALED_COMPONENT_OFFSET; }\n-\n-    bool get_transformation (float (&matrix)[4], contour_point_t &trans) const\n-    {\n-      matrix[0] = matrix[3] = 1.f;\n-      matrix[1] = matrix[2] = 0.f;\n-\n-      int tx, ty;\n-      const HBINT8 *p = &StructAfter<const HBINT8> (glyphIndex);\n-      if (flags & ARG_1_AND_2_ARE_WORDS)\n-      {\n-        tx = *(const HBINT16 *) p;\n-        p += HBINT16::static_size;\n-        ty = *(const HBINT16 *) p;\n-        p += HBINT16::static_size;\n-      }\n-      else\n-      {\n-        tx = *p++;\n-        ty = *p++;\n-      }\n-      if (is_anchored ()) tx = ty = 0;\n-\n-      trans.init ((float) tx, (float) ty);\n-\n-      {\n-        const F2DOT14 *points = (const F2DOT14 *) p;\n-        if (flags & WE_HAVE_A_SCALE)\n-        {\n-          matrix[0] = matrix[3] = points[0].to_float ();\n-          return true;\n-        }\n-        else if (flags & WE_HAVE_AN_X_AND_Y_SCALE)\n-        {\n-          matrix[0] = points[0].to_float ();\n-          matrix[3] = points[1].to_float ();\n-          return true;\n-        }\n-        else if (flags & WE_HAVE_A_TWO_BY_TWO)\n-        {\n-          matrix[0] = points[0].to_float ();\n-          matrix[1] = points[1].to_float ();\n-          matrix[2] = points[2].to_float ();\n-          matrix[3] = points[3].to_float ();\n-          return true;\n-        }\n-      }\n-      return tx || ty;\n-    }\n-\n-    protected:\n-    HBUINT16    flags;\n-    HBGlyphID   glyphIndex;\n-    public:\n-    DEFINE_SIZE_MIN (4);\n-  };\n-\n-  struct composite_iter_t : hb_iter_with_fallback_t<composite_iter_t, const CompositeGlyphChain &>\n-  {\n-    typedef const CompositeGlyphChain *__item_t__;\n-    composite_iter_t (hb_bytes_t glyph_, __item_t__ current_) :\n-      glyph (glyph_), current (current_)\n-    { if (!check_range (current)) current = nullptr; }\n-    composite_iter_t () : glyph (hb_bytes_t ()), current (nullptr) {}\n-\n-    const CompositeGlyphChain &__item__ () const { return *current; }\n-    bool __more__ () const { return current; }\n-    void __next__ ()\n-    {\n-      if (!current->has_more ()) { current = nullptr; return; }\n-\n-      const CompositeGlyphChain *possible = &StructAfter<CompositeGlyphChain,\n-                                                         CompositeGlyphChain> (*current);\n-      if (!check_range (possible)) { current = nullptr; return; }\n-      current = possible;\n-    }\n-    bool operator != (const composite_iter_t& o) const\n-    { return glyph != o.glyph || current != o.current; }\n-\n-    bool check_range (const CompositeGlyphChain *composite) const\n-    {\n-      return glyph.check_range (composite, CompositeGlyphChain::min_size)\n-          && glyph.check_range (composite, composite->get_size ());\n-    }\n-\n-    private:\n-    hb_bytes_t glyph;\n-    __item_t__ current;\n-  };\n-\n-  enum phantom_point_index_t\n-  {\n-    PHANTOM_LEFT   = 0,\n-    PHANTOM_RIGHT  = 1,\n-    PHANTOM_TOP    = 2,\n-    PHANTOM_BOTTOM = 3,\n-    PHANTOM_COUNT  = 4\n-  };\n-\n-  struct accelerator_t;\n-\n-  struct Glyph\n-  {\n-    enum simple_glyph_flag_t\n-    {\n-      FLAG_ON_CURVE  = 0x01,\n-      FLAG_X_SHORT   = 0x02,\n-      FLAG_Y_SHORT   = 0x04,\n-      FLAG_REPEAT    = 0x08,\n-      FLAG_X_SAME    = 0x10,\n-      FLAG_Y_SAME    = 0x20,\n-      FLAG_RESERVED1 = 0x40,\n-      FLAG_RESERVED2 = 0x80\n-    };\n-\n-    private:\n-    struct GlyphHeader\n-    {\n-      bool has_data () const { return numberOfContours; }\n-\n-      bool get_extents (hb_font_t *font, const accelerator_t &glyf_accelerator,\n-                        hb_codepoint_t gid, hb_glyph_extents_t *extents) const\n-      {\n-        \/* Undocumented rasterizer behavior: shift glyph to the left by (lsb - xMin), i.e., xMin = lsb *\/\n-        \/* extents->x_bearing = hb_min (glyph_header.xMin, glyph_header.xMax); *\/\n-        extents->x_bearing = font->em_scale_x (glyf_accelerator.hmtx->get_side_bearing (gid));\n-        extents->y_bearing = font->em_scale_y (hb_max (yMin, yMax));\n-        extents->width     = font->em_scale_x (hb_max (xMin, xMax) - hb_min (xMin, xMax));\n-        extents->height    = font->em_scale_y (hb_min (yMin, yMax) - hb_max (yMin, yMax));\n-\n-        return true;\n-      }\n-\n-      HBINT16   numberOfContours;\n-                        \/* If the number of contours is\n-                         * greater than or equal to zero,\n-                         * this is a simple glyph; if negative,\n-                         * this is a composite glyph. *\/\n-      FWORD     xMin;   \/* Minimum x for coordinate data. *\/\n-      FWORD     yMin;   \/* Minimum y for coordinate data. *\/\n-      FWORD     xMax;   \/* Maximum x for coordinate data. *\/\n-      FWORD     yMax;   \/* Maximum y for coordinate data. *\/\n-      public:\n-      DEFINE_SIZE_STATIC (10);\n-    };\n-\n-    struct SimpleGlyph\n-    {\n-      const GlyphHeader &header;\n-      hb_bytes_t bytes;\n-      SimpleGlyph (const GlyphHeader &header_, hb_bytes_t bytes_) :\n-        header (header_), bytes (bytes_) {}\n-\n-      unsigned int instruction_len_offset () const\n-      { return GlyphHeader::static_size + 2 * header.numberOfContours; }\n-\n-      unsigned int length (unsigned int instruction_len) const\n-      { return instruction_len_offset () + 2 + instruction_len; }\n-\n-      unsigned int instructions_length () const\n-      {\n-        unsigned int instruction_length_offset = instruction_len_offset ();\n-        if (unlikely (instruction_length_offset + 2 > bytes.length)) return 0;\n-\n-        const HBUINT16 &instructionLength = StructAtOffset<HBUINT16> (&bytes, instruction_length_offset);\n-        \/* Out of bounds of the current glyph *\/\n-        if (unlikely (length (instructionLength) > bytes.length)) return 0;\n-        return instructionLength;\n-      }\n-\n-      const Glyph trim_padding () const\n-      {\n-        \/* based on FontTools _g_l_y_f.py::trim *\/\n-        const char *glyph = bytes.arrayZ;\n-        const char *glyph_end = glyph + bytes.length;\n-        \/* simple glyph w\/contours, possibly trimmable *\/\n-        glyph += instruction_len_offset ();\n-\n-        if (unlikely (glyph + 2 >= glyph_end)) return Glyph ();\n-        unsigned int num_coordinates = StructAtOffset<HBUINT16> (glyph - 2, 0) + 1;\n-        unsigned int num_instructions = StructAtOffset<HBUINT16> (glyph, 0);\n-\n-        glyph += 2 + num_instructions;\n-\n-        unsigned int coord_bytes = 0;\n-        unsigned int coords_with_flags = 0;\n-        while (glyph < glyph_end)\n-        {\n-          uint8_t flag = *glyph;\n-          glyph++;\n-\n-          unsigned int repeat = 1;\n-          if (flag & FLAG_REPEAT)\n-          {\n-            if (unlikely (glyph >= glyph_end)) return Glyph ();\n-            repeat = *glyph + 1;\n-            glyph++;\n-          }\n-\n-          unsigned int xBytes, yBytes;\n-          xBytes = yBytes = 0;\n-          if (flag & FLAG_X_SHORT) xBytes = 1;\n-          else if ((flag & FLAG_X_SAME) == 0) xBytes = 2;\n-\n-          if (flag & FLAG_Y_SHORT) yBytes = 1;\n-          else if ((flag & FLAG_Y_SAME) == 0) yBytes = 2;\n-\n-          coord_bytes += (xBytes + yBytes) * repeat;\n-          coords_with_flags += repeat;\n-          if (coords_with_flags >= num_coordinates) break;\n-        }\n-\n-        if (unlikely (coords_with_flags != num_coordinates)) return Glyph ();\n-        return Glyph (bytes.sub_array (0, bytes.length + coord_bytes - (glyph_end - glyph)));\n-      }\n-\n-      \/* zero instruction length *\/\n-      void drop_hints ()\n-      {\n-        GlyphHeader &glyph_header = const_cast<GlyphHeader &> (header);\n-        (HBUINT16 &) StructAtOffset<HBUINT16> (&glyph_header, instruction_len_offset ()) = 0;\n-      }\n-\n-      void drop_hints_bytes (hb_bytes_t &dest_start, hb_bytes_t &dest_end) const\n-      {\n-        unsigned int instructions_len = instructions_length ();\n-        unsigned int glyph_length = length (instructions_len);\n-        dest_start = bytes.sub_array (0, glyph_length - instructions_len);\n-        dest_end = bytes.sub_array (glyph_length, bytes.length - glyph_length);\n-      }\n-\n-      static bool read_points (const HBUINT8 *&p \/* IN\/OUT *\/,\n-                               contour_point_vector_t &points_ \/* IN\/OUT *\/,\n-                               const hb_bytes_t &bytes,\n-                               void (* setter) (contour_point_t &_, float v),\n-                               const simple_glyph_flag_t short_flag,\n-                               const simple_glyph_flag_t same_flag)\n-      {\n-        float v = 0;\n-        for (unsigned i = 0; i < points_.length; i++)\n-        {\n-          uint8_t flag = points_[i].flag;\n-          if (flag & short_flag)\n-          {\n-            if (unlikely (!bytes.check_range (p))) return false;\n-            if (flag & same_flag)\n-              v += *p++;\n-            else\n-              v -= *p++;\n-          }\n-          else\n-          {\n-            if (!(flag & same_flag))\n-            {\n-              if (unlikely (!bytes.check_range ((const HBUINT16 *) p))) return false;\n-              v += *(const HBINT16 *) p;\n-              p += HBINT16::static_size;\n-            }\n-          }\n-          setter (points_[i], v);\n-        }\n-        return true;\n-      }\n-\n-      bool get_contour_points (contour_point_vector_t &points_ \/* OUT *\/,\n-                               bool phantom_only = false) const\n-      {\n-        const HBUINT16 *endPtsOfContours = &StructAfter<HBUINT16> (header);\n-        int num_contours = header.numberOfContours;\n-        if (unlikely (!bytes.check_range (&endPtsOfContours[num_contours + 1]))) return false;\n-        unsigned int num_points = endPtsOfContours[num_contours - 1] + 1;\n-\n-        points_.resize (num_points);\n-        for (unsigned int i = 0; i < points_.length; i++) points_[i].init ();\n-        if (phantom_only) return true;\n-\n-        for (int i = 0; i < num_contours; i++)\n-          points_[endPtsOfContours[i]].is_end_point = true;\n-\n-        \/* Skip instructions *\/\n-        const HBUINT8 *p = &StructAtOffset<HBUINT8> (&endPtsOfContours[num_contours + 1],\n-                                                     endPtsOfContours[num_contours]);\n-\n-        \/* Read flags *\/\n-        for (unsigned int i = 0; i < num_points; i++)\n-        {\n-          if (unlikely (!bytes.check_range (p))) return false;\n-          uint8_t flag = *p++;\n-          points_[i].flag = flag;\n-          if (flag & FLAG_REPEAT)\n-          {\n-            if (unlikely (!bytes.check_range (p))) return false;\n-            unsigned int repeat_count = *p++;\n-            while ((repeat_count-- > 0) && (++i < num_points))\n-              points_[i].flag = flag;\n-          }\n-        }\n-\n-        \/* Read x & y coordinates *\/\n-        return read_points (p, points_, bytes, [] (contour_point_t &p, float v) { p.x = v; },\n-                            FLAG_X_SHORT, FLAG_X_SAME)\n-            && read_points (p, points_, bytes, [] (contour_point_t &p, float v) { p.y = v; },\n-                            FLAG_Y_SHORT, FLAG_Y_SAME);\n-      }\n-    };\n-\n-    struct CompositeGlyph\n-    {\n-      const GlyphHeader &header;\n-      hb_bytes_t bytes;\n-      CompositeGlyph (const GlyphHeader &header_, hb_bytes_t bytes_) :\n-        header (header_), bytes (bytes_) {}\n-\n-      composite_iter_t get_iterator () const\n-      { return composite_iter_t (bytes, &StructAfter<CompositeGlyphChain, GlyphHeader> (header)); }\n-\n-      unsigned int instructions_length (hb_bytes_t bytes) const\n-      {\n-        unsigned int start = bytes.length;\n-        unsigned int end = bytes.length;\n-        const CompositeGlyphChain *last = nullptr;\n-        for (auto &item : get_iterator ())\n-          last = &item;\n-        if (unlikely (!last)) return 0;\n-\n-        if (last->has_instructions ())\n-          start = (char *) last - &bytes + last->get_size ();\n-        if (unlikely (start > end)) return 0;\n-        return end - start;\n-      }\n-\n-      \/* Trimming for composites not implemented.\n-       * If removing hints it falls out of that. *\/\n-      const Glyph trim_padding () const { return Glyph (bytes); }\n-\n-      void drop_hints ()\n-      {\n-        for (const auto &_ : get_iterator ())\n-          const_cast<CompositeGlyphChain &> (_).drop_instructions_flag ();\n-      }\n-\n-      \/* Chop instructions off the end *\/\n-      void drop_hints_bytes (hb_bytes_t &dest_start) const\n-      { dest_start = bytes.sub_array (0, bytes.length - instructions_length (bytes)); }\n-    };\n-\n-    enum glyph_type_t { EMPTY, SIMPLE, COMPOSITE };\n-\n-    public:\n-    composite_iter_t get_composite_iterator () const\n-    {\n-      if (type != COMPOSITE) return composite_iter_t ();\n-      return CompositeGlyph (*header, bytes).get_iterator ();\n-    }\n-\n-    const Glyph trim_padding () const\n-    {\n-      switch (type) {\n-      case COMPOSITE: return CompositeGlyph (*header, bytes).trim_padding ();\n-      case SIMPLE:    return SimpleGlyph (*header, bytes).trim_padding ();\n-      default:        return bytes;\n-      }\n-    }\n-\n-    void drop_hints ()\n-    {\n-      switch (type) {\n-      case COMPOSITE: CompositeGlyph (*header, bytes).drop_hints (); return;\n-      case SIMPLE:    SimpleGlyph (*header, bytes).drop_hints (); return;\n-      default:        return;\n-      }\n-    }\n-\n-    void drop_hints_bytes (hb_bytes_t &dest_start, hb_bytes_t &dest_end) const\n-    {\n-      switch (type) {\n-      case COMPOSITE: CompositeGlyph (*header, bytes).drop_hints_bytes (dest_start); return;\n-      case SIMPLE:    SimpleGlyph (*header, bytes).drop_hints_bytes (dest_start, dest_end); return;\n-      default:        return;\n-      }\n-    }\n-\n-    \/* Note: Recursively calls itself.\n-     * all_points includes phantom points\n-     *\/\n-    bool get_points (hb_font_t *font, const accelerator_t &glyf_accelerator,\n-                     contour_point_vector_t &all_points \/* OUT *\/,\n-                     bool phantom_only = false,\n-                     unsigned int depth = 0) const\n-    {\n-      if (unlikely (depth > HB_MAX_NESTING_LEVEL)) return false;\n-      contour_point_vector_t points;\n-\n-      switch (type) {\n-      case COMPOSITE:\n-      {\n-        \/* pseudo component points for each component in composite glyph *\/\n-        unsigned num_points = hb_len (CompositeGlyph (*header, bytes).get_iterator ());\n-        if (unlikely (!points.resize (num_points))) return false;\n-        for (unsigned i = 0; i < points.length; i++)\n-          points[i].init ();\n-        break;\n-      }\n-      case SIMPLE:\n-        if (unlikely (!SimpleGlyph (*header, bytes).get_contour_points (points, phantom_only)))\n-          return false;\n-        break;\n-      }\n-\n-      \/* Init phantom points *\/\n-      if (unlikely (!points.resize (points.length + PHANTOM_COUNT))) return false;\n-      hb_array_t<contour_point_t> phantoms = points.sub_array (points.length - PHANTOM_COUNT, PHANTOM_COUNT);\n-      {\n-        for (unsigned i = 0; i < PHANTOM_COUNT; ++i) phantoms[i].init ();\n-        int h_delta = (int) header->xMin - glyf_accelerator.hmtx->get_side_bearing (gid);\n-        int v_orig  = (int) header->yMax + glyf_accelerator.vmtx->get_side_bearing (gid);\n-        unsigned h_adv = glyf_accelerator.hmtx->get_advance (gid);\n-        unsigned v_adv = glyf_accelerator.vmtx->get_advance (gid);\n-        phantoms[PHANTOM_LEFT].x = h_delta;\n-        phantoms[PHANTOM_RIGHT].x = h_adv + h_delta;\n-        phantoms[PHANTOM_TOP].y = v_orig;\n-        phantoms[PHANTOM_BOTTOM].y = v_orig - (int) v_adv;\n-      }\n-\n-#ifndef HB_NO_VAR\n-      if (unlikely (!glyf_accelerator.gvar->apply_deltas_to_points (gid, font, points.as_array ())))\n-        return false;\n-#endif\n-\n-      switch (type) {\n-      case SIMPLE:\n-        all_points.extend (points.as_array ());\n-        break;\n-      case COMPOSITE:\n-      {\n-        unsigned int comp_index = 0;\n-        for (auto &item : get_composite_iterator ())\n-        {\n-          contour_point_vector_t comp_points;\n-          if (unlikely (!glyf_accelerator.glyph_for_gid (item.get_glyph_index ())\n-                                         .get_points (font, glyf_accelerator, comp_points,\n-                                                      phantom_only, depth + 1)\n-                        || comp_points.length < PHANTOM_COUNT))\n-            return false;\n-\n-          \/* Copy phantom points from component if USE_MY_METRICS flag set *\/\n-          if (item.is_use_my_metrics ())\n-            for (unsigned int i = 0; i < PHANTOM_COUNT; i++)\n-              phantoms[i] = comp_points[comp_points.length - PHANTOM_COUNT + i];\n-\n-          \/* Apply component transformation & translation *\/\n-          item.transform_points (comp_points);\n-\n-          \/* Apply translation from gvar *\/\n-          comp_points.translate (points[comp_index]);\n-\n-          if (item.is_anchored ())\n-          {\n-            unsigned int p1, p2;\n-            item.get_anchor_points (p1, p2);\n-            if (likely (p1 < all_points.length && p2 < comp_points.length))\n-            {\n-              contour_point_t delta;\n-              delta.init (all_points[p1].x - comp_points[p2].x,\n-                          all_points[p1].y - comp_points[p2].y);\n-\n-              comp_points.translate (delta);\n-            }\n-          }\n-\n-          all_points.extend (comp_points.sub_array (0, comp_points.length - PHANTOM_COUNT));\n-\n-          comp_index++;\n-        }\n-\n-        all_points.extend (phantoms);\n-      } break;\n-      default:\n-        all_points.extend (phantoms);\n-      }\n-\n-      if (depth == 0) \/* Apply at top level *\/\n-      {\n-        \/* Undocumented rasterizer behavior:\n-         * Shift points horizontally by the updated left side bearing\n-         *\/\n-        contour_point_t delta;\n-        delta.init (-phantoms[PHANTOM_LEFT].x, 0.f);\n-        if (delta.x) all_points.translate (delta);\n-      }\n-\n-      return true;\n-    }\n-\n-    bool get_extents (hb_font_t *font, const accelerator_t &glyf_accelerator,\n-                      hb_glyph_extents_t *extents) const\n-    {\n-      if (type == EMPTY) return true; \/* Empty glyph; zero extents. *\/\n-      return header->get_extents (font, glyf_accelerator, gid, extents);\n-    }\n-\n-    hb_bytes_t get_bytes () const { return bytes; }\n-\n-    Glyph (hb_bytes_t bytes_ = hb_bytes_t (),\n-           hb_codepoint_t gid_ = (hb_codepoint_t) -1) : bytes (bytes_), gid (gid_),\n-                                                        header (bytes.as<GlyphHeader> ())\n-    {\n-      int num_contours = header->numberOfContours;\n-      if (unlikely (num_contours == 0)) type = EMPTY;\n-      else if (num_contours > 0) type = SIMPLE;\n-      else type = COMPOSITE; \/* negative numbers *\/\n-    }\n-\n-    protected:\n-    hb_bytes_t bytes;\n-    hb_codepoint_t gid;\n-    const GlyphHeader *header;\n-    unsigned type;\n-  };\n-\n-  struct accelerator_t\n-  {\n-    void init (hb_face_t *face_)\n-    {\n-      short_offset = false;\n-      num_glyphs = 0;\n-      loca_table = nullptr;\n-      glyf_table = nullptr;\n-#ifndef HB_NO_VAR\n-      gvar = nullptr;\n-#endif\n-      hmtx = nullptr;\n-      vmtx = nullptr;\n-      face = face_;\n-      const OT::head &head = *face->table.head;\n-      if (head.indexToLocFormat > 1 || head.glyphDataFormat > 0)\n-        \/* Unknown format.  Leave num_glyphs=0, that takes care of disabling us. *\/\n-        return;\n-      short_offset = 0 == head.indexToLocFormat;\n-\n-      loca_table = hb_sanitize_context_t ().reference_table<loca> (face);\n-      glyf_table = hb_sanitize_context_t ().reference_table<glyf> (face);\n-#ifndef HB_NO_VAR\n-      gvar = face->table.gvar;\n-#endif\n-      hmtx = face->table.hmtx;\n-      vmtx = face->table.vmtx;\n-\n-      num_glyphs = hb_max (1u, loca_table.get_length () \/ (short_offset ? 2 : 4)) - 1;\n-      num_glyphs = hb_min (num_glyphs, face->get_num_glyphs ());\n-    }\n-\n-    void fini ()\n-    {\n-      loca_table.destroy ();\n-      glyf_table.destroy ();\n-    }\n-\n-    protected:\n-    template<typename T>\n-    bool get_points (hb_font_t *font, hb_codepoint_t gid, T consumer) const\n-    {\n-      if (gid >= num_glyphs) return false;\n-\n-      \/* Making this alloc free is not that easy\n-         https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2095\n-         mostly because of gvar handling in VF fonts,\n-         perhaps a separate path for non-VF fonts can be considered *\/\n-      contour_point_vector_t all_points;\n-\n-      bool phantom_only = !consumer.is_consuming_contour_points ();\n-      if (unlikely (!glyph_for_gid (gid).get_points (font, *this, all_points, phantom_only)))\n-        return false;\n-\n-      if (consumer.is_consuming_contour_points ())\n-      {\n-        for (unsigned point_index = 0; point_index + 4 < all_points.length; ++point_index)\n-          consumer.consume_point (all_points[point_index]);\n-        consumer.points_end ();\n-      }\n-\n-      \/* Where to write phantoms, nullptr if not requested *\/\n-      contour_point_t *phantoms = consumer.get_phantoms_sink ();\n-      if (phantoms)\n-        for (unsigned i = 0; i < PHANTOM_COUNT; ++i)\n-          phantoms[i] = all_points[all_points.length - PHANTOM_COUNT + i];\n-\n-      return true;\n-    }\n-\n-#ifndef HB_NO_VAR\n-    struct points_aggregator_t\n-    {\n-      hb_font_t *font;\n-      hb_glyph_extents_t *extents;\n-      contour_point_t *phantoms;\n-\n-      struct contour_bounds_t\n-      {\n-        contour_bounds_t () { min_x = min_y = FLT_MAX; max_x = max_y = -FLT_MAX; }\n-\n-        void add (const contour_point_t &p)\n-        {\n-          min_x = hb_min (min_x, p.x);\n-          min_y = hb_min (min_y, p.y);\n-          max_x = hb_max (max_x, p.x);\n-          max_y = hb_max (max_y, p.y);\n-        }\n-\n-        bool empty () const { return (min_x >= max_x) || (min_y >= max_y); }\n-\n-        void get_extents (hb_font_t *font, hb_glyph_extents_t *extents)\n-        {\n-          if (unlikely (empty ()))\n-          {\n-            extents->width = 0;\n-            extents->x_bearing = 0;\n-            extents->height = 0;\n-            extents->y_bearing = 0;\n-            return;\n-          }\n-          extents->x_bearing = font->em_scalef_x (min_x);\n-          extents->width = font->em_scalef_x (max_x) - extents->x_bearing;\n-          extents->y_bearing = font->em_scalef_y (max_y);\n-          extents->height = font->em_scalef_y (min_y) - extents->y_bearing;\n-        }\n-\n-        protected:\n-        float min_x, min_y, max_x, max_y;\n-      } bounds;\n-\n-      points_aggregator_t (hb_font_t *font_, hb_glyph_extents_t *extents_, contour_point_t *phantoms_)\n-      {\n-        font = font_;\n-        extents = extents_;\n-        phantoms = phantoms_;\n-        if (extents) bounds = contour_bounds_t ();\n-      }\n-\n-      void consume_point (const contour_point_t &point) { bounds.add (point); }\n-      void points_end () { bounds.get_extents (font, extents); }\n-\n-      bool is_consuming_contour_points () { return extents; }\n-      contour_point_t *get_phantoms_sink () { return phantoms; }\n-    };\n-\n-    public:\n-    unsigned\n-    get_advance_var (hb_font_t *font, hb_codepoint_t gid, bool is_vertical) const\n-    {\n-      if (unlikely (gid >= num_glyphs)) return 0;\n-\n-      bool success = false;\n-\n-      contour_point_t phantoms[PHANTOM_COUNT];\n-      if (likely (font->num_coords == gvar->get_axis_count ()))\n-        success = get_points (font, gid, points_aggregator_t (font, nullptr, phantoms));\n-\n-      if (unlikely (!success))\n-        return is_vertical ? vmtx->get_advance (gid) : hmtx->get_advance (gid);\n-\n-      float result = is_vertical\n-                   ? phantoms[PHANTOM_TOP].y - phantoms[PHANTOM_BOTTOM].y\n-                   : phantoms[PHANTOM_RIGHT].x - phantoms[PHANTOM_LEFT].x;\n-      return hb_clamp (roundf (result), 0.f, (float) UINT_MAX \/ 2);\n-    }\n-\n-    int get_side_bearing_var (hb_font_t *font, hb_codepoint_t gid, bool is_vertical) const\n-    {\n-      if (unlikely (gid >= num_glyphs)) return 0;\n-\n-      hb_glyph_extents_t extents;\n-\n-      contour_point_t phantoms[PHANTOM_COUNT];\n-      if (unlikely (!get_points (font, gid, points_aggregator_t (font, &extents, phantoms))))\n-        return is_vertical ? vmtx->get_side_bearing (gid) : hmtx->get_side_bearing (gid);\n-\n-      return is_vertical\n-           ? ceilf (phantoms[PHANTOM_TOP].y) - extents.y_bearing\n-           : floorf (phantoms[PHANTOM_LEFT].x);\n-    }\n-#endif\n-\n-    public:\n-    bool get_extents (hb_font_t *font, hb_codepoint_t gid, hb_glyph_extents_t *extents) const\n-    {\n-      if (unlikely (gid >= num_glyphs)) return false;\n-\n-#ifndef HB_NO_VAR\n-      if (font->num_coords && font->num_coords == gvar->get_axis_count ())\n-        return get_points (font, gid, points_aggregator_t (font, extents, nullptr));\n-#endif\n-      return glyph_for_gid (gid).get_extents (font, *this, extents);\n-    }\n-\n-    const Glyph\n-    glyph_for_gid (hb_codepoint_t gid, bool needs_padding_removal = false) const\n-    {\n-      if (unlikely (gid >= num_glyphs)) return Glyph ();\n-\n-      unsigned int start_offset, end_offset;\n-\n-      if (short_offset)\n-      {\n-        const HBUINT16 *offsets = (const HBUINT16 *) loca_table->dataZ.arrayZ;\n-        start_offset = 2 * offsets[gid];\n-        end_offset   = 2 * offsets[gid + 1];\n-      }\n-      else\n-      {\n-        const HBUINT32 *offsets = (const HBUINT32 *) loca_table->dataZ.arrayZ;\n-        start_offset = offsets[gid];\n-        end_offset   = offsets[gid + 1];\n-      }\n-\n-      if (unlikely (start_offset > end_offset || end_offset > glyf_table.get_length ()))\n-        return Glyph ();\n-\n-      Glyph glyph (hb_bytes_t ((const char *) this->glyf_table + start_offset,\n-                               end_offset - start_offset), gid);\n-      return needs_padding_removal ? glyph.trim_padding () : glyph;\n-    }\n-\n-    void\n-    add_gid_and_children (hb_codepoint_t gid, hb_set_t *gids_to_retain,\n-                          unsigned int depth = 0) const\n-    {\n-      if (unlikely (depth++ > HB_MAX_NESTING_LEVEL)) return;\n-      \/* Check if is already visited *\/\n-      if (gids_to_retain->has (gid)) return;\n-\n-      gids_to_retain->add (gid);\n-\n-      for (auto &item : glyph_for_gid (gid).get_composite_iterator ())\n-        add_gid_and_children (item.get_glyph_index (), gids_to_retain, depth);\n-    }\n-\n-#ifdef HB_EXPERIMENTAL_API\n-    struct path_builder_t\n-    {\n-      hb_font_t *font;\n-      draw_helper_t *draw_helper;\n-\n-      struct optional_point_t\n-      {\n-        optional_point_t () { has_data = false; }\n-        optional_point_t (float x_, float y_) { x = x_; y = y_; has_data = true; }\n-\n-        bool has_data;\n-        float x;\n-        float y;\n-\n-        optional_point_t lerp (optional_point_t p, float t)\n-        { return optional_point_t (x + t * (p.x - x), y + t * (p.y - y)); }\n-      } first_oncurve, first_offcurve, last_offcurve;\n-\n-      path_builder_t (hb_font_t *font_, draw_helper_t &draw_helper_)\n-      {\n-        font = font_;\n-        draw_helper = &draw_helper_;\n-        first_oncurve = first_offcurve = last_offcurve = optional_point_t ();\n-      }\n-\n-      \/* based on https:\/\/github.com\/RazrFalcon\/ttf-parser\/blob\/4f32821\/src\/glyf.rs#L287\n-         See also:\n-         * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM01\/Chap1.html\n-         * https:\/\/stackoverflow.com\/a\/20772557 *\/\n-      void consume_point (const contour_point_t &point)\n-      {\n-        \/* Skip empty contours *\/\n-        if (unlikely (point.is_end_point && !first_oncurve.has_data && !first_offcurve.has_data))\n-          return;\n-\n-        bool is_on_curve = point.flag & Glyph::FLAG_ON_CURVE;\n-        optional_point_t p (point.x, point.y);\n-        if (!first_oncurve.has_data)\n-        {\n-          if (is_on_curve)\n-          {\n-            first_oncurve = p;\n-            draw_helper->move_to (font->em_scalef_x (p.x), font->em_scalef_y (p.y));\n-          }\n-          else\n-          {\n-            if (first_offcurve.has_data)\n-            {\n-              optional_point_t mid = first_offcurve.lerp (p, .5f);\n-              first_oncurve = mid;\n-              last_offcurve = p;\n-              draw_helper->move_to (font->em_scalef_x (mid.x), font->em_scalef_y (mid.y));\n-            }\n-            else\n-              first_offcurve = p;\n-          }\n-        }\n-        else\n-        {\n-          if (last_offcurve.has_data)\n-          {\n-            if (is_on_curve)\n-            {\n-              draw_helper->quadratic_to (font->em_scalef_x (last_offcurve.x), font->em_scalef_y (last_offcurve.y),\n-                                         font->em_scalef_x (p.x), font->em_scalef_y (p.y));\n-              last_offcurve = optional_point_t ();\n-            }\n-            else\n-            {\n-              optional_point_t mid = last_offcurve.lerp (p, .5f);\n-              draw_helper->quadratic_to (font->em_scalef_x (last_offcurve.x), font->em_scalef_y (last_offcurve.y),\n-                                         font->em_scalef_x (mid.x), font->em_scalef_y (mid.y));\n-              last_offcurve = p;\n-            }\n-          }\n-          else\n-          {\n-            if (is_on_curve)\n-              draw_helper->line_to (font->em_scalef_x (p.x), font->em_scalef_y (p.y));\n-            else\n-              last_offcurve = p;\n-          }\n-        }\n-\n-        if (point.is_end_point)\n-        {\n-          if (first_offcurve.has_data && last_offcurve.has_data)\n-          {\n-            optional_point_t mid = last_offcurve.lerp (first_offcurve, .5f);\n-            draw_helper->quadratic_to (font->em_scalef_x (last_offcurve.x), font->em_scalef_y (last_offcurve.y),\n-                                       font->em_scalef_x (mid.x), font->em_scalef_y (mid.y));\n-            last_offcurve = optional_point_t ();\n-            \/* now check the rest *\/\n-          }\n-\n-          if (first_offcurve.has_data && first_oncurve.has_data)\n-            draw_helper->quadratic_to (font->em_scalef_x (first_offcurve.x), font->em_scalef_y (first_offcurve.y),\n-                                       font->em_scalef_x (first_oncurve.x), font->em_scalef_y (first_oncurve.y));\n-          else if (last_offcurve.has_data && first_oncurve.has_data)\n-            draw_helper->quadratic_to (font->em_scalef_x (last_offcurve.x), font->em_scalef_y (last_offcurve.y),\n-                                       font->em_scalef_x (first_oncurve.x), font->em_scalef_y (first_oncurve.y));\n-          else if (first_oncurve.has_data)\n-            draw_helper->line_to (font->em_scalef_x (first_oncurve.x), font->em_scalef_y (first_oncurve.y));\n-\n-          \/* Getting ready for the next contour *\/\n-          first_oncurve = first_offcurve = last_offcurve = optional_point_t ();\n-          draw_helper->end_path ();\n-        }\n-      }\n-      void points_end () {}\n-\n-      bool is_consuming_contour_points () { return true; }\n-      contour_point_t *get_phantoms_sink () { return nullptr; }\n-    };\n-\n-    bool\n-    get_path (hb_font_t *font, hb_codepoint_t gid, draw_helper_t &draw_helper) const\n-    { return get_points (font, gid, path_builder_t (font, draw_helper)); }\n-#endif\n-\n-#ifndef HB_NO_VAR\n-    const gvar_accelerator_t *gvar;\n-#endif\n-    const hmtx_accelerator_t *hmtx;\n-    const vmtx_accelerator_t *vmtx;\n-\n-    private:\n-    bool short_offset;\n-    unsigned int num_glyphs;\n-    hb_blob_ptr_t<loca> loca_table;\n-    hb_blob_ptr_t<glyf> glyf_table;\n-    hb_face_t *face;\n-  };\n-\n-  struct SubsetGlyph\n-  {\n-    hb_codepoint_t new_gid;\n-    hb_codepoint_t old_gid;\n-    Glyph source_glyph;\n-    hb_bytes_t dest_start;  \/* region of source_glyph to copy first *\/\n-    hb_bytes_t dest_end;    \/* region of source_glyph to copy second *\/\n-\n-    bool serialize (hb_serialize_context_t *c,\n-                    const hb_subset_plan_t *plan) const\n-    {\n-      TRACE_SERIALIZE (this);\n-\n-      hb_bytes_t dest_glyph = dest_start.copy (c);\n-      dest_glyph = hb_bytes_t (&dest_glyph, dest_glyph.length + dest_end.copy (c).length);\n-      unsigned int pad_length = padding ();\n-      DEBUG_MSG (SUBSET, nullptr, \"serialize %d byte glyph, width %d pad %d\", dest_glyph.length, dest_glyph.length + pad_length, pad_length);\n-\n-      HBUINT8 pad;\n-      pad = 0;\n-      while (pad_length > 0)\n-      {\n-        c->embed (pad);\n-        pad_length--;\n-      }\n-\n-      if (unlikely (!dest_glyph.length)) return_trace (true);\n-\n-      \/* update components gids *\/\n-      for (auto &_ : Glyph (dest_glyph).get_composite_iterator ())\n-      {\n-        hb_codepoint_t new_gid;\n-        if (plan->new_gid_for_old_gid (_.get_glyph_index (), &new_gid))\n-          const_cast<CompositeGlyphChain &> (_).set_glyph_index (new_gid);\n-      }\n-\n-      if (plan->drop_hints) Glyph (dest_glyph).drop_hints ();\n-\n-      return_trace (true);\n-    }\n-\n-    void drop_hints_bytes ()\n-    { source_glyph.drop_hints_bytes (dest_start, dest_end); }\n-\n-    unsigned int      length () const { return dest_start.length + dest_end.length; }\n-    \/* pad to 2 to ensure 2-byte loca will be ok *\/\n-    unsigned int     padding () const { return length () % 2; }\n-    unsigned int padded_size () const { return length () + padding (); }\n-  };\n-\n-  protected:\n-  UnsizedArrayOf<HBUINT8>\n-                dataZ;  \/* Glyphs data. *\/\n-  public:\n-  DEFINE_SIZE_MIN (0);  \/* In reality, this is UNBOUNDED() type; but since we always\n-                         * check the size externally, allow Null() object of it by\n-                         * defining it _MIN instead. *\/\n-};\n-\n-struct glyf_accelerator_t : glyf::accelerator_t {};\n-\n-} \/* namespace OT *\/\n-\n+#include \"OT\/glyf\/glyf.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-glyf-table.hh","additions":1,"deletions":1227,"binary":false,"changes":1228,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    if (unlikely (!c->extend (*this, length)))  return_trace (false);\n+    if (unlikely (!c->extend (this, length)))  return_trace (false);\n@@ -113,1 +113,1 @@\n-    return_trace (c->successful);\n+    return_trace (c->successful ());\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-hdmx-table.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,1 +75,2 @@\n-    CONDENSED   = 1u<<5\n+    CONDENSED   = 1u<<5,\n+    EXPANDED    = 1u<<6,\n@@ -81,0 +82,1 @@\n+  bool is_expanded () const  { return macStyle & EXPANDED; }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-head-table.hh","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"hb-ot-maxp-table.hh\"\n@@ -101,1 +102,1 @@\n-                  unsigned num_advances)\n+                  unsigned num_long_metrics)\n@@ -106,1 +107,1 @@\n-      if (idx < num_advances)\n+      if (idx < num_long_metrics)\n@@ -130,3 +131,14 @@\n-    accelerator_t _mtx;\n-    _mtx.init (c->plan->source);\n-    unsigned num_advances = _mtx.num_advances_for_subset (c->plan);\n+    accelerator_t _mtx (c->plan->source);\n+    unsigned num_long_metrics;\n+    {\n+      \/* Determine num_long_metrics to encode. *\/\n+      auto& plan = c->plan;\n+      num_long_metrics = plan->num_output_glyphs ();\n+      hb_codepoint_t old_gid = 0;\n+      unsigned int last_advance = plan->old_gid_for_new_gid (num_long_metrics - 1, &old_gid) ? _mtx.get_advance (old_gid) : 0;\n+      while (num_long_metrics > 1 &&\n+             last_advance == (plan->old_gid_for_new_gid (num_long_metrics - 2, &old_gid) ? _mtx.get_advance (old_gid) : 0))\n+      {\n+        num_long_metrics--;\n+      }\n+    }\n@@ -145,3 +157,1 @@\n-    table_prime->serialize (c->serializer, it, num_advances);\n-\n-    _mtx.fini ();\n+    table_prime->serialize (c->serializer, it, num_long_metrics);\n@@ -149,1 +159,1 @@\n-    if (unlikely (c->serializer->ran_out_of_room || c->serializer->in_error ()))\n+    if (unlikely (c->serializer->in_error ()))\n@@ -153,1 +163,1 @@\n-    if (unlikely (!subset_update_header (c->plan, num_advances)))\n+    if (unlikely (!subset_update_header (c->plan, num_long_metrics)))\n@@ -163,2 +173,1 @@\n-    void init (hb_face_t *face,\n-               unsigned int default_advance_ = 0)\n+    accelerator_t (hb_face_t *face)\n@@ -166,1 +175,2 @@\n-      default_advance = default_advance_ ? default_advance_ : hb_face_get_upem (face);\n+      table = hb_sanitize_context_t ().reference_table<hmtxvmtx> (face, T::tableTag);\n+      var_table = hb_sanitize_context_t ().reference_table<HVARVVAR> (face, T::variationsTag);\n@@ -168,1 +178,1 @@\n-      num_advances = T::is_horizontal ? face->table.hhea->numberOfLongMetrics : face->table.vhea->numberOfLongMetrics;\n+      default_advance = T::is_horizontal ? hb_face_get_upem (face) \/ 2 : hb_face_get_upem (face);\n@@ -170,1 +180,1 @@\n-      table = hb_sanitize_context_t ().reference_table<hmtxvmtx> (face, T::tableTag);\n+      \/* Populate count variables and sort them out as we go *\/\n@@ -172,1 +182,0 @@\n-      \/* Cap num_metrics() and num_advances() based on table length. *\/\n@@ -174,3 +183,16 @@\n-      if (unlikely (num_advances * 4 > len))\n-        num_advances = len \/ 4;\n-      num_metrics = num_advances + (len - 4 * num_advances) \/ 2;\n+      if (len & 1)\n+        len--;\n+\n+      num_long_metrics = T::is_horizontal ?\n+                         face->table.hhea->numberOfLongMetrics :\n+#ifndef HB_NO_VERTICAL\n+                         face->table.vhea->numberOfLongMetrics\n+#else\n+                         0\n+#endif\n+                         ;\n+      if (unlikely (num_long_metrics * 4 > len))\n+        num_long_metrics = len \/ 4;\n+      len -= num_long_metrics * 4;\n+\n+      num_bearings = face->table.maxp->get_num_glyphs ();\n@@ -178,1 +200,7 @@\n-      \/* We MUST set num_metrics to zero if num_advances is zero.\n+      if (unlikely (num_bearings < num_long_metrics))\n+        num_bearings = num_long_metrics;\n+      if (unlikely ((num_bearings - num_long_metrics) * 2 > len))\n+        num_bearings = num_long_metrics + len \/ 2;\n+      len -= (num_bearings - num_long_metrics) * 2;\n+\n+      \/* We MUST set num_bearings to zero if num_long_metrics is zero.\n@@ -180,6 +208,2 @@\n-      if (unlikely (!num_advances))\n-      {\n-        num_metrics = num_advances = 0;\n-        table.destroy ();\n-        table = hb_blob_get_empty ();\n-      }\n+      if (unlikely (!num_long_metrics))\n+        num_bearings = num_long_metrics = 0;\n@@ -187,1 +211,4 @@\n-      var_table = hb_sanitize_context_t ().reference_table<HVARVVAR> (face, T::variationsTag);\n+      num_advances = num_bearings + len \/ 2;\n+      num_glyphs = face->get_num_glyphs ();\n+      if (num_glyphs < num_advances)\n+        num_glyphs = num_advances;\n@@ -189,2 +216,1 @@\n-\n-    void fini ()\n+    ~accelerator_t ()\n@@ -196,0 +222,2 @@\n+    bool has_data () const { return (bool) num_bearings; }\n+\n@@ -198,1 +226,1 @@\n-      if (glyph < num_advances)\n+      if (glyph < num_long_metrics)\n@@ -201,1 +229,1 @@\n-      if (unlikely (glyph >= num_metrics))\n+      if (unlikely (glyph >= num_bearings))\n@@ -204,2 +232,2 @@\n-      const FWORD *bearings = (const FWORD *) &table->longMetricZ[num_advances];\n-      return bearings[glyph - num_advances];\n+      const FWORD *bearings = (const FWORD *) &table->longMetricZ[num_long_metrics];\n+      return bearings[glyph - num_long_metrics];\n@@ -213,1 +241,1 @@\n-      if (unlikely (glyph >= num_metrics) || !font->num_coords)\n+      if (unlikely (glyph >= num_bearings) || !font->num_coords)\n@@ -217,1 +245,1 @@\n-        return side_bearing + var_table->get_side_bearing_var (glyph, font->coords, font->num_coords); \/\/ TODO Optimize?!\n+        return side_bearing + var_table->get_side_bearing_var (glyph, font->coords, font->num_coords);\n@@ -227,10 +255,9 @@\n-      if (unlikely (glyph >= num_metrics))\n-      {\n-        \/* If num_metrics is zero, it means we don't have the metrics table\n-         * for this direction: return default advance.  Otherwise, it means that the\n-         * glyph index is out of bound: return zero. *\/\n-        if (num_metrics)\n-          return 0;\n-        else\n-          return default_advance;\n-      }\n+      \/* OpenType case. *\/\n+      if (glyph < num_bearings)\n+        return table->longMetricZ[hb_min (glyph, (uint32_t) num_long_metrics - 1)].advance;\n+\n+      \/* If num_advances is zero, it means we don't have the metrics table\n+       * for this direction: return default advance.  Otherwise, there's a\n+       * well-defined answer. *\/\n+      if (unlikely (!num_advances))\n+        return default_advance;\n@@ -238,1 +265,19 @@\n-      return table->longMetricZ[hb_min (glyph, (uint32_t) num_advances - 1)].advance;\n+#ifdef HB_NO_BORING_EXPANSION\n+      return 0;\n+#endif\n+\n+      if (unlikely (glyph >= num_glyphs))\n+        return 0;\n+\n+      \/* num_bearings <= glyph < num_glyphs;\n+       * num_bearings <= num_advances *\/\n+\n+      \/* TODO Optimize *\/\n+\n+      if (num_bearings == num_advances)\n+        return get_advance (num_bearings - 1);\n+\n+      const FWORD *bearings = (const FWORD *) &table->longMetricZ[num_long_metrics];\n+      const UFWORD *advances = (const UFWORD *) &bearings[num_bearings - num_long_metrics];\n+\n+      return advances[hb_min (glyph - num_bearings, num_advances - num_bearings - 1)];\n@@ -242,1 +287,2 @@\n-                              hb_font_t      *font) const\n+                              hb_font_t      *font,\n+                              VariationStore::cache_t *store_cache = nullptr) const\n@@ -247,1 +293,1 @@\n-      if (unlikely (glyph >= num_metrics) || !font->num_coords)\n+      if (unlikely (glyph >= num_bearings) || !font->num_coords)\n@@ -251,1 +297,1 @@\n-        return advance + roundf (var_table->get_advance_var (glyph, font)); \/\/ TODO Optimize?!\n+        return advance + roundf (var_table->get_advance_var (glyph, font, store_cache)); \/\/ TODO Optimize?!\n@@ -259,26 +305,0 @@\n-    unsigned int num_advances_for_subset (const hb_subset_plan_t *plan) const\n-    {\n-      unsigned int num_advances = plan->num_output_glyphs ();\n-      unsigned int last_advance = _advance_for_new_gid (plan,\n-                                                        num_advances - 1);\n-      while (num_advances > 1 &&\n-             last_advance == _advance_for_new_gid (plan,\n-                                                   num_advances - 2))\n-      {\n-        num_advances--;\n-      }\n-\n-      return num_advances;\n-    }\n-\n-    private:\n-    unsigned int _advance_for_new_gid (const hb_subset_plan_t *plan,\n-                                       hb_codepoint_t new_gid) const\n-    {\n-      hb_codepoint_t old_gid;\n-      if (!plan->old_gid_for_new_gid (new_gid, &old_gid))\n-        return 0;\n-\n-      return get_advance (old_gid);\n-    }\n-\n@@ -286,2 +306,6 @@\n-    unsigned int num_metrics;\n-    unsigned int num_advances;\n+    \/\/ 0 <= num_long_metrics <= num_bearings <= num_advances <= num_glyphs\n+    unsigned num_long_metrics;\n+    unsigned num_bearings;\n+    unsigned num_advances;\n+    unsigned num_glyphs;\n+\n@@ -290,1 +314,1 @@\n-    private:\n+    public:\n@@ -319,0 +343,2 @@\n+\/*UnsizedArrayOf<UFWORD>advancesX;*\/\n+                                \/* TODO Document. *\/\n@@ -334,2 +360,6 @@\n-struct hmtx_accelerator_t : hmtx::accelerator_t {};\n-struct vmtx_accelerator_t : vmtx::accelerator_t {};\n+struct hmtx_accelerator_t : hmtx::accelerator_t {\n+  hmtx_accelerator_t (hb_face_t *face) : hmtx::accelerator_t (face) {}\n+};\n+struct vmtx_accelerator_t : vmtx::accelerator_t {\n+  vmtx_accelerator_t (hb_face_t *face) : vmtx::accelerator_t (face) {}\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-hmtx-table.hh","additions":110,"deletions":80,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-    case 1:     return_trace (u.header.apple ? c->dispatch (u.format1, hb_forward<Ts> (ds)...) : c->default_return_value ());\n+    case 1:     return_trace (u.header.apple ? c->dispatch (u.format1, std::forward<Ts> (ds)...) : c->default_return_value ());\n@@ -141,1 +141,1 @@\n-    case 3:     return_trace (u.header.apple ? c->dispatch (u.format3, hb_forward<Ts> (ds)...) : c->default_return_value ());\n+    case 3:     return_trace (u.header.apple ? c->dispatch (u.format3, std::forward<Ts> (ds)...) : c->default_return_value ());\n@@ -328,1 +328,1 @@\n-    case 0:     return_trace (c->dispatch (u.ot, hb_forward<Ts> (ds)...));\n+    case 0:     return_trace (c->dispatch (u.ot, std::forward<Ts> (ds)...));\n@@ -330,1 +330,1 @@\n-    case 1:     return_trace (c->dispatch (u.aat, hb_forward<Ts> (ds)...));\n+    case 1:     return_trace (c->dispatch (u.aat, std::forward<Ts> (ds)...));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-kern-table.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,1 +44,4 @@\n-  hb_position_t get_coord () const { return coordinate; }\n+  hb_position_t get_coord (hb_font_t *font, hb_direction_t direction) const\n+  {\n+    return HB_DIRECTION_IS_HORIZONTAL (direction) ? font->em_scale_y (coordinate) : font->em_scale_x (coordinate);\n+  }\n@@ -61,1 +64,1 @@\n-  hb_position_t get_coord () const\n+  hb_position_t get_coord (hb_font_t *font, hb_direction_t direction) const\n@@ -64,1 +67,1 @@\n-    return coordinate;\n+    return HB_DIRECTION_IS_HORIZONTAL (direction) ? font->em_scale_y (coordinate) : font->em_scale_x (coordinate);\n@@ -76,1 +79,1 @@\n-  HBGlyphID     referenceGlyph; \/* Glyph ID of control glyph *\/\n+  HBGlyphID16   referenceGlyph; \/* Glyph ID of control glyph *\/\n@@ -90,3 +93,4 @@\n-    return coordinate + (HB_DIRECTION_IS_VERTICAL (direction) ?\n-                         device.get_y_delta (font, var_store) :\n-                         device.get_x_delta (font, var_store));\n+\n+    return HB_DIRECTION_IS_HORIZONTAL (direction)\n+         ? font->em_scale_y (coordinate) + device.get_y_delta (font, var_store)\n+         : font->em_scale_x (coordinate) + device.get_x_delta (font, var_store);\n@@ -106,1 +110,1 @@\n-  OffsetTo<Device>\n+  Offset16To<Device>\n@@ -123,2 +127,2 @@\n-    case 1: return u.format1.get_coord ();\n-    case 2: return u.format2.get_coord ();\n+    case 1: return u.format1.get_coord (font, direction);\n+    case 2: return u.format2.get_coord (font, direction);\n@@ -176,1 +180,1 @@\n-  OffsetTo<BaseCoord>\n+  Offset16To<BaseCoord>\n@@ -180,1 +184,1 @@\n-  OffsetTo<BaseCoord>\n+  Offset16To<BaseCoord>\n@@ -215,1 +219,1 @@\n-  OffsetTo<BaseCoord>\n+  Offset16To<BaseCoord>\n@@ -219,1 +223,1 @@\n-  OffsetTo<BaseCoord>\n+  Offset16To<BaseCoord>\n@@ -223,1 +227,1 @@\n-  SortedArrayOf<FeatMinMaxRecord>\n+  SortedArray16Of<FeatMinMaxRecord>\n@@ -250,1 +254,1 @@\n-  OffsetArrayOf<BaseCoord>\n+  Array16OfOffset16To<BaseCoord>\n@@ -278,1 +282,1 @@\n-  OffsetTo<MinMax>\n+  Offset16To<MinMax>\n@@ -308,1 +312,1 @@\n-  OffsetTo<BaseValues>\n+  Offset16To<BaseValues>\n@@ -311,1 +315,1 @@\n-  OffsetTo<MinMax>\n+  Offset16To<MinMax>\n@@ -314,1 +318,1 @@\n-  SortedArrayOf<BaseLangSysRecord>\n+  SortedArray16Of<BaseLangSysRecord>\n@@ -342,1 +346,1 @@\n-  OffsetTo<BaseScript>\n+  Offset16To<BaseScript>\n@@ -367,1 +371,1 @@\n-  SortedArrayOf<BaseScriptRecord>\n+  SortedArray16Of<BaseScriptRecord>\n@@ -429,1 +433,1 @@\n-  OffsetTo<SortedArrayOf<Tag>>\n+  Offset16To<SortedArray16Of<Tag>>\n@@ -434,1 +438,1 @@\n-  OffsetTo<BaseScriptList>\n+  Offset16To<BaseScriptList>\n@@ -504,1 +508,1 @@\n-  OffsetTo<Axis>hAxis;          \/* Offset to horizontal Axis table, from beginning\n+  Offset16To<Axis>hAxis;                \/* Offset to horizontal Axis table, from beginning\n@@ -506,1 +510,1 @@\n-  OffsetTo<Axis>vAxis;          \/* Offset to vertical Axis table, from beginning\n+  Offset16To<Axis>vAxis;                \/* Offset to vertical Axis table, from beginning\n@@ -508,1 +512,1 @@\n-  LOffsetTo<VariationStore>\n+  Offset32To<VariationStore>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-base-table.hh","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#define HB_MAX_NESTING_LEVEL    6\n+#define HB_MAX_NESTING_LEVEL    64\n@@ -63,0 +63,4 @@\n+#ifndef HB_MAX_LANGSYS_FEATURE_COUNT\n+#define HB_MAX_LANGSYS_FEATURE_COUNT 50000\n+#endif\n+\n@@ -71,2 +75,2 @@\n-#ifndef HB_MAX_LOOKUP_INDICES\n-#define HB_MAX_LOOKUP_INDICES   20000\n+#ifndef HB_MAX_LOOKUP_VISIT_COUNT\n+#define HB_MAX_LOOKUP_VISIT_COUNT       35000\n@@ -90,6 +94,39 @@\n-static void ClassDef_remap_and_serialize (hb_serialize_context_t *c,\n-                                          const hb_set_t &glyphset,\n-                                          const hb_map_t &gid_klass_map,\n-                                          hb_sorted_vector_t<HBGlyphID> &glyphs,\n-                                          const hb_set_t &klasses,\n-                                          hb_map_t *klass_map \/*INOUT*\/);\n+static void ClassDef_remap_and_serialize (\n+    hb_serialize_context_t *c,\n+    const hb_set_t &klasses,\n+    bool use_class_zero,\n+    hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> &glyph_and_klass, \/* IN\/OUT *\/\n+    hb_map_t *klass_map \/*IN\/OUT*\/);\n+\n+\n+struct hb_prune_langsys_context_t\n+{\n+  hb_prune_langsys_context_t (const void         *table_,\n+                              hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *script_langsys_map_,\n+                              const hb_map_t     *duplicate_feature_map_,\n+                              hb_set_t           *new_collected_feature_indexes_)\n+      :table (table_),\n+      script_langsys_map (script_langsys_map_),\n+      duplicate_feature_map (duplicate_feature_map_),\n+      new_feature_indexes (new_collected_feature_indexes_),\n+      script_count (0),langsys_feature_count (0) {}\n+\n+  bool visitScript ()\n+  { return script_count++ < HB_MAX_SCRIPTS; }\n+\n+  bool visitLangsys (unsigned feature_count)\n+  {\n+    langsys_feature_count += feature_count;\n+    return langsys_feature_count < HB_MAX_LANGSYS_FEATURE_COUNT;\n+  }\n+\n+  public:\n+  const void *table;\n+  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *script_langsys_map;\n+  const hb_map_t     *duplicate_feature_map;\n+  hb_set_t           *new_feature_indexes;\n+\n+  private:\n+  unsigned script_count;\n+  unsigned langsys_feature_count;\n+};\n@@ -122,1 +159,1 @@\n-    return lookup_index_count < HB_MAX_LOOKUP_INDICES;\n+    return lookup_index_count < HB_MAX_LOOKUP_VISIT_COUNT;\n@@ -128,0 +165,1 @@\n+  const hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *script_langsys_map;\n@@ -129,0 +167,1 @@\n+  unsigned cur_script_index;\n@@ -133,1 +172,2 @@\n-                              hb_map_t *feature_map_) :\n+                              hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *script_langsys_map_,\n+                              hb_map_t *feature_index_map_) :\n@@ -137,1 +177,3 @@\n-                                feature_index_map (feature_map_),\n+                                script_langsys_map (script_langsys_map_),\n+                                feature_index_map (feature_index_map_),\n+                                cur_script_index (0xFFFFu),\n@@ -181,0 +223,1 @@\n+    auto snap = subset_context->serializer->snapshot ();\n@@ -183,1 +226,0 @@\n-    auto snap = subset_context->serializer->snapshot ();\n@@ -212,0 +254,1 @@\n+    auto snap = subset_context->serializer->snapshot ();\n@@ -214,1 +257,0 @@\n-    auto snap = subset_context->serializer->snapshot ();\n@@ -290,0 +332,37 @@\n+\n+template<typename OutputArray>\n+struct serialize_math_record_array_t\n+{\n+  serialize_math_record_array_t (hb_serialize_context_t *serialize_context_,\n+                         OutputArray& out_,\n+                         const void *base_) : serialize_context (serialize_context_),\n+                                              out (out_), base (base_) {}\n+\n+  template <typename T>\n+  bool operator () (T&& record)\n+  {\n+    if (!serialize_context->copy (record, base)) return false;\n+    out.len++;\n+    return true;\n+  }\n+\n+  private:\n+  hb_serialize_context_t *serialize_context;\n+  OutputArray &out;\n+  const void *base;\n+};\n+\n+\/*\n+ * Helper to serialize an array of MATH records.\n+ *\/\n+struct\n+{\n+  template<typename OutputArray>\n+  serialize_math_record_array_t<OutputArray>\n+  operator () (hb_serialize_context_t *serialize_context, OutputArray& out,\n+               const void *base) const\n+  { return serialize_math_record_array_t<OutputArray> (serialize_context, out, base); }\n+\n+}\n+HB_FUNCOBJ (serialize_math_record_array);\n+\n@@ -328,1 +407,1 @@\n-  OffsetTo<Type>\n+  Offset16To<Type>\n@@ -336,1 +415,1 @@\n-struct RecordArrayOf : SortedArrayOf<Record<Type>>\n+struct RecordArrayOf : SortedArray16Of<Record<Type>>\n@@ -338,1 +417,1 @@\n-  const OffsetTo<Type>& get_offset (unsigned int i) const\n+  const Offset16To<Type>& get_offset (unsigned int i) const\n@@ -340,1 +419,1 @@\n-  OffsetTo<Type>& get_offset (unsigned int i)\n+  Offset16To<Type>& get_offset (unsigned int i)\n@@ -359,1 +438,1 @@\n-    return this->bfind (tag, index, HB_BFIND_NOT_FOUND_STORE, Index::NOT_FOUND_INDEX);\n+    return this->bfind (tag, index, HB_NOT_FOUND_STORE, Index::NOT_FOUND_INDEX);\n@@ -410,0 +489,24 @@\n+struct Script;\n+struct RecordListOfScript : RecordListOf<Script>\n+{\n+  bool subset (hb_subset_context_t *c,\n+               hb_subset_layout_context_t *l) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out || !c->serializer->extend_min (out))) return_trace (false);\n+\n+    unsigned count = this->len;\n+    for (auto _ : + hb_zip (*this, hb_range (count)))\n+    {\n+      auto snap = c->serializer->snapshot ();\n+      l->cur_script_index = _.second;\n+      bool ret = _.first.subset (l, this);\n+      if (!ret) c->serializer->revert (snap);\n+      else out->len++;\n+    }\n+\n+    return_trace (true);\n+  }\n+};\n+\n@@ -428,2 +531,2 @@\n-  HBGlyphID     first;          \/* First GlyphID in the range *\/\n-  HBGlyphID     last;           \/* Last GlyphID in the range *\/\n+  HBGlyphID16   first;          \/* First GlyphID in the range *\/\n+  HBGlyphID16   last;           \/* Last GlyphID in the range *\/\n@@ -437,1 +540,1 @@\n-struct IndexArray : ArrayOf<Index>\n+struct IndexArray : Array16Of<Index>\n@@ -477,1 +580,1 @@\n-    output->add_array (arrayZ, len);\n+    output->add_array (as_array ());\n@@ -509,1 +612,1 @@\n-  bool operator == (const LangSys& o) const\n+  bool compare (const LangSys& o, const hb_map_t *feature_index_map) const\n@@ -511,2 +614,1 @@\n-    if (featureIndex.len != o.featureIndex.len ||\n-        reqFeatureIndex != o.reqFeatureIndex)\n+    if (reqFeatureIndex != o.reqFeatureIndex)\n@@ -515,2 +617,20 @@\n-    for (const auto _ : + hb_zip (featureIndex, o.featureIndex))\n-      if (_.first != _.second) return false;\n+    auto iter =\n+    + hb_iter (featureIndex)\n+    | hb_filter (feature_index_map)\n+    | hb_map (feature_index_map)\n+    ;\n+\n+    auto o_iter =\n+    + hb_iter (o.featureIndex)\n+    | hb_filter (feature_index_map)\n+    | hb_map (feature_index_map)\n+    ;\n+\n+    for (; iter && o_iter; iter++, o_iter++)\n+    {\n+      unsigned a = *iter;\n+      unsigned b = *o_iter;\n+      if (a != b) return false;\n+    }\n+\n+    if (iter || o_iter) return false;\n@@ -521,0 +641,13 @@\n+  void collect_features (hb_prune_langsys_context_t *c) const\n+  {\n+    if (!has_required_feature () && !get_feature_count ()) return;\n+    if (has_required_feature () &&\n+        c->duplicate_feature_map->has (reqFeatureIndex))\n+      c->new_feature_indexes->add (get_required_feature_index ());\n+\n+    + hb_iter (featureIndex)\n+    | hb_filter (c->duplicate_feature_map)\n+    | hb_sink (c->new_feature_indexes)\n+    ;\n+  }\n+\n@@ -529,1 +662,2 @@\n-    out->reqFeatureIndex = l->feature_index_map->has (reqFeatureIndex) ? l->feature_index_map->get (reqFeatureIndex) : 0xFFFFu;\n+    const unsigned *v;\n+    out->reqFeatureIndex = l->feature_index_map->has (reqFeatureIndex, &v) ? *v : 0xFFFFu;\n@@ -584,0 +718,43 @@\n+  void prune_langsys (hb_prune_langsys_context_t *c,\n+                      unsigned script_index) const\n+  {\n+    if (!has_default_lang_sys () && !get_lang_sys_count ()) return;\n+    if (!c->visitScript ()) return;\n+\n+    if (!c->script_langsys_map->has (script_index))\n+    {\n+      if (unlikely (!c->script_langsys_map->set (script_index, hb::unique_ptr<hb_set_t> {hb_set_create ()})))\n+        return;\n+    }\n+\n+    unsigned langsys_count = get_lang_sys_count ();\n+    if (has_default_lang_sys ())\n+    {\n+      \/\/only collect features from non-redundant langsys\n+      const LangSys& d = get_default_lang_sys ();\n+      if (c->visitLangsys (d.get_feature_count ())) {\n+        d.collect_features (c);\n+      }\n+\n+      for (auto _ : + hb_zip (langSys, hb_range (langsys_count)))\n+      {\n+        const LangSys& l = this+_.first.offset;\n+        if (!c->visitLangsys (l.get_feature_count ())) continue;\n+        if (l.compare (d, c->duplicate_feature_map)) continue;\n+\n+        l.collect_features (c);\n+        c->script_langsys_map->get (script_index)->add (_.second);\n+      }\n+    }\n+    else\n+    {\n+      for (auto _ : + hb_zip (langSys, hb_range (langsys_count)))\n+      {\n+        const LangSys& l = this+_.first.offset;\n+        if (!c->visitLangsys (l.get_feature_count ())) continue;\n+        l.collect_features (c);\n+        c->script_langsys_map->get (script_index)->add (_.second);\n+      }\n+    }\n+  }\n+\n@@ -612,10 +789,11 @@\n-    + langSys.iter ()\n-    | hb_filter ([=] (const Record<LangSys>& record) {return l->visitLangSys (); })\n-    | hb_filter ([&] (const Record<LangSys>& record)\n-                 {\n-                   const LangSys& d = this+defaultLangSys;\n-                   const LangSys& l = this+record.offset;\n-                   return !(l == d);\n-                 })\n-    | hb_apply (subset_record_array (l, &(out->langSys), this))\n-    ;\n+    const hb_set_t *active_langsys = l->script_langsys_map->get (l->cur_script_index);\n+    if (active_langsys)\n+    {\n+      unsigned count = langSys.len;\n+      + hb_zip (langSys, hb_range (count))\n+      | hb_filter (active_langsys, hb_second)\n+      | hb_map (hb_first)\n+      | hb_filter ([=] (const Record<LangSys>& record) {return l->visitLangSys (); })\n+      | hb_apply (subset_record_array (l, &(out->langSys), this))\n+      ;\n+    }\n@@ -634,1 +812,1 @@\n-  OffsetTo<LangSys>\n+  Offset16To<LangSys>\n@@ -644,1 +822,1 @@\n-typedef RecordListOf<Script> ScriptList;\n+typedef RecordListOfScript ScriptList;\n@@ -656,1 +834,1 @@\n-     * Adobe tools calculated the offset of the FeatureParams sutable from the\n+     * Adobe tools calculated the offset of the FeatureParams subtable from the\n@@ -859,1 +1037,1 @@\n-  ArrayOf<HBUINT24>\n+  Array16Of<HBUINT24>\n@@ -956,1 +1134,1 @@\n-    bool subset_featureParams = out->featureParams.serialize_subset (c, featureParams, this, tag);\n+    out->featureParams.serialize_subset (c, featureParams, this, tag);\n@@ -965,2 +1143,3 @@\n-    return_trace (bool (it) || subset_featureParams\n-                  || (tag && *tag == HB_TAG ('p', 'r', 'e', 'f')));\n+    \/\/ The decision to keep or drop this feature is already made before we get here\n+    \/\/ so always retain it.\n+    return_trace (true);\n@@ -1001,1 +1180,1 @@\n-      OffsetTo<FeatureParams> new_offset;\n+      Offset16To<FeatureParams> new_offset;\n@@ -1013,1 +1192,1 @@\n-  OffsetTo<FeatureParams>\n+  Offset16To<FeatureParams>\n@@ -1052,2 +1231,2 @@\n-  const OffsetArrayOf<TSubTable>& get_subtables () const\n-  { return reinterpret_cast<const OffsetArrayOf<TSubTable> &> (subTable); }\n+  const Array16OfOffset16To<TSubTable>& get_subtables () const\n+  { return reinterpret_cast<const Array16OfOffset16To<TSubTable> &> (subTable); }\n@@ -1055,2 +1234,2 @@\n-  OffsetArrayOf<TSubTable>& get_subtables ()\n-  { return reinterpret_cast<OffsetArrayOf<TSubTable> &> (subTable); }\n+  Array16OfOffset16To<TSubTable>& get_subtables ()\n+  { return reinterpret_cast<Array16OfOffset16To<TSubTable> &> (subTable); }\n@@ -1096,1 +1275,1 @@\n-      typename context_t::return_t r = get_subtable<TSubTable> (i).dispatch (c, lookup_type, hb_forward<Ts> (ds)...);\n+      typename context_t::return_t r = get_subtable<TSubTable> (i).dispatch (c, lookup_type, std::forward<Ts> (ds)...);\n@@ -1109,1 +1288,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -1115,1 +1294,1 @@\n-      if (unlikely (!c->extend (*this))) return_trace (false);\n+      if (unlikely (!c->extend (this))) return_trace (false);\n@@ -1134,1 +1313,1 @@\n-    | hb_filter ([this, glyphset, lookup_type] (const OffsetTo<TSubTable> &_) { return (this+_).intersects (glyphset, lookup_type); })\n+    | hb_filter ([this, glyphset, lookup_type] (const Offset16To<TSubTable> &_) { return (this+_).intersects (glyphset, lookup_type); })\n@@ -1138,1 +1317,9 @@\n-    return_trace (true);\n+    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n+    {\n+      if (unlikely (!c->serializer->extend (out))) return_trace (false);\n+      const HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n+      HBUINT16 &outMarkFilteringSet = StructAfter<HBUINT16> (out->subTable);\n+      outMarkFilteringSet = markFilteringSet;\n+    }\n+\n+    return_trace (out->subTable.len);\n@@ -1159,1 +1346,1 @@\n-    if (unlikely (get_type () == TSubTable::Extension && !c->get_edit_count ()))\n+    if (unlikely (get_type () == TSubTable::Extension && subtables && !c->get_edit_count ()))\n@@ -1182,1 +1369,1 @@\n-  ArrayOf<Offset16>\n+  Array16Of<Offset16>\n@@ -1191,1 +1378,1 @@\n-typedef OffsetListOf<Lookup> LookupList;\n+typedef List16OfOffset16To<Lookup> LookupList;\n@@ -1194,1 +1381,1 @@\n-struct LookupOffsetList : OffsetListOf<TLookup>\n+struct LookupOffsetList : List16OfOffset16To<TLookup>\n@@ -1215,1 +1402,1 @@\n-    return_trace (OffsetListOf<TLookup>::sanitize (c, this));\n+    return_trace (List16OfOffset16To<TLookup>::sanitize (c, this));\n@@ -1232,1 +1419,1 @@\n-    glyphArray.bfind (glyph_id, &i, HB_BFIND_NOT_FOUND_STORE, NOT_COVERED);\n+    glyphArray.bfind (glyph_id, &i, HB_NOT_FOUND_STORE, NOT_COVERED);\n@@ -1253,4 +1440,2 @@\n-    unsigned int count = glyphArray.len;\n-    const HBGlyphID *arr = glyphArray.arrayZ;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (glyphs->has (arr[i]))\n+    for (const auto& g : glyphArray.as_array ())\n+      if (glyphs->has (g))\n@@ -1263,0 +1448,8 @@\n+  void intersected_coverage_glyphs (const hb_set_t *glyphs, hb_set_t *intersect_glyphs) const\n+  {\n+    unsigned count = glyphArray.len;\n+    for (unsigned i = 0; i < count; i++)\n+      if (glyphs->has (glyphArray[i]))\n+        intersect_glyphs->add (glyphArray[i]);\n+  }\n+\n@@ -1265,1 +1458,1 @@\n-  { return glyphs->add_sorted_array (glyphArray.arrayZ, glyphArray.len); }\n+  { return glyphs->add_sorted_array (glyphArray.as_array ()); }\n@@ -1277,1 +1470,2 @@\n-    { return i != o.i || c != o.c; }\n+    { return i != o.i; }\n+    iter_t __end__ () const { iter_t it; it.init (*c); it.i = c->glyphArray.len; return it; }\n@@ -1287,1 +1481,1 @@\n-  SortedArrayOf<HBGlyphID>\n+  SortedArray16Of<HBGlyphID16>\n@@ -1311,7 +1505,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-\n-    if (unlikely (!glyphs))\n-    {\n-      rangeRecord.len = 0;\n-      return_trace (true);\n-    }\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -1331,0 +1519,1 @@\n+    if (!num_ranges) return_trace (true);\n@@ -1359,8 +1548,2 @@\n-    \/* TODO Speed up, using hb_set_next() and bsearch()? *\/\n-    \/* TODO(iter) Rewrite as dagger. *\/\n-    unsigned count = rangeRecord.len;\n-    const RangeRecord *arr = rangeRecord.arrayZ;\n-    for (unsigned i = 0; i < count; i++)\n-      if (arr[i].intersects (glyphs))\n-        return true;\n-    return false;\n+    return hb_any (+ hb_iter (rangeRecord.as_array ())\n+                   | hb_map ([glyphs] (const RangeRecord &range) { return range.intersects (glyphs); }));\n@@ -1370,12 +1553,15 @@\n-    \/* TODO(iter) Rewrite as dagger. *\/\n-    unsigned count = rangeRecord.len;\n-    const RangeRecord *arr = rangeRecord.arrayZ;\n-    for (unsigned i = 0; i < count; i++) {\n-      const RangeRecord &range = arr[i];\n-      if (range.value <= index &&\n-          index < (unsigned int) range.value + (range.last - range.first) &&\n-          range.intersects (glyphs))\n-        return true;\n-      else if (index < range.value)\n-        return false;\n-    }\n+    auto cmp = [] (const void *pk, const void *pr) -> int\n+    {\n+      unsigned index = * (const unsigned *) pk;\n+      const RangeRecord &range = * (const RangeRecord *) pr;\n+      if (index < range.value) return -1;\n+      if (index > (unsigned int) range.value + (range.last - range.first)) return +1;\n+      return 0;\n+    };\n+\n+    auto arr = rangeRecord.as_array ();\n+    unsigned idx;\n+    if (hb_bsearch_impl (&idx, index,\n+                         arr.arrayZ, arr.length, sizeof (arr[0]),\n+                         (int (*)(const void *_key, const void *_item)) cmp))\n+      return arr.arrayZ[idx].intersects (glyphs);\n@@ -1385,0 +1571,12 @@\n+  void intersected_coverage_glyphs (const hb_set_t *glyphs, hb_set_t *intersect_glyphs) const\n+  {\n+    for (const auto& range : rangeRecord.as_array ())\n+    {\n+      if (!range.intersects (glyphs)) continue;\n+      unsigned last = range.last;\n+      for (hb_codepoint_t g = range.first - 1;\n+           glyphs->next (&g) && g <= last;)\n+        intersect_glyphs->add (g);\n+    }\n+  }\n+\n@@ -1433,0 +1631,2 @@\n+        else\n+          j = 0;\n@@ -1440,1 +1640,9 @@\n-    { return i != o.i || j != o.j || c != o.c; }\n+    { return i != o.i || j != o.j; }\n+    iter_t __end__ () const\n+    {\n+      iter_t it;\n+      it.init (*c);\n+      it.i = c->rangeRecord.len;\n+      it.j = 0;\n+      return it;\n+    }\n@@ -1451,1 +1659,1 @@\n-  SortedArrayOf<RangeRecord>\n+  SortedArray16Of<RangeRecord>\n@@ -1484,1 +1692,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -1509,3 +1717,0 @@\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n@@ -1514,2 +1719,2 @@\n-    | hb_filter (glyphset)\n-    | hb_map_retains_sorting (glyph_map)\n+    | hb_filter (c->plan->glyph_map_gsub)\n+    | hb_map_retains_sorting (c->plan->glyph_map_gsub)\n@@ -1518,3 +1723,5 @@\n-    bool ret = bool (it);\n-    Coverage_serialize (c->serializer, it);\n-    return_trace (ret);\n+    \/\/ Cache the iterator result as it will be iterated multiple times\n+    \/\/ by the serialize code below.\n+    hb_sorted_vector_t<hb_codepoint_t> glyphs (it);\n+    Coverage_serialize (c->serializer, glyphs.iter ());\n+    return_trace (bool (glyphs));\n@@ -1567,0 +1774,10 @@\n+  void intersected_coverage_glyphs (const hb_set_t *glyphs, hb_set_t *intersect_glyphs) const\n+  {\n+    switch (u.format)\n+    {\n+    case 1: return u.format1.intersected_coverage_glyphs (glyphs, intersect_glyphs);\n+    case 2: return u.format2.intersected_coverage_glyphs (glyphs, intersect_glyphs);\n+    default:return ;\n+    }\n+  }\n+\n@@ -1613,1 +1830,1 @@\n-      if (format != o.format) return true;\n+      if (unlikely (format != o.format)) return true;\n@@ -1621,0 +1838,12 @@\n+    iter_t __end__ () const\n+    {\n+      iter_t it = {};\n+      it.format = format;\n+      switch (format)\n+      {\n+      case 1: it.u.format1 = u.format1.__end__ (); break;\n+      case 2: it.u.format2 = u.format2.__end__ (); break;\n+      default: break;\n+      }\n+      return it;\n+    }\n@@ -1648,3 +1877,0 @@\n-                                          const hb_set_t &glyphset,\n-                                          const hb_map_t &gid_klass_map,\n-                                          hb_sorted_vector_t<HBGlyphID> &glyphs,\n@@ -1652,1 +1878,3 @@\n-                                          hb_map_t *klass_map \/*INOUT*\/)\n+                                          bool use_class_zero,\n+                                          hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> &glyph_and_klass, \/* IN\/OUT *\/\n+                                          hb_map_t *klass_map \/*IN\/OUT*\/)\n@@ -1656,2 +1884,1 @@\n-    ClassDef_serialize (c, hb_zip (glyphs.iter (), + glyphs.iter ()\n-                                                   | hb_map (gid_klass_map)));\n+    ClassDef_serialize (c, glyph_and_klass.iter ());\n@@ -1663,1 +1890,1 @@\n-  if (glyphset.get_population () > gid_klass_map.get_population ())\n+  if (!use_class_zero)\n@@ -1674,8 +1901,0 @@\n-  auto it =\n-  + glyphs.iter ()\n-  | hb_map_retains_sorting ([&] (const HBGlyphID& gid) -> hb_pair_t<hb_codepoint_t, unsigned>\n-                            {\n-                              unsigned new_klass = klass_map->get (gid_klass_map[gid]);\n-                              return hb_pair ((hb_codepoint_t)gid, new_klass);\n-                            })\n-  ;\n@@ -1683,2 +1902,8 @@\n-  c->propagate_error (glyphs, klasses);\n-  ClassDef_serialize (c, it);\n+  for (unsigned i = 0; i < glyph_and_klass.length; i++)\n+  {\n+    hb_codepoint_t klass = glyph_and_klass[i].second;\n+    glyph_and_klass[i].second = klass_map->get (klass);\n+  }\n+\n+  c->propagate_error (glyph_and_klass, klasses);\n+  ClassDef_serialize (c, glyph_and_klass.iter ());\n@@ -1707,1 +1932,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -1711,0 +1936,1 @@\n+      classFormat = 1;\n@@ -1733,1 +1959,4 @@\n-               hb_map_t *klass_map = nullptr \/*OUT*\/) const\n+               hb_map_t *klass_map = nullptr \/*OUT*\/,\n+               bool keep_empty_table = true,\n+               bool use_class_zero = true,\n+               const Coverage* glyph_filter = nullptr) const\n@@ -1736,2 +1965,1 @@\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map_gsub;\n@@ -1739,1 +1967,1 @@\n-    hb_sorted_vector_t<HBGlyphID> glyphs;\n+    hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> glyph_and_klass;\n@@ -1741,1 +1969,0 @@\n-    hb_map_t gid_org_klass_map;\n@@ -1745,2 +1972,2 @@\n-    for (const hb_codepoint_t gid : + hb_range (start, end)\n-                                    | hb_filter (glyphset))\n+\n+    for (const hb_codepoint_t gid : + hb_range (start, end))\n@@ -1748,0 +1975,4 @@\n+      hb_codepoint_t new_gid = glyph_map[gid];\n+      if (new_gid == HB_MAP_VALUE_INVALID) continue;\n+      if (glyph_filter && !glyph_filter->has(gid)) continue;\n+\n@@ -1751,2 +1982,1 @@\n-      glyphs.push (glyph_map[gid]);\n-      gid_org_klass_map.set (glyph_map[gid], klass);\n+      glyph_and_klass.push (hb_pair (new_gid, klass));\n@@ -1756,3 +1986,10 @@\n-    ClassDef_remap_and_serialize (c->serializer, glyphset, gid_org_klass_map,\n-                                  glyphs, orig_klasses, klass_map);\n-    return_trace ((bool) glyphs);\n+    unsigned glyph_count = glyph_filter\n+                           ? hb_len (hb_iter (glyph_map.keys()) | hb_filter (glyph_filter))\n+                           : glyph_map.get_population ();\n+    use_class_zero = use_class_zero && glyph_count <= glyph_and_klass.length;\n+    ClassDef_remap_and_serialize (c->serializer,\n+                                  orig_klasses,\n+                                  use_class_zero,\n+                                  glyph_and_klass,\n+                                  klass_map);\n+    return_trace (keep_empty_table || (bool) glyph_and_klass);\n@@ -1767,0 +2004,2 @@\n+  unsigned cost () const { return 1; }\n+\n@@ -1824,1 +2063,0 @@\n-    HBUINT16 k {klass};\n@@ -1827,1 +2065,1 @@\n-      if (arr[i] == k && glyphs->has (startGlyph + i))\n+      if (arr[i] == klass && glyphs->has (startGlyph + i))\n@@ -1832,0 +2070,49 @@\n+  void intersected_class_glyphs (const hb_set_t *glyphs, unsigned klass, hb_set_t *intersect_glyphs) const\n+  {\n+    unsigned count = classValue.len;\n+    if (klass == 0)\n+    {\n+      unsigned start_glyph = startGlyph;\n+      for (unsigned g = HB_SET_VALUE_INVALID;\n+           hb_set_next (glyphs, &g) && g < start_glyph;)\n+        intersect_glyphs->add (g);\n+\n+      for (unsigned g = startGlyph + count - 1;\n+           hb_set_next (glyphs, &g);)\n+        intersect_glyphs->add (g);\n+\n+      return;\n+    }\n+\n+    for (unsigned i = 0; i < count; i++)\n+      if (classValue[i] == klass && glyphs->has (startGlyph + i))\n+        intersect_glyphs->add (startGlyph + i);\n+\n+#if 0\n+    \/* The following implementation is faster asymptotically, but slower\n+     * in practice. *\/\n+    unsigned start_glyph = startGlyph;\n+    unsigned end_glyph = start_glyph + count;\n+    for (unsigned g = startGlyph - 1;\n+         hb_set_next (glyphs, &g) && g < end_glyph;)\n+      if (classValue.arrayZ[g - start_glyph] == klass)\n+        intersect_glyphs->add (g);\n+#endif\n+  }\n+\n+  void intersected_classes (const hb_set_t *glyphs, hb_set_t *intersect_classes) const\n+  {\n+    if (glyphs->is_empty ()) return;\n+    hb_codepoint_t end_glyph = startGlyph + classValue.len - 1;\n+    if (glyphs->get_min () < startGlyph ||\n+        glyphs->get_max () > end_glyph)\n+      intersect_classes->add (0);\n+\n+    for (const auto& _ : + hb_enumerate (classValue))\n+    {\n+      hb_codepoint_t g = startGlyph + _.first;\n+      if (glyphs->has (g))\n+        intersect_classes->add (_.second);\n+    }\n+  }\n+\n@@ -1834,2 +2121,2 @@\n-  HBGlyphID     startGlyph;     \/* First GlyphID of the classValueArray *\/\n-  ArrayOf<HBUINT16>\n+  HBGlyphID16   startGlyph;     \/* First GlyphID of the classValueArray *\/\n+  Array16Of<HBUINT16>\n@@ -1857,1 +2144,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -1861,0 +2148,1 @@\n+      classFormat = 2;\n@@ -1906,1 +2194,4 @@\n-               hb_map_t *klass_map = nullptr \/*OUT*\/) const\n+               hb_map_t *klass_map = nullptr \/*OUT*\/,\n+               bool keep_empty_table = true,\n+               bool use_class_zero = true,\n+               const Coverage* glyph_filter = nullptr) const\n@@ -1909,2 +2200,1 @@\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map_gsub;\n@@ -1912,1 +2202,1 @@\n-    hb_sorted_vector_t<HBGlyphID> glyphs;\n+    hb_sorted_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> glyph_and_klass;\n@@ -1914,1 +2204,0 @@\n-    hb_map_t gid_org_klass_map;\n@@ -1925,3 +2214,5 @@\n-        if (!glyphset.has (g)) continue;\n-        glyphs.push (glyph_map[g]);\n-        gid_org_klass_map.set (glyph_map[g], klass);\n+        hb_codepoint_t new_gid = glyph_map[g];\n+        if (new_gid == HB_MAP_VALUE_INVALID) continue;\n+        if (glyph_filter && !glyph_filter->has (g)) continue;\n+\n+        glyph_and_klass.push (hb_pair (new_gid, klass));\n@@ -1932,3 +2223,11 @@\n-    ClassDef_remap_and_serialize (c->serializer, glyphset, gid_org_klass_map,\n-                                  glyphs, orig_klasses, klass_map);\n-    return_trace ((bool) glyphs);\n+    const hb_set_t& glyphset = *c->plan->glyphset_gsub ();\n+    unsigned glyph_count = glyph_filter\n+                           ? hb_len (hb_iter (glyphset) | hb_filter (glyph_filter))\n+                           : glyph_map.get_population ();\n+    use_class_zero = use_class_zero && glyph_count <= glyph_and_klass.length;\n+    ClassDef_remap_and_serialize (c->serializer,\n+                                  orig_klasses,\n+                                  use_class_zero,\n+                                  glyph_and_klass,\n+                                  klass_map);\n+    return_trace (keep_empty_table || (bool) glyph_and_klass);\n@@ -1943,0 +2242,2 @@\n+  unsigned cost () const { return hb_bit_storage ((unsigned) rangeRecord.len); \/* bsearch cost *\/ }\n+\n@@ -2000,1 +2301,0 @@\n-    HBUINT16 k {klass};\n@@ -2003,1 +2303,1 @@\n-      if (arr[i].value == k && arr[i].intersects (glyphs))\n+      if (arr[i].value == klass && arr[i].intersects (glyphs))\n@@ -2008,0 +2308,74 @@\n+  void intersected_class_glyphs (const hb_set_t *glyphs, unsigned klass, hb_set_t *intersect_glyphs) const\n+  {\n+    unsigned count = rangeRecord.len;\n+    if (klass == 0)\n+    {\n+      hb_codepoint_t g = HB_SET_VALUE_INVALID;\n+      for (unsigned int i = 0; i < count; i++)\n+      {\n+        if (!hb_set_next (glyphs, &g))\n+          goto done;\n+        while (g < rangeRecord[i].first)\n+        {\n+          intersect_glyphs->add (g);\n+          if (!hb_set_next (glyphs, &g))\n+            goto done;\n+        }\n+        g = rangeRecord[i].last;\n+      }\n+      while (hb_set_next (glyphs, &g))\n+        intersect_glyphs->add (g);\n+      done:\n+\n+      return;\n+    }\n+\n+#if 0\n+    \/* The following implementation is faster asymptotically, but slower\n+     * in practice. *\/\n+    if ((count >> 3) > glyphs->get_population ())\n+    {\n+      for (hb_codepoint_t g = HB_SET_VALUE_INVALID;\n+           hb_set_next (glyphs, &g);)\n+        if (rangeRecord.as_array ().bfind (g))\n+          intersect_glyphs->add (g);\n+      return;\n+    }\n+#endif\n+\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (rangeRecord[i].value != klass) continue;\n+\n+      unsigned end = rangeRecord[i].last + 1;\n+      for (hb_codepoint_t g = rangeRecord[i].first - 1;\n+           hb_set_next (glyphs, &g) && g < end;)\n+        intersect_glyphs->add (g);\n+    }\n+  }\n+\n+  void intersected_classes (const hb_set_t *glyphs, hb_set_t *intersect_classes) const\n+  {\n+    if (glyphs->is_empty ()) return;\n+\n+    unsigned count = rangeRecord.len;\n+    hb_codepoint_t g = HB_SET_VALUE_INVALID;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (!hb_set_next (glyphs, &g))\n+        break;\n+      if (g < rangeRecord[i].first)\n+      {\n+        intersect_classes->add (0);\n+        break;\n+      }\n+      g = rangeRecord[i].last;\n+    }\n+    if (g != HB_SET_VALUE_INVALID && hb_set_next (glyphs, &g))\n+      intersect_classes->add (0);\n+\n+    for (const RangeRecord& record : rangeRecord.iter ())\n+      if (record.intersects (glyphs))\n+        intersect_classes->add (record.value);\n+  }\n+\n@@ -2010,1 +2384,1 @@\n-  SortedArrayOf<RangeRecord>\n+  SortedArray16Of<RangeRecord>\n@@ -2039,1 +2413,1 @@\n-  bool serialize (hb_serialize_context_t *c, Iterator it)\n+  bool serialize (hb_serialize_context_t *c, Iterator it_with_class_zero)\n@@ -2042,1 +2416,3 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+\n+    auto it = + it_with_class_zero | hb_filter (hb_second);\n@@ -2048,3 +2424,1 @@\n-      hb_codepoint_t glyph_max = + it\n-                                 | hb_map (hb_first)\n-                                 | hb_reduce (hb_max, 0u);\n+      hb_codepoint_t glyph_max = glyph_min;\n@@ -2052,0 +2426,1 @@\n+      unsigned num_glyphs = 0;\n@@ -2060,1 +2435,3 @@\n-        if (cur_gid == glyph_min || !cur_klass) continue;\n+        num_glyphs++;\n+        if (cur_gid == glyph_min) continue;\n+        if (cur_gid > glyph_max) glyph_max = cur_gid;\n@@ -2069,1 +2446,1 @@\n-      if (1 + (glyph_max - glyph_min + 1) <= num_ranges * 3)\n+      if (num_glyphs && 1 + (glyph_max - glyph_min + 1) <= num_ranges * 3)\n@@ -2083,1 +2460,4 @@\n-               hb_map_t *klass_map = nullptr \/*OUT*\/) const\n+               hb_map_t *klass_map = nullptr \/*OUT*\/,\n+               bool keep_empty_table = true,\n+               bool use_class_zero = true,\n+               const Coverage* glyph_filter = nullptr) const\n@@ -2087,2 +2467,2 @@\n-    case 1: return_trace (u.format1.subset (c, klass_map));\n-    case 2: return_trace (u.format2.subset (c, klass_map));\n+    case 1: return_trace (u.format1.subset (c, klass_map, keep_empty_table, use_class_zero, glyph_filter));\n+    case 2: return_trace (u.format2.subset (c, klass_map, keep_empty_table, use_class_zero, glyph_filter));\n@@ -2104,0 +2484,9 @@\n+  unsigned cost () const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.cost ();\n+    case 2: return u.format2.cost ();\n+    default:return 0u;\n+    }\n+  }\n+\n@@ -2145,0 +2534,19 @@\n+  void intersected_class_glyphs (const hb_set_t *glyphs, unsigned klass, hb_set_t *intersect_glyphs) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.intersected_class_glyphs (glyphs, klass, intersect_glyphs);\n+    case 2: return u.format2.intersected_class_glyphs (glyphs, klass, intersect_glyphs);\n+    default:return;\n+    }\n+  }\n+\n+  void intersected_classes (const hb_set_t *glyphs, hb_set_t *intersect_classes) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.intersected_classes (glyphs, intersect_classes);\n+    case 2: return u.format2.intersected_classes (glyphs, intersect_classes);\n+    default:return;\n+    }\n+  }\n+\n+\n@@ -2206,0 +2614,2 @@\n+#define REGION_CACHE_ITEM_CACHE_INVALID 2.f\n+\n@@ -2208,0 +2618,2 @@\n+  using cache_t = float;\n+\n@@ -2209,1 +2621,2 @@\n-                  const int *coords, unsigned int coord_len) const\n+                  const int *coords, unsigned int coord_len,\n+                  cache_t *cache = nullptr) const\n@@ -2214,0 +2627,8 @@\n+    float *cached_value = nullptr;\n+    if (cache)\n+    {\n+      cached_value = &(cache[region_index]);\n+      if (likely (*cached_value != REGION_CACHE_ITEM_CACHE_INVALID))\n+        return *cached_value;\n+    }\n+\n@@ -2223,0 +2644,3 @@\n+      {\n+        if (cache)\n+          *cached_value = 0.;\n@@ -2224,0 +2648,1 @@\n+      }\n@@ -2226,0 +2651,3 @@\n+\n+    if (cache)\n+      *cached_value = v;\n@@ -2232,2 +2660,1 @@\n-    return_trace (c->check_struct (this) &&\n-                  axesZ.sanitize (c, (unsigned int) axisCount * (unsigned int) regionCount));\n+    return_trace (c->check_struct (this) && axesZ.sanitize (c, axisCount * regionCount));\n@@ -2239,2 +2666,1 @@\n-    VarRegionList *out = c->allocate_min<VarRegionList> ();\n-    if (unlikely (!out)) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -2243,2 +2669,4 @@\n-    if (unlikely (!c->allocate_size<VarRegionList> (get_size () - min_size))) return_trace (false);\n-    unsigned int region_count = src->get_region_count ();\n+    if (unlikely (hb_unsigned_mul_overflows (axisCount * regionCount,\n+                                             VarRegionAxis::static_size))) return_trace (false);\n+    if (unlikely (!c->extend (this))) return_trace (false);\n+    unsigned int region_count = src->regionCount;\n@@ -2256,1 +2684,0 @@\n-  unsigned int get_region_count () const { return regionCount; }\n@@ -2258,1 +2685,1 @@\n-  protected:\n+  public:\n@@ -2260,1 +2687,2 @@\n-  HBUINT16      regionCount;\n+  HBUINT15      regionCount;\n+  protected:\n@@ -2273,1 +2701,1 @@\n-  { return shortCount + regionIndices.len; }\n+  { return (wordCount () + regionIndices.len) * (longWords () ? 2 : 1); }\n@@ -2276,1 +2704,4 @@\n-  { return itemCount * get_row_size (); }\n+  { return min_size\n+         - regionIndices.min_size + regionIndices.get_size ()\n+         + itemCount * get_row_size ();\n+  }\n@@ -2280,1 +2711,2 @@\n-                   const VarRegionList &regions) const\n+                   const VarRegionList &regions,\n+                   VarRegionList::cache_t *cache = nullptr) const\n@@ -2286,1 +2718,4 @@\n-   unsigned int scount = shortCount;\n+   bool is_long = longWords ();\n+   unsigned word_count = wordCount ();\n+   unsigned int scount = is_long ? count - word_count : word_count;\n+   unsigned int lcount = is_long ? word_count : 0;\n@@ -2294,1 +2729,7 @@\n-   const HBINT16 *scursor = reinterpret_cast<const HBINT16 *> (row);\n+   const HBINT16 *lcursor = reinterpret_cast<const HBINT16 *> (row);\n+   for (; i < lcount; i++)\n+   {\n+     float scalar = regions.evaluate (regionIndices.arrayZ[i], coords, coord_count, cache);\n+     delta += scalar * *lcursor++;\n+   }\n+   const HBINT16 *scursor = reinterpret_cast<const HBINT16 *> (lcursor);\n@@ -2297,1 +2738,1 @@\n-     float scalar = regions.evaluate (regionIndices.arrayZ[i], coords, coord_count);\n+     float scalar = regions.evaluate (regionIndices.arrayZ[i], coords, coord_count, cache);\n@@ -2303,1 +2744,1 @@\n-     float scalar = regions.evaluate (regionIndices.arrayZ[i], coords, coord_count);\n+     float scalar = regions.evaluate (regionIndices.arrayZ[i], coords, coord_count, cache);\n@@ -2310,4 +2751,4 @@\n-  void get_scalars (const int *coords, unsigned int coord_count,\n-                    const VarRegionList &regions,\n-                    float *scalars \/*OUT *\/,\n-                    unsigned int num_scalars) const\n+  void get_region_scalars (const int *coords, unsigned int coord_count,\n+                           const VarRegionList &regions,\n+                           float *scalars \/*OUT *\/,\n+                           unsigned int num_scalars) const\n@@ -2327,1 +2768,1 @@\n-                  shortCount <= regionIndices.len &&\n+                  wordCount () <= regionIndices.len &&\n@@ -2339,1 +2780,1 @@\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n@@ -2342,3 +2783,3 @@\n-    \/* Optimize short count *\/\n-    unsigned short ri_count = src->regionIndices.len;\n-    enum delta_size_t { kZero=0, kByte, kShort };\n+    \/* Optimize word count *\/\n+    unsigned ri_count = src->regionIndices.len;\n+    enum delta_size_t { kZero=0, kNonWord, kWord };\n@@ -2349,1 +2790,1 @@\n-    unsigned int new_short_count = 0;\n+    unsigned int new_word_count = 0;\n@@ -2351,0 +2792,21 @@\n+\n+    bool has_long = false;\n+    if (src->longWords ())\n+    {\n+      for (r = 0; r < ri_count; r++)\n+      {\n+        for (unsigned int i = 0; i < inner_map.get_next_value (); i++)\n+        {\n+          unsigned int old = inner_map.backward (i);\n+          int32_t delta = src->get_item_delta (old, r);\n+          if (delta < -65536 || 65535 < delta)\n+          {\n+            has_long = true;\n+            break;\n+          }\n+        }\n+      }\n+    }\n+\n+    signed min_threshold = has_long ? -65536 : -128;\n+    signed max_threshold = has_long ? +65535 : +127;\n@@ -2357,2 +2819,2 @@\n-        int16_t delta = src->get_item_delta (old, r);\n-        if (delta < -128 || 127 < delta)\n+        int32_t delta = src->get_item_delta (old, r);\n+        if (delta < min_threshold || max_threshold < delta)\n@@ -2360,2 +2822,2 @@\n-          delta_sz[r] = kShort;\n-          new_short_count++;\n+          delta_sz[r] = kWord;\n+          new_word_count++;\n@@ -2365,1 +2827,1 @@\n-          delta_sz[r] = kByte;\n+          delta_sz[r] = kNonWord;\n@@ -2368,2 +2830,3 @@\n-    unsigned int short_index = 0;\n-    unsigned int byte_index = new_short_count;\n+\n+    unsigned int word_index = 0;\n+    unsigned int non_word_index = new_word_count;\n@@ -2374,1 +2837,1 @@\n-        ri_map[r] = (delta_sz[r] == kShort)? short_index++ : byte_index++;\n+        ri_map[r] = (delta_sz[r] == kWord)? word_index++ : non_word_index++;\n@@ -2378,1 +2841,2 @@\n-    shortCount = new_short_count;\n+    wordSizeCount = new_word_count | (has_long ? 0x8000u \/* LONG_WORDS *\/ : 0);\n+\n@@ -2381,3 +2845,1 @@\n-    unsigned int size = regionIndices.get_size () - HBUINT16::static_size\/*regionIndices.len*\/ + (get_row_size () * itemCount);\n-    if (unlikely (!c->allocate_size<HBUINT8> (size)))\n-      return_trace (false);\n+    if (unlikely (!c->extend (this))) return_trace (false);\n@@ -2398,1 +2860,1 @@\n-  void collect_region_refs (hb_inc_bimap_t &region_map, const hb_inc_bimap_t &inner_map) const\n+  void collect_region_refs (hb_set_t &region_indices, const hb_inc_bimap_t &inner_map) const\n@@ -2403,1 +2865,1 @@\n-      if (region_map.has (region)) continue;\n+      if (region_indices.has (region)) continue;\n@@ -2407,1 +2869,1 @@\n-          region_map.add (region);\n+          region_indices.add (region);\n@@ -2420,1 +2882,1 @@\n-  int16_t get_item_delta (unsigned int item, unsigned int region) const\n+  int32_t get_item_delta (unsigned int item, unsigned int region) const\n@@ -2423,3 +2885,10 @@\n-    const HBINT8 *p = (const HBINT8 *)get_delta_bytes () + item * get_row_size ();\n-    if (region < shortCount)\n-      return ((const HBINT16 *)p)[region];\n+    const HBINT8 *p = (const HBINT8 *) get_delta_bytes () + item * get_row_size ();\n+    unsigned word_count = wordCount ();\n+    bool is_long = longWords ();\n+    if (is_long)\n+    {\n+      if (region < word_count)\n+        return ((const HBINT32 *) p)[region];\n+      else\n+        return ((const HBINT16 *)(p + HBINT32::static_size * word_count))[region - word_count];\n+    }\n@@ -2427,1 +2896,6 @@\n-      return (p + HBINT16::static_size * shortCount)[region - shortCount];\n+    {\n+      if (region < word_count)\n+        return ((const HBINT16 *) p)[region];\n+      else\n+        return (p + HBINT16::static_size * word_count)[region - word_count];\n+    }\n@@ -2430,1 +2904,1 @@\n-  void set_item_delta (unsigned int item, unsigned int region, int16_t delta)\n+  void set_item_delta (unsigned int item, unsigned int region, int32_t delta)\n@@ -2433,2 +2907,9 @@\n-    if (region < shortCount)\n-      ((HBINT16 *)p)[region] = delta;\n+    unsigned word_count = wordCount ();\n+    bool is_long = longWords ();\n+    if (is_long)\n+    {\n+      if (region < word_count)\n+        ((HBINT32 *) p)[region] = delta;\n+      else\n+        ((HBINT16 *)(p + HBINT32::static_size * word_count))[region - word_count] = delta;\n+    }\n@@ -2436,1 +2917,6 @@\n-      (p + HBINT16::static_size * shortCount)[region - shortCount] = delta;\n+    {\n+      if (region < word_count)\n+        ((HBINT16 *) p)[region] = delta;\n+      else\n+        (p + HBINT16::static_size * word_count)[region - word_count] = delta;\n+    }\n@@ -2439,0 +2925,3 @@\n+  bool longWords () const { return wordSizeCount & 0x8000u \/* LONG_WORDS *\/; }\n+  unsigned wordCount () const { return wordSizeCount & 0x7FFFu \/* WORD_DELTA_COUNT_MASK *\/; }\n+\n@@ -2441,2 +2930,2 @@\n-  HBUINT16              shortCount;\n-  ArrayOf<HBUINT16>     regionIndices;\n+  HBUINT16              wordSizeCount;\n+  Array16Of<HBUINT16>   regionIndices;\n@@ -2450,0 +2939,19 @@\n+  using cache_t = VarRegionList::cache_t;\n+\n+  cache_t *create_cache () const\n+  {\n+    auto &r = this+regions;\n+    unsigned count = r.regionCount;\n+\n+    float *cache = (float *) hb_malloc (sizeof (float) * count);\n+    if (unlikely (!cache)) return nullptr;\n+\n+    for (unsigned i = 0; i < count; i++)\n+      cache[i] = REGION_CACHE_ITEM_CACHE_INVALID;\n+\n+    return cache;\n+  }\n+\n+  static void destroy_cache (cache_t *cache) { hb_free (cache); }\n+\n+  private:\n@@ -2451,1 +2959,2 @@\n-                   const int *coords, unsigned int coord_count) const\n+                   const int *coords, unsigned int coord_count,\n+                   VarRegionList::cache_t *cache = nullptr) const\n@@ -2462,1 +2971,2 @@\n-                                             this+regions);\n+                                             this+regions,\n+                                             cache);\n@@ -2465,0 +2975,1 @@\n+  public:\n@@ -2466,1 +2977,2 @@\n-                   const int *coords, unsigned int coord_count) const\n+                   const int *coords, unsigned int coord_count,\n+                   VarRegionList::cache_t *cache = nullptr) const\n@@ -2470,1 +2982,1 @@\n-    return get_delta (outer, inner, coords, coord_count);\n+    return get_delta (outer, inner, coords, coord_count, cache);\n@@ -2491,0 +3003,2 @@\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+\n@@ -2493,1 +3007,2 @@\n-      if (inner_maps[i].get_population () > 0) set_count++;\n+      if (inner_maps[i].get_population ())\n+        set_count++;\n@@ -2495,2 +3010,0 @@\n-    unsigned int size = min_size + HBUINT32::static_size * set_count;\n-    if (unlikely (!c->allocate_size<HBUINT32> (size))) return_trace (false);\n@@ -2499,1 +3012,3 @@\n-    hb_inc_bimap_t region_map;\n+    const auto &src_regions = src+src->regions;\n+\n+    hb_set_t region_indices;\n@@ -2501,2 +3016,4 @@\n-      (src+src->dataSets[i]).collect_region_refs (region_map, inner_maps[i]);\n-    region_map.sort ();\n+      (src+src->dataSets[i]).collect_region_refs (region_indices, inner_maps[i]);\n+\n+    if (region_indices.in_error ())\n+      return_trace (false);\n@@ -2504,2 +3021,12 @@\n-    if (unlikely (!regions.serialize (c, this)\n-                  .serialize (c, &(src+src->regions), region_map))) return_trace (false);\n+    region_indices.del_range ((src_regions).regionCount, hb_set_t::INVALID);\n+\n+    \/* TODO use constructor when our data-structures support that. *\/\n+    hb_inc_bimap_t region_map;\n+    + hb_iter (region_indices)\n+    | hb_apply ([&region_map] (unsigned _) { region_map.add(_); })\n+    ;\n+    if (region_map.in_error())\n+      return_trace (false);\n+\n+    if (unlikely (!regions.serialize_serialize (c, &src_regions, region_map)))\n+      return_trace (false);\n@@ -2507,3 +3034,0 @@\n-    \/* TODO: The following code could be simplified when\n-     * OffsetListOf::subset () can take a custom param to be passed to VarData::serialize ()\n-     *\/\n@@ -2511,0 +3035,4 @@\n+    if (unlikely (!c->extend (dataSets))) return_trace (false);\n+\n+    \/* TODO: The following code could be simplified when\n+     * List16OfOffset16To::subset () can take a custom param to be passed to VarData::serialize () *\/\n@@ -2514,3 +3042,3 @@\n-      if (inner_maps[i].get_population () == 0) continue;\n-      if (unlikely (!dataSets[set_index++].serialize (c, this)\n-                      .serialize (c, &(src+src->dataSets[i]), inner_maps[i], region_map)))\n+      if (!inner_maps[i].get_population ()) continue;\n+      if (unlikely (!dataSets[set_index++]\n+                     .serialize_serialize (c, &(src+src->dataSets[i]), inner_maps[i], region_map)))\n@@ -2535,2 +3063,0 @@\n-    for (unsigned i = 0; i < inner_maps.length; i++)\n-      inner_maps[i].init ();\n@@ -2544,3 +3070,0 @@\n-      {\n-        for (unsigned i = 0; i < inner_maps.length; i++)\n-          inner_maps[i].fini ();\n@@ -2548,1 +3071,0 @@\n-      }\n@@ -2553,3 +3075,0 @@\n-    for (unsigned i = 0; i < inner_maps.length; i++)\n-      inner_maps[i].fini ();\n-\n@@ -2561,2 +3080,2 @@\n-  unsigned int get_region_index_count (unsigned int ivs) const\n-  { return (this+dataSets[ivs]).get_region_index_count (); }\n+  unsigned int get_region_index_count (unsigned int major) const\n+  { return (this+dataSets[major]).get_region_index_count (); }\n@@ -2564,4 +3083,4 @@\n-  void get_scalars (unsigned int ivs,\n-                    const int *coords, unsigned int coord_count,\n-                    float *scalars \/*OUT*\/,\n-                    unsigned int num_scalars) const\n+  void get_region_scalars (unsigned int major,\n+                           const int *coords, unsigned int coord_count,\n+                           float *scalars \/*OUT*\/,\n+                           unsigned int num_scalars) const\n@@ -2575,2 +3094,3 @@\n-    (this+dataSets[ivs]).get_scalars (coords, coord_count, this+regions,\n-                                      &scalars[0], num_scalars);\n+    (this+dataSets[major]).get_region_scalars (coords, coord_count,\n+                                               this+regions,\n+                                               &scalars[0], num_scalars);\n@@ -2583,2 +3103,2 @@\n-  LOffsetTo<VarRegionList>              regions;\n-  LOffsetArrayOf<VarData>               dataSets;\n+  Offset32To<VarRegionList>             regions;\n+  Array16OfOffset32To<VarData>          dataSets;\n@@ -2586,1 +3106,1 @@\n-  DEFINE_SIZE_ARRAY (8, dataSets);\n+  DEFINE_SIZE_ARRAY_SIZED (8, dataSets);\n@@ -2589,0 +3109,2 @@\n+#undef REGION_CACHE_ITEM_CACHE_INVALID\n+\n@@ -2643,1 +3165,1 @@\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n@@ -2687,1 +3209,2 @@\n-    return_trace (true);\n+\n+    return_trace (bool (out->conditions));\n@@ -2697,1 +3220,1 @@\n-  LOffsetArrayOf<Condition>     conditions;\n+  Array16OfOffset32To<Condition>        conditions;\n@@ -2722,0 +3245,6 @@\n+    if (!c->feature_index_map->has (featureIndex)) {\n+      \/\/ Feature that is being substituted is not being retained, so we don't\n+      \/\/ need this.\n+      return_trace (false);\n+    }\n+\n@@ -2738,1 +3267,1 @@\n-  LOffsetTo<Feature>    feature;\n+  Offset32To<Feature>   feature;\n@@ -2774,0 +3303,9 @@\n+  bool intersects_features (const hb_map_t *feature_index_map) const\n+  {\n+    for (const FeatureTableSubstitutionRecord& record : substitutions)\n+    {\n+      if (feature_index_map->has (record.featureIndex)) return true;\n+    }\n+    return false;\n+  }\n+\n@@ -2787,1 +3325,2 @@\n-    return_trace (true);\n+\n+    return_trace (bool (out->substitutions));\n@@ -2800,1 +3339,1 @@\n-  ArrayOf<FeatureTableSubstitutionRecord>\n+  Array16Of<FeatureTableSubstitutionRecord>\n@@ -2824,0 +3363,5 @@\n+  bool intersects_features (const void *base, const hb_map_t *feature_index_map) const\n+  {\n+    return (base+substitutions).intersects_features (feature_index_map);\n+  }\n+\n@@ -2844,1 +3388,1 @@\n-  LOffsetTo<ConditionSet>\n+  Offset32To<ConditionSet>\n@@ -2846,1 +3390,1 @@\n-  LOffsetTo<FeatureTableSubstitution>\n+  Offset32To<FeatureTableSubstitution>\n@@ -2910,3 +3454,12 @@\n-    + varRecords.iter ()\n-    | hb_apply (subset_record_array (l, &(out->varRecords), this))\n-    ;\n+    int keep_up_to = -1;\n+    for (int i = varRecords.len - 1; i >= 0; i--) {\n+      if (varRecords[i].intersects_features (this, l->feature_index_map)) {\n+        keep_up_to = i;\n+        break;\n+      }\n+    }\n+\n+    unsigned count = (unsigned) (keep_up_to + 1);\n+    for (unsigned i = 0; i < count; i++) {\n+      subset_record_array (l, &(out->varRecords), this) (varRecords[i]);\n+    }\n@@ -2926,1 +3479,1 @@\n-  LArrayOf<FeatureVariationRecord>\n+  Array32Of<FeatureVariationRecord>\n@@ -3025,2 +3578,4 @@\n-  hb_position_t get_x_delta (hb_font_t *font, const VariationStore &store) const\n-  { return font->em_scalef_x (get_delta (font, store)); }\n+  hb_position_t get_x_delta (hb_font_t *font,\n+                             const VariationStore &store,\n+                             VariationStore::cache_t *store_cache = nullptr) const\n+  { return font->em_scalef_x (get_delta (font, store, store_cache)); }\n@@ -3028,2 +3583,4 @@\n-  hb_position_t get_y_delta (hb_font_t *font, const VariationStore &store) const\n-  { return font->em_scalef_y (get_delta (font, store)); }\n+  hb_position_t get_y_delta (hb_font_t *font,\n+                             const VariationStore &store,\n+                             VariationStore::cache_t *store_cache = nullptr) const\n+  { return font->em_scalef_y (get_delta (font, store, store_cache)); }\n@@ -3039,2 +3596,2 @@\n-    unsigned org_idx = (outerIndex << 16) + innerIndex;\n-    if (!layout_variation_idx_map->has (org_idx))\n+    \/* TODO Just get() and bail if NO_VARIATION. Needs to setup the map to return that. *\/\n+    if (!layout_variation_idx_map->has (varIdx))\n@@ -3045,3 +3602,2 @@\n-    unsigned new_idx = layout_variation_idx_map->get (org_idx);\n-    out->outerIndex = new_idx >> 16;\n-    out->innerIndex = new_idx & 0xFFFF;\n+    unsigned new_idx = layout_variation_idx_map->get (varIdx);\n+    out->varIdx = new_idx;\n@@ -3053,2 +3609,1 @@\n-    unsigned var_idx = (outerIndex << 16) + innerIndex;\n-    layout_variation_indices->add (var_idx);\n+    layout_variation_indices->add (varIdx);\n@@ -3065,1 +3620,3 @@\n-  float get_delta (hb_font_t *font, const VariationStore &store) const\n+  float get_delta (hb_font_t *font,\n+                   const VariationStore &store,\n+                   VariationStore::cache_t *store_cache = nullptr) const\n@@ -3067,1 +3624,1 @@\n-    return store.get_delta (outerIndex, innerIndex, font->coords, font->num_coords);\n+    return store.get_delta (varIdx, font->coords, font->num_coords, (VariationStore::cache_t *) store_cache);\n@@ -3071,2 +3628,1 @@\n-  HBUINT16      outerIndex;\n-  HBUINT16      innerIndex;\n+  VarIdx        varIdx;\n@@ -3091,1 +3647,3 @@\n-  hb_position_t get_x_delta (hb_font_t *font, const VariationStore &store=Null (VariationStore)) const\n+  hb_position_t get_x_delta (hb_font_t *font,\n+                             const VariationStore &store=Null (VariationStore),\n+                             VariationStore::cache_t *store_cache = nullptr) const\n@@ -3101,1 +3659,1 @@\n-      return u.variation.get_x_delta (font, store);\n+      return u.variation.get_x_delta (font, store, store_cache);\n@@ -3107,1 +3665,3 @@\n-  hb_position_t get_y_delta (hb_font_t *font, const VariationStore &store=Null (VariationStore)) const\n+  hb_position_t get_y_delta (hb_font_t *font,\n+                             const VariationStore &store=Null (VariationStore),\n+                             VariationStore::cache_t *store_cache = nullptr) const\n@@ -3117,1 +3677,1 @@\n-      return u.variation.get_y_delta (font, store);\n+      return u.variation.get_y_delta (font, store, store_cache);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-common.hh","additions":850,"deletions":290,"binary":false,"changes":1140,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-struct AttachPoint : ArrayOf<HBUINT16>\n+struct AttachPoint : Array16Of<HBUINT16>\n@@ -87,1 +87,1 @@\n-    const hb_set_t &glyphset = *c->plan->glyphset ();\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n@@ -101,2 +101,1 @@\n-    out->coverage.serialize (c->serializer, out)\n-                 .serialize (c->serializer, new_coverage.iter ());\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n@@ -113,1 +112,1 @@\n-  OffsetTo<Coverage>\n+  Offset16To<Coverage>\n@@ -116,1 +115,1 @@\n-  OffsetArrayOf<AttachPoint>\n+  Array16OfOffset16To<AttachPoint>\n@@ -223,1 +222,1 @@\n-  OffsetTo<Device>\n+  Offset16To<Device>\n@@ -252,3 +251,3 @@\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.format2, hb_forward<Ts> (ds)...));\n-    case 3: return_trace (c->dispatch (u.format3, hb_forward<Ts> (ds)...));\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    case 3: return_trace (c->dispatch (u.format3, std::forward<Ts> (ds)...));\n@@ -332,1 +331,1 @@\n-    for (const OffsetTo<CaretValue>& offset : carets.iter ())\n+    for (const Offset16To<CaretValue>& offset : carets.iter ())\n@@ -343,1 +342,1 @@\n-  OffsetArrayOf<CaretValue>\n+  Array16OfOffset16To<CaretValue>\n@@ -375,1 +374,1 @@\n-    const hb_set_t &glyphset = *c->plan->glyphset ();\n+    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n@@ -389,2 +388,1 @@\n-    out->coverage.serialize (c->serializer, out)\n-                 .serialize (c->serializer, new_coverage.iter ());\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n@@ -411,1 +409,1 @@\n-  OffsetTo<Coverage>\n+  Offset16To<Coverage>\n@@ -414,1 +412,1 @@\n-  OffsetArrayOf<LigGlyph>\n+  Array16OfOffset16To<LigGlyph>\n@@ -435,1 +433,1 @@\n-    for (const LOffsetTo<Coverage>& offset : coverage.iter ())\n+    for (const Offset32To<Coverage>& offset : coverage.iter ())\n@@ -463,1 +461,1 @@\n-  ArrayOf<LOffsetTo<Coverage>>\n+  Array16Of<Offset32To<Coverage>>\n@@ -576,1 +574,1 @@\n-    default:                    return 0;\n+    default:                    return HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED;\n@@ -590,1 +588,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -592,2 +590,2 @@\n-      this->table = hb_sanitize_context_t ().reference_table<GDEF> (face);\n-      if (unlikely (this->table->is_blocklisted (this->table.get_blob (), face)))\n+      table = hb_sanitize_context_t ().reference_table<GDEF> (face);\n+      if (unlikely (table->is_blocklisted (table.get_blob (), face)))\n@@ -595,2 +593,2 @@\n-        hb_blob_destroy (this->table.get_blob ());\n-        this->table = hb_blob_get_empty ();\n+        hb_blob_destroy (table.get_blob ());\n+        table = hb_blob_get_empty ();\n@@ -599,2 +597,1 @@\n-\n-    void fini () { this->table.destroy (); }\n+    ~accelerator_t () { table.destroy (); }\n@@ -646,1 +643,1 @@\n-    bool subset_glyphclassdef = out->glyphClassDef.serialize_subset (c, glyphClassDef, this);\n+    bool subset_glyphclassdef = out->glyphClassDef.serialize_subset (c, glyphClassDef, this, nullptr, false, true);\n@@ -649,1 +646,1 @@\n-    bool subset_markattachclassdef = out->markAttachClassDef.serialize_subset (c, markAttachClassDef, this);\n+    bool subset_markattachclassdef = out->markAttachClassDef.serialize_subset (c, markAttachClassDef, this, nullptr, false, true);\n@@ -690,1 +687,1 @@\n-  OffsetTo<ClassDef>\n+  Offset16To<ClassDef>\n@@ -694,1 +691,1 @@\n-  OffsetTo<AttachList>\n+  Offset16To<AttachList>\n@@ -698,1 +695,1 @@\n-  OffsetTo<LigCaretList>\n+  Offset16To<LigCaretList>\n@@ -702,1 +699,1 @@\n-  OffsetTo<ClassDef>\n+  Offset16To<ClassDef>\n@@ -706,1 +703,1 @@\n-  OffsetTo<MarkGlyphSets>\n+  Offset16To<MarkGlyphSets>\n@@ -711,1 +708,1 @@\n-  LOffsetTo<VariationStore>\n+  Offset32To<VariationStore>\n@@ -720,1 +717,3 @@\n-struct GDEF_accelerator_t : GDEF::accelerator_t {};\n+struct GDEF_accelerator_t : GDEF::accelerator_t {\n+  GDEF_accelerator_t (hb_face_t *face) : GDEF::accelerator_t (face) {}\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gdef-table.hh","additions":35,"deletions":36,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -32,2 +32,1 @@\n-#include \"hb-ot-layout-gsubgpos.hh\"\n-\n+#include \"OT\/Layout\/GPOS.hh\"\n@@ -37,2764 +36,1 @@\n-struct MarkArray;\n-static void Markclass_closure_and_remap_indexes (const Coverage  &mark_coverage,\n-                                                 const MarkArray &mark_array,\n-                                                 const hb_set_t  &glyphset,\n-                                                 hb_map_t*        klass_mapping \/* INOUT *\/);\n-\n-\/* buffer **position** var allocations *\/\n-#define attach_chain() var.i16[0] \/* glyph to which this attaches to, relative to current glyphs; negative for going back, positive for forward. *\/\n-#define attach_type() var.u8[2] \/* attachment type *\/\n-\/* Note! if attach_chain() is zero, the value of attach_type() is irrelevant. *\/\n-\n-enum attach_type_t {\n-  ATTACH_TYPE_NONE      = 0X00,\n-\n-  \/* Each attachment should be either a mark or a cursive; can't be both. *\/\n-  ATTACH_TYPE_MARK      = 0X01,\n-  ATTACH_TYPE_CURSIVE   = 0X02,\n-};\n-\n-\n-\/* Shared Tables: ValueRecord, Anchor Table, and MarkArray *\/\n-\n-typedef HBUINT16 Value;\n-\n-typedef UnsizedArrayOf<Value> ValueRecord;\n-\n-struct ValueFormat : HBUINT16\n-{\n-  enum Flags {\n-    xPlacement  = 0x0001u,      \/* Includes horizontal adjustment for placement *\/\n-    yPlacement  = 0x0002u,      \/* Includes vertical adjustment for placement *\/\n-    xAdvance    = 0x0004u,      \/* Includes horizontal adjustment for advance *\/\n-    yAdvance    = 0x0008u,      \/* Includes vertical adjustment for advance *\/\n-    xPlaDevice  = 0x0010u,      \/* Includes horizontal Device table for placement *\/\n-    yPlaDevice  = 0x0020u,      \/* Includes vertical Device table for placement *\/\n-    xAdvDevice  = 0x0040u,      \/* Includes horizontal Device table for advance *\/\n-    yAdvDevice  = 0x0080u,      \/* Includes vertical Device table for advance *\/\n-    ignored     = 0x0F00u,      \/* Was used in TrueType Open for MM fonts *\/\n-    reserved    = 0xF000u,      \/* For future use *\/\n-\n-    devices     = 0x00F0u       \/* Mask for having any Device table *\/\n-  };\n-\n-\/* All fields are options.  Only those available advance the value pointer. *\/\n-#if 0\n-  HBINT16               xPlacement;     \/* Horizontal adjustment for\n-                                         * placement--in design units *\/\n-  HBINT16               yPlacement;     \/* Vertical adjustment for\n-                                         * placement--in design units *\/\n-  HBINT16               xAdvance;       \/* Horizontal adjustment for\n-                                         * advance--in design units (only used\n-                                         * for horizontal writing) *\/\n-  HBINT16               yAdvance;       \/* Vertical adjustment for advance--in\n-                                         * design units (only used for vertical\n-                                         * writing) *\/\n-  OffsetTo<Device>      xPlaDevice;     \/* Offset to Device table for\n-                                         * horizontal placement--measured from\n-                                         * beginning of PosTable (may be NULL) *\/\n-  OffsetTo<Device>      yPlaDevice;     \/* Offset to Device table for vertical\n-                                         * placement--measured from beginning\n-                                         * of PosTable (may be NULL) *\/\n-  OffsetTo<Device>      xAdvDevice;     \/* Offset to Device table for\n-                                         * horizontal advance--measured from\n-                                         * beginning of PosTable (may be NULL) *\/\n-  OffsetTo<Device>      yAdvDevice;     \/* Offset to Device table for vertical\n-                                         * advance--measured from beginning of\n-                                         * PosTable (may be NULL) *\/\n-#endif\n-\n-  unsigned int get_len () const  { return hb_popcount ((unsigned int) *this); }\n-  unsigned int get_size () const { return get_len () * Value::static_size; }\n-\n-  bool apply_value (hb_ot_apply_context_t *c,\n-                    const void            *base,\n-                    const Value           *values,\n-                    hb_glyph_position_t   &glyph_pos) const\n-  {\n-    bool ret = false;\n-    unsigned int format = *this;\n-    if (!format) return ret;\n-\n-    hb_font_t *font = c->font;\n-    bool horizontal = HB_DIRECTION_IS_HORIZONTAL (c->direction);\n-\n-    if (format & xPlacement) glyph_pos.x_offset  += font->em_scale_x (get_short (values++, &ret));\n-    if (format & yPlacement) glyph_pos.y_offset  += font->em_scale_y (get_short (values++, &ret));\n-    if (format & xAdvance) {\n-      if (likely (horizontal)) glyph_pos.x_advance += font->em_scale_x (get_short (values, &ret));\n-      values++;\n-    }\n-    \/* y_advance values grow downward but font-space grows upward, hence negation *\/\n-    if (format & yAdvance) {\n-      if (unlikely (!horizontal)) glyph_pos.y_advance -= font->em_scale_y (get_short (values, &ret));\n-      values++;\n-    }\n-\n-    if (!has_device ()) return ret;\n-\n-    bool use_x_device = font->x_ppem || font->num_coords;\n-    bool use_y_device = font->y_ppem || font->num_coords;\n-\n-    if (!use_x_device && !use_y_device) return ret;\n-\n-    const VariationStore &store = c->var_store;\n-\n-    \/* pixel -> fractional pixel *\/\n-    if (format & xPlaDevice) {\n-      if (use_x_device) glyph_pos.x_offset  += (base + get_device (values, &ret)).get_x_delta (font, store);\n-      values++;\n-    }\n-    if (format & yPlaDevice) {\n-      if (use_y_device) glyph_pos.y_offset  += (base + get_device (values, &ret)).get_y_delta (font, store);\n-      values++;\n-    }\n-    if (format & xAdvDevice) {\n-      if (horizontal && use_x_device) glyph_pos.x_advance += (base + get_device (values, &ret)).get_x_delta (font, store);\n-      values++;\n-    }\n-    if (format & yAdvDevice) {\n-      \/* y_advance values grow downward but font-space grows upward, hence negation *\/\n-      if (!horizontal && use_y_device) glyph_pos.y_advance -= (base + get_device (values, &ret)).get_y_delta (font, store);\n-      values++;\n-    }\n-    return ret;\n-  }\n-\n-  void serialize_copy (hb_serialize_context_t *c, const void *base,\n-                       const Value *values, const hb_map_t *layout_variation_idx_map) const\n-  {\n-    unsigned int format = *this;\n-    if (!format) return;\n-\n-    if (format & xPlacement) c->copy (*values++);\n-    if (format & yPlacement) c->copy (*values++);\n-    if (format & xAdvance)   c->copy (*values++);\n-    if (format & yAdvance)   c->copy (*values++);\n-\n-    if (format & xPlaDevice) copy_device (c, base, values++, layout_variation_idx_map);\n-    if (format & yPlaDevice) copy_device (c, base, values++, layout_variation_idx_map);\n-    if (format & xAdvDevice) copy_device (c, base, values++, layout_variation_idx_map);\n-    if (format & yAdvDevice) copy_device (c, base, values++, layout_variation_idx_map);\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n-                                  const void *base,\n-                                  const hb_array_t<const Value>& values) const\n-  {\n-    unsigned format = *this;\n-    unsigned i = 0;\n-    if (format & xPlacement) i++;\n-    if (format & yPlacement) i++;\n-    if (format & xAdvance) i++;\n-    if (format & yAdvance) i++;\n-    if (format & xPlaDevice)\n-    {\n-      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n-      i++;\n-    }\n-\n-    if (format & ValueFormat::yPlaDevice)\n-    {\n-      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n-      i++;\n-    }\n-\n-    if (format & ValueFormat::xAdvDevice)\n-    {\n-\n-      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n-      i++;\n-    }\n-\n-    if (format & ValueFormat::yAdvDevice)\n-    {\n-\n-      (base + get_device (&(values[i]))).collect_variation_indices (c->layout_variation_indices);\n-      i++;\n-    }\n-  }\n-\n-  private:\n-  bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const\n-  {\n-    unsigned int format = *this;\n-\n-    if (format & xPlacement) values++;\n-    if (format & yPlacement) values++;\n-    if (format & xAdvance)   values++;\n-    if (format & yAdvance)   values++;\n-\n-    if ((format & xPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n-    if ((format & yPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n-    if ((format & xAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n-    if ((format & yAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n-\n-    return true;\n-  }\n-\n-  static inline OffsetTo<Device>& get_device (Value* value)\n-  {\n-    return *static_cast<OffsetTo<Device> *> (value);\n-  }\n-  static inline const OffsetTo<Device>& get_device (const Value* value, bool *worked=nullptr)\n-  {\n-    if (worked) *worked |= bool (*value);\n-    return *static_cast<const OffsetTo<Device> *> (value);\n-  }\n-\n-  bool copy_device (hb_serialize_context_t *c, const void *base,\n-                    const Value *src_value, const hb_map_t *layout_variation_idx_map) const\n-  {\n-    Value       *dst_value = c->copy (*src_value);\n-\n-    if (!dst_value) return false;\n-    if (*dst_value == 0) return true;\n-\n-    *dst_value = 0;\n-    c->push ();\n-    if ((base + get_device (src_value)).copy (c, layout_variation_idx_map))\n-    {\n-      c->add_link (*dst_value, c->pop_pack ());\n-      return true;\n-    }\n-    else\n-    {\n-      c->pop_discard ();\n-      return false;\n-    }\n-  }\n-\n-  static inline const HBINT16& get_short (const Value* value, bool *worked=nullptr)\n-  {\n-    if (worked) *worked |= bool (*value);\n-    return *reinterpret_cast<const HBINT16 *> (value);\n-  }\n-\n-  public:\n-\n-  bool has_device () const\n-  {\n-    unsigned int format = *this;\n-    return (format & devices) != 0;\n-  }\n-\n-  bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_range (values, get_size ()) && (!has_device () || sanitize_value_devices (c, base, values)));\n-  }\n-\n-  bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const\n-  {\n-    TRACE_SANITIZE (this);\n-    unsigned int len = get_len ();\n-\n-    if (!c->check_range (values, count, get_size ())) return_trace (false);\n-\n-    if (!has_device ()) return_trace (true);\n-\n-    for (unsigned int i = 0; i < count; i++) {\n-      if (!sanitize_value_devices (c, base, values))\n-        return_trace (false);\n-      values += len;\n-    }\n-\n-    return_trace (true);\n-  }\n-\n-  \/* Just sanitize referenced Device tables.  Doesn't check the values themselves. *\/\n-  bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const\n-  {\n-    TRACE_SANITIZE (this);\n-\n-    if (!has_device ()) return_trace (true);\n-\n-    for (unsigned int i = 0; i < count; i++) {\n-      if (!sanitize_value_devices (c, base, values))\n-        return_trace (false);\n-      values += stride;\n-    }\n-\n-    return_trace (true);\n-  }\n-};\n-\n-template<typename Iterator>\n-static void SinglePos_serialize (hb_serialize_context_t *c,\n-                                 const void *src,\n-                                 Iterator it,\n-                                 ValueFormat valFormat,\n-                                 const hb_map_t *layout_variation_idx_map);\n-\n-\n-struct AnchorFormat1\n-{\n-  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,\n-                   float *x, float *y) const\n-  {\n-    hb_font_t *font = c->font;\n-    *x = font->em_fscale_x (xCoordinate);\n-    *y = font->em_fscale_y (yCoordinate);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  AnchorFormat1* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    return_trace (c->embed<AnchorFormat1> (this));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  FWORD         xCoordinate;            \/* Horizontal value--in design units *\/\n-  FWORD         yCoordinate;            \/* Vertical value--in design units *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-struct AnchorFormat2\n-{\n-  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,\n-                   float *x, float *y) const\n-  {\n-    hb_font_t *font = c->font;\n-\n-#ifdef HB_NO_HINTING\n-    *x = font->em_fscale_x (xCoordinate);\n-    *y = font->em_fscale_y (yCoordinate);\n-    return;\n-#endif\n-\n-    unsigned int x_ppem = font->x_ppem;\n-    unsigned int y_ppem = font->y_ppem;\n-    hb_position_t cx = 0, cy = 0;\n-    bool ret;\n-\n-    ret = (x_ppem || y_ppem) &&\n-          font->get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &cx, &cy);\n-    *x = ret && x_ppem ? cx : font->em_fscale_x (xCoordinate);\n-    *y = ret && y_ppem ? cy : font->em_fscale_y (yCoordinate);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this));\n-  }\n-\n-  AnchorFormat2* copy (hb_serialize_context_t *c) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    return_trace (c->embed<AnchorFormat2> (this));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n-  FWORD         xCoordinate;            \/* Horizontal value--in design units *\/\n-  FWORD         yCoordinate;            \/* Vertical value--in design units *\/\n-  HBUINT16      anchorPoint;            \/* Index to glyph contour point *\/\n-  public:\n-  DEFINE_SIZE_STATIC (8);\n-};\n-\n-struct AnchorFormat3\n-{\n-  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,\n-                   float *x, float *y) const\n-  {\n-    hb_font_t *font = c->font;\n-    *x = font->em_fscale_x (xCoordinate);\n-    *y = font->em_fscale_y (yCoordinate);\n-\n-    if (font->x_ppem || font->num_coords)\n-      *x += (this+xDeviceTable).get_x_delta (font, c->var_store);\n-    if (font->y_ppem || font->num_coords)\n-      *y += (this+yDeviceTable).get_y_delta (font, c->var_store);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && xDeviceTable.sanitize (c, this) && yDeviceTable.sanitize (c, this));\n-  }\n-\n-  AnchorFormat3* copy (hb_serialize_context_t *c,\n-                       const hb_map_t *layout_variation_idx_map) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (!layout_variation_idx_map) return_trace (nullptr);\n-\n-    auto *out = c->embed<AnchorFormat3> (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n-\n-    out->xDeviceTable.serialize_copy (c, xDeviceTable, this, 0, hb_serialize_context_t::Head, layout_variation_idx_map);\n-    out->yDeviceTable.serialize_copy (c, yDeviceTable, this, 0, hb_serialize_context_t::Head, layout_variation_idx_map);\n-    return_trace (out);\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    (this+xDeviceTable).collect_variation_indices (c->layout_variation_indices);\n-    (this+yDeviceTable).collect_variation_indices (c->layout_variation_indices);\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 3 *\/\n-  FWORD         xCoordinate;            \/* Horizontal value--in design units *\/\n-  FWORD         yCoordinate;            \/* Vertical value--in design units *\/\n-  OffsetTo<Device>\n-                xDeviceTable;           \/* Offset to Device table for X\n-                                         * coordinate-- from beginning of\n-                                         * Anchor table (may be NULL) *\/\n-  OffsetTo<Device>\n-                yDeviceTable;           \/* Offset to Device table for Y\n-                                         * coordinate-- from beginning of\n-                                         * Anchor table (may be NULL) *\/\n-  public:\n-  DEFINE_SIZE_STATIC (10);\n-};\n-\n-struct Anchor\n-{\n-  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,\n-                   float *x, float *y) const\n-  {\n-    *x = *y = 0;\n-    switch (u.format) {\n-    case 1: u.format1.get_anchor (c, glyph_id, x, y); return;\n-    case 2: u.format2.get_anchor (c, glyph_id, x, y); return;\n-    case 3: u.format3.get_anchor (c, glyph_id, x, y); return;\n-    default:                                          return;\n-    }\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (!u.format.sanitize (c)) return_trace (false);\n-    switch (u.format) {\n-    case 1: return_trace (u.format1.sanitize (c));\n-    case 2: return_trace (u.format2.sanitize (c));\n-    case 3: return_trace (u.format3.sanitize (c));\n-    default:return_trace (true);\n-    }\n-  }\n-\n-  Anchor* copy (hb_serialize_context_t *c, const hb_map_t *layout_variation_idx_map) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    switch (u.format) {\n-    case 1: return_trace (reinterpret_cast<Anchor *> (u.format1.copy (c)));\n-    case 2: return_trace (reinterpret_cast<Anchor *> (u.format2.copy (c)));\n-    case 3: return_trace (reinterpret_cast<Anchor *> (u.format3.copy (c, layout_variation_idx_map)));\n-    default:return_trace (nullptr);\n-    }\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    switch (u.format) {\n-    case 1: case 2:\n-      return;\n-    case 3:\n-      u.format3.collect_variation_indices (c);\n-      return;\n-    default: return;\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  AnchorFormat1         format1;\n-  AnchorFormat2         format2;\n-  AnchorFormat3         format3;\n-  } u;\n-  public:\n-  DEFINE_SIZE_UNION (2, format);\n-};\n-\n-\n-struct AnchorMatrix\n-{\n-  const Anchor& get_anchor (unsigned int row, unsigned int col,\n-                            unsigned int cols, bool *found) const\n-  {\n-    *found = false;\n-    if (unlikely (row >= rows || col >= cols)) return Null (Anchor);\n-    *found = !matrixZ[row * cols + col].is_null ();\n-    return this+matrixZ[row * cols + col];\n-  }\n-\n-  template <typename Iterator,\n-            hb_requires (hb_is_iterator (Iterator))>\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n-                                  Iterator index_iter) const\n-  {\n-    for (unsigned i : index_iter)\n-      (this+matrixZ[i]).collect_variation_indices (c);\n-  }\n-\n-  template <typename Iterator,\n-            hb_requires (hb_is_iterator (Iterator))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  unsigned                num_rows,\n-                  AnchorMatrix const     *offset_matrix,\n-                  const hb_map_t         *layout_variation_idx_map,\n-                  Iterator                index_iter)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (!index_iter) return_trace (false);\n-    if (unlikely (!c->extend_min ((*this))))  return_trace (false);\n-\n-    this->rows = num_rows;\n-    for (const unsigned i : index_iter)\n-    {\n-      auto *offset = c->embed (offset_matrix->matrixZ[i]);\n-      if (!offset) return_trace (false);\n-      offset->serialize_copy (c, offset_matrix->matrixZ[i],\n-                              offset_matrix, c->to_bias (this),\n-                              hb_serialize_context_t::Head,\n-                              layout_variation_idx_map);\n-    }\n-\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t *c,\n-               unsigned cols,\n-               const hb_map_t *klass_mapping) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-\n-    auto indexes =\n-    + hb_range (rows * cols)\n-    | hb_filter ([=] (unsigned index) { return klass_mapping->has (index % cols); })\n-    ;\n-\n-    out->serialize (c->serializer,\n-                    (unsigned) rows,\n-                    this,\n-                    c->plan->layout_variation_idx_map,\n-                    indexes);\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (!c->check_struct (this)) return_trace (false);\n-    if (unlikely (hb_unsigned_mul_overflows (rows, cols))) return_trace (false);\n-    unsigned int count = rows * cols;\n-    if (!c->check_array (matrixZ.arrayZ, count)) return_trace (false);\n-    for (unsigned int i = 0; i < count; i++)\n-      if (!matrixZ[i].sanitize (c, this)) return_trace (false);\n-    return_trace (true);\n-  }\n-\n-  HBUINT16      rows;                   \/* Number of rows *\/\n-  UnsizedArrayOf<OffsetTo<Anchor>>\n-                matrixZ;                \/* Matrix of offsets to Anchor tables--\n-                                         * from beginning of AnchorMatrix table *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (2, matrixZ);\n-};\n-\n-\n-struct MarkRecord\n-{\n-  friend struct MarkArray;\n-\n-  unsigned get_class () const { return (unsigned) klass; }\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) && markAnchor.sanitize (c, base));\n-  }\n-\n-  MarkRecord *copy (hb_serialize_context_t *c,\n-                    const void             *src_base,\n-                    unsigned                dst_bias,\n-                    const hb_map_t         *klass_mapping,\n-                    const hb_map_t         *layout_variation_idx_map) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->embed (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n-\n-    out->klass = klass_mapping->get (klass);\n-    out->markAnchor.serialize_copy (c, markAnchor, src_base, dst_bias, hb_serialize_context_t::Head, layout_variation_idx_map);\n-    return_trace (out);\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n-                                  const void *src_base) const\n-  {\n-    (src_base+markAnchor).collect_variation_indices (c);\n-  }\n-\n-  protected:\n-  HBUINT16      klass;                  \/* Class defined for this mark *\/\n-  OffsetTo<Anchor>\n-                markAnchor;             \/* Offset to Anchor table--from\n-                                         * beginning of MarkArray table *\/\n-  public:\n-  DEFINE_SIZE_STATIC (4);\n-};\n-\n-struct MarkArray : ArrayOf<MarkRecord>  \/* Array of MarkRecords--in Coverage order *\/\n-{\n-  bool apply (hb_ot_apply_context_t *c,\n-              unsigned int mark_index, unsigned int glyph_index,\n-              const AnchorMatrix &anchors, unsigned int class_count,\n-              unsigned int glyph_pos) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    const MarkRecord &record = ArrayOf<MarkRecord>::operator[](mark_index);\n-    unsigned int mark_class = record.klass;\n-\n-    const Anchor& mark_anchor = this + record.markAnchor;\n-    bool found;\n-    const Anchor& glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count, &found);\n-    \/* If this subtable doesn't have an anchor for this base and this class,\n-     * return false such that the subsequent subtables have a chance at it. *\/\n-    if (unlikely (!found)) return_trace (false);\n-\n-    float mark_x, mark_y, base_x, base_y;\n-\n-    buffer->unsafe_to_break (glyph_pos, buffer->idx);\n-    mark_anchor.get_anchor (c, buffer->cur().codepoint, &mark_x, &mark_y);\n-    glyph_anchor.get_anchor (c, buffer->info[glyph_pos].codepoint, &base_x, &base_y);\n-\n-    hb_glyph_position_t &o = buffer->cur_pos();\n-    o.x_offset = roundf (base_x - mark_x);\n-    o.y_offset = roundf (base_y - mark_y);\n-    o.attach_type() = ATTACH_TYPE_MARK;\n-    o.attach_chain() = (int) glyph_pos - (int) buffer->idx;\n-    buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n-\n-    buffer->idx++;\n-    return_trace (true);\n-  }\n-\n-  template<typename Iterator,\n-           hb_requires (hb_is_source_of (Iterator, MarkRecord))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  const hb_map_t         *klass_mapping,\n-                  const hb_map_t         *layout_variation_idx_map,\n-                  const void             *base,\n-                  Iterator                it)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    if (unlikely (!c->check_assign (len, it.len ()))) return_trace (false);\n-    c->copy_all (it, base, c->to_bias (this), klass_mapping, layout_variation_idx_map);\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (ArrayOf<MarkRecord>::sanitize (c, this));\n-  }\n-};\n-\n-\n-\/* Lookups *\/\n-\n-struct SinglePosFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return (this+coverage).intersects (glyphs); }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    if (!valueFormat.has_device ()) return;\n-\n-    auto it =\n-    + hb_iter (this+coverage)\n-    | hb_filter (c->glyph_set)\n-    ;\n-\n-    if (!it) return;\n-    valueFormat.collect_variation_indices (c, this, values.as_array (valueFormat.get_len ()));\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  { if (unlikely (!(this+coverage).collect_coverage (c->input))) return; }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    valueFormat.apply_value (c, this, values, buffer->cur_pos());\n-\n-    buffer->idx++;\n-    return_trace (true);\n-  }\n-\n-  template<typename Iterator,\n-           hb_requires (hb_is_iterator (Iterator))>\n-  void serialize (hb_serialize_context_t *c,\n-                  const void *src,\n-                  Iterator it,\n-                  ValueFormat valFormat,\n-                  const hb_map_t *layout_variation_idx_map)\n-  {\n-    auto out = c->extend_min (*this);\n-    if (unlikely (!out)) return;\n-    if (unlikely (!c->check_assign (valueFormat, valFormat))) return;\n-\n-    + it\n-    | hb_map (hb_second)\n-    | hb_apply ([&] (hb_array_t<const Value> _)\n-                { valFormat.serialize_copy (c, src, &_, layout_variation_idx_map); })\n-    ;\n-\n-    auto glyphs =\n-    + it\n-    | hb_map_retains_sorting (hb_first)\n-    ;\n-\n-    coverage.serialize (c, this).serialize (c, glyphs);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto it =\n-    + hb_iter (this+coverage)\n-    | hb_filter (glyphset)\n-    | hb_map_retains_sorting (glyph_map)\n-    | hb_zip (hb_repeat (values.as_array (valueFormat.get_len ())))\n-    ;\n-\n-    bool ret = bool (it);\n-    SinglePos_serialize (c->serializer, this, it, valueFormat, c->plan->layout_variation_idx_map);\n-    return_trace (ret);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  coverage.sanitize (c, this) &&\n-                  valueFormat.sanitize_value (c, this, values));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of subtable *\/\n-  ValueFormat   valueFormat;            \/* Defines the types of data in the\n-                                         * ValueRecord *\/\n-  ValueRecord   values;                 \/* Defines positioning\n-                                         * value(s)--applied to all glyphs in\n-                                         * the Coverage table *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (6, values);\n-};\n-\n-struct SinglePosFormat2\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return (this+coverage).intersects (glyphs); }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    if (!valueFormat.has_device ()) return;\n-\n-    auto it =\n-    + hb_zip (this+coverage, hb_range ((unsigned) valueCount))\n-    | hb_filter (c->glyph_set, hb_first)\n-    ;\n-\n-    if (!it) return;\n-\n-    unsigned sub_length = valueFormat.get_len ();\n-    const hb_array_t<const Value> values_array = values.as_array (valueCount * sub_length);\n-\n-    for (unsigned i : + it\n-                      | hb_map (hb_second))\n-      valueFormat.collect_variation_indices (c, this, values_array.sub_array (i * sub_length, sub_length));\n-\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  { if (unlikely (!(this+coverage).collect_coverage (c->input))) return; }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    if (likely (index >= valueCount)) return_trace (false);\n-\n-    valueFormat.apply_value (c, this,\n-                             &values[index * valueFormat.get_len ()],\n-                             buffer->cur_pos());\n-\n-    buffer->idx++;\n-    return_trace (true);\n-  }\n-\n-  template<typename Iterator,\n-           hb_requires (hb_is_iterator (Iterator))>\n-  void serialize (hb_serialize_context_t *c,\n-                  const void *src,\n-                  Iterator it,\n-                  ValueFormat valFormat,\n-                  const hb_map_t *layout_variation_idx_map)\n-  {\n-    auto out = c->extend_min (*this);\n-    if (unlikely (!out)) return;\n-    if (unlikely (!c->check_assign (valueFormat, valFormat))) return;\n-    if (unlikely (!c->check_assign (valueCount, it.len ()))) return;\n-\n-    + it\n-    | hb_map (hb_second)\n-    | hb_apply ([&] (hb_array_t<const Value> _)\n-                { valFormat.serialize_copy (c, src, &_, layout_variation_idx_map); })\n-    ;\n-\n-    auto glyphs =\n-    + it\n-    | hb_map_retains_sorting (hb_first)\n-    ;\n-\n-    coverage.serialize (c, this).serialize (c, glyphs);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    unsigned sub_length = valueFormat.get_len ();\n-    auto values_array = values.as_array (valueCount * sub_length);\n-\n-    auto it =\n-    + hb_zip (this+coverage, hb_range ((unsigned) valueCount))\n-    | hb_filter (glyphset, hb_first)\n-    | hb_map_retains_sorting ([&] (const hb_pair_t<hb_codepoint_t, unsigned>& _)\n-                              {\n-                                return hb_pair (glyph_map[_.first],\n-                                                values_array.sub_array (_.second * sub_length,\n-                                                                        sub_length));\n-                              })\n-    ;\n-\n-    bool ret = bool (it);\n-    SinglePos_serialize (c->serializer, this, it, valueFormat, c->plan->layout_variation_idx_map);\n-    return_trace (ret);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  coverage.sanitize (c, this) &&\n-                  valueFormat.sanitize_values (c, this, values, valueCount));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of subtable *\/\n-  ValueFormat   valueFormat;            \/* Defines the types of data in the\n-                                         * ValueRecord *\/\n-  HBUINT16      valueCount;             \/* Number of ValueRecords *\/\n-  ValueRecord   values;                 \/* Array of ValueRecords--positioning\n-                                         * values applied to glyphs *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (8, values);\n-};\n-\n-struct SinglePos\n-{\n-  template<typename Iterator,\n-           hb_requires (hb_is_iterator (Iterator))>\n-  unsigned get_format (Iterator glyph_val_iter_pairs)\n-  {\n-    hb_array_t<const Value> first_val_iter = hb_second (*glyph_val_iter_pairs);\n-\n-    for (const auto iter : glyph_val_iter_pairs)\n-      for (const auto _ : hb_zip (iter.second, first_val_iter))\n-        if (_.first != _.second)\n-          return 2;\n-\n-    return 1;\n-  }\n-\n-\n-  template<typename Iterator,\n-           hb_requires (hb_is_iterator (Iterator))>\n-  void serialize (hb_serialize_context_t *c,\n-                  const void *src,\n-                  Iterator glyph_val_iter_pairs,\n-                  ValueFormat valFormat,\n-                  const hb_map_t *layout_variation_idx_map)\n-  {\n-    if (unlikely (!c->extend_min (u.format))) return;\n-    unsigned format = 2;\n-\n-    if (glyph_val_iter_pairs) format = get_format (glyph_val_iter_pairs);\n-\n-    u.format = format;\n-    switch (u.format) {\n-    case 1: u.format1.serialize (c, src, glyph_val_iter_pairs, valFormat, layout_variation_idx_map);\n-            return;\n-    case 2: u.format2.serialize (c, src, glyph_val_iter_pairs, valFormat, layout_variation_idx_map);\n-            return;\n-    default:return;\n-    }\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.format2, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  SinglePosFormat1      format1;\n-  SinglePosFormat2      format2;\n-  } u;\n-};\n-\n-template<typename Iterator>\n-static void\n-SinglePos_serialize (hb_serialize_context_t *c,\n-                     const void *src,\n-                     Iterator it,\n-                     ValueFormat valFormat,\n-                     const hb_map_t *layout_variation_idx_map)\n-{ c->start_embed<SinglePos> ()->serialize (c, src, it, valFormat, layout_variation_idx_map); }\n-\n-\n-struct PairValueRecord\n-{\n-  friend struct PairSet;\n-\n-  int cmp (hb_codepoint_t k) const\n-  { return secondGlyph.cmp (k); }\n-\n-  struct serialize_closure_t\n-  {\n-    const void          *base;\n-    const ValueFormat   *valueFormats;\n-    unsigned            len1; \/* valueFormats[0].get_len() *\/\n-    const hb_map_t      *glyph_map;\n-    const hb_map_t      *layout_variation_idx_map;\n-  };\n-\n-  bool serialize (hb_serialize_context_t *c,\n-                  serialize_closure_t *closure) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->start_embed (*this);\n-    if (unlikely (!c->extend_min (out))) return_trace (false);\n-\n-    out->secondGlyph = (*closure->glyph_map)[secondGlyph];\n-\n-    closure->valueFormats[0].serialize_copy (c, closure->base, &values[0], closure->layout_variation_idx_map);\n-    closure->valueFormats[1].serialize_copy (c, closure->base, &values[closure->len1], closure->layout_variation_idx_map);\n-\n-    return_trace (true);\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n-                                  const ValueFormat *valueFormats,\n-                                  const void *base) const\n-  {\n-    unsigned record1_len = valueFormats[0].get_len ();\n-    unsigned record2_len = valueFormats[1].get_len ();\n-    const hb_array_t<const Value> values_array = values.as_array (record1_len + record2_len);\n-\n-    if (valueFormats[0].has_device ())\n-      valueFormats[0].collect_variation_indices (c, base, values_array.sub_array (0, record1_len));\n-\n-    if (valueFormats[1].has_device ())\n-      valueFormats[1].collect_variation_indices (c, base, values_array.sub_array (record1_len, record2_len));\n-  }\n-\n-  protected:\n-  HBGlyphID     secondGlyph;            \/* GlyphID of second glyph in the\n-                                         * pair--first glyph is listed in the\n-                                         * Coverage table *\/\n-  ValueRecord   values;                 \/* Positioning data for the first glyph\n-                                         * followed by for second glyph *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (2, values);\n-};\n-\n-struct PairSet\n-{\n-  friend struct PairPosFormat1;\n-\n-  bool intersects (const hb_set_t *glyphs,\n-                   const ValueFormat *valueFormats) const\n-  {\n-    unsigned int len1 = valueFormats[0].get_len ();\n-    unsigned int len2 = valueFormats[1].get_len ();\n-    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n-\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    unsigned int count = len;\n-    for (unsigned int i = 0; i < count; i++)\n-    {\n-      if (glyphs->has (record->secondGlyph))\n-        return true;\n-      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n-    }\n-    return false;\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c,\n-                       const ValueFormat *valueFormats) const\n-  {\n-    unsigned int len1 = valueFormats[0].get_len ();\n-    unsigned int len2 = valueFormats[1].get_len ();\n-    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n-\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    c->input->add_array (&record->secondGlyph, len, record_size);\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n-                                  const ValueFormat *valueFormats) const\n-  {\n-    unsigned len1 = valueFormats[0].get_len ();\n-    unsigned len2 = valueFormats[1].get_len ();\n-    unsigned record_size = HBUINT16::static_size * (1 + len1 + len2);\n-\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    unsigned count = len;\n-    for (unsigned i = 0; i < count; i++)\n-    {\n-      if (c->glyph_set->has (record->secondGlyph))\n-      { record->collect_variation_indices (c, valueFormats, this); }\n-\n-      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n-    }\n-  }\n-\n-  bool apply (hb_ot_apply_context_t *c,\n-              const ValueFormat *valueFormats,\n-              unsigned int pos) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    unsigned int len1 = valueFormats[0].get_len ();\n-    unsigned int len2 = valueFormats[1].get_len ();\n-    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n-\n-    const PairValueRecord *record = hb_bsearch (buffer->info[pos].codepoint,\n-                                                &firstPairValueRecord,\n-                                                len,\n-                                                record_size);\n-    if (record)\n-    {\n-      \/* Note the intentional use of \"|\" instead of short-circuit \"||\". *\/\n-      if (valueFormats[0].apply_value (c, this, &record->values[0], buffer->cur_pos()) |\n-          valueFormats[1].apply_value (c, this, &record->values[len1], buffer->pos[pos]))\n-        buffer->unsafe_to_break (buffer->idx, pos + 1);\n-      if (len2)\n-        pos++;\n-      buffer->idx = pos;\n-      return_trace (true);\n-    }\n-    return_trace (false);\n-  }\n-\n-  bool subset (hb_subset_context_t *c,\n-               const ValueFormat valueFormats[2]) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto snap = c->serializer->snapshot ();\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->len = 0;\n-\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    unsigned len1 = valueFormats[0].get_len ();\n-    unsigned len2 = valueFormats[1].get_len ();\n-    unsigned record_size = HBUINT16::static_size + Value::static_size * (len1 + len2);\n-\n-    PairValueRecord::serialize_closure_t closure =\n-    {\n-      this,\n-      valueFormats,\n-      len1,\n-      &glyph_map,\n-      c->plan->layout_variation_idx_map\n-    };\n-\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    unsigned count = len, num = 0;\n-    for (unsigned i = 0; i < count; i++)\n-    {\n-      if (glyphset.has (record->secondGlyph)\n-         && record->serialize (c->serializer, &closure)) num++;\n-      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n-    }\n-\n-    out->len = num;\n-    if (!num) c->serializer->revert (snap);\n-    return_trace (num);\n-  }\n-\n-  struct sanitize_closure_t\n-  {\n-    const ValueFormat *valueFormats;\n-    unsigned int len1; \/* valueFormats[0].get_len() *\/\n-    unsigned int stride; \/* 1 + len1 + len2 *\/\n-  };\n-\n-  bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (!(c->check_struct (this)\n-       && c->check_range (&firstPairValueRecord,\n-                          len,\n-                          HBUINT16::static_size,\n-                          closure->stride))) return_trace (false);\n-\n-    unsigned int count = len;\n-    const PairValueRecord *record = &firstPairValueRecord;\n-    return_trace (closure->valueFormats[0].sanitize_values_stride_unsafe (c, this, &record->values[0], count, closure->stride) &&\n-                  closure->valueFormats[1].sanitize_values_stride_unsafe (c, this, &record->values[closure->len1], count, closure->stride));\n-  }\n-\n-  protected:\n-  HBUINT16              len;    \/* Number of PairValueRecords *\/\n-  PairValueRecord       firstPairValueRecord;\n-                                \/* Array of PairValueRecords--ordered\n-                                 * by GlyphID of the second glyph *\/\n-  public:\n-  DEFINE_SIZE_MIN (2);\n-};\n-\n-struct PairPosFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    return\n-    + hb_zip (this+coverage, pairSet)\n-    | hb_filter (*glyphs, hb_first)\n-    | hb_map (hb_second)\n-    | hb_map ([glyphs, this] (const OffsetTo<PairSet> &_)\n-              { return (this+_).intersects (glyphs, valueFormat); })\n-    | hb_any\n-    ;\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    if ((!valueFormat[0].has_device ()) && (!valueFormat[1].has_device ())) return;\n-\n-    auto it =\n-    + hb_zip (this+coverage, pairSet)\n-    | hb_filter (c->glyph_set, hb_first)\n-    | hb_map (hb_second)\n-    ;\n-\n-    if (!it) return;\n-    + it\n-    | hb_map (hb_add (this))\n-    | hb_apply ([&] (const PairSet& _) { _.collect_variation_indices (c, valueFormat); })\n-    ;\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n-    unsigned int count = pairSet.len;\n-    for (unsigned int i = 0; i < count; i++)\n-      (this+pairSet[i]).collect_glyphs (c, valueFormat);\n-  }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n-    skippy_iter.reset (buffer->idx, 1);\n-    if (!skippy_iter.next ()) return_trace (false);\n-\n-    return_trace ((this+pairSet[index]).apply (c, valueFormat, skippy_iter.idx));\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->format = format;\n-    out->valueFormat[0] = valueFormat[0];\n-    out->valueFormat[1] = valueFormat[1];\n-\n-    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n-\n-    + hb_zip (this+coverage, pairSet)\n-    | hb_filter (glyphset, hb_first)\n-    | hb_filter ([this, c, out] (const OffsetTo<PairSet>& _)\n-                 {\n-                   auto *o = out->pairSet.serialize_append (c->serializer);\n-                   if (unlikely (!o)) return false;\n-                   auto snap = c->serializer->snapshot ();\n-                   bool ret = o->serialize_subset (c, _, this, valueFormat);\n-                   if (!ret)\n-                   {\n-                     out->pairSet.pop ();\n-                     c->serializer->revert (snap);\n-                   }\n-                   return ret;\n-                 },\n-                 hb_second)\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-\n-    out->coverage.serialize (c->serializer, out)\n-                 .serialize (c->serializer, new_coverage.iter ());\n-\n-    return_trace (bool (new_coverage));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-\n-    if (!c->check_struct (this)) return_trace (false);\n-\n-    unsigned int len1 = valueFormat[0].get_len ();\n-    unsigned int len2 = valueFormat[1].get_len ();\n-    PairSet::sanitize_closure_t closure =\n-    {\n-      valueFormat,\n-      len1,\n-      1 + len1 + len2\n-    };\n-\n-    return_trace (coverage.sanitize (c, this) && pairSet.sanitize (c, this, &closure));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of subtable *\/\n-  ValueFormat   valueFormat[2];         \/* [0] Defines the types of data in\n-                                         * ValueRecord1--for the first glyph\n-                                         * in the pair--may be zero (0) *\/\n-                                        \/* [1] Defines the types of data in\n-                                         * ValueRecord2--for the second glyph\n-                                         * in the pair--may be zero (0) *\/\n-  OffsetArrayOf<PairSet>\n-                pairSet;                \/* Array of PairSet tables\n-                                         * ordered by Coverage Index *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (10, pairSet);\n-};\n-\n-struct PairPosFormat2\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    return (this+coverage).intersects (glyphs) &&\n-           (this+classDef2).intersects (glyphs);\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    if ((!valueFormat1.has_device ()) && (!valueFormat2.has_device ())) return;\n-\n-    hb_set_t class1_set, class2_set;\n-    for (const unsigned cp : c->glyph_set->iter ())\n-    {\n-      unsigned klass1 = (this+classDef1).get (cp);\n-      unsigned klass2 = (this+classDef2).get (cp);\n-      class1_set.add (klass1);\n-      class2_set.add (klass2);\n-    }\n-\n-    if (class1_set.is_empty () || class2_set.is_empty ()) return;\n-\n-    unsigned len1 = valueFormat1.get_len ();\n-    unsigned len2 = valueFormat2.get_len ();\n-    const hb_array_t<const Value> values_array = values.as_array ((unsigned)class1Count * (unsigned) class2Count * (len1 + len2));\n-    for (const unsigned class1_idx : class1_set.iter ())\n-    {\n-      for (const unsigned class2_idx : class2_set.iter ())\n-      {\n-        unsigned start_offset = (class1_idx * (unsigned) class2Count + class2_idx) * (len1 + len2);\n-        if (valueFormat1.has_device ())\n-          valueFormat1.collect_variation_indices (c, this, values_array.sub_array (start_offset, len1));\n-\n-        if (valueFormat2.has_device ())\n-          valueFormat2.collect_variation_indices (c, this, values_array.sub_array (start_offset+len1, len2));\n-      }\n-    }\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n-    if (unlikely (!(this+classDef2).collect_coverage (c->input))) return;\n-  }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n-    skippy_iter.reset (buffer->idx, 1);\n-    if (!skippy_iter.next ()) return_trace (false);\n-\n-    unsigned int len1 = valueFormat1.get_len ();\n-    unsigned int len2 = valueFormat2.get_len ();\n-    unsigned int record_len = len1 + len2;\n-\n-    unsigned int klass1 = (this+classDef1).get_class (buffer->cur().codepoint);\n-    unsigned int klass2 = (this+classDef2).get_class (buffer->info[skippy_iter.idx].codepoint);\n-    if (unlikely (klass1 >= class1Count || klass2 >= class2Count)) return_trace (false);\n-\n-    const Value *v = &values[record_len * (klass1 * class2Count + klass2)];\n-    \/* Note the intentional use of \"|\" instead of short-circuit \"||\". *\/\n-    if (valueFormat1.apply_value (c, this, v, buffer->cur_pos()) |\n-        valueFormat2.apply_value (c, this, v + len1, buffer->pos[skippy_iter.idx]))\n-      buffer->unsafe_to_break (buffer->idx, skippy_iter.idx + 1);\n-\n-    buffer->idx = skippy_iter.idx;\n-    if (len2)\n-      buffer->idx++;\n-\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->format = format;\n-    out->valueFormat1 = valueFormat1;\n-    out->valueFormat2 = valueFormat2;\n-\n-    hb_map_t klass1_map;\n-    out->classDef1.serialize_subset (c, classDef1, this, &klass1_map);\n-    out->class1Count = klass1_map.get_population ();\n-\n-    hb_map_t klass2_map;\n-    out->classDef2.serialize_subset (c, classDef2, this, &klass2_map);\n-    out->class2Count = klass2_map.get_population ();\n-\n-    unsigned len1 = valueFormat1.get_len ();\n-    unsigned len2 = valueFormat2.get_len ();\n-\n-    + hb_range ((unsigned) class1Count)\n-    | hb_filter (klass1_map)\n-    | hb_apply ([&] (const unsigned class1_idx)\n-                {\n-                  + hb_range ((unsigned) class2Count)\n-                  | hb_filter (klass2_map)\n-                  | hb_apply ([&] (const unsigned class2_idx)\n-                              {\n-                                unsigned idx = (class1_idx * (unsigned) class2Count + class2_idx) * (len1 + len2);\n-                                valueFormat1.serialize_copy (c->serializer, this, &values[idx], c->plan->layout_variation_idx_map);\n-                                valueFormat2.serialize_copy (c->serializer, this, &values[idx + len1], c->plan->layout_variation_idx_map);\n-                              })\n-                  ;\n-                })\n-    ;\n-\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto it =\n-    + hb_iter (this+coverage)\n-    | hb_filter (glyphset)\n-    | hb_map_retains_sorting (glyph_map)\n-    ;\n-\n-    out->coverage.serialize (c->serializer, out).serialize (c->serializer, it);\n-    return_trace (out->class1Count && out->class2Count && bool (it));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (!(c->check_struct (this)\n-       && coverage.sanitize (c, this)\n-       && classDef1.sanitize (c, this)\n-       && classDef2.sanitize (c, this))) return_trace (false);\n-\n-    unsigned int len1 = valueFormat1.get_len ();\n-    unsigned int len2 = valueFormat2.get_len ();\n-    unsigned int stride = len1 + len2;\n-    unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();\n-    unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;\n-    return_trace (c->check_range ((const void *) values,\n-                                  count,\n-                                  record_size) &&\n-                  valueFormat1.sanitize_values_stride_unsafe (c, this, &values[0], count, stride) &&\n-                  valueFormat2.sanitize_values_stride_unsafe (c, this, &values[len1], count, stride));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of subtable *\/\n-  ValueFormat   valueFormat1;           \/* ValueRecord definition--for the\n-                                         * first glyph of the pair--may be zero\n-                                         * (0) *\/\n-  ValueFormat   valueFormat2;           \/* ValueRecord definition--for the\n-                                         * second glyph of the pair--may be\n-                                         * zero (0) *\/\n-  OffsetTo<ClassDef>\n-                classDef1;              \/* Offset to ClassDef table--from\n-                                         * beginning of PairPos subtable--for\n-                                         * the first glyph of the pair *\/\n-  OffsetTo<ClassDef>\n-                classDef2;              \/* Offset to ClassDef table--from\n-                                         * beginning of PairPos subtable--for\n-                                         * the second glyph of the pair *\/\n-  HBUINT16      class1Count;            \/* Number of classes in ClassDef1\n-                                         * table--includes Class0 *\/\n-  HBUINT16      class2Count;            \/* Number of classes in ClassDef2\n-                                         * table--includes Class0 *\/\n-  ValueRecord   values;                 \/* Matrix of value pairs:\n-                                         * class1-major, class2-minor,\n-                                         * Each entry has value1 and value2 *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (16, values);\n-};\n-\n-struct PairPos\n-{\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.format2, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  PairPosFormat1        format1;\n-  PairPosFormat2        format2;\n-  } u;\n-};\n-\n-\n-struct EntryExitRecord\n-{\n-  friend struct CursivePosFormat1;\n-\n-  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (entryAnchor.sanitize (c, base) && exitAnchor.sanitize (c, base));\n-  }\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c,\n-                                  const void *src_base) const\n-  {\n-    (src_base+entryAnchor).collect_variation_indices (c);\n-    (src_base+exitAnchor).collect_variation_indices (c);\n-  }\n-\n-  EntryExitRecord* copy (hb_serialize_context_t *c,\n-                         const void *src_base,\n-                         const void *dst_base,\n-                         const hb_map_t *layout_variation_idx_map) const\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->embed (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n-\n-    out->entryAnchor.serialize_copy (c, entryAnchor, src_base, c->to_bias (dst_base), hb_serialize_context_t::Head, layout_variation_idx_map);\n-    out->exitAnchor.serialize_copy (c, exitAnchor, src_base, c->to_bias (dst_base), hb_serialize_context_t::Head, layout_variation_idx_map);\n-    return_trace (out);\n-  }\n-\n-  protected:\n-  OffsetTo<Anchor>\n-                entryAnchor;            \/* Offset to EntryAnchor table--from\n-                                         * beginning of CursivePos\n-                                         * subtable--may be NULL *\/\n-  OffsetTo<Anchor>\n-                exitAnchor;             \/* Offset to ExitAnchor table--from\n-                                         * beginning of CursivePos\n-                                         * subtable--may be NULL *\/\n-  public:\n-  DEFINE_SIZE_STATIC (4);\n-};\n-\n-static void\n-reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent);\n-\n-struct CursivePosFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return (this+coverage).intersects (glyphs); }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    + hb_zip (this+coverage, entryExitRecord)\n-    | hb_filter (c->glyph_set, hb_first)\n-    | hb_map (hb_second)\n-    | hb_apply ([&] (const EntryExitRecord& record) { record.collect_variation_indices (c, this); })\n-    ;\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  { if (unlikely (!(this+coverage).collect_coverage (c->input))) return; }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-\n-    const EntryExitRecord &this_record = entryExitRecord[(this+coverage).get_coverage  (buffer->cur().codepoint)];\n-    if (!this_record.entryAnchor) return_trace (false);\n-\n-    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n-    skippy_iter.reset (buffer->idx, 1);\n-    if (!skippy_iter.prev ()) return_trace (false);\n-\n-    const EntryExitRecord &prev_record = entryExitRecord[(this+coverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint)];\n-    if (!prev_record.exitAnchor) return_trace (false);\n-\n-    unsigned int i = skippy_iter.idx;\n-    unsigned int j = buffer->idx;\n-\n-    buffer->unsafe_to_break (i, j);\n-    float entry_x, entry_y, exit_x, exit_y;\n-    (this+prev_record.exitAnchor).get_anchor (c, buffer->info[i].codepoint, &exit_x, &exit_y);\n-    (this+this_record.entryAnchor).get_anchor (c, buffer->info[j].codepoint, &entry_x, &entry_y);\n-\n-    hb_glyph_position_t *pos = buffer->pos;\n-\n-    hb_position_t d;\n-    \/* Main-direction adjustment *\/\n-    switch (c->direction) {\n-      case HB_DIRECTION_LTR:\n-        pos[i].x_advance  = roundf (exit_x) + pos[i].x_offset;\n-\n-        d = roundf (entry_x) + pos[j].x_offset;\n-        pos[j].x_advance -= d;\n-        pos[j].x_offset  -= d;\n-        break;\n-      case HB_DIRECTION_RTL:\n-        d = roundf (exit_x) + pos[i].x_offset;\n-        pos[i].x_advance -= d;\n-        pos[i].x_offset  -= d;\n-\n-        pos[j].x_advance  = roundf (entry_x) + pos[j].x_offset;\n-        break;\n-      case HB_DIRECTION_TTB:\n-        pos[i].y_advance  = roundf (exit_y) + pos[i].y_offset;\n-\n-        d = roundf (entry_y) + pos[j].y_offset;\n-        pos[j].y_advance -= d;\n-        pos[j].y_offset  -= d;\n-        break;\n-      case HB_DIRECTION_BTT:\n-        d = roundf (exit_y) + pos[i].y_offset;\n-        pos[i].y_advance -= d;\n-        pos[i].y_offset  -= d;\n-\n-        pos[j].y_advance  = roundf (entry_y);\n-        break;\n-      case HB_DIRECTION_INVALID:\n-      default:\n-        break;\n-    }\n-\n-    \/* Cross-direction adjustment *\/\n-\n-    \/* We attach child to parent (think graph theory and rooted trees whereas\n-     * the root stays on baseline and each node aligns itself against its\n-     * parent.\n-     *\n-     * Optimize things for the case of RightToLeft, as that's most common in\n-     * Arabic. *\/\n-    unsigned int child  = i;\n-    unsigned int parent = j;\n-    hb_position_t x_offset = entry_x - exit_x;\n-    hb_position_t y_offset = entry_y - exit_y;\n-    if  (!(c->lookup_props & LookupFlag::RightToLeft))\n-    {\n-      unsigned int k = child;\n-      child = parent;\n-      parent = k;\n-      x_offset = -x_offset;\n-      y_offset = -y_offset;\n-    }\n-\n-    \/* If child was already connected to someone else, walk through its old\n-     * chain and reverse the link direction, such that the whole tree of its\n-     * previous connection now attaches to new parent.  Watch out for case\n-     * where new parent is on the path from old chain...\n-     *\/\n-    reverse_cursive_minor_offset (pos, child, c->direction, parent);\n-\n-    pos[child].attach_type() = ATTACH_TYPE_CURSIVE;\n-    pos[child].attach_chain() = (int) parent - (int) child;\n-    buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n-    if (likely (HB_DIRECTION_IS_HORIZONTAL (c->direction)))\n-      pos[child].y_offset = y_offset;\n-    else\n-      pos[child].x_offset = x_offset;\n-\n-    \/* If parent was attached to child, break them free.\n-     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2469\n-     *\/\n-    if (unlikely (pos[parent].attach_chain() == -pos[child].attach_chain()))\n-      pos[parent].attach_chain() = 0;\n-\n-    buffer->idx++;\n-    return_trace (true);\n-  }\n-\n-  template <typename Iterator,\n-            hb_requires (hb_is_iterator (Iterator))>\n-  void serialize (hb_serialize_context_t *c,\n-                  Iterator it,\n-                  const void *src_base,\n-                  const hb_map_t *layout_variation_idx_map)\n-  {\n-    if (unlikely (!c->extend_min ((*this)))) return;\n-    this->format = 1;\n-    this->entryExitRecord.len = it.len ();\n-\n-    for (const EntryExitRecord& entry_record : + it\n-                                               | hb_map (hb_second))\n-      c->copy (entry_record, src_base, this, layout_variation_idx_map);\n-\n-    auto glyphs =\n-    + it\n-    | hb_map_retains_sorting (hb_first)\n-    ;\n-\n-    coverage.serialize (c, this).serialize (c, glyphs);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!out)) return_trace (false);\n-\n-    auto it =\n-    + hb_zip (this+coverage, entryExitRecord)\n-    | hb_filter (glyphset, hb_first)\n-    | hb_map_retains_sorting ([&] (hb_pair_t<hb_codepoint_t, const EntryExitRecord&> p) -> hb_pair_t<hb_codepoint_t, const EntryExitRecord&>\n-                              { return hb_pair (glyph_map[p.first], p.second);})\n-    ;\n-\n-    bool ret = bool (it);\n-    out->serialize (c->serializer, it, this, c->plan->layout_variation_idx_map);\n-    return_trace (ret);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (coverage.sanitize (c, this) && entryExitRecord.sanitize (c, this));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of subtable *\/\n-  ArrayOf<EntryExitRecord>\n-                entryExitRecord;        \/* Array of EntryExit records--in\n-                                         * Coverage Index order *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (6, entryExitRecord);\n-};\n-\n-struct CursivePos\n-{\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  CursivePosFormat1     format1;\n-  } u;\n-};\n-\n-\n-typedef AnchorMatrix BaseArray;         \/* base-major--\n-                                         * in order of BaseCoverage Index--,\n-                                         * mark-minor--\n-                                         * ordered by class--zero-based. *\/\n-\n-static void Markclass_closure_and_remap_indexes (const Coverage  &mark_coverage,\n-                                                 const MarkArray &mark_array,\n-                                                 const hb_set_t  &glyphset,\n-                                                 hb_map_t*        klass_mapping \/* INOUT *\/)\n-{\n-  hb_set_t orig_classes;\n-\n-  + hb_zip (mark_coverage, mark_array)\n-  | hb_filter (glyphset, hb_first)\n-  | hb_map (hb_second)\n-  | hb_map (&MarkRecord::get_class)\n-  | hb_sink (orig_classes)\n-  ;\n-\n-  unsigned idx = 0;\n-  for (auto klass : orig_classes.iter ())\n-  {\n-    if (klass_mapping->has (klass)) continue;\n-    klass_mapping->set (klass, idx);\n-    idx++;\n-  }\n-}\n-\n-struct MarkBasePosFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    return (this+markCoverage).intersects (glyphs) &&\n-           (this+baseCoverage).intersects (glyphs);\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    + hb_zip (this+markCoverage, this+markArray)\n-    | hb_filter (c->glyph_set, hb_first)\n-    | hb_map (hb_second)\n-    | hb_apply ([&] (const MarkRecord& record) { record.collect_variation_indices (c, &(this+markArray)); })\n-    ;\n-\n-    hb_map_t klass_mapping;\n-    Markclass_closure_and_remap_indexes (this+markCoverage, this+markArray, *c->glyph_set, &klass_mapping);\n-\n-    unsigned basecount = (this+baseArray).rows;\n-    auto base_iter =\n-    + hb_zip (this+baseCoverage, hb_range (basecount))\n-    | hb_filter (c->glyph_set, hb_first)\n-    | hb_map (hb_second)\n-    ;\n-\n-    hb_sorted_vector_t<unsigned> base_indexes;\n-    for (const unsigned row : base_iter)\n-    {\n-      + hb_range ((unsigned) classCount)\n-      | hb_filter (klass_mapping)\n-      | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n-      | hb_sink (base_indexes)\n-      ;\n-    }\n-    (this+baseArray).collect_variation_indices (c, base_indexes.iter ());\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+markCoverage).collect_coverage (c->input))) return;\n-    if (unlikely (!(this+baseCoverage).collect_coverage (c->input))) return;\n-  }\n-\n-  const Coverage &get_coverage () const { return this+markCoverage; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n-    if (likely (mark_index == NOT_COVERED)) return_trace (false);\n-\n-    \/* Now we search backwards for a non-mark glyph *\/\n-    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n-    skippy_iter.reset (buffer->idx, 1);\n-    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n-    do {\n-      if (!skippy_iter.prev ()) return_trace (false);\n-      \/* We only want to attach to the first of a MultipleSubst sequence.\n-       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/740\n-       * Reject others...\n-       * ...but stop if we find a mark in the MultipleSubst sequence:\n-       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1020 *\/\n-      if (!_hb_glyph_info_multiplied (&buffer->info[skippy_iter.idx]) ||\n-          0 == _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]) ||\n-          (skippy_iter.idx == 0 ||\n-           _hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx - 1]) ||\n-           _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx]) !=\n-           _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx - 1]) ||\n-           _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]) !=\n-           _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx - 1]) + 1\n-           ))\n-        break;\n-      skippy_iter.reject ();\n-    } while (true);\n-\n-    \/* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled *\/\n-    \/\/if (!_hb_glyph_info_is_base_glyph (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n-\n-    unsigned int base_index = (this+baseCoverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint);\n-    if (base_index == NOT_COVERED) return_trace (false);\n-\n-    return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->format = format;\n-\n-    hb_map_t klass_mapping;\n-    Markclass_closure_and_remap_indexes (this+markCoverage, this+markArray, glyphset, &klass_mapping);\n-\n-    if (!klass_mapping.get_population ()) return_trace (false);\n-    out->classCount = klass_mapping.get_population ();\n-\n-    auto mark_iter =\n-    + hb_zip (this+markCoverage, this+markArray)\n-    | hb_filter (glyphset, hb_first)\n-    ;\n-\n-    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n-    + mark_iter\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-\n-    if (!out->markCoverage.serialize (c->serializer, out)\n-                          .serialize (c->serializer, new_coverage.iter ()))\n-      return_trace (false);\n-\n-    out->markArray.serialize (c->serializer, out)\n-                  .serialize (c->serializer, &klass_mapping, c->plan->layout_variation_idx_map, &(this+markArray), + mark_iter\n-                                                                                                                   | hb_map (hb_second));\n-\n-    unsigned basecount = (this+baseArray).rows;\n-    auto base_iter =\n-    + hb_zip (this+baseCoverage, hb_range (basecount))\n-    | hb_filter (glyphset, hb_first)\n-    ;\n-\n-    new_coverage.reset ();\n-    + base_iter\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-\n-    if (!out->baseCoverage.serialize (c->serializer, out)\n-                          .serialize (c->serializer, new_coverage.iter ()))\n-      return_trace (false);\n-\n-    hb_sorted_vector_t<unsigned> base_indexes;\n-    for (const unsigned row : + base_iter\n-                              | hb_map (hb_second))\n-    {\n-      + hb_range ((unsigned) classCount)\n-      | hb_filter (klass_mapping)\n-      | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n-      | hb_sink (base_indexes)\n-      ;\n-    }\n-    out->baseArray.serialize (c->serializer, out)\n-                  .serialize (c->serializer, base_iter.len (), &(this+baseArray), c->plan->layout_variation_idx_map, base_indexes.iter ());\n-\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  markCoverage.sanitize (c, this) &&\n-                  baseCoverage.sanitize (c, this) &&\n-                  markArray.sanitize (c, this) &&\n-                  baseArray.sanitize (c, this, (unsigned int) classCount));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                markCoverage;           \/* Offset to MarkCoverage table--from\n-                                         * beginning of MarkBasePos subtable *\/\n-  OffsetTo<Coverage>\n-                baseCoverage;           \/* Offset to BaseCoverage table--from\n-                                         * beginning of MarkBasePos subtable *\/\n-  HBUINT16      classCount;             \/* Number of classes defined for marks *\/\n-  OffsetTo<MarkArray>\n-                markArray;              \/* Offset to MarkArray table--from\n-                                         * beginning of MarkBasePos subtable *\/\n-  OffsetTo<BaseArray>\n-                baseArray;              \/* Offset to BaseArray table--from\n-                                         * beginning of MarkBasePos subtable *\/\n-  public:\n-  DEFINE_SIZE_STATIC (12);\n-};\n-\n-struct MarkBasePos\n-{\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  MarkBasePosFormat1    format1;\n-  } u;\n-};\n-\n-\n-typedef AnchorMatrix LigatureAttach;    \/* component-major--\n-                                         * in order of writing direction--,\n-                                         * mark-minor--\n-                                         * ordered by class--zero-based. *\/\n-\n-\/* Array of LigatureAttach tables ordered by LigatureCoverage Index *\/\n-struct LigatureArray : OffsetListOf<LigatureAttach>\n-{\n-  template <typename Iterator,\n-            hb_requires (hb_is_iterator (Iterator))>\n-  bool subset (hb_subset_context_t *c,\n-               Iterator             coverage,\n-               unsigned             class_count,\n-               const hb_map_t      *klass_mapping) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-\n-    auto *out = c->serializer->start_embed (this);\n-    if (unlikely (!c->serializer->extend_min (out)))  return_trace (false);\n-\n-    for (const auto _ : + hb_zip (coverage, *this)\n-                  | hb_filter (glyphset, hb_first))\n-    {\n-      auto *matrix = out->serialize_append (c->serializer);\n-      if (unlikely (!matrix)) return_trace (false);\n-\n-      matrix->serialize_subset (c,\n-                                _.second,\n-                                this,\n-                                class_count,\n-                                klass_mapping);\n-    }\n-    return_trace (this->len);\n-  }\n-};\n-\n-struct MarkLigPosFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    return (this+markCoverage).intersects (glyphs) &&\n-           (this+ligatureCoverage).intersects (glyphs);\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    + hb_zip (this+markCoverage, this+markArray)\n-    | hb_filter (c->glyph_set, hb_first)\n-    | hb_map (hb_second)\n-    | hb_apply ([&] (const MarkRecord& record) { record.collect_variation_indices (c, &(this+markArray)); })\n-    ;\n-\n-    hb_map_t klass_mapping;\n-    Markclass_closure_and_remap_indexes (this+markCoverage, this+markArray, *c->glyph_set, &klass_mapping);\n-\n-    unsigned ligcount = (this+ligatureArray).len;\n-    auto lig_iter =\n-    + hb_zip (this+ligatureCoverage, hb_range (ligcount))\n-    | hb_filter (c->glyph_set, hb_first)\n-    | hb_map (hb_second)\n-    ;\n-\n-    const LigatureArray& lig_array = this+ligatureArray;\n-    for (const unsigned i : lig_iter)\n-    {\n-      hb_sorted_vector_t<unsigned> lig_indexes;\n-      unsigned row_count = lig_array[i].rows;\n-      for (unsigned row : + hb_range (row_count))\n-      {\n-        + hb_range ((unsigned) classCount)\n-        | hb_filter (klass_mapping)\n-        | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n-        | hb_sink (lig_indexes)\n-        ;\n-      }\n-\n-      lig_array[i].collect_variation_indices (c, lig_indexes.iter ());\n-    }\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+markCoverage).collect_coverage (c->input))) return;\n-    if (unlikely (!(this+ligatureCoverage).collect_coverage (c->input))) return;\n-  }\n-\n-  const Coverage &get_coverage () const { return this+markCoverage; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n-    if (likely (mark_index == NOT_COVERED)) return_trace (false);\n-\n-    \/* Now we search backwards for a non-mark glyph *\/\n-    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n-    skippy_iter.reset (buffer->idx, 1);\n-    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n-    if (!skippy_iter.prev ()) return_trace (false);\n-\n-    \/* Checking that matched glyph is actually a ligature by GDEF is too strong; disabled *\/\n-    \/\/if (!_hb_glyph_info_is_ligature (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n-\n-    unsigned int j = skippy_iter.idx;\n-    unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer->info[j].codepoint);\n-    if (lig_index == NOT_COVERED) return_trace (false);\n-\n-    const LigatureArray& lig_array = this+ligatureArray;\n-    const LigatureAttach& lig_attach = lig_array[lig_index];\n-\n-    \/* Find component to attach to *\/\n-    unsigned int comp_count = lig_attach.rows;\n-    if (unlikely (!comp_count)) return_trace (false);\n-\n-    \/* We must now check whether the ligature ID of the current mark glyph\n-     * is identical to the ligature ID of the found ligature.  If yes, we\n-     * can directly use the component index.  If not, we attach the mark\n-     * glyph to the last component of the ligature. *\/\n-    unsigned int comp_index;\n-    unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n-    unsigned int mark_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n-    unsigned int mark_comp = _hb_glyph_info_get_lig_comp (&buffer->cur());\n-    if (lig_id && lig_id == mark_id && mark_comp > 0)\n-      comp_index = hb_min (comp_count, _hb_glyph_info_get_lig_comp (&buffer->cur())) - 1;\n-    else\n-      comp_index = comp_count - 1;\n-\n-    return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->format = format;\n-\n-    hb_map_t klass_mapping;\n-    Markclass_closure_and_remap_indexes (this+markCoverage, this+markArray, glyphset, &klass_mapping);\n-\n-    if (!klass_mapping.get_population ()) return_trace (false);\n-    out->classCount = klass_mapping.get_population ();\n-\n-    auto mark_iter =\n-    + hb_zip (this+markCoverage, this+markArray)\n-    | hb_filter (glyphset, hb_first)\n-    ;\n-\n-    auto new_mark_coverage =\n-    + mark_iter\n-    | hb_map_retains_sorting (hb_first)\n-    | hb_map_retains_sorting (glyph_map)\n-    ;\n-\n-    if (!out->markCoverage.serialize (c->serializer, out)\n-                          .serialize (c->serializer, new_mark_coverage))\n-      return_trace (false);\n-\n-    out->markArray.serialize (c->serializer, out)\n-                  .serialize (c->serializer,\n-                              &klass_mapping,\n-                              c->plan->layout_variation_idx_map,\n-                              &(this+markArray),\n-                              + mark_iter\n-                              | hb_map (hb_second));\n-\n-    auto new_ligature_coverage =\n-    + hb_iter (this + ligatureCoverage)\n-    | hb_filter (glyphset)\n-    | hb_map_retains_sorting (glyph_map)\n-    ;\n-\n-    if (!out->ligatureCoverage.serialize (c->serializer, out)\n-                              .serialize (c->serializer, new_ligature_coverage))\n-      return_trace (false);\n-\n-    out->ligatureArray.serialize_subset (c, ligatureArray, this,\n-                                         hb_iter (this+ligatureCoverage), classCount, &klass_mapping);\n-\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  markCoverage.sanitize (c, this) &&\n-                  ligatureCoverage.sanitize (c, this) &&\n-                  markArray.sanitize (c, this) &&\n-                  ligatureArray.sanitize (c, this, (unsigned int) classCount));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                markCoverage;           \/* Offset to Mark Coverage table--from\n-                                         * beginning of MarkLigPos subtable *\/\n-  OffsetTo<Coverage>\n-                ligatureCoverage;       \/* Offset to Ligature Coverage\n-                                         * table--from beginning of MarkLigPos\n-                                         * subtable *\/\n-  HBUINT16      classCount;             \/* Number of defined mark classes *\/\n-  OffsetTo<MarkArray>\n-                markArray;              \/* Offset to MarkArray table--from\n-                                         * beginning of MarkLigPos subtable *\/\n-  OffsetTo<LigatureArray>\n-                ligatureArray;          \/* Offset to LigatureArray table--from\n-                                         * beginning of MarkLigPos subtable *\/\n-  public:\n-  DEFINE_SIZE_STATIC (12);\n-};\n-\n-\n-struct MarkLigPos\n-{\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  MarkLigPosFormat1     format1;\n-  } u;\n-};\n-\n-\n-typedef AnchorMatrix Mark2Array;        \/* mark2-major--\n-                                         * in order of Mark2Coverage Index--,\n-                                         * mark1-minor--\n-                                         * ordered by class--zero-based. *\/\n-\n-struct MarkMarkPosFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    return (this+mark1Coverage).intersects (glyphs) &&\n-           (this+mark2Coverage).intersects (glyphs);\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    + hb_zip (this+mark1Coverage, this+mark1Array)\n-    | hb_filter (c->glyph_set, hb_first)\n-    | hb_map (hb_second)\n-    | hb_apply ([&] (const MarkRecord& record) { record.collect_variation_indices (c, &(this+mark1Array)); })\n-    ;\n-\n-    hb_map_t klass_mapping;\n-    Markclass_closure_and_remap_indexes (this+mark1Coverage, this+mark1Array, *c->glyph_set, &klass_mapping);\n-\n-    unsigned mark2_count = (this+mark2Array).rows;\n-    auto mark2_iter =\n-    + hb_zip (this+mark2Coverage, hb_range (mark2_count))\n-    | hb_filter (c->glyph_set, hb_first)\n-    | hb_map (hb_second)\n-    ;\n-\n-    hb_sorted_vector_t<unsigned> mark2_indexes;\n-    for (const unsigned row : mark2_iter)\n-    {\n-      + hb_range ((unsigned) classCount)\n-      | hb_filter (klass_mapping)\n-      | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n-      | hb_sink (mark2_indexes)\n-      ;\n-    }\n-    (this+mark2Array).collect_variation_indices (c, mark2_indexes.iter ());\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+mark1Coverage).collect_coverage (c->input))) return;\n-    if (unlikely (!(this+mark2Coverage).collect_coverage (c->input))) return;\n-  }\n-\n-  const Coverage &get_coverage () const { return this+mark1Coverage; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_buffer_t *buffer = c->buffer;\n-    unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer->cur().codepoint);\n-    if (likely (mark1_index == NOT_COVERED)) return_trace (false);\n-\n-    \/* now we search backwards for a suitable mark glyph until a non-mark glyph *\/\n-    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n-    skippy_iter.reset (buffer->idx, 1);\n-    skippy_iter.set_lookup_props (c->lookup_props & ~LookupFlag::IgnoreFlags);\n-    if (!skippy_iter.prev ()) return_trace (false);\n-\n-    if (!_hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n-\n-    unsigned int j = skippy_iter.idx;\n-\n-    unsigned int id1 = _hb_glyph_info_get_lig_id (&buffer->cur());\n-    unsigned int id2 = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n-    unsigned int comp1 = _hb_glyph_info_get_lig_comp (&buffer->cur());\n-    unsigned int comp2 = _hb_glyph_info_get_lig_comp (&buffer->info[j]);\n-\n-    if (likely (id1 == id2))\n-    {\n-      if (id1 == 0) \/* Marks belonging to the same base. *\/\n-        goto good;\n-      else if (comp1 == comp2) \/* Marks belonging to the same ligature component. *\/\n-        goto good;\n-    }\n-    else\n-    {\n-      \/* If ligature ids don't match, it may be the case that one of the marks\n-       * itself is a ligature.  In which case match. *\/\n-      if ((id1 > 0 && !comp1) || (id2 > 0 && !comp2))\n-        goto good;\n-    }\n-\n-    \/* Didn't match. *\/\n-    return_trace (false);\n-\n-    good:\n-    unsigned int mark2_index = (this+mark2Coverage).get_coverage  (buffer->info[j].codepoint);\n-    if (mark2_index == NOT_COVERED) return_trace (false);\n-\n-    return_trace ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->format = format;\n-\n-    hb_map_t klass_mapping;\n-    Markclass_closure_and_remap_indexes (this+mark1Coverage, this+mark1Array, glyphset, &klass_mapping);\n-\n-    if (!klass_mapping.get_population ()) return_trace (false);\n-    out->classCount = klass_mapping.get_population ();\n-\n-    auto mark1_iter =\n-    + hb_zip (this+mark1Coverage, this+mark1Array)\n-    | hb_filter (glyphset, hb_first)\n-    ;\n-\n-    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n-    + mark1_iter\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-\n-    if (!out->mark1Coverage.serialize (c->serializer, out)\n-                           .serialize (c->serializer, new_coverage.iter ()))\n-      return_trace (false);\n-\n-    out->mark1Array.serialize (c->serializer, out)\n-                   .serialize (c->serializer, &klass_mapping, c->plan->layout_variation_idx_map, &(this+mark1Array), + mark1_iter\n-                                                                                                                     | hb_map (hb_second));\n-\n-    unsigned mark2count = (this+mark2Array).rows;\n-    auto mark2_iter =\n-    + hb_zip (this+mark2Coverage, hb_range (mark2count))\n-    | hb_filter (glyphset, hb_first)\n-    ;\n-\n-    new_coverage.reset ();\n-    + mark2_iter\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-\n-    if (!out->mark2Coverage.serialize (c->serializer, out)\n-                           .serialize (c->serializer, new_coverage.iter ()))\n-      return_trace (false);\n-\n-    hb_sorted_vector_t<unsigned> mark2_indexes;\n-    for (const unsigned row : + mark2_iter\n-                              | hb_map (hb_second))\n-    {\n-      + hb_range ((unsigned) classCount)\n-      | hb_filter (klass_mapping)\n-      | hb_map ([&] (const unsigned col) { return row * (unsigned) classCount + col; })\n-      | hb_sink (mark2_indexes)\n-      ;\n-    }\n-    out->mark2Array.serialize (c->serializer, out)\n-                   .serialize (c->serializer, mark2_iter.len (), &(this+mark2Array), c->plan->layout_variation_idx_map, mark2_indexes.iter ());\n-\n-    return_trace (true);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  mark1Coverage.sanitize (c, this) &&\n-                  mark2Coverage.sanitize (c, this) &&\n-                  mark1Array.sanitize (c, this) &&\n-                  mark2Array.sanitize (c, this, (unsigned int) classCount));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                mark1Coverage;          \/* Offset to Combining Mark1 Coverage\n-                                         * table--from beginning of MarkMarkPos\n-                                         * subtable *\/\n-  OffsetTo<Coverage>\n-                mark2Coverage;          \/* Offset to Combining Mark2 Coverage\n-                                         * table--from beginning of MarkMarkPos\n-                                         * subtable *\/\n-  HBUINT16      classCount;             \/* Number of defined mark classes *\/\n-  OffsetTo<MarkArray>\n-                mark1Array;             \/* Offset to Mark1Array table--from\n-                                         * beginning of MarkMarkPos subtable *\/\n-  OffsetTo<Mark2Array>\n-                mark2Array;             \/* Offset to Mark2Array table--from\n-                                         * beginning of MarkMarkPos subtable *\/\n-  public:\n-  DEFINE_SIZE_STATIC (12);\n-};\n-\n-struct MarkMarkPos\n-{\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  MarkMarkPosFormat1    format1;\n-  } u;\n-};\n-\n-\n-struct ContextPos : Context {};\n-\n-struct ChainContextPos : ChainContext {};\n-\n-struct ExtensionPos : Extension<ExtensionPos>\n-{\n-  typedef struct PosLookupSubTable SubTable;\n-};\n-\n-\n-\n-\/*\n- * PosLookup\n- *\/\n-\n-\n-struct PosLookupSubTable\n-{\n-  friend struct Lookup;\n-  friend struct PosLookup;\n-\n-  enum Type {\n-    Single              = 1,\n-    Pair                = 2,\n-    Cursive             = 3,\n-    MarkBase            = 4,\n-    MarkLig             = 5,\n-    MarkMark            = 6,\n-    Context             = 7,\n-    ChainContext        = 8,\n-    Extension           = 9\n-  };\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, lookup_type);\n-    switch (lookup_type) {\n-    case Single:                return_trace (u.single.dispatch (c, hb_forward<Ts> (ds)...));\n-    case Pair:                  return_trace (u.pair.dispatch (c, hb_forward<Ts> (ds)...));\n-    case Cursive:               return_trace (u.cursive.dispatch (c, hb_forward<Ts> (ds)...));\n-    case MarkBase:              return_trace (u.markBase.dispatch (c, hb_forward<Ts> (ds)...));\n-    case MarkLig:               return_trace (u.markLig.dispatch (c, hb_forward<Ts> (ds)...));\n-    case MarkMark:              return_trace (u.markMark.dispatch (c, hb_forward<Ts> (ds)...));\n-    case Context:               return_trace (u.context.dispatch (c, hb_forward<Ts> (ds)...));\n-    case ChainContext:          return_trace (u.chainContext.dispatch (c, hb_forward<Ts> (ds)...));\n-    case Extension:             return_trace (u.extension.dispatch (c, hb_forward<Ts> (ds)...));\n-    default:                    return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  bool intersects (const hb_set_t *glyphs, unsigned int lookup_type) const\n-  {\n-    hb_intersects_context_t c (glyphs);\n-    return dispatch (&c, lookup_type);\n-  }\n-\n-  protected:\n-  union {\n-  SinglePos             single;\n-  PairPos               pair;\n-  CursivePos            cursive;\n-  MarkBasePos           markBase;\n-  MarkLigPos            markLig;\n-  MarkMarkPos           markMark;\n-  ContextPos            context;\n-  ChainContextPos       chainContext;\n-  ExtensionPos          extension;\n-  } u;\n-  public:\n-  DEFINE_SIZE_MIN (0);\n-};\n-\n-\n-struct PosLookup : Lookup\n-{\n-  typedef struct PosLookupSubTable SubTable;\n-\n-  const SubTable& get_subtable (unsigned int i) const\n-  { return Lookup::get_subtable<SubTable> (i); }\n-\n-  bool is_reverse () const\n-  {\n-    return false;\n-  }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    return_trace (dispatch (c));\n-  }\n-\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    hb_intersects_context_t c (glyphs);\n-    return dispatch (&c);\n-  }\n-\n-  hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  { return dispatch (c); }\n-\n-  hb_closure_lookups_context_t::return_t closure_lookups (hb_closure_lookups_context_t *c, unsigned this_index) const\n-  {\n-    if (c->is_lookup_visited (this_index))\n-      return hb_closure_lookups_context_t::default_return_value ();\n-\n-    c->set_lookup_visited (this_index);\n-    if (!intersects (c->glyphs))\n-    {\n-      c->set_lookup_inactive (this_index);\n-      return hb_closure_lookups_context_t::default_return_value ();\n-    }\n-    c->set_recurse_func (dispatch_closure_lookups_recurse_func);\n-\n-    hb_closure_lookups_context_t::return_t ret = dispatch (c);\n-    return ret;\n-  }\n-\n-  template <typename set_t>\n-  void collect_coverage (set_t *glyphs) const\n-  {\n-    hb_collect_coverage_context_t<set_t> c (glyphs);\n-    dispatch (&c);\n-  }\n-\n-  static inline bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);\n-\n-  template <typename context_t>\n-  static typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n-\n-  HB_INTERNAL static hb_closure_lookups_context_t::return_t dispatch_closure_lookups_recurse_func (hb_closure_lookups_context_t *c, unsigned this_index);\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  { return Lookup::dispatch<SubTable> (c, hb_forward<Ts> (ds)...); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  { return Lookup::subset<SubTable> (c); }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  { return Lookup::sanitize<SubTable> (c); }\n-};\n-\n-\/*\n- * GPOS -- Glyph Positioning\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gpos\n- *\/\n-\n-struct GPOS : GSUBGPOS\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_GPOS;\n-\n-  const PosLookup& get_lookup (unsigned int i) const\n-  { return static_cast<const PosLookup &> (GSUBGPOS::get_lookup (i)); }\n-\n-  static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);\n-  static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);\n-  static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    hb_subset_layout_context_t l (c, tableTag, c->plan->gpos_lookups, c->plan->gpos_features);\n-    return GSUBGPOS::subset<PosLookup> (&l);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  { return GSUBGPOS::sanitize<PosLookup> (c); }\n-\n-  HB_INTERNAL bool is_blocklisted (hb_blob_t *blob,\n-                                   hb_face_t *face) const;\n-\n-  void collect_variation_indices (hb_collect_variation_indices_context_t *c) const\n-  {\n-    for (unsigned i = 0; i < GSUBGPOS::get_lookup_count (); i++)\n-    {\n-      if (!c->gpos_lookups->has (i)) continue;\n-      const PosLookup &l = get_lookup (i);\n-      l.dispatch (c);\n-    }\n-  }\n-\n-  void closure_lookups (hb_face_t      *face,\n-                        const hb_set_t *glyphs,\n-                        hb_set_t       *lookup_indexes \/* IN\/OUT *\/) const\n-  { GSUBGPOS::closure_lookups<PosLookup> (face, glyphs, lookup_indexes); }\n-\n-  typedef GSUBGPOS::accelerator_t<GPOS> accelerator_t;\n-};\n-\n-\n-static void\n-reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent)\n-{\n-  int chain = pos[i].attach_chain(), type = pos[i].attach_type();\n-  if (likely (!chain || 0 == (type & ATTACH_TYPE_CURSIVE)))\n-    return;\n-\n-  pos[i].attach_chain() = 0;\n-\n-  unsigned int j = (int) i + chain;\n-\n-  \/* Stop if we see new parent in the chain. *\/\n-  if (j == new_parent)\n-    return;\n-\n-  reverse_cursive_minor_offset (pos, j, direction, new_parent);\n-\n-  if (HB_DIRECTION_IS_HORIZONTAL (direction))\n-    pos[j].y_offset = -pos[i].y_offset;\n-  else\n-    pos[j].x_offset = -pos[i].x_offset;\n-\n-  pos[j].attach_chain() = -chain;\n-  pos[j].attach_type() = type;\n-}\n-static void\n-propagate_attachment_offsets (hb_glyph_position_t *pos,\n-                              unsigned int len,\n-                              unsigned int i,\n-                              hb_direction_t direction)\n-{\n-  \/* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate\n-   * offset of glyph they are attached to. *\/\n-  int chain = pos[i].attach_chain(), type = pos[i].attach_type();\n-  if (likely (!chain))\n-    return;\n-\n-  pos[i].attach_chain() = 0;\n-\n-  unsigned int j = (int) i + chain;\n-\n-  if (unlikely (j >= len))\n-    return;\n-\n-  propagate_attachment_offsets (pos, len, j, direction);\n-\n-  assert (!!(type & ATTACH_TYPE_MARK) ^ !!(type & ATTACH_TYPE_CURSIVE));\n-\n-  if (type & ATTACH_TYPE_CURSIVE)\n-  {\n-    if (HB_DIRECTION_IS_HORIZONTAL (direction))\n-      pos[i].y_offset += pos[j].y_offset;\n-    else\n-      pos[i].x_offset += pos[j].x_offset;\n-  }\n-  else \/*if (type & ATTACH_TYPE_MARK)*\/\n-  {\n-    pos[i].x_offset += pos[j].x_offset;\n-    pos[i].y_offset += pos[j].y_offset;\n-\n-    assert (j < i);\n-    if (HB_DIRECTION_IS_FORWARD (direction))\n-      for (unsigned int k = j; k < i; k++) {\n-        pos[i].x_offset -= pos[k].x_advance;\n-        pos[i].y_offset -= pos[k].y_advance;\n-      }\n-    else\n-      for (unsigned int k = j + 1; k < i + 1; k++) {\n-        pos[i].x_offset += pos[k].x_advance;\n-        pos[i].y_offset += pos[k].y_advance;\n-      }\n-  }\n-}\n-\n-void\n-GPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n-{\n-  unsigned int count = buffer->len;\n-  for (unsigned int i = 0; i < count; i++)\n-    buffer->pos[i].attach_chain() = buffer->pos[i].attach_type() = 0;\n-}\n-\n-void\n-GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)\n-{\n-  \/\/_hb_buffer_assert_gsubgpos_vars (buffer);\n-}\n-\n-void\n-GPOS::position_finish_offsets (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n-{\n-  _hb_buffer_assert_gsubgpos_vars (buffer);\n-\n-  unsigned int len;\n-  hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &len);\n-  hb_direction_t direction = buffer->props.direction;\n-\n-  \/* Handle attachments *\/\n-  if (buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)\n-    for (unsigned int i = 0; i < len; i++)\n-      propagate_attachment_offsets (pos, len, i, direction);\n-}\n-\n-\n-struct GPOS_accelerator_t : GPOS::accelerator_t {};\n-\n+using Layout::GPOS_impl::PosLookup;\n@@ -2802,0 +38,1 @@\n+\/\/ TODO(garretrieger): Move into new layout directory.\n@@ -2803,1 +40,0 @@\n-\n@@ -2812,1 +48,3 @@\n-\/*static*\/ inline hb_closure_lookups_context_t::return_t PosLookup::dispatch_closure_lookups_recurse_func (hb_closure_lookups_context_t *c, unsigned this_index)\n+template <>\n+inline hb_closure_lookups_context_t::return_t\n+PosLookup::dispatch_recurse_func<hb_closure_lookups_context_t> (hb_closure_lookups_context_t *c, unsigned this_index)\n@@ -2818,1 +56,2 @@\n-\/*static*\/ bool PosLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)\n+template <>\n+inline bool PosLookup::dispatch_recurse_func<hb_ot_apply_context_t> (hb_ot_apply_context_t *c, unsigned int lookup_index)\n@@ -2832,1 +71,0 @@\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gpos-table.hh","additions":8,"deletions":2770,"binary":false,"changes":2778,"status":"modified"},{"patch":"@@ -32,2 +32,1 @@\n-#include \"hb-ot-layout-gsubgpos.hh\"\n-\n+#include \"OT\/Layout\/GSUB\/GSUB.hh\"\n@@ -37,1551 +36,2 @@\n-typedef hb_pair_t<hb_codepoint_t, hb_codepoint_t> hb_codepoint_pair_t;\n-\n-template<typename Iterator>\n-static void SingleSubst_serialize (hb_serialize_context_t *c,\n-                                   Iterator it);\n-\n-\n-struct SingleSubstFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return (this+coverage).intersects (glyphs); }\n-\n-  void closure (hb_closure_context_t *c) const\n-  {\n-    unsigned d = deltaGlyphID;\n-    + hb_iter (this+coverage)\n-    | hb_filter (*c->glyphs)\n-    | hb_map ([d] (hb_codepoint_t g) { return (g + d) & 0xFFFFu; })\n-    | hb_sink (c->output)\n-    ;\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n-    unsigned d = deltaGlyphID;\n-    + hb_iter (this+coverage)\n-    | hb_map ([d] (hb_codepoint_t g) { return (g + d) & 0xFFFFu; })\n-    | hb_sink (c->output)\n-    ;\n-  }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool would_apply (hb_would_apply_context_t *c) const\n-  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n-    unsigned int index = (this+coverage).get_coverage (glyph_id);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    \/* According to the Adobe Annotated OpenType Suite, result is always\n-     * limited to 16bit. *\/\n-    glyph_id = (glyph_id + deltaGlyphID) & 0xFFFFu;\n-    c->replace_glyph (glyph_id);\n-\n-    return_trace (true);\n-  }\n-\n-  template<typename Iterator,\n-           hb_requires (hb_is_sorted_source_of (Iterator, hb_codepoint_t))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  Iterator glyphs,\n-                  unsigned delta)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);\n-    c->check_assign (deltaGlyphID, delta);\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    hb_codepoint_t delta = deltaGlyphID;\n-\n-    auto it =\n-    + hb_iter (this+coverage)\n-    | hb_filter (glyphset)\n-    | hb_map_retains_sorting ([&] (hb_codepoint_t g) {\n-                                return hb_codepoint_pair_t (g,\n-                                                            (g + delta) & 0xFFFF); })\n-    | hb_filter (glyphset, hb_second)\n-    | hb_map_retains_sorting ([&] (hb_codepoint_pair_t p) -> hb_codepoint_pair_t\n-                              { return hb_pair (glyph_map[p.first], glyph_map[p.second]); })\n-    ;\n-\n-    bool ret = bool (it);\n-    SingleSubst_serialize (c->serializer, it);\n-    return_trace (ret);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (coverage.sanitize (c, this) && deltaGlyphID.sanitize (c));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of Substitution table *\/\n-  HBUINT16      deltaGlyphID;           \/* Add to original GlyphID to get\n-                                         * substitute GlyphID, modulo 0x10000 *\/\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-\n-struct SingleSubstFormat2\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return (this+coverage).intersects (glyphs); }\n-\n-  void closure (hb_closure_context_t *c) const\n-  {\n-    + hb_zip (this+coverage, substitute)\n-    | hb_filter (*c->glyphs, hb_first)\n-    | hb_map (hb_second)\n-    | hb_sink (c->output)\n-    ;\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n-    + hb_zip (this+coverage, substitute)\n-    | hb_map (hb_second)\n-    | hb_sink (c->output)\n-    ;\n-  }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool would_apply (hb_would_apply_context_t *c) const\n-  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    if (unlikely (index >= substitute.len)) return_trace (false);\n-\n-    c->replace_glyph (substitute[index]);\n-\n-    return_trace (true);\n-  }\n-\n-  template<typename Iterator,\n-           hb_requires (hb_is_sorted_source_of (Iterator,\n-                                                hb_codepoint_pair_t))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  Iterator it)\n-  {\n-    TRACE_SERIALIZE (this);\n-    auto substitutes =\n-      + it\n-      | hb_map (hb_second)\n-      ;\n-    auto glyphs =\n-      + it\n-      | hb_map_retains_sorting (hb_first)\n-      ;\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    if (unlikely (!substitute.serialize (c, substitutes))) return_trace (false);\n-    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto it =\n-    + hb_zip (this+coverage, substitute)\n-    | hb_filter (glyphset, hb_first)\n-    | hb_filter (glyphset, hb_second)\n-    | hb_map_retains_sorting ([&] (hb_pair_t<hb_codepoint_t, const HBGlyphID &> p) -> hb_codepoint_pair_t\n-                              { return hb_pair (glyph_map[p.first], glyph_map[p.second]); })\n-    ;\n-\n-    bool ret = bool (it);\n-    SingleSubst_serialize (c->serializer, it);\n-    return_trace (ret);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (coverage.sanitize (c, this) && substitute.sanitize (c));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of Substitution table *\/\n-  ArrayOf<HBGlyphID>\n-                substitute;             \/* Array of substitute\n-                                         * GlyphIDs--ordered by Coverage Index *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (6, substitute);\n-};\n-\n-struct SingleSubst\n-{\n-\n-  template<typename Iterator,\n-           hb_requires (hb_is_sorted_source_of (Iterator,\n-                                                const hb_codepoint_pair_t))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  Iterator glyphs)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n-    unsigned format = 2;\n-    unsigned delta = 0;\n-    if (glyphs)\n-    {\n-      format = 1;\n-      auto get_delta = [=] (hb_codepoint_pair_t _)\n-                       { return (unsigned) (_.second - _.first) & 0xFFFF; };\n-      delta = get_delta (*glyphs);\n-      if (!hb_all (++(+glyphs), delta, get_delta)) format = 2;\n-    }\n-    u.format = format;\n-    switch (u.format) {\n-    case 1: return_trace (u.format1.serialize (c,\n-                                               + glyphs\n-                                               | hb_map_retains_sorting (hb_first),\n-                                               delta));\n-    case 2: return_trace (u.format2.serialize (c, glyphs));\n-    default:return_trace (false);\n-    }\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.format2, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  SingleSubstFormat1    format1;\n-  SingleSubstFormat2    format2;\n-  } u;\n-};\n-\n-template<typename Iterator>\n-static void\n-SingleSubst_serialize (hb_serialize_context_t *c,\n-                       Iterator it)\n-{ c->start_embed<SingleSubst> ()->serialize (c, it); }\n-\n-struct Sequence\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return hb_all (substitute, glyphs); }\n-\n-  void closure (hb_closure_context_t *c) const\n-  { c->output->add_array (substitute.arrayZ, substitute.len); }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  { c->output->add_array (substitute.arrayZ, substitute.len); }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    unsigned int count = substitute.len;\n-\n-    \/* Special-case to make it in-place and not consider this\n-     * as a \"multiplied\" substitution. *\/\n-    if (unlikely (count == 1))\n-    {\n-      c->replace_glyph (substitute.arrayZ[0]);\n-      return_trace (true);\n-    }\n-    \/* Spec disallows this, but Uniscribe allows it.\n-     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/253 *\/\n-    else if (unlikely (count == 0))\n-    {\n-      c->buffer->delete_glyph ();\n-      return_trace (true);\n-    }\n-\n-    unsigned int klass = _hb_glyph_info_is_ligature (&c->buffer->cur()) ?\n-                         HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH : 0;\n-\n-    for (unsigned int i = 0; i < count; i++) {\n-      _hb_glyph_info_set_lig_props_for_component (&c->buffer->cur(), i);\n-      c->output_glyph_for_component (substitute.arrayZ[i], klass);\n-    }\n-    c->buffer->skip_glyph ();\n-\n-    return_trace (true);\n-  }\n-\n-  template <typename Iterator,\n-            hb_requires (hb_is_source_of (Iterator, hb_codepoint_t))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  Iterator subst)\n-  {\n-    TRACE_SERIALIZE (this);\n-    return_trace (substitute.serialize (c, subst));\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    if (!intersects (&glyphset)) return_trace (false);\n-\n-    auto it =\n-    + hb_iter (substitute)\n-    | hb_map (glyph_map)\n-    ;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    return_trace (out->serialize (c->serializer, it));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (substitute.sanitize (c));\n-  }\n-\n-  protected:\n-  ArrayOf<HBGlyphID>\n-                substitute;             \/* String of GlyphIDs to substitute *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (2, substitute);\n-};\n-\n-struct MultipleSubstFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return (this+coverage).intersects (glyphs); }\n-\n-  void closure (hb_closure_context_t *c) const\n-  {\n-    + hb_zip (this+coverage, sequence)\n-    | hb_filter (*c->glyphs, hb_first)\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([c] (const Sequence &_) { _.closure (c); })\n-    ;\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n-    + hb_zip (this+coverage, sequence)\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([c] (const Sequence &_) { _.collect_glyphs (c); })\n-    ;\n-  }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool would_apply (hb_would_apply_context_t *c) const\n-  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-\n-    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    return_trace ((this+sequence[index]).apply (c));\n-  }\n-\n-  bool serialize (hb_serialize_context_t *c,\n-                  hb_sorted_array_t<const HBGlyphID> glyphs,\n-                  hb_array_t<const unsigned int> substitute_len_list,\n-                  hb_array_t<const HBGlyphID> substitute_glyphs_list)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    if (unlikely (!sequence.serialize (c, glyphs.length))) return_trace (false);\n-    for (unsigned int i = 0; i < glyphs.length; i++)\n-    {\n-      unsigned int substitute_len = substitute_len_list[i];\n-      if (unlikely (!sequence[i].serialize (c, this)\n-                                .serialize (c, substitute_glyphs_list.sub_array (0, substitute_len))))\n-        return_trace (false);\n-      substitute_glyphs_list += substitute_len;\n-    }\n-    return_trace (coverage.serialize (c, this).serialize (c, glyphs));\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->format = format;\n-\n-    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n-    + hb_zip (this+coverage, sequence)\n-    | hb_filter (glyphset, hb_first)\n-    | hb_filter (subset_offset_array (c, out->sequence, this), hb_second)\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-    out->coverage.serialize (c->serializer, out)\n-                 .serialize (c->serializer, new_coverage.iter ());\n-    return_trace (bool (new_coverage));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (coverage.sanitize (c, this) && sequence.sanitize (c, this));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of Substitution table *\/\n-  OffsetArrayOf<Sequence>\n-                sequence;               \/* Array of Sequence tables\n-                                         * ordered by Coverage Index *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (6, sequence);\n-};\n-\n-struct MultipleSubst\n-{\n-  bool serialize (hb_serialize_context_t *c,\n-                  hb_sorted_array_t<const HBGlyphID> glyphs,\n-                  hb_array_t<const unsigned int> substitute_len_list,\n-                  hb_array_t<const HBGlyphID> substitute_glyphs_list)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n-    unsigned int format = 1;\n-    u.format = format;\n-    switch (u.format) {\n-    case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, substitute_glyphs_list));\n-    default:return_trace (false);\n-    }\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  MultipleSubstFormat1  format1;\n-  } u;\n-};\n-\n-struct AlternateSet\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return hb_any (alternates, glyphs); }\n-\n-  void closure (hb_closure_context_t *c) const\n-  { c->output->add_array (alternates.arrayZ, alternates.len); }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  { c->output->add_array (alternates.arrayZ, alternates.len); }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    unsigned int count = alternates.len;\n-\n-    if (unlikely (!count)) return_trace (false);\n-\n-    hb_mask_t glyph_mask = c->buffer->cur().mask;\n-    hb_mask_t lookup_mask = c->lookup_mask;\n-\n-    \/* Note: This breaks badly if two features enabled this lookup together. *\/\n-    unsigned int shift = hb_ctz (lookup_mask);\n-    unsigned int alt_index = ((lookup_mask & glyph_mask) >> shift);\n-\n-    \/* If alt_index is MAX_VALUE, randomize feature if it is the rand feature. *\/\n-    if (alt_index == HB_OT_MAP_MAX_VALUE && c->random)\n-      alt_index = c->random_number () % count + 1;\n-\n-    if (unlikely (alt_index > count || alt_index == 0)) return_trace (false);\n-\n-    c->replace_glyph (alternates[alt_index - 1]);\n-\n-    return_trace (true);\n-  }\n-\n-  unsigned\n-  get_alternates (unsigned        start_offset,\n-                  unsigned       *alternate_count  \/* IN\/OUT.  May be NULL. *\/,\n-                  hb_codepoint_t *alternate_glyphs \/* OUT.     May be NULL. *\/) const\n-  {\n-    if (alternates.len && alternate_count)\n-    {\n-      + alternates.sub_array (start_offset, alternate_count)\n-      | hb_sink (hb_array (alternate_glyphs, *alternate_count))\n-      ;\n-    }\n-    return alternates.len;\n-  }\n-\n-  template <typename Iterator,\n-            hb_requires (hb_is_source_of (Iterator, hb_codepoint_t))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  Iterator alts)\n-  {\n-    TRACE_SERIALIZE (this);\n-    return_trace (alternates.serialize (c, alts));\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto it =\n-      + hb_iter (alternates)\n-      | hb_filter (glyphset)\n-      | hb_map (glyph_map)\n-      ;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    return_trace (out->serialize (c->serializer, it) &&\n-                  out->alternates);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (alternates.sanitize (c));\n-  }\n-\n-  protected:\n-  ArrayOf<HBGlyphID>\n-                alternates;             \/* Array of alternate GlyphIDs--in\n-                                         * arbitrary order *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (2, alternates);\n-};\n-\n-struct AlternateSubstFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return (this+coverage).intersects (glyphs); }\n-\n-  void closure (hb_closure_context_t *c) const\n-  {\n-    + hb_zip (this+coverage, alternateSet)\n-    | hb_filter (c->glyphs, hb_first)\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([c] (const AlternateSet &_) { _.closure (c); })\n-    ;\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n-    + hb_zip (this+coverage, alternateSet)\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([c] (const AlternateSet &_) { _.collect_glyphs (c); })\n-    ;\n-  }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool would_apply (hb_would_apply_context_t *c) const\n-  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n-\n-  unsigned\n-  get_glyph_alternates (hb_codepoint_t  gid,\n-                        unsigned        start_offset,\n-                        unsigned       *alternate_count  \/* IN\/OUT.  May be NULL. *\/,\n-                        hb_codepoint_t *alternate_glyphs \/* OUT.     May be NULL. *\/) const\n-  { return (this+alternateSet[(this+coverage).get_coverage (gid)])\n-           .get_alternates (start_offset, alternate_count, alternate_glyphs); }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-\n-    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    return_trace ((this+alternateSet[index]).apply (c));\n-  }\n-\n-  bool serialize (hb_serialize_context_t *c,\n-                  hb_sorted_array_t<const HBGlyphID> glyphs,\n-                  hb_array_t<const unsigned int> alternate_len_list,\n-                  hb_array_t<const HBGlyphID> alternate_glyphs_list)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    if (unlikely (!alternateSet.serialize (c, glyphs.length))) return_trace (false);\n-    for (unsigned int i = 0; i < glyphs.length; i++)\n-    {\n-      unsigned int alternate_len = alternate_len_list[i];\n-      if (unlikely (!alternateSet[i].serialize (c, this)\n-                                    .serialize (c, alternate_glyphs_list.sub_array (0, alternate_len))))\n-        return_trace (false);\n-      alternate_glyphs_list += alternate_len;\n-    }\n-    return_trace (coverage.serialize (c, this).serialize (c, glyphs));\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->format = format;\n-\n-    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n-    + hb_zip (this+coverage, alternateSet)\n-    | hb_filter (glyphset, hb_first)\n-    | hb_filter (subset_offset_array (c, out->alternateSet, this), hb_second)\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-    out->coverage.serialize (c->serializer, out)\n-                 .serialize (c->serializer, new_coverage.iter ());\n-    return_trace (bool (new_coverage));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (coverage.sanitize (c, this) && alternateSet.sanitize (c, this));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of Substitution table *\/\n-  OffsetArrayOf<AlternateSet>\n-                alternateSet;           \/* Array of AlternateSet tables\n-                                         * ordered by Coverage Index *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (6, alternateSet);\n-};\n-\n-struct AlternateSubst\n-{\n-  bool serialize (hb_serialize_context_t *c,\n-                  hb_sorted_array_t<const HBGlyphID> glyphs,\n-                  hb_array_t<const unsigned int> alternate_len_list,\n-                  hb_array_t<const HBGlyphID> alternate_glyphs_list)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n-    unsigned int format = 1;\n-    u.format = format;\n-    switch (u.format) {\n-    case 1: return_trace (u.format1.serialize (c, glyphs, alternate_len_list, alternate_glyphs_list));\n-    default:return_trace (false);\n-    }\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  AlternateSubstFormat1 format1;\n-  } u;\n-};\n-\n-\n-struct Ligature\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  { return hb_all (component, glyphs); }\n-\n-  void closure (hb_closure_context_t *c) const\n-  {\n-    if (!intersects (c->glyphs)) return;\n-    c->output->add (ligGlyph);\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    c->input->add_array (component.arrayZ, component.get_length ());\n-    c->output->add (ligGlyph);\n-  }\n-\n-  bool would_apply (hb_would_apply_context_t *c) const\n-  {\n-    if (c->len != component.lenP1)\n-      return false;\n-\n-    for (unsigned int i = 1; i < c->len; i++)\n-      if (likely (c->glyphs[i] != component[i]))\n-        return false;\n-\n-    return true;\n-  }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    unsigned int count = component.lenP1;\n-\n-    if (unlikely (!count)) return_trace (false);\n-\n-    \/* Special-case to make it in-place and not consider this\n-     * as a \"ligated\" substitution. *\/\n-    if (unlikely (count == 1))\n-    {\n-      c->replace_glyph (ligGlyph);\n-      return_trace (true);\n-    }\n-\n-    unsigned int total_component_count = 0;\n-\n-    unsigned int match_length = 0;\n-    unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];\n-\n-    if (likely (!match_input (c, count,\n-                              &component[1],\n-                              match_glyph,\n-                              nullptr,\n-                              &match_length,\n-                              match_positions,\n-                              &total_component_count)))\n-      return_trace (false);\n-\n-    ligate_input (c,\n-                  count,\n-                  match_positions,\n-                  match_length,\n-                  ligGlyph,\n-                  total_component_count);\n-\n-    return_trace (true);\n-  }\n-\n-  template <typename Iterator,\n-            hb_requires (hb_is_source_of (Iterator, hb_codepoint_t))>\n-  bool serialize (hb_serialize_context_t *c,\n-                  hb_codepoint_t ligature,\n-                  Iterator components \/* Starting from second *\/)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    ligGlyph = ligature;\n-    if (unlikely (!component.serialize (c, components))) return_trace (false);\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    if (!intersects (&glyphset) || !glyphset.has (ligGlyph)) return_trace (false);\n-\n-    auto it =\n-      + hb_iter (component)\n-      | hb_map (glyph_map)\n-      ;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    return_trace (out->serialize (c->serializer,\n-                                  glyph_map[ligGlyph],\n-                                  it));\n-  }\n-\n-  public:\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (ligGlyph.sanitize (c) && component.sanitize (c));\n-  }\n-\n-  protected:\n-  HBGlyphID     ligGlyph;               \/* GlyphID of ligature to substitute *\/\n-  HeadlessArrayOf<HBGlyphID>\n-                component;              \/* Array of component GlyphIDs--start\n-                                         * with the second  component--ordered\n-                                         * in writing direction *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (4, component);\n-};\n-\n-struct LigatureSet\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    return\n-    + hb_iter (ligature)\n-    | hb_map (hb_add (this))\n-    | hb_map ([glyphs] (const Ligature &_) { return _.intersects (glyphs); })\n-    | hb_any\n-    ;\n-  }\n-\n-  void closure (hb_closure_context_t *c) const\n-  {\n-    + hb_iter (ligature)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([c] (const Ligature &_) { _.closure (c); })\n-    ;\n-  }\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    + hb_iter (ligature)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([c] (const Ligature &_) { _.collect_glyphs (c); })\n-    ;\n-  }\n-\n-  bool would_apply (hb_would_apply_context_t *c) const\n-  {\n-    return\n-    + hb_iter (ligature)\n-    | hb_map (hb_add (this))\n-    | hb_map ([c] (const Ligature &_) { return _.would_apply (c); })\n-    | hb_any\n-    ;\n-  }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    unsigned int num_ligs = ligature.len;\n-    for (unsigned int i = 0; i < num_ligs; i++)\n-    {\n-      const Ligature &lig = this+ligature[i];\n-      if (lig.apply (c)) return_trace (true);\n-    }\n-\n-    return_trace (false);\n-  }\n-\n-  bool serialize (hb_serialize_context_t *c,\n-                  hb_array_t<const HBGlyphID> ligatures,\n-                  hb_array_t<const unsigned int> component_count_list,\n-                  hb_array_t<const HBGlyphID> &component_list \/* Starting from second for each ligature *\/)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    if (unlikely (!ligature.serialize (c, ligatures.length))) return_trace (false);\n-    for (unsigned int i = 0; i < ligatures.length; i++)\n-    {\n-      unsigned int component_count = (unsigned) hb_max ((int) component_count_list[i] - 1, 0);\n-      if (unlikely (!ligature[i].serialize (c, this)\n-                                .serialize (c,\n-                                            ligatures[i],\n-                                            component_list.sub_array (0, component_count))))\n-        return_trace (false);\n-      component_list += component_count;\n-    }\n-    return_trace (true);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-\n-    + hb_iter (ligature)\n-    | hb_filter (subset_offset_array (c, out->ligature, this))\n-    | hb_drain\n-    ;\n-    return_trace (bool (out->ligature));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (ligature.sanitize (c, this));\n-  }\n-\n-  protected:\n-  OffsetArrayOf<Ligature>\n-                ligature;               \/* Array LigatureSet tables\n-                                         * ordered by preference *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (2, ligature);\n-};\n-\n-struct LigatureSubstFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    return\n-    + hb_zip (this+coverage, ligatureSet)\n-    | hb_filter (*glyphs, hb_first)\n-    | hb_map (hb_second)\n-    | hb_map ([this, glyphs] (const OffsetTo<LigatureSet> &_)\n-              { return (this+_).intersects (glyphs); })\n-    | hb_any\n-    ;\n-  }\n-\n-  void closure (hb_closure_context_t *c) const\n-  {\n-    + hb_zip (this+coverage, ligatureSet)\n-    | hb_filter (*c->glyphs, hb_first)\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([c] (const LigatureSet &_) { _.closure (c); })\n-    ;\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n-\n-    + hb_zip (this+coverage, ligatureSet)\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([c] (const LigatureSet &_) { _.collect_glyphs (c); })\n-    ;\n-  }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool would_apply (hb_would_apply_context_t *c) const\n-  {\n-    unsigned int index = (this+coverage).get_coverage (c->glyphs[0]);\n-    if (likely (index == NOT_COVERED)) return false;\n-\n-    const LigatureSet &lig_set = this+ligatureSet[index];\n-    return lig_set.would_apply (c);\n-  }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-\n-    unsigned int index = (this+coverage).get_coverage (c->buffer->cur ().codepoint);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    const LigatureSet &lig_set = this+ligatureSet[index];\n-    return_trace (lig_set.apply (c));\n-  }\n-\n-  bool serialize (hb_serialize_context_t *c,\n-                  hb_sorted_array_t<const HBGlyphID> first_glyphs,\n-                  hb_array_t<const unsigned int> ligature_per_first_glyph_count_list,\n-                  hb_array_t<const HBGlyphID> ligatures_list,\n-                  hb_array_t<const unsigned int> component_count_list,\n-                  hb_array_t<const HBGlyphID> component_list \/* Starting from second for each ligature *\/)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-    if (unlikely (!ligatureSet.serialize (c, first_glyphs.length))) return_trace (false);\n-    for (unsigned int i = 0; i < first_glyphs.length; i++)\n-    {\n-      unsigned int ligature_count = ligature_per_first_glyph_count_list[i];\n-      if (unlikely (!ligatureSet[i].serialize (c, this)\n-                                   .serialize (c,\n-                                               ligatures_list.sub_array (0, ligature_count),\n-                                               component_count_list.sub_array (0, ligature_count),\n-                                               component_list))) return_trace (false);\n-      ligatures_list += ligature_count;\n-      component_count_list += ligature_count;\n-    }\n-    return_trace (coverage.serialize (c, this).serialize (c, first_glyphs));\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    const hb_set_t &glyphset = *c->plan->glyphset_gsub ();\n-    const hb_map_t &glyph_map = *c->plan->glyph_map;\n-\n-    auto *out = c->serializer->start_embed (*this);\n-    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n-    out->format = format;\n-\n-    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n-    + hb_zip (this+coverage, ligatureSet)\n-    | hb_filter (glyphset, hb_first)\n-    | hb_filter (subset_offset_array (c, out->ligatureSet, this), hb_second)\n-    | hb_map (hb_first)\n-    | hb_map (glyph_map)\n-    | hb_sink (new_coverage)\n-    ;\n-    out->coverage.serialize (c->serializer, out)\n-                 .serialize (c->serializer, new_coverage.iter ());\n-    return_trace (bool (new_coverage));\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (coverage.sanitize (c, this) && ligatureSet.sanitize (c, this));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of Substitution table *\/\n-  OffsetArrayOf<LigatureSet>\n-                ligatureSet;            \/* Array LigatureSet tables\n-                                         * ordered by Coverage Index *\/\n-  public:\n-  DEFINE_SIZE_ARRAY (6, ligatureSet);\n-};\n-\n-struct LigatureSubst\n-{\n-  bool serialize (hb_serialize_context_t *c,\n-                  hb_sorted_array_t<const HBGlyphID> first_glyphs,\n-                  hb_array_t<const unsigned int> ligature_per_first_glyph_count_list,\n-                  hb_array_t<const HBGlyphID> ligatures_list,\n-                  hb_array_t<const unsigned int> component_count_list,\n-                  hb_array_t<const HBGlyphID> component_list \/* Starting from second for each ligature *\/)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n-    unsigned int format = 1;\n-    u.format = format;\n-    switch (u.format) {\n-    case 1: return_trace (u.format1.serialize (c,\n-                                               first_glyphs,\n-                                               ligature_per_first_glyph_count_list,\n-                                               ligatures_list,\n-                                               component_count_list,\n-                                               component_list));\n-    default:return_trace (false);\n-    }\n-  }\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16              format;         \/* Format identifier *\/\n-  LigatureSubstFormat1  format1;\n-  } u;\n-};\n-\n-\n-struct ContextSubst : Context {};\n-\n-struct ChainContextSubst : ChainContext {};\n-\n-struct ExtensionSubst : Extension<ExtensionSubst>\n-{\n-  typedef struct SubstLookupSubTable SubTable;\n-  bool is_reverse () const;\n-};\n-\n-\n-struct ReverseChainSingleSubstFormat1\n-{\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    if (!(this+coverage).intersects (glyphs))\n-      return false;\n-\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n-\n-    unsigned int count;\n-\n-    count = backtrack.len;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (!(this+backtrack[i]).intersects (glyphs))\n-        return false;\n-\n-    count = lookahead.len;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (!(this+lookahead[i]).intersects (glyphs))\n-        return false;\n-\n-    return true;\n-  }\n-\n-  void closure (hb_closure_context_t *c) const\n-  {\n-    if (!intersects (c->glyphs)) return;\n-\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n-    const ArrayOf<HBGlyphID> &substitute = StructAfter<ArrayOf<HBGlyphID>> (lookahead);\n-\n-    + hb_zip (this+coverage, substitute)\n-    | hb_filter (*c->glyphs, hb_first)\n-    | hb_map (hb_second)\n-    | hb_sink (c->output)\n-    ;\n-  }\n-\n-  void closure_lookups (hb_closure_lookups_context_t *c) const {}\n-\n-  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    if (unlikely (!(this+coverage).collect_coverage (c->input))) return;\n-\n-    unsigned int count;\n-\n-    count = backtrack.len;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (unlikely (!(this+backtrack[i]).collect_coverage (c->before))) return;\n-\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n-    count = lookahead.len;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (unlikely (!(this+lookahead[i]).collect_coverage (c->after))) return;\n-\n-    const ArrayOf<HBGlyphID> &substitute = StructAfter<ArrayOf<HBGlyphID>> (lookahead);\n-    count = substitute.len;\n-    c->output->add_array (substitute.arrayZ, substitute.len);\n-  }\n-\n-  const Coverage &get_coverage () const { return this+coverage; }\n-\n-  bool would_apply (hb_would_apply_context_t *c) const\n-  { return c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED; }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    if (unlikely (c->nesting_level_left != HB_MAX_NESTING_LEVEL))\n-      return_trace (false); \/* No chaining to this type *\/\n-\n-    unsigned int index = (this+coverage).get_coverage (c->buffer->cur ().codepoint);\n-    if (likely (index == NOT_COVERED)) return_trace (false);\n-\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n-    const ArrayOf<HBGlyphID> &substitute = StructAfter<ArrayOf<HBGlyphID>> (lookahead);\n-\n-    if (unlikely (index >= substitute.len)) return_trace (false);\n-\n-    unsigned int start_index = 0, end_index = 0;\n-    if (match_backtrack (c,\n-                         backtrack.len, (HBUINT16 *) backtrack.arrayZ,\n-                         match_coverage, this,\n-                         &start_index) &&\n-        match_lookahead (c,\n-                         lookahead.len, (HBUINT16 *) lookahead.arrayZ,\n-                         match_coverage, this,\n-                         1, &end_index))\n-    {\n-      c->buffer->unsafe_to_break_from_outbuffer (start_index, end_index);\n-      c->replace_glyph_inplace (substitute[index]);\n-      \/* Note: We DON'T decrease buffer->idx.  The main loop does it\n-       * for us.  This is useful for preventing surprises if someone\n-       * calls us through a Context lookup. *\/\n-      return_trace (true);\n-    }\n-\n-    return_trace (false);\n-  }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    TRACE_SUBSET (this);\n-    \/\/ TODO(subset)\n-    return_trace (false);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    if (!(coverage.sanitize (c, this) && backtrack.sanitize (c, this)))\n-      return_trace (false);\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n-    if (!lookahead.sanitize (c, this))\n-      return_trace (false);\n-    const ArrayOf<HBGlyphID> &substitute = StructAfter<ArrayOf<HBGlyphID>> (lookahead);\n-    return_trace (substitute.sanitize (c));\n-  }\n-\n-  protected:\n-  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n-  OffsetTo<Coverage>\n-                coverage;               \/* Offset to Coverage table--from\n-                                         * beginning of table *\/\n-  OffsetArrayOf<Coverage>\n-                backtrack;              \/* Array of coverage tables\n-                                         * in backtracking sequence, in glyph\n-                                         * sequence order *\/\n-  OffsetArrayOf<Coverage>\n-                lookaheadX;             \/* Array of coverage tables\n-                                         * in lookahead sequence, in glyph\n-                                         * sequence order *\/\n-  ArrayOf<HBGlyphID>\n-                substituteX;            \/* Array of substitute\n-                                         * GlyphIDs--ordered by Coverage Index *\/\n-  public:\n-  DEFINE_SIZE_MIN (10);\n-};\n-\n-struct ReverseChainSingleSubst\n-{\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, u.format);\n-    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n-    switch (u.format) {\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    default:return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  protected:\n-  union {\n-  HBUINT16                              format;         \/* Format identifier *\/\n-  ReverseChainSingleSubstFormat1        format1;\n-  } u;\n-};\n-\n-\n-\n-\/*\n- * SubstLookup\n- *\/\n-\n-struct SubstLookupSubTable\n-{\n-  friend struct Lookup;\n-  friend struct SubstLookup;\n-\n-  enum Type {\n-    Single              = 1,\n-    Multiple            = 2,\n-    Alternate           = 3,\n-    Ligature            = 4,\n-    Context             = 5,\n-    ChainContext        = 6,\n-    Extension           = 7,\n-    ReverseChainSingle  = 8\n-  };\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type, Ts&&... ds) const\n-  {\n-    TRACE_DISPATCH (this, lookup_type);\n-    switch (lookup_type) {\n-    case Single:                return_trace (u.single.dispatch (c, hb_forward<Ts> (ds)...));\n-    case Multiple:              return_trace (u.multiple.dispatch (c, hb_forward<Ts> (ds)...));\n-    case Alternate:             return_trace (u.alternate.dispatch (c, hb_forward<Ts> (ds)...));\n-    case Ligature:              return_trace (u.ligature.dispatch (c, hb_forward<Ts> (ds)...));\n-    case Context:               return_trace (u.context.dispatch (c, hb_forward<Ts> (ds)...));\n-    case ChainContext:          return_trace (u.chainContext.dispatch (c, hb_forward<Ts> (ds)...));\n-    case Extension:             return_trace (u.extension.dispatch (c, hb_forward<Ts> (ds)...));\n-    case ReverseChainSingle:    return_trace (u.reverseChainContextSingle.dispatch (c, hb_forward<Ts> (ds)...));\n-    default:                    return_trace (c->default_return_value ());\n-    }\n-  }\n-\n-  bool intersects (const hb_set_t *glyphs, unsigned int lookup_type) const\n-  {\n-    hb_intersects_context_t c (glyphs);\n-    return dispatch (&c, lookup_type);\n-  }\n-\n-  protected:\n-  union {\n-  SingleSubst                   single;\n-  MultipleSubst                 multiple;\n-  AlternateSubst                alternate;\n-  LigatureSubst                 ligature;\n-  ContextSubst                  context;\n-  ChainContextSubst             chainContext;\n-  ExtensionSubst                extension;\n-  ReverseChainSingleSubst       reverseChainContextSingle;\n-  } u;\n-  public:\n-  DEFINE_SIZE_MIN (0);\n-};\n-\n-\n-struct SubstLookup : Lookup\n-{\n-  typedef SubstLookupSubTable SubTable;\n-\n-  const SubTable& get_subtable (unsigned int i) const\n-  { return Lookup::get_subtable<SubTable> (i); }\n-\n-  static inline bool lookup_type_is_reverse (unsigned int lookup_type)\n-  { return lookup_type == SubTable::ReverseChainSingle; }\n-\n-  bool is_reverse () const\n-  {\n-    unsigned int type = get_type ();\n-    if (unlikely (type == SubTable::Extension))\n-      return reinterpret_cast<const ExtensionSubst &> (get_subtable (0)).is_reverse ();\n-    return lookup_type_is_reverse (type);\n-  }\n-\n-  bool apply (hb_ot_apply_context_t *c) const\n-  {\n-    TRACE_APPLY (this);\n-    return_trace (dispatch (c));\n-  }\n-\n-  bool intersects (const hb_set_t *glyphs) const\n-  {\n-    hb_intersects_context_t c (glyphs);\n-    return dispatch (&c);\n-  }\n-\n-  hb_closure_context_t::return_t closure (hb_closure_context_t *c, unsigned int this_index) const\n-  {\n-    if (!c->should_visit_lookup (this_index))\n-      return hb_closure_context_t::default_return_value ();\n-\n-    c->set_recurse_func (dispatch_closure_recurse_func);\n-\n-    hb_closure_context_t::return_t ret = dispatch (c);\n-\n-    c->flush ();\n-\n-    return ret;\n-  }\n-\n-  hb_closure_lookups_context_t::return_t closure_lookups (hb_closure_lookups_context_t *c, unsigned this_index) const\n-  {\n-    if (c->is_lookup_visited (this_index))\n-      return hb_closure_lookups_context_t::default_return_value ();\n-\n-    c->set_lookup_visited (this_index);\n-    if (!intersects (c->glyphs))\n-    {\n-      c->set_lookup_inactive (this_index);\n-      return hb_closure_lookups_context_t::default_return_value ();\n-    }\n-\n-    c->set_recurse_func (dispatch_closure_lookups_recurse_func);\n-\n-    hb_closure_lookups_context_t::return_t ret = dispatch (c);\n-    return ret;\n-  }\n-\n-  hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n-  {\n-    c->set_recurse_func (dispatch_recurse_func<hb_collect_glyphs_context_t>);\n-    return dispatch (c);\n-  }\n-\n-  template <typename set_t>\n-  void collect_coverage (set_t *glyphs) const\n-  {\n-    hb_collect_coverage_context_t<set_t> c (glyphs);\n-    dispatch (&c);\n-  }\n-\n-  bool would_apply (hb_would_apply_context_t *c,\n-                    const hb_ot_layout_lookup_accelerator_t *accel) const\n-  {\n-    if (unlikely (!c->len)) return false;\n-    if (!accel->may_have (c->glyphs[0])) return false;\n-      return dispatch (c);\n-  }\n-\n-  static inline bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);\n-\n-  SubTable& serialize_subtable (hb_serialize_context_t *c,\n-                                unsigned int i)\n-  { return get_subtables<SubTable> ()[i].serialize (c, this); }\n-\n-  bool serialize_single (hb_serialize_context_t *c,\n-                         uint32_t lookup_props,\n-                         hb_sorted_array_t<const HBGlyphID> glyphs,\n-                         hb_array_t<const HBGlyphID> substitutes)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!Lookup::serialize (c, SubTable::Single, lookup_props, 1))) return_trace (false);\n-    return_trace (serialize_subtable (c, 0).u.single.\n-                  serialize (c, hb_zip (glyphs, substitutes)));\n-  }\n-\n-  bool serialize_multiple (hb_serialize_context_t *c,\n-                           uint32_t lookup_props,\n-                           hb_sorted_array_t<const HBGlyphID> glyphs,\n-                           hb_array_t<const unsigned int> substitute_len_list,\n-                           hb_array_t<const HBGlyphID> substitute_glyphs_list)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!Lookup::serialize (c, SubTable::Multiple, lookup_props, 1))) return_trace (false);\n-    return_trace (serialize_subtable (c, 0).u.multiple.\n-                  serialize (c,\n-                             glyphs,\n-                             substitute_len_list,\n-                             substitute_glyphs_list));\n-  }\n-\n-  bool serialize_alternate (hb_serialize_context_t *c,\n-                            uint32_t lookup_props,\n-                            hb_sorted_array_t<const HBGlyphID> glyphs,\n-                            hb_array_t<const unsigned int> alternate_len_list,\n-                            hb_array_t<const HBGlyphID> alternate_glyphs_list)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!Lookup::serialize (c, SubTable::Alternate, lookup_props, 1))) return_trace (false);\n-    return_trace (serialize_subtable (c, 0).u.alternate.\n-                  serialize (c,\n-                             glyphs,\n-                             alternate_len_list,\n-                             alternate_glyphs_list));\n-  }\n-\n-  bool serialize_ligature (hb_serialize_context_t *c,\n-                           uint32_t lookup_props,\n-                           hb_sorted_array_t<const HBGlyphID> first_glyphs,\n-                           hb_array_t<const unsigned int> ligature_per_first_glyph_count_list,\n-                           hb_array_t<const HBGlyphID> ligatures_list,\n-                           hb_array_t<const unsigned int> component_count_list,\n-                           hb_array_t<const HBGlyphID> component_list \/* Starting from second for each ligature *\/)\n-  {\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (!Lookup::serialize (c, SubTable::Ligature, lookup_props, 1))) return_trace (false);\n-    return_trace (serialize_subtable (c, 0).u.ligature.\n-                  serialize (c,\n-                             first_glyphs,\n-                             ligature_per_first_glyph_count_list,\n-                             ligatures_list,\n-                             component_count_list,\n-                             component_list));\n-  }\n-\n-  template <typename context_t>\n-  static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n-\n-  static inline hb_closure_context_t::return_t dispatch_closure_recurse_func (hb_closure_context_t *c, unsigned int lookup_index)\n-  {\n-    if (!c->should_visit_lookup (lookup_index))\n-      return hb_empty_t ();\n-\n-    hb_closure_context_t::return_t ret = dispatch_recurse_func (c, lookup_index);\n-\n-    \/* While in theory we should flush here, it will cause timeouts because a recursive\n-     * lookup can keep growing the glyph set.  Skip, and outer loop will retry up to\n-     * HB_CLOSURE_MAX_STAGES time, which should be enough for every realistic font. *\/\n-    \/\/c->flush ();\n-\n-    return ret;\n-  }\n-\n-  HB_INTERNAL static hb_closure_lookups_context_t::return_t dispatch_closure_lookups_recurse_func (hb_closure_lookups_context_t *c, unsigned lookup_index);\n-\n-  template <typename context_t, typename ...Ts>\n-  typename context_t::return_t dispatch (context_t *c, Ts&&... ds) const\n-  { return Lookup::dispatch<SubTable> (c, hb_forward<Ts> (ds)...); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  { return Lookup::subset<SubTable> (c); }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  { return Lookup::sanitize<SubTable> (c); }\n-};\n-\n-\/*\n- * GSUB -- Glyph Substitution\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gsub\n- *\/\n-\n-struct GSUB : GSUBGPOS\n-{\n-  static constexpr hb_tag_t tableTag = HB_OT_TAG_GSUB;\n-\n-  const SubstLookup& get_lookup (unsigned int i) const\n-  { return static_cast<const SubstLookup &> (GSUBGPOS::get_lookup (i)); }\n-\n-  bool subset (hb_subset_context_t *c) const\n-  {\n-    hb_subset_layout_context_t l (c, tableTag, c->plan->gsub_lookups, c->plan->gsub_features);\n-    return GSUBGPOS::subset<SubstLookup> (&l);\n-  }\n-\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  { return GSUBGPOS::sanitize<SubstLookup> (c); }\n-\n-  HB_INTERNAL bool is_blocklisted (hb_blob_t *blob,\n-                                   hb_face_t *face) const;\n-\n-  void closure_lookups (hb_face_t      *face,\n-                        const hb_set_t *glyphs,\n-                        hb_set_t       *lookup_indexes \/* IN\/OUT *\/) const\n-  { GSUBGPOS::closure_lookups<SubstLookup> (face, glyphs, lookup_indexes); }\n-\n-  typedef GSUBGPOS::accelerator_t<GSUB> accelerator_t;\n-};\n-\n-\n-struct GSUB_accelerator_t : GSUB::accelerator_t {};\n-\n+using Layout::GSUB::SubstLookup;\n+using Layout::GSUB::ExtensionSubst;\n@@ -1589,0 +39,1 @@\n+\/\/ TODO(garretrieger): Move into the new layout directory.\n@@ -1603,1 +54,11 @@\n-\/*static*\/ inline hb_closure_lookups_context_t::return_t SubstLookup::dispatch_closure_lookups_recurse_func (hb_closure_lookups_context_t *c, unsigned this_index)\n+\/*static*\/ typename hb_closure_context_t::return_t SubstLookup::closure_glyphs_recurse_func (hb_closure_context_t *c, unsigned lookup_index, hb_set_t *covered_seq_indices, unsigned seq_index, unsigned end_index)\n+{\n+  const SubstLookup &l = c->face->table.GSUB.get_relaxed ()->table->get_lookup (lookup_index);\n+  if (l.may_have_non_1to1 ())\n+      hb_set_add_range (covered_seq_indices, seq_index, end_index);\n+  return l.dispatch (c);\n+}\n+\n+template <>\n+inline hb_closure_lookups_context_t::return_t\n+SubstLookup::dispatch_recurse_func<hb_closure_lookups_context_t> (hb_closure_lookups_context_t *c, unsigned this_index)\n@@ -1609,1 +70,2 @@\n-\/*static*\/ bool SubstLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)\n+template <>\n+inline bool SubstLookup::dispatch_recurse_func<hb_ot_apply_context_t> (hb_ot_apply_context_t *c, unsigned int lookup_index)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gsub-table.hh","additions":17,"deletions":1555,"binary":false,"changes":1572,"status":"modified"},{"patch":"@@ -55,1 +55,10 @@\n-                             glyphs (glyphs_) {}\n+                            glyphs (glyphs_) {}\n+};\n+\n+struct hb_have_non_1to1_context_t :\n+       hb_dispatch_context_t<hb_have_non_1to1_context_t, bool>\n+{\n+  template <typename T>\n+  return_t dispatch (const T &obj) { return obj.may_have_non_1to1 (); }\n+  static return_t default_return_value () { return false; }\n+  bool stop_sublookup_iteration (return_t r) const { return r; }\n@@ -61,1 +70,1 @@\n-  typedef return_t (*recurse_func_t) (hb_closure_context_t *c, unsigned int lookup_index);\n+  typedef return_t (*recurse_func_t) (hb_closure_context_t *c, unsigned lookup_index, hb_set_t *covered_seq_indicies, unsigned seq_index, unsigned end_index);\n@@ -65,1 +74,1 @@\n-  void recurse (unsigned int lookup_index)\n+  void recurse (unsigned lookup_index, hb_set_t *covered_seq_indicies, unsigned seq_index, unsigned end_index)\n@@ -71,1 +80,1 @@\n-    recurse_func (this, lookup_index);\n+    recurse_func (this, lookup_index, covered_seq_indicies, seq_index, end_index);\n@@ -75,0 +84,3 @@\n+  void reset_lookup_visit_count ()\n+  { lookup_count = 0; }\n+\n@@ -76,1 +88,1 @@\n-  { return lookup_count > HB_MAX_LOOKUP_INDICES; }\n+  { return lookup_count > HB_MAX_LOOKUP_VISIT_COUNT; }\n@@ -80,1 +92,1 @@\n-    if (lookup_count++ > HB_MAX_LOOKUP_INDICES)\n+    if (lookup_count++ > HB_MAX_LOOKUP_VISIT_COUNT)\n@@ -86,1 +98,0 @@\n-    done_lookups->set (lookup_index, glyphs->get_population ());\n@@ -92,1 +103,2 @@\n-    if (unlikely (done_lookups->in_error ()))\n+    if (done_lookups_glyph_count->in_error () ||\n+        done_lookups_glyph_set->in_error ())\n@@ -96,1 +108,50 @@\n-    return done_lookups->get (lookup_index) == glyphs->get_population ();\n+    if (done_lookups_glyph_count->get (lookup_index) != glyphs->get_population ())\n+    {\n+      done_lookups_glyph_count->set (lookup_index, glyphs->get_population ());\n+\n+      if (!done_lookups_glyph_set->has (lookup_index))\n+      {\n+        if (unlikely (!done_lookups_glyph_set->set (lookup_index, hb::unique_ptr<hb_set_t> {hb_set_create ()})))\n+          return true;\n+      }\n+\n+      hb_set_clear (done_lookups_glyph_set->get (lookup_index));\n+    }\n+\n+    hb_set_t *covered_glyph_set = done_lookups_glyph_set->get (lookup_index);\n+    if (unlikely (covered_glyph_set->in_error ()))\n+      return true;\n+    if (parent_active_glyphs ().is_subset (*covered_glyph_set))\n+      return true;\n+\n+    covered_glyph_set->union_ (parent_active_glyphs ());\n+    return false;\n+  }\n+\n+  const hb_set_t& previous_parent_active_glyphs () {\n+    if (active_glyphs_stack.length <= 1)\n+      return *glyphs;\n+\n+    return active_glyphs_stack[active_glyphs_stack.length - 2];\n+  }\n+\n+  const hb_set_t& parent_active_glyphs ()\n+  {\n+    if (!active_glyphs_stack)\n+      return *glyphs;\n+\n+    return active_glyphs_stack.tail ();\n+  }\n+\n+  hb_set_t& push_cur_active_glyphs ()\n+  {\n+    return *active_glyphs_stack.push ();\n+  }\n+\n+  bool pop_cur_done_glyphs ()\n+  {\n+    if (active_glyphs_stack.length < 1)\n+      return false;\n+\n+    active_glyphs_stack.pop ();\n+    return true;\n@@ -102,1 +163,2 @@\n-  recurse_func_t recurse_func;\n+  hb_vector_t<hb_set_t> active_glyphs_stack;\n+  recurse_func_t recurse_func = nullptr;\n@@ -107,1 +169,2 @@\n-                        hb_map_t *done_lookups_,\n+                        hb_map_t *done_lookups_glyph_count_,\n+                        hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *done_lookups_glyph_set_,\n@@ -111,1 +174,0 @@\n-                          recurse_func (nullptr),\n@@ -113,2 +175,2 @@\n-                          done_lookups (done_lookups_),\n-                          lookup_count (0)\n+                          done_lookups_glyph_count (done_lookups_glyph_count_),\n+                          done_lookups_glyph_set (done_lookups_glyph_set_)\n@@ -123,3 +185,5 @@\n-    hb_set_del_range (output, face->get_num_glyphs (), hb_set_get_max (output));        \/* Remove invalid glyphs. *\/\n-    hb_set_union (glyphs, output);\n-    hb_set_clear (output);\n+    output->del_range (face->get_num_glyphs (), HB_SET_VALUE_INVALID);  \/* Remove invalid glyphs. *\/\n+    glyphs->union_ (*output);\n+    output->clear ();\n+    active_glyphs_stack.pop ();\n+    active_glyphs_stack.reset ();\n@@ -129,2 +193,3 @@\n-  hb_map_t *done_lookups;\n-  unsigned int lookup_count;\n+  hb_map_t *done_lookups_glyph_count;\n+  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *done_lookups_glyph_set;\n+  unsigned int lookup_count = 0;\n@@ -133,0 +198,2 @@\n+\n+\n@@ -146,1 +213,5 @@\n-    if (is_lookup_visited (lookup_index))\n+    if (lookup_limit_exceeded ()\n+        || visited_lookups->in_error ()\n+        || visited_lookups->has (lookup_index))\n+      \/\/ Don't increment lookup count here, that will be done in the call to closure_lookups()\n+      \/\/ made by recurse_func.\n@@ -161,1 +232,5 @@\n-  { return lookup_count > HB_MAX_LOOKUP_INDICES; }\n+  {\n+    bool ret = lookup_count > HB_MAX_LOOKUP_VISIT_COUNT;\n+    if (ret)\n+      DEBUG_MSG (SUBSET, nullptr, \"lookup visit count limit exceeded in lookup closure!\");\n+    return ret; }\n@@ -165,1 +240,4 @@\n-    if (unlikely (lookup_count++ > HB_MAX_LOOKUP_INDICES))\n+    if (unlikely (lookup_count++ > HB_MAX_LOOKUP_VISIT_COUNT))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"total visited lookup count %u exceeds max limit, lookup %u is dropped.\",\n+                 lookup_count, lookup_index);\n@@ -167,0 +245,1 @@\n+    }\n@@ -318,1 +397,0 @@\n-\n@@ -326,0 +404,1 @@\n+             mask (-1),\n@@ -328,4 +407,2 @@\n-             mask (-1),\n-#define arg1(arg) (arg) \/* Remove the macro to see why it's needed! *\/\n-             syllable arg1(0),\n-#undef arg1\n+             per_syllable (false),\n+             syllable {0},\n@@ -335,1 +412,1 @@\n-    typedef bool (*match_func_t) (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data);\n+    typedef bool (*match_func_t) (hb_glyph_info_t &info, const HBUINT16 &value, const void *data);\n@@ -341,1 +418,2 @@\n-    void set_syllable (uint8_t syllable_)  { syllable = syllable_; }\n+    void set_per_syllable (bool per_syllable_) { per_syllable = per_syllable_; }\n+    void set_syllable (uint8_t syllable_)  { syllable = per_syllable ? syllable_ : 0; }\n@@ -352,1 +430,1 @@\n-    may_match_t may_match (const hb_glyph_info_t &info,\n+    may_match_t may_match (hb_glyph_info_t &info,\n@@ -360,1 +438,1 @@\n-        return match_func (info.codepoint, *glyph_data, match_data) ? MATCH_YES : MATCH_NO;\n+        return match_func (info, *glyph_data, match_data) ? MATCH_YES : MATCH_NO;\n@@ -387,0 +465,1 @@\n+    hb_mask_t mask;\n@@ -389,1 +468,1 @@\n-    hb_mask_t mask;\n+    bool per_syllable;\n@@ -408,0 +487,1 @@\n+      matcher.set_per_syllable (c->per_syllable);\n@@ -440,1 +520,1 @@\n-    bool next ()\n+    bool next (unsigned *unsafe_to = nullptr)\n@@ -446,1 +526,1 @@\n-        const hb_glyph_info_t &info = c->buffer->info[idx];\n+        hb_glyph_info_t &info = c->buffer->info[idx];\n@@ -463,0 +543,3 @@\n+        {\n+          if (unsafe_to)\n+            *unsafe_to = idx + 1;\n@@ -464,0 +547,1 @@\n+        }\n@@ -465,0 +549,2 @@\n+      if (unsafe_to)\n+        *unsafe_to = end;\n@@ -467,1 +553,1 @@\n-    bool prev ()\n+    bool prev (unsigned *unsafe_from = nullptr)\n@@ -473,1 +559,1 @@\n-        const hb_glyph_info_t &info = c->buffer->out_info[idx];\n+        hb_glyph_info_t &info = c->buffer->out_info[idx];\n@@ -490,0 +576,3 @@\n+        {\n+          if (unsafe_from)\n+            *unsafe_from = hb_max (1u, idx) - 1u;\n@@ -491,0 +580,1 @@\n+        }\n@@ -492,0 +582,2 @@\n+      if (unsafe_from)\n+        *unsafe_from = 0;\n@@ -515,0 +607,2 @@\n+    {\n+      buffer->shaping_failed = true;\n@@ -516,0 +610,1 @@\n+    }\n@@ -525,0 +620,1 @@\n+  unsigned int table_index; \/* GSUB\/GPOS *\/\n@@ -528,1 +624,1 @@\n-  recurse_func_t recurse_func;\n+  recurse_func_t recurse_func = nullptr;\n@@ -531,0 +627,1 @@\n+  VariationStore::cache_t *var_store_cache;\n@@ -533,5 +630,4 @@\n-  hb_mask_t lookup_mask;\n-  unsigned int table_index; \/* GSUB\/GPOS *\/\n-  unsigned int lookup_index;\n-  unsigned int lookup_props;\n-  unsigned int nesting_level_left;\n+  hb_mask_t lookup_mask = 1;\n+  unsigned int lookup_index = (unsigned) -1;\n+  unsigned int lookup_props = 0;\n+  unsigned int nesting_level_left = HB_MAX_NESTING_LEVEL;\n@@ -540,6 +636,6 @@\n-  bool auto_zwnj;\n-  bool auto_zwj;\n-  bool random;\n-\n-  uint32_t random_state;\n-\n+  bool auto_zwnj = true;\n+  bool auto_zwj = true;\n+  bool per_syllable = false;\n+  bool random = false;\n+  uint32_t random_state = 1;\n+  unsigned new_syllables = (unsigned) -1;\n@@ -550,1 +646,1 @@\n-                        iter_input (), iter_context (),\n+                        table_index (table_index_),\n@@ -552,1 +648,0 @@\n-                        recurse_func (nullptr),\n@@ -561,0 +656,7 @@\n+                        var_store_cache (\n+#ifndef HB_NO_VAR\n+                                         table_index == 1 && font->num_coords ? var_store.create_cache () : nullptr\n+#else\n+                                         nullptr\n+#endif\n+                                        ),\n@@ -562,10 +664,9 @@\n-                        lookup_mask (1),\n-                        table_index (table_index_),\n-                        lookup_index ((unsigned int) -1),\n-                        lookup_props (0),\n-                        nesting_level_left (HB_MAX_NESTING_LEVEL),\n-                        has_glyph_classes (gdef.has_glyph_classes ()),\n-                        auto_zwnj (true),\n-                        auto_zwj (true),\n-                        random (false),\n-                        random_state (1) { init_iters (); }\n+                        has_glyph_classes (gdef.has_glyph_classes ())\n+  { init_iters (); }\n+\n+  ~hb_ot_apply_context_t ()\n+  {\n+#ifndef HB_NO_VAR\n+    VariationStore::destroy_cache (var_store_cache);\n+#endif\n+  }\n@@ -582,0 +683,1 @@\n+  void set_per_syllable (bool per_syllable_) { per_syllable = per_syllable_; init_iters (); }\n@@ -632,1 +734,1 @@\n-  void _set_glyph_props (hb_codepoint_t glyph_index,\n+  void _set_glyph_class (hb_codepoint_t glyph_index,\n@@ -637,3 +739,5 @@\n-    unsigned int add_in = _hb_glyph_info_get_glyph_props (&buffer->cur()) &\n-                          HB_OT_LAYOUT_GLYPH_PROPS_PRESERVE;\n-    add_in |= HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED;\n+    if (new_syllables != (unsigned) -1)\n+      buffer->cur().syllable() = new_syllables;\n+\n+    unsigned int props = _hb_glyph_info_get_glyph_props (&buffer->cur());\n+    props |= HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED;\n@@ -642,1 +746,1 @@\n-      add_in |= HB_OT_LAYOUT_GLYPH_PROPS_LIGATED;\n+      props |= HB_OT_LAYOUT_GLYPH_PROPS_LIGATED;\n@@ -649,1 +753,1 @@\n-      add_in &= ~HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n+      props &= ~HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n@@ -652,1 +756,1 @@\n-      add_in |= HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n+      props |= HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n@@ -654,1 +758,4 @@\n-      _hb_glyph_info_set_glyph_props (&buffer->cur(), add_in | gdef.get_glyph_props (glyph_index));\n+    {\n+      props &= HB_OT_LAYOUT_GLYPH_PROPS_PRESERVE;\n+      _hb_glyph_info_set_glyph_props (&buffer->cur(), props | gdef.get_glyph_props (glyph_index));\n+    }\n@@ -656,1 +763,6 @@\n-      _hb_glyph_info_set_glyph_props (&buffer->cur(), add_in | class_guess);\n+    {\n+      props &= HB_OT_LAYOUT_GLYPH_PROPS_PRESERVE;\n+      _hb_glyph_info_set_glyph_props (&buffer->cur(), props | class_guess);\n+    }\n+    else\n+      _hb_glyph_info_set_glyph_props (&buffer->cur(), props);\n@@ -661,1 +773,1 @@\n-    _set_glyph_props (glyph_index);\n+    _set_glyph_class (glyph_index);\n@@ -666,1 +778,1 @@\n-    _set_glyph_props (glyph_index);\n+    _set_glyph_class (glyph_index);\n@@ -672,1 +784,1 @@\n-    _set_glyph_props (glyph_index, class_guess, true);\n+    _set_glyph_class (glyph_index, class_guess, true);\n@@ -678,1 +790,1 @@\n-    _set_glyph_props (glyph_index, class_guess, false, true);\n+    _set_glyph_class (glyph_index, class_guess, false, true);\n@@ -684,2 +796,2 @@\n-struct hb_get_subtables_context_t :\n-       hb_dispatch_context_t<hb_get_subtables_context_t>\n+struct hb_accelerate_subtables_context_t :\n+       hb_dispatch_context_t<hb_accelerate_subtables_context_t>\n@@ -694,0 +806,24 @@\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+  template <typename T>\n+  static inline auto apply_cached_ (const T *obj, OT::hb_ot_apply_context_t *c, hb_priority<1>) HB_RETURN (bool, obj->apply (c, true) )\n+  template <typename T>\n+  static inline auto apply_cached_ (const T *obj, OT::hb_ot_apply_context_t *c, hb_priority<0>) HB_RETURN (bool, obj->apply (c) )\n+  template <typename Type>\n+  static inline bool apply_cached_to (const void *obj, OT::hb_ot_apply_context_t *c)\n+  {\n+    const Type *typed_obj = (const Type *) obj;\n+    return apply_cached_ (typed_obj, c, hb_prioritize);\n+  }\n+\n+  template <typename T>\n+  static inline auto cache_func_ (const T *obj, OT::hb_ot_apply_context_t *c, bool enter, hb_priority<1>) HB_RETURN (bool, obj->cache_func (c, enter) )\n+  template <typename T>\n+  static inline bool cache_func_ (const T *obj, OT::hb_ot_apply_context_t *c, bool enter, hb_priority<0>) { return false; }\n+  template <typename Type>\n+  static inline bool cache_func_to (const void *obj, OT::hb_ot_apply_context_t *c, bool enter)\n+  {\n+    const Type *typed_obj = (const Type *) obj;\n+    return cache_func_ (typed_obj, c, enter, hb_prioritize);\n+  }\n+#endif\n+\n@@ -695,0 +831,1 @@\n+  typedef bool (*hb_cache_func_t) (const void *obj, OT::hb_ot_apply_context_t *c, bool enter);\n@@ -698,0 +835,3 @@\n+    friend struct hb_accelerate_subtables_context_t;\n+    friend struct hb_ot_layout_lookup_accelerator_t;\n+\n@@ -699,1 +839,7 @@\n-    void init (const T &obj_, hb_apply_func_t apply_func_)\n+    void init (const T &obj_,\n+               hb_apply_func_t apply_func_\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+               , hb_apply_func_t apply_cached_func_\n+               , hb_cache_func_t cache_func_\n+#endif\n+                )\n@@ -703,0 +849,4 @@\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+      apply_cached_func = apply_cached_func_;\n+      cache_func = cache_func_;\n+#endif\n@@ -711,0 +861,14 @@\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+    bool apply_cached (OT::hb_ot_apply_context_t *c) const\n+    {\n+      return digest.may_have (c->buffer->cur().codepoint) &&  apply_cached_func (obj, c);\n+    }\n+    bool cache_enter (OT::hb_ot_apply_context_t *c) const\n+    {\n+      return cache_func (obj, c, true);\n+    }\n+    void cache_leave (OT::hb_ot_apply_context_t *c) const\n+    {\n+      cache_func (obj, c, false);\n+    }\n+#endif\n@@ -715,0 +879,4 @@\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+    hb_apply_func_t apply_cached_func;\n+    hb_cache_func_t cache_func;\n+#endif\n@@ -720,0 +888,7 @@\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+  template <typename T>\n+  auto cache_cost (const T &obj, hb_priority<1>) HB_AUTO_RETURN ( obj.cache_cost () )\n+  template <typename T>\n+  auto cache_cost (const T &obj, hb_priority<0>) HB_AUTO_RETURN ( 0u )\n+#endif\n+\n@@ -724,2 +899,29 @@\n-    hb_applicable_t *entry = array.push();\n-    entry->init (obj, apply_to<T>);\n+    hb_applicable_t entry;\n+\n+    entry.init (obj,\n+                apply_to<T>\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+                , apply_cached_to<T>\n+                , cache_func_to<T>\n+#endif\n+                );\n+\n+    array.push (entry);\n+\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+    \/* Cache handling\n+     *\n+     * We allow one subtable from each lookup to use a cache. The assumption\n+     * being that multiple subtables of the same lookup cannot use a cache\n+     * because the resources they would use will collide.  As such, we ask\n+     * each subtable to tell us how much it costs (which a cache would avoid),\n+     * and we allocate the cache opportunity to the costliest subtable.\n+     *\/\n+    unsigned cost = cache_cost (obj, hb_prioritize);\n+    if (cost > cache_user_cost && !array.in_error ())\n+    {\n+      cache_user_idx = array.length - 1;\n+      cache_user_cost = cost;\n+    }\n+#endif\n+\n@@ -730,2 +932,2 @@\n-  hb_get_subtables_context_t (array_t &array_) :\n-                              array (array_) {}\n+  hb_accelerate_subtables_context_t (array_t &array_) :\n+                                     array (array_) {}\n@@ -734,2 +936,0 @@\n-};\n-\n@@ -737,0 +937,5 @@\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+  unsigned cache_user_idx = (unsigned) -1;\n+  unsigned cache_user_cost = 0;\n+#endif\n+};\n@@ -740,0 +945,1 @@\n+typedef void (*intersected_glyphs_func_t) (const hb_set_t *glyphs, const void *data, unsigned value, hb_set_t *intersected_glyphs);\n@@ -741,1 +947,1 @@\n-typedef bool (*match_func_t) (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data);\n+typedef bool (*match_func_t) (hb_glyph_info_t &info, const HBUINT16 &value, const void *data);\n@@ -746,0 +952,1 @@\n+  intersected_glyphs_func_t intersected_glyphs;\n@@ -755,0 +962,4 @@\n+struct ChainContextApplyFuncs\n+{\n+  match_func_t match[3];\n+};\n@@ -768,1 +979,1 @@\n-  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n+  const Offset16To<Coverage> &coverage = (const Offset16To<Coverage>&)value;\n@@ -772,0 +983,19 @@\n+\n+static inline void intersected_glyph (const hb_set_t *glyphs HB_UNUSED, const void *data, unsigned value, hb_set_t *intersected_glyphs)\n+{\n+  unsigned g = reinterpret_cast<const HBUINT16 *>(data)[value];\n+  intersected_glyphs->add (g);\n+}\n+static inline void intersected_class_glyphs (const hb_set_t *glyphs, const void *data, unsigned value, hb_set_t *intersected_glyphs)\n+{\n+  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n+  class_def.intersected_class_glyphs (glyphs, value, intersected_glyphs);\n+}\n+static inline void intersected_coverage_glyphs (const hb_set_t *glyphs, const void *data, unsigned value, hb_set_t *intersected_glyphs)\n+{\n+  Offset16To<Coverage> coverage;\n+  coverage = value;\n+  (data+coverage).intersected_coverage_glyphs (glyphs, intersected_glyphs);\n+}\n+\n+\n@@ -795,1 +1025,1 @@\n-  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n+  const Offset16To<Coverage> &coverage = (const Offset16To<Coverage>&)value;\n@@ -812,1 +1042,5 @@\n-static inline bool match_glyph (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data HB_UNUSED)\n+static inline bool match_glyph (hb_glyph_info_t &info, const HBUINT16 &value, const void *data HB_UNUSED)\n+{\n+  return info.codepoint == value;\n+}\n+static inline bool match_class (hb_glyph_info_t &info, const HBUINT16 &value, const void *data)\n@@ -814,1 +1048,2 @@\n-  return glyph_id == value;\n+  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n+  return class_def.get_class (info.codepoint) == value;\n@@ -816,1 +1051,1 @@\n-static inline bool match_class (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data)\n+static inline bool match_class_cached (hb_glyph_info_t &info, const HBUINT16 &value, const void *data)\n@@ -818,0 +1053,3 @@\n+  unsigned klass = info.syllable();\n+  if (klass < 255)\n+    return klass == value;\n@@ -819,1 +1057,4 @@\n-  return class_def.get_class (glyph_id) == value;\n+  klass = class_def.get_class (info.codepoint);\n+  if (likely (klass < 255))\n+    info.syllable() = klass;\n+  return klass == value;\n@@ -821,1 +1062,1 @@\n-static inline bool match_coverage (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data)\n+static inline bool match_coverage (hb_glyph_info_t &info, const HBUINT16 &value, const void *data)\n@@ -823,2 +1064,2 @@\n-  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n-  return (data+coverage).get_coverage (glyph_id) != NOT_COVERED;\n+  const Offset16To<Coverage> &coverage = (const Offset16To<Coverage>&)value;\n+  return (data+coverage).get_coverage (info.codepoint) != NOT_COVERED;\n@@ -837,1 +1078,4 @@\n-    if (likely (!match_func (c->glyphs[i], input[i - 1], match_data)))\n+  {\n+    hb_glyph_info_t info;\n+    info.codepoint = c->glyphs[i];\n+    if (likely (!match_func (info, input[i - 1], match_data)))\n@@ -839,0 +1083,1 @@\n+  }\n@@ -847,1 +1092,1 @@\n-                                unsigned int *end_offset,\n+                                unsigned int *end_position,\n@@ -900,1 +1145,6 @@\n-    if (!skippy_iter.next ()) return_trace (false);\n+    unsigned unsafe_to;\n+    if (!skippy_iter.next (&unsafe_to))\n+    {\n+      *end_position = unsafe_to;\n+      return_trace (false);\n+    }\n@@ -954,1 +1204,1 @@\n-  *end_offset = skippy_iter.idx - buffer->idx + 1;\n+  *end_position = skippy_iter.idx + 1;\n@@ -964,1 +1214,1 @@\n-                                 unsigned int match_length,\n+                                 unsigned int match_end,\n@@ -972,1 +1222,1 @@\n-  buffer->merge_clusters (buffer->idx, buffer->idx + match_length);\n+  buffer->merge_clusters (buffer->idx, match_end);\n@@ -1089,1 +1339,5 @@\n-    if (!skippy_iter.prev ())\n+  {\n+    unsigned unsafe_from;\n+    if (!skippy_iter.prev (&unsafe_from))\n+    {\n+      *match_start = unsafe_from;\n@@ -1091,0 +1345,2 @@\n+    }\n+  }\n@@ -1093,1 +1349,0 @@\n-\n@@ -1102,1 +1357,1 @@\n-                                    unsigned int offset,\n+                                    unsigned int start_index,\n@@ -1108,1 +1363,1 @@\n-  skippy_iter.reset (c->buffer->idx + offset - 1, count);\n+  skippy_iter.reset (start_index - 1, count);\n@@ -1112,1 +1367,5 @@\n-    if (!skippy_iter.next ())\n+  {\n+    unsigned unsafe_to;\n+    if (!skippy_iter.next (&unsafe_to))\n+    {\n+      *end_index = unsafe_to;\n@@ -1114,0 +1373,2 @@\n+    }\n+  }\n@@ -1116,1 +1377,0 @@\n-\n@@ -1124,2 +1384,2 @@\n-  LookupRecord* copy (hb_serialize_context_t *c,\n-                      const hb_map_t         *lookup_map) const\n+  bool serialize (hb_serialize_context_t *c,\n+                  const hb_map_t         *lookup_map) const\n@@ -1129,1 +1389,1 @@\n-    if (unlikely (!out)) return_trace (nullptr);\n+    if (unlikely (!out)) return_trace (false);\n@@ -1131,2 +1391,1 @@\n-    out->lookupListIndex = hb_map_get (lookup_map, lookupListIndex);\n-    return_trace (out);\n+    return_trace (c->check_assign (out->lookupListIndex, lookup_map->get (lookupListIndex), HB_SERIALIZE_ERROR_INT_OVERFLOW));\n@@ -1149,0 +1408,88 @@\n+static unsigned serialize_lookuprecord_array (hb_serialize_context_t *c,\n+                                              const hb_array_t<const LookupRecord> lookupRecords,\n+                                              const hb_map_t *lookup_map)\n+{\n+  unsigned count = 0;\n+  for (const LookupRecord& r : lookupRecords)\n+  {\n+    if (!lookup_map->has (r.lookupListIndex))\n+      continue;\n+\n+    if (!r.serialize (c, lookup_map))\n+      return 0;\n+\n+    count++;\n+  }\n+  return count;\n+}\n+\n+enum ContextFormat { SimpleContext = 1, ClassBasedContext = 2, CoverageBasedContext = 3 };\n+\n+static void context_closure_recurse_lookups (hb_closure_context_t *c,\n+                                             unsigned inputCount, const HBUINT16 input[],\n+                                             unsigned lookupCount,\n+                                             const LookupRecord lookupRecord[] \/* Array of LookupRecords--in design order *\/,\n+                                             unsigned value,\n+                                             ContextFormat context_format,\n+                                             const void *data,\n+                                             intersected_glyphs_func_t intersected_glyphs_func)\n+{\n+  hb_set_t *covered_seq_indicies = hb_set_create ();\n+  for (unsigned int i = 0; i < lookupCount; i++)\n+  {\n+    unsigned seqIndex = lookupRecord[i].sequenceIndex;\n+    if (seqIndex >= inputCount) continue;\n+\n+    bool has_pos_glyphs = false;\n+    hb_set_t pos_glyphs;\n+\n+    if (!hb_set_has (covered_seq_indicies, seqIndex))\n+    {\n+      has_pos_glyphs = true;\n+      if (seqIndex == 0)\n+      {\n+        switch (context_format) {\n+        case ContextFormat::SimpleContext:\n+          pos_glyphs.add (value);\n+          break;\n+        case ContextFormat::ClassBasedContext:\n+          intersected_glyphs_func (&c->parent_active_glyphs (), data, value, &pos_glyphs);\n+          break;\n+        case ContextFormat::CoverageBasedContext:\n+          pos_glyphs.set (c->parent_active_glyphs ());\n+          break;\n+        }\n+      }\n+      else\n+      {\n+        const void *input_data = input;\n+        unsigned input_value = seqIndex - 1;\n+        if (context_format != ContextFormat::SimpleContext)\n+        {\n+          input_data = data;\n+          input_value = input[seqIndex - 1];\n+        }\n+\n+        intersected_glyphs_func (c->glyphs, input_data, input_value, &pos_glyphs);\n+      }\n+    }\n+\n+    covered_seq_indicies->add (seqIndex);\n+    if (has_pos_glyphs) {\n+      c->push_cur_active_glyphs () = std::move (pos_glyphs);\n+    } else {\n+      c->push_cur_active_glyphs ().set (*c->glyphs);\n+    }\n+\n+    unsigned endIndex = inputCount;\n+    if (context_format == ContextFormat::CoverageBasedContext)\n+      endIndex += 1;\n+\n+    c->recurse (lookupRecord[i].lookupListIndex, covered_seq_indicies, seqIndex, endIndex);\n+\n+    c->pop_cur_done_glyphs ();\n+  }\n+\n+  hb_set_destroy (covered_seq_indicies);\n+}\n+\n@@ -1158,1 +1505,1 @@\n-static inline bool apply_lookup (hb_ot_apply_context_t *c,\n+static inline void apply_lookup (hb_ot_apply_context_t *c,\n@@ -1163,1 +1510,1 @@\n-                                 unsigned int match_length)\n+                                 unsigned int match_end)\n@@ -1165,2 +1512,0 @@\n-  TRACE_APPLY (nullptr);\n-\n@@ -1174,1 +1519,1 @@\n-    end = bl + match_length;\n+    end = bl + match_end - buffer->idx;\n@@ -1188,3 +1533,4 @@\n-    \/* Don't recurse to ourself at same position.\n-     * Note that this test is too naive, it doesn't catch longer loops. *\/\n-    if (unlikely (idx == 0 && lookupRecord[i].lookupListIndex == c->lookup_index))\n+    unsigned int orig_len = buffer->backtrack_len () + buffer->lookahead_len ();\n+\n+    \/* This can happen if earlier recursed lookups deleted many entries. *\/\n+    if (unlikely (match_positions[idx] >= orig_len))\n@@ -1199,1 +1545,0 @@\n-    unsigned int orig_len = buffer->backtrack_len () + buffer->lookahead_len ();\n@@ -1225,5 +1570,4 @@\n-     *     mean that n match positions where removed, as there might\n-     *     have been marks and default-ignorables in the sequence.  We\n-     *     should instead drop match positions between current-position\n-     *     and current-position + n instead. Though, am not sure which\n-     *     one is better. Both cases have valid uses. Sigh.\n+     *     mean that n match positions where removed, as there recursed-to\n+     *     lookup might had a different LookupFlag.  Here's a constructed\n+     *     case of that:\n+     *     https:\/\/github.com\/harfbuzz\/harfbuzz\/discussions\/3538\n@@ -1235,1 +1579,1 @@\n-    if (end <= int (match_positions[idx]))\n+    if (end < int (match_positions[idx]))\n@@ -1238,3 +1582,8 @@\n-       * lookup ended up removing many items, more than we have had matched.\n-       * Just never rewind end back and get out of here.\n-       * https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=659496 *\/\n+       * lookup ended up removing many items.\n+       * Just never rewind end beyond start of current position, since that is\n+       * not possible in the recursed lookup.  Also adjust delta as such.\n+       *\n+       * https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=659496\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1611\n+       *\/\n+      delta += match_positions[idx] - end;\n@@ -1242,2 +1591,0 @@\n-      \/* There can't be any further changes. *\/\n-      break;\n@@ -1255,1 +1602,1 @@\n-      \/* NOTE: delta is negative. *\/\n+      \/* NOTE: delta is non-positive. *\/\n@@ -1276,2 +1623,0 @@\n-\n-  return_trace (true);\n@@ -1287,0 +1632,1 @@\n+  ContextFormat context_format;\n@@ -1317,0 +1663,1 @@\n+                                           unsigned value, \/* Index of first glyph in Coverage or Class value in ClassDef table *\/\n@@ -1322,2 +1669,7 @@\n-    recurse_lookups (c,\n-                     lookupCount, lookupRecord);\n+    context_closure_recurse_lookups (c,\n+                                     inputCount, input,\n+                                     lookupCount, lookupRecord,\n+                                     value,\n+                                     lookup_context.context_format,\n+                                     lookup_context.intersects_data,\n+                                     lookup_context.funcs.intersected_glyphs);\n@@ -1358,11 +1710,19 @@\n-  unsigned int match_length = 0;\n-  unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];\n-  return match_input (c,\n-                      inputCount, input,\n-                      lookup_context.funcs.match, lookup_context.match_data,\n-                      &match_length, match_positions)\n-      && (c->buffer->unsafe_to_break (c->buffer->idx, c->buffer->idx + match_length),\n-          apply_lookup (c,\n-                       inputCount, match_positions,\n-                       lookupCount, lookupRecord,\n-                       match_length));\n+  unsigned match_end = 0;\n+  unsigned match_positions[HB_MAX_CONTEXT_LENGTH];\n+  if (match_input (c,\n+                   inputCount, input,\n+                   lookup_context.funcs.match, lookup_context.match_data,\n+                   &match_end, match_positions))\n+  {\n+    c->buffer->unsafe_to_break (c->buffer->idx, match_end);\n+    apply_lookup (c,\n+                  inputCount, match_positions,\n+                  lookupCount, lookupRecord,\n+                  match_end);\n+    return true;\n+  }\n+  else\n+  {\n+    c->buffer->unsafe_to_concat (c->buffer->idx, match_end);\n+    return false;\n+  }\n@@ -1380,1 +1740,1 @@\n-  void closure (hb_closure_context_t *c, ContextClosureLookupContext &lookup_context) const\n+  void closure (hb_closure_context_t *c, unsigned value, ContextClosureLookupContext &lookup_context) const\n@@ -1389,1 +1749,1 @@\n-                            lookup_context);\n+                            value, lookup_context);\n@@ -1443,2 +1803,0 @@\n-    out->lookupCount = lookupCount;\n-\n@@ -1455,2 +1813,0 @@\n-    for (unsigned i = 0; i < (unsigned) lookupCount; i++)\n-      c->copy (lookupRecord[i], lookup_map);\n@@ -1458,1 +1814,2 @@\n-    return_trace (true);\n+    unsigned count = serialize_lookuprecord_array (c, lookupRecord.as_array (lookupCount), lookup_map);\n+    return_trace (c->check_assign (out->lookupCount, count, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n@@ -1466,3 +1823,2 @@\n-\n-    const hb_array_t<const HBUINT16> input = inputZ.as_array ((inputCount ? inputCount - 1 : 0));\n-    if (!input.length) return_trace (false);\n+    if (unlikely (!inputCount)) return_trace (false);\n+    const hb_array_t<const HBUINT16> input = inputZ.as_array (inputCount - 1);\n@@ -1514,1 +1870,1 @@\n-  void closure (hb_closure_context_t *c,\n+  void closure (hb_closure_context_t *c, unsigned value,\n@@ -1522,1 +1878,1 @@\n-    | hb_apply ([&] (const Rule &_) { _.closure (c, lookup_context); })\n+    | hb_apply ([&] (const Rule &_) { _.closure (c, value, lookup_context); })\n@@ -1580,1 +1936,1 @@\n-    for (const OffsetTo<Rule>& _ : rule)\n+    for (const Offset16To<Rule>& _ : rule)\n@@ -1583,0 +1939,1 @@\n+      auto o_snap = c->serializer->snapshot ();\n@@ -1586,1 +1943,0 @@\n-      auto o_snap = c->serializer->snapshot ();\n@@ -1607,1 +1963,1 @@\n-  OffsetArrayOf<Rule>\n+  Array16OfOffset16To<Rule>\n@@ -1620,1 +1976,2 @@\n-      {intersects_glyph},\n+      {intersects_glyph, intersected_glyph},\n+      ContextFormat::SimpleContext,\n@@ -1634,0 +1991,3 @@\n+  bool may_have_non_1to1 () const\n+  { return true; }\n+\n@@ -1636,0 +1996,4 @@\n+    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n+    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+                                                 cur_active_glyphs);\n+\n@@ -1637,1 +2001,2 @@\n-      {intersects_glyph},\n+      {intersects_glyph, intersected_glyph},\n+      ContextFormat::SimpleContext,\n@@ -1641,5 +2006,6 @@\n-    + hb_zip (this+coverage, ruleSet)\n-    | hb_filter (*c->glyphs, hb_first)\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([&] (const RuleSet &_) { _.closure (c, lookup_context); })\n+    + hb_zip (this+coverage, hb_range ((unsigned) ruleSet.len))\n+    | hb_filter ([&] (hb_codepoint_t _) {\n+      return c->previous_parent_active_glyphs ().has (_);\n+    }, hb_first)\n+    | hb_map ([&](const hb_pair_t<hb_codepoint_t, unsigned> _) { return hb_pair_t<unsigned, const RuleSet&> (_.first, this+ruleSet[_.second]); })\n+    | hb_apply ([&] (const hb_pair_t<unsigned, const RuleSet&>& _) { _.second.closure (c, _.first, lookup_context); })\n@@ -1647,0 +2013,2 @@\n+\n+    c->pop_cur_done_glyphs ();\n@@ -1652,1 +2020,2 @@\n-      {intersects_glyph},\n+      {intersects_glyph, intersected_glyph},\n+      ContextFormat::SimpleContext,\n@@ -1728,2 +2097,1 @@\n-    out->coverage.serialize (c->serializer, out)\n-                 .serialize (c->serializer, new_coverage.iter ());\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n@@ -1741,1 +2109,1 @@\n-  OffsetTo<Coverage>\n+  Offset16To<Coverage>\n@@ -1744,1 +2112,1 @@\n-  OffsetArrayOf<RuleSet>\n+  Array16OfOffset16To<RuleSet>\n@@ -1762,1 +2130,2 @@\n-      {intersects_class},\n+      {intersects_class, intersected_class_glyphs},\n+      ContextFormat::ClassBasedContext,\n@@ -1766,0 +2135,7 @@\n+    hb_set_t retained_coverage_glyphs;\n+    (this+coverage).intersected_coverage_glyphs (glyphs, &retained_coverage_glyphs);\n+\n+    hb_set_t coverage_glyph_classes;\n+    class_def.intersected_classes (&retained_coverage_glyphs, &coverage_glyph_classes);\n+\n+\n@@ -1772,0 +2148,1 @@\n+                       coverage_glyph_classes.has (p.first) &&\n@@ -1777,0 +2154,3 @@\n+  bool may_have_non_1to1 () const\n+  { return true; }\n+\n@@ -1782,0 +2162,4 @@\n+    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n+    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+                                                 cur_active_glyphs);\n+\n@@ -1785,1 +2169,2 @@\n-      {intersects_class},\n+      {intersects_class, intersected_class_glyphs},\n+      ContextFormat::ClassBasedContext,\n@@ -1789,1 +2174,0 @@\n-    return\n@@ -1792,1 +2176,1 @@\n-                 { return class_def.intersects_class (c->glyphs, _); },\n+    { return class_def.intersects_class (&c->parent_active_glyphs (), _); },\n@@ -1794,3 +2178,5 @@\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([&] (const RuleSet &_) { _.closure (c, lookup_context); })\n+    | hb_apply ([&] (const hb_pair_t<unsigned, const Offset16To<RuleSet>&> _)\n+                {\n+                  const RuleSet& rule_set = this+_.second;\n+                  rule_set.closure (c, _.first, lookup_context);\n+                })\n@@ -1798,0 +2184,2 @@\n+\n+    c->pop_cur_done_glyphs ();\n@@ -1808,1 +2196,2 @@\n-      {intersects_class},\n+      {intersects_class, intersected_class_glyphs},\n+      ContextFormat::ClassBasedContext,\n@@ -1854,1 +2243,27 @@\n-  bool apply (hb_ot_apply_context_t *c) const\n+  unsigned cache_cost () const\n+  {\n+    unsigned c = (this+classDef).cost () * ruleSet.len;\n+    return c >= 4 ? c : 0;\n+  }\n+  bool cache_func (hb_ot_apply_context_t *c, bool enter) const\n+  {\n+    if (enter)\n+    {\n+      if (!HB_BUFFER_TRY_ALLOCATE_VAR (c->buffer, syllable))\n+        return false;\n+      auto &info = c->buffer->info;\n+      unsigned count = c->buffer->len;\n+      for (unsigned i = 0; i < count; i++)\n+        info[i].syllable() = 255;\n+      c->new_syllables = 255;\n+      return true;\n+    }\n+    else\n+    {\n+      c->new_syllables = (unsigned) -1;\n+      HB_BUFFER_DEALLOCATE_VAR (c->buffer, syllable);\n+      return true;\n+    }\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c, bool cached = false) const\n@@ -1861,2 +2276,1 @@\n-    index = class_def.get_class (c->buffer->cur().codepoint);\n-    const RuleSet &rule_set = this+ruleSet[index];\n+\n@@ -1864,1 +2278,1 @@\n-      {match_class},\n+      {cached ? match_class_cached : match_class},\n@@ -1867,0 +2281,10 @@\n+\n+    if (cached && c->buffer->cur().syllable() < 255)\n+      index = c->buffer->cur().syllable ();\n+    else\n+    {\n+      index = class_def.get_class (c->buffer->cur().codepoint);\n+      if (cached && index < 255)\n+        c->buffer->cur().syllable() = index;\n+    }\n+    const RuleSet &rule_set = this+ruleSet[index];\n@@ -1882,0 +2306,7 @@\n+    const hb_set_t* glyphset = c->plan->glyphset_gsub ();\n+    hb_set_t retained_coverage_glyphs;\n+    (this+coverage).intersected_coverage_glyphs (glyphset, &retained_coverage_glyphs);\n+\n+    hb_set_t coverage_glyph_classes;\n+    (this+classDef).intersected_classes (&retained_coverage_glyphs, &coverage_glyph_classes);\n+\n@@ -1884,1 +2315,1 @@\n-    int non_zero_index = 0, index = 0;\n+    int non_zero_index = -1, index = 0;\n@@ -1895,1 +2326,2 @@\n-      if (o->serialize_subset (c, _.second, this, lookup_map, &klass_map))\n+      if (coverage_glyph_classes.has (_.first) &&\n+          o->serialize_subset (c, _.second, this, lookup_map, &klass_map))\n@@ -1901,1 +2333,1 @@\n-    if (!ret) return_trace (ret);\n+    if (!ret || non_zero_index == -1) return_trace (false);\n@@ -1922,1 +2354,1 @@\n-  OffsetTo<Coverage>\n+  Offset16To<Coverage>\n@@ -1925,1 +2357,1 @@\n-  OffsetTo<ClassDef>\n+  Offset16To<ClassDef>\n@@ -1928,1 +2360,1 @@\n-  OffsetArrayOf<RuleSet>\n+  Array16OfOffset16To<RuleSet>\n@@ -1944,1 +2376,2 @@\n-      {intersects_coverage},\n+      {intersects_coverage, intersected_coverage_glyphs},\n+      ContextFormat::CoverageBasedContext,\n@@ -1952,0 +2385,3 @@\n+  bool may_have_non_1to1 () const\n+  { return true; }\n+\n@@ -1957,0 +2393,5 @@\n+    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n+    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+                                                 cur_active_glyphs);\n+\n+\n@@ -1959,1 +2400,2 @@\n-      {intersects_coverage},\n+      {intersects_coverage, intersected_coverage_glyphs},\n+      ContextFormat::CoverageBasedContext,\n@@ -1965,1 +2407,3 @@\n-                            lookup_context);\n+                            0, lookup_context);\n+\n+    c->pop_cur_done_glyphs ();\n@@ -2031,1 +2475,0 @@\n-    out->lookupCount = lookupCount;\n@@ -2035,1 +2478,1 @@\n-    for (const OffsetTo<Coverage>& offset : coverages)\n+    for (const Offset16To<Coverage>& offset : coverages)\n@@ -2038,1 +2481,1 @@\n-      auto *o = c->serializer->allocate_size<OffsetTo<Coverage>> (OffsetTo<Coverage>::static_size);\n+      auto *o = c->serializer->allocate_size<Offset16To<Coverage>> (Offset16To<Coverage>::static_size);\n@@ -2043,1 +2486,1 @@\n-    const LookupRecord *lookupRecord = &StructAfter<LookupRecord> (coverageZ.as_array (glyphCount));\n+    const UnsizedArrayOf<LookupRecord>& lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord>> (coverageZ.as_array (glyphCount));\n@@ -2045,2 +2488,0 @@\n-    for (unsigned i = 0; i < (unsigned) lookupCount; i++)\n-      c->serializer->copy (lookupRecord[i], lookup_map);\n@@ -2048,1 +2489,3 @@\n-    return_trace (true);\n+\n+    unsigned count = serialize_lookuprecord_array (c->serializer, lookupRecord.as_array (lookupCount), lookup_map);\n+    return_trace (c->serializer->check_assign (out->lookupCount, count, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n@@ -2069,1 +2512,1 @@\n-  UnsizedArrayOf<OffsetTo<Coverage>>\n+  UnsizedArrayOf<Offset16To<Coverage>>\n@@ -2087,3 +2530,3 @@\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.format2, hb_forward<Ts> (ds)...));\n-    case 3: return_trace (c->dispatch (u.format3, hb_forward<Ts> (ds)...));\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    case 3: return_trace (c->dispatch (u.format3, std::forward<Ts> (ds)...));\n@@ -2109,0 +2552,1 @@\n+  ContextFormat context_format;\n@@ -2120,1 +2564,1 @@\n-  ContextApplyFuncs funcs;\n+  ChainContextApplyFuncs funcs;\n@@ -2153,0 +2597,1 @@\n+                                                 unsigned value,\n@@ -2160,2 +2605,7 @@\n-    recurse_lookups (c,\n-                     lookupCount, lookupRecord);\n+    context_closure_recurse_lookups (c,\n+                     inputCount, input,\n+                     lookupCount, lookupRecord,\n+                     value,\n+                     lookup_context.context_format,\n+                     lookup_context.intersects_data[1],\n+                     lookup_context.funcs.intersected_glyphs);\n@@ -2202,1 +2652,1 @@\n-                            lookup_context.funcs.match, lookup_context.match_data[1]);\n+                            lookup_context.funcs.match[1], lookup_context.match_data[1]);\n@@ -2216,19 +2666,32 @@\n-  unsigned int start_index = 0, match_length = 0, end_index = 0;\n-  unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];\n-  return match_input (c,\n-                      inputCount, input,\n-                      lookup_context.funcs.match, lookup_context.match_data[1],\n-                      &match_length, match_positions)\n-      && match_backtrack (c,\n-                          backtrackCount, backtrack,\n-                          lookup_context.funcs.match, lookup_context.match_data[0],\n-                          &start_index)\n-      && match_lookahead (c,\n-                          lookaheadCount, lookahead,\n-                          lookup_context.funcs.match, lookup_context.match_data[2],\n-                          match_length, &end_index)\n-      && (c->buffer->unsafe_to_break_from_outbuffer (start_index, end_index),\n-          apply_lookup (c,\n-                        inputCount, match_positions,\n-                        lookupCount, lookupRecord,\n-                        match_length));\n+  unsigned end_index = c->buffer->idx;\n+  unsigned match_end = 0;\n+  unsigned match_positions[HB_MAX_CONTEXT_LENGTH];\n+  if (!(match_input (c,\n+                     inputCount, input,\n+                     lookup_context.funcs.match[1], lookup_context.match_data[1],\n+                     &match_end, match_positions) && (end_index = match_end)\n+       && match_lookahead (c,\n+                           lookaheadCount, lookahead,\n+                           lookup_context.funcs.match[2], lookup_context.match_data[2],\n+                           match_end, &end_index)))\n+  {\n+    c->buffer->unsafe_to_concat (c->buffer->idx, end_index);\n+    return false;\n+  }\n+\n+  unsigned start_index = c->buffer->out_len;\n+  if (!match_backtrack (c,\n+                        backtrackCount, backtrack,\n+                        lookup_context.funcs.match[0], lookup_context.match_data[0],\n+                        &start_index))\n+  {\n+    c->buffer->unsafe_to_concat_from_outbuffer (start_index, end_index);\n+    return false;\n+  }\n+\n+  c->buffer->unsafe_to_break_from_outbuffer (start_index, end_index);\n+  apply_lookup (c,\n+                inputCount, match_positions,\n+                lookupCount, lookupRecord,\n+                match_end);\n+  return true;\n@@ -2242,1 +2705,1 @@\n-    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16>> (input);\n+    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n@@ -2250,1 +2713,1 @@\n-  void closure (hb_closure_context_t *c,\n+  void closure (hb_closure_context_t *c, unsigned value,\n@@ -2256,2 +2719,2 @@\n-    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -2263,0 +2726,1 @@\n+                                  value,\n@@ -2273,2 +2737,2 @@\n-    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -2282,2 +2746,2 @@\n-    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -2296,2 +2760,2 @@\n-    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -2309,2 +2773,2 @@\n-    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -2329,5 +2793,5 @@\n-  ChainRule* copy (hb_serialize_context_t *c,\n-                   const hb_map_t *lookup_map,\n-                   const hb_map_t *backtrack_map,\n-                   const hb_map_t *input_map = nullptr,\n-                   const hb_map_t *lookahead_map = nullptr) const\n+  bool serialize (hb_serialize_context_t *c,\n+                  const hb_map_t *lookup_map,\n+                  const hb_map_t *backtrack_map,\n+                  const hb_map_t *input_map = nullptr,\n+                  const hb_map_t *lookahead_map = nullptr) const\n@@ -2337,1 +2801,1 @@\n-    if (unlikely (!out)) return_trace (nullptr);\n+    if (unlikely (!out)) return_trace (false);\n@@ -2348,1 +2812,1 @@\n-    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16>> (input);\n+    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n@@ -2353,1 +2817,1 @@\n-    const ArrayOf<LookupRecord> &lookupRecord = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16Of<LookupRecord> &lookupRecord = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -2356,1 +2820,1 @@\n-    if (!lookupCount) return_trace (nullptr);\n+    if (!lookupCount) return_trace (false);\n@@ -2358,11 +2822,2 @@\n-    for (unsigned i = 0; i < lookupRecord.len; i++)\n-    {\n-      if (!lookup_map->has (lookupRecord[i].lookupListIndex))\n-      {\n-        (*lookupCount)--;\n-        continue;\n-      }\n-      if (!c->copy (lookupRecord[i], lookup_map)) return_trace (nullptr);\n-    }\n-\n-    return_trace (out);\n+    unsigned count = serialize_lookuprecord_array (c, lookupRecord.as_array (), lookup_map);\n+    return_trace (c->check_assign (*lookupCount, count, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n@@ -2380,1 +2835,1 @@\n-    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16>> (input);\n+    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n@@ -2390,1 +2845,1 @@\n-      copy (c->serializer, lookup_map, c->plan->glyph_map);\n+      serialize (c->serializer, lookup_map, c->plan->glyph_map);\n@@ -2399,1 +2854,1 @@\n-      copy (c->serializer, lookup_map, backtrack_map, input_map, lookahead_map);\n+      serialize (c->serializer, lookup_map, backtrack_map, input_map, lookahead_map);\n@@ -2411,1 +2866,1 @@\n-    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16>> (input);\n+    const Array16Of<HBUINT16> &lookahead = StructAfter<Array16Of<HBUINT16>> (input);\n@@ -2413,1 +2868,1 @@\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -2418,1 +2873,1 @@\n-  ArrayOf<HBUINT16>\n+  Array16Of<HBUINT16>\n@@ -2425,1 +2880,1 @@\n-  ArrayOf<HBUINT16>\n+  Array16Of<HBUINT16>\n@@ -2428,1 +2883,1 @@\n-  ArrayOf<LookupRecord>\n+  Array16Of<LookupRecord>\n@@ -2446,1 +2901,1 @@\n-  void closure (hb_closure_context_t *c, ChainContextClosureLookupContext &lookup_context) const\n+  void closure (hb_closure_context_t *c, unsigned value, ChainContextClosureLookupContext &lookup_context) const\n@@ -2453,1 +2908,1 @@\n-    | hb_apply ([&] (const ChainRule &_) { _.closure (c, lookup_context); })\n+    | hb_apply ([&] (const ChainRule &_) { _.closure (c, value, lookup_context); })\n@@ -2511,1 +2966,1 @@\n-    for (const OffsetTo<ChainRule>& _ : rule)\n+    for (const Offset16To<ChainRule>& _ : rule)\n@@ -2514,0 +2969,1 @@\n+      auto o_snap = c->serializer->snapshot ();\n@@ -2517,1 +2973,0 @@\n-      auto o_snap = c->serializer->snapshot ();\n@@ -2542,1 +2997,1 @@\n-  OffsetArrayOf<ChainRule>\n+  Array16OfOffset16To<ChainRule>\n@@ -2554,1 +3009,2 @@\n-      {intersects_glyph},\n+      {intersects_glyph, intersected_glyph},\n+      ContextFormat::SimpleContext,\n@@ -2568,0 +3024,3 @@\n+  bool may_have_non_1to1 () const\n+  { return true; }\n+\n@@ -2570,0 +3029,4 @@\n+    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n+    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+                                                 cur_active_glyphs);\n+\n@@ -2571,1 +3034,2 @@\n-      {intersects_glyph},\n+      {intersects_glyph, intersected_glyph},\n+      ContextFormat::SimpleContext,\n@@ -2575,5 +3039,6 @@\n-    + hb_zip (this+coverage, ruleSet)\n-    | hb_filter (*c->glyphs, hb_first)\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([&] (const ChainRuleSet &_) { _.closure (c, lookup_context); })\n+    + hb_zip (this+coverage, hb_range ((unsigned) ruleSet.len))\n+    | hb_filter ([&] (hb_codepoint_t _) {\n+      return c->previous_parent_active_glyphs ().has (_);\n+    }, hb_first)\n+    | hb_map ([&](const hb_pair_t<hb_codepoint_t, unsigned> _) { return hb_pair_t<unsigned, const ChainRuleSet&> (_.first, this+ruleSet[_.second]); })\n+    | hb_apply ([&] (const hb_pair_t<unsigned, const ChainRuleSet&>& _) { _.second.closure (c, _.first, lookup_context); })\n@@ -2581,0 +3046,2 @@\n+\n+    c->pop_cur_done_glyphs ();\n@@ -2586,1 +3053,2 @@\n-      {intersects_glyph},\n+      {intersects_glyph, intersected_glyph},\n+      ContextFormat::SimpleContext,\n@@ -2619,1 +3087,1 @@\n-      {match_glyph},\n+      {{match_glyph, match_glyph, match_glyph}},\n@@ -2635,1 +3103,1 @@\n-      {match_glyph},\n+      {{match_glyph, match_glyph, match_glyph}},\n@@ -2661,2 +3129,1 @@\n-    out->coverage.serialize (c->serializer, out)\n-                 .serialize (c->serializer, new_coverage.iter ());\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n@@ -2674,1 +3141,1 @@\n-  OffsetTo<Coverage>\n+  Offset16To<Coverage>\n@@ -2677,1 +3144,1 @@\n-  OffsetArrayOf<ChainRuleSet>\n+  Array16OfOffset16To<ChainRuleSet>\n@@ -2696,1 +3163,2 @@\n-      {intersects_class},\n+      {intersects_class, intersected_class_glyphs},\n+      ContextFormat::ClassBasedContext,\n@@ -2702,0 +3170,6 @@\n+    hb_set_t retained_coverage_glyphs;\n+    (this+coverage).intersected_coverage_glyphs (glyphs, &retained_coverage_glyphs);\n+\n+    hb_set_t coverage_glyph_classes;\n+    input_class_def.intersected_classes (&retained_coverage_glyphs, &coverage_glyph_classes);\n+\n@@ -2708,0 +3182,1 @@\n+                       coverage_glyph_classes.has (p.first) &&\n@@ -2712,0 +3187,4 @@\n+\n+  bool may_have_non_1to1 () const\n+  { return true; }\n+\n@@ -2717,0 +3196,5 @@\n+    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n+    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+                                                 cur_active_glyphs);\n+\n+\n@@ -2722,1 +3206,2 @@\n-      {intersects_class},\n+      {intersects_class, intersected_class_glyphs},\n+      ContextFormat::ClassBasedContext,\n@@ -2728,1 +3213,0 @@\n-    return\n@@ -2731,1 +3215,1 @@\n-                 { return input_class_def.intersects_class (c->glyphs, _); },\n+    { return input_class_def.intersects_class (&c->parent_active_glyphs (), _); },\n@@ -2733,3 +3217,5 @@\n-    | hb_map (hb_second)\n-    | hb_map (hb_add (this))\n-    | hb_apply ([&] (const ChainRuleSet &_) { _.closure (c, lookup_context); })\n+    | hb_apply ([&] (const hb_pair_t<unsigned, const Offset16To<ChainRuleSet>&> _)\n+                {\n+                  const ChainRuleSet& chainrule_set = this+_.second;\n+                  chainrule_set.closure (c, _.first, lookup_context);\n+                })\n@@ -2737,0 +3223,2 @@\n+\n+    c->pop_cur_done_glyphs ();\n@@ -2749,1 +3237,2 @@\n-      {intersects_class},\n+      {intersects_class, intersected_class_glyphs},\n+      ContextFormat::ClassBasedContext,\n@@ -2798,1 +3287,1 @@\n-      {match_class},\n+      {{match_class, match_class, match_class}},\n@@ -2808,1 +3297,27 @@\n-  bool apply (hb_ot_apply_context_t *c) const\n+  unsigned cache_cost () const\n+  {\n+    unsigned c = (this+lookaheadClassDef).cost () * ruleSet.len;\n+    return c >= 4 ? c : 0;\n+  }\n+  bool cache_func (hb_ot_apply_context_t *c, bool enter) const\n+  {\n+    if (enter)\n+    {\n+      if (!HB_BUFFER_TRY_ALLOCATE_VAR (c->buffer, syllable))\n+        return false;\n+      auto &info = c->buffer->info;\n+      unsigned count = c->buffer->len;\n+      for (unsigned i = 0; i < count; i++)\n+        info[i].syllable() = 255;\n+      c->new_syllables = 255;\n+      return true;\n+    }\n+    else\n+    {\n+      c->new_syllables = (unsigned) -1;\n+      HB_BUFFER_DEALLOCATE_VAR (c->buffer, syllable);\n+      return true;\n+    }\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c, bool cached = false) const\n@@ -2818,2 +3333,10 @@\n-    index = input_class_def.get_class (c->buffer->cur().codepoint);\n-    const ChainRuleSet &rule_set = this+ruleSet[index];\n+    \/* For ChainContextFormat2 we cache the LookaheadClassDef instead of InputClassDef.\n+     * The reason is that most heavy fonts want to identify a glyph in context and apply\n+     * a lookup to it. In this scenario, the length of the input sequence is one, whereas\n+     * the lookahead \/ backtrack are typically longer.  The one glyph in input sequence is\n+     * looked-up below and no input glyph is looked up in individual rules, whereas the\n+     * lookahead and backtrack glyphs are tried.  Since we match lookahead before backtrack,\n+     * we should cache lookahead.  This decisions showed a 20% improvement in shaping of\n+     * the Gulzar font.\n+     *\/\n+\n@@ -2821,1 +3344,3 @@\n-      {match_class},\n+      {{cached && &backtrack_class_def == &input_class_def ? match_class_cached : match_class,\n+        cached && &input_class_def == &lookahead_class_def ? match_class_cached : match_class,\n+        cached ? match_class_cached : match_class}},\n@@ -2826,0 +3351,3 @@\n+\n+    index = input_class_def.get_class (c->buffer->cur().codepoint);\n+    const ChainRuleSet &rule_set = this+ruleSet[index];\n@@ -2851,0 +3379,7 @@\n+    const hb_set_t* glyphset = c->plan->glyphset_gsub ();\n+    hb_set_t retained_coverage_glyphs;\n+    (this+coverage).intersected_coverage_glyphs (glyphset, &retained_coverage_glyphs);\n+\n+    hb_set_t coverage_glyph_classes;\n+    (this+inputClassDef).intersected_classes (&retained_coverage_glyphs, &coverage_glyph_classes);\n+\n@@ -2855,3 +3390,2 @@\n-    for (const OffsetTo<ChainRuleSet>& _ : + hb_enumerate (ruleSet)\n-                                           | hb_filter (input_klass_map, hb_first)\n-                                           | hb_map (hb_second))\n+    for (const auto& _ : + hb_enumerate (ruleSet)\n+                         | hb_filter (input_klass_map, hb_first))\n@@ -2865,1 +3399,2 @@\n-      if (o->serialize_subset (c, _, this,\n+      if (coverage_glyph_classes.has (_.first) &&\n+          o->serialize_subset (c, _.second, this,\n@@ -2878,1 +3413,1 @@\n-    if (!ret) return_trace (ret);\n+    if (!ret || non_zero_index == -1) return_trace (false);\n@@ -2901,1 +3436,1 @@\n-  OffsetTo<Coverage>\n+  Offset16To<Coverage>\n@@ -2904,1 +3439,1 @@\n-  OffsetTo<ClassDef>\n+  Offset16To<ClassDef>\n@@ -2908,1 +3443,1 @@\n-  OffsetTo<ClassDef>\n+  Offset16To<ClassDef>\n@@ -2912,1 +3447,1 @@\n-  OffsetTo<ClassDef>\n+  Offset16To<ClassDef>\n@@ -2916,1 +3451,1 @@\n-  OffsetArrayOf<ChainRuleSet>\n+  Array16OfOffset16To<ChainRuleSet>\n@@ -2927,1 +3462,1 @@\n-    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n+    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n@@ -2932,1 +3467,1 @@\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (input);\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n@@ -2934,1 +3469,2 @@\n-      {intersects_coverage},\n+      {intersects_coverage, intersected_coverage_glyphs},\n+      ContextFormat::CoverageBasedContext,\n@@ -2944,0 +3480,3 @@\n+  bool may_have_non_1to1 () const\n+  { return true; }\n+\n@@ -2946,1 +3485,1 @@\n-    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n+    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n@@ -2951,2 +3490,7 @@\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    hb_set_t* cur_active_glyphs = &c->push_cur_active_glyphs ();\n+    get_coverage ().intersected_coverage_glyphs (&c->previous_parent_active_glyphs (),\n+                                                 cur_active_glyphs);\n+\n+\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -2954,1 +3498,2 @@\n-      {intersects_coverage},\n+      {intersects_coverage, intersected_coverage_glyphs},\n+      ContextFormat::CoverageBasedContext,\n@@ -2962,1 +3507,3 @@\n-                                  lookup_context);\n+                                  0, lookup_context);\n+\n+    c->pop_cur_done_glyphs ();\n@@ -2970,3 +3517,3 @@\n-    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -2980,1 +3527,1 @@\n-    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n+    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n@@ -2984,2 +3531,2 @@\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -3000,3 +3547,3 @@\n-    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -3004,1 +3551,1 @@\n-      {match_coverage},\n+      {{match_coverage, match_coverage, match_coverage}},\n@@ -3016,1 +3563,1 @@\n-    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n+    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n@@ -3023,1 +3570,1 @@\n-    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n+    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n@@ -3028,2 +3575,2 @@\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (input);\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -3031,1 +3578,1 @@\n-      {match_coverage},\n+      {{match_coverage, match_coverage, match_coverage}},\n@@ -3046,1 +3593,1 @@\n-    auto *out = c->serializer->start_embed<OffsetArrayOf<Coverage>> ();\n+    auto *out = c->serializer->start_embed<Array16OfOffset16To<Coverage>> ();\n@@ -3071,1 +3618,1 @@\n-    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n+    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n@@ -3075,1 +3622,1 @@\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (input);\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n@@ -3079,5 +3626,1 @@\n-    const ArrayOf<LookupRecord> &lookupRecord = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n-    HBUINT16 lookupCount;\n-    lookupCount = lookupRecord.len;\n-    if (!c->serializer->copy (lookupCount)) return_trace (false);\n-\n+    const Array16Of<LookupRecord> &lookupRecord = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -3085,2 +3628,0 @@\n-    for (unsigned i = 0; i < (unsigned) lookupCount; i++)\n-      if (!c->serializer->copy (lookupRecord[i], lookup_map)) return_trace (false);\n@@ -3088,1 +3629,5 @@\n-    return_trace (true);\n+    HBUINT16 *lookupCount = c->serializer->copy<HBUINT16> (lookupRecord.len);\n+    if (!lookupCount) return_trace (false);\n+\n+    unsigned count = serialize_lookuprecord_array (c->serializer, lookupRecord.as_array (), lookup_map);\n+    return_trace (c->serializer->check_assign (*lookupCount, count, HB_SERIALIZE_ERROR_INT_OVERFLOW));\n@@ -3095,1 +3640,1 @@\n-    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage>> (backtrack);\n+    const Array16OfOffset16To<Coverage> &input = StructAfter<Array16OfOffset16To<Coverage>> (backtrack);\n@@ -3098,1 +3643,1 @@\n-    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage>> (input);\n+    const Array16OfOffset16To<Coverage> &lookahead = StructAfter<Array16OfOffset16To<Coverage>> (input);\n@@ -3100,1 +3645,1 @@\n-    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord>> (lookahead);\n+    const Array16Of<LookupRecord> &lookup = StructAfter<Array16Of<LookupRecord>> (lookahead);\n@@ -3106,1 +3651,1 @@\n-  OffsetArrayOf<Coverage>\n+  Array16OfOffset16To<Coverage>\n@@ -3110,1 +3655,1 @@\n-  OffsetArrayOf<Coverage>\n+  Array16OfOffset16To<Coverage>\n@@ -3114,1 +3659,1 @@\n-  OffsetArrayOf<Coverage>\n+  Array16OfOffset16To<Coverage>\n@@ -3118,1 +3663,1 @@\n-  ArrayOf<LookupRecord>\n+  Array16Of<LookupRecord>\n@@ -3133,3 +3678,3 @@\n-    case 1: return_trace (c->dispatch (u.format1, hb_forward<Ts> (ds)...));\n-    case 2: return_trace (c->dispatch (u.format2, hb_forward<Ts> (ds)...));\n-    case 3: return_trace (c->dispatch (u.format3, hb_forward<Ts> (ds)...));\n+    case 1: return_trace (c->dispatch (u.format1, std::forward<Ts> (ds)...));\n+    case 2: return_trace (c->dispatch (u.format2, std::forward<Ts> (ds)...));\n+    case 3: return_trace (c->dispatch (u.format3, std::forward<Ts> (ds)...));\n@@ -3157,1 +3702,1 @@\n-  { return this + reinterpret_cast<const LOffsetTo<typename T::SubTable> &> (extensionOffset); }\n+  { return this + reinterpret_cast<const Offset32To<typename T::SubTable> &> (extensionOffset); }\n@@ -3164,1 +3709,1 @@\n-    return_trace (get_subtable<typename T::SubTable> ().dispatch (c, get_type (), hb_forward<Ts> (ds)...));\n+    return_trace (get_subtable<typename T::SubTable> ().dispatch (c, get_type (), std::forward<Ts> (ds)...));\n@@ -3189,1 +3734,1 @@\n-        reinterpret_cast<const LOffsetTo<typename T::SubTable> &> (extensionOffset);\n+        reinterpret_cast<const Offset32To<typename T::SubTable> &> (extensionOffset);\n@@ -3191,1 +3736,1 @@\n-        reinterpret_cast<LOffsetTo<typename T::SubTable> &> (out->extensionOffset);\n+        reinterpret_cast<Offset32To<typename T::SubTable> &> (out->extensionOffset);\n@@ -3244,1 +3789,1 @@\n-    case 1: return_trace (u.format1.dispatch (c, hb_forward<Ts> (ds)...));\n+    case 1: return_trace (u.format1.dispatch (c, std::forward<Ts> (ds)...));\n@@ -3270,2 +3815,9 @@\n-    OT::hb_get_subtables_context_t c_get_subtables (subtables);\n-    lookup.dispatch (&c_get_subtables);\n+    OT::hb_accelerate_subtables_context_t c_accelerate_subtables (subtables);\n+    lookup.dispatch (&c_accelerate_subtables);\n+\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+    cache_user_idx = c_accelerate_subtables.cache_user_idx;\n+    for (unsigned i = 0; i < subtables.length; i++)\n+      if (i != cache_user_idx)\n+        subtables[i].apply_cached_func = subtables[i].apply_func;\n+#endif\n@@ -3278,1 +3830,1 @@\n-  bool apply (hb_ot_apply_context_t *c) const\n+  bool apply (hb_ot_apply_context_t *c, bool use_cache) const\n@@ -3280,3 +3832,14 @@\n-    for (unsigned int i = 0; i < subtables.length; i++)\n-      if (subtables[i].apply (c))\n-        return true;\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+    if (use_cache)\n+    {\n+      for (unsigned int i = 0; i < subtables.length; i++)\n+        if (subtables[i].apply_cached (c))\n+          return true;\n+    }\n+    else\n+#endif\n+    {\n+      for (unsigned int i = 0; i < subtables.length; i++)\n+        if (subtables[i].apply (c))\n+          return true;\n+    }\n@@ -3286,0 +3849,17 @@\n+  bool cache_enter (OT::hb_ot_apply_context_t *c) const\n+  {\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+    return cache_user_idx != (unsigned) -1 &&\n+           subtables[cache_user_idx].cache_enter (c);\n+#else\n+    return false;\n+#endif\n+  }\n+  void cache_leave (OT::hb_ot_apply_context_t *c) const\n+  {\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+    subtables[cache_user_idx].cache_leave (c);\n+#endif\n+  }\n+\n+\n@@ -3288,1 +3868,4 @@\n-  hb_get_subtables_context_t::array_t subtables;\n+  hb_accelerate_subtables_context_t::array_t subtables;\n+#ifndef HB_NO_OT_LAYOUT_LOOKUP_CACHE\n+  unsigned cache_user_idx = (unsigned) -1;\n+#endif\n@@ -3368,0 +3951,2 @@\n+    c.set_recurse_func (TLookup::template dispatch_recurse_func<hb_closure_lookups_context_t>);\n+\n@@ -3375,0 +3960,14 @@\n+  void prune_langsys (const hb_map_t *duplicate_feature_map,\n+                      hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *script_langsys_map,\n+                      hb_set_t       *new_feature_indexes \/* OUT *\/) const\n+  {\n+    hb_prune_langsys_context_t c (this, script_langsys_map, duplicate_feature_map, new_feature_indexes);\n+\n+    unsigned count = get_script_count ();\n+    for (unsigned script_index = 0; script_index < count; script_index++)\n+    {\n+      const Script& s = get_script (script_index);\n+      s.prune_langsys (&c, script_index);\n+    }\n+  }\n+\n@@ -3383,1 +3982,1 @@\n-    reinterpret_cast<OffsetTo<TLookupList> &> (out->lookupList)\n+    reinterpret_cast<Offset16To<TLookupList> &> (out->lookupList)\n@@ -3385,1 +3984,1 @@\n-                           reinterpret_cast<const OffsetTo<TLookupList> &> (lookupList),\n+                           reinterpret_cast<const Offset16To<TLookupList> &> (lookupList),\n@@ -3389,1 +3988,1 @@\n-    reinterpret_cast<OffsetTo<RecordListOfFeature> &> (out->featureList)\n+    reinterpret_cast<Offset16To<RecordListOfFeature> &> (out->featureList)\n@@ -3391,1 +3990,1 @@\n-                           reinterpret_cast<const OffsetTo<RecordListOfFeature> &> (featureList),\n+                           reinterpret_cast<const Offset16To<RecordListOfFeature> &> (featureList),\n@@ -3415,0 +4014,62 @@\n+  void find_duplicate_features (const hb_map_t *lookup_indices,\n+                                const hb_set_t *feature_indices,\n+                                hb_map_t *duplicate_feature_map \/* OUT *\/) const\n+  {\n+    if (feature_indices->is_empty ()) return;\n+    hb_hashmap_t<hb_tag_t, hb::unique_ptr<hb_set_t>> unique_features;\n+    \/\/find out duplicate features after subset\n+    for (unsigned i : feature_indices->iter ())\n+    {\n+      hb_tag_t t = get_feature_tag (i);\n+      if (t == HB_MAP_VALUE_INVALID) continue;\n+      if (!unique_features.has (t))\n+      {\n+        if (unlikely (!unique_features.set (t, hb::unique_ptr<hb_set_t> {hb_set_create ()})))\n+          return;\n+        if (unique_features.has (t))\n+          unique_features.get (t)->add (i);\n+        duplicate_feature_map->set (i, i);\n+        continue;\n+      }\n+\n+      bool found = false;\n+\n+      hb_set_t* same_tag_features = unique_features.get (t);\n+      for (unsigned other_f_index : same_tag_features->iter ())\n+      {\n+        const Feature& f = get_feature (i);\n+        const Feature& other_f = get_feature (other_f_index);\n+\n+        auto f_iter =\n+        + hb_iter (f.lookupIndex)\n+        | hb_filter (lookup_indices)\n+        ;\n+\n+        auto other_f_iter =\n+        + hb_iter (other_f.lookupIndex)\n+        | hb_filter (lookup_indices)\n+        ;\n+\n+        bool is_equal = true;\n+        for (; f_iter && other_f_iter; f_iter++, other_f_iter++)\n+        {\n+          unsigned a = *f_iter;\n+          unsigned b = *other_f_iter;\n+          if (a != b) { is_equal = false; break; }\n+        }\n+\n+        if (is_equal == false || f_iter || other_f_iter) continue;\n+\n+        found = true;\n+        duplicate_feature_map->set (i, other_f_index);\n+        break;\n+      }\n+\n+      if (found == false)\n+      {\n+        same_tag_features->add (i);\n+        duplicate_feature_map->set (i, i);\n+      }\n+    }\n+  }\n+\n@@ -3425,2 +4086,3 @@\n-    if (unlikely (alternate_feature_indices.in_error())) {\n-      feature_indices->successful = false;\n+    if (unlikely (alternate_feature_indices.in_error()))\n+    {\n+      feature_indices->err ();\n@@ -3434,0 +4096,8 @@\n+      hb_tag_t tag =  get_feature_tag (i);\n+      if (tag == HB_TAG ('p', 'r', 'e', 'f'))\n+        \/\/ Note: Never ever drop feature 'pref', even if it's empty.\n+        \/\/ HarfBuzz chooses shaper for Khmer based on presence of this\n+        \/\/ feature.     See thread at:\n+        \/\/ http:\/\/lists.freedesktop.org\/archives\/harfbuzz\/2012-November\/002660.html\n+        continue;\n+\n@@ -3435,2 +4105,5 @@\n-      if (f.featureParams.is_null ()\n-          && !f.intersects_lookup_indexes (lookup_indices)\n+      if (!f.featureParams.is_null () &&\n+          tag == HB_TAG ('s', 'i', 'z', 'e'))\n+        continue;\n+\n+      if (!f.intersects_lookup_indexes (lookup_indices)\n@@ -3455,1 +4128,1 @@\n-    typedef OffsetListOf<TLookup> TLookupList;\n+    typedef List16OfOffset16To<TLookup> TLookupList;\n@@ -3460,1 +4133,1 @@\n-                    reinterpret_cast<const OffsetTo<TLookupList> &> (lookupList).sanitize (c, this))))\n+                    reinterpret_cast<const Offset16To<TLookupList> &> (lookupList).sanitize (c, this))))\n@@ -3474,1 +4147,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -3485,1 +4158,1 @@\n-      this->accels = (hb_ot_layout_lookup_accelerator_t *) calloc (this->lookup_count, sizeof (hb_ot_layout_lookup_accelerator_t));\n+      this->accels = (hb_ot_layout_lookup_accelerator_t *) hb_calloc (this->lookup_count, sizeof (hb_ot_layout_lookup_accelerator_t));\n@@ -3496,2 +4169,1 @@\n-\n-    void fini ()\n+    ~accelerator_t ()\n@@ -3501,1 +4173,1 @@\n-      free (this->accels);\n+      hb_free (this->accels);\n@@ -3513,1 +4185,1 @@\n-  OffsetTo<ScriptList>\n+  Offset16To<ScriptList>\n@@ -3515,1 +4187,1 @@\n-  OffsetTo<FeatureList>\n+  Offset16To<FeatureList>\n@@ -3517,1 +4189,1 @@\n-  OffsetTo<LookupList>\n+  Offset16To<LookupList>\n@@ -3519,1 +4191,1 @@\n-  LOffsetTo<FeatureVariations>\n+  Offset32To<FeatureVariations>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gsubgpos.hh","additions":1056,"deletions":384,"binary":false,"changes":1440,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-typedef OffsetListOf<PosLookup> JstfMax;\n+typedef List16OfOffset16To<PosLookup> JstfMax;\n@@ -74,1 +74,1 @@\n-  OffsetTo<JstfModList>\n+  Offset16To<JstfModList>\n@@ -78,1 +78,1 @@\n-  OffsetTo<JstfModList>\n+  Offset16To<JstfModList>\n@@ -82,1 +82,1 @@\n-  OffsetTo<JstfModList>\n+  Offset16To<JstfModList>\n@@ -86,1 +86,1 @@\n-  OffsetTo<JstfModList>\n+  Offset16To<JstfModList>\n@@ -90,1 +90,1 @@\n-  OffsetTo<JstfMax>\n+  Offset16To<JstfMax>\n@@ -94,1 +94,1 @@\n-  OffsetTo<JstfModList>\n+  Offset16To<JstfModList>\n@@ -98,1 +98,1 @@\n-  OffsetTo<JstfModList>\n+  Offset16To<JstfModList>\n@@ -102,1 +102,1 @@\n-  OffsetTo<JstfModList>\n+  Offset16To<JstfModList>\n@@ -106,1 +106,1 @@\n-  OffsetTo<JstfModList>\n+  Offset16To<JstfModList>\n@@ -110,1 +110,1 @@\n-  OffsetTo<JstfMax>\n+  Offset16To<JstfMax>\n@@ -124,1 +124,1 @@\n-struct JstfLangSys : OffsetListOf<JstfPriority>\n+struct JstfLangSys : List16OfOffset16To<JstfPriority>\n@@ -130,1 +130,1 @@\n-    return_trace (OffsetListOf<JstfPriority>::sanitize (c));\n+    return_trace (List16OfOffset16To<JstfPriority>::sanitize (c));\n@@ -139,1 +139,1 @@\n-typedef SortedArrayOf<HBGlyphID> ExtenderGlyphs;\n+typedef SortedArray16Of<HBGlyphID16> ExtenderGlyphs;\n@@ -177,1 +177,1 @@\n-  OffsetTo<ExtenderGlyphs>\n+  Offset16To<ExtenderGlyphs>\n@@ -180,1 +180,1 @@\n-  OffsetTo<JstfLangSys>\n+  Offset16To<JstfLangSys>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-jstf-table.hh","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-#include \"hb-ot-layout-base-table.hh\" \/\/ Just so we compile it; unused otherwise.\n+#include \"hb-ot-layout-base-table.hh\"\n@@ -57,0 +57,3 @@\n+using OT::Layout::GSUB::GSUB;\n+using OT::Layout::GPOS;\n+\n@@ -134,0 +137,1 @@\n+  if (!buffer->message (font, \"start table kern\")) return;\n@@ -135,0 +139,1 @@\n+  (void) buffer->message (font, \"end table kern\");\n@@ -147,1 +152,1 @@\n-#ifdef HB_NO_OT_LAYOUT_BLACKLIST\n+#ifdef HB_NO_OT_LAYOUT_BLOCKLIST\n@@ -259,1 +264,0 @@\n-    buffer->info[i].syllable() = 0;\n@@ -334,0 +338,2 @@\n+ * Return value: Total number of attachment points for @glyph.\n+ *\n@@ -360,0 +366,9 @@\n+ * Note that a ligature that is formed from n characters will have n-1\n+ * caret positions. The first character is not represented in the array,\n+ * since its caret position is the glyph position.\n+ *\n+ * The positions returned by this function are 'unshaped', and will have to\n+ * be fixed up for kerning that may be applied to the ligature glyph.\n+ *\n+ * Return value: Total number of ligature caret positions for @glyph.\n+ *\n@@ -379,1 +394,1 @@\n-OT::GSUB::is_blocklisted (hb_blob_t *blob HB_UNUSED,\n+GSUB::is_blocklisted (hb_blob_t *blob HB_UNUSED,\n@@ -382,1 +397,1 @@\n-#ifdef HB_NO_OT_LAYOUT_BLACKLIST\n+#ifdef HB_NO_OT_LAYOUT_BLOCKLIST\n@@ -389,1 +404,1 @@\n-OT::GPOS::is_blocklisted (hb_blob_t *blob HB_UNUSED,\n+GPOS::is_blocklisted (hb_blob_t *blob HB_UNUSED,\n@@ -392,1 +407,1 @@\n-#ifdef HB_NO_OT_LAYOUT_BLACKLIST\n+#ifdef HB_NO_OT_LAYOUT_BLOCKLIST\n@@ -422,0 +437,2 @@\n+ * Return value: Total number of script tags.\n+ *\n@@ -588,0 +605,2 @@\n+ * Return value: Total number of feature tags.\n+ *\n@@ -606,1 +625,1 @@\n- * @feature_tag: The #hb_tag_t og the requested feature tag\n+ * @feature_tag: The #hb_tag_t of the requested feature tag\n@@ -650,0 +669,2 @@\n+ * Return value: Total number of language tags.\n+ *\n@@ -679,2 +700,2 @@\n- * Since: ??\n- * Deprecated: ??\n+ * Since: 0.6.0\n+ * Deprecated: 2.0.0\n@@ -708,2 +729,3 @@\n- * Fetches the index of a given language tag in the specified face's GSUB table\n- * or GPOS table, underneath the specified script index.\n+ * Fetches the index of the first language tag fom @language_tags that is present\n+ * in the specified face's GSUB or GPOS table, underneath the specified script\n+ * index.\n@@ -711,1 +733,4 @@\n- * Return value: %true if the language tag is found, %false otherwise\n+ * If none of the given language tags is found, %false is returned and\n+ * @language_index is set to the default language index.\n+ *\n+ * Return value: %true if one of the given language tags is found, %false otherwise\n@@ -737,1 +762,2 @@\n-  if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;\n+  if (language_index)\n+    *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;\n@@ -821,0 +847,2 @@\n+ *\n+ * Return value: Total number of features.\n@@ -853,0 +881,1 @@\n+ * Return value: Total number of feature tags.\n@@ -935,0 +964,2 @@\n+ * Return value: Total number of lookups.\n+ *\n@@ -963,0 +994,2 @@\n+ * Return value: Total number of lookups.\n+ *\n@@ -977,1 +1010,3 @@\n-                                 hb_set_t  *feature_indexes_)\n+                                 hb_set_t  *feature_indices_,\n+                                 const hb_tag_t *features)\n+\n@@ -979,2 +1014,27 @@\n-      feature_indexes (feature_indexes_),\n-      script_count (0),langsys_count (0), feature_index_count (0) {}\n+      feature_indices (feature_indices_),\n+      has_feature_filter (false),\n+      script_count (0),langsys_count (0), feature_index_count (0)\n+  {\n+    compute_feature_filter (features);\n+  }\n+\n+  void compute_feature_filter (const hb_tag_t *features)\n+  {\n+    if (features == nullptr)\n+    {\n+      has_feature_filter = false;\n+      return;\n+    }\n+\n+    has_feature_filter = true;\n+    hb_set_t features_set;\n+    for (; *features; features++)\n+      features_set.add (*features);\n+\n+    for (unsigned i = 0; i < g.get_feature_count (); i++)\n+    {\n+      hb_tag_t tag = g.get_feature_tag (i);\n+      if (features_set.has (tag))\n+        feature_indices_filter.add(i);\n+    }\n+  }\n@@ -1029,1 +1089,3 @@\n-  hb_set_t           *feature_indexes;\n+  hb_set_t *feature_indices;\n+  hb_set_t  feature_indices_filter;\n+  bool has_feature_filter;\n@@ -1041,2 +1103,1 @@\n-                          const OT::LangSys  &l,\n-                          const hb_tag_t     *features)\n+                          const OT::LangSys  &l)\n@@ -1046,1 +1107,1 @@\n-  if (!features)\n+  if (!c->has_feature_filter)\n@@ -1050,1 +1111,1 @@\n-      c->feature_indexes->add (l.get_required_feature_index ());\n+      c->feature_indices->add (l.get_required_feature_index ());\n@@ -1052,0 +1113,1 @@\n+    \/\/ TODO(garretrieger): filter out indices >= feature count?\n@@ -1053,1 +1115,1 @@\n-      l.add_feature_indexes_to (c->feature_indexes);\n+      l.add_feature_indexes_to (c->feature_indices);\n@@ -1057,2 +1119,3 @@\n-    \/* Ugh. Any faster way? *\/\n-    for (; *features; features++)\n+    if (c->feature_indices_filter.is_empty()) return;\n+    unsigned int num_features = l.get_feature_count ();\n+    for (unsigned int i = 0; i < num_features; i++)\n@@ -1060,5 +1123,2 @@\n-      hb_tag_t feature_tag = *features;\n-      unsigned int num_features = l.get_feature_count ();\n-      for (unsigned int i = 0; i < num_features; i++)\n-      {\n-        unsigned int feature_index = l.get_feature_index (i);\n+      unsigned int feature_index = l.get_feature_index (i);\n+      if (!c->feature_indices_filter.has (feature_index)) continue;\n@@ -1066,6 +1126,2 @@\n-        if (feature_tag == c->g.get_feature_tag (feature_index))\n-        {\n-          c->feature_indexes->add (feature_index);\n-          break;\n-        }\n-      }\n+      c->feature_indices->add (feature_index);\n+      c->feature_indices_filter.del (feature_index);\n@@ -1079,2 +1135,1 @@\n-                         const hb_tag_t *languages,\n-                         const hb_tag_t *features)\n+                         const hb_tag_t *languages)\n@@ -1089,2 +1144,2 @@\n-                                s.get_default_lang_sys (),\n-                                features);\n+                                s.get_default_lang_sys ());\n+\n@@ -1095,2 +1150,1 @@\n-                                s.get_lang_sys (language_index),\n-                                features);\n+                                s.get_lang_sys (language_index));\n@@ -1105,2 +1159,2 @@\n-                                  s.get_lang_sys (language_index),\n-                                  features);\n+                                  s.get_lang_sys (language_index));\n+\n@@ -1137,1 +1191,1 @@\n-  hb_collect_features_context_t c (face, table_tag, feature_indexes);\n+  hb_collect_features_context_t c (face, table_tag, feature_indexes, features);\n@@ -1145,2 +1199,1 @@\n-                               languages,\n-                               features);\n+                               languages);\n@@ -1156,2 +1209,1 @@\n-                                 languages,\n-                                 features);\n+                                 languages);\n@@ -1265,0 +1317,2 @@\n+ * Return value: %true if feature variations were found, %false otherwise.\n+ *\n@@ -1294,0 +1348,2 @@\n+ * Return value: Total number of lookups.\n+ *\n@@ -1340,1 +1396,2 @@\n- * @zero_context: #hb_bool_t indicating whether substitutions should be context-free\n+ * @zero_context: #hb_bool_t indicating whether pre-\/post-context are disallowed\n+ * in substitutions\n@@ -1446,2 +1503,3 @@\n-  hb_map_t done_lookups;\n-  OT::hb_closure_context_t c (face, glyphs, &done_lookups);\n+  hb_map_t done_lookups_glyph_count;\n+  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> done_lookups_glyph_set;\n+  OT::hb_closure_context_t c (face, glyphs, &done_lookups_glyph_count, &done_lookups_glyph_set);\n@@ -1470,3 +1528,4 @@\n-  hb_map_t done_lookups;\n-  OT::hb_closure_context_t c (face, glyphs, &done_lookups);\n-  const OT::GSUB& gsub = *face->table.GSUB->table;\n+  hb_map_t done_lookups_glyph_count;\n+  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> done_lookups_glyph_set;\n+  OT::hb_closure_context_t c (face, glyphs, &done_lookups_glyph_count, &done_lookups_glyph_set);\n+  const GSUB& gsub = *face->table.GSUB->table;\n@@ -1478,0 +1537,1 @@\n+    c.reset_lookup_visit_count ();\n@@ -1494,1 +1554,1 @@\n- * OT::GPOS\n+ * GPOS\n@@ -1525,1 +1585,1 @@\n-  OT::GPOS::position_start (font, buffer);\n+  GPOS::position_start (font, buffer);\n@@ -1540,1 +1600,1 @@\n-  OT::GPOS::position_finish_advances (font, buffer);\n+  GPOS::position_finish_advances (font, buffer);\n@@ -1554,1 +1614,1 @@\n-  OT::GPOS::position_finish_offsets (font, buffer);\n+  GPOS::position_finish_offsets (font, buffer);\n@@ -1589,1 +1649,1 @@\n-  const OT::GPOS &gpos = *face->table.GPOS->table;\n+  const GPOS &gpos = *face->table.GPOS->table;\n@@ -1740,1 +1800,1 @@\n-  static constexpr bool inplace = false;\n+  static constexpr bool always_inplace = false;\n@@ -1747,1 +1807,1 @@\n-  const OT::GSUB &table;\n+  const GSUB &table;\n@@ -1754,1 +1814,1 @@\n-  static constexpr bool inplace = true;\n+  static constexpr bool always_inplace = true;\n@@ -1761,1 +1821,1 @@\n-  const OT::GPOS &table;\n+  const GPOS &table;\n@@ -1770,0 +1830,2 @@\n+  bool use_cache = accel.cache_enter (c);\n+\n@@ -1779,1 +1841,1 @@\n-       applied = accel.apply (c);\n+       applied = accel.apply (c, use_cache);\n@@ -1787,0 +1849,4 @@\n+\n+  if (use_cache)\n+    accel.cache_leave (c);\n+\n@@ -1801,1 +1867,1 @@\n-     ret |= accel.apply (c);\n+     ret |= accel.apply (c, false);\n@@ -1827,1 +1893,1 @@\n-    if (Proxy::table_index == 0u)\n+    if (!Proxy::always_inplace)\n@@ -1829,0 +1895,1 @@\n+\n@@ -1830,0 +1897,1 @@\n+    apply_forward (c, accel);\n@@ -1831,9 +1899,2 @@\n-    bool ret;\n-    ret = apply_forward (c, accel);\n-    if (ret)\n-    {\n-      if (!Proxy::inplace)\n-        buffer->swap_buffers ();\n-      else\n-        assert (!buffer->has_separate_output ());\n-    }\n+    if (!Proxy::always_inplace)\n+      buffer->sync ();\n@@ -1844,2 +1905,1 @@\n-    if (Proxy::table_index == 0u)\n-      buffer->remove_output ();\n+    assert (!buffer->have_output);\n@@ -1847,1 +1907,0 @@\n-\n@@ -1861,1 +1920,1 @@\n-  c.set_recurse_func (Proxy::Lookup::apply_recurse_func);\n+  c.set_recurse_func (Proxy::Lookup::template dispatch_recurse_func<OT::hb_ot_apply_context_t>);\n@@ -1863,1 +1922,2 @@\n-  for (unsigned int stage_index = 0; stage_index < stages[table_index].length; stage_index++) {\n+  for (unsigned int stage_index = 0; stage_index < stages[table_index].length; stage_index++)\n+  {\n@@ -1873,5 +1933,3 @@\n-      if (lookups[table_index][i].random)\n-      {\n-        c.set_random (true);\n-        buffer->unsafe_to_break_all ();\n-      }\n+      c.set_random (lookups[table_index][i].random);\n+      c.set_per_syllable (lookups[table_index][i].per_syllable);\n+\n@@ -1885,2 +1943,0 @@\n-    {\n-      buffer->clear_output ();\n@@ -1888,1 +1944,0 @@\n-    }\n@@ -1917,0 +1972,71 @@\n+\/**\n+ * hb_ot_layout_get_horizontal_baseline_tag_for_script:\n+ * @script: a script tag.\n+ *\n+ * Fetches the dominant horizontal baseline tag used by @script.\n+ *\n+ * Return value: dominant baseline tag for the @script.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+hb_ot_layout_baseline_tag_t\n+hb_ot_layout_get_horizontal_baseline_tag_for_script (hb_script_t script)\n+{\n+  \/* Keep in sync with hb_ot_layout_get_baseline_with_fallback *\/\n+  switch ((int) script)\n+  {\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_BENGALI:\n+    case HB_SCRIPT_DEVANAGARI:\n+    case HB_SCRIPT_GUJARATI:\n+    case HB_SCRIPT_GURMUKHI:\n+    \/* Unicode-2.0 additions *\/\n+    case HB_SCRIPT_TIBETAN:\n+    \/* Unicode-4.0 additions *\/\n+    case HB_SCRIPT_LIMBU:\n+    \/* Unicode-4.1 additions *\/\n+    case HB_SCRIPT_SYLOTI_NAGRI:\n+    \/* Unicode-5.0 additions *\/\n+    case HB_SCRIPT_PHAGS_PA:\n+    \/* Unicode-5.2 additions *\/\n+    case HB_SCRIPT_MEETEI_MAYEK:\n+    \/* Unicode-6.1 additions *\/\n+    case HB_SCRIPT_SHARADA:\n+    case HB_SCRIPT_TAKRI:\n+    \/* Unicode-7.0 additions *\/\n+    case HB_SCRIPT_MODI:\n+    case HB_SCRIPT_SIDDHAM:\n+    case HB_SCRIPT_TIRHUTA:\n+    \/* Unicode-9.0 additions *\/\n+    case HB_SCRIPT_MARCHEN:\n+    case HB_SCRIPT_NEWA:\n+    \/* Unicode-10.0 additions *\/\n+    case HB_SCRIPT_SOYOMBO:\n+    case HB_SCRIPT_ZANABAZAR_SQUARE:\n+    \/* Unicode-11.0 additions *\/\n+    case HB_SCRIPT_DOGRA:\n+    case HB_SCRIPT_GUNJALA_GONDI:\n+    \/* Unicode-12.0 additions *\/\n+    case HB_SCRIPT_NANDINAGARI:\n+      return HB_OT_LAYOUT_BASELINE_TAG_HANGING;\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_HANGUL:\n+    case HB_SCRIPT_HAN:\n+    case HB_SCRIPT_HIRAGANA:\n+    case HB_SCRIPT_KATAKANA:\n+    \/* Unicode-3.0 additions *\/\n+    case HB_SCRIPT_BOPOMOFO:\n+    \/* Unicode-9.0 additions *\/\n+    case HB_SCRIPT_TANGUT:\n+    \/* Unicode-10.0 additions *\/\n+    case HB_SCRIPT_NUSHU:\n+    \/* Unicode-13.0 additions *\/\n+    case HB_SCRIPT_KHITAN_SMALL_SCRIPT:\n+      return HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_BOTTOM_OR_LEFT;\n+\n+    default:\n+      return HB_OT_LAYOUT_BASELINE_TAG_ROMAN;\n+  }\n+}\n+\n@@ -1924,1 +2050,1 @@\n- * @coord: (out): baseline value if found.\n+ * @coord: (out) (nullable): baseline value if found.\n@@ -1928,1 +2054,1 @@\n- * Return value: if found baseline value in the font.\n+ * Return value: %true if found baseline value in the font.\n@@ -1940,1 +2066,32 @@\n-  bool result = font->face->table.BASE->get_baseline (font, baseline_tag, direction, script_tag, language_tag, coord);\n+  return font->face->table.BASE->get_baseline (font, baseline_tag, direction, script_tag, language_tag, coord);\n+}\n+\n+\/**\n+ * hb_ot_layout_get_baseline_with_fallback:\n+ * @font: a font\n+ * @baseline_tag: a baseline tag\n+ * @direction: text direction.\n+ * @script_tag:  script tag.\n+ * @language_tag: language tag, currently unused.\n+ * @coord: (out): baseline value if found.\n+ *\n+ * Fetches a baseline value from the face, and synthesizes\n+ * it if the font does not have it.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+void\n+hb_ot_layout_get_baseline_with_fallback (hb_font_t                   *font,\n+                                         hb_ot_layout_baseline_tag_t  baseline_tag,\n+                                         hb_direction_t               direction,\n+                                         hb_tag_t                     script_tag,\n+                                         hb_tag_t                     language_tag,\n+                                         hb_position_t               *coord \/* OUT *\/)\n+{\n+  if (hb_ot_layout_get_baseline (font,\n+                                 baseline_tag,\n+                                 direction,\n+                                 script_tag,\n+                                 language_tag,\n+                                 coord))\n+    return;\n@@ -1942,2 +2099,30 @@\n-  if (result && coord)\n-    *coord = HB_DIRECTION_IS_HORIZONTAL (direction) ? font->em_scale_y (*coord) : font->em_scale_x (*coord);\n+  \/* Synthesize missing baselines.\n+   * See https:\/\/www.w3.org\/TR\/css-inline-3\/#baseline-synthesis-fonts\n+   *\/\n+  switch (baseline_tag)\n+  {\n+  case HB_OT_LAYOUT_BASELINE_TAG_ROMAN:\n+    *coord = 0; \/\/ FIXME origin ?\n+    break;\n+\n+  case HB_OT_LAYOUT_BASELINE_TAG_MATH:\n+    {\n+      hb_codepoint_t glyph;\n+      hb_glyph_extents_t extents;\n+      if (HB_DIRECTION_IS_HORIZONTAL (direction) &&\n+          (hb_font_get_nominal_glyph (font, 0x2212u, &glyph) ||\n+           hb_font_get_nominal_glyph (font, '-', &glyph)) &&\n+          hb_font_get_glyph_extents (font, glyph, &extents))\n+      {\n+        *coord = extents.y_bearing + extents.height \/ 2;\n+      }\n+      else\n+      {\n+        hb_position_t x_height = font->y_scale \/ 2;\n+#ifndef HB_NO_METRICS\n+        hb_ot_metrics_get_position_with_fallback (font, HB_OT_METRICS_TAG_X_HEIGHT, &x_height);\n+#endif\n+        *coord = x_height \/ 2;\n+      }\n+    }\n+    break;\n@@ -1945,1 +2130,159 @@\n-  return result;\n+  case HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_TOP_OR_RIGHT:\n+  case HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_BOTTOM_OR_LEFT:\n+    {\n+      hb_position_t embox_top, embox_bottom;\n+\n+      hb_ot_layout_get_baseline_with_fallback (font,\n+                                               HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_TOP_OR_RIGHT,\n+                                               direction,\n+                                               script_tag,\n+                                               language_tag,\n+                                               &embox_top);\n+      hb_ot_layout_get_baseline_with_fallback (font,\n+                                               HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_BOTTOM_OR_LEFT,\n+                                               direction,\n+                                               script_tag,\n+                                               language_tag,\n+                                               &embox_bottom);\n+\n+      if (baseline_tag == HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_TOP_OR_RIGHT)\n+        *coord = embox_top + (embox_bottom - embox_top) \/ 10;\n+      else\n+        *coord = embox_bottom + (embox_top - embox_bottom) \/ 10;\n+    }\n+    break;\n+\n+  case HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_TOP_OR_RIGHT:\n+    if (hb_ot_layout_get_baseline (font,\n+                                   HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_BOTTOM_OR_LEFT,\n+                                   direction,\n+                                   script_tag,\n+                                   language_tag,\n+                                   coord))\n+      *coord += HB_DIRECTION_IS_HORIZONTAL (direction) ? font->y_scale : font->x_scale;\n+    else\n+    {\n+      hb_font_extents_t font_extents;\n+      hb_font_get_extents_for_direction (font, direction, &font_extents);\n+      *coord = font_extents.ascender;\n+    }\n+    break;\n+\n+  case HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_BOTTOM_OR_LEFT:\n+    if (hb_ot_layout_get_baseline (font,\n+                                   HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_TOP_OR_RIGHT,\n+                                   direction,\n+                                   script_tag,\n+                                   language_tag,\n+                                   coord))\n+      *coord -= HB_DIRECTION_IS_HORIZONTAL (direction) ? font->y_scale : font->x_scale;\n+    else\n+    {\n+      hb_font_extents_t font_extents;\n+      hb_font_get_extents_for_direction (font, direction, &font_extents);\n+      *coord = font_extents.descender;\n+    }\n+    break;\n+\n+  case HB_OT_LAYOUT_BASELINE_TAG_HANGING:\n+    if (HB_DIRECTION_IS_HORIZONTAL (direction))\n+    {\n+      hb_codepoint_t ch;\n+      hb_codepoint_t glyph;\n+      hb_glyph_extents_t extents;\n+\n+      \/* Keep in sync with hb_ot_layout_get_horizontal_baseline_for_script *\/\n+      switch ((int) script_tag)\n+      {\n+      \/* Unicode-1.1 additions *\/\n+      case HB_SCRIPT_BENGALI:          ch = 0x0995u; break;\n+      case HB_SCRIPT_DEVANAGARI:       ch = 0x0915u; break;\n+      case HB_SCRIPT_GUJARATI:         ch = 0x0a95u; break;\n+      case HB_SCRIPT_GURMUKHI:         ch = 0x0a15u; break;\n+      \/* Unicode-2.0 additions *\/\n+      case HB_SCRIPT_TIBETAN:          ch = 0x0f40u; break;\n+      \/* Unicode-4.0 additions *\/\n+      case HB_SCRIPT_LIMBU:            ch = 0x1901u; break;\n+      \/* Unicode-4.1 additions *\/\n+      case HB_SCRIPT_SYLOTI_NAGRI:     ch = 0xa807u; break;\n+      \/* Unicode-5.0 additions *\/\n+      case HB_SCRIPT_PHAGS_PA:         ch = 0xa840u; break;\n+      \/* Unicode-5.2 additions *\/\n+      case HB_SCRIPT_MEETEI_MAYEK:     ch = 0xabc0u; break;\n+      \/* Unicode-6.1 additions *\/\n+      case HB_SCRIPT_SHARADA:          ch = 0x11191u; break;\n+      case HB_SCRIPT_TAKRI:            ch = 0x1168cu; break;\n+      \/* Unicode-7.0 additions *\/\n+      case HB_SCRIPT_MODI:             ch = 0x1160eu;break;\n+      case HB_SCRIPT_SIDDHAM:          ch = 0x11590u; break;\n+      case HB_SCRIPT_TIRHUTA:          ch = 0x1148fu; break;\n+      \/* Unicode-9.0 additions *\/\n+      case HB_SCRIPT_MARCHEN:          ch = 0x11c72u; break;\n+      case HB_SCRIPT_NEWA:             ch = 0x1140eu; break;\n+      \/* Unicode-10.0 additions *\/\n+      case HB_SCRIPT_SOYOMBO:          ch = 0x11a5cu; break;\n+      case HB_SCRIPT_ZANABAZAR_SQUARE: ch = 0x11a0bu; break;\n+      \/* Unicode-11.0 additions *\/\n+      case HB_SCRIPT_DOGRA:            ch = 0x1180au; break;\n+      case HB_SCRIPT_GUNJALA_GONDI:    ch = 0x11d6cu; break;\n+      \/* Unicode-12.0 additions *\/\n+      case HB_SCRIPT_NANDINAGARI:      ch = 0x119b0u; break;\n+      default:                         ch = 0;        break;\n+      }\n+\n+      if (ch &&\n+          hb_font_get_nominal_glyph (font, ch, &glyph) &&\n+          hb_font_get_glyph_extents (font, glyph, &extents))\n+        *coord = extents.y_bearing;\n+      else\n+        *coord = font->y_scale * 6 \/ 10; \/\/ FIXME makes assumptions about origin\n+    }\n+    else\n+      *coord = font->x_scale * 6 \/ 10; \/\/ FIXME makes assumptions about origin\n+    break;\n+\n+  case HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_CENTRAL:\n+    {\n+      hb_position_t top, bottom;\n+      hb_ot_layout_get_baseline_with_fallback (font,\n+                                               HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_TOP_OR_RIGHT,\n+                                               direction,\n+                                               script_tag,\n+                                               language_tag,\n+                                               &top);\n+      hb_ot_layout_get_baseline_with_fallback (font,\n+                                               HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_BOTTOM_OR_LEFT,\n+                                               direction,\n+                                               script_tag,\n+                                               language_tag,\n+                                               &bottom);\n+      *coord = (top + bottom) \/ 2;\n+\n+    }\n+    break;\n+\n+  case HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_CENTRAL:\n+    {\n+      hb_position_t top, bottom;\n+      hb_ot_layout_get_baseline_with_fallback (font,\n+                                               HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_TOP_OR_RIGHT,\n+                                               direction,\n+                                               script_tag,\n+                                               language_tag,\n+                                               &top);\n+      hb_ot_layout_get_baseline_with_fallback (font,\n+                                               HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_BOTTOM_OR_LEFT,\n+                                               direction,\n+                                               script_tag,\n+                                               language_tag,\n+                                               &bottom);\n+      *coord = (top + bottom) \/ 2;\n+\n+    }\n+    break;\n+\n+  case _HB_OT_LAYOUT_BASELINE_TAG_MAX_VALUE:\n+  default:\n+    *coord = 0;\n+    break;\n+  }\n@@ -1947,0 +2290,1 @@\n+\n@@ -1964,1 +2308,1 @@\n-  ( obj.get_glyph_alternates (hb_forward<Ts> (ds)...) )\n+  ( obj.get_glyph_alternates (std::forward<Ts> (ds)...) )\n@@ -1971,1 +2315,1 @@\n-  ( _dispatch (obj, hb_prioritize, hb_forward<Ts> (ds)...) )\n+  ( _dispatch (obj, hb_prioritize, std::forward<Ts> (ds)...) )\n@@ -1987,1 +2331,1 @@\n- * Return value: total number of alternates found in the specific lookup index for the given glyph id.\n+ * Return value: Total number of alternates found in the specific lookup index for the given glyph id.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.cc","additions":442,"deletions":98,"binary":false,"changes":540,"status":"modified"},{"patch":"@@ -335,25 +335,0 @@\n-#ifdef HB_NOT_IMPLEMENTED\n-typedef struct\n-{\n-  const hb_codepoint_t *before,\n-  unsigned int          before_length,\n-  const hb_codepoint_t *input,\n-  unsigned int          input_length,\n-  const hb_codepoint_t *after,\n-  unsigned int          after_length,\n-} hb_ot_layout_glyph_sequence_t;\n-\n-typedef hb_bool_t\n-(*hb_ot_layout_glyph_sequence_func_t) (hb_font_t    *font,\n-                                       hb_tag_t      table_tag,\n-                                       unsigned int  lookup_index,\n-                                       const hb_ot_layout_glyph_sequence_t *sequence,\n-                                       void         *user_data);\n-\n-HB_EXTERN void\n-Xhb_ot_layout_lookup_enumerate_sequences (hb_face_t    *face,\n-                                         hb_tag_t      table_tag,\n-                                         unsigned int  lookup_index,\n-                                         hb_ot_layout_glyph_sequence_func_t callback,\n-                                         void         *user_data);\n-#endif\n@@ -414,13 +389,0 @@\n-#ifdef HB_NOT_IMPLEMENTED\n-\/* Note: You better have GDEF when using this API, or marks won't do much. *\/\n-HB_EXTERN hb_bool_t\n-Xhb_ot_layout_lookup_substitute (hb_font_t            *font,\n-                                unsigned int          lookup_index,\n-                                const hb_ot_layout_glyph_sequence_t *sequence,\n-                                unsigned int          out_size,\n-                                hb_codepoint_t       *glyphs_out,   \/* OUT *\/\n-                                unsigned int         *clusters_out, \/* OUT *\/\n-                                unsigned int         *out_length    \/* OUT *\/);\n-#endif\n-\n-\n@@ -434,9 +396,0 @@\n-#ifdef HB_NOT_IMPLEMENTED\n-\/* Note: You better have GDEF when using this API, or marks won't do much. *\/\n-HB_EXTERN hb_bool_t\n-Xhb_ot_layout_lookup_position (hb_font_t            *font,\n-                              unsigned int          lookup_index,\n-                              const hb_ot_layout_glyph_sequence_t *sequence,\n-                              hb_glyph_position_t  *positions \/* IN \/ OUT *\/);\n-#endif\n-\n@@ -490,0 +443,1 @@\n+ * @HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_CENTRAL: The center of the ideographic character face. Since: 4.0.0\n@@ -493,0 +447,1 @@\n+ * @HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_CENTRAL: The center of the ideographic em-box. Since: 4.0.0\n@@ -506,0 +461,1 @@\n+  HB_OT_LAYOUT_BASELINE_TAG_IDEO_FACE_CENTRAL           = HB_TAG ('I','c','f','c'),\n@@ -508,0 +464,1 @@\n+  HB_OT_LAYOUT_BASELINE_TAG_IDEO_EMBOX_CENTRAL          = HB_TAG ('I','d','c','e'),\n@@ -514,0 +471,3 @@\n+HB_EXTERN hb_ot_layout_baseline_tag_t\n+hb_ot_layout_get_horizontal_baseline_tag_for_script (hb_script_t script);\n+\n@@ -522,0 +482,8 @@\n+HB_EXTERN void\n+hb_ot_layout_get_baseline_with_fallback (hb_font_t                   *font,\n+                                         hb_ot_layout_baseline_tag_t  baseline_tag,\n+                                         hb_direction_t               direction,\n+                                         hb_tag_t                     script_tag,\n+                                         hb_tag_t                     language_tag,\n+                                         hb_position_t               *coord        \/* OUT *\/);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.h","additions":15,"deletions":47,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -111,1 +111,0 @@\n-  struct SubstLookup;\n@@ -113,0 +112,5 @@\n+namespace Layout {\n+namespace GSUB {\n+  struct SubstLookup;\n+}\n+}\n@@ -117,1 +121,1 @@\n-                                const OT::SubstLookup &lookup,\n+                                const OT::Layout::GSUB::SubstLookup &lookup,\n@@ -171,11 +175,0 @@\n-static inline void\n-_hb_clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                     hb_font_t *font HB_UNUSED,\n-                     hb_buffer_t *buffer)\n-{\n-  hb_glyph_info_t *info = buffer->info;\n-  unsigned int count = buffer->len;\n-  for (unsigned int i = 0; i < count; i++)\n-    info[i].syllable() = 0;\n-}\n-\n@@ -190,1 +183,1 @@\n- *   * Whether it's one of the three Mongolian Free Variation Selectors,\n+ *   * Whether it's one of the four Mongolian Free Variation Selectors,\n@@ -205,1 +198,1 @@\n-  UPROPS_MASK_HIDDEN    = 0x0040u, \/* MONGOLIAN FREE VARIATION SELECTOR 1..3, or TAG characters *\/\n+  UPROPS_MASK_HIDDEN    = 0x0040u, \/* MONGOLIAN FREE VARIATION SELECTOR 1..4, or TAG characters *\/\n@@ -239,1 +232,1 @@\n-      else if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x180Bu, 0x180Du))) props |= UPROPS_MASK_HIDDEN;\n+      else if (unlikely (hb_in_ranges<hb_codepoint_t> (u, 0x180Bu, 0x180Du, 0x180Fu, 0x180Fu))) props |= UPROPS_MASK_HIDDEN;\n@@ -317,1 +310,0 @@\n-static inline bool _hb_glyph_info_ligated (const hb_glyph_info_t *info);\n@@ -331,1 +323,1 @@\n-         !_hb_glyph_info_ligated (info);\n+         !_hb_glyph_info_substituted (info);\n@@ -354,7 +346,0 @@\n-\/* Loop over grapheme. Based on foreach_cluster(). *\/\n-#define foreach_grapheme(buffer, start, end) \\\n-  for (unsigned int \\\n-       _count = buffer->len, \\\n-       start = 0, end = _count ? _hb_next_grapheme (buffer, 0) : 0; \\\n-       start < _count; \\\n-       start = end, end = _hb_next_grapheme (buffer, start))\n@@ -362,5 +347,4 @@\n-static inline unsigned int\n-_hb_next_grapheme (hb_buffer_t *buffer, unsigned int start)\n-{\n-  hb_glyph_info_t *info = buffer->info;\n-  unsigned int count = buffer->len;\n+static inline bool\n+_hb_grapheme_group_func (const hb_glyph_info_t& a HB_UNUSED,\n+                         const hb_glyph_info_t& b)\n+{ return _hb_glyph_info_is_continuation (&b); }\n@@ -368,2 +352,2 @@\n-  while (++start < count && _hb_glyph_info_is_continuation (&info[start]))\n-    ;\n+#define foreach_grapheme(buffer, start, end) \\\n+        foreach_group (buffer, start, end, _hb_grapheme_group_func)\n@@ -371,1 +355,5 @@\n-  return start;\n+static inline void\n+_hb_ot_layout_reverse_graphemes (hb_buffer_t *buffer)\n+{\n+  buffer->reverse_groups (_hb_grapheme_group_func,\n+                          buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS);\n@@ -490,1 +478,2 @@\n-_hb_allocate_lig_id (hb_buffer_t *buffer) {\n+_hb_allocate_lig_id (hb_buffer_t *buffer)\n+{\n@@ -603,1 +592,0 @@\n-  HB_BUFFER_ALLOCATE_VAR (buffer, syllable);\n@@ -609,1 +597,0 @@\n-  HB_BUFFER_DEALLOCATE_VAR (buffer, syllable);\n@@ -619,1 +606,0 @@\n-  HB_BUFFER_ASSERT_VAR (buffer, syllable);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.hh","additions":23,"deletions":37,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n@@ -66,1 +65,6 @@\n-  hb_ot_tags_from_script_and_language (props.script, props.language, &script_count, script_tags, &language_count, language_tags);\n+  hb_ot_tags_from_script_and_language (props.script,\n+                                       props.language,\n+                                       &script_count,\n+                                       script_tags,\n+                                       &language_count,\n+                                       language_tags);\n@@ -68,1 +72,2 @@\n-  for (unsigned int table_index = 0; table_index < 2; table_index++) {\n+  for (unsigned int table_index = 0; table_index < 2; table_index++)\n+  {\n@@ -70,2 +75,12 @@\n-    found_script[table_index] = (bool) hb_ot_layout_table_select_script (face, table_tag, script_count, script_tags, &script_index[table_index], &chosen_script[table_index]);\n-    hb_ot_layout_script_select_language (face, table_tag, script_index[table_index], language_count, language_tags, &language_index[table_index]);\n+    found_script[table_index] = (bool) hb_ot_layout_table_select_script (face,\n+                                                                         table_tag,\n+                                                                         script_count,\n+                                                                         script_tags,\n+                                                                         &script_index[table_index],\n+                                                                         &chosen_script[table_index]);\n+    hb_ot_layout_script_select_language (face,\n+                                         table_tag,\n+                                         script_index[table_index],\n+                                         language_count,\n+                                         language_tags,\n+                                         &language_index[table_index]);\n@@ -105,1 +120,2 @@\n-                                  bool          random)\n+                                  bool          random,\n+                                  bool          per_syllable)\n@@ -133,0 +149,1 @@\n+      lookup->per_syllable = per_syllable;\n@@ -153,3 +170,2 @@\n-  static_assert ((!(HB_GLYPH_FLAG_DEFINED & (HB_GLYPH_FLAG_DEFINED + 1))), \"\");\n-  unsigned int global_bit_mask = HB_GLYPH_FLAG_DEFINED + 1;\n-  unsigned int global_bit_shift = hb_popcount (HB_GLYPH_FLAG_DEFINED);\n+  unsigned int global_bit_shift = 8 * sizeof (hb_mask_t) - 1;\n+  unsigned int global_bit_mask = 1u << global_bit_shift;\n@@ -208,1 +224,2 @@\n-  unsigned int next_bit = global_bit_shift + 1;\n+  static_assert ((!(HB_GLYPH_FLAG_DEFINED & (HB_GLYPH_FLAG_DEFINED + 1))), \"\");\n+  unsigned int next_bit = hb_popcount (HB_GLYPH_FLAG_DEFINED) + 1;\n@@ -223,1 +240,1 @@\n-    if (!info->max_value || next_bit + bits_needed > 8 * sizeof (hb_mask_t))\n+    if (!info->max_value || next_bit + bits_needed >= global_bit_shift)\n@@ -265,0 +282,1 @@\n+    map->per_syllable = !!(info->flags & F_PER_SYLLABLE);\n@@ -277,1 +295,0 @@\n-\n@@ -308,1 +325,2 @@\n-                       m.features[i].random);\n+                       m.features[i].random,\n+                       m.features[i].per_syllable);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-map.cc","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+    unsigned int per_syllable : 1;\n@@ -69,0 +70,1 @@\n+    unsigned short per_syllable : 1;\n@@ -186,1 +188,2 @@\n-  F_RANDOM              = 0x0020u  \/* Randomly select a glyph from an AlternateSubstFormat1 subtable. *\/\n+  F_RANDOM              = 0x0020u, \/* Randomly select a glyph from an AlternateSubstFormat1 subtable. *\/\n+  F_PER_SYLLABLE        = 0x0040u  \/* Contain lookup application to within syllable. *\/\n@@ -240,1 +243,2 @@\n-                                bool          random = false);\n+                                bool          random = false,\n+                                bool          per_syllable = false);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-map.hh","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,10 @@\n+  MathValueRecord* copy (hb_serialize_context_t *c, const void *base) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+    out->deviceTable.serialize_copy (c, deviceTable, base, 0, hb_serialize_context_t::Head);\n+\n+    return_trace (out);\n+  }\n+\n@@ -52,1 +62,1 @@\n-  OffsetTo<Device>      deviceTable;    \/* Offset to the device table - from the\n+  Offset16To<Device>    deviceTable;    \/* Offset to the device table - from the\n@@ -62,0 +72,23 @@\n+  MathConstants* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->start_embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+\n+    HBINT16 *p = c->allocate_size<HBINT16> (HBINT16::static_size * 2);\n+    if (unlikely (!p)) return_trace (nullptr);\n+    memcpy (p, percentScaleDown, HBINT16::static_size * 2);\n+\n+    HBUINT16 *m = c->allocate_size<HBUINT16> (HBUINT16::static_size * 2);\n+    if (unlikely (!m)) return_trace (nullptr);\n+    memcpy (m, minHeight, HBUINT16::static_size * 2);\n+\n+    unsigned count = ARRAY_LENGTH (mathValueRecords);\n+    for (unsigned i = 0; i < count; i++)\n+      if (!c->copy (mathValueRecords[i], this))\n+        return_trace (nullptr);\n+\n+    if (!c->embed (radicalDegreeBottomRaisePercent)) return_trace (nullptr);\n+    return_trace (out);\n+  }\n+\n@@ -168,0 +201,22 @@\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+    + hb_zip (this+coverage, italicsCorrection)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter (serialize_math_record_array (c->serializer, out->italicsCorrection, this), hb_second)\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+\n+    out->coverage.serialize_serialize (c->serializer, new_coverage.iter ());\n+    return_trace (true);\n+  }\n+\n@@ -184,1 +239,1 @@\n-  OffsetTo<Coverage>       coverage;            \/* Offset to Coverage table -\n+  Offset16To<Coverage>       coverage;          \/* Offset to Coverage table -\n@@ -188,1 +243,1 @@\n-  ArrayOf<MathValueRecord> italicsCorrection;   \/* Array of MathValueRecords\n+  Array16Of<MathValueRecord> italicsCorrection; \/* Array of MathValueRecords\n@@ -199,0 +254,22 @@\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+    + hb_zip (this+topAccentCoverage, topAccentAttachment)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter (serialize_math_record_array (c->serializer, out->topAccentAttachment, this), hb_second)\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+\n+    out->topAccentCoverage.serialize_serialize (c->serializer, new_coverage.iter ());\n+    return_trace (true);\n+  }\n+\n@@ -217,1 +294,1 @@\n-  OffsetTo<Coverage>       topAccentCoverage;   \/* Offset to Coverage table -\n+  Offset16To<Coverage>       topAccentCoverage;   \/* Offset to Coverage table -\n@@ -221,1 +298,1 @@\n-  ArrayOf<MathValueRecord> topAccentAttachment; \/* Array of MathValueRecords\n+  Array16Of<MathValueRecord> topAccentAttachment; \/* Array of MathValueRecords\n@@ -232,0 +309,16 @@\n+  MathKern* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->start_embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+\n+    if (unlikely (!c->embed (heightCount))) return_trace (nullptr);\n+\n+    unsigned count = 2 * heightCount + 1;\n+    for (unsigned i = 0; i < count; i++)\n+      if (!c->copy (mathValueRecordsZ.arrayZ[i], this))\n+        return_trace (nullptr);\n+\n+    return_trace (out);\n+  }\n+\n@@ -279,0 +372,31 @@\n+  unsigned int get_entries (unsigned int start_offset,\n+                            unsigned int *entries_count, \/* IN\/OUT *\/\n+                            hb_ot_math_kern_entry_t *kern_entries, \/* OUT *\/\n+                            hb_font_t *font) const\n+  {\n+    const MathValueRecord* correctionHeight = mathValueRecordsZ.arrayZ;\n+    const MathValueRecord* kernValue = mathValueRecordsZ.arrayZ + heightCount;\n+    const unsigned int entriesCount = heightCount + 1;\n+\n+    if (entries_count)\n+    {\n+      unsigned int start = hb_min (start_offset, entriesCount);\n+      unsigned int end = hb_min (start + *entries_count, entriesCount);\n+      *entries_count = end - start;\n+\n+      for (unsigned int i = 0; i < *entries_count; i++) {\n+        unsigned int j = start + i;\n+\n+        hb_position_t max_height;\n+        if (j == heightCount) {\n+          max_height = INT32_MAX;\n+        } else {\n+          max_height = correctionHeight[j].get_y_value (font, this);\n+        }\n+\n+        kern_entries[i] = {max_height, kernValue[j].get_x_value (font, this)};\n+      }\n+    }\n+    return entriesCount;\n+  }\n+\n@@ -298,0 +422,13 @@\n+  MathKernInfoRecord* copy (hb_serialize_context_t *c, const void *base) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+\n+    unsigned count = ARRAY_LENGTH (mathKern);\n+    for (unsigned i = 0; i < count; i++)\n+      out->mathKern[i].serialize_copy (c, mathKern[i], base, 0, hb_serialize_context_t::Head);\n+\n+    return_trace (out);\n+  }\n+\n@@ -320,0 +457,18 @@\n+  unsigned int get_kernings (hb_ot_math_kern_t kern,\n+                             unsigned int start_offset,\n+                             unsigned int *entries_count, \/* IN\/OUT *\/\n+                             hb_ot_math_kern_entry_t *kern_entries, \/* OUT *\/\n+                             hb_font_t *font,\n+                             const void *base) const\n+  {\n+    unsigned int idx = kern;\n+    if (unlikely (idx >= ARRAY_LENGTH (mathKern)) || !mathKern[idx]) {\n+      if (entries_count) *entries_count = 0;\n+      return 0;\n+    }\n+    return (base+mathKern[idx]).get_entries (start_offset,\n+                                             entries_count,\n+                                             kern_entries,\n+                                             font);\n+  }\n+\n@@ -323,1 +478,1 @@\n-  OffsetTo<MathKern> mathKern[4];\n+  Offset16To<MathKern> mathKern[4];\n@@ -331,0 +486,22 @@\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_coverage;\n+    + hb_zip (this+mathKernCoverage, mathKernInfoRecords)\n+    | hb_filter (glyphset, hb_first)\n+    | hb_filter (serialize_math_record_array (c->serializer, out->mathKernInfoRecords, this), hb_second)\n+    | hb_map (hb_first)\n+    | hb_map (glyph_map)\n+    | hb_sink (new_coverage)\n+    ;\n+\n+    out->mathKernCoverage.serialize_serialize (c->serializer, new_coverage.iter ());\n+    return_trace (true);\n+  }\n+\n@@ -348,0 +525,16 @@\n+  unsigned int get_kernings (hb_codepoint_t glyph,\n+                             hb_ot_math_kern_t kern,\n+                             unsigned int start_offset,\n+                             unsigned int *entries_count, \/* IN\/OUT *\/\n+                             hb_ot_math_kern_entry_t *kern_entries, \/* OUT *\/\n+                             hb_font_t *font) const\n+  {\n+    unsigned int index = (this+mathKernCoverage).get_coverage (glyph);\n+    return mathKernInfoRecords[index].get_kernings (kern,\n+                                                    start_offset,\n+                                                    entries_count,\n+                                                    kern_entries,\n+                                                    font,\n+                                                    this);\n+  }\n+\n@@ -349,1 +542,1 @@\n-  OffsetTo<Coverage>\n+  Offset16To<Coverage>\n@@ -354,1 +547,1 @@\n-  ArrayOf<MathKernInfoRecord>\n+  Array16Of<MathKernInfoRecord>\n@@ -368,0 +561,25 @@\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    out->mathItalicsCorrectionInfo.serialize_subset (c, mathItalicsCorrectionInfo, this);\n+    out->mathTopAccentAttachment.serialize_subset (c, mathTopAccentAttachment, this);\n+\n+    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto it =\n+    + hb_iter (this+extendedShapeCoverage)\n+    | hb_filter (glyphset)\n+    | hb_map_retains_sorting (glyph_map)\n+    ;\n+\n+    if (it) out->extendedShapeCoverage.serialize_serialize (c->serializer, it);\n+    else out->extendedShapeCoverage = 0;\n+\n+    out->mathKernInfo.serialize_subset (c, mathKernInfo, this);\n+    return_trace (true);\n+  }\n+\n@@ -395,0 +613,13 @@\n+  hb_position_t get_kernings (hb_codepoint_t glyph,\n+                              hb_ot_math_kern_t kern,\n+                              unsigned int start_offset,\n+                              unsigned int *entries_count, \/* IN\/OUT *\/\n+                              hb_ot_math_kern_entry_t *kern_entries, \/* OUT *\/\n+                              hb_font_t *font) const\n+  { return (this+mathKernInfo).get_kernings (glyph,\n+                                             kern,\n+                                             start_offset,\n+                                             entries_count,\n+                                             kern_entries,\n+                                             font); }\n+\n@@ -398,1 +629,1 @@\n-  OffsetTo<MathItalicsCorrectionInfo> mathItalicsCorrectionInfo;\n+  Offset16To<MathItalicsCorrectionInfo> mathItalicsCorrectionInfo;\n@@ -402,1 +633,1 @@\n-  OffsetTo<MathTopAccentAttachment> mathTopAccentAttachment;\n+  Offset16To<MathTopAccentAttachment> mathTopAccentAttachment;\n@@ -409,1 +640,1 @@\n-  OffsetTo<Coverage> extendedShapeCoverage;\n+  Offset16To<Coverage> extendedShapeCoverage;\n@@ -413,1 +644,1 @@\n-  OffsetTo<MathKernInfo> mathKernInfo;\n+  Offset16To<MathKernInfo> mathKernInfo;\n@@ -423,0 +654,10 @@\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    const hb_map_t& glyph_map = *c->plan->glyph_map;\n+    return_trace (c->serializer->check_assign (out->variantGlyph, glyph_map.get (variantGlyph), HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n@@ -429,0 +670,3 @@\n+  void closure_glyphs (hb_set_t *variant_glyphs) const\n+  { variant_glyphs->add (variantGlyph); }\n+\n@@ -430,1 +674,1 @@\n-  HBGlyphID variantGlyph;       \/* Glyph ID for the variant. *\/\n+  HBGlyphID16 variantGlyph;       \/* Glyph ID for the variant. *\/\n@@ -453,0 +697,10 @@\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    const hb_map_t& glyph_map = *c->plan->glyph_map;\n+    return_trace (c->serializer->check_assign (out->glyph, glyph_map.get (glyph), HB_SERIALIZE_ERROR_INT_OVERFLOW));\n+  }\n+\n@@ -477,0 +731,3 @@\n+  void closure_glyphs (hb_set_t *variant_glyphs) const\n+  { variant_glyphs->add (glyph); }\n+\n@@ -478,1 +735,1 @@\n-  HBGlyphID     glyph;          \/* Glyph ID for the part. *\/\n+  HBGlyphID16   glyph;          \/* Glyph ID for the part. *\/\n@@ -500,0 +757,14 @@\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    if (!c->serializer->copy (italicsCorrection, this)) return_trace (false);\n+    if (!c->serializer->copy<HBUINT16> (partRecords.len)) return_trace (false);\n+\n+    for (const auto& record : partRecords.iter ())\n+      if (!record.subset (c)) return_trace (false);\n+    return_trace (true);\n+  }\n+\n@@ -529,0 +800,6 @@\n+  void closure_glyphs (hb_set_t *variant_glyphs) const\n+  {\n+    for (const auto& _ : partRecords.iter ())\n+      _.closure_glyphs (variant_glyphs);\n+  }\n+\n@@ -535,1 +812,1 @@\n-  ArrayOf<MathGlyphPartRecord>\n+  Array16Of<MathGlyphPartRecord>\n@@ -546,0 +823,16 @@\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+\n+    out->glyphAssembly.serialize_subset (c, glyphAssembly, this);\n+\n+    if (!c->serializer->check_assign (out->mathGlyphVariantRecord.len, mathGlyphVariantRecord.len, HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+    for (const auto& record : mathGlyphVariantRecord.iter ())\n+      if (!record.subset (c)) return_trace (false);\n+\n+    return_trace (true);\n+  }\n+\n@@ -572,0 +865,8 @@\n+  void closure_glyphs (hb_set_t *variant_glyphs) const\n+  {\n+    (this+glyphAssembly).closure_glyphs (variant_glyphs);\n+\n+    for (const auto& _ : mathGlyphVariantRecord.iter ())\n+      _.closure_glyphs (variant_glyphs);\n+  }\n+\n@@ -575,1 +876,1 @@\n-  OffsetTo<MathGlyphAssembly>     glyphAssembly;\n+  Offset16To<MathGlyphAssembly>   glyphAssembly;\n@@ -578,1 +879,1 @@\n-  ArrayOf<MathGlyphVariantRecord> mathGlyphVariantRecord;\n+  Array16Of<MathGlyphVariantRecord> mathGlyphVariantRecord;\n@@ -586,0 +887,88 @@\n+  void closure_glyphs (const hb_set_t *glyph_set,\n+                       hb_set_t *variant_glyphs) const\n+  {\n+    const hb_array_t<const Offset16To<MathGlyphConstruction>> glyph_construction_offsets = glyphConstruction.as_array (vertGlyphCount + horizGlyphCount);\n+\n+    if (vertGlyphCoverage)\n+    {\n+      const auto vert_offsets = glyph_construction_offsets.sub_array (0, vertGlyphCount);\n+      + hb_zip (this+vertGlyphCoverage, vert_offsets)\n+      | hb_filter (glyph_set, hb_first)\n+      | hb_map (hb_second)\n+      | hb_map (hb_add (this))\n+      | hb_apply ([=] (const MathGlyphConstruction &_) { _.closure_glyphs (variant_glyphs); })\n+      ;\n+    }\n+\n+    if (horizGlyphCoverage)\n+    {\n+      const auto hori_offsets = glyph_construction_offsets.sub_array (vertGlyphCount, horizGlyphCount);\n+      + hb_zip (this+horizGlyphCoverage, hori_offsets)\n+      | hb_filter (glyph_set, hb_first)\n+      | hb_map (hb_second)\n+      | hb_map (hb_add (this))\n+      | hb_apply ([=] (const MathGlyphConstruction &_) { _.closure_glyphs (variant_glyphs); })\n+      ;\n+    }\n+  }\n+\n+  void collect_coverage_and_indices (hb_sorted_vector_t<hb_codepoint_t>& new_coverage,\n+                                     const Offset16To<Coverage>& coverage,\n+                                     unsigned i,\n+                                     unsigned end_index,\n+                                     hb_set_t& indices,\n+                                     const hb_set_t& glyphset,\n+                                     const hb_map_t& glyph_map) const\n+  {\n+    if (!coverage) return;\n+\n+    for (const auto _ : (this+coverage).iter ())\n+    {\n+      if (i >= end_index) return;\n+      if (glyphset.has (_))\n+      {\n+        unsigned new_gid = glyph_map.get (_);\n+        new_coverage.push (new_gid);\n+        indices.add (i);\n+      }\n+      i++;\n+    }\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->_glyphset_mathed;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+\n+    auto *out = c->serializer->start_embed (*this);\n+    if (unlikely (!c->serializer->extend_min (out))) return_trace (false);\n+    if (!c->serializer->check_assign (out->minConnectorOverlap, minConnectorOverlap, HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+\n+    hb_sorted_vector_t<hb_codepoint_t> new_vert_coverage;\n+    hb_sorted_vector_t<hb_codepoint_t> new_hori_coverage;\n+    hb_set_t indices;\n+    collect_coverage_and_indices (new_vert_coverage, vertGlyphCoverage, 0, vertGlyphCount, indices, glyphset, glyph_map);\n+    collect_coverage_and_indices (new_hori_coverage, horizGlyphCoverage, vertGlyphCount, vertGlyphCount + horizGlyphCount, indices, glyphset, glyph_map);\n+\n+    if (!c->serializer->check_assign (out->vertGlyphCount, new_vert_coverage.length, HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+    if (!c->serializer->check_assign (out->horizGlyphCount, new_hori_coverage.length, HB_SERIALIZE_ERROR_INT_OVERFLOW))\n+      return_trace (false);\n+\n+    for (unsigned i : indices.iter ())\n+    {\n+      auto *o = c->serializer->embed (glyphConstruction[i]);\n+      if (!o) return_trace (false);\n+      o->serialize_subset (c, glyphConstruction[i], this);\n+    }\n+\n+    if (new_vert_coverage)\n+      out->vertGlyphCoverage.serialize_serialize (c->serializer, new_vert_coverage.iter ());\n+\n+    if (new_hori_coverage)\n+    out->horizGlyphCoverage.serialize_serialize (c->serializer, new_hori_coverage.iter ());\n+    return_trace (true);\n+  }\n+\n@@ -639,1 +1028,1 @@\n-    const OffsetTo<Coverage> &coverage = vertical ? vertGlyphCoverage\n+    const Offset16To<Coverage> &coverage = vertical ? vertGlyphCoverage\n@@ -656,1 +1045,1 @@\n-  OffsetTo<Coverage> vertGlyphCoverage;\n+  Offset16To<Coverage> vertGlyphCoverage;\n@@ -660,1 +1049,1 @@\n-  OffsetTo<Coverage> horizGlyphCoverage;\n+  Offset16To<Coverage> horizGlyphCoverage;\n@@ -674,1 +1063,1 @@\n-  UnsizedArrayOf<OffsetTo<MathGlyphConstruction>>\n+  UnsizedArrayOf<Offset16To<MathGlyphConstruction>>\n@@ -693,0 +1082,22 @@\n+  void closure_glyphs (hb_set_t *glyph_set) const\n+  {\n+    if (mathVariants)\n+    {\n+      hb_set_t variant_glyphs;\n+      (this+mathVariants).closure_glyphs (glyph_set, &variant_glyphs);\n+      hb_set_union (glyph_set, &variant_glyphs);\n+    }\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    out->mathConstants.serialize_copy (c->serializer, mathConstants, this, 0, hb_serialize_context_t::Head);\n+    out->mathGlyphInfo.serialize_subset (c, mathGlyphInfo, this);\n+    out->mathVariants.serialize_subset (c, mathVariants, this);\n+    return_trace (true);\n+  }\n+\n@@ -714,1 +1125,1 @@\n-  OffsetTo<MathConstants>\n+  Offset16To<MathConstants>\n@@ -716,1 +1127,1 @@\n-  OffsetTo<MathGlyphInfo>\n+  Offset16To<MathGlyphInfo>\n@@ -718,1 +1129,1 @@\n-  OffsetTo<MathVariants>\n+  Offset16To<MathVariants>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-math-table.hh","additions":435,"deletions":24,"binary":false,"changes":459,"status":"modified"},{"patch":"@@ -187,0 +187,45 @@\n+\/**\n+ * hb_ot_math_get_glyph_kernings:\n+ * @font: #hb_font_t to work upon\n+ * @glyph: The glyph index from which to retrieve the kernings\n+ * @kern: The #hb_ot_math_kern_t from which to retrieve the kernings\n+ * @start_offset: offset of the first kern entry to retrieve\n+ * @entries_count: (inout) (optional): Input = the maximum number of kern entries to return;\n+ *                                     Output = the actual number of kern entries returned\n+ * @kern_entries: (out caller-allocates) (array length=entries_count): array of kern entries returned\n+ *\n+ * Fetches the raw MathKern (cut-in) data for the specified font, glyph index,\n+ * and @kern. The corresponding list of kern values and correction heights is\n+ * returned as a list of #hb_ot_math_kern_entry_t structs.\n+ *\n+ * See also #hb_ot_math_get_glyph_kerning, which handles selecting the\n+ * appropriate kern value for a given correction height.\n+ *\n+ * <note>For a glyph with @n defined kern values (where @n > 0), there are only\n+ * @n1 defined correction heights, as each correction height defines a boundary\n+ * past which the next kern value should be selected. Therefore, only the\n+ * #hb_ot_math_kern_entry_t.kern_value of the uppermost #hb_ot_math_kern_entry_t\n+ * actually comes from the font; its corresponding\n+ * #hb_ot_math_kern_entry_t.max_correction_height is always set to\n+ * <code>INT32_MAX<\/code>.<\/note>\n+ *\n+ * Return value: the total number of kern values available or zero\n+ *\n+ * Since: 3.4.0\n+ **\/\n+unsigned int\n+hb_ot_math_get_glyph_kernings (hb_font_t *font,\n+                               hb_codepoint_t glyph,\n+                               hb_ot_math_kern_t kern,\n+                               unsigned int start_offset,\n+                               unsigned int *entries_count, \/* IN\/OUT *\/\n+                               hb_ot_math_kern_entry_t *kern_entries \/* OUT *\/)\n+{\n+  return font->face->table.MATH->get_glyph_info().get_kernings (glyph,\n+                                                                kern,\n+                                                                start_offset,\n+                                                                entries_count,\n+                                                                kern_entries,\n+                                                                font);\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-math.cc","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * HB_OT_MATH_SCRIPT:\n+ * HB_OT_TAG_MATH_SCRIPT:\n@@ -55,2 +55,1 @@\n- * OpenType script tag for math shaping, for use with\n- * Use with hb_buffer_set_script().\n+ * OpenType script tag, `math`, for features specific to math shaping.\n@@ -58,1 +57,6 @@\n- * Since: 1.3.3\n+ * <note>#HB_OT_TAG_MATH_SCRIPT is not a valid #hb_script_t and should only be\n+ * used with functions that accept raw OpenType script tags, such as\n+ * #hb_ot_layout_collect_features. In other cases, #HB_SCRIPT_MATH should be\n+ * used instead.<\/note>\n+ *\n+ * Since: 3.4.0\n@@ -60,1 +64,1 @@\n-#define HB_OT_MATH_SCRIPT HB_TAG('m','a','t','h')\n+#define HB_OT_TAG_MATH_SCRIPT HB_TAG('m','a','t','h')\n@@ -207,0 +211,14 @@\n+\/**\n+ * hb_ot_math_kern_entry_t:\n+ * @max_correction_height: The maximum height at which this entry should be used\n+ * @kern_value: The kern value of the entry\n+ *\n+ * Data type to hold math kerning (cut-in) information for a glyph.\n+ *\n+ * Since: 3.4.0\n+ *\/\n+typedef struct {\n+  hb_position_t max_correction_height;\n+  hb_position_t kern_value;\n+} hb_ot_math_kern_entry_t;\n+\n@@ -284,0 +302,8 @@\n+hb_ot_math_get_glyph_kernings (hb_font_t *font,\n+                               hb_codepoint_t glyph,\n+                               hb_ot_math_kern_t kern,\n+                               unsigned int start_offset,\n+                               unsigned int *entries_count, \/* IN\/OUT *\/\n+                               hb_ot_math_kern_entry_t *kern_entries \/* OUT *\/);\n+\n+HB_EXTERN unsigned int\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-math.h","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-      if (c->plan->drop_hints)\n+      if (c->plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-maxp-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<HBUINT8>>\n+  NNOffset32To<UnsizedArrayOf<HBUINT8>>\n@@ -74,1 +74,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -76,1 +76,1 @@\n-    void fini () { table.destroy (); }\n+    ~accelerator_t () { table.destroy (); }\n@@ -116,1 +116,1 @@\n-  LArrayOf<DataMap>\n+  Array32Of<DataMap>\n@@ -122,1 +122,3 @@\n-struct meta_accelerator_t : meta::accelerator_t {};\n+struct meta_accelerator_t : meta::accelerator_t {\n+  meta_accelerator_t (hb_face_t *face) : meta::accelerator_t (face) {}\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-meta-table.hh","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+\n@@ -89,0 +90,2 @@\n+\n+#ifndef HB_NO_VERTICAL\n@@ -92,0 +95,2 @@\n+#endif\n+\n@@ -158,2 +163,42 @@\n-  case HB_OT_METRICS_TAG_HORIZONTAL_CARET_RISE:       return GET_METRIC_Y (hhea, caretSlopeRise);\n-  case HB_OT_METRICS_TAG_HORIZONTAL_CARET_RUN:        return GET_METRIC_X (hhea, caretSlopeRun);\n+\n+  case HB_OT_METRICS_TAG_HORIZONTAL_CARET_RISE:\n+  case HB_OT_METRICS_TAG_HORIZONTAL_CARET_RUN:\n+  {\n+    unsigned mult = 1u;\n+\n+    if (font->slant)\n+    {\n+      unsigned rise = face->table.hhea->caretSlopeRise;\n+      unsigned upem = face->get_upem ();\n+      mult = (rise && rise < upem) ? hb_min (upem \/ rise, 256u) : 1u;\n+    }\n+\n+    if (metrics_tag == HB_OT_METRICS_TAG_HORIZONTAL_CARET_RISE)\n+    {\n+      bool ret = GET_METRIC_Y (hhea, caretSlopeRise);\n+\n+      if (position)\n+        *position *= mult;\n+\n+      return ret;\n+    }\n+    else\n+    {\n+      hb_position_t rise = 0;\n+\n+      if (font->slant && position && GET_METRIC_Y (hhea, caretSlopeRise))\n+        rise = *position;\n+\n+      bool ret = GET_METRIC_X (hhea, caretSlopeRun);\n+\n+      if (position)\n+      {\n+        *position *= mult;\n+\n+        if (font->slant)\n+          *position += _hb_roundf (mult * font->slant_xy * rise);\n+      }\n+\n+      return ret;\n+    }\n+  }\n@@ -161,0 +206,2 @@\n+\n+#ifndef HB_NO_VERTICAL\n@@ -164,0 +211,1 @@\n+#endif\n@@ -193,0 +241,139 @@\n+\/**\n+ * hb_ot_metrics_get_position_with_fallback:\n+ * @font: an #hb_font_t object.\n+ * @metrics_tag: tag of metrics value you like to fetch.\n+ * @position: (out) (optional): result of metrics value from the font.\n+ *\n+ * Fetches metrics value corresponding to @metrics_tag from @font,\n+ * and synthesizes a value if it the value is missing in the font.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+void\n+hb_ot_metrics_get_position_with_fallback (hb_font_t           *font,\n+                                          hb_ot_metrics_tag_t  metrics_tag,\n+                                          hb_position_t       *position     \/* OUT *\/)\n+{\n+  hb_font_extents_t font_extents;\n+  hb_codepoint_t glyph;\n+  hb_glyph_extents_t extents;\n+\n+  if (hb_ot_metrics_get_position (font, metrics_tag, position))\n+    {\n+      if ((metrics_tag != HB_OT_METRICS_TAG_STRIKEOUT_SIZE &&\n+           metrics_tag != HB_OT_METRICS_TAG_UNDERLINE_SIZE) ||\n+          *position != 0)\n+        return;\n+    }\n+\n+  switch (metrics_tag)\n+  {\n+  case HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER:\n+  case HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_ASCENT:\n+    hb_font_get_extents_for_direction (font, HB_DIRECTION_LTR, &font_extents);\n+    *position = font_extents.ascender;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_VERTICAL_ASCENDER:\n+    hb_font_get_extents_for_direction (font, HB_DIRECTION_TTB, &font_extents);\n+    *position = font_extents.ascender;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_HORIZONTAL_DESCENDER:\n+  case HB_OT_METRICS_TAG_HORIZONTAL_CLIPPING_DESCENT:\n+    hb_font_get_extents_for_direction (font, HB_DIRECTION_LTR, &font_extents);\n+    *position = font_extents.descender;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_VERTICAL_DESCENDER:\n+    hb_font_get_extents_for_direction (font, HB_DIRECTION_TTB, &font_extents);\n+    *position = font_extents.ascender;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_HORIZONTAL_LINE_GAP:\n+    hb_font_get_extents_for_direction (font, HB_DIRECTION_LTR, &font_extents);\n+    *position = font_extents.line_gap;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_VERTICAL_LINE_GAP:\n+    hb_font_get_extents_for_direction (font, HB_DIRECTION_TTB, &font_extents);\n+    *position = font_extents.line_gap;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_HORIZONTAL_CARET_RISE:\n+  case HB_OT_METRICS_TAG_VERTICAL_CARET_RISE:\n+    *position = 1;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_HORIZONTAL_CARET_RUN:\n+  case HB_OT_METRICS_TAG_VERTICAL_CARET_RUN:\n+    *position = 0;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_HORIZONTAL_CARET_OFFSET:\n+  case HB_OT_METRICS_TAG_VERTICAL_CARET_OFFSET:\n+    *position = 0;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_X_HEIGHT:\n+    if (hb_font_get_nominal_glyph (font, 'x', &glyph) &&\n+        hb_font_get_glyph_extents (font, glyph, &extents))\n+      *position = extents.y_bearing;\n+    else\n+      *position = font->y_scale \/ 2;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_CAP_HEIGHT:\n+    if (hb_font_get_nominal_glyph (font, 'O', &glyph) &&\n+        hb_font_get_glyph_extents (font, glyph, &extents))\n+      *position = extents.height + 2 * extents.y_bearing;\n+    else\n+      *position = font->y_scale * 2 \/ 3;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_STRIKEOUT_SIZE:\n+  case HB_OT_METRICS_TAG_UNDERLINE_SIZE:\n+    *position = font->y_scale \/ 18;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_STRIKEOUT_OFFSET:\n+    {\n+      hb_position_t ascender;\n+      hb_ot_metrics_get_position_with_fallback (font,\n+                                                HB_OT_METRICS_TAG_HORIZONTAL_ASCENDER,\n+                                                &ascender);\n+      *position = ascender \/ 2;\n+    }\n+    break;\n+\n+  case HB_OT_METRICS_TAG_UNDERLINE_OFFSET:\n+    *position = - font->y_scale \/ 18;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_SIZE:\n+  case HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_SIZE:\n+    *position = font->x_scale * 10 \/ 12;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_SIZE:\n+  case HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_SIZE:\n+    *position = font->y_scale * 10 \/ 12;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_SUBSCRIPT_EM_X_OFFSET:\n+  case HB_OT_METRICS_TAG_SUPERSCRIPT_EM_X_OFFSET:\n+    *position = 0;\n+    break;\n+\n+  case HB_OT_METRICS_TAG_SUBSCRIPT_EM_Y_OFFSET:\n+  case HB_OT_METRICS_TAG_SUPERSCRIPT_EM_Y_OFFSET:\n+    *position = font->y_scale \/ 5;\n+    break;\n+\n+  case _HB_OT_METRICS_TAG_MAX_VALUE:\n+  default:\n+    *position = 0;\n+    break;\n+  }\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-metrics.cc","additions":189,"deletions":2,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -113,0 +113,5 @@\n+HB_EXTERN void\n+hb_ot_metrics_get_position_with_fallback (hb_font_t           *font,\n+                                          hb_ot_metrics_tag_t  metrics_tag,\n+                                          hb_position_t       *position     \/* OUT *\/);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-metrics.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-hb_ms_language_map[] =\n+_hb_ms_language_map[] =\n@@ -301,1 +301,1 @@\n-hb_mac_language_map[] =\n+_hb_mac_language_map[] =\n@@ -444,2 +444,2 @@\n-                                   hb_ms_language_map,\n-                                   ARRAY_LENGTH (hb_ms_language_map));\n+                                   _hb_ms_language_map,\n+                                   ARRAY_LENGTH (_hb_ms_language_map));\n@@ -452,2 +452,2 @@\n-                                   hb_mac_language_map,\n-                                   ARRAY_LENGTH (hb_mac_language_map));\n+                                   _hb_mac_language_map,\n+                                   ARRAY_LENGTH (_hb_mac_language_map));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name-language-static.hh","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-  NNOffsetTo<UnsizedArrayOf<HBUINT8>>\n+  NNOffset16To<UnsizedArrayOf<HBUINT8>>\n@@ -159,1 +159,1 @@\n-_hb_ot_name_entry_cmp_key (const void *pa, const void *pb)\n+_hb_ot_name_entry_cmp_key (const void *pa, const void *pb, bool exact)\n@@ -172,2 +172,17 @@\n-  return strcmp (hb_language_to_string (a->language),\n-                 hb_language_to_string (b->language));\n+\n+  const char *astr = hb_language_to_string (a->language);\n+  const char *bstr = hb_language_to_string (b->language);\n+\n+  signed c = strcmp (astr, bstr);\n+\n+  if (!exact && c)\n+  {\n+    unsigned la = strlen (astr);\n+    unsigned lb = strlen (bstr);\n+    \/\/ 'a' is the user request, and 'b' is string in the font.\n+    \/\/ If eg. user asks for \"en-us\" and font has \"en\", approve.\n+    if (la > lb && astr[lb] == '-' && !strncmp (astr, bstr, lb))\n+      return 0;\n+  }\n+\n+  return c;\n@@ -181,1 +196,1 @@\n-  int v = _hb_ot_name_entry_cmp_key (pa, pb);\n+  int v = _hb_ot_name_entry_cmp_key (pa, pb, true);\n@@ -217,1 +232,1 @@\n-    NameRecord *name_records = (NameRecord *) calloc (it.len (), NameRecord::static_size);\n+    NameRecord *name_records = (NameRecord *) hb_calloc (it.len (), NameRecord::static_size);\n@@ -231,1 +246,2 @@\n-    free (records.arrayZ);\n+    hb_free (records.arrayZ);\n+\n@@ -233,1 +249,1 @@\n-    if (unlikely (c->ran_out_of_room)) return_trace (false);\n+    if (unlikely (c->ran_out_of_room ())) return_trace (false);\n@@ -251,1 +267,5 @@\n-    | hb_filter ([&] (const NameRecord& namerecord) { return c->plan->name_legacy || namerecord.isUnicode (); })\n+    | hb_filter ([&] (const NameRecord& namerecord) {\n+      return\n+          (c->plan->flags & HB_SUBSET_FLAGS_NAME_LEGACY)\n+          || namerecord.isUnicode ();\n+    })\n@@ -254,1 +274,1 @@\n-    name_prime->serialize (c->serializer, it, hb_addressof (this + stringOffset));\n+    name_prime->serialize (c->serializer, it, std::addressof (this + stringOffset));\n@@ -277,1 +297,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -286,1 +306,0 @@\n-      this->names.init ();\n@@ -316,2 +335,1 @@\n-\n-    void fini ()\n+    ~accelerator_t ()\n@@ -319,1 +337,0 @@\n-      this->names.fini ();\n@@ -331,1 +348,12 @@\n-                                                    _hb_ot_name_entry_cmp_key);\n+                                                    _hb_ot_name_entry_cmp_key,\n+                                                    true);\n+\n+      if (!entry)\n+      {\n+        entry = hb_bsearch (key, (const hb_ot_name_entry_t *) this->names,\n+                            this->names.length,\n+                            sizeof (hb_ot_name_entry_t),\n+                            _hb_ot_name_entry_cmp_key,\n+                            false);\n+      }\n+\n@@ -360,1 +388,1 @@\n-  NNOffsetTo<UnsizedArrayOf<HBUINT8>>\n+  NNOffset16To<UnsizedArrayOf<HBUINT8>>\n@@ -371,1 +399,3 @@\n-struct name_accelerator_t : name::accelerator_t {};\n+struct name_accelerator_t : name::accelerator_t {\n+  name_accelerator_t (hb_face_t *face) : name::accelerator_t (face) {}\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name-table.hh","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * Returns: (out) (transfer none) (array length=num_entries): Array of available name entries.\n+ * Returns: (transfer none) (array length=num_entries): Array of available name entries.\n@@ -159,1 +159,2 @@\n- * Returns string in UTF-8 encoding.\n+ * Returns string in UTF-8 encoding. A NUL terminator is always written\n+ * for convenience, and isn't included in the output @text_size.\n@@ -186,1 +187,2 @@\n- * Returns string in UTF-16 encoding.\n+ * Returns string in UTF-16 encoding. A NUL terminator is always written\n+ * for convenience, and isn't included in the output @text_size.\n@@ -212,1 +214,2 @@\n- * Returns string in UTF-32 encoding.\n+ * Returns string in UTF-32 encoding. A NUL terminator is always written\n+ * for convenience, and isn't included in the output @text_size.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name.cc","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,0 +39,27 @@\n+ * @HB_OT_NAME_ID_COPYRIGHT: Copyright notice\n+ * @HB_OT_NAME_ID_FONT_FAMILY: Font Family name\n+ * @HB_OT_NAME_ID_FONT_SUBFAMILY: Font Subfamily name\n+ * @HB_OT_NAME_ID_UNIQUE_ID: Unique font identifier\n+ * @HB_OT_NAME_ID_FULL_NAME: Full font name that reflects\n+ * all family and relevant subfamily descriptors\n+ * @HB_OT_NAME_ID_VERSION_STRING: Version string\n+ * @HB_OT_NAME_ID_POSTSCRIPT_NAME: PostScript name for the font\n+ * @HB_OT_NAME_ID_TRADEMARK: Trademark\n+ * @HB_OT_NAME_ID_MANUFACTURER: Manufacturer Name\n+ * @HB_OT_NAME_ID_DESIGNER: Designer\n+ * @HB_OT_NAME_ID_DESCRIPTION: Description\n+ * @HB_OT_NAME_ID_VENDOR_URL: URL of font vendor\n+ * @HB_OT_NAME_ID_DESIGNER_URL: URL of typeface designer\n+ * @HB_OT_NAME_ID_LICENSE: License Description\n+ * @HB_OT_NAME_ID_LICENSE_URL: URL where additional licensing\n+ * information can be found\n+ * @HB_OT_NAME_ID_TYPOGRAPHIC_FAMILY: Typographic Family name\n+ * @HB_OT_NAME_ID_TYPOGRAPHIC_SUBFAMILY: Typographic Subfamily name\n+ * @HB_OT_NAME_ID_MAC_FULL_NAME: Compatible Full Name for MacOS\n+ * @HB_OT_NAME_ID_SAMPLE_TEXT: Sample text\n+ * @HB_OT_NAME_ID_CID_FINDFONT_NAME: PostScript CID findfont name\n+ * @HB_OT_NAME_ID_WWS_FAMILY: WWS Family Name\n+ * @HB_OT_NAME_ID_WWS_SUBFAMILY: WWS Subfamily Name\n+ * @HB_OT_NAME_ID_LIGHT_BACKGROUND: Light Background Palette\n+ * @HB_OT_NAME_ID_DARK_BACKGROUND: Dark Background Palette\n+ * @HB_OT_NAME_ID_VARIATIONS_PS_PREFIX: Variations PostScript Name Prefix\n@@ -45,0 +72,3 @@\n+ * For more information on these fields, see the\n+ * [OpenType spec](https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/name#name-ids).\n+ *\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"hb-ot-cmap-table.hh\"\n@@ -175,0 +174,2 @@\n+    if (c->plan->flags & HB_SUBSET_FLAGS_NO_PRUNE_UNICODE_RANGES)\n+      return_trace (true);\n@@ -176,18 +177,0 @@\n-    hb_set_t unicodes;\n-    if (!c->plan->glyphs_requested->is_empty ())\n-    {\n-      hb_map_t unicode_glyphid_map;\n-\n-      OT::cmap::accelerator_t cmap;\n-      cmap.init (c->plan->source);\n-      cmap.collect_mapping (&unicodes, &unicode_glyphid_map);\n-      cmap.fini ();\n-\n-      hb_set_set (&unicodes, c->plan->unicodes);\n-\n-      + unicode_glyphid_map.iter ()\n-      | hb_filter (c->plan->glyphs_requested, hb_second)\n-      | hb_map (hb_first)\n-      | hb_sink (unicodes)\n-      ;\n-    }\n@@ -197,1 +180,1 @@\n-    find_min_and_max_codepoint (unicodes.is_empty () ? c->plan->unicodes : &unicodes, &min_cp, &max_cp);\n+    find_min_and_max_codepoint (c->plan->unicodes, &min_cp, &max_cp);\n@@ -201,1 +184,1 @@\n-    _update_unicode_ranges (unicodes.is_empty () ? c->plan->unicodes : &unicodes, os2_prime->ulUnicodeRange);\n+    _update_unicode_ranges (c->plan->unicodes, os2_prime->ulUnicodeRange);\n@@ -244,1 +227,2 @@\n-  \/* https:\/\/github.com\/Microsoft\/Font-Validator\/blob\/520aaae\/OTFontFileVal\/val_OS2.cs#L644-L681 *\/\n+  \/* https:\/\/github.com\/Microsoft\/Font-Validator\/blob\/520aaae\/OTFontFileVal\/val_OS2.cs#L644-L681\n+   * https:\/\/docs.microsoft.com\/en-us\/typography\/legacy\/legacy_arabic_fonts *\/\n@@ -247,0 +231,1 @@\n+    FONT_PAGE_NONE              = 0,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-os2-table.hh","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright  2021  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ *\/\n+\n+#ifndef HB_OT_POST_TABLE_V2SUBSET_HH\n+#define HB_OT_POST_TABLE_V2SUBSET_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-post-table.hh\"\n+\n+\/*\n+ * post -- PostScript\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/post\n+ *\/\n+\n+namespace OT {\n+template<typename Iterator>\n+HB_INTERNAL bool postV2Tail::serialize (hb_serialize_context_t *c,\n+                                        Iterator it,\n+                                        const void* _post) const\n+{\n+  TRACE_SERIALIZE (this);\n+  auto *out = c->start_embed (this);\n+  if (unlikely (!c->check_success (out))) return_trace (false);\n+  if (!out->glyphNameIndex.serialize (c, + it\n+                                         | hb_map (hb_second)))\n+      return_trace (false);\n+\n+  hb_set_t copied_indices;\n+  for (const auto& _ : + it )\n+  {\n+    unsigned glyph_id = _.first;\n+    unsigned new_index = _.second;\n+\n+    if (new_index < 258) continue;\n+    if (copied_indices.has (new_index)) continue;\n+    copied_indices.add (new_index);\n+\n+    hb_bytes_t s = reinterpret_cast<const post::accelerator_t*> (_post)->find_glyph_name (glyph_id);\n+    HBUINT8 *o = c->allocate_size<HBUINT8> (HBUINT8::static_size * (s.length + 1));\n+    if (unlikely (!o)) return_trace (false);\n+    if (!c->check_assign (o[0], s.length, HB_SERIALIZE_ERROR_INT_OVERFLOW)) return_trace (false);\n+    hb_memcpy (o+1, s.arrayZ, HBUINT8::static_size * s.length);\n+  }\n+\n+  return_trace (true);\n+}\n+\n+HB_INTERNAL bool postV2Tail::subset (hb_subset_context_t *c) const\n+{\n+  TRACE_SUBSET (this);\n+\n+  const hb_map_t &reverse_glyph_map = *c->plan->reverse_glyph_map;\n+  unsigned num_glyphs = c->plan->num_output_glyphs ();\n+  hb_map_t old_new_index_map, old_gid_new_index_map;\n+  unsigned i = 0;\n+\n+  post::accelerator_t _post (c->plan->source);\n+\n+  hb_hashmap_t<hb_bytes_t, unsigned, true> glyph_name_to_new_index;\n+  for (hb_codepoint_t new_gid = 0; new_gid < num_glyphs; new_gid++)\n+  {\n+    hb_codepoint_t old_gid = reverse_glyph_map.get (new_gid);\n+    unsigned old_index = glyphNameIndex[old_gid];\n+\n+    unsigned new_index;\n+    const unsigned *new_index2;\n+    if (old_index <= 257) new_index = old_index;\n+    else if (old_new_index_map.has (old_index, &new_index2))\n+    {\n+      new_index = *new_index2;\n+    } else {\n+      hb_bytes_t s = _post.find_glyph_name (old_gid);\n+      new_index = glyph_name_to_new_index.get (s);\n+      if (new_index == (unsigned)-1)\n+      {\n+        int standard_glyph_index = -1;\n+        for (unsigned i = 0; i < format1_names_length; i++)\n+        {\n+          if (s == format1_names (i))\n+          {\n+            standard_glyph_index = i;\n+            break;\n+          }\n+        }\n+\n+        if (standard_glyph_index == -1)\n+        {\n+          new_index = 258 + i;\n+          i++;\n+        }\n+        else\n+        { new_index = standard_glyph_index; }\n+        glyph_name_to_new_index.set (s, new_index);\n+      }\n+      old_new_index_map.set (old_index, new_index);\n+    }\n+    old_gid_new_index_map.set (old_gid, new_index);\n+  }\n+\n+  auto index_iter =\n+  + hb_range (num_glyphs)\n+  | hb_map (reverse_glyph_map)\n+  | hb_map_retains_sorting ([&](hb_codepoint_t old_gid)\n+                            {\n+                              unsigned new_index = old_gid_new_index_map.get (old_gid);\n+                              return hb_pair_t<unsigned, unsigned> (old_gid, new_index);\n+                            })\n+  ;\n+\n+  return_trace (serialize (c->serializer, index_iter, &_post));\n+}\n+\n+} \/* namespace OT *\/\n+#endif \/* HB_OT_POST_TABLE_V2SUBSET_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-post-table-v2subset.hh","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -58,0 +58,7 @@\n+  template<typename Iterator>\n+  bool serialize (hb_serialize_context_t *c,\n+                  Iterator it,\n+                  const void* _post) const;\n+\n+  bool subset (hb_subset_context_t *c) const;\n+\n@@ -59,1 +66,1 @@\n-  ArrayOf<HBUINT16>     glyphNameIndex; \/* This is not an offset, but is the\n+  Array16Of<HBUINT16>   glyphNameIndex; \/* This is not an offset, but is the\n@@ -74,1 +81,1 @@\n-  void serialize (hb_serialize_context_t *c) const\n+  bool serialize (hb_serialize_context_t *c, bool glyph_names) const\n@@ -76,0 +83,1 @@\n+    TRACE_SERIALIZE (this);\n@@ -77,1 +85,1 @@\n-    if (unlikely (!post_prime))  return;\n+    if (unlikely (!post_prime))  return_trace (false);\n@@ -80,1 +88,5 @@\n-    post_prime->version.major = 3; \/\/ Version 3 does not have any glyph names.\n+    if (!glyph_names)\n+      return_trace (c->check_assign (post_prime->version.major, 3,\n+                                     HB_SERIALIZE_ERROR_INT_OVERFLOW)); \/\/ Version 3 does not have any glyph names.\n+\n+    return_trace (true);\n@@ -89,1 +101,6 @@\n-    serialize (c->serializer);\n+    bool glyph_names = c->plan->flags & HB_SUBSET_FLAGS_GLYPH_NAMES;\n+    if (!serialize (c->serializer, glyph_names))\n+      return_trace (false);\n+\n+    if (glyph_names && version.major == 2)\n+      return_trace (v2X.subset (c));\n@@ -96,3 +113,1 @@\n-    void init (hb_face_t *face)\n-    {\n-      index_to_offset.init ();\n+    friend struct postV2Tail;\n@@ -100,0 +115,2 @@\n+    accelerator_t (hb_face_t *face)\n+    {\n@@ -117,1 +134,1 @@\n-    void fini ()\n+    ~accelerator_t ()\n@@ -119,2 +136,1 @@\n-      index_to_offset.fini ();\n-      free (gids_sorted_by_name.get ());\n+      hb_free (gids_sorted_by_name.get ());\n@@ -151,1 +167,1 @@\n-        gids = (uint16_t *) malloc (count * sizeof (gids[0]));\n+        gids = (uint16_t *) hb_malloc (count * sizeof (gids[0]));\n@@ -161,1 +177,1 @@\n-          free (gids);\n+          hb_free (gids);\n@@ -239,1 +255,1 @@\n-    const ArrayOf<HBUINT16> *glyphNameIndex;\n+    const Array16Of<HBUINT16> *glyphNameIndex = nullptr;\n@@ -241,1 +257,1 @@\n-    const uint8_t *pool;\n+    const uint8_t *pool = nullptr;\n@@ -292,1 +308,4 @@\n-struct post_accelerator_t : post::accelerator_t {};\n+struct post_accelerator_t : post::accelerator_t {\n+  post_accelerator_t (hb_face_t *face) : post::accelerator_t (face) {}\n+};\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-post-table.hh","additions":35,"deletions":16,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,348 +0,0 @@\n-\/*\n- * Copyright  2012  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH\n-#define HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH\n-\n-#include \"hb.hh\"\n-\n-#include \"hb-ot-shape.hh\"\n-#include \"hb-ot-layout-gsub-table.hh\"\n-\n-\n-\/* Features ordered the same as the entries in shaping_table rows,\n- * followed by rlig.  Don't change. *\/\n-static const hb_tag_t arabic_fallback_features[] =\n-{\n-  HB_TAG('i','n','i','t'),\n-  HB_TAG('m','e','d','i'),\n-  HB_TAG('f','i','n','a'),\n-  HB_TAG('i','s','o','l'),\n-  HB_TAG('r','l','i','g'),\n-};\n-\n-static OT::SubstLookup *\n-arabic_fallback_synthesize_lookup_single (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                                          hb_font_t *font,\n-                                          unsigned int feature_index)\n-{\n-  OT::HBGlyphID glyphs[SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1];\n-  OT::HBGlyphID substitutes[SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1];\n-  unsigned int num_glyphs = 0;\n-\n-  \/* Populate arrays *\/\n-  for (hb_codepoint_t u = SHAPING_TABLE_FIRST; u < SHAPING_TABLE_LAST + 1; u++)\n-  {\n-    hb_codepoint_t s = shaping_table[u - SHAPING_TABLE_FIRST][feature_index];\n-    hb_codepoint_t u_glyph, s_glyph;\n-\n-    if (!s ||\n-        !hb_font_get_glyph (font, u, 0, &u_glyph) ||\n-        !hb_font_get_glyph (font, s, 0, &s_glyph) ||\n-        u_glyph == s_glyph ||\n-        u_glyph > 0xFFFFu || s_glyph > 0xFFFFu)\n-      continue;\n-\n-    glyphs[num_glyphs] = u_glyph;\n-    substitutes[num_glyphs] = s_glyph;\n-\n-    num_glyphs++;\n-  }\n-\n-  if (!num_glyphs)\n-    return nullptr;\n-\n-  \/* Bubble-sort or something equally good!\n-   * May not be good-enough for presidential candidate interviews, but good-enough for us... *\/\n-  hb_stable_sort (&glyphs[0], num_glyphs,\n-                  (int(*)(const OT::HBUINT16*, const OT::HBUINT16 *)) OT::HBGlyphID::cmp,\n-                  &substitutes[0]);\n-\n-\n-  \/* Each glyph takes four bytes max, and there's some overhead. *\/\n-  char buf[(SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1) * 4 + 128];\n-  hb_serialize_context_t c (buf, sizeof (buf));\n-  OT::SubstLookup *lookup = c.start_serialize<OT::SubstLookup> ();\n-  bool ret = lookup->serialize_single (&c,\n-                                       OT::LookupFlag::IgnoreMarks,\n-                                       hb_sorted_array (glyphs, num_glyphs),\n-                                       hb_array (substitutes, num_glyphs));\n-  c.end_serialize ();\n-\n-  return ret && !c.in_error () ? c.copy<OT::SubstLookup> () : nullptr;\n-}\n-\n-static OT::SubstLookup *\n-arabic_fallback_synthesize_lookup_ligature (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                                            hb_font_t *font)\n-{\n-  OT::HBGlyphID first_glyphs[ARRAY_LENGTH_CONST (ligature_table)];\n-  unsigned int first_glyphs_indirection[ARRAY_LENGTH_CONST (ligature_table)];\n-  unsigned int ligature_per_first_glyph_count_list[ARRAY_LENGTH_CONST (first_glyphs)];\n-  unsigned int num_first_glyphs = 0;\n-\n-  \/* We know that all our ligatures are 2-component *\/\n-  OT::HBGlyphID ligature_list[ARRAY_LENGTH_CONST (first_glyphs) * ARRAY_LENGTH_CONST(ligature_table[0].ligatures)];\n-  unsigned int component_count_list[ARRAY_LENGTH_CONST (ligature_list)];\n-  OT::HBGlyphID component_list[ARRAY_LENGTH_CONST (ligature_list) * 1\/* One extra component per ligature *\/];\n-  unsigned int num_ligatures = 0;\n-\n-  \/* Populate arrays *\/\n-\n-  \/* Sort out the first-glyphs *\/\n-  for (unsigned int first_glyph_idx = 0; first_glyph_idx < ARRAY_LENGTH (first_glyphs); first_glyph_idx++)\n-  {\n-    hb_codepoint_t first_u = ligature_table[first_glyph_idx].first;\n-    hb_codepoint_t first_glyph;\n-    if (!hb_font_get_glyph (font, first_u, 0, &first_glyph))\n-      continue;\n-    first_glyphs[num_first_glyphs] = first_glyph;\n-    ligature_per_first_glyph_count_list[num_first_glyphs] = 0;\n-    first_glyphs_indirection[num_first_glyphs] = first_glyph_idx;\n-    num_first_glyphs++;\n-  }\n-  hb_stable_sort (&first_glyphs[0], num_first_glyphs,\n-                  (int(*)(const OT::HBUINT16*, const OT::HBUINT16 *)) OT::HBGlyphID::cmp,\n-                  &first_glyphs_indirection[0]);\n-\n-  \/* Now that the first-glyphs are sorted, walk again, populate ligatures. *\/\n-  for (unsigned int i = 0; i < num_first_glyphs; i++)\n-  {\n-    unsigned int first_glyph_idx = first_glyphs_indirection[i];\n-\n-    for (unsigned int second_glyph_idx = 0; second_glyph_idx < ARRAY_LENGTH (ligature_table[0].ligatures); second_glyph_idx++)\n-    {\n-      hb_codepoint_t second_u   = ligature_table[first_glyph_idx].ligatures[second_glyph_idx].second;\n-      hb_codepoint_t ligature_u = ligature_table[first_glyph_idx].ligatures[second_glyph_idx].ligature;\n-      hb_codepoint_t second_glyph, ligature_glyph;\n-      if (!second_u ||\n-          !hb_font_get_glyph (font, second_u,   0, &second_glyph) ||\n-          !hb_font_get_glyph (font, ligature_u, 0, &ligature_glyph))\n-        continue;\n-\n-      ligature_per_first_glyph_count_list[i]++;\n-\n-      ligature_list[num_ligatures] = ligature_glyph;\n-      component_count_list[num_ligatures] = 2;\n-      component_list[num_ligatures] = second_glyph;\n-      num_ligatures++;\n-    }\n-  }\n-\n-  if (!num_ligatures)\n-    return nullptr;\n-\n-\n-  \/* 16 bytes per ligature ought to be enough... *\/\n-  char buf[ARRAY_LENGTH_CONST (ligature_list) * 16 + 128];\n-  hb_serialize_context_t c (buf, sizeof (buf));\n-  OT::SubstLookup *lookup = c.start_serialize<OT::SubstLookup> ();\n-  bool ret = lookup->serialize_ligature (&c,\n-                                         OT::LookupFlag::IgnoreMarks,\n-                                         hb_sorted_array (first_glyphs, num_first_glyphs),\n-                                         hb_array (ligature_per_first_glyph_count_list, num_first_glyphs),\n-                                         hb_array (ligature_list, num_ligatures),\n-                                         hb_array (component_count_list, num_ligatures),\n-                                         hb_array (component_list, num_ligatures));\n-  c.end_serialize ();\n-  \/* TODO sanitize the results? *\/\n-\n-  return ret && !c.in_error () ? c.copy<OT::SubstLookup> () : nullptr;\n-}\n-\n-static OT::SubstLookup *\n-arabic_fallback_synthesize_lookup (const hb_ot_shape_plan_t *plan,\n-                                   hb_font_t *font,\n-                                   unsigned int feature_index)\n-{\n-  if (feature_index < 4)\n-    return arabic_fallback_synthesize_lookup_single (plan, font, feature_index);\n-  else\n-    return arabic_fallback_synthesize_lookup_ligature (plan, font);\n-}\n-\n-#define ARABIC_FALLBACK_MAX_LOOKUPS 5\n-\n-struct arabic_fallback_plan_t\n-{\n-  unsigned int num_lookups;\n-  bool free_lookups;\n-\n-  hb_mask_t mask_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n-  OT::SubstLookup *lookup_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n-  OT::hb_ot_layout_lookup_accelerator_t accel_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n-};\n-\n-#if defined(_WIN32) && !defined(HB_NO_WIN1256)\n-#define HB_WITH_WIN1256\n-#endif\n-\n-#ifdef HB_WITH_WIN1256\n-#include \"hb-ot-shape-complex-arabic-win1256.hh\"\n-#endif\n-\n-struct ManifestLookup\n-{\n-  public:\n-  OT::Tag tag;\n-  OT::OffsetTo<OT::SubstLookup> lookupOffset;\n-  public:\n-  DEFINE_SIZE_STATIC (6);\n-};\n-typedef OT::ArrayOf<ManifestLookup> Manifest;\n-\n-static bool\n-arabic_fallback_plan_init_win1256 (arabic_fallback_plan_t *fallback_plan HB_UNUSED,\n-                                   const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                                   hb_font_t *font HB_UNUSED)\n-{\n-#ifdef HB_WITH_WIN1256\n-  \/* Does this font look like it's Windows-1256-encoded? *\/\n-  hb_codepoint_t g;\n-  if (!(hb_font_get_glyph (font, 0x0627u, 0, &g) && g == 199 \/* ALEF *\/ &&\n-        hb_font_get_glyph (font, 0x0644u, 0, &g) && g == 225 \/* LAM *\/ &&\n-        hb_font_get_glyph (font, 0x0649u, 0, &g) && g == 236 \/* ALEF MAKSURA *\/ &&\n-        hb_font_get_glyph (font, 0x064Au, 0, &g) && g == 237 \/* YEH *\/ &&\n-        hb_font_get_glyph (font, 0x0652u, 0, &g) && g == 250 \/* SUKUN *\/))\n-    return false;\n-\n-  const Manifest &manifest = reinterpret_cast<const Manifest&> (arabic_win1256_gsub_lookups.manifest);\n-  static_assert (sizeof (arabic_win1256_gsub_lookups.manifestData) ==\n-                 ARABIC_FALLBACK_MAX_LOOKUPS * sizeof (ManifestLookup), \"\");\n-  \/* TODO sanitize the table? *\/\n-\n-  unsigned j = 0;\n-  unsigned int count = manifest.len;\n-  for (unsigned int i = 0; i < count; i++)\n-  {\n-    fallback_plan->mask_array[j] = plan->map.get_1_mask (manifest[i].tag);\n-    if (fallback_plan->mask_array[j])\n-    {\n-      fallback_plan->lookup_array[j] = const_cast<OT::SubstLookup*> (&(&manifest+manifest[i].lookupOffset));\n-      if (fallback_plan->lookup_array[j])\n-      {\n-        fallback_plan->accel_array[j].init (*fallback_plan->lookup_array[j]);\n-        j++;\n-      }\n-    }\n-  }\n-\n-  fallback_plan->num_lookups = j;\n-  fallback_plan->free_lookups = false;\n-\n-  return j > 0;\n-#else\n-  return false;\n-#endif\n-}\n-\n-static bool\n-arabic_fallback_plan_init_unicode (arabic_fallback_plan_t *fallback_plan,\n-                                   const hb_ot_shape_plan_t *plan,\n-                                   hb_font_t *font)\n-{\n-  static_assert ((ARRAY_LENGTH_CONST(arabic_fallback_features) <= ARABIC_FALLBACK_MAX_LOOKUPS), \"\");\n-  unsigned int j = 0;\n-  for (unsigned int i = 0; i < ARRAY_LENGTH(arabic_fallback_features) ; i++)\n-  {\n-    fallback_plan->mask_array[j] = plan->map.get_1_mask (arabic_fallback_features[i]);\n-    if (fallback_plan->mask_array[j])\n-    {\n-      fallback_plan->lookup_array[j] = arabic_fallback_synthesize_lookup (plan, font, i);\n-      if (fallback_plan->lookup_array[j])\n-      {\n-        fallback_plan->accel_array[j].init (*fallback_plan->lookup_array[j]);\n-        j++;\n-      }\n-    }\n-  }\n-\n-  fallback_plan->num_lookups = j;\n-  fallback_plan->free_lookups = true;\n-\n-  return j > 0;\n-}\n-\n-static arabic_fallback_plan_t *\n-arabic_fallback_plan_create (const hb_ot_shape_plan_t *plan,\n-                             hb_font_t *font)\n-{\n-  arabic_fallback_plan_t *fallback_plan = (arabic_fallback_plan_t *) calloc (1, sizeof (arabic_fallback_plan_t));\n-  if (unlikely (!fallback_plan))\n-    return const_cast<arabic_fallback_plan_t *> (&Null (arabic_fallback_plan_t));\n-\n-  fallback_plan->num_lookups = 0;\n-  fallback_plan->free_lookups = false;\n-\n-  \/* Try synthesizing GSUB table using Unicode Arabic Presentation Forms,\n-   * in case the font has cmap entries for the presentation-forms characters. *\/\n-  if (arabic_fallback_plan_init_unicode (fallback_plan, plan, font))\n-    return fallback_plan;\n-\n-  \/* See if this looks like a Windows-1256-encoded font.  If it does, use a\n-   * hand-coded GSUB table. *\/\n-  if (arabic_fallback_plan_init_win1256 (fallback_plan, plan, font))\n-    return fallback_plan;\n-\n-  assert (fallback_plan->num_lookups == 0);\n-  free (fallback_plan);\n-  return const_cast<arabic_fallback_plan_t *> (&Null (arabic_fallback_plan_t));\n-}\n-\n-static void\n-arabic_fallback_plan_destroy (arabic_fallback_plan_t *fallback_plan)\n-{\n-  if (!fallback_plan || fallback_plan->num_lookups == 0)\n-    return;\n-\n-  for (unsigned int i = 0; i < fallback_plan->num_lookups; i++)\n-    if (fallback_plan->lookup_array[i])\n-    {\n-      fallback_plan->accel_array[i].fini ();\n-      if (fallback_plan->free_lookups)\n-        free (fallback_plan->lookup_array[i]);\n-    }\n-\n-  free (fallback_plan);\n-}\n-\n-static void\n-arabic_fallback_plan_shape (arabic_fallback_plan_t *fallback_plan,\n-                            hb_font_t *font,\n-                            hb_buffer_t *buffer)\n-{\n-  OT::hb_ot_apply_context_t c (0, font, buffer);\n-  for (unsigned int i = 0; i < fallback_plan->num_lookups; i++)\n-    if (fallback_plan->lookup_array[i]) {\n-      c.set_lookup_mask (fallback_plan->mask_array[i]);\n-      hb_ot_layout_substitute_lookup (&c,\n-                                      *fallback_plan->lookup_array[i],\n-                                      fallback_plan->accel_array[i]);\n-    }\n-}\n-\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-arabic-fallback.hh","additions":0,"deletions":348,"binary":false,"changes":348,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/* == Start of generated function == *\/\n-\/*\n- * The following function is generated by running:\n- *\n- *   .\/gen-arabic-joining-list.py ArabicShaping.txt Scripts.txt\n- *\n- * on files with these headers:\n- *\n- * # ArabicShaping-13.0.0.txt\n- * # Date: 2020-01-31, 23:55:00 GMT [KW, RP]\n- * # Scripts-13.0.0.txt\n- * # Date: 2020-01-22, 00:07:43 GMT\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_JOINING_LIST_HH\n-#define HB_OT_SHAPE_COMPLEX_ARABIC_JOINING_LIST_HH\n-\n-static bool\n-has_arabic_joining (hb_script_t script)\n-{\n-  \/* List of scripts that have data in arabic-table. *\/\n-  switch ((int) script)\n-  {\n-    case HB_SCRIPT_ADLAM:\n-    case HB_SCRIPT_ARABIC:\n-    case HB_SCRIPT_CHORASMIAN:\n-    case HB_SCRIPT_HANIFI_ROHINGYA:\n-    case HB_SCRIPT_MANDAIC:\n-    case HB_SCRIPT_MANICHAEAN:\n-    case HB_SCRIPT_MONGOLIAN:\n-    case HB_SCRIPT_NKO:\n-    case HB_SCRIPT_PHAGS_PA:\n-    case HB_SCRIPT_PSALTER_PAHLAVI:\n-    case HB_SCRIPT_SOGDIAN:\n-    case HB_SCRIPT_SYRIAC:\n-      return true;\n-\n-    default:\n-      return false;\n-  }\n-}\n-\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_ARABIC_JOINING_LIST_HH *\/\n-\n-\/* == End of generated function == *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-arabic-joining-list.hh","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,433 +0,0 @@\n-\/* == Start of generated table == *\/\n-\/*\n- * The following table is generated by running:\n- *\n- *   .\/gen-arabic-table.py ArabicShaping.txt UnicodeData.txt Blocks.txt\n- *\n- * on files with these headers:\n- *\n- * # ArabicShaping-13.0.0.txt\n- * # Date: 2020-01-31, 23:55:00 GMT [KW, RP]\n- * # Blocks-13.0.0.txt\n- * # Date: 2019-07-10, 19:06:00 GMT [KW]\n- * UnicodeData.txt does not have a header.\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH\n-#define HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH\n-\n-\n-#define A       JOINING_GROUP_ALAPH\n-#define DR      JOINING_GROUP_DALATH_RISH\n-#define C       JOINING_TYPE_C\n-#define D       JOINING_TYPE_D\n-#define L       JOINING_TYPE_L\n-#define R       JOINING_TYPE_R\n-#define T       JOINING_TYPE_T\n-#define U       JOINING_TYPE_U\n-#define X       JOINING_TYPE_X\n-\n-static const uint8_t joining_table[] =\n-{\n-\n-#define joining_offset_0x0600u 0\n-\n-  \/* Arabic *\/\n-\n-  \/* 0600 *\/ U,U,U,U,U,U,X,X,U,X,X,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 0620 *\/ D,U,R,R,R,R,D,R,D,R,D,D,D,D,D,R,R,R,R,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 0640 *\/ C,D,D,D,D,D,D,D,R,D,D,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 0660 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,D,D,X,R,R,R,U,R,R,R,D,D,D,D,D,D,D,D,\n-  \/* 0680 *\/ D,D,D,D,D,D,D,D,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,D,D,D,D,D,D,\n-  \/* 06A0 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 06C0 *\/ R,D,D,R,R,R,R,R,R,R,R,R,D,R,D,R,D,D,R,R,X,R,X,X,X,X,X,X,X,U,X,X,\n-  \/* 06E0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,R,R,X,X,X,X,X,X,X,X,X,X,D,D,D,X,X,D,\n-\n-  \/* Syriac *\/\n-\n-  \/* 0700 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,T,A,X,D,D,D,DR,DR,R,R,R,D,D,D,D,R,D,\n-  \/* 0720 *\/ D,D,D,D,D,D,D,D,R,D,DR,D,R,D,D,DR,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 0740 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,R,D,D,\n-\n-  \/* Arabic Supplement *\/\n-\n-  \/* 0740 *\/                                 D,D,D,D,D,D,D,D,D,R,R,R,D,D,D,D,\n-  \/* 0760 *\/ D,D,D,D,D,D,D,D,D,D,D,R,R,D,D,D,D,R,D,R,R,D,D,D,R,R,D,D,D,D,D,D,\n-\n-  \/* FILLER *\/\n-\n-  \/* 0780 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 07A0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-\n-  \/* NKo *\/\n-\n-  \/* 07C0 *\/ X,X,X,X,X,X,X,X,X,X,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 07E0 *\/ D,D,D,D,D,D,D,D,D,D,D,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,C,X,X,X,X,X,\n-\n-  \/* FILLER *\/\n-\n-  \/* 0800 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 0820 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-\n-  \/* Mandaic *\/\n-\n-  \/* 0840 *\/ R,D,D,D,D,D,R,R,D,R,D,D,D,D,D,D,D,D,D,D,R,D,R,R,R,X,X,X,X,X,X,X,\n-\n-  \/* Syriac Supplement *\/\n-\n-  \/* 0860 *\/ D,U,D,D,D,D,U,R,D,R,R,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 0880 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-\n-  \/* Arabic Extended-A *\/\n-\n-  \/* 08A0 *\/ D,D,D,D,D,D,D,D,D,D,R,R,R,U,R,D,D,R,R,D,D,X,D,D,D,R,D,D,D,D,D,D,\n-  \/* 08C0 *\/ D,D,D,D,D,D,D,D,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 08E0 *\/ X,X,U,\n-\n-#define joining_offset_0x1806u 739\n-\n-  \/* Mongolian *\/\n-\n-  \/* 1800 *\/             U,D,X,X,C,X,X,X,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 1820 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 1840 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 1860 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,X,X,X,X,X,X,X,\n-  \/* 1880 *\/ U,U,U,U,U,T,T,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 18A0 *\/ D,D,D,D,D,D,D,D,D,X,D,\n-\n-#define joining_offset_0x200cu 904\n-\n-  \/* General Punctuation *\/\n-\n-  \/* 2000 *\/                         U,C,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 2020 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 2040 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 2060 *\/ X,X,X,X,X,X,U,U,U,U,\n-\n-#define joining_offset_0xa840u 998\n-\n-  \/* Phags-pa *\/\n-\n-  \/* A840 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* A860 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,L,U,\n-\n-#define joining_offset_0x10ac0u 1050\n-\n-  \/* Manichaean *\/\n-\n-  \/* 10AC0 *\/ D,D,D,D,D,R,U,R,U,R,R,U,U,L,R,R,R,R,R,D,D,D,D,L,D,D,D,D,D,R,D,D,\n-  \/* 10AE0 *\/ D,R,U,U,R,X,X,X,X,X,X,D,D,D,D,R,\n-\n-#define joining_offset_0x10b80u 1098\n-\n-  \/* Psalter Pahlavi *\/\n-\n-  \/* 10B80 *\/ D,R,D,R,R,R,D,D,D,R,D,D,R,D,R,R,D,R,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n-  \/* 10BA0 *\/ X,X,X,X,X,X,X,X,X,R,R,R,R,D,D,U,\n-\n-#define joining_offset_0x10d00u 1146\n-\n-  \/* Hanifi Rohingya *\/\n-\n-  \/* 10D00 *\/ L,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 10D20 *\/ D,D,R,D,\n-\n-#define joining_offset_0x10f30u 1182\n-\n-  \/* Sogdian *\/\n-\n-  \/* 10F20 *\/                                 D,D,D,R,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 10F40 *\/ D,D,D,D,D,U,X,X,X,X,X,X,X,X,X,X,X,D,D,D,R,\n-\n-#define joining_offset_0x10fb0u 1219\n-\n-  \/* Chorasmian *\/\n-\n-  \/* 10FA0 *\/                                 D,U,D,D,R,R,R,U,D,R,R,D,D,R,D,D,\n-  \/* 10FC0 *\/ U,D,R,R,D,U,U,U,U,R,D,L,\n-\n-#define joining_offset_0x110bdu 1247\n-\n-  \/* Kaithi *\/\n-\n-  \/* 110A0 *\/                                                           U,X,X,\n-  \/* 110C0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,U,\n-\n-#define joining_offset_0x1e900u 1264\n-\n-  \/* Adlam *\/\n-\n-  \/* 1E900 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 1E920 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n-  \/* 1E940 *\/ D,D,D,D,X,X,X,X,X,X,X,T,\n-\n-}; \/* Table items: 1340; occupancy: 57% *\/\n-\n-\n-static unsigned int\n-joining_type (hb_codepoint_t u)\n-{\n-  switch (u >> 12)\n-  {\n-    case 0x0u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0600u, 0x08E2u)) return joining_table[u - 0x0600u + joining_offset_0x0600u];\n-      break;\n-\n-    case 0x1u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1806u, 0x18AAu)) return joining_table[u - 0x1806u + joining_offset_0x1806u];\n-      break;\n-\n-    case 0x2u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x200Cu, 0x2069u)) return joining_table[u - 0x200Cu + joining_offset_0x200cu];\n-      break;\n-\n-    case 0xAu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0xA840u, 0xA873u)) return joining_table[u - 0xA840u + joining_offset_0xa840u];\n-      break;\n-\n-    case 0x10u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10AC0u, 0x10AEFu)) return joining_table[u - 0x10AC0u + joining_offset_0x10ac0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10B80u, 0x10BAFu)) return joining_table[u - 0x10B80u + joining_offset_0x10b80u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10D00u, 0x10D23u)) return joining_table[u - 0x10D00u + joining_offset_0x10d00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10F30u, 0x10F54u)) return joining_table[u - 0x10F30u + joining_offset_0x10f30u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10FB0u, 0x10FCBu)) return joining_table[u - 0x10FB0u + joining_offset_0x10fb0u];\n-      break;\n-\n-    case 0x11u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x110BDu, 0x110CDu)) return joining_table[u - 0x110BDu + joining_offset_0x110bdu];\n-      break;\n-\n-    case 0x1Eu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1E900u, 0x1E94Bu)) return joining_table[u - 0x1E900u + joining_offset_0x1e900u];\n-      break;\n-\n-    default:\n-      break;\n-  }\n-  return X;\n-}\n-\n-#undef A\n-#undef DR\n-#undef C\n-#undef D\n-#undef L\n-#undef R\n-#undef T\n-#undef U\n-#undef X\n-\n-\n-static const uint16_t shaping_table[][4] =\n-{\n-  {0x0000u, 0x0000u, 0x0000u, 0xFE80u}, \/* U+0621 ARABIC LETTER HAMZA ISOLATED FORM *\/\n-  {0x0000u, 0x0000u, 0xFE82u, 0xFE81u}, \/* U+0622 ARABIC LETTER ALEF WITH MADDA ABOVE *\/\n-  {0x0000u, 0x0000u, 0xFE84u, 0xFE83u}, \/* U+0623 ARABIC LETTER ALEF WITH HAMZA ABOVE *\/\n-  {0x0000u, 0x0000u, 0xFE86u, 0xFE85u}, \/* U+0624 ARABIC LETTER WAW WITH HAMZA ABOVE *\/\n-  {0x0000u, 0x0000u, 0xFE88u, 0xFE87u}, \/* U+0625 ARABIC LETTER ALEF WITH HAMZA BELOW *\/\n-  {0xFE8Bu, 0xFE8Cu, 0xFE8Au, 0xFE89u}, \/* U+0626 ARABIC LETTER YEH WITH HAMZA ABOVE *\/\n-  {0x0000u, 0x0000u, 0xFE8Eu, 0xFE8Du}, \/* U+0627 ARABIC LETTER ALEF *\/\n-  {0xFE91u, 0xFE92u, 0xFE90u, 0xFE8Fu}, \/* U+0628 ARABIC LETTER BEH *\/\n-  {0x0000u, 0x0000u, 0xFE94u, 0xFE93u}, \/* U+0629 ARABIC LETTER TEH MARBUTA *\/\n-  {0xFE97u, 0xFE98u, 0xFE96u, 0xFE95u}, \/* U+062A ARABIC LETTER TEH *\/\n-  {0xFE9Bu, 0xFE9Cu, 0xFE9Au, 0xFE99u}, \/* U+062B ARABIC LETTER THEH *\/\n-  {0xFE9Fu, 0xFEA0u, 0xFE9Eu, 0xFE9Du}, \/* U+062C ARABIC LETTER JEEM *\/\n-  {0xFEA3u, 0xFEA4u, 0xFEA2u, 0xFEA1u}, \/* U+062D ARABIC LETTER HAH *\/\n-  {0xFEA7u, 0xFEA8u, 0xFEA6u, 0xFEA5u}, \/* U+062E ARABIC LETTER KHAH *\/\n-  {0x0000u, 0x0000u, 0xFEAAu, 0xFEA9u}, \/* U+062F ARABIC LETTER DAL *\/\n-  {0x0000u, 0x0000u, 0xFEACu, 0xFEABu}, \/* U+0630 ARABIC LETTER THAL *\/\n-  {0x0000u, 0x0000u, 0xFEAEu, 0xFEADu}, \/* U+0631 ARABIC LETTER REH *\/\n-  {0x0000u, 0x0000u, 0xFEB0u, 0xFEAFu}, \/* U+0632 ARABIC LETTER ZAIN *\/\n-  {0xFEB3u, 0xFEB4u, 0xFEB2u, 0xFEB1u}, \/* U+0633 ARABIC LETTER SEEN *\/\n-  {0xFEB7u, 0xFEB8u, 0xFEB6u, 0xFEB5u}, \/* U+0634 ARABIC LETTER SHEEN *\/\n-  {0xFEBBu, 0xFEBCu, 0xFEBAu, 0xFEB9u}, \/* U+0635 ARABIC LETTER SAD *\/\n-  {0xFEBFu, 0xFEC0u, 0xFEBEu, 0xFEBDu}, \/* U+0636 ARABIC LETTER DAD *\/\n-  {0xFEC3u, 0xFEC4u, 0xFEC2u, 0xFEC1u}, \/* U+0637 ARABIC LETTER TAH *\/\n-  {0xFEC7u, 0xFEC8u, 0xFEC6u, 0xFEC5u}, \/* U+0638 ARABIC LETTER ZAH *\/\n-  {0xFECBu, 0xFECCu, 0xFECAu, 0xFEC9u}, \/* U+0639 ARABIC LETTER AIN *\/\n-  {0xFECFu, 0xFED0u, 0xFECEu, 0xFECDu}, \/* U+063A ARABIC LETTER GHAIN *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063B  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063C  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063D  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063E  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063F  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0640  *\/\n-  {0xFED3u, 0xFED4u, 0xFED2u, 0xFED1u}, \/* U+0641 ARABIC LETTER FEH *\/\n-  {0xFED7u, 0xFED8u, 0xFED6u, 0xFED5u}, \/* U+0642 ARABIC LETTER QAF *\/\n-  {0xFEDBu, 0xFEDCu, 0xFEDAu, 0xFED9u}, \/* U+0643 ARABIC LETTER KAF *\/\n-  {0xFEDFu, 0xFEE0u, 0xFEDEu, 0xFEDDu}, \/* U+0644 ARABIC LETTER LAM *\/\n-  {0xFEE3u, 0xFEE4u, 0xFEE2u, 0xFEE1u}, \/* U+0645 ARABIC LETTER MEEM *\/\n-  {0xFEE7u, 0xFEE8u, 0xFEE6u, 0xFEE5u}, \/* U+0646 ARABIC LETTER NOON *\/\n-  {0xFEEBu, 0xFEECu, 0xFEEAu, 0xFEE9u}, \/* U+0647 ARABIC LETTER HEH *\/\n-  {0x0000u, 0x0000u, 0xFEEEu, 0xFEEDu}, \/* U+0648 ARABIC LETTER WAW *\/\n-  {0xFBE8u, 0xFBE9u, 0xFEF0u, 0xFEEFu}, \/* U+0649 ARABIC LETTER *\/\n-  {0xFEF3u, 0xFEF4u, 0xFEF2u, 0xFEF1u}, \/* U+064A ARABIC LETTER YEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064B  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064C  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064D  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064E  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064F  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0650  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0651  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0652  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0653  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0654  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0655  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0656  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0657  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0658  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0659  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065A  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065B  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065C  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065D  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065E  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065F  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0660  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0661  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0662  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0663  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0664  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0665  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0666  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0667  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0668  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0669  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066A  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066B  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066C  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066D  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066E  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066F  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0670  *\/\n-  {0x0000u, 0x0000u, 0xFB51u, 0xFB50u}, \/* U+0671 ARABIC LETTER ALEF WASLA *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0672  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0673  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0674  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0675  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0676  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0xFBDDu}, \/* U+0677 ARABIC LETTER U WITH HAMZA ABOVE ISOLATED FORM *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0678  *\/\n-  {0xFB68u, 0xFB69u, 0xFB67u, 0xFB66u}, \/* U+0679 ARABIC LETTER TTEH *\/\n-  {0xFB60u, 0xFB61u, 0xFB5Fu, 0xFB5Eu}, \/* U+067A ARABIC LETTER TTEHEH *\/\n-  {0xFB54u, 0xFB55u, 0xFB53u, 0xFB52u}, \/* U+067B ARABIC LETTER BEEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+067C  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+067D  *\/\n-  {0xFB58u, 0xFB59u, 0xFB57u, 0xFB56u}, \/* U+067E ARABIC LETTER PEH *\/\n-  {0xFB64u, 0xFB65u, 0xFB63u, 0xFB62u}, \/* U+067F ARABIC LETTER TEHEH *\/\n-  {0xFB5Cu, 0xFB5Du, 0xFB5Bu, 0xFB5Au}, \/* U+0680 ARABIC LETTER BEHEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0681  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0682  *\/\n-  {0xFB78u, 0xFB79u, 0xFB77u, 0xFB76u}, \/* U+0683 ARABIC LETTER NYEH *\/\n-  {0xFB74u, 0xFB75u, 0xFB73u, 0xFB72u}, \/* U+0684 ARABIC LETTER DYEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0685  *\/\n-  {0xFB7Cu, 0xFB7Du, 0xFB7Bu, 0xFB7Au}, \/* U+0686 ARABIC LETTER TCHEH *\/\n-  {0xFB80u, 0xFB81u, 0xFB7Fu, 0xFB7Eu}, \/* U+0687 ARABIC LETTER TCHEHEH *\/\n-  {0x0000u, 0x0000u, 0xFB89u, 0xFB88u}, \/* U+0688 ARABIC LETTER DDAL *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0689  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+068A  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+068B  *\/\n-  {0x0000u, 0x0000u, 0xFB85u, 0xFB84u}, \/* U+068C ARABIC LETTER DAHAL *\/\n-  {0x0000u, 0x0000u, 0xFB83u, 0xFB82u}, \/* U+068D ARABIC LETTER DDAHAL *\/\n-  {0x0000u, 0x0000u, 0xFB87u, 0xFB86u}, \/* U+068E ARABIC LETTER DUL *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+068F  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0690  *\/\n-  {0x0000u, 0x0000u, 0xFB8Du, 0xFB8Cu}, \/* U+0691 ARABIC LETTER RREH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0692  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0693  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0694  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0695  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0696  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0697  *\/\n-  {0x0000u, 0x0000u, 0xFB8Bu, 0xFB8Au}, \/* U+0698 ARABIC LETTER JEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0699  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069A  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069B  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069C  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069D  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069E  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069F  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A0  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A1  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A2  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A3  *\/\n-  {0xFB6Cu, 0xFB6Du, 0xFB6Bu, 0xFB6Au}, \/* U+06A4 ARABIC LETTER VEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A5  *\/\n-  {0xFB70u, 0xFB71u, 0xFB6Fu, 0xFB6Eu}, \/* U+06A6 ARABIC LETTER PEHEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A7  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A8  *\/\n-  {0xFB90u, 0xFB91u, 0xFB8Fu, 0xFB8Eu}, \/* U+06A9 ARABIC LETTER KEHEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AA  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AB  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AC  *\/\n-  {0xFBD5u, 0xFBD6u, 0xFBD4u, 0xFBD3u}, \/* U+06AD ARABIC LETTER NG *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AE  *\/\n-  {0xFB94u, 0xFB95u, 0xFB93u, 0xFB92u}, \/* U+06AF ARABIC LETTER GAF *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B0  *\/\n-  {0xFB9Cu, 0xFB9Du, 0xFB9Bu, 0xFB9Au}, \/* U+06B1 ARABIC LETTER NGOEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B2  *\/\n-  {0xFB98u, 0xFB99u, 0xFB97u, 0xFB96u}, \/* U+06B3 ARABIC LETTER GUEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B4  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B5  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B6  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B7  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B8  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B9  *\/\n-  {0x0000u, 0x0000u, 0xFB9Fu, 0xFB9Eu}, \/* U+06BA ARABIC LETTER NOON GHUNNA *\/\n-  {0xFBA2u, 0xFBA3u, 0xFBA1u, 0xFBA0u}, \/* U+06BB ARABIC LETTER RNOON *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06BC  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06BD  *\/\n-  {0xFBACu, 0xFBADu, 0xFBABu, 0xFBAAu}, \/* U+06BE ARABIC LETTER HEH DOACHASHMEE *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06BF  *\/\n-  {0x0000u, 0x0000u, 0xFBA5u, 0xFBA4u}, \/* U+06C0 ARABIC LETTER HEH WITH YEH ABOVE *\/\n-  {0xFBA8u, 0xFBA9u, 0xFBA7u, 0xFBA6u}, \/* U+06C1 ARABIC LETTER HEH GOAL *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06C2  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06C3  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06C4  *\/\n-  {0x0000u, 0x0000u, 0xFBE1u, 0xFBE0u}, \/* U+06C5 ARABIC LETTER KIRGHIZ OE *\/\n-  {0x0000u, 0x0000u, 0xFBDAu, 0xFBD9u}, \/* U+06C6 ARABIC LETTER OE *\/\n-  {0x0000u, 0x0000u, 0xFBD8u, 0xFBD7u}, \/* U+06C7 ARABIC LETTER U *\/\n-  {0x0000u, 0x0000u, 0xFBDCu, 0xFBDBu}, \/* U+06C8 ARABIC LETTER YU *\/\n-  {0x0000u, 0x0000u, 0xFBE3u, 0xFBE2u}, \/* U+06C9 ARABIC LETTER KIRGHIZ YU *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CA  *\/\n-  {0x0000u, 0x0000u, 0xFBDFu, 0xFBDEu}, \/* U+06CB ARABIC LETTER VE *\/\n-  {0xFBFEu, 0xFBFFu, 0xFBFDu, 0xFBFCu}, \/* U+06CC ARABIC LETTER FARSI YEH *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CD  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CE  *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CF  *\/\n-  {0xFBE6u, 0xFBE7u, 0xFBE5u, 0xFBE4u}, \/* U+06D0 ARABIC LETTER E *\/\n-  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06D1  *\/\n-  {0x0000u, 0x0000u, 0xFBAFu, 0xFBAEu}, \/* U+06D2 ARABIC LETTER YEH BARREE *\/\n-  {0x0000u, 0x0000u, 0xFBB1u, 0xFBB0u}, \/* U+06D3 ARABIC LETTER YEH BARREE WITH HAMZA ABOVE *\/\n-};\n-\n-#define SHAPING_TABLE_FIRST     0x0621u\n-#define SHAPING_TABLE_LAST      0x06D3u\n-\n-\n-static const struct ligature_set_t {\n- uint16_t first;\n- struct ligature_pairs_t {\n-   uint16_t second;\n-   uint16_t ligature;\n- } ligatures[4];\n-} ligature_table[] =\n-{\n-  { 0xFEDFu, {\n-    { 0xFE82u, 0xFEF5u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE ISOLATED FORM *\/\n-    { 0xFE84u, 0xFEF7u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE ISOLATED FORM *\/\n-    { 0xFE88u, 0xFEF9u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW ISOLATED FORM *\/\n-    { 0xFE8Eu, 0xFEFBu }, \/* ARABIC LIGATURE LAM WITH ALEF ISOLATED FORM *\/\n-  }},\n-  { 0xFEE0u, {\n-    { 0xFE82u, 0xFEF6u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE FINAL FORM *\/\n-    { 0xFE84u, 0xFEF8u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE FINAL FORM *\/\n-    { 0xFE88u, 0xFEFAu }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW FINAL FORM *\/\n-    { 0xFE8Eu, 0xFEFCu }, \/* ARABIC LIGATURE LAM WITH ALEF FINAL FORM *\/\n-  }},\n-};\n-\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH *\/\n-\n-\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-arabic-table.hh","additions":0,"deletions":433,"binary":false,"changes":433,"status":"deleted"},{"patch":"@@ -1,603 +0,0 @@\n-\n-#line 1 \"hb-ot-shape-complex-indic-machine.rl\"\n-\/*\n- * Copyright  2011,2012  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH\n-#define HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH\n-\n-#include \"hb.hh\"\n-\n-enum indic_syllable_type_t {\n-  indic_consonant_syllable,\n-  indic_vowel_syllable,\n-  indic_standalone_cluster,\n-  indic_symbol_cluster,\n-  indic_broken_cluster,\n-  indic_non_indic_cluster,\n-};\n-\n-\n-#line 45 \"hb-ot-shape-complex-indic-machine.hh\"\n-#define indic_syllable_machine_ex_A 10u\n-#define indic_syllable_machine_ex_C 1u\n-#define indic_syllable_machine_ex_CM 17u\n-#define indic_syllable_machine_ex_CS 19u\n-#define indic_syllable_machine_ex_DOTTEDCIRCLE 12u\n-#define indic_syllable_machine_ex_H 4u\n-#define indic_syllable_machine_ex_M 7u\n-#define indic_syllable_machine_ex_N 3u\n-#define indic_syllable_machine_ex_PLACEHOLDER 11u\n-#define indic_syllable_machine_ex_RS 13u\n-#define indic_syllable_machine_ex_Ra 16u\n-#define indic_syllable_machine_ex_Repha 15u\n-#define indic_syllable_machine_ex_SM 8u\n-#define indic_syllable_machine_ex_Symbol 18u\n-#define indic_syllable_machine_ex_V 2u\n-#define indic_syllable_machine_ex_ZWJ 6u\n-#define indic_syllable_machine_ex_ZWNJ 5u\n-\n-\n-#line 65 \"hb-ot-shape-complex-indic-machine.hh\"\n-static const unsigned char _indic_syllable_machine_trans_keys[] = {\n-        8u, 8u, 4u, 8u, 5u, 7u, 5u, 8u, 4u, 8u, 6u, 6u, 16u, 16u, 4u, 8u,\n-        4u, 13u, 4u, 8u, 8u, 8u, 5u, 7u, 5u, 8u, 4u, 8u, 6u, 6u, 16u, 16u,\n-        4u, 8u, 4u, 13u, 4u, 13u, 4u, 13u, 8u, 8u, 5u, 7u, 5u, 8u, 4u, 8u,\n-        6u, 6u, 16u, 16u, 4u, 8u, 4u, 8u, 4u, 13u, 8u, 8u, 5u, 7u, 5u, 8u,\n-        4u, 8u, 6u, 6u, 16u, 16u, 4u, 8u, 4u, 8u, 5u, 8u, 8u, 8u, 1u, 19u,\n-        3u, 17u, 3u, 17u, 4u, 17u, 1u, 16u, 5u, 10u, 5u, 10u, 10u, 10u, 5u, 10u,\n-        1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u, 4u, 10u, 5u, 10u, 4u, 10u, 5u, 10u,\n-        3u, 10u, 5u, 10u, 3u, 17u, 3u, 17u, 3u, 17u, 3u, 17u, 4u, 17u, 1u, 16u,\n-        3u, 17u, 3u, 17u, 4u, 17u, 1u, 16u, 5u, 10u, 10u, 10u, 5u, 10u, 1u, 16u,\n-        1u, 16u, 3u, 10u, 4u, 10u, 5u, 10u, 4u, 10u, 5u, 10u, 5u, 10u, 3u, 10u,\n-        5u, 10u, 3u, 17u, 3u, 17u, 4u, 8u, 3u, 17u, 3u, 17u, 4u, 17u, 1u, 16u,\n-        3u, 17u, 1u, 16u, 5u, 10u, 10u, 10u, 5u, 10u, 1u, 16u, 1u, 16u, 3u, 10u,\n-        4u, 10u, 5u, 10u, 3u, 17u, 4u, 10u, 5u, 10u, 5u, 10u, 3u, 10u, 5u, 10u,\n-        3u, 17u, 4u, 13u, 4u, 8u, 3u, 17u, 3u, 17u, 4u, 17u, 1u, 16u, 3u, 17u,\n-        1u, 16u, 5u, 10u, 10u, 10u, 5u, 10u, 1u, 16u, 1u, 16u, 3u, 10u, 4u, 10u,\n-        5u, 10u, 3u, 17u, 4u, 10u, 5u, 10u, 5u, 10u, 3u, 10u, 5u, 10u, 1u, 17u,\n-        3u, 17u, 1u, 17u, 4u, 13u, 5u, 10u, 10u, 10u, 5u, 10u, 1u, 16u, 3u, 10u,\n-        5u, 10u, 5u, 10u, 10u, 10u, 5u, 10u, 1u, 16u, 0\n-};\n-\n-static const char _indic_syllable_machine_key_spans[] = {\n-        1, 5, 3, 4, 5, 1, 1, 5,\n-        10, 5, 1, 3, 4, 5, 1, 1,\n-        5, 10, 10, 10, 1, 3, 4, 5,\n-        1, 1, 5, 5, 10, 1, 3, 4,\n-        5, 1, 1, 5, 5, 4, 1, 19,\n-        15, 15, 14, 16, 6, 6, 1, 6,\n-        16, 16, 16, 8, 7, 6, 7, 6,\n-        8, 6, 15, 15, 15, 15, 14, 16,\n-        15, 15, 14, 16, 6, 1, 6, 16,\n-        16, 8, 7, 6, 7, 6, 6, 8,\n-        6, 15, 15, 5, 15, 15, 14, 16,\n-        15, 16, 6, 1, 6, 16, 16, 8,\n-        7, 6, 15, 7, 6, 6, 8, 6,\n-        15, 10, 5, 15, 15, 14, 16, 15,\n-        16, 6, 1, 6, 16, 16, 8, 7,\n-        6, 15, 7, 6, 6, 8, 6, 17,\n-        15, 17, 10, 6, 1, 6, 16, 8,\n-        6, 6, 1, 6, 16\n-};\n-\n-static const short _indic_syllable_machine_index_offsets[] = {\n-        0, 2, 8, 12, 17, 23, 25, 27,\n-        33, 44, 50, 52, 56, 61, 67, 69,\n-        71, 77, 88, 99, 110, 112, 116, 121,\n-        127, 129, 131, 137, 143, 154, 156, 160,\n-        165, 171, 173, 175, 181, 187, 192, 194,\n-        214, 230, 246, 261, 278, 285, 292, 294,\n-        301, 318, 335, 352, 361, 369, 376, 384,\n-        391, 400, 407, 423, 439, 455, 471, 486,\n-        503, 519, 535, 550, 567, 574, 576, 583,\n-        600, 617, 626, 634, 641, 649, 656, 663,\n-        672, 679, 695, 711, 717, 733, 749, 764,\n-        781, 797, 814, 821, 823, 830, 847, 864,\n-        873, 881, 888, 904, 912, 919, 926, 935,\n-        942, 958, 969, 975, 991, 1007, 1022, 1039,\n-        1055, 1072, 1079, 1081, 1088, 1105, 1122, 1131,\n-        1139, 1146, 1162, 1170, 1177, 1184, 1193, 1200,\n-        1218, 1234, 1252, 1263, 1270, 1272, 1279, 1296,\n-        1305, 1312, 1319, 1321, 1328\n-};\n-\n-static const unsigned char _indic_syllable_machine_indicies[] = {\n-        1, 0, 2, 3, 3, 4, 1, 0,\n-        3, 3, 4, 0, 3, 3, 4, 1,\n-        0, 5, 3, 3, 4, 1, 0, 6,\n-        0, 7, 0, 8, 3, 3, 4, 1,\n-        0, 2, 3, 3, 4, 1, 0, 0,\n-        0, 0, 9, 0, 11, 12, 12, 13,\n-        14, 10, 14, 10, 12, 12, 13, 10,\n-        12, 12, 13, 14, 10, 15, 12, 12,\n-        13, 14, 10, 16, 10, 17, 10, 18,\n-        12, 12, 13, 14, 10, 11, 12, 12,\n-        13, 14, 10, 10, 10, 10, 19, 10,\n-        11, 12, 12, 13, 14, 10, 10, 10,\n-        10, 20, 10, 22, 23, 23, 24, 25,\n-        21, 21, 21, 21, 26, 21, 25, 21,\n-        23, 23, 24, 27, 23, 23, 24, 25,\n-        21, 28, 23, 23, 24, 25, 21, 29,\n-        21, 30, 21, 22, 23, 23, 24, 25,\n-        21, 31, 23, 23, 24, 25, 21, 33,\n-        34, 34, 35, 36, 32, 32, 32, 32,\n-        37, 32, 36, 32, 34, 34, 35, 32,\n-        34, 34, 35, 36, 32, 38, 34, 34,\n-        35, 36, 32, 39, 32, 40, 32, 33,\n-        34, 34, 35, 36, 32, 41, 34, 34,\n-        35, 36, 32, 23, 23, 24, 1, 0,\n-        43, 42, 45, 46, 47, 48, 49, 50,\n-        24, 25, 44, 51, 52, 52, 26, 44,\n-        53, 54, 55, 56, 57, 44, 59, 60,\n-        61, 62, 4, 1, 58, 63, 58, 58,\n-        9, 58, 58, 58, 64, 58, 65, 60,\n-        66, 66, 4, 1, 58, 63, 58, 58,\n-        58, 58, 58, 58, 64, 58, 60, 66,\n-        66, 4, 1, 58, 63, 58, 58, 58,\n-        58, 58, 58, 64, 58, 45, 58, 58,\n-        58, 67, 68, 58, 1, 58, 63, 58,\n-        58, 58, 58, 58, 45, 58, 69, 69,\n-        58, 1, 58, 63, 58, 63, 58, 58,\n-        70, 58, 63, 58, 63, 58, 63, 58,\n-        58, 58, 58, 63, 58, 45, 58, 71,\n-        58, 69, 69, 58, 1, 58, 63, 58,\n-        58, 58, 58, 58, 45, 58, 45, 58,\n-        58, 58, 69, 69, 58, 1, 58, 63,\n-        58, 58, 58, 58, 58, 45, 58, 45,\n-        58, 58, 58, 69, 68, 58, 1, 58,\n-        63, 58, 58, 58, 58, 58, 45, 58,\n-        72, 7, 73, 74, 4, 1, 58, 63,\n-        58, 7, 73, 74, 4, 1, 58, 63,\n-        58, 73, 73, 4, 1, 58, 63, 58,\n-        75, 76, 76, 4, 1, 58, 63, 58,\n-        67, 77, 58, 1, 58, 63, 58, 67,\n-        58, 69, 69, 58, 1, 58, 63, 58,\n-        69, 77, 58, 1, 58, 63, 58, 59,\n-        60, 66, 66, 4, 1, 58, 63, 58,\n-        58, 58, 58, 58, 58, 64, 58, 59,\n-        60, 61, 66, 4, 1, 58, 63, 58,\n-        58, 9, 58, 58, 58, 64, 58, 79,\n-        80, 81, 82, 13, 14, 78, 83, 78,\n-        78, 20, 78, 78, 78, 84, 78, 85,\n-        80, 86, 82, 13, 14, 78, 83, 78,\n-        78, 78, 78, 78, 78, 84, 78, 80,\n-        86, 82, 13, 14, 78, 83, 78, 78,\n-        78, 78, 78, 78, 84, 78, 87, 78,\n-        78, 78, 88, 89, 78, 14, 78, 83,\n-        78, 78, 78, 78, 78, 87, 78, 90,\n-        80, 91, 92, 13, 14, 78, 83, 78,\n-        78, 19, 78, 78, 78, 84, 78, 93,\n-        80, 86, 86, 13, 14, 78, 83, 78,\n-        78, 78, 78, 78, 78, 84, 78, 80,\n-        86, 86, 13, 14, 78, 83, 78, 78,\n-        78, 78, 78, 78, 84, 78, 87, 78,\n-        78, 78, 94, 89, 78, 14, 78, 83,\n-        78, 78, 78, 78, 78, 87, 78, 83,\n-        78, 78, 95, 78, 83, 78, 83, 78,\n-        83, 78, 78, 78, 78, 83, 78, 87,\n-        78, 96, 78, 94, 94, 78, 14, 78,\n-        83, 78, 78, 78, 78, 78, 87, 78,\n-        87, 78, 78, 78, 94, 94, 78, 14,\n-        78, 83, 78, 78, 78, 78, 78, 87,\n-        78, 97, 17, 98, 99, 13, 14, 78,\n-        83, 78, 17, 98, 99, 13, 14, 78,\n-        83, 78, 98, 98, 13, 14, 78, 83,\n-        78, 100, 101, 101, 13, 14, 78, 83,\n-        78, 88, 102, 78, 14, 78, 83, 78,\n-        94, 94, 78, 14, 78, 83, 78, 88,\n-        78, 94, 94, 78, 14, 78, 83, 78,\n-        94, 102, 78, 14, 78, 83, 78, 90,\n-        80, 86, 86, 13, 14, 78, 83, 78,\n-        78, 78, 78, 78, 78, 84, 78, 90,\n-        80, 91, 86, 13, 14, 78, 83, 78,\n-        78, 19, 78, 78, 78, 84, 78, 11,\n-        12, 12, 13, 14, 78, 79, 80, 86,\n-        82, 13, 14, 78, 83, 78, 78, 78,\n-        78, 78, 78, 84, 78, 104, 48, 105,\n-        105, 24, 25, 103, 51, 103, 103, 103,\n-        103, 103, 103, 55, 103, 48, 105, 105,\n-        24, 25, 103, 51, 103, 103, 103, 103,\n-        103, 103, 55, 103, 106, 103, 103, 103,\n-        107, 108, 103, 25, 103, 51, 103, 103,\n-        103, 103, 103, 106, 103, 47, 48, 109,\n-        110, 24, 25, 103, 51, 103, 103, 26,\n-        103, 103, 103, 55, 103, 106, 103, 103,\n-        103, 111, 108, 103, 25, 103, 51, 103,\n-        103, 103, 103, 103, 106, 103, 51, 103,\n-        103, 112, 103, 51, 103, 51, 103, 51,\n-        103, 103, 103, 103, 51, 103, 106, 103,\n-        113, 103, 111, 111, 103, 25, 103, 51,\n-        103, 103, 103, 103, 103, 106, 103, 106,\n-        103, 103, 103, 111, 111, 103, 25, 103,\n-        51, 103, 103, 103, 103, 103, 106, 103,\n-        114, 30, 115, 116, 24, 25, 103, 51,\n-        103, 30, 115, 116, 24, 25, 103, 51,\n-        103, 115, 115, 24, 25, 103, 51, 103,\n-        47, 48, 105, 105, 24, 25, 103, 51,\n-        103, 103, 103, 103, 103, 103, 55, 103,\n-        117, 118, 118, 24, 25, 103, 51, 103,\n-        107, 119, 103, 25, 103, 51, 103, 111,\n-        111, 103, 25, 103, 51, 103, 107, 103,\n-        111, 111, 103, 25, 103, 51, 103, 111,\n-        119, 103, 25, 103, 51, 103, 47, 48,\n-        109, 105, 24, 25, 103, 51, 103, 103,\n-        26, 103, 103, 103, 55, 103, 22, 23,\n-        23, 24, 25, 120, 120, 120, 120, 26,\n-        120, 22, 23, 23, 24, 25, 120, 122,\n-        123, 124, 125, 35, 36, 121, 126, 121,\n-        121, 37, 121, 121, 121, 127, 121, 128,\n-        123, 125, 125, 35, 36, 121, 126, 121,\n-        121, 121, 121, 121, 121, 127, 121, 123,\n-        125, 125, 35, 36, 121, 126, 121, 121,\n-        121, 121, 121, 121, 127, 121, 129, 121,\n-        121, 121, 130, 131, 121, 36, 121, 126,\n-        121, 121, 121, 121, 121, 129, 121, 122,\n-        123, 124, 52, 35, 36, 121, 126, 121,\n-        121, 37, 121, 121, 121, 127, 121, 129,\n-        121, 121, 121, 132, 131, 121, 36, 121,\n-        126, 121, 121, 121, 121, 121, 129, 121,\n-        126, 121, 121, 133, 121, 126, 121, 126,\n-        121, 126, 121, 121, 121, 121, 126, 121,\n-        129, 121, 134, 121, 132, 132, 121, 36,\n-        121, 126, 121, 121, 121, 121, 121, 129,\n-        121, 129, 121, 121, 121, 132, 132, 121,\n-        36, 121, 126, 121, 121, 121, 121, 121,\n-        129, 121, 135, 40, 136, 137, 35, 36,\n-        121, 126, 121, 40, 136, 137, 35, 36,\n-        121, 126, 121, 136, 136, 35, 36, 121,\n-        126, 121, 122, 123, 125, 125, 35, 36,\n-        121, 126, 121, 121, 121, 121, 121, 121,\n-        127, 121, 138, 139, 139, 35, 36, 121,\n-        126, 121, 130, 140, 121, 36, 121, 126,\n-        121, 132, 132, 121, 36, 121, 126, 121,\n-        130, 121, 132, 132, 121, 36, 121, 126,\n-        121, 132, 140, 121, 36, 121, 126, 121,\n-        45, 46, 47, 48, 109, 105, 24, 25,\n-        103, 51, 52, 52, 26, 103, 103, 45,\n-        55, 103, 59, 141, 61, 62, 4, 1,\n-        58, 63, 58, 58, 9, 58, 58, 58,\n-        64, 58, 45, 46, 47, 48, 142, 143,\n-        24, 144, 58, 145, 58, 52, 26, 58,\n-        58, 45, 55, 58, 22, 146, 146, 24,\n-        144, 58, 63, 58, 58, 26, 58, 145,\n-        58, 58, 147, 58, 145, 58, 145, 58,\n-        145, 58, 58, 58, 58, 145, 58, 45,\n-        58, 71, 22, 146, 146, 24, 144, 58,\n-        63, 58, 58, 58, 58, 58, 45, 58,\n-        149, 148, 150, 150, 148, 43, 148, 151,\n-        148, 150, 150, 148, 43, 148, 151, 148,\n-        151, 148, 148, 152, 148, 151, 148, 151,\n-        148, 151, 148, 148, 148, 148, 151, 148,\n-        45, 120, 120, 120, 120, 120, 120, 120,\n-        120, 120, 52, 120, 120, 120, 120, 45,\n-        120, 0\n-};\n-\n-static const unsigned char _indic_syllable_machine_trans_targs[] = {\n-        39, 45, 50, 2, 51, 5, 6, 53,\n-        57, 58, 39, 67, 11, 73, 68, 14,\n-        15, 75, 80, 81, 84, 39, 89, 21,\n-        95, 90, 98, 39, 24, 25, 97, 103,\n-        39, 112, 30, 118, 113, 121, 33, 34,\n-        120, 126, 39, 137, 39, 40, 60, 85,\n-        87, 105, 106, 91, 107, 127, 128, 99,\n-        135, 140, 39, 41, 43, 8, 59, 46,\n-        54, 42, 1, 44, 48, 0, 47, 49,\n-        52, 3, 4, 55, 7, 56, 39, 61,\n-        63, 18, 83, 69, 76, 62, 9, 64,\n-        78, 71, 65, 17, 82, 66, 10, 70,\n-        72, 74, 12, 13, 77, 16, 79, 39,\n-        86, 26, 88, 101, 93, 19, 104, 20,\n-        92, 94, 96, 22, 23, 100, 27, 102,\n-        39, 39, 108, 110, 28, 35, 114, 122,\n-        109, 111, 124, 116, 29, 115, 117, 119,\n-        31, 32, 123, 36, 125, 129, 130, 134,\n-        131, 132, 37, 133, 39, 136, 38, 138,\n-        139\n-};\n-\n-static const char _indic_syllable_machine_trans_actions[] = {\n-        1, 0, 2, 0, 2, 0, 0, 2,\n-        2, 2, 3, 2, 0, 2, 0, 0,\n-        0, 2, 2, 2, 2, 4, 2, 0,\n-        5, 0, 5, 6, 0, 0, 5, 2,\n-        7, 2, 0, 2, 0, 2, 0, 0,\n-        2, 2, 8, 0, 11, 2, 2, 5,\n-        0, 12, 12, 0, 2, 5, 2, 5,\n-        2, 0, 13, 2, 0, 0, 2, 0,\n-        2, 2, 0, 2, 2, 0, 0, 2,\n-        2, 0, 0, 0, 0, 2, 14, 2,\n-        0, 0, 2, 0, 2, 2, 0, 2,\n-        2, 2, 2, 0, 2, 2, 0, 0,\n-        2, 2, 0, 0, 0, 0, 2, 15,\n-        5, 0, 5, 2, 2, 0, 5, 0,\n-        0, 2, 5, 0, 0, 0, 0, 2,\n-        16, 17, 2, 0, 0, 0, 0, 2,\n-        2, 2, 2, 2, 0, 0, 2, 2,\n-        0, 0, 0, 0, 2, 0, 18, 18,\n-        0, 0, 0, 0, 19, 2, 0, 0,\n-        0\n-};\n-\n-static const char _indic_syllable_machine_to_state_actions[] = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 9,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0\n-};\n-\n-static const char _indic_syllable_machine_from_state_actions[] = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 10,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0\n-};\n-\n-static const short _indic_syllable_machine_eof_trans[] = {\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 11, 11, 11, 11, 11, 11, 11,\n-        11, 11, 11, 22, 22, 28, 22, 22,\n-        22, 22, 22, 22, 33, 33, 33, 33,\n-        33, 33, 33, 33, 33, 1, 43, 0,\n-        59, 59, 59, 59, 59, 59, 59, 59,\n-        59, 59, 59, 59, 59, 59, 59, 59,\n-        59, 59, 59, 59, 79, 79, 79, 79,\n-        79, 79, 79, 79, 79, 79, 79, 79,\n-        79, 79, 79, 79, 79, 79, 79, 79,\n-        79, 79, 79, 79, 79, 104, 104, 104,\n-        104, 104, 104, 104, 104, 104, 104, 104,\n-        104, 104, 104, 104, 104, 104, 104, 104,\n-        104, 121, 121, 122, 122, 122, 122, 122,\n-        122, 122, 122, 122, 122, 122, 122, 122,\n-        122, 122, 122, 122, 122, 122, 122, 104,\n-        59, 59, 59, 59, 59, 59, 59, 149,\n-        149, 149, 149, 149, 121\n-};\n-\n-static const int indic_syllable_machine_start = 39;\n-static const int indic_syllable_machine_first_final = 39;\n-static const int indic_syllable_machine_error = -1;\n-\n-static const int indic_syllable_machine_en_main = 39;\n-\n-\n-#line 46 \"hb-ot-shape-complex-indic-machine.rl\"\n-\n-\n-\n-#line 102 \"hb-ot-shape-complex-indic-machine.rl\"\n-\n-\n-#define found_syllable(syllable_type) \\\n-  HB_STMT_START { \\\n-    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n-    for (unsigned int i = ts; i < te; i++) \\\n-      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n-    syllable_serial++; \\\n-    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n-  } HB_STMT_END\n-\n-static void\n-find_syllables_indic (hb_buffer_t *buffer)\n-{\n-  unsigned int p, pe, eof, ts, te, act;\n-  int cs;\n-  hb_glyph_info_t *info = buffer->info;\n-\n-#line 440 \"hb-ot-shape-complex-indic-machine.hh\"\n-        {\n-        cs = indic_syllable_machine_start;\n-        ts = 0;\n-        te = 0;\n-        act = 0;\n-        }\n-\n-#line 122 \"hb-ot-shape-complex-indic-machine.rl\"\n-\n-\n-  p = 0;\n-  pe = eof = buffer->len;\n-\n-  unsigned int syllable_serial = 1;\n-\n-#line 456 \"hb-ot-shape-complex-indic-machine.hh\"\n-        {\n-        int _slen;\n-        int _trans;\n-        const unsigned char *_keys;\n-        const unsigned char *_inds;\n-        if ( p == pe )\n-                goto _test_eof;\n-_resume:\n-        switch ( _indic_syllable_machine_from_state_actions[cs] ) {\n-        case 10:\n-#line 1 \"NONE\"\n-        {ts = p;}\n-        break;\n-#line 470 \"hb-ot-shape-complex-indic-machine.hh\"\n-        }\n-\n-        _keys = _indic_syllable_machine_trans_keys + (cs<<1);\n-        _inds = _indic_syllable_machine_indicies + _indic_syllable_machine_index_offsets[cs];\n-\n-        _slen = _indic_syllable_machine_key_spans[cs];\n-        _trans = _inds[ _slen > 0 && _keys[0] <=( info[p].indic_category()) &&\n-                ( info[p].indic_category()) <= _keys[1] ?\n-                ( info[p].indic_category()) - _keys[0] : _slen ];\n-\n-_eof_trans:\n-        cs = _indic_syllable_machine_trans_targs[_trans];\n-\n-        if ( _indic_syllable_machine_trans_actions[_trans] == 0 )\n-                goto _again;\n-\n-        switch ( _indic_syllable_machine_trans_actions[_trans] ) {\n-        case 2:\n-#line 1 \"NONE\"\n-        {te = p+1;}\n-        break;\n-        case 11:\n-#line 98 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {te = p+1;{ found_syllable (indic_non_indic_cluster); }}\n-        break;\n-        case 13:\n-#line 93 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {te = p;p--;{ found_syllable (indic_consonant_syllable); }}\n-        break;\n-        case 14:\n-#line 94 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {te = p;p--;{ found_syllable (indic_vowel_syllable); }}\n-        break;\n-        case 17:\n-#line 95 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {te = p;p--;{ found_syllable (indic_standalone_cluster); }}\n-        break;\n-        case 19:\n-#line 96 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {te = p;p--;{ found_syllable (indic_symbol_cluster); }}\n-        break;\n-        case 15:\n-#line 97 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {te = p;p--;{ found_syllable (indic_broken_cluster); }}\n-        break;\n-        case 16:\n-#line 98 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {te = p;p--;{ found_syllable (indic_non_indic_cluster); }}\n-        break;\n-        case 1:\n-#line 93 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {{p = ((te))-1;}{ found_syllable (indic_consonant_syllable); }}\n-        break;\n-        case 3:\n-#line 94 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {{p = ((te))-1;}{ found_syllable (indic_vowel_syllable); }}\n-        break;\n-        case 7:\n-#line 95 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {{p = ((te))-1;}{ found_syllable (indic_standalone_cluster); }}\n-        break;\n-        case 8:\n-#line 96 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {{p = ((te))-1;}{ found_syllable (indic_symbol_cluster); }}\n-        break;\n-        case 4:\n-#line 97 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {{p = ((te))-1;}{ found_syllable (indic_broken_cluster); }}\n-        break;\n-        case 6:\n-#line 1 \"NONE\"\n-        {       switch( act ) {\n-        case 1:\n-        {{p = ((te))-1;} found_syllable (indic_consonant_syllable); }\n-        break;\n-        case 5:\n-        {{p = ((te))-1;} found_syllable (indic_broken_cluster); }\n-        break;\n-        case 6:\n-        {{p = ((te))-1;} found_syllable (indic_non_indic_cluster); }\n-        break;\n-        }\n-        }\n-        break;\n-        case 18:\n-#line 1 \"NONE\"\n-        {te = p+1;}\n-#line 93 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {act = 1;}\n-        break;\n-        case 5:\n-#line 1 \"NONE\"\n-        {te = p+1;}\n-#line 97 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {act = 5;}\n-        break;\n-        case 12:\n-#line 1 \"NONE\"\n-        {te = p+1;}\n-#line 98 \"hb-ot-shape-complex-indic-machine.rl\"\n-        {act = 6;}\n-        break;\n-#line 573 \"hb-ot-shape-complex-indic-machine.hh\"\n-        }\n-\n-_again:\n-        switch ( _indic_syllable_machine_to_state_actions[cs] ) {\n-        case 9:\n-#line 1 \"NONE\"\n-        {ts = 0;}\n-        break;\n-#line 582 \"hb-ot-shape-complex-indic-machine.hh\"\n-        }\n-\n-        if ( ++p != pe )\n-                goto _resume;\n-        _test_eof: {}\n-        if ( p == eof )\n-        {\n-        if ( _indic_syllable_machine_eof_trans[cs] > 0 ) {\n-                _trans = _indic_syllable_machine_eof_trans[cs] - 1;\n-                goto _eof_trans;\n-        }\n-        }\n-\n-        }\n-\n-#line 130 \"hb-ot-shape-complex-indic-machine.rl\"\n-\n-}\n-\n-#undef found_syllable\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-indic-machine.hh","additions":0,"deletions":603,"binary":false,"changes":603,"status":"deleted"},{"patch":"@@ -1,501 +0,0 @@\n-\/* == Start of generated table == *\/\n-\/*\n- * The following table is generated by running:\n- *\n- *   .\/gen-indic-table.py IndicSyllabicCategory.txt IndicPositionalCategory.txt Blocks.txt\n- *\n- * on files with these headers:\n- *\n- * # IndicSyllabicCategory-13.0.0.txt\n- * # Date: 2019-07-22, 19:55:00 GMT [KW, RP]\n- * # IndicPositionalCategory-13.0.0.txt\n- * # Date: 2019-07-23, 00:01:00 GMT [KW, RP]\n- * # Blocks-13.0.0.txt\n- * # Date: 2019-07-10, 19:06:00 GMT [KW]\n- *\/\n-\n-#include \"hb.hh\"\n-\n-#ifndef HB_NO_OT_SHAPE\n-\n-#include \"hb-ot-shape-complex-indic.hh\"\n-\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wunused-macros\"\n-\n-#define ISC_A    INDIC_SYLLABIC_CATEGORY_AVAGRAHA                    \/*   17 chars; Avagraha *\/\n-#define ISC_Bi   INDIC_SYLLABIC_CATEGORY_BINDU                       \/*   91 chars; Bindu *\/\n-#define ISC_BJN  INDIC_SYLLABIC_CATEGORY_BRAHMI_JOINING_NUMBER       \/*   20 chars; Brahmi_Joining_Number *\/\n-#define ISC_Ca   INDIC_SYLLABIC_CATEGORY_CANTILLATION_MARK           \/*   59 chars; Cantillation_Mark *\/\n-#define ISC_C    INDIC_SYLLABIC_CATEGORY_CONSONANT                   \/* 2195 chars; Consonant *\/\n-#define ISC_CD   INDIC_SYLLABIC_CATEGORY_CONSONANT_DEAD              \/*   12 chars; Consonant_Dead *\/\n-#define ISC_CF   INDIC_SYLLABIC_CATEGORY_CONSONANT_FINAL             \/*   67 chars; Consonant_Final *\/\n-#define ISC_CHL  INDIC_SYLLABIC_CATEGORY_CONSONANT_HEAD_LETTER       \/*    5 chars; Consonant_Head_Letter *\/\n-#define ISC_CIP  INDIC_SYLLABIC_CATEGORY_CONSONANT_INITIAL_POSTFIXED \/*    1 chars; Consonant_Initial_Postfixed *\/\n-#define ISC_CK   INDIC_SYLLABIC_CATEGORY_CONSONANT_KILLER            \/*    2 chars; Consonant_Killer *\/\n-#define ISC_CM   INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL            \/*   31 chars; Consonant_Medial *\/\n-#define ISC_CP   INDIC_SYLLABIC_CATEGORY_CONSONANT_PLACEHOLDER       \/*   22 chars; Consonant_Placeholder *\/\n-#define ISC_CPR  INDIC_SYLLABIC_CATEGORY_CONSONANT_PRECEDING_REPHA   \/*    3 chars; Consonant_Preceding_Repha *\/\n-#define ISC_CPrf INDIC_SYLLABIC_CATEGORY_CONSONANT_PREFIXED          \/*   10 chars; Consonant_Prefixed *\/\n-#define ISC_CS   INDIC_SYLLABIC_CATEGORY_CONSONANT_SUBJOINED         \/*   94 chars; Consonant_Subjoined *\/\n-#define ISC_CSR  INDIC_SYLLABIC_CATEGORY_CONSONANT_SUCCEEDING_REPHA  \/*    4 chars; Consonant_Succeeding_Repha *\/\n-#define ISC_CWS  INDIC_SYLLABIC_CATEGORY_CONSONANT_WITH_STACKER      \/*    8 chars; Consonant_With_Stacker *\/\n-#define ISC_GM   INDIC_SYLLABIC_CATEGORY_GEMINATION_MARK             \/*    3 chars; Gemination_Mark *\/\n-#define ISC_IS   INDIC_SYLLABIC_CATEGORY_INVISIBLE_STACKER           \/*   12 chars; Invisible_Stacker *\/\n-#define ISC_ZWJ  INDIC_SYLLABIC_CATEGORY_JOINER                      \/*    1 chars; Joiner *\/\n-#define ISC_ML   INDIC_SYLLABIC_CATEGORY_MODIFYING_LETTER            \/*    1 chars; Modifying_Letter *\/\n-#define ISC_ZWNJ INDIC_SYLLABIC_CATEGORY_NON_JOINER                  \/*    1 chars; Non_Joiner *\/\n-#define ISC_N    INDIC_SYLLABIC_CATEGORY_NUKTA                       \/*   31 chars; Nukta *\/\n-#define ISC_Nd   INDIC_SYLLABIC_CATEGORY_NUMBER                      \/*  491 chars; Number *\/\n-#define ISC_NJ   INDIC_SYLLABIC_CATEGORY_NUMBER_JOINER               \/*    1 chars; Number_Joiner *\/\n-#define ISC_x    INDIC_SYLLABIC_CATEGORY_OTHER                       \/*    1 chars; Other *\/\n-#define ISC_PK   INDIC_SYLLABIC_CATEGORY_PURE_KILLER                 \/*   23 chars; Pure_Killer *\/\n-#define ISC_RS   INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER            \/*    2 chars; Register_Shifter *\/\n-#define ISC_SM   INDIC_SYLLABIC_CATEGORY_SYLLABLE_MODIFIER           \/*   25 chars; Syllable_Modifier *\/\n-#define ISC_TL   INDIC_SYLLABIC_CATEGORY_TONE_LETTER                 \/*    7 chars; Tone_Letter *\/\n-#define ISC_TM   INDIC_SYLLABIC_CATEGORY_TONE_MARK                   \/*   42 chars; Tone_Mark *\/\n-#define ISC_V    INDIC_SYLLABIC_CATEGORY_VIRAMA                      \/*   27 chars; Virama *\/\n-#define ISC_Vs   INDIC_SYLLABIC_CATEGORY_VISARGA                     \/*   35 chars; Visarga *\/\n-#define ISC_Vo   INDIC_SYLLABIC_CATEGORY_VOWEL                       \/*   30 chars; Vowel *\/\n-#define ISC_M    INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT             \/*  683 chars; Vowel_Dependent *\/\n-#define ISC_VI   INDIC_SYLLABIC_CATEGORY_VOWEL_INDEPENDENT           \/*  484 chars; Vowel_Independent *\/\n-\n-#define IMC_B    INDIC_MATRA_CATEGORY_BOTTOM                         \/*  351 chars; Bottom *\/\n-#define IMC_BL   INDIC_MATRA_CATEGORY_BOTTOM_AND_LEFT                \/*    1 chars; Bottom_And_Left *\/\n-#define IMC_BR   INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT               \/*    4 chars; Bottom_And_Right *\/\n-#define IMC_L    INDIC_MATRA_CATEGORY_LEFT                           \/*   64 chars; Left *\/\n-#define IMC_LR   INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT                 \/*   22 chars; Left_And_Right *\/\n-#define IMC_x    INDIC_MATRA_CATEGORY_NOT_APPLICABLE                 \/*    1 chars; Not_Applicable *\/\n-#define IMC_O    INDIC_MATRA_CATEGORY_OVERSTRUCK                     \/*   10 chars; Overstruck *\/\n-#define IMC_R    INDIC_MATRA_CATEGORY_RIGHT                          \/*  288 chars; Right *\/\n-#define IMC_T    INDIC_MATRA_CATEGORY_TOP                            \/*  415 chars; Top *\/\n-#define IMC_TB   INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM                 \/*   10 chars; Top_And_Bottom *\/\n-#define IMC_TBL  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_LEFT        \/*    2 chars; Top_And_Bottom_And_Left *\/\n-#define IMC_TBR  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT       \/*    1 chars; Top_And_Bottom_And_Right *\/\n-#define IMC_TL   INDIC_MATRA_CATEGORY_TOP_AND_LEFT                   \/*    6 chars; Top_And_Left *\/\n-#define IMC_TLR  INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT         \/*    4 chars; Top_And_Left_And_Right *\/\n-#define IMC_TR   INDIC_MATRA_CATEGORY_TOP_AND_RIGHT                  \/*   13 chars; Top_And_Right *\/\n-#define IMC_VOL  INDIC_MATRA_CATEGORY_VISUAL_ORDER_LEFT              \/*   19 chars; Visual_Order_Left *\/\n-\n-#pragma GCC diagnostic pop\n-\n-#define _(S,M) INDIC_COMBINE_CATEGORIES (ISC_##S, IMC_##M)\n-\n-\n-static const uint16_t indic_table[] = {\n-\n-\n-#define indic_offset_0x0028u 0\n-\n-\n-  \/* Basic Latin *\/\n-\n-  \/* 0028 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(CP,x),  _(x,x),  _(x,x),\n-  \/* 0030 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0038 *\/ _(Nd,x), _(Nd,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-#define indic_offset_0x00b0u 24\n-\n-\n-  \/* Latin-1 Supplement *\/\n-\n-  \/* 00B0 *\/  _(x,x),  _(x,x), _(SM,x), _(SM,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 00B8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 00C0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 00C8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 00D0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(CP,x),\n-\n-#define indic_offset_0x0900u 64\n-\n-\n-  \/* Devanagari *\/\n-\n-  \/* 0900 *\/ _(Bi,T), _(Bi,T), _(Bi,T), _(Vs,R), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0908 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0910 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0918 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0920 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0928 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0930 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0938 *\/  _(C,x),  _(C,x),  _(M,T),  _(M,R),  _(N,B),  _(A,x),  _(M,R),  _(M,L),\n-  \/* 0940 *\/  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(M,T),  _(M,T),  _(M,T),\n-  \/* 0948 *\/  _(M,T),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(V,B),  _(M,L),  _(M,R),\n-  \/* 0950 *\/  _(x,x), _(Ca,T), _(Ca,B),  _(x,T),  _(x,T),  _(M,T),  _(M,B),  _(M,B),\n-  \/* 0958 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0960 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 0968 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0970 *\/  _(x,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0978 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-\n-  \/* Bengali *\/\n-\n-  \/* 0980 *\/ _(CP,x), _(Bi,T), _(Bi,R), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0988 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x), _(VI,x),\n-  \/* 0990 *\/ _(VI,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0998 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 09A0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 09A8 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 09B0 *\/  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),\n-  \/* 09B8 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(A,x),  _(M,R),  _(M,L),\n-  \/* 09C0 *\/  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(M,L),\n-  \/* 09C8 *\/  _(M,L),  _(x,x),  _(x,x), _(M,LR), _(M,LR),  _(V,B), _(CD,x),  _(x,x),\n-  \/* 09D0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),\n-  \/* 09D8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),\n-  \/* 09E0 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 09E8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 09F0 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 09F8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(Bi,x),  _(x,x), _(SM,T),  _(x,x),\n-\n-  \/* Gurmukhi *\/\n-\n-  \/* 0A00 *\/  _(x,x), _(Bi,T), _(Bi,T), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0A08 *\/ _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x),\n-  \/* 0A10 *\/ _(VI,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0A18 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0A20 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0A28 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0A30 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),\n-  \/* 0A38 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(x,x),  _(M,R),  _(M,L),\n-  \/* 0A40 *\/  _(M,R),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T),\n-  \/* 0A48 *\/  _(M,T),  _(x,x),  _(x,x),  _(M,T),  _(M,T),  _(V,B),  _(x,x),  _(x,x),\n-  \/* 0A50 *\/  _(x,x), _(Ca,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0A58 *\/  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),\n-  \/* 0A60 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 0A68 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0A70 *\/ _(Bi,T), _(GM,T), _(CP,x), _(CP,x),  _(x,x), _(CM,B),  _(x,x),  _(x,x),\n-  \/* 0A78 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-  \/* Gujarati *\/\n-\n-  \/* 0A80 *\/  _(x,x), _(Bi,T), _(Bi,T), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0A88 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x),\n-  \/* 0A90 *\/ _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0A98 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0AA0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0AA8 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0AB0 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0AB8 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(A,x),  _(M,R),  _(M,L),\n-  \/* 0AC0 *\/  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(M,T),  _(x,x),  _(M,T),\n-  \/* 0AC8 *\/  _(M,T), _(M,TR),  _(x,x),  _(M,R),  _(M,R),  _(V,B),  _(x,x),  _(x,x),\n-  \/* 0AD0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0AD8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0AE0 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 0AE8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0AF0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0AF8 *\/  _(x,x),  _(C,x), _(Ca,T), _(Ca,T), _(Ca,T),  _(N,T),  _(N,T),  _(N,T),\n-\n-  \/* Oriya *\/\n-\n-  \/* 0B00 *\/  _(x,x), _(Bi,T), _(Bi,R), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0B08 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x), _(VI,x),\n-  \/* 0B10 *\/ _(VI,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0B18 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0B20 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0B28 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0B30 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0B38 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(A,x),  _(M,R),  _(M,T),\n-  \/* 0B40 *\/  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(M,L),\n-  \/* 0B48 *\/ _(M,TL),  _(x,x),  _(x,x), _(M,LR),_(M,TLR),  _(V,B),  _(x,x),  _(x,x),\n-  \/* 0B50 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T),  _(M,T), _(M,TR),\n-  \/* 0B58 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),\n-  \/* 0B60 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 0B68 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0B70 *\/  _(x,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0B78 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-  \/* Tamil *\/\n-\n-  \/* 0B80 *\/  _(x,x),  _(x,x), _(Bi,T), _(ML,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0B88 *\/ _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),\n-  \/* 0B90 *\/ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(x,x),  _(x,x),\n-  \/* 0B98 *\/  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),\n-  \/* 0BA0 *\/  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0BA8 *\/  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),\n-  \/* 0BB0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0BB8 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),  _(M,R),\n-  \/* 0BC0 *\/  _(M,T),  _(M,R),  _(M,R),  _(x,x),  _(x,x),  _(x,x),  _(M,L),  _(M,L),\n-  \/* 0BC8 *\/  _(M,L),  _(x,x), _(M,LR), _(M,LR), _(M,LR),  _(V,T),  _(x,x),  _(x,x),\n-  \/* 0BD0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),\n-  \/* 0BD8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0BE0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 0BE8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0BF0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0BF8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-  \/* Telugu *\/\n-\n-  \/* 0C00 *\/ _(Bi,T), _(Bi,R), _(Bi,R), _(Vs,R), _(Bi,T), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0C08 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),\n-  \/* 0C10 *\/ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0C18 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0C20 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0C28 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0C30 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0C38 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(A,x),  _(M,T),  _(M,T),\n-  \/* 0C40 *\/  _(M,T),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(x,x),  _(M,T),  _(M,T),\n-  \/* 0C48 *\/ _(M,TB),  _(x,x),  _(M,T),  _(M,T),  _(M,T),  _(V,T),  _(x,x),  _(x,x),\n-  \/* 0C50 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T),  _(M,B),  _(x,x),\n-  \/* 0C58 *\/  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0C60 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 0C68 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0C70 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0C78 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-  \/* Kannada *\/\n-\n-  \/* 0C80 *\/ _(Bi,x), _(Bi,T), _(Bi,R), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0C88 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),\n-  \/* 0C90 *\/ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0C98 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0CA0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0CA8 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0CB0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0CB8 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(A,x),  _(M,R),  _(M,T),\n-  \/* 0CC0 *\/ _(M,TR),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(x,x),  _(M,T), _(M,TR),\n-  \/* 0CC8 *\/ _(M,TR),  _(x,x), _(M,TR), _(M,TR),  _(M,T),  _(V,T),  _(x,x),  _(x,x),\n-  \/* 0CD0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),  _(M,R),  _(x,x),\n-  \/* 0CD8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(x,x),\n-  \/* 0CE0 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 0CE8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0CF0 *\/  _(x,x),_(CWS,x),_(CWS,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0CF8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-  \/* Malayalam *\/\n-\n-  \/* 0D00 *\/ _(Bi,T), _(Bi,T), _(Bi,R), _(Vs,R), _(Bi,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0D08 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),\n-  \/* 0D10 *\/ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0D18 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0D20 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0D28 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0D30 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0D38 *\/  _(C,x),  _(C,x),  _(C,x), _(PK,T), _(PK,T),  _(A,x),  _(M,R),  _(M,R),\n-  \/* 0D40 *\/  _(M,R),  _(M,R),  _(M,R),  _(M,B),  _(M,B),  _(x,x),  _(M,L),  _(M,L),\n-  \/* 0D48 *\/  _(M,L),  _(x,x), _(M,LR), _(M,LR), _(M,LR),  _(V,T),_(CPR,T),  _(x,x),\n-  \/* 0D50 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(CD,x), _(CD,x), _(CD,x),  _(M,R),\n-  \/* 0D58 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x),\n-  \/* 0D60 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 0D68 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0D70 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 0D78 *\/  _(x,x),  _(x,x), _(CD,x), _(CD,x), _(CD,x), _(CD,x), _(CD,x), _(CD,x),\n-\n-  \/* Sinhala *\/\n-\n-  \/* 0D80 *\/  _(x,x), _(Bi,T), _(Bi,R), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0D88 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 0D90 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),\n-  \/* 0D98 *\/  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0DA0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0DA8 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0DB0 *\/  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 0DB8 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(x,x),\n-  \/* 0DC0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),\n-  \/* 0DC8 *\/  _(x,x),  _(x,x),  _(V,T),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),\n-  \/* 0DD0 *\/  _(M,R),  _(M,R),  _(M,T),  _(M,T),  _(M,B),  _(x,x),  _(M,B),  _(x,x),\n-  \/* 0DD8 *\/  _(M,R),  _(M,L), _(M,TL),  _(M,L), _(M,LR),_(M,TLR), _(M,LR),  _(M,R),\n-  \/* 0DE0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n-  \/* 0DE8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 0DF0 *\/  _(x,x),  _(x,x),  _(M,R),  _(M,R),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-#define indic_offset_0x1000u 1336\n-\n-\n-  \/* Myanmar *\/\n-\n-  \/* 1000 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 1008 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 1010 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 1018 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 1020 *\/  _(C,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 1028 *\/ _(VI,x), _(VI,x), _(VI,x),  _(M,R),  _(M,R),  _(M,T),  _(M,T),  _(M,B),\n-  \/* 1030 *\/  _(M,B),  _(M,L),  _(M,T),  _(M,T),  _(M,T),  _(M,T), _(Bi,T), _(TM,B),\n-  \/* 1038 *\/ _(Vs,R), _(IS,x), _(PK,T), _(CM,R),_(CM,TBL), _(CM,B), _(CM,B),  _(C,x),\n-  \/* 1040 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 1048 *\/ _(Nd,x), _(Nd,x),  _(x,x), _(CP,x),  _(x,x),  _(x,x), _(CP,x),  _(x,x),\n-  \/* 1050 *\/  _(C,x),  _(C,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(M,R),  _(M,R),\n-  \/* 1058 *\/  _(M,B),  _(M,B),  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(CM,B), _(CM,B),\n-  \/* 1060 *\/ _(CM,B),  _(C,x),  _(M,R), _(TM,R), _(TM,R),  _(C,x),  _(C,x),  _(M,R),\n-  \/* 1068 *\/  _(M,R), _(TM,R), _(TM,R), _(TM,R), _(TM,R), _(TM,R),  _(C,x),  _(C,x),\n-  \/* 1070 *\/  _(C,x),  _(M,T),  _(M,T),  _(M,T),  _(M,T),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 1078 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 1080 *\/  _(C,x),  _(C,x), _(CM,B),  _(M,R),  _(M,L),  _(M,T),  _(M,T), _(TM,R),\n-  \/* 1088 *\/ _(TM,R), _(TM,R), _(TM,R), _(TM,R), _(TM,R), _(TM,B),  _(C,x), _(TM,R),\n-  \/* 1090 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 1098 *\/ _(Nd,x), _(Nd,x), _(TM,R), _(TM,R),  _(M,R),  _(M,T),  _(x,x),  _(x,x),\n-\n-#define indic_offset_0x1780u 1496\n-\n-\n-  \/* Khmer *\/\n-\n-  \/* 1780 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 1788 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 1790 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 1798 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* 17A0 *\/  _(C,x),  _(C,x),  _(C,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 17A8 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n-  \/* 17B0 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x),  _(M,R),  _(M,T),\n-  \/* 17B8 *\/  _(M,T),  _(M,T),  _(M,T),  _(M,B),  _(M,B),  _(M,B), _(M,TL),_(M,TLR),\n-  \/* 17C0 *\/ _(M,LR),  _(M,L),  _(M,L),  _(M,L), _(M,LR), _(M,LR), _(Bi,T), _(Vs,R),\n-  \/* 17C8 *\/  _(M,R), _(RS,T), _(RS,T), _(SM,T),_(CSR,T), _(CK,T), _(SM,T), _(SM,T),\n-  \/* 17D0 *\/ _(SM,T), _(PK,T), _(IS,x), _(SM,T),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 17D8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(A,x), _(SM,T),  _(x,x),  _(x,x),\n-  \/* 17E0 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* 17E8 *\/ _(Nd,x), _(Nd,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-#define indic_offset_0x1cd0u 1608\n-\n-\n-  \/* Vedic Extensions *\/\n-\n-  \/* 1CD0 *\/ _(Ca,T), _(Ca,T), _(Ca,T),  _(x,x), _(Ca,O), _(Ca,B), _(Ca,B), _(Ca,B),\n-  \/* 1CD8 *\/ _(Ca,B), _(Ca,B), _(Ca,T), _(Ca,T), _(Ca,B), _(Ca,B), _(Ca,B), _(Ca,B),\n-  \/* 1CE0 *\/ _(Ca,T), _(Ca,R),  _(x,O),  _(x,O),  _(x,O),  _(x,O),  _(x,O),  _(x,O),\n-  \/* 1CE8 *\/  _(x,O),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,B),  _(x,x),  _(x,x),\n-  \/* 1CF0 *\/  _(x,x),  _(x,x), _(CD,x), _(CD,x), _(Ca,T),_(CWS,x),_(CWS,x), _(Ca,R),\n-  \/* 1CF8 *\/ _(Ca,x), _(Ca,x), _(CP,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-#define indic_offset_0x2008u 1656\n-\n-\n-  \/* General Punctuation *\/\n-\n-  \/* 2008 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),_(ZWNJ,x),_(ZWJ,x),  _(x,x),  _(x,x),\n-  \/* 2010 *\/ _(CP,x), _(CP,x), _(CP,x), _(CP,x), _(CP,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-#define indic_offset_0x2070u 1672\n-\n-\n-  \/* Superscripts and Subscripts *\/\n-\n-  \/* 2070 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(SM,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 2078 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* 2080 *\/  _(x,x),  _(x,x), _(SM,x), _(SM,x), _(SM,x),  _(x,x),  _(x,x),  _(x,x),\n-\n-#define indic_offset_0xa8e0u 1696\n-\n-\n-  \/* Devanagari Extended *\/\n-\n-  \/* A8E0 *\/ _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T),\n-  \/* A8E8 *\/ _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T),\n-  \/* A8F0 *\/ _(Ca,T), _(Ca,T), _(Bi,x), _(Bi,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n-  \/* A8F8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x),  _(M,T),\n-\n-#define indic_offset_0xa9e0u 1728\n-\n-\n-  \/* Myanmar Extended-B *\/\n-\n-  \/* A9E0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(M,T),  _(x,x),  _(C,x),\n-  \/* A9E8 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* A9F0 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n-  \/* A9F8 *\/ _(Nd,x), _(Nd,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),\n-\n-#define indic_offset_0xaa60u 1760\n-\n-\n-  \/* Myanmar Extended-A *\/\n-\n-  \/* AA60 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* AA68 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n-  \/* AA70 *\/  _(x,x),  _(C,x),  _(C,x),  _(C,x), _(CP,x), _(CP,x), _(CP,x),  _(x,x),\n-  \/* AA78 *\/  _(x,x),  _(x,x),  _(C,x), _(TM,R), _(TM,T), _(TM,R),  _(C,x),  _(C,x),\n-\n-}; \/* Table items: 1792; occupancy: 70% *\/\n-\n-uint16_t\n-hb_indic_get_categories (hb_codepoint_t u)\n-{\n-  switch (u >> 12)\n-  {\n-    case 0x0u:\n-      if (unlikely (u == 0x00A0u)) return _(CP,x);\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0028u, 0x003Fu)) return indic_table[u - 0x0028u + indic_offset_0x0028u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x00B0u, 0x00D7u)) return indic_table[u - 0x00B0u + indic_offset_0x00b0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0900u, 0x0DF7u)) return indic_table[u - 0x0900u + indic_offset_0x0900u];\n-      break;\n-\n-    case 0x1u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1000u, 0x109Fu)) return indic_table[u - 0x1000u + indic_offset_0x1000u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1780u, 0x17EFu)) return indic_table[u - 0x1780u + indic_offset_0x1780u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1CD0u, 0x1CFFu)) return indic_table[u - 0x1CD0u + indic_offset_0x1cd0u];\n-      break;\n-\n-    case 0x2u:\n-      if (unlikely (u == 0x25CCu)) return _(CP,x);\n-      if (hb_in_range<hb_codepoint_t> (u, 0x2008u, 0x2017u)) return indic_table[u - 0x2008u + indic_offset_0x2008u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x2070u, 0x2087u)) return indic_table[u - 0x2070u + indic_offset_0x2070u];\n-      break;\n-\n-    case 0xAu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0xA8E0u, 0xA8FFu)) return indic_table[u - 0xA8E0u + indic_offset_0xa8e0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0xA9E0u, 0xA9FFu)) return indic_table[u - 0xA9E0u + indic_offset_0xa9e0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0xAA60u, 0xAA7Fu)) return indic_table[u - 0xAA60u + indic_offset_0xaa60u];\n-      break;\n-\n-    default:\n-      break;\n-  }\n-  return _(x,x);\n-}\n-\n-#undef _\n-\n-#undef ISC_A\n-#undef ISC_Bi\n-#undef ISC_BJN\n-#undef ISC_Ca\n-#undef ISC_C\n-#undef ISC_CD\n-#undef ISC_CF\n-#undef ISC_CHL\n-#undef ISC_CIP\n-#undef ISC_CK\n-#undef ISC_CM\n-#undef ISC_CP\n-#undef ISC_CPR\n-#undef ISC_CPrf\n-#undef ISC_CS\n-#undef ISC_CSR\n-#undef ISC_CWS\n-#undef ISC_GM\n-#undef ISC_IS\n-#undef ISC_ZWJ\n-#undef ISC_ML\n-#undef ISC_ZWNJ\n-#undef ISC_N\n-#undef ISC_Nd\n-#undef ISC_NJ\n-#undef ISC_x\n-#undef ISC_PK\n-#undef ISC_RS\n-#undef ISC_SM\n-#undef ISC_TL\n-#undef ISC_TM\n-#undef ISC_V\n-#undef ISC_Vs\n-#undef ISC_Vo\n-#undef ISC_M\n-#undef ISC_VI\n-\n-#undef IMC_B\n-#undef IMC_BL\n-#undef IMC_BR\n-#undef IMC_L\n-#undef IMC_LR\n-#undef IMC_x\n-#undef IMC_O\n-#undef IMC_R\n-#undef IMC_T\n-#undef IMC_TB\n-#undef IMC_TBL\n-#undef IMC_TBR\n-#undef IMC_TL\n-#undef IMC_TLR\n-#undef IMC_TR\n-#undef IMC_VOL\n-\n-#endif\n-\n-\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-indic-table.cc","additions":0,"deletions":501,"binary":false,"changes":501,"status":"deleted"},{"patch":"@@ -1,1573 +0,0 @@\n-\/*\n- * Copyright  2011,2012  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#include \"hb.hh\"\n-\n-#ifndef HB_NO_OT_SHAPE\n-\n-#include \"hb-ot-shape-complex-indic.hh\"\n-#include \"hb-ot-shape-complex-indic-machine.hh\"\n-#include \"hb-ot-shape-complex-vowel-constraints.hh\"\n-#include \"hb-ot-layout.hh\"\n-\n-\n-\/*\n- * Indic shaper.\n- *\/\n-\n-\n-\/*\n- * Indic configurations.  Note that we do not want to keep every single script-specific\n- * behavior in these tables necessarily.  This should mainly be used for per-script\n- * properties that are cheaper keeping here, than in the code.  Ie. if, say, one and\n- * only one script has an exception, that one script can be if'ed directly in the code,\n- * instead of adding a new flag in these structs.\n- *\/\n-\n-enum base_position_t {\n-  BASE_POS_LAST_SINHALA,\n-  BASE_POS_LAST\n-};\n-enum reph_position_t {\n-  REPH_POS_AFTER_MAIN  = POS_AFTER_MAIN,\n-  REPH_POS_BEFORE_SUB  = POS_BEFORE_SUB,\n-  REPH_POS_AFTER_SUB   = POS_AFTER_SUB,\n-  REPH_POS_BEFORE_POST = POS_BEFORE_POST,\n-  REPH_POS_AFTER_POST  = POS_AFTER_POST\n-};\n-enum reph_mode_t {\n-  REPH_MODE_IMPLICIT,  \/* Reph formed out of initial Ra,H sequence. *\/\n-  REPH_MODE_EXPLICIT,  \/* Reph formed out of initial Ra,H,ZWJ sequence. *\/\n-  REPH_MODE_LOG_REPHA  \/* Encoded Repha character, needs reordering. *\/\n-};\n-enum blwf_mode_t {\n-  BLWF_MODE_PRE_AND_POST, \/* Below-forms feature applied to pre-base and post-base. *\/\n-  BLWF_MODE_POST_ONLY     \/* Below-forms feature applied to post-base only. *\/\n-};\n-struct indic_config_t\n-{\n-  hb_script_t     script;\n-  bool            has_old_spec;\n-  hb_codepoint_t  virama;\n-  base_position_t base_pos;\n-  reph_position_t reph_pos;\n-  reph_mode_t     reph_mode;\n-  blwf_mode_t     blwf_mode;\n-};\n-\n-static const indic_config_t indic_configs[] =\n-{\n-  \/* Default.  Should be first. *\/\n-  {HB_SCRIPT_INVALID,   false,      0,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n-  {HB_SCRIPT_DEVANAGARI,true, 0x094Du,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n-  {HB_SCRIPT_BENGALI,   true, 0x09CDu,BASE_POS_LAST, REPH_POS_AFTER_SUB,  REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n-  {HB_SCRIPT_GURMUKHI,  true, 0x0A4Du,BASE_POS_LAST, REPH_POS_BEFORE_SUB, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n-  {HB_SCRIPT_GUJARATI,  true, 0x0ACDu,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n-  {HB_SCRIPT_ORIYA,     true, 0x0B4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n-  {HB_SCRIPT_TAMIL,     true, 0x0BCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n-  {HB_SCRIPT_TELUGU,    true, 0x0C4Du,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_POST_ONLY},\n-  {HB_SCRIPT_KANNADA,   true, 0x0CCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_POST_ONLY},\n-  {HB_SCRIPT_MALAYALAM, true, 0x0D4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_LOG_REPHA,BLWF_MODE_PRE_AND_POST},\n-  {HB_SCRIPT_SINHALA,   false,0x0DCAu,BASE_POS_LAST_SINHALA,\n-                                                     REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_PRE_AND_POST},\n-};\n-\n-\n-\n-\/*\n- * Indic shaper.\n- *\/\n-\n-static const hb_ot_map_feature_t\n-indic_features[] =\n-{\n-  \/*\n-   * Basic features.\n-   * These features are applied in order, one at a time, after initial_reordering.\n-   *\/\n-  {HB_TAG('n','u','k','t'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('a','k','h','n'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('r','p','h','f'),        F_MANUAL_JOINERS},\n-  {HB_TAG('r','k','r','f'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('p','r','e','f'),        F_MANUAL_JOINERS},\n-  {HB_TAG('b','l','w','f'),        F_MANUAL_JOINERS},\n-  {HB_TAG('a','b','v','f'),        F_MANUAL_JOINERS},\n-  {HB_TAG('h','a','l','f'),        F_MANUAL_JOINERS},\n-  {HB_TAG('p','s','t','f'),        F_MANUAL_JOINERS},\n-  {HB_TAG('v','a','t','u'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('c','j','c','t'), F_GLOBAL_MANUAL_JOINERS},\n-  \/*\n-   * Other features.\n-   * These features are applied all at once, after final_reordering\n-   * but before clearing syllables.\n-   * Default Bengali font in Windows for example has intermixed\n-   * lookups for init,pres,abvs,blws features.\n-   *\/\n-  {HB_TAG('i','n','i','t'),        F_MANUAL_JOINERS},\n-  {HB_TAG('p','r','e','s'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('a','b','v','s'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('b','l','w','s'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('p','s','t','s'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('h','a','l','n'), F_GLOBAL_MANUAL_JOINERS},\n-};\n-\n-\/*\n- * Must be in the same order as the indic_features array.\n- *\/\n-enum {\n-  _INDIC_NUKT,\n-  _INDIC_AKHN,\n-  INDIC_RPHF,\n-  _INDIC_RKRF,\n-  INDIC_PREF,\n-  INDIC_BLWF,\n-  INDIC_ABVF,\n-  INDIC_HALF,\n-  INDIC_PSTF,\n-  _INDIC_VATU,\n-  _INDIC_CJCT,\n-\n-  INDIC_INIT,\n-  _INDIC_PRES,\n-  _INDIC_ABVS,\n-  _INDIC_BLWS,\n-  _INDIC_PSTS,\n-  _INDIC_HALN,\n-\n-  INDIC_NUM_FEATURES,\n-  INDIC_BASIC_FEATURES = INDIC_INIT, \/* Don't forget to update this! *\/\n-};\n-\n-static void\n-setup_syllables_indic (const hb_ot_shape_plan_t *plan,\n-                       hb_font_t *font,\n-                       hb_buffer_t *buffer);\n-static void\n-initial_reordering_indic (const hb_ot_shape_plan_t *plan,\n-                          hb_font_t *font,\n-                          hb_buffer_t *buffer);\n-static void\n-final_reordering_indic (const hb_ot_shape_plan_t *plan,\n-                        hb_font_t *font,\n-                        hb_buffer_t *buffer);\n-\n-static void\n-collect_features_indic (hb_ot_shape_planner_t *plan)\n-{\n-  hb_ot_map_builder_t *map = &plan->map;\n-\n-  \/* Do this before any lookups have been applied. *\/\n-  map->add_gsub_pause (setup_syllables_indic);\n-\n-  map->enable_feature (HB_TAG('l','o','c','l'));\n-  \/* The Indic specs do not require ccmp, but we apply it here since if\n-   * there is a use of it, it's typically at the beginning. *\/\n-  map->enable_feature (HB_TAG('c','c','m','p'));\n-\n-\n-  unsigned int i = 0;\n-  map->add_gsub_pause (initial_reordering_indic);\n-\n-  for (; i < INDIC_BASIC_FEATURES; i++) {\n-    map->add_feature (indic_features[i]);\n-    map->add_gsub_pause (nullptr);\n-  }\n-\n-  map->add_gsub_pause (final_reordering_indic);\n-\n-  for (; i < INDIC_NUM_FEATURES; i++)\n-    map->add_feature (indic_features[i]);\n-\n-  map->enable_feature (HB_TAG('c','a','l','t'));\n-  map->enable_feature (HB_TAG('c','l','i','g'));\n-\n-  map->add_gsub_pause (_hb_clear_syllables);\n-}\n-\n-static void\n-override_features_indic (hb_ot_shape_planner_t *plan)\n-{\n-  plan->map.disable_feature (HB_TAG('l','i','g','a'));\n-}\n-\n-\n-struct indic_shape_plan_t\n-{\n-  bool load_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const\n-  {\n-    hb_codepoint_t glyph = virama_glyph.get_relaxed ();\n-    if (unlikely (glyph == (hb_codepoint_t) -1))\n-    {\n-      if (!config->virama || !font->get_nominal_glyph (config->virama, &glyph))\n-        glyph = 0;\n-      \/* Technically speaking, the spec says we should apply 'locl' to virama too.\n-       * Maybe one day... *\/\n-\n-      \/* Our get_nominal_glyph() function needs a font, so we can't get the virama glyph\n-       * during shape planning...  Instead, overwrite it here. *\/\n-      virama_glyph.set_relaxed ((int) glyph);\n-    }\n-\n-    *pglyph = glyph;\n-    return glyph != 0;\n-  }\n-\n-  const indic_config_t *config;\n-\n-  bool is_old_spec;\n-#ifndef HB_NO_UNISCRIBE_BUG_COMPATIBLE\n-  bool uniscribe_bug_compatible;\n-#else\n-  static constexpr bool uniscribe_bug_compatible = false;\n-#endif\n-  mutable hb_atomic_int_t virama_glyph;\n-\n-  hb_indic_would_substitute_feature_t rphf;\n-  hb_indic_would_substitute_feature_t pref;\n-  hb_indic_would_substitute_feature_t blwf;\n-  hb_indic_would_substitute_feature_t pstf;\n-  hb_indic_would_substitute_feature_t vatu;\n-\n-  hb_mask_t mask_array[INDIC_NUM_FEATURES];\n-};\n-\n-static void *\n-data_create_indic (const hb_ot_shape_plan_t *plan)\n-{\n-  indic_shape_plan_t *indic_plan = (indic_shape_plan_t *) calloc (1, sizeof (indic_shape_plan_t));\n-  if (unlikely (!indic_plan))\n-    return nullptr;\n-\n-  indic_plan->config = &indic_configs[0];\n-  for (unsigned int i = 1; i < ARRAY_LENGTH (indic_configs); i++)\n-    if (plan->props.script == indic_configs[i].script) {\n-      indic_plan->config = &indic_configs[i];\n-      break;\n-    }\n-\n-  indic_plan->is_old_spec = indic_plan->config->has_old_spec && ((plan->map.chosen_script[0] & 0x000000FFu) != '2');\n-#ifndef HB_NO_UNISCRIBE_BUG_COMPATIBLE\n-  indic_plan->uniscribe_bug_compatible = hb_options ().uniscribe_bug_compatible;\n-#endif\n-  indic_plan->virama_glyph.set_relaxed (-1);\n-\n-  \/* Use zero-context would_substitute() matching for new-spec of the main\n-   * Indic scripts, and scripts with one spec only, but not for old-specs.\n-   * The new-spec for all dual-spec scripts says zero-context matching happens.\n-   *\n-   * However, testing with Malayalam shows that old and new spec both allow\n-   * context.  Testing with Bengali new-spec however shows that it doesn't.\n-   * So, the heuristic here is the way it is.  It should *only* be changed,\n-   * as we discover more cases of what Windows does.  DON'T TOUCH OTHERWISE.\n-   *\/\n-  bool zero_context = !indic_plan->is_old_spec && plan->props.script != HB_SCRIPT_MALAYALAM;\n-  indic_plan->rphf.init (&plan->map, HB_TAG('r','p','h','f'), zero_context);\n-  indic_plan->pref.init (&plan->map, HB_TAG('p','r','e','f'), zero_context);\n-  indic_plan->blwf.init (&plan->map, HB_TAG('b','l','w','f'), zero_context);\n-  indic_plan->pstf.init (&plan->map, HB_TAG('p','s','t','f'), zero_context);\n-  indic_plan->vatu.init (&plan->map, HB_TAG('v','a','t','u'), zero_context);\n-\n-  for (unsigned int i = 0; i < ARRAY_LENGTH (indic_plan->mask_array); i++)\n-    indic_plan->mask_array[i] = (indic_features[i].flags & F_GLOBAL) ?\n-                                 0 : plan->map.get_1_mask (indic_features[i].tag);\n-\n-  return indic_plan;\n-}\n-\n-static void\n-data_destroy_indic (void *data)\n-{\n-  free (data);\n-}\n-\n-static indic_position_t\n-consonant_position_from_face (const indic_shape_plan_t *indic_plan,\n-                              const hb_codepoint_t consonant,\n-                              const hb_codepoint_t virama,\n-                              hb_face_t *face)\n-{\n-  \/* For old-spec, the order of glyphs is Consonant,Virama,\n-   * whereas for new-spec, it's Virama,Consonant.  However,\n-   * some broken fonts (like Free Sans) simply copied lookups\n-   * from old-spec to new-spec without modification.\n-   * And oddly enough, Uniscribe seems to respect those lookups.\n-   * Eg. in the sequence U+0924,U+094D,U+0930, Uniscribe finds\n-   * base at 0.  The font however, only has lookups matching\n-   * 930,94D in 'blwf', not the expected 94D,930 (with new-spec\n-   * table).  As such, we simply match both sequences.  Seems\n-   * to work.\n-   *\n-   * Vatu is done as well, for:\n-   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1587\n-   *\/\n-  hb_codepoint_t glyphs[3] = {virama, consonant, virama};\n-  if (indic_plan->blwf.would_substitute (glyphs  , 2, face) ||\n-      indic_plan->blwf.would_substitute (glyphs+1, 2, face) ||\n-      indic_plan->vatu.would_substitute (glyphs  , 2, face) ||\n-      indic_plan->vatu.would_substitute (glyphs+1, 2, face))\n-    return POS_BELOW_C;\n-  if (indic_plan->pstf.would_substitute (glyphs  , 2, face) ||\n-      indic_plan->pstf.would_substitute (glyphs+1, 2, face))\n-    return POS_POST_C;\n-  if (indic_plan->pref.would_substitute (glyphs  , 2, face) ||\n-      indic_plan->pref.would_substitute (glyphs+1, 2, face))\n-    return POS_POST_C;\n-  return POS_BASE_C;\n-}\n-\n-static void\n-setup_masks_indic (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                   hb_buffer_t              *buffer,\n-                   hb_font_t                *font HB_UNUSED)\n-{\n-  HB_BUFFER_ALLOCATE_VAR (buffer, indic_category);\n-  HB_BUFFER_ALLOCATE_VAR (buffer, indic_position);\n-\n-  \/* We cannot setup masks here.  We save information about characters\n-   * and setup masks later on in a pause-callback. *\/\n-\n-  unsigned int count = buffer->len;\n-  hb_glyph_info_t *info = buffer->info;\n-  for (unsigned int i = 0; i < count; i++)\n-    set_indic_properties (info[i]);\n-}\n-\n-static void\n-setup_syllables_indic (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                       hb_font_t *font HB_UNUSED,\n-                       hb_buffer_t *buffer)\n-{\n-  find_syllables_indic (buffer);\n-  foreach_syllable (buffer, start, end)\n-    buffer->unsafe_to_break (start, end);\n-}\n-\n-static int\n-compare_indic_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)\n-{\n-  int a = pa->indic_position();\n-  int b = pb->indic_position();\n-\n-  return a < b ? -1 : a == b ? 0 : +1;\n-}\n-\n-\n-\n-static void\n-update_consonant_positions_indic (const hb_ot_shape_plan_t *plan,\n-                                  hb_font_t         *font,\n-                                  hb_buffer_t       *buffer)\n-{\n-  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n-\n-  if (indic_plan->config->base_pos != BASE_POS_LAST)\n-    return;\n-\n-  hb_codepoint_t virama;\n-  if (indic_plan->load_virama_glyph (font, &virama))\n-  {\n-    hb_face_t *face = font->face;\n-    unsigned int count = buffer->len;\n-    hb_glyph_info_t *info = buffer->info;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (info[i].indic_position() == POS_BASE_C)\n-      {\n-        hb_codepoint_t consonant = info[i].codepoint;\n-        info[i].indic_position() = consonant_position_from_face (indic_plan, consonant, virama, face);\n-      }\n-  }\n-}\n-\n-\n-\/* Rules from:\n- * https:\/\/docs.microsqoft.com\/en-us\/typography\/script-development\/devanagari *\/\n-\n-static void\n-initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,\n-                                       hb_face_t *face,\n-                                       hb_buffer_t *buffer,\n-                                       unsigned int start, unsigned int end)\n-{\n-  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n-  hb_glyph_info_t *info = buffer->info;\n-\n-  \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/435#issuecomment-335560167\n-   * \/\/ For compatibility with legacy usage in Kannada,\n-   * \/\/ Ra+h+ZWJ must behave like Ra+ZWJ+h...\n-   *\/\n-  if (buffer->props.script == HB_SCRIPT_KANNADA &&\n-      start + 3 <= end &&\n-      is_one_of (info[start  ], FLAG (OT_Ra)) &&\n-      is_one_of (info[start+1], FLAG (OT_H)) &&\n-      is_one_of (info[start+2], FLAG (OT_ZWJ)))\n-  {\n-    buffer->merge_clusters (start+1, start+3);\n-    hb_glyph_info_t tmp = info[start+1];\n-    info[start+1] = info[start+2];\n-    info[start+2] = tmp;\n-  }\n-\n-  \/* 1. Find base consonant:\n-   *\n-   * The shaping engine finds the base consonant of the syllable, using the\n-   * following algorithm: starting from the end of the syllable, move backwards\n-   * until a consonant is found that does not have a below-base or post-base\n-   * form (post-base forms have to follow below-base forms), or that is not a\n-   * pre-base-reordering Ra, or arrive at the first consonant. The consonant\n-   * stopped at will be the base.\n-   *\n-   *   o If the syllable starts with Ra + Halant (in a script that has Reph)\n-   *     and has more than one consonant, Ra is excluded from candidates for\n-   *     base consonants.\n-   *\/\n-\n-  unsigned int base = end;\n-  bool has_reph = false;\n-\n-  {\n-    \/* -> If the syllable starts with Ra + Halant (in a script that has Reph)\n-     *    and has more than one consonant, Ra is excluded from candidates for\n-     *    base consonants. *\/\n-    unsigned int limit = start;\n-    if (indic_plan->mask_array[INDIC_RPHF] &&\n-        start + 3 <= end &&\n-        (\n-         (indic_plan->config->reph_mode == REPH_MODE_IMPLICIT && !is_joiner (info[start + 2])) ||\n-         (indic_plan->config->reph_mode == REPH_MODE_EXPLICIT && info[start + 2].indic_category() == OT_ZWJ)\n-        ))\n-    {\n-      \/* See if it matches the 'rphf' feature. *\/\n-      hb_codepoint_t glyphs[3] = {info[start].codepoint,\n-                                  info[start + 1].codepoint,\n-                                  indic_plan->config->reph_mode == REPH_MODE_EXPLICIT ?\n-                                    info[start + 2].codepoint : 0};\n-      if (indic_plan->rphf.would_substitute (glyphs, 2, face) ||\n-          (indic_plan->config->reph_mode == REPH_MODE_EXPLICIT &&\n-           indic_plan->rphf.would_substitute (glyphs, 3, face)))\n-      {\n-        limit += 2;\n-        while (limit < end && is_joiner (info[limit]))\n-          limit++;\n-        base = start;\n-        has_reph = true;\n-      }\n-    } else if (indic_plan->config->reph_mode == REPH_MODE_LOG_REPHA && info[start].indic_category() == OT_Repha)\n-    {\n-        limit += 1;\n-        while (limit < end && is_joiner (info[limit]))\n-          limit++;\n-        base = start;\n-        has_reph = true;\n-    }\n-\n-    switch (indic_plan->config->base_pos)\n-    {\n-      case BASE_POS_LAST:\n-      {\n-        \/* -> starting from the end of the syllable, move backwards *\/\n-        unsigned int i = end;\n-        bool seen_below = false;\n-        do {\n-          i--;\n-          \/* -> until a consonant is found *\/\n-          if (is_consonant (info[i]))\n-          {\n-            \/* -> that does not have a below-base or post-base form\n-             * (post-base forms have to follow below-base forms), *\/\n-            if (info[i].indic_position() != POS_BELOW_C &&\n-                (info[i].indic_position() != POS_POST_C || seen_below))\n-            {\n-              base = i;\n-              break;\n-            }\n-            if (info[i].indic_position() == POS_BELOW_C)\n-              seen_below = true;\n-\n-            \/* -> or that is not a pre-base-reordering Ra,\n-             *\n-             * IMPLEMENTATION NOTES:\n-             *\n-             * Our pre-base-reordering Ra's are marked POS_POST_C, so will be skipped\n-             * by the logic above already.\n-             *\/\n-\n-            \/* -> or arrive at the first consonant. The consonant stopped at will\n-             * be the base. *\/\n-            base = i;\n-          }\n-          else\n-          {\n-            \/* A ZWJ after a Halant stops the base search, and requests an explicit\n-             * half form.\n-             * A ZWJ before a Halant, requests a subjoined form instead, and hence\n-             * search continues.  This is particularly important for Bengali\n-             * sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya. *\/\n-            if (start < i &&\n-                info[i].indic_category() == OT_ZWJ &&\n-                info[i - 1].indic_category() == OT_H)\n-              break;\n-          }\n-        } while (i > limit);\n-      }\n-      break;\n-\n-      case BASE_POS_LAST_SINHALA:\n-      {\n-        \/* Sinhala base positioning is slightly different from main Indic, in that:\n-         * 1. Its ZWJ behavior is different,\n-         * 2. We don't need to look into the font for consonant positions.\n-         *\/\n-\n-        if (!has_reph)\n-          base = limit;\n-\n-        \/* Find the last base consonant that is not blocked by ZWJ.  If there is\n-         * a ZWJ right before a base consonant, that would request a subjoined form. *\/\n-        for (unsigned int i = limit; i < end; i++)\n-          if (is_consonant (info[i]))\n-          {\n-            if (limit < i && info[i - 1].indic_category() == OT_ZWJ)\n-              break;\n-            else\n-              base = i;\n-          }\n-\n-        \/* Mark all subsequent consonants as below. *\/\n-        for (unsigned int i = base + 1; i < end; i++)\n-          if (is_consonant (info[i]))\n-            info[i].indic_position() = POS_BELOW_C;\n-      }\n-      break;\n-    }\n-\n-    \/* -> If the syllable starts with Ra + Halant (in a script that has Reph)\n-     *    and has more than one consonant, Ra is excluded from candidates for\n-     *    base consonants.\n-     *\n-     *  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ. *\/\n-    if (has_reph && base == start && limit - base <= 2) {\n-      \/* Have no other consonant, so Reph is not formed and Ra becomes base. *\/\n-      has_reph = false;\n-    }\n-  }\n-\n-\n-  \/* 2. Decompose and reorder Matras:\n-   *\n-   * Each matra and any syllable modifier sign in the syllable are moved to the\n-   * appropriate position relative to the consonant(s) in the syllable. The\n-   * shaping engine decomposes two- or three-part matras into their constituent\n-   * parts before any repositioning. Matra characters are classified by which\n-   * consonant in a conjunct they have affinity for and are reordered to the\n-   * following positions:\n-   *\n-   *   o Before first half form in the syllable\n-   *   o After subjoined consonants\n-   *   o After post-form consonant\n-   *   o After main consonant (for above marks)\n-   *\n-   * IMPLEMENTATION NOTES:\n-   *\n-   * The normalize() routine has already decomposed matras for us, so we don't\n-   * need to worry about that.\n-   *\/\n-\n-\n-  \/* 3.  Reorder marks to canonical order:\n-   *\n-   * Adjacent nukta and halant or nukta and vedic sign are always repositioned\n-   * if necessary, so that the nukta is first.\n-   *\n-   * IMPLEMENTATION NOTES:\n-   *\n-   * We don't need to do this: the normalize() routine already did this for us.\n-   *\/\n-\n-\n-  \/* Reorder characters *\/\n-\n-  for (unsigned int i = start; i < base; i++)\n-    info[i].indic_position() = hb_min (POS_PRE_C, (indic_position_t) info[i].indic_position());\n-\n-  if (base < end)\n-    info[base].indic_position() = POS_BASE_C;\n-\n-  \/* Mark final consonants.  A final consonant is one appearing after a matra.\n-   * Happens in Sinhala. *\/\n-  for (unsigned int i = base + 1; i < end; i++)\n-    if (info[i].indic_category() == OT_M) {\n-      for (unsigned int j = i + 1; j < end; j++)\n-        if (is_consonant (info[j])) {\n-         info[j].indic_position() = POS_FINAL_C;\n-         break;\n-       }\n-      break;\n-    }\n-\n-  \/* Handle beginning Ra *\/\n-  if (has_reph)\n-    info[start].indic_position() = POS_RA_TO_BECOME_REPH;\n-\n-  \/* For old-style Indic script tags, move the first post-base Halant after\n-   * last consonant.\n-   *\n-   * Reports suggest that in some scripts Uniscribe does this only if there\n-   * is *not* a Halant after last consonant already.  We know that is the\n-   * case for Kannada, while it reorders unconditionally in other scripts,\n-   * eg. Malayalam, Bengali, and Devanagari.  We don't currently know about\n-   * other scripts, so we block Kannada.\n-   *\n-   * Kannada test case:\n-   * U+0C9A,U+0CCD,U+0C9A,U+0CCD\n-   * With some versions of Lohit Kannada.\n-   * https:\/\/bugs.freedesktop.org\/show_bug.cgi?id=59118\n-   *\n-   * Malayalam test case:\n-   * U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D\n-   * With lohit-ttf-20121122\/Lohit-Malayalam.ttf\n-   *\n-   * Bengali test case:\n-   * U+0998,U+09CD,U+09AF,U+09CD\n-   * With Windows XP vrinda.ttf\n-   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1073\n-   *\n-   * Devanagari test case:\n-   * U+091F,U+094D,U+0930,U+094D\n-   * With chandas.ttf\n-   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1071\n-   *\/\n-  if (indic_plan->is_old_spec)\n-  {\n-    bool disallow_double_halants = buffer->props.script == HB_SCRIPT_KANNADA;\n-    for (unsigned int i = base + 1; i < end; i++)\n-      if (info[i].indic_category() == OT_H)\n-      {\n-        unsigned int j;\n-        for (j = end - 1; j > i; j--)\n-          if (is_consonant (info[j]) ||\n-              (disallow_double_halants && info[j].indic_category() == OT_H))\n-            break;\n-        if (info[j].indic_category() != OT_H && j > i) {\n-          \/* Move Halant to after last consonant. *\/\n-          hb_glyph_info_t t = info[i];\n-          memmove (&info[i], &info[i + 1], (j - i) * sizeof (info[0]));\n-          info[j] = t;\n-        }\n-        break;\n-      }\n-  }\n-\n-  \/* Attach misc marks to previous char to move with them. *\/\n-  {\n-    indic_position_t last_pos = POS_START;\n-    for (unsigned int i = start; i < end; i++)\n-    {\n-      if ((FLAG_UNSAFE (info[i].indic_category()) & (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | MEDIAL_FLAGS | FLAG (OT_H))))\n-      {\n-        info[i].indic_position() = last_pos;\n-        if (unlikely (info[i].indic_category() == OT_H &&\n-                      info[i].indic_position() == POS_PRE_M))\n-        {\n-          \/*\n-           * Uniscribe doesn't move the Halant with Left Matra.\n-           * TEST: U+092B,U+093F,U+094DE\n-           * We follow.  This is important for the Sinhala\n-           * U+0DDA split matra since it decomposes to U+0DD9,U+0DCA\n-           * where U+0DD9 is a left matra and U+0DCA is the virama.\n-           * We don't want to move the virama with the left matra.\n-           * TEST: U+0D9A,U+0DDA\n-           *\/\n-          for (unsigned int j = i; j > start; j--)\n-            if (info[j - 1].indic_position() != POS_PRE_M) {\n-              info[i].indic_position() = info[j - 1].indic_position();\n-              break;\n-            }\n-        }\n-      } else if (info[i].indic_position() != POS_SMVD) {\n-        last_pos = (indic_position_t) info[i].indic_position();\n-      }\n-    }\n-  }\n-  \/* For post-base consonants let them own anything before them\n-   * since the last consonant or matra. *\/\n-  {\n-    unsigned int last = base;\n-    for (unsigned int i = base + 1; i < end; i++)\n-      if (is_consonant (info[i]))\n-      {\n-        for (unsigned int j = last + 1; j < i; j++)\n-          if (info[j].indic_position() < POS_SMVD)\n-            info[j].indic_position() = info[i].indic_position();\n-        last = i;\n-      } else if (info[i].indic_category() == OT_M)\n-        last = i;\n-  }\n-\n-\n-  {\n-    \/* Use syllable() for sort accounting temporarily. *\/\n-    unsigned int syllable = info[start].syllable();\n-    for (unsigned int i = start; i < end; i++)\n-      info[i].syllable() = i - start;\n-\n-    \/* Sit tight, rock 'n roll! *\/\n-    hb_stable_sort (info + start, end - start, compare_indic_order);\n-    \/* Find base again *\/\n-    base = end;\n-    for (unsigned int i = start; i < end; i++)\n-      if (info[i].indic_position() == POS_BASE_C)\n-      {\n-        base = i;\n-        break;\n-      }\n-    \/* Things are out-of-control for post base positions, they may shuffle\n-     * around like crazy.  In old-spec mode, we move halants around, so in\n-     * that case merge all clusters after base.  Otherwise, check the sort\n-     * order and merge as needed.\n-     * For pre-base stuff, we handle cluster issues in final reordering.\n-     *\n-     * We could use buffer->sort() for this, if there was no special\n-     * reordering of pre-base stuff happening later...\n-     * We don't want to merge_clusters all of that, which buffer->sort()\n-     * would.  Here's a concrete example:\n-     *\n-     * Assume there's a pre-base consonant and explicit Halant before base,\n-     * followed by a prebase-reordering (left) Matra:\n-     *\n-     *   C,H,ZWNJ,B,M\n-     *\n-     * At this point in reordering we would have:\n-     *\n-     *   M,C,H,ZWNJ,B\n-     *\n-     * whereas in final reordering we will bring the Matra closer to Base:\n-     *\n-     *   C,H,ZWNJ,M,B\n-     *\n-     * That's why we don't want to merge-clusters anything before the Base\n-     * at this point.  But if something moved from after Base to before it,\n-     * we should merge clusters from base to them.  In final-reordering, we\n-     * only move things around before base, and merge-clusters up to base.\n-     * These two merge-clusters from the two sides of base will interlock\n-     * to merge things correctly.  See:\n-     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2272\n-     *\/\n-    if (indic_plan->is_old_spec || end - start > 127)\n-      buffer->merge_clusters (base, end);\n-    else\n-    {\n-      \/* Note!  syllable() is a one-byte field. *\/\n-      for (unsigned int i = base; i < end; i++)\n-        if (info[i].syllable() != 255)\n-        {\n-          unsigned int min = i;\n-          unsigned int max = i;\n-          unsigned int j = start + info[i].syllable();\n-          while (j != i)\n-          {\n-            min = hb_min (min, j);\n-            max = hb_max (max, j);\n-            unsigned int next = start + info[j].syllable();\n-            info[j].syllable() = 255; \/* So we don't process j later again. *\/\n-            j = next;\n-          }\n-          buffer->merge_clusters (hb_max (base, min), max + 1);\n-        }\n-    }\n-\n-    \/* Put syllable back in. *\/\n-    for (unsigned int i = start; i < end; i++)\n-      info[i].syllable() = syllable;\n-  }\n-\n-  \/* Setup masks now *\/\n-\n-  {\n-    hb_mask_t mask;\n-\n-    \/* Reph *\/\n-    for (unsigned int i = start; i < end && info[i].indic_position() == POS_RA_TO_BECOME_REPH; i++)\n-      info[i].mask |= indic_plan->mask_array[INDIC_RPHF];\n-\n-    \/* Pre-base *\/\n-    mask = indic_plan->mask_array[INDIC_HALF];\n-    if (!indic_plan->is_old_spec &&\n-        indic_plan->config->blwf_mode == BLWF_MODE_PRE_AND_POST)\n-      mask |= indic_plan->mask_array[INDIC_BLWF];\n-    for (unsigned int i = start; i < base; i++)\n-      info[i].mask  |= mask;\n-    \/* Base *\/\n-    mask = 0;\n-    if (base < end)\n-      info[base].mask |= mask;\n-    \/* Post-base *\/\n-    mask = indic_plan->mask_array[INDIC_BLWF] |\n-           indic_plan->mask_array[INDIC_ABVF] |\n-           indic_plan->mask_array[INDIC_PSTF];\n-    for (unsigned int i = base + 1; i < end; i++)\n-      info[i].mask  |= mask;\n-  }\n-\n-  if (indic_plan->is_old_spec &&\n-      buffer->props.script == HB_SCRIPT_DEVANAGARI)\n-  {\n-    \/* Old-spec eye-lash Ra needs special handling.  From the\n-     * spec:\n-     *\n-     * \"The feature 'below-base form' is applied to consonants\n-     * having below-base forms and following the base consonant.\n-     * The exception is vattu, which may appear below half forms\n-     * as well as below the base glyph. The feature 'below-base\n-     * form' will be applied to all such occurrences of Ra as well.\"\n-     *\n-     * Test case: U+0924,U+094D,U+0930,U+094d,U+0915\n-     * with Sanskrit 2003 font.\n-     *\n-     * However, note that Ra,Halant,ZWJ is the correct way to\n-     * request eyelash form of Ra, so we wouldbn't inhibit it\n-     * in that sequence.\n-     *\n-     * Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915\n-     *\/\n-    for (unsigned int i = start; i + 1 < base; i++)\n-      if (info[i  ].indic_category() == OT_Ra &&\n-          info[i+1].indic_category() == OT_H  &&\n-          (i + 2 == base ||\n-           info[i+2].indic_category() != OT_ZWJ))\n-      {\n-        info[i  ].mask |= indic_plan->mask_array[INDIC_BLWF];\n-        info[i+1].mask |= indic_plan->mask_array[INDIC_BLWF];\n-      }\n-  }\n-\n-  unsigned int pref_len = 2;\n-  if (indic_plan->mask_array[INDIC_PREF] && base + pref_len < end)\n-  {\n-    \/* Find a Halant,Ra sequence and mark it for pre-base-reordering processing. *\/\n-    for (unsigned int i = base + 1; i + pref_len - 1 < end; i++) {\n-      hb_codepoint_t glyphs[2];\n-      for (unsigned int j = 0; j < pref_len; j++)\n-        glyphs[j] = info[i + j].codepoint;\n-      if (indic_plan->pref.would_substitute (glyphs, pref_len, face))\n-      {\n-        for (unsigned int j = 0; j < pref_len; j++)\n-          info[i++].mask |= indic_plan->mask_array[INDIC_PREF];\n-        break;\n-      }\n-    }\n-  }\n-\n-  \/* Apply ZWJ\/ZWNJ effects *\/\n-  for (unsigned int i = start + 1; i < end; i++)\n-    if (is_joiner (info[i])) {\n-      bool non_joiner = info[i].indic_category() == OT_ZWNJ;\n-      unsigned int j = i;\n-\n-      do {\n-        j--;\n-\n-        \/* ZWJ\/ZWNJ should disable CJCT.  They do that by simply\n-         * being there, since we don't skip them for the CJCT\n-         * feature (ie. F_MANUAL_ZWJ) *\/\n-\n-        \/* A ZWNJ disables HALF. *\/\n-        if (non_joiner)\n-          info[j].mask &= ~indic_plan->mask_array[INDIC_HALF];\n-\n-      } while (j > start && !is_consonant (info[j]));\n-    }\n-}\n-\n-static void\n-initial_reordering_standalone_cluster (const hb_ot_shape_plan_t *plan,\n-                                       hb_face_t *face,\n-                                       hb_buffer_t *buffer,\n-                                       unsigned int start, unsigned int end)\n-{\n-  \/* We treat placeholder\/dotted-circle as if they are consonants, so we\n-   * should just chain.  Only if not in compatibility mode that is... *\/\n-\n-  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n-  if (indic_plan->uniscribe_bug_compatible)\n-  {\n-    \/* For dotted-circle, this is what Uniscribe does:\n-     * If dotted-circle is the last glyph, it just does nothing.\n-     * Ie. It doesn't form Reph. *\/\n-    if (buffer->info[end - 1].indic_category() == OT_DOTTEDCIRCLE)\n-      return;\n-  }\n-\n-  initial_reordering_consonant_syllable (plan, face, buffer, start, end);\n-}\n-\n-static void\n-initial_reordering_syllable_indic (const hb_ot_shape_plan_t *plan,\n-                                   hb_face_t *face,\n-                                   hb_buffer_t *buffer,\n-                                   unsigned int start, unsigned int end)\n-{\n-  indic_syllable_type_t syllable_type = (indic_syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n-  switch (syllable_type)\n-  {\n-    case indic_vowel_syllable: \/* We made the vowels look like consonants.  So let's call the consonant logic! *\/\n-    case indic_consonant_syllable:\n-     initial_reordering_consonant_syllable (plan, face, buffer, start, end);\n-     break;\n-\n-    case indic_broken_cluster: \/* We already inserted dotted-circles, so just call the standalone_cluster. *\/\n-    case indic_standalone_cluster:\n-     initial_reordering_standalone_cluster (plan, face, buffer, start, end);\n-     break;\n-\n-    case indic_symbol_cluster:\n-    case indic_non_indic_cluster:\n-      break;\n-  }\n-}\n-\n-static void\n-initial_reordering_indic (const hb_ot_shape_plan_t *plan,\n-                          hb_font_t *font,\n-                          hb_buffer_t *buffer)\n-{\n-  if (!buffer->message (font, \"start reordering indic initial\"))\n-    return;\n-\n-  update_consonant_positions_indic (plan, font, buffer);\n-  hb_syllabic_insert_dotted_circles (font, buffer,\n-                                     indic_broken_cluster,\n-                                     OT_DOTTEDCIRCLE,\n-                                     OT_Repha);\n-\n-  foreach_syllable (buffer, start, end)\n-    initial_reordering_syllable_indic (plan, font->face, buffer, start, end);\n-\n-  (void) buffer->message (font, \"end reordering indic initial\");\n-}\n-\n-static void\n-final_reordering_syllable_indic (const hb_ot_shape_plan_t *plan,\n-                                 hb_buffer_t *buffer,\n-                                 unsigned int start, unsigned int end)\n-{\n-  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n-  hb_glyph_info_t *info = buffer->info;\n-\n-\n-  \/* This function relies heavily on halant glyphs.  Lots of ligation\n-   * and possibly multiple substitutions happened prior to this\n-   * phase, and that might have messed up our properties.  Recover\n-   * from a particular case of that where we're fairly sure that a\n-   * class of OT_H is desired but has been lost. *\/\n-  \/* We don't call load_virama_glyph(), since we know it's already\n-   * loaded. *\/\n-  hb_codepoint_t virama_glyph = indic_plan->virama_glyph.get_relaxed ();\n-  if (virama_glyph)\n-  {\n-    for (unsigned int i = start; i < end; i++)\n-      if (info[i].codepoint == virama_glyph &&\n-          _hb_glyph_info_ligated (&info[i]) &&\n-          _hb_glyph_info_multiplied (&info[i]))\n-      {\n-        \/* This will make sure that this glyph passes is_halant() test. *\/\n-        info[i].indic_category() = OT_H;\n-        _hb_glyph_info_clear_ligated_and_multiplied (&info[i]);\n-      }\n-  }\n-\n-\n-  \/* 4. Final reordering:\n-   *\n-   * After the localized forms and basic shaping forms GSUB features have been\n-   * applied (see below), the shaping engine performs some final glyph\n-   * reordering before applying all the remaining font features to the entire\n-   * syllable.\n-   *\/\n-\n-  bool try_pref = !!indic_plan->mask_array[INDIC_PREF];\n-\n-  \/* Find base again *\/\n-  unsigned int base;\n-  for (base = start; base < end; base++)\n-    if (info[base].indic_position() >= POS_BASE_C)\n-    {\n-      if (try_pref && base + 1 < end)\n-      {\n-        for (unsigned int i = base + 1; i < end; i++)\n-          if ((info[i].mask & indic_plan->mask_array[INDIC_PREF]) != 0)\n-          {\n-            if (!(_hb_glyph_info_substituted (&info[i]) &&\n-                  _hb_glyph_info_ligated_and_didnt_multiply (&info[i])))\n-            {\n-              \/* Ok, this was a 'pref' candidate but didn't form any.\n-               * Base is around here... *\/\n-              base = i;\n-              while (base < end && is_halant (info[base]))\n-                base++;\n-              info[base].indic_position() = POS_BASE_C;\n-\n-              try_pref = false;\n-            }\n-            break;\n-          }\n-      }\n-      \/* For Malayalam, skip over unformed below- (but NOT post-) forms. *\/\n-      if (buffer->props.script == HB_SCRIPT_MALAYALAM)\n-      {\n-        for (unsigned int i = base + 1; i < end; i++)\n-        {\n-          while (i < end && is_joiner (info[i]))\n-            i++;\n-          if (i == end || !is_halant (info[i]))\n-            break;\n-          i++; \/* Skip halant. *\/\n-          while (i < end && is_joiner (info[i]))\n-            i++;\n-          if (i < end && is_consonant (info[i]) && info[i].indic_position() == POS_BELOW_C)\n-          {\n-            base = i;\n-            info[base].indic_position() = POS_BASE_C;\n-          }\n-        }\n-      }\n-\n-      if (start < base && info[base].indic_position() > POS_BASE_C)\n-        base--;\n-      break;\n-    }\n-  if (base == end && start < base &&\n-      is_one_of (info[base - 1], FLAG (OT_ZWJ)))\n-    base--;\n-  if (base < end)\n-    while (start < base &&\n-           is_one_of (info[base], (FLAG (OT_N) | FLAG (OT_H))))\n-      base--;\n-\n-\n-  \/*   o Reorder matras:\n-   *\n-   *     If a pre-base matra character had been reordered before applying basic\n-   *     features, the glyph can be moved closer to the main consonant based on\n-   *     whether half-forms had been formed. Actual position for the matra is\n-   *     defined as after last standalone halant glyph, after initial matra\n-   *     position and before the main consonant. If ZWJ or ZWNJ follow this\n-   *     halant, position is moved after it.\n-   *\n-   * IMPLEMENTATION NOTES:\n-   *\n-   * It looks like the last sentence is wrong.  Testing, with Windows 7 Uniscribe\n-   * and Devanagari shows that the behavior is best described as:\n-   *\n-   * \"If ZWJ follows this halant, matra is NOT repositioned after this halant.\n-   *  If ZWNJ follows this halant, position is moved after it.\"\n-   *\n-   * Test case, with Adobe Devanagari or Nirmala UI:\n-   *\n-   *   U+091F,U+094D,U+200C,U+092F,U+093F\n-   *   (Matra moves to the middle, after ZWNJ.)\n-   *\n-   *   U+091F,U+094D,U+200D,U+092F,U+093F\n-   *   (Matra does NOT move, stays to the left.)\n-   *\n-   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1070\n-   *\/\n-\n-  if (start + 1 < end && start < base) \/* Otherwise there can't be any pre-base matra characters. *\/\n-  {\n-    \/* If we lost track of base, alas, position before last thingy. *\/\n-    unsigned int new_pos = base == end ? base - 2 : base - 1;\n-\n-    \/* Malayalam \/ Tamil do not have \"half\" forms or explicit virama forms.\n-     * The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n-     * We want to position matra after them.\n-     *\/\n-    if (buffer->props.script != HB_SCRIPT_MALAYALAM && buffer->props.script != HB_SCRIPT_TAMIL)\n-    {\n-    search:\n-      while (new_pos > start &&\n-             !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_H)))))\n-        new_pos--;\n-\n-      \/* If we found no Halant we are done.\n-       * Otherwise only proceed if the Halant does\n-       * not belong to the Matra itself! *\/\n-      if (is_halant (info[new_pos]) &&\n-          info[new_pos].indic_position() != POS_PRE_M)\n-      {\n-#if 0 \/\/ See comment above\n-        \/* -> If ZWJ or ZWNJ follow this halant, position is moved after it. *\/\n-        if (new_pos + 1 < end && is_joiner (info[new_pos + 1]))\n-          new_pos++;\n-#endif\n-        if (new_pos + 1 < end)\n-        {\n-          \/* -> If ZWJ follows this halant, matra is NOT repositioned after this halant. *\/\n-          if (info[new_pos + 1].indic_category() == OT_ZWJ)\n-          {\n-            \/* Keep searching. *\/\n-            if (new_pos > start)\n-            {\n-              new_pos--;\n-              goto search;\n-            }\n-          }\n-          \/* -> If ZWNJ follows this halant, position is moved after it.\n-           *\n-           * IMPLEMENTATION NOTES:\n-           *\n-           * This is taken care of by the state-machine. A Halant,ZWNJ is a terminating\n-           * sequence for a consonant syllable; any pre-base matras occurring after it\n-           * will belong to the subsequent syllable.\n-           *\/\n-        }\n-      }\n-      else\n-        new_pos = start; \/* No move. *\/\n-    }\n-\n-    if (start < new_pos && info[new_pos].indic_position () != POS_PRE_M)\n-    {\n-      \/* Now go see if there's actually any matras... *\/\n-      for (unsigned int i = new_pos; i > start; i--)\n-        if (info[i - 1].indic_position () == POS_PRE_M)\n-        {\n-          unsigned int old_pos = i - 1;\n-          if (old_pos < base && base <= new_pos) \/* Shouldn't actually happen. *\/\n-            base--;\n-\n-          hb_glyph_info_t tmp = info[old_pos];\n-          memmove (&info[old_pos], &info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));\n-          info[new_pos] = tmp;\n-\n-          \/* Note: this merge_clusters() is intentionally *after* the reordering.\n-           * Indic matra reordering is special and tricky... *\/\n-          buffer->merge_clusters (new_pos, hb_min (end, base + 1));\n-\n-          new_pos--;\n-        }\n-    } else {\n-      for (unsigned int i = start; i < base; i++)\n-        if (info[i].indic_position () == POS_PRE_M) {\n-          buffer->merge_clusters (i, hb_min (end, base + 1));\n-          break;\n-        }\n-    }\n-  }\n-\n-\n-  \/*   o Reorder reph:\n-   *\n-   *     Rephs original position is always at the beginning of the syllable,\n-   *     (i.e. it is not reordered at the character reordering stage). However,\n-   *     it will be reordered according to the basic-forms shaping results.\n-   *     Possible positions for reph, depending on the script, are; after main,\n-   *     before post-base consonant forms, and after post-base consonant forms.\n-   *\/\n-\n-  \/* Two cases:\n-   *\n-   * - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then\n-   *   we should only move it if the sequence ligated to the repha form.\n-   *\n-   * - If repha is encoded separately and in the logical position, we should only\n-   *   move it if it did NOT ligate.  If it ligated, it's probably the font trying\n-   *   to make it work without the reordering.\n-   *\/\n-  if (start + 1 < end &&\n-      info[start].indic_position() == POS_RA_TO_BECOME_REPH &&\n-      ((info[start].indic_category() == OT_Repha) ^\n-       _hb_glyph_info_ligated_and_didnt_multiply (&info[start])))\n-  {\n-    unsigned int new_reph_pos;\n-    reph_position_t reph_pos = indic_plan->config->reph_pos;\n-\n-    \/*       1. If reph should be positioned after post-base consonant forms,\n-     *          proceed to step 5.\n-     *\/\n-    if (reph_pos == REPH_POS_AFTER_POST)\n-    {\n-      goto reph_step_5;\n-    }\n-\n-    \/*       2. If the reph repositioning class is not after post-base: target\n-     *          position is after the first explicit halant glyph between the\n-     *          first post-reph consonant and last main consonant. If ZWJ or ZWNJ\n-     *          are following this halant, position is moved after it. If such\n-     *          position is found, this is the target position. Otherwise,\n-     *          proceed to the next step.\n-     *\n-     *          Note: in old-implementation fonts, where classifications were\n-     *          fixed in shaping engine, there was no case where reph position\n-     *          will be found on this step.\n-     *\/\n-    {\n-      new_reph_pos = start + 1;\n-      while (new_reph_pos < base && !is_halant (info[new_reph_pos]))\n-        new_reph_pos++;\n-\n-      if (new_reph_pos < base && is_halant (info[new_reph_pos]))\n-      {\n-        \/* ->If ZWJ or ZWNJ are following this halant, position is moved after it. *\/\n-        if (new_reph_pos + 1 < base && is_joiner (info[new_reph_pos + 1]))\n-          new_reph_pos++;\n-        goto reph_move;\n-      }\n-    }\n-\n-    \/*       3. If reph should be repositioned after the main consonant: find the\n-     *          first consonant not ligated with main, or find the first\n-     *          consonant that is not a potential pre-base-reordering Ra.\n-     *\/\n-    if (reph_pos == REPH_POS_AFTER_MAIN)\n-    {\n-      new_reph_pos = base;\n-      while (new_reph_pos + 1 < end && info[new_reph_pos + 1].indic_position() <= POS_AFTER_MAIN)\n-        new_reph_pos++;\n-      if (new_reph_pos < end)\n-        goto reph_move;\n-    }\n-\n-    \/*       4. If reph should be positioned before post-base consonant, find\n-     *          first post-base classified consonant not ligated with main. If no\n-     *          consonant is found, the target position should be before the\n-     *          first matra, syllable modifier sign or vedic sign.\n-     *\/\n-    \/* This is our take on what step 4 is trying to say (and failing, BADLY). *\/\n-    if (reph_pos == REPH_POS_AFTER_SUB)\n-    {\n-      new_reph_pos = base;\n-      while (new_reph_pos + 1 < end &&\n-             !( FLAG_UNSAFE (info[new_reph_pos + 1].indic_position()) & (FLAG (POS_POST_C) | FLAG (POS_AFTER_POST) | FLAG (POS_SMVD))))\n-        new_reph_pos++;\n-      if (new_reph_pos < end)\n-        goto reph_move;\n-    }\n-\n-    \/*       5. If no consonant is found in steps 3 or 4, move reph to a position\n-     *          immediately before the first post-base matra, syllable modifier\n-     *          sign or vedic sign that has a reordering class after the intended\n-     *          reph position. For example, if the reordering position for reph\n-     *          is post-main, it will skip above-base matras that also have a\n-     *          post-main position.\n-     *\/\n-    reph_step_5:\n-    {\n-      \/* Copied from step 2. *\/\n-      new_reph_pos = start + 1;\n-      while (new_reph_pos < base && !is_halant (info[new_reph_pos]))\n-        new_reph_pos++;\n-\n-      if (new_reph_pos < base && is_halant (info[new_reph_pos]))\n-      {\n-        \/* ->If ZWJ or ZWNJ are following this halant, position is moved after it. *\/\n-        if (new_reph_pos + 1 < base && is_joiner (info[new_reph_pos + 1]))\n-          new_reph_pos++;\n-        goto reph_move;\n-      }\n-    }\n-    \/* See https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2298#issuecomment-615318654 *\/\n-\n-    \/*       6. Otherwise, reorder reph to the end of the syllable.\n-     *\/\n-    {\n-      new_reph_pos = end - 1;\n-      while (new_reph_pos > start && info[new_reph_pos].indic_position() == POS_SMVD)\n-        new_reph_pos--;\n-\n-      \/*\n-       * If the Reph is to be ending up after a Matra,Halant sequence,\n-       * position it before that Halant so it can interact with the Matra.\n-       * However, if it's a plain Consonant,Halant we shouldn't do that.\n-       * Uniscribe doesn't do this.\n-       * TEST: U+0930,U+094D,U+0915,U+094B,U+094D\n-       *\/\n-      if (!indic_plan->uniscribe_bug_compatible &&\n-          unlikely (is_halant (info[new_reph_pos])))\n-      {\n-        for (unsigned int i = base + 1; i < new_reph_pos; i++)\n-          if (info[i].indic_category() == OT_M) {\n-            \/* Ok, got it. *\/\n-            new_reph_pos--;\n-          }\n-      }\n-\n-      goto reph_move;\n-    }\n-\n-    reph_move:\n-    {\n-      \/* Move *\/\n-      buffer->merge_clusters (start, new_reph_pos + 1);\n-      hb_glyph_info_t reph = info[start];\n-      memmove (&info[start], &info[start + 1], (new_reph_pos - start) * sizeof (info[0]));\n-      info[new_reph_pos] = reph;\n-\n-      if (start < base && base <= new_reph_pos)\n-        base--;\n-    }\n-  }\n-\n-\n-  \/*   o Reorder pre-base-reordering consonants:\n-   *\n-   *     If a pre-base-reordering consonant is found, reorder it according to\n-   *     the following rules:\n-   *\/\n-\n-  if (try_pref && base + 1 < end) \/* Otherwise there can't be any pre-base-reordering Ra. *\/\n-  {\n-    for (unsigned int i = base + 1; i < end; i++)\n-      if ((info[i].mask & indic_plan->mask_array[INDIC_PREF]) != 0)\n-      {\n-        \/*       1. Only reorder a glyph produced by substitution during application\n-         *          of the <pref> feature. (Note that a font may shape a Ra consonant with\n-         *          the feature generally but block it in certain contexts.)\n-         *\/\n-        \/* Note: We just check that something got substituted.  We don't check that\n-         * the <pref> feature actually did it...\n-         *\n-         * Reorder pref only if it ligated. *\/\n-        if (_hb_glyph_info_ligated_and_didnt_multiply (&info[i]))\n-        {\n-          \/*\n-           *       2. Try to find a target position the same way as for pre-base matra.\n-           *          If it is found, reorder pre-base consonant glyph.\n-           *\n-           *       3. If position is not found, reorder immediately before main\n-           *          consonant.\n-           *\/\n-\n-          unsigned int new_pos = base;\n-          \/* Malayalam \/ Tamil do not have \"half\" forms or explicit virama forms.\n-           * The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n-           * We want to position matra after them.\n-           *\/\n-          if (buffer->props.script != HB_SCRIPT_MALAYALAM && buffer->props.script != HB_SCRIPT_TAMIL)\n-          {\n-            while (new_pos > start &&\n-                   !(is_one_of (info[new_pos - 1], FLAG(OT_M) | FLAG (OT_H))))\n-              new_pos--;\n-          }\n-\n-          if (new_pos > start && is_halant (info[new_pos - 1]))\n-          {\n-            \/* -> If ZWJ or ZWNJ follow this halant, position is moved after it. *\/\n-            if (new_pos < end && is_joiner (info[new_pos]))\n-              new_pos++;\n-          }\n-\n-          {\n-            unsigned int old_pos = i;\n-\n-            buffer->merge_clusters (new_pos, old_pos + 1);\n-            hb_glyph_info_t tmp = info[old_pos];\n-            memmove (&info[new_pos + 1], &info[new_pos], (old_pos - new_pos) * sizeof (info[0]));\n-            info[new_pos] = tmp;\n-\n-            if (new_pos <= base && base < old_pos)\n-              base++;\n-          }\n-        }\n-\n-        break;\n-      }\n-  }\n-\n-\n-  \/* Apply 'init' to the Left Matra if it's a word start. *\/\n-  if (info[start].indic_position () == POS_PRE_M)\n-  {\n-    if (!start ||\n-        !(FLAG_UNSAFE (_hb_glyph_info_get_general_category (&info[start - 1])) &\n-         FLAG_RANGE (HB_UNICODE_GENERAL_CATEGORY_FORMAT, HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))\n-      info[start].mask |= indic_plan->mask_array[INDIC_INIT];\n-    else\n-      buffer->unsafe_to_break (start - 1, start + 1);\n-  }\n-\n-\n-  \/*\n-   * Finish off the clusters and go home!\n-   *\/\n-  if (indic_plan->uniscribe_bug_compatible)\n-  {\n-    switch ((hb_tag_t) plan->props.script)\n-    {\n-      case HB_SCRIPT_TAMIL:\n-      case HB_SCRIPT_SINHALA:\n-        break;\n-\n-      default:\n-        \/* Uniscribe merges the entire syllable into a single cluster... Except for Tamil & Sinhala.\n-         * This means, half forms are submerged into the main consonant's cluster.\n-         * This is unnecessary, and makes cursor positioning harder, but that's what\n-         * Uniscribe does. *\/\n-        buffer->merge_clusters (start, end);\n-        break;\n-    }\n-  }\n-}\n-\n-\n-static void\n-final_reordering_indic (const hb_ot_shape_plan_t *plan,\n-                        hb_font_t *font HB_UNUSED,\n-                        hb_buffer_t *buffer)\n-{\n-  unsigned int count = buffer->len;\n-  if (unlikely (!count)) return;\n-\n-  if (buffer->message (font, \"start reordering indic final\")) {\n-    foreach_syllable (buffer, start, end)\n-      final_reordering_syllable_indic (plan, buffer, start, end);\n-    (void) buffer->message (font, \"end reordering indic final\");\n-  }\n-\n-  HB_BUFFER_DEALLOCATE_VAR (buffer, indic_category);\n-  HB_BUFFER_DEALLOCATE_VAR (buffer, indic_position);\n-}\n-\n-\n-static void\n-preprocess_text_indic (const hb_ot_shape_plan_t *plan,\n-                       hb_buffer_t              *buffer,\n-                       hb_font_t                *font)\n-{\n-  _hb_preprocess_text_vowel_constraints (plan, buffer, font);\n-}\n-\n-static bool\n-decompose_indic (const hb_ot_shape_normalize_context_t *c,\n-                 hb_codepoint_t  ab,\n-                 hb_codepoint_t *a,\n-                 hb_codepoint_t *b)\n-{\n-  switch (ab)\n-  {\n-    \/* Don't decompose these. *\/\n-    case 0x0931u  : return false; \/* DEVANAGARI LETTER RRA *\/\n-    \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/779\n-    case 0x09DCu  : return false; \/* BENGALI LETTER RRA *\/\n-    case 0x09DDu  : return false; \/* BENGALI LETTER RHA *\/\n-    case 0x0B94u  : return false; \/* TAMIL LETTER AU *\/\n-\n-\n-    \/*\n-     * Decompose split matras that don't have Unicode decompositions.\n-     *\/\n-\n-#if 0\n-    \/* Gujarati *\/\n-    \/* This one has no decomposition in Unicode, but needs no decomposition either. *\/\n-    \/* case 0x0AC9u  : return false; *\/\n-\n-    \/* Oriya *\/\n-    case 0x0B57u  : *a = no decomp, -> RIGHT; return true;\n-#endif\n-  }\n-\n-  if ((ab == 0x0DDAu || hb_in_range<hb_codepoint_t> (ab, 0x0DDCu, 0x0DDEu)))\n-  {\n-    \/*\n-     * Sinhala split matras...  Let the fun begin.\n-     *\n-     * These four characters have Unicode decompositions.  However, Uniscribe\n-     * decomposes them \"Khmer-style\", that is, it uses the character itself to\n-     * get the second half.  The first half of all four decompositions is always\n-     * U+0DD9.\n-     *\n-     * Now, there are buggy fonts, namely, the widely used lklug.ttf, that are\n-     * broken with Uniscribe.  But we need to support them.  As such, we only\n-     * do the Uniscribe-style decomposition if the character is transformed into\n-     * its \"sec.half\" form by the 'pstf' feature.  Otherwise, we fall back to\n-     * Unicode decomposition.\n-     *\n-     * Note that we can't unconditionally use Unicode decomposition.  That would\n-     * break some other fonts, that are designed to work with Uniscribe, and\n-     * don't have positioning features for the Unicode-style decomposition.\n-     *\n-     * Argh...\n-     *\n-     * The Uniscribe behavior is now documented in the newly published Sinhala\n-     * spec in 2012:\n-     *\n-     *   https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/sinhala#shaping\n-     *\/\n-\n-\n-    const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) c->plan->data;\n-    hb_codepoint_t glyph;\n-    if (indic_plan->uniscribe_bug_compatible ||\n-        (c->font->get_nominal_glyph (ab, &glyph) &&\n-         indic_plan->pstf.would_substitute (&glyph, 1, c->font->face)))\n-    {\n-      \/* Ok, safe to use Uniscribe-style decomposition. *\/\n-      *a = 0x0DD9u;\n-      *b = ab;\n-      return true;\n-    }\n-  }\n-\n-  return (bool) c->unicode->decompose (ab, a, b);\n-}\n-\n-static bool\n-compose_indic (const hb_ot_shape_normalize_context_t *c,\n-               hb_codepoint_t  a,\n-               hb_codepoint_t  b,\n-               hb_codepoint_t *ab)\n-{\n-  \/* Avoid recomposing split matras. *\/\n-  if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c->unicode->general_category (a)))\n-    return false;\n-\n-  \/* Composition-exclusion exceptions that we want to recompose. *\/\n-  if (a == 0x09AFu && b == 0x09BCu) { *ab = 0x09DFu; return true; }\n-\n-  return (bool) c->unicode->compose (a, b, ab);\n-}\n-\n-\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_indic =\n-{\n-  collect_features_indic,\n-  override_features_indic,\n-  data_create_indic,\n-  data_destroy_indic,\n-  preprocess_text_indic,\n-  nullptr, \/* postprocess_glyphs *\/\n-  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n-  decompose_indic,\n-  compose_indic,\n-  setup_masks_indic,\n-  HB_TAG_NONE, \/* gpos_tag *\/\n-  nullptr, \/* reorder_marks *\/\n-  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n-  false, \/* fallback_position *\/\n-};\n-\n-\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-indic.cc","additions":0,"deletions":1573,"binary":false,"changes":1573,"status":"deleted"},{"patch":"@@ -1,430 +0,0 @@\n-\/*\n- * Copyright  2012  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_INDIC_HH\n-#define HB_OT_SHAPE_COMPLEX_INDIC_HH\n-\n-#include \"hb.hh\"\n-\n-#include \"hb-ot-shape-complex-syllabic.hh\"\n-\n-\n-\/* buffer var allocations *\/\n-#define indic_category() complex_var_u8_category() \/* indic_category_t *\/\n-#define indic_position() complex_var_u8_auxiliary() \/* indic_position_t *\/\n-\n-\n-\/* Cateories used in the OpenType spec:\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/devanagari\n- *\/\n-\/* Note: This enum is duplicated in the -machine.rl source file.\n- * Not sure how to avoid duplication. *\/\n-enum indic_category_t {\n-  OT_X = 0,\n-  OT_C = 1,\n-  OT_V = 2,\n-  OT_N = 3,\n-  OT_H = 4,\n-  OT_ZWNJ = 5,\n-  OT_ZWJ = 6,\n-  OT_M = 7,\n-  OT_SM = 8,\n-  \/* OT_VD = 9, UNUSED; we use OT_A instead. *\/\n-  OT_A = 10,\n-  OT_PLACEHOLDER = 11,\n-  OT_DOTTEDCIRCLE = 12,\n-  OT_RS = 13, \/* Register Shifter, used in Khmer OT spec. *\/\n-  OT_Coeng = 14, \/* Khmer-style Virama. *\/\n-  OT_Repha = 15, \/* Atomically-encoded logical or visual repha. *\/\n-  OT_Ra = 16,\n-  OT_CM = 17,  \/* Consonant-Medial. *\/\n-  OT_Symbol = 18, \/* Avagraha, etc that take marks (SM,A,VD). *\/\n-  OT_CS = 19,\n-\n-  \/* The following are used by Khmer & Myanmar shapers.  Defined\n-   * here for them to share. *\/\n-  OT_VAbv    = 26,\n-  OT_VBlw    = 27,\n-  OT_VPre    = 28,\n-  OT_VPst    = 29,\n-};\n-\n-#define MEDIAL_FLAGS (FLAG (OT_CM))\n-\n-\/* Note:\n- *\n- * We treat Vowels and placeholders as if they were consonants.  This is safe because Vowels\n- * cannot happen in a consonant syllable.  The plus side however is, we can call the\n- * consonant syllable logic from the vowel syllable function and get it all right! *\/\n-#define CONSONANT_FLAGS (FLAG (OT_C) | FLAG (OT_CS) | FLAG (OT_Ra) | MEDIAL_FLAGS | FLAG (OT_V) | FLAG (OT_PLACEHOLDER) | FLAG (OT_DOTTEDCIRCLE))\n-#define JOINER_FLAGS (FLAG (OT_ZWJ) | FLAG (OT_ZWNJ))\n-\n-\n-\/* Visual positions in a syllable from left to right. *\/\n-enum indic_position_t {\n-  POS_START = 0,\n-\n-  POS_RA_TO_BECOME_REPH = 1,\n-  POS_PRE_M = 2,\n-  POS_PRE_C = 3,\n-\n-  POS_BASE_C = 4,\n-  POS_AFTER_MAIN = 5,\n-\n-  POS_ABOVE_C = 6,\n-\n-  POS_BEFORE_SUB = 7,\n-  POS_BELOW_C = 8,\n-  POS_AFTER_SUB = 9,\n-\n-  POS_BEFORE_POST = 10,\n-  POS_POST_C = 11,\n-  POS_AFTER_POST = 12,\n-\n-  POS_FINAL_C = 13,\n-  POS_SMVD = 14,\n-\n-  POS_END = 15\n-};\n-\n-\/* Categories used in IndicSyllabicCategory.txt from UCD. *\/\n-enum indic_syllabic_category_t {\n-  INDIC_SYLLABIC_CATEGORY_OTHER                         = OT_X,\n-\n-  INDIC_SYLLABIC_CATEGORY_AVAGRAHA                      = OT_Symbol,\n-  INDIC_SYLLABIC_CATEGORY_BINDU                         = OT_SM,\n-  INDIC_SYLLABIC_CATEGORY_BRAHMI_JOINING_NUMBER         = OT_PLACEHOLDER, \/* Don't care. *\/\n-  INDIC_SYLLABIC_CATEGORY_CANTILLATION_MARK             = OT_A,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT                     = OT_C,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_DEAD                = OT_C,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_FINAL               = OT_CM,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_HEAD_LETTER         = OT_C,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_KILLER              = OT_M, \/* U+17CD only. *\/\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL              = OT_CM,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_PLACEHOLDER         = OT_PLACEHOLDER,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_PRECEDING_REPHA     = OT_Repha,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_PREFIXED            = OT_X, \/* Don't care. *\/\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_SUBJOINED           = OT_CM,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_SUCCEEDING_REPHA    = OT_CM,\n-  INDIC_SYLLABIC_CATEGORY_CONSONANT_WITH_STACKER        = OT_CS,\n-  INDIC_SYLLABIC_CATEGORY_GEMINATION_MARK               = OT_SM, \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/552 *\/\n-  INDIC_SYLLABIC_CATEGORY_INVISIBLE_STACKER             = OT_Coeng,\n-  INDIC_SYLLABIC_CATEGORY_JOINER                        = OT_ZWJ,\n-  INDIC_SYLLABIC_CATEGORY_MODIFYING_LETTER              = OT_X,\n-  INDIC_SYLLABIC_CATEGORY_NON_JOINER                    = OT_ZWNJ,\n-  INDIC_SYLLABIC_CATEGORY_NUKTA                         = OT_N,\n-  INDIC_SYLLABIC_CATEGORY_NUMBER                        = OT_PLACEHOLDER,\n-  INDIC_SYLLABIC_CATEGORY_NUMBER_JOINER                 = OT_PLACEHOLDER, \/* Don't care. *\/\n-  INDIC_SYLLABIC_CATEGORY_PURE_KILLER                   = OT_M, \/* Is like a vowel matra. *\/\n-  INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER              = OT_RS,\n-  INDIC_SYLLABIC_CATEGORY_SYLLABLE_MODIFIER             = OT_SM,\n-  INDIC_SYLLABIC_CATEGORY_TONE_LETTER                   = OT_X,\n-  INDIC_SYLLABIC_CATEGORY_TONE_MARK                     = OT_N,\n-  INDIC_SYLLABIC_CATEGORY_VIRAMA                        = OT_H,\n-  INDIC_SYLLABIC_CATEGORY_VISARGA                       = OT_SM,\n-  INDIC_SYLLABIC_CATEGORY_VOWEL                         = OT_V,\n-  INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT               = OT_M,\n-  INDIC_SYLLABIC_CATEGORY_VOWEL_INDEPENDENT             = OT_V\n-};\n-\n-\/* Categories used in IndicSMatraCategory.txt from UCD *\/\n-enum indic_matra_category_t {\n-  INDIC_MATRA_CATEGORY_NOT_APPLICABLE                   = POS_END,\n-\n-  INDIC_MATRA_CATEGORY_LEFT                             = POS_PRE_C,\n-  INDIC_MATRA_CATEGORY_TOP                              = POS_ABOVE_C,\n-  INDIC_MATRA_CATEGORY_BOTTOM                           = POS_BELOW_C,\n-  INDIC_MATRA_CATEGORY_RIGHT                            = POS_POST_C,\n-\n-  \/* These should resolve to the position of the last part of the split sequence. *\/\n-  INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT                 = INDIC_MATRA_CATEGORY_RIGHT,\n-  INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT                   = INDIC_MATRA_CATEGORY_RIGHT,\n-  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM                   = INDIC_MATRA_CATEGORY_BOTTOM,\n-  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_LEFT          = INDIC_MATRA_CATEGORY_BOTTOM,\n-  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT         = INDIC_MATRA_CATEGORY_RIGHT,\n-  INDIC_MATRA_CATEGORY_TOP_AND_LEFT                     = INDIC_MATRA_CATEGORY_TOP,\n-  INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT           = INDIC_MATRA_CATEGORY_RIGHT,\n-  INDIC_MATRA_CATEGORY_TOP_AND_RIGHT                    = INDIC_MATRA_CATEGORY_RIGHT,\n-\n-  INDIC_MATRA_CATEGORY_OVERSTRUCK                       = POS_AFTER_MAIN,\n-  INDIC_MATRA_CATEGORY_VISUAL_ORDER_LEFT                = POS_PRE_M\n-};\n-\n-#define INDIC_COMBINE_CATEGORIES(S,M) \\\n-  ( \\\n-    static_assert_expr (S < 255 && M < 255) + \\\n-    ( S | \\\n-     ( \\\n-      ( \\\n-       S == INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL || \\\n-       S == INDIC_SYLLABIC_CATEGORY_GEMINATION_MARK || \\\n-       S == INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER || \\\n-       S == INDIC_SYLLABIC_CATEGORY_CONSONANT_SUCCEEDING_REPHA || \\\n-       S == INDIC_SYLLABIC_CATEGORY_VIRAMA || \\\n-       S == INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT || \\\n-       false \\\n-       ? M : INDIC_MATRA_CATEGORY_NOT_APPLICABLE \\\n-      ) << 8 \\\n-     ) \\\n-    ) \\\n-   )\n-\n-HB_INTERNAL uint16_t\n-hb_indic_get_categories (hb_codepoint_t u);\n-\n-\n-static inline bool\n-is_one_of (const hb_glyph_info_t &info, unsigned int flags)\n-{\n-  \/* If it ligated, all bets are off. *\/\n-  if (_hb_glyph_info_ligated (&info)) return false;\n-  return !!(FLAG_UNSAFE (info.indic_category()) & flags);\n-}\n-\n-static inline bool\n-is_joiner (const hb_glyph_info_t &info)\n-{\n-  return is_one_of (info, JOINER_FLAGS);\n-}\n-\n-static inline bool\n-is_consonant (const hb_glyph_info_t &info)\n-{\n-  return is_one_of (info, CONSONANT_FLAGS);\n-}\n-\n-static inline bool\n-is_halant (const hb_glyph_info_t &info)\n-{\n-  return is_one_of (info, FLAG (OT_H));\n-}\n-\n-#define IN_HALF_BLOCK(u, Base) (((u) & ~0x7Fu) == (Base))\n-\n-#define IS_DEVA(u) (IN_HALF_BLOCK (u, 0x0900u))\n-#define IS_BENG(u) (IN_HALF_BLOCK (u, 0x0980u))\n-#define IS_GURU(u) (IN_HALF_BLOCK (u, 0x0A00u))\n-#define IS_GUJR(u) (IN_HALF_BLOCK (u, 0x0A80u))\n-#define IS_ORYA(u) (IN_HALF_BLOCK (u, 0x0B00u))\n-#define IS_TAML(u) (IN_HALF_BLOCK (u, 0x0B80u))\n-#define IS_TELU(u) (IN_HALF_BLOCK (u, 0x0C00u))\n-#define IS_KNDA(u) (IN_HALF_BLOCK (u, 0x0C80u))\n-#define IS_MLYM(u) (IN_HALF_BLOCK (u, 0x0D00u))\n-#define IS_SINH(u) (IN_HALF_BLOCK (u, 0x0D80u))\n-\n-\n-#define MATRA_POS_LEFT(u)       POS_PRE_M\n-#define MATRA_POS_RIGHT(u)      ( \\\n-                                  IS_DEVA(u) ? POS_AFTER_SUB  : \\\n-                                  IS_BENG(u) ? POS_AFTER_POST : \\\n-                                  IS_GURU(u) ? POS_AFTER_POST : \\\n-                                  IS_GUJR(u) ? POS_AFTER_POST : \\\n-                                  IS_ORYA(u) ? POS_AFTER_POST : \\\n-                                  IS_TAML(u) ? POS_AFTER_POST : \\\n-                                  IS_TELU(u) ? (u <= 0x0C42u ? POS_BEFORE_SUB : POS_AFTER_SUB) : \\\n-                                  IS_KNDA(u) ? (u < 0x0CC3u || u > 0xCD6u ? POS_BEFORE_SUB : POS_AFTER_SUB) : \\\n-                                  IS_MLYM(u) ? POS_AFTER_POST : \\\n-                                  IS_SINH(u) ? POS_AFTER_SUB  : \\\n-                                  \/*default*\/  POS_AFTER_SUB    \\\n-                                )\n-#define MATRA_POS_TOP(u)        ( \/* BENG and MLYM don't have top matras. *\/ \\\n-                                  IS_DEVA(u) ? POS_AFTER_SUB  : \\\n-                                  IS_GURU(u) ? POS_AFTER_POST : \/* Deviate from spec *\/ \\\n-                                  IS_GUJR(u) ? POS_AFTER_SUB  : \\\n-                                  IS_ORYA(u) ? POS_AFTER_MAIN : \\\n-                                  IS_TAML(u) ? POS_AFTER_SUB  : \\\n-                                  IS_TELU(u) ? POS_BEFORE_SUB : \\\n-                                  IS_KNDA(u) ? POS_BEFORE_SUB : \\\n-                                  IS_SINH(u) ? POS_AFTER_SUB  : \\\n-                                  \/*default*\/  POS_AFTER_SUB    \\\n-                                )\n-#define MATRA_POS_BOTTOM(u)     ( \\\n-                                  IS_DEVA(u) ? POS_AFTER_SUB  : \\\n-                                  IS_BENG(u) ? POS_AFTER_SUB  : \\\n-                                  IS_GURU(u) ? POS_AFTER_POST : \\\n-                                  IS_GUJR(u) ? POS_AFTER_POST : \\\n-                                  IS_ORYA(u) ? POS_AFTER_SUB  : \\\n-                                  IS_TAML(u) ? POS_AFTER_POST : \\\n-                                  IS_TELU(u) ? POS_BEFORE_SUB : \\\n-                                  IS_KNDA(u) ? POS_BEFORE_SUB : \\\n-                                  IS_MLYM(u) ? POS_AFTER_POST : \\\n-                                  IS_SINH(u) ? POS_AFTER_SUB  : \\\n-                                  \/*default*\/  POS_AFTER_SUB    \\\n-                                )\n-\n-static inline indic_position_t\n-matra_position_indic (hb_codepoint_t u, indic_position_t side)\n-{\n-  switch ((int) side)\n-  {\n-    case POS_PRE_C:     return MATRA_POS_LEFT (u);\n-    case POS_POST_C:    return MATRA_POS_RIGHT (u);\n-    case POS_ABOVE_C:   return MATRA_POS_TOP (u);\n-    case POS_BELOW_C:   return MATRA_POS_BOTTOM (u);\n-  }\n-  return side;\n-}\n-\n-\/* XXX\n- * This is a hack for now.  We should move this data into the main Indic table.\n- * Or completely remove it and just check in the tables.\n- *\/\n-static const hb_codepoint_t ra_chars[] = {\n-  0x0930u, \/* Devanagari *\/\n-  0x09B0u, \/* Bengali *\/\n-  0x09F0u, \/* Bengali *\/\n-  0x0A30u, \/* Gurmukhi *\/       \/* No Reph *\/\n-  0x0AB0u, \/* Gujarati *\/\n-  0x0B30u, \/* Oriya *\/\n-  0x0BB0u, \/* Tamil *\/          \/* No Reph *\/\n-  0x0C30u, \/* Telugu *\/         \/* Reph formed only with ZWJ *\/\n-  0x0CB0u, \/* Kannada *\/\n-  0x0D30u, \/* Malayalam *\/      \/* No Reph, Logical Repha *\/\n-\n-  0x0DBBu, \/* Sinhala *\/        \/* Reph formed only with ZWJ *\/\n-};\n-\n-static inline bool\n-is_ra (hb_codepoint_t u)\n-{\n-  return hb_array (ra_chars).lfind (u);\n-}\n-\n-static inline void\n-set_indic_properties (hb_glyph_info_t &info)\n-{\n-  hb_codepoint_t u = info.codepoint;\n-  unsigned int type = hb_indic_get_categories (u);\n-  indic_category_t cat = (indic_category_t) (type & 0xFFu);\n-  indic_position_t pos = (indic_position_t) (type >> 8);\n-\n-\n-  \/*\n-   * Re-assign category\n-   *\/\n-\n-  \/* The following act more like the Bindus. *\/\n-  if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x0953u, 0x0954u)))\n-    cat = OT_SM;\n-  \/* The following act like consonants. *\/\n-  else if (unlikely (hb_in_ranges<hb_codepoint_t> (u, 0x0A72u, 0x0A73u,\n-                                      0x1CF5u, 0x1CF6u)))\n-    cat = OT_C;\n-  \/* TODO: The following should only be allowed after a Visarga.\n-   * For now, just treat them like regular tone marks. *\/\n-  else if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x1CE2u, 0x1CE8u)))\n-    cat = OT_A;\n-  \/* TODO: The following should only be allowed after some of\n-   * the nasalization marks, maybe only for U+1CE9..U+1CF1.\n-   * For now, just treat them like tone marks. *\/\n-  else if (unlikely (u == 0x1CEDu))\n-    cat = OT_A;\n-  \/* The following take marks in standalone clusters, similar to Avagraha. *\/\n-  else if (unlikely (hb_in_ranges<hb_codepoint_t> (u, 0xA8F2u, 0xA8F7u,\n-                                      0x1CE9u, 0x1CECu,\n-                                      0x1CEEu, 0x1CF1u)))\n-  {\n-    cat = OT_Symbol;\n-    static_assert (((int) INDIC_SYLLABIC_CATEGORY_AVAGRAHA == OT_Symbol), \"\");\n-  }\n-  else if (unlikely (u == 0x0A51u))\n-  {\n-    \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/524 *\/\n-    cat = OT_M;\n-    pos = POS_BELOW_C;\n-  }\n-\n-  \/* According to ScriptExtensions.txt, these Grantha marks may also be used in Tamil,\n-   * so the Indic shaper needs to know their categories. *\/\n-  else if (unlikely (u == 0x11301u || u == 0x11303u)) cat = OT_SM;\n-  else if (unlikely (u == 0x1133Bu || u == 0x1133Cu)) cat = OT_N;\n-\n-  else if (unlikely (u == 0x0AFBu)) cat = OT_N; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/552 *\/\n-  else if (unlikely (u == 0x0B55u)) cat = OT_N; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2849 *\/\n-\n-  else if (unlikely (u == 0x0980u)) cat = OT_PLACEHOLDER; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/538 *\/\n-  else if (unlikely (u == 0x09FCu)) cat = OT_PLACEHOLDER; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/1613 *\/\n-  else if (unlikely (u == 0x0C80u)) cat = OT_PLACEHOLDER; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/623 *\/\n-  else if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x2010u, 0x2011u)))\n-                                    cat = OT_PLACEHOLDER;\n-  else if (unlikely (u == 0x25CCu)) cat = OT_DOTTEDCIRCLE;\n-\n-\n-  \/*\n-   * Re-assign position.\n-   *\/\n-\n-  if ((FLAG_UNSAFE (cat) & CONSONANT_FLAGS))\n-  {\n-    pos = POS_BASE_C;\n-    if (is_ra (u))\n-      cat = OT_Ra;\n-  }\n-  else if (cat == OT_M)\n-  {\n-    pos = matra_position_indic (u, pos);\n-  }\n-  else if ((FLAG_UNSAFE (cat) & (FLAG (OT_SM) \/* | FLAG (OT_VD) *\/ | FLAG (OT_A) | FLAG (OT_Symbol))))\n-  {\n-    pos = POS_SMVD;\n-  }\n-\n-  if (unlikely (u == 0x0B01u)) pos = POS_BEFORE_SUB; \/* Oriya Bindu is BeforeSub in the spec. *\/\n-\n-\n-\n-  info.indic_category() = cat;\n-  info.indic_position() = pos;\n-}\n-\n-struct hb_indic_would_substitute_feature_t\n-{\n-  void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)\n-  {\n-    zero_context = zero_context_;\n-    map->get_stage_lookups (0\/*GSUB*\/,\n-                            map->get_feature_stage (0\/*GSUB*\/, feature_tag),\n-                            &lookups, &count);\n-  }\n-\n-  bool would_substitute (const hb_codepoint_t *glyphs,\n-                         unsigned int          glyphs_count,\n-                         hb_face_t            *face) const\n-  {\n-    for (unsigned int i = 0; i < count; i++)\n-      if (hb_ot_layout_lookup_would_substitute (face, lookups[i].index, glyphs, glyphs_count, zero_context))\n-        return true;\n-    return false;\n-  }\n-\n-  private:\n-  const hb_ot_map_t::lookup_map_t *lookups;\n-  unsigned int count;\n-  bool zero_context;\n-};\n-\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_INDIC_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-indic.hh","additions":0,"deletions":430,"binary":false,"changes":430,"status":"deleted"},{"patch":"@@ -1,455 +0,0 @@\n-#line 1 \"hb-ot-shape-complex-khmer-machine.rl\"\n-\/*\n-* Copyright  2011,2012  Google, Inc.\n-*\n-*  This is part of HarfBuzz, a text shaping library.\n-*\n-* Permission is hereby granted, without written agreement and without\n-* license or royalty fees, to use, copy, modify, and distribute this\n-* software and its documentation for any purpose, provided that the\n-* above copyright notice and the following two paragraphs appear in\n-* all copies of this software.\n-*\n-* IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n-* DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n-* ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n-* IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n-* DAMAGE.\n-*\n-* THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n-* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n-* FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n-* ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n-* PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n-*\n-* Google Author(s): Behdad Esfahbod\n-*\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_KHMER_MACHINE_HH\n-#define HB_OT_SHAPE_COMPLEX_KHMER_MACHINE_HH\n-\n-#include \"hb.hh\"\n-\n-enum khmer_syllable_type_t {\n-        khmer_consonant_syllable,\n-        khmer_broken_cluster,\n-        khmer_non_khmer_cluster,\n-};\n-\n-\n-#line 41 \"hb-ot-shape-complex-khmer-machine.hh\"\n-#define khmer_syllable_machine_ex_C 1u\n-#define khmer_syllable_machine_ex_Coeng 14u\n-#define khmer_syllable_machine_ex_DOTTEDCIRCLE 12u\n-#define khmer_syllable_machine_ex_PLACEHOLDER 11u\n-#define khmer_syllable_machine_ex_Ra 16u\n-#define khmer_syllable_machine_ex_Robatic 20u\n-#define khmer_syllable_machine_ex_V 2u\n-#define khmer_syllable_machine_ex_VAbv 26u\n-#define khmer_syllable_machine_ex_VBlw 27u\n-#define khmer_syllable_machine_ex_VPre 28u\n-#define khmer_syllable_machine_ex_VPst 29u\n-#define khmer_syllable_machine_ex_Xgroup 21u\n-#define khmer_syllable_machine_ex_Ygroup 22u\n-#define khmer_syllable_machine_ex_ZWJ 6u\n-#define khmer_syllable_machine_ex_ZWNJ 5u\n-\n-\n-#line 59 \"hb-ot-shape-complex-khmer-machine.hh\"\n-static const unsigned char _khmer_syllable_machine_trans_keys[] = {\n-        2u, 8u, 2u, 6u, 2u, 8u, 2u, 6u,\n-        0u, 0u, 2u, 6u, 2u, 8u, 2u, 6u,\n-        2u, 8u, 2u, 6u, 2u, 6u, 2u, 8u,\n-        2u, 6u, 0u, 0u, 2u, 6u, 2u, 8u,\n-        2u, 6u, 2u, 8u, 2u, 6u, 2u, 8u,\n-        0u, 11u, 2u, 11u, 2u, 11u, 2u, 11u,\n-        7u, 7u, 2u, 7u, 2u, 11u, 2u, 11u,\n-        2u, 11u, 0u, 0u, 2u, 8u, 2u, 11u,\n-        2u, 11u, 7u, 7u, 2u, 7u, 2u, 11u,\n-        2u, 11u, 0u, 0u, 2u, 11u, 2u, 11u,\n-        0u\n-};\n-\n-static const signed char _khmer_syllable_machine_char_class[] = {\n-        0, 0, 1, 1, 2, 2, 1, 1,\n-        1, 1, 3, 3, 1, 4, 1, 0,\n-        1, 1, 1, 5, 6, 7, 1, 1,\n-        1, 8, 9, 10, 11, 0\n-};\n-\n-static const short _khmer_syllable_machine_index_offsets[] = {\n-        0, 7, 12, 19, 24, 25, 30, 37,\n-        42, 49, 54, 59, 66, 71, 72, 77,\n-        84, 89, 96, 101, 108, 120, 130, 140,\n-        150, 151, 157, 167, 177, 187, 188, 195,\n-        205, 215, 216, 222, 232, 242, 243, 253,\n-        0\n-};\n-\n-static const signed char _khmer_syllable_machine_indicies[] = {\n-        1, 0, 0, 2, 3, 0, 4, 1,\n-        0, 0, 0, 3, 1, 0, 0, 0,\n-        3, 0, 4, 5, 0, 0, 0, 4,\n-        6, 7, 0, 0, 0, 8, 9, 0,\n-        0, 0, 10, 0, 4, 9, 0, 0,\n-        0, 10, 11, 0, 0, 0, 12, 0,\n-        4, 11, 0, 0, 0, 12, 14, 13,\n-        13, 13, 15, 14, 16, 16, 16, 15,\n-        16, 17, 18, 16, 16, 16, 17, 19,\n-        20, 16, 16, 16, 21, 22, 16, 16,\n-        16, 23, 16, 17, 22, 16, 16, 16,\n-        23, 24, 16, 16, 16, 25, 16, 17,\n-        24, 16, 16, 16, 25, 14, 16, 16,\n-        26, 15, 16, 17, 29, 28, 30, 2,\n-        31, 28, 15, 19, 17, 23, 25, 21,\n-        33, 32, 34, 2, 3, 6, 4, 10,\n-        12, 8, 35, 32, 36, 32, 3, 6,\n-        4, 10, 12, 8, 5, 32, 36, 32,\n-        4, 6, 32, 32, 32, 8, 6, 7,\n-        32, 36, 32, 8, 6, 37, 32, 36,\n-        32, 10, 6, 4, 32, 32, 8, 38,\n-        32, 36, 32, 12, 6, 4, 10, 32,\n-        8, 35, 32, 34, 32, 3, 6, 4,\n-        10, 12, 8, 29, 14, 39, 39, 39,\n-        15, 39, 17, 41, 40, 42, 40, 15,\n-        19, 17, 23, 25, 21, 18, 40, 42,\n-        40, 17, 19, 40, 40, 40, 21, 19,\n-        20, 40, 42, 40, 21, 19, 43, 40,\n-        42, 40, 23, 19, 17, 40, 40, 21,\n-        44, 40, 42, 40, 25, 19, 17, 23,\n-        40, 21, 45, 46, 40, 31, 26, 15,\n-        19, 17, 23, 25, 21, 41, 40, 31,\n-        40, 15, 19, 17, 23, 25, 21, 0\n-};\n-\n-static const signed char _khmer_syllable_machine_index_defaults[] = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 13, 16, 16, 16, 16, 16,\n-        16, 16, 16, 16, 28, 32, 32, 32,\n-        32, 32, 32, 32, 32, 32, 39, 40,\n-        40, 40, 40, 40, 40, 40, 40, 40,\n-        0\n-};\n-\n-static const signed char _khmer_syllable_machine_cond_targs[] = {\n-        20, 1, 28, 22, 23, 3, 24, 5,\n-        25, 7, 26, 9, 27, 20, 10, 31,\n-        20, 32, 12, 33, 14, 34, 16, 35,\n-        18, 36, 39, 20, 20, 21, 30, 37,\n-        20, 0, 29, 2, 4, 6, 8, 20,\n-        20, 11, 13, 15, 17, 38, 19, 0\n-};\n-\n-static const signed char _khmer_syllable_machine_cond_actions[] = {\n-        1, 0, 2, 2, 2, 0, 0, 0,\n-        2, 0, 2, 0, 2, 3, 0, 4,\n-        5, 2, 0, 0, 0, 2, 0, 2,\n-        0, 2, 4, 0, 8, 2, 9, 0,\n-        10, 0, 0, 0, 0, 0, 0, 11,\n-        12, 0, 0, 0, 0, 4, 0, 0\n-};\n-\n-static const signed char _khmer_syllable_machine_to_state_actions[] = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 6, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0\n-};\n-\n-static const signed char _khmer_syllable_machine_from_state_actions[] = {\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 7, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0\n-};\n-\n-static const signed char _khmer_syllable_machine_eof_trans[] = {\n-        1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 14, 17, 17, 17, 17, 17,\n-        17, 17, 17, 17, 28, 33, 33, 33,\n-        33, 33, 33, 33, 33, 33, 40, 41,\n-        41, 41, 41, 41, 41, 41, 41, 41,\n-        0\n-};\n-\n-static const int khmer_syllable_machine_start = 20;\n-static const int khmer_syllable_machine_first_final = 20;\n-static const int khmer_syllable_machine_error = -1;\n-\n-static const int khmer_syllable_machine_en_main = 20;\n-\n-\n-#line 43 \"hb-ot-shape-complex-khmer-machine.rl\"\n-\n-\n-\n-#line 86 \"hb-ot-shape-complex-khmer-machine.rl\"\n-\n-\n-#define found_syllable(syllable_type) \\\n-HB_STMT_START { \\\n-        if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n-                for (unsigned int i = ts; i < te; i++) \\\n-        info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n-        syllable_serial++; \\\n-        if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n-        } HB_STMT_END\n-\n-static void\n-find_syllables_khmer (hb_buffer_t *buffer)\n-{\n-        unsigned int p, pe, eof, ts, te, act HB_UNUSED;\n-        int cs;\n-        hb_glyph_info_t *info = buffer->info;\n-\n-#line 210 \"hb-ot-shape-complex-khmer-machine.hh\"\n-        {\n-                cs = (int)khmer_syllable_machine_start;\n-                ts = 0;\n-                te = 0;\n-                act = 0;\n-        }\n-\n-#line 106 \"hb-ot-shape-complex-khmer-machine.rl\"\n-\n-\n-        p = 0;\n-        pe = eof = buffer->len;\n-\n-        unsigned int syllable_serial = 1;\n-\n-#line 226 \"hb-ot-shape-complex-khmer-machine.hh\"\n-        {\n-                unsigned int _trans = 0;\n-                const unsigned char * _keys;\n-                const signed char * _inds;\n-                int _ic;\n-                _resume: {}\n-                if ( p == pe && p != eof )\n-                        goto _out;\n-                switch ( _khmer_syllable_machine_from_state_actions[cs] ) {\n-                        case 7:  {\n-                                {\n-#line 1 \"NONE\"\n-                                        {ts = p;}}\n-\n-#line 241 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                break;\n-                        }\n-                }\n-\n-                if ( p == eof ) {\n-                        if ( _khmer_syllable_machine_eof_trans[cs] > 0 ) {\n-                                _trans = (unsigned int)_khmer_syllable_machine_eof_trans[cs] - 1;\n-                        }\n-                }\n-                else {\n-                        _keys = ( _khmer_syllable_machine_trans_keys + ((cs<<1)));\n-                        _inds = ( _khmer_syllable_machine_indicies + (_khmer_syllable_machine_index_offsets[cs]));\n-\n-                        if ( (info[p].khmer_category()) <= 29 && (info[p].khmer_category()) >= 1 ) {\n-                                _ic = (int)_khmer_syllable_machine_char_class[(int)(info[p].khmer_category()) - 1];\n-                                if ( _ic <= (int)(*( _keys+1)) && _ic >= (int)(*( _keys)) )\n-                                        _trans = (unsigned int)(*( _inds + (int)( _ic - (int)(*( _keys)) ) ));\n-                                else\n-                                        _trans = (unsigned int)_khmer_syllable_machine_index_defaults[cs];\n-                        }\n-                        else {\n-                                _trans = (unsigned int)_khmer_syllable_machine_index_defaults[cs];\n-                        }\n-\n-                }\n-                cs = (int)_khmer_syllable_machine_cond_targs[_trans];\n-\n-                if ( _khmer_syllable_machine_cond_actions[_trans] != 0 ) {\n-\n-                        switch ( _khmer_syllable_machine_cond_actions[_trans] ) {\n-                                case 2:  {\n-                                        {\n-#line 1 \"NONE\"\n-                                                {te = p+1;}}\n-\n-#line 279 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 8:  {\n-                                        {\n-#line 82 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                {te = p+1;{\n-#line 82 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                                found_syllable (khmer_non_khmer_cluster); }\n-                                                }}\n-\n-#line 292 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 10:  {\n-                                        {\n-#line 80 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 80 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                                found_syllable (khmer_consonant_syllable); }\n-                                                }}\n-\n-#line 305 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 12:  {\n-                                        {\n-#line 81 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 81 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                                found_syllable (khmer_broken_cluster); }\n-                                                }}\n-\n-#line 318 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 11:  {\n-                                        {\n-#line 82 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 82 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                                found_syllable (khmer_non_khmer_cluster); }\n-                                                }}\n-\n-#line 331 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 1:  {\n-                                        {\n-#line 80 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                {p = ((te))-1;\n-                                                        {\n-#line 80 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                                found_syllable (khmer_consonant_syllable); }\n-                                                }}\n-\n-#line 345 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 5:  {\n-                                        {\n-#line 81 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                {p = ((te))-1;\n-                                                        {\n-#line 81 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                                found_syllable (khmer_broken_cluster); }\n-                                                }}\n-\n-#line 359 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 3:  {\n-                                        {\n-#line 1 \"NONE\"\n-                                                {switch( act ) {\n-                                                                case 2:  {\n-                                                                        p = ((te))-1;\n-                                                                        {\n-#line 81 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                                                found_syllable (khmer_broken_cluster); }\n-                                                                        break;\n-                                                                }\n-                                                                case 3:  {\n-                                                                        p = ((te))-1;\n-                                                                        {\n-#line 82 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                                                found_syllable (khmer_non_khmer_cluster); }\n-                                                                        break;\n-                                                                }\n-                                                        }}\n-                                        }\n-\n-#line 385 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 4:  {\n-                                        {\n-#line 1 \"NONE\"\n-                                                {te = p+1;}}\n-\n-#line 395 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-                                        {\n-#line 81 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                {act = 2;}}\n-\n-#line 401 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 9:  {\n-                                        {\n-#line 1 \"NONE\"\n-                                                {te = p+1;}}\n-\n-#line 411 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-                                        {\n-#line 82 \"hb-ot-shape-complex-khmer-machine.rl\"\n-                                                {act = 3;}}\n-\n-#line 417 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                        }\n-\n-                }\n-\n-                if ( p == eof ) {\n-                        if ( cs >= 20 )\n-                                goto _out;\n-                }\n-                else {\n-                        switch ( _khmer_syllable_machine_to_state_actions[cs] ) {\n-                                case 6:  {\n-                                        {\n-#line 1 \"NONE\"\n-                                                {ts = 0;}}\n-\n-#line 437 \"hb-ot-shape-complex-khmer-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                        }\n-\n-                        p += 1;\n-                        goto _resume;\n-                }\n-                _out: {}\n-        }\n-\n-#line 114 \"hb-ot-shape-complex-khmer-machine.rl\"\n-\n-}\n-\n-#undef found_syllable\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_KHMER_MACHINE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-khmer-machine.hh","additions":0,"deletions":455,"binary":false,"changes":455,"status":"deleted"},{"patch":"@@ -1,369 +0,0 @@\n-\/*\n- * Copyright  2011,2012  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#include \"hb.hh\"\n-\n-#ifndef HB_NO_OT_SHAPE\n-\n-#include \"hb-ot-shape-complex-khmer.hh\"\n-#include \"hb-ot-shape-complex-khmer-machine.hh\"\n-#include \"hb-ot-layout.hh\"\n-\n-\n-\/*\n- * Khmer shaper.\n- *\/\n-\n-static const hb_ot_map_feature_t\n-khmer_features[] =\n-{\n-  \/*\n-   * Basic features.\n-   * These features are applied in order, one at a time, after reordering.\n-   *\/\n-  {HB_TAG('p','r','e','f'), F_MANUAL_JOINERS},\n-  {HB_TAG('b','l','w','f'), F_MANUAL_JOINERS},\n-  {HB_TAG('a','b','v','f'), F_MANUAL_JOINERS},\n-  {HB_TAG('p','s','t','f'), F_MANUAL_JOINERS},\n-  {HB_TAG('c','f','a','r'), F_MANUAL_JOINERS},\n-  \/*\n-   * Other features.\n-   * These features are applied all at once after clearing syllables.\n-   *\/\n-  {HB_TAG('p','r','e','s'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('a','b','v','s'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('b','l','w','s'), F_GLOBAL_MANUAL_JOINERS},\n-  {HB_TAG('p','s','t','s'), F_GLOBAL_MANUAL_JOINERS},\n-};\n-\n-\/*\n- * Must be in the same order as the khmer_features array.\n- *\/\n-enum {\n-  KHMER_PREF,\n-  KHMER_BLWF,\n-  KHMER_ABVF,\n-  KHMER_PSTF,\n-  KHMER_CFAR,\n-\n-  _KHMER_PRES,\n-  _KHMER_ABVS,\n-  _KHMER_BLWS,\n-  _KHMER_PSTS,\n-\n-  KHMER_NUM_FEATURES,\n-  KHMER_BASIC_FEATURES = _KHMER_PRES, \/* Don't forget to update this! *\/\n-};\n-\n-static void\n-setup_syllables_khmer (const hb_ot_shape_plan_t *plan,\n-                       hb_font_t *font,\n-                       hb_buffer_t *buffer);\n-static void\n-reorder_khmer (const hb_ot_shape_plan_t *plan,\n-               hb_font_t *font,\n-               hb_buffer_t *buffer);\n-\n-static void\n-collect_features_khmer (hb_ot_shape_planner_t *plan)\n-{\n-  hb_ot_map_builder_t *map = &plan->map;\n-\n-  \/* Do this before any lookups have been applied. *\/\n-  map->add_gsub_pause (setup_syllables_khmer);\n-  map->add_gsub_pause (reorder_khmer);\n-\n-  \/* Testing suggests that Uniscribe does NOT pause between basic\n-   * features.  Test with KhmerUI.ttf and the following three\n-   * sequences:\n-   *\n-   *   U+1789,U+17BC\n-   *   U+1789,U+17D2,U+1789\n-   *   U+1789,U+17D2,U+1789,U+17BC\n-   *\n-   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/974\n-   *\/\n-  map->enable_feature (HB_TAG('l','o','c','l'));\n-  map->enable_feature (HB_TAG('c','c','m','p'));\n-\n-  unsigned int i = 0;\n-  for (; i < KHMER_BASIC_FEATURES; i++)\n-    map->add_feature (khmer_features[i]);\n-\n-  map->add_gsub_pause (_hb_clear_syllables);\n-\n-  for (; i < KHMER_NUM_FEATURES; i++)\n-    map->add_feature (khmer_features[i]);\n-}\n-\n-static void\n-override_features_khmer (hb_ot_shape_planner_t *plan)\n-{\n-  hb_ot_map_builder_t *map = &plan->map;\n-\n-  \/* Khmer spec has 'clig' as part of required shaping features:\n-   * \"Apply feature 'clig' to form ligatures that are desired for\n-   * typographical correctness.\", hence in overrides... *\/\n-  map->enable_feature (HB_TAG('c','l','i','g'));\n-\n-  \/* Uniscribe does not apply 'kern' in Khmer. *\/\n-  if (hb_options ().uniscribe_bug_compatible)\n-  {\n-    map->disable_feature (HB_TAG('k','e','r','n'));\n-  }\n-\n-  map->disable_feature (HB_TAG('l','i','g','a'));\n-}\n-\n-\n-struct khmer_shape_plan_t\n-{\n-  hb_mask_t mask_array[KHMER_NUM_FEATURES];\n-};\n-\n-static void *\n-data_create_khmer (const hb_ot_shape_plan_t *plan)\n-{\n-  khmer_shape_plan_t *khmer_plan = (khmer_shape_plan_t *) calloc (1, sizeof (khmer_shape_plan_t));\n-  if (unlikely (!khmer_plan))\n-    return nullptr;\n-\n-  for (unsigned int i = 0; i < ARRAY_LENGTH (khmer_plan->mask_array); i++)\n-    khmer_plan->mask_array[i] = (khmer_features[i].flags & F_GLOBAL) ?\n-                                 0 : plan->map.get_1_mask (khmer_features[i].tag);\n-\n-  return khmer_plan;\n-}\n-\n-static void\n-data_destroy_khmer (void *data)\n-{\n-  free (data);\n-}\n-\n-static void\n-setup_masks_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                   hb_buffer_t              *buffer,\n-                   hb_font_t                *font HB_UNUSED)\n-{\n-  HB_BUFFER_ALLOCATE_VAR (buffer, khmer_category);\n-\n-  \/* We cannot setup masks here.  We save information about characters\n-   * and setup masks later on in a pause-callback. *\/\n-\n-  unsigned int count = buffer->len;\n-  hb_glyph_info_t *info = buffer->info;\n-  for (unsigned int i = 0; i < count; i++)\n-    set_khmer_properties (info[i]);\n-}\n-\n-static void\n-setup_syllables_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                       hb_font_t *font HB_UNUSED,\n-                       hb_buffer_t *buffer)\n-{\n-  find_syllables_khmer (buffer);\n-  foreach_syllable (buffer, start, end)\n-    buffer->unsafe_to_break (start, end);\n-}\n-\n-\n-\/* Rules from:\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/devanagari *\/\n-\n-static void\n-reorder_consonant_syllable (const hb_ot_shape_plan_t *plan,\n-                            hb_face_t *face HB_UNUSED,\n-                            hb_buffer_t *buffer,\n-                            unsigned int start, unsigned int end)\n-{\n-  const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan->data;\n-  hb_glyph_info_t *info = buffer->info;\n-\n-  \/* Setup masks. *\/\n-  {\n-    \/* Post-base *\/\n-    hb_mask_t mask = khmer_plan->mask_array[KHMER_BLWF] |\n-                     khmer_plan->mask_array[KHMER_ABVF] |\n-                     khmer_plan->mask_array[KHMER_PSTF];\n-    for (unsigned int i = start + 1; i < end; i++)\n-      info[i].mask  |= mask;\n-  }\n-\n-  unsigned int num_coengs = 0;\n-  for (unsigned int i = start + 1; i < end; i++)\n-  {\n-    \/* \"\"\"\n-     * When a COENG + (Cons | IndV) combination are found (and subscript count\n-     * is less than two) the character combination is handled according to the\n-     * subscript type of the character following the COENG.\n-     *\n-     * ...\n-     *\n-     * Subscript Type 2 - The COENG + RO characters are reordered to immediately\n-     * before the base glyph. Then the COENG + RO characters are assigned to have\n-     * the 'pref' OpenType feature applied to them.\n-     * \"\"\"\n-     *\/\n-    if (info[i].khmer_category() == OT_Coeng && num_coengs <= 2 && i + 1 < end)\n-    {\n-      num_coengs++;\n-\n-      if (info[i + 1].khmer_category() == OT_Ra)\n-      {\n-        for (unsigned int j = 0; j < 2; j++)\n-          info[i + j].mask |= khmer_plan->mask_array[KHMER_PREF];\n-\n-        \/* Move the Coeng,Ro sequence to the start. *\/\n-        buffer->merge_clusters (start, i + 2);\n-        hb_glyph_info_t t0 = info[i];\n-        hb_glyph_info_t t1 = info[i + 1];\n-        memmove (&info[start + 2], &info[start], (i - start) * sizeof (info[0]));\n-        info[start] = t0;\n-        info[start + 1] = t1;\n-\n-        \/* Mark the subsequent stuff with 'cfar'.  Used in Khmer.\n-         * Read the feature spec.\n-         * This allows distinguishing the following cases with MS Khmer fonts:\n-         * U+1784,U+17D2,U+179A,U+17D2,U+1782\n-         * U+1784,U+17D2,U+1782,U+17D2,U+179A\n-         *\/\n-        if (khmer_plan->mask_array[KHMER_CFAR])\n-          for (unsigned int j = i + 2; j < end; j++)\n-            info[j].mask |= khmer_plan->mask_array[KHMER_CFAR];\n-\n-        num_coengs = 2; \/* Done. *\/\n-      }\n-    }\n-\n-    \/* Reorder left matra piece. *\/\n-    else if (info[i].khmer_category() == OT_VPre)\n-    {\n-      \/* Move to the start. *\/\n-      buffer->merge_clusters (start, i + 1);\n-      hb_glyph_info_t t = info[i];\n-      memmove (&info[start + 1], &info[start], (i - start) * sizeof (info[0]));\n-      info[start] = t;\n-    }\n-  }\n-}\n-\n-static void\n-reorder_syllable_khmer (const hb_ot_shape_plan_t *plan,\n-                        hb_face_t *face,\n-                        hb_buffer_t *buffer,\n-                        unsigned int start, unsigned int end)\n-{\n-  khmer_syllable_type_t syllable_type = (khmer_syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n-  switch (syllable_type)\n-  {\n-    case khmer_broken_cluster: \/* We already inserted dotted-circles, so just call the consonant_syllable. *\/\n-    case khmer_consonant_syllable:\n-     reorder_consonant_syllable (plan, face, buffer, start, end);\n-     break;\n-\n-    case khmer_non_khmer_cluster:\n-      break;\n-  }\n-}\n-\n-static void\n-reorder_khmer (const hb_ot_shape_plan_t *plan,\n-               hb_font_t *font,\n-               hb_buffer_t *buffer)\n-{\n-  if (buffer->message (font, \"start reordering khmer\"))\n-  {\n-    hb_syllabic_insert_dotted_circles (font, buffer,\n-                                       khmer_broken_cluster,\n-                                       OT_DOTTEDCIRCLE,\n-                                       OT_Repha);\n-\n-    foreach_syllable (buffer, start, end)\n-      reorder_syllable_khmer (plan, font->face, buffer, start, end);\n-    (void) buffer->message (font, \"end reordering khmer\");\n-  }\n-  HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_category);\n-}\n-\n-\n-static bool\n-decompose_khmer (const hb_ot_shape_normalize_context_t *c,\n-                 hb_codepoint_t  ab,\n-                 hb_codepoint_t *a,\n-                 hb_codepoint_t *b)\n-{\n-  switch (ab)\n-  {\n-    \/*\n-     * Decompose split matras that don't have Unicode decompositions.\n-     *\/\n-\n-    \/* Khmer *\/\n-    case 0x17BEu  : *a = 0x17C1u; *b= 0x17BEu; return true;\n-    case 0x17BFu  : *a = 0x17C1u; *b= 0x17BFu; return true;\n-    case 0x17C0u  : *a = 0x17C1u; *b= 0x17C0u; return true;\n-    case 0x17C4u  : *a = 0x17C1u; *b= 0x17C4u; return true;\n-    case 0x17C5u  : *a = 0x17C1u; *b= 0x17C5u; return true;\n-  }\n-\n-  return (bool) c->unicode->decompose (ab, a, b);\n-}\n-\n-static bool\n-compose_khmer (const hb_ot_shape_normalize_context_t *c,\n-               hb_codepoint_t  a,\n-               hb_codepoint_t  b,\n-               hb_codepoint_t *ab)\n-{\n-  \/* Avoid recomposing split matras. *\/\n-  if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c->unicode->general_category (a)))\n-    return false;\n-\n-  return (bool) c->unicode->compose (a, b, ab);\n-}\n-\n-\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_khmer =\n-{\n-  collect_features_khmer,\n-  override_features_khmer,\n-  data_create_khmer,\n-  data_destroy_khmer,\n-  nullptr, \/* preprocess_text *\/\n-  nullptr, \/* postprocess_glyphs *\/\n-  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n-  decompose_khmer,\n-  compose_khmer,\n-  setup_masks_khmer,\n-  HB_TAG_NONE, \/* gpos_tag *\/\n-  nullptr, \/* reorder_marks *\/\n-  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n-  false, \/* fallback_position *\/\n-};\n-\n-\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-khmer.cc","additions":0,"deletions":369,"binary":false,"changes":369,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright  2018  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_KHMER_HH\n-#define HB_OT_SHAPE_COMPLEX_KHMER_HH\n-\n-#include \"hb.hh\"\n-\n-#include \"hb-ot-shape-complex-indic.hh\"\n-\n-\n-\/* buffer var allocations *\/\n-#define khmer_category() indic_category() \/* khmer_category_t *\/\n-\n-\n-\/* Note: This enum is duplicated in the -machine.rl source file.\n- * Not sure how to avoid duplication. *\/\n-enum khmer_category_t\n-{\n-  OT_Robatic = 20,\n-  OT_Xgroup  = 21,\n-  OT_Ygroup  = 22,\n-  \/\/OT_VAbv = 26,\n-  \/\/OT_VBlw = 27,\n-  \/\/OT_VPre = 28,\n-  \/\/OT_VPst = 29,\n-};\n-\n-static inline void\n-set_khmer_properties (hb_glyph_info_t &info)\n-{\n-  hb_codepoint_t u = info.codepoint;\n-  unsigned int type = hb_indic_get_categories (u);\n-  khmer_category_t cat = (khmer_category_t) (type & 0xFFu);\n-  indic_position_t pos = (indic_position_t) (type >> 8);\n-\n-\n-  \/*\n-   * Re-assign category\n-   *\n-   * These categories are experimentally extracted from what Uniscribe allows.\n-   *\/\n-  switch (u)\n-  {\n-    case 0x179Au:\n-      cat = (khmer_category_t) OT_Ra;\n-      break;\n-\n-    case 0x17CCu:\n-    case 0x17C9u:\n-    case 0x17CAu:\n-      cat = OT_Robatic;\n-      break;\n-\n-    case 0x17C6u:\n-    case 0x17CBu:\n-    case 0x17CDu:\n-    case 0x17CEu:\n-    case 0x17CFu:\n-    case 0x17D0u:\n-    case 0x17D1u:\n-      cat = OT_Xgroup;\n-      break;\n-\n-    case 0x17C7u:\n-    case 0x17C8u:\n-    case 0x17DDu:\n-    case 0x17D3u: \/* Just guessing. Uniscribe doesn't categorize it. *\/\n-      cat = OT_Ygroup;\n-      break;\n-  }\n-\n-  \/*\n-   * Re-assign position.\n-   *\/\n-  if (cat == (khmer_category_t) OT_M)\n-    switch ((int) pos)\n-    {\n-      case POS_PRE_C:   cat = (khmer_category_t) OT_VPre; break;\n-      case POS_BELOW_C: cat = (khmer_category_t) OT_VBlw; break;\n-      case POS_ABOVE_C: cat = (khmer_category_t) OT_VAbv; break;\n-      case POS_POST_C:  cat = (khmer_category_t) OT_VPst; break;\n-      default: assert (0);\n-    }\n-\n-  info.khmer_category() = cat;\n-}\n-\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_KHMER_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-khmer.hh","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,465 +0,0 @@\n-\n-#line 1 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-\/*\n- * Copyright  2011,2012  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_MYANMAR_MACHINE_HH\n-#define HB_OT_SHAPE_COMPLEX_MYANMAR_MACHINE_HH\n-\n-#include \"hb.hh\"\n-\n-enum myanmar_syllable_type_t {\n-  myanmar_consonant_syllable,\n-  myanmar_punctuation_cluster,\n-  myanmar_broken_cluster,\n-  myanmar_non_myanmar_cluster,\n-};\n-\n-\n-#line 43 \"hb-ot-shape-complex-myanmar-machine.hh\"\n-#define myanmar_syllable_machine_ex_A 10u\n-#define myanmar_syllable_machine_ex_As 18u\n-#define myanmar_syllable_machine_ex_C 1u\n-#define myanmar_syllable_machine_ex_CS 19u\n-#define myanmar_syllable_machine_ex_D 32u\n-#define myanmar_syllable_machine_ex_D0 20u\n-#define myanmar_syllable_machine_ex_DB 3u\n-#define myanmar_syllable_machine_ex_GB 11u\n-#define myanmar_syllable_machine_ex_H 4u\n-#define myanmar_syllable_machine_ex_IV 2u\n-#define myanmar_syllable_machine_ex_MH 21u\n-#define myanmar_syllable_machine_ex_MR 22u\n-#define myanmar_syllable_machine_ex_MW 23u\n-#define myanmar_syllable_machine_ex_MY 24u\n-#define myanmar_syllable_machine_ex_P 31u\n-#define myanmar_syllable_machine_ex_PT 25u\n-#define myanmar_syllable_machine_ex_Ra 16u\n-#define myanmar_syllable_machine_ex_V 8u\n-#define myanmar_syllable_machine_ex_VAbv 26u\n-#define myanmar_syllable_machine_ex_VBlw 27u\n-#define myanmar_syllable_machine_ex_VPre 28u\n-#define myanmar_syllable_machine_ex_VPst 29u\n-#define myanmar_syllable_machine_ex_VS 30u\n-#define myanmar_syllable_machine_ex_ZWJ 6u\n-#define myanmar_syllable_machine_ex_ZWNJ 5u\n-\n-\n-#line 71 \"hb-ot-shape-complex-myanmar-machine.hh\"\n-static const unsigned char _myanmar_syllable_machine_trans_keys[] = {\n-        1u, 32u, 3u, 30u, 5u, 29u, 5u, 8u, 5u, 29u, 3u, 25u, 5u, 25u, 5u, 25u,\n-        3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u, 1u, 16u, 3u, 29u, 3u, 29u, 3u, 29u,\n-        3u, 29u, 3u, 29u, 3u, 30u, 3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u,\n-        5u, 29u, 5u, 8u, 5u, 29u, 3u, 25u, 5u, 25u, 5u, 25u, 3u, 29u, 3u, 29u,\n-        3u, 29u, 3u, 29u, 1u, 16u, 3u, 30u, 3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u,\n-        3u, 29u, 3u, 30u, 3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u, 3u, 30u,\n-        3u, 29u, 1u, 32u, 1u, 32u, 8u, 8u, 0\n-};\n-\n-static const char _myanmar_syllable_machine_key_spans[] = {\n-        32, 28, 25, 4, 25, 23, 21, 21,\n-        27, 27, 27, 27, 16, 27, 27, 27,\n-        27, 27, 28, 27, 27, 27, 27, 27,\n-        25, 4, 25, 23, 21, 21, 27, 27,\n-        27, 27, 16, 28, 27, 27, 27, 27,\n-        27, 28, 27, 27, 27, 27, 27, 28,\n-        27, 32, 32, 1\n-};\n-\n-static const short _myanmar_syllable_machine_index_offsets[] = {\n-        0, 33, 62, 88, 93, 119, 143, 165,\n-        187, 215, 243, 271, 299, 316, 344, 372,\n-        400, 428, 456, 485, 513, 541, 569, 597,\n-        625, 651, 656, 682, 706, 728, 750, 778,\n-        806, 834, 862, 879, 908, 936, 964, 992,\n-        1020, 1048, 1077, 1105, 1133, 1161, 1189, 1217,\n-        1246, 1274, 1307, 1340\n-};\n-\n-static const char _myanmar_syllable_machine_indicies[] = {\n-        1, 1, 2, 3, 4, 4, 0, 5,\n-        0, 6, 1, 0, 0, 0, 0, 7,\n-        0, 8, 9, 0, 10, 11, 12, 13,\n-        14, 15, 16, 17, 18, 19, 20, 1,\n-        0, 22, 23, 24, 24, 21, 25, 21,\n-        26, 21, 21, 21, 21, 21, 21, 21,\n-        27, 21, 21, 28, 29, 30, 31, 32,\n-        33, 34, 35, 36, 37, 21, 24, 24,\n-        21, 25, 21, 21, 21, 21, 21, 21,\n-        21, 21, 21, 38, 21, 21, 21, 21,\n-        21, 21, 32, 21, 21, 21, 36, 21,\n-        24, 24, 21, 25, 21, 24, 24, 21,\n-        25, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        21, 32, 21, 21, 21, 36, 21, 39,\n-        21, 24, 24, 21, 25, 21, 32, 21,\n-        21, 21, 21, 21, 21, 21, 40, 21,\n-        21, 21, 21, 21, 21, 32, 21, 24,\n-        24, 21, 25, 21, 21, 21, 21, 21,\n-        21, 21, 21, 21, 40, 21, 21, 21,\n-        21, 21, 21, 32, 21, 24, 24, 21,\n-        25, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        21, 32, 21, 22, 21, 24, 24, 21,\n-        25, 21, 26, 21, 21, 21, 21, 21,\n-        21, 21, 41, 21, 21, 41, 21, 21,\n-        21, 32, 42, 21, 21, 36, 21, 22,\n-        21, 24, 24, 21, 25, 21, 26, 21,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 21, 21, 21, 32, 21, 21,\n-        21, 36, 21, 22, 21, 24, 24, 21,\n-        25, 21, 26, 21, 21, 21, 21, 21,\n-        21, 21, 41, 21, 21, 21, 21, 21,\n-        21, 32, 42, 21, 21, 36, 21, 22,\n-        21, 24, 24, 21, 25, 21, 26, 21,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 21, 21, 21, 32, 42, 21,\n-        21, 36, 21, 1, 1, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 1, 21, 22, 21, 24, 24,\n-        21, 25, 21, 26, 21, 21, 21, 21,\n-        21, 21, 21, 27, 21, 21, 28, 29,\n-        30, 31, 32, 33, 34, 35, 36, 21,\n-        22, 21, 24, 24, 21, 25, 21, 26,\n-        21, 21, 21, 21, 21, 21, 21, 43,\n-        21, 21, 21, 21, 21, 21, 32, 33,\n-        34, 35, 36, 21, 22, 21, 24, 24,\n-        21, 25, 21, 26, 21, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 32, 33, 34, 35, 36, 21,\n-        22, 21, 24, 24, 21, 25, 21, 26,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 32, 33,\n-        34, 21, 36, 21, 22, 21, 24, 24,\n-        21, 25, 21, 26, 21, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 32, 21, 34, 21, 36, 21,\n-        22, 21, 24, 24, 21, 25, 21, 26,\n-        21, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 32, 33,\n-        34, 35, 36, 43, 21, 22, 21, 24,\n-        24, 21, 25, 21, 26, 21, 21, 21,\n-        21, 21, 21, 21, 21, 21, 21, 28,\n-        21, 30, 21, 32, 33, 34, 35, 36,\n-        21, 22, 21, 24, 24, 21, 25, 21,\n-        26, 21, 21, 21, 21, 21, 21, 21,\n-        43, 21, 21, 28, 21, 21, 21, 32,\n-        33, 34, 35, 36, 21, 22, 21, 24,\n-        24, 21, 25, 21, 26, 21, 21, 21,\n-        21, 21, 21, 21, 44, 21, 21, 28,\n-        29, 30, 21, 32, 33, 34, 35, 36,\n-        21, 22, 21, 24, 24, 21, 25, 21,\n-        26, 21, 21, 21, 21, 21, 21, 21,\n-        21, 21, 21, 28, 29, 30, 21, 32,\n-        33, 34, 35, 36, 21, 22, 23, 24,\n-        24, 21, 25, 21, 26, 21, 21, 21,\n-        21, 21, 21, 21, 27, 21, 21, 28,\n-        29, 30, 31, 32, 33, 34, 35, 36,\n-        21, 46, 46, 45, 5, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 47, 45,\n-        45, 45, 45, 45, 45, 14, 45, 45,\n-        45, 18, 45, 46, 46, 45, 5, 45,\n-        46, 46, 45, 5, 45, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 14, 45, 45, 45,\n-        18, 45, 48, 45, 46, 46, 45, 5,\n-        45, 14, 45, 45, 45, 45, 45, 45,\n-        45, 49, 45, 45, 45, 45, 45, 45,\n-        14, 45, 46, 46, 45, 5, 45, 45,\n-        45, 45, 45, 45, 45, 45, 45, 49,\n-        45, 45, 45, 45, 45, 45, 14, 45,\n-        46, 46, 45, 5, 45, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 14, 45, 2, 45,\n-        46, 46, 45, 5, 45, 6, 45, 45,\n-        45, 45, 45, 45, 45, 50, 45, 45,\n-        50, 45, 45, 45, 14, 51, 45, 45,\n-        18, 45, 2, 45, 46, 46, 45, 5,\n-        45, 6, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 45, 45,\n-        14, 45, 45, 45, 18, 45, 2, 45,\n-        46, 46, 45, 5, 45, 6, 45, 45,\n-        45, 45, 45, 45, 45, 50, 45, 45,\n-        45, 45, 45, 45, 14, 51, 45, 45,\n-        18, 45, 2, 45, 46, 46, 45, 5,\n-        45, 6, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 45, 45,\n-        14, 51, 45, 45, 18, 45, 52, 52,\n-        45, 45, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 45, 52, 45, 2,\n-        3, 46, 46, 45, 5, 45, 6, 45,\n-        45, 45, 45, 45, 45, 45, 8, 45,\n-        45, 10, 11, 12, 13, 14, 15, 16,\n-        17, 18, 19, 45, 2, 45, 46, 46,\n-        45, 5, 45, 6, 45, 45, 45, 45,\n-        45, 45, 45, 8, 45, 45, 10, 11,\n-        12, 13, 14, 15, 16, 17, 18, 45,\n-        2, 45, 46, 46, 45, 5, 45, 6,\n-        45, 45, 45, 45, 45, 45, 45, 53,\n-        45, 45, 45, 45, 45, 45, 14, 15,\n-        16, 17, 18, 45, 2, 45, 46, 46,\n-        45, 5, 45, 6, 45, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 45, 45,\n-        45, 45, 14, 15, 16, 17, 18, 45,\n-        2, 45, 46, 46, 45, 5, 45, 6,\n-        45, 45, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 14, 15,\n-        16, 45, 18, 45, 2, 45, 46, 46,\n-        45, 5, 45, 6, 45, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 45, 45,\n-        45, 45, 14, 45, 16, 45, 18, 45,\n-        2, 45, 46, 46, 45, 5, 45, 6,\n-        45, 45, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 14, 15,\n-        16, 17, 18, 53, 45, 2, 45, 46,\n-        46, 45, 5, 45, 6, 45, 45, 45,\n-        45, 45, 45, 45, 45, 45, 45, 10,\n-        45, 12, 45, 14, 15, 16, 17, 18,\n-        45, 2, 45, 46, 46, 45, 5, 45,\n-        6, 45, 45, 45, 45, 45, 45, 45,\n-        53, 45, 45, 10, 45, 45, 45, 14,\n-        15, 16, 17, 18, 45, 2, 45, 46,\n-        46, 45, 5, 45, 6, 45, 45, 45,\n-        45, 45, 45, 45, 54, 45, 45, 10,\n-        11, 12, 45, 14, 15, 16, 17, 18,\n-        45, 2, 45, 46, 46, 45, 5, 45,\n-        6, 45, 45, 45, 45, 45, 45, 45,\n-        45, 45, 45, 10, 11, 12, 45, 14,\n-        15, 16, 17, 18, 45, 2, 3, 46,\n-        46, 45, 5, 45, 6, 45, 45, 45,\n-        45, 45, 45, 45, 8, 45, 45, 10,\n-        11, 12, 13, 14, 15, 16, 17, 18,\n-        45, 22, 23, 24, 24, 21, 25, 21,\n-        26, 21, 21, 21, 21, 21, 21, 21,\n-        55, 21, 21, 28, 29, 30, 31, 32,\n-        33, 34, 35, 36, 37, 21, 22, 56,\n-        24, 24, 21, 25, 21, 26, 21, 21,\n-        21, 21, 21, 21, 21, 27, 21, 21,\n-        28, 29, 30, 31, 32, 33, 34, 35,\n-        36, 21, 1, 1, 2, 3, 46, 46,\n-        45, 5, 45, 6, 1, 45, 45, 45,\n-        45, 1, 45, 8, 45, 45, 10, 11,\n-        12, 13, 14, 15, 16, 17, 18, 19,\n-        45, 1, 45, 1, 1, 57, 57, 57,\n-        57, 57, 57, 57, 57, 1, 57, 57,\n-        57, 57, 1, 57, 57, 57, 57, 57,\n-        57, 57, 57, 57, 57, 57, 57, 57,\n-        57, 57, 1, 57, 58, 57, 0\n-};\n-\n-static const char _myanmar_syllable_machine_trans_targs[] = {\n-        0, 1, 24, 34, 0, 25, 31, 47,\n-        36, 50, 37, 42, 43, 44, 27, 39,\n-        40, 41, 30, 46, 51, 0, 2, 12,\n-        0, 3, 9, 13, 14, 19, 20, 21,\n-        5, 16, 17, 18, 8, 23, 4, 6,\n-        7, 10, 11, 15, 22, 0, 0, 26,\n-        28, 29, 32, 33, 35, 38, 45, 48,\n-        49, 0, 0\n-};\n-\n-static const char _myanmar_syllable_machine_trans_actions[] = {\n-        3, 0, 0, 0, 4, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 5, 0, 0,\n-        6, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 7, 8, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 9, 10\n-};\n-\n-static const char _myanmar_syllable_machine_to_state_actions[] = {\n-        1, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0\n-};\n-\n-static const char _myanmar_syllable_machine_from_state_actions[] = {\n-        2, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0\n-};\n-\n-static const short _myanmar_syllable_machine_eof_trans[] = {\n-        0, 22, 22, 22, 22, 22, 22, 22,\n-        22, 22, 22, 22, 22, 22, 22, 22,\n-        22, 22, 22, 22, 22, 22, 22, 22,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 46,\n-        46, 46, 46, 46, 46, 46, 46, 22,\n-        22, 46, 58, 58\n-};\n-\n-static const int myanmar_syllable_machine_start = 0;\n-static const int myanmar_syllable_machine_first_final = 0;\n-static const int myanmar_syllable_machine_error = -1;\n-\n-static const int myanmar_syllable_machine_en_main = 0;\n-\n-\n-#line 44 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-\n-\n-\n-#line 101 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-\n-\n-#define found_syllable(syllable_type) \\\n-  HB_STMT_START { \\\n-    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n-    for (unsigned int i = ts; i < te; i++) \\\n-      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n-    syllable_serial++; \\\n-    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n-  } HB_STMT_END\n-\n-static void\n-find_syllables_myanmar (hb_buffer_t *buffer)\n-{\n-  unsigned int p, pe, eof, ts, te, act HB_UNUSED;\n-  int cs;\n-  hb_glyph_info_t *info = buffer->info;\n-\n-#line 355 \"hb-ot-shape-complex-myanmar-machine.hh\"\n-        {\n-        cs = myanmar_syllable_machine_start;\n-        ts = 0;\n-        te = 0;\n-        act = 0;\n-        }\n-\n-#line 121 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-\n-\n-  p = 0;\n-  pe = eof = buffer->len;\n-\n-  unsigned int syllable_serial = 1;\n-\n-#line 371 \"hb-ot-shape-complex-myanmar-machine.hh\"\n-        {\n-        int _slen;\n-        int _trans;\n-        const unsigned char *_keys;\n-        const char *_inds;\n-        if ( p == pe )\n-                goto _test_eof;\n-_resume:\n-        switch ( _myanmar_syllable_machine_from_state_actions[cs] ) {\n-        case 2:\n-#line 1 \"NONE\"\n-        {ts = p;}\n-        break;\n-#line 385 \"hb-ot-shape-complex-myanmar-machine.hh\"\n-        }\n-\n-        _keys = _myanmar_syllable_machine_trans_keys + (cs<<1);\n-        _inds = _myanmar_syllable_machine_indicies + _myanmar_syllable_machine_index_offsets[cs];\n-\n-        _slen = _myanmar_syllable_machine_key_spans[cs];\n-        _trans = _inds[ _slen > 0 && _keys[0] <=( info[p].myanmar_category()) &&\n-                ( info[p].myanmar_category()) <= _keys[1] ?\n-                ( info[p].myanmar_category()) - _keys[0] : _slen ];\n-\n-_eof_trans:\n-        cs = _myanmar_syllable_machine_trans_targs[_trans];\n-\n-        if ( _myanmar_syllable_machine_trans_actions[_trans] == 0 )\n-                goto _again;\n-\n-        switch ( _myanmar_syllable_machine_trans_actions[_trans] ) {\n-        case 6:\n-#line 93 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-        {te = p+1;{ found_syllable (myanmar_consonant_syllable); }}\n-        break;\n-        case 4:\n-#line 94 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-        {te = p+1;{ found_syllable (myanmar_non_myanmar_cluster); }}\n-        break;\n-        case 10:\n-#line 95 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-        {te = p+1;{ found_syllable (myanmar_punctuation_cluster); }}\n-        break;\n-        case 8:\n-#line 96 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-        {te = p+1;{ found_syllable (myanmar_broken_cluster); }}\n-        break;\n-        case 3:\n-#line 97 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-        {te = p+1;{ found_syllable (myanmar_non_myanmar_cluster); }}\n-        break;\n-        case 5:\n-#line 93 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-        {te = p;p--;{ found_syllable (myanmar_consonant_syllable); }}\n-        break;\n-        case 7:\n-#line 96 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-        {te = p;p--;{ found_syllable (myanmar_broken_cluster); }}\n-        break;\n-        case 9:\n-#line 97 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-        {te = p;p--;{ found_syllable (myanmar_non_myanmar_cluster); }}\n-        break;\n-#line 435 \"hb-ot-shape-complex-myanmar-machine.hh\"\n-        }\n-\n-_again:\n-        switch ( _myanmar_syllable_machine_to_state_actions[cs] ) {\n-        case 1:\n-#line 1 \"NONE\"\n-        {ts = 0;}\n-        break;\n-#line 444 \"hb-ot-shape-complex-myanmar-machine.hh\"\n-        }\n-\n-        if ( ++p != pe )\n-                goto _resume;\n-        _test_eof: {}\n-        if ( p == eof )\n-        {\n-        if ( _myanmar_syllable_machine_eof_trans[cs] > 0 ) {\n-                _trans = _myanmar_syllable_machine_eof_trans[cs] - 1;\n-                goto _eof_trans;\n-        }\n-        }\n-\n-        }\n-\n-#line 129 \"hb-ot-shape-complex-myanmar-machine.rl\"\n-\n-}\n-\n-#undef found_syllable\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_MYANMAR_MACHINE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-myanmar-machine.hh","additions":0,"deletions":465,"binary":false,"changes":465,"status":"deleted"},{"patch":"@@ -1,320 +0,0 @@\n-\/*\n- * Copyright  2011,2012,2013  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#include \"hb.hh\"\n-\n-#ifndef HB_NO_OT_SHAPE\n-\n-#include \"hb-ot-shape-complex-myanmar.hh\"\n-#include \"hb-ot-shape-complex-myanmar-machine.hh\"\n-\n-\n-\/*\n- * Myanmar shaper.\n- *\/\n-\n-static const hb_tag_t\n-myanmar_basic_features[] =\n-{\n-  \/*\n-   * Basic features.\n-   * These features are applied in order, one at a time, after reordering.\n-   *\/\n-  HB_TAG('r','p','h','f'),\n-  HB_TAG('p','r','e','f'),\n-  HB_TAG('b','l','w','f'),\n-  HB_TAG('p','s','t','f'),\n-};\n-static const hb_tag_t\n-myanmar_other_features[] =\n-{\n-  \/*\n-   * Other features.\n-   * These features are applied all at once, after clearing syllables.\n-   *\/\n-  HB_TAG('p','r','e','s'),\n-  HB_TAG('a','b','v','s'),\n-  HB_TAG('b','l','w','s'),\n-  HB_TAG('p','s','t','s'),\n-};\n-\n-static void\n-setup_syllables_myanmar (const hb_ot_shape_plan_t *plan,\n-                         hb_font_t *font,\n-                         hb_buffer_t *buffer);\n-static void\n-reorder_myanmar (const hb_ot_shape_plan_t *plan,\n-                 hb_font_t *font,\n-                 hb_buffer_t *buffer);\n-\n-static void\n-collect_features_myanmar (hb_ot_shape_planner_t *plan)\n-{\n-  hb_ot_map_builder_t *map = &plan->map;\n-\n-  \/* Do this before any lookups have been applied. *\/\n-  map->add_gsub_pause (setup_syllables_myanmar);\n-\n-  map->enable_feature (HB_TAG('l','o','c','l'));\n-  \/* The Indic specs do not require ccmp, but we apply it here since if\n-   * there is a use of it, it's typically at the beginning. *\/\n-  map->enable_feature (HB_TAG('c','c','m','p'));\n-\n-\n-  map->add_gsub_pause (reorder_myanmar);\n-\n-  for (unsigned int i = 0; i < ARRAY_LENGTH (myanmar_basic_features); i++)\n-  {\n-    map->enable_feature (myanmar_basic_features[i], F_MANUAL_ZWJ);\n-    map->add_gsub_pause (nullptr);\n-  }\n-\n-  map->add_gsub_pause (_hb_clear_syllables);\n-\n-  for (unsigned int i = 0; i < ARRAY_LENGTH (myanmar_other_features); i++)\n-    map->enable_feature (myanmar_other_features[i], F_MANUAL_ZWJ);\n-}\n-\n-static void\n-setup_masks_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                     hb_buffer_t              *buffer,\n-                     hb_font_t                *font HB_UNUSED)\n-{\n-  HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_category);\n-  HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_position);\n-\n-  \/* We cannot setup masks here.  We save information about characters\n-   * and setup masks later on in a pause-callback. *\/\n-\n-  unsigned int count = buffer->len;\n-  hb_glyph_info_t *info = buffer->info;\n-  for (unsigned int i = 0; i < count; i++)\n-    set_myanmar_properties (info[i]);\n-}\n-\n-static void\n-setup_syllables_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                         hb_font_t *font HB_UNUSED,\n-                         hb_buffer_t *buffer)\n-{\n-  find_syllables_myanmar (buffer);\n-  foreach_syllable (buffer, start, end)\n-    buffer->unsafe_to_break (start, end);\n-}\n-\n-static int\n-compare_myanmar_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)\n-{\n-  int a = pa->myanmar_position();\n-  int b = pb->myanmar_position();\n-\n-  return a < b ? -1 : a == b ? 0 : +1;\n-}\n-\n-\n-\/* Rules from:\n- * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/myanmar *\/\n-\n-static void\n-initial_reordering_consonant_syllable (hb_buffer_t *buffer,\n-                                       unsigned int start, unsigned int end)\n-{\n-  hb_glyph_info_t *info = buffer->info;\n-\n-  unsigned int base = end;\n-  bool has_reph = false;\n-\n-  {\n-    unsigned int limit = start;\n-    if (start + 3 <= end &&\n-        info[start  ].myanmar_category() == OT_Ra &&\n-        info[start+1].myanmar_category() == OT_As &&\n-        info[start+2].myanmar_category() == OT_H)\n-    {\n-      limit += 3;\n-      base = start;\n-      has_reph = true;\n-    }\n-\n-    {\n-      if (!has_reph)\n-        base = limit;\n-\n-      for (unsigned int i = limit; i < end; i++)\n-        if (is_consonant (info[i]))\n-        {\n-          base = i;\n-          break;\n-        }\n-    }\n-  }\n-\n-  \/* Reorder! *\/\n-  {\n-    unsigned int i = start;\n-    for (; i < start + (has_reph ? 3 : 0); i++)\n-      info[i].myanmar_position() = POS_AFTER_MAIN;\n-    for (; i < base; i++)\n-      info[i].myanmar_position() = POS_PRE_C;\n-    if (i < end)\n-    {\n-      info[i].myanmar_position() = POS_BASE_C;\n-      i++;\n-    }\n-    indic_position_t pos = POS_AFTER_MAIN;\n-    \/* The following loop may be ugly, but it implements all of\n-     * Myanmar reordering! *\/\n-    for (; i < end; i++)\n-    {\n-      if (info[i].myanmar_category() == OT_MR) \/* Pre-base reordering *\/\n-      {\n-        info[i].myanmar_position() = POS_PRE_C;\n-        continue;\n-      }\n-      if (info[i].myanmar_position() < POS_BASE_C) \/* Left matra *\/\n-      {\n-        continue;\n-      }\n-      if (info[i].myanmar_category() == OT_VS)\n-      {\n-        info[i].myanmar_position() = info[i - 1].myanmar_position();\n-        continue;\n-      }\n-\n-      if (pos == POS_AFTER_MAIN && info[i].myanmar_category() == OT_VBlw)\n-      {\n-        pos = POS_BELOW_C;\n-        info[i].myanmar_position() = pos;\n-        continue;\n-      }\n-\n-      if (pos == POS_BELOW_C && info[i].myanmar_category() == OT_A)\n-      {\n-        info[i].myanmar_position() = POS_BEFORE_SUB;\n-        continue;\n-      }\n-      if (pos == POS_BELOW_C && info[i].myanmar_category() == OT_VBlw)\n-      {\n-        info[i].myanmar_position() = pos;\n-        continue;\n-      }\n-      if (pos == POS_BELOW_C && info[i].myanmar_category() != OT_A)\n-      {\n-        pos = POS_AFTER_SUB;\n-        info[i].myanmar_position() = pos;\n-        continue;\n-      }\n-      info[i].myanmar_position() = pos;\n-    }\n-  }\n-\n-  \/* Sit tight, rock 'n roll! *\/\n-  buffer->sort (start, end, compare_myanmar_order);\n-}\n-\n-static void\n-reorder_syllable_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,\n-                          hb_face_t *face HB_UNUSED,\n-                          hb_buffer_t *buffer,\n-                          unsigned int start, unsigned int end)\n-{\n-  myanmar_syllable_type_t syllable_type = (myanmar_syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n-  switch (syllable_type) {\n-\n-    case myanmar_broken_cluster: \/* We already inserted dotted-circles, so just call the consonant_syllable. *\/\n-    case myanmar_consonant_syllable:\n-      initial_reordering_consonant_syllable  (buffer, start, end);\n-      break;\n-\n-    case myanmar_punctuation_cluster:\n-    case myanmar_non_myanmar_cluster:\n-      break;\n-  }\n-}\n-\n-static void\n-reorder_myanmar (const hb_ot_shape_plan_t *plan,\n-                 hb_font_t *font,\n-                 hb_buffer_t *buffer)\n-{\n-  if (buffer->message (font, \"start reordering myanmar\"))\n-  {\n-    hb_syllabic_insert_dotted_circles (font, buffer,\n-                                       myanmar_broken_cluster,\n-                                       OT_GB);\n-\n-    foreach_syllable (buffer, start, end)\n-      reorder_syllable_myanmar (plan, font->face, buffer, start, end);\n-    (void) buffer->message (font, \"end reordering myanmar\");\n-  }\n-\n-  HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_category);\n-  HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_position);\n-}\n-\n-\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar =\n-{\n-  collect_features_myanmar,\n-  nullptr, \/* override_features *\/\n-  nullptr, \/* data_create *\/\n-  nullptr, \/* data_destroy *\/\n-  nullptr, \/* preprocess_text *\/\n-  nullptr, \/* postprocess_glyphs *\/\n-  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n-  nullptr, \/* decompose *\/\n-  nullptr, \/* compose *\/\n-  setup_masks_myanmar,\n-  HB_TAG_NONE, \/* gpos_tag *\/\n-  nullptr, \/* reorder_marks *\/\n-  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,\n-  false, \/* fallback_position *\/\n-};\n-\n-\n-\/* Ugly Zawgyi encoding.\n- * Disable all auto processing.\n- * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1162 *\/\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar_zawgyi =\n-{\n-  nullptr, \/* collect_features *\/\n-  nullptr, \/* override_features *\/\n-  nullptr, \/* data_create *\/\n-  nullptr, \/* data_destroy *\/\n-  nullptr, \/* preprocess_text *\/\n-  nullptr, \/* postprocess_glyphs *\/\n-  HB_OT_SHAPE_NORMALIZATION_MODE_NONE,\n-  nullptr, \/* decompose *\/\n-  nullptr, \/* compose *\/\n-  nullptr, \/* setup_masks *\/\n-  HB_TAG_NONE, \/* gpos_tag *\/\n-  nullptr, \/* reorder_marks *\/\n-  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n-  false, \/* fallback_position *\/\n-};\n-\n-\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-myanmar.cc","additions":0,"deletions":320,"binary":false,"changes":320,"status":"deleted"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright  2018  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_MYANMAR_HH\n-#define HB_OT_SHAPE_COMPLEX_MYANMAR_HH\n-\n-#include \"hb.hh\"\n-\n-#include \"hb-ot-shape-complex-indic.hh\"\n-\n-\n-\/* buffer var allocations *\/\n-#define myanmar_category() indic_category() \/* myanmar_category_t *\/\n-#define myanmar_position() indic_position() \/* myanmar_position_t *\/\n-\n-\n-\/* Note: This enum is duplicated in the -machine.rl source file.\n- * Not sure how to avoid duplication. *\/\n-enum myanmar_category_t {\n-  OT_As  = 18,  \/* Asat *\/\n-  OT_D0  = 20, \/* Digit zero *\/\n-  OT_DB  = OT_N, \/* Dot below *\/\n-  OT_GB  = OT_PLACEHOLDER,\n-  OT_MH  = 21, \/* Various consonant medial types *\/\n-  OT_MR  = 22, \/* Various consonant medial types *\/\n-  OT_MW  = 23, \/* Various consonant medial types *\/\n-  OT_MY  = 24, \/* Various consonant medial types *\/\n-  OT_PT  = 25, \/* Pwo and other tones *\/\n-  \/\/OT_VAbv = 26,\n-  \/\/OT_VBlw = 27,\n-  \/\/OT_VPre = 28,\n-  \/\/OT_VPst = 29,\n-  OT_VS   = 30, \/* Variation selectors *\/\n-  OT_P    = 31, \/* Punctuation *\/\n-  OT_D    = 32, \/* Digits except zero *\/\n-};\n-\n-\n-static inline void\n-set_myanmar_properties (hb_glyph_info_t &info)\n-{\n-  hb_codepoint_t u = info.codepoint;\n-  unsigned int type = hb_indic_get_categories (u);\n-  unsigned int cat = type & 0xFFu;\n-  indic_position_t pos = (indic_position_t) (type >> 8);\n-\n-  \/* Myanmar\n-   * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/myanmar#analyze\n-   *\/\n-  if (unlikely (hb_in_range<hb_codepoint_t> (u, 0xFE00u, 0xFE0Fu)))\n-    cat = OT_VS;\n-\n-  switch (u)\n-  {\n-    case 0x104Eu:\n-      cat = OT_C; \/* The spec says C, IndicSyllableCategory doesn't have. *\/\n-      break;\n-\n-    case 0x002Du: case 0x00A0u: case 0x00D7u: case 0x2012u:\n-    case 0x2013u: case 0x2014u: case 0x2015u: case 0x2022u:\n-    case 0x25CCu: case 0x25FBu: case 0x25FCu: case 0x25FDu:\n-    case 0x25FEu:\n-      cat = OT_GB;\n-      break;\n-\n-    case 0x1004u: case 0x101Bu: case 0x105Au:\n-      cat = OT_Ra;\n-      break;\n-\n-    case 0x1032u: case 0x1036u:\n-      cat = OT_A;\n-      break;\n-\n-    case 0x1039u:\n-      cat = OT_H;\n-      break;\n-\n-    case 0x103Au:\n-      cat = OT_As;\n-      break;\n-\n-    case 0x1041u: case 0x1042u: case 0x1043u: case 0x1044u:\n-    case 0x1045u: case 0x1046u: case 0x1047u: case 0x1048u:\n-    case 0x1049u: case 0x1090u: case 0x1091u: case 0x1092u:\n-    case 0x1093u: case 0x1094u: case 0x1095u: case 0x1096u:\n-    case 0x1097u: case 0x1098u: case 0x1099u:\n-      cat = OT_D;\n-      break;\n-\n-    case 0x1040u:\n-      cat = OT_D; \/* XXX The spec says D0, but Uniscribe doesn't seem to do. *\/\n-      break;\n-\n-    case 0x103Eu: case 0x1060u:\n-      cat = OT_MH;\n-      break;\n-\n-    case 0x103Cu:\n-      cat = OT_MR;\n-      break;\n-\n-    case 0x103Du: case 0x1082u:\n-      cat = OT_MW;\n-      break;\n-\n-    case 0x103Bu: case 0x105Eu: case 0x105Fu:\n-      cat = OT_MY;\n-      break;\n-\n-    case 0x1063u: case 0x1064u: case 0x1069u: case 0x106Au:\n-    case 0x106Bu: case 0x106Cu: case 0x106Du: case 0xAA7Bu:\n-      cat = OT_PT;\n-      break;\n-\n-    case 0x1038u: case 0x1087u: case 0x1088u: case 0x1089u:\n-    case 0x108Au: case 0x108Bu: case 0x108Cu: case 0x108Du:\n-    case 0x108Fu: case 0x109Au: case 0x109Bu: case 0x109Cu:\n-      cat = OT_SM;\n-      break;\n-\n-    case 0x104Au: case 0x104Bu:\n-      cat = OT_P;\n-      break;\n-\n-    case 0xAA74u: case 0xAA75u: case 0xAA76u:\n-      \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/218 *\/\n-      cat = OT_C;\n-      break;\n-  }\n-\n-  if (cat == OT_M)\n-  {\n-    switch ((int) pos)\n-    {\n-      case POS_PRE_C:   cat = (myanmar_category_t) OT_VPre;\n-                        pos = POS_PRE_M; break;\n-      case POS_ABOVE_C: cat = (myanmar_category_t) OT_VAbv;   break;\n-      case POS_BELOW_C: cat = (myanmar_category_t) OT_VBlw;   break;\n-      case POS_POST_C:  cat = (myanmar_category_t) OT_VPst;   break;\n-    }\n-  }\n-\n-  info.myanmar_category() = cat;\n-  info.myanmar_position() = pos;\n-}\n-\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_MYANMAR_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-myanmar.hh","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright  2021  Behdad Esfahbod.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\/\n-\n-#include \"hb.hh\"\n-\n-#ifndef HB_NO_OT_SHAPE\n-\n-#include \"hb-ot-shape-complex-syllabic.hh\"\n-\n-\n-void\n-hb_syllabic_insert_dotted_circles (hb_font_t *font,\n-                                   hb_buffer_t *buffer,\n-                                   unsigned int broken_syllable_type,\n-                                   unsigned int dottedcircle_category,\n-                                   int repha_category)\n-{\n-  if (unlikely (buffer->flags & HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE))\n-    return;\n-\n-  \/* Note: This loop is extra overhead, but should not be measurable.\n-   * TODO Use a buffer scratch flag to remove the loop. *\/\n-  bool has_broken_syllables = false;\n-  unsigned int count = buffer->len;\n-  hb_glyph_info_t *info = buffer->info;\n-  for (unsigned int i = 0; i < count; i++)\n-    if ((info[i].syllable() & 0x0F) == broken_syllable_type)\n-    {\n-      has_broken_syllables = true;\n-      break;\n-    }\n-  if (likely (!has_broken_syllables))\n-    return;\n-\n-\n-  hb_codepoint_t dottedcircle_glyph;\n-  if (!font->get_nominal_glyph (0x25CCu, &dottedcircle_glyph))\n-    return;\n-\n-  hb_glyph_info_t dottedcircle = {0};\n-  dottedcircle.codepoint = 0x25CCu;\n-  dottedcircle.complex_var_u8_category() = dottedcircle_category;\n-  dottedcircle.codepoint = dottedcircle_glyph;\n-\n-  buffer->clear_output ();\n-\n-  buffer->idx = 0;\n-  unsigned int last_syllable = 0;\n-  while (buffer->idx < buffer->len && buffer->successful)\n-  {\n-    unsigned int syllable = buffer->cur().syllable();\n-    if (unlikely (last_syllable != syllable && (syllable & 0x0F) == broken_syllable_type))\n-    {\n-      last_syllable = syllable;\n-\n-      hb_glyph_info_t ginfo = dottedcircle;\n-      ginfo.cluster = buffer->cur().cluster;\n-      ginfo.mask = buffer->cur().mask;\n-      ginfo.syllable() = buffer->cur().syllable();\n-\n-      \/* Insert dottedcircle after possible Repha. *\/\n-      if (repha_category != -1)\n-      {\n-        while (buffer->idx < buffer->len && buffer->successful &&\n-               last_syllable == buffer->cur().syllable() &&\n-               buffer->cur().complex_var_u8_category() == (unsigned) repha_category)\n-          (void) buffer->next_glyph ();\n-      }\n-\n-      (void) buffer->output_info (ginfo);\n-    }\n-    else\n-      (void) buffer->next_glyph ();\n-  }\n-  buffer->swap_buffers ();\n-}\n-\n-\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-syllabic.cc","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright  2021  Behdad Esfahbod.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_SYLLABIC_HH\n-#define HB_OT_SHAPE_COMPLEX_SYLLABIC_HH\n-\n-#include \"hb.hh\"\n-\n-#include \"hb-ot-shape-complex.hh\"\n-\n-\n-HB_INTERNAL void\n-hb_syllabic_insert_dotted_circles (hb_font_t *font,\n-                                   hb_buffer_t *buffer,\n-                                   unsigned int broken_syllable_type,\n-                                   unsigned int dottedcircle_category,\n-                                   int repha_category = -1);\n-\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_SYLLABIC_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-syllabic.hh","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,729 +0,0 @@\n-#line 1 \"hb-ot-shape-complex-use-machine.rl\"\n-\/*\n-* Copyright  2015  Mozilla Foundation.\n-* Copyright  2015  Google, Inc.\n-*\n-*  This is part of HarfBuzz, a text shaping library.\n-*\n-* Permission is hereby granted, without written agreement and without\n-* license or royalty fees, to use, copy, modify, and distribute this\n-* software and its documentation for any purpose, provided that the\n-* above copyright notice and the following two paragraphs appear in\n-* all copies of this software.\n-*\n-* IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n-* DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n-* ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n-* IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n-* DAMAGE.\n-*\n-* THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n-* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n-* FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n-* ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n-* PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n-*\n-* Mozilla Author(s): Jonathan Kew\n-* Google Author(s): Behdad Esfahbod\n-*\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_USE_MACHINE_HH\n-#define HB_OT_SHAPE_COMPLEX_USE_MACHINE_HH\n-\n-#include \"hb.hh\"\n-\n-#include \"hb-ot-shape-complex-syllabic.hh\"\n-\n-\/* buffer var allocations *\/\n-#define use_category() complex_var_u8_category()\n-\n-#define USE(Cat) use_syllable_machine_ex_##Cat\n-\n-enum use_syllable_type_t {\n-        use_independent_cluster,\n-        use_virama_terminated_cluster,\n-        use_sakot_terminated_cluster,\n-        use_standard_cluster,\n-        use_number_joiner_terminated_cluster,\n-        use_numeral_cluster,\n-        use_symbol_cluster,\n-        use_hieroglyph_cluster,\n-        use_broken_cluster,\n-        use_non_cluster,\n-};\n-\n-\n-#line 57 \"hb-ot-shape-complex-use-machine.hh\"\n-#define use_syllable_machine_ex_B 1u\n-#define use_syllable_machine_ex_CMAbv 31u\n-#define use_syllable_machine_ex_CMBlw 32u\n-#define use_syllable_machine_ex_CS 43u\n-#define use_syllable_machine_ex_FAbv 24u\n-#define use_syllable_machine_ex_FBlw 25u\n-#define use_syllable_machine_ex_FMAbv 45u\n-#define use_syllable_machine_ex_FMBlw 46u\n-#define use_syllable_machine_ex_FMPst 47u\n-#define use_syllable_machine_ex_FPst 26u\n-#define use_syllable_machine_ex_G 49u\n-#define use_syllable_machine_ex_GB 5u\n-#define use_syllable_machine_ex_H 12u\n-#define use_syllable_machine_ex_HN 13u\n-#define use_syllable_machine_ex_HVM 44u\n-#define use_syllable_machine_ex_J 50u\n-#define use_syllable_machine_ex_MAbv 27u\n-#define use_syllable_machine_ex_MBlw 28u\n-#define use_syllable_machine_ex_MPre 30u\n-#define use_syllable_machine_ex_MPst 29u\n-#define use_syllable_machine_ex_N 4u\n-#define use_syllable_machine_ex_O 0u\n-#define use_syllable_machine_ex_R 18u\n-#define use_syllable_machine_ex_S 19u\n-#define use_syllable_machine_ex_SB 51u\n-#define use_syllable_machine_ex_SE 52u\n-#define use_syllable_machine_ex_SMAbv 41u\n-#define use_syllable_machine_ex_SMBlw 42u\n-#define use_syllable_machine_ex_SUB 11u\n-#define use_syllable_machine_ex_Sk 48u\n-#define use_syllable_machine_ex_VAbv 33u\n-#define use_syllable_machine_ex_VBlw 34u\n-#define use_syllable_machine_ex_VMAbv 37u\n-#define use_syllable_machine_ex_VMBlw 38u\n-#define use_syllable_machine_ex_VMPre 23u\n-#define use_syllable_machine_ex_VMPst 39u\n-#define use_syllable_machine_ex_VPre 22u\n-#define use_syllable_machine_ex_VPst 35u\n-#define use_syllable_machine_ex_ZWNJ 14u\n-\n-\n-#line 99 \"hb-ot-shape-complex-use-machine.hh\"\n-static const unsigned char _use_syllable_machine_trans_keys[] = {\n-        1u, 1u, 1u, 1u, 0u, 37u, 5u, 34u,\n-        5u, 34u, 1u, 1u, 10u, 34u, 11u, 34u,\n-        12u, 33u, 13u, 33u, 14u, 33u, 31u, 32u,\n-        32u, 32u, 12u, 34u, 12u, 34u, 12u, 34u,\n-        1u, 1u, 12u, 34u, 11u, 34u, 11u, 34u,\n-        11u, 34u, 10u, 34u, 10u, 34u, 10u, 34u,\n-        5u, 34u, 1u, 34u, 7u, 7u, 3u, 3u,\n-        5u, 34u, 27u, 28u, 28u, 28u, 5u, 34u,\n-        10u, 34u, 11u, 34u, 12u, 33u, 13u, 33u,\n-        14u, 33u, 31u, 32u, 32u, 32u, 12u, 34u,\n-        12u, 34u, 12u, 34u, 12u, 34u, 11u, 34u,\n-        11u, 34u, 11u, 34u, 10u, 34u, 10u, 34u,\n-        10u, 34u, 5u, 34u, 1u, 34u, 1u, 1u,\n-        3u, 3u, 7u, 7u, 1u, 34u, 5u, 34u,\n-        27u, 28u, 28u, 28u, 1u, 4u, 36u, 38u,\n-        35u, 38u, 35u, 37u, 0u\n-};\n-\n-static const signed char _use_syllable_machine_char_class[] = {\n-        0, 1, 2, 2, 3, 4, 2, 2,\n-        2, 2, 2, 5, 6, 7, 2, 2,\n-        2, 2, 8, 9, 2, 2, 10, 11,\n-        12, 13, 14, 15, 16, 17, 18, 19,\n-        20, 21, 22, 23, 2, 24, 25, 26,\n-        2, 27, 28, 29, 30, 31, 32, 33,\n-        34, 35, 36, 37, 38, 0\n-};\n-\n-static const short _use_syllable_machine_index_offsets[] = {\n-        0, 1, 2, 40, 70, 100, 101, 126,\n-        150, 172, 193, 213, 215, 216, 239, 262,\n-        285, 286, 309, 333, 357, 381, 406, 431,\n-        456, 486, 520, 521, 522, 552, 554, 555,\n-        585, 610, 634, 656, 677, 697, 699, 700,\n-        723, 746, 769, 792, 816, 840, 864, 889,\n-        914, 939, 969, 1003, 1004, 1005, 1006, 1040,\n-        1070, 1072, 1073, 1077, 1080, 1084, 0\n-};\n-\n-static const signed char _use_syllable_machine_indicies[] = {\n-        1, 2, 4, 5, 6, 7, 8, 1,\n-        9, 10, 11, 12, 13, 14, 15, 16,\n-        17, 18, 19, 13, 20, 21, 22, 23,\n-        24, 25, 26, 27, 28, 29, 30, 31,\n-        32, 33, 34, 35, 9, 36, 6, 37,\n-        39, 40, 38, 38, 38, 41, 42, 43,\n-        44, 45, 46, 47, 41, 48, 5, 49,\n-        50, 51, 52, 53, 54, 55, 38, 38,\n-        38, 56, 57, 58, 59, 40, 39, 40,\n-        38, 38, 38, 41, 42, 43, 44, 45,\n-        46, 47, 41, 48, 49, 49, 50, 51,\n-        52, 53, 54, 55, 38, 38, 38, 56,\n-        57, 58, 59, 40, 39, 41, 42, 43,\n-        44, 45, 38, 38, 38, 38, 38, 38,\n-        50, 51, 52, 53, 54, 55, 38, 38,\n-        38, 42, 57, 58, 59, 61, 42, 43,\n-        44, 45, 38, 38, 38, 38, 38, 38,\n-        38, 38, 38, 53, 54, 55, 38, 38,\n-        38, 38, 57, 58, 59, 61, 43, 44,\n-        45, 38, 38, 38, 38, 38, 38, 38,\n-        38, 38, 38, 38, 38, 38, 38, 38,\n-        38, 57, 58, 59, 44, 45, 38, 38,\n-        38, 38, 38, 38, 38, 38, 38, 38,\n-        38, 38, 38, 38, 38, 38, 57, 58,\n-        59, 45, 38, 38, 38, 38, 38, 38,\n-        38, 38, 38, 38, 38, 38, 38, 38,\n-        38, 38, 57, 58, 59, 57, 58, 58,\n-        43, 44, 45, 38, 38, 38, 38, 38,\n-        38, 38, 38, 38, 53, 54, 55, 38,\n-        38, 38, 38, 57, 58, 59, 61, 43,\n-        44, 45, 38, 38, 38, 38, 38, 38,\n-        38, 38, 38, 38, 54, 55, 38, 38,\n-        38, 38, 57, 58, 59, 61, 43, 44,\n-        45, 38, 38, 38, 38, 38, 38, 38,\n-        38, 38, 38, 38, 55, 38, 38, 38,\n-        38, 57, 58, 59, 61, 63, 43, 44,\n-        45, 38, 38, 38, 38, 38, 38, 38,\n-        38, 38, 38, 38, 38, 38, 38, 38,\n-        38, 57, 58, 59, 61, 42, 43, 44,\n-        45, 38, 38, 38, 38, 38, 38, 50,\n-        51, 52, 53, 54, 55, 38, 38, 38,\n-        42, 57, 58, 59, 61, 42, 43, 44,\n-        45, 38, 38, 38, 38, 38, 38, 38,\n-        51, 52, 53, 54, 55, 38, 38, 38,\n-        42, 57, 58, 59, 61, 42, 43, 44,\n-        45, 38, 38, 38, 38, 38, 38, 38,\n-        38, 52, 53, 54, 55, 38, 38, 38,\n-        42, 57, 58, 59, 61, 41, 42, 43,\n-        44, 45, 38, 47, 41, 38, 38, 38,\n-        50, 51, 52, 53, 54, 55, 38, 38,\n-        38, 42, 57, 58, 59, 61, 41, 42,\n-        43, 44, 45, 38, 38, 41, 38, 38,\n-        38, 50, 51, 52, 53, 54, 55, 38,\n-        38, 38, 42, 57, 58, 59, 61, 41,\n-        42, 43, 44, 45, 46, 47, 41, 38,\n-        38, 38, 50, 51, 52, 53, 54, 55,\n-        38, 38, 38, 42, 57, 58, 59, 61,\n-        39, 40, 38, 38, 38, 41, 42, 43,\n-        44, 45, 46, 47, 41, 48, 38, 49,\n-        50, 51, 52, 53, 54, 55, 38, 38,\n-        38, 56, 57, 58, 59, 40, 39, 60,\n-        60, 60, 60, 60, 60, 60, 60, 60,\n-        42, 43, 44, 45, 60, 60, 60, 60,\n-        60, 60, 60, 60, 60, 53, 54, 55,\n-        60, 60, 60, 60, 57, 58, 59, 61,\n-        65, 7, 39, 40, 38, 38, 38, 41,\n-        42, 43, 44, 45, 46, 47, 41, 48,\n-        5, 49, 50, 51, 52, 53, 54, 55,\n-        12, 67, 38, 56, 57, 58, 59, 40,\n-        12, 67, 67, 1, 70, 69, 69, 69,\n-        13, 14, 15, 16, 17, 18, 19, 13,\n-        20, 22, 22, 23, 24, 25, 26, 27,\n-        28, 69, 69, 69, 32, 33, 34, 35,\n-        70, 13, 14, 15, 16, 17, 69, 69,\n-        69, 69, 69, 69, 23, 24, 25, 26,\n-        27, 28, 69, 69, 69, 14, 33, 34,\n-        35, 71, 14, 15, 16, 17, 69, 69,\n-        69, 69, 69, 69, 69, 69, 69, 26,\n-        27, 28, 69, 69, 69, 69, 33, 34,\n-        35, 71, 15, 16, 17, 69, 69, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        69, 69, 69, 69, 69, 33, 34, 35,\n-        16, 17, 69, 69, 69, 69, 69, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        69, 69, 33, 34, 35, 17, 69, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        69, 69, 69, 69, 69, 69, 33, 34,\n-        35, 33, 34, 34, 15, 16, 17, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        26, 27, 28, 69, 69, 69, 69, 33,\n-        34, 35, 71, 15, 16, 17, 69, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        27, 28, 69, 69, 69, 69, 33, 34,\n-        35, 71, 15, 16, 17, 69, 69, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        28, 69, 69, 69, 69, 33, 34, 35,\n-        71, 15, 16, 17, 69, 69, 69, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        69, 69, 69, 69, 33, 34, 35, 71,\n-        14, 15, 16, 17, 69, 69, 69, 69,\n-        69, 69, 23, 24, 25, 26, 27, 28,\n-        69, 69, 69, 14, 33, 34, 35, 71,\n-        14, 15, 16, 17, 69, 69, 69, 69,\n-        69, 69, 69, 24, 25, 26, 27, 28,\n-        69, 69, 69, 14, 33, 34, 35, 71,\n-        14, 15, 16, 17, 69, 69, 69, 69,\n-        69, 69, 69, 69, 25, 26, 27, 28,\n-        69, 69, 69, 14, 33, 34, 35, 71,\n-        13, 14, 15, 16, 17, 69, 19, 13,\n-        69, 69, 69, 23, 24, 25, 26, 27,\n-        28, 69, 69, 69, 14, 33, 34, 35,\n-        71, 13, 14, 15, 16, 17, 69, 69,\n-        13, 69, 69, 69, 23, 24, 25, 26,\n-        27, 28, 69, 69, 69, 14, 33, 34,\n-        35, 71, 13, 14, 15, 16, 17, 18,\n-        19, 13, 69, 69, 69, 23, 24, 25,\n-        26, 27, 28, 69, 69, 69, 14, 33,\n-        34, 35, 71, 1, 70, 69, 69, 69,\n-        13, 14, 15, 16, 17, 18, 19, 13,\n-        20, 69, 22, 23, 24, 25, 26, 27,\n-        28, 69, 69, 69, 32, 33, 34, 35,\n-        70, 1, 69, 69, 69, 69, 69, 69,\n-        69, 69, 69, 14, 15, 16, 17, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        26, 27, 28, 69, 69, 69, 69, 33,\n-        34, 35, 71, 1, 73, 10, 5, 69,\n-        69, 5, 1, 70, 10, 69, 69, 13,\n-        14, 15, 16, 17, 18, 19, 13, 20,\n-        21, 22, 23, 24, 25, 26, 27, 28,\n-        29, 30, 69, 32, 33, 34, 35, 70,\n-        1, 70, 69, 69, 69, 13, 14, 15,\n-        16, 17, 18, 19, 13, 20, 21, 22,\n-        23, 24, 25, 26, 27, 28, 69, 69,\n-        69, 32, 33, 34, 35, 70, 29, 30,\n-        30, 5, 72, 72, 5, 75, 74, 36,\n-        36, 75, 74, 75, 36, 74, 37, 0\n-};\n-\n-static const signed char _use_syllable_machine_index_defaults[] = {\n-        0, 0, 6, 38, 38, 60, 38, 38,\n-        38, 38, 38, 38, 38, 38, 38, 38,\n-        62, 38, 38, 38, 38, 38, 38, 38,\n-        38, 60, 64, 66, 38, 68, 68, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        69, 69, 69, 69, 69, 69, 69, 69,\n-        69, 69, 69, 72, 69, 69, 69, 69,\n-        69, 69, 72, 74, 74, 74, 0\n-};\n-\n-static const signed char _use_syllable_machine_cond_targs[] = {\n-        2, 31, 42, 2, 2, 3, 2, 26,\n-        28, 51, 52, 54, 29, 32, 33, 34,\n-        35, 36, 46, 47, 48, 55, 49, 43,\n-        44, 45, 39, 40, 41, 56, 57, 58,\n-        50, 37, 38, 2, 59, 61, 2, 4,\n-        5, 6, 7, 8, 9, 10, 21, 22,\n-        23, 24, 18, 19, 20, 13, 14, 15,\n-        25, 11, 12, 2, 2, 16, 2, 17,\n-        2, 27, 2, 30, 2, 2, 0, 1,\n-        2, 53, 2, 60, 0\n-};\n-\n-static const signed char _use_syllable_machine_cond_actions[] = {\n-        1, 2, 2, 0, 5, 0, 6, 0,\n-        0, 0, 0, 2, 0, 2, 2, 0,\n-        0, 0, 2, 2, 2, 2, 2, 2,\n-        2, 2, 2, 2, 2, 0, 0, 0,\n-        2, 0, 0, 7, 0, 0, 8, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 9, 10, 0, 11, 0,\n-        12, 0, 13, 0, 14, 15, 0, 0,\n-        16, 0, 17, 0, 0\n-};\n-\n-static const signed char _use_syllable_machine_to_state_actions[] = {\n-        0, 0, 3, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0\n-};\n-\n-static const signed char _use_syllable_machine_from_state_actions[] = {\n-        0, 0, 4, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0, 0,\n-        0, 0, 0, 0, 0, 0, 0\n-};\n-\n-static const signed char _use_syllable_machine_eof_trans[] = {\n-        1, 1, 4, 39, 39, 61, 39, 39,\n-        39, 39, 39, 39, 39, 39, 39, 39,\n-        63, 39, 39, 39, 39, 39, 39, 39,\n-        39, 61, 65, 67, 39, 69, 69, 70,\n-        70, 70, 70, 70, 70, 70, 70, 70,\n-        70, 70, 70, 70, 70, 70, 70, 70,\n-        70, 70, 70, 73, 70, 70, 70, 70,\n-        70, 70, 73, 75, 75, 75, 0\n-};\n-\n-static const int use_syllable_machine_start = 2;\n-static const int use_syllable_machine_first_final = 2;\n-static const int use_syllable_machine_error = -1;\n-\n-static const int use_syllable_machine_en_main = 2;\n-\n-\n-#line 59 \"hb-ot-shape-complex-use-machine.rl\"\n-\n-\n-\n-#line 176 \"hb-ot-shape-complex-use-machine.rl\"\n-\n-\n-#define found_syllable(syllable_type) \\\n-HB_STMT_START { \\\n-        if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", (*ts).second.first, (*te).second.first, #syllable_type); \\\n-                for (unsigned i = (*ts).second.first; i < (*te).second.first; ++i) \\\n-        info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n-        syllable_serial++; \\\n-        if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n-        } HB_STMT_END\n-\n-\n-template <typename Iter>\n-struct machine_index_t :\n-hb_iter_with_fallback_t<machine_index_t<Iter>,\n-typename Iter::item_t>\n-{\n-        machine_index_t (const Iter& it) : it (it) {}\n-        machine_index_t (const machine_index_t& o) : it (o.it) {}\n-\n-        static constexpr bool is_random_access_iterator = Iter::is_random_access_iterator;\n-        static constexpr bool is_sorted_iterator = Iter::is_sorted_iterator;\n-\n-        typename Iter::item_t __item__ () const { return *it; }\n-        typename Iter::item_t __item_at__ (unsigned i) const { return it[i]; }\n-        unsigned __len__ () const { return it.len (); }\n-        void __next__ () { ++it; }\n-        void __forward__ (unsigned n) { it += n; }\n-        void __prev__ () { --it; }\n-        void __rewind__ (unsigned n) { it -= n; }\n-        void operator = (unsigned n)\n-        { unsigned index = (*it).first; if (index < n) it += n - index; else if (index > n) it -= index - n; }\n-        void operator = (const machine_index_t& o) { *this = (*o.it).first; }\n-        bool operator == (const machine_index_t& o) const { return (*it).first == (*o.it).first; }\n-        bool operator != (const machine_index_t& o) const { return !(*this == o); }\n-\n-        private:\n-        Iter it;\n-};\n-struct\n-{\n-        template <typename Iter,\n-        hb_requires (hb_is_iterable (Iter))>\n-        machine_index_t<hb_iter_type<Iter>>\n-        operator () (Iter&& it) const\n-        { return machine_index_t<hb_iter_type<Iter>> (hb_iter (it)); }\n-}\n-HB_FUNCOBJ (machine_index);\n-\n-\n-\n-static bool\n-not_standard_default_ignorable (const hb_glyph_info_t &i)\n-{ return !(i.use_category() == USE(O) && _hb_glyph_info_is_default_ignorable (&i)); }\n-\n-static inline void\n-find_syllables_use (hb_buffer_t *buffer)\n-{\n-        hb_glyph_info_t *info = buffer->info;\n-        auto p =\n-        + hb_iter (info, buffer->len)\n-        | hb_enumerate\n-        | hb_filter ([] (const hb_glyph_info_t &i) { return not_standard_default_ignorable (i); },\n-        hb_second)\n-        | hb_filter ([&] (const hb_pair_t<unsigned, const hb_glyph_info_t &> p)\n-        {\n-                if (p.second.use_category() == USE(ZWNJ))\n-                        for (unsigned i = p.first + 1; i < buffer->len; ++i)\n-                if (not_standard_default_ignorable (info[i]))\n-                        return !_hb_glyph_info_is_unicode_mark (&info[i]);\n-                return true;\n-        })\n-        | hb_enumerate\n-        | machine_index\n-        ;\n-        auto pe = p + p.len ();\n-        auto eof = +pe;\n-        auto ts = +p;\n-        auto te = +p;\n-        unsigned int act HB_UNUSED;\n-        int cs;\n-\n-#line 443 \"hb-ot-shape-complex-use-machine.hh\"\n-        {\n-                cs = (int)use_syllable_machine_start;\n-                ts = 0;\n-                te = 0;\n-        }\n-\n-#line 260 \"hb-ot-shape-complex-use-machine.rl\"\n-\n-\n-        unsigned int syllable_serial = 1;\n-\n-#line 455 \"hb-ot-shape-complex-use-machine.hh\"\n-        {\n-                unsigned int _trans = 0;\n-                const unsigned char * _keys;\n-                const signed char * _inds;\n-                int _ic;\n-                _resume: {}\n-                if ( p == pe && p != eof )\n-                        goto _out;\n-                switch ( _use_syllable_machine_from_state_actions[cs] ) {\n-                        case 4:  {\n-                                {\n-#line 1 \"NONE\"\n-                                        {ts = p;}}\n-\n-#line 470 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                break;\n-                        }\n-                }\n-\n-                if ( p == eof ) {\n-                        if ( _use_syllable_machine_eof_trans[cs] > 0 ) {\n-                                _trans = (unsigned int)_use_syllable_machine_eof_trans[cs] - 1;\n-                        }\n-                }\n-                else {\n-                        _keys = ( _use_syllable_machine_trans_keys + ((cs<<1)));\n-                        _inds = ( _use_syllable_machine_indicies + (_use_syllable_machine_index_offsets[cs]));\n-\n-                        if ( ((*p).second.second.use_category()) <= 52 ) {\n-                                _ic = (int)_use_syllable_machine_char_class[(int)((*p).second.second.use_category()) - 0];\n-                                if ( _ic <= (int)(*( _keys+1)) && _ic >= (int)(*( _keys)) )\n-                                        _trans = (unsigned int)(*( _inds + (int)( _ic - (int)(*( _keys)) ) ));\n-                                else\n-                                        _trans = (unsigned int)_use_syllable_machine_index_defaults[cs];\n-                        }\n-                        else {\n-                                _trans = (unsigned int)_use_syllable_machine_index_defaults[cs];\n-                        }\n-\n-                }\n-                cs = (int)_use_syllable_machine_cond_targs[_trans];\n-\n-                if ( _use_syllable_machine_cond_actions[_trans] != 0 ) {\n-\n-                        switch ( _use_syllable_machine_cond_actions[_trans] ) {\n-                                case 2:  {\n-                                        {\n-#line 1 \"NONE\"\n-                                                {te = p+1;}}\n-\n-#line 508 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 5:  {\n-                                        {\n-#line 163 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p+1;{\n-#line 163 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_independent_cluster); }\n-                                                }}\n-\n-#line 521 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 9:  {\n-                                        {\n-#line 166 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p+1;{\n-#line 166 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_standard_cluster); }\n-                                                }}\n-\n-#line 534 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 7:  {\n-                                        {\n-#line 171 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p+1;{\n-#line 171 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_broken_cluster); }\n-                                                }}\n-\n-#line 547 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 6:  {\n-                                        {\n-#line 172 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p+1;{\n-#line 172 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_non_cluster); }\n-                                                }}\n-\n-#line 560 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 10:  {\n-                                        {\n-#line 164 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 164 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_virama_terminated_cluster); }\n-                                                }}\n-\n-#line 573 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 11:  {\n-                                        {\n-#line 165 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 165 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_sakot_terminated_cluster); }\n-                                                }}\n-\n-#line 586 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 8:  {\n-                                        {\n-#line 166 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 166 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_standard_cluster); }\n-                                                }}\n-\n-#line 599 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 13:  {\n-                                        {\n-#line 167 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 167 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_number_joiner_terminated_cluster); }\n-                                                }}\n-\n-#line 612 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 12:  {\n-                                        {\n-#line 168 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 168 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_numeral_cluster); }\n-                                                }}\n-\n-#line 625 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 14:  {\n-                                        {\n-#line 169 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 169 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_symbol_cluster); }\n-                                                }}\n-\n-#line 638 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 17:  {\n-                                        {\n-#line 170 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 170 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_hieroglyph_cluster); }\n-                                                }}\n-\n-#line 651 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 15:  {\n-                                        {\n-#line 171 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 171 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_broken_cluster); }\n-                                                }}\n-\n-#line 664 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 16:  {\n-                                        {\n-#line 172 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {te = p;p = p - 1;{\n-#line 172 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_non_cluster); }\n-                                                }}\n-\n-#line 677 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                                case 1:  {\n-                                        {\n-#line 171 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                {p = ((te))-1;\n-                                                        {\n-#line 171 \"hb-ot-shape-complex-use-machine.rl\"\n-                                                                found_syllable (use_broken_cluster); }\n-                                                }}\n-\n-#line 691 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                        }\n-\n-                }\n-\n-                if ( p == eof ) {\n-                        if ( cs >= 2 )\n-                                goto _out;\n-                }\n-                else {\n-                        switch ( _use_syllable_machine_to_state_actions[cs] ) {\n-                                case 3:  {\n-                                        {\n-#line 1 \"NONE\"\n-                                                {ts = 0;}}\n-\n-#line 711 \"hb-ot-shape-complex-use-machine.hh\"\n-\n-\n-                                        break;\n-                                }\n-                        }\n-\n-                        p += 1;\n-                        goto _resume;\n-                }\n-                _out: {}\n-        }\n-\n-#line 265 \"hb-ot-shape-complex-use-machine.rl\"\n-\n-}\n-\n-#undef found_syllable\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_USE_MACHINE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-use-machine.hh","additions":0,"deletions":729,"binary":false,"changes":729,"status":"deleted"},{"patch":"@@ -1,1203 +0,0 @@\n-\/* == Start of generated table == *\/\n-\/*\n- * The following table is generated by running:\n- *\n- *   .\/gen-use-table.py IndicSyllabicCategory.txt IndicPositionalCategory.txt UnicodeData.txt ArabicShaping.txt Blocks.txt IndicSyllabicCategory-Additional.txt IndicPositionalCategory-Additional.txt\n- *\n- * on files with these headers:\n- *\n- * # IndicSyllabicCategory-13.0.0.txt\n- * # Date: 2019-07-22, 19:55:00 GMT [KW, RP]\n- * # IndicPositionalCategory-13.0.0.txt\n- * # Date: 2019-07-23, 00:01:00 GMT [KW, RP]\n- * # ArabicShaping-13.0.0.txt\n- * # Date: 2020-01-31, 23:55:00 GMT [KW, RP]\n- * # Blocks-13.0.0.txt\n- * # Date: 2019-07-10, 19:06:00 GMT [KW]\n- * # Override values For Indic_Syllabic_Category\n- * # Not derivable\n- * # Initial version based on Unicode 7.0 by Andrew Glass 2014-03-17\n- * # Updated  for Unicode 10.0 by Andrew Glass 2017-07-25\n- * # Updated  for Unicode 12.1 by Andrew Glass 2019-05-24\n- * # Updated  for Unicode 13.0 by Andrew Glass 2020-07-28\n- * # Override values For Indic_Positional_Category\n- * # Not derivable\n- * # Initial version based on Unicode 7.0 by Andrew Glass 2014-03-17\n- * # Updated  for Unicode 10.0 by Andrew Glass 2017-07-25\n- * # Ammended for Unicode 10.0 by Andrew Glass 2018-09-21\n- * # Updated  for L2\/19-083    by Andrew Glass 2019-05-06\n- * # Updated  for Unicode 12.1 by Andrew Glass 2019-05-30\n- * # Updated  for Unicode 13.0 by Andrew Glass 2020-07-28\n- * UnicodeData.txt does not have a header.\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_USE_TABLE_HH\n-#define HB_OT_SHAPE_COMPLEX_USE_TABLE_HH\n-\n-#include \"hb.hh\"\n-\n-#include \"hb-ot-shape-complex-use-machine.hh\"\n-\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wunused-macros\"\n-#define B       USE(B)  \/* BASE *\/\n-#define CS      USE(CS) \/* CONS_WITH_STACKER *\/\n-#define G       USE(G)  \/* HIEROGLYPH *\/\n-#define GB      USE(GB) \/* BASE_OTHER *\/\n-#define H       USE(H)  \/* HALANT *\/\n-#define HN      USE(HN) \/* HALANT_NUM *\/\n-#define HVM     USE(HVM)        \/* HALANT_OR_VOWEL_MODIFIER *\/\n-#define J       USE(J)  \/* HIEROGLYPH_JOINER *\/\n-#define N       USE(N)  \/* BASE_NUM *\/\n-#define O       USE(O)  \/* OTHER *\/\n-#define R       USE(R)  \/* REPHA *\/\n-#define S       USE(S)  \/* SYM *\/\n-#define SB      USE(SB) \/* HIEROGLYPH_SEGMENT_BEGIN *\/\n-#define SE      USE(SE) \/* HIEROGLYPH_SEGMENT_END *\/\n-#define SUB     USE(SUB)        \/* CONS_SUB *\/\n-#define Sk      USE(Sk) \/* SAKOT *\/\n-#define ZWNJ    USE(ZWNJ)       \/* ZWNJ *\/\n-#define CMAbv   USE(CMAbv)\n-#define CMBlw   USE(CMBlw)\n-#define FAbv    USE(FAbv)\n-#define FBlw    USE(FBlw)\n-#define FPst    USE(FPst)\n-#define FMAbv   USE(FMAbv)\n-#define FMBlw   USE(FMBlw)\n-#define FMPst   USE(FMPst)\n-#define MAbv    USE(MAbv)\n-#define MBlw    USE(MBlw)\n-#define MPst    USE(MPst)\n-#define MPre    USE(MPre)\n-#define SMAbv   USE(SMAbv)\n-#define SMBlw   USE(SMBlw)\n-#define VAbv    USE(VAbv)\n-#define VBlw    USE(VBlw)\n-#define VPst    USE(VPst)\n-#define VPre    USE(VPre)\n-#define VMAbv   USE(VMAbv)\n-#define VMBlw   USE(VMBlw)\n-#define VMPst   USE(VMPst)\n-#define VMPre   USE(VMPre)\n-#pragma GCC diagnostic pop\n-\n-static const uint8_t use_table[] = {\n-\n-\n-#define use_offset_0x0028u 0\n-\n-\n-  \/* Basic Latin *\/\n-                                                                         O,     O,     O,     O,     O,    GB,     O,     O,\n-  \/* 0030 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x00a0u 24\n-\n-\n-  \/* Latin-1 Supplement *\/\n-\n-  \/* 00A0 *\/    GB,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 00B0 *\/     O,     O, FMPst, FMPst,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 00C0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 00D0 *\/     O,     O,     O,     O,     O,     O,     O,    GB,\n-\n-#define use_offset_0x0640u 80\n-\n-\n-  \/* Arabic *\/\n-\n-  \/* 0640 *\/     B,     O,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x07c8u 88\n-\n-\n-  \/* NKo *\/\n-                                                                         O,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 07D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 07E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,\n-  \/* 07F0 *\/ VMAbv, VMAbv, VMAbv, VMAbv,     O,     O,     O,     O,     O,     O,     B,     O,     O, VMAbv,     O,     O,\n-\n-#define use_offset_0x0840u 144\n-\n-\n-  \/* Mandaic *\/\n-\n-  \/* 0840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, CMBlw, CMBlw, CMBlw,     O,     O,     O,     O,\n-\n-#define use_offset_0x0900u 176\n-\n-\n-  \/* Devanagari *\/\n-\n-  \/* 0900 *\/ VMAbv, VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VPst, CMBlw,     B,  VPst,  VPre,\n-  \/* 0940 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VPst,  VPst,  VPst,  VPst,     H,  VPre,  VPst,\n-  \/* 0950 *\/     O, VMAbv, VMBlw,     O,     O,  VAbv,  VBlw,  VBlw,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0960 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0970 *\/     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-\n-  \/* Bengali *\/\n-\n-  \/* 0980 *\/    GB, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     B,\n-  \/* 0990 *\/     B,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 09A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 09B0 *\/     B,     O,     B,     O,     O,     O,     B,     B,     B,     B,     O,     O, CMBlw,     B,  VPst,  VPre,\n-  \/* 09C0 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,     O,     O,  VPre,  VPre,     O,     O,  VPre,  VPre,     H,     O,     O,\n-  \/* 09D0 *\/     O,     O,     O,     O,     O,     O,     O,  VPst,     O,     O,     O,     O,     B,     B,     O,     B,\n-  \/* 09E0 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 09F0 *\/     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     B,     O, FMAbv,     O,\n-\n-  \/* Gurmukhi *\/\n-\n-  \/* 0A00 *\/     O, VMAbv, VMAbv, VMPst,     O,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     B,\n-  \/* 0A10 *\/     B,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 0A30 *\/     B,     O,     B,     B,     O,     B,     B,     O,     B,     B,     O,     O, CMBlw,     O,  VPst,  VPre,\n-  \/* 0A40 *\/  VPst,  VBlw,  VBlw,     O,     O,     O,     O,  VAbv,  VAbv,     O,     O,  VAbv,  VAbv,     H,     O,     O,\n-  \/* 0A50 *\/     O, VMBlw,     O,     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     O,     B,     O,\n-  \/* 0A60 *\/     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0A70 *\/ VMAbv, CMAbv,    GB,    GB,     O,  MBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Gujarati *\/\n-\n-  \/* 0A80 *\/     O, VMAbv, VMAbv, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,\n-  \/* 0A90 *\/     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0AA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 0AB0 *\/     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,     O,     O, CMBlw,     B,  VPst,  VPre,\n-  \/* 0AC0 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,     O,  VAbv,  VAbv,  VAbv,     O,  VPst,  VPst,     H,     O,     O,\n-  \/* 0AD0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 0AE0 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0AF0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     B, VMAbv, VMAbv, VMAbv, CMAbv, CMAbv, CMAbv,\n-\n-  \/* Oriya *\/\n-\n-  \/* 0B00 *\/     O, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     B,\n-  \/* 0B10 *\/     B,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 0B30 *\/     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,     O,     O, CMBlw,     B,  VPst,  VAbv,\n-  \/* 0B40 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,     O,     O,  VPre,  VPre,     O,     O,  VPre,  VPre,     H,     O,     O,\n-  \/* 0B50 *\/     O,     O,     O,     O,     O,  VAbv,  VAbv,  VAbv,     O,     O,     O,     O,     B,     B,     O,     B,\n-  \/* 0B60 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0B70 *\/     O,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Tamil *\/\n-\n-  \/* 0B80 *\/     O,     O, VMAbv,     O,     O,     B,     B,     B,     B,     B,     B,     O,     O,     O,     B,     B,\n-  \/* 0B90 *\/     B,     O,     B,     B,     B,     B,     O,     O,     O,     B,     B,     O,     B,     O,     B,     B,\n-  \/* 0BA0 *\/     O,     O,     O,     B,     B,     O,     O,     O,     B,     B,     B,     O,     O,     O,     B,     B,\n-  \/* 0BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,  VPst,  VPst,\n-  \/* 0BC0 *\/  VAbv,  VPst,  VPst,     O,     O,     O,  VPre,  VPre,  VPre,     O,  VPre,  VPre,  VPre,     H,     O,     O,\n-  \/* 0BD0 *\/     O,     O,     O,     O,     O,     O,     O,  VPst,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 0BE0 *\/     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0BF0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Telugu *\/\n-\n-  \/* 0C00 *\/ VMAbv, VMPst, VMPst, VMPst, VMAbv,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n-  \/* 0C10 *\/     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 0C30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     B,  VAbv,  VAbv,\n-  \/* 0C40 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,     O,  VAbv,  VAbv,  VAbv,     O,  VAbv,  VAbv,  VAbv,     H,     O,     O,\n-  \/* 0C50 *\/     O,     O,     O,     O,     O,  VAbv,  VBlw,     O,     B,     B,     B,     O,     O,     O,     O,     O,\n-  \/* 0C60 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0C70 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Kannada *\/\n-\n-  \/* 0C80 *\/     B, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n-  \/* 0C90 *\/     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0CA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 0CB0 *\/     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     O,     O, CMBlw,     B,  VPst,  VAbv,\n-  \/* 0CC0 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,     O,  VAbv,  VAbv,  VAbv,     O,  VAbv,  VAbv,  VAbv,     H,     O,     O,\n-  \/* 0CD0 *\/     O,     O,     O,     O,     O,  VPst,  VPst,     O,     O,     O,     O,     O,     O,     O,     B,     O,\n-  \/* 0CE0 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0CF0 *\/     O,    CS,    CS,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Malayalam *\/\n-\n-  \/* 0D00 *\/ VMAbv, VMAbv, VMPst, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n-  \/* 0D10 *\/     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0D20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,     B,  VPst,  VPst,\n-  \/* 0D40 *\/  VPst,  VPst,  VPst,  VBlw,  VBlw,     O,  VPre,  VPre,  VPre,     O,  VPre,  VPre,  VPre,     H,     R,     O,\n-  \/* 0D50 *\/     O,     O,     O,     O,     O,     O,     O,  VPst,     O,     O,     O,     O,     O,     O,     O,     B,\n-  \/* 0D60 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0D70 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Sinhala *\/\n-\n-  \/* 0D80 *\/     O, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0D90 *\/     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 0DA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0DB0 *\/     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     O,     O,\n-  \/* 0DC0 *\/     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     H,     O,     O,     O,     O,  VPst,\n-  \/* 0DD0 *\/  VPst,  VPst,  VAbv,  VAbv,  VBlw,     O,  VBlw,     O,  VPst,  VPre,  VPre,  VPre,  VPre,  VPre,  VPre,  VPst,\n-  \/* 0DE0 *\/     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0DF0 *\/     O,     O,  VPst,  VPst,     O,     O,     O,     O,\n-\n-#define use_offset_0x0f00u 1448\n-\n-\n-  \/* Tibetan *\/\n-\n-  \/* 0F00 *\/     B,     B,     O,     O,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 0F10 *\/     O,     O,     O,     O,     O,     O,     O,     O,  VBlw,  VBlw,     O,     O,     O,     O,     O,     O,\n-  \/* 0F20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0F30 *\/     B,     B,     B,     B,     O,  FBlw,     O,  FBlw,     O, CMAbv,     O,     O,     O,     O,  VPst,  VPre,\n-  \/* 0F40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0F50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 0F60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,\n-  \/* 0F70 *\/     O, CMBlw,  VBlw,  VAbv,  VAbv,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw, VMAbv,     O,\n-  \/* 0F80 *\/  VBlw,  VAbv, VMAbv, VMAbv,  VBlw,     O, VMAbv, VMAbv,     B,     B,     B,     B,     B,   SUB,   SUB,   SUB,\n-  \/* 0F90 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,     O,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n-  \/* 0FA0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n-  \/* 0FB0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,     O,     O,     O,\n-  \/* 0FC0 *\/     O,     O,     O,     O,     O,     O,  FBlw,     O,\n-\n-#define use_offset_0x1000u 1648\n-\n-\n-  \/* Myanmar *\/\n-\n-  \/* 1000 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VAbv,  VAbv,  VBlw,\n-  \/* 1030 *\/  VBlw,  VPre,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMBlw, VMPst,     H,  VAbv,  MPst,  MPre,  MBlw,  MBlw,     B,\n-  \/* 1040 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,    GB,     O,     O,    GB,     O,\n-  \/* 1050 *\/     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VBlw,  VBlw,     B,     B,     B,     B,  MBlw,  MBlw,\n-  \/* 1060 *\/  MBlw,     B,  VPst, VMPst, VMPst,     B,     B,  VPst,  VPst, VMPst, VMPst, VMPst, VMPst, VMPst,     B,     B,\n-  \/* 1070 *\/     B,  VAbv,  VAbv,  VAbv,  VAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1080 *\/     B,     B,  MBlw,  VPst,  VPre,  VAbv,  VAbv, VMPst, VMPst, VMPst, VMPst, VMPst, VMPst, VMBlw,     B, VMPst,\n-  \/* 1090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMPst, VMPst,  VPst,  VAbv,     O,     O,\n-\n-#define use_offset_0x1700u 1808\n-\n-\n-  \/* Tagalog *\/\n-\n-  \/* 1700 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n-  \/* 1710 *\/     B,     B,  VAbv,  VBlw,  VBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Hanunoo *\/\n-\n-  \/* 1720 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1730 *\/     B,     B,  VAbv,  VBlw,  VBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Buhid *\/\n-\n-  \/* 1740 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1750 *\/     B,     B,  VAbv,  VBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Tagbanwa *\/\n-\n-  \/* 1760 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n-  \/* 1770 *\/     B,     O,  VAbv,  VBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Khmer *\/\n-\n-  \/* 1780 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1790 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 17A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 17B0 *\/     B,     B,     B,     B,     O,     O,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VPre,  VPre,\n-  \/* 17C0 *\/  VPre,  VPre,  VPre,  VPre,  VPre,  VPre, VMAbv, VMPst,  VPst, VMAbv, VMAbv, FMAbv,  FAbv, CMAbv, FMAbv, VMAbv,\n-  \/* 17D0 *\/ FMAbv,  VAbv,     H, FMAbv,     O,     O,     O,     O,     O,     O,     O,     O,     B, FMAbv,     O,     O,\n-  \/* 17E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-  \/* 17F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Mongolian *\/\n-\n-  \/* 1800 *\/     B,     O,     O,     O,     O,     O,     O,     B,     O,     O,     B,     O,     O,     O,     O,     O,\n-  \/* 1810 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 1820 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1830 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1860 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1870 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 1880 *\/    GB,    GB,    GB,    GB,    GB, CMAbv, CMAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1890 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, CMBlw,     B,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x1900u 2240\n-\n-\n-  \/* Limbu *\/\n-\n-  \/* 1900 *\/    GB,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,\n-  \/* 1920 *\/  VAbv,  VAbv,  VBlw,  VPst,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,   SUB,   SUB,   SUB,     O,     O,     O,     O,\n-  \/* 1930 *\/  FPst,  FPst, VMBlw,  FPst,  FPst,  FPst,  FPst,  FPst,  FPst,  FBlw, VMAbv, FMBlw,     O,     O,     O,     O,\n-  \/* 1940 *\/     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-\n-  \/* Tai Le *\/\n-\n-  \/* 1950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1960 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,\n-  \/* 1970 *\/     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* New Tai Lue *\/\n-\n-  \/* 1980 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1990 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 19A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,\n-  \/* 19B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 19C0 *\/     B,     B,     B,     B,     B,     B,     B,     B, VMPst, VMPst,     O,     O,     O,     O,     O,     O,\n-  \/* 19D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,\n-  \/* 19E0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 19F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Buginese *\/\n-\n-  \/* 1A00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1A10 *\/     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VPre,  VPst,  VAbv,     O,     O,     O,     O,\n-\n-  \/* Tai Tham *\/\n-\n-  \/* 1A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1A30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1A40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1A50 *\/     B,     B,     B,     B,     B,  MPre,  MBlw,   SUB,  FAbv,  FAbv,  MAbv,   SUB,   SUB,   SUB,   SUB,     O,\n-  \/* 1A60 *\/    Sk,  VPst,  VAbv,  VPst,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VAbv,  VBlw,  VPst,  VPre,  VPre,\n-  \/* 1A70 *\/  VPre,  VPre,  VPre,  VAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,  VAbv, VMAbv, VMAbv,     O,     O, VMBlw,\n-  \/* 1A80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-  \/* 1A90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x1b00u 2656\n-\n-\n-  \/* Balinese *\/\n-\n-  \/* 1B00 *\/ VMAbv, VMAbv, VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1B30 *\/     B,     B,     B,     B, CMAbv,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPre,  VPre,\n-  \/* 1B40 *\/  VPre,  VPre,  VAbv,  VAbv,     H,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,\n-  \/* 1B50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,    GB,    GB,     O,     O,    GB,\n-  \/* 1B60 *\/     O,     S,    GB,     S,     S,     S,     S,     S,    GB,     S,     S, SMAbv, SMBlw, SMAbv, SMAbv, SMAbv,\n-  \/* 1B70 *\/ SMAbv, SMAbv, SMAbv, SMAbv,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Sundanese *\/\n-\n-  \/* 1B80 *\/ VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1B90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BA0 *\/     B,   SUB,   SUB,   SUB,  VAbv,  VBlw,  VPre,  VPst,  VAbv,  VAbv,  VPst,     H,   SUB,   SUB,     B,     B,\n-  \/* 1BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-\n-  \/* Batak *\/\n-\n-  \/* 1BC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BE0 *\/     B,     B,     B,     B,     B,     B, CMAbv,  VPst,  VAbv,  VAbv,  VPst,  VPst,  VPst,  VAbv,  VPst,  VAbv,\n-  \/* 1BF0 *\/  FAbv,  FAbv, CMBlw, CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Lepcha *\/\n-\n-  \/* 1C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1C20 *\/     B,     B,     B,     B,   SUB,   SUB,  VPst,  VPre,  VPre,  VPre,  VPst,  VPst,  VBlw,  FAbv,  FAbv,  FAbv,\n-  \/* 1C30 *\/  FAbv,  FAbv,  FAbv,  FAbv, VMPre, VMPre, FMAbv, CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 1C40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     B,     B,     B,\n-\n-#define use_offset_0x1cd0u 2992\n-\n-\n-  \/* Vedic Extensions *\/\n-\n-  \/* 1CD0 *\/ VMAbv, VMAbv, VMAbv,     O, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMAbv, VMAbv, VMBlw, VMBlw, VMBlw, VMBlw,\n-  \/* 1CE0 *\/ VMAbv, VMPst, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw,     O,     O,     O,     O, VMBlw,     O,     O,\n-  \/* 1CF0 *\/     O,     O,     O,     O, VMAbv,    CS,    CS, VMPst, VMAbv, VMAbv,    GB,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x1df8u 3040\n-\n-\n-  \/* Combining Diacritical Marks Supplement *\/\n-                                                                         O,     O,     O, FMAbv,     O,     O,     O,     O,\n-\n-#define use_offset_0x2008u 3048\n-\n-\n-  \/* General Punctuation *\/\n-                                                                         O,     O,     O,     O,  ZWNJ,     O,     O,     O,\n-  \/* 2010 *\/    GB,    GB,    GB,    GB,    GB,     O,     O,     O,\n-\n-#define use_offset_0x2070u 3064\n-\n-\n-  \/* Superscripts and Subscripts *\/\n-\n-  \/* 2070 *\/     O,     O,     O,     O, FMPst,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 2080 *\/     O,     O, FMPst, FMPst, FMPst,     O,     O,     O,\n-\n-#define use_offset_0x20f0u 3088\n-\n-\n-  \/* Combining Diacritical Marks for Symbols *\/\n-\n-  \/* 20F0 *\/ VMAbv,     O,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x25c8u 3096\n-\n-\n-  \/* Geometric Shapes *\/\n-                                                                         O,     O,     O,     O,     B,     O,     O,     O,\n-\n-#define use_offset_0x2d30u 3104\n-\n-\n-  \/* Tifinagh *\/\n-\n-  \/* 2D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 2D40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 2D50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 2D60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     B,\n-  \/* 2D70 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     H,\n-\n-#define use_offset_0xa800u 3184\n-\n-\n-  \/* Syloti Nagri *\/\n-\n-  \/* A800 *\/     B,     B,  VAbv,     B,     B,     B,     H,     B,     B,     B,     B, VMAbv,     B,     B,     B,     B,\n-  \/* A810 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A820 *\/     B,     B,     B,  VPst,  VPst,  VBlw,  VAbv,  VPst,     O,     O,     O,     O,  VBlw,     O,     O,     O,\n-  \/* A830 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Phags-pa *\/\n-\n-  \/* A840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A860 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A870 *\/     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Saurashtra *\/\n-\n-  \/* A880 *\/ VMPst, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A890 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A8A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A8B0 *\/     B,     B,     B,     B,  MPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,\n-  \/* A8C0 *\/  VPst,  VPst,  VPst,  VPst,     H, VMAbv,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* A8D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Devanagari Extended *\/\n-\n-  \/* A8E0 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,\n-  \/* A8F0 *\/ VMAbv, VMAbv,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     B,  VAbv,\n-\n-  \/* Kayah Li *\/\n-\n-  \/* A900 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A920 *\/     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv, VMBlw, VMBlw, VMBlw,     O,     O,\n-\n-  \/* Rejang *\/\n-\n-  \/* A930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A940 *\/     B,     B,     B,     B,     B,     B,     B,  VBlw,  VBlw,  VBlw,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  FAbv,\n-  \/* A950 *\/  FAbv,  FAbv,  FPst,  VPst,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* A960 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* A970 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Javanese *\/\n-\n-  \/* A980 *\/ VMAbv, VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A990 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A9A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A9B0 *\/     B,     B,     B, CMAbv,  VPst,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VPre,  VPre,  VAbv,  MBlw,  MPst,  MBlw,\n-  \/* A9C0 *\/     H,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* A9D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Myanmar Extended-B *\/\n-\n-  \/* A9E0 *\/     B,     B,     B,     B,     B,  VAbv,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* A9F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,\n-\n-  \/* Cham *\/\n-\n-  \/* AA00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AA10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AA20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VAbv,  VPre,\n-  \/* AA30 *\/  VPre,  VAbv,  VBlw,  MPst,  MPre,  MAbv,  MBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* AA40 *\/     B,     B,     B,  FAbv,     B,     B,     B,     B,     B,     B,     B,     B,  FAbv,  FPst,     O,     O,\n-  \/* AA50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Myanmar Extended-A *\/\n-\n-  \/* AA60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AA70 *\/     O,     B,     B,     B,    GB,    GB,    GB,     O,     O,     O,     B, VMPst, VMAbv, VMPst,     B,     B,\n-\n-  \/* Tai Viet *\/\n-\n-  \/* AA80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AA90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AAA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* AAB0 *\/  VAbv,     B,  VAbv,  VAbv,  VBlw,     B,     B,  VAbv,  VAbv,     B,     B,     B,     B,     B,  VAbv, VMAbv,\n-  \/* AAC0 *\/     B, VMAbv,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* AAD0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Meetei Mayek Extensions *\/\n-\n-  \/* AAE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPre,  VBlw,  VAbv,  VPre,  VPst,\n-  \/* AAF0 *\/     O,     O,     O,     O,     O, VMPst,     H,     O,\n-\n-#define use_offset_0xabc0u 3944\n-\n-\n-  \/* Meetei Mayek *\/\n-\n-  \/* ABC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* ABD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* ABE0 *\/     B,     B,     B,  VPst,  VPst,  VAbv,  VPst,  VPst,  VBlw,  VPst,  VPst,     O, VMPst,  VBlw,     O,     O,\n-  \/* ABF0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x10a00u 4008\n-\n-\n-  \/* Kharoshthi *\/\n-\n-  \/* 10A00 *\/     B,  VBlw,  VBlw,  VBlw,     O,  VAbv,  VBlw,     O,     O,     O,     O,     O,  VPst, VMBlw, VMBlw, VMAbv,\n-  \/* 10A10 *\/     B,     B,     B,     B,     O,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10A30 *\/     B,     B,     B,     B,     B,     B,     O,     O, CMAbv, CMBlw, CMBlw,     O,     O,     O,     O,     H,\n-  \/* 10A40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x10ac0u 4088\n-\n-\n-  \/* Manichaean *\/\n-\n-  \/* 10AC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10AD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10AE0 *\/     B,     B,     B,     B,     B, CMBlw, CMBlw,     O,\n-\n-#define use_offset_0x10b80u 4128\n-\n-\n-  \/* Psalter Pahlavi *\/\n-\n-  \/* 10B80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10B90 *\/     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 10BA0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     B,     B,     O,\n-\n-#define use_offset_0x10d00u 4176\n-\n-\n-  \/* Hanifi Rohingya *\/\n-\n-  \/* 10D00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10D10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10D20 *\/     B,     B,     B,     B, VMAbv, VMAbv, VMAbv, CMAbv,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 10D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x10e80u 4240\n-\n-\n-  \/* Yezidi *\/\n-\n-  \/* 10E80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10E90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10EA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,  VAbv,  VAbv,     O,     O,     O,\n-  \/* 10EB0 *\/     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x10f30u 4296\n-\n-\n-  \/* Sogdian *\/\n-\n-  \/* 10F30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10F40 *\/     B,     B,     B,     B,     B,     B, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw,\n-  \/* 10F50 *\/ VMBlw,     B,     B,     B,     B,     O,     O,     O,\n-\n-#define use_offset_0x10fb0u 4336\n-\n-\n-  \/* Chorasmian *\/\n-\n-  \/* 10FB0 *\/     B,     O,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 10FC0 *\/     O,     B,     B,     B,     B,     O,     O,     O,     O,     B,     B,     B,     O,     O,     O,     O,\n-  \/* 10FD0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 10FE0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 10FF0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Brahmi *\/\n-\n-  \/* 11000 *\/ VMPst, VMAbv, VMPst,    CS,    CS,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11030 *\/     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,\n-  \/* 11040 *\/  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,   HVM,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11050 *\/     O,     O,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,\n-  \/* 11060 *\/     N,     N,     N,     N,     N,     N,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11070 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    HN,\n-\n-  \/* Kaithi *\/\n-\n-  \/* 11080 *\/ VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 110A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 110B0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VAbv,  VAbv,  VPst,  VPst,     H, CMBlw,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x11100u 4608\n-\n-\n-  \/* Chakma *\/\n-\n-  \/* 11100 *\/ VMAbv, VMAbv, VMAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11110 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11120 *\/     B,     B,     B,     B,     B,     B,     B,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPre,  VBlw,  VAbv,  VAbv,\n-  \/* 11130 *\/  VBlw,  VAbv,  VAbv,     H, CMAbv,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11140 *\/     O,     O,     O,     O,     B,  VPst,  VPst,     B,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Mahajani *\/\n-\n-  \/* 11150 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11160 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11170 *\/     B,     B,     B, CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Sharada *\/\n-\n-  \/* 11180 *\/ VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11190 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 111A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 111B0 *\/     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,\n-  \/* 111C0 *\/     H,     B,     R,     R,     O,     O,     O,     O,    GB, FMBlw, CMBlw,  VAbv,  VBlw,     O,  VPre, VMAbv,\n-  \/* 111D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,\n-\n-  \/* Sinhala Archaic Numbers *\/\n-\n-  \/* 111E0 *\/     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 111F0 *\/     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Khojki *\/\n-\n-  \/* 11200 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11210 *\/     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11220 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VPst,  VBlw,\n-  \/* 11230 *\/  VAbv,  VAbv,  VAbv,  VAbv, VMAbv,     H, CMAbv, CMAbv,     O,     O,     O,     O,     O,     O, VMAbv,     O,\n-\n-#define use_offset_0x11280u 4928\n-\n-\n-  \/* Multani *\/\n-\n-  \/* 11280 *\/     B,     B,     B,     B,     B,     B,     B,     O,     B,     O,     B,     B,     B,     B,     O,     B,\n-  \/* 11290 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,\n-  \/* 112A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Khudawadi *\/\n-\n-  \/* 112B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 112C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 112D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,\n-  \/* 112E0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv, CMBlw,  VBlw,     O,     O,     O,     O,     O,\n-  \/* 112F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Grantha *\/\n-\n-  \/* 11300 *\/ VMAbv, VMAbv, VMAbv, VMAbv,     O,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     B,\n-  \/* 11310 *\/     B,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11320 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 11330 *\/     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,     O, CMBlw, CMBlw,     B,  VPst,  VPst,\n-  \/* 11340 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,     O,     O,  VPre,  VPre,     O,     O,  VPre,  VPre,   HVM,     O,     O,\n-  \/* 11350 *\/     O,     O,     O,     O,     O,     O,     O,  VPst,     O,     O,     O,     O,     O,     O,     B,     B,\n-  \/* 11360 *\/     B,     B,  VPst,  VPst,     O,     O, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     O,     O,     O,\n-  \/* 11370 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     O,     O,     O,\n-\n-#define use_offset_0x11400u 5176\n-\n-\n-  \/* Newa *\/\n-\n-  \/* 11400 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11410 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11420 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11430 *\/     B,     B,     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,\n-  \/* 11440 *\/  VPst,  VPst,     H, VMAbv, VMAbv, VMPst, CMBlw,     B,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11450 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O, FMAbv,     B,\n-  \/* 11460 *\/    CS,    CS,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11470 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Tirhuta *\/\n-\n-  \/* 11480 *\/     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11490 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 114A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 114B0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VPre,  VAbv,  VPre,  VPre,  VPst,  VPre, VMAbv,\n-  \/* 114C0 *\/ VMAbv, VMAbv,     H, CMBlw,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 114D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x11580u 5400\n-\n-\n-  \/* Siddham *\/\n-\n-  \/* 11580 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11590 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 115A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,\n-  \/* 115B0 *\/  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,     O,     O,  VPre,  VPre,  VPre,  VPre, VMAbv, VMAbv, VMPst,     H,\n-  \/* 115C0 *\/ CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 115D0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,  VBlw,  VBlw,     O,     O,\n-  \/* 115E0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 115F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Modi *\/\n-\n-  \/* 11600 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11610 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11620 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11630 *\/  VPst,  VPst,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPst,  VPst, VMAbv, VMPst,     H,\n-  \/* 11640 *\/  VAbv,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11650 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-  \/* 11660 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11670 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Takri *\/\n-\n-  \/* 11680 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11690 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 116A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMPst,  VAbv,  VPre,  VPst,\n-  \/* 116B0 *\/  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,     H, CMBlw,     B,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 116C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-  \/* 116D0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 116E0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 116F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Ahom *\/\n-\n-  \/* 11700 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11710 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,  MBlw,  MPre,  MAbv,\n-  \/* 11720 *\/  VPst,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VPre,  VAbv,  VBlw,  VAbv,  VAbv,  VAbv,     O,     O,     O,     O,\n-  \/* 11730 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,\n-\n-#define use_offset_0x11800u 5848\n-\n-\n-  \/* Dogra *\/\n-\n-  \/* 11800 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11810 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11820 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,\n-  \/* 11830 *\/  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMPst,     H, CMBlw,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x11900u 5912\n-\n-\n-  \/* Dives Akuru *\/\n-\n-  \/* 11900 *\/     B,     B,     B,     B,     B,     B,     B,     O,     O,     B,     O,     O,     B,     B,     B,     B,\n-  \/* 11910 *\/     B,     B,     B,     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11930 *\/  VPst,  VPst,  VPst,  VPst,  VPst,  VPre,     O,  VPre,  VPre,     O,     O, VMAbv, VMAbv,  VPst,     H,     R,\n-  \/* 11940 *\/  MPst,     R,  MPst, CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x119a0u 6008\n-\n-\n-  \/* Nandinagari *\/\n-\n-  \/* 119A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 119B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 119C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 119D0 *\/     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,     O,     O,  VAbv,  VAbv,  VPst,  VPst, VMPst, VMPst,\n-  \/* 119E0 *\/     H,     B,     O,     O,  VPre,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 119F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Zanabazar Square *\/\n-\n-  \/* 11A00 *\/     B,  VAbv,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,     B,     B,     B,     B,     B,\n-  \/* 11A10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11A30 *\/     B,     B,     B, FMBlw,  VBlw, VMAbv, VMAbv, VMAbv, VMAbv, VMPst,     R,  MBlw,  MBlw,  MBlw,  MBlw,    GB,\n-  \/* 11A40 *\/     O,     O,     O,     O,     O,    GB,     O,     H,     O,     O,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Soyombo *\/\n-\n-  \/* 11A50 *\/     B,  VAbv,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VPst,  VPst,  VBlw,  VBlw,  VBlw,     B,     B,     B,     B,\n-  \/* 11A60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11A70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11A80 *\/     B,     B,     B,     B,     R,     R,     R,     R,     R,     R,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,\n-  \/* 11A90 *\/  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw, VMAbv, VMPst, CMAbv,     H,     O,     O,     O,     B,     O,     O,\n-\n-#define use_offset_0x11c00u 6264\n-\n-\n-  \/* Bhaiksuki *\/\n-\n-  \/* 11C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 11C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,\n-  \/* 11C30 *\/  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,     O,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMAbv, VMPst,     H,\n-  \/* 11C40 *\/     B,     O,     O,     O,    GB,    GB,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11C50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11C60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,\n-\n-  \/* Marchen *\/\n-\n-  \/* 11C70 *\/     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11C80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11C90 *\/     O,     O,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n-  \/* 11CA0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,     O,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n-  \/* 11CB0 *\/  VBlw,  VPre,  VBlw,  VAbv,  VPst, VMAbv, VMAbv,     O,\n-\n-#define use_offset_0x11d00u 6448\n-\n-\n-  \/* Masaram Gondi *\/\n-\n-  \/* 11D00 *\/     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,\n-  \/* 11D10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11D20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11D30 *\/     B,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,     O,     O,     O,  VAbv,     O,  VAbv,  VAbv,     O,  VAbv,\n-  \/* 11D40 *\/ VMAbv, VMAbv, CMBlw,  VAbv,  VBlw,     H,     R,  MBlw,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11D50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-  \/* Gunjala Gondi *\/\n-\n-  \/* 11D60 *\/     B,     B,     B,     B,     B,     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n-  \/* 11D70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11D80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VPst,  VPst,  VPst,     O,\n-  \/* 11D90 *\/  VAbv,  VAbv,     O,  VPst,  VPst, VMAbv, VMPst,     H,     O,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 11DA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x11ee0u 6624\n-\n-\n-  \/* Makasar *\/\n-\n-  \/* 11EE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 11EF0 *\/     B,     B,    GB,  VAbv,  VBlw,  VPre,  VPst,     O,\n-\n-#define use_offset_0x13000u 6648\n-\n-\n-  \/* Egyptian Hieroglyphs *\/\n-\n-  \/* 13000 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13010 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13020 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13030 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13040 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13050 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13060 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13070 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13080 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13090 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 130A0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 130B0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 130C0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 130D0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 130E0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 130F0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13100 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13110 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13120 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13130 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13140 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13150 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13160 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13170 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13180 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13190 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 131A0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 131B0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 131C0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 131D0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 131E0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 131F0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13200 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13210 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13220 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13230 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13240 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13250 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13260 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13270 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13280 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13290 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 132A0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 132B0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 132C0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 132D0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 132E0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 132F0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13300 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13310 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13320 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13330 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13340 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13350 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13360 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13370 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13380 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13390 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 133A0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 133B0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 133C0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 133D0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 133E0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 133F0 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13400 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13410 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,\n-  \/* 13420 *\/     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     G,     O,\n-\n-  \/* Egyptian Hieroglyph Format Controls *\/\n-\n-  \/* 13430 *\/     J,     J,     J,     J,     J,     J,     J,    SB,    SE,     O,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x16b00u 7736\n-\n-\n-  \/* Pahawh Hmong *\/\n-\n-  \/* 16B00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16B30 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     O,\n-\n-#define use_offset_0x16f00u 7792\n-\n-\n-  \/* Miao *\/\n-\n-  \/* 16F00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16F10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16F20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16F30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 16F40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O, CMBlw,\n-  \/* 16F50 *\/     O,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,\n-  \/* 16F60 *\/  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,\n-  \/* 16F70 *\/  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,\n-  \/* 16F80 *\/  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,     O,     O,     O,     O,     O,     O,     O, VMBlw,\n-  \/* 16F90 *\/ VMBlw, VMBlw, VMBlw,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x16fe0u 7944\n-\n-\n-  \/* Ideographic Symbols and Punctuation *\/\n-\n-  \/* 16FE0 *\/     O,     O,     O,     O,     B,     O,     O,     O,\n-\n-#define use_offset_0x18b00u 7952\n-\n-\n-  \/* Khitan Small Script *\/\n-\n-  \/* 18B00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18B90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18BF0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18C90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18CA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18CB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18CC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 18CD0 *\/     B,     B,     B,     B,     B,     B,     O,     O,\n-\n-#define use_offset_0x1bc00u 8424\n-\n-\n-  \/* Duployan *\/\n-\n-  \/* 1BC00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1BC60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,\n-  \/* 1BC70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,\n-  \/* 1BC80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,\n-  \/* 1BC90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O, CMBlw, CMBlw,     O,\n-\n-#define use_offset_0x1e100u 8584\n-\n-\n-  \/* Nyiakeng Puachue Hmong *\/\n-\n-  \/* 1E100 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E110 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E120 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,\n-  \/* 1E130 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     B,     B,     B,     B,     B,     B,     B,     O,     O,\n-  \/* 1E140 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     B,     B,\n-\n-#define use_offset_0x1e2c0u 8664\n-\n-\n-  \/* Wancho *\/\n-\n-  \/* 1E2C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E2D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E2E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMAbv, VMAbv, VMAbv,\n-  \/* 1E2F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-#define use_offset_0x1e900u 8728\n-\n-\n-  \/* Adlam *\/\n-\n-  \/* 1E900 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n-  \/* 1E940 *\/     B,     B,     B,     B, CMAbv, CMAbv, CMAbv, CMAbv, CMAbv, CMAbv, CMAbv,     B,     O,     O,     O,     O,\n-  \/* 1E950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n-\n-}; \/* Table items: 8824; occupancy: 79% *\/\n-\n-static inline uint8_t\n-hb_use_get_category (hb_codepoint_t u)\n-{\n-  switch (u >> 12)\n-  {\n-    case 0x0u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0028u, 0x003Fu)) return use_table[u - 0x0028u + use_offset_0x0028u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x00A0u, 0x00D7u)) return use_table[u - 0x00A0u + use_offset_0x00a0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0640u, 0x0647u)) return use_table[u - 0x0640u + use_offset_0x0640u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x07C8u, 0x07FFu)) return use_table[u - 0x07C8u + use_offset_0x07c8u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0840u, 0x085Fu)) return use_table[u - 0x0840u + use_offset_0x0840u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0900u, 0x0DF7u)) return use_table[u - 0x0900u + use_offset_0x0900u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x0F00u, 0x0FC7u)) return use_table[u - 0x0F00u + use_offset_0x0f00u];\n-      break;\n-\n-    case 0x1u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1000u, 0x109Fu)) return use_table[u - 0x1000u + use_offset_0x1000u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1700u, 0x18AFu)) return use_table[u - 0x1700u + use_offset_0x1700u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1900u, 0x1A9Fu)) return use_table[u - 0x1900u + use_offset_0x1900u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1B00u, 0x1C4Fu)) return use_table[u - 0x1B00u + use_offset_0x1b00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1CD0u, 0x1CFFu)) return use_table[u - 0x1CD0u + use_offset_0x1cd0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1DF8u, 0x1DFFu)) return use_table[u - 0x1DF8u + use_offset_0x1df8u];\n-      break;\n-\n-    case 0x2u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x2008u, 0x2017u)) return use_table[u - 0x2008u + use_offset_0x2008u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x2070u, 0x2087u)) return use_table[u - 0x2070u + use_offset_0x2070u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x20F0u, 0x20F7u)) return use_table[u - 0x20F0u + use_offset_0x20f0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x25C8u, 0x25CFu)) return use_table[u - 0x25C8u + use_offset_0x25c8u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x2D30u, 0x2D7Fu)) return use_table[u - 0x2D30u + use_offset_0x2d30u];\n-      break;\n-\n-    case 0xAu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0xA800u, 0xAAF7u)) return use_table[u - 0xA800u + use_offset_0xa800u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0xABC0u, 0xABFFu)) return use_table[u - 0xABC0u + use_offset_0xabc0u];\n-      break;\n-\n-    case 0x10u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10A00u, 0x10A4Fu)) return use_table[u - 0x10A00u + use_offset_0x10a00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10AC0u, 0x10AE7u)) return use_table[u - 0x10AC0u + use_offset_0x10ac0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10B80u, 0x10BAFu)) return use_table[u - 0x10B80u + use_offset_0x10b80u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10D00u, 0x10D3Fu)) return use_table[u - 0x10D00u + use_offset_0x10d00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10E80u, 0x10EB7u)) return use_table[u - 0x10E80u + use_offset_0x10e80u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10F30u, 0x10F57u)) return use_table[u - 0x10F30u + use_offset_0x10f30u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10FB0u, 0x110BFu)) return use_table[u - 0x10FB0u + use_offset_0x10fb0u];\n-      break;\n-\n-    case 0x11u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x10FB0u, 0x110BFu)) return use_table[u - 0x10FB0u + use_offset_0x10fb0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11100u, 0x1123Fu)) return use_table[u - 0x11100u + use_offset_0x11100u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11280u, 0x11377u)) return use_table[u - 0x11280u + use_offset_0x11280u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11400u, 0x114DFu)) return use_table[u - 0x11400u + use_offset_0x11400u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11580u, 0x1173Fu)) return use_table[u - 0x11580u + use_offset_0x11580u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11800u, 0x1183Fu)) return use_table[u - 0x11800u + use_offset_0x11800u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11900u, 0x1195Fu)) return use_table[u - 0x11900u + use_offset_0x11900u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x119A0u, 0x11A9Fu)) return use_table[u - 0x119A0u + use_offset_0x119a0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11C00u, 0x11CB7u)) return use_table[u - 0x11C00u + use_offset_0x11c00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11D00u, 0x11DAFu)) return use_table[u - 0x11D00u + use_offset_0x11d00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x11EE0u, 0x11EF7u)) return use_table[u - 0x11EE0u + use_offset_0x11ee0u];\n-      break;\n-\n-    case 0x13u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x13000u, 0x1343Fu)) return use_table[u - 0x13000u + use_offset_0x13000u];\n-      break;\n-\n-    case 0x16u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x16B00u, 0x16B37u)) return use_table[u - 0x16B00u + use_offset_0x16b00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x16F00u, 0x16F97u)) return use_table[u - 0x16F00u + use_offset_0x16f00u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x16FE0u, 0x16FE7u)) return use_table[u - 0x16FE0u + use_offset_0x16fe0u];\n-      break;\n-\n-    case 0x18u:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x18B00u, 0x18CD7u)) return use_table[u - 0x18B00u + use_offset_0x18b00u];\n-      break;\n-\n-    case 0x1Bu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1BC00u, 0x1BC9Fu)) return use_table[u - 0x1BC00u + use_offset_0x1bc00u];\n-      break;\n-\n-    case 0x1Eu:\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1E100u, 0x1E14Fu)) return use_table[u - 0x1E100u + use_offset_0x1e100u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1E2C0u, 0x1E2FFu)) return use_table[u - 0x1E2C0u + use_offset_0x1e2c0u];\n-      if (hb_in_range<hb_codepoint_t> (u, 0x1E900u, 0x1E95Fu)) return use_table[u - 0x1E900u + use_offset_0x1e900u];\n-      break;\n-\n-    default:\n-      break;\n-  }\n-  return USE(O);\n-}\n-\n-#undef B\n-#undef CS\n-#undef G\n-#undef GB\n-#undef H\n-#undef HN\n-#undef HVM\n-#undef J\n-#undef N\n-#undef O\n-#undef R\n-#undef S\n-#undef SB\n-#undef SE\n-#undef SUB\n-#undef Sk\n-#undef ZWNJ\n-#undef CMAbv\n-#undef CMBlw\n-#undef FAbv\n-#undef FBlw\n-#undef FPst\n-#undef FMAbv\n-#undef FMBlw\n-#undef FMPst\n-#undef MAbv\n-#undef MBlw\n-#undef MPst\n-#undef MPre\n-#undef SMAbv\n-#undef SMBlw\n-#undef VAbv\n-#undef VBlw\n-#undef VPst\n-#undef VPre\n-#undef VMAbv\n-#undef VMBlw\n-#undef VMPst\n-#undef VMPre\n-\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_USE_TABLE_HH *\/\n-\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-use-table.hh","additions":0,"deletions":1203,"binary":false,"changes":1203,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright  2018  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_VOWEL_CONSTRAINTS_HH\n-#define HB_OT_SHAPE_COMPLEX_VOWEL_CONSTRAINTS_HH\n-\n-#include \"hb.hh\"\n-\n-#include \"hb-ot-shape-complex.hh\"\n-\n-HB_INTERNAL void\n-_hb_preprocess_text_vowel_constraints (const hb_ot_shape_plan_t *plan,\n-                                       hb_buffer_t              *buffer,\n-                                       hb_font_t                *font);\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_VOWEL_CONSTRAINTS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-vowel-constraints.hh","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,391 +0,0 @@\n-\/*\n- * Copyright  2010,2011,2012  Google, Inc.\n- *\n- *  This is part of HarfBuzz, a text shaping library.\n- *\n- * Permission is hereby granted, without written agreement and without\n- * license or royalty fees, to use, copy, modify, and distribute this\n- * software and its documentation for any purpose, provided that the\n- * above copyright notice and the following two paragraphs appear in\n- * all copies of this software.\n- *\n- * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n- * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n- * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n- * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n- * DAMAGE.\n- *\n- * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n- * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n- * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n- * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n- *\n- * Google Author(s): Behdad Esfahbod\n- *\/\n-\n-#ifndef HB_OT_SHAPE_COMPLEX_HH\n-#define HB_OT_SHAPE_COMPLEX_HH\n-\n-#include \"hb.hh\"\n-\n-#include \"hb-ot-layout.hh\"\n-#include \"hb-ot-shape.hh\"\n-#include \"hb-ot-shape-normalize.hh\"\n-\n-\n-\/* buffer var allocations, used by complex shapers *\/\n-#define complex_var_u8_category()       var2.u8[2]\n-#define complex_var_u8_auxiliary()      var2.u8[3]\n-\n-\n-#define HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS 32\n-\n-enum hb_ot_shape_zero_width_marks_type_t {\n-  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n-  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,\n-  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE\n-};\n-\n-\n-\/* Master OT shaper list *\/\n-#define HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (arabic) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (default) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (dumber) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (hangul) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (hebrew) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (indic) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (khmer) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (myanmar) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (myanmar_zawgyi) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (thai) \\\n-  HB_COMPLEX_SHAPER_IMPLEMENT (use) \\\n-  \/* ^--- Add new shapers here; keep sorted. *\/\n-\n-\n-struct hb_ot_complex_shaper_t\n-{\n-  \/* collect_features()\n-   * Called during shape_plan().\n-   * Shapers should use plan->map to add their features and callbacks.\n-   * May be NULL.\n-   *\/\n-  void (*collect_features) (hb_ot_shape_planner_t *plan);\n-\n-  \/* override_features()\n-   * Called during shape_plan().\n-   * Shapers should use plan->map to override features and add callbacks after\n-   * common features are added.\n-   * May be NULL.\n-   *\/\n-  void (*override_features) (hb_ot_shape_planner_t *plan);\n-\n-\n-  \/* data_create()\n-   * Called at the end of shape_plan().\n-   * Whatever shapers return will be accessible through plan->data later.\n-   * If nullptr is returned, means a plan failure.\n-   *\/\n-  void *(*data_create) (const hb_ot_shape_plan_t *plan);\n-\n-  \/* data_destroy()\n-   * Called when the shape_plan is being destroyed.\n-   * plan->data is passed here for destruction.\n-   * If nullptr is returned, means a plan failure.\n-   * May be NULL.\n-   *\/\n-  void (*data_destroy) (void *data);\n-\n-\n-  \/* preprocess_text()\n-   * Called during shape().\n-   * Shapers can use to modify text before shaping starts.\n-   * May be NULL.\n-   *\/\n-  void (*preprocess_text) (const hb_ot_shape_plan_t *plan,\n-                           hb_buffer_t              *buffer,\n-                           hb_font_t                *font);\n-\n-  \/* postprocess_glyphs()\n-   * Called during shape().\n-   * Shapers can use to modify glyphs after shaping ends.\n-   * May be NULL.\n-   *\/\n-  void (*postprocess_glyphs) (const hb_ot_shape_plan_t *plan,\n-                              hb_buffer_t              *buffer,\n-                              hb_font_t                *font);\n-\n-\n-  hb_ot_shape_normalization_mode_t normalization_preference;\n-\n-  \/* decompose()\n-   * Called during shape()'s normalization.\n-   * May be NULL.\n-   *\/\n-  bool (*decompose) (const hb_ot_shape_normalize_context_t *c,\n-                     hb_codepoint_t  ab,\n-                     hb_codepoint_t *a,\n-                     hb_codepoint_t *b);\n-\n-  \/* compose()\n-   * Called during shape()'s normalization.\n-   * May be NULL.\n-   *\/\n-  bool (*compose) (const hb_ot_shape_normalize_context_t *c,\n-                   hb_codepoint_t  a,\n-                   hb_codepoint_t  b,\n-                   hb_codepoint_t *ab);\n-\n-  \/* setup_masks()\n-   * Called during shape().\n-   * Shapers should use map to get feature masks and set on buffer.\n-   * Shapers may NOT modify characters.\n-   * May be NULL.\n-   *\/\n-  void (*setup_masks) (const hb_ot_shape_plan_t *plan,\n-                       hb_buffer_t              *buffer,\n-                       hb_font_t                *font);\n-\n-  \/* gpos_tag()\n-   * If not HB_TAG_NONE, then must match found GPOS script tag for\n-   * GPOS to be applied.  Otherwise, fallback positioning will be used.\n-   *\/\n-  hb_tag_t gpos_tag;\n-\n-  \/* reorder_marks()\n-   * Called during shape().\n-   * Shapers can use to modify ordering of combining marks.\n-   * May be NULL.\n-   *\/\n-  void (*reorder_marks) (const hb_ot_shape_plan_t *plan,\n-                         hb_buffer_t              *buffer,\n-                         unsigned int              start,\n-                         unsigned int              end);\n-\n-  hb_ot_shape_zero_width_marks_type_t zero_width_marks;\n-\n-  bool fallback_position;\n-};\n-\n-#define HB_COMPLEX_SHAPER_IMPLEMENT(name) extern HB_INTERNAL const hb_ot_complex_shaper_t _hb_ot_complex_shaper_##name;\n-HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS\n-#undef HB_COMPLEX_SHAPER_IMPLEMENT\n-\n-\n-static inline const hb_ot_complex_shaper_t *\n-hb_ot_shape_complex_categorize (const hb_ot_shape_planner_t *planner)\n-{\n-  switch ((hb_tag_t) planner->props.script)\n-  {\n-    default:\n-      return &_hb_ot_complex_shaper_default;\n-\n-\n-    \/* Unicode-1.1 additions *\/\n-    case HB_SCRIPT_ARABIC:\n-\n-    \/* Unicode-3.0 additions *\/\n-    case HB_SCRIPT_SYRIAC:\n-\n-      \/* For Arabic script, use the Arabic shaper even if no OT script tag was found.\n-       * This is because we do fallback shaping for Arabic script (and not others).\n-       * But note that Arabic shaping is applicable only to horizontal layout; for\n-       * vertical text, just use the generic shaper instead. *\/\n-      if ((planner->map.chosen_script[0] != HB_OT_TAG_DEFAULT_SCRIPT ||\n-           planner->props.script == HB_SCRIPT_ARABIC) &&\n-          HB_DIRECTION_IS_HORIZONTAL(planner->props.direction))\n-        return &_hb_ot_complex_shaper_arabic;\n-      else\n-        return &_hb_ot_complex_shaper_default;\n-\n-\n-    \/* Unicode-1.1 additions *\/\n-    case HB_SCRIPT_THAI:\n-    case HB_SCRIPT_LAO:\n-\n-      return &_hb_ot_complex_shaper_thai;\n-\n-\n-    \/* Unicode-1.1 additions *\/\n-    case HB_SCRIPT_HANGUL:\n-\n-      return &_hb_ot_complex_shaper_hangul;\n-\n-\n-    \/* Unicode-1.1 additions *\/\n-    case HB_SCRIPT_HEBREW:\n-\n-      return &_hb_ot_complex_shaper_hebrew;\n-\n-\n-    \/* Unicode-1.1 additions *\/\n-    case HB_SCRIPT_BENGALI:\n-    case HB_SCRIPT_DEVANAGARI:\n-    case HB_SCRIPT_GUJARATI:\n-    case HB_SCRIPT_GURMUKHI:\n-    case HB_SCRIPT_KANNADA:\n-    case HB_SCRIPT_MALAYALAM:\n-    case HB_SCRIPT_ORIYA:\n-    case HB_SCRIPT_TAMIL:\n-    case HB_SCRIPT_TELUGU:\n-\n-    \/* Unicode-3.0 additions *\/\n-    case HB_SCRIPT_SINHALA:\n-\n-      \/* If the designer designed the font for the 'DFLT' script,\n-       * (or we ended up arbitrarily pick 'latn'), use the default shaper.\n-       * Otherwise, use the specific shaper.\n-       *\n-       * If it's indy3 tag, send to USE. *\/\n-      if (planner->map.chosen_script[0] == HB_TAG ('D','F','L','T') ||\n-          planner->map.chosen_script[0] == HB_TAG ('l','a','t','n'))\n-        return &_hb_ot_complex_shaper_default;\n-      else if ((planner->map.chosen_script[0] & 0x000000FF) == '3')\n-        return &_hb_ot_complex_shaper_use;\n-      else\n-        return &_hb_ot_complex_shaper_indic;\n-\n-    case HB_SCRIPT_KHMER:\n-        return &_hb_ot_complex_shaper_khmer;\n-\n-    case HB_SCRIPT_MYANMAR:\n-      \/* If the designer designed the font for the 'DFLT' script,\n-       * (or we ended up arbitrarily pick 'latn'), use the default shaper.\n-       * Otherwise, use the specific shaper.\n-       *\n-       * If designer designed for 'mymr' tag, also send to default\n-       * shaper.  That's tag used from before Myanmar shaping spec\n-       * was developed.  The shaping spec uses 'mym2' tag. *\/\n-      if (planner->map.chosen_script[0] == HB_TAG ('D','F','L','T') ||\n-          planner->map.chosen_script[0] == HB_TAG ('l','a','t','n') ||\n-          planner->map.chosen_script[0] == HB_TAG ('m','y','m','r'))\n-        return &_hb_ot_complex_shaper_default;\n-      else\n-        return &_hb_ot_complex_shaper_myanmar;\n-\n-\n-#define HB_SCRIPT_MYANMAR_ZAWGYI        ((hb_script_t) HB_TAG ('Q','a','a','g'))\n-    case HB_SCRIPT_MYANMAR_ZAWGYI:\n-    \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1162 *\/\n-\n-      return &_hb_ot_complex_shaper_myanmar_zawgyi;\n-\n-\n-    \/* Unicode-2.0 additions *\/\n-    case HB_SCRIPT_TIBETAN:\n-\n-    \/* Unicode-3.0 additions *\/\n-    case HB_SCRIPT_MONGOLIAN:\n-    \/\/case HB_SCRIPT_SINHALA:\n-\n-    \/* Unicode-3.2 additions *\/\n-    case HB_SCRIPT_BUHID:\n-    case HB_SCRIPT_HANUNOO:\n-    case HB_SCRIPT_TAGALOG:\n-    case HB_SCRIPT_TAGBANWA:\n-\n-    \/* Unicode-4.0 additions *\/\n-    case HB_SCRIPT_LIMBU:\n-    case HB_SCRIPT_TAI_LE:\n-\n-    \/* Unicode-4.1 additions *\/\n-    case HB_SCRIPT_BUGINESE:\n-    case HB_SCRIPT_KHAROSHTHI:\n-    case HB_SCRIPT_SYLOTI_NAGRI:\n-    case HB_SCRIPT_TIFINAGH:\n-\n-    \/* Unicode-5.0 additions *\/\n-    case HB_SCRIPT_BALINESE:\n-    case HB_SCRIPT_NKO:\n-    case HB_SCRIPT_PHAGS_PA:\n-\n-    \/* Unicode-5.1 additions *\/\n-    case HB_SCRIPT_CHAM:\n-    case HB_SCRIPT_KAYAH_LI:\n-    case HB_SCRIPT_LEPCHA:\n-    case HB_SCRIPT_REJANG:\n-    case HB_SCRIPT_SAURASHTRA:\n-    case HB_SCRIPT_SUNDANESE:\n-\n-    \/* Unicode-5.2 additions *\/\n-    case HB_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n-    case HB_SCRIPT_JAVANESE:\n-    case HB_SCRIPT_KAITHI:\n-    case HB_SCRIPT_MEETEI_MAYEK:\n-    case HB_SCRIPT_TAI_THAM:\n-    case HB_SCRIPT_TAI_VIET:\n-\n-    \/* Unicode-6.0 additions *\/\n-    case HB_SCRIPT_BATAK:\n-    case HB_SCRIPT_BRAHMI:\n-    case HB_SCRIPT_MANDAIC:\n-\n-    \/* Unicode-6.1 additions *\/\n-    case HB_SCRIPT_CHAKMA:\n-    case HB_SCRIPT_MIAO:\n-    case HB_SCRIPT_SHARADA:\n-    case HB_SCRIPT_TAKRI:\n-\n-    \/* Unicode-7.0 additions *\/\n-    case HB_SCRIPT_DUPLOYAN:\n-    case HB_SCRIPT_GRANTHA:\n-    case HB_SCRIPT_KHOJKI:\n-    case HB_SCRIPT_KHUDAWADI:\n-    case HB_SCRIPT_MAHAJANI:\n-    case HB_SCRIPT_MANICHAEAN:\n-    case HB_SCRIPT_MODI:\n-    case HB_SCRIPT_PAHAWH_HMONG:\n-    case HB_SCRIPT_PSALTER_PAHLAVI:\n-    case HB_SCRIPT_SIDDHAM:\n-    case HB_SCRIPT_TIRHUTA:\n-\n-    \/* Unicode-8.0 additions *\/\n-    case HB_SCRIPT_AHOM:\n-    case HB_SCRIPT_MULTANI:\n-\n-    \/* Unicode-9.0 additions *\/\n-    case HB_SCRIPT_ADLAM:\n-    case HB_SCRIPT_BHAIKSUKI:\n-    case HB_SCRIPT_MARCHEN:\n-    case HB_SCRIPT_NEWA:\n-\n-    \/* Unicode-10.0 additions *\/\n-    case HB_SCRIPT_MASARAM_GONDI:\n-    case HB_SCRIPT_SOYOMBO:\n-    case HB_SCRIPT_ZANABAZAR_SQUARE:\n-\n-    \/* Unicode-11.0 additions *\/\n-    case HB_SCRIPT_DOGRA:\n-    case HB_SCRIPT_GUNJALA_GONDI:\n-    case HB_SCRIPT_HANIFI_ROHINGYA:\n-    case HB_SCRIPT_MAKASAR:\n-    case HB_SCRIPT_MEDEFAIDRIN:\n-    case HB_SCRIPT_OLD_SOGDIAN:\n-    case HB_SCRIPT_SOGDIAN:\n-\n-    \/* Unicode-12.0 additions *\/\n-    case HB_SCRIPT_ELYMAIC:\n-    case HB_SCRIPT_NANDINAGARI:\n-    case HB_SCRIPT_NYIAKENG_PUACHUE_HMONG:\n-    case HB_SCRIPT_WANCHO:\n-\n-    \/* Unicode-13.0 additions *\/\n-    case HB_SCRIPT_CHORASMIAN:\n-    case HB_SCRIPT_DIVES_AKURU:\n-\n-      \/* If the designer designed the font for the 'DFLT' script,\n-       * (or we ended up arbitrarily pick 'latn'), use the default shaper.\n-       * Otherwise, use the specific shaper.\n-       * Note that for some simple scripts, there may not be *any*\n-       * GSUB\/GPOS needed, so there may be no scripts found! *\/\n-      if (planner->map.chosen_script[0] == HB_TAG ('D','F','L','T') ||\n-          planner->map.chosen_script[0] == HB_TAG ('l','a','t','n'))\n-        return &_hb_ot_complex_shaper_default;\n-      else\n-        return &_hb_ot_complex_shaper_use;\n-  }\n-}\n-\n-\n-#endif \/* HB_OT_SHAPE_COMPLEX_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex.hh","additions":0,"deletions":391,"binary":false,"changes":391,"status":"deleted"},{"patch":"@@ -95,1 +95,1 @@\n-    case HB_MODIFIED_COMBINING_CLASS_CCC18: \/* qamats *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC18: \/* qamats & qamats qatan *\/\n@@ -107,1 +107,1 @@\n-    case HB_MODIFIED_COMBINING_CLASS_CCC19: \/* holam *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC19: \/* holam & holam haser for vav *\/\n@@ -449,0 +449,3 @@\n+  if (!buffer->message (font, \"start fallback mark\"))\n+    return;\n+\n@@ -460,0 +463,2 @@\n+\n+  (void) buffer->message (font, \"end fallback mark\");\n@@ -500,0 +505,3 @@\n+  if (!buffer->message (font, \"start fallback kern\"))\n+    return;\n+\n@@ -511,0 +519,2 @@\n+\n+  (void) buffer->message (font, \"end fallback kern\");\n@@ -528,0 +538,9 @@\n+      \/* If font had no ASCII space and we used the invisible glyph, give it a 1\/4 EM default advance. *\/\n+      if (buffer->invisible && info[i].codepoint == buffer->invisible)\n+      {\n+        if (horizontal)\n+          pos[i].x_advance = +font->x_scale \/ 4;\n+        else\n+          pos[i].y_advance = -font->y_scale \/ 4;\n+      }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-fallback.cc","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"hb-ot-shape-complex.hh\"\n+#include \"hb-ot-shaper.hh\"\n@@ -72,1 +72,1 @@\n- *   - The complex shapers can customize the compose and decompose functions to\n+ *   - The shapers can customize the compose and decompose functions to\n@@ -146,2 +146,1 @@\n-  unsigned int ret;\n-  if ((ret = decompose (c, shortest, a))) {\n+  if (unsigned ret = decompose (c, shortest, a)) {\n@@ -174,1 +173,1 @@\n-  if (shortest && c->font->get_nominal_glyph (u, &glyph))\n+  if (shortest && c->font->get_nominal_glyph (u, &glyph, c->not_found))\n@@ -186,1 +185,1 @@\n-  if (!shortest && c->font->get_nominal_glyph (u, &glyph))\n+  if (!shortest && c->font->get_nominal_glyph (u, &glyph, c->not_found))\n@@ -196,1 +195,2 @@\n-    if (space_type != hb_unicode_funcs_t::NOT_SPACE && c->font->get_nominal_glyph (0x0020u, &space_glyph))\n+    if (space_type != hb_unicode_funcs_t::NOT_SPACE &&\n+        (c->font->get_nominal_glyph (0x0020, &space_glyph) || (space_glyph = buffer->invisible)))\n@@ -225,1 +225,1 @@\n-  \/* TODO Currently if there's a variation-selector we give-up, it's just too hard. *\/\n+  \/* Currently if there's a variation-selector we give-up on normalization, it's just too hard. *\/\n@@ -315,0 +315,1 @@\n+    buffer->not_found,\n@@ -376,1 +377,1 @@\n-    buffer->swap_buffers ();\n+    buffer->sync ();\n@@ -396,1 +397,1 @@\n-      if (end - i > HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS) {\n+      if (end - i > HB_OT_SHAPE_MAX_COMBINING_MARKS) {\n@@ -479,1 +480,1 @@\n-    buffer->swap_buffers ();\n+    buffer->sync ();\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-normalize.cc","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  const hb_codepoint_t not_found;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-normalize.hh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"hb-ot-shape-complex.hh\"\n+#include \"hb-ot-shaper.hh\"\n@@ -50,0 +50,3 @@\n+static inline bool\n+_hb_codepoint_is_regional_indicator (hb_codepoint_t u)\n+{ return hb_in_range<hb_codepoint_t> (u, 0x1F1E6u, 0x1F1FFu); }\n@@ -86,1 +89,1 @@\n-  shaper = hb_ot_shape_complex_categorize (this);\n+  shaper = hb_ot_shaper_categorize (this);\n@@ -92,2 +95,2 @@\n-  if (apply_morx && shaper != &_hb_ot_complex_shaper_default)\n-    shaper = &_hb_ot_complex_shaper_dumber;\n+  if (apply_morx && shaper != &_hb_ot_shaper_default)\n+    shaper = &_hb_ot_shaper_dumber;\n@@ -152,1 +155,6 @@\n-  if (0)\n+#ifndef HB_NO_AAT_SHAPE\n+  bool has_kerx = hb_aat_layout_has_positioning (face);\n+  bool has_gsub = !apply_morx && hb_ot_layout_has_substitution (face);\n+#endif\n+  bool has_gpos = !disable_gpos && hb_ot_layout_has_positioning (face);\n+  if (false)\n@@ -155,1 +163,3 @@\n-  else if (hb_aat_layout_has_positioning (face))\n+  \/* Prefer GPOS over kerx if GSUB is present;\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3008 *\/\n+  else if (has_kerx && !(has_gsub && has_gpos))\n@@ -158,1 +168,1 @@\n-  else if (!apply_morx && !disable_gpos && hb_ot_layout_has_positioning (face))\n+  else if (has_gpos)\n@@ -163,1 +173,0 @@\n-    \/* Apparently Apple applies kerx if GPOS kern was not applied. *\/\n@@ -165,1 +174,1 @@\n-    if (hb_aat_layout_has_positioning (face))\n+    if (has_kerx)\n@@ -175,0 +184,2 @@\n+  plan.apply_fallback_kern = !(plan.apply_gpos || plan.apply_kerx || plan.apply_kern);\n+\n@@ -196,0 +207,6 @@\n+  \/* If we're using morx shaping, we cancel mark position adjustment because\n+     Apple Color Emoji assumes this will NOT be done when forming emoji sequences;\n+     https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2967. *\/\n+  if (plan.apply_morx)\n+    plan.adjust_mark_positioning_when_zeroing = false;\n+\n@@ -269,0 +286,1 @@\n+\n@@ -270,1 +288,1 @@\n-  else if (this->apply_kern)\n+  if (this->apply_kern)\n@@ -273,1 +291,1 @@\n-  else\n+  else if (this->apply_fallback_kern)\n@@ -309,3 +327,3 @@\n-hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,\n-                              const hb_feature_t             *user_features,\n-                              unsigned int                    num_user_features)\n+hb_ot_shape_collect_features (hb_ot_shape_planner_t *planner,\n+                              const hb_feature_t    *user_features,\n+                              unsigned int           num_user_features)\n@@ -318,1 +336,2 @@\n-  switch (planner->props.direction) {\n+  switch (planner->props.direction)\n+  {\n@@ -351,1 +370,2 @@\n-  map->enable_feature (HB_TAG ('H','A','R','F'));\n+  map->enable_feature (HB_TAG ('H','a','r','f')); \/* Considered required. *\/\n+  map->enable_feature (HB_TAG ('H','A','R','F')); \/* Considered discretionary. *\/\n@@ -356,1 +376,2 @@\n-  map->enable_feature (HB_TAG ('B','U','Z','Z'));\n+  map->enable_feature (HB_TAG ('B','u','z','z')); \/* Considered required. *\/\n+  map->enable_feature (HB_TAG ('B','U','Z','Z')); \/* Considered discretionary. *\/\n@@ -366,0 +387,4 @@\n+    \/* We only apply `vert` feature. See:\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/commit\/d71c0df2d17f4590d5611239577a6cb532c26528\n+     * https:\/\/lists.freedesktop.org\/archives\/harfbuzz\/2013-August\/003490.html *\/\n+\n@@ -481,0 +506,8 @@\n+      _hb_glyph_info_set_continuation (&info[i]);\n+    }\n+    \/* Regional_Indicators are hairy as hell...\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2265 *\/\n+    else if (unlikely (i && _hb_codepoint_is_regional_indicator (info[i].codepoint)))\n+    {\n+      if (_hb_codepoint_is_regional_indicator (info[i - 1].codepoint) &&\n+          !_hb_glyph_info_is_continuation (&info[i - 1]))\n@@ -538,1 +571,2 @@\n-  buffer->swap_buffers ();\n+\n+  buffer->sync ();\n@@ -561,0 +595,39 @@\n+  \/* Numeric runs in natively-RTL scripts are actually native-LTR, so we reset\n+   * the horiz_dir if the run contains at least one decimal-number char, and no\n+   * letter chars (ideally we should be checking for chars with strong\n+   * directionality but hb-unicode currently lacks bidi categories).\n+   *\n+   * This allows digit sequences in Arabic etc to be shaped in \"native\"\n+   * direction, so that features like ligatures will work as intended.\n+   *\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/501\n+   *\n+   * Similar thing about Regional_Indicators; They are bidi=L, but Script=Common.\n+   * If they are present in a run of natively-RTL text, they get assigned a script\n+   * with natively RTL direction, which would result in wrong shaping if we\n+   * assign such native RTL direction to them then. Detect that as well.\n+   *\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3314\n+   *\/\n+  if (unlikely (horiz_dir == HB_DIRECTION_RTL && direction == HB_DIRECTION_LTR))\n+  {\n+    bool found_number = false, found_letter = false, found_ri = false;\n+    const auto* info = buffer->info;\n+    const auto count = buffer->len;\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      auto gc = _hb_glyph_info_get_general_category (&info[i]);\n+      if (gc == HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER)\n+        found_number = true;\n+      else if (HB_UNICODE_GENERAL_CATEGORY_IS_LETTER (gc))\n+      {\n+        found_letter = true;\n+        break;\n+      }\n+      else if (_hb_codepoint_is_regional_indicator (info[i].codepoint))\n+        found_ri = true;\n+    }\n+    if ((found_number || found_ri) && !found_letter)\n+      horiz_dir = HB_DIRECTION_LTR;\n+  }\n+\n@@ -570,14 +643,1 @@\n-\n-    if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)\n-      foreach_grapheme (buffer, start, end)\n-      {\n-        buffer->merge_clusters (start, end);\n-        buffer->reverse_range (start, end);\n-      }\n-    else\n-      foreach_grapheme (buffer, start, end)\n-        \/* form_clusters() merged clusters already, we don't merge. *\/\n-        buffer->reverse_range (start, end);\n-\n-    buffer->reverse ();\n-\n+    _hb_ot_layout_reverse_graphemes (buffer);\n@@ -593,0 +653,1 @@\n+#ifndef HB_NO_VERTICAL\n@@ -643,0 +704,1 @@\n+#endif\n@@ -665,0 +727,1 @@\n+#ifndef HB_NO_VERTICAL\n@@ -673,0 +736,1 @@\n+#endif\n@@ -866,1 +930,1 @@\n-hb_ot_substitute_complex (const hb_ot_shape_context_t *c)\n+hb_ot_substitute_plan (const hb_ot_shape_context_t *c)\n@@ -885,1 +949,6 @@\n-  hb_ot_substitute_complex (c);\n+  hb_ot_substitute_plan (c);\n+\n+#ifndef HB_NO_AAT_SHAPE\n+  if (c->plan->apply_morx && c->plan->apply_gpos)\n+    hb_aat_layout_remove_deleted_glyphs (c->buffer);\n+#endif\n@@ -891,1 +960,0 @@\n-  hb_ot_hide_default_ignorables (c->buffer, c->font);\n@@ -893,1 +961,1 @@\n-  if (c->plan->apply_morx)\n+  if (c->plan->apply_morx && !c->plan->apply_gpos)\n@@ -897,0 +965,2 @@\n+  hb_ot_hide_default_ignorables (c->buffer, c->font);\n+\n@@ -972,1 +1042,1 @@\n-hb_ot_position_complex (const hb_ot_shape_context_t *c)\n+hb_ot_position_plan (const hb_ot_shape_context_t *c)\n@@ -985,1 +1055,1 @@\n-   * this as it will be overriden.\n+   * this as it will be overridden.\n@@ -1057,1 +1127,1 @@\n-  hb_ot_position_complex (c);\n+  hb_ot_position_plan (c);\n@@ -1071,1 +1141,1 @@\n-  if (!(buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK))\n+  if (!(buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_GLYPH_FLAGS))\n@@ -1080,5 +1150,1 @@\n-      if (info[i].mask & HB_GLYPH_FLAG_UNSAFE_TO_BREAK)\n-      {\n-         mask = HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n-         break;\n-      }\n+      mask |= info[i].mask & HB_GLYPH_FLAG_DEFINED;\n@@ -1096,13 +1162,0 @@\n-  c->buffer->deallocate_var_all ();\n-  c->buffer->scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;\n-  if (likely (!hb_unsigned_mul_overflows (c->buffer->len, HB_BUFFER_MAX_LEN_FACTOR)))\n-  {\n-    c->buffer->max_len = hb_max (c->buffer->len * HB_BUFFER_MAX_LEN_FACTOR,\n-                                 (unsigned) HB_BUFFER_MAX_LEN_MIN);\n-  }\n-  if (likely (!hb_unsigned_mul_overflows (c->buffer->len, HB_BUFFER_MAX_OPS_FACTOR)))\n-  {\n-    c->buffer->max_ops = hb_max (c->buffer->len * HB_BUFFER_MAX_OPS_FACTOR,\n-                                 (unsigned) HB_BUFFER_MAX_OPS_MIN);\n-  }\n-\n@@ -1114,2 +1167,0 @@\n-  c->buffer->clear_output ();\n-\n@@ -1125,1 +1176,2 @@\n-    c->buffer->message(c->font, \"start preprocess-text\")) {\n+      c->buffer->message(c->font, \"start preprocess-text\"))\n+  {\n@@ -1140,3 +1192,1 @@\n-  c->buffer->max_len = HB_BUFFER_MAX_LEN_DEFAULT;\n-  c->buffer->max_ops = HB_BUFFER_MAX_OPS_DEFAULT;\n-  c->buffer->deallocate_var_all ();\n+  c->buffer->leave ();\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape.cc","additions":114,"deletions":64,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  const struct hb_ot_complex_shaper_t *shaper;\n+  const struct hb_ot_shaper_t *shaper;\n@@ -115,0 +115,1 @@\n+  bool apply_fallback_kern : 1;\n@@ -160,1 +161,1 @@\n-  const struct hb_ot_complex_shaper_t *shaper;\n+  const struct hb_ot_shaper_t *shaper;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape.hh","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright  2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_ARABIC_FALLBACK_HH\n+#define HB_OT_SHAPER_ARABIC_FALLBACK_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shape.hh\"\n+#include \"hb-ot-layout-gsub-table.hh\"\n+\n+\n+\/* Features ordered the same as the entries in shaping_table rows,\n+ * followed by rlig.  Don't change.\n+ *\n+ * We currently support one subtable per lookup, and one lookup\n+ * per feature.  But we allow duplicate features, so we use that!\n+ *\/\n+static const hb_tag_t arabic_fallback_features[] =\n+{\n+  HB_TAG('i','n','i','t'),\n+  HB_TAG('m','e','d','i'),\n+  HB_TAG('f','i','n','a'),\n+  HB_TAG('i','s','o','l'),\n+  HB_TAG('r','l','i','g'),\n+  HB_TAG('r','l','i','g'),\n+  HB_TAG('r','l','i','g'),\n+};\n+\n+static OT::SubstLookup *\n+arabic_fallback_synthesize_lookup_single (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                                          hb_font_t *font,\n+                                          unsigned int feature_index)\n+{\n+  OT::HBGlyphID16 glyphs[SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1];\n+  OT::HBGlyphID16 substitutes[SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1];\n+  unsigned int num_glyphs = 0;\n+\n+  \/* Populate arrays *\/\n+  for (hb_codepoint_t u = SHAPING_TABLE_FIRST; u < SHAPING_TABLE_LAST + 1; u++)\n+  {\n+    hb_codepoint_t s = shaping_table[u - SHAPING_TABLE_FIRST][feature_index];\n+    hb_codepoint_t u_glyph, s_glyph;\n+\n+    if (!s ||\n+        !hb_font_get_glyph (font, u, 0, &u_glyph) ||\n+        !hb_font_get_glyph (font, s, 0, &s_glyph) ||\n+        u_glyph == s_glyph ||\n+        u_glyph > 0xFFFFu || s_glyph > 0xFFFFu)\n+      continue;\n+\n+    glyphs[num_glyphs] = u_glyph;\n+    substitutes[num_glyphs] = s_glyph;\n+\n+    num_glyphs++;\n+  }\n+\n+  if (!num_glyphs)\n+    return nullptr;\n+\n+  \/* Bubble-sort or something equally good!\n+   * May not be good-enough for presidential candidate interviews, but good-enough for us... *\/\n+  hb_stable_sort (&glyphs[0], num_glyphs,\n+                  (int(*)(const OT::HBUINT16*, const OT::HBUINT16 *)) OT::HBGlyphID16::cmp,\n+                  &substitutes[0]);\n+\n+\n+  \/* Each glyph takes four bytes max, and there's some overhead. *\/\n+  char buf[(SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1) * 4 + 128];\n+  hb_serialize_context_t c (buf, sizeof (buf));\n+  OT::SubstLookup *lookup = c.start_serialize<OT::SubstLookup> ();\n+  bool ret = lookup->serialize_single (&c,\n+                                       OT::LookupFlag::IgnoreMarks,\n+                                       hb_sorted_array (glyphs, num_glyphs),\n+                                       hb_array (substitutes, num_glyphs));\n+  c.end_serialize ();\n+\n+  return ret && !c.in_error () ? c.copy<OT::SubstLookup> () : nullptr;\n+}\n+\n+template <typename T>\n+static OT::SubstLookup *\n+arabic_fallback_synthesize_lookup_ligature (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                                            hb_font_t *font,\n+                                            const T &ligature_table,\n+                                            unsigned lookup_flags)\n+{\n+  OT::HBGlyphID16 first_glyphs[ARRAY_LENGTH_CONST (ligature_table)];\n+  unsigned int first_glyphs_indirection[ARRAY_LENGTH_CONST (ligature_table)];\n+  unsigned int ligature_per_first_glyph_count_list[ARRAY_LENGTH_CONST (first_glyphs)];\n+  unsigned int num_first_glyphs = 0;\n+\n+  \/* We know that all our ligatures have the same number of components. *\/\n+  OT::HBGlyphID16 ligature_list[ARRAY_LENGTH_CONST (first_glyphs) * ARRAY_LENGTH_CONST(ligature_table[0].ligatures)];\n+  unsigned int component_count_list[ARRAY_LENGTH_CONST (ligature_list)];\n+  OT::HBGlyphID16 component_list[ARRAY_LENGTH_CONST (ligature_list) *\n+                                 ARRAY_LENGTH_CONST (ligature_table[0].ligatures[0].components)];\n+  unsigned int num_ligatures = 0;\n+  unsigned int num_components = 0;\n+\n+  \/* Populate arrays *\/\n+\n+  \/* Sort out the first-glyphs *\/\n+  for (unsigned int first_glyph_idx = 0; first_glyph_idx < ARRAY_LENGTH (first_glyphs); first_glyph_idx++)\n+  {\n+    hb_codepoint_t first_u = ligature_table[first_glyph_idx].first;\n+    hb_codepoint_t first_glyph;\n+    if (!hb_font_get_glyph (font, first_u, 0, &first_glyph))\n+      continue;\n+    first_glyphs[num_first_glyphs] = first_glyph;\n+    ligature_per_first_glyph_count_list[num_first_glyphs] = 0;\n+    first_glyphs_indirection[num_first_glyphs] = first_glyph_idx;\n+    num_first_glyphs++;\n+  }\n+  hb_stable_sort (&first_glyphs[0], num_first_glyphs,\n+                  (int(*)(const OT::HBUINT16*, const OT::HBUINT16 *)) OT::HBGlyphID16::cmp,\n+                  &first_glyphs_indirection[0]);\n+\n+  \/* Now that the first-glyphs are sorted, walk again, populate ligatures. *\/\n+  for (unsigned int i = 0; i < num_first_glyphs; i++)\n+  {\n+    unsigned int first_glyph_idx = first_glyphs_indirection[i];\n+\n+    for (unsigned int ligature_idx = 0; ligature_idx < ARRAY_LENGTH (ligature_table[0].ligatures); ligature_idx++)\n+    {\n+      hb_codepoint_t ligature_u = ligature_table[first_glyph_idx].ligatures[ligature_idx].ligature;\n+      hb_codepoint_t ligature_glyph;\n+      if (!hb_font_get_glyph (font, ligature_u, 0, &ligature_glyph))\n+        continue;\n+\n+      const auto &components = ligature_table[first_glyph_idx].ligatures[ligature_idx].components;\n+      unsigned component_count = ARRAY_LENGTH_CONST (components);\n+\n+      for (unsigned i = 0; i < component_count; i++)\n+      {\n+        hb_codepoint_t component_u   = ligature_table[first_glyph_idx].ligatures[ligature_idx].components[i];\n+        hb_codepoint_t component_glyph;\n+        if (!component_u ||\n+            !hb_font_get_glyph (font, component_u,   0, &component_glyph))\n+          continue;\n+\n+        component_list[num_components++] = component_glyph;\n+      }\n+\n+      component_count_list[num_ligatures] = 1 + component_count;\n+      ligature_list[num_ligatures] = ligature_glyph;\n+\n+      ligature_per_first_glyph_count_list[i]++;\n+\n+      num_ligatures++;\n+    }\n+  }\n+\n+  if (!num_ligatures)\n+    return nullptr;\n+\n+\n+  \/* 16 bytes per ligature ought to be enough... *\/\n+  char buf[ARRAY_LENGTH_CONST (ligature_list) * 16 + 128];\n+  hb_serialize_context_t c (buf, sizeof (buf));\n+  OT::SubstLookup *lookup = c.start_serialize<OT::SubstLookup> ();\n+  bool ret = lookup->serialize_ligature (&c,\n+                                         lookup_flags,\n+                                         hb_sorted_array (first_glyphs, num_first_glyphs),\n+                                         hb_array (ligature_per_first_glyph_count_list, num_first_glyphs),\n+                                         hb_array (ligature_list, num_ligatures),\n+                                         hb_array (component_count_list, num_ligatures),\n+                                         hb_array (component_list, num_components));\n+  c.end_serialize ();\n+\n+  return ret && !c.in_error () ? c.copy<OT::SubstLookup> () : nullptr;\n+}\n+\n+static OT::SubstLookup *\n+arabic_fallback_synthesize_lookup (const hb_ot_shape_plan_t *plan,\n+                                   hb_font_t *font,\n+                                   unsigned int feature_index)\n+{\n+  if (feature_index < 4)\n+    return arabic_fallback_synthesize_lookup_single (plan, font, feature_index);\n+  else\n+  {\n+    switch (feature_index) {\n+      case 4: return arabic_fallback_synthesize_lookup_ligature (plan, font, ligature_3_table, OT::LookupFlag::IgnoreMarks);\n+      case 5: return arabic_fallback_synthesize_lookup_ligature (plan, font, ligature_table, OT::LookupFlag::IgnoreMarks);\n+      case 6: return arabic_fallback_synthesize_lookup_ligature (plan, font, ligature_mark_table, 0);\n+    }\n+  }\n+  assert (false);\n+  return nullptr;\n+}\n+\n+#define ARABIC_FALLBACK_MAX_LOOKUPS ARRAY_LENGTH_CONST (arabic_fallback_features)\n+\n+struct arabic_fallback_plan_t\n+{\n+  unsigned int num_lookups;\n+  bool free_lookups;\n+\n+  hb_mask_t mask_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n+  OT::SubstLookup *lookup_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n+  OT::hb_ot_layout_lookup_accelerator_t accel_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n+};\n+\n+#if defined(_WIN32) && !defined(HB_NO_WIN1256)\n+#define HB_WITH_WIN1256\n+#endif\n+\n+#ifdef HB_WITH_WIN1256\n+#include \"hb-ot-shaper-arabic-win1256.hh\"\n+#endif\n+\n+struct ManifestLookup\n+{\n+  public:\n+  OT::Tag tag;\n+  OT::Offset16To<OT::SubstLookup> lookupOffset;\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+typedef OT::Array16Of<ManifestLookup> Manifest;\n+\n+static bool\n+arabic_fallback_plan_init_win1256 (arabic_fallback_plan_t *fallback_plan HB_UNUSED,\n+                                   const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                                   hb_font_t *font HB_UNUSED)\n+{\n+#ifdef HB_WITH_WIN1256\n+  \/* Does this font look like it's Windows-1256-encoded? *\/\n+  hb_codepoint_t g;\n+  if (!(hb_font_get_glyph (font, 0x0627u, 0, &g) && g == 199 \/* ALEF *\/ &&\n+        hb_font_get_glyph (font, 0x0644u, 0, &g) && g == 225 \/* LAM *\/ &&\n+        hb_font_get_glyph (font, 0x0649u, 0, &g) && g == 236 \/* ALEF MAKSURA *\/ &&\n+        hb_font_get_glyph (font, 0x064Au, 0, &g) && g == 237 \/* YEH *\/ &&\n+        hb_font_get_glyph (font, 0x0652u, 0, &g) && g == 250 \/* SUKUN *\/))\n+    return false;\n+\n+  const Manifest &manifest = reinterpret_cast<const Manifest&> (arabic_win1256_gsub_lookups.manifest);\n+  static_assert (sizeof (arabic_win1256_gsub_lookups.manifestData) <=\n+                 ARABIC_FALLBACK_MAX_LOOKUPS * sizeof (ManifestLookup), \"\");\n+\n+  unsigned j = 0;\n+  unsigned int count = manifest.len;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    fallback_plan->mask_array[j] = plan->map.get_1_mask (manifest[i].tag);\n+    if (fallback_plan->mask_array[j])\n+    {\n+      fallback_plan->lookup_array[j] = const_cast<OT::SubstLookup*> (&(&manifest+manifest[i].lookupOffset));\n+      if (fallback_plan->lookup_array[j])\n+      {\n+        fallback_plan->accel_array[j].init (*fallback_plan->lookup_array[j]);\n+        j++;\n+      }\n+    }\n+  }\n+\n+  fallback_plan->num_lookups = j;\n+  fallback_plan->free_lookups = false;\n+\n+  return j > 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n+static bool\n+arabic_fallback_plan_init_unicode (arabic_fallback_plan_t *fallback_plan,\n+                                   const hb_ot_shape_plan_t *plan,\n+                                   hb_font_t *font)\n+{\n+  static_assert ((ARRAY_LENGTH_CONST (arabic_fallback_features) <= ARABIC_FALLBACK_MAX_LOOKUPS), \"\");\n+  unsigned int j = 0;\n+  for (unsigned int i = 0; i < ARRAY_LENGTH(arabic_fallback_features) ; i++)\n+  {\n+    fallback_plan->mask_array[j] = plan->map.get_1_mask (arabic_fallback_features[i]);\n+    if (fallback_plan->mask_array[j])\n+    {\n+      fallback_plan->lookup_array[j] = arabic_fallback_synthesize_lookup (plan, font, i);\n+      if (fallback_plan->lookup_array[j])\n+      {\n+        fallback_plan->accel_array[j].init (*fallback_plan->lookup_array[j]);\n+        j++;\n+      }\n+    }\n+  }\n+\n+  fallback_plan->num_lookups = j;\n+  fallback_plan->free_lookups = true;\n+\n+  return j > 0;\n+}\n+\n+static arabic_fallback_plan_t *\n+arabic_fallback_plan_create (const hb_ot_shape_plan_t *plan,\n+                             hb_font_t *font)\n+{\n+  arabic_fallback_plan_t *fallback_plan = (arabic_fallback_plan_t *) hb_calloc (1, sizeof (arabic_fallback_plan_t));\n+  if (unlikely (!fallback_plan))\n+    return const_cast<arabic_fallback_plan_t *> (&Null (arabic_fallback_plan_t));\n+\n+  fallback_plan->num_lookups = 0;\n+  fallback_plan->free_lookups = false;\n+\n+  \/* Try synthesizing GSUB table using Unicode Arabic Presentation Forms,\n+   * in case the font has cmap entries for the presentation-forms characters. *\/\n+  if (arabic_fallback_plan_init_unicode (fallback_plan, plan, font))\n+    return fallback_plan;\n+\n+  \/* See if this looks like a Windows-1256-encoded font.  If it does, use a\n+   * hand-coded GSUB table. *\/\n+  if (arabic_fallback_plan_init_win1256 (fallback_plan, plan, font))\n+    return fallback_plan;\n+\n+  assert (fallback_plan->num_lookups == 0);\n+  hb_free (fallback_plan);\n+  return const_cast<arabic_fallback_plan_t *> (&Null (arabic_fallback_plan_t));\n+}\n+\n+static void\n+arabic_fallback_plan_destroy (arabic_fallback_plan_t *fallback_plan)\n+{\n+  if (!fallback_plan || fallback_plan->num_lookups == 0)\n+    return;\n+\n+  for (unsigned int i = 0; i < fallback_plan->num_lookups; i++)\n+    if (fallback_plan->lookup_array[i])\n+    {\n+      fallback_plan->accel_array[i].fini ();\n+      if (fallback_plan->free_lookups)\n+        hb_free (fallback_plan->lookup_array[i]);\n+    }\n+\n+  hb_free (fallback_plan);\n+}\n+\n+static void\n+arabic_fallback_plan_shape (arabic_fallback_plan_t *fallback_plan,\n+                            hb_font_t *font,\n+                            hb_buffer_t *buffer)\n+{\n+  OT::hb_ot_apply_context_t c (0, font, buffer);\n+  for (unsigned int i = 0; i < fallback_plan->num_lookups; i++)\n+    if (fallback_plan->lookup_array[i]) {\n+      c.set_lookup_mask (fallback_plan->mask_array[i]);\n+      hb_ot_layout_substitute_lookup (&c,\n+                                      *fallback_plan->lookup_array[i],\n+                                      fallback_plan->accel_array[i]);\n+    }\n+}\n+\n+\n+#endif \/* HB_OT_SHAPER_ARABIC_FALLBACK_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic-fallback.hh","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/* == Start of generated function == *\/\n+\/*\n+ * The following function is generated by running:\n+ *\n+ *   .\/gen-arabic-joining-list.py ArabicShaping.txt Scripts.txt\n+ *\n+ * on files with these headers:\n+ *\n+ * # ArabicShaping-14.0.0.txt\n+ * # Date: 2021-05-21, 01:54:00 GMT [KW, RP]\n+ * # Scripts-14.0.0.txt\n+ * # Date: 2021-07-10, 00:35:31 GMT\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_ARABIC_JOINING_LIST_HH\n+#define HB_OT_SHAPER_ARABIC_JOINING_LIST_HH\n+\n+static bool\n+has_arabic_joining (hb_script_t script)\n+{\n+  \/* List of scripts that have data in arabic-table. *\/\n+  switch ((int) script)\n+  {\n+    case HB_SCRIPT_ADLAM:\n+    case HB_SCRIPT_ARABIC:\n+    case HB_SCRIPT_CHORASMIAN:\n+    case HB_SCRIPT_HANIFI_ROHINGYA:\n+    case HB_SCRIPT_MANDAIC:\n+    case HB_SCRIPT_MANICHAEAN:\n+    case HB_SCRIPT_MONGOLIAN:\n+    case HB_SCRIPT_NKO:\n+    case HB_SCRIPT_OLD_UYGHUR:\n+    case HB_SCRIPT_PHAGS_PA:\n+    case HB_SCRIPT_PSALTER_PAHLAVI:\n+    case HB_SCRIPT_SOGDIAN:\n+    case HB_SCRIPT_SYRIAC:\n+      return true;\n+\n+    default:\n+      return false;\n+  }\n+}\n+\n+\n+#endif \/* HB_OT_SHAPER_ARABIC_JOINING_LIST_HH *\/\n+\n+\/* == End of generated function == *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic-joining-list.hh","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/* == Start of generated table == *\/\n+\/*\n+ * The following table is generated by running:\n+ *\n+ *   .\/gen-arabic-pua.py\n+ *\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_ARABIC_PUA_HH\n+#define HB_OT_SHAPER_ARABIC_PUA_HH\n+\n+static const uint8_t\n+_hb_arabic_u8[464] =\n+{\n+   84, 86, 85, 85, 85, 85, 85,213, 16, 34, 34, 34, 34, 34, 35, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 36, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 82, 16,  0,  0,  0,  0,  1,  2,  3,  4,\n+    0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,  0,  7,\n+    0,  0,  8,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0, 11, 12, 13, 14, 15,\n+   16, 17, 18, 19, 20, 21,  0,  0,  0, 22,  0, 23,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0, 24, 25, 26, 27, 28, 29, 30, 31,\n+   32, 33, 34, 35, 36, 37, 38, 39, 16, 34, 34, 34, 35, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 66, 16, 50, 68, 68, 68, 68, 68, 68,\n+   68, 68, 68, 68,101, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,\n+   71, 68, 68, 68, 68, 68, 68, 68,152,186, 76, 77, 68,254, 16, 50,\n+    0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  0,  0,  5,  6,\n+    0,  0,  0,  0,  0,  0,  7,  8,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0, 10,  0,\n+    0,  0,  0,  0,  0, 11,  0,  0,  0,  0,  0,  0,  0, 12,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0, 13,  0,  0, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n+   24, 25, 26, 27, 28, 23, 23, 29, 30, 31, 32, 33,  0,  0,  0,  0,\n+    0,  0,  0, 34,  0,  0,  0, 35,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 36, 37, 38,  0,  0,  0,  0,  0,  0,  0, 39,  0,  0, 40,\n+   41, 42,  0, 43, 44,  0,  0, 45, 46,  0, 47, 48, 49,  0,  0,  0,\n+    0, 50,  0,  0, 51, 52,  0, 53, 54, 55, 56, 57, 58,  0,  0,  0,\n+    0,  0, 59, 60, 61, 62, 63, 64,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 65,  0,  0, 66,\n+    0,  0, 67,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\n+   84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n+};\n+static const uint16_t\n+_hb_arabic_u16[720] =\n+{\n+      0,    0,    0,    0,    0,    0,    0,    0,61728,61729,61730,    0,    0,61733,    0,    0,\n+  61736,61737,61738,61739,61790,61741,61742,61743,61872,61873,61874,61875,61876,61877,61878,61879,\n+  61880,61881,61754,61755,    0,61757,    0,61759,    0,    0,    0,61787,61788,61789,    0,    0,\n+      0,    0,    0,61731,    0,    0,    0,    0,    0,    0,    0,61732,    0,    0,    0,    0,\n+      0,    0,    0,    0,    0,    0,    0,61734,    0,    0,    0,    0,    0,    0,    0,61735,\n+      0,    0,    0,    0,61740,    0,    0,    0,    0,    0,    0,61755,    0,    0,    0,61759,\n+      0,61869,61765,61763,61883,61767,61882,61761,61770,61865,61772,61774,61777,61780,61783,61784,\n+  61785,61786,61792,61794,61796,61798,61800,61801,61802,61806,61810,61696,61696,61696,61696,61696,\n+  61791,61813,61816,61818,61820,61822,61921,61860,61861,61868,61864,61895,61896,61899,61892,61893,\n+  61898,61897,61894,61696,61696,61696,61696,61696,61696,61696,61696,61696,61696,61696,61696,    0,\n+  61744,61745,61746,61747,61748,61749,61750,61751,61752,61753,    0,61790,61790,    0,    0,    0,\n+      0,    0,    0,    0,61708,61709,61710,61711,61756,61758,    0,    0,    0,    0,    0,    0,\n+      0,61765,61766,61763,61764,61883,61883,61767,61768,61882,61871,61870,61870,61761,61762,61770,\n+  61770,61769,61769,61865,61866,61772,61772,61771,61771,61774,61774,61773,61773,61777,61776,61775,\n+  61775,61780,61779,61778,61778,61783,61782,61781,61781,61784,61784,61785,61785,61786,61786,61792,\n+  61792,61794,61794,61793,61793,61796,61796,61795,61795,61798,61798,61797,61797,61800,61800,61799,\n+  61799,61801,61801,61801,61801,61802,61802,61802,61802,61806,61805,61803,61804,61810,61809,61807,\n+  61808,61813,61813,61811,61812,61816,61816,61814,61815,61818,61818,61817,61817,61820,61820,61819,\n+  61819,61822,61822,61821,61821,61921,61921,61823,61823,61860,61859,61857,61858,61861,61861,61868,\n+  61867,61864,61863,61862,61862,61888,61889,61886,61887,61890,61891,61885,61884,    0,    0,    0,\n+      0,    0,    0,    0,61984,61985,61986,    0,    0,61989,    0,    0,61992,61993,61994,61995,\n+  62046,61997,61998,61999,    0,    0,62010,62011,    0,62013,    0,62015,    0,    0,    0,62043,\n+      0,62045,    0,    0,    0,    0,    0,61987,    0,    0,    0,61988,    0,    0,    0,61990,\n+      0,    0,    0,61991,61996,    0,    0,    0,    0,    0,    0,62011,    0,    0,    0,62015,\n+      0,62165,62021,62019,62170,62023,62169,62017,62028,62161,62032,62036,62040,62048,62052,62053,\n+  62055,62057,62059,62064,62068,62072,62078,62114,62115,62122,62126,61952,61952,61952,61952,61952,\n+  62047,62130,62134,62138,62142,62146,62150,62154,62155,62164,62160,62183,62184,62187,62180,62181,\n+  62186,62185,62182,61952,61952,61952,61952,    0,62000,62001,62002,62003,62004,62005,62006,62007,\n+  62008,62009,    0,62046,62046,    0,    0,    0,61964,61965,61966,61967,62012,62014,    0,    0,\n+  61954,    0,61981,    0,    0,    0,61955,    0,61982,    0,61956,    0,    0,    0,62111,    0,\n+      0,    0,    0,61970,61971,61972,61957,    0,61980,    0,    0,    0,    0,    0,61958,    0,\n+  61983,    0,    0,    0,    0,    0,62191,    0,62188,62189,62192,    0,    0,    0,61973,    0,\n+      0,62098,    0,    0,61974,    0,    0,62099,    0,    0,62101,    0,    0,61975,    0,    0,\n+  62100,    0,    0,    0,62080,62081,62082,62102,    0,62083,62084,62085,62103,    0,    0,    0,\n+  62106,    0,62107,    0,62108,    0,    0,    0,61976,    0,    0,    0,    0,62086,62087,62088,\n+  62109,61978,62089,62090,62091,62110,62093,62094,    0,62104,    0,    0,    0,    0,62095,62096,\n+  62097,62105,    0,    0,61977,    0,    0,    0,    0,    0,62075,62077,61968,    0,    0,    0,\n+      0,62021,62022,62019,62020,62170,62171,62023,62024,62169,62168,62166,62167,62017,62018,62028,\n+  62027,62025,62026,62161,62162,62032,62031,62029,62030,62036,62035,62033,62034,62040,62039,62037,\n+  62038,62048,62044,62041,62042,62052,62051,62049,62050,62053,62054,62055,62056,62057,62058,62059,\n+  62060,62064,62063,62061,62062,62068,62067,62065,62066,62072,62071,62069,62070,62078,62076,62073,\n+  62074,62114,62113,62079,62193,62118,62117,62115,62116,62122,62121,62119,62120,62126,62125,62123,\n+  62124,62130,62129,62127,62128,62134,62133,62131,62132,62138,62137,62135,62136,62142,62141,62139,\n+  62140,62146,62145,62143,62144,62150,62149,62147,62148,62154,62153,62151,62152,62155,62156,62164,\n+  62163,62160,62159,62157,62158,62176,62177,62174,62175,62178,62179,62172,62173,    0,    0,    0,\n+};\n+\n+static inline unsigned\n+_hb_arabic_b2 (const uint8_t* a, unsigned i)\n+{\n+  return (a[i>>2]>>((i&3u)<<1))&3u;\n+}\n+static inline unsigned\n+_hb_arabic_b4 (const uint8_t* a, unsigned i)\n+{\n+  return (a[i>>1]>>((i&1u)<<2))&15u;\n+}\n+static inline uint_fast16_t\n+_hb_arabic_pua_simp_map (unsigned u)\n+{\n+  return u<65277u?_hb_arabic_u16[((_hb_arabic_u8[40+(((_hb_arabic_b4(8+_hb_arabic_u8,((_hb_arabic_b2(_hb_arabic_u8,u>>3>>4>>4))<<4)+((u>>3>>4)&15u)))<<4)+((u>>3)&15u))])<<3)+((u)&7u)]:0;\n+}\n+static inline uint_fast16_t\n+_hb_arabic_pua_trad_map (unsigned u)\n+{\n+  return u<65277u?_hb_arabic_u16[320+(((_hb_arabic_u8[208+(((_hb_arabic_b4(168+_hb_arabic_u8,((_hb_arabic_b4(136+_hb_arabic_u8,u>>2>>4>>4))<<4)+((u>>2>>4)&15u)))<<4)+((u>>2)&15u))])<<2)+((u)&3u))]:0;\n+}\n+\n+#endif \/* HB_OT_SHAPER_ARABIC_PUA_HH *\/\n+\n+\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic-pua.hh","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,556 @@\n+\/* == Start of generated table == *\/\n+\/*\n+ * The following table is generated by running:\n+ *\n+ *   .\/gen-arabic-table.py ArabicShaping.txt UnicodeData.txt Blocks.txt\n+ *\n+ * on files with these headers:\n+ *\n+ * # ArabicShaping-14.0.0.txt\n+ * # Date: 2021-05-21, 01:54:00 GMT [KW, RP]\n+ * # Blocks-14.0.0.txt\n+ * # Date: 2021-01-22, 23:29:00 GMT [KW]\n+ * UnicodeData.txt does not have a header.\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_ARABIC_TABLE_HH\n+#define HB_OT_SHAPER_ARABIC_TABLE_HH\n+\n+\n+#define A       JOINING_GROUP_ALAPH\n+#define DR      JOINING_GROUP_DALATH_RISH\n+#define C       JOINING_TYPE_C\n+#define D       JOINING_TYPE_D\n+#define L       JOINING_TYPE_L\n+#define R       JOINING_TYPE_R\n+#define T       JOINING_TYPE_T\n+#define U       JOINING_TYPE_U\n+#define X       JOINING_TYPE_X\n+\n+static const uint8_t joining_table[] =\n+{\n+\n+#define joining_offset_0x0600u 0\n+\n+  \/* Arabic *\/\n+\n+  \/* 0600 *\/ U,U,U,U,U,U,X,X,U,X,X,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 0620 *\/ D,U,R,R,R,R,D,R,D,R,D,D,D,D,D,R,R,R,R,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 0640 *\/ C,D,D,D,D,D,D,D,R,D,D,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 0660 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,D,D,X,R,R,R,U,R,R,R,D,D,D,D,D,D,D,D,\n+  \/* 0680 *\/ D,D,D,D,D,D,D,D,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,D,D,D,D,D,D,\n+  \/* 06A0 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 06C0 *\/ R,D,D,R,R,R,R,R,R,R,R,R,D,R,D,R,D,D,R,R,X,R,X,X,X,X,X,X,X,U,X,X,\n+  \/* 06E0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,R,R,X,X,X,X,X,X,X,X,X,X,D,D,D,X,X,D,\n+\n+  \/* Syriac *\/\n+\n+  \/* 0700 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,T,A,X,D,D,D,DR,DR,R,R,R,D,D,D,D,R,D,\n+  \/* 0720 *\/ D,D,D,D,D,D,D,D,R,D,DR,D,R,D,D,DR,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 0740 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,R,D,D,\n+\n+  \/* Arabic Supplement *\/\n+\n+  \/* 0740 *\/                                 D,D,D,D,D,D,D,D,D,R,R,R,D,D,D,D,\n+  \/* 0760 *\/ D,D,D,D,D,D,D,D,D,D,D,R,R,D,D,D,D,R,D,R,R,D,D,D,R,R,D,D,D,D,D,D,\n+\n+  \/* FILLER *\/\n+\n+  \/* 0780 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 07A0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+\n+  \/* NKo *\/\n+\n+  \/* 07C0 *\/ X,X,X,X,X,X,X,X,X,X,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 07E0 *\/ D,D,D,D,D,D,D,D,D,D,D,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,C,X,X,X,X,X,\n+\n+  \/* FILLER *\/\n+\n+  \/* 0800 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 0820 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+\n+  \/* Mandaic *\/\n+\n+  \/* 0840 *\/ R,D,D,D,D,D,R,R,D,R,D,D,D,D,D,D,D,D,D,D,R,D,R,R,R,X,X,X,X,X,X,X,\n+\n+  \/* Syriac Supplement *\/\n+\n+  \/* 0860 *\/ D,U,D,D,D,D,U,R,D,R,R,X,X,X,X,X,\n+\n+  \/* Arabic Extended-B *\/\n+\n+  \/* 0860 *\/                                 R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,\n+  \/* 0880 *\/ R,R,R,C,C,C,D,U,U,D,D,D,D,D,R,X,U,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+\n+  \/* Arabic Extended-A *\/\n+\n+  \/* 08A0 *\/ D,D,D,D,D,D,D,D,D,D,R,R,R,U,R,D,D,R,R,D,D,D,D,D,D,R,D,D,D,D,D,D,\n+  \/* 08C0 *\/ D,D,D,D,D,D,D,D,D,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 08E0 *\/ X,X,U,\n+\n+#define joining_offset_0x1806u 739\n+\n+  \/* Mongolian *\/\n+\n+  \/* 1800 *\/             U,D,X,X,C,X,X,X,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 1820 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 1840 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 1860 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,X,X,X,X,X,X,X,\n+  \/* 1880 *\/ U,U,U,U,U,T,T,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 18A0 *\/ D,D,D,D,D,D,D,D,D,X,D,\n+\n+#define joining_offset_0x200cu 904\n+\n+  \/* General Punctuation *\/\n+\n+  \/* 2000 *\/                         U,C,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 2020 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 2040 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 2060 *\/ X,X,X,X,X,X,U,U,U,U,\n+\n+#define joining_offset_0xa840u 998\n+\n+  \/* Phags-pa *\/\n+\n+  \/* A840 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* A860 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,L,U,\n+\n+#define joining_offset_0x10ac0u 1050\n+\n+  \/* Manichaean *\/\n+\n+  \/* 10AC0 *\/ D,D,D,D,D,R,U,R,U,R,R,U,U,L,R,R,R,R,R,D,D,D,D,L,D,D,D,D,D,R,D,D,\n+  \/* 10AE0 *\/ D,R,U,U,R,X,X,X,X,X,X,D,D,D,D,R,\n+\n+#define joining_offset_0x10b80u 1098\n+\n+  \/* Psalter Pahlavi *\/\n+\n+  \/* 10B80 *\/ D,R,D,R,R,R,D,D,D,R,D,D,R,D,R,R,D,R,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 10BA0 *\/ X,X,X,X,X,X,X,X,X,R,R,R,R,D,D,U,\n+\n+#define joining_offset_0x10d00u 1146\n+\n+  \/* Hanifi Rohingya *\/\n+\n+  \/* 10D00 *\/ L,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 10D20 *\/ D,D,R,D,\n+\n+#define joining_offset_0x10f30u 1182\n+\n+  \/* Sogdian *\/\n+\n+  \/* 10F20 *\/                                 D,D,D,R,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 10F40 *\/ D,D,D,D,D,U,X,X,X,X,X,X,X,X,X,X,X,D,D,D,R,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 10F60 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+\n+  \/* Old Uyghur *\/\n+\n+  \/* 10F60 *\/                                 D,D,D,D,R,R,D,D,D,D,D,D,D,D,D,D,\n+  \/* 10F80 *\/ D,D,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 10FA0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+\n+  \/* Chorasmian *\/\n+\n+  \/* 10FA0 *\/                                 D,U,D,D,R,R,R,U,D,R,R,D,D,R,D,D,\n+  \/* 10FC0 *\/ U,D,R,R,D,U,U,U,U,R,D,L,\n+\n+#define joining_offset_0x110bdu 1338\n+\n+  \/* Kaithi *\/\n+\n+  \/* 110A0 *\/                                                           U,X,X,\n+  \/* 110C0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,U,\n+\n+#define joining_offset_0x1e900u 1355\n+\n+  \/* Adlam *\/\n+\n+  \/* 1E900 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 1E920 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 1E940 *\/ D,D,D,D,X,X,X,X,X,X,X,T,\n+\n+}; \/* Table items: 1431; occupancy: 57% *\/\n+\n+\n+static unsigned int\n+joining_type (hb_codepoint_t u)\n+{\n+  switch (u >> 12)\n+  {\n+    case 0x0u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0600u, 0x08E2u)) return joining_table[u - 0x0600u + joining_offset_0x0600u];\n+      break;\n+\n+    case 0x1u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1806u, 0x18AAu)) return joining_table[u - 0x1806u + joining_offset_0x1806u];\n+      break;\n+\n+    case 0x2u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x200Cu, 0x2069u)) return joining_table[u - 0x200Cu + joining_offset_0x200cu];\n+      break;\n+\n+    case 0xAu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xA840u, 0xA873u)) return joining_table[u - 0xA840u + joining_offset_0xa840u];\n+      break;\n+\n+    case 0x10u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10AC0u, 0x10AEFu)) return joining_table[u - 0x10AC0u + joining_offset_0x10ac0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10B80u, 0x10BAFu)) return joining_table[u - 0x10B80u + joining_offset_0x10b80u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10D00u, 0x10D23u)) return joining_table[u - 0x10D00u + joining_offset_0x10d00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10F30u, 0x10FCBu)) return joining_table[u - 0x10F30u + joining_offset_0x10f30u];\n+      break;\n+\n+    case 0x11u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x110BDu, 0x110CDu)) return joining_table[u - 0x110BDu + joining_offset_0x110bdu];\n+      break;\n+\n+    case 0x1Eu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1E900u, 0x1E94Bu)) return joining_table[u - 0x1E900u + joining_offset_0x1e900u];\n+      break;\n+\n+    default:\n+      break;\n+  }\n+  return X;\n+}\n+\n+#undef A\n+#undef DR\n+#undef C\n+#undef D\n+#undef L\n+#undef R\n+#undef T\n+#undef U\n+#undef X\n+\n+\n+static const uint16_t shaping_table[][4] =\n+{\n+  {0x0000u, 0x0000u, 0x0000u, 0xFE80u}, \/* U+0621 ARABIC LETTER HAMZA ISOLATED FORM *\/\n+  {0x0000u, 0x0000u, 0xFE82u, 0xFE81u}, \/* U+0622 ARABIC LETTER ALEF WITH MADDA ABOVE *\/\n+  {0x0000u, 0x0000u, 0xFE84u, 0xFE83u}, \/* U+0623 ARABIC LETTER ALEF WITH HAMZA ABOVE *\/\n+  {0x0000u, 0x0000u, 0xFE86u, 0xFE85u}, \/* U+0624 ARABIC LETTER WAW WITH HAMZA ABOVE *\/\n+  {0x0000u, 0x0000u, 0xFE88u, 0xFE87u}, \/* U+0625 ARABIC LETTER ALEF WITH HAMZA BELOW *\/\n+  {0xFE8Bu, 0xFE8Cu, 0xFE8Au, 0xFE89u}, \/* U+0626 ARABIC LETTER YEH WITH HAMZA ABOVE *\/\n+  {0x0000u, 0x0000u, 0xFE8Eu, 0xFE8Du}, \/* U+0627 ARABIC LETTER ALEF *\/\n+  {0xFE91u, 0xFE92u, 0xFE90u, 0xFE8Fu}, \/* U+0628 ARABIC LETTER BEH *\/\n+  {0x0000u, 0x0000u, 0xFE94u, 0xFE93u}, \/* U+0629 ARABIC LETTER TEH MARBUTA *\/\n+  {0xFE97u, 0xFE98u, 0xFE96u, 0xFE95u}, \/* U+062A ARABIC LETTER TEH *\/\n+  {0xFE9Bu, 0xFE9Cu, 0xFE9Au, 0xFE99u}, \/* U+062B ARABIC LETTER THEH *\/\n+  {0xFE9Fu, 0xFEA0u, 0xFE9Eu, 0xFE9Du}, \/* U+062C ARABIC LETTER JEEM *\/\n+  {0xFEA3u, 0xFEA4u, 0xFEA2u, 0xFEA1u}, \/* U+062D ARABIC LETTER HAH *\/\n+  {0xFEA7u, 0xFEA8u, 0xFEA6u, 0xFEA5u}, \/* U+062E ARABIC LETTER KHAH *\/\n+  {0x0000u, 0x0000u, 0xFEAAu, 0xFEA9u}, \/* U+062F ARABIC LETTER DAL *\/\n+  {0x0000u, 0x0000u, 0xFEACu, 0xFEABu}, \/* U+0630 ARABIC LETTER THAL *\/\n+  {0x0000u, 0x0000u, 0xFEAEu, 0xFEADu}, \/* U+0631 ARABIC LETTER REH *\/\n+  {0x0000u, 0x0000u, 0xFEB0u, 0xFEAFu}, \/* U+0632 ARABIC LETTER ZAIN *\/\n+  {0xFEB3u, 0xFEB4u, 0xFEB2u, 0xFEB1u}, \/* U+0633 ARABIC LETTER SEEN *\/\n+  {0xFEB7u, 0xFEB8u, 0xFEB6u, 0xFEB5u}, \/* U+0634 ARABIC LETTER SHEEN *\/\n+  {0xFEBBu, 0xFEBCu, 0xFEBAu, 0xFEB9u}, \/* U+0635 ARABIC LETTER SAD *\/\n+  {0xFEBFu, 0xFEC0u, 0xFEBEu, 0xFEBDu}, \/* U+0636 ARABIC LETTER DAD *\/\n+  {0xFEC3u, 0xFEC4u, 0xFEC2u, 0xFEC1u}, \/* U+0637 ARABIC LETTER TAH *\/\n+  {0xFEC7u, 0xFEC8u, 0xFEC6u, 0xFEC5u}, \/* U+0638 ARABIC LETTER ZAH *\/\n+  {0xFECBu, 0xFECCu, 0xFECAu, 0xFEC9u}, \/* U+0639 ARABIC LETTER AIN *\/\n+  {0xFECFu, 0xFED0u, 0xFECEu, 0xFECDu}, \/* U+063A ARABIC LETTER GHAIN *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0640  *\/\n+  {0xFED3u, 0xFED4u, 0xFED2u, 0xFED1u}, \/* U+0641 ARABIC LETTER FEH *\/\n+  {0xFED7u, 0xFED8u, 0xFED6u, 0xFED5u}, \/* U+0642 ARABIC LETTER QAF *\/\n+  {0xFEDBu, 0xFEDCu, 0xFEDAu, 0xFED9u}, \/* U+0643 ARABIC LETTER KAF *\/\n+  {0xFEDFu, 0xFEE0u, 0xFEDEu, 0xFEDDu}, \/* U+0644 ARABIC LETTER LAM *\/\n+  {0xFEE3u, 0xFEE4u, 0xFEE2u, 0xFEE1u}, \/* U+0645 ARABIC LETTER MEEM *\/\n+  {0xFEE7u, 0xFEE8u, 0xFEE6u, 0xFEE5u}, \/* U+0646 ARABIC LETTER NOON *\/\n+  {0xFEEBu, 0xFEECu, 0xFEEAu, 0xFEE9u}, \/* U+0647 ARABIC LETTER HEH *\/\n+  {0x0000u, 0x0000u, 0xFEEEu, 0xFEEDu}, \/* U+0648 ARABIC LETTER WAW *\/\n+  {0xFBE8u, 0xFBE9u, 0xFEF0u, 0xFEEFu}, \/* U+0649 ARABIC LETTER *\/\n+  {0xFEF3u, 0xFEF4u, 0xFEF2u, 0xFEF1u}, \/* U+064A ARABIC LETTER YEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0650  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0651  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0652  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0653  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0654  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0655  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0656  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0657  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0658  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0659  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065A  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0660  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0661  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0662  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0663  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0664  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0665  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0666  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0667  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0668  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0669  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066A  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0670  *\/\n+  {0x0000u, 0x0000u, 0xFB51u, 0xFB50u}, \/* U+0671 ARABIC LETTER ALEF WASLA *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0672  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0673  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0674  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0675  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0676  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0xFBDDu}, \/* U+0677 ARABIC LETTER U WITH HAMZA ABOVE ISOLATED FORM *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0678  *\/\n+  {0xFB68u, 0xFB69u, 0xFB67u, 0xFB66u}, \/* U+0679 ARABIC LETTER TTEH *\/\n+  {0xFB60u, 0xFB61u, 0xFB5Fu, 0xFB5Eu}, \/* U+067A ARABIC LETTER TTEHEH *\/\n+  {0xFB54u, 0xFB55u, 0xFB53u, 0xFB52u}, \/* U+067B ARABIC LETTER BEEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+067C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+067D  *\/\n+  {0xFB58u, 0xFB59u, 0xFB57u, 0xFB56u}, \/* U+067E ARABIC LETTER PEH *\/\n+  {0xFB64u, 0xFB65u, 0xFB63u, 0xFB62u}, \/* U+067F ARABIC LETTER TEHEH *\/\n+  {0xFB5Cu, 0xFB5Du, 0xFB5Bu, 0xFB5Au}, \/* U+0680 ARABIC LETTER BEHEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0681  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0682  *\/\n+  {0xFB78u, 0xFB79u, 0xFB77u, 0xFB76u}, \/* U+0683 ARABIC LETTER NYEH *\/\n+  {0xFB74u, 0xFB75u, 0xFB73u, 0xFB72u}, \/* U+0684 ARABIC LETTER DYEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0685  *\/\n+  {0xFB7Cu, 0xFB7Du, 0xFB7Bu, 0xFB7Au}, \/* U+0686 ARABIC LETTER TCHEH *\/\n+  {0xFB80u, 0xFB81u, 0xFB7Fu, 0xFB7Eu}, \/* U+0687 ARABIC LETTER TCHEHEH *\/\n+  {0x0000u, 0x0000u, 0xFB89u, 0xFB88u}, \/* U+0688 ARABIC LETTER DDAL *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0689  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+068A  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+068B  *\/\n+  {0x0000u, 0x0000u, 0xFB85u, 0xFB84u}, \/* U+068C ARABIC LETTER DAHAL *\/\n+  {0x0000u, 0x0000u, 0xFB83u, 0xFB82u}, \/* U+068D ARABIC LETTER DDAHAL *\/\n+  {0x0000u, 0x0000u, 0xFB87u, 0xFB86u}, \/* U+068E ARABIC LETTER DUL *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+068F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0690  *\/\n+  {0x0000u, 0x0000u, 0xFB8Du, 0xFB8Cu}, \/* U+0691 ARABIC LETTER RREH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0692  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0693  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0694  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0695  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0696  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0697  *\/\n+  {0x0000u, 0x0000u, 0xFB8Bu, 0xFB8Au}, \/* U+0698 ARABIC LETTER JEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0699  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069A  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A0  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A1  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A2  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A3  *\/\n+  {0xFB6Cu, 0xFB6Du, 0xFB6Bu, 0xFB6Au}, \/* U+06A4 ARABIC LETTER VEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A5  *\/\n+  {0xFB70u, 0xFB71u, 0xFB6Fu, 0xFB6Eu}, \/* U+06A6 ARABIC LETTER PEHEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A7  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A8  *\/\n+  {0xFB90u, 0xFB91u, 0xFB8Fu, 0xFB8Eu}, \/* U+06A9 ARABIC LETTER KEHEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AA  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AB  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AC  *\/\n+  {0xFBD5u, 0xFBD6u, 0xFBD4u, 0xFBD3u}, \/* U+06AD ARABIC LETTER NG *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AE  *\/\n+  {0xFB94u, 0xFB95u, 0xFB93u, 0xFB92u}, \/* U+06AF ARABIC LETTER GAF *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B0  *\/\n+  {0xFB9Cu, 0xFB9Du, 0xFB9Bu, 0xFB9Au}, \/* U+06B1 ARABIC LETTER NGOEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B2  *\/\n+  {0xFB98u, 0xFB99u, 0xFB97u, 0xFB96u}, \/* U+06B3 ARABIC LETTER GUEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B4  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B5  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B6  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B7  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B8  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B9  *\/\n+  {0x0000u, 0x0000u, 0xFB9Fu, 0xFB9Eu}, \/* U+06BA ARABIC LETTER NOON GHUNNA *\/\n+  {0xFBA2u, 0xFBA3u, 0xFBA1u, 0xFBA0u}, \/* U+06BB ARABIC LETTER RNOON *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06BC  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06BD  *\/\n+  {0xFBACu, 0xFBADu, 0xFBABu, 0xFBAAu}, \/* U+06BE ARABIC LETTER HEH DOACHASHMEE *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06BF  *\/\n+  {0x0000u, 0x0000u, 0xFBA5u, 0xFBA4u}, \/* U+06C0 ARABIC LETTER HEH WITH YEH ABOVE *\/\n+  {0xFBA8u, 0xFBA9u, 0xFBA7u, 0xFBA6u}, \/* U+06C1 ARABIC LETTER HEH GOAL *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06C2  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06C3  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06C4  *\/\n+  {0x0000u, 0x0000u, 0xFBE1u, 0xFBE0u}, \/* U+06C5 ARABIC LETTER KIRGHIZ OE *\/\n+  {0x0000u, 0x0000u, 0xFBDAu, 0xFBD9u}, \/* U+06C6 ARABIC LETTER OE *\/\n+  {0x0000u, 0x0000u, 0xFBD8u, 0xFBD7u}, \/* U+06C7 ARABIC LETTER U *\/\n+  {0x0000u, 0x0000u, 0xFBDCu, 0xFBDBu}, \/* U+06C8 ARABIC LETTER YU *\/\n+  {0x0000u, 0x0000u, 0xFBE3u, 0xFBE2u}, \/* U+06C9 ARABIC LETTER KIRGHIZ YU *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CA  *\/\n+  {0x0000u, 0x0000u, 0xFBDFu, 0xFBDEu}, \/* U+06CB ARABIC LETTER VE *\/\n+  {0xFBFEu, 0xFBFFu, 0xFBFDu, 0xFBFCu}, \/* U+06CC ARABIC LETTER FARSI YEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CD  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CE  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CF  *\/\n+  {0xFBE6u, 0xFBE7u, 0xFBE5u, 0xFBE4u}, \/* U+06D0 ARABIC LETTER E *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06D1  *\/\n+  {0x0000u, 0x0000u, 0xFBAFu, 0xFBAEu}, \/* U+06D2 ARABIC LETTER YEH BARREE *\/\n+  {0x0000u, 0x0000u, 0xFBB1u, 0xFBB0u}, \/* U+06D3 ARABIC LETTER YEH BARREE WITH HAMZA ABOVE *\/\n+};\n+\n+#define SHAPING_TABLE_FIRST     0x0621u\n+#define SHAPING_TABLE_LAST      0x06D3u\n+\n+\n+static const struct ligature_set_t {\n+ uint16_t first;\n+ struct ligature_pairs_t {\n+   uint16_t components[1];\n+   uint16_t ligature;\n+ } ligatures[14];\n+} ligature_table[] =\n+{\n+  { 0xFE91u, {\n+    { {0xFEE2u}, 0xFC08u }, \/* ARABIC LIGATURE BEH WITH MEEM ISOLATED FORM *\/\n+    { {0xFEE4u}, 0xFC9Fu }, \/* ARABIC LIGATURE BEH WITH MEEM INITIAL FORM *\/\n+    { {0xFEA0u}, 0xFC9Cu }, \/* ARABIC LIGATURE BEH WITH JEEM INITIAL FORM *\/\n+    { {0xFEA4u}, 0xFC9Du }, \/* ARABIC LIGATURE BEH WITH HAH INITIAL FORM *\/\n+    { {0xFEA8u}, 0xFC9Eu }, \/* ARABIC LIGATURE BEH WITH KHAH INITIAL FORM *\/\n+  }},\n+  { 0xFE92u, {\n+    { {0xFEAEu}, 0xFC6Au }, \/* ARABIC LIGATURE BEH WITH REH FINAL FORM *\/\n+    { {0xFEE6u}, 0xFC6Du }, \/* ARABIC LIGATURE BEH WITH NOON FINAL FORM *\/\n+    { {0xFEF2u}, 0xFC6Fu }, \/* ARABIC LIGATURE BEH WITH YEH FINAL FORM *\/\n+  }},\n+  { 0xFE97u, {\n+    { {0xFEE2u}, 0xFC0Eu }, \/* ARABIC LIGATURE TEH WITH MEEM ISOLATED FORM *\/\n+    { {0xFEE4u}, 0xFCA4u }, \/* ARABIC LIGATURE TEH WITH MEEM INITIAL FORM *\/\n+    { {0xFEA0u}, 0xFCA1u }, \/* ARABIC LIGATURE TEH WITH JEEM INITIAL FORM *\/\n+    { {0xFEA4u}, 0xFCA2u }, \/* ARABIC LIGATURE TEH WITH HAH INITIAL FORM *\/\n+    { {0xFEA8u}, 0xFCA3u }, \/* ARABIC LIGATURE TEH WITH KHAH INITIAL FORM *\/\n+  }},\n+  { 0xFE98u, {\n+    { {0xFEAEu}, 0xFC70u }, \/* ARABIC LIGATURE TEH WITH REH FINAL FORM *\/\n+    { {0xFEE6u}, 0xFC73u }, \/* ARABIC LIGATURE TEH WITH NOON FINAL FORM *\/\n+    { {0xFEF2u}, 0xFC75u }, \/* ARABIC LIGATURE TEH WITH YEH FINAL FORM *\/\n+  }},\n+  { 0xFE9Bu, {\n+    { {0xFEE2u}, 0xFC12u }, \/* ARABIC LIGATURE THEH WITH MEEM ISOLATED FORM *\/\n+  }},\n+  { 0xFE9Fu, {\n+    { {0xFEE4u}, 0xFCA8u }, \/* ARABIC LIGATURE JEEM WITH MEEM INITIAL FORM *\/\n+  }},\n+  { 0xFEA3u, {\n+    { {0xFEE4u}, 0xFCAAu }, \/* ARABIC LIGATURE HAH WITH MEEM INITIAL FORM *\/\n+  }},\n+  { 0xFEA7u, {\n+    { {0xFEE4u}, 0xFCACu }, \/* ARABIC LIGATURE KHAH WITH MEEM INITIAL FORM *\/\n+  }},\n+  { 0xFEB3u, {\n+    { {0xFEE4u}, 0xFCB0u }, \/* ARABIC LIGATURE SEEN WITH MEEM INITIAL FORM *\/\n+  }},\n+  { 0xFEB7u, {\n+    { {0xFEE4u}, 0xFD30u }, \/* ARABIC LIGATURE SHEEN WITH MEEM INITIAL FORM *\/\n+  }},\n+  { 0xFED3u, {\n+    { {0xFEF2u}, 0xFC32u }, \/* ARABIC LIGATURE FEH WITH YEH ISOLATED FORM *\/\n+  }},\n+  { 0xFEDFu, {\n+    { {0xFE9Eu}, 0xFC3Fu }, \/* ARABIC LIGATURE LAM WITH JEEM ISOLATED FORM *\/\n+    { {0xFEA0u}, 0xFCC9u }, \/* ARABIC LIGATURE LAM WITH JEEM INITIAL FORM *\/\n+    { {0xFEA2u}, 0xFC40u }, \/* ARABIC LIGATURE LAM WITH HAH ISOLATED FORM *\/\n+    { {0xFEA4u}, 0xFCCAu }, \/* ARABIC LIGATURE LAM WITH HAH INITIAL FORM *\/\n+    { {0xFEA6u}, 0xFC41u }, \/* ARABIC LIGATURE LAM WITH KHAH ISOLATED FORM *\/\n+    { {0xFEA8u}, 0xFCCBu }, \/* ARABIC LIGATURE LAM WITH KHAH INITIAL FORM *\/\n+    { {0xFEE2u}, 0xFC42u }, \/* ARABIC LIGATURE LAM WITH MEEM ISOLATED FORM *\/\n+    { {0xFEE4u}, 0xFCCCu }, \/* ARABIC LIGATURE LAM WITH MEEM INITIAL FORM *\/\n+    { {0xFEF2u}, 0xFC44u }, \/* ARABIC LIGATURE LAM WITH YEH ISOLATED FORM *\/\n+    { {0xFEECu}, 0xFCCDu }, \/* ARABIC LIGATURE LAM WITH HEH INITIAL FORM *\/\n+    { {0xFE82u}, 0xFEF5u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE ISOLATED FORM *\/\n+    { {0xFE84u}, 0xFEF7u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE ISOLATED FORM *\/\n+    { {0xFE88u}, 0xFEF9u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW ISOLATED FORM *\/\n+    { {0xFE8Eu}, 0xFEFBu }, \/* ARABIC LIGATURE LAM WITH ALEF ISOLATED FORM *\/\n+  }},\n+  { 0xFEE0u, {\n+    { {0xFEF0u}, 0xFC86u }, \/* ARABIC LIGATURE LAM WITH ALEF MAKSURA FINAL FORM *\/\n+    { {0xFE82u}, 0xFEF6u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE FINAL FORM *\/\n+    { {0xFE84u}, 0xFEF8u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE FINAL FORM *\/\n+    { {0xFE88u}, 0xFEFAu }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW FINAL FORM *\/\n+    { {0xFE8Eu}, 0xFEFCu }, \/* ARABIC LIGATURE LAM WITH ALEF FINAL FORM *\/\n+  }},\n+  { 0xFEE3u, {\n+    { {0xFEA0u}, 0xFCCEu }, \/* ARABIC LIGATURE MEEM WITH JEEM INITIAL FORM *\/\n+    { {0xFEA4u}, 0xFCCFu }, \/* ARABIC LIGATURE MEEM WITH HAH INITIAL FORM *\/\n+    { {0xFEA8u}, 0xFCD0u }, \/* ARABIC LIGATURE MEEM WITH KHAH INITIAL FORM *\/\n+    { {0xFEE4u}, 0xFCD1u }, \/* ARABIC LIGATURE MEEM WITH MEEM INITIAL FORM *\/\n+  }},\n+  { 0xFEE7u, {\n+    { {0xFEE2u}, 0xFC4Eu }, \/* ARABIC LIGATURE NOON WITH MEEM ISOLATED FORM *\/\n+    { {0xFEE4u}, 0xFCD5u }, \/* ARABIC LIGATURE NOON WITH MEEM INITIAL FORM *\/\n+    { {0xFEA0u}, 0xFCD2u }, \/* ARABIC LIGATURE NOON WITH JEEM INITIAL FORM *\/\n+    { {0xFEA4u}, 0xFCD3u }, \/* ARABIC LIGATURE NOON WITH HAH INITIAL FORM *\/\n+  }},\n+  { 0xFEE8u, {\n+    { {0xFEF2u}, 0xFC8Fu }, \/* ARABIC LIGATURE NOON WITH YEH FINAL FORM *\/\n+  }},\n+  { 0xFEF3u, {\n+    { {0xFEA0u}, 0xFCDAu }, \/* ARABIC LIGATURE YEH WITH JEEM INITIAL FORM *\/\n+    { {0xFEA4u}, 0xFCDBu }, \/* ARABIC LIGATURE YEH WITH HAH INITIAL FORM *\/\n+    { {0xFEA8u}, 0xFCDCu }, \/* ARABIC LIGATURE YEH WITH KHAH INITIAL FORM *\/\n+    { {0xFEE4u}, 0xFCDDu }, \/* ARABIC LIGATURE YEH WITH MEEM INITIAL FORM *\/\n+  }},\n+  { 0xFEF4u, {\n+    { {0xFEAEu}, 0xFC91u }, \/* ARABIC LIGATURE YEH WITH REH FINAL FORM *\/\n+    { {0xFEE6u}, 0xFC94u }, \/* ARABIC LIGATURE YEH WITH NOON FINAL FORM *\/\n+  }},\n+};\n+\n+\n+static const struct ligature_mark_set_t {\n+ uint16_t first;\n+ struct ligature_pairs_t {\n+   uint16_t components[1];\n+   uint16_t ligature;\n+ } ligatures[5];\n+} ligature_mark_table[] =\n+{\n+  { 0x0651u, {\n+    { {0x064Cu}, 0xFC5Eu }, \/* ARABIC LIGATURE SHADDA WITH DAMMATAN ISOLATED FORM *\/\n+    { {0x064Eu}, 0xFC60u }, \/* ARABIC LIGATURE SHADDA WITH FATHA ISOLATED FORM *\/\n+    { {0x064Fu}, 0xFC61u }, \/* ARABIC LIGATURE SHADDA WITH DAMMA ISOLATED FORM *\/\n+    { {0x0650u}, 0xFC62u }, \/* ARABIC LIGATURE SHADDA WITH KASRA ISOLATED FORM *\/\n+    { {0x064Bu}, 0xF2EEu }, \/* PUA ARABIC LIGATURE SHADDA WITH FATHATAN ISOLATED FORM *\/\n+  }},\n+};\n+\n+\n+static const struct ligature_3_set_t {\n+ uint16_t first;\n+ struct ligature_triplets_t {\n+   uint16_t components[2];\n+   uint16_t ligature;\n+ } ligatures[3];\n+} ligature_3_table[] =\n+{\n+  { 0xFEDFu, {\n+    { {0xFEE4u, 0xFEA4u}, 0xFD88u}, \/* ARABIC LIGATURE LAM WITH MEEM WITH HAH INITIAL FORM *\/\n+    { {0xFEE0u, 0xFEEAu}, 0xF201u}, \/* PUA ARABIC LIGATURE LELLAH ISOLATED FORM *\/\n+    { {0xFEE4u, 0xFEA0u}, 0xF211u}, \/* PUA ARABIC LIGATURE LAM WITH MEEM WITH JEEM INITIAL FORM *\/\n+  }},\n+};\n+\n+\n+#endif \/* HB_OT_SHAPER_ARABIC_TABLE_HH *\/\n+\n+\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic-table.hh","additions":556,"deletions":0,"binary":false,"changes":556,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_WIN1256_HH\n+#ifndef HB_OT_SHAPER_ARABIC_WIN1256_HH\n@@ -90,0 +90,2 @@\n+\/* Shorthand. *\/\n+#define G       OT_GLYPHID\n@@ -186,2 +188,0 @@\n-\/* Shorthand. *\/\n-#define G       OT_GLYPHID\n@@ -303,0 +303,4 @@\n+\n+#undef MANIFEST\n+#undef MANIFEST_LOOKUP\n+\n@@ -309,1 +313,0 @@\n-#undef OT_DISTANCE\n@@ -311,0 +314,23 @@\n+#undef OT_DISTANCE\n+\n+#undef OT_LABEL\n+#undef OT_LIST\n+\n+#undef OT_TAG\n+#undef OT_OFFSET\n+#undef OT_GLYPHID\n+#undef G\n+#undef OT_UARRAY\n+#undef OT_UHEADLESSARRAY\n+\n+#undef OT_LOOKUP_FLAG_IGNORE_MARKS\n+#undef OT_LOOKUP\n+#undef OT_SUBLOOKUP\n+#undef OT_COVERAGE1\n+#undef OT_LOOKUP_TYPE_SUBST_SINGLE\n+#undef OT_LOOKUP_TYPE_SUBST_LIGATURE\n+#undef OT_SUBLOOKUP_SINGLE_SUBST_FORMAT2\n+#undef OT_SUBLOOKUP_LIGATURE_SUBST_FORMAT1\n+#undef OT_LIGATURE_SET\n+#undef OT_LIGATURE\n+\n@@ -319,1 +345,1 @@\n-#include \"hb-ot-shape-complex-arabic-win1256.hh\"\n+#include \"hb-ot-shaper-arabic-win1256.hh\"\n@@ -322,2 +348,2 @@\n-#define HB_OT_SHAPE_COMPLEX_ARABIC_WIN1256_HH\n-#endif \/* HB_OT_SHAPE_COMPLEX_ARABIC_WIN1256_HH *\/\n+#define HB_OT_SHAPER_ARABIC_WIN1256_HH\n+#endif \/* HB_OT_SHAPER_ARABIC_WIN1256_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic-win1256.hh","additions":33,"deletions":7,"binary":false,"changes":40,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-arabic-win1256.hh","status":"renamed"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"hb-ot-shape-complex-arabic.hh\"\n+#include \"hb-ot-shaper-arabic.hh\"\n@@ -36,1 +36,1 @@\n-#define arabic_shaping_action() complex_var_u8_auxiliary() \/* arabic shaping action *\/\n+#define arabic_shaping_action() ot_shaper_var_u8_auxiliary() \/* arabic shaping action *\/\n@@ -38,1 +38,1 @@\n-#define HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH HB_BUFFER_SCRATCH_FLAG_COMPLEX0\n+#define HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH HB_BUFFER_SCRATCH_FLAG_SHAPER0\n@@ -84,1 +84,1 @@\n-#include \"hb-ot-shape-complex-arabic-table.hh\"\n+#include \"hb-ot-shaper-arabic-table.hh\"\n@@ -174,0 +174,8 @@\n+static void\n+deallocate_buffer_var (const hb_ot_shape_plan_t *plan,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, arabic_shaping_action);\n+}\n+\n@@ -216,0 +224,1 @@\n+   map->add_gsub_pause (deallocate_buffer_var);\n@@ -243,1 +252,1 @@\n-#include \"hb-ot-shape-complex-arabic-fallback.hh\"\n+#include \"hb-ot-shaper-arabic-fallback.hh\"\n@@ -262,1 +271,1 @@\n-  arabic_shape_plan_t *arabic_plan = (arabic_shape_plan_t *) calloc (1, sizeof (arabic_shape_plan_t));\n+  arabic_shape_plan_t *arabic_plan = (arabic_shape_plan_t *) hb_calloc (1, sizeof (arabic_shape_plan_t));\n@@ -285,1 +294,1 @@\n-  free (data);\n+  hb_free (data);\n@@ -324,0 +333,14 @@\n+    else\n+    {\n+      if (prev == UINT_MAX)\n+      {\n+        if (this_type >= JOINING_TYPE_R)\n+          buffer->unsafe_to_concat_from_outbuffer (0, i + 1);\n+      }\n+      else\n+      {\n+        if (this_type >= JOINING_TYPE_R ||\n+            (2 <= state && state <= 5) \/* States that have a possible prev_action. *\/)\n+          buffer->unsafe_to_concat (prev, i + 1);\n+      }\n+    }\n@@ -340,0 +363,1 @@\n+    {\n@@ -341,0 +365,6 @@\n+      buffer->unsafe_to_break (prev, buffer->len);\n+    }\n+    else if (2 <= state && state <= 5) \/* States that have a possible prev_action. *\/\n+    {\n+      buffer->unsafe_to_concat (prev, buffer->len);\n+    }\n@@ -352,1 +382,1 @@\n-    if (unlikely (hb_in_range<hb_codepoint_t> (info[i].codepoint, 0x180Bu, 0x180Du)))\n+    if (unlikely (hb_in_ranges<hb_codepoint_t> (info[i].codepoint, 0x180Bu, 0x180Du, 0x180Fu, 0x180Fu)))\n@@ -387,1 +417,1 @@\n-#ifdef HB_NO_OT_SHAPE_COMPLEX_ARABIC_FALLBACK\n+#ifdef HB_NO_OT_SHAPER_ARABIC_FALLBACK\n@@ -601,2 +631,0 @@\n-\n-  HB_BUFFER_DEALLOCATE_VAR (buffer, arabic_shaping_action);\n@@ -617,0 +645,5 @@\n+  0x08CAu, \/* ARABIC SMALL HIGH FARSI YEH *\/\n+  0x08CBu, \/* ARABIC SMALL HIGH YEH BARREE WITH TWO DOTS BELOW *\/\n+  0x08CDu, \/* ARABIC SMALL HIGH ZAH *\/\n+  0x08CEu, \/* ARABIC LARGE ROUND DOT ABOVE *\/\n+  0x08CFu, \/* ARABIC LARGE ROUND DOT BELOW *\/\n@@ -666,1 +699,1 @@\n-    hb_glyph_info_t temp[HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS];\n+    hb_glyph_info_t temp[HB_OT_SHAPE_MAX_COMBINING_MARKS];\n@@ -697,1 +730,1 @@\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_arabic =\n+const hb_ot_shaper_t _hb_ot_shaper_arabic =\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic.cc","additions":46,"deletions":13,"binary":false,"changes":59,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-arabic.cc","status":"renamed"},{"patch":"@@ -29,2 +29,2 @@\n-#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_HH\n-#define HB_OT_SHAPE_COMPLEX_ARABIC_HH\n+#ifndef HB_OT_SHAPER_ARABIC_HH\n+#define HB_OT_SHAPER_ARABIC_HH\n@@ -34,1 +34,1 @@\n-#include \"hb-ot-shape-complex.hh\"\n+#include \"hb-ot-shaper.hh\"\n@@ -50,1 +50,1 @@\n-#endif \/* HB_OT_SHAPE_COMPLEX_ARABIC_HH *\/\n+#endif \/* HB_OT_SHAPER_ARABIC_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-arabic.hh","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-arabic.hh","status":"renamed"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"hb-ot-shape-complex.hh\"\n+#include \"hb-ot-shaper.hh\"\n@@ -34,1 +34,1 @@\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_default =\n+const hb_ot_shaper_t _hb_ot_shaper_default =\n@@ -54,1 +54,1 @@\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_dumber =\n+const hb_ot_shaper_t _hb_ot_shaper_dumber =\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-default.cc","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-default.cc","status":"renamed"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"hb-ot-shape-complex.hh\"\n+#include \"hb-ot-shaper.hh\"\n@@ -83,1 +83,1 @@\n-  hangul_shape_plan_t *hangul_plan = (hangul_shape_plan_t *) calloc (1, sizeof (hangul_shape_plan_t));\n+  hangul_shape_plan_t *hangul_plan = (hangul_shape_plan_t *) hb_calloc (1, sizeof (hangul_shape_plan_t));\n@@ -96,1 +96,1 @@\n-  free (data);\n+  hb_free (data);\n@@ -122,1 +122,1 @@\n-#define hangul_shaping_feature() complex_var_u8_auxiliary() \/* hangul jamo shaping feature *\/\n+#define hangul_shaping_feature() ot_shaper_var_u8_auxiliary() \/* hangul jamo shaping feature *\/\n@@ -143,1 +143,1 @@\n-   *   - LVT can be fully precomposed, partically precomposed, or\n+   *   - LVT can be fully precomposed, partially precomposed, or\n@@ -395,1 +395,1 @@\n-  buffer->swap_buffers ();\n+  buffer->sync ();\n@@ -417,1 +417,1 @@\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_hangul =\n+const hb_ot_shaper_t _hb_ot_shaper_hangul =\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-hangul.cc","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-hangul.cc","status":"renamed"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"hb-ot-shape-complex.hh\"\n+#include \"hb-ot-shaper.hh\"\n@@ -77,1 +77,1 @@\n-#ifdef HB_NO_OT_SHAPE_COMPLEX_HEBREW_FALLBACK\n+#ifdef HB_NO_OT_SHAPER_HEBREW_FALLBACK\n@@ -166,1 +166,1 @@\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_hebrew =\n+const hb_ot_shaper_t _hb_ot_shaper_hebrew =\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-hebrew.cc","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-hebrew.cc","status":"renamed"},{"patch":"@@ -0,0 +1,589 @@\n+\n+#line 1 \"hb-ot-shaper-indic-machine.rl\"\n+\/*\n+ * Copyright  2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_INDIC_MACHINE_HH\n+#define HB_OT_SHAPER_INDIC_MACHINE_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-layout.hh\"\n+#include \"hb-ot-shaper-indic.hh\"\n+\n+\/* buffer var allocations *\/\n+#define indic_category() ot_shaper_var_u8_category() \/* indic_category_t *\/\n+#define indic_position() ot_shaper_var_u8_auxiliary() \/* indic_position_t *\/\n+\n+using indic_category_t = unsigned;\n+using indic_position_t = ot_position_t;\n+\n+#define I_Cat(Cat) indic_syllable_machine_ex_##Cat\n+\n+enum indic_syllable_type_t {\n+  indic_consonant_syllable,\n+  indic_vowel_syllable,\n+  indic_standalone_cluster,\n+  indic_symbol_cluster,\n+  indic_broken_cluster,\n+  indic_non_indic_cluster,\n+};\n+\n+\n+#line 57 \"hb-ot-shaper-indic-machine.hh\"\n+#define indic_syllable_machine_ex_A 9u\n+#define indic_syllable_machine_ex_C 1u\n+#define indic_syllable_machine_ex_CM 16u\n+#define indic_syllable_machine_ex_CS 18u\n+#define indic_syllable_machine_ex_DOTTEDCIRCLE 11u\n+#define indic_syllable_machine_ex_H 4u\n+#define indic_syllable_machine_ex_M 7u\n+#define indic_syllable_machine_ex_N 3u\n+#define indic_syllable_machine_ex_PLACEHOLDER 10u\n+#define indic_syllable_machine_ex_RS 12u\n+#define indic_syllable_machine_ex_Ra 15u\n+#define indic_syllable_machine_ex_Repha 14u\n+#define indic_syllable_machine_ex_SM 8u\n+#define indic_syllable_machine_ex_Symbol 17u\n+#define indic_syllable_machine_ex_V 2u\n+#define indic_syllable_machine_ex_VD 9u\n+#define indic_syllable_machine_ex_X 0u\n+#define indic_syllable_machine_ex_ZWJ 6u\n+#define indic_syllable_machine_ex_ZWNJ 5u\n+\n+\n+#line 79 \"hb-ot-shaper-indic-machine.hh\"\n+static const unsigned char _indic_syllable_machine_trans_keys[] = {\n+        8u, 8u, 4u, 8u, 5u, 7u, 5u, 8u, 4u, 8u, 4u, 12u, 4u, 8u, 8u, 8u,\n+        5u, 7u, 5u, 8u, 4u, 8u, 4u, 12u, 4u, 12u, 4u, 12u, 8u, 8u, 5u, 7u,\n+        5u, 8u, 4u, 8u, 4u, 8u, 4u, 12u, 8u, 8u, 5u, 7u, 5u, 8u, 4u, 8u,\n+        4u, 8u, 5u, 8u, 8u, 8u, 1u, 18u, 3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u,\n+        5u, 9u, 5u, 9u, 9u, 9u, 5u, 9u, 1u, 15u, 1u, 15u, 1u, 15u, 3u, 9u,\n+        4u, 9u, 5u, 9u, 4u, 9u, 5u, 9u, 3u, 9u, 5u, 9u, 3u, 16u, 3u, 16u,\n+        3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u, 3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u,\n+        5u, 9u, 9u, 9u, 5u, 9u, 1u, 15u, 1u, 15u, 3u, 9u, 4u, 9u, 5u, 9u,\n+        4u, 9u, 5u, 9u, 5u, 9u, 3u, 9u, 5u, 9u, 3u, 16u, 3u, 16u, 4u, 8u,\n+        3u, 16u, 3u, 16u, 4u, 16u, 1u, 15u, 3u, 16u, 1u, 15u, 5u, 9u, 9u, 9u,\n+        5u, 9u, 1u, 15u, 1u, 15u, 3u, 9u, 4u, 9u, 5u, 9u, 3u, 16u, 4u, 9u,\n+        5u, 9u, 5u, 9u, 3u, 9u, 5u, 9u, 3u, 16u, 4u, 12u, 4u, 8u, 3u, 16u,\n+        3u, 16u, 4u, 16u, 1u, 15u, 3u, 16u, 1u, 15u, 5u, 9u, 9u, 9u, 5u, 9u,\n+        1u, 15u, 1u, 15u, 3u, 9u, 4u, 9u, 5u, 9u, 3u, 16u, 4u, 9u, 5u, 9u,\n+        5u, 9u, 3u, 9u, 5u, 9u, 1u, 16u, 3u, 16u, 1u, 16u, 4u, 12u, 5u, 9u,\n+        9u, 9u, 5u, 9u, 1u, 15u, 3u, 9u, 5u, 9u, 5u, 9u, 9u, 9u, 5u, 9u,\n+        1u, 15u, 0\n+};\n+\n+static const char _indic_syllable_machine_key_spans[] = {\n+        1, 5, 3, 4, 5, 9, 5, 1,\n+        3, 4, 5, 9, 9, 9, 1, 3,\n+        4, 5, 5, 9, 1, 3, 4, 5,\n+        5, 4, 1, 18, 14, 14, 13, 15,\n+        5, 5, 1, 5, 15, 15, 15, 7,\n+        6, 5, 6, 5, 7, 5, 14, 14,\n+        14, 14, 13, 15, 14, 14, 13, 15,\n+        5, 1, 5, 15, 15, 7, 6, 5,\n+        6, 5, 5, 7, 5, 14, 14, 5,\n+        14, 14, 13, 15, 14, 15, 5, 1,\n+        5, 15, 15, 7, 6, 5, 14, 6,\n+        5, 5, 7, 5, 14, 9, 5, 14,\n+        14, 13, 15, 14, 15, 5, 1, 5,\n+        15, 15, 7, 6, 5, 14, 6, 5,\n+        5, 7, 5, 16, 14, 16, 9, 5,\n+        1, 5, 15, 7, 5, 5, 1, 5,\n+        15\n+};\n+\n+static const short _indic_syllable_machine_index_offsets[] = {\n+        0, 2, 8, 12, 17, 23, 33, 39,\n+        41, 45, 50, 56, 66, 76, 86, 88,\n+        92, 97, 103, 109, 119, 121, 125, 130,\n+        136, 142, 147, 149, 168, 183, 198, 212,\n+        228, 234, 240, 242, 248, 264, 280, 296,\n+        304, 311, 317, 324, 330, 338, 344, 359,\n+        374, 389, 404, 418, 434, 449, 464, 478,\n+        494, 500, 502, 508, 524, 540, 548, 555,\n+        561, 568, 574, 580, 588, 594, 609, 624,\n+        630, 645, 660, 674, 690, 705, 721, 727,\n+        729, 735, 751, 767, 775, 782, 788, 803,\n+        810, 816, 822, 830, 836, 851, 861, 867,\n+        882, 897, 911, 927, 942, 958, 964, 966,\n+        972, 988, 1004, 1012, 1019, 1025, 1040, 1047,\n+        1053, 1059, 1067, 1073, 1090, 1105, 1122, 1132,\n+        1138, 1140, 1146, 1162, 1170, 1176, 1182, 1184,\n+        1190\n+};\n+\n+static const unsigned char _indic_syllable_machine_indicies[] = {\n+        1, 0, 2, 3, 3, 4, 1, 0,\n+        3, 3, 4, 0, 3, 3, 4, 1,\n+        0, 5, 3, 3, 4, 1, 0, 2,\n+        3, 3, 4, 1, 0, 0, 0, 6,\n+        0, 8, 9, 9, 10, 11, 7, 11,\n+        7, 9, 9, 10, 7, 9, 9, 10,\n+        11, 7, 12, 9, 9, 10, 11, 7,\n+        8, 9, 9, 10, 11, 7, 7, 7,\n+        13, 7, 8, 9, 9, 10, 11, 7,\n+        7, 7, 14, 7, 16, 17, 17, 18,\n+        19, 15, 15, 15, 20, 15, 19, 15,\n+        17, 17, 18, 21, 17, 17, 18, 19,\n+        15, 16, 17, 17, 18, 19, 15, 22,\n+        17, 17, 18, 19, 15, 24, 25, 25,\n+        26, 27, 23, 23, 23, 28, 23, 27,\n+        23, 25, 25, 26, 23, 25, 25, 26,\n+        27, 23, 24, 25, 25, 26, 27, 23,\n+        29, 25, 25, 26, 27, 23, 17, 17,\n+        18, 1, 0, 31, 30, 33, 34, 35,\n+        36, 37, 38, 18, 19, 39, 40, 40,\n+        20, 32, 41, 42, 43, 44, 45, 32,\n+        47, 48, 49, 50, 4, 1, 51, 46,\n+        46, 6, 46, 46, 46, 52, 46, 53,\n+        48, 54, 54, 4, 1, 51, 46, 46,\n+        46, 46, 46, 46, 52, 46, 48, 54,\n+        54, 4, 1, 51, 46, 46, 46, 46,\n+        46, 46, 52, 46, 33, 46, 46, 46,\n+        55, 56, 46, 1, 51, 46, 46, 46,\n+        46, 46, 33, 46, 57, 57, 46, 1,\n+        51, 46, 51, 46, 46, 58, 51, 46,\n+        51, 46, 51, 46, 46, 46, 51, 46,\n+        33, 46, 59, 46, 57, 57, 46, 1,\n+        51, 46, 46, 46, 46, 46, 33, 46,\n+        33, 46, 46, 46, 57, 57, 46, 1,\n+        51, 46, 46, 46, 46, 46, 33, 46,\n+        33, 46, 46, 46, 57, 56, 46, 1,\n+        51, 46, 46, 46, 46, 46, 33, 46,\n+        60, 61, 62, 62, 4, 1, 51, 46,\n+        61, 62, 62, 4, 1, 51, 46, 62,\n+        62, 4, 1, 51, 46, 63, 64, 64,\n+        4, 1, 51, 46, 55, 65, 46, 1,\n+        51, 46, 55, 46, 57, 57, 46, 1,\n+        51, 46, 57, 65, 46, 1, 51, 46,\n+        47, 48, 54, 54, 4, 1, 51, 46,\n+        46, 46, 46, 46, 46, 52, 46, 47,\n+        48, 49, 54, 4, 1, 51, 46, 46,\n+        6, 46, 46, 46, 52, 46, 67, 68,\n+        69, 70, 10, 11, 71, 66, 66, 14,\n+        66, 66, 66, 72, 66, 73, 68, 74,\n+        70, 10, 11, 71, 66, 66, 66, 66,\n+        66, 66, 72, 66, 68, 74, 70, 10,\n+        11, 71, 66, 66, 66, 66, 66, 66,\n+        72, 66, 75, 66, 66, 66, 76, 77,\n+        66, 11, 71, 66, 66, 66, 66, 66,\n+        75, 66, 78, 68, 79, 80, 10, 11,\n+        71, 66, 66, 13, 66, 66, 66, 72,\n+        66, 81, 68, 74, 74, 10, 11, 71,\n+        66, 66, 66, 66, 66, 66, 72, 66,\n+        68, 74, 74, 10, 11, 71, 66, 66,\n+        66, 66, 66, 66, 72, 66, 75, 66,\n+        66, 66, 82, 77, 66, 11, 71, 66,\n+        66, 66, 66, 66, 75, 66, 71, 66,\n+        66, 83, 71, 66, 71, 66, 71, 66,\n+        66, 66, 71, 66, 75, 66, 84, 66,\n+        82, 82, 66, 11, 71, 66, 66, 66,\n+        66, 66, 75, 66, 75, 66, 66, 66,\n+        82, 82, 66, 11, 71, 66, 66, 66,\n+        66, 66, 75, 66, 85, 86, 87, 87,\n+        10, 11, 71, 66, 86, 87, 87, 10,\n+        11, 71, 66, 87, 87, 10, 11, 71,\n+        66, 88, 89, 89, 10, 11, 71, 66,\n+        76, 90, 66, 11, 71, 66, 82, 82,\n+        66, 11, 71, 66, 76, 66, 82, 82,\n+        66, 11, 71, 66, 82, 90, 66, 11,\n+        71, 66, 78, 68, 74, 74, 10, 11,\n+        71, 66, 66, 66, 66, 66, 66, 72,\n+        66, 78, 68, 79, 74, 10, 11, 71,\n+        66, 66, 13, 66, 66, 66, 72, 66,\n+        8, 9, 9, 10, 11, 66, 67, 68,\n+        74, 70, 10, 11, 71, 66, 66, 66,\n+        66, 66, 66, 72, 66, 92, 36, 93,\n+        93, 18, 19, 39, 91, 91, 91, 91,\n+        91, 91, 43, 91, 36, 93, 93, 18,\n+        19, 39, 91, 91, 91, 91, 91, 91,\n+        43, 91, 94, 91, 91, 91, 95, 96,\n+        91, 19, 39, 91, 91, 91, 91, 91,\n+        94, 91, 35, 36, 97, 98, 18, 19,\n+        39, 91, 91, 20, 91, 91, 91, 43,\n+        91, 94, 91, 91, 91, 99, 96, 91,\n+        19, 39, 91, 91, 91, 91, 91, 94,\n+        91, 39, 91, 91, 100, 39, 91, 39,\n+        91, 39, 91, 91, 91, 39, 91, 94,\n+        91, 101, 91, 99, 99, 91, 19, 39,\n+        91, 91, 91, 91, 91, 94, 91, 94,\n+        91, 91, 91, 99, 99, 91, 19, 39,\n+        91, 91, 91, 91, 91, 94, 91, 102,\n+        103, 104, 104, 18, 19, 39, 91, 103,\n+        104, 104, 18, 19, 39, 91, 104, 104,\n+        18, 19, 39, 91, 35, 36, 93, 93,\n+        18, 19, 39, 91, 91, 91, 91, 91,\n+        91, 43, 91, 105, 106, 106, 18, 19,\n+        39, 91, 95, 107, 91, 19, 39, 91,\n+        99, 99, 91, 19, 39, 91, 95, 91,\n+        99, 99, 91, 19, 39, 91, 99, 107,\n+        91, 19, 39, 91, 35, 36, 97, 93,\n+        18, 19, 39, 91, 91, 20, 91, 91,\n+        91, 43, 91, 16, 17, 17, 18, 19,\n+        108, 108, 108, 20, 108, 16, 17, 17,\n+        18, 19, 108, 110, 111, 112, 113, 26,\n+        27, 114, 109, 109, 28, 109, 109, 109,\n+        115, 109, 116, 111, 113, 113, 26, 27,\n+        114, 109, 109, 109, 109, 109, 109, 115,\n+        109, 111, 113, 113, 26, 27, 114, 109,\n+        109, 109, 109, 109, 109, 115, 109, 117,\n+        109, 109, 109, 118, 119, 109, 27, 114,\n+        109, 109, 109, 109, 109, 117, 109, 110,\n+        111, 112, 40, 26, 27, 114, 109, 109,\n+        28, 109, 109, 109, 115, 109, 117, 109,\n+        109, 109, 120, 119, 109, 27, 114, 109,\n+        109, 109, 109, 109, 117, 109, 114, 109,\n+        109, 121, 114, 109, 114, 109, 114, 109,\n+        109, 109, 114, 109, 117, 109, 122, 109,\n+        120, 120, 109, 27, 114, 109, 109, 109,\n+        109, 109, 117, 109, 117, 109, 109, 109,\n+        120, 120, 109, 27, 114, 109, 109, 109,\n+        109, 109, 117, 109, 123, 124, 125, 125,\n+        26, 27, 114, 109, 124, 125, 125, 26,\n+        27, 114, 109, 125, 125, 26, 27, 114,\n+        109, 110, 111, 113, 113, 26, 27, 114,\n+        109, 109, 109, 109, 109, 109, 115, 109,\n+        126, 127, 127, 26, 27, 114, 109, 118,\n+        128, 109, 27, 114, 109, 120, 120, 109,\n+        27, 114, 109, 118, 109, 120, 120, 109,\n+        27, 114, 109, 120, 128, 109, 27, 114,\n+        109, 33, 34, 35, 36, 97, 93, 18,\n+        19, 39, 40, 40, 20, 91, 91, 33,\n+        43, 91, 47, 129, 49, 50, 4, 1,\n+        51, 46, 46, 6, 46, 46, 46, 52,\n+        46, 33, 34, 35, 36, 130, 131, 18,\n+        132, 133, 46, 40, 20, 46, 46, 33,\n+        43, 46, 16, 134, 134, 18, 132, 51,\n+        46, 46, 20, 46, 133, 46, 46, 135,\n+        133, 46, 133, 46, 133, 46, 46, 46,\n+        133, 46, 33, 46, 59, 16, 134, 134,\n+        18, 132, 51, 46, 46, 46, 46, 46,\n+        33, 46, 137, 136, 138, 138, 136, 31,\n+        139, 136, 138, 138, 136, 31, 139, 136,\n+        139, 136, 136, 140, 139, 136, 139, 136,\n+        139, 136, 136, 136, 139, 136, 33, 108,\n+        108, 108, 108, 108, 108, 108, 108, 40,\n+        108, 108, 108, 108, 33, 108, 0\n+};\n+\n+static const unsigned char _indic_syllable_machine_trans_targs[] = {\n+        27, 33, 38, 2, 39, 45, 46, 27,\n+        55, 8, 61, 56, 68, 69, 72, 27,\n+        77, 15, 83, 78, 86, 27, 91, 27,\n+        100, 21, 106, 101, 109, 114, 27, 125,\n+        27, 28, 48, 73, 75, 93, 94, 79,\n+        95, 115, 116, 87, 123, 128, 27, 29,\n+        31, 5, 47, 34, 42, 30, 1, 32,\n+        36, 0, 35, 37, 40, 41, 3, 43,\n+        4, 44, 27, 49, 51, 12, 71, 57,\n+        64, 50, 6, 52, 66, 59, 53, 11,\n+        70, 54, 7, 58, 60, 62, 63, 9,\n+        65, 10, 67, 27, 74, 17, 76, 89,\n+        81, 13, 92, 14, 80, 82, 84, 85,\n+        16, 88, 18, 90, 27, 27, 96, 98,\n+        19, 23, 102, 110, 97, 99, 112, 104,\n+        20, 103, 105, 107, 108, 22, 111, 24,\n+        113, 117, 118, 122, 119, 120, 25, 121,\n+        27, 124, 26, 126, 127\n+};\n+\n+static const char _indic_syllable_machine_trans_actions[] = {\n+        1, 0, 2, 0, 2, 2, 2, 3,\n+        2, 0, 2, 0, 2, 2, 2, 4,\n+        2, 0, 5, 0, 5, 6, 2, 7,\n+        2, 0, 2, 0, 2, 2, 8, 0,\n+        11, 2, 2, 5, 0, 12, 12, 0,\n+        2, 5, 2, 5, 2, 0, 13, 2,\n+        0, 0, 2, 0, 2, 2, 0, 2,\n+        2, 0, 0, 2, 2, 2, 0, 0,\n+        0, 2, 14, 2, 0, 0, 2, 0,\n+        2, 2, 0, 2, 2, 2, 2, 0,\n+        2, 2, 0, 0, 2, 2, 2, 0,\n+        0, 0, 2, 15, 5, 0, 5, 2,\n+        2, 0, 5, 0, 0, 2, 5, 5,\n+        0, 0, 0, 2, 16, 17, 2, 0,\n+        0, 0, 0, 2, 2, 2, 2, 2,\n+        0, 0, 2, 2, 2, 0, 0, 0,\n+        2, 0, 18, 18, 0, 0, 0, 0,\n+        19, 2, 0, 0, 0\n+};\n+\n+static const char _indic_syllable_machine_to_state_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 9, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0\n+};\n+\n+static const char _indic_syllable_machine_from_state_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 10, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0\n+};\n+\n+static const short _indic_syllable_machine_eof_trans[] = {\n+        1, 1, 1, 1, 1, 1, 8, 8,\n+        8, 8, 8, 8, 8, 16, 16, 22,\n+        16, 16, 16, 24, 24, 24, 24, 24,\n+        24, 1, 31, 0, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        67, 67, 67, 67, 67, 67, 67, 67,\n+        67, 67, 67, 67, 67, 67, 67, 67,\n+        67, 67, 67, 67, 67, 67, 67, 67,\n+        67, 92, 92, 92, 92, 92, 92, 92,\n+        92, 92, 92, 92, 92, 92, 92, 92,\n+        92, 92, 92, 92, 92, 109, 109, 110,\n+        110, 110, 110, 110, 110, 110, 110, 110,\n+        110, 110, 110, 110, 110, 110, 110, 110,\n+        110, 110, 110, 92, 47, 47, 47, 47,\n+        47, 47, 47, 137, 137, 137, 137, 137,\n+        109\n+};\n+\n+static const int indic_syllable_machine_start = 27;\n+static const int indic_syllable_machine_first_final = 27;\n+static const int indic_syllable_machine_error = -1;\n+\n+static const int indic_syllable_machine_en_main = 27;\n+\n+\n+#line 58 \"hb-ot-shaper-indic-machine.rl\"\n+\n+\n+\n+#line 117 \"hb-ot-shaper-indic-machine.rl\"\n+\n+\n+#define found_syllable(syllable_type) \\\n+  HB_STMT_START { \\\n+    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    for (unsigned int i = ts; i < te; i++) \\\n+      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n+    syllable_serial++; \\\n+    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+  } HB_STMT_END\n+\n+inline void\n+find_syllables_indic (hb_buffer_t *buffer)\n+{\n+  unsigned int p, pe, eof, ts, te, act;\n+  int cs;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+#line 426 \"hb-ot-shaper-indic-machine.hh\"\n+        {\n+        cs = indic_syllable_machine_start;\n+        ts = 0;\n+        te = 0;\n+        act = 0;\n+        }\n+\n+#line 137 \"hb-ot-shaper-indic-machine.rl\"\n+\n+\n+  p = 0;\n+  pe = eof = buffer->len;\n+\n+  unsigned int syllable_serial = 1;\n+\n+#line 442 \"hb-ot-shaper-indic-machine.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const unsigned char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+_resume:\n+        switch ( _indic_syllable_machine_from_state_actions[cs] ) {\n+        case 10:\n+#line 1 \"NONE\"\n+        {ts = p;}\n+        break;\n+#line 456 \"hb-ot-shaper-indic-machine.hh\"\n+        }\n+\n+        _keys = _indic_syllable_machine_trans_keys + (cs<<1);\n+        _inds = _indic_syllable_machine_indicies + _indic_syllable_machine_index_offsets[cs];\n+\n+        _slen = _indic_syllable_machine_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=( info[p].indic_category()) &&\n+                ( info[p].indic_category()) <= _keys[1] ?\n+                ( info[p].indic_category()) - _keys[0] : _slen ];\n+\n+_eof_trans:\n+        cs = _indic_syllable_machine_trans_targs[_trans];\n+\n+        if ( _indic_syllable_machine_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _indic_syllable_machine_trans_actions[_trans] ) {\n+        case 2:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+        break;\n+        case 11:\n+#line 113 \"hb-ot-shaper-indic-machine.rl\"\n+        {te = p+1;{ found_syllable (indic_non_indic_cluster); }}\n+        break;\n+        case 13:\n+#line 108 \"hb-ot-shaper-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (indic_consonant_syllable); }}\n+        break;\n+        case 14:\n+#line 109 \"hb-ot-shaper-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (indic_vowel_syllable); }}\n+        break;\n+        case 17:\n+#line 110 \"hb-ot-shaper-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (indic_standalone_cluster); }}\n+        break;\n+        case 19:\n+#line 111 \"hb-ot-shaper-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (indic_symbol_cluster); }}\n+        break;\n+        case 15:\n+#line 112 \"hb-ot-shaper-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (indic_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }}\n+        break;\n+        case 16:\n+#line 113 \"hb-ot-shaper-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (indic_non_indic_cluster); }}\n+        break;\n+        case 1:\n+#line 108 \"hb-ot-shaper-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (indic_consonant_syllable); }}\n+        break;\n+        case 3:\n+#line 109 \"hb-ot-shaper-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (indic_vowel_syllable); }}\n+        break;\n+        case 7:\n+#line 110 \"hb-ot-shaper-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (indic_standalone_cluster); }}\n+        break;\n+        case 8:\n+#line 111 \"hb-ot-shaper-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (indic_symbol_cluster); }}\n+        break;\n+        case 4:\n+#line 112 \"hb-ot-shaper-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (indic_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }}\n+        break;\n+        case 6:\n+#line 1 \"NONE\"\n+        {       switch( act ) {\n+        case 1:\n+        {{p = ((te))-1;} found_syllable (indic_consonant_syllable); }\n+        break;\n+        case 5:\n+        {{p = ((te))-1;} found_syllable (indic_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }\n+        break;\n+        case 6:\n+        {{p = ((te))-1;} found_syllable (indic_non_indic_cluster); }\n+        break;\n+        }\n+        }\n+        break;\n+        case 18:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 108 \"hb-ot-shaper-indic-machine.rl\"\n+        {act = 1;}\n+        break;\n+        case 5:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 112 \"hb-ot-shaper-indic-machine.rl\"\n+        {act = 5;}\n+        break;\n+        case 12:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 113 \"hb-ot-shaper-indic-machine.rl\"\n+        {act = 6;}\n+        break;\n+#line 559 \"hb-ot-shaper-indic-machine.hh\"\n+        }\n+\n+_again:\n+        switch ( _indic_syllable_machine_to_state_actions[cs] ) {\n+        case 9:\n+#line 1 \"NONE\"\n+        {ts = 0;}\n+        break;\n+#line 568 \"hb-ot-shaper-indic-machine.hh\"\n+        }\n+\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        if ( _indic_syllable_machine_eof_trans[cs] > 0 ) {\n+                _trans = _indic_syllable_machine_eof_trans[cs] - 1;\n+                goto _eof_trans;\n+        }\n+        }\n+\n+        }\n+\n+#line 145 \"hb-ot-shaper-indic-machine.rl\"\n+\n+}\n+\n+#undef found_syllable\n+\n+#endif \/* HB_OT_SHAPER_INDIC_MACHINE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic-machine.hh","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"},{"patch":"@@ -0,0 +1,560 @@\n+\/* == Start of generated table == *\/\n+\/*\n+ * The following table is generated by running:\n+ *\n+ *   .\/gen-indic-table.py IndicSyllabicCategory.txt IndicPositionalCategory.txt Blocks.txt\n+ *\n+ * on files with these headers:\n+ *\n+ * # IndicSyllabicCategory-14.0.0.txt\n+ * # Date: 2021-05-22, 01:01:00 GMT [KW, RP]\n+ * # IndicPositionalCategory-14.0.0.txt\n+ * # Date: 2021-05-22, 01:01:00 GMT [KW, RP]\n+ * # Blocks-14.0.0.txt\n+ * # Date: 2021-01-22, 23:29:00 GMT [KW]\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_OT_SHAPE\n+\n+#include \"hb-ot-shaper-indic.hh\"\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-macros\"\n+\n+#include \"hb-ot-shaper-indic-machine.hh\"\n+#include \"hb-ot-shaper-khmer-machine.hh\"\n+#include \"hb-ot-shaper-myanmar-machine.hh\"\n+\n+\/* indic *\/\n+#define OT_X I_Cat(X)\n+#define OT_C I_Cat(C)\n+#define OT_V I_Cat(V)\n+#define OT_N I_Cat(N)\n+#define OT_H I_Cat(H)\n+#define OT_ZWNJ I_Cat(ZWNJ)\n+#define OT_ZWJ I_Cat(ZWJ)\n+#define OT_M I_Cat(M)\n+#define OT_SM I_Cat(SM)\n+#define OT_A I_Cat(A)\n+#define OT_VD I_Cat(VD)\n+#define OT_PLACEHOLDER I_Cat(PLACEHOLDER)\n+#define OT_DOTTEDCIRCLE I_Cat(DOTTEDCIRCLE)\n+#define OT_RS I_Cat(RS)\n+#define OT_Repha I_Cat(Repha)\n+#define OT_Ra I_Cat(Ra)\n+#define OT_CM I_Cat(CM)\n+#define OT_Symbol I_Cat(Symbol)\n+#define OT_CS I_Cat(CS)\n+\/* khmer *\/\n+#define OT_VAbv K_Cat(VAbv)\n+#define OT_VBlw K_Cat(VBlw)\n+#define OT_VPre K_Cat(VPre)\n+#define OT_VPst K_Cat(VPst)\n+#define OT_Robatic K_Cat(Robatic)\n+#define OT_Xgroup K_Cat(Xgroup)\n+#define OT_Ygroup K_Cat(Ygroup)\n+\/* myanmar *\/\n+static_assert (OT_VAbv == M_Cat(VAbv), \"\");\n+static_assert (OT_VBlw == M_Cat(VBlw), \"\");\n+static_assert (OT_VPre == M_Cat(VPre), \"\");\n+static_assert (OT_VPst == M_Cat(VPst), \"\");\n+#define OT_IV M_Cat(IV)\n+#define OT_As M_Cat(As)\n+#define OT_DB M_Cat(DB)\n+#define OT_GB M_Cat(GB)\n+#define OT_MH M_Cat(MH)\n+#define OT_MR M_Cat(MR)\n+#define OT_MW M_Cat(MW)\n+#define OT_MY M_Cat(MY)\n+#define OT_PT M_Cat(PT)\n+#define OT_VS M_Cat(VS)\n+#define OT_ML M_Cat(ML)\n+\n+\n+#define _OT_A    OT_A            \/*  53 chars; A *\/\n+#define _OT_As   OT_As           \/*   1 chars; As *\/\n+#define _OT_C    OT_C            \/* 478 chars; C *\/\n+#define _OT_CM   OT_CM           \/*   1 chars; CM *\/\n+#define _OT_CS   OT_CS           \/*   2 chars; CS *\/\n+#define _OT_DC   OT_DOTTEDCIRCLE \/*   1 chars; DOTTEDCIRCLE *\/\n+#define _OT_H    OT_H            \/*  11 chars; H *\/\n+#define _OT_M    OT_M            \/* 143 chars; M *\/\n+#define _OT_MH   OT_MH           \/*   1 chars; MH *\/\n+#define _OT_ML   OT_ML           \/*   1 chars; ML *\/\n+#define _OT_MR   OT_MR           \/*   1 chars; MR *\/\n+#define _OT_MW   OT_MW           \/*   2 chars; MW *\/\n+#define _OT_MY   OT_MY           \/*   3 chars; MY *\/\n+#define _OT_N    OT_N            \/*  17 chars; N *\/\n+#define _OT_GB   OT_PLACEHOLDER  \/* 165 chars; PLACEHOLDER *\/\n+#define _OT_PT   OT_PT           \/*   8 chars; PT *\/\n+#define _OT_R    OT_Ra           \/*  14 chars; Ra *\/\n+#define _OT_Rf   OT_Repha        \/*   1 chars; Repha *\/\n+#define _OT_Rt   OT_Robatic      \/*   3 chars; Robatic *\/\n+#define _OT_SM   OT_SM           \/*  55 chars; SM *\/\n+#define _OT_S    OT_Symbol       \/*  22 chars; Symbol *\/\n+#define _OT_V    OT_V            \/* 172 chars; V *\/\n+#define _OT_VA   OT_VAbv         \/*  18 chars; VAbv *\/\n+#define _OT_VB   OT_VBlw         \/*   7 chars; VBlw *\/\n+#define _OT_VL   OT_VPre         \/*   5 chars; VPre *\/\n+#define _OT_VR   OT_VPst         \/*  13 chars; VPst *\/\n+#define _OT_VS   OT_VS           \/*  16 chars; VS *\/\n+#define _OT_X    OT_X            \/*   2 chars; X *\/\n+#define _OT_Xg   OT_Xgroup       \/*   7 chars; Xgroup *\/\n+#define _OT_Yg   OT_Ygroup       \/*   4 chars; Ygroup *\/\n+#define _OT_ZWJ  OT_ZWJ          \/*   1 chars; ZWJ *\/\n+#define _OT_ZWNJ OT_ZWNJ         \/*   1 chars; ZWNJ *\/\n+\n+#define _POS_T   POS_ABOVE_C     \/*  22 chars; ABOVE_C *\/\n+#define _POS_A   POS_AFTER_MAIN  \/*   3 chars; AFTER_MAIN *\/\n+#define _POS_AP  POS_AFTER_POST  \/*  50 chars; AFTER_POST *\/\n+#define _POS_AS  POS_AFTER_SUB   \/*  51 chars; AFTER_SUB *\/\n+#define _POS_C   POS_BASE_C      \/* 833 chars; BASE_C *\/\n+#define _POS_BS  POS_BEFORE_SUB  \/*  25 chars; BEFORE_SUB *\/\n+#define _POS_B   POS_BELOW_C     \/*  13 chars; BELOW_C *\/\n+#define _POS_X   POS_END         \/*  71 chars; END *\/\n+#define _POS_R   POS_POST_C      \/*  13 chars; POST_C *\/\n+#define _POS_L   POS_PRE_C       \/*   5 chars; PRE_C *\/\n+#define _POS_LM  POS_PRE_M       \/*  14 chars; PRE_M *\/\n+#define _POS_SM  POS_SMVD        \/* 129 chars; SMVD *\/\n+\n+#pragma GCC diagnostic pop\n+\n+#define INDIC_COMBINE_CATEGORIES(S,M) ((S) | ((M) << 8))\n+\n+#define _(S,M) INDIC_COMBINE_CATEGORIES (_OT_##S, _POS_##M)\n+\n+\n+static const uint16_t indic_table[] = {\n+\n+\n+#define indic_offset_0x0028u 0\n+\n+\n+  \/* Basic Latin *\/\n+\n+  \/* 0028 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(GB,C),  _(X,X),  _(X,X),\n+  \/* 0030 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 0038 *\/ _(GB,C), _(GB,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+#define indic_offset_0x00b0u 24\n+\n+\n+  \/* Latin-1 Supplement *\/\n+\n+  \/* 00B0 *\/  _(X,X),  _(X,X),_(SM,SM),_(SM,SM),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 00B8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 00C0 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 00C8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 00D0 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(GB,C),\n+\n+#define indic_offset_0x0900u 64\n+\n+\n+  \/* Devanagari *\/\n+\n+  \/* 0900 *\/_(SM,SM),_(SM,SM),_(SM,SM),_(SM,SM),  _(V,C),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0908 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0910 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0918 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0920 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0928 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0930 *\/  _(R,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0938 *\/  _(C,C),  _(C,C), _(M,AS), _(M,AS),  _(N,X), _(S,SM), _(M,AS), _(M,LM),\n+  \/* 0940 *\/ _(M,AS), _(M,AS), _(M,AS), _(M,AS), _(M,AS), _(M,AS), _(M,AS), _(M,AS),\n+  \/* 0948 *\/ _(M,AS), _(M,AS), _(M,AS), _(M,AS), _(M,AS),  _(H,B), _(M,LM), _(M,AS),\n+  \/* 0950 *\/  _(X,X), _(A,SM), _(A,SM),_(SM,SM),_(SM,SM), _(M,AS), _(M,AS), _(M,AS),\n+  \/* 0958 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0960 *\/  _(V,C),  _(V,C), _(M,AS), _(M,AS),  _(X,X),  _(X,X), _(GB,C), _(GB,C),\n+  \/* 0968 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 0970 *\/  _(X,X),  _(X,X),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0978 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+\n+  \/* Bengali *\/\n+\n+  \/* 0980 *\/ _(GB,C),_(SM,SM),_(SM,SM),_(SM,SM),  _(X,X),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0988 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(X,X),  _(X,X),  _(V,C),\n+  \/* 0990 *\/  _(V,C),  _(X,X),  _(X,X),  _(V,C),  _(V,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0998 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 09A0 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 09A8 *\/  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 09B0 *\/  _(R,C),  _(X,X),  _(C,C),  _(X,X),  _(X,X),  _(X,X),  _(C,C),  _(C,C),\n+  \/* 09B8 *\/  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(N,X), _(S,SM), _(M,AP), _(M,LM),\n+  \/* 09C0 *\/ _(M,AP), _(M,AS), _(M,AS), _(M,AS), _(M,AS),  _(X,X),  _(X,X), _(M,LM),\n+  \/* 09C8 *\/ _(M,LM),  _(X,X),  _(X,X), _(M,AP), _(M,AP),  _(H,B),  _(C,C),  _(X,X),\n+  \/* 09D0 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(M,AP),\n+  \/* 09D8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(C,C),  _(C,C),  _(X,X),  _(C,C),\n+  \/* 09E0 *\/  _(V,C),  _(V,C), _(M,AS), _(M,AS),  _(X,X),  _(X,X), _(GB,C), _(GB,C),\n+  \/* 09E8 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 09F0 *\/  _(R,C),  _(C,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 09F8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(GB,C),  _(X,X),_(SM,SM),  _(X,X),\n+\n+  \/* Gurmukhi *\/\n+\n+  \/* 0A00 *\/  _(X,X),_(SM,SM),_(SM,SM),_(SM,SM),  _(X,X),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0A08 *\/  _(V,C),  _(V,C),  _(V,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(V,C),\n+  \/* 0A10 *\/  _(V,C),  _(X,X),  _(X,X),  _(V,C),  _(V,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0A18 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0A20 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0A28 *\/  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0A30 *\/  _(R,C),  _(X,X),  _(C,C),  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(X,X),\n+  \/* 0A38 *\/  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(N,X),  _(X,X), _(M,AP), _(M,LM),\n+  \/* 0A40 *\/ _(M,AP), _(M,AP), _(M,AP),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(M,AP),\n+  \/* 0A48 *\/ _(M,AP),  _(X,X),  _(X,X), _(M,AP), _(M,AP),  _(H,B),  _(X,X),  _(X,X),\n+  \/* 0A50 *\/  _(X,X),  _(M,B),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0A58 *\/  _(X,X),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(X,X),  _(C,C),  _(X,X),\n+  \/* 0A60 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(GB,C), _(GB,C),\n+  \/* 0A68 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 0A70 *\/_(SM,SM),_(SM,SM),  _(C,C),  _(C,C),  _(X,X), _(CM,C),  _(X,X),  _(X,X),\n+  \/* 0A78 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+  \/* Gujarati *\/\n+\n+  \/* 0A80 *\/  _(X,X),_(SM,SM),_(SM,SM),_(SM,SM),  _(X,X),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0A88 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(X,X),  _(V,C),\n+  \/* 0A90 *\/  _(V,C),  _(V,C),  _(X,X),  _(V,C),  _(V,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0A98 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0AA0 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0AA8 *\/  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0AB0 *\/  _(R,C),  _(X,X),  _(C,C),  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0AB8 *\/  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(N,X), _(S,SM), _(M,AP), _(M,LM),\n+  \/* 0AC0 *\/ _(M,AP), _(M,AP), _(M,AP), _(M,AP), _(M,AP), _(M,AS),  _(X,X), _(M,AS),\n+  \/* 0AC8 *\/ _(M,AS), _(M,AP),  _(X,X), _(M,AP), _(M,AP),  _(H,B),  _(X,X),  _(X,X),\n+  \/* 0AD0 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0AD8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0AE0 *\/  _(V,C),  _(V,C), _(M,AP), _(M,AP),  _(X,X),  _(X,X), _(GB,C), _(GB,C),\n+  \/* 0AE8 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 0AF0 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0AF8 *\/  _(X,X),  _(C,C), _(A,SM),  _(N,X), _(A,SM),  _(N,X),  _(N,X),  _(N,X),\n+\n+  \/* Oriya *\/\n+\n+  \/* 0B00 *\/  _(X,X),_(SM,BS),_(SM,SM),_(SM,SM),  _(X,X),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0B08 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(X,X),  _(X,X),  _(V,C),\n+  \/* 0B10 *\/  _(V,C),  _(X,X),  _(X,X),  _(V,C),  _(V,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0B18 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0B20 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0B28 *\/  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0B30 *\/  _(R,C),  _(X,X),  _(C,C),  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0B38 *\/  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(N,X), _(S,SM), _(M,AP),  _(M,A),\n+  \/* 0B40 *\/ _(M,AP), _(M,AS), _(M,AS), _(M,AS), _(M,AS),  _(X,X),  _(X,X), _(M,LM),\n+  \/* 0B48 *\/  _(M,A),  _(X,X),  _(X,X), _(M,AP), _(M,AP),  _(H,B),  _(X,X),  _(X,X),\n+  \/* 0B50 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(N,X),  _(M,A), _(M,AP),\n+  \/* 0B58 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(C,C),  _(C,C),  _(X,X),  _(C,C),\n+  \/* 0B60 *\/  _(V,C),  _(V,C), _(M,AS), _(M,AS),  _(X,X),  _(X,X), _(GB,C), _(GB,C),\n+  \/* 0B68 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 0B70 *\/  _(X,X),  _(C,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0B78 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+  \/* Tamil *\/\n+\n+  \/* 0B80 *\/  _(X,X),  _(X,X),_(SM,SM),  _(X,X),  _(X,X),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0B88 *\/  _(V,C),  _(V,C),  _(V,C),  _(X,X),  _(X,X),  _(X,X),  _(V,C),  _(V,C),\n+  \/* 0B90 *\/  _(V,C),  _(X,X),  _(V,C),  _(V,C),  _(V,C),  _(C,C),  _(X,X),  _(X,X),\n+  \/* 0B98 *\/  _(X,X),  _(C,C),  _(C,C),  _(X,X),  _(C,C),  _(X,X),  _(C,C),  _(C,C),\n+  \/* 0BA0 *\/  _(X,X),  _(X,X),  _(X,X),  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0BA8 *\/  _(C,C),  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(X,X),  _(C,C),  _(C,C),\n+  \/* 0BB0 *\/  _(R,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0BB8 *\/  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(M,AP), _(M,AP),\n+  \/* 0BC0 *\/ _(M,AS), _(M,AP), _(M,AP),  _(X,X),  _(X,X),  _(X,X), _(M,LM), _(M,LM),\n+  \/* 0BC8 *\/ _(M,LM),  _(X,X), _(M,AP), _(M,AP), _(M,AP),  _(H,T),  _(X,X),  _(X,X),\n+  \/* 0BD0 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(M,AP),\n+  \/* 0BD8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0BE0 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(GB,C), _(GB,C),\n+  \/* 0BE8 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 0BF0 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0BF8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+  \/* Telugu *\/\n+\n+  \/* 0C00 *\/_(SM,SM),_(SM,SM),_(SM,SM),_(SM,SM),_(SM,SM),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0C08 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(X,X),  _(V,C),  _(V,C),\n+  \/* 0C10 *\/  _(V,C),  _(X,X),  _(V,C),  _(V,C),  _(V,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0C18 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0C20 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0C28 *\/  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0C30 *\/  _(R,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0C38 *\/  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(N,X), _(S,SM), _(M,BS), _(M,BS),\n+  \/* 0C40 *\/ _(M,BS), _(M,BS), _(M,BS), _(M,AS), _(M,AS),  _(X,X), _(M,BS), _(M,BS),\n+  \/* 0C48 *\/ _(M,BS),  _(X,X), _(M,BS), _(M,BS), _(M,BS),  _(H,T),  _(X,X),  _(X,X),\n+  \/* 0C50 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(M,BS), _(M,BS),  _(X,X),\n+  \/* 0C58 *\/  _(C,C),  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(C,C),  _(X,X),  _(X,X),\n+  \/* 0C60 *\/  _(V,C),  _(V,C), _(M,BS), _(M,BS),  _(X,X),  _(X,X), _(GB,C), _(GB,C),\n+  \/* 0C68 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 0C70 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0C78 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+  \/* Kannada *\/\n+\n+  \/* 0C80 *\/ _(GB,C),_(SM,SM),_(SM,SM),_(SM,SM),  _(X,X),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0C88 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(X,X),  _(V,C),  _(V,C),\n+  \/* 0C90 *\/  _(V,C),  _(X,X),  _(V,C),  _(V,C),  _(V,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0C98 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0CA0 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0CA8 *\/  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0CB0 *\/  _(R,C),  _(C,C),  _(C,C),  _(C,C),  _(X,X),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0CB8 *\/  _(C,C),  _(C,C),  _(X,X),  _(X,X),  _(N,X), _(S,SM), _(M,BS), _(M,BS),\n+  \/* 0CC0 *\/ _(M,BS), _(M,BS), _(M,BS), _(M,AS), _(M,AS),  _(X,X), _(M,BS), _(M,AS),\n+  \/* 0CC8 *\/ _(M,AS),  _(X,X), _(M,AS), _(M,AS), _(M,BS),  _(H,T),  _(X,X),  _(X,X),\n+  \/* 0CD0 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X), _(M,AS), _(M,AS),  _(X,X),\n+  \/* 0CD8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(C,C),  _(C,C),  _(X,X),\n+  \/* 0CE0 *\/  _(V,C),  _(V,C), _(M,BS), _(M,BS),  _(X,X),  _(X,X), _(GB,C), _(GB,C),\n+  \/* 0CE8 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 0CF0 *\/  _(X,X), _(CS,C), _(CS,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0CF8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+  \/* Malayalam *\/\n+\n+  \/* 0D00 *\/_(SM,SM),_(SM,SM),_(SM,SM),_(SM,SM), _(GB,C),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 0D08 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(X,X),  _(V,C),  _(V,C),\n+  \/* 0D10 *\/  _(V,C),  _(X,X),  _(V,C),  _(V,C),  _(V,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0D18 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0D20 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0D28 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0D30 *\/  _(R,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 0D38 *\/  _(C,C),  _(C,C),  _(C,C), _(M,AS), _(M,AS), _(S,SM), _(M,AP), _(M,AP),\n+  \/* 0D40 *\/ _(M,AP), _(M,AP), _(M,AP), _(M,AP), _(M,AP),  _(X,X), _(M,LM), _(M,LM),\n+  \/* 0D48 *\/ _(M,LM),  _(X,X), _(M,AP), _(M,AP), _(M,AP),  _(H,T), _(Rf,X),  _(X,X),\n+  \/* 0D50 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(C,C),  _(C,C),  _(C,C), _(M,AP),\n+  \/* 0D58 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(V,C),\n+  \/* 0D60 *\/  _(V,C),  _(V,C), _(M,AP), _(M,AP),  _(X,X),  _(X,X), _(GB,C), _(GB,C),\n+  \/* 0D68 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 0D70 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 0D78 *\/  _(X,X),  _(X,X),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+\n+#define indic_offset_0x1000u 1216\n+\n+\n+  \/* Myanmar *\/\n+\n+  \/* 1000 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(R,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 1008 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 1010 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 1018 *\/  _(C,C),  _(C,C),  _(C,C),  _(R,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 1020 *\/  _(C,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 1028 *\/  _(V,C),  _(V,C),  _(V,C), _(VR,R), _(VR,R), _(VA,T), _(VA,T), _(VB,B),\n+  \/* 1030 *\/ _(VB,B), _(VL,L), _(A,SM), _(VA,T), _(VA,T), _(VA,T), _(A,SM),  _(N,X),\n+  \/* 1038 *\/_(SM,SM),  _(H,X), _(As,X), _(MY,X), _(MR,X), _(MW,X), _(MH,X),  _(C,C),\n+  \/* 1040 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 1048 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C),  _(X,X),  _(X,X),  _(C,C),  _(X,X),\n+  \/* 1050 *\/  _(C,C),  _(C,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C), _(VR,R), _(VR,R),\n+  \/* 1058 *\/ _(VB,B), _(VB,B),  _(R,C),  _(C,C),  _(C,C),  _(C,C), _(MY,X), _(MY,X),\n+  \/* 1060 *\/ _(ML,X),  _(C,C), _(VR,R), _(PT,X), _(PT,X),  _(C,C),  _(C,C), _(VR,R),\n+  \/* 1068 *\/ _(VR,R), _(PT,X), _(PT,X), _(PT,X), _(PT,X), _(PT,X),  _(C,C),  _(C,C),\n+  \/* 1070 *\/  _(C,C), _(VA,T), _(VA,T), _(VA,T), _(VA,T),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 1078 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 1080 *\/  _(C,C),  _(C,C), _(MW,X), _(VR,R), _(VL,L), _(VA,T), _(VA,T),_(SM,SM),\n+  \/* 1088 *\/_(SM,SM),_(SM,SM),_(SM,SM),_(SM,SM),_(SM,SM),_(SM,SM),  _(C,C),_(SM,SM),\n+  \/* 1090 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 1098 *\/ _(GB,C), _(GB,C),_(SM,SM),_(SM,SM),_(SM,SM), _(VA,T),  _(X,X),  _(X,X),\n+\n+#define indic_offset_0x1780u 1376\n+\n+\n+  \/* Khmer *\/\n+\n+  \/* 1780 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 1788 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 1790 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 1798 *\/  _(C,C),  _(C,C),  _(R,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* 17A0 *\/  _(C,C),  _(C,C),  _(C,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 17A8 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(V,C),\n+  \/* 17B0 *\/  _(V,C),  _(V,C),  _(V,C),  _(V,C),  _(X,X),  _(X,X), _(VR,R), _(VA,T),\n+  \/* 17B8 *\/ _(VA,T), _(VA,T), _(VA,T), _(VB,B), _(VB,B), _(VB,B), _(VA,T), _(VR,R),\n+  \/* 17C0 *\/ _(VR,R), _(VL,L), _(VL,L), _(VL,L), _(VR,R), _(VR,R), _(Xg,X), _(Yg,X),\n+  \/* 17C8 *\/ _(Yg,X), _(Rt,X), _(Rt,X), _(Xg,X), _(Rt,X), _(Xg,X), _(Xg,X), _(Xg,X),\n+  \/* 17D0 *\/ _(Xg,X), _(Xg,X),  _(H,X), _(Yg,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 17D8 *\/  _(X,X), _(GB,C),  _(X,X),  _(X,X), _(S,SM), _(Yg,X),  _(X,X),  _(X,X),\n+  \/* 17E0 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* 17E8 *\/ _(GB,C), _(GB,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+#define indic_offset_0x1cd0u 1488\n+\n+\n+  \/* Vedic Extensions *\/\n+\n+  \/* 1CD0 *\/ _(A,SM), _(A,SM), _(A,SM),  _(X,X), _(A,SM), _(A,SM), _(A,SM), _(A,SM),\n+  \/* 1CD8 *\/ _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM),\n+  \/* 1CE0 *\/ _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM),\n+  \/* 1CE8 *\/ _(A,SM), _(S,SM), _(S,SM), _(S,SM), _(S,SM), _(A,SM), _(S,SM), _(S,SM),\n+  \/* 1CF0 *\/ _(S,SM), _(S,SM),  _(C,C),  _(C,C), _(A,SM),  _(C,C),  _(C,C), _(A,SM),\n+  \/* 1CF8 *\/ _(A,SM), _(A,SM), _(GB,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+#define indic_offset_0x2008u 1536\n+\n+\n+  \/* General Punctuation *\/\n+\n+  \/* 2008 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),_(ZWNJ,X),_(ZWJ,X),  _(X,X),  _(X,X),\n+  \/* 2010 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),  _(X,X),  _(X,X),\n+  \/* 2018 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 2020 *\/  _(X,X),  _(X,X), _(GB,C),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+#define indic_offset_0x2070u 1568\n+\n+\n+  \/* Superscripts and Subscripts *\/\n+\n+  \/* 2070 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),_(SM,SM),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 2078 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 2080 *\/  _(X,X),  _(X,X),_(SM,SM),_(SM,SM),_(SM,SM),  _(X,X),  _(X,X),  _(X,X),\n+\n+#define indic_offset_0x25f8u 1592\n+\n+\n+  \/* Geometric Shapes *\/\n+\n+  \/* 25F8 *\/  _(X,X),  _(X,X),  _(X,X), _(GB,C), _(GB,C), _(GB,C), _(GB,C),  _(X,X),\n+\n+#define indic_offset_0xa8e0u 1600\n+\n+\n+  \/* Devanagari Extended *\/\n+\n+  \/* A8E0 *\/ _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM),\n+  \/* A8E8 *\/ _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM), _(A,SM),\n+  \/* A8F0 *\/ _(A,SM), _(A,SM), _(S,SM), _(S,SM), _(S,SM), _(S,SM), _(S,SM), _(S,SM),\n+  \/* A8F8 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(V,C), _(M,AS),\n+\n+#define indic_offset_0xa9e0u 1632\n+\n+\n+  \/* Myanmar Extended-B *\/\n+\n+  \/* A9E0 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C), _(VA,T),  _(X,X),  _(C,C),\n+  \/* A9E8 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* A9F0 *\/ _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C), _(GB,C),\n+  \/* A9F8 *\/ _(GB,C), _(GB,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(X,X),\n+\n+#define indic_offset_0xaa60u 1664\n+\n+\n+  \/* Myanmar Extended-A *\/\n+\n+  \/* AA60 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* AA68 *\/  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),  _(C,C),\n+  \/* AA70 *\/  _(X,X),  _(C,C),  _(C,C),  _(C,C), _(GB,C), _(GB,C), _(GB,C),  _(X,X),\n+  \/* AA78 *\/  _(X,X),  _(X,X),  _(C,C), _(PT,X),  _(N,X),  _(N,X),  _(C,C),  _(C,C),\n+\n+#define indic_offset_0xfe00u 1696\n+\n+\n+  \/* Variation Selectors *\/\n+\n+  \/* FE00 *\/ _(VS,X), _(VS,X), _(VS,X), _(VS,X), _(VS,X), _(VS,X), _(VS,X), _(VS,X),\n+  \/* FE08 *\/ _(VS,X), _(VS,X), _(VS,X), _(VS,X), _(VS,X), _(VS,X), _(VS,X), _(VS,X),\n+\n+#define indic_offset_0x11300u 1712\n+\n+\n+  \/* Grantha *\/\n+\n+  \/* 11300 *\/  _(X,X),_(SM,SM),_(SM,SM),_(SM,SM),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 11308 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 11310 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 11318 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 11320 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 11328 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 11330 *\/  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),  _(X,X),\n+  \/* 11338 *\/  _(X,X),  _(X,X),  _(X,X),  _(N,X),  _(N,X),  _(X,X),  _(X,X),  _(X,X),\n+\n+}; \/* Table items: 1776; occupancy: 69% *\/\n+\n+uint16_t\n+hb_indic_get_categories (hb_codepoint_t u)\n+{\n+  switch (u >> 12)\n+  {\n+    case 0x0u:\n+      if (unlikely (u == 0x00A0u)) return _(GB,C);\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0028u, 0x003Fu)) return indic_table[u - 0x0028u + indic_offset_0x0028u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x00B0u, 0x00D7u)) return indic_table[u - 0x00B0u + indic_offset_0x00b0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0900u, 0x0D7Fu)) return indic_table[u - 0x0900u + indic_offset_0x0900u];\n+      break;\n+\n+    case 0x1u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1000u, 0x109Fu)) return indic_table[u - 0x1000u + indic_offset_0x1000u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1780u, 0x17EFu)) return indic_table[u - 0x1780u + indic_offset_0x1780u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1CD0u, 0x1CFFu)) return indic_table[u - 0x1CD0u + indic_offset_0x1cd0u];\n+      break;\n+\n+    case 0x2u:\n+      if (unlikely (u == 0x25CCu)) return _(DC,C);\n+      if (hb_in_range<hb_codepoint_t> (u, 0x2008u, 0x2027u)) return indic_table[u - 0x2008u + indic_offset_0x2008u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x2070u, 0x2087u)) return indic_table[u - 0x2070u + indic_offset_0x2070u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x25F8u, 0x25FFu)) return indic_table[u - 0x25F8u + indic_offset_0x25f8u];\n+      break;\n+\n+    case 0xAu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xA8E0u, 0xA8FFu)) return indic_table[u - 0xA8E0u + indic_offset_0xa8e0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0xA9E0u, 0xA9FFu)) return indic_table[u - 0xA9E0u + indic_offset_0xa9e0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0xAA60u, 0xAA7Fu)) return indic_table[u - 0xAA60u + indic_offset_0xaa60u];\n+      break;\n+\n+    case 0xFu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xFE00u, 0xFE0Fu)) return indic_table[u - 0xFE00u + indic_offset_0xfe00u];\n+      break;\n+\n+    case 0x11u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11300u, 0x1133Fu)) return indic_table[u - 0x11300u + indic_offset_0x11300u];\n+      break;\n+\n+    default:\n+      break;\n+  }\n+  return _(X,X);\n+}\n+\n+#undef _\n+#undef INDIC_COMBINE_CATEGORIES\n+\n+#undef _OT_A\n+#undef _OT_As\n+#undef _OT_C\n+#undef _OT_CM\n+#undef _OT_CS\n+#undef _OT_DC\n+#undef _OT_H\n+#undef _OT_M\n+#undef _OT_MH\n+#undef _OT_ML\n+#undef _OT_MR\n+#undef _OT_MW\n+#undef _OT_MY\n+#undef _OT_N\n+#undef _OT_GB\n+#undef _OT_PT\n+#undef _OT_R\n+#undef _OT_Rf\n+#undef _OT_Rt\n+#undef _OT_SM\n+#undef _OT_S\n+#undef _OT_V\n+#undef _OT_VA\n+#undef _OT_VB\n+#undef _OT_VL\n+#undef _OT_VR\n+#undef _OT_VS\n+#undef _OT_X\n+#undef _OT_Xg\n+#undef _OT_Yg\n+#undef _OT_ZWJ\n+#undef _OT_ZWNJ\n+\n+#undef _POS_T\n+#undef _POS_A\n+#undef _POS_AP\n+#undef _POS_AS\n+#undef _POS_C\n+#undef _POS_BS\n+#undef _POS_B\n+#undef _POS_X\n+#undef _POS_R\n+#undef _POS_L\n+#undef _POS_LM\n+#undef _POS_SM\n+\n+#endif\n+\n+\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic-table.cc","additions":560,"deletions":0,"binary":false,"changes":560,"status":"added"},{"patch":"@@ -0,0 +1,1542 @@\n+\/*\n+ * Copyright  2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_OT_SHAPE\n+\n+#include \"hb-ot-shaper-indic.hh\"\n+#include \"hb-ot-shaper-indic-machine.hh\"\n+#include \"hb-ot-shaper-vowel-constraints.hh\"\n+#include \"hb-ot-layout.hh\"\n+\n+\n+\/*\n+ * Indic shaper.\n+ *\/\n+\n+\n+static inline void\n+set_indic_properties (hb_glyph_info_t &info)\n+{\n+  hb_codepoint_t u = info.codepoint;\n+  unsigned int type = hb_indic_get_categories (u);\n+\n+  info.indic_category() = (indic_category_t) (type & 0xFFu);\n+  info.indic_position() = (indic_position_t) (type >> 8);\n+}\n+\n+\n+static inline bool\n+is_one_of (const hb_glyph_info_t &info, unsigned int flags)\n+{\n+  \/* If it ligated, all bets are off. *\/\n+  if (_hb_glyph_info_ligated (&info)) return false;\n+  return !!(FLAG_UNSAFE (info.indic_category()) & flags);\n+}\n+\n+\/* Note:\n+ *\n+ * We treat Vowels and placeholders as if they were consonants.  This is safe because Vowels\n+ * cannot happen in a consonant syllable.  The plus side however is, we can call the\n+ * consonant syllable logic from the vowel syllable function and get it all right!\n+ *\n+ * Keep in sync with consonant_categories in the generator. *\/\n+#define CONSONANT_FLAGS_INDIC (FLAG (I_Cat(C)) | FLAG (I_Cat(CS)) | FLAG (I_Cat(Ra)) | FLAG (I_Cat(CM)) | FLAG (I_Cat(V)) | FLAG (I_Cat(PLACEHOLDER)) | FLAG (I_Cat(DOTTEDCIRCLE)))\n+\n+static inline bool\n+is_consonant (const hb_glyph_info_t &info)\n+{\n+  return is_one_of (info, CONSONANT_FLAGS_INDIC);\n+}\n+\n+#define JOINER_FLAGS (FLAG (I_Cat(ZWJ)) | FLAG (I_Cat(ZWNJ)))\n+\n+static inline bool\n+is_joiner (const hb_glyph_info_t &info)\n+{\n+  return is_one_of (info, JOINER_FLAGS);\n+}\n+\n+static inline bool\n+is_halant (const hb_glyph_info_t &info)\n+{\n+  return is_one_of (info, FLAG (I_Cat(H)));\n+}\n+\n+struct hb_indic_would_substitute_feature_t\n+{\n+  void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)\n+  {\n+    zero_context = zero_context_;\n+    map->get_stage_lookups (0\/*GSUB*\/,\n+                            map->get_feature_stage (0\/*GSUB*\/, feature_tag),\n+                            &lookups, &count);\n+  }\n+\n+  bool would_substitute (const hb_codepoint_t *glyphs,\n+                         unsigned int          glyphs_count,\n+                         hb_face_t            *face) const\n+  {\n+    for (unsigned int i = 0; i < count; i++)\n+      if (hb_ot_layout_lookup_would_substitute (face, lookups[i].index, glyphs, glyphs_count, zero_context))\n+        return true;\n+    return false;\n+  }\n+\n+  private:\n+  const hb_ot_map_t::lookup_map_t *lookups;\n+  unsigned int count;\n+  bool zero_context;\n+};\n+\n+\n+\/*\n+ * Indic configurations.  Note that we do not want to keep every single script-specific\n+ * behavior in these tables necessarily.  This should mainly be used for per-script\n+ * properties that are cheaper keeping here, than in the code.  Ie. if, say, one and\n+ * only one script has an exception, that one script can be if'ed directly in the code,\n+ * instead of adding a new flag in these structs.\n+ *\/\n+\n+enum reph_position_t {\n+  REPH_POS_AFTER_MAIN  = POS_AFTER_MAIN,\n+  REPH_POS_BEFORE_SUB  = POS_BEFORE_SUB,\n+  REPH_POS_AFTER_SUB   = POS_AFTER_SUB,\n+  REPH_POS_BEFORE_POST = POS_BEFORE_POST,\n+  REPH_POS_AFTER_POST  = POS_AFTER_POST\n+};\n+enum reph_mode_t {\n+  REPH_MODE_IMPLICIT,  \/* Reph formed out of initial Ra,H sequence. *\/\n+  REPH_MODE_EXPLICIT,  \/* Reph formed out of initial Ra,H,ZWJ sequence. *\/\n+  REPH_MODE_LOG_REPHA  \/* Encoded Repha character, needs reordering. *\/\n+};\n+enum blwf_mode_t {\n+  BLWF_MODE_PRE_AND_POST, \/* Below-forms feature applied to pre-base and post-base. *\/\n+  BLWF_MODE_POST_ONLY     \/* Below-forms feature applied to post-base only. *\/\n+};\n+struct indic_config_t\n+{\n+  hb_script_t     script;\n+  bool            has_old_spec;\n+  hb_codepoint_t  virama;\n+  reph_position_t reph_pos;\n+  reph_mode_t     reph_mode;\n+  blwf_mode_t     blwf_mode;\n+};\n+\n+static const indic_config_t indic_configs[] =\n+{\n+  \/* Default.  Should be first. *\/\n+  {HB_SCRIPT_INVALID,   false,      0,REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_DEVANAGARI,true, 0x094Du,REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_BENGALI,   true, 0x09CDu,REPH_POS_AFTER_SUB,  REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_GURMUKHI,  true, 0x0A4Du,REPH_POS_BEFORE_SUB, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_GUJARATI,  true, 0x0ACDu,REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_ORIYA,     true, 0x0B4Du,REPH_POS_AFTER_MAIN, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_TAMIL,     true, 0x0BCDu,REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_TELUGU,    true, 0x0C4Du,REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_POST_ONLY},\n+  {HB_SCRIPT_KANNADA,   true, 0x0CCDu,REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_POST_ONLY},\n+  {HB_SCRIPT_MALAYALAM, true, 0x0D4Du,REPH_POS_AFTER_MAIN, REPH_MODE_LOG_REPHA,BLWF_MODE_PRE_AND_POST},\n+};\n+\n+\n+static const hb_ot_map_feature_t\n+indic_features[] =\n+{\n+  \/*\n+   * Basic features.\n+   * These features are applied in order, one at a time, after initial_reordering,\n+   * constrained to the syllable.\n+   *\/\n+  {HB_TAG('n','u','k','t'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('a','k','h','n'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('r','p','h','f'),        F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('r','k','r','f'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('p','r','e','f'),        F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('b','l','w','f'),        F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('a','b','v','f'),        F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('h','a','l','f'),        F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('p','s','t','f'),        F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('v','a','t','u'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('c','j','c','t'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  \/*\n+   * Other features.\n+   * These features are applied all at once, after final_reordering, constrained\n+   * to the syllable.\n+   * Default Bengali font in Windows for example has intermixed\n+   * lookups for init,pres,abvs,blws features.\n+   *\/\n+  {HB_TAG('i','n','i','t'),        F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('p','r','e','s'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('a','b','v','s'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('b','l','w','s'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('p','s','t','s'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('h','a','l','n'), F_GLOBAL_MANUAL_JOINERS | F_PER_SYLLABLE},\n+};\n+\n+\/*\n+ * Must be in the same order as the indic_features array.\n+ *\/\n+enum {\n+  _INDIC_NUKT,\n+  _INDIC_AKHN,\n+  INDIC_RPHF,\n+  _INDIC_RKRF,\n+  INDIC_PREF,\n+  INDIC_BLWF,\n+  INDIC_ABVF,\n+  INDIC_HALF,\n+  INDIC_PSTF,\n+  _INDIC_VATU,\n+  _INDIC_CJCT,\n+\n+  INDIC_INIT,\n+  _INDIC_PRES,\n+  _INDIC_ABVS,\n+  _INDIC_BLWS,\n+  _INDIC_PSTS,\n+  _INDIC_HALN,\n+\n+  INDIC_NUM_FEATURES,\n+  INDIC_BASIC_FEATURES = INDIC_INIT, \/* Don't forget to update this! *\/\n+};\n+\n+static void\n+setup_syllables_indic (const hb_ot_shape_plan_t *plan,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer);\n+static void\n+initial_reordering_indic (const hb_ot_shape_plan_t *plan,\n+                          hb_font_t *font,\n+                          hb_buffer_t *buffer);\n+static void\n+final_reordering_indic (const hb_ot_shape_plan_t *plan,\n+                        hb_font_t *font,\n+                        hb_buffer_t *buffer);\n+\n+static void\n+collect_features_indic (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* Do this before any lookups have been applied. *\/\n+  map->add_gsub_pause (setup_syllables_indic);\n+\n+  map->enable_feature (HB_TAG('l','o','c','l'), F_PER_SYLLABLE);\n+  \/* The Indic specs do not require ccmp, but we apply it here since if\n+   * there is a use of it, it's typically at the beginning. *\/\n+  map->enable_feature (HB_TAG('c','c','m','p'), F_PER_SYLLABLE);\n+\n+\n+  unsigned int i = 0;\n+  map->add_gsub_pause (initial_reordering_indic);\n+\n+  for (; i < INDIC_BASIC_FEATURES; i++) {\n+    map->add_feature (indic_features[i]);\n+    map->add_gsub_pause (nullptr);\n+  }\n+\n+  map->add_gsub_pause (final_reordering_indic);\n+\n+  for (; i < INDIC_NUM_FEATURES; i++)\n+    map->add_feature (indic_features[i]);\n+}\n+\n+static void\n+override_features_indic (hb_ot_shape_planner_t *plan)\n+{\n+  plan->map.disable_feature (HB_TAG('l','i','g','a'));\n+  plan->map.add_gsub_pause (hb_syllabic_clear_var); \/\/ Don't need syllables anymore, use stop to free buffer var\n+}\n+\n+\n+struct indic_shape_plan_t\n+{\n+  bool load_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const\n+  {\n+    hb_codepoint_t glyph = virama_glyph.get_relaxed ();\n+    if (unlikely (glyph == (hb_codepoint_t) -1))\n+    {\n+      if (!config->virama || !font->get_nominal_glyph (config->virama, &glyph))\n+        glyph = 0;\n+      \/* Technically speaking, the spec says we should apply 'locl' to virama too.\n+       * Maybe one day... *\/\n+\n+      \/* Our get_nominal_glyph() function needs a font, so we can't get the virama glyph\n+       * during shape planning...  Instead, overwrite it here. *\/\n+      virama_glyph.set_relaxed ((int) glyph);\n+    }\n+\n+    *pglyph = glyph;\n+    return glyph != 0;\n+  }\n+\n+  const indic_config_t *config;\n+\n+  bool is_old_spec;\n+#ifndef HB_NO_UNISCRIBE_BUG_COMPATIBLE\n+  bool uniscribe_bug_compatible;\n+#else\n+  static constexpr bool uniscribe_bug_compatible = false;\n+#endif\n+  mutable hb_atomic_int_t virama_glyph;\n+\n+  hb_indic_would_substitute_feature_t rphf;\n+  hb_indic_would_substitute_feature_t pref;\n+  hb_indic_would_substitute_feature_t blwf;\n+  hb_indic_would_substitute_feature_t pstf;\n+  hb_indic_would_substitute_feature_t vatu;\n+\n+  hb_mask_t mask_array[INDIC_NUM_FEATURES];\n+};\n+\n+static void *\n+data_create_indic (const hb_ot_shape_plan_t *plan)\n+{\n+  indic_shape_plan_t *indic_plan = (indic_shape_plan_t *) hb_calloc (1, sizeof (indic_shape_plan_t));\n+  if (unlikely (!indic_plan))\n+    return nullptr;\n+\n+  indic_plan->config = &indic_configs[0];\n+  for (unsigned int i = 1; i < ARRAY_LENGTH (indic_configs); i++)\n+    if (plan->props.script == indic_configs[i].script) {\n+      indic_plan->config = &indic_configs[i];\n+      break;\n+    }\n+\n+  indic_plan->is_old_spec = indic_plan->config->has_old_spec && ((plan->map.chosen_script[0] & 0x000000FFu) != '2');\n+#ifndef HB_NO_UNISCRIBE_BUG_COMPATIBLE\n+  indic_plan->uniscribe_bug_compatible = hb_options ().uniscribe_bug_compatible;\n+#endif\n+  indic_plan->virama_glyph.set_relaxed (-1);\n+\n+  \/* Use zero-context would_substitute() matching for new-spec of the main\n+   * Indic scripts, and scripts with one spec only, but not for old-specs.\n+   * The new-spec for all dual-spec scripts says zero-context matching happens.\n+   *\n+   * However, testing with Malayalam shows that old and new spec both allow\n+   * context.  Testing with Bengali new-spec however shows that it doesn't.\n+   * So, the heuristic here is the way it is.  It should *only* be changed,\n+   * as we discover more cases of what Windows does.  DON'T TOUCH OTHERWISE.\n+   *\/\n+  bool zero_context = !indic_plan->is_old_spec && plan->props.script != HB_SCRIPT_MALAYALAM;\n+  indic_plan->rphf.init (&plan->map, HB_TAG('r','p','h','f'), zero_context);\n+  indic_plan->pref.init (&plan->map, HB_TAG('p','r','e','f'), zero_context);\n+  indic_plan->blwf.init (&plan->map, HB_TAG('b','l','w','f'), zero_context);\n+  indic_plan->pstf.init (&plan->map, HB_TAG('p','s','t','f'), zero_context);\n+  indic_plan->vatu.init (&plan->map, HB_TAG('v','a','t','u'), zero_context);\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (indic_plan->mask_array); i++)\n+    indic_plan->mask_array[i] = (indic_features[i].flags & F_GLOBAL) ?\n+                                 0 : plan->map.get_1_mask (indic_features[i].tag);\n+\n+  return indic_plan;\n+}\n+\n+static void\n+data_destroy_indic (void *data)\n+{\n+  hb_free (data);\n+}\n+\n+static indic_position_t\n+consonant_position_from_face (const indic_shape_plan_t *indic_plan,\n+                              const hb_codepoint_t consonant,\n+                              const hb_codepoint_t virama,\n+                              hb_face_t *face)\n+{\n+  \/* For old-spec, the order of glyphs is Consonant,Virama,\n+   * whereas for new-spec, it's Virama,Consonant.  However,\n+   * some broken fonts (like Free Sans) simply copied lookups\n+   * from old-spec to new-spec without modification.\n+   * And oddly enough, Uniscribe seems to respect those lookups.\n+   * Eg. in the sequence U+0924,U+094D,U+0930, Uniscribe finds\n+   * base at 0.  The font however, only has lookups matching\n+   * 930,94D in 'blwf', not the expected 94D,930 (with new-spec\n+   * table).  As such, we simply match both sequences.  Seems\n+   * to work.\n+   *\n+   * Vatu is done as well, for:\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1587\n+   *\/\n+  hb_codepoint_t glyphs[3] = {virama, consonant, virama};\n+  if (indic_plan->blwf.would_substitute (glyphs  , 2, face) ||\n+      indic_plan->blwf.would_substitute (glyphs+1, 2, face) ||\n+      indic_plan->vatu.would_substitute (glyphs  , 2, face) ||\n+      indic_plan->vatu.would_substitute (glyphs+1, 2, face))\n+    return POS_BELOW_C;\n+  if (indic_plan->pstf.would_substitute (glyphs  , 2, face) ||\n+      indic_plan->pstf.would_substitute (glyphs+1, 2, face))\n+    return POS_POST_C;\n+  if (indic_plan->pref.would_substitute (glyphs  , 2, face) ||\n+      indic_plan->pref.would_substitute (glyphs+1, 2, face))\n+    return POS_POST_C;\n+  return POS_BASE_C;\n+}\n+\n+static void\n+setup_masks_indic (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                   hb_buffer_t              *buffer,\n+                   hb_font_t                *font HB_UNUSED)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, indic_category);\n+  HB_BUFFER_ALLOCATE_VAR (buffer, indic_position);\n+\n+  \/* We cannot setup masks here.  We save information about characters\n+   * and setup masks later on in a pause-callback. *\/\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    set_indic_properties (info[i]);\n+}\n+\n+static void\n+setup_syllables_indic (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                       hb_font_t *font HB_UNUSED,\n+                       hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, syllable);\n+  find_syllables_indic (buffer);\n+  foreach_syllable (buffer, start, end)\n+    buffer->unsafe_to_break (start, end);\n+}\n+\n+static int\n+compare_indic_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)\n+{\n+  int a = pa->indic_position();\n+  int b = pb->indic_position();\n+\n+  return (int) a - (int) b;\n+}\n+\n+\n+\n+static void\n+update_consonant_positions_indic (const hb_ot_shape_plan_t *plan,\n+                                  hb_font_t         *font,\n+                                  hb_buffer_t       *buffer)\n+{\n+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n+\n+  hb_codepoint_t virama;\n+  if (indic_plan->load_virama_glyph (font, &virama))\n+  {\n+    hb_face_t *face = font->face;\n+    unsigned int count = buffer->len;\n+    hb_glyph_info_t *info = buffer->info;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (info[i].indic_position() == POS_BASE_C)\n+      {\n+        hb_codepoint_t consonant = info[i].codepoint;\n+        info[i].indic_position() = consonant_position_from_face (indic_plan, consonant, virama, face);\n+      }\n+  }\n+}\n+\n+\n+\/* Rules from:\n+ * https:\/\/docs.microsqoft.com\/en-us\/typography\/script-development\/devanagari *\/\n+\n+static void\n+initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,\n+                                       hb_face_t *face,\n+                                       hb_buffer_t *buffer,\n+                                       unsigned int start, unsigned int end)\n+{\n+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/435#issuecomment-335560167\n+   * \/\/ For compatibility with legacy usage in Kannada,\n+   * \/\/ Ra+h+ZWJ must behave like Ra+ZWJ+h...\n+   *\/\n+  if (buffer->props.script == HB_SCRIPT_KANNADA &&\n+      start + 3 <= end &&\n+      is_one_of (info[start  ], FLAG (I_Cat(Ra))) &&\n+      is_one_of (info[start+1], FLAG (I_Cat(H))) &&\n+      is_one_of (info[start+2], FLAG (I_Cat(ZWJ))))\n+  {\n+    buffer->merge_clusters (start+1, start+3);\n+    hb_glyph_info_t tmp = info[start+1];\n+    info[start+1] = info[start+2];\n+    info[start+2] = tmp;\n+  }\n+\n+  \/* 1. Find base consonant:\n+   *\n+   * The shaping engine finds the base consonant of the syllable, using the\n+   * following algorithm: starting from the end of the syllable, move backwards\n+   * until a consonant is found that does not have a below-base or post-base\n+   * form (post-base forms have to follow below-base forms), or that is not a\n+   * pre-base-reordering Ra, or arrive at the first consonant. The consonant\n+   * stopped at will be the base.\n+   *\n+   *   o If the syllable starts with Ra + Halant (in a script that has Reph)\n+   *     and has more than one consonant, Ra is excluded from candidates for\n+   *     base consonants.\n+   *\/\n+\n+  unsigned int base = end;\n+  bool has_reph = false;\n+\n+  {\n+    \/* -> If the syllable starts with Ra + Halant (in a script that has Reph)\n+     *    and has more than one consonant, Ra is excluded from candidates for\n+     *    base consonants. *\/\n+    unsigned int limit = start;\n+    if (indic_plan->mask_array[INDIC_RPHF] &&\n+        start + 3 <= end &&\n+        (\n+         (indic_plan->config->reph_mode == REPH_MODE_IMPLICIT && !is_joiner (info[start + 2])) ||\n+         (indic_plan->config->reph_mode == REPH_MODE_EXPLICIT && info[start + 2].indic_category() == I_Cat(ZWJ))\n+        ))\n+    {\n+      \/* See if it matches the 'rphf' feature. *\/\n+      hb_codepoint_t glyphs[3] = {info[start].codepoint,\n+                                  info[start + 1].codepoint,\n+                                  indic_plan->config->reph_mode == REPH_MODE_EXPLICIT ?\n+                                    info[start + 2].codepoint : 0};\n+      if (indic_plan->rphf.would_substitute (glyphs, 2, face) ||\n+          (indic_plan->config->reph_mode == REPH_MODE_EXPLICIT &&\n+           indic_plan->rphf.would_substitute (glyphs, 3, face)))\n+      {\n+        limit += 2;\n+        while (limit < end && is_joiner (info[limit]))\n+          limit++;\n+        base = start;\n+        has_reph = true;\n+      }\n+    } else if (indic_plan->config->reph_mode == REPH_MODE_LOG_REPHA && info[start].indic_category() == I_Cat(Repha))\n+    {\n+        limit += 1;\n+        while (limit < end && is_joiner (info[limit]))\n+          limit++;\n+        base = start;\n+        has_reph = true;\n+    }\n+\n+    {\n+      \/* -> starting from the end of the syllable, move backwards *\/\n+      unsigned int i = end;\n+      bool seen_below = false;\n+      do {\n+        i--;\n+        \/* -> until a consonant is found *\/\n+        if (is_consonant (info[i]))\n+        {\n+          \/* -> that does not have a below-base or post-base form\n+           * (post-base forms have to follow below-base forms), *\/\n+          if (info[i].indic_position() != POS_BELOW_C &&\n+              (info[i].indic_position() != POS_POST_C || seen_below))\n+          {\n+            base = i;\n+            break;\n+          }\n+          if (info[i].indic_position() == POS_BELOW_C)\n+            seen_below = true;\n+\n+          \/* -> or that is not a pre-base-reordering Ra,\n+           *\n+           * IMPLEMENTATION NOTES:\n+           *\n+           * Our pre-base-reordering Ra's are marked POS_POST_C, so will be skipped\n+           * by the logic above already.\n+           *\/\n+\n+          \/* -> or arrive at the first consonant. The consonant stopped at will\n+           * be the base. *\/\n+          base = i;\n+        }\n+        else\n+        {\n+          \/* A ZWJ after a Halant stops the base search, and requests an explicit\n+           * half form.\n+           * A ZWJ before a Halant, requests a subjoined form instead, and hence\n+           * search continues.  This is particularly important for Bengali\n+           * sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya. *\/\n+          if (start < i &&\n+              info[i].indic_category() == I_Cat(ZWJ) &&\n+              info[i - 1].indic_category() == I_Cat(H))\n+            break;\n+        }\n+      } while (i > limit);\n+    }\n+\n+    \/* -> If the syllable starts with Ra + Halant (in a script that has Reph)\n+     *    and has more than one consonant, Ra is excluded from candidates for\n+     *    base consonants.\n+     *\n+     *  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ. *\/\n+    if (has_reph && base == start && limit - base <= 2) {\n+      \/* Have no other consonant, so Reph is not formed and Ra becomes base. *\/\n+      has_reph = false;\n+    }\n+  }\n+\n+\n+  \/* 2. Decompose and reorder Matras:\n+   *\n+   * Each matra and any syllable modifier sign in the syllable are moved to the\n+   * appropriate position relative to the consonant(s) in the syllable. The\n+   * shaping engine decomposes two- or three-part matras into their constituent\n+   * parts before any repositioning. Matra characters are classified by which\n+   * consonant in a conjunct they have affinity for and are reordered to the\n+   * following positions:\n+   *\n+   *   o Before first half form in the syllable\n+   *   o After subjoined consonants\n+   *   o After post-form consonant\n+   *   o After main consonant (for above marks)\n+   *\n+   * IMPLEMENTATION NOTES:\n+   *\n+   * The normalize() routine has already decomposed matras for us, so we don't\n+   * need to worry about that.\n+   *\/\n+\n+\n+  \/* 3.  Reorder marks to canonical order:\n+   *\n+   * Adjacent nukta and halant or nukta and vedic sign are always repositioned\n+   * if necessary, so that the nukta is first.\n+   *\n+   * IMPLEMENTATION NOTES:\n+   *\n+   * We don't need to do this: the normalize() routine already did this for us.\n+   *\/\n+\n+\n+  \/* Reorder characters *\/\n+\n+  for (unsigned int i = start; i < base; i++)\n+    info[i].indic_position() = hb_min (POS_PRE_C, (indic_position_t) info[i].indic_position());\n+\n+  if (base < end)\n+    info[base].indic_position() = POS_BASE_C;\n+\n+  \/* Handle beginning Ra *\/\n+  if (has_reph)\n+    info[start].indic_position() = POS_RA_TO_BECOME_REPH;\n+\n+  \/* For old-style Indic script tags, move the first post-base Halant after\n+   * last consonant.\n+   *\n+   * Reports suggest that in some scripts Uniscribe does this only if there\n+   * is *not* a Halant after last consonant already.  We know that is the\n+   * case for Kannada, while it reorders unconditionally in other scripts,\n+   * eg. Malayalam, Bengali, and Devanagari.  We don't currently know about\n+   * other scripts, so we block Kannada.\n+   *\n+   * Kannada test case:\n+   * U+0C9A,U+0CCD,U+0C9A,U+0CCD\n+   * With some versions of Lohit Kannada.\n+   * https:\/\/bugs.freedesktop.org\/show_bug.cgi?id=59118\n+   *\n+   * Malayalam test case:\n+   * U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D\n+   * With lohit-ttf-20121122\/Lohit-Malayalam.ttf\n+   *\n+   * Bengali test case:\n+   * U+0998,U+09CD,U+09AF,U+09CD\n+   * With Windows XP vrinda.ttf\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1073\n+   *\n+   * Devanagari test case:\n+   * U+091F,U+094D,U+0930,U+094D\n+   * With chandas.ttf\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1071\n+   *\/\n+  if (indic_plan->is_old_spec)\n+  {\n+    bool disallow_double_halants = buffer->props.script == HB_SCRIPT_KANNADA;\n+    for (unsigned int i = base + 1; i < end; i++)\n+      if (info[i].indic_category() == I_Cat(H))\n+      {\n+        unsigned int j;\n+        for (j = end - 1; j > i; j--)\n+          if (is_consonant (info[j]) ||\n+              (disallow_double_halants && info[j].indic_category() == I_Cat(H)))\n+            break;\n+        if (info[j].indic_category() != I_Cat(H) && j > i) {\n+          \/* Move Halant to after last consonant. *\/\n+          hb_glyph_info_t t = info[i];\n+          memmove (&info[i], &info[i + 1], (j - i) * sizeof (info[0]));\n+          info[j] = t;\n+        }\n+        break;\n+      }\n+  }\n+\n+  \/* Attach misc marks to previous char to move with them. *\/\n+  {\n+    indic_position_t last_pos = POS_START;\n+    for (unsigned int i = start; i < end; i++)\n+    {\n+      if ((FLAG_UNSAFE (info[i].indic_category()) & (JOINER_FLAGS | FLAG (I_Cat(N)) | FLAG (I_Cat(RS)) | FLAG (I_Cat(CM)) | FLAG (I_Cat(H)))))\n+      {\n+        info[i].indic_position() = last_pos;\n+        if (unlikely (info[i].indic_category() == I_Cat(H) &&\n+                      info[i].indic_position() == POS_PRE_M))\n+        {\n+          \/*\n+           * Uniscribe doesn't move the Halant with Left Matra.\n+           * TEST: U+092B,U+093F,U+094D\n+           * We follow.\n+           *\/\n+          for (unsigned int j = i; j > start; j--)\n+            if (info[j - 1].indic_position() != POS_PRE_M) {\n+              info[i].indic_position() = info[j - 1].indic_position();\n+              break;\n+            }\n+        }\n+      } else if (info[i].indic_position() != POS_SMVD) {\n+        last_pos = (indic_position_t) info[i].indic_position();\n+      }\n+    }\n+  }\n+  \/* For post-base consonants let them own anything before them\n+   * since the last consonant or matra. *\/\n+  {\n+    unsigned int last = base;\n+    for (unsigned int i = base + 1; i < end; i++)\n+      if (is_consonant (info[i]))\n+      {\n+        for (unsigned int j = last + 1; j < i; j++)\n+          if (info[j].indic_position() < POS_SMVD)\n+            info[j].indic_position() = info[i].indic_position();\n+        last = i;\n+      } else if (info[i].indic_category() == I_Cat(M))\n+        last = i;\n+  }\n+\n+\n+  {\n+    \/* Use syllable() for sort accounting temporarily. *\/\n+    unsigned int syllable = info[start].syllable();\n+    for (unsigned int i = start; i < end; i++)\n+      info[i].syllable() = i - start;\n+\n+    \/* Sit tight, rock 'n roll! *\/\n+    hb_stable_sort (info + start, end - start, compare_indic_order);\n+    \/* Find base again *\/\n+    base = end;\n+    for (unsigned int i = start; i < end; i++)\n+      if (info[i].indic_position() == POS_BASE_C)\n+      {\n+        base = i;\n+        break;\n+      }\n+    \/* Things are out-of-control for post base positions, they may shuffle\n+     * around like crazy.  In old-spec mode, we move halants around, so in\n+     * that case merge all clusters after base.  Otherwise, check the sort\n+     * order and merge as needed.\n+     * For pre-base stuff, we handle cluster issues in final reordering.\n+     *\n+     * We could use buffer->sort() for this, if there was no special\n+     * reordering of pre-base stuff happening later...\n+     * We don't want to merge_clusters all of that, which buffer->sort()\n+     * would.  Here's a concrete example:\n+     *\n+     * Assume there's a pre-base consonant and explicit Halant before base,\n+     * followed by a prebase-reordering (left) Matra:\n+     *\n+     *   C,H,ZWNJ,B,M\n+     *\n+     * At this point in reordering we would have:\n+     *\n+     *   M,C,H,ZWNJ,B\n+     *\n+     * whereas in final reordering we will bring the Matra closer to Base:\n+     *\n+     *   C,H,ZWNJ,M,B\n+     *\n+     * That's why we don't want to merge-clusters anything before the Base\n+     * at this point.  But if something moved from after Base to before it,\n+     * we should merge clusters from base to them.  In final-reordering, we\n+     * only move things around before base, and merge-clusters up to base.\n+     * These two merge-clusters from the two sides of base will interlock\n+     * to merge things correctly.  See:\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2272\n+     *\/\n+    if (indic_plan->is_old_spec || end - start > 127)\n+      buffer->merge_clusters (base, end);\n+    else\n+    {\n+      \/* Note!  syllable() is a one-byte field. *\/\n+      for (unsigned int i = base; i < end; i++)\n+        if (info[i].syllable() != 255)\n+        {\n+          unsigned int min = i;\n+          unsigned int max = i;\n+          unsigned int j = start + info[i].syllable();\n+          while (j != i)\n+          {\n+            min = hb_min (min, j);\n+            max = hb_max (max, j);\n+            unsigned int next = start + info[j].syllable();\n+            info[j].syllable() = 255; \/* So we don't process j later again. *\/\n+            j = next;\n+          }\n+          buffer->merge_clusters (hb_max (base, min), max + 1);\n+        }\n+    }\n+\n+    \/* Put syllable back in. *\/\n+    for (unsigned int i = start; i < end; i++)\n+      info[i].syllable() = syllable;\n+  }\n+\n+  \/* Setup masks now *\/\n+\n+  {\n+    hb_mask_t mask;\n+\n+    \/* Reph *\/\n+    for (unsigned int i = start; i < end && info[i].indic_position() == POS_RA_TO_BECOME_REPH; i++)\n+      info[i].mask |= indic_plan->mask_array[INDIC_RPHF];\n+\n+    \/* Pre-base *\/\n+    mask = indic_plan->mask_array[INDIC_HALF];\n+    if (!indic_plan->is_old_spec &&\n+        indic_plan->config->blwf_mode == BLWF_MODE_PRE_AND_POST)\n+      mask |= indic_plan->mask_array[INDIC_BLWF];\n+    for (unsigned int i = start; i < base; i++)\n+      info[i].mask  |= mask;\n+    \/* Base *\/\n+    mask = 0;\n+    if (base < end)\n+      info[base].mask |= mask;\n+    \/* Post-base *\/\n+    mask = indic_plan->mask_array[INDIC_BLWF] |\n+           indic_plan->mask_array[INDIC_ABVF] |\n+           indic_plan->mask_array[INDIC_PSTF];\n+    for (unsigned int i = base + 1; i < end; i++)\n+      info[i].mask  |= mask;\n+  }\n+\n+  if (indic_plan->is_old_spec &&\n+      buffer->props.script == HB_SCRIPT_DEVANAGARI)\n+  {\n+    \/* Old-spec eye-lash Ra needs special handling.  From the\n+     * spec:\n+     *\n+     * \"The feature 'below-base form' is applied to consonants\n+     * having below-base forms and following the base consonant.\n+     * The exception is vattu, which may appear below half forms\n+     * as well as below the base glyph. The feature 'below-base\n+     * form' will be applied to all such occurrences of Ra as well.\"\n+     *\n+     * Test case: U+0924,U+094D,U+0930,U+094d,U+0915\n+     * with Sanskrit 2003 font.\n+     *\n+     * However, note that Ra,Halant,ZWJ is the correct way to\n+     * request eyelash form of Ra, so we wouldbn't inhibit it\n+     * in that sequence.\n+     *\n+     * Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915\n+     *\/\n+    for (unsigned int i = start; i + 1 < base; i++)\n+      if (info[i  ].indic_category() == I_Cat(Ra) &&\n+          info[i+1].indic_category() == I_Cat(H)  &&\n+          (i + 2 == base ||\n+           info[i+2].indic_category() != I_Cat(ZWJ)))\n+      {\n+        info[i  ].mask |= indic_plan->mask_array[INDIC_BLWF];\n+        info[i+1].mask |= indic_plan->mask_array[INDIC_BLWF];\n+      }\n+  }\n+\n+  unsigned int pref_len = 2;\n+  if (indic_plan->mask_array[INDIC_PREF] && base + pref_len < end)\n+  {\n+    \/* Find a Halant,Ra sequence and mark it for pre-base-reordering processing. *\/\n+    for (unsigned int i = base + 1; i + pref_len - 1 < end; i++) {\n+      hb_codepoint_t glyphs[2];\n+      for (unsigned int j = 0; j < pref_len; j++)\n+        glyphs[j] = info[i + j].codepoint;\n+      if (indic_plan->pref.would_substitute (glyphs, pref_len, face))\n+      {\n+        for (unsigned int j = 0; j < pref_len; j++)\n+          info[i++].mask |= indic_plan->mask_array[INDIC_PREF];\n+        break;\n+      }\n+    }\n+  }\n+\n+  \/* Apply ZWJ\/ZWNJ effects *\/\n+  for (unsigned int i = start + 1; i < end; i++)\n+    if (is_joiner (info[i])) {\n+      bool non_joiner = info[i].indic_category() == I_Cat(ZWNJ);\n+      unsigned int j = i;\n+\n+      do {\n+        j--;\n+\n+        \/* ZWJ\/ZWNJ should disable CJCT.  They do that by simply\n+         * being there, since we don't skip them for the CJCT\n+         * feature (ie. F_MANUAL_ZWJ) *\/\n+\n+        \/* A ZWNJ disables HALF. *\/\n+        if (non_joiner)\n+          info[j].mask &= ~indic_plan->mask_array[INDIC_HALF];\n+\n+      } while (j > start && !is_consonant (info[j]));\n+    }\n+}\n+\n+static void\n+initial_reordering_standalone_cluster (const hb_ot_shape_plan_t *plan,\n+                                       hb_face_t *face,\n+                                       hb_buffer_t *buffer,\n+                                       unsigned int start, unsigned int end)\n+{\n+  \/* We treat placeholder\/dotted-circle as if they are consonants, so we\n+   * should just chain.  Only if not in compatibility mode that is... *\/\n+\n+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n+  if (indic_plan->uniscribe_bug_compatible)\n+  {\n+    \/* For dotted-circle, this is what Uniscribe does:\n+     * If dotted-circle is the last glyph, it just does nothing.\n+     * Ie. It doesn't form Reph. *\/\n+    if (buffer->info[end - 1].indic_category() == I_Cat(DOTTEDCIRCLE))\n+      return;\n+  }\n+\n+  initial_reordering_consonant_syllable (plan, face, buffer, start, end);\n+}\n+\n+static void\n+initial_reordering_syllable_indic (const hb_ot_shape_plan_t *plan,\n+                                   hb_face_t *face,\n+                                   hb_buffer_t *buffer,\n+                                   unsigned int start, unsigned int end)\n+{\n+  indic_syllable_type_t syllable_type = (indic_syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n+  switch (syllable_type)\n+  {\n+    case indic_vowel_syllable: \/* We made the vowels look like consonants.  So let's call the consonant logic! *\/\n+    case indic_consonant_syllable:\n+     initial_reordering_consonant_syllable (plan, face, buffer, start, end);\n+     break;\n+\n+    case indic_broken_cluster: \/* We already inserted dotted-circles, so just call the standalone_cluster. *\/\n+    case indic_standalone_cluster:\n+     initial_reordering_standalone_cluster (plan, face, buffer, start, end);\n+     break;\n+\n+    case indic_symbol_cluster:\n+    case indic_non_indic_cluster:\n+      break;\n+  }\n+}\n+\n+static void\n+initial_reordering_indic (const hb_ot_shape_plan_t *plan,\n+                          hb_font_t *font,\n+                          hb_buffer_t *buffer)\n+{\n+  if (!buffer->message (font, \"start reordering indic initial\"))\n+    return;\n+\n+  update_consonant_positions_indic (plan, font, buffer);\n+  hb_syllabic_insert_dotted_circles (font, buffer,\n+                                     indic_broken_cluster,\n+                                     I_Cat(DOTTEDCIRCLE),\n+                                     I_Cat(Repha),\n+                                     POS_END);\n+\n+  foreach_syllable (buffer, start, end)\n+    initial_reordering_syllable_indic (plan, font->face, buffer, start, end);\n+\n+  (void) buffer->message (font, \"end reordering indic initial\");\n+}\n+\n+static void\n+final_reordering_syllable_indic (const hb_ot_shape_plan_t *plan,\n+                                 hb_buffer_t *buffer,\n+                                 unsigned int start, unsigned int end)\n+{\n+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+\n+  \/* This function relies heavily on halant glyphs.  Lots of ligation\n+   * and possibly multiple substitutions happened prior to this\n+   * phase, and that might have messed up our properties.  Recover\n+   * from a particular case of that where we're fairly sure that a\n+   * class of I_Cat(H) is desired but has been lost. *\/\n+  \/* We don't call load_virama_glyph(), since we know it's already\n+   * loaded. *\/\n+  hb_codepoint_t virama_glyph = indic_plan->virama_glyph.get_relaxed ();\n+  if (virama_glyph)\n+  {\n+    for (unsigned int i = start; i < end; i++)\n+      if (info[i].codepoint == virama_glyph &&\n+          _hb_glyph_info_ligated (&info[i]) &&\n+          _hb_glyph_info_multiplied (&info[i]))\n+      {\n+        \/* This will make sure that this glyph passes is_halant() test. *\/\n+        info[i].indic_category() = I_Cat(H);\n+        _hb_glyph_info_clear_ligated_and_multiplied (&info[i]);\n+      }\n+  }\n+\n+\n+  \/* 4. Final reordering:\n+   *\n+   * After the localized forms and basic shaping forms GSUB features have been\n+   * applied (see below), the shaping engine performs some final glyph\n+   * reordering before applying all the remaining font features to the entire\n+   * syllable.\n+   *\/\n+\n+  bool try_pref = !!indic_plan->mask_array[INDIC_PREF];\n+\n+  \/* Find base again *\/\n+  unsigned int base;\n+  for (base = start; base < end; base++)\n+    if (info[base].indic_position() >= POS_BASE_C)\n+    {\n+      if (try_pref && base + 1 < end)\n+      {\n+        for (unsigned int i = base + 1; i < end; i++)\n+          if ((info[i].mask & indic_plan->mask_array[INDIC_PREF]) != 0)\n+          {\n+            if (!(_hb_glyph_info_substituted (&info[i]) &&\n+                  _hb_glyph_info_ligated_and_didnt_multiply (&info[i])))\n+            {\n+              \/* Ok, this was a 'pref' candidate but didn't form any.\n+               * Base is around here... *\/\n+              base = i;\n+              while (base < end && is_halant (info[base]))\n+                base++;\n+              info[base].indic_position() = POS_BASE_C;\n+\n+              try_pref = false;\n+            }\n+            break;\n+          }\n+      }\n+      \/* For Malayalam, skip over unformed below- (but NOT post-) forms. *\/\n+      if (buffer->props.script == HB_SCRIPT_MALAYALAM)\n+      {\n+        for (unsigned int i = base + 1; i < end; i++)\n+        {\n+          while (i < end && is_joiner (info[i]))\n+            i++;\n+          if (i == end || !is_halant (info[i]))\n+            break;\n+          i++; \/* Skip halant. *\/\n+          while (i < end && is_joiner (info[i]))\n+            i++;\n+          if (i < end && is_consonant (info[i]) && info[i].indic_position() == POS_BELOW_C)\n+          {\n+            base = i;\n+            info[base].indic_position() = POS_BASE_C;\n+          }\n+        }\n+      }\n+\n+      if (start < base && info[base].indic_position() > POS_BASE_C)\n+        base--;\n+      break;\n+    }\n+  if (base == end && start < base &&\n+      is_one_of (info[base - 1], FLAG (I_Cat(ZWJ))))\n+    base--;\n+  if (base < end)\n+    while (start < base &&\n+           is_one_of (info[base], (FLAG (I_Cat(N)) | FLAG (I_Cat(H)))))\n+      base--;\n+\n+\n+  \/*   o Reorder matras:\n+   *\n+   *     If a pre-base matra character had been reordered before applying basic\n+   *     features, the glyph can be moved closer to the main consonant based on\n+   *     whether half-forms had been formed. Actual position for the matra is\n+   *     defined as after last standalone halant glyph, after initial matra\n+   *     position and before the main consonant. If ZWJ or ZWNJ follow this\n+   *     halant, position is moved after it.\n+   *\n+   * IMPLEMENTATION NOTES:\n+   *\n+   * It looks like the last sentence is wrong.  Testing, with Windows 7 Uniscribe\n+   * and Devanagari shows that the behavior is best described as:\n+   *\n+   * \"If ZWJ follows this halant, matra is NOT repositioned after this halant.\n+   *  If ZWNJ follows this halant, position is moved after it.\"\n+   *\n+   * Test case, with Adobe Devanagari or Nirmala UI:\n+   *\n+   *   U+091F,U+094D,U+200C,U+092F,U+093F\n+   *   (Matra moves to the middle, after ZWNJ.)\n+   *\n+   *   U+091F,U+094D,U+200D,U+092F,U+093F\n+   *   (Matra does NOT move, stays to the left.)\n+   *\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1070\n+   *\/\n+\n+  if (start + 1 < end && start < base) \/* Otherwise there can't be any pre-base matra characters. *\/\n+  {\n+    \/* If we lost track of base, alas, position before last thingy. *\/\n+    unsigned int new_pos = base == end ? base - 2 : base - 1;\n+\n+    \/* Malayalam \/ Tamil do not have \"half\" forms or explicit virama forms.\n+     * The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n+     * We want to position matra after them.\n+     *\/\n+    if (buffer->props.script != HB_SCRIPT_MALAYALAM && buffer->props.script != HB_SCRIPT_TAMIL)\n+    {\n+    search:\n+      while (new_pos > start &&\n+             !(is_one_of (info[new_pos], (FLAG (I_Cat(M)) | FLAG (I_Cat(H))))))\n+        new_pos--;\n+\n+      \/* If we found no Halant we are done.\n+       * Otherwise only proceed if the Halant does\n+       * not belong to the Matra itself! *\/\n+      if (is_halant (info[new_pos]) &&\n+          info[new_pos].indic_position() != POS_PRE_M)\n+      {\n+#if 0 \/\/ See comment above\n+        \/* -> If ZWJ or ZWNJ follow this halant, position is moved after it. *\/\n+        if (new_pos + 1 < end && is_joiner (info[new_pos + 1]))\n+          new_pos++;\n+#endif\n+        if (new_pos + 1 < end)\n+        {\n+          \/* -> If ZWJ follows this halant, matra is NOT repositioned after this halant. *\/\n+          if (info[new_pos + 1].indic_category() == I_Cat(ZWJ))\n+          {\n+            \/* Keep searching. *\/\n+            if (new_pos > start)\n+            {\n+              new_pos--;\n+              goto search;\n+            }\n+          }\n+          \/* -> If ZWNJ follows this halant, position is moved after it.\n+           *\n+           * IMPLEMENTATION NOTES:\n+           *\n+           * This is taken care of by the state-machine. A Halant,ZWNJ is a terminating\n+           * sequence for a consonant syllable; any pre-base matras occurring after it\n+           * will belong to the subsequent syllable.\n+           *\/\n+        }\n+      }\n+      else\n+        new_pos = start; \/* No move. *\/\n+    }\n+\n+    if (start < new_pos && info[new_pos].indic_position () != POS_PRE_M)\n+    {\n+      \/* Now go see if there's actually any matras... *\/\n+      for (unsigned int i = new_pos; i > start; i--)\n+        if (info[i - 1].indic_position () == POS_PRE_M)\n+        {\n+          unsigned int old_pos = i - 1;\n+          if (old_pos < base && base <= new_pos) \/* Shouldn't actually happen. *\/\n+            base--;\n+\n+          hb_glyph_info_t tmp = info[old_pos];\n+          memmove (&info[old_pos], &info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));\n+          info[new_pos] = tmp;\n+\n+          \/* Note: this merge_clusters() is intentionally *after* the reordering.\n+           * Indic matra reordering is special and tricky... *\/\n+          buffer->merge_clusters (new_pos, hb_min (end, base + 1));\n+\n+          new_pos--;\n+        }\n+    } else {\n+      for (unsigned int i = start; i < base; i++)\n+        if (info[i].indic_position () == POS_PRE_M) {\n+          buffer->merge_clusters (i, hb_min (end, base + 1));\n+          break;\n+        }\n+    }\n+  }\n+\n+\n+  \/*   o Reorder reph:\n+   *\n+   *     Rephs original position is always at the beginning of the syllable,\n+   *     (i.e. it is not reordered at the character reordering stage). However,\n+   *     it will be reordered according to the basic-forms shaping results.\n+   *     Possible positions for reph, depending on the script, are; after main,\n+   *     before post-base consonant forms, and after post-base consonant forms.\n+   *\/\n+\n+  \/* Two cases:\n+   *\n+   * - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then\n+   *   we should only move it if the sequence ligated to the repha form.\n+   *\n+   * - If repha is encoded separately and in the logical position, we should only\n+   *   move it if it did NOT ligate.  If it ligated, it's probably the font trying\n+   *   to make it work without the reordering.\n+   *\/\n+  if (start + 1 < end &&\n+      info[start].indic_position() == POS_RA_TO_BECOME_REPH &&\n+      ((info[start].indic_category() == I_Cat(Repha)) ^\n+       _hb_glyph_info_ligated_and_didnt_multiply (&info[start])))\n+  {\n+    unsigned int new_reph_pos;\n+    reph_position_t reph_pos = indic_plan->config->reph_pos;\n+\n+    \/*       1. If reph should be positioned after post-base consonant forms,\n+     *          proceed to step 5.\n+     *\/\n+    if (reph_pos == REPH_POS_AFTER_POST)\n+    {\n+      goto reph_step_5;\n+    }\n+\n+    \/*       2. If the reph repositioning class is not after post-base: target\n+     *          position is after the first explicit halant glyph between the\n+     *          first post-reph consonant and last main consonant. If ZWJ or ZWNJ\n+     *          are following this halant, position is moved after it. If such\n+     *          position is found, this is the target position. Otherwise,\n+     *          proceed to the next step.\n+     *\n+     *          Note: in old-implementation fonts, where classifications were\n+     *          fixed in shaping engine, there was no case where reph position\n+     *          will be found on this step.\n+     *\/\n+    {\n+      new_reph_pos = start + 1;\n+      while (new_reph_pos < base && !is_halant (info[new_reph_pos]))\n+        new_reph_pos++;\n+\n+      if (new_reph_pos < base && is_halant (info[new_reph_pos]))\n+      {\n+        \/* ->If ZWJ or ZWNJ are following this halant, position is moved after it. *\/\n+        if (new_reph_pos + 1 < base && is_joiner (info[new_reph_pos + 1]))\n+          new_reph_pos++;\n+        goto reph_move;\n+      }\n+    }\n+\n+    \/*       3. If reph should be repositioned after the main consonant: find the\n+     *          first consonant not ligated with main, or find the first\n+     *          consonant that is not a potential pre-base-reordering Ra.\n+     *\/\n+    if (reph_pos == REPH_POS_AFTER_MAIN)\n+    {\n+      new_reph_pos = base;\n+      while (new_reph_pos + 1 < end && info[new_reph_pos + 1].indic_position() <= POS_AFTER_MAIN)\n+        new_reph_pos++;\n+      if (new_reph_pos < end)\n+        goto reph_move;\n+    }\n+\n+    \/*       4. If reph should be positioned before post-base consonant, find\n+     *          first post-base classified consonant not ligated with main. If no\n+     *          consonant is found, the target position should be before the\n+     *          first matra, syllable modifier sign or vedic sign.\n+     *\/\n+    \/* This is our take on what step 4 is trying to say (and failing, BADLY). *\/\n+    if (reph_pos == REPH_POS_AFTER_SUB)\n+    {\n+      new_reph_pos = base;\n+      while (new_reph_pos + 1 < end &&\n+             !( FLAG_UNSAFE (info[new_reph_pos + 1].indic_position()) & (FLAG (POS_POST_C) | FLAG (POS_AFTER_POST) | FLAG (POS_SMVD))))\n+        new_reph_pos++;\n+      if (new_reph_pos < end)\n+        goto reph_move;\n+    }\n+\n+    \/*       5. If no consonant is found in steps 3 or 4, move reph to a position\n+     *          immediately before the first post-base matra, syllable modifier\n+     *          sign or vedic sign that has a reordering class after the intended\n+     *          reph position. For example, if the reordering position for reph\n+     *          is post-main, it will skip above-base matras that also have a\n+     *          post-main position.\n+     *\/\n+    reph_step_5:\n+    {\n+      \/* Copied from step 2. *\/\n+      new_reph_pos = start + 1;\n+      while (new_reph_pos < base && !is_halant (info[new_reph_pos]))\n+        new_reph_pos++;\n+\n+      if (new_reph_pos < base && is_halant (info[new_reph_pos]))\n+      {\n+        \/* ->If ZWJ or ZWNJ are following this halant, position is moved after it. *\/\n+        if (new_reph_pos + 1 < base && is_joiner (info[new_reph_pos + 1]))\n+          new_reph_pos++;\n+        goto reph_move;\n+      }\n+    }\n+    \/* See https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/2298#issuecomment-615318654 *\/\n+\n+    \/*       6. Otherwise, reorder reph to the end of the syllable.\n+     *\/\n+    {\n+      new_reph_pos = end - 1;\n+      while (new_reph_pos > start && info[new_reph_pos].indic_position() == POS_SMVD)\n+        new_reph_pos--;\n+\n+      \/*\n+       * If the Reph is to be ending up after a Matra,Halant sequence,\n+       * position it before that Halant so it can interact with the Matra.\n+       * However, if it's a plain Consonant,Halant we shouldn't do that.\n+       * Uniscribe doesn't do this.\n+       * TEST: U+0930,U+094D,U+0915,U+094B,U+094D\n+       *\/\n+      if (!indic_plan->uniscribe_bug_compatible &&\n+          unlikely (is_halant (info[new_reph_pos])))\n+      {\n+        for (unsigned int i = base + 1; i < new_reph_pos; i++)\n+          if (info[i].indic_category() == I_Cat(M)) {\n+            \/* Ok, got it. *\/\n+            new_reph_pos--;\n+          }\n+      }\n+\n+      goto reph_move;\n+    }\n+\n+    reph_move:\n+    {\n+      \/* Move *\/\n+      buffer->merge_clusters (start, new_reph_pos + 1);\n+      hb_glyph_info_t reph = info[start];\n+      memmove (&info[start], &info[start + 1], (new_reph_pos - start) * sizeof (info[0]));\n+      info[new_reph_pos] = reph;\n+\n+      if (start < base && base <= new_reph_pos)\n+        base--;\n+    }\n+  }\n+\n+\n+  \/*   o Reorder pre-base-reordering consonants:\n+   *\n+   *     If a pre-base-reordering consonant is found, reorder it according to\n+   *     the following rules:\n+   *\/\n+\n+  if (try_pref && base + 1 < end) \/* Otherwise there can't be any pre-base-reordering Ra. *\/\n+  {\n+    for (unsigned int i = base + 1; i < end; i++)\n+      if ((info[i].mask & indic_plan->mask_array[INDIC_PREF]) != 0)\n+      {\n+        \/*       1. Only reorder a glyph produced by substitution during application\n+         *          of the <pref> feature. (Note that a font may shape a Ra consonant with\n+         *          the feature generally but block it in certain contexts.)\n+         *\/\n+        \/* Note: We just check that something got substituted.  We don't check that\n+         * the <pref> feature actually did it...\n+         *\n+         * Reorder pref only if it ligated. *\/\n+        if (_hb_glyph_info_ligated_and_didnt_multiply (&info[i]))\n+        {\n+          \/*\n+           *       2. Try to find a target position the same way as for pre-base matra.\n+           *          If it is found, reorder pre-base consonant glyph.\n+           *\n+           *       3. If position is not found, reorder immediately before main\n+           *          consonant.\n+           *\/\n+\n+          unsigned int new_pos = base;\n+          \/* Malayalam \/ Tamil do not have \"half\" forms or explicit virama forms.\n+           * The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n+           * We want to position matra after them.\n+           *\/\n+          if (buffer->props.script != HB_SCRIPT_MALAYALAM && buffer->props.script != HB_SCRIPT_TAMIL)\n+          {\n+            while (new_pos > start &&\n+                   !(is_one_of (info[new_pos - 1], FLAG(I_Cat(M)) | FLAG (I_Cat(H)))))\n+              new_pos--;\n+          }\n+\n+          if (new_pos > start && is_halant (info[new_pos - 1]))\n+          {\n+            \/* -> If ZWJ or ZWNJ follow this halant, position is moved after it. *\/\n+            if (new_pos < end && is_joiner (info[new_pos]))\n+              new_pos++;\n+          }\n+\n+          {\n+            unsigned int old_pos = i;\n+\n+            buffer->merge_clusters (new_pos, old_pos + 1);\n+            hb_glyph_info_t tmp = info[old_pos];\n+            memmove (&info[new_pos + 1], &info[new_pos], (old_pos - new_pos) * sizeof (info[0]));\n+            info[new_pos] = tmp;\n+\n+            if (new_pos <= base && base < old_pos)\n+              base++;\n+          }\n+        }\n+\n+        break;\n+      }\n+  }\n+\n+\n+  \/* Apply 'init' to the Left Matra if it's a word start. *\/\n+  if (info[start].indic_position () == POS_PRE_M)\n+  {\n+    if (!start ||\n+        !(FLAG_UNSAFE (_hb_glyph_info_get_general_category (&info[start - 1])) &\n+         FLAG_RANGE (HB_UNICODE_GENERAL_CATEGORY_FORMAT, HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))\n+      info[start].mask |= indic_plan->mask_array[INDIC_INIT];\n+    else\n+      buffer->unsafe_to_break (start - 1, start + 1);\n+  }\n+\n+\n+  \/*\n+   * Finish off the clusters and go home!\n+   *\/\n+  if (indic_plan->uniscribe_bug_compatible)\n+  {\n+    switch ((hb_tag_t) plan->props.script)\n+    {\n+      case HB_SCRIPT_TAMIL:\n+        break;\n+\n+      default:\n+        \/* Uniscribe merges the entire syllable into a single cluster... Except for Tamil.\n+         * This means, half forms are submerged into the main consonant's cluster.\n+         * This is unnecessary, and makes cursor positioning harder, but that's what\n+         * Uniscribe does. *\/\n+        buffer->merge_clusters (start, end);\n+        break;\n+    }\n+  }\n+}\n+\n+\n+static void\n+final_reordering_indic (const hb_ot_shape_plan_t *plan,\n+                        hb_font_t *font HB_UNUSED,\n+                        hb_buffer_t *buffer)\n+{\n+  unsigned int count = buffer->len;\n+  if (unlikely (!count)) return;\n+\n+  if (buffer->message (font, \"start reordering indic final\")) {\n+    foreach_syllable (buffer, start, end)\n+      final_reordering_syllable_indic (plan, buffer, start, end);\n+    (void) buffer->message (font, \"end reordering indic final\");\n+  }\n+\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, indic_category);\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, indic_position);\n+}\n+\n+\n+static void\n+preprocess_text_indic (const hb_ot_shape_plan_t *plan,\n+                       hb_buffer_t              *buffer,\n+                       hb_font_t                *font)\n+{\n+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n+  if (!indic_plan->uniscribe_bug_compatible)\n+    _hb_preprocess_text_vowel_constraints (plan, buffer, font);\n+}\n+\n+static bool\n+decompose_indic (const hb_ot_shape_normalize_context_t *c,\n+                 hb_codepoint_t  ab,\n+                 hb_codepoint_t *a,\n+                 hb_codepoint_t *b)\n+{\n+  switch (ab)\n+  {\n+    \/* Don't decompose these. *\/\n+    case 0x0931u  : return false; \/* DEVANAGARI LETTER RRA *\/\n+    \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/779\n+    case 0x09DCu  : return false; \/* BENGALI LETTER RRA *\/\n+    case 0x09DDu  : return false; \/* BENGALI LETTER RHA *\/\n+    case 0x0B94u  : return false; \/* TAMIL LETTER AU *\/\n+\n+\n+    \/*\n+     * Decompose split matras that don't have Unicode decompositions.\n+     *\/\n+\n+#if 0\n+    \/* Gujarati *\/\n+    \/* This one has no decomposition in Unicode, but needs no decomposition either. *\/\n+    \/* case 0x0AC9u  : return false; *\/\n+\n+    \/* Oriya *\/\n+    case 0x0B57u  : *a = no decomp, -> RIGHT; return true;\n+#endif\n+  }\n+\n+  return (bool) c->unicode->decompose (ab, a, b);\n+}\n+\n+static bool\n+compose_indic (const hb_ot_shape_normalize_context_t *c,\n+               hb_codepoint_t  a,\n+               hb_codepoint_t  b,\n+               hb_codepoint_t *ab)\n+{\n+  \/* Avoid recomposing split matras. *\/\n+  if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c->unicode->general_category (a)))\n+    return false;\n+\n+  \/* Composition-exclusion exceptions that we want to recompose. *\/\n+  if (a == 0x09AFu && b == 0x09BCu) { *ab = 0x09DFu; return true; }\n+\n+  return (bool) c->unicode->compose (a, b, ab);\n+}\n+\n+\n+const hb_ot_shaper_t _hb_ot_shaper_indic =\n+{\n+  collect_features_indic,\n+  override_features_indic,\n+  data_create_indic,\n+  data_destroy_indic,\n+  preprocess_text_indic,\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n+  decompose_indic,\n+  compose_indic,\n+  setup_masks_indic,\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n+  false, \/* fallback_position *\/\n+};\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic.cc","additions":1542,"deletions":0,"binary":false,"changes":1542,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright  2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_INDIC_HH\n+#define HB_OT_SHAPER_INDIC_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shaper-syllabic.hh\"\n+\n+\n+\/* Visual positions in a syllable from left to right. *\/\n+enum ot_position_t {\n+  POS_START = 0,\n+\n+  POS_RA_TO_BECOME_REPH = 1,\n+  POS_PRE_M = 2,\n+  POS_PRE_C = 3,\n+\n+  POS_BASE_C = 4,\n+  POS_AFTER_MAIN = 5,\n+\n+  POS_ABOVE_C = 6,\n+\n+  POS_BEFORE_SUB = 7,\n+  POS_BELOW_C = 8,\n+  POS_AFTER_SUB = 9,\n+\n+  POS_BEFORE_POST = 10,\n+  POS_POST_C = 11,\n+  POS_AFTER_POST = 12,\n+\n+  POS_SMVD = 13,\n+\n+  POS_END = 14\n+};\n+\n+\n+HB_INTERNAL uint16_t\n+hb_indic_get_categories (hb_codepoint_t u);\n+\n+\n+#endif \/* HB_OT_SHAPER_INDIC_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic.hh","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,428 @@\n+\n+#line 1 \"hb-ot-shaper-khmer-machine.rl\"\n+\/*\n+ * Copyright  2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_KHMER_MACHINE_HH\n+#define HB_OT_SHAPER_KHMER_MACHINE_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-layout.hh\"\n+#include \"hb-ot-shaper-indic.hh\"\n+\n+\/* buffer var allocations *\/\n+#define khmer_category() ot_shaper_var_u8_category() \/* khmer_category_t *\/\n+\n+using khmer_category_t = unsigned;\n+\n+#define K_Cat(Cat) khmer_syllable_machine_ex_##Cat\n+\n+enum khmer_syllable_type_t {\n+  khmer_consonant_syllable,\n+  khmer_broken_cluster,\n+  khmer_non_khmer_cluster,\n+};\n+\n+\n+#line 52 \"hb-ot-shaper-khmer-machine.hh\"\n+#define khmer_syllable_machine_ex_C 1u\n+#define khmer_syllable_machine_ex_DOTTEDCIRCLE 11u\n+#define khmer_syllable_machine_ex_H 4u\n+#define khmer_syllable_machine_ex_PLACEHOLDER 10u\n+#define khmer_syllable_machine_ex_Ra 15u\n+#define khmer_syllable_machine_ex_Robatic 25u\n+#define khmer_syllable_machine_ex_V 2u\n+#define khmer_syllable_machine_ex_VAbv 20u\n+#define khmer_syllable_machine_ex_VBlw 21u\n+#define khmer_syllable_machine_ex_VPre 22u\n+#define khmer_syllable_machine_ex_VPst 23u\n+#define khmer_syllable_machine_ex_Xgroup 26u\n+#define khmer_syllable_machine_ex_Ygroup 27u\n+#define khmer_syllable_machine_ex_ZWJ 6u\n+#define khmer_syllable_machine_ex_ZWNJ 5u\n+\n+\n+#line 70 \"hb-ot-shaper-khmer-machine.hh\"\n+static const unsigned char _khmer_syllable_machine_trans_keys[] = {\n+        5u, 26u, 5u, 26u, 1u, 15u, 5u, 26u, 5u, 26u, 5u, 26u, 5u, 26u, 5u, 26u,\n+        5u, 26u, 5u, 26u, 5u, 26u, 5u, 26u, 5u, 26u, 1u, 15u, 5u, 26u, 5u, 26u,\n+        5u, 26u, 5u, 26u, 5u, 26u, 5u, 26u, 5u, 26u, 1u, 27u, 4u, 27u, 1u, 15u,\n+        4u, 27u, 4u, 27u, 27u, 27u, 4u, 27u, 4u, 27u, 4u, 27u, 4u, 27u, 4u, 27u,\n+        4u, 27u, 1u, 15u, 4u, 27u, 4u, 27u, 27u, 27u, 4u, 27u, 4u, 27u, 4u, 27u,\n+        4u, 27u, 4u, 27u, 5u, 26u, 0\n+};\n+\n+static const char _khmer_syllable_machine_key_spans[] = {\n+        22, 22, 15, 22, 22, 22, 22, 22,\n+        22, 22, 22, 22, 22, 15, 22, 22,\n+        22, 22, 22, 22, 22, 27, 24, 15,\n+        24, 24, 1, 24, 24, 24, 24, 24,\n+        24, 15, 24, 24, 1, 24, 24, 24,\n+        24, 24, 22\n+};\n+\n+static const short _khmer_syllable_machine_index_offsets[] = {\n+        0, 23, 46, 62, 85, 108, 131, 154,\n+        177, 200, 223, 246, 269, 292, 308, 331,\n+        354, 377, 400, 423, 446, 469, 497, 522,\n+        538, 563, 588, 590, 615, 640, 665, 690,\n+        715, 740, 756, 781, 806, 808, 833, 858,\n+        883, 908, 933\n+};\n+\n+static const char _khmer_syllable_machine_indicies[] = {\n+        1, 1, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 2,\n+        0, 0, 0, 0, 3, 4, 0, 1,\n+        1, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 4, 0, 5, 5,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 5, 0, 1, 1,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 2, 0, 0,\n+        0, 0, 0, 4, 0, 6, 6, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 2, 0, 7, 7, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 8, 0, 9, 9, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 2, 0, 0, 0, 0, 0,\n+        10, 0, 9, 9, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 10,\n+        0, 11, 11, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        2, 0, 0, 0, 0, 0, 12, 0,\n+        11, 11, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 12, 0, 1,\n+        1, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 2, 0,\n+        0, 0, 0, 13, 4, 0, 15, 15,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 16, 14, 14,\n+        14, 14, 17, 18, 14, 15, 15, 19,\n+        19, 19, 19, 19, 19, 19, 19, 19,\n+        19, 19, 19, 19, 19, 19, 19, 19,\n+        19, 19, 18, 19, 20, 20, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 20, 14, 15, 15, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 16, 14, 14, 14, 14,\n+        14, 18, 14, 21, 21, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        16, 14, 22, 22, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 23,\n+        14, 24, 24, 14, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        16, 14, 14, 14, 14, 14, 25, 14,\n+        24, 24, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 25, 14, 26,\n+        26, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 16, 14,\n+        14, 14, 14, 14, 27, 14, 26, 26,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 27, 14, 29, 29, 28,\n+        30, 31, 31, 28, 28, 28, 13, 13,\n+        28, 28, 28, 29, 28, 28, 28, 28,\n+        16, 25, 27, 23, 28, 17, 18, 20,\n+        28, 33, 34, 34, 32, 32, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        32, 2, 10, 12, 8, 32, 13, 4,\n+        5, 32, 35, 35, 32, 32, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        35, 32, 33, 36, 36, 32, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        32, 32, 2, 10, 12, 8, 32, 3,\n+        4, 5, 32, 37, 38, 38, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        32, 32, 32, 2, 10, 12, 8, 32,\n+        32, 4, 5, 32, 5, 32, 37, 6,\n+        6, 32, 32, 32, 32, 32, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        32, 8, 32, 32, 2, 5, 32, 37,\n+        7, 7, 32, 32, 32, 32, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        32, 32, 32, 32, 32, 8, 5, 32,\n+        37, 39, 39, 32, 32, 32, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        2, 32, 32, 8, 32, 32, 10, 5,\n+        32, 37, 40, 40, 32, 32, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        32, 2, 10, 32, 8, 32, 32, 12,\n+        5, 32, 33, 38, 38, 32, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        32, 32, 2, 10, 12, 8, 32, 32,\n+        4, 5, 32, 33, 38, 38, 32, 32,\n+        32, 32, 32, 32, 32, 32, 32, 32,\n+        32, 32, 32, 2, 10, 12, 8, 32,\n+        3, 4, 5, 32, 42, 42, 41, 41,\n+        41, 41, 41, 41, 41, 41, 41, 41,\n+        41, 41, 42, 41, 30, 43, 43, 41,\n+        41, 41, 41, 41, 41, 41, 41, 41,\n+        41, 41, 41, 41, 16, 25, 27, 23,\n+        41, 17, 18, 20, 41, 44, 45, 45,\n+        41, 41, 41, 41, 41, 41, 41, 41,\n+        41, 41, 41, 41, 41, 16, 25, 27,\n+        23, 41, 41, 18, 20, 41, 20, 41,\n+        44, 21, 21, 41, 41, 41, 41, 41,\n+        41, 41, 41, 41, 41, 41, 41, 41,\n+        41, 41, 41, 23, 41, 41, 16, 20,\n+        41, 44, 22, 22, 41, 41, 41, 41,\n+        41, 41, 41, 41, 41, 41, 41, 41,\n+        41, 41, 41, 41, 41, 41, 41, 23,\n+        20, 41, 44, 46, 46, 41, 41, 41,\n+        41, 41, 41, 41, 41, 41, 41, 41,\n+        41, 41, 16, 41, 41, 23, 41, 41,\n+        25, 20, 41, 44, 47, 47, 41, 41,\n+        41, 41, 41, 41, 41, 41, 41, 41,\n+        41, 41, 41, 16, 25, 41, 23, 41,\n+        41, 27, 20, 41, 30, 45, 45, 41,\n+        41, 41, 41, 41, 41, 41, 41, 41,\n+        41, 41, 41, 41, 16, 25, 27, 23,\n+        41, 41, 18, 20, 41, 15, 15, 48,\n+        48, 48, 48, 48, 48, 48, 48, 48,\n+        48, 48, 48, 48, 16, 48, 48, 48,\n+        48, 48, 18, 48, 0\n+};\n+\n+static const char _khmer_syllable_machine_trans_targs[] = {\n+        21, 1, 27, 31, 25, 26, 4, 5,\n+        28, 7, 29, 9, 30, 32, 21, 12,\n+        37, 41, 35, 21, 36, 15, 16, 38,\n+        18, 39, 20, 40, 21, 22, 33, 42,\n+        21, 23, 10, 24, 0, 2, 3, 6,\n+        8, 21, 34, 11, 13, 14, 17, 19,\n+        21\n+};\n+\n+static const char _khmer_syllable_machine_trans_actions[] = {\n+        1, 0, 2, 2, 2, 0, 0, 0,\n+        2, 0, 2, 0, 2, 2, 3, 0,\n+        2, 4, 4, 5, 0, 0, 0, 2,\n+        0, 2, 0, 2, 8, 2, 0, 9,\n+        10, 0, 0, 2, 0, 0, 0, 0,\n+        0, 11, 4, 0, 0, 0, 0, 0,\n+        12\n+};\n+\n+static const char _khmer_syllable_machine_to_state_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 6, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0\n+};\n+\n+static const char _khmer_syllable_machine_from_state_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 7, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0\n+};\n+\n+static const short _khmer_syllable_machine_eof_trans[] = {\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 15, 20, 15, 15, 15,\n+        15, 15, 15, 15, 15, 0, 33, 33,\n+        33, 33, 33, 33, 33, 33, 33, 33,\n+        33, 42, 42, 42, 42, 42, 42, 42,\n+        42, 42, 49\n+};\n+\n+static const int khmer_syllable_machine_start = 21;\n+static const int khmer_syllable_machine_first_final = 21;\n+static const int khmer_syllable_machine_error = -1;\n+\n+static const int khmer_syllable_machine_en_main = 21;\n+\n+\n+#line 53 \"hb-ot-shaper-khmer-machine.rl\"\n+\n+\n+\n+#line 102 \"hb-ot-shaper-khmer-machine.rl\"\n+\n+\n+#define found_syllable(syllable_type) \\\n+  HB_STMT_START { \\\n+    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    for (unsigned int i = ts; i < te; i++) \\\n+      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n+    syllable_serial++; \\\n+    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+  } HB_STMT_END\n+\n+inline void\n+find_syllables_khmer (hb_buffer_t *buffer)\n+{\n+  unsigned int p, pe, eof, ts, te, act HB_UNUSED;\n+  int cs;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+#line 298 \"hb-ot-shaper-khmer-machine.hh\"\n+        {\n+        cs = khmer_syllable_machine_start;\n+        ts = 0;\n+        te = 0;\n+        act = 0;\n+        }\n+\n+#line 122 \"hb-ot-shaper-khmer-machine.rl\"\n+\n+\n+  p = 0;\n+  pe = eof = buffer->len;\n+\n+  unsigned int syllable_serial = 1;\n+\n+#line 314 \"hb-ot-shaper-khmer-machine.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+_resume:\n+        switch ( _khmer_syllable_machine_from_state_actions[cs] ) {\n+        case 7:\n+#line 1 \"NONE\"\n+        {ts = p;}\n+        break;\n+#line 328 \"hb-ot-shaper-khmer-machine.hh\"\n+        }\n+\n+        _keys = _khmer_syllable_machine_trans_keys + (cs<<1);\n+        _inds = _khmer_syllable_machine_indicies + _khmer_syllable_machine_index_offsets[cs];\n+\n+        _slen = _khmer_syllable_machine_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=( info[p].khmer_category()) &&\n+                ( info[p].khmer_category()) <= _keys[1] ?\n+                ( info[p].khmer_category()) - _keys[0] : _slen ];\n+\n+_eof_trans:\n+        cs = _khmer_syllable_machine_trans_targs[_trans];\n+\n+        if ( _khmer_syllable_machine_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _khmer_syllable_machine_trans_actions[_trans] ) {\n+        case 2:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+        break;\n+        case 8:\n+#line 98 \"hb-ot-shaper-khmer-machine.rl\"\n+        {te = p+1;{ found_syllable (khmer_non_khmer_cluster); }}\n+        break;\n+        case 10:\n+#line 96 \"hb-ot-shaper-khmer-machine.rl\"\n+        {te = p;p--;{ found_syllable (khmer_consonant_syllable); }}\n+        break;\n+        case 11:\n+#line 97 \"hb-ot-shaper-khmer-machine.rl\"\n+        {te = p;p--;{ found_syllable (khmer_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }}\n+        break;\n+        case 12:\n+#line 98 \"hb-ot-shaper-khmer-machine.rl\"\n+        {te = p;p--;{ found_syllable (khmer_non_khmer_cluster); }}\n+        break;\n+        case 1:\n+#line 96 \"hb-ot-shaper-khmer-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (khmer_consonant_syllable); }}\n+        break;\n+        case 3:\n+#line 97 \"hb-ot-shaper-khmer-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (khmer_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }}\n+        break;\n+        case 5:\n+#line 1 \"NONE\"\n+        {       switch( act ) {\n+        case 2:\n+        {{p = ((te))-1;} found_syllable (khmer_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }\n+        break;\n+        case 3:\n+        {{p = ((te))-1;} found_syllable (khmer_non_khmer_cluster); }\n+        break;\n+        }\n+        }\n+        break;\n+        case 4:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 97 \"hb-ot-shaper-khmer-machine.rl\"\n+        {act = 2;}\n+        break;\n+        case 9:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 98 \"hb-ot-shaper-khmer-machine.rl\"\n+        {act = 3;}\n+        break;\n+#line 398 \"hb-ot-shaper-khmer-machine.hh\"\n+        }\n+\n+_again:\n+        switch ( _khmer_syllable_machine_to_state_actions[cs] ) {\n+        case 6:\n+#line 1 \"NONE\"\n+        {ts = 0;}\n+        break;\n+#line 407 \"hb-ot-shaper-khmer-machine.hh\"\n+        }\n+\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        if ( _khmer_syllable_machine_eof_trans[cs] > 0 ) {\n+                _trans = _khmer_syllable_machine_eof_trans[cs] - 1;\n+                goto _eof_trans;\n+        }\n+        }\n+\n+        }\n+\n+#line 130 \"hb-ot-shaper-khmer-machine.rl\"\n+\n+}\n+\n+#undef found_syllable\n+\n+#endif \/* HB_OT_SHAPER_KHMER_MACHINE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-khmer-machine.hh","additions":428,"deletions":0,"binary":false,"changes":428,"status":"added"},{"patch":"@@ -0,0 +1,382 @@\n+\/*\n+ * Copyright  2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_OT_SHAPE\n+\n+#include \"hb-ot-shaper-khmer-machine.hh\"\n+#include \"hb-ot-shaper-indic.hh\"\n+#include \"hb-ot-layout.hh\"\n+\n+\n+\/*\n+ * Khmer shaper.\n+ *\/\n+\n+\n+static const hb_ot_map_feature_t\n+khmer_features[] =\n+{\n+  \/*\n+   * Basic features.\n+   * These features are applied all at once, before reordering, constrained\n+   * to the syllable.\n+   *\/\n+  {HB_TAG('p','r','e','f'), F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('b','l','w','f'), F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('a','b','v','f'), F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('p','s','t','f'), F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  {HB_TAG('c','f','a','r'), F_MANUAL_JOINERS | F_PER_SYLLABLE},\n+  \/*\n+   * Other features.\n+   * These features are applied all at once after clearing syllables.\n+   *\/\n+  {HB_TAG('p','r','e','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('a','b','v','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('b','l','w','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('p','s','t','s'), F_GLOBAL_MANUAL_JOINERS},\n+};\n+\n+\/*\n+ * Must be in the same order as the khmer_features array.\n+ *\/\n+enum {\n+  KHMER_PREF,\n+  KHMER_BLWF,\n+  KHMER_ABVF,\n+  KHMER_PSTF,\n+  KHMER_CFAR,\n+\n+  _KHMER_PRES,\n+  _KHMER_ABVS,\n+  _KHMER_BLWS,\n+  _KHMER_PSTS,\n+\n+  KHMER_NUM_FEATURES,\n+  KHMER_BASIC_FEATURES = _KHMER_PRES, \/* Don't forget to update this! *\/\n+};\n+\n+static inline void\n+set_khmer_properties (hb_glyph_info_t &info)\n+{\n+  hb_codepoint_t u = info.codepoint;\n+  unsigned int type = hb_indic_get_categories (u);\n+\n+  info.khmer_category() = (khmer_category_t) (type & 0xFFu);\n+}\n+\n+static void\n+setup_syllables_khmer (const hb_ot_shape_plan_t *plan,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer);\n+static void\n+reorder_khmer (const hb_ot_shape_plan_t *plan,\n+               hb_font_t *font,\n+               hb_buffer_t *buffer);\n+\n+static void\n+collect_features_khmer (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* Do this before any lookups have been applied. *\/\n+  map->add_gsub_pause (setup_syllables_khmer);\n+  map->add_gsub_pause (reorder_khmer);\n+\n+  \/* Testing suggests that Uniscribe does NOT pause between basic\n+   * features.  Test with KhmerUI.ttf and the following three\n+   * sequences:\n+   *\n+   *   U+1789,U+17BC\n+   *   U+1789,U+17D2,U+1789\n+   *   U+1789,U+17D2,U+1789,U+17BC\n+   *\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/974\n+   *\/\n+  map->enable_feature (HB_TAG('l','o','c','l'), F_PER_SYLLABLE);\n+  map->enable_feature (HB_TAG('c','c','m','p'), F_PER_SYLLABLE);\n+\n+  unsigned int i = 0;\n+  for (; i < KHMER_BASIC_FEATURES; i++)\n+    map->add_feature (khmer_features[i]);\n+\n+  \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/3531 *\/\n+  map->add_gsub_pause (hb_syllabic_clear_var); \/\/ Don't need syllables anymore, use stop to free buffer var\n+\n+  for (; i < KHMER_NUM_FEATURES; i++)\n+    map->add_feature (khmer_features[i]);\n+}\n+\n+static void\n+override_features_khmer (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* Khmer spec has 'clig' as part of required shaping features:\n+   * \"Apply feature 'clig' to form ligatures that are desired for\n+   * typographical correctness.\", hence in overrides... *\/\n+  map->enable_feature (HB_TAG('c','l','i','g'));\n+\n+  \/* Uniscribe does not apply 'kern' in Khmer. *\/\n+  if (hb_options ().uniscribe_bug_compatible)\n+  {\n+    map->disable_feature (HB_TAG('k','e','r','n'));\n+  }\n+\n+  map->disable_feature (HB_TAG('l','i','g','a'));\n+}\n+\n+\n+struct khmer_shape_plan_t\n+{\n+  hb_mask_t mask_array[KHMER_NUM_FEATURES];\n+};\n+\n+static void *\n+data_create_khmer (const hb_ot_shape_plan_t *plan)\n+{\n+  khmer_shape_plan_t *khmer_plan = (khmer_shape_plan_t *) hb_calloc (1, sizeof (khmer_shape_plan_t));\n+  if (unlikely (!khmer_plan))\n+    return nullptr;\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (khmer_plan->mask_array); i++)\n+    khmer_plan->mask_array[i] = (khmer_features[i].flags & F_GLOBAL) ?\n+                                 0 : plan->map.get_1_mask (khmer_features[i].tag);\n+\n+  return khmer_plan;\n+}\n+\n+static void\n+data_destroy_khmer (void *data)\n+{\n+  hb_free (data);\n+}\n+\n+static void\n+setup_masks_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                   hb_buffer_t              *buffer,\n+                   hb_font_t                *font HB_UNUSED)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, khmer_category);\n+\n+  \/* We cannot setup masks here.  We save information about characters\n+   * and setup masks later on in a pause-callback. *\/\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    set_khmer_properties (info[i]);\n+}\n+\n+static void\n+setup_syllables_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                       hb_font_t *font HB_UNUSED,\n+                       hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, syllable);\n+  find_syllables_khmer (buffer);\n+  foreach_syllable (buffer, start, end)\n+    buffer->unsafe_to_break (start, end);\n+}\n+\n+\n+\/* Rules from:\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/devanagari *\/\n+\n+static void\n+reorder_consonant_syllable (const hb_ot_shape_plan_t *plan,\n+                            hb_face_t *face HB_UNUSED,\n+                            hb_buffer_t *buffer,\n+                            unsigned int start, unsigned int end)\n+{\n+  const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan->data;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  \/* Setup masks. *\/\n+  {\n+    \/* Post-base *\/\n+    hb_mask_t mask = khmer_plan->mask_array[KHMER_BLWF] |\n+                     khmer_plan->mask_array[KHMER_ABVF] |\n+                     khmer_plan->mask_array[KHMER_PSTF];\n+    for (unsigned int i = start + 1; i < end; i++)\n+      info[i].mask  |= mask;\n+  }\n+\n+  unsigned int num_coengs = 0;\n+  for (unsigned int i = start + 1; i < end; i++)\n+  {\n+    \/* \"\"\"\n+     * When a COENG + (Cons | IndV) combination are found (and subscript count\n+     * is less than two) the character combination is handled according to the\n+     * subscript type of the character following the COENG.\n+     *\n+     * ...\n+     *\n+     * Subscript Type 2 - The COENG + RO characters are reordered to immediately\n+     * before the base glyph. Then the COENG + RO characters are assigned to have\n+     * the 'pref' OpenType feature applied to them.\n+     * \"\"\"\n+     *\/\n+    if (info[i].khmer_category() == K_Cat(H) && num_coengs <= 2 && i + 1 < end)\n+    {\n+      num_coengs++;\n+\n+      if (info[i + 1].khmer_category() == K_Cat(Ra))\n+      {\n+        for (unsigned int j = 0; j < 2; j++)\n+          info[i + j].mask |= khmer_plan->mask_array[KHMER_PREF];\n+\n+        \/* Move the Coeng,Ro sequence to the start. *\/\n+        buffer->merge_clusters (start, i + 2);\n+        hb_glyph_info_t t0 = info[i];\n+        hb_glyph_info_t t1 = info[i + 1];\n+        memmove (&info[start + 2], &info[start], (i - start) * sizeof (info[0]));\n+        info[start] = t0;\n+        info[start + 1] = t1;\n+\n+        \/* Mark the subsequent stuff with 'cfar'.  Used in Khmer.\n+         * Read the feature spec.\n+         * This allows distinguishing the following cases with MS Khmer fonts:\n+         * U+1784,U+17D2,U+179A,U+17D2,U+1782\n+         * U+1784,U+17D2,U+1782,U+17D2,U+179A\n+         *\/\n+        if (khmer_plan->mask_array[KHMER_CFAR])\n+          for (unsigned int j = i + 2; j < end; j++)\n+            info[j].mask |= khmer_plan->mask_array[KHMER_CFAR];\n+\n+        num_coengs = 2; \/* Done. *\/\n+      }\n+    }\n+\n+    \/* Reorder left matra piece. *\/\n+    else if (info[i].khmer_category() == K_Cat(VPre))\n+    {\n+      \/* Move to the start. *\/\n+      buffer->merge_clusters (start, i + 1);\n+      hb_glyph_info_t t = info[i];\n+      memmove (&info[start + 1], &info[start], (i - start) * sizeof (info[0]));\n+      info[start] = t;\n+    }\n+  }\n+}\n+\n+static void\n+reorder_syllable_khmer (const hb_ot_shape_plan_t *plan,\n+                        hb_face_t *face,\n+                        hb_buffer_t *buffer,\n+                        unsigned int start, unsigned int end)\n+{\n+  khmer_syllable_type_t syllable_type = (khmer_syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n+  switch (syllable_type)\n+  {\n+    case khmer_broken_cluster: \/* We already inserted dotted-circles, so just call the consonant_syllable. *\/\n+    case khmer_consonant_syllable:\n+     reorder_consonant_syllable (plan, face, buffer, start, end);\n+     break;\n+\n+    case khmer_non_khmer_cluster:\n+      break;\n+  }\n+}\n+\n+static void\n+reorder_khmer (const hb_ot_shape_plan_t *plan,\n+               hb_font_t *font,\n+               hb_buffer_t *buffer)\n+{\n+  if (buffer->message (font, \"start reordering khmer\"))\n+  {\n+    hb_syllabic_insert_dotted_circles (font, buffer,\n+                                       khmer_broken_cluster,\n+                                       K_Cat(DOTTEDCIRCLE),\n+                                       (unsigned) -1);\n+\n+    foreach_syllable (buffer, start, end)\n+      reorder_syllable_khmer (plan, font->face, buffer, start, end);\n+    (void) buffer->message (font, \"end reordering khmer\");\n+  }\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_category);\n+}\n+\n+\n+static bool\n+decompose_khmer (const hb_ot_shape_normalize_context_t *c,\n+                 hb_codepoint_t  ab,\n+                 hb_codepoint_t *a,\n+                 hb_codepoint_t *b)\n+{\n+  switch (ab)\n+  {\n+    \/*\n+     * Decompose split matras that don't have Unicode decompositions.\n+     *\/\n+\n+    \/* Khmer *\/\n+    case 0x17BEu  : *a = 0x17C1u; *b= 0x17BEu; return true;\n+    case 0x17BFu  : *a = 0x17C1u; *b= 0x17BFu; return true;\n+    case 0x17C0u  : *a = 0x17C1u; *b= 0x17C0u; return true;\n+    case 0x17C4u  : *a = 0x17C1u; *b= 0x17C4u; return true;\n+    case 0x17C5u  : *a = 0x17C1u; *b= 0x17C5u; return true;\n+  }\n+\n+  return (bool) c->unicode->decompose (ab, a, b);\n+}\n+\n+static bool\n+compose_khmer (const hb_ot_shape_normalize_context_t *c,\n+               hb_codepoint_t  a,\n+               hb_codepoint_t  b,\n+               hb_codepoint_t *ab)\n+{\n+  \/* Avoid recomposing split matras. *\/\n+  if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c->unicode->general_category (a)))\n+    return false;\n+\n+  return (bool) c->unicode->compose (a, b, ab);\n+}\n+\n+\n+const hb_ot_shaper_t _hb_ot_shaper_khmer =\n+{\n+  collect_features_khmer,\n+  override_features_khmer,\n+  data_create_khmer,\n+  data_destroy_khmer,\n+  nullptr, \/* preprocess_text *\/\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n+  decompose_khmer,\n+  compose_khmer,\n+  setup_masks_khmer,\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n+  false, \/* fallback_position *\/\n+};\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-khmer.cc","additions":382,"deletions":0,"binary":false,"changes":382,"status":"added"},{"patch":"@@ -0,0 +1,553 @@\n+\n+#line 1 \"hb-ot-shaper-myanmar-machine.rl\"\n+\/*\n+ * Copyright  2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_MYANMAR_MACHINE_HH\n+#define HB_OT_SHAPER_MYANMAR_MACHINE_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-layout.hh\"\n+#include \"hb-ot-shaper-indic.hh\"\n+\n+\/* buffer var allocations *\/\n+#define myanmar_category() ot_shaper_var_u8_category() \/* myanmar_category_t *\/\n+#define myanmar_position() ot_shaper_var_u8_auxiliary() \/* myanmar_position_t *\/\n+\n+using myanmar_category_t = unsigned;\n+using myanmar_position_t = ot_position_t;\n+\n+#define M_Cat(Cat) myanmar_syllable_machine_ex_##Cat\n+\n+enum myanmar_syllable_type_t {\n+  myanmar_consonant_syllable,\n+  myanmar_broken_cluster,\n+  myanmar_non_myanmar_cluster,\n+};\n+\n+\n+#line 54 \"hb-ot-shaper-myanmar-machine.hh\"\n+#define myanmar_syllable_machine_ex_A 9u\n+#define myanmar_syllable_machine_ex_As 32u\n+#define myanmar_syllable_machine_ex_C 1u\n+#define myanmar_syllable_machine_ex_CS 18u\n+#define myanmar_syllable_machine_ex_DB 3u\n+#define myanmar_syllable_machine_ex_DOTTEDCIRCLE 11u\n+#define myanmar_syllable_machine_ex_GB 10u\n+#define myanmar_syllable_machine_ex_H 4u\n+#define myanmar_syllable_machine_ex_IV 2u\n+#define myanmar_syllable_machine_ex_MH 35u\n+#define myanmar_syllable_machine_ex_ML 41u\n+#define myanmar_syllable_machine_ex_MR 36u\n+#define myanmar_syllable_machine_ex_MW 37u\n+#define myanmar_syllable_machine_ex_MY 38u\n+#define myanmar_syllable_machine_ex_PT 39u\n+#define myanmar_syllable_machine_ex_Ra 15u\n+#define myanmar_syllable_machine_ex_SM 8u\n+#define myanmar_syllable_machine_ex_VAbv 20u\n+#define myanmar_syllable_machine_ex_VBlw 21u\n+#define myanmar_syllable_machine_ex_VPre 22u\n+#define myanmar_syllable_machine_ex_VPst 23u\n+#define myanmar_syllable_machine_ex_VS 40u\n+#define myanmar_syllable_machine_ex_ZWJ 6u\n+#define myanmar_syllable_machine_ex_ZWNJ 5u\n+\n+\n+#line 81 \"hb-ot-shaper-myanmar-machine.hh\"\n+static const unsigned char _myanmar_syllable_machine_trans_keys[] = {\n+        1u, 41u, 3u, 41u, 5u, 39u, 5u, 8u, 3u, 41u, 3u, 39u, 3u, 39u, 5u, 39u,\n+        5u, 39u, 3u, 39u, 3u, 39u, 3u, 41u, 5u, 39u, 1u, 15u, 3u, 39u, 3u, 39u,\n+        3u, 40u, 3u, 39u, 3u, 41u, 3u, 41u, 3u, 39u, 3u, 41u, 3u, 41u, 3u, 41u,\n+        3u, 41u, 3u, 41u, 5u, 39u, 5u, 8u, 3u, 41u, 3u, 39u, 3u, 39u, 5u, 39u,\n+        5u, 39u, 3u, 39u, 3u, 39u, 3u, 41u, 5u, 39u, 1u, 15u, 3u, 41u, 3u, 39u,\n+        3u, 39u, 3u, 40u, 3u, 39u, 3u, 41u, 3u, 41u, 3u, 39u, 3u, 41u, 3u, 41u,\n+        3u, 41u, 3u, 41u, 3u, 41u, 3u, 41u, 3u, 41u, 1u, 41u, 1u, 15u, 0\n+};\n+\n+static const char _myanmar_syllable_machine_key_spans[] = {\n+        41, 39, 35, 4, 39, 37, 37, 35,\n+        35, 37, 37, 39, 35, 15, 37, 37,\n+        38, 37, 39, 39, 37, 39, 39, 39,\n+        39, 39, 35, 4, 39, 37, 37, 35,\n+        35, 37, 37, 39, 35, 15, 39, 37,\n+        37, 38, 37, 39, 39, 37, 39, 39,\n+        39, 39, 39, 39, 39, 41, 15\n+};\n+\n+static const short _myanmar_syllable_machine_index_offsets[] = {\n+        0, 42, 82, 118, 123, 163, 201, 239,\n+        275, 311, 349, 387, 427, 463, 479, 517,\n+        555, 594, 632, 672, 712, 750, 790, 830,\n+        870, 910, 950, 986, 991, 1031, 1069, 1107,\n+        1143, 1179, 1217, 1255, 1295, 1331, 1347, 1387,\n+        1425, 1463, 1502, 1540, 1580, 1620, 1658, 1698,\n+        1738, 1778, 1818, 1858, 1898, 1938, 1980\n+};\n+\n+static const char _myanmar_syllable_machine_indicies[] = {\n+        1, 1, 2, 3, 4, 4, 0, 5,\n+        6, 1, 1, 0, 0, 0, 7, 0,\n+        0, 8, 0, 9, 10, 11, 12, 0,\n+        0, 0, 0, 0, 0, 0, 0, 13,\n+        0, 0, 14, 15, 16, 17, 18, 19,\n+        20, 0, 22, 23, 24, 24, 21, 25,\n+        26, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 27, 28, 29, 30, 21,\n+        21, 21, 21, 21, 21, 21, 21, 31,\n+        21, 21, 32, 33, 34, 35, 36, 37,\n+        38, 21, 24, 24, 21, 25, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 30, 21, 21, 21,\n+        21, 21, 21, 21, 21, 39, 21, 21,\n+        21, 21, 21, 21, 36, 21, 24, 24,\n+        21, 25, 21, 22, 21, 24, 24, 21,\n+        25, 26, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 40, 21, 21, 30,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        41, 21, 21, 42, 21, 21, 21, 36,\n+        21, 41, 21, 22, 21, 24, 24, 21,\n+        25, 26, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 30,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 36,\n+        21, 43, 21, 24, 24, 21, 25, 36,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 44, 21,\n+        21, 21, 21, 21, 21, 36, 21, 24,\n+        24, 21, 25, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 44, 21, 21, 21, 21, 21,\n+        21, 36, 21, 24, 24, 21, 25, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 36, 21, 22,\n+        21, 24, 24, 21, 25, 26, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        40, 21, 21, 30, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 36, 21, 22, 21, 24,\n+        24, 21, 25, 26, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 40, 21,\n+        21, 30, 21, 21, 21, 21, 21, 21,\n+        21, 21, 41, 21, 21, 21, 21, 21,\n+        21, 36, 21, 22, 21, 24, 24, 21,\n+        25, 26, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 40, 21, 21, 30,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        41, 21, 21, 21, 21, 21, 21, 36,\n+        21, 41, 21, 24, 24, 21, 25, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 30, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 36, 21, 1,\n+        1, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 1, 21, 22,\n+        21, 24, 24, 21, 25, 26, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        27, 28, 21, 30, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 36, 21, 22, 21, 24,\n+        24, 21, 25, 26, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 28,\n+        21, 30, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 36, 21, 22, 21, 24, 24, 21,\n+        25, 26, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 27, 28, 29, 30,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 36,\n+        45, 21, 22, 21, 24, 24, 21, 25,\n+        26, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 27, 28, 29, 30, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 36, 21,\n+        22, 21, 24, 24, 21, 25, 26, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 27, 28, 29, 30, 21, 21, 21,\n+        21, 21, 21, 21, 21, 31, 21, 21,\n+        32, 33, 34, 35, 36, 21, 38, 21,\n+        22, 21, 24, 24, 21, 25, 26, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 27, 28, 29, 30, 21, 21, 21,\n+        21, 21, 21, 21, 21, 45, 21, 21,\n+        21, 21, 21, 21, 36, 21, 38, 21,\n+        22, 21, 24, 24, 21, 25, 26, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 27, 28, 29, 30, 21, 21, 21,\n+        21, 21, 21, 21, 21, 45, 21, 21,\n+        21, 21, 21, 21, 36, 21, 22, 21,\n+        24, 24, 21, 25, 26, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 27,\n+        28, 29, 30, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 32, 21,\n+        34, 21, 36, 21, 38, 21, 22, 21,\n+        24, 24, 21, 25, 26, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 27,\n+        28, 29, 30, 21, 21, 21, 21, 21,\n+        21, 21, 21, 45, 21, 21, 32, 21,\n+        21, 21, 36, 21, 38, 21, 22, 21,\n+        24, 24, 21, 25, 26, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 27,\n+        28, 29, 30, 21, 21, 21, 21, 21,\n+        21, 21, 21, 46, 21, 21, 32, 33,\n+        34, 21, 36, 21, 38, 21, 22, 21,\n+        24, 24, 21, 25, 26, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 27,\n+        28, 29, 30, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 32, 33,\n+        34, 21, 36, 21, 38, 21, 22, 23,\n+        24, 24, 21, 25, 26, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 27,\n+        28, 29, 30, 21, 21, 21, 21, 21,\n+        21, 21, 21, 31, 21, 21, 32, 33,\n+        34, 35, 36, 21, 38, 21, 48, 48,\n+        47, 5, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        12, 47, 47, 47, 47, 47, 47, 47,\n+        47, 49, 47, 47, 47, 47, 47, 47,\n+        18, 47, 48, 48, 47, 5, 47, 2,\n+        47, 48, 48, 47, 5, 6, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        50, 47, 47, 12, 47, 47, 47, 47,\n+        47, 47, 47, 47, 51, 47, 47, 52,\n+        47, 47, 47, 18, 47, 51, 47, 2,\n+        47, 48, 48, 47, 5, 6, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 12, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 18, 47, 53, 47, 48,\n+        48, 47, 5, 18, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 54, 47, 47, 47, 47, 47,\n+        47, 18, 47, 48, 48, 47, 5, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 54, 47,\n+        47, 47, 47, 47, 47, 18, 47, 48,\n+        48, 47, 5, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 18, 47, 2, 47, 48, 48, 47,\n+        5, 6, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 50, 47, 47, 12,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 18,\n+        47, 2, 47, 48, 48, 47, 5, 6,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 50, 47, 47, 12, 47, 47,\n+        47, 47, 47, 47, 47, 47, 51, 47,\n+        47, 47, 47, 47, 47, 18, 47, 2,\n+        47, 48, 48, 47, 5, 6, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        50, 47, 47, 12, 47, 47, 47, 47,\n+        47, 47, 47, 47, 51, 47, 47, 47,\n+        47, 47, 47, 18, 47, 51, 47, 48,\n+        48, 47, 5, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 12, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 18, 47, 55, 55, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 55, 47, 2, 3, 48, 48, 47,\n+        5, 6, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 9, 10, 11, 12,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        13, 47, 47, 14, 15, 16, 17, 18,\n+        19, 20, 47, 2, 47, 48, 48, 47,\n+        5, 6, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 9, 10, 47, 12,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 18,\n+        47, 2, 47, 48, 48, 47, 5, 6,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 10, 47, 12, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 18, 47, 2,\n+        47, 48, 48, 47, 5, 6, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        9, 10, 11, 12, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 18, 56, 47, 2, 47,\n+        48, 48, 47, 5, 6, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 9,\n+        10, 11, 12, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 18, 47, 2, 47, 48, 48,\n+        47, 5, 6, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 9, 10, 11,\n+        12, 47, 47, 47, 47, 47, 47, 47,\n+        47, 13, 47, 47, 14, 15, 16, 17,\n+        18, 47, 20, 47, 2, 47, 48, 48,\n+        47, 5, 6, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 9, 10, 11,\n+        12, 47, 47, 47, 47, 47, 47, 47,\n+        47, 56, 47, 47, 47, 47, 47, 47,\n+        18, 47, 20, 47, 2, 47, 48, 48,\n+        47, 5, 6, 47, 47, 47, 47, 47,\n+        47, 47, 47, 47, 47, 9, 10, 11,\n+        12, 47, 47, 47, 47, 47, 47, 47,\n+        47, 56, 47, 47, 47, 47, 47, 47,\n+        18, 47, 2, 47, 48, 48, 47, 5,\n+        6, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 9, 10, 11, 12, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 14, 47, 16, 47, 18, 47,\n+        20, 47, 2, 47, 48, 48, 47, 5,\n+        6, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 9, 10, 11, 12, 47,\n+        47, 47, 47, 47, 47, 47, 47, 56,\n+        47, 47, 14, 47, 47, 47, 18, 47,\n+        20, 47, 2, 47, 48, 48, 47, 5,\n+        6, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 9, 10, 11, 12, 47,\n+        47, 47, 47, 47, 47, 47, 47, 57,\n+        47, 47, 14, 15, 16, 47, 18, 47,\n+        20, 47, 2, 47, 48, 48, 47, 5,\n+        6, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 9, 10, 11, 12, 47,\n+        47, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 14, 15, 16, 47, 18, 47,\n+        20, 47, 2, 3, 48, 48, 47, 5,\n+        6, 47, 47, 47, 47, 47, 47, 47,\n+        47, 47, 47, 9, 10, 11, 12, 47,\n+        47, 47, 47, 47, 47, 47, 47, 13,\n+        47, 47, 14, 15, 16, 17, 18, 47,\n+        20, 47, 22, 23, 24, 24, 21, 25,\n+        26, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 27, 28, 29, 30, 21,\n+        21, 21, 21, 21, 21, 21, 21, 58,\n+        21, 21, 32, 33, 34, 35, 36, 37,\n+        38, 21, 22, 59, 24, 24, 21, 25,\n+        26, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 27, 28, 29, 30, 21,\n+        21, 21, 21, 21, 21, 21, 21, 31,\n+        21, 21, 32, 33, 34, 35, 36, 21,\n+        38, 21, 1, 1, 2, 3, 48, 48,\n+        47, 5, 6, 1, 1, 47, 47, 47,\n+        1, 47, 47, 47, 47, 9, 10, 11,\n+        12, 47, 47, 47, 47, 47, 47, 47,\n+        47, 13, 47, 47, 14, 15, 16, 17,\n+        18, 19, 20, 47, 1, 1, 60, 60,\n+        60, 60, 60, 60, 60, 1, 1, 60,\n+        60, 60, 1, 60, 0\n+};\n+\n+static const char _myanmar_syllable_machine_trans_targs[] = {\n+        0, 1, 26, 37, 0, 27, 29, 51,\n+        54, 39, 40, 41, 28, 43, 44, 46,\n+        47, 48, 30, 50, 45, 0, 2, 13,\n+        0, 3, 5, 14, 15, 16, 4, 18,\n+        19, 21, 22, 23, 6, 25, 20, 12,\n+        9, 10, 11, 7, 8, 17, 24, 0,\n+        0, 36, 33, 34, 35, 31, 32, 38,\n+        42, 49, 52, 53, 0\n+};\n+\n+static const char _myanmar_syllable_machine_trans_actions[] = {\n+        3, 0, 0, 0, 4, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 5, 0, 0,\n+        6, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 7,\n+        8, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 9\n+};\n+\n+static const char _myanmar_syllable_machine_to_state_actions[] = {\n+        1, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0\n+};\n+\n+static const char _myanmar_syllable_machine_from_state_actions[] = {\n+        2, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0\n+};\n+\n+static const short _myanmar_syllable_machine_eof_trans[] = {\n+        0, 22, 22, 22, 22, 22, 22, 22,\n+        22, 22, 22, 22, 22, 22, 22, 22,\n+        22, 22, 22, 22, 22, 22, 22, 22,\n+        22, 22, 48, 48, 48, 48, 48, 48,\n+        48, 48, 48, 48, 48, 48, 48, 48,\n+        48, 48, 48, 48, 48, 48, 48, 48,\n+        48, 48, 48, 22, 22, 48, 61\n+};\n+\n+static const int myanmar_syllable_machine_start = 0;\n+static const int myanmar_syllable_machine_first_final = 0;\n+static const int myanmar_syllable_machine_error = -1;\n+\n+static const int myanmar_syllable_machine_en_main = 0;\n+\n+\n+#line 55 \"hb-ot-shaper-myanmar-machine.rl\"\n+\n+\n+\n+#line 117 \"hb-ot-shaper-myanmar-machine.rl\"\n+\n+\n+#define found_syllable(syllable_type) \\\n+  HB_STMT_START { \\\n+    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    for (unsigned int i = ts; i < te; i++) \\\n+      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n+    syllable_serial++; \\\n+    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+  } HB_STMT_END\n+\n+inline void\n+find_syllables_myanmar (hb_buffer_t *buffer)\n+{\n+  unsigned int p, pe, eof, ts, te, act HB_UNUSED;\n+  int cs;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+#line 447 \"hb-ot-shaper-myanmar-machine.hh\"\n+        {\n+        cs = myanmar_syllable_machine_start;\n+        ts = 0;\n+        te = 0;\n+        act = 0;\n+        }\n+\n+#line 137 \"hb-ot-shaper-myanmar-machine.rl\"\n+\n+\n+  p = 0;\n+  pe = eof = buffer->len;\n+\n+  unsigned int syllable_serial = 1;\n+\n+#line 463 \"hb-ot-shaper-myanmar-machine.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+_resume:\n+        switch ( _myanmar_syllable_machine_from_state_actions[cs] ) {\n+        case 2:\n+#line 1 \"NONE\"\n+        {ts = p;}\n+        break;\n+#line 477 \"hb-ot-shaper-myanmar-machine.hh\"\n+        }\n+\n+        _keys = _myanmar_syllable_machine_trans_keys + (cs<<1);\n+        _inds = _myanmar_syllable_machine_indicies + _myanmar_syllable_machine_index_offsets[cs];\n+\n+        _slen = _myanmar_syllable_machine_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=( info[p].myanmar_category()) &&\n+                ( info[p].myanmar_category()) <= _keys[1] ?\n+                ( info[p].myanmar_category()) - _keys[0] : _slen ];\n+\n+_eof_trans:\n+        cs = _myanmar_syllable_machine_trans_targs[_trans];\n+\n+        if ( _myanmar_syllable_machine_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _myanmar_syllable_machine_trans_actions[_trans] ) {\n+        case 6:\n+#line 110 \"hb-ot-shaper-myanmar-machine.rl\"\n+        {te = p+1;{ found_syllable (myanmar_consonant_syllable); }}\n+        break;\n+        case 4:\n+#line 111 \"hb-ot-shaper-myanmar-machine.rl\"\n+        {te = p+1;{ found_syllable (myanmar_non_myanmar_cluster); }}\n+        break;\n+        case 8:\n+#line 112 \"hb-ot-shaper-myanmar-machine.rl\"\n+        {te = p+1;{ found_syllable (myanmar_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }}\n+        break;\n+        case 3:\n+#line 113 \"hb-ot-shaper-myanmar-machine.rl\"\n+        {te = p+1;{ found_syllable (myanmar_non_myanmar_cluster); }}\n+        break;\n+        case 5:\n+#line 110 \"hb-ot-shaper-myanmar-machine.rl\"\n+        {te = p;p--;{ found_syllable (myanmar_consonant_syllable); }}\n+        break;\n+        case 7:\n+#line 112 \"hb-ot-shaper-myanmar-machine.rl\"\n+        {te = p;p--;{ found_syllable (myanmar_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }}\n+        break;\n+        case 9:\n+#line 113 \"hb-ot-shaper-myanmar-machine.rl\"\n+        {te = p;p--;{ found_syllable (myanmar_non_myanmar_cluster); }}\n+        break;\n+#line 523 \"hb-ot-shaper-myanmar-machine.hh\"\n+        }\n+\n+_again:\n+        switch ( _myanmar_syllable_machine_to_state_actions[cs] ) {\n+        case 1:\n+#line 1 \"NONE\"\n+        {ts = 0;}\n+        break;\n+#line 532 \"hb-ot-shaper-myanmar-machine.hh\"\n+        }\n+\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        if ( _myanmar_syllable_machine_eof_trans[cs] > 0 ) {\n+                _trans = _myanmar_syllable_machine_eof_trans[cs] - 1;\n+                goto _eof_trans;\n+        }\n+        }\n+\n+        }\n+\n+#line 145 \"hb-ot-shaper-myanmar-machine.rl\"\n+\n+}\n+\n+#undef found_syllable\n+\n+#endif \/* HB_OT_SHAPER_MYANMAR_MACHINE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-myanmar-machine.hh","additions":553,"deletions":0,"binary":false,"changes":553,"status":"added"},{"patch":"@@ -0,0 +1,356 @@\n+\/*\n+ * Copyright  2011,2012,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_OT_SHAPE\n+\n+#include \"hb-ot-shaper-myanmar-machine.hh\"\n+#include \"hb-ot-shaper-indic.hh\"\n+#include \"hb-ot-layout.hh\"\n+\n+\n+\/*\n+ * Myanmar shaper.\n+ *\/\n+\n+\n+static const hb_tag_t\n+myanmar_basic_features[] =\n+{\n+  \/*\n+   * Basic features.\n+   * These features are applied in order, one at a time, after reordering,\n+   * constrained to the syllable.\n+   *\/\n+  HB_TAG('r','p','h','f'),\n+  HB_TAG('p','r','e','f'),\n+  HB_TAG('b','l','w','f'),\n+  HB_TAG('p','s','t','f'),\n+};\n+static const hb_tag_t\n+myanmar_other_features[] =\n+{\n+  \/*\n+   * Other features.\n+   * These features are applied all at once, after clearing syllables.\n+   *\/\n+  HB_TAG('p','r','e','s'),\n+  HB_TAG('a','b','v','s'),\n+  HB_TAG('b','l','w','s'),\n+  HB_TAG('p','s','t','s'),\n+};\n+\n+static inline void\n+set_myanmar_properties (hb_glyph_info_t &info)\n+{\n+  hb_codepoint_t u = info.codepoint;\n+  unsigned int type = hb_indic_get_categories (u);\n+\n+  info.myanmar_category() = (myanmar_category_t) (type & 0xFFu);\n+}\n+\n+\n+static inline bool\n+is_one_of_myanmar (const hb_glyph_info_t &info, unsigned int flags)\n+{\n+  \/* If it ligated, all bets are off. *\/\n+  if (_hb_glyph_info_ligated (&info)) return false;\n+  return !!(FLAG_UNSAFE (info.myanmar_category()) & flags);\n+}\n+\n+\/* Note:\n+ *\n+ * We treat Vowels and placeholders as if they were consonants.  This is safe because Vowels\n+ * cannot happen in a consonant syllable.  The plus side however is, we can call the\n+ * consonant syllable logic from the vowel syllable function and get it all right!\n+ *\n+ * Keep in sync with consonant_categories in the generator. *\/\n+#define CONSONANT_FLAGS_MYANMAR (FLAG (M_Cat(C)) | FLAG (M_Cat(CS)) | FLAG (M_Cat(Ra)) | \/* FLAG (M_Cat(CM)) | *\/ FLAG (M_Cat(IV)) | FLAG (M_Cat(GB)) | FLAG (M_Cat(DOTTEDCIRCLE)))\n+\n+static inline bool\n+is_consonant_myanmar (const hb_glyph_info_t &info)\n+{\n+  return is_one_of_myanmar (info, CONSONANT_FLAGS_MYANMAR);\n+}\n+\n+\n+static void\n+setup_syllables_myanmar (const hb_ot_shape_plan_t *plan,\n+                         hb_font_t *font,\n+                         hb_buffer_t *buffer);\n+static void\n+reorder_myanmar (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer);\n+\n+static void\n+collect_features_myanmar (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* Do this before any lookups have been applied. *\/\n+  map->add_gsub_pause (setup_syllables_myanmar);\n+\n+  map->enable_feature (HB_TAG('l','o','c','l'), F_PER_SYLLABLE);\n+  \/* The Indic specs do not require ccmp, but we apply it here since if\n+   * there is a use of it, it's typically at the beginning. *\/\n+  map->enable_feature (HB_TAG('c','c','m','p'), F_PER_SYLLABLE);\n+\n+\n+  map->add_gsub_pause (reorder_myanmar);\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (myanmar_basic_features); i++)\n+  {\n+    map->enable_feature (myanmar_basic_features[i], F_MANUAL_ZWJ | F_PER_SYLLABLE);\n+    map->add_gsub_pause (nullptr);\n+  }\n+  map->add_gsub_pause (hb_syllabic_clear_var); \/\/ Don't need syllables anymore, use stop to free buffer var\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (myanmar_other_features); i++)\n+    map->enable_feature (myanmar_other_features[i], F_MANUAL_ZWJ);\n+}\n+\n+static void\n+setup_masks_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                     hb_buffer_t              *buffer,\n+                     hb_font_t                *font HB_UNUSED)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_category);\n+  HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_position);\n+\n+  \/* No masks, we just save information about characters. *\/\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    set_myanmar_properties (info[i]);\n+}\n+\n+static void\n+setup_syllables_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                         hb_font_t *font HB_UNUSED,\n+                         hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, syllable);\n+  find_syllables_myanmar (buffer);\n+  foreach_syllable (buffer, start, end)\n+    buffer->unsafe_to_break (start, end);\n+}\n+\n+static int\n+compare_myanmar_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)\n+{\n+  int a = pa->myanmar_position();\n+  int b = pb->myanmar_position();\n+\n+  return (int) a - (int) b;\n+}\n+\n+\n+\/* Rules from:\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/myanmar *\/\n+\n+static void\n+initial_reordering_consonant_syllable (hb_buffer_t *buffer,\n+                                       unsigned int start, unsigned int end)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  unsigned int base = end;\n+  bool has_reph = false;\n+\n+  {\n+    unsigned int limit = start;\n+    if (start + 3 <= end &&\n+        info[start  ].myanmar_category() == M_Cat(Ra) &&\n+        info[start+1].myanmar_category() == M_Cat(As) &&\n+        info[start+2].myanmar_category() == M_Cat(H))\n+    {\n+      limit += 3;\n+      base = start;\n+      has_reph = true;\n+    }\n+\n+    {\n+      if (!has_reph)\n+        base = limit;\n+\n+      for (unsigned int i = limit; i < end; i++)\n+        if (is_consonant_myanmar (info[i]))\n+        {\n+          base = i;\n+          break;\n+        }\n+    }\n+  }\n+\n+  \/* Reorder! *\/\n+  {\n+    unsigned int i = start;\n+    for (; i < start + (has_reph ? 3 : 0); i++)\n+      info[i].myanmar_position() = POS_AFTER_MAIN;\n+    for (; i < base; i++)\n+      info[i].myanmar_position() = POS_PRE_C;\n+    if (i < end)\n+    {\n+      info[i].myanmar_position() = POS_BASE_C;\n+      i++;\n+    }\n+    myanmar_position_t pos = POS_AFTER_MAIN;\n+    \/* The following loop may be ugly, but it implements all of\n+     * Myanmar reordering! *\/\n+    for (; i < end; i++)\n+    {\n+      if (info[i].myanmar_category() == M_Cat(MR)) \/* Pre-base reordering *\/\n+      {\n+        info[i].myanmar_position() = POS_PRE_C;\n+        continue;\n+      }\n+      if (info[i].myanmar_category() == M_Cat(VPre)) \/* Left matra *\/\n+      {\n+        info[i].myanmar_position() = POS_PRE_M;\n+        continue;\n+      }\n+      if (info[i].myanmar_category() == M_Cat(VS))\n+      {\n+        info[i].myanmar_position() = info[i - 1].myanmar_position();\n+        continue;\n+      }\n+\n+      if (pos == POS_AFTER_MAIN && info[i].myanmar_category() == M_Cat(VBlw))\n+      {\n+        pos = POS_BELOW_C;\n+        info[i].myanmar_position() = pos;\n+        continue;\n+      }\n+\n+      if (pos == POS_BELOW_C && info[i].myanmar_category() == M_Cat(A))\n+      {\n+        info[i].myanmar_position() = POS_BEFORE_SUB;\n+        continue;\n+      }\n+      if (pos == POS_BELOW_C && info[i].myanmar_category() == M_Cat(VBlw))\n+      {\n+        info[i].myanmar_position() = pos;\n+        continue;\n+      }\n+      if (pos == POS_BELOW_C && info[i].myanmar_category() != M_Cat(A))\n+      {\n+        pos = POS_AFTER_SUB;\n+        info[i].myanmar_position() = pos;\n+        continue;\n+      }\n+      info[i].myanmar_position() = pos;\n+    }\n+  }\n+\n+  \/* Sit tight, rock 'n roll! *\/\n+  buffer->sort (start, end, compare_myanmar_order);\n+}\n+\n+static void\n+reorder_syllable_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                          hb_face_t *face HB_UNUSED,\n+                          hb_buffer_t *buffer,\n+                          unsigned int start, unsigned int end)\n+{\n+  myanmar_syllable_type_t syllable_type = (myanmar_syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n+  switch (syllable_type) {\n+\n+    case myanmar_broken_cluster: \/* We already inserted dotted-circles, so just call the consonant_syllable. *\/\n+    case myanmar_consonant_syllable:\n+      initial_reordering_consonant_syllable  (buffer, start, end);\n+      break;\n+\n+    case myanmar_non_myanmar_cluster:\n+      break;\n+  }\n+}\n+\n+static void\n+reorder_myanmar (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer)\n+{\n+  if (buffer->message (font, \"start reordering myanmar\"))\n+  {\n+    hb_syllabic_insert_dotted_circles (font, buffer,\n+                                       myanmar_broken_cluster,\n+                                       M_Cat(DOTTEDCIRCLE));\n+\n+    foreach_syllable (buffer, start, end)\n+      reorder_syllable_myanmar (plan, font->face, buffer, start, end);\n+    (void) buffer->message (font, \"end reordering myanmar\");\n+  }\n+\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_category);\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_position);\n+}\n+\n+\n+const hb_ot_shaper_t _hb_ot_shaper_myanmar =\n+{\n+  collect_features_myanmar,\n+  nullptr, \/* override_features *\/\n+  nullptr, \/* data_create *\/\n+  nullptr, \/* data_destroy *\/\n+  nullptr, \/* preprocess_text *\/\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n+  nullptr, \/* decompose *\/\n+  nullptr, \/* compose *\/\n+  setup_masks_myanmar,\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,\n+  false, \/* fallback_position *\/\n+};\n+\n+\n+\/* Ugly Zawgyi encoding.\n+ * Disable all auto processing.\n+ * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1162 *\/\n+const hb_ot_shaper_t _hb_ot_shaper_myanmar_zawgyi =\n+{\n+  nullptr, \/* collect_features *\/\n+  nullptr, \/* override_features *\/\n+  nullptr, \/* data_create *\/\n+  nullptr, \/* data_destroy *\/\n+  nullptr, \/* preprocess_text *\/\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_NONE,\n+  nullptr, \/* decompose *\/\n+  nullptr, \/* compose *\/\n+  nullptr, \/* setup_masks *\/\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n+  false, \/* fallback_position *\/\n+};\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-myanmar.cc","additions":356,"deletions":0,"binary":false,"changes":356,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright  2021  Behdad Esfahbod.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#ifndef HB_NO_OT_SHAPE\n+\n+#include \"hb-ot-shaper-syllabic.hh\"\n+\n+\n+void\n+hb_syllabic_insert_dotted_circles (hb_font_t *font,\n+                                   hb_buffer_t *buffer,\n+                                   unsigned int broken_syllable_type,\n+                                   unsigned int dottedcircle_category,\n+                                   int repha_category,\n+                                   int dottedcircle_position)\n+{\n+  if (unlikely (buffer->flags & HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE))\n+    return;\n+  if (likely (!(buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE)))\n+    return;\n+\n+  hb_codepoint_t dottedcircle_glyph;\n+  if (!font->get_nominal_glyph (0x25CCu, &dottedcircle_glyph))\n+    return;\n+\n+  hb_glyph_info_t dottedcircle = {0};\n+  dottedcircle.codepoint = 0x25CCu;\n+  dottedcircle.ot_shaper_var_u8_category() = dottedcircle_category;\n+  if (dottedcircle_position != -1)\n+    dottedcircle.ot_shaper_var_u8_auxiliary() = dottedcircle_position;\n+  dottedcircle.codepoint = dottedcircle_glyph;\n+\n+  buffer->clear_output ();\n+\n+  buffer->idx = 0;\n+  unsigned int last_syllable = 0;\n+  while (buffer->idx < buffer->len && buffer->successful)\n+  {\n+    unsigned int syllable = buffer->cur().syllable();\n+    if (unlikely (last_syllable != syllable && (syllable & 0x0F) == broken_syllable_type))\n+    {\n+      last_syllable = syllable;\n+\n+      hb_glyph_info_t ginfo = dottedcircle;\n+      ginfo.cluster = buffer->cur().cluster;\n+      ginfo.mask = buffer->cur().mask;\n+      ginfo.syllable() = buffer->cur().syllable();\n+\n+      \/* Insert dottedcircle after possible Repha. *\/\n+      if (repha_category != -1)\n+      {\n+        while (buffer->idx < buffer->len && buffer->successful &&\n+               last_syllable == buffer->cur().syllable() &&\n+               buffer->cur().ot_shaper_var_u8_category() == (unsigned) repha_category)\n+          (void) buffer->next_glyph ();\n+      }\n+\n+      (void) buffer->output_info (ginfo);\n+    }\n+    else\n+      (void) buffer->next_glyph ();\n+  }\n+  buffer->sync ();\n+}\n+\n+HB_INTERNAL void\n+hb_syllabic_clear_var (const hb_ot_shape_plan_t *plan,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, syllable);\n+}\n+\n+\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-syllabic.cc","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright  2021  Behdad Esfahbod.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_SYLLABIC_HH\n+#define HB_OT_SHAPER_SYLLABIC_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shaper.hh\"\n+\n+\n+HB_INTERNAL void\n+hb_syllabic_insert_dotted_circles (hb_font_t *font,\n+                                   hb_buffer_t *buffer,\n+                                   unsigned int broken_syllable_type,\n+                                   unsigned int dottedcircle_category,\n+                                   int repha_category = -1,\n+                                   int dottedcircle_position = -1);\n+\n+HB_INTERNAL void\n+hb_syllabic_clear_var (const hb_ot_shape_plan_t *plan,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer);\n+\n+\n+#endif \/* HB_OT_SHAPER_SYLLABIC_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-syllabic.hh","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"hb-ot-shape-complex.hh\"\n+#include \"hb-ot-shaper.hh\"\n@@ -225,1 +225,1 @@\n-#ifdef HB_NO_OT_SHAPE_COMPLEX_THAI_FALLBACK\n+#ifdef HB_NO_OT_SHAPER_THAI_FALLBACK\n@@ -282,1 +282,1 @@\n-   * NIKHAHIT backwards over any tone mark (0E48-0E4B).\n+   * NIKHAHIT backwards over any above-base marks.\n@@ -311,2 +311,2 @@\n-   * Thai:      <0E31,0E34..0E37,0E47..0E4E>\n-   * Lao:       <0EB1,0EB4..0EB7,0EC7..0ECE>\n+   * Thai:      <0E31,0E34..0E37,     0E47..0E4E>\n+   * Lao:       <0EB1,0EB4..0EB7,0EBB,0EC8..0ECD>\n@@ -322,1 +322,1 @@\n-#define IS_TONE_MARK(x) (hb_in_ranges<hb_codepoint_t> ((x) & ~0x0080u, 0x0E34u, 0x0E37u, 0x0E47u, 0x0E4Eu, 0x0E31u, 0x0E31u))\n+#define IS_ABOVE_BASE_MARK(x) (hb_in_ranges<hb_codepoint_t> ((x) & ~0x0080u, 0x0E34u, 0x0E37u, 0x0E47u, 0x0E4Eu, 0x0E31u, 0x0E31u, 0x0E3Bu, 0x0E3Bu))\n@@ -346,1 +346,1 @@\n-    while (start > 0 && IS_TONE_MARK (buffer->out_info[start - 1].codepoint))\n+    while (start > 0 && IS_ABOVE_BASE_MARK (buffer->out_info[start - 1].codepoint))\n@@ -367,1 +367,1 @@\n-  buffer->swap_buffers ();\n+  buffer->sync ();\n@@ -374,1 +374,1 @@\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_thai =\n+const hb_ot_shaper_t _hb_ot_shaper_thai =\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-thai.cc","additions":9,"deletions":9,"binary":false,"changes":18,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-thai.cc","status":"renamed"},{"patch":"@@ -0,0 +1,931 @@\n+\n+#line 1 \"hb-ot-shaper-use-machine.rl\"\n+\/*\n+ * Copyright  2015  Mozilla Foundation.\n+ * Copyright  2015  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Mozilla Author(s): Jonathan Kew\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_USE_MACHINE_HH\n+#define HB_OT_SHAPER_USE_MACHINE_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shaper-syllabic.hh\"\n+\n+\/* buffer var allocations *\/\n+#define use_category() ot_shaper_var_u8_category()\n+\n+#define USE(Cat) use_syllable_machine_ex_##Cat\n+\n+enum use_syllable_type_t {\n+  use_virama_terminated_cluster,\n+  use_sakot_terminated_cluster,\n+  use_standard_cluster,\n+  use_number_joiner_terminated_cluster,\n+  use_numeral_cluster,\n+  use_symbol_cluster,\n+  use_hieroglyph_cluster,\n+  use_broken_cluster,\n+  use_non_cluster,\n+};\n+\n+\n+#line 57 \"hb-ot-shaper-use-machine.hh\"\n+#define use_syllable_machine_ex_B 1u\n+#define use_syllable_machine_ex_CGJ 6u\n+#define use_syllable_machine_ex_CMAbv 31u\n+#define use_syllable_machine_ex_CMBlw 32u\n+#define use_syllable_machine_ex_CS 43u\n+#define use_syllable_machine_ex_FAbv 24u\n+#define use_syllable_machine_ex_FBlw 25u\n+#define use_syllable_machine_ex_FMAbv 45u\n+#define use_syllable_machine_ex_FMBlw 46u\n+#define use_syllable_machine_ex_FMPst 47u\n+#define use_syllable_machine_ex_FPst 26u\n+#define use_syllable_machine_ex_G 49u\n+#define use_syllable_machine_ex_GB 5u\n+#define use_syllable_machine_ex_H 12u\n+#define use_syllable_machine_ex_HN 13u\n+#define use_syllable_machine_ex_HVM 53u\n+#define use_syllable_machine_ex_IS 44u\n+#define use_syllable_machine_ex_J 50u\n+#define use_syllable_machine_ex_MAbv 27u\n+#define use_syllable_machine_ex_MBlw 28u\n+#define use_syllable_machine_ex_MPre 30u\n+#define use_syllable_machine_ex_MPst 29u\n+#define use_syllable_machine_ex_N 4u\n+#define use_syllable_machine_ex_O 0u\n+#define use_syllable_machine_ex_R 18u\n+#define use_syllable_machine_ex_SB 51u\n+#define use_syllable_machine_ex_SE 52u\n+#define use_syllable_machine_ex_SMAbv 41u\n+#define use_syllable_machine_ex_SMBlw 42u\n+#define use_syllable_machine_ex_SUB 11u\n+#define use_syllable_machine_ex_Sk 48u\n+#define use_syllable_machine_ex_VAbv 33u\n+#define use_syllable_machine_ex_VBlw 34u\n+#define use_syllable_machine_ex_VMAbv 37u\n+#define use_syllable_machine_ex_VMBlw 38u\n+#define use_syllable_machine_ex_VMPre 23u\n+#define use_syllable_machine_ex_VMPst 39u\n+#define use_syllable_machine_ex_VPre 22u\n+#define use_syllable_machine_ex_VPst 35u\n+#define use_syllable_machine_ex_WJ 16u\n+#define use_syllable_machine_ex_ZWNJ 14u\n+\n+\n+#line 101 \"hb-ot-shaper-use-machine.hh\"\n+static const unsigned char _use_syllable_machine_trans_keys[] = {\n+        0u, 53u, 11u, 53u, 11u, 53u, 1u, 53u, 23u, 48u, 24u, 47u, 25u, 47u, 26u, 47u,\n+        45u, 46u, 46u, 46u, 24u, 48u, 24u, 48u, 24u, 48u, 1u, 1u, 24u, 48u, 22u, 53u,\n+        23u, 53u, 23u, 53u, 23u, 53u, 12u, 53u, 23u, 53u, 12u, 53u, 12u, 53u, 12u, 53u,\n+        11u, 53u, 1u, 1u, 1u, 48u, 11u, 53u, 41u, 42u, 42u, 42u, 11u, 53u, 11u, 53u,\n+        1u, 53u, 23u, 48u, 24u, 47u, 25u, 47u, 26u, 47u, 45u, 46u, 46u, 46u, 24u, 48u,\n+        24u, 48u, 24u, 48u, 1u, 1u, 24u, 48u, 22u, 53u, 23u, 53u, 23u, 53u, 23u, 53u,\n+        12u, 53u, 23u, 53u, 12u, 53u, 12u, 53u, 12u, 53u, 11u, 53u, 1u, 1u, 1u, 48u,\n+        13u, 13u, 4u, 4u, 11u, 53u, 11u, 53u, 1u, 53u, 23u, 48u, 24u, 47u, 25u, 47u,\n+        26u, 47u, 45u, 46u, 46u, 46u, 24u, 48u, 24u, 48u, 24u, 48u, 1u, 1u, 24u, 48u,\n+        22u, 53u, 23u, 53u, 23u, 53u, 23u, 53u, 12u, 53u, 23u, 53u, 12u, 53u, 12u, 53u,\n+        12u, 53u, 11u, 53u, 1u, 1u, 1u, 48u, 11u, 53u, 11u, 53u, 1u, 53u, 23u, 48u,\n+        24u, 47u, 25u, 47u, 26u, 47u, 45u, 46u, 46u, 46u, 24u, 48u, 24u, 48u, 24u, 48u,\n+        1u, 1u, 24u, 48u, 22u, 53u, 23u, 53u, 23u, 53u, 23u, 53u, 12u, 53u, 23u, 53u,\n+        12u, 53u, 12u, 53u, 12u, 53u, 11u, 53u, 1u, 1u, 1u, 48u, 4u, 4u, 13u, 13u,\n+        1u, 53u, 11u, 53u, 41u, 42u, 42u, 42u, 1u, 5u, 50u, 52u, 49u, 52u, 49u, 51u,\n+        0\n+};\n+\n+static const char _use_syllable_machine_key_spans[] = {\n+        54, 43, 43, 53, 26, 24, 23, 22,\n+        2, 1, 25, 25, 25, 1, 25, 32,\n+        31, 31, 31, 42, 31, 42, 42, 42,\n+        43, 1, 48, 43, 2, 1, 43, 43,\n+        53, 26, 24, 23, 22, 2, 1, 25,\n+        25, 25, 1, 25, 32, 31, 31, 31,\n+        42, 31, 42, 42, 42, 43, 1, 48,\n+        1, 1, 43, 43, 53, 26, 24, 23,\n+        22, 2, 1, 25, 25, 25, 1, 25,\n+        32, 31, 31, 31, 42, 31, 42, 42,\n+        42, 43, 1, 48, 43, 43, 53, 26,\n+        24, 23, 22, 2, 1, 25, 25, 25,\n+        1, 25, 32, 31, 31, 31, 42, 31,\n+        42, 42, 42, 43, 1, 48, 1, 1,\n+        53, 43, 2, 1, 5, 3, 4, 3\n+};\n+\n+static const short _use_syllable_machine_index_offsets[] = {\n+        0, 55, 99, 143, 197, 224, 249, 273,\n+        296, 299, 301, 327, 353, 379, 381, 407,\n+        440, 472, 504, 536, 579, 611, 654, 697,\n+        740, 784, 786, 835, 879, 882, 884, 928,\n+        972, 1026, 1053, 1078, 1102, 1125, 1128, 1130,\n+        1156, 1182, 1208, 1210, 1236, 1269, 1301, 1333,\n+        1365, 1408, 1440, 1483, 1526, 1569, 1613, 1615,\n+        1664, 1666, 1668, 1712, 1756, 1810, 1837, 1862,\n+        1886, 1909, 1912, 1914, 1940, 1966, 1992, 1994,\n+        2020, 2053, 2085, 2117, 2149, 2192, 2224, 2267,\n+        2310, 2353, 2397, 2399, 2448, 2492, 2536, 2590,\n+        2617, 2642, 2666, 2689, 2692, 2694, 2720, 2746,\n+        2772, 2774, 2800, 2833, 2865, 2897, 2929, 2972,\n+        3004, 3047, 3090, 3133, 3177, 3179, 3228, 3230,\n+        3232, 3286, 3330, 3333, 3335, 3341, 3345, 3350\n+};\n+\n+static const unsigned char _use_syllable_machine_indicies[] = {\n+        0, 1, 2, 2, 3, 4, 2, 2,\n+        2, 2, 2, 5, 6, 7, 2, 2,\n+        2, 2, 8, 2, 2, 2, 9, 10,\n+        11, 12, 13, 14, 15, 16, 17, 18,\n+        19, 20, 21, 22, 2, 23, 24, 25,\n+        2, 26, 27, 28, 29, 30, 31, 32,\n+        29, 33, 2, 34, 2, 35, 2, 37,\n+        38, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 39, 40, 41, 42, 43, 44,\n+        45, 46, 47, 48, 49, 50, 51, 52,\n+        36, 53, 54, 55, 36, 56, 57, 36,\n+        58, 59, 60, 61, 58, 36, 36, 36,\n+        36, 62, 36, 37, 38, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 39, 40,\n+        41, 42, 43, 44, 45, 46, 47, 49,\n+        49, 50, 51, 52, 36, 53, 54, 55,\n+        36, 36, 36, 36, 58, 59, 60, 61,\n+        58, 36, 36, 36, 36, 62, 36, 37,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 40, 41, 42,\n+        43, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 53, 54, 55, 36, 36,\n+        36, 36, 36, 59, 60, 61, 63, 36,\n+        36, 36, 36, 40, 36, 40, 41, 42,\n+        43, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 53, 54, 55, 36, 36,\n+        36, 36, 36, 59, 60, 61, 63, 36,\n+        41, 42, 43, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 59, 60, 61,\n+        36, 42, 43, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 59, 60, 61,\n+        36, 43, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 59, 60, 61, 36,\n+        59, 60, 36, 60, 36, 41, 42, 43,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 53, 54, 55, 36, 36, 36,\n+        36, 36, 59, 60, 61, 63, 36, 41,\n+        42, 43, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 54, 55, 36,\n+        36, 36, 36, 36, 59, 60, 61, 63,\n+        36, 41, 42, 43, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        55, 36, 36, 36, 36, 36, 59, 60,\n+        61, 63, 36, 64, 36, 41, 42, 43,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 59, 60, 61, 63, 36, 39,\n+        40, 41, 42, 43, 36, 36, 36, 36,\n+        36, 36, 50, 51, 52, 36, 53, 54,\n+        55, 36, 36, 36, 36, 36, 59, 60,\n+        61, 63, 36, 36, 36, 36, 40, 36,\n+        40, 41, 42, 43, 36, 36, 36, 36,\n+        36, 36, 50, 51, 52, 36, 53, 54,\n+        55, 36, 36, 36, 36, 36, 59, 60,\n+        61, 63, 36, 36, 36, 36, 40, 36,\n+        40, 41, 42, 43, 36, 36, 36, 36,\n+        36, 36, 36, 51, 52, 36, 53, 54,\n+        55, 36, 36, 36, 36, 36, 59, 60,\n+        61, 63, 36, 36, 36, 36, 40, 36,\n+        40, 41, 42, 43, 36, 36, 36, 36,\n+        36, 36, 36, 36, 52, 36, 53, 54,\n+        55, 36, 36, 36, 36, 36, 59, 60,\n+        61, 63, 36, 36, 36, 36, 40, 36,\n+        65, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 39, 40, 41, 42, 43, 36,\n+        45, 46, 36, 36, 36, 50, 51, 52,\n+        36, 53, 54, 55, 36, 36, 36, 36,\n+        36, 59, 60, 61, 63, 36, 36, 36,\n+        36, 40, 36, 40, 41, 42, 43, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 53, 54, 55, 36, 36, 36, 36,\n+        36, 59, 60, 61, 63, 36, 36, 36,\n+        36, 40, 36, 65, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 39, 40, 41,\n+        42, 43, 36, 36, 46, 36, 36, 36,\n+        50, 51, 52, 36, 53, 54, 55, 36,\n+        36, 36, 36, 36, 59, 60, 61, 63,\n+        36, 36, 36, 36, 40, 36, 65, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        39, 40, 41, 42, 43, 36, 36, 36,\n+        36, 36, 36, 50, 51, 52, 36, 53,\n+        54, 55, 36, 36, 36, 36, 36, 59,\n+        60, 61, 63, 36, 36, 36, 36, 40,\n+        36, 65, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 39, 40, 41, 42, 43,\n+        44, 45, 46, 36, 36, 36, 50, 51,\n+        52, 36, 53, 54, 55, 36, 36, 36,\n+        36, 36, 59, 60, 61, 63, 36, 36,\n+        36, 36, 40, 36, 37, 38, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 39,\n+        40, 41, 42, 43, 44, 45, 46, 47,\n+        36, 49, 50, 51, 52, 36, 53, 54,\n+        55, 36, 36, 36, 36, 58, 59, 60,\n+        61, 58, 36, 36, 36, 36, 62, 36,\n+        37, 36, 37, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        40, 41, 42, 43, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 53, 54,\n+        55, 36, 36, 36, 36, 36, 59, 60,\n+        61, 63, 36, 37, 38, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 39, 40,\n+        41, 42, 43, 44, 45, 46, 47, 48,\n+        49, 50, 51, 52, 36, 53, 54, 55,\n+        36, 36, 36, 36, 58, 59, 60, 61,\n+        58, 36, 36, 36, 36, 62, 36, 56,\n+        57, 36, 57, 36, 67, 68, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 69,\n+        70, 71, 72, 73, 74, 75, 76, 77,\n+        1, 78, 79, 80, 81, 66, 82, 83,\n+        84, 66, 66, 66, 66, 85, 86, 87,\n+        88, 89, 66, 66, 66, 66, 90, 66,\n+        67, 68, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 69, 70, 71, 72, 73,\n+        74, 75, 76, 77, 78, 78, 79, 80,\n+        81, 66, 82, 83, 84, 66, 66, 66,\n+        66, 85, 86, 87, 88, 89, 66, 66,\n+        66, 66, 90, 66, 67, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 70, 71, 72, 73, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        82, 83, 84, 66, 66, 66, 66, 66,\n+        86, 87, 88, 91, 66, 66, 66, 66,\n+        70, 66, 70, 71, 72, 73, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        82, 83, 84, 66, 66, 66, 66, 66,\n+        86, 87, 88, 91, 66, 71, 72, 73,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 86, 87, 88, 66, 72, 73,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 86, 87, 88, 66, 73, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 86, 87, 88, 66, 86, 87, 66,\n+        87, 66, 71, 72, 73, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 82,\n+        83, 84, 66, 66, 66, 66, 66, 86,\n+        87, 88, 91, 66, 71, 72, 73, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 83, 84, 66, 66, 66, 66,\n+        66, 86, 87, 88, 91, 66, 71, 72,\n+        73, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 84, 66, 66,\n+        66, 66, 66, 86, 87, 88, 91, 66,\n+        93, 92, 71, 72, 73, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 86,\n+        87, 88, 91, 66, 69, 70, 71, 72,\n+        73, 66, 66, 66, 66, 66, 66, 79,\n+        80, 81, 66, 82, 83, 84, 66, 66,\n+        66, 66, 66, 86, 87, 88, 91, 66,\n+        66, 66, 66, 70, 66, 70, 71, 72,\n+        73, 66, 66, 66, 66, 66, 66, 79,\n+        80, 81, 66, 82, 83, 84, 66, 66,\n+        66, 66, 66, 86, 87, 88, 91, 66,\n+        66, 66, 66, 70, 66, 70, 71, 72,\n+        73, 66, 66, 66, 66, 66, 66, 66,\n+        80, 81, 66, 82, 83, 84, 66, 66,\n+        66, 66, 66, 86, 87, 88, 91, 66,\n+        66, 66, 66, 70, 66, 70, 71, 72,\n+        73, 66, 66, 66, 66, 66, 66, 66,\n+        66, 81, 66, 82, 83, 84, 66, 66,\n+        66, 66, 66, 86, 87, 88, 91, 66,\n+        66, 66, 66, 70, 66, 94, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 69,\n+        70, 71, 72, 73, 66, 75, 76, 66,\n+        66, 66, 79, 80, 81, 66, 82, 83,\n+        84, 66, 66, 66, 66, 66, 86, 87,\n+        88, 91, 66, 66, 66, 66, 70, 66,\n+        70, 71, 72, 73, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 82, 83,\n+        84, 66, 66, 66, 66, 66, 86, 87,\n+        88, 91, 66, 66, 66, 66, 70, 66,\n+        94, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 69, 70, 71, 72, 73, 66,\n+        66, 76, 66, 66, 66, 79, 80, 81,\n+        66, 82, 83, 84, 66, 66, 66, 66,\n+        66, 86, 87, 88, 91, 66, 66, 66,\n+        66, 70, 66, 94, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 69, 70, 71,\n+        72, 73, 66, 66, 66, 66, 66, 66,\n+        79, 80, 81, 66, 82, 83, 84, 66,\n+        66, 66, 66, 66, 86, 87, 88, 91,\n+        66, 66, 66, 66, 70, 66, 94, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        69, 70, 71, 72, 73, 74, 75, 76,\n+        66, 66, 66, 79, 80, 81, 66, 82,\n+        83, 84, 66, 66, 66, 66, 66, 86,\n+        87, 88, 91, 66, 66, 66, 66, 70,\n+        66, 67, 68, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 69, 70, 71, 72,\n+        73, 74, 75, 76, 77, 66, 78, 79,\n+        80, 81, 66, 82, 83, 84, 66, 66,\n+        66, 66, 85, 86, 87, 88, 89, 66,\n+        66, 66, 66, 90, 66, 67, 95, 67,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 70, 71, 72,\n+        73, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 82, 83, 84, 66, 66,\n+        66, 66, 66, 86, 87, 88, 91, 66,\n+        97, 96, 3, 98, 99, 100, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 101,\n+        102, 103, 104, 105, 106, 107, 108, 109,\n+        110, 111, 112, 113, 114, 66, 115, 116,\n+        117, 66, 56, 57, 66, 118, 119, 120,\n+        88, 121, 66, 66, 66, 66, 122, 66,\n+        99, 100, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 101, 102, 103, 104, 105,\n+        106, 107, 108, 109, 111, 111, 112, 113,\n+        114, 66, 115, 116, 117, 66, 66, 66,\n+        66, 118, 119, 120, 88, 121, 66, 66,\n+        66, 66, 122, 66, 99, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 102, 103, 104, 105, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        115, 116, 117, 66, 66, 66, 66, 66,\n+        119, 120, 88, 123, 66, 66, 66, 66,\n+        102, 66, 102, 103, 104, 105, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        115, 116, 117, 66, 66, 66, 66, 66,\n+        119, 120, 88, 123, 66, 103, 104, 105,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 119, 120, 88, 66, 104, 105,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 119, 120, 88, 66, 105, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 119, 120, 88, 66, 119, 120, 66,\n+        120, 66, 103, 104, 105, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 115,\n+        116, 117, 66, 66, 66, 66, 66, 119,\n+        120, 88, 123, 66, 103, 104, 105, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 116, 117, 66, 66, 66, 66,\n+        66, 119, 120, 88, 123, 66, 103, 104,\n+        105, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 117, 66, 66,\n+        66, 66, 66, 119, 120, 88, 123, 66,\n+        124, 92, 103, 104, 105, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 119,\n+        120, 88, 123, 66, 101, 102, 103, 104,\n+        105, 66, 66, 66, 66, 66, 66, 112,\n+        113, 114, 66, 115, 116, 117, 66, 66,\n+        66, 66, 66, 119, 120, 88, 123, 66,\n+        66, 66, 66, 102, 66, 102, 103, 104,\n+        105, 66, 66, 66, 66, 66, 66, 112,\n+        113, 114, 66, 115, 116, 117, 66, 66,\n+        66, 66, 66, 119, 120, 88, 123, 66,\n+        66, 66, 66, 102, 66, 102, 103, 104,\n+        105, 66, 66, 66, 66, 66, 66, 66,\n+        113, 114, 66, 115, 116, 117, 66, 66,\n+        66, 66, 66, 119, 120, 88, 123, 66,\n+        66, 66, 66, 102, 66, 102, 103, 104,\n+        105, 66, 66, 66, 66, 66, 66, 66,\n+        66, 114, 66, 115, 116, 117, 66, 66,\n+        66, 66, 66, 119, 120, 88, 123, 66,\n+        66, 66, 66, 102, 66, 125, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 101,\n+        102, 103, 104, 105, 66, 107, 108, 66,\n+        66, 66, 112, 113, 114, 66, 115, 116,\n+        117, 66, 66, 66, 66, 66, 119, 120,\n+        88, 123, 66, 66, 66, 66, 102, 66,\n+        102, 103, 104, 105, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 115, 116,\n+        117, 66, 66, 66, 66, 66, 119, 120,\n+        88, 123, 66, 66, 66, 66, 102, 66,\n+        125, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 101, 102, 103, 104, 105, 66,\n+        66, 108, 66, 66, 66, 112, 113, 114,\n+        66, 115, 116, 117, 66, 66, 66, 66,\n+        66, 119, 120, 88, 123, 66, 66, 66,\n+        66, 102, 66, 125, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 101, 102, 103,\n+        104, 105, 66, 66, 66, 66, 66, 66,\n+        112, 113, 114, 66, 115, 116, 117, 66,\n+        66, 66, 66, 66, 119, 120, 88, 123,\n+        66, 66, 66, 66, 102, 66, 125, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        101, 102, 103, 104, 105, 106, 107, 108,\n+        66, 66, 66, 112, 113, 114, 66, 115,\n+        116, 117, 66, 66, 66, 66, 66, 119,\n+        120, 88, 123, 66, 66, 66, 66, 102,\n+        66, 99, 100, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 101, 102, 103, 104,\n+        105, 106, 107, 108, 109, 66, 111, 112,\n+        113, 114, 66, 115, 116, 117, 66, 66,\n+        66, 66, 118, 119, 120, 88, 121, 66,\n+        66, 66, 66, 122, 66, 99, 95, 99,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 102, 103, 104,\n+        105, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 115, 116, 117, 66, 66,\n+        66, 66, 66, 119, 120, 88, 123, 66,\n+        99, 100, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 101, 102, 103, 104, 105,\n+        106, 107, 108, 109, 110, 111, 112, 113,\n+        114, 66, 115, 116, 117, 66, 66, 66,\n+        66, 118, 119, 120, 88, 121, 66, 66,\n+        66, 66, 122, 66, 5, 6, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 9,\n+        10, 11, 12, 13, 14, 15, 16, 17,\n+        19, 19, 20, 21, 22, 126, 23, 24,\n+        25, 126, 126, 126, 126, 29, 30, 31,\n+        32, 29, 126, 126, 126, 126, 35, 126,\n+        5, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 10, 11,\n+        12, 13, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 23, 24, 25, 126,\n+        126, 126, 126, 126, 30, 31, 32, 127,\n+        126, 126, 126, 126, 10, 126, 10, 11,\n+        12, 13, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 23, 24, 25, 126,\n+        126, 126, 126, 126, 30, 31, 32, 127,\n+        126, 11, 12, 13, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 30, 31,\n+        32, 126, 12, 13, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 30, 31,\n+        32, 126, 13, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 30, 31, 32,\n+        126, 30, 31, 126, 31, 126, 11, 12,\n+        13, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 23, 24, 25, 126, 126,\n+        126, 126, 126, 30, 31, 32, 127, 126,\n+        11, 12, 13, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 24, 25,\n+        126, 126, 126, 126, 126, 30, 31, 32,\n+        127, 126, 11, 12, 13, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 25, 126, 126, 126, 126, 126, 30,\n+        31, 32, 127, 126, 128, 126, 11, 12,\n+        13, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 30, 31, 32, 127, 126,\n+        9, 10, 11, 12, 13, 126, 126, 126,\n+        126, 126, 126, 20, 21, 22, 126, 23,\n+        24, 25, 126, 126, 126, 126, 126, 30,\n+        31, 32, 127, 126, 126, 126, 126, 10,\n+        126, 10, 11, 12, 13, 126, 126, 126,\n+        126, 126, 126, 20, 21, 22, 126, 23,\n+        24, 25, 126, 126, 126, 126, 126, 30,\n+        31, 32, 127, 126, 126, 126, 126, 10,\n+        126, 10, 11, 12, 13, 126, 126, 126,\n+        126, 126, 126, 126, 21, 22, 126, 23,\n+        24, 25, 126, 126, 126, 126, 126, 30,\n+        31, 32, 127, 126, 126, 126, 126, 10,\n+        126, 10, 11, 12, 13, 126, 126, 126,\n+        126, 126, 126, 126, 126, 22, 126, 23,\n+        24, 25, 126, 126, 126, 126, 126, 30,\n+        31, 32, 127, 126, 126, 126, 126, 10,\n+        126, 129, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 9, 10, 11, 12, 13,\n+        126, 15, 16, 126, 126, 126, 20, 21,\n+        22, 126, 23, 24, 25, 126, 126, 126,\n+        126, 126, 30, 31, 32, 127, 126, 126,\n+        126, 126, 10, 126, 10, 11, 12, 13,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 23, 24, 25, 126, 126, 126,\n+        126, 126, 30, 31, 32, 127, 126, 126,\n+        126, 126, 10, 126, 129, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 9, 10,\n+        11, 12, 13, 126, 126, 16, 126, 126,\n+        126, 20, 21, 22, 126, 23, 24, 25,\n+        126, 126, 126, 126, 126, 30, 31, 32,\n+        127, 126, 126, 126, 126, 10, 126, 129,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 9, 10, 11, 12, 13, 126, 126,\n+        126, 126, 126, 126, 20, 21, 22, 126,\n+        23, 24, 25, 126, 126, 126, 126, 126,\n+        30, 31, 32, 127, 126, 126, 126, 126,\n+        10, 126, 129, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 9, 10, 11, 12,\n+        13, 14, 15, 16, 126, 126, 126, 20,\n+        21, 22, 126, 23, 24, 25, 126, 126,\n+        126, 126, 126, 30, 31, 32, 127, 126,\n+        126, 126, 126, 10, 126, 5, 6, 126,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        9, 10, 11, 12, 13, 14, 15, 16,\n+        17, 126, 19, 20, 21, 22, 126, 23,\n+        24, 25, 126, 126, 126, 126, 29, 30,\n+        31, 32, 29, 126, 126, 126, 126, 35,\n+        126, 5, 126, 5, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 10, 11, 12, 13, 126, 126, 126,\n+        126, 126, 126, 126, 126, 126, 126, 23,\n+        24, 25, 126, 126, 126, 126, 126, 30,\n+        31, 32, 127, 126, 130, 126, 7, 126,\n+        1, 126, 126, 126, 1, 126, 126, 126,\n+        126, 126, 5, 6, 7, 126, 126, 126,\n+        126, 126, 126, 126, 126, 9, 10, 11,\n+        12, 13, 14, 15, 16, 17, 18, 19,\n+        20, 21, 22, 126, 23, 24, 25, 126,\n+        26, 27, 126, 29, 30, 31, 32, 29,\n+        126, 126, 126, 126, 35, 126, 5, 6,\n+        126, 126, 126, 126, 126, 126, 126, 126,\n+        126, 9, 10, 11, 12, 13, 14, 15,\n+        16, 17, 18, 19, 20, 21, 22, 126,\n+        23, 24, 25, 126, 126, 126, 126, 29,\n+        30, 31, 32, 29, 126, 126, 126, 126,\n+        35, 126, 26, 27, 126, 27, 126, 1,\n+        131, 131, 131, 1, 131, 133, 132, 33,\n+        132, 33, 133, 132, 133, 132, 33, 132,\n+        34, 132, 0\n+};\n+\n+static const char _use_syllable_machine_trans_targs[] = {\n+        1, 30, 0, 56, 58, 85, 86, 110,\n+        112, 98, 87, 88, 89, 90, 102, 104,\n+        105, 106, 113, 107, 99, 100, 101, 93,\n+        94, 95, 114, 115, 116, 108, 91, 92,\n+        0, 117, 119, 109, 0, 2, 3, 15,\n+        4, 5, 6, 7, 19, 21, 22, 23,\n+        27, 24, 16, 17, 18, 10, 11, 12,\n+        28, 29, 25, 8, 9, 0, 26, 13,\n+        14, 20, 0, 31, 32, 44, 33, 34,\n+        35, 36, 48, 50, 51, 52, 53, 45,\n+        46, 47, 39, 40, 41, 54, 37, 38,\n+        0, 54, 55, 42, 0, 43, 49, 0,\n+        0, 57, 0, 59, 60, 72, 61, 62,\n+        63, 64, 76, 78, 79, 80, 84, 81,\n+        73, 74, 75, 67, 68, 69, 82, 65,\n+        66, 82, 83, 70, 71, 77, 0, 96,\n+        97, 103, 111, 0, 0, 118\n+};\n+\n+static const char _use_syllable_machine_trans_actions[] = {\n+        0, 0, 3, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        4, 0, 0, 0, 5, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 6, 0, 0,\n+        0, 0, 7, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 8, 0, 0,\n+        9, 10, 0, 0, 11, 0, 0, 12,\n+        13, 0, 14, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 8, 0,\n+        0, 10, 0, 0, 0, 0, 15, 0,\n+        0, 0, 0, 16, 17, 0\n+};\n+\n+static const char _use_syllable_machine_to_state_actions[] = {\n+        1, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0\n+};\n+\n+static const char _use_syllable_machine_from_state_actions[] = {\n+        2, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0\n+};\n+\n+static const short _use_syllable_machine_eof_trans[] = {\n+        0, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 67, 67,\n+        67, 67, 67, 67, 67, 67, 67, 67,\n+        67, 67, 93, 67, 67, 67, 67, 67,\n+        67, 67, 67, 67, 67, 67, 96, 67,\n+        97, 99, 67, 67, 67, 67, 67, 67,\n+        67, 67, 67, 67, 67, 67, 93, 67,\n+        67, 67, 67, 67, 67, 67, 67, 67,\n+        67, 67, 96, 67, 67, 127, 127, 127,\n+        127, 127, 127, 127, 127, 127, 127, 127,\n+        127, 127, 127, 127, 127, 127, 127, 127,\n+        127, 127, 127, 127, 127, 127, 127, 127,\n+        127, 127, 127, 127, 132, 133, 133, 133\n+};\n+\n+static const int use_syllable_machine_start = 0;\n+static const int use_syllable_machine_first_final = 0;\n+static const int use_syllable_machine_error = -1;\n+\n+static const int use_syllable_machine_en_main = 0;\n+\n+\n+#line 58 \"hb-ot-shaper-use-machine.rl\"\n+\n+\n+\n+#line 182 \"hb-ot-shaper-use-machine.rl\"\n+\n+\n+#define found_syllable(syllable_type) \\\n+  HB_STMT_START { \\\n+    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", (*ts).second.first, (*te).second.first, #syllable_type); \\\n+    for (unsigned i = (*ts).second.first; i < (*te).second.first; ++i) \\\n+      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n+    syllable_serial++; \\\n+    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+  } HB_STMT_END\n+\n+\n+template <typename Iter>\n+struct machine_index_t :\n+  hb_iter_with_fallback_t<machine_index_t<Iter>,\n+                          typename Iter::item_t>\n+{\n+  machine_index_t (const Iter& it) : it (it) {}\n+  machine_index_t (const machine_index_t& o) : hb_iter_with_fallback_t<machine_index_t<Iter>,\n+                                                                       typename Iter::item_t> (),\n+                                               it (o.it), is_null (o.is_null) {}\n+\n+  static constexpr bool is_random_access_iterator = Iter::is_random_access_iterator;\n+  static constexpr bool is_sorted_iterator = Iter::is_sorted_iterator;\n+\n+  typename Iter::item_t __item__ () const { return *it; }\n+  typename Iter::item_t __item_at__ (unsigned i) const { return it[i]; }\n+  unsigned __len__ () const { return it.len (); }\n+  void __next__ () { ++it; }\n+  void __forward__ (unsigned n) { it += n; }\n+  void __prev__ () { --it; }\n+  void __rewind__ (unsigned n) { it -= n; }\n+\n+  void operator = (unsigned n)\n+  {\n+    assert (n == 0);\n+    is_null = true;\n+  }\n+  explicit operator bool () { return !is_null; }\n+\n+  void operator = (const machine_index_t& o)\n+  {\n+    is_null = o.is_null;\n+    unsigned index = (*it).first;\n+    unsigned n = (*o.it).first;\n+    if (index < n) it += n - index; else if (index > n) it -= index - n;\n+  }\n+  bool operator == (const machine_index_t& o) const\n+  { return is_null ? o.is_null : !o.is_null && (*it).first == (*o.it).first; }\n+  bool operator != (const machine_index_t& o) const { return !(*this == o); }\n+\n+  private:\n+  Iter it;\n+  bool is_null = false;\n+};\n+struct\n+{\n+  template <typename Iter,\n+            hb_requires (hb_is_iterable (Iter))>\n+  machine_index_t<hb_iter_type<Iter>>\n+  operator () (Iter&& it) const\n+  { return machine_index_t<hb_iter_type<Iter>> (hb_iter (it)); }\n+}\n+HB_FUNCOBJ (machine_index);\n+\n+\n+\n+static bool\n+not_ccs_default_ignorable (const hb_glyph_info_t &i)\n+{ return i.use_category() != USE(CGJ); }\n+\n+static inline void\n+find_syllables_use (hb_buffer_t *buffer)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  auto p =\n+    + hb_iter (info, buffer->len)\n+    | hb_enumerate\n+    | hb_filter ([] (const hb_glyph_info_t &i) { return not_ccs_default_ignorable (i); },\n+                 hb_second)\n+    | hb_filter ([&] (const hb_pair_t<unsigned, const hb_glyph_info_t &> p)\n+                 {\n+                   if (p.second.use_category() == USE(ZWNJ))\n+                     for (unsigned i = p.first + 1; i < buffer->len; ++i)\n+                       if (not_ccs_default_ignorable (info[i]))\n+                         return !_hb_glyph_info_is_unicode_mark (&info[i]);\n+                   return true;\n+                 })\n+    | hb_enumerate\n+    | machine_index\n+    ;\n+  auto pe = p + p.len ();\n+  auto eof = +pe;\n+  auto ts = +p;\n+  auto te = +p;\n+  unsigned int act HB_UNUSED;\n+  int cs;\n+\n+#line 784 \"hb-ot-shaper-use-machine.hh\"\n+        {\n+        cs = use_syllable_machine_start;\n+        ts = 0;\n+        te = 0;\n+        act = 0;\n+        }\n+\n+#line 282 \"hb-ot-shaper-use-machine.rl\"\n+\n+\n+  unsigned int syllable_serial = 1;\n+\n+#line 797 \"hb-ot-shaper-use-machine.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const unsigned char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+_resume:\n+        switch ( _use_syllable_machine_from_state_actions[cs] ) {\n+        case 2:\n+#line 1 \"NONE\"\n+        {ts = p;}\n+        break;\n+#line 811 \"hb-ot-shaper-use-machine.hh\"\n+        }\n+\n+        _keys = _use_syllable_machine_trans_keys + (cs<<1);\n+        _inds = _use_syllable_machine_indicies + _use_syllable_machine_index_offsets[cs];\n+\n+        _slen = _use_syllable_machine_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=( (*p).second.second.use_category()) &&\n+                ( (*p).second.second.use_category()) <= _keys[1] ?\n+                ( (*p).second.second.use_category()) - _keys[0] : _slen ];\n+\n+_eof_trans:\n+        cs = _use_syllable_machine_trans_targs[_trans];\n+\n+        if ( _use_syllable_machine_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _use_syllable_machine_trans_actions[_trans] ) {\n+        case 9:\n+#line 172 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p+1;{ found_syllable (use_standard_cluster); }}\n+        break;\n+        case 6:\n+#line 175 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p+1;{ found_syllable (use_symbol_cluster); }}\n+        break;\n+        case 4:\n+#line 177 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p+1;{ found_syllable (use_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }}\n+        break;\n+        case 3:\n+#line 178 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p+1;{ found_syllable (use_non_cluster); }}\n+        break;\n+        case 11:\n+#line 171 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (use_sakot_terminated_cluster); }}\n+        break;\n+        case 7:\n+#line 172 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (use_standard_cluster); }}\n+        break;\n+        case 14:\n+#line 173 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (use_number_joiner_terminated_cluster); }}\n+        break;\n+        case 13:\n+#line 174 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (use_numeral_cluster); }}\n+        break;\n+        case 5:\n+#line 175 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (use_symbol_cluster); }}\n+        break;\n+        case 17:\n+#line 176 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (use_hieroglyph_cluster); }}\n+        break;\n+        case 15:\n+#line 177 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (use_broken_cluster); buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_BROKEN_SYLLABLE; }}\n+        break;\n+        case 16:\n+#line 178 \"hb-ot-shaper-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (use_non_cluster); }}\n+        break;\n+        case 12:\n+#line 1 \"NONE\"\n+        {       switch( act ) {\n+        case 1:\n+        {{p = ((te))-1;} found_syllable (use_virama_terminated_cluster); }\n+        break;\n+        case 2:\n+        {{p = ((te))-1;} found_syllable (use_sakot_terminated_cluster); }\n+        break;\n+        }\n+        }\n+        break;\n+        case 8:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 170 \"hb-ot-shaper-use-machine.rl\"\n+        {act = 1;}\n+        break;\n+        case 10:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 171 \"hb-ot-shaper-use-machine.rl\"\n+        {act = 2;}\n+        break;\n+#line 901 \"hb-ot-shaper-use-machine.hh\"\n+        }\n+\n+_again:\n+        switch ( _use_syllable_machine_to_state_actions[cs] ) {\n+        case 1:\n+#line 1 \"NONE\"\n+        {ts = 0;}\n+        break;\n+#line 910 \"hb-ot-shaper-use-machine.hh\"\n+        }\n+\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        if ( _use_syllable_machine_eof_trans[cs] > 0 ) {\n+                _trans = _use_syllable_machine_eof_trans[cs] - 1;\n+                goto _eof_trans;\n+        }\n+        }\n+\n+        }\n+\n+#line 287 \"hb-ot-shaper-use-machine.rl\"\n+\n+}\n+\n+#undef found_syllable\n+\n+#endif \/* HB_OT_SHAPER_USE_MACHINE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-use-machine.hh","additions":931,"deletions":0,"binary":false,"changes":931,"status":"added"},{"patch":"@@ -0,0 +1,1572 @@\n+\/* == Start of generated table == *\/\n+\/*\n+ * The following table is generated by running:\n+ *\n+ *   .\/gen-use-table.py IndicSyllabicCategory.txt IndicPositionalCategory.txt ArabicShaping.txt DerivedCoreProperties.txt UnicodeData.txt Blocks.txt Scripts.txt IndicSyllabicCategory-Additional.txt IndicPositionalCategory-Additional.txt\n+ *\n+ * on files with these headers:\n+ *\n+ * # IndicSyllabicCategory-14.0.0.txt\n+ * # Date: 2021-05-22, 01:01:00 GMT [KW, RP]\n+ * # IndicPositionalCategory-14.0.0.txt\n+ * # Date: 2021-05-22, 01:01:00 GMT [KW, RP]\n+ * # ArabicShaping-14.0.0.txt\n+ * # Date: 2021-05-21, 01:54:00 GMT [KW, RP]\n+ * # DerivedCoreProperties-14.0.0.txt\n+ * # Date: 2021-08-12, 23:12:53 GMT\n+ * # Blocks-14.0.0.txt\n+ * # Date: 2021-01-22, 23:29:00 GMT [KW]\n+ * # Scripts-14.0.0.txt\n+ * # Date: 2021-07-10, 00:35:31 GMT\n+ * # Override values For Indic_Syllabic_Category\n+ * # Not derivable\n+ * # Initial version based on Unicode 7.0 by Andrew Glass 2014-03-17\n+ * # Updated for Unicode 10.0 by Andrew Glass 2017-07-25\n+ * # Updated for Unicode 12.1 by Andrew Glass 2019-05-24\n+ * # Updated for Unicode 13.0 by Andrew Glass 2020-07-28\n+ * # Updated for Unicode 14.0 by Andrew Glass 2021-09-25\n+ * # Override values For Indic_Positional_Category\n+ * # Not derivable\n+ * # Initial version based on Unicode 7.0 by Andrew Glass 2014-03-17\n+ * # Updated for Unicode 10.0 by Andrew Glass 2017-07-25\n+ * # Ammended for Unicode 10.0 by Andrew Glass 2018-09-21\n+ * # Updated for L2\/19-083    by Andrew Glass 2019-05-06\n+ * # Updated for Unicode 12.1 by Andrew Glass 2019-05-30\n+ * # Updated for Unicode 13.0 by Andrew Glass 2020-07-28\n+ * # Updated for Unicode 14.0 by Andrew Glass 2021-09-28\n+ * UnicodeData.txt does not have a header.\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_USE_TABLE_HH\n+#define HB_OT_SHAPER_USE_TABLE_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shaper-use-machine.hh\"\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-macros\"\n+#define B       USE(B)  \/* BASE *\/\n+#define CGJ     USE(CGJ)        \/* CGJ *\/\n+#define CS      USE(CS) \/* CONS_WITH_STACKER *\/\n+#define G       USE(G)  \/* HIEROGLYPH *\/\n+#define GB      USE(GB) \/* BASE_OTHER *\/\n+#define H       USE(H)  \/* HALANT *\/\n+#define HN      USE(HN) \/* HALANT_NUM *\/\n+#define HVM     USE(HVM)        \/* HALANT_OR_VOWEL_MODIFIER *\/\n+#define IS      USE(IS) \/* INVISIBLE_STACKER *\/\n+#define J       USE(J)  \/* HIEROGLYPH_JOINER *\/\n+#define N       USE(N)  \/* BASE_NUM *\/\n+#define O       USE(O)  \/* OTHER *\/\n+#define R       USE(R)  \/* REPHA *\/\n+#define SB      USE(SB) \/* HIEROGLYPH_SEGMENT_BEGIN *\/\n+#define SE      USE(SE) \/* HIEROGLYPH_SEGMENT_END *\/\n+#define SUB     USE(SUB)        \/* CONS_SUB *\/\n+#define Sk      USE(Sk) \/* SAKOT *\/\n+#define WJ      USE(WJ) \/* Word_Joiner *\/\n+#define ZWNJ    USE(ZWNJ)       \/* ZWNJ *\/\n+#define CMAbv   USE(CMAbv)\n+#define CMBlw   USE(CMBlw)\n+#define FAbv    USE(FAbv)\n+#define FBlw    USE(FBlw)\n+#define FPst    USE(FPst)\n+#define FMAbv   USE(FMAbv)\n+#define FMBlw   USE(FMBlw)\n+#define FMPst   USE(FMPst)\n+#define MAbv    USE(MAbv)\n+#define MBlw    USE(MBlw)\n+#define MPst    USE(MPst)\n+#define MPre    USE(MPre)\n+#define SMAbv   USE(SMAbv)\n+#define SMBlw   USE(SMBlw)\n+#define VAbv    USE(VAbv)\n+#define VBlw    USE(VBlw)\n+#define VPst    USE(VPst)\n+#define VPre    USE(VPre)\n+#define VMAbv   USE(VMAbv)\n+#define VMBlw   USE(VMBlw)\n+#define VMPst   USE(VMPst)\n+#define VMPre   USE(VMPre)\n+#pragma GCC diagnostic pop\n+\n+static const uint8_t use_table[] = {\n+\n+\n+#define use_offset_0x0028u 0\n+\n+\n+  \/* Basic Latin *\/\n+                                                                         O,     O,     O,     O,     O,    GB,     O,     O,\n+  \/* 0030 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x00a0u 24\n+\n+\n+  \/* Latin-1 Supplement *\/\n+\n+  \/* 00A0 *\/    GB,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,     O,     O,\n+  \/* 00B0 *\/     O,     O, FMPst, FMPst,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 00C0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 00D0 *\/     O,     O,     O,     O,     O,     O,     O,    GB,\n+\n+#define use_offset_0x0348u 80\n+\n+\n+  \/* Combining Diacritical Marks *\/\n+                                                                         O,     O,     O,     O,     O,     O,     O,   CGJ,\n+\n+#define use_offset_0x0640u 88\n+\n+\n+  \/* Arabic *\/\n+\n+  \/* 0640 *\/     B,     O,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x07c8u 96\n+\n+\n+  \/* NKo *\/\n+                                                                         O,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 07D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 07E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,\n+  \/* 07F0 *\/ VMAbv, VMAbv, VMAbv, VMAbv,     O,     O,     O,     O,     O,     O,     B,    WJ,    WJ, VMAbv,     O,     O,\n+\n+#define use_offset_0x0840u 152\n+\n+\n+  \/* Mandaic *\/\n+\n+  \/* 0840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, CMBlw, CMBlw, CMBlw,    WJ,    WJ,     O,    WJ,\n+\n+#define use_offset_0x0900u 184\n+\n+\n+  \/* Devanagari *\/\n+\n+  \/* 0900 *\/ VMAbv, VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VPst, CMBlw,     B,  VPst,  VPre,\n+  \/* 0940 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VPst,  VPst,  VPst,  VPst,     H,  VPre,  VPst,\n+  \/* 0950 *\/     O, VMAbv, VMBlw,     O,     O,  VAbv,  VBlw,  VBlw,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0960 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0970 *\/     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+\n+  \/* Bengali *\/\n+\n+  \/* 0980 *\/    GB, VMAbv, VMPst, VMPst,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,\n+  \/* 0990 *\/     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 09A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 09B0 *\/     B,    WJ,     B,    WJ,    WJ,    WJ,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VPst,  VPre,\n+  \/* 09C0 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,  VPre,  VPre,    WJ,    WJ,  VPre,  VPre,     H,     O,    WJ,\n+  \/* 09D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,  VPst,    WJ,    WJ,    WJ,    WJ,     B,     B,    WJ,     B,\n+  \/* 09E0 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 09F0 *\/     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     B,     O, FMAbv,    WJ,\n+\n+  \/* Gurmukhi *\/\n+\n+  \/* 0A00 *\/    WJ, VMAbv, VMAbv, VMPst,    WJ,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,     B,\n+  \/* 0A10 *\/     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 0A30 *\/     B,    WJ,     B,     B,    WJ,     B,     B,    WJ,     B,     B,    WJ,    WJ, CMBlw,    WJ,  VPst,  VPre,\n+  \/* 0A40 *\/  VPst,  VBlw,  VBlw,    WJ,    WJ,    WJ,    WJ,  VAbv,  VAbv,    WJ,    WJ,  VAbv,  VAbv,     H,    WJ,    WJ,\n+  \/* 0A50 *\/    WJ, VMBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,    WJ,     B,    WJ,\n+  \/* 0A60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0A70 *\/ VMAbv, CMAbv,    GB,    GB,     O,  MBlw,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Gujarati *\/\n+\n+  \/* 0A80 *\/    WJ, VMAbv, VMAbv, VMPst,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,\n+  \/* 0A90 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0AA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 0AB0 *\/     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VPst,  VPre,\n+  \/* 0AC0 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,    WJ,  VAbv,  VAbv,  VAbv,    WJ,  VPst,  VPst,     H,    WJ,    WJ,\n+  \/* 0AD0 *\/     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 0AE0 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0AF0 *\/     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B, VMAbv, VMAbv, VMAbv, CMAbv, CMAbv, CMAbv,\n+\n+  \/* Oriya *\/\n+\n+  \/* 0B00 *\/    WJ, VMAbv, VMPst, VMPst,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,\n+  \/* 0B10 *\/     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 0B30 *\/     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VPst,  VAbv,\n+  \/* 0B40 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,  VPre,  VPre,    WJ,    WJ,  VPre,  VPre,     H,    WJ,    WJ,\n+  \/* 0B50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,  VAbv,  VAbv,  VAbv,    WJ,    WJ,    WJ,    WJ,     B,     B,    WJ,     B,\n+  \/* 0B60 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0B70 *\/     O,     B,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Tamil *\/\n+\n+  \/* 0B80 *\/    WJ,    WJ, VMAbv,     O,    WJ,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,\n+  \/* 0B90 *\/     B,    WJ,     B,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,    WJ,     B,    WJ,     B,     B,\n+  \/* 0BA0 *\/    WJ,    WJ,    WJ,     B,     B,    WJ,    WJ,    WJ,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,\n+  \/* 0BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,  VPst,  VPst,\n+  \/* 0BC0 *\/  VAbv,  VPst,  VPst,    WJ,    WJ,    WJ,  VPre,  VPre,  VPre,    WJ,  VPre,  VPre,  VPre,     H,    WJ,    WJ,\n+  \/* 0BD0 *\/     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 0BE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0BF0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Telugu *\/\n+\n+  \/* 0C00 *\/ VMAbv, VMPst, VMPst, VMPst, VMAbv,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,\n+  \/* 0C10 *\/     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 0C30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VAbv,  VAbv,\n+  \/* 0C40 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,    WJ,  VAbv,  VAbv,  VAbv,    WJ,  VAbv,  VAbv,  VAbv,     H,    WJ,    WJ,\n+  \/* 0C50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,  VAbv,  VBlw,    WJ,     B,     B,     B,    WJ,    WJ,     O,    WJ,    WJ,\n+  \/* 0C60 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0C70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Kannada *\/\n+\n+  \/* 0C80 *\/     B, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,\n+  \/* 0C90 *\/     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0CA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 0CB0 *\/     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw,     B,  VPst,  VAbv,\n+  \/* 0CC0 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,    WJ,  VAbv,  VAbv,  VAbv,    WJ,  VAbv,  VAbv,  VAbv,     H,    WJ,    WJ,\n+  \/* 0CD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,  VPst,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     B,    WJ,\n+  \/* 0CE0 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0CF0 *\/    WJ,    CS,    CS,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Malayalam *\/\n+\n+  \/* 0D00 *\/ VMAbv, VMAbv, VMPst, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,\n+  \/* 0D10 *\/     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0D20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,     B,  VPst,  VPst,\n+  \/* 0D40 *\/  VPst,  VPst,  VPst,  VBlw,  VBlw,    WJ,  VPre,  VPre,  VPre,    WJ,  VPre,  VPre,  VPre,     H,     R,     O,\n+  \/* 0D50 *\/    WJ,    WJ,    WJ,    WJ,     O,     O,     O,  VPst,     O,     O,     O,     O,     O,     O,     O,     B,\n+  \/* 0D60 *\/     B,     B,  VBlw,  VBlw,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0D70 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Sinhala *\/\n+\n+  \/* 0D80 *\/    WJ, VMAbv, VMPst, VMPst,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0D90 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 0DA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0DB0 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,    WJ,    WJ,\n+  \/* 0DC0 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,   HVM,    WJ,    WJ,    WJ,    WJ,  VPst,\n+  \/* 0DD0 *\/  VPst,  VPst,  VAbv,  VAbv,  VBlw,    WJ,  VBlw,    WJ,  VPst,  VPre,  VPre,  VPre,  VPre,  VPre,  VPre,  VPst,\n+  \/* 0DE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0DF0 *\/    WJ,    WJ,  VPst,  VPst,     O,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x0f00u 1456\n+\n+\n+  \/* Tibetan *\/\n+\n+  \/* 0F00 *\/     B,     B,     O,     O,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 0F10 *\/     O,     O,     O,     O,     O,     O,     O,     O,  VBlw,  VBlw,     O,     O,     O,     O,     O,     O,\n+  \/* 0F20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0F30 *\/     B,     B,     B,     B,     O,  FBlw,     O,  FBlw,     O, CMAbv,     O,     O,     O,     O,  VPst,  VPre,\n+  \/* 0F40 *\/     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0F50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0F60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n+  \/* 0F70 *\/    WJ, CMBlw,  VBlw,  VAbv,  VAbv,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw, VMAbv,     O,\n+  \/* 0F80 *\/  VBlw,  VAbv, VMAbv, VMAbv,  VBlw,     O, VMAbv, VMAbv,     B,     B,     B,     B,     B,   SUB,   SUB,   SUB,\n+  \/* 0F90 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,    WJ,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n+  \/* 0FA0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n+  \/* 0FB0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,    WJ,     O,     O,\n+  \/* 0FC0 *\/     O,     O,     O,     O,     O,     O,  FBlw,     O,\n+\n+#define use_offset_0x1000u 1656\n+\n+\n+  \/* Myanmar *\/\n+\n+  \/* 1000 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VAbv,  VAbv,  VBlw,\n+  \/* 1030 *\/  VBlw,  VPre,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMBlw, VMPst,    IS,  VAbv,  MPst,  MPre,  MBlw,  MBlw,     B,\n+  \/* 1040 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,    GB,     O,     O,    GB,     O,\n+  \/* 1050 *\/     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VBlw,  VBlw,     B,     B,     B,     B,  MBlw,  MBlw,\n+  \/* 1060 *\/  MBlw,     B,  VPst, VMPst, VMPst,     B,     B,  VPst,  VPst, VMPst, VMPst, VMPst, VMPst, VMPst,     B,     B,\n+  \/* 1070 *\/     B,  VAbv,  VAbv,  VAbv,  VAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1080 *\/     B,     B,  MBlw,  VPst,  VPre,  VAbv,  VAbv, VMPst, VMPst, VMPst, VMPst, VMPst, VMPst, VMBlw,     B, VMPst,\n+  \/* 1090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMPst, VMPst,  VPst,  VAbv,     O,     O,\n+\n+#define use_offset_0x1700u 1816\n+\n+\n+  \/* Tagalog *\/\n+\n+  \/* 1700 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1710 *\/     B,     B,  VAbv,  VBlw,  VBlw,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,\n+\n+  \/* Hanunoo *\/\n+\n+  \/* 1720 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1730 *\/     B,     B,  VAbv,  VBlw,  VPst,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Buhid *\/\n+\n+  \/* 1740 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1750 *\/     B,     B,  VAbv,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Tagbanwa *\/\n+\n+  \/* 1760 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,\n+  \/* 1770 *\/     B,    WJ,  VAbv,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Khmer *\/\n+\n+  \/* 1780 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1790 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 17A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 17B0 *\/     B,     B,     B,     B,   CGJ,   CGJ,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VPre,  VPre,\n+  \/* 17C0 *\/  VPre,  VPre,  VPre,  VPre,  VPre,  VPre, VMAbv, VMPst,  VPst, VMAbv, VMAbv, FMAbv,  FAbv, CMAbv, FMAbv, VMAbv,\n+  \/* 17D0 *\/ FMAbv,  VAbv,    IS, FMAbv,     O,     O,     O,     O,     O,     O,     O,     O,     B, FMAbv,    WJ,    WJ,\n+  \/* 17E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 17F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Mongolian *\/\n+\n+  \/* 1800 *\/     B,     O,     O,     O,     O,     O,     O,     B,     O,     O,     B,   CGJ,   CGJ,   CGJ,    WJ,   CGJ,\n+  \/* 1810 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 1820 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1830 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1860 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1870 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 1880 *\/    GB,    GB,    GB,    GB,    GB, CMAbv, CMAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1890 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, CMBlw,     B,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x1900u 2248\n+\n+\n+  \/* Limbu *\/\n+\n+  \/* 1900 *\/    GB,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,\n+  \/* 1920 *\/  VAbv,  VAbv,  VBlw,  VPst,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,   SUB,   SUB,   SUB,    WJ,    WJ,    WJ,    WJ,\n+  \/* 1930 *\/  FPst,  FPst, VMBlw,  FPst,  FPst,  FPst,  FPst,  FPst,  FPst,  FBlw, VMAbv, FMBlw,    WJ,    WJ,    WJ,    WJ,\n+  \/* 1940 *\/     O,    WJ,    WJ,    WJ,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+\n+  \/* Tai Le *\/\n+\n+  \/* 1950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1960 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,\n+  \/* 1970 *\/     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* New Tai Lue *\/\n+\n+  \/* 1980 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1990 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 19A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,\n+  \/* 19B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 19C0 *\/     B,     B,     B,     B,     B,     B,     B,     B, VMPst, VMPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 19D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,     O,     O,\n+  \/* 19E0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 19F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Buginese *\/\n+\n+  \/* 1A00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1A10 *\/     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VPre,  VPst,  VAbv,    WJ,    WJ,     O,     O,\n+\n+  \/* Tai Tham *\/\n+\n+  \/* 1A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1A30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1A40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1A50 *\/     B,     B,     B,     B,     B,  MPre,  MBlw,   SUB,  FAbv,  FAbv,  MAbv,   SUB,   SUB,   SUB,   SUB,    WJ,\n+  \/* 1A60 *\/    Sk,  VPst,  VAbv,  VPst,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VAbv,  VBlw,  VPst,  VPre,  VPre,\n+  \/* 1A70 *\/  VPre,  VPre,  VPre,  VAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,  VAbv, VMAbv, VMAbv,    WJ,    WJ, VMBlw,\n+  \/* 1A80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 1A90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x1b00u 2664\n+\n+\n+  \/* Balinese *\/\n+\n+  \/* 1B00 *\/ VMAbv, VMAbv, VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1B30 *\/     B,     B,     B,     B, CMAbv,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPre,  VPre,\n+  \/* 1B40 *\/  VPre,  VPre,  VAbv,  VAbv,     H,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n+  \/* 1B50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+  \/* 1B60 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O, SMAbv, SMBlw, SMAbv, SMAbv, SMAbv,\n+  \/* 1B70 *\/ SMAbv, SMAbv, SMAbv, SMAbv,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,\n+\n+  \/* Sundanese *\/\n+\n+  \/* 1B80 *\/ VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1B90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BA0 *\/     B,   SUB,   SUB,   SUB,  VAbv,  VBlw,  VPre,  VPst,  VAbv,  VAbv,  VPst,    IS,   SUB,   SUB,     B,     B,\n+  \/* 1BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+\n+  \/* Batak *\/\n+\n+  \/* 1BC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BE0 *\/     B,     B,     B,     B,     B,     B, CMAbv,  VPst,  VAbv,  VAbv,  VPst,  VPst,  VPst,  VAbv,  VPst,  VAbv,\n+  \/* 1BF0 *\/  FAbv,  FAbv, CMBlw, CMBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,\n+\n+  \/* Lepcha *\/\n+\n+  \/* 1C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1C20 *\/     B,     B,     B,     B,   SUB,   SUB,  VPst,  VPre,  VPre,  VPre,  VPst,  VPst,  VBlw,  FAbv,  FAbv,  FAbv,\n+  \/* 1C30 *\/  FAbv,  FAbv,  FAbv,  FAbv, VMPre, VMPre, FMAbv, CMBlw,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,\n+  \/* 1C40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,     B,     B,     B,\n+\n+#define use_offset_0x1cd0u 3000\n+\n+\n+  \/* Vedic Extensions *\/\n+\n+  \/* 1CD0 *\/ VMAbv, VMAbv, VMAbv,     O, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMAbv, VMAbv, VMBlw, VMBlw, VMBlw, VMBlw,\n+  \/* 1CE0 *\/ VMAbv, VMPst, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw,     O,     O,     O,     O, VMBlw,     O,     O,\n+  \/* 1CF0 *\/     O,     O,     O,     O, VMAbv,    CS,    CS, VMPst, VMAbv, VMAbv,    GB,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x1df8u 3048\n+\n+\n+  \/* Combining Diacritical Marks Supplement *\/\n+                                                                         O,     O,     O, FMAbv,     O,     O,     O,     O,\n+\n+#define use_offset_0x2008u 3056\n+\n+\n+  \/* General Punctuation *\/\n+                                                                         O,     O,     O,    WJ,  ZWNJ,   CGJ,    WJ,    WJ,\n+  \/* 2010 *\/    GB,    GB,    GB,    GB,    GB,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 2020 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,     O,\n+  \/* 2030 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 2040 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 2050 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 2060 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Superscripts and Subscripts *\/\n+\n+  \/* 2070 *\/     O,     O,    WJ,    WJ, FMPst,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 2080 *\/     O,     O, FMPst, FMPst, FMPst,     O,     O,     O,\n+\n+#define use_offset_0x20f0u 3184\n+\n+\n+  \/* Combining Diacritical Marks for Symbols *\/\n+\n+  \/* 20F0 *\/ VMAbv,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x25c8u 3192\n+\n+\n+  \/* Geometric Shapes *\/\n+                                                                         O,     O,     O,     O,     B,     O,     O,     O,\n+\n+#define use_offset_0x2d30u 3200\n+\n+\n+  \/* Tifinagh *\/\n+\n+  \/* 2D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 2D40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 2D50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 2D60 *\/     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,\n+  \/* 2D70 *\/     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     H,\n+\n+#define use_offset_0xa800u 3280\n+\n+\n+  \/* Syloti Nagri *\/\n+\n+  \/* A800 *\/     B,     B,  VAbv,     B,     B,     B,     H,     B,     B,     B,     B, VMAbv,     B,     B,     B,     B,\n+  \/* A810 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A820 *\/     B,     B,     B,  VPst,  VPst,  VBlw,  VAbv,  VPst,     O,     O,     O,     O,  VBlw,    WJ,    WJ,    WJ,\n+  \/* A830 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Phags-pa *\/\n+\n+  \/* A840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A860 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A870 *\/     B,     B,     B,     B,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Saurashtra *\/\n+\n+  \/* A880 *\/ VMPst, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A890 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A8A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A8B0 *\/     B,     B,     B,     B,  MPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,\n+  \/* A8C0 *\/  VPst,  VPst,  VPst,  VPst,     H, VMAbv,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,\n+  \/* A8D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Devanagari Extended *\/\n+\n+  \/* A8E0 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,\n+  \/* A8F0 *\/ VMAbv, VMAbv,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     B,  VAbv,\n+\n+  \/* Kayah Li *\/\n+\n+  \/* A900 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A920 *\/     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv, VMBlw, VMBlw, VMBlw,     O,     O,\n+\n+  \/* Rejang *\/\n+\n+  \/* A930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A940 *\/     B,     B,     B,     B,     B,     B,     B,  VBlw,  VBlw,  VBlw,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  FAbv,\n+  \/* A950 *\/  FAbv,  FAbv,  FPst,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,\n+  \/* A960 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* A970 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,\n+\n+  \/* Javanese *\/\n+\n+  \/* A980 *\/ VMAbv, VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A990 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A9A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A9B0 *\/     B,     B,     B, CMAbv,  VPst,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VPre,  VPre,  VAbv,  MBlw,  MPst,  MBlw,\n+  \/* A9C0 *\/     H,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,     O,\n+  \/* A9D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,     O,     O,\n+\n+  \/* Myanmar Extended-B *\/\n+\n+  \/* A9E0 *\/     B,     B,     B,     B,     B,  VAbv,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A9F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,\n+\n+  \/* Cham *\/\n+\n+  \/* AA00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AA10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AA20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VAbv,  VPre,\n+  \/* AA30 *\/  VPre,  VAbv,  VBlw,  MPst,  MPre,  MAbv,  MBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* AA40 *\/     B,     B,     B,  FAbv,     B,     B,     B,     B,     B,     B,     B,     B,  FAbv,  FPst,    WJ,    WJ,\n+  \/* AA50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     O,     O,     O,     O,\n+\n+  \/* Myanmar Extended-A *\/\n+\n+  \/* AA60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AA70 *\/     O,     B,     B,     B,    GB,    GB,    GB,     O,     O,     O,     B, VMPst, VMAbv, VMPst,     B,     B,\n+\n+  \/* Tai Viet *\/\n+\n+  \/* AA80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AA90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AAA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AAB0 *\/  VAbv,     B,  VAbv,  VAbv,  VBlw,     B,     B,  VAbv,  VAbv,     B,     B,     B,     B,     B,  VAbv, VMAbv,\n+  \/* AAC0 *\/     B, VMAbv,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* AAD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,\n+\n+  \/* Meetei Mayek Extensions *\/\n+\n+  \/* AAE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPre,  VBlw,  VAbv,  VPre,  VPst,\n+  \/* AAF0 *\/     O,     O,     O,     O,     O, VMPst,    IS,    WJ,\n+\n+#define use_offset_0xabc0u 4040\n+\n+\n+  \/* Meetei Mayek *\/\n+\n+  \/* ABC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* ABD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* ABE0 *\/     B,     B,     B,  VPst,  VPst,  VAbv,  VPst,  VPst,  VBlw,  VPst,  VPst,     O, VMPst,  VBlw,    WJ,    WJ,\n+  \/* ABF0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0xfe00u 4104\n+\n+\n+  \/* Variation Selectors *\/\n+\n+  \/* FE00 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+\n+#define use_offset_0xfef8u 4120\n+\n+\n+  \/* Arabic Presentation Forms-B *\/\n+                                                                         O,     O,     O,     O,     O,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0xfff0u 4128\n+\n+\n+  \/* Specials *\/\n+\n+  \/* FFF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,    WJ,    WJ,\n+\n+#define use_offset_0x10570u 4144\n+\n+\n+  \/* Vithkuqi *\/\n+\n+  \/* 10570 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,\n+  \/* 10580 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,\n+  \/* 10590 *\/     B,     B,     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 105A0 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 105B0 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x10a00u 4224\n+\n+\n+  \/* Kharoshthi *\/\n+\n+  \/* 10A00 *\/     B,  VBlw,  VBlw,  VBlw,    WJ,  VAbv,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,  VPst, VMBlw, VMBlw, VMAbv,\n+  \/* 10A10 *\/     B,     B,     B,     B,    WJ,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10A30 *\/     B,     B,     B,     B,     B,     B,    WJ,    WJ, CMBlw, CMBlw, CMBlw,    WJ,    WJ,    WJ,    WJ,    IS,\n+  \/* 10A40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x10ac0u 4304\n+\n+\n+  \/* Manichaean *\/\n+\n+  \/* 10AC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10AD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10AE0 *\/     B,     B,     B,     B,     B, CMBlw, CMBlw,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,\n+\n+#define use_offset_0x10b80u 4352\n+\n+\n+  \/* Psalter Pahlavi *\/\n+\n+  \/* 10B80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10B90 *\/     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,    WJ,    WJ,    WJ,\n+  \/* 10BA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     O,\n+\n+#define use_offset_0x10d00u 4400\n+\n+\n+  \/* Hanifi Rohingya *\/\n+\n+  \/* 10D00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10D10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10D20 *\/     B,     B,     B,     B, VMAbv, VMAbv, VMAbv, CMAbv,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 10D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x10e80u 4464\n+\n+\n+  \/* Yezidi *\/\n+\n+  \/* 10E80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10E90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10EA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,  VAbv,  VAbv,     O,    WJ,    WJ,\n+  \/* 10EB0 *\/     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x10f30u 4520\n+\n+\n+  \/* Sogdian *\/\n+\n+  \/* 10F30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10F40 *\/     B,     B,     B,     B,     B,     B, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw,\n+  \/* 10F50 *\/ VMBlw,     B,     B,     B,     B,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 10F60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Old Uyghur *\/\n+\n+  \/* 10F70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10F80 *\/     B,     B, CMBlw, CMBlw, CMBlw, CMBlw,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 10F90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 10FA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Chorasmian *\/\n+\n+  \/* 10FB0 *\/     B,     O,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10FC0 *\/     O,     B,     B,     B,     B,     O,     O,     O,     O,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,\n+  \/* 10FD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 10FE0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 10FF0 *\/     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Brahmi *\/\n+\n+  \/* 11000 *\/ VMPst, VMAbv, VMPst,    CS,    CS,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11030 *\/     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,\n+  \/* 11040 *\/  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,     H,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,\n+  \/* 11050 *\/    WJ,    WJ,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,\n+  \/* 11060 *\/     N,     N,     N,     N,     N,     N,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11070 *\/  VAbv,     B,     B,  VAbv,  VAbv,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    HN,\n+\n+  \/* Kaithi *\/\n+\n+  \/* 11080 *\/ VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 110A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 110B0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VAbv,  VAbv,  VPst,  VPst,     H, CMBlw,     O,     O,     O,     O,     O,\n+  \/* 110C0 *\/     O,     O,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x11100u 4928\n+\n+\n+  \/* Chakma *\/\n+\n+  \/* 11100 *\/ VMAbv, VMAbv, VMAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11110 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11120 *\/     B,     B,     B,     B,     B,     B,     B,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPre,  VBlw,  VAbv,  VAbv,\n+  \/* 11130 *\/  VBlw,  VAbv,  VAbv,    IS, CMAbv,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11140 *\/     O,     O,     O,     O,     B,  VPst,  VPst,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Mahajani *\/\n+\n+  \/* 11150 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11160 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11170 *\/     B,     B,     B, CMBlw,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Sharada *\/\n+\n+  \/* 11180 *\/ VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11190 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 111A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 111B0 *\/     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,\n+  \/* 111C0 *\/     H,     B,     R,     R,     O,     O,     O,     O,     O, FMBlw, CMBlw,  VAbv,  VBlw,     O,  VPre, VMAbv,\n+  \/* 111D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,\n+\n+  \/* Sinhala Archaic Numbers *\/\n+\n+  \/* 111E0 *\/    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 111F0 *\/     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Khojki *\/\n+\n+  \/* 11200 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11210 *\/     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11220 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VPst,  VBlw,\n+  \/* 11230 *\/  VAbv,  VAbv,  VAbv,  VAbv, VMAbv,     H, CMAbv, CMAbv,     O,     O,     O,     O,     O,     O, VMAbv,    WJ,\n+\n+#define use_offset_0x11280u 5248\n+\n+\n+  \/* Multani *\/\n+\n+  \/* 11280 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,     B,    WJ,     B,     B,     B,     B,    WJ,     B,\n+  \/* 11290 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,\n+  \/* 112A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Khudawadi *\/\n+\n+  \/* 112B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 112C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 112D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,\n+  \/* 112E0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv, CMBlw,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 112F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Grantha *\/\n+\n+  \/* 11300 *\/ VMAbv, VMAbv, VMAbv, VMAbv,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,\n+  \/* 11310 *\/     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11320 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 11330 *\/     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,    WJ, CMBlw, CMBlw,     B,  VPst,  VPst,\n+  \/* 11340 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,    WJ,    WJ,  VPre,  VPre,    WJ,    WJ,  VPre,  VPre,     H,    WJ,    WJ,\n+  \/* 11350 *\/     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,  VPst,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     B,     B,\n+  \/* 11360 *\/     B,     B,  VPst,  VPst,    WJ,    WJ, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,    WJ,    WJ,    WJ,\n+  \/* 11370 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x11400u 5496\n+\n+\n+  \/* Newa *\/\n+\n+  \/* 11400 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11410 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11420 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11430 *\/     B,     B,     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,\n+  \/* 11440 *\/  VPst,  VPst,     H, VMAbv, VMAbv, VMPst, CMBlw,     B,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 11450 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,    WJ,     O, FMAbv,     B,\n+  \/* 11460 *\/    CS,    CS,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 11470 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Tirhuta *\/\n+\n+  \/* 11480 *\/     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11490 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 114A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 114B0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VPre,  VAbv,  VPre,  VPre,  VPst,  VPre, VMAbv,\n+  \/* 114C0 *\/ VMAbv, VMAbv,     H, CMBlw,     B,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 114D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x11580u 5720\n+\n+\n+  \/* Siddham *\/\n+\n+  \/* 11580 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11590 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 115A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,\n+  \/* 115B0 *\/  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,  VPre,  VPre,  VPre,  VPre, VMAbv, VMAbv, VMPst,     H,\n+  \/* 115C0 *\/ CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 115D0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,  VBlw,  VBlw,    WJ,    WJ,\n+  \/* 115E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 115F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Modi *\/\n+\n+  \/* 11600 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11610 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11620 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11630 *\/  VPst,  VPst,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPst,  VPst, VMAbv, VMPst,     H,\n+  \/* 11640 *\/  VAbv,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 11650 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 11660 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,\n+  \/* 11670 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Takri *\/\n+\n+  \/* 11680 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11690 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 116A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMPst,  VAbv,  VPre,  VPst,\n+  \/* 116B0 *\/  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,     H, CMBlw,     B,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 116C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 116D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 116E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 116F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Ahom *\/\n+\n+  \/* 11700 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11710 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,  MBlw,  MPre,  MAbv,\n+  \/* 11720 *\/  VPst,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VPre,  VAbv,  VBlw,  VAbv,  VAbv,  VAbv,    WJ,    WJ,    WJ,    WJ,\n+  \/* 11730 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,\n+  \/* 11740 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,\n+\n+#define use_offset_0x11800u 6176\n+\n+\n+  \/* Dogra *\/\n+\n+  \/* 11800 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11810 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11820 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,\n+  \/* 11830 *\/  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMPst,     H, CMBlw,     O,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x11900u 6240\n+\n+\n+  \/* Dives Akuru *\/\n+\n+  \/* 11900 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,    WJ,    WJ,     B,     B,     B,     B,\n+  \/* 11910 *\/     B,     B,     B,     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11930 *\/  VPst,  VPst,  VPst,  VPst,  VPst,  VPre,    WJ,  VPre,  VPre,    WJ,    WJ, VMAbv, VMAbv,  VPst,    IS,     R,\n+  \/* 11940 *\/  MPst,     R,  MPst, CMBlw,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 11950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x119a0u 6336\n+\n+\n+  \/* Nandinagari *\/\n+\n+  \/* 119A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 119B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 119C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 119D0 *\/     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,  VAbv,  VAbv,  VPst,  VPst, VMPst, VMPst,\n+  \/* 119E0 *\/     H,     B,     O,     O,  VPre,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 119F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Zanabazar Square *\/\n+\n+  \/* 11A00 *\/     B,  VAbv,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,     B,     B,     B,     B,     B,\n+  \/* 11A10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11A30 *\/     B,     B,     B, FMBlw,  VBlw, VMAbv, VMAbv, VMAbv, VMAbv, VMPst,     R,  MBlw,  MBlw,  MBlw,  MBlw,    GB,\n+  \/* 11A40 *\/     O,     O,     O,     O,     O,    GB,     O,    IS,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Soyombo *\/\n+\n+  \/* 11A50 *\/     B,  VAbv,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VPst,  VPst,  VBlw,  VBlw,  VBlw,     B,     B,     B,     B,\n+  \/* 11A60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11A70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11A80 *\/     B,     B,     B,     B,     R,     R,     R,     R,     R,     R,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,\n+  \/* 11A90 *\/  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw, VMAbv, VMPst, CMAbv,    IS,     O,     O,     O,     B,     O,     O,\n+\n+#define use_offset_0x11c00u 6592\n+\n+\n+  \/* Bhaiksuki *\/\n+\n+  \/* 11C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 11C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,\n+  \/* 11C30 *\/  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMAbv, VMPst,     H,\n+  \/* 11C40 *\/     B,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 11C50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11C60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n+\n+  \/* Marchen *\/\n+\n+  \/* 11C70 *\/     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11C80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11C90 *\/    WJ,    WJ,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n+  \/* 11CA0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,    WJ,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n+  \/* 11CB0 *\/  VBlw,  VPre,  VBlw,  VAbv,  VPst, VMAbv, VMAbv,    WJ,\n+\n+#define use_offset_0x11d00u 6776\n+\n+\n+  \/* Masaram Gondi *\/\n+\n+  \/* 11D00 *\/     B,     B,     B,     B,     B,     B,     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,\n+  \/* 11D10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11D20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11D30 *\/     B,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,    WJ,    WJ,    WJ,  VAbv,    WJ,  VAbv,  VAbv,    WJ,  VAbv,\n+  \/* 11D40 *\/ VMAbv, VMAbv, CMBlw,  VAbv,  VBlw,    IS,     R,  MBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 11D50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Gunjala Gondi *\/\n+\n+  \/* 11D60 *\/     B,     B,     B,     B,     B,     B,    WJ,     B,     B,    WJ,     B,     B,     B,     B,     B,     B,\n+  \/* 11D70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11D80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VPst,  VPst,  VPst,    WJ,\n+  \/* 11D90 *\/  VAbv,  VAbv,    WJ,  VPst,  VPst, VMAbv, VMPst,    IS,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 11DA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x11ee0u 6952\n+\n+\n+  \/* Makasar *\/\n+\n+  \/* 11EE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11EF0 *\/     B,     B,    GB,  VAbv,  VBlw,  VPre,  VPst,     O,\n+\n+#define use_offset_0x13000u 6976\n+\n+\n+  \/* Egyptian Hieroglyphs *\/\n+\n+  \/* 13000 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13030 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13040 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13050 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13060 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13070 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13080 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 130A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 130B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 130C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 130D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 130E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 130F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13100 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13110 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13120 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13130 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13140 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13150 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13160 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13170 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13180 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13190 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 131A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 131B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 131C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 131D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 131E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 131F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13200 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13210 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13220 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13230 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13240 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13250 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13260 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13270 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13280 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13290 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 132A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 132B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 132C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 132D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 132E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 132F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13300 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13310 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13320 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13330 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13340 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13350 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13360 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13370 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13380 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13390 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 133A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 133B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 133C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 133D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 133E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 133F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13400 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13410 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 13420 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,\n+\n+  \/* Egyptian Hieroglyph Format Controls *\/\n+\n+  \/* 13430 *\/     H,     H,     H,     H,     H,     H,     H,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x16ac0u 8064\n+\n+\n+  \/* Tangsa *\/\n+\n+  \/* 16AC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 16AD0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 16AE0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    WJ,    WJ,\n+  \/* 16AF0 *\/     O,     O,     O,     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Pahawh Hmong *\/\n+\n+  \/* 16B00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 16B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 16B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 16B30 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     O,\n+\n+#define use_offset_0x16f00u 8184\n+\n+\n+  \/* Miao *\/\n+\n+  \/* 16F00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 16F10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 16F20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 16F30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 16F40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ, CMBlw,\n+  \/* 16F50 *\/     O,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,\n+  \/* 16F60 *\/  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,\n+  \/* 16F70 *\/  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,\n+  \/* 16F80 *\/  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ, VMBlw,\n+  \/* 16F90 *\/ VMBlw, VMBlw, VMBlw,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x16fe0u 8336\n+\n+\n+  \/* Ideographic Symbols and Punctuation *\/\n+\n+  \/* 16FE0 *\/     O,     O,     O,     O,     B,    WJ,    WJ,    WJ,\n+\n+#define use_offset_0x18b00u 8344\n+\n+\n+  \/* Khitan Small Script *\/\n+\n+  \/* 18B00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18B30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18B40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18B50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18B60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18B70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18B80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18B90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18BA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18BC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18BD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18BE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18BF0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18C90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18CA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18CB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18CC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 18CD0 *\/     B,     B,     B,     B,     B,     B,    WJ,    WJ,\n+\n+#define use_offset_0x1bc00u 8816\n+\n+\n+  \/* Duployan *\/\n+\n+  \/* 1BC00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BC10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BC20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BC30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BC40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BC50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BC60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 1BC70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n+  \/* 1BC80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* 1BC90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,     O, CMBlw, CMBlw,     O,\n+\n+#define use_offset_0x1d170u 8976\n+\n+\n+  \/* Musical Symbols *\/\n+\n+  \/* 1D170 *\/     O,     O,     O,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x1e100u 8992\n+\n+\n+  \/* Nyiakeng Puachue Hmong *\/\n+\n+  \/* 1E100 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1E110 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1E120 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,\n+  \/* 1E130 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,\n+  \/* 1E140 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,     B,     B,\n+\n+#define use_offset_0x1e290u 9072\n+\n+\n+  \/* Toto *\/\n+\n+  \/* 1E290 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1E2A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,    WJ,\n+  \/* 1E2B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Wancho *\/\n+\n+  \/* 1E2C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1E2D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1E2E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMAbv, VMAbv, VMAbv,\n+  \/* 1E2F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,    WJ,     O,\n+\n+#define use_offset_0x1e900u 9184\n+\n+\n+  \/* Adlam *\/\n+\n+  \/* 1E900 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1E910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1E920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1E930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1E940 *\/     B,     B,     B,     B, CMAbv, CMAbv, CMAbv, CMAbv, CMAbv, CMAbv, CMAbv,     B,    WJ,    WJ,    WJ,    WJ,\n+  \/* 1E950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,    WJ,    WJ,    WJ,    WJ,     O,     O,\n+\n+#define use_offset_0xe0000u 9280\n+\n+\n+  \/* Tags *\/\n+\n+  \/* E0000 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0010 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0020 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0030 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0040 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0050 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0060 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0070 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* No_Block *\/\n+\n+  \/* E0080 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0090 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E00A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E00B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E00C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E00D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E00E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E00F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+  \/* Variation Selectors Supplement *\/\n+\n+  \/* E0100 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E0110 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E0120 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E0130 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E0140 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E0150 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E0160 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E0170 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E0180 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E0190 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E01A0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E01B0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E01C0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E01D0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+  \/* E01E0 *\/   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,   CGJ,\n+\n+  \/* No_Block *\/\n+\n+  \/* E01F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0200 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0210 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0220 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0230 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0240 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0250 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0260 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0270 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0280 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0290 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E02A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E02B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E02C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E02D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E02E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E02F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0300 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0310 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0320 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0330 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0340 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0350 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0360 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0370 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0380 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0390 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E03A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E03B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E03C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E03D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E03E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E03F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0400 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0410 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0420 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0430 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0440 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0450 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0460 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0470 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0480 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0490 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E04A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E04B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E04C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E04D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E04E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E04F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0500 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0510 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0520 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0530 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0540 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0550 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0560 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0570 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0580 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0590 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E05A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E05B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E05C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E05D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E05E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E05F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0600 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0610 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0620 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0630 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0640 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0650 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0660 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0670 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0680 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0690 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E06A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E06B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E06C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E06D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E06E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E06F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0700 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0710 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0720 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0730 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0740 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0750 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0760 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0770 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0780 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0790 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E07A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E07B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E07C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E07D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E07E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E07F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0800 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0810 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0820 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0830 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0840 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0850 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0860 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0870 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0880 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0890 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E08A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E08B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E08C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E08D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E08E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E08F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0900 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0910 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0920 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0930 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0940 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0950 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0960 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0970 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0980 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0990 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E09A0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E09B0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E09C0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E09D0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E09E0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E09F0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0A90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0AA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0AB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0AC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0AD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0AE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0AF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0B90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0BA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0BB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0BC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0BD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0BE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0BF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0C90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0CA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0CB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0CC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0CD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0CE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0CF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0D90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0DA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0DB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0DC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0DD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0DE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0DF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0E90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0EA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0EB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0EC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0ED0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0EE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0EF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F00 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F10 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F20 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F30 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F40 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F50 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F60 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F70 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F80 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0F90 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0FA0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0FB0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0FC0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0FD0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0FE0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+  \/* E0FF0 *\/    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,    WJ,\n+\n+}; \/* Table items: 13376; occupancy: 84% *\/\n+\n+static inline uint8_t\n+hb_use_get_category (hb_glyph_info_t info)\n+{\n+  hb_codepoint_t u = info.codepoint;\n+  switch (u >> 12)\n+  {\n+    case 0x0u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0028u, 0x003Fu)) return use_table[u - 0x0028u + use_offset_0x0028u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x00A0u, 0x00D7u)) return use_table[u - 0x00A0u + use_offset_0x00a0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0348u, 0x034Fu)) return use_table[u - 0x0348u + use_offset_0x0348u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0640u, 0x0647u)) return use_table[u - 0x0640u + use_offset_0x0640u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x07C8u, 0x07FFu)) return use_table[u - 0x07C8u + use_offset_0x07c8u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0840u, 0x085Fu)) return use_table[u - 0x0840u + use_offset_0x0840u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0900u, 0x0DF7u)) return use_table[u - 0x0900u + use_offset_0x0900u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0F00u, 0x0FC7u)) return use_table[u - 0x0F00u + use_offset_0x0f00u];\n+      break;\n+\n+    case 0x1u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1000u, 0x109Fu)) return use_table[u - 0x1000u + use_offset_0x1000u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1700u, 0x18AFu)) return use_table[u - 0x1700u + use_offset_0x1700u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1900u, 0x1A9Fu)) return use_table[u - 0x1900u + use_offset_0x1900u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1B00u, 0x1C4Fu)) return use_table[u - 0x1B00u + use_offset_0x1b00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1CD0u, 0x1CFFu)) return use_table[u - 0x1CD0u + use_offset_0x1cd0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1DF8u, 0x1DFFu)) return use_table[u - 0x1DF8u + use_offset_0x1df8u];\n+      break;\n+\n+    case 0x2u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x2008u, 0x2087u)) return use_table[u - 0x2008u + use_offset_0x2008u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x20F0u, 0x20F7u)) return use_table[u - 0x20F0u + use_offset_0x20f0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x25C8u, 0x25CFu)) return use_table[u - 0x25C8u + use_offset_0x25c8u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x2D30u, 0x2D7Fu)) return use_table[u - 0x2D30u + use_offset_0x2d30u];\n+      break;\n+\n+    case 0xAu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xA800u, 0xAAF7u)) return use_table[u - 0xA800u + use_offset_0xa800u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0xABC0u, 0xABFFu)) return use_table[u - 0xABC0u + use_offset_0xabc0u];\n+      break;\n+\n+    case 0xFu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xFE00u, 0xFE0Fu)) return use_table[u - 0xFE00u + use_offset_0xfe00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0xFEF8u, 0xFEFFu)) return use_table[u - 0xFEF8u + use_offset_0xfef8u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0xFFF0u, 0xFFFFu)) return use_table[u - 0xFFF0u + use_offset_0xfff0u];\n+      break;\n+\n+    case 0x10u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xFFF0u, 0xFFFFu)) return use_table[u - 0xFFF0u + use_offset_0xfff0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10570u, 0x105BFu)) return use_table[u - 0x10570u + use_offset_0x10570u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10A00u, 0x10A4Fu)) return use_table[u - 0x10A00u + use_offset_0x10a00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10AC0u, 0x10AEFu)) return use_table[u - 0x10AC0u + use_offset_0x10ac0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10B80u, 0x10BAFu)) return use_table[u - 0x10B80u + use_offset_0x10b80u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10D00u, 0x10D3Fu)) return use_table[u - 0x10D00u + use_offset_0x10d00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10E80u, 0x10EB7u)) return use_table[u - 0x10E80u + use_offset_0x10e80u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10F30u, 0x110C7u)) return use_table[u - 0x10F30u + use_offset_0x10f30u];\n+      break;\n+\n+    case 0x11u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10F30u, 0x110C7u)) return use_table[u - 0x10F30u + use_offset_0x10f30u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11100u, 0x1123Fu)) return use_table[u - 0x11100u + use_offset_0x11100u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11280u, 0x11377u)) return use_table[u - 0x11280u + use_offset_0x11280u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11400u, 0x114DFu)) return use_table[u - 0x11400u + use_offset_0x11400u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11580u, 0x11747u)) return use_table[u - 0x11580u + use_offset_0x11580u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11800u, 0x1183Fu)) return use_table[u - 0x11800u + use_offset_0x11800u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11900u, 0x1195Fu)) return use_table[u - 0x11900u + use_offset_0x11900u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x119A0u, 0x11A9Fu)) return use_table[u - 0x119A0u + use_offset_0x119a0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11C00u, 0x11CB7u)) return use_table[u - 0x11C00u + use_offset_0x11c00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11D00u, 0x11DAFu)) return use_table[u - 0x11D00u + use_offset_0x11d00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11EE0u, 0x11EF7u)) return use_table[u - 0x11EE0u + use_offset_0x11ee0u];\n+      break;\n+\n+    case 0x13u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x13000u, 0x1343Fu)) return use_table[u - 0x13000u + use_offset_0x13000u];\n+      break;\n+\n+    case 0x16u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x16AC0u, 0x16B37u)) return use_table[u - 0x16AC0u + use_offset_0x16ac0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x16F00u, 0x16F97u)) return use_table[u - 0x16F00u + use_offset_0x16f00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x16FE0u, 0x16FE7u)) return use_table[u - 0x16FE0u + use_offset_0x16fe0u];\n+      break;\n+\n+    case 0x18u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x18B00u, 0x18CD7u)) return use_table[u - 0x18B00u + use_offset_0x18b00u];\n+      break;\n+\n+    case 0x1Bu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1BC00u, 0x1BC9Fu)) return use_table[u - 0x1BC00u + use_offset_0x1bc00u];\n+      break;\n+\n+    case 0x1Du:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1D170u, 0x1D17Fu)) return use_table[u - 0x1D170u + use_offset_0x1d170u];\n+      break;\n+\n+    case 0x1Eu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1E100u, 0x1E14Fu)) return use_table[u - 0x1E100u + use_offset_0x1e100u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1E290u, 0x1E2FFu)) return use_table[u - 0x1E290u + use_offset_0x1e290u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1E900u, 0x1E95Fu)) return use_table[u - 0x1E900u + use_offset_0x1e900u];\n+      break;\n+\n+    case 0xE0u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xE0000u, 0xE0FFFu)) return use_table[u - 0xE0000u + use_offset_0xe0000u];\n+      break;\n+\n+    case 0xE1u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xE0000u, 0xE0FFFu)) return use_table[u - 0xE0000u + use_offset_0xe0000u];\n+      break;\n+\n+    default:\n+      break;\n+  }\n+  if (_hb_glyph_info_get_general_category (&info) == HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED)\n+    return WJ;\n+  return O;\n+}\n+\n+#undef B\n+#undef CGJ\n+#undef CS\n+#undef G\n+#undef GB\n+#undef H\n+#undef HN\n+#undef HVM\n+#undef IS\n+#undef J\n+#undef N\n+#undef O\n+#undef R\n+#undef SB\n+#undef SE\n+#undef SUB\n+#undef Sk\n+#undef WJ\n+#undef ZWNJ\n+#undef CMAbv\n+#undef CMBlw\n+#undef FAbv\n+#undef FBlw\n+#undef FPst\n+#undef FMAbv\n+#undef FMBlw\n+#undef FMPst\n+#undef MAbv\n+#undef MBlw\n+#undef MPst\n+#undef MPre\n+#undef SMAbv\n+#undef SMBlw\n+#undef VAbv\n+#undef VBlw\n+#undef VPst\n+#undef VPre\n+#undef VMAbv\n+#undef VMBlw\n+#undef VMPst\n+#undef VMPre\n+\n+\n+#endif \/* HB_OT_SHAPER_USE_TABLE_HH *\/\n+\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-use-table.hh","additions":1572,"deletions":0,"binary":false,"changes":1572,"status":"added"},{"patch":"@@ -33,5 +33,5 @@\n-#include \"hb-ot-shape-complex-use-machine.hh\"\n-#include \"hb-ot-shape-complex-use-table.hh\"\n-#include \"hb-ot-shape-complex-arabic.hh\"\n-#include \"hb-ot-shape-complex-arabic-joining-list.hh\"\n-#include \"hb-ot-shape-complex-vowel-constraints.hh\"\n+#include \"hb-ot-shaper-use-machine.hh\"\n+#include \"hb-ot-shaper-use-table.hh\"\n+#include \"hb-ot-shaper-arabic.hh\"\n+#include \"hb-ot-shaper-arabic-joining-list.hh\"\n+#include \"hb-ot-shaper-vowel-constraints.hh\"\n@@ -50,1 +50,2 @@\n-   * These features are applied all at once, before reordering.\n+   * These features are applied all at once, before reordering, constrained\n+   * to the syllable.\n@@ -117,4 +118,4 @@\n-  map->enable_feature (HB_TAG('l','o','c','l'));\n-  map->enable_feature (HB_TAG('c','c','m','p'));\n-  map->enable_feature (HB_TAG('n','u','k','t'));\n-  map->enable_feature (HB_TAG('a','k','h','n'), F_MANUAL_ZWJ);\n+  map->enable_feature (HB_TAG('l','o','c','l'), F_PER_SYLLABLE);\n+  map->enable_feature (HB_TAG('c','c','m','p'), F_PER_SYLLABLE);\n+  map->enable_feature (HB_TAG('n','u','k','t'), F_PER_SYLLABLE);\n+  map->enable_feature (HB_TAG('a','k','h','n'), F_MANUAL_ZWJ | F_PER_SYLLABLE);\n@@ -124,1 +125,1 @@\n-  map->add_feature (HB_TAG('r','p','h','f'), F_MANUAL_ZWJ);\n+  map->add_feature (HB_TAG('r','p','h','f'), F_MANUAL_ZWJ | F_PER_SYLLABLE);\n@@ -127,1 +128,1 @@\n-  map->enable_feature (HB_TAG('p','r','e','f'), F_MANUAL_ZWJ);\n+  map->enable_feature (HB_TAG('p','r','e','f'), F_MANUAL_ZWJ | F_PER_SYLLABLE);\n@@ -132,1 +133,1 @@\n-    map->enable_feature (use_basic_features[i], F_MANUAL_ZWJ);\n+    map->enable_feature (use_basic_features[i], F_MANUAL_ZWJ | F_PER_SYLLABLE);\n@@ -135,1 +136,1 @@\n-  map->add_gsub_pause (_hb_clear_syllables);\n+  map->add_gsub_pause (hb_syllabic_clear_var); \/\/ Don't need syllables anymore, use stop to free buffer var\n@@ -157,1 +158,1 @@\n-  use_shape_plan_t *use_plan = (use_shape_plan_t *) calloc (1, sizeof (use_shape_plan_t));\n+  use_shape_plan_t *use_plan = (use_shape_plan_t *) hb_calloc (1, sizeof (use_shape_plan_t));\n@@ -168,1 +169,1 @@\n-      free (use_plan);\n+      hb_free (use_plan);\n@@ -184,1 +185,1 @@\n-  free (data);\n+  hb_free (data);\n@@ -208,1 +209,1 @@\n-    info[i].use_category() = hb_use_get_category (info[i].codepoint);\n+    info[i].use_category() = hb_use_get_category (info[i]);\n@@ -259,2 +260,0 @@\n-      case use_independent_cluster:\n-      case use_symbol_cluster:\n@@ -272,0 +271,1 @@\n+      case use_symbol_cluster:\n@@ -301,0 +301,1 @@\n+  HB_BUFFER_ALLOCATE_VAR (buffer, syllable);\n@@ -353,1 +354,1 @@\n-  return (info.use_category() == USE(H) || info.use_category() == USE(HVM)) &&\n+  return (info.use_category() == USE(H) || info.use_category() == USE(HVM) || info.use_category() == USE(IS)) &&\n@@ -366,0 +367,1 @@\n+                   FLAG (use_symbol_cluster) |\n@@ -483,1 +485,1 @@\n-const hb_ot_complex_shaper_t _hb_ot_complex_shaper_use =\n+const hb_ot_shaper_t _hb_ot_shaper_use =\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-use.cc","additions":24,"deletions":22,"binary":false,"changes":46,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-use.cc","status":"renamed"},{"patch":"@@ -13,2 +13,2 @@\n- * # Scripts-13.0.0.txt\n- * # Date: 2020-01-22, 00:07:43 GMT\n+ * # Scripts-14.0.0.txt\n+ * # Date: 2021-07-10, 00:35:31 GMT\n@@ -21,1 +21,1 @@\n-#include \"hb-ot-shape-complex-vowel-constraints.hh\"\n+#include \"hb-ot-shaper-vowel-constraints.hh\"\n@@ -42,1 +42,1 @@\n-#ifdef HB_NO_OT_SHAPE_COMPLEX_VOWEL_CONSTRAINTS\n+#ifdef HB_NO_OT_SHAPER_VOWEL_CONSTRAINTS\n@@ -438,1 +438,1 @@\n-  buffer->swap_buffers ();\n+  buffer->sync ();\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-vowel-constraints.cc","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-vowel-constraints.cc","status":"renamed"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright  2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_VOWEL_CONSTRAINTS_HH\n+#define HB_OT_SHAPER_VOWEL_CONSTRAINTS_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shaper.hh\"\n+\n+HB_INTERNAL void\n+_hb_preprocess_text_vowel_constraints (const hb_ot_shape_plan_t *plan,\n+                                       hb_buffer_t              *buffer,\n+                                       hb_font_t                *font);\n+\n+#endif \/* HB_OT_SHAPER_VOWEL_CONSTRAINTS_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-vowel-constraints.hh","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,397 @@\n+\/*\n+ * Copyright  2010,2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPER_HH\n+#define HB_OT_SHAPER_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-layout.hh\"\n+#include \"hb-ot-shape.hh\"\n+#include \"hb-ot-shape-normalize.hh\"\n+\n+\n+\/* buffer var allocations, used by all OT shapers *\/\n+#define ot_shaper_var_u8_category()     var2.u8[2]\n+#define ot_shaper_var_u8_auxiliary()    var2.u8[3]\n+\n+\n+#define HB_OT_SHAPE_MAX_COMBINING_MARKS 32\n+\n+enum hb_ot_shape_zero_width_marks_type_t {\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE\n+};\n+\n+\n+\/* Master OT shaper list *\/\n+#define HB_OT_SHAPERS_IMPLEMENT_SHAPERS \\\n+  HB_OT_SHAPER_IMPLEMENT (arabic) \\\n+  HB_OT_SHAPER_IMPLEMENT (default) \\\n+  HB_OT_SHAPER_IMPLEMENT (dumber) \\\n+  HB_OT_SHAPER_IMPLEMENT (hangul) \\\n+  HB_OT_SHAPER_IMPLEMENT (hebrew) \\\n+  HB_OT_SHAPER_IMPLEMENT (indic) \\\n+  HB_OT_SHAPER_IMPLEMENT (khmer) \\\n+  HB_OT_SHAPER_IMPLEMENT (myanmar) \\\n+  HB_OT_SHAPER_IMPLEMENT (myanmar_zawgyi) \\\n+  HB_OT_SHAPER_IMPLEMENT (thai) \\\n+  HB_OT_SHAPER_IMPLEMENT (use) \\\n+  \/* ^--- Add new shapers here; keep sorted. *\/\n+\n+\n+struct hb_ot_shaper_t\n+{\n+  \/* collect_features()\n+   * Called during shape_plan().\n+   * Shapers should use plan->map to add their features and callbacks.\n+   * May be NULL.\n+   *\/\n+  void (*collect_features) (hb_ot_shape_planner_t *plan);\n+\n+  \/* override_features()\n+   * Called during shape_plan().\n+   * Shapers should use plan->map to override features and add callbacks after\n+   * common features are added.\n+   * May be NULL.\n+   *\/\n+  void (*override_features) (hb_ot_shape_planner_t *plan);\n+\n+\n+  \/* data_create()\n+   * Called at the end of shape_plan().\n+   * Whatever shapers return will be accessible through plan->data later.\n+   * If nullptr is returned, means a plan failure.\n+   *\/\n+  void *(*data_create) (const hb_ot_shape_plan_t *plan);\n+\n+  \/* data_destroy()\n+   * Called when the shape_plan is being destroyed.\n+   * plan->data is passed here for destruction.\n+   * If nullptr is returned, means a plan failure.\n+   * May be NULL.\n+   *\/\n+  void (*data_destroy) (void *data);\n+\n+\n+  \/* preprocess_text()\n+   * Called during shape().\n+   * Shapers can use to modify text before shaping starts.\n+   * May be NULL.\n+   *\/\n+  void (*preprocess_text) (const hb_ot_shape_plan_t *plan,\n+                           hb_buffer_t              *buffer,\n+                           hb_font_t                *font);\n+\n+  \/* postprocess_glyphs()\n+   * Called during shape().\n+   * Shapers can use to modify glyphs after shaping ends.\n+   * May be NULL.\n+   *\/\n+  void (*postprocess_glyphs) (const hb_ot_shape_plan_t *plan,\n+                              hb_buffer_t              *buffer,\n+                              hb_font_t                *font);\n+\n+\n+  hb_ot_shape_normalization_mode_t normalization_preference;\n+\n+  \/* decompose()\n+   * Called during shape()'s normalization.\n+   * May be NULL.\n+   *\/\n+  bool (*decompose) (const hb_ot_shape_normalize_context_t *c,\n+                     hb_codepoint_t  ab,\n+                     hb_codepoint_t *a,\n+                     hb_codepoint_t *b);\n+\n+  \/* compose()\n+   * Called during shape()'s normalization.\n+   * May be NULL.\n+   *\/\n+  bool (*compose) (const hb_ot_shape_normalize_context_t *c,\n+                   hb_codepoint_t  a,\n+                   hb_codepoint_t  b,\n+                   hb_codepoint_t *ab);\n+\n+  \/* setup_masks()\n+   * Called during shape().\n+   * Shapers should use map to get feature masks and set on buffer.\n+   * Shapers may NOT modify characters.\n+   * May be NULL.\n+   *\/\n+  void (*setup_masks) (const hb_ot_shape_plan_t *plan,\n+                       hb_buffer_t              *buffer,\n+                       hb_font_t                *font);\n+\n+  \/* gpos_tag()\n+   * If not HB_TAG_NONE, then must match found GPOS script tag for\n+   * GPOS to be applied.  Otherwise, fallback positioning will be used.\n+   *\/\n+  hb_tag_t gpos_tag;\n+\n+  \/* reorder_marks()\n+   * Called during shape().\n+   * Shapers can use to modify ordering of combining marks.\n+   * May be NULL.\n+   *\/\n+  void (*reorder_marks) (const hb_ot_shape_plan_t *plan,\n+                         hb_buffer_t              *buffer,\n+                         unsigned int              start,\n+                         unsigned int              end);\n+\n+  hb_ot_shape_zero_width_marks_type_t zero_width_marks;\n+\n+  bool fallback_position;\n+};\n+\n+#define HB_OT_SHAPER_IMPLEMENT(name) extern HB_INTERNAL const hb_ot_shaper_t _hb_ot_shaper_##name;\n+HB_OT_SHAPERS_IMPLEMENT_SHAPERS\n+#undef HB_OT_SHAPER_IMPLEMENT\n+\n+\n+static inline const hb_ot_shaper_t *\n+hb_ot_shaper_categorize (const hb_ot_shape_planner_t *planner)\n+{\n+  switch ((hb_tag_t) planner->props.script)\n+  {\n+    default:\n+      return &_hb_ot_shaper_default;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_ARABIC:\n+\n+    \/* Unicode-3.0 additions *\/\n+    case HB_SCRIPT_SYRIAC:\n+\n+      \/* For Arabic script, use the Arabic shaper even if no OT script tag was found.\n+       * This is because we do fallback shaping for Arabic script (and not others).\n+       * But note that Arabic shaping is applicable only to horizontal layout; for\n+       * vertical text, just use the generic shaper instead. *\/\n+      if ((planner->map.chosen_script[0] != HB_OT_TAG_DEFAULT_SCRIPT ||\n+           planner->props.script == HB_SCRIPT_ARABIC) &&\n+          HB_DIRECTION_IS_HORIZONTAL(planner->props.direction))\n+        return &_hb_ot_shaper_arabic;\n+      else\n+        return &_hb_ot_shaper_default;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_THAI:\n+    case HB_SCRIPT_LAO:\n+\n+      return &_hb_ot_shaper_thai;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_HANGUL:\n+\n+      return &_hb_ot_shaper_hangul;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_HEBREW:\n+\n+      return &_hb_ot_shaper_hebrew;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_BENGALI:\n+    case HB_SCRIPT_DEVANAGARI:\n+    case HB_SCRIPT_GUJARATI:\n+    case HB_SCRIPT_GURMUKHI:\n+    case HB_SCRIPT_KANNADA:\n+    case HB_SCRIPT_MALAYALAM:\n+    case HB_SCRIPT_ORIYA:\n+    case HB_SCRIPT_TAMIL:\n+    case HB_SCRIPT_TELUGU:\n+\n+      \/* If the designer designed the font for the 'DFLT' script,\n+       * (or we ended up arbitrarily pick 'latn'), use the default shaper.\n+       * Otherwise, use the specific shaper.\n+       *\n+       * If it's indy3 tag, send to USE. *\/\n+      if (planner->map.chosen_script[0] == HB_TAG ('D','F','L','T') ||\n+          planner->map.chosen_script[0] == HB_TAG ('l','a','t','n'))\n+        return &_hb_ot_shaper_default;\n+      else if ((planner->map.chosen_script[0] & 0x000000FF) == '3')\n+        return &_hb_ot_shaper_use;\n+      else\n+        return &_hb_ot_shaper_indic;\n+\n+    case HB_SCRIPT_KHMER:\n+        return &_hb_ot_shaper_khmer;\n+\n+    case HB_SCRIPT_MYANMAR:\n+      \/* If the designer designed the font for the 'DFLT' script,\n+       * (or we ended up arbitrarily pick 'latn'), use the default shaper.\n+       * Otherwise, use the specific shaper.\n+       *\n+       * If designer designed for 'mymr' tag, also send to default\n+       * shaper.  That's tag used from before Myanmar shaping spec\n+       * was developed.  The shaping spec uses 'mym2' tag. *\/\n+      if (planner->map.chosen_script[0] == HB_TAG ('D','F','L','T') ||\n+          planner->map.chosen_script[0] == HB_TAG ('l','a','t','n') ||\n+          planner->map.chosen_script[0] == HB_TAG ('m','y','m','r'))\n+        return &_hb_ot_shaper_default;\n+      else\n+        return &_hb_ot_shaper_myanmar;\n+\n+\n+#define HB_SCRIPT_MYANMAR_ZAWGYI        ((hb_script_t) HB_TAG ('Q','a','a','g'))\n+    case HB_SCRIPT_MYANMAR_ZAWGYI:\n+    \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1162 *\/\n+\n+      return &_hb_ot_shaper_myanmar_zawgyi;\n+\n+\n+    \/* Unicode-2.0 additions *\/\n+    case HB_SCRIPT_TIBETAN:\n+\n+    \/* Unicode-3.0 additions *\/\n+    case HB_SCRIPT_MONGOLIAN:\n+    case HB_SCRIPT_SINHALA:\n+\n+    \/* Unicode-3.2 additions *\/\n+    case HB_SCRIPT_BUHID:\n+    case HB_SCRIPT_HANUNOO:\n+    case HB_SCRIPT_TAGALOG:\n+    case HB_SCRIPT_TAGBANWA:\n+\n+    \/* Unicode-4.0 additions *\/\n+    case HB_SCRIPT_LIMBU:\n+    case HB_SCRIPT_TAI_LE:\n+\n+    \/* Unicode-4.1 additions *\/\n+    case HB_SCRIPT_BUGINESE:\n+    case HB_SCRIPT_KHAROSHTHI:\n+    case HB_SCRIPT_SYLOTI_NAGRI:\n+    case HB_SCRIPT_TIFINAGH:\n+\n+    \/* Unicode-5.0 additions *\/\n+    case HB_SCRIPT_BALINESE:\n+    case HB_SCRIPT_NKO:\n+    case HB_SCRIPT_PHAGS_PA:\n+\n+    \/* Unicode-5.1 additions *\/\n+    case HB_SCRIPT_CHAM:\n+    case HB_SCRIPT_KAYAH_LI:\n+    case HB_SCRIPT_LEPCHA:\n+    case HB_SCRIPT_REJANG:\n+    case HB_SCRIPT_SAURASHTRA:\n+    case HB_SCRIPT_SUNDANESE:\n+\n+    \/* Unicode-5.2 additions *\/\n+    case HB_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n+    case HB_SCRIPT_JAVANESE:\n+    case HB_SCRIPT_KAITHI:\n+    case HB_SCRIPT_MEETEI_MAYEK:\n+    case HB_SCRIPT_TAI_THAM:\n+    case HB_SCRIPT_TAI_VIET:\n+\n+    \/* Unicode-6.0 additions *\/\n+    case HB_SCRIPT_BATAK:\n+    case HB_SCRIPT_BRAHMI:\n+    case HB_SCRIPT_MANDAIC:\n+\n+    \/* Unicode-6.1 additions *\/\n+    case HB_SCRIPT_CHAKMA:\n+    case HB_SCRIPT_MIAO:\n+    case HB_SCRIPT_SHARADA:\n+    case HB_SCRIPT_TAKRI:\n+\n+    \/* Unicode-7.0 additions *\/\n+    case HB_SCRIPT_DUPLOYAN:\n+    case HB_SCRIPT_GRANTHA:\n+    case HB_SCRIPT_KHOJKI:\n+    case HB_SCRIPT_KHUDAWADI:\n+    case HB_SCRIPT_MAHAJANI:\n+    case HB_SCRIPT_MANICHAEAN:\n+    case HB_SCRIPT_MODI:\n+    case HB_SCRIPT_PAHAWH_HMONG:\n+    case HB_SCRIPT_PSALTER_PAHLAVI:\n+    case HB_SCRIPT_SIDDHAM:\n+    case HB_SCRIPT_TIRHUTA:\n+\n+    \/* Unicode-8.0 additions *\/\n+    case HB_SCRIPT_AHOM:\n+    case HB_SCRIPT_MULTANI:\n+\n+    \/* Unicode-9.0 additions *\/\n+    case HB_SCRIPT_ADLAM:\n+    case HB_SCRIPT_BHAIKSUKI:\n+    case HB_SCRIPT_MARCHEN:\n+    case HB_SCRIPT_NEWA:\n+\n+    \/* Unicode-10.0 additions *\/\n+    case HB_SCRIPT_MASARAM_GONDI:\n+    case HB_SCRIPT_SOYOMBO:\n+    case HB_SCRIPT_ZANABAZAR_SQUARE:\n+\n+    \/* Unicode-11.0 additions *\/\n+    case HB_SCRIPT_DOGRA:\n+    case HB_SCRIPT_GUNJALA_GONDI:\n+    case HB_SCRIPT_HANIFI_ROHINGYA:\n+    case HB_SCRIPT_MAKASAR:\n+    case HB_SCRIPT_MEDEFAIDRIN:\n+    case HB_SCRIPT_OLD_SOGDIAN:\n+    case HB_SCRIPT_SOGDIAN:\n+\n+    \/* Unicode-12.0 additions *\/\n+    case HB_SCRIPT_ELYMAIC:\n+    case HB_SCRIPT_NANDINAGARI:\n+    case HB_SCRIPT_NYIAKENG_PUACHUE_HMONG:\n+    case HB_SCRIPT_WANCHO:\n+\n+    \/* Unicode-13.0 additions *\/\n+    case HB_SCRIPT_CHORASMIAN:\n+    case HB_SCRIPT_DIVES_AKURU:\n+    case HB_SCRIPT_KHITAN_SMALL_SCRIPT:\n+    case HB_SCRIPT_YEZIDI:\n+\n+    \/* Unicode-14.0 additions *\/\n+    case HB_SCRIPT_CYPRO_MINOAN:\n+    case HB_SCRIPT_OLD_UYGHUR:\n+    case HB_SCRIPT_TANGSA:\n+    case HB_SCRIPT_TOTO:\n+    case HB_SCRIPT_VITHKUQI:\n+\n+      \/* If the designer designed the font for the 'DFLT' script,\n+       * (or we ended up arbitrarily pick 'latn'), use the default shaper.\n+       * Otherwise, use the specific shaper.\n+       * Note that for some simple scripts, there may not be *any*\n+       * GSUB\/GPOS needed, so there may be no scripts found! *\/\n+      if (planner->map.chosen_script[0] == HB_TAG ('D','F','L','T') ||\n+          planner->map.chosen_script[0] == HB_TAG ('l','a','t','n'))\n+        return &_hb_ot_shaper_default;\n+      else\n+        return &_hb_ot_shaper_use;\n+  }\n+}\n+\n+\n+#endif \/* HB_OT_SHAPER_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper.hh","additions":397,"deletions":0,"binary":false,"changes":397,"status":"added"},{"patch":"@@ -300,1 +300,1 @@\n-    hb_array_t<const OffsetTo<AxisValue>> axis_values = get_axis_value_offsets ();\n+    hb_array_t<const Offset16To<AxisValue>> axis_values = get_axis_value_offsets ();\n@@ -362,1 +362,1 @@\n-  hb_array_t<const OffsetTo<AxisValue>> const get_axis_value_offsets () const\n+  hb_array_t<const Offset16To<AxisValue>> const get_axis_value_offsets () const\n@@ -376,1 +376,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<StatAxisRecord>>\n+  NNOffset32To<UnsizedArrayOf<StatAxisRecord>>\n@@ -384,1 +384,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<OffsetTo<AxisValue>>>\n+  NNOffset32To<UnsizedArrayOf<Offset16To<AxisValue>>>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-stat-table.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -9,2 +9,2 @@\n- * <meta name=\"updated_at\" content=\"2021-02-12 04:08 PM\" \/>\n- * File-Date: 2021-03-05\n+ * <meta name=\"updated_at\" content=\"2022-01-28 10:00 PM\" \/>\n+ * File-Date: 2022-03-02\n@@ -16,1571 +16,204 @@\n-static const LangTag ot_languages[] = {\n-  {\"aa\",        HB_TAG('A','F','R',' ')},       \/* Afar *\/\n-  {\"aae\",       HB_TAG('S','Q','I',' ')},       \/* Arbresh Albanian -> Albanian *\/\n-  {\"aao\",       HB_TAG('A','R','A',' ')},       \/* Algerian Saharan Arabic -> Arabic *\/\n-  {\"aat\",       HB_TAG('S','Q','I',' ')},       \/* Arvanitika Albanian -> Albanian *\/\n-  {\"ab\",        HB_TAG('A','B','K',' ')},       \/* Abkhazian *\/\n-  {\"aba\",       HB_TAG_NONE            },       \/* Ab != Abaza *\/\n-  {\"abh\",       HB_TAG('A','R','A',' ')},       \/* Tajiki Arabic -> Arabic *\/\n-  {\"abq\",       HB_TAG('A','B','A',' ')},       \/* Abaza *\/\n-  {\"abs\",       HB_TAG('C','P','P',' ')},       \/* Ambonese Malay -> Creoles *\/\n-  {\"abv\",       HB_TAG('A','R','A',' ')},       \/* Baharna Arabic -> Arabic *\/\n-  {\"acf\",       HB_TAG('F','A','N',' ')},       \/* Saint Lucian Creole French -> French Antillean *\/\n-  {\"acf\",       HB_TAG('C','P','P',' ')},       \/* Saint Lucian Creole French -> Creoles *\/\n-\/*{\"ach\",       HB_TAG('A','C','H',' ')},*\/     \/* Acoli -> Acholi *\/\n-  {\"acm\",       HB_TAG('A','R','A',' ')},       \/* Mesopotamian Arabic -> Arabic *\/\n-  {\"acq\",       HB_TAG('A','R','A',' ')},       \/* Ta'izzi-Adeni Arabic -> Arabic *\/\n-  {\"acr\",       HB_TAG('A','C','R',' ')},       \/* Achi *\/\n-  {\"acr\",       HB_TAG('M','Y','N',' ')},       \/* Achi -> Mayan *\/\n-  {\"acw\",       HB_TAG('A','R','A',' ')},       \/* Hijazi Arabic -> Arabic *\/\n-  {\"acx\",       HB_TAG('A','R','A',' ')},       \/* Omani Arabic -> Arabic *\/\n-  {\"acy\",       HB_TAG('A','R','A',' ')},       \/* Cypriot Arabic -> Arabic *\/\n-  {\"ada\",       HB_TAG('D','N','G',' ')},       \/* Adangme -> Dangme *\/\n-  {\"adf\",       HB_TAG('A','R','A',' ')},       \/* Dhofari Arabic -> Arabic *\/\n-  {\"adp\",       HB_TAG('D','Z','N',' ')},       \/* Adap (retired code) -> Dzongkha *\/\n-\/*{\"ady\",       HB_TAG('A','D','Y',' ')},*\/     \/* Adyghe *\/\n-  {\"aeb\",       HB_TAG('A','R','A',' ')},       \/* Tunisian Arabic -> Arabic *\/\n-  {\"aec\",       HB_TAG('A','R','A',' ')},       \/* Saidi Arabic -> Arabic *\/\n-  {\"af\",        HB_TAG('A','F','K',' ')},       \/* Afrikaans *\/\n-  {\"afb\",       HB_TAG('A','R','A',' ')},       \/* Gulf Arabic -> Arabic *\/\n-  {\"afk\",       HB_TAG_NONE            },       \/* Nanubae != Afrikaans *\/\n-  {\"afs\",       HB_TAG('C','P','P',' ')},       \/* Afro-Seminole Creole -> Creoles *\/\n-  {\"agu\",       HB_TAG('M','Y','N',' ')},       \/* Aguacateco -> Mayan *\/\n-  {\"agw\",       HB_TAG_NONE            },       \/* Kahua != Agaw *\/\n-  {\"ahg\",       HB_TAG('A','G','W',' ')},       \/* Qimant -> Agaw *\/\n-  {\"aht\",       HB_TAG('A','T','H',' ')},       \/* Ahtena -> Athapaskan *\/\n-  {\"aig\",       HB_TAG('C','P','P',' ')},       \/* Antigua and Barbuda Creole English -> Creoles *\/\n-  {\"aii\",       HB_TAG('S','W','A',' ')},       \/* Assyrian Neo-Aramaic -> Swadaya Aramaic *\/\n-  {\"aii\",       HB_TAG('S','Y','R',' ')},       \/* Assyrian Neo-Aramaic -> Syriac *\/\n-\/*{\"aio\",       HB_TAG('A','I','O',' ')},*\/     \/* Aiton *\/\n-  {\"aiw\",       HB_TAG('A','R','I',' ')},       \/* Aari *\/\n-  {\"ajp\",       HB_TAG('A','R','A',' ')},       \/* South Levantine Arabic -> Arabic *\/\n-  {\"ak\",        HB_TAG('A','K','A',' ')},       \/* Akan [macrolanguage] *\/\n-  {\"akb\",       HB_TAG('A','K','B',' ')},       \/* Batak Angkola *\/\n-  {\"akb\",       HB_TAG('B','T','K',' ')},       \/* Batak Angkola -> Batak *\/\n-  {\"aln\",       HB_TAG('S','Q','I',' ')},       \/* Gheg Albanian -> Albanian *\/\n-  {\"als\",       HB_TAG('S','Q','I',' ')},       \/* Tosk Albanian -> Albanian *\/\n-\/*{\"alt\",       HB_TAG('A','L','T',' ')},*\/     \/* Southern Altai -> Altai *\/\n-  {\"am\",        HB_TAG('A','M','H',' ')},       \/* Amharic *\/\n-  {\"amf\",       HB_TAG('H','B','N',' ')},       \/* Hamer-Banna -> Hammer-Banna *\/\n-  {\"amw\",       HB_TAG('S','Y','R',' ')},       \/* Western Neo-Aramaic -> Syriac *\/\n-  {\"an\",        HB_TAG('A','R','G',' ')},       \/* Aragonese *\/\n-\/*{\"ang\",       HB_TAG('A','N','G',' ')},*\/     \/* Old English (ca. 450-1100) -> Anglo-Saxon *\/\n-  {\"aoa\",       HB_TAG('C','P','P',' ')},       \/* Angolar -> Creoles *\/\n-  {\"apa\",       HB_TAG('A','T','H',' ')},       \/* Apache [family] -> Athapaskan *\/\n-  {\"apc\",       HB_TAG('A','R','A',' ')},       \/* North Levantine Arabic -> Arabic *\/\n-  {\"apd\",       HB_TAG('A','R','A',' ')},       \/* Sudanese Arabic -> Arabic *\/\n-  {\"apj\",       HB_TAG('A','T','H',' ')},       \/* Jicarilla Apache -> Athapaskan *\/\n-  {\"apk\",       HB_TAG('A','T','H',' ')},       \/* Kiowa Apache -> Athapaskan *\/\n-  {\"apl\",       HB_TAG('A','T','H',' ')},       \/* Lipan Apache -> Athapaskan *\/\n-  {\"apm\",       HB_TAG('A','T','H',' ')},       \/* Mescalero-Chiricahua Apache -> Athapaskan *\/\n-  {\"apw\",       HB_TAG('A','T','H',' ')},       \/* Western Apache -> Athapaskan *\/\n-  {\"ar\",        HB_TAG('A','R','A',' ')},       \/* Arabic [macrolanguage] *\/\n-  {\"arb\",       HB_TAG('A','R','A',' ')},       \/* Standard Arabic -> Arabic *\/\n-  {\"ari\",       HB_TAG_NONE            },       \/* Arikara != Aari *\/\n-  {\"ark\",       HB_TAG_NONE            },       \/* Arikap != Rakhine *\/\n-  {\"arn\",       HB_TAG('M','A','P',' ')},       \/* Mapudungun *\/\n-  {\"arq\",       HB_TAG('A','R','A',' ')},       \/* Algerian Arabic -> Arabic *\/\n-  {\"ars\",       HB_TAG('A','R','A',' ')},       \/* Najdi Arabic -> Arabic *\/\n-  {\"ary\",       HB_TAG('M','O','R',' ')},       \/* Moroccan Arabic -> Moroccan *\/\n-  {\"ary\",       HB_TAG('A','R','A',' ')},       \/* Moroccan Arabic -> Arabic *\/\n-  {\"arz\",       HB_TAG('A','R','A',' ')},       \/* Egyptian Arabic -> Arabic *\/\n-  {\"as\",        HB_TAG('A','S','M',' ')},       \/* Assamese *\/\n-\/*{\"ast\",       HB_TAG('A','S','T',' ')},*\/     \/* Asturian *\/\n-\/*{\"ath\",       HB_TAG('A','T','H',' ')},*\/     \/* Athapascan [family] -> Athapaskan *\/\n-  {\"atj\",       HB_TAG('R','C','R',' ')},       \/* Atikamekw -> R-Cree *\/\n-  {\"atv\",       HB_TAG('A','L','T',' ')},       \/* Northern Altai -> Altai *\/\n-  {\"auj\",       HB_TAG('B','B','R',' ')},       \/* Awjilah -> Berber *\/\n-  {\"auz\",       HB_TAG('A','R','A',' ')},       \/* Uzbeki Arabic -> Arabic *\/\n-  {\"av\",        HB_TAG('A','V','R',' ')},       \/* Avaric -> Avar *\/\n-  {\"avl\",       HB_TAG('A','R','A',' ')},       \/* Eastern Egyptian Bedawi Arabic -> Arabic *\/\n-\/*{\"awa\",       HB_TAG('A','W','A',' ')},*\/     \/* Awadhi *\/\n-  {\"ay\",        HB_TAG('A','Y','M',' ')},       \/* Aymara [macrolanguage] *\/\n-  {\"ayc\",       HB_TAG('A','Y','M',' ')},       \/* Southern Aymara -> Aymara *\/\n-  {\"ayh\",       HB_TAG('A','R','A',' ')},       \/* Hadrami Arabic -> Arabic *\/\n-  {\"ayl\",       HB_TAG('A','R','A',' ')},       \/* Libyan Arabic -> Arabic *\/\n-  {\"ayn\",       HB_TAG('A','R','A',' ')},       \/* Sanaani Arabic -> Arabic *\/\n-  {\"ayp\",       HB_TAG('A','R','A',' ')},       \/* North Mesopotamian Arabic -> Arabic *\/\n-  {\"ayr\",       HB_TAG('A','Y','M',' ')},       \/* Central Aymara -> Aymara *\/\n-  {\"az\",        HB_TAG('A','Z','E',' ')},       \/* Azerbaijani [macrolanguage] *\/\n-  {\"azb\",       HB_TAG('A','Z','B',' ')},       \/* South Azerbaijani -> Torki *\/\n-  {\"azb\",       HB_TAG('A','Z','E',' ')},       \/* South Azerbaijani -> Azerbaijani *\/\n-  {\"azd\",       HB_TAG('N','A','H',' ')},       \/* Eastern Durango Nahuatl -> Nahuatl *\/\n-  {\"azj\",       HB_TAG('A','Z','E',' ')},       \/* North Azerbaijani -> Azerbaijani *\/\n-  {\"azn\",       HB_TAG('N','A','H',' ')},       \/* Western Durango Nahuatl -> Nahuatl *\/\n-  {\"azz\",       HB_TAG('N','A','H',' ')},       \/* Highland Puebla Nahuatl -> Nahuatl *\/\n-  {\"ba\",        HB_TAG('B','S','H',' ')},       \/* Bashkir *\/\n-  {\"bad\",       HB_TAG('B','A','D','0')},       \/* Banda [family] *\/\n-  {\"bag\",       HB_TAG_NONE            },       \/* Tuki != Baghelkhandi *\/\n-  {\"bah\",       HB_TAG('C','P','P',' ')},       \/* Bahamas Creole English -> Creoles *\/\n-  {\"bai\",       HB_TAG('B','M','L',' ')},       \/* Bamileke [family] *\/\n-  {\"bal\",       HB_TAG('B','L','I',' ')},       \/* Baluchi [macrolanguage] *\/\n-\/*{\"ban\",       HB_TAG('B','A','N',' ')},*\/     \/* Balinese *\/\n-\/*{\"bar\",       HB_TAG('B','A','R',' ')},*\/     \/* Bavarian *\/\n-  {\"bau\",       HB_TAG_NONE            },       \/* Bada (Nigeria) != Baul *\/\n-  {\"bbc\",       HB_TAG('B','B','C',' ')},       \/* Batak Toba *\/\n-  {\"bbc\",       HB_TAG('B','T','K',' ')},       \/* Batak Toba -> Batak *\/\n-  {\"bbj\",       HB_TAG('B','M','L',' ')},       \/* Ghoml' -> Bamileke *\/\n-  {\"bbp\",       HB_TAG('B','A','D','0')},       \/* West Central Banda -> Banda *\/\n-  {\"bbr\",       HB_TAG_NONE            },       \/* Girawa != Berber *\/\n-  {\"bbz\",       HB_TAG('A','R','A',' ')},       \/* Babalia Creole Arabic (retired code) -> Arabic *\/\n-  {\"bcc\",       HB_TAG('B','L','I',' ')},       \/* Southern Balochi -> Baluchi *\/\n-  {\"bch\",       HB_TAG_NONE            },       \/* Bariai != Bench *\/\n-  {\"bci\",       HB_TAG('B','A','U',' ')},       \/* Baoul -> Baul *\/\n-  {\"bcl\",       HB_TAG('B','I','K',' ')},       \/* Central Bikol -> Bikol *\/\n-  {\"bcq\",       HB_TAG('B','C','H',' ')},       \/* Bench *\/\n-  {\"bcr\",       HB_TAG('A','T','H',' ')},       \/* Babine -> Athapaskan *\/\n-\/*{\"bdy\",       HB_TAG('B','D','Y',' ')},*\/     \/* Bandjalang *\/\n-  {\"be\",        HB_TAG('B','E','L',' ')},       \/* Belarusian -> Belarussian *\/\n-  {\"bea\",       HB_TAG('A','T','H',' ')},       \/* Beaver -> Athapaskan *\/\n-  {\"beb\",       HB_TAG('B','T','I',' ')},       \/* Bebele -> Beti *\/\n-\/*{\"bem\",       HB_TAG('B','E','M',' ')},*\/     \/* Bemba (Zambia) *\/\n-  {\"ber\",       HB_TAG('B','B','R',' ')},       \/* Berber [family] *\/\n-  {\"bew\",       HB_TAG('C','P','P',' ')},       \/* Betawi -> Creoles *\/\n-  {\"bfl\",       HB_TAG('B','A','D','0')},       \/* Banda-Ndl -> Banda *\/\n-  {\"bfq\",       HB_TAG('B','A','D',' ')},       \/* Badaga *\/\n-  {\"bft\",       HB_TAG('B','L','T',' ')},       \/* Balti *\/\n-  {\"bfu\",       HB_TAG('L','A','H',' ')},       \/* Gahri -> Lahuli *\/\n-  {\"bfy\",       HB_TAG('B','A','G',' ')},       \/* Bagheli -> Baghelkhandi *\/\n-  {\"bg\",        HB_TAG('B','G','R',' ')},       \/* Bulgarian *\/\n-\/*{\"bgc\",       HB_TAG('B','G','C',' ')},*\/     \/* Haryanvi *\/\n-  {\"bgn\",       HB_TAG('B','L','I',' ')},       \/* Western Balochi -> Baluchi *\/\n-  {\"bgp\",       HB_TAG('B','L','I',' ')},       \/* Eastern Balochi -> Baluchi *\/\n-  {\"bgq\",       HB_TAG('B','G','Q',' ')},       \/* Bagri *\/\n-  {\"bgq\",       HB_TAG('R','A','J',' ')},       \/* Bagri -> Rajasthani *\/\n-  {\"bgr\",       HB_TAG('Q','I','N',' ')},       \/* Bawm Chin -> Chin *\/\n-  {\"bhb\",       HB_TAG('B','H','I',' ')},       \/* Bhili *\/\n-\/*{\"bhi\",       HB_TAG('B','H','I',' ')},*\/     \/* Bhilali -> Bhili *\/\n-  {\"bhk\",       HB_TAG('B','I','K',' ')},       \/* Albay Bicolano (retired code) -> Bikol *\/\n-\/*{\"bho\",       HB_TAG('B','H','O',' ')},*\/     \/* Bhojpuri *\/\n-  {\"bhr\",       HB_TAG('M','L','G',' ')},       \/* Bara Malagasy -> Malagasy *\/\n-  {\"bi\",        HB_TAG('B','I','S',' ')},       \/* Bislama *\/\n-  {\"bi\",        HB_TAG('C','P','P',' ')},       \/* Bislama -> Creoles *\/\n-\/*{\"bik\",       HB_TAG('B','I','K',' ')},*\/     \/* Bikol [macrolanguage] *\/\n-  {\"bil\",       HB_TAG_NONE            },       \/* Bile != Bilen *\/\n-  {\"bin\",       HB_TAG('E','D','O',' ')},       \/* Edo *\/\n-  {\"biu\",       HB_TAG('Q','I','N',' ')},       \/* Biete -> Chin *\/\n-\/*{\"bjj\",       HB_TAG('B','J','J',' ')},*\/     \/* Kanauji *\/\n-  {\"bjn\",       HB_TAG('M','L','Y',' ')},       \/* Banjar -> Malay *\/\n-  {\"bjo\",       HB_TAG('B','A','D','0')},       \/* Mid-Southern Banda -> Banda *\/\n-  {\"bjq\",       HB_TAG('M','L','G',' ')},       \/* Southern Betsimisaraka Malagasy (retired code) -> Malagasy *\/\n-  {\"bjs\",       HB_TAG('C','P','P',' ')},       \/* Bajan -> Creoles *\/\n-  {\"bjt\",       HB_TAG('B','L','N',' ')},       \/* Balanta-Ganja -> Balante *\/\n-  {\"bkf\",       HB_TAG_NONE            },       \/* Beeke != Blackfoot *\/\n-  {\"bko\",       HB_TAG('B','M','L',' ')},       \/* Kwa' -> Bamileke *\/\n-  {\"bla\",       HB_TAG('B','K','F',' ')},       \/* Siksika -> Blackfoot *\/\n-  {\"ble\",       HB_TAG('B','L','N',' ')},       \/* Balanta-Kentohe -> Balante *\/\n-  {\"blg\",       HB_TAG('I','B','A',' ')},       \/* Balau (retired code) -> Iban *\/\n-  {\"bli\",       HB_TAG_NONE            },       \/* Bolia != Baluchi *\/\n-  {\"blk\",       HB_TAG('B','L','K',' ')},       \/* Pao Karen *\/\n-  {\"blk\",       HB_TAG('K','R','N',' ')},       \/* Pa'o Karen -> Karen *\/\n-  {\"bln\",       HB_TAG('B','I','K',' ')},       \/* Southern Catanduanes Bikol -> Bikol *\/\n-  {\"blt\",       HB_TAG_NONE            },       \/* Tai Dam != Balti *\/\n-  {\"bm\",        HB_TAG('B','M','B',' ')},       \/* Bambara (Bamanankan) *\/\n-  {\"bmb\",       HB_TAG_NONE            },       \/* Bembe != Bambara (Bamanankan) *\/\n-  {\"bml\",       HB_TAG_NONE            },       \/* Bomboli != Bamileke *\/\n-  {\"bmm\",       HB_TAG('M','L','G',' ')},       \/* Northern Betsimisaraka Malagasy -> Malagasy *\/\n-  {\"bn\",        HB_TAG('B','E','N',' ')},       \/* Bengali *\/\n-  {\"bo\",        HB_TAG('T','I','B',' ')},       \/* Tibetan *\/\n-  {\"bpd\",       HB_TAG('B','A','D','0')},       \/* Banda-Banda -> Banda *\/\n-  {\"bpl\",       HB_TAG('C','P','P',' ')},       \/* Broome Pearling Lugger Pidgin -> Creoles *\/\n-  {\"bpq\",       HB_TAG('C','P','P',' ')},       \/* Banda Malay -> Creoles *\/\n-\/*{\"bpy\",       HB_TAG('B','P','Y',' ')},*\/     \/* Bishnupriya -> Bishnupriya Manipuri *\/\n-  {\"bqi\",       HB_TAG('L','R','C',' ')},       \/* Bakhtiari -> Luri *\/\n-  {\"bqk\",       HB_TAG('B','A','D','0')},       \/* Banda-Mbrs -> Banda *\/\n-  {\"br\",        HB_TAG('B','R','E',' ')},       \/* Breton *\/\n-  {\"bra\",       HB_TAG('B','R','I',' ')},       \/* Braj -> Braj Bhasha *\/\n-  {\"brc\",       HB_TAG('C','P','P',' ')},       \/* Berbice Creole Dutch -> Creoles *\/\n-\/*{\"brh\",       HB_TAG('B','R','H',' ')},*\/     \/* Brahui *\/\n-  {\"bri\",       HB_TAG_NONE            },       \/* Mokpwe != Braj Bhasha *\/\n-  {\"brm\",       HB_TAG_NONE            },       \/* Barambu != Burmese *\/\n-\/*{\"brx\",       HB_TAG('B','R','X',' ')},*\/     \/* Bodo (India) *\/\n-  {\"bs\",        HB_TAG('B','O','S',' ')},       \/* Bosnian *\/\n-  {\"bsh\",       HB_TAG_NONE            },       \/* Kati != Bashkir *\/\n-\/*{\"bsk\",       HB_TAG('B','S','K',' ')},*\/     \/* Burushaski *\/\n-  {\"btb\",       HB_TAG('B','T','I',' ')},       \/* Beti (Cameroon) (retired code) *\/\n-  {\"btd\",       HB_TAG('B','T','D',' ')},       \/* Batak Dairi (Pakpak) *\/\n-  {\"btd\",       HB_TAG('B','T','K',' ')},       \/* Batak Dairi -> Batak *\/\n-  {\"bti\",       HB_TAG_NONE            },       \/* Burate != Beti *\/\n-  {\"btj\",       HB_TAG('M','L','Y',' ')},       \/* Bacanese Malay -> Malay *\/\n-\/*{\"btk\",       HB_TAG('B','T','K',' ')},*\/     \/* Batak [family] *\/\n-  {\"btm\",       HB_TAG('B','T','M',' ')},       \/* Batak Mandailing *\/\n-  {\"btm\",       HB_TAG('B','T','K',' ')},       \/* Batak Mandailing -> Batak *\/\n-  {\"bto\",       HB_TAG('B','I','K',' ')},       \/* Rinconada Bikol -> Bikol *\/\n-  {\"bts\",       HB_TAG('B','T','S',' ')},       \/* Batak Simalungun *\/\n-  {\"bts\",       HB_TAG('B','T','K',' ')},       \/* Batak Simalungun -> Batak *\/\n-  {\"btx\",       HB_TAG('B','T','X',' ')},       \/* Batak Karo *\/\n-  {\"btx\",       HB_TAG('B','T','K',' ')},       \/* Batak Karo -> Batak *\/\n-  {\"btz\",       HB_TAG('B','T','Z',' ')},       \/* Batak Alas-Kluet *\/\n-  {\"btz\",       HB_TAG('B','T','K',' ')},       \/* Batak Alas-Kluet -> Batak *\/\n-\/*{\"bug\",       HB_TAG('B','U','G',' ')},*\/     \/* Buginese -> Bugis *\/\n-  {\"bum\",       HB_TAG('B','T','I',' ')},       \/* Bulu (Cameroon) -> Beti *\/\n-  {\"bve\",       HB_TAG('M','L','Y',' ')},       \/* Berau Malay -> Malay *\/\n-  {\"bvu\",       HB_TAG('M','L','Y',' ')},       \/* Bukit Malay -> Malay *\/\n-  {\"bwe\",       HB_TAG('K','R','N',' ')},       \/* Bwe Karen -> Karen *\/\n-  {\"bxk\",       HB_TAG('L','U','H',' ')},       \/* Bukusu -> Luyia *\/\n-  {\"bxo\",       HB_TAG('C','P','P',' ')},       \/* Barikanchi -> Creoles *\/\n-  {\"bxp\",       HB_TAG('B','T','I',' ')},       \/* Bebil -> Beti *\/\n-  {\"bxr\",       HB_TAG('R','B','U',' ')},       \/* Russia Buriat -> Russian Buriat *\/\n-  {\"byn\",       HB_TAG('B','I','L',' ')},       \/* Bilin -> Bilen *\/\n-  {\"byv\",       HB_TAG('B','Y','V',' ')},       \/* Medumba *\/\n-  {\"byv\",       HB_TAG('B','M','L',' ')},       \/* Medumba -> Bamileke *\/\n-  {\"bzc\",       HB_TAG('M','L','G',' ')},       \/* Southern Betsimisaraka Malagasy -> Malagasy *\/\n-  {\"bzj\",       HB_TAG('C','P','P',' ')},       \/* Belize Kriol English -> Creoles *\/\n-  {\"bzk\",       HB_TAG('C','P','P',' ')},       \/* Nicaragua Creole English -> Creoles *\/\n-  {\"ca\",        HB_TAG('C','A','T',' ')},       \/* Catalan *\/\n-  {\"caa\",       HB_TAG('M','Y','N',' ')},       \/* Chort -> Mayan *\/\n-  {\"cac\",       HB_TAG('M','Y','N',' ')},       \/* Chuj -> Mayan *\/\n-  {\"caf\",       HB_TAG('C','R','R',' ')},       \/* Southern Carrier -> Carrier *\/\n-  {\"caf\",       HB_TAG('A','T','H',' ')},       \/* Southern Carrier -> Athapaskan *\/\n-  {\"cak\",       HB_TAG('C','A','K',' ')},       \/* Kaqchikel *\/\n-  {\"cak\",       HB_TAG('M','Y','N',' ')},       \/* Kaqchikel -> Mayan *\/\n-  {\"cbk\",       HB_TAG('C','B','K',' ')},       \/* Chavacano -> Zamboanga Chavacano *\/\n-  {\"cbk\",       HB_TAG('C','P','P',' ')},       \/* Chavacano -> Creoles *\/\n-  {\"cbl\",       HB_TAG('Q','I','N',' ')},       \/* Bualkhaw Chin -> Chin *\/\n-  {\"ccl\",       HB_TAG('C','P','P',' ')},       \/* Cutchi-Swahili -> Creoles *\/\n-  {\"ccm\",       HB_TAG('C','P','P',' ')},       \/* Malaccan Creole Malay -> Creoles *\/\n-  {\"cco\",       HB_TAG('C','C','H','N')},       \/* Comaltepec Chinantec -> Chinantec *\/\n-  {\"ccq\",       HB_TAG('A','R','K',' ')},       \/* Chaungtha (retired code) -> Rakhine *\/\n-  {\"cdo\",       HB_TAG('Z','H','S',' ')},       \/* Min Dong Chinese -> Chinese, Simplified *\/\n-  {\"ce\",        HB_TAG('C','H','E',' ')},       \/* Chechen *\/\n-\/*{\"ceb\",       HB_TAG('C','E','B',' ')},*\/     \/* Cebuano *\/\n-  {\"cek\",       HB_TAG('Q','I','N',' ')},       \/* Eastern Khumi Chin -> Chin *\/\n-  {\"cey\",       HB_TAG('Q','I','N',' ')},       \/* Ekai Chin -> Chin *\/\n-  {\"cfm\",       HB_TAG('H','A','L',' ')},       \/* Halam (Falam Chin) *\/\n-  {\"cfm\",       HB_TAG('Q','I','N',' ')},       \/* Falam Chin -> Chin *\/\n-\/*{\"cgg\",       HB_TAG('C','G','G',' ')},*\/     \/* Chiga *\/\n-  {\"ch\",        HB_TAG('C','H','A',' ')},       \/* Chamorro *\/\n-  {\"chf\",       HB_TAG('M','Y','N',' ')},       \/* Tabasco Chontal -> Mayan *\/\n-  {\"chg\",       HB_TAG_NONE            },       \/* Chagatai != Chaha Gurage *\/\n-  {\"chh\",       HB_TAG_NONE            },       \/* Chinook != Chattisgarhi *\/\n-  {\"chj\",       HB_TAG('C','C','H','N')},       \/* Ojitln Chinantec -> Chinantec *\/\n-  {\"chk\",       HB_TAG('C','H','K','0')},       \/* Chuukese *\/\n-  {\"chn\",       HB_TAG('C','P','P',' ')},       \/* Chinook jargon -> Creoles *\/\n-\/*{\"cho\",       HB_TAG('C','H','O',' ')},*\/     \/* Choctaw *\/\n-  {\"chp\",       HB_TAG('C','H','P',' ')},       \/* Chipewyan *\/\n-  {\"chp\",       HB_TAG('S','A','Y',' ')},       \/* Chipewyan -> Sayisi *\/\n-  {\"chp\",       HB_TAG('A','T','H',' ')},       \/* Chipewyan -> Athapaskan *\/\n-  {\"chq\",       HB_TAG('C','C','H','N')},       \/* Quiotepec Chinantec -> Chinantec *\/\n-\/*{\"chr\",       HB_TAG('C','H','R',' ')},*\/     \/* Cherokee *\/\n-\/*{\"chy\",       HB_TAG('C','H','Y',' ')},*\/     \/* Cheyenne *\/\n-  {\"chz\",       HB_TAG('C','C','H','N')},       \/* Ozumacn Chinantec -> Chinantec *\/\n-  {\"ciw\",       HB_TAG('O','J','B',' ')},       \/* Chippewa -> Ojibway *\/\n-\/*{\"cja\",       HB_TAG('C','J','A',' ')},*\/     \/* Western Cham *\/\n-\/*{\"cjm\",       HB_TAG('C','J','M',' ')},*\/     \/* Eastern Cham *\/\n-  {\"cjy\",       HB_TAG('Z','H','S',' ')},       \/* Jinyu Chinese -> Chinese, Simplified *\/\n-  {\"cka\",       HB_TAG('Q','I','N',' ')},       \/* Khumi Awa Chin (retired code) -> Chin *\/\n-  {\"ckb\",       HB_TAG('K','U','R',' ')},       \/* Central Kurdish -> Kurdish *\/\n-  {\"ckn\",       HB_TAG('Q','I','N',' ')},       \/* Kaang Chin -> Chin *\/\n-  {\"cks\",       HB_TAG('C','P','P',' ')},       \/* Tayo -> Creoles *\/\n-  {\"ckt\",       HB_TAG('C','H','K',' ')},       \/* Chukot -> Chukchi *\/\n-  {\"ckz\",       HB_TAG('M','Y','N',' ')},       \/* Cakchiquel-Quich Mixed Language -> Mayan *\/\n-  {\"clc\",       HB_TAG('A','T','H',' ')},       \/* Chilcotin -> Athapaskan *\/\n-  {\"cld\",       HB_TAG('S','Y','R',' ')},       \/* Chaldean Neo-Aramaic -> Syriac *\/\n-  {\"cle\",       HB_TAG('C','C','H','N')},       \/* Lealao Chinantec -> Chinantec *\/\n-  {\"clj\",       HB_TAG('Q','I','N',' ')},       \/* Laitu Chin -> Chin *\/\n-  {\"clt\",       HB_TAG('Q','I','N',' ')},       \/* Lautu Chin -> Chin *\/\n-  {\"cmn\",       HB_TAG('Z','H','S',' ')},       \/* Mandarin Chinese -> Chinese, Simplified *\/\n-  {\"cmr\",       HB_TAG('Q','I','N',' ')},       \/* Mro-Khimi Chin -> Chin *\/\n-  {\"cnb\",       HB_TAG('Q','I','N',' ')},       \/* Chinbon Chin -> Chin *\/\n-  {\"cnh\",       HB_TAG('Q','I','N',' ')},       \/* Hakha Chin -> Chin *\/\n-  {\"cnk\",       HB_TAG('Q','I','N',' ')},       \/* Khumi Chin -> Chin *\/\n-  {\"cnl\",       HB_TAG('C','C','H','N')},       \/* Lalana Chinantec -> Chinantec *\/\n-  {\"cnp\",       HB_TAG('Z','H','S',' ')},       \/* Northern Ping Chinese -> Chinese, Simplified *\/\n-  {\"cnr\",       HB_TAG('S','R','B',' ')},       \/* Montenegrin -> Serbian *\/\n-  {\"cnt\",       HB_TAG('C','C','H','N')},       \/* Tepetotutla Chinantec -> Chinantec *\/\n-  {\"cnu\",       HB_TAG('B','B','R',' ')},       \/* Chenoua -> Berber *\/\n-  {\"cnw\",       HB_TAG('Q','I','N',' ')},       \/* Ngawn Chin -> Chin *\/\n-  {\"co\",        HB_TAG('C','O','S',' ')},       \/* Corsican *\/\n-  {\"coa\",       HB_TAG('M','L','Y',' ')},       \/* Cocos Islands Malay -> Malay *\/\n-  {\"cob\",       HB_TAG('M','Y','N',' ')},       \/* Chicomuceltec -> Mayan *\/\n-\/*{\"cop\",       HB_TAG('C','O','P',' ')},*\/     \/* Coptic *\/\n-  {\"coq\",       HB_TAG('A','T','H',' ')},       \/* Coquille -> Athapaskan *\/\n-  {\"cpa\",       HB_TAG('C','C','H','N')},       \/* Palantla Chinantec -> Chinantec *\/\n-  {\"cpe\",       HB_TAG('C','P','P',' ')},       \/* English-based creoles and pidgins [family] -> Creoles *\/\n-  {\"cpf\",       HB_TAG('C','P','P',' ')},       \/* French-based creoles and pidgins [family] -> Creoles *\/\n-  {\"cpi\",       HB_TAG('C','P','P',' ')},       \/* Chinese Pidgin English -> Creoles *\/\n-\/*{\"cpp\",       HB_TAG('C','P','P',' ')},*\/     \/* Portuguese-based creoles and pidgins [family] -> Creoles *\/\n-  {\"cpx\",       HB_TAG('Z','H','S',' ')},       \/* Pu-Xian Chinese -> Chinese, Simplified *\/\n-  {\"cqd\",       HB_TAG('H','M','N',' ')},       \/* Chuanqiandian Cluster Miao -> Hmong *\/\n-  {\"cqu\",       HB_TAG('Q','U','H',' ')},       \/* Chilean Quechua (retired code) -> Quechua (Bolivia) *\/\n-  {\"cqu\",       HB_TAG('Q','U','Z',' ')},       \/* Chilean Quechua (retired code) -> Quechua *\/\n-  {\"cr\",        HB_TAG('C','R','E',' ')},       \/* Cree [macrolanguage] *\/\n-  {\"crh\",       HB_TAG('C','R','T',' ')},       \/* Crimean Tatar *\/\n-  {\"cri\",       HB_TAG('C','P','P',' ')},       \/* Sotomense -> Creoles *\/\n-  {\"crj\",       HB_TAG('E','C','R',' ')},       \/* Southern East Cree -> Eastern Cree *\/\n-  {\"crj\",       HB_TAG('Y','C','R',' ')},       \/* Southern East Cree -> Y-Cree *\/\n-  {\"crj\",       HB_TAG('C','R','E',' ')},       \/* Southern East Cree -> Cree *\/\n-  {\"crk\",       HB_TAG('W','C','R',' ')},       \/* Plains Cree -> West-Cree *\/\n-  {\"crk\",       HB_TAG('Y','C','R',' ')},       \/* Plains Cree -> Y-Cree *\/\n-  {\"crk\",       HB_TAG('C','R','E',' ')},       \/* Plains Cree -> Cree *\/\n-  {\"crl\",       HB_TAG('E','C','R',' ')},       \/* Northern East Cree -> Eastern Cree *\/\n-  {\"crl\",       HB_TAG('Y','C','R',' ')},       \/* Northern East Cree -> Y-Cree *\/\n-  {\"crl\",       HB_TAG('C','R','E',' ')},       \/* Northern East Cree -> Cree *\/\n-  {\"crm\",       HB_TAG('M','C','R',' ')},       \/* Moose Cree *\/\n-  {\"crm\",       HB_TAG('L','C','R',' ')},       \/* Moose Cree -> L-Cree *\/\n-  {\"crm\",       HB_TAG('C','R','E',' ')},       \/* Moose Cree -> Cree *\/\n-  {\"crp\",       HB_TAG('C','P','P',' ')},       \/* Creoles and pidgins [family] -> Creoles *\/\n-  {\"crr\",       HB_TAG_NONE            },       \/* Carolina Algonquian != Carrier *\/\n-  {\"crs\",       HB_TAG('C','P','P',' ')},       \/* Seselwa Creole French -> Creoles *\/\n-  {\"crt\",       HB_TAG_NONE            },       \/* Iyojwa'ja Chorote != Crimean Tatar *\/\n-  {\"crx\",       HB_TAG('C','R','R',' ')},       \/* Carrier *\/\n-  {\"crx\",       HB_TAG('A','T','H',' ')},       \/* Carrier -> Athapaskan *\/\n-  {\"cs\",        HB_TAG('C','S','Y',' ')},       \/* Czech *\/\n-  {\"csa\",       HB_TAG('C','C','H','N')},       \/* Chiltepec Chinantec -> Chinantec *\/\n-\/*{\"csb\",       HB_TAG('C','S','B',' ')},*\/     \/* Kashubian *\/\n-  {\"csh\",       HB_TAG('Q','I','N',' ')},       \/* Asho Chin -> Chin *\/\n-  {\"csj\",       HB_TAG('Q','I','N',' ')},       \/* Songlai Chin -> Chin *\/\n-  {\"csl\",       HB_TAG_NONE            },       \/* Chinese Sign Language != Church Slavonic *\/\n-  {\"cso\",       HB_TAG('C','C','H','N')},       \/* Sochiapam Chinantec -> Chinantec *\/\n-  {\"csp\",       HB_TAG('Z','H','S',' ')},       \/* Southern Ping Chinese -> Chinese, Simplified *\/\n-  {\"csv\",       HB_TAG('Q','I','N',' ')},       \/* Sumtu Chin -> Chin *\/\n-  {\"csw\",       HB_TAG('N','C','R',' ')},       \/* Swampy Cree -> N-Cree *\/\n-  {\"csw\",       HB_TAG('N','H','C',' ')},       \/* Swampy Cree -> Norway House Cree *\/\n-  {\"csw\",       HB_TAG('C','R','E',' ')},       \/* Swampy Cree -> Cree *\/\n-  {\"csy\",       HB_TAG('Q','I','N',' ')},       \/* Siyin Chin -> Chin *\/\n-  {\"ctc\",       HB_TAG('A','T','H',' ')},       \/* Chetco -> Athapaskan *\/\n-  {\"ctd\",       HB_TAG('Q','I','N',' ')},       \/* Tedim Chin -> Chin *\/\n-  {\"cte\",       HB_TAG('C','C','H','N')},       \/* Tepinapa Chinantec -> Chinantec *\/\n-\/*{\"ctg\",       HB_TAG('C','T','G',' ')},*\/     \/* Chittagonian *\/\n-  {\"cth\",       HB_TAG('Q','I','N',' ')},       \/* Thaiphum Chin -> Chin *\/\n-  {\"ctl\",       HB_TAG('C','C','H','N')},       \/* Tlacoatzintepec Chinantec -> Chinantec *\/\n-  {\"cts\",       HB_TAG('B','I','K',' ')},       \/* Northern Catanduanes Bikol -> Bikol *\/\n-  {\"ctu\",       HB_TAG('M','Y','N',' ')},       \/* Chol -> Mayan *\/\n-  {\"cu\",        HB_TAG('C','S','L',' ')},       \/* Church Slavonic *\/\n-  {\"cuc\",       HB_TAG('C','C','H','N')},       \/* Usila Chinantec -> Chinantec *\/\n-\/*{\"cuk\",       HB_TAG('C','U','K',' ')},*\/     \/* San Blas Kuna *\/\n-  {\"cv\",        HB_TAG('C','H','U',' ')},       \/* Chuvash *\/\n-  {\"cvn\",       HB_TAG('C','C','H','N')},       \/* Valle Nacional Chinantec -> Chinantec *\/\n-  {\"cwd\",       HB_TAG('D','C','R',' ')},       \/* Woods Cree *\/\n-  {\"cwd\",       HB_TAG('T','C','R',' ')},       \/* Woods Cree -> TH-Cree *\/\n-  {\"cwd\",       HB_TAG('C','R','E',' ')},       \/* Woods Cree -> Cree *\/\n-  {\"cy\",        HB_TAG('W','E','L',' ')},       \/* Welsh *\/\n-  {\"czh\",       HB_TAG('Z','H','S',' ')},       \/* Huizhou Chinese -> Chinese, Simplified *\/\n-  {\"czo\",       HB_TAG('Z','H','S',' ')},       \/* Min Zhong Chinese -> Chinese, Simplified *\/\n-  {\"czt\",       HB_TAG('Q','I','N',' ')},       \/* Zotung Chin -> Chin *\/\n-  {\"da\",        HB_TAG('D','A','N',' ')},       \/* Danish *\/\n-\/*{\"dag\",       HB_TAG('D','A','G',' ')},*\/     \/* Dagbani *\/\n-  {\"dao\",       HB_TAG('Q','I','N',' ')},       \/* Daai Chin -> Chin *\/\n-  {\"dap\",       HB_TAG('N','I','S',' ')},       \/* Nisi (India) (retired code) *\/\n-\/*{\"dar\",       HB_TAG('D','A','R',' ')},*\/     \/* Dargwa *\/\n-\/*{\"dax\",       HB_TAG('D','A','X',' ')},*\/     \/* Dayi *\/\n-  {\"dcr\",       HB_TAG('C','P','P',' ')},       \/* Negerhollands -> Creoles *\/\n-  {\"de\",        HB_TAG('D','E','U',' ')},       \/* German *\/\n-  {\"den\",       HB_TAG('S','L','A',' ')},       \/* Slave (Athapascan) [macrolanguage] -> Slavey *\/\n-  {\"den\",       HB_TAG('A','T','H',' ')},       \/* Slave (Athapascan) [macrolanguage] -> Athapaskan *\/\n-  {\"dep\",       HB_TAG('C','P','P',' ')},       \/* Pidgin Delaware -> Creoles *\/\n-  {\"dgo\",       HB_TAG('D','G','O',' ')},       \/* Dogri (individual language) *\/\n-  {\"dgo\",       HB_TAG('D','G','R',' ')},       \/* Dogri (macrolanguage) *\/\n-  {\"dgr\",       HB_TAG('A','T','H',' ')},       \/* Dogrib -> Athapaskan *\/\n-  {\"dhd\",       HB_TAG('M','A','W',' ')},       \/* Dhundari -> Marwari *\/\n-\/*{\"dhg\",       HB_TAG('D','H','G',' ')},*\/     \/* Dhangu *\/\n-  {\"dhv\",       HB_TAG_NONE            },       \/* Dehu != Divehi (Dhivehi, Maldivian) (deprecated) *\/\n-  {\"dib\",       HB_TAG('D','N','K',' ')},       \/* South Central Dinka -> Dinka *\/\n-  {\"dik\",       HB_TAG('D','N','K',' ')},       \/* Southwestern Dinka -> Dinka *\/\n-  {\"din\",       HB_TAG('D','N','K',' ')},       \/* Dinka [macrolanguage] *\/\n-  {\"dip\",       HB_TAG('D','N','K',' ')},       \/* Northeastern Dinka -> Dinka *\/\n-  {\"diq\",       HB_TAG('D','I','Q',' ')},       \/* Dimli *\/\n-  {\"diq\",       HB_TAG('Z','Z','A',' ')},       \/* Dimli -> Zazaki *\/\n-  {\"diw\",       HB_TAG('D','N','K',' ')},       \/* Northwestern Dinka -> Dinka *\/\n-  {\"dje\",       HB_TAG('D','J','R',' ')},       \/* Zarma *\/\n-  {\"djk\",       HB_TAG('C','P','P',' ')},       \/* Eastern Maroon Creole -> Creoles *\/\n-  {\"djr\",       HB_TAG('D','J','R','0')},       \/* Djambarrpuyngu *\/\n-  {\"dks\",       HB_TAG('D','N','K',' ')},       \/* Southeastern Dinka -> Dinka *\/\n-  {\"dng\",       HB_TAG('D','U','N',' ')},       \/* Dungan *\/\n-\/*{\"dnj\",       HB_TAG('D','N','J',' ')},*\/     \/* Dan *\/\n-  {\"dnk\",       HB_TAG_NONE            },       \/* Dengka != Dinka *\/\n-  {\"doi\",       HB_TAG('D','G','R',' ')},       \/* Dogri (macrolanguage) [macrolanguage] *\/\n-  {\"drh\",       HB_TAG('M','N','G',' ')},       \/* Darkhat (retired code) -> Mongolian *\/\n-  {\"dri\",       HB_TAG_NONE            },       \/* C'Lela != Dari *\/\n-  {\"drw\",       HB_TAG('D','R','I',' ')},       \/* Darwazi (retired code) -> Dari *\/\n-  {\"drw\",       HB_TAG('F','A','R',' ')},       \/* Darwazi (retired code) -> Persian *\/\n-  {\"dsb\",       HB_TAG('L','S','B',' ')},       \/* Lower Sorbian *\/\n-  {\"dty\",       HB_TAG('N','E','P',' ')},       \/* Dotyali -> Nepali *\/\n-\/*{\"duj\",       HB_TAG('D','U','J',' ')},*\/     \/* Dhuwal (retired code) *\/\n-  {\"dun\",       HB_TAG_NONE            },       \/* Dusun Deyah != Dungan *\/\n-  {\"dup\",       HB_TAG('M','L','Y',' ')},       \/* Duano -> Malay *\/\n-  {\"dv\",        HB_TAG('D','I','V',' ')},       \/* Divehi (Dhivehi, Maldivian) *\/\n-  {\"dv\",        HB_TAG('D','H','V',' ')},       \/* Divehi (Dhivehi, Maldivian) (deprecated) *\/\n-  {\"dwk\",       HB_TAG('K','U','I',' ')},       \/* Dawik Kui -> Kui *\/\n-  {\"dwu\",       HB_TAG('D','U','J',' ')},       \/* Dhuwal *\/\n-  {\"dwy\",       HB_TAG('D','U','J',' ')},       \/* Dhuwaya -> Dhuwal *\/\n-  {\"dyu\",       HB_TAG('J','U','L',' ')},       \/* Dyula -> Jula *\/\n-  {\"dz\",        HB_TAG('D','Z','N',' ')},       \/* Dzongkha *\/\n-  {\"dzn\",       HB_TAG_NONE            },       \/* Dzando != Dzongkha *\/\n-  {\"ecr\",       HB_TAG_NONE            },       \/* Eteocretan != Eastern Cree *\/\n-  {\"ee\",        HB_TAG('E','W','E',' ')},       \/* Ewe *\/\n-\/*{\"efi\",       HB_TAG('E','F','I',' ')},*\/     \/* Efik *\/\n-  {\"ekk\",       HB_TAG('E','T','I',' ')},       \/* Standard Estonian -> Estonian *\/\n-  {\"eky\",       HB_TAG('K','R','N',' ')},       \/* Eastern Kayah -> Karen *\/\n-  {\"el\",        HB_TAG('E','L','L',' ')},       \/* Modern Greek (1453-) -> Greek *\/\n-  {\"emk\",       HB_TAG('E','M','K',' ')},       \/* Eastern Maninkakan *\/\n-  {\"emk\",       HB_TAG('M','N','K',' ')},       \/* Eastern Maninkakan -> Maninka *\/\n-  {\"emy\",       HB_TAG('M','Y','N',' ')},       \/* Epigraphic Mayan -> Mayan *\/\n-  {\"en\",        HB_TAG('E','N','G',' ')},       \/* English *\/\n-  {\"enb\",       HB_TAG('K','A','L',' ')},       \/* Markweeta -> Kalenjin *\/\n-  {\"enf\",       HB_TAG('F','N','E',' ')},       \/* Forest Enets *\/\n-  {\"enh\",       HB_TAG('T','N','E',' ')},       \/* Tundra Enets *\/\n-  {\"eo\",        HB_TAG('N','T','O',' ')},       \/* Esperanto *\/\n-  {\"es\",        HB_TAG('E','S','P',' ')},       \/* Spanish *\/\n-  {\"esg\",       HB_TAG('G','O','N',' ')},       \/* Aheri Gondi -> Gondi *\/\n-  {\"esi\",       HB_TAG('I','P','K',' ')},       \/* North Alaskan Inupiatun -> Inupiat *\/\n-  {\"esk\",       HB_TAG('I','P','K',' ')},       \/* Northwest Alaska Inupiatun -> Inupiat *\/\n-\/*{\"esu\",       HB_TAG('E','S','U',' ')},*\/     \/* Central Yupik *\/\n-  {\"et\",        HB_TAG('E','T','I',' ')},       \/* Estonian [macrolanguage] *\/\n-  {\"eto\",       HB_TAG('B','T','I',' ')},       \/* Eton (Cameroon) -> Beti *\/\n-  {\"eu\",        HB_TAG('E','U','Q',' ')},       \/* Basque *\/\n-  {\"euq\",       HB_TAG_NONE            },       \/* Basque [family] != Basque *\/\n-  {\"eve\",       HB_TAG('E','V','N',' ')},       \/* Even *\/\n-  {\"evn\",       HB_TAG('E','V','K',' ')},       \/* Evenki *\/\n-  {\"ewo\",       HB_TAG('B','T','I',' ')},       \/* Ewondo -> Beti *\/\n-  {\"eyo\",       HB_TAG('K','A','L',' ')},       \/* Keiyo -> Kalenjin *\/\n-  {\"fa\",        HB_TAG('F','A','R',' ')},       \/* Persian [macrolanguage] *\/\n-  {\"fab\",       HB_TAG('C','P','P',' ')},       \/* Fa d'Ambu -> Creoles *\/\n-  {\"fan\",       HB_TAG('F','A','N','0')},       \/* Fang (Equatorial Guinea) *\/\n-  {\"fan\",       HB_TAG('B','T','I',' ')},       \/* Fang (Equatorial Guinea) -> Beti *\/\n-  {\"far\",       HB_TAG_NONE            },       \/* Fataleka != Persian *\/\n-  {\"fat\",       HB_TAG('F','A','T',' ')},       \/* Fanti *\/\n-  {\"fat\",       HB_TAG('A','K','A',' ')},       \/* Fanti -> Akan *\/\n-  {\"fbl\",       HB_TAG('B','I','K',' ')},       \/* West Albay Bikol -> Bikol *\/\n-  {\"ff\",        HB_TAG('F','U','L',' ')},       \/* Fulah [macrolanguage] *\/\n-  {\"ffm\",       HB_TAG('F','U','L',' ')},       \/* Maasina Fulfulde -> Fulah *\/\n-  {\"fi\",        HB_TAG('F','I','N',' ')},       \/* Finnish *\/\n-  {\"fil\",       HB_TAG('P','I','L',' ')},       \/* Filipino *\/\n-  {\"fj\",        HB_TAG('F','J','I',' ')},       \/* Fijian *\/\n-  {\"flm\",       HB_TAG('H','A','L',' ')},       \/* Halam (Falam Chin) (retired code) *\/\n-  {\"flm\",       HB_TAG('Q','I','N',' ')},       \/* Falam Chin (retired code) -> Chin *\/\n-  {\"fmp\",       HB_TAG('F','M','P',' ')},       \/* Fefe *\/\n-  {\"fmp\",       HB_TAG('B','M','L',' ')},       \/* Fe'fe' -> Bamileke *\/\n-  {\"fng\",       HB_TAG('C','P','P',' ')},       \/* Fanagalo -> Creoles *\/\n-  {\"fo\",        HB_TAG('F','O','S',' ')},       \/* Faroese *\/\n-\/*{\"fon\",       HB_TAG('F','O','N',' ')},*\/     \/* Fon *\/\n-  {\"fos\",       HB_TAG_NONE            },       \/* Siraya != Faroese *\/\n-  {\"fpe\",       HB_TAG('C','P','P',' ')},       \/* Fernando Po Creole English -> Creoles *\/\n-  {\"fr\",        HB_TAG('F','R','A',' ')},       \/* French *\/\n-\/*{\"frc\",       HB_TAG('F','R','C',' ')},*\/     \/* Cajun French *\/\n-\/*{\"frp\",       HB_TAG('F','R','P',' ')},*\/     \/* Arpitan *\/\n-  {\"fub\",       HB_TAG('F','U','L',' ')},       \/* Adamawa Fulfulde -> Fulah *\/\n-  {\"fuc\",       HB_TAG('F','U','L',' ')},       \/* Pulaar -> Fulah *\/\n-  {\"fue\",       HB_TAG('F','U','L',' ')},       \/* Borgu Fulfulde -> Fulah *\/\n-  {\"fuf\",       HB_TAG('F','T','A',' ')},       \/* Pular -> Futa *\/\n-  {\"fuf\",       HB_TAG('F','U','L',' ')},       \/* Pular -> Fulah *\/\n-  {\"fuh\",       HB_TAG('F','U','L',' ')},       \/* Western Niger Fulfulde -> Fulah *\/\n-  {\"fui\",       HB_TAG('F','U','L',' ')},       \/* Bagirmi Fulfulde -> Fulah *\/\n-  {\"fuq\",       HB_TAG('F','U','L',' ')},       \/* Central-Eastern Niger Fulfulde -> Fulah *\/\n-  {\"fur\",       HB_TAG('F','R','L',' ')},       \/* Friulian *\/\n-  {\"fuv\",       HB_TAG('F','U','V',' ')},       \/* Nigerian Fulfulde *\/\n-  {\"fuv\",       HB_TAG('F','U','L',' ')},       \/* Nigerian Fulfulde -> Fulah *\/\n-  {\"fy\",        HB_TAG('F','R','I',' ')},       \/* Western Frisian -> Frisian *\/\n-  {\"ga\",        HB_TAG('I','R','I',' ')},       \/* Irish *\/\n-  {\"gaa\",       HB_TAG('G','A','D',' ')},       \/* Ga *\/\n-  {\"gac\",       HB_TAG('C','P','P',' ')},       \/* Mixed Great Andamanese -> Creoles *\/\n-  {\"gad\",       HB_TAG_NONE            },       \/* Gaddang != Ga *\/\n-  {\"gae\",       HB_TAG_NONE            },       \/* Guarequena != Scottish Gaelic (Gaelic) *\/\n-\/*{\"gag\",       HB_TAG('G','A','G',' ')},*\/     \/* Gagauz *\/\n-  {\"gal\",       HB_TAG_NONE            },       \/* Galolen != Galician *\/\n-  {\"gan\",       HB_TAG('Z','H','S',' ')},       \/* Gan Chinese -> Chinese, Simplified *\/\n-  {\"gar\",       HB_TAG_NONE            },       \/* Galeya != Garshuni *\/\n-  {\"gaw\",       HB_TAG_NONE            },       \/* Nobonob != Garhwali *\/\n-  {\"gax\",       HB_TAG('O','R','O',' ')},       \/* Borana-Arsi-Guji Oromo -> Oromo *\/\n-  {\"gaz\",       HB_TAG('O','R','O',' ')},       \/* West Central Oromo -> Oromo *\/\n-  {\"gbm\",       HB_TAG('G','A','W',' ')},       \/* Garhwali *\/\n-  {\"gce\",       HB_TAG('A','T','H',' ')},       \/* Galice -> Athapaskan *\/\n-  {\"gcf\",       HB_TAG('C','P','P',' ')},       \/* Guadeloupean Creole French -> Creoles *\/\n-  {\"gcl\",       HB_TAG('C','P','P',' ')},       \/* Grenadian Creole English -> Creoles *\/\n-  {\"gcr\",       HB_TAG('C','P','P',' ')},       \/* Guianese Creole French -> Creoles *\/\n-  {\"gd\",        HB_TAG('G','A','E',' ')},       \/* Scottish Gaelic (Gaelic) *\/\n-  {\"gda\",       HB_TAG('R','A','J',' ')},       \/* Gade Lohar -> Rajasthani *\/\n-\/*{\"gez\",       HB_TAG('G','E','Z',' ')},*\/     \/* Geez *\/\n-  {\"ggo\",       HB_TAG('G','O','N',' ')},       \/* Southern Gondi (retired code) -> Gondi *\/\n-  {\"gha\",       HB_TAG('B','B','R',' ')},       \/* Ghadams -> Berber *\/\n-  {\"ghk\",       HB_TAG('K','R','N',' ')},       \/* Geko Karen -> Karen *\/\n-  {\"gho\",       HB_TAG('B','B','R',' ')},       \/* Ghomara -> Berber *\/\n-  {\"gib\",       HB_TAG('C','P','P',' ')},       \/* Gibanawa -> Creoles *\/\n-\/*{\"gih\",       HB_TAG('G','I','H',' ')},*\/     \/* Githabul *\/\n-  {\"gil\",       HB_TAG('G','I','L','0')},       \/* Kiribati (Gilbertese) *\/\n-  {\"gju\",       HB_TAG('R','A','J',' ')},       \/* Gujari -> Rajasthani *\/\n-  {\"gkp\",       HB_TAG('G','K','P',' ')},       \/* Guinea Kpelle -> Kpelle (Guinea) *\/\n-  {\"gkp\",       HB_TAG('K','P','L',' ')},       \/* Guinea Kpelle -> Kpelle *\/\n-  {\"gl\",        HB_TAG('G','A','L',' ')},       \/* Galician *\/\n-  {\"gld\",       HB_TAG('N','A','N',' ')},       \/* Nanai *\/\n-\/*{\"glk\",       HB_TAG('G','L','K',' ')},*\/     \/* Gilaki *\/\n-  {\"gmz\",       HB_TAG_NONE            },       \/* Mgbolizhia != Gumuz *\/\n-  {\"gn\",        HB_TAG('G','U','A',' ')},       \/* Guarani [macrolanguage] *\/\n-  {\"gnb\",       HB_TAG('Q','I','N',' ')},       \/* Gangte -> Chin *\/\n-\/*{\"gnn\",       HB_TAG('G','N','N',' ')},*\/     \/* Gumatj *\/\n-  {\"gno\",       HB_TAG('G','O','N',' ')},       \/* Northern Gondi -> Gondi *\/\n-  {\"gnw\",       HB_TAG('G','U','A',' ')},       \/* Western Bolivian Guaran -> Guarani *\/\n-\/*{\"gog\",       HB_TAG('G','O','G',' ')},*\/     \/* Gogo *\/\n-  {\"gom\",       HB_TAG('K','O','K',' ')},       \/* Goan Konkani -> Konkani *\/\n-\/*{\"gon\",       HB_TAG('G','O','N',' ')},*\/     \/* Gondi [macrolanguage] *\/\n-  {\"goq\",       HB_TAG('C','P','P',' ')},       \/* Gorap -> Creoles *\/\n-  {\"gox\",       HB_TAG('B','A','D','0')},       \/* Gobu -> Banda *\/\n-  {\"gpe\",       HB_TAG('C','P','P',' ')},       \/* Ghanaian Pidgin English -> Creoles *\/\n-  {\"gro\",       HB_TAG_NONE            },       \/* Groma != Garo *\/\n-  {\"grr\",       HB_TAG('B','B','R',' ')},       \/* Taznatit -> Berber *\/\n-  {\"grt\",       HB_TAG('G','R','O',' ')},       \/* Garo *\/\n-  {\"gru\",       HB_TAG('S','O','G',' ')},       \/* Kistane -> Sodo Gurage *\/\n-  {\"gsw\",       HB_TAG('A','L','S',' ')},       \/* Alsatian *\/\n-  {\"gu\",        HB_TAG('G','U','J',' ')},       \/* Gujarati *\/\n-  {\"gua\",       HB_TAG_NONE            },       \/* Shiki != Guarani *\/\n-\/*{\"guc\",       HB_TAG('G','U','C',' ')},*\/     \/* Wayuu *\/\n-\/*{\"guf\",       HB_TAG('G','U','F',' ')},*\/     \/* Gupapuyngu *\/\n-  {\"gug\",       HB_TAG('G','U','A',' ')},       \/* Paraguayan Guaran -> Guarani *\/\n-  {\"gui\",       HB_TAG('G','U','A',' ')},       \/* Eastern Bolivian Guaran -> Guarani *\/\n-  {\"guk\",       HB_TAG('G','M','Z',' ')},       \/* Gumuz *\/\n-  {\"gul\",       HB_TAG('C','P','P',' ')},       \/* Sea Island Creole English -> Creoles *\/\n-  {\"gun\",       HB_TAG('G','U','A',' ')},       \/* Mby Guaran -> Guarani *\/\n-\/*{\"guz\",       HB_TAG('G','U','Z',' ')},*\/     \/* Gusii *\/\n-  {\"gv\",        HB_TAG('M','N','X',' ')},       \/* Manx *\/\n-  {\"gwi\",       HB_TAG('A','T','H',' ')},       \/* Gwichin -> Athapaskan *\/\n-  {\"gyn\",       HB_TAG('C','P','P',' ')},       \/* Guyanese Creole English -> Creoles *\/\n-  {\"ha\",        HB_TAG('H','A','U',' ')},       \/* Hausa *\/\n-  {\"haa\",       HB_TAG('A','T','H',' ')},       \/* Han -> Athapaskan *\/\n-  {\"hae\",       HB_TAG('O','R','O',' ')},       \/* Eastern Oromo -> Oromo *\/\n-  {\"hai\",       HB_TAG_NONE            },       \/* Haida [macrolanguage] != Haitian (Haitian Creole) *\/\n-  {\"hak\",       HB_TAG('Z','H','S',' ')},       \/* Hakka Chinese -> Chinese, Simplified *\/\n-  {\"hal\",       HB_TAG_NONE            },       \/* Halang != Halam (Falam Chin) *\/\n-  {\"har\",       HB_TAG('H','R','I',' ')},       \/* Harari *\/\n-\/*{\"haw\",       HB_TAG('H','A','W',' ')},*\/     \/* Hawaiian *\/\n-\/*{\"hay\",       HB_TAG('H','A','Y',' ')},*\/     \/* Haya *\/\n-\/*{\"haz\",       HB_TAG('H','A','Z',' ')},*\/     \/* Hazaragi *\/\n-  {\"hbn\",       HB_TAG_NONE            },       \/* Heiban != Hammer-Banna *\/\n-  {\"hca\",       HB_TAG('C','P','P',' ')},       \/* Andaman Creole Hindi -> Creoles *\/\n-  {\"he\",        HB_TAG('I','W','R',' ')},       \/* Hebrew *\/\n-  {\"hea\",       HB_TAG('H','M','N',' ')},       \/* Northern Qiandong Miao -> Hmong *\/\n-  {\"hi\",        HB_TAG('H','I','N',' ')},       \/* Hindi *\/\n-\/*{\"hil\",       HB_TAG('H','I','L',' ')},*\/     \/* Hiligaynon *\/\n-  {\"hji\",       HB_TAG('M','L','Y',' ')},       \/* Haji -> Malay *\/\n-  {\"hlt\",       HB_TAG('Q','I','N',' ')},       \/* Matu Chin -> Chin *\/\n-  {\"hma\",       HB_TAG('H','M','N',' ')},       \/* Southern Mashan Hmong -> Hmong *\/\n-  {\"hmc\",       HB_TAG('H','M','N',' ')},       \/* Central Huishui Hmong -> Hmong *\/\n-  {\"hmd\",       HB_TAG('H','M','N',' ')},       \/* Large Flowery Miao -> Hmong *\/\n-  {\"hme\",       HB_TAG('H','M','N',' ')},       \/* Eastern Huishui Hmong -> Hmong *\/\n-  {\"hmg\",       HB_TAG('H','M','N',' ')},       \/* Southwestern Guiyang Hmong -> Hmong *\/\n-  {\"hmh\",       HB_TAG('H','M','N',' ')},       \/* Southwestern Huishui Hmong -> Hmong *\/\n-  {\"hmi\",       HB_TAG('H','M','N',' ')},       \/* Northern Huishui Hmong -> Hmong *\/\n-  {\"hmj\",       HB_TAG('H','M','N',' ')},       \/* Ge -> Hmong *\/\n-  {\"hml\",       HB_TAG('H','M','N',' ')},       \/* Luopohe Hmong -> Hmong *\/\n-  {\"hmm\",       HB_TAG('H','M','N',' ')},       \/* Central Mashan Hmong -> Hmong *\/\n-\/*{\"hmn\",       HB_TAG('H','M','N',' ')},*\/     \/* Hmong [macrolanguage] *\/\n-  {\"hmp\",       HB_TAG('H','M','N',' ')},       \/* Northern Mashan Hmong -> Hmong *\/\n-  {\"hmq\",       HB_TAG('H','M','N',' ')},       \/* Eastern Qiandong Miao -> Hmong *\/\n-  {\"hmr\",       HB_TAG('Q','I','N',' ')},       \/* Hmar -> Chin *\/\n-  {\"hms\",       HB_TAG('H','M','N',' ')},       \/* Southern Qiandong Miao -> Hmong *\/\n-  {\"hmw\",       HB_TAG('H','M','N',' ')},       \/* Western Mashan Hmong -> Hmong *\/\n-  {\"hmy\",       HB_TAG('H','M','N',' ')},       \/* Southern Guiyang Hmong -> Hmong *\/\n-  {\"hmz\",       HB_TAG('H','M','N',' ')},       \/* Hmong Shua -> Hmong *\/\n-\/*{\"hnd\",       HB_TAG('H','N','D',' ')},*\/     \/* Southern Hindko -> Hindko *\/\n-  {\"hne\",       HB_TAG('C','H','H',' ')},       \/* Chhattisgarhi -> Chattisgarhi *\/\n-  {\"hnj\",       HB_TAG('H','M','N',' ')},       \/* Hmong Njua -> Hmong *\/\n-  {\"hno\",       HB_TAG('H','N','D',' ')},       \/* Northern Hindko -> Hindko *\/\n-  {\"ho\",        HB_TAG('H','M','O',' ')},       \/* Hiri Motu *\/\n-  {\"ho\",        HB_TAG('C','P','P',' ')},       \/* Hiri Motu -> Creoles *\/\n-  {\"hoc\",       HB_TAG('H','O',' ',' ')},       \/* Ho *\/\n-  {\"hoi\",       HB_TAG('A','T','H',' ')},       \/* Holikachuk -> Athapaskan *\/\n-  {\"hoj\",       HB_TAG('H','A','R',' ')},       \/* Hadothi -> Harauti *\/\n-  {\"hoj\",       HB_TAG('R','A','J',' ')},       \/* Hadothi -> Rajasthani *\/\n-  {\"hr\",        HB_TAG('H','R','V',' ')},       \/* Croatian *\/\n-  {\"hra\",       HB_TAG('Q','I','N',' ')},       \/* Hrangkhol -> Chin *\/\n-  {\"hrm\",       HB_TAG('H','M','N',' ')},       \/* Horned Miao -> Hmong *\/\n-  {\"hsb\",       HB_TAG('U','S','B',' ')},       \/* Upper Sorbian *\/\n-  {\"hsn\",       HB_TAG('Z','H','S',' ')},       \/* Xiang Chinese -> Chinese, Simplified *\/\n-  {\"ht\",        HB_TAG('H','A','I',' ')},       \/* Haitian (Haitian Creole) *\/\n-  {\"ht\",        HB_TAG('C','P','P',' ')},       \/* Haitian -> Creoles *\/\n-  {\"hu\",        HB_TAG('H','U','N',' ')},       \/* Hungarian *\/\n-  {\"huj\",       HB_TAG('H','M','N',' ')},       \/* Northern Guiyang Hmong -> Hmong *\/\n-  {\"hup\",       HB_TAG('A','T','H',' ')},       \/* Hupa -> Athapaskan *\/\n-  {\"hus\",       HB_TAG('M','Y','N',' ')},       \/* Huastec -> Mayan *\/\n-  {\"hwc\",       HB_TAG('C','P','P',' ')},       \/* Hawai'i Creole English -> Creoles *\/\n-  {\"hy\",        HB_TAG('H','Y','E','0')},       \/* Armenian -> Armenian East *\/\n-  {\"hy\",        HB_TAG('H','Y','E',' ')},       \/* Armenian *\/\n-  {\"hyw\",       HB_TAG('H','Y','E',' ')},       \/* Western Armenian -> Armenian *\/\n-  {\"hz\",        HB_TAG('H','E','R',' ')},       \/* Herero *\/\n-  {\"ia\",        HB_TAG('I','N','A',' ')},       \/* Interlingua (International Auxiliary Language Association) *\/\n-\/*{\"iba\",       HB_TAG('I','B','A',' ')},*\/     \/* Iban *\/\n-\/*{\"ibb\",       HB_TAG('I','B','B',' ')},*\/     \/* Ibibio *\/\n-  {\"iby\",       HB_TAG('I','J','O',' ')},       \/* Ibani -> Ijo *\/\n-  {\"icr\",       HB_TAG('C','P','P',' ')},       \/* Islander Creole English -> Creoles *\/\n-  {\"id\",        HB_TAG('I','N','D',' ')},       \/* Indonesian *\/\n-  {\"id\",        HB_TAG('M','L','Y',' ')},       \/* Indonesian -> Malay *\/\n-  {\"ida\",       HB_TAG('L','U','H',' ')},       \/* Idakho-Isukha-Tiriki -> Luyia *\/\n-  {\"idb\",       HB_TAG('C','P','P',' ')},       \/* Indo-Portuguese -> Creoles *\/\n-  {\"ie\",        HB_TAG('I','L','E',' ')},       \/* Interlingue *\/\n-  {\"ig\",        HB_TAG('I','B','O',' ')},       \/* Igbo *\/\n-  {\"igb\",       HB_TAG('E','B','I',' ')},       \/* Ebira *\/\n-  {\"ihb\",       HB_TAG('C','P','P',' ')},       \/* Iha Based Pidgin -> Creoles *\/\n-  {\"ii\",        HB_TAG('Y','I','M',' ')},       \/* Sichuan Yi -> Yi Modern *\/\n-  {\"ijc\",       HB_TAG('I','J','O',' ')},       \/* Izon -> Ijo *\/\n-  {\"ije\",       HB_TAG('I','J','O',' ')},       \/* Biseni -> Ijo *\/\n-  {\"ijn\",       HB_TAG('I','J','O',' ')},       \/* Kalabari -> Ijo *\/\n-\/*{\"ijo\",       HB_TAG('I','J','O',' ')},*\/     \/* Ijo [family] *\/\n-  {\"ijs\",       HB_TAG('I','J','O',' ')},       \/* Southeast Ijo -> Ijo *\/\n-  {\"ik\",        HB_TAG('I','P','K',' ')},       \/* Inupiaq [macrolanguage] -> Inupiat *\/\n-  {\"ike\",       HB_TAG('I','N','U',' ')},       \/* Eastern Canadian Inuktitut -> Inuktitut *\/\n-  {\"ikt\",       HB_TAG('I','N','U',' ')},       \/* Inuinnaqtun -> Inuktitut *\/\n-\/*{\"ilo\",       HB_TAG('I','L','O',' ')},*\/     \/* Iloko -> Ilokano *\/\n-  {\"in\",        HB_TAG('I','N','D',' ')},       \/* Indonesian (retired code) *\/\n-  {\"in\",        HB_TAG('M','L','Y',' ')},       \/* Indonesian (retired code) -> Malay *\/\n-  {\"ing\",       HB_TAG('A','T','H',' ')},       \/* Degexit'an -> Athapaskan *\/\n-  {\"inh\",       HB_TAG('I','N','G',' ')},       \/* Ingush *\/\n-  {\"io\",        HB_TAG('I','D','O',' ')},       \/* Ido *\/\n-  {\"iri\",       HB_TAG_NONE            },       \/* Rigwe != Irish *\/\n-  {\"is\",        HB_TAG('I','S','L',' ')},       \/* Icelandic *\/\n-  {\"ism\",       HB_TAG_NONE            },       \/* Masimasi != Inari Sami *\/\n-  {\"it\",        HB_TAG('I','T','A',' ')},       \/* Italian *\/\n-  {\"itz\",       HB_TAG('M','Y','N',' ')},       \/* Itz -> Mayan *\/\n-  {\"iu\",        HB_TAG('I','N','U',' ')},       \/* Inuktitut [macrolanguage] *\/\n-  {\"iw\",        HB_TAG('I','W','R',' ')},       \/* Hebrew (retired code) *\/\n-  {\"ixl\",       HB_TAG('M','Y','N',' ')},       \/* Ixil -> Mayan *\/\n-  {\"ja\",        HB_TAG('J','A','N',' ')},       \/* Japanese *\/\n-  {\"jac\",       HB_TAG('M','Y','N',' ')},       \/* Popti' -> Mayan *\/\n-  {\"jak\",       HB_TAG('M','L','Y',' ')},       \/* Jakun -> Malay *\/\n-  {\"jam\",       HB_TAG('J','A','M',' ')},       \/* Jamaican Creole English -> Jamaican Creole *\/\n-  {\"jam\",       HB_TAG('C','P','P',' ')},       \/* Jamaican Creole English -> Creoles *\/\n-  {\"jan\",       HB_TAG_NONE            },       \/* Jandai != Japanese *\/\n-  {\"jax\",       HB_TAG('M','L','Y',' ')},       \/* Jambi Malay -> Malay *\/\n-  {\"jbe\",       HB_TAG('B','B','R',' ')},       \/* Judeo-Berber -> Berber *\/\n-  {\"jbn\",       HB_TAG('B','B','R',' ')},       \/* Nafusi -> Berber *\/\n-\/*{\"jbo\",       HB_TAG('J','B','O',' ')},*\/     \/* Lojban *\/\n-\/*{\"jct\",       HB_TAG('J','C','T',' ')},*\/     \/* Krymchak *\/\n-  {\"jgo\",       HB_TAG('B','M','L',' ')},       \/* Ngomba -> Bamileke *\/\n-  {\"ji\",        HB_TAG('J','I','I',' ')},       \/* Yiddish (retired code) *\/\n-  {\"jii\",       HB_TAG_NONE            },       \/* Jiiddu != Yiddish *\/\n-  {\"jkm\",       HB_TAG('K','R','N',' ')},       \/* Mobwa Karen -> Karen *\/\n-  {\"jkp\",       HB_TAG('K','R','N',' ')},       \/* Paku Karen -> Karen *\/\n-  {\"jud\",       HB_TAG_NONE            },       \/* Worodougou != Ladino *\/\n-  {\"jul\",       HB_TAG_NONE            },       \/* Jirel != Jula *\/\n-  {\"jv\",        HB_TAG('J','A','V',' ')},       \/* Javanese *\/\n-  {\"jvd\",       HB_TAG('C','P','P',' ')},       \/* Javindo -> Creoles *\/\n-  {\"jw\",        HB_TAG('J','A','V',' ')},       \/* Javanese (retired code) *\/\n-  {\"ka\",        HB_TAG('K','A','T',' ')},       \/* Georgian *\/\n-  {\"kaa\",       HB_TAG('K','R','K',' ')},       \/* Karakalpak *\/\n-  {\"kab\",       HB_TAG('K','A','B','0')},       \/* Kabyle *\/\n-  {\"kab\",       HB_TAG('B','B','R',' ')},       \/* Kabyle -> Berber *\/\n-  {\"kac\",       HB_TAG_NONE            },       \/* Kachin != Kachchi *\/\n-  {\"kam\",       HB_TAG('K','M','B',' ')},       \/* Kamba (Kenya) *\/\n-  {\"kar\",       HB_TAG('K','R','N',' ')},       \/* Karen [family] *\/\n-  {\"kbd\",       HB_TAG('K','A','B',' ')},       \/* Kabardian *\/\n-  {\"kby\",       HB_TAG('K','N','R',' ')},       \/* Manga Kanuri -> Kanuri *\/\n-  {\"kca\",       HB_TAG('K','H','K',' ')},       \/* Khanty -> Khanty-Kazim *\/\n-  {\"kca\",       HB_TAG('K','H','S',' ')},       \/* Khanty -> Khanty-Shurishkar *\/\n-  {\"kca\",       HB_TAG('K','H','V',' ')},       \/* Khanty -> Khanty-Vakhi *\/\n-  {\"kcn\",       HB_TAG('C','P','P',' ')},       \/* Nubi -> Creoles *\/\n-\/*{\"kde\",       HB_TAG('K','D','E',' ')},*\/     \/* Makonde *\/\n-  {\"kdr\",       HB_TAG('K','R','M',' ')},       \/* Karaim *\/\n-  {\"kdt\",       HB_TAG('K','U','Y',' ')},       \/* Kuy *\/\n-  {\"kea\",       HB_TAG('K','E','A',' ')},       \/* Kabuverdianu (Crioulo) *\/\n-  {\"kea\",       HB_TAG('C','P','P',' ')},       \/* Kabuverdianu -> Creoles *\/\n-  {\"keb\",       HB_TAG_NONE            },       \/* Kl != Kebena *\/\n-  {\"kek\",       HB_TAG('K','E','K',' ')},       \/* Kekchi *\/\n-  {\"kek\",       HB_TAG('M','Y','N',' ')},       \/* Kekch -> Mayan *\/\n-  {\"kex\",       HB_TAG('K','K','N',' ')},       \/* Kukna -> Kokni *\/\n-  {\"kfa\",       HB_TAG('K','O','D',' ')},       \/* Kodava -> Kodagu *\/\n-  {\"kfr\",       HB_TAG('K','A','C',' ')},       \/* Kachhi -> Kachchi *\/\n-  {\"kfx\",       HB_TAG('K','U','L',' ')},       \/* Kullu Pahari -> Kulvi *\/\n-  {\"kfy\",       HB_TAG('K','M','N',' ')},       \/* Kumaoni *\/\n-  {\"kg\",        HB_TAG('K','O','N','0')},       \/* Kongo [macrolanguage] *\/\n-  {\"kge\",       HB_TAG_NONE            },       \/* Komering != Khutsuri Georgian *\/\n-  {\"kha\",       HB_TAG('K','S','I',' ')},       \/* Khasi *\/\n-  {\"khb\",       HB_TAG('X','B','D',' ')},       \/* L *\/\n-  {\"khk\",       HB_TAG('M','N','G',' ')},       \/* Halh Mongolian -> Mongolian *\/\n-  {\"khn\",       HB_TAG_NONE            },       \/* Khandesi != Khamti Shan (Microsoft fonts) *\/\n-  {\"khs\",       HB_TAG_NONE            },       \/* Kasua != Khanty-Shurishkar *\/\n-  {\"kht\",       HB_TAG('K','H','T',' ')},       \/* Khamti -> Khamti Shan *\/\n-  {\"kht\",       HB_TAG('K','H','N',' ')},       \/* Khamti -> Khamti Shan (Microsoft fonts) *\/\n-  {\"khv\",       HB_TAG_NONE            },       \/* Khvarshi != Khanty-Vakhi *\/\n-\/*{\"khw\",       HB_TAG('K','H','W',' ')},*\/     \/* Khowar *\/\n-  {\"ki\",        HB_TAG('K','I','K',' ')},       \/* Kikuyu (Gikuyu) *\/\n-  {\"kis\",       HB_TAG_NONE            },       \/* Kis != Kisii *\/\n-  {\"kiu\",       HB_TAG('K','I','U',' ')},       \/* Kirmanjki *\/\n-  {\"kiu\",       HB_TAG('Z','Z','A',' ')},       \/* Kirmanjki -> Zazaki *\/\n-  {\"kj\",        HB_TAG('K','U','A',' ')},       \/* Kuanyama *\/\n-  {\"kjb\",       HB_TAG('M','Y','N',' ')},       \/* Q'anjob'al -> Mayan *\/\n-\/*{\"kjd\",       HB_TAG('K','J','D',' ')},*\/     \/* Southern Kiwai *\/\n-  {\"kjh\",       HB_TAG('K','H','A',' ')},       \/* Khakas -> Khakass *\/\n-  {\"kjp\",       HB_TAG('K','J','P',' ')},       \/* Pwo Eastern Karen -> Eastern Pwo Karen *\/\n-  {\"kjp\",       HB_TAG('K','R','N',' ')},       \/* Pwo Eastern Karen -> Karen *\/\n-  {\"kjt\",       HB_TAG('K','R','N',' ')},       \/* Phrae Pwo Karen -> Karen *\/\n-\/*{\"kjz\",       HB_TAG('K','J','Z',' ')},*\/     \/* Bumthangkha *\/\n-  {\"kk\",        HB_TAG('K','A','Z',' ')},       \/* Kazakh *\/\n-  {\"kkn\",       HB_TAG_NONE            },       \/* Kon Keu != Kokni *\/\n-  {\"kkz\",       HB_TAG('A','T','H',' ')},       \/* Kaska -> Athapaskan *\/\n-  {\"kl\",        HB_TAG('G','R','N',' ')},       \/* Greenlandic *\/\n-  {\"klm\",       HB_TAG_NONE            },       \/* Migum != Kalmyk *\/\n-  {\"kln\",       HB_TAG('K','A','L',' ')},       \/* Kalenjin [macrolanguage] *\/\n-  {\"km\",        HB_TAG('K','H','M',' ')},       \/* Khmer *\/\n-  {\"kmb\",       HB_TAG('M','B','N',' ')},       \/* Kimbundu -> Mbundu *\/\n-  {\"kmn\",       HB_TAG_NONE            },       \/* Awtuw != Kumaoni *\/\n-  {\"kmo\",       HB_TAG_NONE            },       \/* Kwoma != Komo *\/\n-  {\"kmr\",       HB_TAG('K','U','R',' ')},       \/* Northern Kurdish -> Kurdish *\/\n-  {\"kms\",       HB_TAG_NONE            },       \/* Kamasau != Komso *\/\n-  {\"kmv\",       HB_TAG('C','P','P',' ')},       \/* Karipna Creole French -> Creoles *\/\n-  {\"kmw\",       HB_TAG('K','M','O',' ')},       \/* Komo (Democratic Republic of Congo) *\/\n-\/*{\"kmz\",       HB_TAG('K','M','Z',' ')},*\/     \/* Khorasani Turkish -> Khorasani Turkic *\/\n-  {\"kn\",        HB_TAG('K','A','N',' ')},       \/* Kannada *\/\n-  {\"knc\",       HB_TAG('K','N','R',' ')},       \/* Central Kanuri -> Kanuri *\/\n-  {\"kng\",       HB_TAG('K','O','N','0')},       \/* Koongo -> Kongo *\/\n-  {\"knj\",       HB_TAG('M','Y','N',' ')},       \/* Western Kanjobal -> Mayan *\/\n-  {\"knn\",       HB_TAG('K','O','K',' ')},       \/* Konkani *\/\n-  {\"knr\",       HB_TAG_NONE            },       \/* Kaningra != Kanuri *\/\n-  {\"ko\",        HB_TAG('K','O','R',' ')},       \/* Korean *\/\n-  {\"ko\",        HB_TAG('K','O','H',' ')},       \/* Korean -> Korean Old Hangul *\/\n-  {\"kod\",       HB_TAG_NONE            },       \/* Kodi != Kodagu *\/\n-  {\"koh\",       HB_TAG_NONE            },       \/* Koyo != Korean Old Hangul *\/\n-  {\"koi\",       HB_TAG('K','O','P',' ')},       \/* Komi-Permyak *\/\n-  {\"koi\",       HB_TAG('K','O','M',' ')},       \/* Komi-Permyak -> Komi *\/\n-\/*{\"kok\",       HB_TAG('K','O','K',' ')},*\/     \/* Konkani [macrolanguage] *\/\n-  {\"kop\",       HB_TAG_NONE            },       \/* Waube != Komi-Permyak *\/\n-\/*{\"kos\",       HB_TAG('K','O','S',' ')},*\/     \/* Kosraean *\/\n-  {\"koy\",       HB_TAG('A','T','H',' ')},       \/* Koyukon -> Athapaskan *\/\n-  {\"koz\",       HB_TAG_NONE            },       \/* Korak != Komi-Zyrian *\/\n-  {\"kpe\",       HB_TAG('K','P','L',' ')},       \/* Kpelle [macrolanguage] *\/\n-  {\"kpl\",       HB_TAG_NONE            },       \/* Kpala != Kpelle *\/\n-  {\"kpp\",       HB_TAG('K','R','N',' ')},       \/* Paku Karen (retired code) -> Karen *\/\n-  {\"kpv\",       HB_TAG('K','O','Z',' ')},       \/* Komi-Zyrian *\/\n-  {\"kpv\",       HB_TAG('K','O','M',' ')},       \/* Komi-Zyrian -> Komi *\/\n-  {\"kpy\",       HB_TAG('K','Y','K',' ')},       \/* Koryak *\/\n-  {\"kqs\",       HB_TAG('K','I','S',' ')},       \/* Northern Kissi -> Kisii *\/\n-  {\"kqy\",       HB_TAG('K','R','T',' ')},       \/* Koorete *\/\n-  {\"kr\",        HB_TAG('K','N','R',' ')},       \/* Kanuri [macrolanguage] *\/\n-  {\"krc\",       HB_TAG('K','A','R',' ')},       \/* Karachay-Balkar -> Karachay *\/\n-  {\"krc\",       HB_TAG('B','A','L',' ')},       \/* Karachay-Balkar -> Balkar *\/\n-  {\"kri\",       HB_TAG('K','R','I',' ')},       \/* Krio *\/\n-  {\"kri\",       HB_TAG('C','P','P',' ')},       \/* Krio -> Creoles *\/\n-  {\"krk\",       HB_TAG_NONE            },       \/* Kerek != Karakalpak *\/\n-\/*{\"krl\",       HB_TAG('K','R','L',' ')},*\/     \/* Karelian *\/\n-  {\"krm\",       HB_TAG_NONE            },       \/* Krim (retired code) != Karaim *\/\n-  {\"krn\",       HB_TAG_NONE            },       \/* Sapo != Karen *\/\n-  {\"krt\",       HB_TAG('K','N','R',' ')},       \/* Tumari Kanuri -> Kanuri *\/\n-  {\"kru\",       HB_TAG('K','U','U',' ')},       \/* Kurukh *\/\n-  {\"ks\",        HB_TAG('K','S','H',' ')},       \/* Kashmiri *\/\n-  {\"ksh\",       HB_TAG('K','S','H','0')},       \/* Klsch -> Ripuarian *\/\n-  {\"ksi\",       HB_TAG_NONE            },       \/* Krisa != Khasi *\/\n-  {\"ksm\",       HB_TAG_NONE            },       \/* Kumba != Kildin Sami *\/\n-  {\"kss\",       HB_TAG('K','I','S',' ')},       \/* Southern Kisi -> Kisii *\/\n-  {\"ksw\",       HB_TAG('K','S','W',' ')},       \/* Sgaw Karen *\/\n-  {\"ksw\",       HB_TAG('K','R','N',' ')},       \/* S'gaw Karen -> Karen *\/\n-  {\"ktb\",       HB_TAG('K','E','B',' ')},       \/* Kambaata -> Kebena *\/\n-  {\"ktu\",       HB_TAG('K','O','N',' ')},       \/* Kituba (Democratic Republic of Congo) -> Kikongo *\/\n-  {\"ktw\",       HB_TAG('A','T','H',' ')},       \/* Kato -> Athapaskan *\/\n-  {\"ku\",        HB_TAG('K','U','R',' ')},       \/* Kurdish [macrolanguage] *\/\n-  {\"kui\",       HB_TAG_NONE            },       \/* Kuikro-Kalaplo != Kui *\/\n-  {\"kul\",       HB_TAG_NONE            },       \/* Kulere != Kulvi *\/\n-\/*{\"kum\",       HB_TAG('K','U','M',' ')},*\/     \/* Kumyk *\/\n-  {\"kuu\",       HB_TAG('A','T','H',' ')},       \/* Upper Kuskokwim -> Athapaskan *\/\n-  {\"kuw\",       HB_TAG('B','A','D','0')},       \/* Kpagua -> Banda *\/\n-  {\"kuy\",       HB_TAG_NONE            },       \/* Kuuku-Ya'u != Kuy *\/\n-  {\"kv\",        HB_TAG('K','O','M',' ')},       \/* Komi [macrolanguage] *\/\n-  {\"kvb\",       HB_TAG('M','L','Y',' ')},       \/* Kubu -> Malay *\/\n-  {\"kvl\",       HB_TAG('K','R','N',' ')},       \/* Kayaw -> Karen *\/\n-  {\"kvq\",       HB_TAG('K','R','N',' ')},       \/* Geba Karen -> Karen *\/\n-  {\"kvr\",       HB_TAG('M','L','Y',' ')},       \/* Kerinci -> Malay *\/\n-  {\"kvt\",       HB_TAG('K','R','N',' ')},       \/* Lahta Karen -> Karen *\/\n-  {\"kvu\",       HB_TAG('K','R','N',' ')},       \/* Yinbaw Karen -> Karen *\/\n-  {\"kvy\",       HB_TAG('K','R','N',' ')},       \/* Yintale Karen -> Karen *\/\n-  {\"kw\",        HB_TAG('C','O','R',' ')},       \/* Cornish *\/\n-  {\"kww\",       HB_TAG('C','P','P',' ')},       \/* Kwinti -> Creoles *\/\n-  {\"kwy\",       HB_TAG('K','O','N','0')},       \/* San Salvador Kongo -> Kongo *\/\n-  {\"kxc\",       HB_TAG('K','M','S',' ')},       \/* Konso -> Komso *\/\n-  {\"kxd\",       HB_TAG('M','L','Y',' ')},       \/* Brunei -> Malay *\/\n-  {\"kxf\",       HB_TAG('K','R','N',' ')},       \/* Manumanaw Karen -> Karen *\/\n-  {\"kxk\",       HB_TAG('K','R','N',' ')},       \/* Zayein Karen -> Karen *\/\n-  {\"kxl\",       HB_TAG('K','U','U',' ')},       \/* Nepali Kurux (retired code) -> Kurukh *\/\n-  {\"kxu\",       HB_TAG('K','U','I',' ')},       \/* Kui (India) (retired code) *\/\n-  {\"ky\",        HB_TAG('K','I','R',' ')},       \/* Kirghiz (Kyrgyz) *\/\n-  {\"kyk\",       HB_TAG_NONE            },       \/* Kamayo != Koryak *\/\n-  {\"kyu\",       HB_TAG('K','Y','U',' ')},       \/* Western Kayah *\/\n-  {\"kyu\",       HB_TAG('K','R','N',' ')},       \/* Western Kayah -> Karen *\/\n-  {\"la\",        HB_TAG('L','A','T',' ')},       \/* Latin *\/\n-  {\"lac\",       HB_TAG('M','Y','N',' ')},       \/* Lacandon -> Mayan *\/\n-  {\"lad\",       HB_TAG('J','U','D',' ')},       \/* Ladino *\/\n-  {\"lah\",       HB_TAG_NONE            },       \/* Lahnda [macrolanguage] != Lahuli *\/\n-  {\"lak\",       HB_TAG_NONE            },       \/* Laka (Nigeria) != Lak *\/\n-  {\"lam\",       HB_TAG_NONE            },       \/* Lamba != Lambani *\/\n-  {\"laz\",       HB_TAG_NONE            },       \/* Aribwatsa != Laz *\/\n-  {\"lb\",        HB_TAG('L','T','Z',' ')},       \/* Luxembourgish *\/\n-  {\"lbe\",       HB_TAG('L','A','K',' ')},       \/* Lak *\/\n-  {\"lbj\",       HB_TAG('L','D','K',' ')},       \/* Ladakhi *\/\n-  {\"lbl\",       HB_TAG('B','I','K',' ')},       \/* Libon Bikol -> Bikol *\/\n-  {\"lce\",       HB_TAG('M','L','Y',' ')},       \/* Loncong -> Malay *\/\n-  {\"lcf\",       HB_TAG('M','L','Y',' ')},       \/* Lubu -> Malay *\/\n-  {\"ldi\",       HB_TAG('K','O','N','0')},       \/* Laari -> Kongo *\/\n-  {\"ldk\",       HB_TAG_NONE            },       \/* Leelau != Ladakhi *\/\n-\/*{\"lez\",       HB_TAG('L','E','Z',' ')},*\/     \/* Lezghian -> Lezgi *\/\n-  {\"lg\",        HB_TAG('L','U','G',' ')},       \/* Ganda *\/\n-  {\"li\",        HB_TAG('L','I','M',' ')},       \/* Limburgish *\/\n-  {\"lif\",       HB_TAG('L','M','B',' ')},       \/* Limbu *\/\n-\/*{\"lij\",       HB_TAG('L','I','J',' ')},*\/     \/* Ligurian *\/\n-  {\"lir\",       HB_TAG('C','P','P',' ')},       \/* Liberian English -> Creoles *\/\n-\/*{\"lis\",       HB_TAG('L','I','S',' ')},*\/     \/* Lisu *\/\n-  {\"liw\",       HB_TAG('M','L','Y',' ')},       \/* Col -> Malay *\/\n-  {\"liy\",       HB_TAG('B','A','D','0')},       \/* Banda-Bambari -> Banda *\/\n-\/*{\"ljp\",       HB_TAG('L','J','P',' ')},*\/     \/* Lampung Api -> Lampung *\/\n-  {\"lkb\",       HB_TAG('L','U','H',' ')},       \/* Kabras -> Luyia *\/\n-\/*{\"lki\",       HB_TAG('L','K','I',' ')},*\/     \/* Laki *\/\n-  {\"lko\",       HB_TAG('L','U','H',' ')},       \/* Khayo -> Luyia *\/\n-  {\"lks\",       HB_TAG('L','U','H',' ')},       \/* Kisa -> Luyia *\/\n-  {\"lld\",       HB_TAG('L','A','D',' ')},       \/* Ladin *\/\n-  {\"lma\",       HB_TAG_NONE            },       \/* East Limba != Low Mari *\/\n-  {\"lmb\",       HB_TAG_NONE            },       \/* Merei != Limbu *\/\n-  {\"lmn\",       HB_TAG('L','A','M',' ')},       \/* Lambadi -> Lambani *\/\n-\/*{\"lmo\",       HB_TAG('L','M','O',' ')},*\/     \/* Lombard *\/\n-  {\"lmw\",       HB_TAG_NONE            },       \/* Lake Miwok != Lomwe *\/\n-  {\"ln\",        HB_TAG('L','I','N',' ')},       \/* Lingala *\/\n-  {\"lna\",       HB_TAG('B','A','D','0')},       \/* Langbashe -> Banda *\/\n-  {\"lnl\",       HB_TAG('B','A','D','0')},       \/* South Central Banda -> Banda *\/\n-  {\"lo\",        HB_TAG('L','A','O',' ')},       \/* Lao *\/\n-\/*{\"lom\",       HB_TAG('L','O','M',' ')},*\/     \/* Loma (Liberia) *\/\n-  {\"lou\",       HB_TAG('C','P','P',' ')},       \/* Louisiana Creole -> Creoles *\/\n-\/*{\"lrc\",       HB_TAG('L','R','C',' ')},*\/     \/* Northern Luri -> Luri *\/\n-  {\"lri\",       HB_TAG('L','U','H',' ')},       \/* Marachi -> Luyia *\/\n-  {\"lrm\",       HB_TAG('L','U','H',' ')},       \/* Marama -> Luyia *\/\n-  {\"lrt\",       HB_TAG('C','P','P',' ')},       \/* Larantuka Malay -> Creoles *\/\n-  {\"lsb\",       HB_TAG_NONE            },       \/* Burundian Sign Language != Lower Sorbian *\/\n-  {\"lsm\",       HB_TAG('L','U','H',' ')},       \/* Saamia -> Luyia *\/\n-  {\"lt\",        HB_TAG('L','T','H',' ')},       \/* Lithuanian *\/\n-  {\"ltg\",       HB_TAG('L','V','I',' ')},       \/* Latgalian -> Latvian *\/\n-  {\"lth\",       HB_TAG_NONE            },       \/* Thur != Lithuanian *\/\n-  {\"lto\",       HB_TAG('L','U','H',' ')},       \/* Tsotso -> Luyia *\/\n-  {\"lts\",       HB_TAG('L','U','H',' ')},       \/* Tachoni -> Luyia *\/\n-  {\"lu\",        HB_TAG('L','U','B',' ')},       \/* Luba-Katanga *\/\n-\/*{\"lua\",       HB_TAG('L','U','A',' ')},*\/     \/* Luba-Lulua *\/\n-\/*{\"luo\",       HB_TAG('L','U','O',' ')},*\/     \/* Luo (Kenya and Tanzania) *\/\n-  {\"lus\",       HB_TAG('M','I','Z',' ')},       \/* Lushai -> Mizo *\/\n-  {\"lus\",       HB_TAG('Q','I','N',' ')},       \/* Lushai -> Chin *\/\n-  {\"luy\",       HB_TAG('L','U','H',' ')},       \/* Luyia [macrolanguage] *\/\n-  {\"luz\",       HB_TAG('L','R','C',' ')},       \/* Southern Luri -> Luri *\/\n-  {\"lv\",        HB_TAG('L','V','I',' ')},       \/* Latvian [macrolanguage] *\/\n-  {\"lvi\",       HB_TAG_NONE            },       \/* Lavi != Latvian *\/\n-  {\"lvs\",       HB_TAG('L','V','I',' ')},       \/* Standard Latvian -> Latvian *\/\n-  {\"lwg\",       HB_TAG('L','U','H',' ')},       \/* Wanga -> Luyia *\/\n-  {\"lzh\",       HB_TAG('Z','H','T',' ')},       \/* Literary Chinese -> Chinese, Traditional *\/\n-  {\"lzz\",       HB_TAG('L','A','Z',' ')},       \/* Laz *\/\n-\/*{\"mad\",       HB_TAG('M','A','D',' ')},*\/     \/* Madurese -> Madura *\/\n-\/*{\"mag\",       HB_TAG('M','A','G',' ')},*\/     \/* Magahi *\/\n-  {\"mai\",       HB_TAG('M','T','H',' ')},       \/* Maithili *\/\n-  {\"maj\",       HB_TAG_NONE            },       \/* Jalapa De Daz Mazatec != Majang *\/\n-  {\"mak\",       HB_TAG('M','K','R',' ')},       \/* Makasar *\/\n-  {\"mam\",       HB_TAG('M','A','M',' ')},       \/* Mam *\/\n-  {\"mam\",       HB_TAG('M','Y','N',' ')},       \/* Mam -> Mayan *\/\n-  {\"man\",       HB_TAG('M','N','K',' ')},       \/* Mandingo [macrolanguage] -> Maninka *\/\n-  {\"map\",       HB_TAG_NONE            },       \/* Austronesian [family] != Mapudungun *\/\n-  {\"maw\",       HB_TAG_NONE            },       \/* Mampruli != Marwari *\/\n-  {\"max\",       HB_TAG('M','L','Y',' ')},       \/* North Moluccan Malay -> Malay *\/\n-  {\"max\",       HB_TAG('C','P','P',' ')},       \/* North Moluccan Malay -> Creoles *\/\n-  {\"mbf\",       HB_TAG('C','P','P',' ')},       \/* Baba Malay -> Creoles *\/\n-  {\"mbn\",       HB_TAG_NONE            },       \/* Macagun != Mbundu *\/\n-\/*{\"mbo\",       HB_TAG('M','B','O',' ')},*\/     \/* Mbo (Cameroon) *\/\n-  {\"mch\",       HB_TAG_NONE            },       \/* Maquiritari != Manchu *\/\n-  {\"mcm\",       HB_TAG('C','P','P',' ')},       \/* Malaccan Creole Portuguese -> Creoles *\/\n-  {\"mcr\",       HB_TAG_NONE            },       \/* Menya != Moose Cree *\/\n-  {\"mct\",       HB_TAG('B','T','I',' ')},       \/* Mengisa -> Beti *\/\n-  {\"mde\",       HB_TAG_NONE            },       \/* Maba (Chad) != Mende *\/\n-  {\"mdf\",       HB_TAG('M','O','K',' ')},       \/* Moksha *\/\n-\/*{\"mdr\",       HB_TAG('M','D','R',' ')},*\/     \/* Mandar *\/\n-  {\"mdy\",       HB_TAG('M','L','E',' ')},       \/* Male (Ethiopia) *\/\n-  {\"men\",       HB_TAG('M','D','E',' ')},       \/* Mende (Sierra Leone) *\/\n-  {\"meo\",       HB_TAG('M','L','Y',' ')},       \/* Kedah Malay -> Malay *\/\n-\/*{\"mer\",       HB_TAG('M','E','R',' ')},*\/     \/* Meru *\/\n-  {\"mfa\",       HB_TAG('M','F','A',' ')},       \/* Pattani Malay *\/\n-  {\"mfa\",       HB_TAG('M','L','Y',' ')},       \/* Pattani Malay -> Malay *\/\n-  {\"mfb\",       HB_TAG('M','L','Y',' ')},       \/* Bangka -> Malay *\/\n-  {\"mfe\",       HB_TAG('M','F','E',' ')},       \/* Morisyen *\/\n-  {\"mfe\",       HB_TAG('C','P','P',' ')},       \/* Morisyen -> Creoles *\/\n-  {\"mfp\",       HB_TAG('C','P','P',' ')},       \/* Makassar Malay -> Creoles *\/\n-  {\"mg\",        HB_TAG('M','L','G',' ')},       \/* Malagasy [macrolanguage] *\/\n-  {\"mh\",        HB_TAG('M','A','H',' ')},       \/* Marshallese *\/\n-  {\"mhc\",       HB_TAG('M','Y','N',' ')},       \/* Mocho -> Mayan *\/\n-  {\"mhr\",       HB_TAG('L','M','A',' ')},       \/* Eastern Mari -> Low Mari *\/\n-  {\"mhv\",       HB_TAG('A','R','K',' ')},       \/* Arakanese (retired code) -> Rakhine *\/\n-  {\"mi\",        HB_TAG('M','R','I',' ')},       \/* Maori *\/\n-  {\"min\",       HB_TAG('M','I','N',' ')},       \/* Minangkabau *\/\n-  {\"min\",       HB_TAG('M','L','Y',' ')},       \/* Minangkabau -> Malay *\/\n-  {\"miz\",       HB_TAG_NONE            },       \/* Coatzospan Mixtec != Mizo *\/\n-  {\"mk\",        HB_TAG('M','K','D',' ')},       \/* Macedonian *\/\n-  {\"mkn\",       HB_TAG('C','P','P',' ')},       \/* Kupang Malay -> Creoles *\/\n-  {\"mkr\",       HB_TAG_NONE            },       \/* Malas != Makasar *\/\n-  {\"mku\",       HB_TAG('M','N','K',' ')},       \/* Konyanka Maninka -> Maninka *\/\n-\/*{\"mkw\",       HB_TAG('M','K','W',' ')},*\/     \/* Kituba (Congo) *\/\n-  {\"ml\",        HB_TAG('M','A','L',' ')},       \/* Malayalam -> Malayalam Traditional *\/\n-  {\"ml\",        HB_TAG('M','L','R',' ')},       \/* Malayalam -> Malayalam Reformed *\/\n-  {\"mle\",       HB_TAG_NONE            },       \/* Manambu != Male *\/\n-  {\"mln\",       HB_TAG_NONE            },       \/* Malango != Malinke *\/\n-  {\"mlq\",       HB_TAG('M','L','N',' ')},       \/* Western Maninkakan -> Malinke *\/\n-  {\"mlq\",       HB_TAG('M','N','K',' ')},       \/* Western Maninkakan -> Maninka *\/\n-  {\"mlr\",       HB_TAG_NONE            },       \/* Vame != Malayalam Reformed *\/\n-  {\"mmr\",       HB_TAG('H','M','N',' ')},       \/* Western Xiangxi Miao -> Hmong *\/\n-  {\"mn\",        HB_TAG('M','N','G',' ')},       \/* Mongolian [macrolanguage] *\/\n-  {\"mnc\",       HB_TAG('M','C','H',' ')},       \/* Manchu *\/\n-  {\"mnd\",       HB_TAG_NONE            },       \/* Mond != Mandinka *\/\n-  {\"mng\",       HB_TAG_NONE            },       \/* Eastern Mnong != Mongolian *\/\n-  {\"mnh\",       HB_TAG('B','A','D','0')},       \/* Mono (Democratic Republic of Congo) -> Banda *\/\n-\/*{\"mni\",       HB_TAG('M','N','I',' ')},*\/     \/* Manipuri *\/\n-  {\"mnk\",       HB_TAG('M','N','D',' ')},       \/* Mandinka *\/\n-  {\"mnk\",       HB_TAG('M','N','K',' ')},       \/* Mandinka -> Maninka *\/\n-  {\"mnp\",       HB_TAG('Z','H','S',' ')},       \/* Min Bei Chinese -> Chinese, Simplified *\/\n-  {\"mns\",       HB_TAG('M','A','N',' ')},       \/* Mansi *\/\n-  {\"mnw\",       HB_TAG('M','O','N',' ')},       \/* Mon *\/\n-  {\"mnx\",       HB_TAG_NONE            },       \/* Manikion != Manx *\/\n-  {\"mo\",        HB_TAG('M','O','L',' ')},       \/* Moldavian (retired code) *\/\n-  {\"mod\",       HB_TAG('C','P','P',' ')},       \/* Mobilian -> Creoles *\/\n-\/*{\"moh\",       HB_TAG('M','O','H',' ')},*\/     \/* Mohawk *\/\n-  {\"mok\",       HB_TAG_NONE            },       \/* Morori != Moksha *\/\n-  {\"mop\",       HB_TAG('M','Y','N',' ')},       \/* Mopn Maya -> Mayan *\/\n-  {\"mor\",       HB_TAG_NONE            },       \/* Moro != Moroccan *\/\n-\/*{\"mos\",       HB_TAG('M','O','S',' ')},*\/     \/* Mossi *\/\n-  {\"mpe\",       HB_TAG('M','A','J',' ')},       \/* Majang *\/\n-  {\"mqg\",       HB_TAG('M','L','Y',' ')},       \/* Kota Bangun Kutai Malay -> Malay *\/\n-  {\"mr\",        HB_TAG('M','A','R',' ')},       \/* Marathi *\/\n-  {\"mrh\",       HB_TAG('Q','I','N',' ')},       \/* Mara Chin -> Chin *\/\n-  {\"mrj\",       HB_TAG('H','M','A',' ')},       \/* Western Mari -> High Mari *\/\n-  {\"ms\",        HB_TAG('M','L','Y',' ')},       \/* Malay [macrolanguage] *\/\n-  {\"msc\",       HB_TAG('M','N','K',' ')},       \/* Sankaran Maninka -> Maninka *\/\n-  {\"msh\",       HB_TAG('M','L','G',' ')},       \/* Masikoro Malagasy -> Malagasy *\/\n-  {\"msi\",       HB_TAG('M','L','Y',' ')},       \/* Sabah Malay -> Malay *\/\n-  {\"msi\",       HB_TAG('C','P','P',' ')},       \/* Sabah Malay -> Creoles *\/\n-  {\"mt\",        HB_TAG('M','T','S',' ')},       \/* Maltese *\/\n-  {\"mth\",       HB_TAG_NONE            },       \/* Munggui != Maithili *\/\n-  {\"mtr\",       HB_TAG('M','A','W',' ')},       \/* Mewari -> Marwari *\/\n-  {\"mts\",       HB_TAG_NONE            },       \/* Yora != Maltese *\/\n-  {\"mud\",       HB_TAG('C','P','P',' ')},       \/* Mednyj Aleut -> Creoles *\/\n-  {\"mui\",       HB_TAG('M','L','Y',' ')},       \/* Musi -> Malay *\/\n-  {\"mun\",       HB_TAG_NONE            },       \/* Munda [family] != Mundari *\/\n-  {\"mup\",       HB_TAG('R','A','J',' ')},       \/* Malvi -> Rajasthani *\/\n-  {\"muq\",       HB_TAG('H','M','N',' ')},       \/* Eastern Xiangxi Miao -> Hmong *\/\n-\/*{\"mus\",       HB_TAG('M','U','S',' ')},*\/     \/* Creek -> Muscogee *\/\n-  {\"mvb\",       HB_TAG('A','T','H',' ')},       \/* Mattole -> Athapaskan *\/\n-  {\"mve\",       HB_TAG('M','A','W',' ')},       \/* Marwari (Pakistan) *\/\n-  {\"mvf\",       HB_TAG('M','N','G',' ')},       \/* Peripheral Mongolian -> Mongolian *\/\n-  {\"mwk\",       HB_TAG('M','N','K',' ')},       \/* Kita Maninkakan -> Maninka *\/\n-\/*{\"mwl\",       HB_TAG('M','W','L',' ')},*\/     \/* Mirandese *\/\n-  {\"mwq\",       HB_TAG('Q','I','N',' ')},       \/* Mn Chin -> Chin *\/\n-  {\"mwr\",       HB_TAG('M','A','W',' ')},       \/* Marwari [macrolanguage] *\/\n-  {\"mww\",       HB_TAG('M','W','W',' ')},       \/* Hmong Daw *\/\n-  {\"mww\",       HB_TAG('H','M','N',' ')},       \/* Hmong Daw -> Hmong *\/\n-  {\"my\",        HB_TAG('B','R','M',' ')},       \/* Burmese *\/\n-  {\"mym\",       HB_TAG('M','E','N',' ')},       \/* Meen *\/\n-\/*{\"myn\",       HB_TAG('M','Y','N',' ')},*\/     \/* Mayan [family] *\/\n-  {\"myq\",       HB_TAG('M','N','K',' ')},       \/* Forest Maninka (retired code) -> Maninka *\/\n-  {\"myv\",       HB_TAG('E','R','Z',' ')},       \/* Erzya *\/\n-  {\"mzb\",       HB_TAG('B','B','R',' ')},       \/* Tumzabt -> Berber *\/\n-\/*{\"mzn\",       HB_TAG('M','Z','N',' ')},*\/     \/* Mazanderani *\/\n-  {\"mzs\",       HB_TAG('C','P','P',' ')},       \/* Macanese -> Creoles *\/\n-  {\"na\",        HB_TAG('N','A','U',' ')},       \/* Nauru -> Nauruan *\/\n-  {\"nag\",       HB_TAG('N','A','G',' ')},       \/* Naga Pidgin -> Naga-Assamese *\/\n-  {\"nag\",       HB_TAG('C','P','P',' ')},       \/* Naga Pidgin -> Creoles *\/\n-\/*{\"nah\",       HB_TAG('N','A','H',' ')},*\/     \/* Nahuatl [family] *\/\n-  {\"nan\",       HB_TAG('Z','H','S',' ')},       \/* Min Nan Chinese -> Chinese, Simplified *\/\n-\/*{\"nap\",       HB_TAG('N','A','P',' ')},*\/     \/* Neapolitan *\/\n-  {\"nas\",       HB_TAG_NONE            },       \/* Naasioi != Naskapi *\/\n-  {\"naz\",       HB_TAG('N','A','H',' ')},       \/* Coatepec Nahuatl -> Nahuatl *\/\n-  {\"nb\",        HB_TAG('N','O','R',' ')},       \/* Norwegian Bokml -> Norwegian *\/\n-  {\"nch\",       HB_TAG('N','A','H',' ')},       \/* Central Huasteca Nahuatl -> Nahuatl *\/\n-  {\"nci\",       HB_TAG('N','A','H',' ')},       \/* Classical Nahuatl -> Nahuatl *\/\n-  {\"ncj\",       HB_TAG('N','A','H',' ')},       \/* Northern Puebla Nahuatl -> Nahuatl *\/\n-  {\"ncl\",       HB_TAG('N','A','H',' ')},       \/* Michoacn Nahuatl -> Nahuatl *\/\n-  {\"ncr\",       HB_TAG_NONE            },       \/* Ncane != N-Cree *\/\n-  {\"ncx\",       HB_TAG('N','A','H',' ')},       \/* Central Puebla Nahuatl -> Nahuatl *\/\n-  {\"nd\",        HB_TAG('N','D','B',' ')},       \/* North Ndebele -> Ndebele *\/\n-  {\"ndb\",       HB_TAG_NONE            },       \/* Kenswei Nsei != Ndebele *\/\n-\/*{\"ndc\",       HB_TAG('N','D','C',' ')},*\/     \/* Ndau *\/\n-  {\"ndg\",       HB_TAG_NONE            },       \/* Ndengereko != Ndonga *\/\n-\/*{\"nds\",       HB_TAG('N','D','S',' ')},*\/     \/* Low Saxon *\/\n-  {\"ne\",        HB_TAG('N','E','P',' ')},       \/* Nepali [macrolanguage] *\/\n-  {\"nef\",       HB_TAG('C','P','P',' ')},       \/* Nefamese -> Creoles *\/\n-\/*{\"new\",       HB_TAG('N','E','W',' ')},*\/     \/* Newari *\/\n-  {\"ng\",        HB_TAG('N','D','G',' ')},       \/* Ndonga *\/\n-\/*{\"nga\",       HB_TAG('N','G','A',' ')},*\/     \/* Ngbaka *\/\n-  {\"ngl\",       HB_TAG('L','M','W',' ')},       \/* Lomwe *\/\n-  {\"ngm\",       HB_TAG('C','P','P',' ')},       \/* Ngatik Men's Creole -> Creoles *\/\n-  {\"ngo\",       HB_TAG('S','X','T',' ')},       \/* Ngoni (retired code) -> Sutu *\/\n-  {\"ngr\",       HB_TAG_NONE            },       \/* Engdewu != Nagari *\/\n-  {\"ngu\",       HB_TAG('N','A','H',' ')},       \/* Guerrero Nahuatl -> Nahuatl *\/\n-  {\"nhc\",       HB_TAG('N','A','H',' ')},       \/* Tabasco Nahuatl -> Nahuatl *\/\n-  {\"nhd\",       HB_TAG('G','U','A',' ')},       \/* Chirip -> Guarani *\/\n-  {\"nhe\",       HB_TAG('N','A','H',' ')},       \/* Eastern Huasteca Nahuatl -> Nahuatl *\/\n-  {\"nhg\",       HB_TAG('N','A','H',' ')},       \/* Tetelcingo Nahuatl -> Nahuatl *\/\n-  {\"nhi\",       HB_TAG('N','A','H',' ')},       \/* Zacatln-Ahuacatln-Tepetzintla Nahuatl -> Nahuatl *\/\n-  {\"nhk\",       HB_TAG('N','A','H',' ')},       \/* Isthmus-Cosoleacaque Nahuatl -> Nahuatl *\/\n-  {\"nhm\",       HB_TAG('N','A','H',' ')},       \/* Morelos Nahuatl -> Nahuatl *\/\n-  {\"nhn\",       HB_TAG('N','A','H',' ')},       \/* Central Nahuatl -> Nahuatl *\/\n-  {\"nhp\",       HB_TAG('N','A','H',' ')},       \/* Isthmus-Pajapan Nahuatl -> Nahuatl *\/\n-  {\"nhq\",       HB_TAG('N','A','H',' ')},       \/* Huaxcaleca Nahuatl -> Nahuatl *\/\n-  {\"nht\",       HB_TAG('N','A','H',' ')},       \/* Ometepec Nahuatl -> Nahuatl *\/\n-  {\"nhv\",       HB_TAG('N','A','H',' ')},       \/* Temascaltepec Nahuatl -> Nahuatl *\/\n-  {\"nhw\",       HB_TAG('N','A','H',' ')},       \/* Western Huasteca Nahuatl -> Nahuatl *\/\n-  {\"nhx\",       HB_TAG('N','A','H',' ')},       \/* Isthmus-Mecayapan Nahuatl -> Nahuatl *\/\n-  {\"nhy\",       HB_TAG('N','A','H',' ')},       \/* Northern Oaxaca Nahuatl -> Nahuatl *\/\n-  {\"nhz\",       HB_TAG('N','A','H',' ')},       \/* Santa Mara La Alta Nahuatl -> Nahuatl *\/\n-  {\"niq\",       HB_TAG('K','A','L',' ')},       \/* Nandi -> Kalenjin *\/\n-  {\"nis\",       HB_TAG_NONE            },       \/* Nimi != Nisi *\/\n-\/*{\"niu\",       HB_TAG('N','I','U',' ')},*\/     \/* Niuean *\/\n-  {\"niv\",       HB_TAG('G','I','L',' ')},       \/* Gilyak *\/\n-  {\"njt\",       HB_TAG('C','P','P',' ')},       \/* Ndyuka-Trio Pidgin -> Creoles *\/\n-  {\"njz\",       HB_TAG('N','I','S',' ')},       \/* Nyishi -> Nisi *\/\n-  {\"nko\",       HB_TAG_NONE            },       \/* Nkonya != NKo *\/\n-  {\"nkx\",       HB_TAG('I','J','O',' ')},       \/* Nkoroo -> Ijo *\/\n-  {\"nl\",        HB_TAG('N','L','D',' ')},       \/* Dutch *\/\n-  {\"nla\",       HB_TAG('B','M','L',' ')},       \/* Ngombale -> Bamileke *\/\n-  {\"nle\",       HB_TAG('L','U','H',' ')},       \/* East Nyala -> Luyia *\/\n-  {\"nln\",       HB_TAG('N','A','H',' ')},       \/* Durango Nahuatl (retired code) -> Nahuatl *\/\n-  {\"nlv\",       HB_TAG('N','A','H',' ')},       \/* Orizaba Nahuatl -> Nahuatl *\/\n-  {\"nn\",        HB_TAG('N','Y','N',' ')},       \/* Norwegian Nynorsk (Nynorsk, Norwegian) *\/\n-  {\"nn\",        HB_TAG('N','O','R',' ')},       \/* Norwegian Nynorsk -> Norwegian *\/\n-  {\"nnh\",       HB_TAG('B','M','L',' ')},       \/* Ngiemboon -> Bamileke *\/\n-  {\"nnz\",       HB_TAG('B','M','L',' ')},       \/* Nda'nda' -> Bamileke *\/\n-  {\"no\",        HB_TAG('N','O','R',' ')},       \/* Norwegian [macrolanguage] *\/\n-  {\"nod\",       HB_TAG('N','T','A',' ')},       \/* Northern Thai -> Northern Tai *\/\n-\/*{\"noe\",       HB_TAG('N','O','E',' ')},*\/     \/* Nimadi *\/\n-\/*{\"nog\",       HB_TAG('N','O','G',' ')},*\/     \/* Nogai *\/\n-\/*{\"nov\",       HB_TAG('N','O','V',' ')},*\/     \/* Novial *\/\n-  {\"npi\",       HB_TAG('N','E','P',' ')},       \/* Nepali *\/\n-  {\"npl\",       HB_TAG('N','A','H',' ')},       \/* Southeastern Puebla Nahuatl -> Nahuatl *\/\n-  {\"nqo\",       HB_TAG('N','K','O',' ')},       \/* NKo *\/\n-  {\"nr\",        HB_TAG('N','D','B',' ')},       \/* South Ndebele -> Ndebele *\/\n-  {\"nsk\",       HB_TAG('N','A','S',' ')},       \/* Naskapi *\/\n-  {\"nsm\",       HB_TAG_NONE            },       \/* Sumi Naga != Northern Sami *\/\n-\/*{\"nso\",       HB_TAG('N','S','O',' ')},*\/     \/* Northern Sotho *\/\n-  {\"nsu\",       HB_TAG('N','A','H',' ')},       \/* Sierra Negra Nahuatl -> Nahuatl *\/\n-  {\"nto\",       HB_TAG_NONE            },       \/* Ntomba != Esperanto *\/\n-  {\"nue\",       HB_TAG('B','A','D','0')},       \/* Ngundu -> Banda *\/\n-  {\"nuu\",       HB_TAG('B','A','D','0')},       \/* Ngbundu -> Banda *\/\n-  {\"nuz\",       HB_TAG('N','A','H',' ')},       \/* Tlamacazapa Nahuatl -> Nahuatl *\/\n-  {\"nv\",        HB_TAG('N','A','V',' ')},       \/* Navajo *\/\n-  {\"nv\",        HB_TAG('A','T','H',' ')},       \/* Navajo -> Athapaskan *\/\n-  {\"nwe\",       HB_TAG('B','M','L',' ')},       \/* Ngwe -> Bamileke *\/\n-  {\"ny\",        HB_TAG('C','H','I',' ')},       \/* Chichewa (Chewa, Nyanja) *\/\n-  {\"nyd\",       HB_TAG('L','U','H',' ')},       \/* Nyore -> Luyia *\/\n-\/*{\"nym\",       HB_TAG('N','Y','M',' ')},*\/     \/* Nyamwezi *\/\n-  {\"nyn\",       HB_TAG('N','K','L',' ')},       \/* Nyankole *\/\n-\/*{\"nza\",       HB_TAG('N','Z','A',' ')},*\/     \/* Tigon Mbembe -> Mbembe Tigon *\/\n-  {\"oc\",        HB_TAG('O','C','I',' ')},       \/* Occitan (post 1500) *\/\n-  {\"oj\",        HB_TAG('O','J','B',' ')},       \/* Ojibwa [macrolanguage] -> Ojibway *\/\n-\/*{\"ojb\",       HB_TAG('O','J','B',' ')},*\/     \/* Northwestern Ojibwa -> Ojibway *\/\n-  {\"ojc\",       HB_TAG('O','J','B',' ')},       \/* Central Ojibwa -> Ojibway *\/\n-  {\"ojg\",       HB_TAG('O','J','B',' ')},       \/* Eastern Ojibwa -> Ojibway *\/\n-  {\"ojs\",       HB_TAG('O','C','R',' ')},       \/* Severn Ojibwa -> Oji-Cree *\/\n-  {\"ojs\",       HB_TAG('O','J','B',' ')},       \/* Severn Ojibwa -> Ojibway *\/\n-  {\"ojw\",       HB_TAG('O','J','B',' ')},       \/* Western Ojibwa -> Ojibway *\/\n-  {\"okd\",       HB_TAG('I','J','O',' ')},       \/* Okodia -> Ijo *\/\n-  {\"oki\",       HB_TAG('K','A','L',' ')},       \/* Okiek -> Kalenjin *\/\n-  {\"okm\",       HB_TAG('K','O','H',' ')},       \/* Middle Korean (10th-16th cent.) -> Korean Old Hangul *\/\n-  {\"okr\",       HB_TAG('I','J','O',' ')},       \/* Kirike -> Ijo *\/\n-  {\"om\",        HB_TAG('O','R','O',' ')},       \/* Oromo [macrolanguage] *\/\n-  {\"onx\",       HB_TAG('C','P','P',' ')},       \/* Onin Based Pidgin -> Creoles *\/\n-  {\"oor\",       HB_TAG('C','P','P',' ')},       \/* Oorlams -> Creoles *\/\n-  {\"or\",        HB_TAG('O','R','I',' ')},       \/* Odia (formerly Oriya) [macrolanguage] *\/\n-  {\"orc\",       HB_TAG('O','R','O',' ')},       \/* Orma -> Oromo *\/\n-  {\"orn\",       HB_TAG('M','L','Y',' ')},       \/* Orang Kanaq -> Malay *\/\n-  {\"oro\",       HB_TAG_NONE            },       \/* Orokolo != Oromo *\/\n-  {\"orr\",       HB_TAG('I','J','O',' ')},       \/* Oruma -> Ijo *\/\n-  {\"ors\",       HB_TAG('M','L','Y',' ')},       \/* Orang Seletar -> Malay *\/\n-  {\"ory\",       HB_TAG('O','R','I',' ')},       \/* Odia (formerly Oriya) *\/\n-  {\"os\",        HB_TAG('O','S','S',' ')},       \/* Ossetian *\/\n-  {\"otw\",       HB_TAG('O','J','B',' ')},       \/* Ottawa -> Ojibway *\/\n-  {\"oua\",       HB_TAG('B','B','R',' ')},       \/* Tagargrent -> Berber *\/\n-  {\"pa\",        HB_TAG('P','A','N',' ')},       \/* Punjabi *\/\n-  {\"paa\",       HB_TAG_NONE            },       \/* Papuan [family] != Palestinian Aramaic *\/\n-\/*{\"pag\",       HB_TAG('P','A','G',' ')},*\/     \/* Pangasinan *\/\n-  {\"pal\",       HB_TAG_NONE            },       \/* Pahlavi != Pali *\/\n-\/*{\"pam\",       HB_TAG('P','A','M',' ')},*\/     \/* Pampanga -> Pampangan *\/\n-  {\"pap\",       HB_TAG('P','A','P','0')},       \/* Papiamento -> Papiamentu *\/\n-  {\"pap\",       HB_TAG('C','P','P',' ')},       \/* Papiamento -> Creoles *\/\n-  {\"pas\",       HB_TAG_NONE            },       \/* Papasena != Pashto *\/\n-\/*{\"pau\",       HB_TAG('P','A','U',' ')},*\/     \/* Palauan *\/\n-  {\"pbt\",       HB_TAG('P','A','S',' ')},       \/* Southern Pashto -> Pashto *\/\n-  {\"pbu\",       HB_TAG('P','A','S',' ')},       \/* Northern Pashto -> Pashto *\/\n-\/*{\"pcc\",       HB_TAG('P','C','C',' ')},*\/     \/* Bouyei *\/\n-\/*{\"pcd\",       HB_TAG('P','C','D',' ')},*\/     \/* Picard *\/\n-  {\"pce\",       HB_TAG('P','L','G',' ')},       \/* Ruching Palaung -> Palaung *\/\n-  {\"pck\",       HB_TAG('Q','I','N',' ')},       \/* Paite Chin -> Chin *\/\n-  {\"pcm\",       HB_TAG('C','P','P',' ')},       \/* Nigerian Pidgin -> Creoles *\/\n-\/*{\"pdc\",       HB_TAG('P','D','C',' ')},*\/     \/* Pennsylvania German *\/\n-  {\"pdu\",       HB_TAG('K','R','N',' ')},       \/* Kayan -> Karen *\/\n-  {\"pea\",       HB_TAG('C','P','P',' ')},       \/* Peranakan Indonesian -> Creoles *\/\n-  {\"pel\",       HB_TAG('M','L','Y',' ')},       \/* Pekal -> Malay *\/\n-  {\"pes\",       HB_TAG('F','A','R',' ')},       \/* Iranian Persian -> Persian *\/\n-  {\"pey\",       HB_TAG('C','P','P',' ')},       \/* Petjo -> Creoles *\/\n-  {\"pga\",       HB_TAG('A','R','A',' ')},       \/* Sudanese Creole Arabic -> Arabic *\/\n-  {\"pga\",       HB_TAG('C','P','P',' ')},       \/* Sudanese Creole Arabic -> Creoles *\/\n-\/*{\"phk\",       HB_TAG('P','H','K',' ')},*\/     \/* Phake *\/\n-  {\"pi\",        HB_TAG('P','A','L',' ')},       \/* Pali *\/\n-  {\"pih\",       HB_TAG('P','I','H',' ')},       \/* Pitcairn-Norfolk -> Norfolk *\/\n-  {\"pih\",       HB_TAG('C','P','P',' ')},       \/* Pitcairn-Norfolk -> Creoles *\/\n-  {\"pil\",       HB_TAG_NONE            },       \/* Yom != Filipino *\/\n-  {\"pis\",       HB_TAG('C','P','P',' ')},       \/* Pijin -> Creoles *\/\n-  {\"pkh\",       HB_TAG('Q','I','N',' ')},       \/* Pankhu -> Chin *\/\n-  {\"pko\",       HB_TAG('K','A','L',' ')},       \/* Pkoot -> Kalenjin *\/\n-  {\"pl\",        HB_TAG('P','L','K',' ')},       \/* Polish *\/\n-  {\"plg\",       HB_TAG_NONE            },       \/* Pilag != Palaung *\/\n-  {\"plk\",       HB_TAG_NONE            },       \/* Kohistani Shina != Polish *\/\n-  {\"pll\",       HB_TAG('P','L','G',' ')},       \/* Shwe Palaung -> Palaung *\/\n-  {\"pln\",       HB_TAG('C','P','P',' ')},       \/* Palenquero -> Creoles *\/\n-  {\"plp\",       HB_TAG('P','A','P',' ')},       \/* Palpa (retired code) *\/\n-  {\"plt\",       HB_TAG('M','L','G',' ')},       \/* Plateau Malagasy -> Malagasy *\/\n-  {\"pml\",       HB_TAG('C','P','P',' ')},       \/* Lingua Franca -> Creoles *\/\n-\/*{\"pms\",       HB_TAG('P','M','S',' ')},*\/     \/* Piemontese *\/\n-  {\"pmy\",       HB_TAG('C','P','P',' ')},       \/* Papuan Malay -> Creoles *\/\n-\/*{\"pnb\",       HB_TAG('P','N','B',' ')},*\/     \/* Western Panjabi *\/\n-  {\"poc\",       HB_TAG('M','Y','N',' ')},       \/* Poqomam -> Mayan *\/\n-  {\"poh\",       HB_TAG('P','O','H',' ')},       \/* Poqomchi' -> Pocomchi *\/\n-  {\"poh\",       HB_TAG('M','Y','N',' ')},       \/* Poqomchi' -> Mayan *\/\n-\/*{\"pon\",       HB_TAG('P','O','N',' ')},*\/     \/* Pohnpeian *\/\n-  {\"pov\",       HB_TAG('C','P','P',' ')},       \/* Upper Guinea Crioulo -> Creoles *\/\n-  {\"ppa\",       HB_TAG('B','A','G',' ')},       \/* Pao (retired code) -> Baghelkhandi *\/\n-  {\"pre\",       HB_TAG('C','P','P',' ')},       \/* Principense -> Creoles *\/\n-\/*{\"pro\",       HB_TAG('P','R','O',' ')},*\/     \/* Old Provenal (to 1500) -> Provenal \/ Old Provenal *\/\n-  {\"prs\",       HB_TAG('D','R','I',' ')},       \/* Dari *\/\n-  {\"prs\",       HB_TAG('F','A','R',' ')},       \/* Dari -> Persian *\/\n-  {\"ps\",        HB_TAG('P','A','S',' ')},       \/* Pashto [macrolanguage] *\/\n-  {\"pse\",       HB_TAG('M','L','Y',' ')},       \/* Central Malay -> Malay *\/\n-  {\"pst\",       HB_TAG('P','A','S',' ')},       \/* Central Pashto -> Pashto *\/\n-  {\"pt\",        HB_TAG('P','T','G',' ')},       \/* Portuguese *\/\n-  {\"pub\",       HB_TAG('Q','I','N',' ')},       \/* Purum -> Chin *\/\n-  {\"puz\",       HB_TAG('Q','I','N',' ')},       \/* Purum Naga (retired code) -> Chin *\/\n-  {\"pwo\",       HB_TAG('P','W','O',' ')},       \/* Pwo Western Karen -> Western Pwo Karen *\/\n-  {\"pwo\",       HB_TAG('K','R','N',' ')},       \/* Pwo Western Karen -> Karen *\/\n-  {\"pww\",       HB_TAG('K','R','N',' ')},       \/* Pwo Northern Karen -> Karen *\/\n-  {\"qu\",        HB_TAG('Q','U','Z',' ')},       \/* Quechua [macrolanguage] *\/\n-  {\"qub\",       HB_TAG('Q','W','H',' ')},       \/* Huallaga Hunuco Quechua -> Quechua (Peru) *\/\n-  {\"qub\",       HB_TAG('Q','U','Z',' ')},       \/* Huallaga Hunuco Quechua -> Quechua *\/\n-  {\"quc\",       HB_TAG('Q','U','C',' ')},       \/* Kiche *\/\n-  {\"quc\",       HB_TAG('M','Y','N',' ')},       \/* K'iche' -> Mayan *\/\n-  {\"qud\",       HB_TAG('Q','V','I',' ')},       \/* Caldern Highland Quichua -> Quechua (Ecuador) *\/\n-  {\"qud\",       HB_TAG('Q','U','Z',' ')},       \/* Caldern Highland Quichua -> Quechua *\/\n-  {\"quf\",       HB_TAG('Q','U','Z',' ')},       \/* Lambayeque Quechua -> Quechua *\/\n-  {\"qug\",       HB_TAG('Q','V','I',' ')},       \/* Chimborazo Highland Quichua -> Quechua (Ecuador) *\/\n-  {\"qug\",       HB_TAG('Q','U','Z',' ')},       \/* Chimborazo Highland Quichua -> Quechua *\/\n-  {\"quh\",       HB_TAG('Q','U','H',' ')},       \/* South Bolivian Quechua -> Quechua (Bolivia) *\/\n-  {\"quh\",       HB_TAG('Q','U','Z',' ')},       \/* South Bolivian Quechua -> Quechua *\/\n-  {\"quk\",       HB_TAG('Q','U','Z',' ')},       \/* Chachapoyas Quechua -> Quechua *\/\n-  {\"qul\",       HB_TAG('Q','U','H',' ')},       \/* North Bolivian Quechua -> Quechua (Bolivia) *\/\n-  {\"qul\",       HB_TAG('Q','U','Z',' ')},       \/* North Bolivian Quechua -> Quechua *\/\n-  {\"qum\",       HB_TAG('M','Y','N',' ')},       \/* Sipacapense -> Mayan *\/\n-  {\"qup\",       HB_TAG('Q','V','I',' ')},       \/* Southern Pastaza Quechua -> Quechua (Ecuador) *\/\n-  {\"qup\",       HB_TAG('Q','U','Z',' ')},       \/* Southern Pastaza Quechua -> Quechua *\/\n-  {\"qur\",       HB_TAG('Q','W','H',' ')},       \/* Yanahuanca Pasco Quechua -> Quechua (Peru) *\/\n-  {\"qur\",       HB_TAG('Q','U','Z',' ')},       \/* Yanahuanca Pasco Quechua -> Quechua *\/\n-  {\"qus\",       HB_TAG('Q','U','H',' ')},       \/* Santiago del Estero Quichua -> Quechua (Bolivia) *\/\n-  {\"qus\",       HB_TAG('Q','U','Z',' ')},       \/* Santiago del Estero Quichua -> Quechua *\/\n-  {\"quv\",       HB_TAG('M','Y','N',' ')},       \/* Sacapulteco -> Mayan *\/\n-  {\"quw\",       HB_TAG('Q','V','I',' ')},       \/* Tena Lowland Quichua -> Quechua (Ecuador) *\/\n-  {\"quw\",       HB_TAG('Q','U','Z',' ')},       \/* Tena Lowland Quichua -> Quechua *\/\n-  {\"qux\",       HB_TAG('Q','W','H',' ')},       \/* Yauyos Quechua -> Quechua (Peru) *\/\n-  {\"qux\",       HB_TAG('Q','U','Z',' ')},       \/* Yauyos Quechua -> Quechua *\/\n-  {\"quy\",       HB_TAG('Q','U','Z',' ')},       \/* Ayacucho Quechua -> Quechua *\/\n-\/*{\"quz\",       HB_TAG('Q','U','Z',' ')},*\/     \/* Cusco Quechua -> Quechua *\/\n-  {\"qva\",       HB_TAG('Q','W','H',' ')},       \/* Ambo-Pasco Quechua -> Quechua (Peru) *\/\n-  {\"qva\",       HB_TAG('Q','U','Z',' ')},       \/* Ambo-Pasco Quechua -> Quechua *\/\n-  {\"qvc\",       HB_TAG('Q','U','Z',' ')},       \/* Cajamarca Quechua -> Quechua *\/\n-  {\"qve\",       HB_TAG('Q','U','Z',' ')},       \/* Eastern Apurmac Quechua -> Quechua *\/\n-  {\"qvh\",       HB_TAG('Q','W','H',' ')},       \/* Huamales-Dos de Mayo Hunuco Quechua -> Quechua (Peru) *\/\n-  {\"qvh\",       HB_TAG('Q','U','Z',' ')},       \/* Huamales-Dos de Mayo Hunuco Quechua -> Quechua *\/\n-  {\"qvi\",       HB_TAG('Q','V','I',' ')},       \/* Imbabura Highland Quichua -> Quechua (Ecuador) *\/\n-  {\"qvi\",       HB_TAG('Q','U','Z',' ')},       \/* Imbabura Highland Quichua -> Quechua *\/\n-  {\"qvj\",       HB_TAG('Q','V','I',' ')},       \/* Loja Highland Quichua -> Quechua (Ecuador) *\/\n-  {\"qvj\",       HB_TAG('Q','U','Z',' ')},       \/* Loja Highland Quichua -> Quechua *\/\n-  {\"qvl\",       HB_TAG('Q','W','H',' ')},       \/* Cajatambo North Lima Quechua -> Quechua (Peru) *\/\n-  {\"qvl\",       HB_TAG('Q','U','Z',' ')},       \/* Cajatambo North Lima Quechua -> Quechua *\/\n-  {\"qvm\",       HB_TAG('Q','W','H',' ')},       \/* Margos-Yarowilca-Lauricocha Quechua -> Quechua (Peru) *\/\n-  {\"qvm\",       HB_TAG('Q','U','Z',' ')},       \/* Margos-Yarowilca-Lauricocha Quechua -> Quechua *\/\n-  {\"qvn\",       HB_TAG('Q','W','H',' ')},       \/* North Junn Quechua -> Quechua (Peru) *\/\n-  {\"qvn\",       HB_TAG('Q','U','Z',' ')},       \/* North Junn Quechua -> Quechua *\/\n-  {\"qvo\",       HB_TAG('Q','V','I',' ')},       \/* Napo Lowland Quechua -> Quechua (Ecuador) *\/\n-  {\"qvo\",       HB_TAG('Q','U','Z',' ')},       \/* Napo Lowland Quechua -> Quechua *\/\n-  {\"qvp\",       HB_TAG('Q','W','H',' ')},       \/* Pacaraos Quechua -> Quechua (Peru) *\/\n-  {\"qvp\",       HB_TAG('Q','U','Z',' ')},       \/* Pacaraos Quechua -> Quechua *\/\n-  {\"qvs\",       HB_TAG('Q','U','Z',' ')},       \/* San Martn Quechua -> Quechua *\/\n-  {\"qvw\",       HB_TAG('Q','W','H',' ')},       \/* Huaylla Wanca Quechua -> Quechua (Peru) *\/\n-  {\"qvw\",       HB_TAG('Q','U','Z',' ')},       \/* Huaylla Wanca Quechua -> Quechua *\/\n-  {\"qvz\",       HB_TAG('Q','V','I',' ')},       \/* Northern Pastaza Quichua -> Quechua (Ecuador) *\/\n-  {\"qvz\",       HB_TAG('Q','U','Z',' ')},       \/* Northern Pastaza Quichua -> Quechua *\/\n-  {\"qwa\",       HB_TAG('Q','W','H',' ')},       \/* Corongo Ancash Quechua -> Quechua (Peru) *\/\n-  {\"qwa\",       HB_TAG('Q','U','Z',' ')},       \/* Corongo Ancash Quechua -> Quechua *\/\n-  {\"qwc\",       HB_TAG('Q','U','Z',' ')},       \/* Classical Quechua -> Quechua *\/\n-  {\"qwh\",       HB_TAG('Q','W','H',' ')},       \/* Huaylas Ancash Quechua -> Quechua (Peru) *\/\n-  {\"qwh\",       HB_TAG('Q','U','Z',' ')},       \/* Huaylas Ancash Quechua -> Quechua *\/\n-  {\"qws\",       HB_TAG('Q','W','H',' ')},       \/* Sihuas Ancash Quechua -> Quechua (Peru) *\/\n-  {\"qws\",       HB_TAG('Q','U','Z',' ')},       \/* Sihuas Ancash Quechua -> Quechua *\/\n-  {\"qwt\",       HB_TAG('A','T','H',' ')},       \/* Kwalhioqua-Tlatskanai -> Athapaskan *\/\n-  {\"qxa\",       HB_TAG('Q','W','H',' ')},       \/* Chiquin Ancash Quechua -> Quechua (Peru) *\/\n-  {\"qxa\",       HB_TAG('Q','U','Z',' ')},       \/* Chiquin Ancash Quechua -> Quechua *\/\n-  {\"qxc\",       HB_TAG('Q','W','H',' ')},       \/* Chincha Quechua -> Quechua (Peru) *\/\n-  {\"qxc\",       HB_TAG('Q','U','Z',' ')},       \/* Chincha Quechua -> Quechua *\/\n-  {\"qxh\",       HB_TAG('Q','W','H',' ')},       \/* Panao Hunuco Quechua -> Quechua (Peru) *\/\n-  {\"qxh\",       HB_TAG('Q','U','Z',' ')},       \/* Panao Hunuco Quechua -> Quechua *\/\n-  {\"qxl\",       HB_TAG('Q','V','I',' ')},       \/* Salasaca Highland Quichua -> Quechua (Ecuador) *\/\n-  {\"qxl\",       HB_TAG('Q','U','Z',' ')},       \/* Salasaca Highland Quichua -> Quechua *\/\n-  {\"qxn\",       HB_TAG('Q','W','H',' ')},       \/* Northern Conchucos Ancash Quechua -> Quechua (Peru) *\/\n-  {\"qxn\",       HB_TAG('Q','U','Z',' ')},       \/* Northern Conchucos Ancash Quechua -> Quechua *\/\n-  {\"qxo\",       HB_TAG('Q','W','H',' ')},       \/* Southern Conchucos Ancash Quechua -> Quechua (Peru) *\/\n-  {\"qxo\",       HB_TAG('Q','U','Z',' ')},       \/* Southern Conchucos Ancash Quechua -> Quechua *\/\n-  {\"qxp\",       HB_TAG('Q','U','Z',' ')},       \/* Puno Quechua -> Quechua *\/\n-  {\"qxr\",       HB_TAG('Q','V','I',' ')},       \/* Caar Highland Quichua -> Quechua (Ecuador) *\/\n-  {\"qxr\",       HB_TAG('Q','U','Z',' ')},       \/* Caar Highland Quichua -> Quechua *\/\n-  {\"qxt\",       HB_TAG('Q','W','H',' ')},       \/* Santa Ana de Tusi Pasco Quechua -> Quechua (Peru) *\/\n-  {\"qxt\",       HB_TAG('Q','U','Z',' ')},       \/* Santa Ana de Tusi Pasco Quechua -> Quechua *\/\n-  {\"qxu\",       HB_TAG('Q','U','Z',' ')},       \/* Arequipa-La Unin Quechua -> Quechua *\/\n-  {\"qxw\",       HB_TAG('Q','W','H',' ')},       \/* Jauja Wanca Quechua -> Quechua (Peru) *\/\n-  {\"qxw\",       HB_TAG('Q','U','Z',' ')},       \/* Jauja Wanca Quechua -> Quechua *\/\n-  {\"rag\",       HB_TAG('L','U','H',' ')},       \/* Logooli -> Luyia *\/\n-\/*{\"raj\",       HB_TAG('R','A','J',' ')},*\/     \/* Rajasthani [macrolanguage] *\/\n-  {\"ral\",       HB_TAG('Q','I','N',' ')},       \/* Ralte -> Chin *\/\n-\/*{\"rar\",       HB_TAG('R','A','R',' ')},*\/     \/* Rarotongan *\/\n-  {\"rbb\",       HB_TAG('P','L','G',' ')},       \/* Rumai Palaung -> Palaung *\/\n-  {\"rbl\",       HB_TAG('B','I','K',' ')},       \/* Miraya Bikol -> Bikol *\/\n-  {\"rcf\",       HB_TAG('C','P','P',' ')},       \/* Runion Creole French -> Creoles *\/\n-\/*{\"rej\",       HB_TAG('R','E','J',' ')},*\/     \/* Rejang *\/\n-\/*{\"ria\",       HB_TAG('R','I','A',' ')},*\/     \/* Riang (India) *\/\n-  {\"rif\",       HB_TAG('R','I','F',' ')},       \/* Tarifit *\/\n-  {\"rif\",       HB_TAG('B','B','R',' ')},       \/* Tarifit -> Berber *\/\n-\/*{\"rit\",       HB_TAG('R','I','T',' ')},*\/     \/* Ritharrngu -> Ritarungo *\/\n-  {\"rki\",       HB_TAG('A','R','K',' ')},       \/* Rakhine *\/\n-\/*{\"rkw\",       HB_TAG('R','K','W',' ')},*\/     \/* Arakwal *\/\n-  {\"rm\",        HB_TAG('R','M','S',' ')},       \/* Romansh *\/\n-  {\"rmc\",       HB_TAG('R','O','Y',' ')},       \/* Carpathian Romani -> Romany *\/\n-  {\"rmf\",       HB_TAG('R','O','Y',' ')},       \/* Kalo Finnish Romani -> Romany *\/\n-  {\"rml\",       HB_TAG('R','O','Y',' ')},       \/* Baltic Romani -> Romany *\/\n-  {\"rmn\",       HB_TAG('R','O','Y',' ')},       \/* Balkan Romani -> Romany *\/\n-  {\"rmo\",       HB_TAG('R','O','Y',' ')},       \/* Sinte Romani -> Romany *\/\n-  {\"rms\",       HB_TAG_NONE            },       \/* Romanian Sign Language != Romansh *\/\n-  {\"rmw\",       HB_TAG('R','O','Y',' ')},       \/* Welsh Romani -> Romany *\/\n-  {\"rmy\",       HB_TAG('R','M','Y',' ')},       \/* Vlax Romani *\/\n-  {\"rmy\",       HB_TAG('R','O','Y',' ')},       \/* Vlax Romani -> Romany *\/\n-  {\"rmz\",       HB_TAG('A','R','K',' ')},       \/* Marma -> Rakhine *\/\n-  {\"rn\",        HB_TAG('R','U','N',' ')},       \/* Rundi *\/\n-  {\"ro\",        HB_TAG('R','O','M',' ')},       \/* Romanian *\/\n-  {\"rom\",       HB_TAG('R','O','Y',' ')},       \/* Romany [macrolanguage] *\/\n-  {\"rop\",       HB_TAG('C','P','P',' ')},       \/* Kriol -> Creoles *\/\n-  {\"rtc\",       HB_TAG('Q','I','N',' ')},       \/* Rungtu Chin -> Chin *\/\n-\/*{\"rtm\",       HB_TAG('R','T','M',' ')},*\/     \/* Rotuman *\/\n-  {\"ru\",        HB_TAG('R','U','S',' ')},       \/* Russian *\/\n-  {\"rue\",       HB_TAG('R','S','Y',' ')},       \/* Rusyn *\/\n-\/*{\"rup\",       HB_TAG('R','U','P',' ')},*\/     \/* Aromanian *\/\n-  {\"rw\",        HB_TAG('R','U','A',' ')},       \/* Kinyarwanda *\/\n-  {\"rwr\",       HB_TAG('M','A','W',' ')},       \/* Marwari (India) *\/\n-  {\"sa\",        HB_TAG('S','A','N',' ')},       \/* Sanskrit *\/\n-  {\"sad\",       HB_TAG_NONE            },       \/* Sandawe != Sadri *\/\n-  {\"sah\",       HB_TAG('Y','A','K',' ')},       \/* Yakut -> Sakha *\/\n-  {\"sam\",       HB_TAG('P','A','A',' ')},       \/* Samaritan Aramaic -> Palestinian Aramaic *\/\n-\/*{\"sas\",       HB_TAG('S','A','S',' ')},*\/     \/* Sasak *\/\n-\/*{\"sat\",       HB_TAG('S','A','T',' ')},*\/     \/* Santali *\/\n-  {\"say\",       HB_TAG_NONE            },       \/* Saya != Sayisi *\/\n-  {\"sc\",        HB_TAG('S','R','D',' ')},       \/* Sardinian [macrolanguage] *\/\n-  {\"scf\",       HB_TAG('C','P','P',' ')},       \/* San Miguel Creole French -> Creoles *\/\n-  {\"sch\",       HB_TAG('Q','I','N',' ')},       \/* Sakachep -> Chin *\/\n-  {\"sci\",       HB_TAG('C','P','P',' ')},       \/* Sri Lankan Creole Malay -> Creoles *\/\n-  {\"sck\",       HB_TAG('S','A','D',' ')},       \/* Sadri *\/\n-\/*{\"scn\",       HB_TAG('S','C','N',' ')},*\/     \/* Sicilian *\/\n-\/*{\"sco\",       HB_TAG('S','C','O',' ')},*\/     \/* Scots *\/\n-  {\"scs\",       HB_TAG('S','C','S',' ')},       \/* North Slavey *\/\n-  {\"scs\",       HB_TAG('S','L','A',' ')},       \/* North Slavey -> Slavey *\/\n-  {\"scs\",       HB_TAG('A','T','H',' ')},       \/* North Slavey -> Athapaskan *\/\n-  {\"sd\",        HB_TAG('S','N','D',' ')},       \/* Sindhi *\/\n-  {\"sdc\",       HB_TAG('S','R','D',' ')},       \/* Sassarese Sardinian -> Sardinian *\/\n-  {\"sdh\",       HB_TAG('K','U','R',' ')},       \/* Southern Kurdish -> Kurdish *\/\n-  {\"sdn\",       HB_TAG('S','R','D',' ')},       \/* Gallurese Sardinian -> Sardinian *\/\n-  {\"sds\",       HB_TAG('B','B','R',' ')},       \/* Sened -> Berber *\/\n-  {\"se\",        HB_TAG('N','S','M',' ')},       \/* Northern Sami *\/\n-  {\"seh\",       HB_TAG('S','N','A',' ')},       \/* Sena *\/\n-  {\"sek\",       HB_TAG('A','T','H',' ')},       \/* Sekani -> Athapaskan *\/\n-\/*{\"sel\",       HB_TAG('S','E','L',' ')},*\/     \/* Selkup *\/\n-  {\"sez\",       HB_TAG('Q','I','N',' ')},       \/* Senthang Chin -> Chin *\/\n-  {\"sfm\",       HB_TAG('H','M','N',' ')},       \/* Small Flowery Miao -> Hmong *\/\n-  {\"sg\",        HB_TAG('S','G','O',' ')},       \/* Sango *\/\n-\/*{\"sga\",       HB_TAG('S','G','A',' ')},*\/     \/* Old Irish (to 900) *\/\n-  {\"sgc\",       HB_TAG('K','A','L',' ')},       \/* Kipsigis -> Kalenjin *\/\n-  {\"sgo\",       HB_TAG_NONE            },       \/* Songa (retired code) != Sango *\/\n-\/*{\"sgs\",       HB_TAG('S','G','S',' ')},*\/     \/* Samogitian *\/\n-  {\"sgw\",       HB_TAG('C','H','G',' ')},       \/* Sebat Bet Gurage -> Chaha Gurage *\/\n-  {\"shi\",       HB_TAG('S','H','I',' ')},       \/* Tachelhit *\/\n-  {\"shi\",       HB_TAG('B','B','R',' ')},       \/* Tachelhit -> Berber *\/\n-  {\"shl\",       HB_TAG('Q','I','N',' ')},       \/* Shendu -> Chin *\/\n-\/*{\"shn\",       HB_TAG('S','H','N',' ')},*\/     \/* Shan *\/\n-  {\"shu\",       HB_TAG('A','R','A',' ')},       \/* Chadian Arabic -> Arabic *\/\n-  {\"shy\",       HB_TAG('B','B','R',' ')},       \/* Tachawit -> Berber *\/\n-  {\"si\",        HB_TAG('S','N','H',' ')},       \/* Sinhala (Sinhalese) *\/\n-  {\"sib\",       HB_TAG_NONE            },       \/* Sebop != Sibe *\/\n-\/*{\"sid\",       HB_TAG('S','I','D',' ')},*\/     \/* Sidamo *\/\n-  {\"sig\",       HB_TAG_NONE            },       \/* Paasaal != Silte Gurage *\/\n-  {\"siz\",       HB_TAG('B','B','R',' ')},       \/* Siwi -> Berber *\/\n-  {\"sjd\",       HB_TAG('K','S','M',' ')},       \/* Kildin Sami *\/\n-  {\"sjo\",       HB_TAG('S','I','B',' ')},       \/* Xibe -> Sibe *\/\n-  {\"sjs\",       HB_TAG('B','B','R',' ')},       \/* Senhaja De Srair -> Berber *\/\n-  {\"sk\",        HB_TAG('S','K','Y',' ')},       \/* Slovak *\/\n-  {\"skg\",       HB_TAG('M','L','G',' ')},       \/* Sakalava Malagasy -> Malagasy *\/\n-  {\"skr\",       HB_TAG('S','R','K',' ')},       \/* Saraiki *\/\n-  {\"sks\",       HB_TAG_NONE            },       \/* Maia != Skolt Sami *\/\n-  {\"skw\",       HB_TAG('C','P','P',' ')},       \/* Skepi Creole Dutch -> Creoles *\/\n-  {\"sky\",       HB_TAG_NONE            },       \/* Sikaiana != Slovak *\/\n-  {\"sl\",        HB_TAG('S','L','V',' ')},       \/* Slovenian *\/\n-  {\"sla\",       HB_TAG_NONE            },       \/* Slavic [family] != Slavey *\/\n-  {\"sm\",        HB_TAG('S','M','O',' ')},       \/* Samoan *\/\n-  {\"sma\",       HB_TAG('S','S','M',' ')},       \/* Southern Sami *\/\n-  {\"smj\",       HB_TAG('L','S','M',' ')},       \/* Lule Sami *\/\n-  {\"sml\",       HB_TAG_NONE            },       \/* Central Sama != Somali *\/\n-  {\"smn\",       HB_TAG('I','S','M',' ')},       \/* Inari Sami *\/\n-  {\"sms\",       HB_TAG('S','K','S',' ')},       \/* Skolt Sami *\/\n-  {\"smt\",       HB_TAG('Q','I','N',' ')},       \/* Simte -> Chin *\/\n-  {\"sn\",        HB_TAG('S','N','A','0')},       \/* Shona *\/\n-  {\"snh\",       HB_TAG_NONE            },       \/* Shinabo (retired code) != Sinhala (Sinhalese) *\/\n-\/*{\"snk\",       HB_TAG('S','N','K',' ')},*\/     \/* Soninke *\/\n-  {\"so\",        HB_TAG('S','M','L',' ')},       \/* Somali *\/\n-  {\"sog\",       HB_TAG_NONE            },       \/* Sogdian != Sodo Gurage *\/\n-\/*{\"sop\",       HB_TAG('S','O','P',' ')},*\/     \/* Songe *\/\n-  {\"spv\",       HB_TAG('O','R','I',' ')},       \/* Sambalpuri -> Odia (formerly Oriya) *\/\n-  {\"spy\",       HB_TAG('K','A','L',' ')},       \/* Sabaot -> Kalenjin *\/\n-  {\"sq\",        HB_TAG('S','Q','I',' ')},       \/* Albanian [macrolanguage] *\/\n-  {\"sr\",        HB_TAG('S','R','B',' ')},       \/* Serbian *\/\n-  {\"srb\",       HB_TAG_NONE            },       \/* Sora != Serbian *\/\n-  {\"src\",       HB_TAG('S','R','D',' ')},       \/* Logudorese Sardinian -> Sardinian *\/\n-  {\"srk\",       HB_TAG_NONE            },       \/* Serudung Murut != Saraiki *\/\n-  {\"srm\",       HB_TAG('C','P','P',' ')},       \/* Saramaccan -> Creoles *\/\n-  {\"srn\",       HB_TAG('C','P','P',' ')},       \/* Sranan Tongo -> Creoles *\/\n-  {\"sro\",       HB_TAG('S','R','D',' ')},       \/* Campidanese Sardinian -> Sardinian *\/\n-\/*{\"srr\",       HB_TAG('S','R','R',' ')},*\/     \/* Serer *\/\n-  {\"srs\",       HB_TAG('A','T','H',' ')},       \/* Sarsi -> Athapaskan *\/\n-  {\"ss\",        HB_TAG('S','W','Z',' ')},       \/* Swati *\/\n-  {\"ssh\",       HB_TAG('A','R','A',' ')},       \/* Shihhi Arabic -> Arabic *\/\n-  {\"ssl\",       HB_TAG_NONE            },       \/* Western Sisaala != South Slavey *\/\n-  {\"ssm\",       HB_TAG_NONE            },       \/* Semnam != Southern Sami *\/\n-  {\"st\",        HB_TAG('S','O','T',' ')},       \/* Southern Sotho *\/\n-  {\"sta\",       HB_TAG('C','P','P',' ')},       \/* Settla -> Creoles *\/\n-\/*{\"stq\",       HB_TAG('S','T','Q',' ')},*\/     \/* Saterfriesisch -> Saterland Frisian *\/\n-  {\"stv\",       HB_TAG('S','I','G',' ')},       \/* Silt'e -> Silte Gurage *\/\n-  {\"su\",        HB_TAG('S','U','N',' ')},       \/* Sundanese *\/\n-\/*{\"suk\",       HB_TAG('S','U','K',' ')},*\/     \/* Sukuma *\/\n-  {\"suq\",       HB_TAG('S','U','R',' ')},       \/* Suri *\/\n-  {\"sur\",       HB_TAG_NONE            },       \/* Mwaghavul != Suri *\/\n-  {\"sv\",        HB_TAG('S','V','E',' ')},       \/* Swedish *\/\n-\/*{\"sva\",       HB_TAG('S','V','A',' ')},*\/     \/* Svan *\/\n-  {\"svc\",       HB_TAG('C','P','P',' ')},       \/* Vincentian Creole English -> Creoles *\/\n-  {\"sve\",       HB_TAG_NONE            },       \/* Serili != Swedish *\/\n-  {\"sw\",        HB_TAG('S','W','K',' ')},       \/* Swahili [macrolanguage] *\/\n-  {\"swb\",       HB_TAG('C','M','R',' ')},       \/* Maore Comorian -> Comorian *\/\n-  {\"swc\",       HB_TAG('S','W','K',' ')},       \/* Congo Swahili -> Swahili *\/\n-  {\"swh\",       HB_TAG('S','W','K',' ')},       \/* Swahili *\/\n-  {\"swk\",       HB_TAG_NONE            },       \/* Malawi Sena != Swahili *\/\n-  {\"swn\",       HB_TAG('B','B','R',' ')},       \/* Sawknah -> Berber *\/\n-  {\"swv\",       HB_TAG('M','A','W',' ')},       \/* Shekhawati -> Marwari *\/\n-\/*{\"sxu\",       HB_TAG('S','X','U',' ')},*\/     \/* Upper Saxon *\/\n-  {\"syc\",       HB_TAG('S','Y','R',' ')},       \/* Classical Syriac -> Syriac *\/\n-\/*{\"syl\",       HB_TAG('S','Y','L',' ')},*\/     \/* Sylheti *\/\n-\/*{\"syr\",       HB_TAG('S','Y','R',' ')},*\/     \/* Syriac [macrolanguage] *\/\n-\/*{\"szl\",       HB_TAG('S','Z','L',' ')},*\/     \/* Silesian *\/\n-  {\"ta\",        HB_TAG('T','A','M',' ')},       \/* Tamil *\/\n-  {\"taa\",       HB_TAG('A','T','H',' ')},       \/* Lower Tanana -> Athapaskan *\/\n-\/*{\"tab\",       HB_TAG('T','A','B',' ')},*\/     \/* Tabassaran -> Tabasaran *\/\n-  {\"taj\",       HB_TAG_NONE            },       \/* Eastern Tamang != Tajiki *\/\n-  {\"taq\",       HB_TAG('T','M','H',' ')},       \/* Tamasheq -> Tamashek *\/\n-  {\"taq\",       HB_TAG('B','B','R',' ')},       \/* Tamasheq -> Berber *\/\n-  {\"tas\",       HB_TAG('C','P','P',' ')},       \/* Tay Boi -> Creoles *\/\n-  {\"tau\",       HB_TAG('A','T','H',' ')},       \/* Upper Tanana -> Athapaskan *\/\n-  {\"tcb\",       HB_TAG('A','T','H',' ')},       \/* Tanacross -> Athapaskan *\/\n-  {\"tce\",       HB_TAG('A','T','H',' ')},       \/* Southern Tutchone -> Athapaskan *\/\n-  {\"tch\",       HB_TAG('C','P','P',' ')},       \/* Turks And Caicos Creole English -> Creoles *\/\n-  {\"tcp\",       HB_TAG('Q','I','N',' ')},       \/* Tawr Chin -> Chin *\/\n-  {\"tcs\",       HB_TAG('C','P','P',' ')},       \/* Torres Strait Creole -> Creoles *\/\n-  {\"tcy\",       HB_TAG('T','U','L',' ')},       \/* Tulu -> Tumbuka *\/\n-  {\"tcz\",       HB_TAG('Q','I','N',' ')},       \/* Thado Chin -> Chin *\/\n-\/*{\"tdd\",       HB_TAG('T','D','D',' ')},*\/     \/* Tai Na -> Dehong Dai *\/\n-  {\"tdx\",       HB_TAG('M','L','G',' ')},       \/* Tandroy-Mahafaly Malagasy -> Malagasy *\/\n-  {\"te\",        HB_TAG('T','E','L',' ')},       \/* Telugu *\/\n-  {\"tec\",       HB_TAG('K','A','L',' ')},       \/* Terik -> Kalenjin *\/\n-  {\"tem\",       HB_TAG('T','M','N',' ')},       \/* Timne -> Temne *\/\n-\/*{\"tet\",       HB_TAG('T','E','T',' ')},*\/     \/* Tetum *\/\n-  {\"tez\",       HB_TAG('B','B','R',' ')},       \/* Tetserret -> Berber *\/\n-  {\"tfn\",       HB_TAG('A','T','H',' ')},       \/* Tanaina -> Athapaskan *\/\n-  {\"tg\",        HB_TAG('T','A','J',' ')},       \/* Tajik -> Tajiki *\/\n-  {\"tgh\",       HB_TAG('C','P','P',' ')},       \/* Tobagonian Creole English -> Creoles *\/\n-  {\"tgj\",       HB_TAG('N','I','S',' ')},       \/* Tagin -> Nisi *\/\n-  {\"tgn\",       HB_TAG_NONE            },       \/* Tandaganon != Tongan *\/\n-  {\"tgr\",       HB_TAG_NONE            },       \/* Tareng != Tigre *\/\n-  {\"tgx\",       HB_TAG('A','T','H',' ')},       \/* Tagish -> Athapaskan *\/\n-  {\"tgy\",       HB_TAG_NONE            },       \/* Togoyo != Tigrinya *\/\n-  {\"th\",        HB_TAG('T','H','A',' ')},       \/* Thai *\/\n-  {\"tht\",       HB_TAG('A','T','H',' ')},       \/* Tahltan -> Athapaskan *\/\n-  {\"thv\",       HB_TAG('T','M','H',' ')},       \/* Tahaggart Tamahaq -> Tamashek *\/\n-  {\"thv\",       HB_TAG('B','B','R',' ')},       \/* Tahaggart Tamahaq -> Berber *\/\n-  {\"thz\",       HB_TAG('T','M','H',' ')},       \/* Tayart Tamajeq -> Tamashek *\/\n-  {\"thz\",       HB_TAG('B','B','R',' ')},       \/* Tayart Tamajeq -> Berber *\/\n-  {\"ti\",        HB_TAG('T','G','Y',' ')},       \/* Tigrinya *\/\n-  {\"tia\",       HB_TAG('B','B','R',' ')},       \/* Tidikelt Tamazight -> Berber *\/\n-  {\"tig\",       HB_TAG('T','G','R',' ')},       \/* Tigre *\/\n-\/*{\"tiv\",       HB_TAG('T','I','V',' ')},*\/     \/* Tiv *\/\n-  {\"tjo\",       HB_TAG('B','B','R',' ')},       \/* Temacine Tamazight -> Berber *\/\n-  {\"tk\",        HB_TAG('T','K','M',' ')},       \/* Turkmen *\/\n-  {\"tkg\",       HB_TAG('M','L','G',' ')},       \/* Tesaka Malagasy -> Malagasy *\/\n-  {\"tkm\",       HB_TAG_NONE            },       \/* Takelma != Turkmen *\/\n-  {\"tl\",        HB_TAG('T','G','L',' ')},       \/* Tagalog *\/\n-  {\"tmg\",       HB_TAG('C','P','P',' ')},       \/* Ternateo -> Creoles *\/\n-  {\"tmh\",       HB_TAG('T','M','H',' ')},       \/* Tamashek [macrolanguage] *\/\n-  {\"tmh\",       HB_TAG('B','B','R',' ')},       \/* Tamashek [macrolanguage] -> Berber *\/\n-  {\"tmn\",       HB_TAG_NONE            },       \/* Taman (Indonesia) != Temne *\/\n-  {\"tmw\",       HB_TAG('M','L','Y',' ')},       \/* Temuan -> Malay *\/\n-  {\"tn\",        HB_TAG('T','N','A',' ')},       \/* Tswana *\/\n-  {\"tna\",       HB_TAG_NONE            },       \/* Tacana != Tswana *\/\n-  {\"tne\",       HB_TAG_NONE            },       \/* Tinoc Kallahan (retired code) != Tundra Enets *\/\n-  {\"tnf\",       HB_TAG('D','R','I',' ')},       \/* Tangshewi (retired code) -> Dari *\/\n-  {\"tnf\",       HB_TAG('F','A','R',' ')},       \/* Tangshewi (retired code) -> Persian *\/\n-  {\"tng\",       HB_TAG_NONE            },       \/* Tobanga != Tonga *\/\n-  {\"to\",        HB_TAG('T','G','N',' ')},       \/* Tonga (Tonga Islands) -> Tongan *\/\n-  {\"tod\",       HB_TAG('T','O','D','0')},       \/* Toma *\/\n-  {\"toi\",       HB_TAG('T','N','G',' ')},       \/* Tonga (Zambia) *\/\n-  {\"toj\",       HB_TAG('M','Y','N',' ')},       \/* Tojolabal -> Mayan *\/\n-  {\"tol\",       HB_TAG('A','T','H',' ')},       \/* Tolowa -> Athapaskan *\/\n-  {\"tor\",       HB_TAG('B','A','D','0')},       \/* Togbo-Vara Banda -> Banda *\/\n-  {\"tpi\",       HB_TAG('T','P','I',' ')},       \/* Tok Pisin *\/\n-  {\"tpi\",       HB_TAG('C','P','P',' ')},       \/* Tok Pisin -> Creoles *\/\n-  {\"tr\",        HB_TAG('T','R','K',' ')},       \/* Turkish *\/\n-  {\"trf\",       HB_TAG('C','P','P',' ')},       \/* Trinidadian Creole English -> Creoles *\/\n-  {\"trk\",       HB_TAG_NONE            },       \/* Turkic [family] != Turkish *\/\n-  {\"tru\",       HB_TAG('T','U','A',' ')},       \/* Turoyo -> Turoyo Aramaic *\/\n-  {\"tru\",       HB_TAG('S','Y','R',' ')},       \/* Turoyo -> Syriac *\/\n-  {\"ts\",        HB_TAG('T','S','G',' ')},       \/* Tsonga *\/\n-  {\"tsg\",       HB_TAG_NONE            },       \/* Tausug != Tsonga *\/\n-\/*{\"tsj\",       HB_TAG('T','S','J',' ')},*\/     \/* Tshangla *\/\n-  {\"tt\",        HB_TAG('T','A','T',' ')},       \/* Tatar *\/\n-  {\"ttc\",       HB_TAG('M','Y','N',' ')},       \/* Tektiteko -> Mayan *\/\n-  {\"ttm\",       HB_TAG('A','T','H',' ')},       \/* Northern Tutchone -> Athapaskan *\/\n-  {\"ttq\",       HB_TAG('T','M','H',' ')},       \/* Tawallammat Tamajaq -> Tamashek *\/\n-  {\"ttq\",       HB_TAG('B','B','R',' ')},       \/* Tawallammat Tamajaq -> Berber *\/\n-  {\"tua\",       HB_TAG_NONE            },       \/* Wiarumus != Turoyo Aramaic *\/\n-  {\"tul\",       HB_TAG_NONE            },       \/* Tula != Tumbuka *\/\n-\/*{\"tum\",       HB_TAG('T','U','M',' ')},*\/     \/* Tumbuka -> Tulu *\/\n-  {\"tuu\",       HB_TAG('A','T','H',' ')},       \/* Tututni -> Athapaskan *\/\n-  {\"tuv\",       HB_TAG_NONE            },       \/* Turkana != Tuvin *\/\n-  {\"tuy\",       HB_TAG('K','A','L',' ')},       \/* Tugen -> Kalenjin *\/\n-\/*{\"tvl\",       HB_TAG('T','V','L',' ')},*\/     \/* Tuvalu *\/\n-  {\"tvy\",       HB_TAG('C','P','P',' ')},       \/* Timor Pidgin -> Creoles *\/\n-  {\"tw\",        HB_TAG('T','W','I',' ')},       \/* Twi *\/\n-  {\"tw\",        HB_TAG('A','K','A',' ')},       \/* Twi -> Akan *\/\n-  {\"txc\",       HB_TAG('A','T','H',' ')},       \/* Tsetsaut -> Athapaskan *\/\n-  {\"txy\",       HB_TAG('M','L','G',' ')},       \/* Tanosy Malagasy -> Malagasy *\/\n-  {\"ty\",        HB_TAG('T','H','T',' ')},       \/* Tahitian *\/\n-  {\"tyv\",       HB_TAG('T','U','V',' ')},       \/* Tuvinian -> Tuvin *\/\n-\/*{\"tyz\",       HB_TAG('T','Y','Z',' ')},*\/     \/* Ty *\/\n-  {\"tzh\",       HB_TAG('M','Y','N',' ')},       \/* Tzeltal -> Mayan *\/\n-  {\"tzj\",       HB_TAG('M','Y','N',' ')},       \/* Tz'utujil -> Mayan *\/\n-  {\"tzm\",       HB_TAG('T','Z','M',' ')},       \/* Central Atlas Tamazight -> Tamazight *\/\n-  {\"tzm\",       HB_TAG('B','B','R',' ')},       \/* Central Atlas Tamazight -> Berber *\/\n-  {\"tzo\",       HB_TAG('T','Z','O',' ')},       \/* Tzotzil *\/\n-  {\"tzo\",       HB_TAG('M','Y','N',' ')},       \/* Tzotzil -> Mayan *\/\n-  {\"ubl\",       HB_TAG('B','I','K',' ')},       \/* Buhi'non Bikol -> Bikol *\/\n-\/*{\"udm\",       HB_TAG('U','D','M',' ')},*\/     \/* Udmurt *\/\n-  {\"ug\",        HB_TAG('U','Y','G',' ')},       \/* Uyghur *\/\n-  {\"uk\",        HB_TAG('U','K','R',' ')},       \/* Ukrainian *\/\n-  {\"uki\",       HB_TAG('K','U','I',' ')},       \/* Kui (India) *\/\n-  {\"uln\",       HB_TAG('C','P','P',' ')},       \/* Unserdeutsch -> Creoles *\/\n-\/*{\"umb\",       HB_TAG('U','M','B',' ')},*\/     \/* Umbundu *\/\n-  {\"unr\",       HB_TAG('M','U','N',' ')},       \/* Mundari *\/\n-  {\"ur\",        HB_TAG('U','R','D',' ')},       \/* Urdu *\/\n-  {\"urk\",       HB_TAG('M','L','Y',' ')},       \/* Urak Lawoi' -> Malay *\/\n-  {\"usp\",       HB_TAG('M','Y','N',' ')},       \/* Uspanteco -> Mayan *\/\n-  {\"uz\",        HB_TAG('U','Z','B',' ')},       \/* Uzbek [macrolanguage] *\/\n-  {\"uzn\",       HB_TAG('U','Z','B',' ')},       \/* Northern Uzbek -> Uzbek *\/\n-  {\"uzs\",       HB_TAG('U','Z','B',' ')},       \/* Southern Uzbek -> Uzbek *\/\n-  {\"vap\",       HB_TAG('Q','I','N',' ')},       \/* Vaiphei -> Chin *\/\n-  {\"ve\",        HB_TAG('V','E','N',' ')},       \/* Venda *\/\n-\/*{\"vec\",       HB_TAG('V','E','C',' ')},*\/     \/* Venetian *\/\n-  {\"vi\",        HB_TAG('V','I','T',' ')},       \/* Vietnamese *\/\n-  {\"vic\",       HB_TAG('C','P','P',' ')},       \/* Virgin Islands Creole English -> Creoles *\/\n-  {\"vit\",       HB_TAG_NONE            },       \/* Viti != Vietnamese *\/\n-  {\"vkk\",       HB_TAG('M','L','Y',' ')},       \/* Kaur -> Malay *\/\n-  {\"vkp\",       HB_TAG('C','P','P',' ')},       \/* Korlai Creole Portuguese -> Creoles *\/\n-  {\"vkt\",       HB_TAG('M','L','Y',' ')},       \/* Tenggarong Kutai Malay -> Malay *\/\n-  {\"vls\",       HB_TAG('F','L','E',' ')},       \/* Vlaams -> Dutch (Flemish) *\/\n-  {\"vmw\",       HB_TAG('M','A','K',' ')},       \/* Makhuwa *\/\n-  {\"vo\",        HB_TAG('V','O','L',' ')},       \/* Volapk *\/\n-\/*{\"vro\",       HB_TAG('V','R','O',' ')},*\/     \/* Vro *\/\n-  {\"wa\",        HB_TAG('W','L','N',' ')},       \/* Walloon *\/\n-  {\"wag\",       HB_TAG_NONE            },       \/* Wa'ema != Wagdi *\/\n-\/*{\"war\",       HB_TAG('W','A','R',' ')},*\/     \/* Waray (Philippines) -> Waray-Waray *\/\n-  {\"wbm\",       HB_TAG('W','A',' ',' ')},       \/* Wa *\/\n-  {\"wbr\",       HB_TAG('W','A','G',' ')},       \/* Wagdi *\/\n-  {\"wbr\",       HB_TAG('R','A','J',' ')},       \/* Wagdi -> Rajasthani *\/\n-  {\"wea\",       HB_TAG('K','R','N',' ')},       \/* Wewaw -> Karen *\/\n-  {\"wes\",       HB_TAG('C','P','P',' ')},       \/* Cameroon Pidgin -> Creoles *\/\n-  {\"weu\",       HB_TAG('Q','I','N',' ')},       \/* Rawngtu Chin -> Chin *\/\n-  {\"wlc\",       HB_TAG('C','M','R',' ')},       \/* Mwali Comorian -> Comorian *\/\n-  {\"wle\",       HB_TAG('S','I','G',' ')},       \/* Wolane -> Silte Gurage *\/\n-  {\"wlk\",       HB_TAG('A','T','H',' ')},       \/* Wailaki -> Athapaskan *\/\n-  {\"wni\",       HB_TAG('C','M','R',' ')},       \/* Ndzwani Comorian -> Comorian *\/\n-  {\"wo\",        HB_TAG('W','L','F',' ')},       \/* Wolof *\/\n-  {\"wry\",       HB_TAG('M','A','W',' ')},       \/* Merwari -> Marwari *\/\n-  {\"wsg\",       HB_TAG('G','O','N',' ')},       \/* Adilabad Gondi -> Gondi *\/\n-\/*{\"wtm\",       HB_TAG('W','T','M',' ')},*\/     \/* Mewati *\/\n-  {\"wuu\",       HB_TAG('Z','H','S',' ')},       \/* Wu Chinese -> Chinese, Simplified *\/\n-  {\"xal\",       HB_TAG('K','L','M',' ')},       \/* Kalmyk *\/\n-  {\"xal\",       HB_TAG('T','O','D',' ')},       \/* Kalmyk -> Todo *\/\n-  {\"xan\",       HB_TAG('S','E','K',' ')},       \/* Xamtanga -> Sekota *\/\n-  {\"xbd\",       HB_TAG_NONE            },       \/* Bindal != L *\/\n-  {\"xh\",        HB_TAG('X','H','S',' ')},       \/* Xhosa *\/\n-\/*{\"xjb\",       HB_TAG('X','J','B',' ')},*\/     \/* Minjungbal -> Minjangbal *\/\n-\/*{\"xkf\",       HB_TAG('X','K','F',' ')},*\/     \/* Khengkha *\/\n-  {\"xmg\",       HB_TAG('B','M','L',' ')},       \/* Mengaka -> Bamileke *\/\n-  {\"xmm\",       HB_TAG('M','L','Y',' ')},       \/* Manado Malay -> Malay *\/\n-  {\"xmm\",       HB_TAG('C','P','P',' ')},       \/* Manado Malay -> Creoles *\/\n-  {\"xmv\",       HB_TAG('M','L','G',' ')},       \/* Antankarana Malagasy -> Malagasy *\/\n-  {\"xmw\",       HB_TAG('M','L','G',' ')},       \/* Tsimihety Malagasy -> Malagasy *\/\n-  {\"xnj\",       HB_TAG('S','X','T',' ')},       \/* Ngoni (Tanzania) -> Sutu *\/\n-  {\"xnq\",       HB_TAG('S','X','T',' ')},       \/* Ngoni (Mozambique) -> Sutu *\/\n-  {\"xnr\",       HB_TAG('D','G','R',' ')},       \/* Kangri -> Dogri (macrolanguage) *\/\n-\/*{\"xog\",       HB_TAG('X','O','G',' ')},*\/     \/* Soga *\/\n-  {\"xpe\",       HB_TAG('X','P','E',' ')},       \/* Liberia Kpelle -> Kpelle (Liberia) *\/\n-  {\"xpe\",       HB_TAG('K','P','L',' ')},       \/* Liberia Kpelle -> Kpelle *\/\n-  {\"xsl\",       HB_TAG('S','S','L',' ')},       \/* South Slavey *\/\n-  {\"xsl\",       HB_TAG('S','L','A',' ')},       \/* South Slavey -> Slavey *\/\n-  {\"xsl\",       HB_TAG('A','T','H',' ')},       \/* South Slavey -> Athapaskan *\/\n-  {\"xst\",       HB_TAG('S','I','G',' ')},       \/* Silt'e (retired code) -> Silte Gurage *\/\n-  {\"xup\",       HB_TAG('A','T','H',' ')},       \/* Upper Umpqua -> Athapaskan *\/\n-  {\"xwo\",       HB_TAG('T','O','D',' ')},       \/* Written Oirat -> Todo *\/\n-  {\"yaj\",       HB_TAG('B','A','D','0')},       \/* Banda-Yangere -> Banda *\/\n-  {\"yak\",       HB_TAG_NONE            },       \/* Yakama != Sakha *\/\n-\/*{\"yao\",       HB_TAG('Y','A','O',' ')},*\/     \/* Yao *\/\n-\/*{\"yap\",       HB_TAG('Y','A','P',' ')},*\/     \/* Yapese *\/\n-  {\"yba\",       HB_TAG_NONE            },       \/* Yala != Yoruba *\/\n-  {\"ybb\",       HB_TAG('B','M','L',' ')},       \/* Yemba -> Bamileke *\/\n-  {\"ybd\",       HB_TAG('A','R','K',' ')},       \/* Yangbye (retired code) -> Rakhine *\/\n-  {\"ydd\",       HB_TAG('J','I','I',' ')},       \/* Eastern Yiddish -> Yiddish *\/\n-  {\"yi\",        HB_TAG('J','I','I',' ')},       \/* Yiddish [macrolanguage] *\/\n-  {\"yih\",       HB_TAG('J','I','I',' ')},       \/* Western Yiddish -> Yiddish *\/\n-  {\"yim\",       HB_TAG_NONE            },       \/* Yimchungru Naga != Yi Modern *\/\n-  {\"yo\",        HB_TAG('Y','B','A',' ')},       \/* Yoruba *\/\n-  {\"yos\",       HB_TAG('Q','I','N',' ')},       \/* Yos (retired code) -> Chin *\/\n-  {\"yua\",       HB_TAG('M','Y','N',' ')},       \/* Yucateco -> Mayan *\/\n-  {\"yue\",       HB_TAG('Z','H','H',' ')},       \/* Yue Chinese -> Chinese, Traditional, Hong Kong SAR *\/\n-  {\"za\",        HB_TAG('Z','H','A',' ')},       \/* Zhuang [macrolanguage] *\/\n-  {\"zch\",       HB_TAG('Z','H','A',' ')},       \/* Central Hongshuihe Zhuang -> Zhuang *\/\n-  {\"zdj\",       HB_TAG('C','M','R',' ')},       \/* Ngazidja Comorian -> Comorian *\/\n-\/*{\"zea\",       HB_TAG('Z','E','A',' ')},*\/     \/* Zeeuws -> Zealandic *\/\n-  {\"zeh\",       HB_TAG('Z','H','A',' ')},       \/* Eastern Hongshuihe Zhuang -> Zhuang *\/\n-  {\"zen\",       HB_TAG('B','B','R',' ')},       \/* Zenaga -> Berber *\/\n-  {\"zgb\",       HB_TAG('Z','H','A',' ')},       \/* Guibei Zhuang -> Zhuang *\/\n-  {\"zgh\",       HB_TAG('Z','G','H',' ')},       \/* Standard Moroccan Tamazight *\/\n-  {\"zgh\",       HB_TAG('B','B','R',' ')},       \/* Standard Moroccan Tamazight -> Berber *\/\n-  {\"zgm\",       HB_TAG('Z','H','A',' ')},       \/* Minz Zhuang -> Zhuang *\/\n-  {\"zgn\",       HB_TAG('Z','H','A',' ')},       \/* Guibian Zhuang -> Zhuang *\/\n-  {\"zh\",        HB_TAG('Z','H','S',' ')},       \/* Chinese, Simplified [macrolanguage] *\/\n-  {\"zhd\",       HB_TAG('Z','H','A',' ')},       \/* Dai Zhuang -> Zhuang *\/\n-  {\"zhn\",       HB_TAG('Z','H','A',' ')},       \/* Nong Zhuang -> Zhuang *\/\n-  {\"zlj\",       HB_TAG('Z','H','A',' ')},       \/* Liujiang Zhuang -> Zhuang *\/\n-  {\"zlm\",       HB_TAG('M','L','Y',' ')},       \/* Malay *\/\n-  {\"zln\",       HB_TAG('Z','H','A',' ')},       \/* Lianshan Zhuang -> Zhuang *\/\n-  {\"zlq\",       HB_TAG('Z','H','A',' ')},       \/* Liuqian Zhuang -> Zhuang *\/\n-  {\"zmi\",       HB_TAG('M','L','Y',' ')},       \/* Negeri Sembilan Malay -> Malay *\/\n-  {\"zmz\",       HB_TAG('B','A','D','0')},       \/* Mbandja -> Banda *\/\n-  {\"znd\",       HB_TAG_NONE            },       \/* Zande [family] != Zande *\/\n-  {\"zne\",       HB_TAG('Z','N','D',' ')},       \/* Zande *\/\n-  {\"zom\",       HB_TAG('Q','I','N',' ')},       \/* Zou -> Chin *\/\n-  {\"zqe\",       HB_TAG('Z','H','A',' ')},       \/* Qiubei Zhuang -> Zhuang *\/\n-  {\"zsm\",       HB_TAG('M','L','Y',' ')},       \/* Standard Malay -> Malay *\/\n-  {\"zu\",        HB_TAG('Z','U','L',' ')},       \/* Zulu *\/\n-  {\"zum\",       HB_TAG('L','R','C',' ')},       \/* Kumzari -> Luri *\/\n-  {\"zyb\",       HB_TAG('Z','H','A',' ')},       \/* Yongbei Zhuang -> Zhuang *\/\n-  {\"zyg\",       HB_TAG('Z','H','A',' ')},       \/* Yang Zhuang -> Zhuang *\/\n-  {\"zyj\",       HB_TAG('Z','H','A',' ')},       \/* Youjiang Zhuang -> Zhuang *\/\n-  {\"zyn\",       HB_TAG('Z','H','A',' ')},       \/* Yongnan Zhuang -> Zhuang *\/\n-  {\"zyp\",       HB_TAG('Q','I','N',' ')},       \/* Zyphe Chin -> Chin *\/\n-\/*{\"zza\",       HB_TAG('Z','Z','A',' ')},*\/     \/* Zazaki [macrolanguage] *\/\n-  {\"zzj\",       HB_TAG('Z','H','A',' ')},       \/* Zuojiang Zhuang -> Zhuang *\/\n+static const LangTag ot_languages2[] = {\n+  {HB_TAG('a','a',' ',' '),     HB_TAG('A','F','R',' ')},       \/* Afar *\/\n+  {HB_TAG('a','b',' ',' '),     HB_TAG('A','B','K',' ')},       \/* Abkhazian *\/\n+  {HB_TAG('a','f',' ',' '),     HB_TAG('A','F','K',' ')},       \/* Afrikaans *\/\n+  {HB_TAG('a','k',' ',' '),     HB_TAG('A','K','A',' ')},       \/* Akan [macrolanguage] *\/\n+  {HB_TAG('a','m',' ',' '),     HB_TAG('A','M','H',' ')},       \/* Amharic *\/\n+  {HB_TAG('a','n',' ',' '),     HB_TAG('A','R','G',' ')},       \/* Aragonese *\/\n+  {HB_TAG('a','r',' ',' '),     HB_TAG('A','R','A',' ')},       \/* Arabic [macrolanguage] *\/\n+  {HB_TAG('a','s',' ',' '),     HB_TAG('A','S','M',' ')},       \/* Assamese *\/\n+  {HB_TAG('a','v',' ',' '),     HB_TAG('A','V','R',' ')},       \/* Avaric -> Avar *\/\n+  {HB_TAG('a','y',' ',' '),     HB_TAG('A','Y','M',' ')},       \/* Aymara [macrolanguage] *\/\n+  {HB_TAG('a','z',' ',' '),     HB_TAG('A','Z','E',' ')},       \/* Azerbaijani [macrolanguage] *\/\n+  {HB_TAG('b','a',' ',' '),     HB_TAG('B','S','H',' ')},       \/* Bashkir *\/\n+  {HB_TAG('b','e',' ',' '),     HB_TAG('B','E','L',' ')},       \/* Belarusian -> Belarussian *\/\n+  {HB_TAG('b','g',' ',' '),     HB_TAG('B','G','R',' ')},       \/* Bulgarian *\/\n+  {HB_TAG('b','i',' ',' '),     HB_TAG('B','I','S',' ')},       \/* Bislama *\/\n+  {HB_TAG('b','i',' ',' '),     HB_TAG('C','P','P',' ')},       \/* Bislama -> Creoles *\/\n+  {HB_TAG('b','m',' ',' '),     HB_TAG('B','M','B',' ')},       \/* Bambara (Bamanankan) *\/\n+  {HB_TAG('b','n',' ',' '),     HB_TAG('B','E','N',' ')},       \/* Bengali *\/\n+  {HB_TAG('b','o',' ',' '),     HB_TAG('T','I','B',' ')},       \/* Tibetan *\/\n+  {HB_TAG('b','r',' ',' '),     HB_TAG('B','R','E',' ')},       \/* Breton *\/\n+  {HB_TAG('b','s',' ',' '),     HB_TAG('B','O','S',' ')},       \/* Bosnian *\/\n+  {HB_TAG('c','a',' ',' '),     HB_TAG('C','A','T',' ')},       \/* Catalan *\/\n+  {HB_TAG('c','e',' ',' '),     HB_TAG('C','H','E',' ')},       \/* Chechen *\/\n+  {HB_TAG('c','h',' ',' '),     HB_TAG('C','H','A',' ')},       \/* Chamorro *\/\n+  {HB_TAG('c','o',' ',' '),     HB_TAG('C','O','S',' ')},       \/* Corsican *\/\n+  {HB_TAG('c','r',' ',' '),     HB_TAG('C','R','E',' ')},       \/* Cree [macrolanguage] *\/\n+  {HB_TAG('c','s',' ',' '),     HB_TAG('C','S','Y',' ')},       \/* Czech *\/\n+  {HB_TAG('c','u',' ',' '),     HB_TAG('C','S','L',' ')},       \/* Church Slavonic *\/\n+  {HB_TAG('c','v',' ',' '),     HB_TAG('C','H','U',' ')},       \/* Chuvash *\/\n+  {HB_TAG('c','y',' ',' '),     HB_TAG('W','E','L',' ')},       \/* Welsh *\/\n+  {HB_TAG('d','a',' ',' '),     HB_TAG('D','A','N',' ')},       \/* Danish *\/\n+  {HB_TAG('d','e',' ',' '),     HB_TAG('D','E','U',' ')},       \/* German *\/\n+  {HB_TAG('d','v',' ',' '),     HB_TAG('D','I','V',' ')},       \/* Divehi (Dhivehi, Maldivian) *\/\n+  {HB_TAG('d','v',' ',' '),     HB_TAG('D','H','V',' ')},       \/* Divehi (Dhivehi, Maldivian) (deprecated) *\/\n+  {HB_TAG('d','z',' ',' '),     HB_TAG('D','Z','N',' ')},       \/* Dzongkha *\/\n+  {HB_TAG('e','e',' ',' '),     HB_TAG('E','W','E',' ')},       \/* Ewe *\/\n+  {HB_TAG('e','l',' ',' '),     HB_TAG('E','L','L',' ')},       \/* Modern Greek (1453-) -> Greek *\/\n+  {HB_TAG('e','n',' ',' '),     HB_TAG('E','N','G',' ')},       \/* English *\/\n+  {HB_TAG('e','o',' ',' '),     HB_TAG('N','T','O',' ')},       \/* Esperanto *\/\n+  {HB_TAG('e','s',' ',' '),     HB_TAG('E','S','P',' ')},       \/* Spanish *\/\n+  {HB_TAG('e','t',' ',' '),     HB_TAG('E','T','I',' ')},       \/* Estonian [macrolanguage] *\/\n+  {HB_TAG('e','u',' ',' '),     HB_TAG('E','U','Q',' ')},       \/* Basque *\/\n+  {HB_TAG('f','a',' ',' '),     HB_TAG('F','A','R',' ')},       \/* Persian [macrolanguage] *\/\n+  {HB_TAG('f','f',' ',' '),     HB_TAG('F','U','L',' ')},       \/* Fulah [macrolanguage] *\/\n+  {HB_TAG('f','i',' ',' '),     HB_TAG('F','I','N',' ')},       \/* Finnish *\/\n+  {HB_TAG('f','j',' ',' '),     HB_TAG('F','J','I',' ')},       \/* Fijian *\/\n+  {HB_TAG('f','o',' ',' '),     HB_TAG('F','O','S',' ')},       \/* Faroese *\/\n+  {HB_TAG('f','r',' ',' '),     HB_TAG('F','R','A',' ')},       \/* French *\/\n+  {HB_TAG('f','y',' ',' '),     HB_TAG('F','R','I',' ')},       \/* Western Frisian -> Frisian *\/\n+  {HB_TAG('g','a',' ',' '),     HB_TAG('I','R','I',' ')},       \/* Irish *\/\n+  {HB_TAG('g','d',' ',' '),     HB_TAG('G','A','E',' ')},       \/* Scottish Gaelic (Gaelic) *\/\n+  {HB_TAG('g','l',' ',' '),     HB_TAG('G','A','L',' ')},       \/* Galician *\/\n+  {HB_TAG('g','n',' ',' '),     HB_TAG('G','U','A',' ')},       \/* Guarani [macrolanguage] *\/\n+  {HB_TAG('g','u',' ',' '),     HB_TAG('G','U','J',' ')},       \/* Gujarati *\/\n+  {HB_TAG('g','v',' ',' '),     HB_TAG('M','N','X',' ')},       \/* Manx *\/\n+  {HB_TAG('h','a',' ',' '),     HB_TAG('H','A','U',' ')},       \/* Hausa *\/\n+  {HB_TAG('h','e',' ',' '),     HB_TAG('I','W','R',' ')},       \/* Hebrew *\/\n+  {HB_TAG('h','i',' ',' '),     HB_TAG('H','I','N',' ')},       \/* Hindi *\/\n+  {HB_TAG('h','o',' ',' '),     HB_TAG('H','M','O',' ')},       \/* Hiri Motu *\/\n+  {HB_TAG('h','o',' ',' '),     HB_TAG('C','P','P',' ')},       \/* Hiri Motu -> Creoles *\/\n+  {HB_TAG('h','r',' ',' '),     HB_TAG('H','R','V',' ')},       \/* Croatian *\/\n+  {HB_TAG('h','t',' ',' '),     HB_TAG('H','A','I',' ')},       \/* Haitian (Haitian Creole) *\/\n+  {HB_TAG('h','t',' ',' '),     HB_TAG('C','P','P',' ')},       \/* Haitian -> Creoles *\/\n+  {HB_TAG('h','u',' ',' '),     HB_TAG('H','U','N',' ')},       \/* Hungarian *\/\n+  {HB_TAG('h','y',' ',' '),     HB_TAG('H','Y','E','0')},       \/* Armenian -> Armenian East *\/\n+  {HB_TAG('h','y',' ',' '),     HB_TAG('H','Y','E',' ')},       \/* Armenian *\/\n+  {HB_TAG('h','z',' ',' '),     HB_TAG('H','E','R',' ')},       \/* Herero *\/\n+  {HB_TAG('i','a',' ',' '),     HB_TAG('I','N','A',' ')},       \/* Interlingua (International Auxiliary Language Association) *\/\n+  {HB_TAG('i','d',' ',' '),     HB_TAG('I','N','D',' ')},       \/* Indonesian *\/\n+  {HB_TAG('i','d',' ',' '),     HB_TAG('M','L','Y',' ')},       \/* Indonesian -> Malay *\/\n+  {HB_TAG('i','e',' ',' '),     HB_TAG('I','L','E',' ')},       \/* Interlingue *\/\n+  {HB_TAG('i','g',' ',' '),     HB_TAG('I','B','O',' ')},       \/* Igbo *\/\n+  {HB_TAG('i','i',' ',' '),     HB_TAG('Y','I','M',' ')},       \/* Sichuan Yi -> Yi Modern *\/\n+  {HB_TAG('i','k',' ',' '),     HB_TAG('I','P','K',' ')},       \/* Inupiaq [macrolanguage] -> Inupiat *\/\n+  {HB_TAG('i','n',' ',' '),     HB_TAG('I','N','D',' ')},       \/* Indonesian (retired code) *\/\n+  {HB_TAG('i','n',' ',' '),     HB_TAG('M','L','Y',' ')},       \/* Indonesian (retired code) -> Malay *\/\n+  {HB_TAG('i','o',' ',' '),     HB_TAG('I','D','O',' ')},       \/* Ido *\/\n+  {HB_TAG('i','s',' ',' '),     HB_TAG('I','S','L',' ')},       \/* Icelandic *\/\n+  {HB_TAG('i','t',' ',' '),     HB_TAG('I','T','A',' ')},       \/* Italian *\/\n+  {HB_TAG('i','u',' ',' '),     HB_TAG('I','N','U',' ')},       \/* Inuktitut [macrolanguage] *\/\n+  {HB_TAG('i','u',' ',' '),     HB_TAG('I','N','U','K')},       \/* Inuktitut [macrolanguage] -> Nunavik Inuktitut *\/\n+  {HB_TAG('i','w',' ',' '),     HB_TAG('I','W','R',' ')},       \/* Hebrew (retired code) *\/\n+  {HB_TAG('j','a',' ',' '),     HB_TAG('J','A','N',' ')},       \/* Japanese *\/\n+  {HB_TAG('j','i',' ',' '),     HB_TAG('J','I','I',' ')},       \/* Yiddish (retired code) *\/\n+  {HB_TAG('j','v',' ',' '),     HB_TAG('J','A','V',' ')},       \/* Javanese *\/\n+  {HB_TAG('j','w',' ',' '),     HB_TAG('J','A','V',' ')},       \/* Javanese (retired code) *\/\n+  {HB_TAG('k','a',' ',' '),     HB_TAG('K','A','T',' ')},       \/* Georgian *\/\n+  {HB_TAG('k','g',' ',' '),     HB_TAG('K','O','N','0')},       \/* Kongo [macrolanguage] *\/\n+  {HB_TAG('k','i',' ',' '),     HB_TAG('K','I','K',' ')},       \/* Kikuyu (Gikuyu) *\/\n+  {HB_TAG('k','j',' ',' '),     HB_TAG('K','U','A',' ')},       \/* Kuanyama *\/\n+  {HB_TAG('k','k',' ',' '),     HB_TAG('K','A','Z',' ')},       \/* Kazakh *\/\n+  {HB_TAG('k','l',' ',' '),     HB_TAG('G','R','N',' ')},       \/* Greenlandic *\/\n+  {HB_TAG('k','m',' ',' '),     HB_TAG('K','H','M',' ')},       \/* Khmer *\/\n+  {HB_TAG('k','n',' ',' '),     HB_TAG('K','A','N',' ')},       \/* Kannada *\/\n+  {HB_TAG('k','o',' ',' '),     HB_TAG('K','O','R',' ')},       \/* Korean *\/\n+  {HB_TAG('k','o',' ',' '),     HB_TAG('K','O','H',' ')},       \/* Korean -> Korean Old Hangul *\/\n+  {HB_TAG('k','r',' ',' '),     HB_TAG('K','N','R',' ')},       \/* Kanuri [macrolanguage] *\/\n+  {HB_TAG('k','s',' ',' '),     HB_TAG('K','S','H',' ')},       \/* Kashmiri *\/\n+  {HB_TAG('k','u',' ',' '),     HB_TAG('K','U','R',' ')},       \/* Kurdish [macrolanguage] *\/\n+  {HB_TAG('k','v',' ',' '),     HB_TAG('K','O','M',' ')},       \/* Komi [macrolanguage] *\/\n+  {HB_TAG('k','w',' ',' '),     HB_TAG('C','O','R',' ')},       \/* Cornish *\/\n+  {HB_TAG('k','y',' ',' '),     HB_TAG('K','I','R',' ')},       \/* Kirghiz (Kyrgyz) *\/\n+  {HB_TAG('l','a',' ',' '),     HB_TAG('L','A','T',' ')},       \/* Latin *\/\n+  {HB_TAG('l','b',' ',' '),     HB_TAG('L','T','Z',' ')},       \/* Luxembourgish *\/\n+  {HB_TAG('l','g',' ',' '),     HB_TAG('L','U','G',' ')},       \/* Ganda *\/\n+  {HB_TAG('l','i',' ',' '),     HB_TAG('L','I','M',' ')},       \/* Limburgish *\/\n+  {HB_TAG('l','n',' ',' '),     HB_TAG('L','I','N',' ')},       \/* Lingala *\/\n+  {HB_TAG('l','o',' ',' '),     HB_TAG('L','A','O',' ')},       \/* Lao *\/\n+  {HB_TAG('l','t',' ',' '),     HB_TAG('L','T','H',' ')},       \/* Lithuanian *\/\n+  {HB_TAG('l','u',' ',' '),     HB_TAG('L','U','B',' ')},       \/* Luba-Katanga *\/\n+  {HB_TAG('l','v',' ',' '),     HB_TAG('L','V','I',' ')},       \/* Latvian [macrolanguage] *\/\n+  {HB_TAG('m','g',' ',' '),     HB_TAG('M','L','G',' ')},       \/* Malagasy [macrolanguage] *\/\n+  {HB_TAG('m','h',' ',' '),     HB_TAG('M','A','H',' ')},       \/* Marshallese *\/\n+  {HB_TAG('m','i',' ',' '),     HB_TAG('M','R','I',' ')},       \/* Maori *\/\n+  {HB_TAG('m','k',' ',' '),     HB_TAG('M','K','D',' ')},       \/* Macedonian *\/\n+  {HB_TAG('m','l',' ',' '),     HB_TAG('M','A','L',' ')},       \/* Malayalam -> Malayalam Traditional *\/\n+  {HB_TAG('m','l',' ',' '),     HB_TAG('M','L','R',' ')},       \/* Malayalam -> Malayalam Reformed *\/\n+  {HB_TAG('m','n',' ',' '),     HB_TAG('M','N','G',' ')},       \/* Mongolian [macrolanguage] *\/\n+  {HB_TAG('m','o',' ',' '),     HB_TAG('M','O','L',' ')},       \/* Moldavian (retired code) *\/\n+  {HB_TAG('m','o',' ',' '),     HB_TAG('R','O','M',' ')},       \/* Moldavian (retired code) -> Romanian *\/\n+  {HB_TAG('m','r',' ',' '),     HB_TAG('M','A','R',' ')},       \/* Marathi *\/\n+  {HB_TAG('m','s',' ',' '),     HB_TAG('M','L','Y',' ')},       \/* Malay [macrolanguage] *\/\n+  {HB_TAG('m','t',' ',' '),     HB_TAG('M','T','S',' ')},       \/* Maltese *\/\n+  {HB_TAG('m','y',' ',' '),     HB_TAG('B','R','M',' ')},       \/* Burmese *\/\n+  {HB_TAG('n','a',' ',' '),     HB_TAG('N','A','U',' ')},       \/* Nauru -> Nauruan *\/\n+  {HB_TAG('n','b',' ',' '),     HB_TAG('N','O','R',' ')},       \/* Norwegian Bokml -> Norwegian *\/\n+  {HB_TAG('n','d',' ',' '),     HB_TAG('N','D','B',' ')},       \/* North Ndebele -> Ndebele *\/\n+  {HB_TAG('n','e',' ',' '),     HB_TAG('N','E','P',' ')},       \/* Nepali [macrolanguage] *\/\n+  {HB_TAG('n','g',' ',' '),     HB_TAG('N','D','G',' ')},       \/* Ndonga *\/\n+  {HB_TAG('n','l',' ',' '),     HB_TAG('N','L','D',' ')},       \/* Dutch *\/\n+  {HB_TAG('n','n',' ',' '),     HB_TAG('N','Y','N',' ')},       \/* Norwegian Nynorsk (Nynorsk, Norwegian) *\/\n+  {HB_TAG('n','o',' ',' '),     HB_TAG('N','O','R',' ')},       \/* Norwegian [macrolanguage] *\/\n+  {HB_TAG('n','r',' ',' '),     HB_TAG('N','D','B',' ')},       \/* South Ndebele -> Ndebele *\/\n+  {HB_TAG('n','v',' ',' '),     HB_TAG('N','A','V',' ')},       \/* Navajo *\/\n+  {HB_TAG('n','v',' ',' '),     HB_TAG('A','T','H',' ')},       \/* Navajo -> Athapaskan *\/\n+  {HB_TAG('n','y',' ',' '),     HB_TAG('C','H','I',' ')},       \/* Chichewa (Chewa, Nyanja) *\/\n+  {HB_TAG('o','c',' ',' '),     HB_TAG('O','C','I',' ')},       \/* Occitan (post 1500) *\/\n+  {HB_TAG('o','j',' ',' '),     HB_TAG('O','J','B',' ')},       \/* Ojibwa [macrolanguage] -> Ojibway *\/\n+  {HB_TAG('o','m',' ',' '),     HB_TAG('O','R','O',' ')},       \/* Oromo [macrolanguage] *\/\n+  {HB_TAG('o','r',' ',' '),     HB_TAG('O','R','I',' ')},       \/* Odia (formerly Oriya) [macrolanguage] *\/\n+  {HB_TAG('o','s',' ',' '),     HB_TAG('O','S','S',' ')},       \/* Ossetian *\/\n+  {HB_TAG('p','a',' ',' '),     HB_TAG('P','A','N',' ')},       \/* Punjabi *\/\n+  {HB_TAG('p','i',' ',' '),     HB_TAG('P','A','L',' ')},       \/* Pali *\/\n+  {HB_TAG('p','l',' ',' '),     HB_TAG('P','L','K',' ')},       \/* Polish *\/\n+  {HB_TAG('p','s',' ',' '),     HB_TAG('P','A','S',' ')},       \/* Pashto [macrolanguage] *\/\n+  {HB_TAG('p','t',' ',' '),     HB_TAG('P','T','G',' ')},       \/* Portuguese *\/\n+  {HB_TAG('q','u',' ',' '),     HB_TAG('Q','U','Z',' ')},       \/* Quechua [macrolanguage] *\/\n+  {HB_TAG('r','m',' ',' '),     HB_TAG('R','M','S',' ')},       \/* Romansh *\/\n+  {HB_TAG('r','n',' ',' '),     HB_TAG('R','U','N',' ')},       \/* Rundi *\/\n+  {HB_TAG('r','o',' ',' '),     HB_TAG('R','O','M',' ')},       \/* Romanian *\/\n+  {HB_TAG('r','u',' ',' '),     HB_TAG('R','U','S',' ')},       \/* Russian *\/\n+  {HB_TAG('r','w',' ',' '),     HB_TAG('R','U','A',' ')},       \/* Kinyarwanda *\/\n+  {HB_TAG('s','a',' ',' '),     HB_TAG('S','A','N',' ')},       \/* Sanskrit *\/\n+  {HB_TAG('s','c',' ',' '),     HB_TAG('S','R','D',' ')},       \/* Sardinian [macrolanguage] *\/\n+  {HB_TAG('s','d',' ',' '),     HB_TAG('S','N','D',' ')},       \/* Sindhi *\/\n+  {HB_TAG('s','e',' ',' '),     HB_TAG('N','S','M',' ')},       \/* Northern Sami *\/\n+  {HB_TAG('s','g',' ',' '),     HB_TAG('S','G','O',' ')},       \/* Sango *\/\n+  {HB_TAG('s','h',' ',' '),     HB_TAG('B','O','S',' ')},       \/* Serbo-Croatian [macrolanguage] -> Bosnian *\/\n+  {HB_TAG('s','h',' ',' '),     HB_TAG('H','R','V',' ')},       \/* Serbo-Croatian [macrolanguage] -> Croatian *\/\n+  {HB_TAG('s','h',' ',' '),     HB_TAG('S','R','B',' ')},       \/* Serbo-Croatian [macrolanguage] -> Serbian *\/\n+  {HB_TAG('s','i',' ',' '),     HB_TAG('S','N','H',' ')},       \/* Sinhala (Sinhalese) *\/\n+  {HB_TAG('s','k',' ',' '),     HB_TAG('S','K','Y',' ')},       \/* Slovak *\/\n+  {HB_TAG('s','l',' ',' '),     HB_TAG('S','L','V',' ')},       \/* Slovenian *\/\n+  {HB_TAG('s','m',' ',' '),     HB_TAG('S','M','O',' ')},       \/* Samoan *\/\n+  {HB_TAG('s','n',' ',' '),     HB_TAG('S','N','A','0')},       \/* Shona *\/\n+  {HB_TAG('s','o',' ',' '),     HB_TAG('S','M','L',' ')},       \/* Somali *\/\n+  {HB_TAG('s','q',' ',' '),     HB_TAG('S','Q','I',' ')},       \/* Albanian [macrolanguage] *\/\n+  {HB_TAG('s','r',' ',' '),     HB_TAG('S','R','B',' ')},       \/* Serbian *\/\n+  {HB_TAG('s','s',' ',' '),     HB_TAG('S','W','Z',' ')},       \/* Swati *\/\n+  {HB_TAG('s','t',' ',' '),     HB_TAG('S','O','T',' ')},       \/* Southern Sotho *\/\n+  {HB_TAG('s','u',' ',' '),     HB_TAG('S','U','N',' ')},       \/* Sundanese *\/\n+  {HB_TAG('s','v',' ',' '),     HB_TAG('S','V','E',' ')},       \/* Swedish *\/\n+  {HB_TAG('s','w',' ',' '),     HB_TAG('S','W','K',' ')},       \/* Swahili [macrolanguage] *\/\n+  {HB_TAG('t','a',' ',' '),     HB_TAG('T','A','M',' ')},       \/* Tamil *\/\n+  {HB_TAG('t','e',' ',' '),     HB_TAG('T','E','L',' ')},       \/* Telugu *\/\n+  {HB_TAG('t','g',' ',' '),     HB_TAG('T','A','J',' ')},       \/* Tajik -> Tajiki *\/\n+  {HB_TAG('t','h',' ',' '),     HB_TAG('T','H','A',' ')},       \/* Thai *\/\n+  {HB_TAG('t','i',' ',' '),     HB_TAG('T','G','Y',' ')},       \/* Tigrinya *\/\n+  {HB_TAG('t','k',' ',' '),     HB_TAG('T','K','M',' ')},       \/* Turkmen *\/\n+  {HB_TAG('t','l',' ',' '),     HB_TAG('T','G','L',' ')},       \/* Tagalog *\/\n+  {HB_TAG('t','n',' ',' '),     HB_TAG('T','N','A',' ')},       \/* Tswana *\/\n+  {HB_TAG('t','o',' ',' '),     HB_TAG('T','G','N',' ')},       \/* Tonga (Tonga Islands) -> Tongan *\/\n+  {HB_TAG('t','r',' ',' '),     HB_TAG('T','R','K',' ')},       \/* Turkish *\/\n+  {HB_TAG('t','s',' ',' '),     HB_TAG('T','S','G',' ')},       \/* Tsonga *\/\n+  {HB_TAG('t','t',' ',' '),     HB_TAG('T','A','T',' ')},       \/* Tatar *\/\n+  {HB_TAG('t','w',' ',' '),     HB_TAG('T','W','I',' ')},       \/* Twi *\/\n+  {HB_TAG('t','w',' ',' '),     HB_TAG('A','K','A',' ')},       \/* Twi -> Akan *\/\n+  {HB_TAG('t','y',' ',' '),     HB_TAG('T','H','T',' ')},       \/* Tahitian *\/\n+  {HB_TAG('u','g',' ',' '),     HB_TAG('U','Y','G',' ')},       \/* Uyghur *\/\n+  {HB_TAG('u','k',' ',' '),     HB_TAG('U','K','R',' ')},       \/* Ukrainian *\/\n+  {HB_TAG('u','r',' ',' '),     HB_TAG('U','R','D',' ')},       \/* Urdu *\/\n+  {HB_TAG('u','z',' ',' '),     HB_TAG('U','Z','B',' ')},       \/* Uzbek [macrolanguage] *\/\n+  {HB_TAG('v','e',' ',' '),     HB_TAG('V','E','N',' ')},       \/* Venda *\/\n+  {HB_TAG('v','i',' ',' '),     HB_TAG('V','I','T',' ')},       \/* Vietnamese *\/\n+  {HB_TAG('v','o',' ',' '),     HB_TAG('V','O','L',' ')},       \/* Volapk *\/\n+  {HB_TAG('w','a',' ',' '),     HB_TAG('W','L','N',' ')},       \/* Walloon *\/\n+  {HB_TAG('w','o',' ',' '),     HB_TAG('W','L','F',' ')},       \/* Wolof *\/\n+  {HB_TAG('x','h',' ',' '),     HB_TAG('X','H','S',' ')},       \/* Xhosa *\/\n+  {HB_TAG('y','i',' ',' '),     HB_TAG('J','I','I',' ')},       \/* Yiddish [macrolanguage] *\/\n+  {HB_TAG('y','o',' ',' '),     HB_TAG('Y','B','A',' ')},       \/* Yoruba *\/\n+  {HB_TAG('z','a',' ',' '),     HB_TAG('Z','H','A',' ')},       \/* Zhuang [macrolanguage] *\/\n+  {HB_TAG('z','h',' ',' '),     HB_TAG('Z','H','S',' ')},       \/* Chinese, Simplified [macrolanguage] *\/\n+  {HB_TAG('z','u',' ',' '),     HB_TAG('Z','U','L',' ')},       \/* Zulu *\/\n@@ -1589,0 +222,1405 @@\n+#ifndef HB_NO_LANGUAGE_LONG\n+static const LangTag ot_languages3[] = {\n+  {HB_TAG('a','a','e',' '),     HB_TAG('S','Q','I',' ')},       \/* Arbresh Albanian -> Albanian *\/\n+  {HB_TAG('a','a','o',' '),     HB_TAG('A','R','A',' ')},       \/* Algerian Saharan Arabic -> Arabic *\/\n+  {HB_TAG('a','a','t',' '),     HB_TAG('S','Q','I',' ')},       \/* Arvanitika Albanian -> Albanian *\/\n+  {HB_TAG('a','b','a',' '),     HB_TAG_NONE            },       \/* Ab != Abaza *\/\n+  {HB_TAG('a','b','h',' '),     HB_TAG('A','R','A',' ')},       \/* Tajiki Arabic -> Arabic *\/\n+  {HB_TAG('a','b','q',' '),     HB_TAG('A','B','A',' ')},       \/* Abaza *\/\n+  {HB_TAG('a','b','s',' '),     HB_TAG('C','P','P',' ')},       \/* Ambonese Malay -> Creoles *\/\n+  {HB_TAG('a','b','v',' '),     HB_TAG('A','R','A',' ')},       \/* Baharna Arabic -> Arabic *\/\n+  {HB_TAG('a','c','f',' '),     HB_TAG('F','A','N',' ')},       \/* Saint Lucian Creole French -> French Antillean *\/\n+  {HB_TAG('a','c','f',' '),     HB_TAG('C','P','P',' ')},       \/* Saint Lucian Creole French -> Creoles *\/\n+\/*{HB_TAG('a','c','h',' '),     HB_TAG('A','C','H',' ')},*\/     \/* Acoli -> Acholi *\/\n+  {HB_TAG('a','c','m',' '),     HB_TAG('A','R','A',' ')},       \/* Mesopotamian Arabic -> Arabic *\/\n+  {HB_TAG('a','c','q',' '),     HB_TAG('A','R','A',' ')},       \/* Ta'izzi-Adeni Arabic -> Arabic *\/\n+  {HB_TAG('a','c','r',' '),     HB_TAG('A','C','R',' ')},       \/* Achi *\/\n+  {HB_TAG('a','c','r',' '),     HB_TAG('M','Y','N',' ')},       \/* Achi -> Mayan *\/\n+  {HB_TAG('a','c','w',' '),     HB_TAG('A','R','A',' ')},       \/* Hijazi Arabic -> Arabic *\/\n+  {HB_TAG('a','c','x',' '),     HB_TAG('A','R','A',' ')},       \/* Omani Arabic -> Arabic *\/\n+  {HB_TAG('a','c','y',' '),     HB_TAG('A','R','A',' ')},       \/* Cypriot Arabic -> Arabic *\/\n+  {HB_TAG('a','d','a',' '),     HB_TAG('D','N','G',' ')},       \/* Adangme -> Dangme *\/\n+  {HB_TAG('a','d','f',' '),     HB_TAG('A','R','A',' ')},       \/* Dhofari Arabic -> Arabic *\/\n+  {HB_TAG('a','d','p',' '),     HB_TAG('D','Z','N',' ')},       \/* Adap (retired code) -> Dzongkha *\/\n+\/*{HB_TAG('a','d','y',' '),     HB_TAG('A','D','Y',' ')},*\/     \/* Adyghe *\/\n+  {HB_TAG('a','e','b',' '),     HB_TAG('A','R','A',' ')},       \/* Tunisian Arabic -> Arabic *\/\n+  {HB_TAG('a','e','c',' '),     HB_TAG('A','R','A',' ')},       \/* Saidi Arabic -> Arabic *\/\n+  {HB_TAG('a','f','b',' '),     HB_TAG('A','R','A',' ')},       \/* Gulf Arabic -> Arabic *\/\n+  {HB_TAG('a','f','k',' '),     HB_TAG_NONE            },       \/* Nanubae != Afrikaans *\/\n+  {HB_TAG('a','f','s',' '),     HB_TAG('C','P','P',' ')},       \/* Afro-Seminole Creole -> Creoles *\/\n+  {HB_TAG('a','g','u',' '),     HB_TAG('M','Y','N',' ')},       \/* Aguacateco -> Mayan *\/\n+  {HB_TAG('a','g','w',' '),     HB_TAG_NONE            },       \/* Kahua != Agaw *\/\n+  {HB_TAG('a','h','g',' '),     HB_TAG('A','G','W',' ')},       \/* Qimant -> Agaw *\/\n+  {HB_TAG('a','h','t',' '),     HB_TAG('A','T','H',' ')},       \/* Ahtena -> Athapaskan *\/\n+  {HB_TAG('a','i','g',' '),     HB_TAG('C','P','P',' ')},       \/* Antigua and Barbuda Creole English -> Creoles *\/\n+  {HB_TAG('a','i','i',' '),     HB_TAG('S','W','A',' ')},       \/* Assyrian Neo-Aramaic -> Swadaya Aramaic *\/\n+  {HB_TAG('a','i','i',' '),     HB_TAG('S','Y','R',' ')},       \/* Assyrian Neo-Aramaic -> Syriac *\/\n+\/*{HB_TAG('a','i','o',' '),     HB_TAG('A','I','O',' ')},*\/     \/* Aiton *\/\n+  {HB_TAG('a','i','w',' '),     HB_TAG('A','R','I',' ')},       \/* Aari *\/\n+  {HB_TAG('a','j','p',' '),     HB_TAG('A','R','A',' ')},       \/* South Levantine Arabic -> Arabic *\/\n+  {HB_TAG('a','j','t',' '),     HB_TAG('A','R','A',' ')},       \/* Judeo-Tunisian Arabic (retired code) -> Arabic *\/\n+  {HB_TAG('a','k','b',' '),     HB_TAG('A','K','B',' ')},       \/* Batak Angkola *\/\n+  {HB_TAG('a','k','b',' '),     HB_TAG('B','T','K',' ')},       \/* Batak Angkola -> Batak *\/\n+  {HB_TAG('a','l','n',' '),     HB_TAG('S','Q','I',' ')},       \/* Gheg Albanian -> Albanian *\/\n+  {HB_TAG('a','l','s',' '),     HB_TAG('S','Q','I',' ')},       \/* Tosk Albanian -> Albanian *\/\n+\/*{HB_TAG('a','l','t',' '),     HB_TAG('A','L','T',' ')},*\/     \/* Southern Altai -> Altai *\/\n+  {HB_TAG('a','m','f',' '),     HB_TAG('H','B','N',' ')},       \/* Hamer-Banna -> Hammer-Banna *\/\n+  {HB_TAG('a','m','w',' '),     HB_TAG('S','Y','R',' ')},       \/* Western Neo-Aramaic -> Syriac *\/\n+\/*{HB_TAG('a','n','g',' '),     HB_TAG('A','N','G',' ')},*\/     \/* Old English (ca. 450-1100) -> Anglo-Saxon *\/\n+  {HB_TAG('a','o','a',' '),     HB_TAG('C','P','P',' ')},       \/* Angolar -> Creoles *\/\n+  {HB_TAG('a','p','a',' '),     HB_TAG('A','T','H',' ')},       \/* Apache [collection] -> Athapaskan *\/\n+  {HB_TAG('a','p','c',' '),     HB_TAG('A','R','A',' ')},       \/* North Levantine Arabic -> Arabic *\/\n+  {HB_TAG('a','p','d',' '),     HB_TAG('A','R','A',' ')},       \/* Sudanese Arabic -> Arabic *\/\n+  {HB_TAG('a','p','j',' '),     HB_TAG('A','T','H',' ')},       \/* Jicarilla Apache -> Athapaskan *\/\n+  {HB_TAG('a','p','k',' '),     HB_TAG('A','T','H',' ')},       \/* Kiowa Apache -> Athapaskan *\/\n+  {HB_TAG('a','p','l',' '),     HB_TAG('A','T','H',' ')},       \/* Lipan Apache -> Athapaskan *\/\n+  {HB_TAG('a','p','m',' '),     HB_TAG('A','T','H',' ')},       \/* Mescalero-Chiricahua Apache -> Athapaskan *\/\n+  {HB_TAG('a','p','w',' '),     HB_TAG('A','T','H',' ')},       \/* Western Apache -> Athapaskan *\/\n+  {HB_TAG('a','r','b',' '),     HB_TAG('A','R','A',' ')},       \/* Standard Arabic -> Arabic *\/\n+  {HB_TAG('a','r','i',' '),     HB_TAG_NONE            },       \/* Arikara != Aari *\/\n+  {HB_TAG('a','r','k',' '),     HB_TAG_NONE            },       \/* Arikap != Rakhine *\/\n+  {HB_TAG('a','r','n',' '),     HB_TAG('M','A','P',' ')},       \/* Mapudungun *\/\n+  {HB_TAG('a','r','q',' '),     HB_TAG('A','R','A',' ')},       \/* Algerian Arabic -> Arabic *\/\n+  {HB_TAG('a','r','s',' '),     HB_TAG('A','R','A',' ')},       \/* Najdi Arabic -> Arabic *\/\n+  {HB_TAG('a','r','y',' '),     HB_TAG('M','O','R',' ')},       \/* Moroccan Arabic -> Moroccan *\/\n+  {HB_TAG('a','r','y',' '),     HB_TAG('A','R','A',' ')},       \/* Moroccan Arabic -> Arabic *\/\n+  {HB_TAG('a','r','z',' '),     HB_TAG('A','R','A',' ')},       \/* Egyptian Arabic -> Arabic *\/\n+\/*{HB_TAG('a','s','t',' '),     HB_TAG('A','S','T',' ')},*\/     \/* Asturian *\/\n+\/*{HB_TAG('a','t','h',' '),     HB_TAG('A','T','H',' ')},*\/     \/* Athapascan [collection] -> Athapaskan *\/\n+  {HB_TAG('a','t','j',' '),     HB_TAG('R','C','R',' ')},       \/* Atikamekw -> R-Cree *\/\n+  {HB_TAG('a','t','v',' '),     HB_TAG('A','L','T',' ')},       \/* Northern Altai -> Altai *\/\n+  {HB_TAG('a','u','j',' '),     HB_TAG('B','B','R',' ')},       \/* Awjilah -> Berber *\/\n+  {HB_TAG('a','u','z',' '),     HB_TAG('A','R','A',' ')},       \/* Uzbeki Arabic -> Arabic *\/\n+  {HB_TAG('a','v','l',' '),     HB_TAG('A','R','A',' ')},       \/* Eastern Egyptian Bedawi Arabic -> Arabic *\/\n+\/*{HB_TAG('a','v','n',' '),     HB_TAG('A','V','N',' ')},*\/     \/* Avatime *\/\n+\/*{HB_TAG('a','w','a',' '),     HB_TAG('A','W','A',' ')},*\/     \/* Awadhi *\/\n+  {HB_TAG('a','y','c',' '),     HB_TAG('A','Y','M',' ')},       \/* Southern Aymara -> Aymara *\/\n+  {HB_TAG('a','y','h',' '),     HB_TAG('A','R','A',' ')},       \/* Hadrami Arabic -> Arabic *\/\n+  {HB_TAG('a','y','l',' '),     HB_TAG('A','R','A',' ')},       \/* Libyan Arabic -> Arabic *\/\n+  {HB_TAG('a','y','n',' '),     HB_TAG('A','R','A',' ')},       \/* Sanaani Arabic -> Arabic *\/\n+  {HB_TAG('a','y','p',' '),     HB_TAG('A','R','A',' ')},       \/* North Mesopotamian Arabic -> Arabic *\/\n+  {HB_TAG('a','y','r',' '),     HB_TAG('A','Y','M',' ')},       \/* Central Aymara -> Aymara *\/\n+  {HB_TAG('a','z','b',' '),     HB_TAG('A','Z','B',' ')},       \/* South Azerbaijani -> Torki *\/\n+  {HB_TAG('a','z','b',' '),     HB_TAG('A','Z','E',' ')},       \/* South Azerbaijani -> Azerbaijani *\/\n+  {HB_TAG('a','z','d',' '),     HB_TAG('N','A','H',' ')},       \/* Eastern Durango Nahuatl -> Nahuatl *\/\n+  {HB_TAG('a','z','j',' '),     HB_TAG('A','Z','E',' ')},       \/* North Azerbaijani -> Azerbaijani *\/\n+  {HB_TAG('a','z','n',' '),     HB_TAG('N','A','H',' ')},       \/* Western Durango Nahuatl -> Nahuatl *\/\n+  {HB_TAG('a','z','z',' '),     HB_TAG('N','A','H',' ')},       \/* Highland Puebla Nahuatl -> Nahuatl *\/\n+  {HB_TAG('b','a','d',' '),     HB_TAG('B','A','D','0')},       \/* Banda [collection] *\/\n+  {HB_TAG('b','a','g',' '),     HB_TAG_NONE            },       \/* Tuki != Baghelkhandi *\/\n+  {HB_TAG('b','a','h',' '),     HB_TAG('C','P','P',' ')},       \/* Bahamas Creole English -> Creoles *\/\n+  {HB_TAG('b','a','i',' '),     HB_TAG('B','M','L',' ')},       \/* Bamileke [collection] *\/\n+  {HB_TAG('b','a','l',' '),     HB_TAG('B','L','I',' ')},       \/* Baluchi [macrolanguage] *\/\n+\/*{HB_TAG('b','a','n',' '),     HB_TAG('B','A','N',' ')},*\/     \/* Balinese *\/\n+\/*{HB_TAG('b','a','r',' '),     HB_TAG('B','A','R',' ')},*\/     \/* Bavarian *\/\n+  {HB_TAG('b','a','u',' '),     HB_TAG_NONE            },       \/* Bada (Nigeria) != Baul *\/\n+  {HB_TAG('b','b','c',' '),     HB_TAG('B','B','C',' ')},       \/* Batak Toba *\/\n+  {HB_TAG('b','b','c',' '),     HB_TAG('B','T','K',' ')},       \/* Batak Toba -> Batak *\/\n+  {HB_TAG('b','b','j',' '),     HB_TAG('B','M','L',' ')},       \/* Ghoml' -> Bamileke *\/\n+  {HB_TAG('b','b','p',' '),     HB_TAG('B','A','D','0')},       \/* West Central Banda -> Banda *\/\n+  {HB_TAG('b','b','r',' '),     HB_TAG_NONE            },       \/* Girawa != Berber *\/\n+  {HB_TAG('b','b','z',' '),     HB_TAG('A','R','A',' ')},       \/* Babalia Creole Arabic (retired code) -> Arabic *\/\n+  {HB_TAG('b','c','c',' '),     HB_TAG('B','L','I',' ')},       \/* Southern Balochi -> Baluchi *\/\n+  {HB_TAG('b','c','h',' '),     HB_TAG_NONE            },       \/* Bariai != Bench *\/\n+  {HB_TAG('b','c','i',' '),     HB_TAG('B','A','U',' ')},       \/* Baoul -> Baul *\/\n+  {HB_TAG('b','c','l',' '),     HB_TAG('B','I','K',' ')},       \/* Central Bikol -> Bikol *\/\n+  {HB_TAG('b','c','q',' '),     HB_TAG('B','C','H',' ')},       \/* Bench *\/\n+  {HB_TAG('b','c','r',' '),     HB_TAG('A','T','H',' ')},       \/* Babine -> Athapaskan *\/\n+\/*{HB_TAG('b','d','y',' '),     HB_TAG('B','D','Y',' ')},*\/     \/* Bandjalang *\/\n+  {HB_TAG('b','e','a',' '),     HB_TAG('A','T','H',' ')},       \/* Beaver -> Athapaskan *\/\n+  {HB_TAG('b','e','b',' '),     HB_TAG('B','T','I',' ')},       \/* Bebele -> Beti *\/\n+\/*{HB_TAG('b','e','m',' '),     HB_TAG('B','E','M',' ')},*\/     \/* Bemba (Zambia) *\/\n+  {HB_TAG('b','e','r',' '),     HB_TAG('B','B','R',' ')},       \/* Berber [collection] *\/\n+  {HB_TAG('b','e','w',' '),     HB_TAG('C','P','P',' ')},       \/* Betawi -> Creoles *\/\n+  {HB_TAG('b','f','l',' '),     HB_TAG('B','A','D','0')},       \/* Banda-Ndl -> Banda *\/\n+  {HB_TAG('b','f','q',' '),     HB_TAG('B','A','D',' ')},       \/* Badaga *\/\n+  {HB_TAG('b','f','t',' '),     HB_TAG('B','L','T',' ')},       \/* Balti *\/\n+  {HB_TAG('b','f','u',' '),     HB_TAG('L','A','H',' ')},       \/* Gahri -> Lahuli *\/\n+  {HB_TAG('b','f','y',' '),     HB_TAG('B','A','G',' ')},       \/* Bagheli -> Baghelkhandi *\/\n+\/*{HB_TAG('b','g','c',' '),     HB_TAG('B','G','C',' ')},*\/     \/* Haryanvi *\/\n+  {HB_TAG('b','g','n',' '),     HB_TAG('B','L','I',' ')},       \/* Western Balochi -> Baluchi *\/\n+  {HB_TAG('b','g','p',' '),     HB_TAG('B','L','I',' ')},       \/* Eastern Balochi -> Baluchi *\/\n+  {HB_TAG('b','g','q',' '),     HB_TAG('B','G','Q',' ')},       \/* Bagri *\/\n+  {HB_TAG('b','g','q',' '),     HB_TAG('R','A','J',' ')},       \/* Bagri -> Rajasthani *\/\n+  {HB_TAG('b','g','r',' '),     HB_TAG('Q','I','N',' ')},       \/* Bawm Chin -> Chin *\/\n+  {HB_TAG('b','h','b',' '),     HB_TAG('B','H','I',' ')},       \/* Bhili *\/\n+\/*{HB_TAG('b','h','i',' '),     HB_TAG('B','H','I',' ')},*\/     \/* Bhilali -> Bhili *\/\n+  {HB_TAG('b','h','k',' '),     HB_TAG('B','I','K',' ')},       \/* Albay Bicolano (retired code) -> Bikol *\/\n+\/*{HB_TAG('b','h','o',' '),     HB_TAG('B','H','O',' ')},*\/     \/* Bhojpuri *\/\n+  {HB_TAG('b','h','r',' '),     HB_TAG('M','L','G',' ')},       \/* Bara Malagasy -> Malagasy *\/\n+\/*{HB_TAG('b','i','k',' '),     HB_TAG('B','I','K',' ')},*\/     \/* Bikol [macrolanguage] *\/\n+  {HB_TAG('b','i','l',' '),     HB_TAG_NONE            },       \/* Bile != Bilen *\/\n+  {HB_TAG('b','i','n',' '),     HB_TAG('E','D','O',' ')},       \/* Edo *\/\n+  {HB_TAG('b','i','u',' '),     HB_TAG('Q','I','N',' ')},       \/* Biete -> Chin *\/\n+\/*{HB_TAG('b','j','j',' '),     HB_TAG('B','J','J',' ')},*\/     \/* Kanauji *\/\n+  {HB_TAG('b','j','n',' '),     HB_TAG('M','L','Y',' ')},       \/* Banjar -> Malay *\/\n+  {HB_TAG('b','j','o',' '),     HB_TAG('B','A','D','0')},       \/* Mid-Southern Banda -> Banda *\/\n+  {HB_TAG('b','j','q',' '),     HB_TAG('M','L','G',' ')},       \/* Southern Betsimisaraka Malagasy (retired code) -> Malagasy *\/\n+  {HB_TAG('b','j','s',' '),     HB_TAG('C','P','P',' ')},       \/* Bajan -> Creoles *\/\n+  {HB_TAG('b','j','t',' '),     HB_TAG('B','L','N',' ')},       \/* Balanta-Ganja -> Balante *\/\n+  {HB_TAG('b','k','f',' '),     HB_TAG_NONE            },       \/* Beeke != Blackfoot *\/\n+  {HB_TAG('b','k','o',' '),     HB_TAG('B','M','L',' ')},       \/* Kwa' -> Bamileke *\/\n+  {HB_TAG('b','l','a',' '),     HB_TAG('B','K','F',' ')},       \/* Siksika -> Blackfoot *\/\n+  {HB_TAG('b','l','e',' '),     HB_TAG('B','L','N',' ')},       \/* Balanta-Kentohe -> Balante *\/\n+  {HB_TAG('b','l','g',' '),     HB_TAG('I','B','A',' ')},       \/* Balau (retired code) -> Iban *\/\n+  {HB_TAG('b','l','i',' '),     HB_TAG_NONE            },       \/* Bolia != Baluchi *\/\n+  {HB_TAG('b','l','k',' '),     HB_TAG('B','L','K',' ')},       \/* Pao Karen *\/\n+  {HB_TAG('b','l','k',' '),     HB_TAG('K','R','N',' ')},       \/* Pa'o Karen -> Karen *\/\n+  {HB_TAG('b','l','n',' '),     HB_TAG('B','I','K',' ')},       \/* Southern Catanduanes Bikol -> Bikol *\/\n+  {HB_TAG('b','l','t',' '),     HB_TAG_NONE            },       \/* Tai Dam != Balti *\/\n+  {HB_TAG('b','m','b',' '),     HB_TAG_NONE            },       \/* Bembe != Bambara (Bamanankan) *\/\n+  {HB_TAG('b','m','l',' '),     HB_TAG_NONE            },       \/* Bomboli != Bamileke *\/\n+  {HB_TAG('b','m','m',' '),     HB_TAG('M','L','G',' ')},       \/* Northern Betsimisaraka Malagasy -> Malagasy *\/\n+  {HB_TAG('b','p','d',' '),     HB_TAG('B','A','D','0')},       \/* Banda-Banda -> Banda *\/\n+  {HB_TAG('b','p','l',' '),     HB_TAG('C','P','P',' ')},       \/* Broome Pearling Lugger Pidgin -> Creoles *\/\n+  {HB_TAG('b','p','q',' '),     HB_TAG('C','P','P',' ')},       \/* Banda Malay -> Creoles *\/\n+\/*{HB_TAG('b','p','y',' '),     HB_TAG('B','P','Y',' ')},*\/     \/* Bishnupriya -> Bishnupriya Manipuri *\/\n+  {HB_TAG('b','q','i',' '),     HB_TAG('L','R','C',' ')},       \/* Bakhtiari -> Luri *\/\n+  {HB_TAG('b','q','k',' '),     HB_TAG('B','A','D','0')},       \/* Banda-Mbrs -> Banda *\/\n+  {HB_TAG('b','r','a',' '),     HB_TAG('B','R','I',' ')},       \/* Braj -> Braj Bhasha *\/\n+  {HB_TAG('b','r','c',' '),     HB_TAG('C','P','P',' ')},       \/* Berbice Creole Dutch -> Creoles *\/\n+\/*{HB_TAG('b','r','h',' '),     HB_TAG('B','R','H',' ')},*\/     \/* Brahui *\/\n+  {HB_TAG('b','r','i',' '),     HB_TAG_NONE            },       \/* Mokpwe != Braj Bhasha *\/\n+  {HB_TAG('b','r','m',' '),     HB_TAG_NONE            },       \/* Barambu != Burmese *\/\n+\/*{HB_TAG('b','r','x',' '),     HB_TAG('B','R','X',' ')},*\/     \/* Bodo (India) *\/\n+  {HB_TAG('b','s','h',' '),     HB_TAG_NONE            },       \/* Kati != Bashkir *\/\n+\/*{HB_TAG('b','s','k',' '),     HB_TAG('B','S','K',' ')},*\/     \/* Burushaski *\/\n+  {HB_TAG('b','t','b',' '),     HB_TAG('B','T','I',' ')},       \/* Beti (Cameroon) (retired code) *\/\n+  {HB_TAG('b','t','d',' '),     HB_TAG('B','T','D',' ')},       \/* Batak Dairi (Pakpak) *\/\n+  {HB_TAG('b','t','d',' '),     HB_TAG('B','T','K',' ')},       \/* Batak Dairi -> Batak *\/\n+  {HB_TAG('b','t','i',' '),     HB_TAG_NONE            },       \/* Burate != Beti *\/\n+  {HB_TAG('b','t','j',' '),     HB_TAG('M','L','Y',' ')},       \/* Bacanese Malay -> Malay *\/\n+\/*{HB_TAG('b','t','k',' '),     HB_TAG('B','T','K',' ')},*\/     \/* Batak [collection] *\/\n+  {HB_TAG('b','t','m',' '),     HB_TAG('B','T','M',' ')},       \/* Batak Mandailing *\/\n+  {HB_TAG('b','t','m',' '),     HB_TAG('B','T','K',' ')},       \/* Batak Mandailing -> Batak *\/\n+  {HB_TAG('b','t','o',' '),     HB_TAG('B','I','K',' ')},       \/* Rinconada Bikol -> Bikol *\/\n+  {HB_TAG('b','t','s',' '),     HB_TAG('B','T','S',' ')},       \/* Batak Simalungun *\/\n+  {HB_TAG('b','t','s',' '),     HB_TAG('B','T','K',' ')},       \/* Batak Simalungun -> Batak *\/\n+  {HB_TAG('b','t','x',' '),     HB_TAG('B','T','X',' ')},       \/* Batak Karo *\/\n+  {HB_TAG('b','t','x',' '),     HB_TAG('B','T','K',' ')},       \/* Batak Karo -> Batak *\/\n+  {HB_TAG('b','t','z',' '),     HB_TAG('B','T','Z',' ')},       \/* Batak Alas-Kluet *\/\n+  {HB_TAG('b','t','z',' '),     HB_TAG('B','T','K',' ')},       \/* Batak Alas-Kluet -> Batak *\/\n+\/*{HB_TAG('b','u','g',' '),     HB_TAG('B','U','G',' ')},*\/     \/* Buginese -> Bugis *\/\n+  {HB_TAG('b','u','m',' '),     HB_TAG('B','T','I',' ')},       \/* Bulu (Cameroon) -> Beti *\/\n+  {HB_TAG('b','v','e',' '),     HB_TAG('M','L','Y',' ')},       \/* Berau Malay -> Malay *\/\n+  {HB_TAG('b','v','u',' '),     HB_TAG('M','L','Y',' ')},       \/* Bukit Malay -> Malay *\/\n+  {HB_TAG('b','w','e',' '),     HB_TAG('K','R','N',' ')},       \/* Bwe Karen -> Karen *\/\n+  {HB_TAG('b','x','k',' '),     HB_TAG('L','U','H',' ')},       \/* Bukusu -> Luyia *\/\n+  {HB_TAG('b','x','o',' '),     HB_TAG('C','P','P',' ')},       \/* Barikanchi -> Creoles *\/\n+  {HB_TAG('b','x','p',' '),     HB_TAG('B','T','I',' ')},       \/* Bebil -> Beti *\/\n+  {HB_TAG('b','x','r',' '),     HB_TAG('R','B','U',' ')},       \/* Russia Buriat -> Russian Buriat *\/\n+  {HB_TAG('b','y','n',' '),     HB_TAG('B','I','L',' ')},       \/* Bilin -> Bilen *\/\n+  {HB_TAG('b','y','v',' '),     HB_TAG('B','Y','V',' ')},       \/* Medumba *\/\n+  {HB_TAG('b','y','v',' '),     HB_TAG('B','M','L',' ')},       \/* Medumba -> Bamileke *\/\n+  {HB_TAG('b','z','c',' '),     HB_TAG('M','L','G',' ')},       \/* Southern Betsimisaraka Malagasy -> Malagasy *\/\n+  {HB_TAG('b','z','j',' '),     HB_TAG('C','P','P',' ')},       \/* Belize Kriol English -> Creoles *\/\n+  {HB_TAG('b','z','k',' '),     HB_TAG('C','P','P',' ')},       \/* Nicaragua Creole English -> Creoles *\/\n+  {HB_TAG('c','a','a',' '),     HB_TAG('M','Y','N',' ')},       \/* Chort -> Mayan *\/\n+  {HB_TAG('c','a','c',' '),     HB_TAG('M','Y','N',' ')},       \/* Chuj -> Mayan *\/\n+  {HB_TAG('c','a','f',' '),     HB_TAG('C','R','R',' ')},       \/* Southern Carrier -> Carrier *\/\n+  {HB_TAG('c','a','f',' '),     HB_TAG('A','T','H',' ')},       \/* Southern Carrier -> Athapaskan *\/\n+  {HB_TAG('c','a','k',' '),     HB_TAG('C','A','K',' ')},       \/* Kaqchikel *\/\n+  {HB_TAG('c','a','k',' '),     HB_TAG('M','Y','N',' ')},       \/* Kaqchikel -> Mayan *\/\n+  {HB_TAG('c','b','k',' '),     HB_TAG('C','B','K',' ')},       \/* Chavacano -> Zamboanga Chavacano *\/\n+  {HB_TAG('c','b','k',' '),     HB_TAG('C','P','P',' ')},       \/* Chavacano -> Creoles *\/\n+  {HB_TAG('c','b','l',' '),     HB_TAG('Q','I','N',' ')},       \/* Bualkhaw Chin -> Chin *\/\n+  {HB_TAG('c','c','l',' '),     HB_TAG('C','P','P',' ')},       \/* Cutchi-Swahili -> Creoles *\/\n+  {HB_TAG('c','c','m',' '),     HB_TAG('C','P','P',' ')},       \/* Malaccan Creole Malay -> Creoles *\/\n+  {HB_TAG('c','c','o',' '),     HB_TAG('C','C','H','N')},       \/* Comaltepec Chinantec -> Chinantec *\/\n+  {HB_TAG('c','c','q',' '),     HB_TAG('A','R','K',' ')},       \/* Chaungtha (retired code) -> Rakhine *\/\n+  {HB_TAG('c','d','o',' '),     HB_TAG('Z','H','S',' ')},       \/* Min Dong Chinese -> Chinese, Simplified *\/\n+\/*{HB_TAG('c','e','b',' '),     HB_TAG('C','E','B',' ')},*\/     \/* Cebuano *\/\n+  {HB_TAG('c','e','k',' '),     HB_TAG('Q','I','N',' ')},       \/* Eastern Khumi Chin -> Chin *\/\n+  {HB_TAG('c','e','y',' '),     HB_TAG('Q','I','N',' ')},       \/* Ekai Chin -> Chin *\/\n+  {HB_TAG('c','f','m',' '),     HB_TAG('H','A','L',' ')},       \/* Halam (Falam Chin) *\/\n+  {HB_TAG('c','f','m',' '),     HB_TAG('Q','I','N',' ')},       \/* Falam Chin -> Chin *\/\n+\/*{HB_TAG('c','g','g',' '),     HB_TAG('C','G','G',' ')},*\/     \/* Chiga *\/\n+  {HB_TAG('c','h','f',' '),     HB_TAG('M','Y','N',' ')},       \/* Tabasco Chontal -> Mayan *\/\n+  {HB_TAG('c','h','g',' '),     HB_TAG_NONE            },       \/* Chagatai != Chaha Gurage *\/\n+  {HB_TAG('c','h','h',' '),     HB_TAG_NONE            },       \/* Chinook != Chattisgarhi *\/\n+  {HB_TAG('c','h','j',' '),     HB_TAG('C','C','H','N')},       \/* Ojitln Chinantec -> Chinantec *\/\n+  {HB_TAG('c','h','k',' '),     HB_TAG('C','H','K','0')},       \/* Chuukese *\/\n+  {HB_TAG('c','h','m',' '),     HB_TAG('H','M','A',' ')},       \/* Mari (Russia) [macrolanguage] -> High Mari *\/\n+  {HB_TAG('c','h','m',' '),     HB_TAG('L','M','A',' ')},       \/* Mari (Russia) [macrolanguage] -> Low Mari *\/\n+  {HB_TAG('c','h','n',' '),     HB_TAG('C','P','P',' ')},       \/* Chinook jargon -> Creoles *\/\n+\/*{HB_TAG('c','h','o',' '),     HB_TAG('C','H','O',' ')},*\/     \/* Choctaw *\/\n+  {HB_TAG('c','h','p',' '),     HB_TAG('C','H','P',' ')},       \/* Chipewyan *\/\n+  {HB_TAG('c','h','p',' '),     HB_TAG('S','A','Y',' ')},       \/* Chipewyan -> Sayisi *\/\n+  {HB_TAG('c','h','p',' '),     HB_TAG('A','T','H',' ')},       \/* Chipewyan -> Athapaskan *\/\n+  {HB_TAG('c','h','q',' '),     HB_TAG('C','C','H','N')},       \/* Quiotepec Chinantec -> Chinantec *\/\n+\/*{HB_TAG('c','h','r',' '),     HB_TAG('C','H','R',' ')},*\/     \/* Cherokee *\/\n+\/*{HB_TAG('c','h','y',' '),     HB_TAG('C','H','Y',' ')},*\/     \/* Cheyenne *\/\n+  {HB_TAG('c','h','z',' '),     HB_TAG('C','C','H','N')},       \/* Ozumacn Chinantec -> Chinantec *\/\n+  {HB_TAG('c','i','w',' '),     HB_TAG('O','J','B',' ')},       \/* Chippewa -> Ojibway *\/\n+\/*{HB_TAG('c','j','a',' '),     HB_TAG('C','J','A',' ')},*\/     \/* Western Cham *\/\n+\/*{HB_TAG('c','j','m',' '),     HB_TAG('C','J','M',' ')},*\/     \/* Eastern Cham *\/\n+  {HB_TAG('c','j','y',' '),     HB_TAG('Z','H','S',' ')},       \/* Jinyu Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('c','k','a',' '),     HB_TAG('Q','I','N',' ')},       \/* Khumi Awa Chin (retired code) -> Chin *\/\n+  {HB_TAG('c','k','b',' '),     HB_TAG('K','U','R',' ')},       \/* Central Kurdish -> Kurdish *\/\n+  {HB_TAG('c','k','n',' '),     HB_TAG('Q','I','N',' ')},       \/* Kaang Chin -> Chin *\/\n+  {HB_TAG('c','k','s',' '),     HB_TAG('C','P','P',' ')},       \/* Tayo -> Creoles *\/\n+  {HB_TAG('c','k','t',' '),     HB_TAG('C','H','K',' ')},       \/* Chukot -> Chukchi *\/\n+  {HB_TAG('c','k','z',' '),     HB_TAG('M','Y','N',' ')},       \/* Cakchiquel-Quich Mixed Language -> Mayan *\/\n+  {HB_TAG('c','l','c',' '),     HB_TAG('A','T','H',' ')},       \/* Chilcotin -> Athapaskan *\/\n+  {HB_TAG('c','l','d',' '),     HB_TAG('S','Y','R',' ')},       \/* Chaldean Neo-Aramaic -> Syriac *\/\n+  {HB_TAG('c','l','e',' '),     HB_TAG('C','C','H','N')},       \/* Lealao Chinantec -> Chinantec *\/\n+  {HB_TAG('c','l','j',' '),     HB_TAG('Q','I','N',' ')},       \/* Laitu Chin -> Chin *\/\n+  {HB_TAG('c','l','t',' '),     HB_TAG('Q','I','N',' ')},       \/* Lautu Chin -> Chin *\/\n+  {HB_TAG('c','m','n',' '),     HB_TAG('Z','H','S',' ')},       \/* Mandarin Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('c','m','r',' '),     HB_TAG('Q','I','N',' ')},       \/* Mro-Khimi Chin -> Chin *\/\n+  {HB_TAG('c','n','b',' '),     HB_TAG('Q','I','N',' ')},       \/* Chinbon Chin -> Chin *\/\n+  {HB_TAG('c','n','h',' '),     HB_TAG('Q','I','N',' ')},       \/* Hakha Chin -> Chin *\/\n+  {HB_TAG('c','n','k',' '),     HB_TAG('Q','I','N',' ')},       \/* Khumi Chin -> Chin *\/\n+  {HB_TAG('c','n','l',' '),     HB_TAG('C','C','H','N')},       \/* Lalana Chinantec -> Chinantec *\/\n+  {HB_TAG('c','n','p',' '),     HB_TAG('Z','H','S',' ')},       \/* Northern Ping Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('c','n','r',' '),     HB_TAG('S','R','B',' ')},       \/* Montenegrin -> Serbian *\/\n+  {HB_TAG('c','n','t',' '),     HB_TAG('C','C','H','N')},       \/* Tepetotutla Chinantec -> Chinantec *\/\n+  {HB_TAG('c','n','u',' '),     HB_TAG('B','B','R',' ')},       \/* Chenoua -> Berber *\/\n+  {HB_TAG('c','n','w',' '),     HB_TAG('Q','I','N',' ')},       \/* Ngawn Chin -> Chin *\/\n+  {HB_TAG('c','o','a',' '),     HB_TAG('M','L','Y',' ')},       \/* Cocos Islands Malay -> Malay *\/\n+  {HB_TAG('c','o','b',' '),     HB_TAG('M','Y','N',' ')},       \/* Chicomuceltec -> Mayan *\/\n+\/*{HB_TAG('c','o','p',' '),     HB_TAG('C','O','P',' ')},*\/     \/* Coptic *\/\n+  {HB_TAG('c','o','q',' '),     HB_TAG('A','T','H',' ')},       \/* Coquille -> Athapaskan *\/\n+  {HB_TAG('c','p','a',' '),     HB_TAG('C','C','H','N')},       \/* Palantla Chinantec -> Chinantec *\/\n+  {HB_TAG('c','p','e',' '),     HB_TAG('C','P','P',' ')},       \/* English-based creoles and pidgins [collection] -> Creoles *\/\n+  {HB_TAG('c','p','f',' '),     HB_TAG('C','P','P',' ')},       \/* French-based creoles and pidgins [collection] -> Creoles *\/\n+  {HB_TAG('c','p','i',' '),     HB_TAG('C','P','P',' ')},       \/* Chinese Pidgin English -> Creoles *\/\n+\/*{HB_TAG('c','p','p',' '),     HB_TAG('C','P','P',' ')},*\/     \/* Portuguese-based creoles and pidgins [collection] -> Creoles *\/\n+  {HB_TAG('c','p','x',' '),     HB_TAG('Z','H','S',' ')},       \/* Pu-Xian Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('c','q','d',' '),     HB_TAG('H','M','N',' ')},       \/* Chuanqiandian Cluster Miao -> Hmong *\/\n+  {HB_TAG('c','q','u',' '),     HB_TAG('Q','U','H',' ')},       \/* Chilean Quechua (retired code) -> Quechua (Bolivia) *\/\n+  {HB_TAG('c','q','u',' '),     HB_TAG('Q','U','Z',' ')},       \/* Chilean Quechua (retired code) -> Quechua *\/\n+  {HB_TAG('c','r','h',' '),     HB_TAG('C','R','T',' ')},       \/* Crimean Tatar *\/\n+  {HB_TAG('c','r','i',' '),     HB_TAG('C','P','P',' ')},       \/* Sotomense -> Creoles *\/\n+  {HB_TAG('c','r','j',' '),     HB_TAG('E','C','R',' ')},       \/* Southern East Cree -> Eastern Cree *\/\n+  {HB_TAG('c','r','j',' '),     HB_TAG('Y','C','R',' ')},       \/* Southern East Cree -> Y-Cree *\/\n+  {HB_TAG('c','r','j',' '),     HB_TAG('C','R','E',' ')},       \/* Southern East Cree -> Cree *\/\n+  {HB_TAG('c','r','k',' '),     HB_TAG('W','C','R',' ')},       \/* Plains Cree -> West-Cree *\/\n+  {HB_TAG('c','r','k',' '),     HB_TAG('Y','C','R',' ')},       \/* Plains Cree -> Y-Cree *\/\n+  {HB_TAG('c','r','k',' '),     HB_TAG('C','R','E',' ')},       \/* Plains Cree -> Cree *\/\n+  {HB_TAG('c','r','l',' '),     HB_TAG('E','C','R',' ')},       \/* Northern East Cree -> Eastern Cree *\/\n+  {HB_TAG('c','r','l',' '),     HB_TAG('Y','C','R',' ')},       \/* Northern East Cree -> Y-Cree *\/\n+  {HB_TAG('c','r','l',' '),     HB_TAG('C','R','E',' ')},       \/* Northern East Cree -> Cree *\/\n+  {HB_TAG('c','r','m',' '),     HB_TAG('M','C','R',' ')},       \/* Moose Cree *\/\n+  {HB_TAG('c','r','m',' '),     HB_TAG('L','C','R',' ')},       \/* Moose Cree -> L-Cree *\/\n+  {HB_TAG('c','r','m',' '),     HB_TAG('C','R','E',' ')},       \/* Moose Cree -> Cree *\/\n+  {HB_TAG('c','r','p',' '),     HB_TAG('C','P','P',' ')},       \/* Creoles and pidgins [collection] -> Creoles *\/\n+  {HB_TAG('c','r','r',' '),     HB_TAG_NONE            },       \/* Carolina Algonquian != Carrier *\/\n+  {HB_TAG('c','r','s',' '),     HB_TAG('C','P','P',' ')},       \/* Seselwa Creole French -> Creoles *\/\n+  {HB_TAG('c','r','t',' '),     HB_TAG_NONE            },       \/* Iyojwa'ja Chorote != Crimean Tatar *\/\n+  {HB_TAG('c','r','x',' '),     HB_TAG('C','R','R',' ')},       \/* Carrier *\/\n+  {HB_TAG('c','r','x',' '),     HB_TAG('A','T','H',' ')},       \/* Carrier -> Athapaskan *\/\n+  {HB_TAG('c','s','a',' '),     HB_TAG('C','C','H','N')},       \/* Chiltepec Chinantec -> Chinantec *\/\n+\/*{HB_TAG('c','s','b',' '),     HB_TAG('C','S','B',' ')},*\/     \/* Kashubian *\/\n+  {HB_TAG('c','s','h',' '),     HB_TAG('Q','I','N',' ')},       \/* Asho Chin -> Chin *\/\n+  {HB_TAG('c','s','j',' '),     HB_TAG('Q','I','N',' ')},       \/* Songlai Chin -> Chin *\/\n+  {HB_TAG('c','s','l',' '),     HB_TAG_NONE            },       \/* Chinese Sign Language != Church Slavonic *\/\n+  {HB_TAG('c','s','o',' '),     HB_TAG('C','C','H','N')},       \/* Sochiapam Chinantec -> Chinantec *\/\n+  {HB_TAG('c','s','p',' '),     HB_TAG('Z','H','S',' ')},       \/* Southern Ping Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('c','s','v',' '),     HB_TAG('Q','I','N',' ')},       \/* Sumtu Chin -> Chin *\/\n+  {HB_TAG('c','s','w',' '),     HB_TAG('N','C','R',' ')},       \/* Swampy Cree -> N-Cree *\/\n+  {HB_TAG('c','s','w',' '),     HB_TAG('N','H','C',' ')},       \/* Swampy Cree -> Norway House Cree *\/\n+  {HB_TAG('c','s','w',' '),     HB_TAG('C','R','E',' ')},       \/* Swampy Cree -> Cree *\/\n+  {HB_TAG('c','s','y',' '),     HB_TAG('Q','I','N',' ')},       \/* Siyin Chin -> Chin *\/\n+  {HB_TAG('c','t','c',' '),     HB_TAG('A','T','H',' ')},       \/* Chetco -> Athapaskan *\/\n+  {HB_TAG('c','t','d',' '),     HB_TAG('Q','I','N',' ')},       \/* Tedim Chin -> Chin *\/\n+  {HB_TAG('c','t','e',' '),     HB_TAG('C','C','H','N')},       \/* Tepinapa Chinantec -> Chinantec *\/\n+\/*{HB_TAG('c','t','g',' '),     HB_TAG('C','T','G',' ')},*\/     \/* Chittagonian *\/\n+  {HB_TAG('c','t','h',' '),     HB_TAG('Q','I','N',' ')},       \/* Thaiphum Chin -> Chin *\/\n+  {HB_TAG('c','t','l',' '),     HB_TAG('C','C','H','N')},       \/* Tlacoatzintepec Chinantec -> Chinantec *\/\n+  {HB_TAG('c','t','s',' '),     HB_TAG('B','I','K',' ')},       \/* Northern Catanduanes Bikol -> Bikol *\/\n+\/*{HB_TAG('c','t','t',' '),     HB_TAG('C','T','T',' ')},*\/     \/* Wayanad Chetti *\/\n+  {HB_TAG('c','t','u',' '),     HB_TAG('M','Y','N',' ')},       \/* Chol -> Mayan *\/\n+  {HB_TAG('c','u','c',' '),     HB_TAG('C','C','H','N')},       \/* Usila Chinantec -> Chinantec *\/\n+\/*{HB_TAG('c','u','k',' '),     HB_TAG('C','U','K',' ')},*\/     \/* San Blas Kuna *\/\n+  {HB_TAG('c','v','n',' '),     HB_TAG('C','C','H','N')},       \/* Valle Nacional Chinantec -> Chinantec *\/\n+  {HB_TAG('c','w','d',' '),     HB_TAG('D','C','R',' ')},       \/* Woods Cree *\/\n+  {HB_TAG('c','w','d',' '),     HB_TAG('T','C','R',' ')},       \/* Woods Cree -> TH-Cree *\/\n+  {HB_TAG('c','w','d',' '),     HB_TAG('C','R','E',' ')},       \/* Woods Cree -> Cree *\/\n+  {HB_TAG('c','z','h',' '),     HB_TAG('Z','H','S',' ')},       \/* Huizhou Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('c','z','o',' '),     HB_TAG('Z','H','S',' ')},       \/* Min Zhong Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('c','z','t',' '),     HB_TAG('Q','I','N',' ')},       \/* Zotung Chin -> Chin *\/\n+\/*{HB_TAG('d','a','g',' '),     HB_TAG('D','A','G',' ')},*\/     \/* Dagbani *\/\n+  {HB_TAG('d','a','o',' '),     HB_TAG('Q','I','N',' ')},       \/* Daai Chin -> Chin *\/\n+  {HB_TAG('d','a','p',' '),     HB_TAG('N','I','S',' ')},       \/* Nisi (India) (retired code) *\/\n+\/*{HB_TAG('d','a','r',' '),     HB_TAG('D','A','R',' ')},*\/     \/* Dargwa *\/\n+\/*{HB_TAG('d','a','x',' '),     HB_TAG('D','A','X',' ')},*\/     \/* Dayi *\/\n+  {HB_TAG('d','c','r',' '),     HB_TAG('C','P','P',' ')},       \/* Negerhollands -> Creoles *\/\n+  {HB_TAG('d','e','n',' '),     HB_TAG('S','L','A',' ')},       \/* Slave (Athapascan) [macrolanguage] -> Slavey *\/\n+  {HB_TAG('d','e','n',' '),     HB_TAG('A','T','H',' ')},       \/* Slave (Athapascan) [macrolanguage] -> Athapaskan *\/\n+  {HB_TAG('d','e','p',' '),     HB_TAG('C','P','P',' ')},       \/* Pidgin Delaware -> Creoles *\/\n+  {HB_TAG('d','g','o',' '),     HB_TAG('D','G','O',' ')},       \/* Dogri (individual language) *\/\n+  {HB_TAG('d','g','o',' '),     HB_TAG('D','G','R',' ')},       \/* Dogri (macrolanguage) *\/\n+  {HB_TAG('d','g','r',' '),     HB_TAG('A','T','H',' ')},       \/* Dogrib -> Athapaskan *\/\n+  {HB_TAG('d','h','d',' '),     HB_TAG('M','A','W',' ')},       \/* Dhundari -> Marwari *\/\n+\/*{HB_TAG('d','h','g',' '),     HB_TAG('D','H','G',' ')},*\/     \/* Dhangu *\/\n+  {HB_TAG('d','h','v',' '),     HB_TAG_NONE            },       \/* Dehu != Divehi (Dhivehi, Maldivian) (deprecated) *\/\n+  {HB_TAG('d','i','b',' '),     HB_TAG('D','N','K',' ')},       \/* South Central Dinka -> Dinka *\/\n+  {HB_TAG('d','i','k',' '),     HB_TAG('D','N','K',' ')},       \/* Southwestern Dinka -> Dinka *\/\n+  {HB_TAG('d','i','n',' '),     HB_TAG('D','N','K',' ')},       \/* Dinka [macrolanguage] *\/\n+  {HB_TAG('d','i','p',' '),     HB_TAG('D','N','K',' ')},       \/* Northeastern Dinka -> Dinka *\/\n+  {HB_TAG('d','i','q',' '),     HB_TAG('D','I','Q',' ')},       \/* Dimli *\/\n+  {HB_TAG('d','i','q',' '),     HB_TAG('Z','Z','A',' ')},       \/* Dimli -> Zazaki *\/\n+  {HB_TAG('d','i','w',' '),     HB_TAG('D','N','K',' ')},       \/* Northwestern Dinka -> Dinka *\/\n+  {HB_TAG('d','j','e',' '),     HB_TAG('D','J','R',' ')},       \/* Zarma *\/\n+  {HB_TAG('d','j','k',' '),     HB_TAG('C','P','P',' ')},       \/* Eastern Maroon Creole -> Creoles *\/\n+  {HB_TAG('d','j','r',' '),     HB_TAG('D','J','R','0')},       \/* Djambarrpuyngu *\/\n+  {HB_TAG('d','k','s',' '),     HB_TAG('D','N','K',' ')},       \/* Southeastern Dinka -> Dinka *\/\n+  {HB_TAG('d','n','g',' '),     HB_TAG('D','U','N',' ')},       \/* Dungan *\/\n+\/*{HB_TAG('d','n','j',' '),     HB_TAG('D','N','J',' ')},*\/     \/* Dan *\/\n+  {HB_TAG('d','n','k',' '),     HB_TAG_NONE            },       \/* Dengka != Dinka *\/\n+  {HB_TAG('d','o','i',' '),     HB_TAG('D','G','R',' ')},       \/* Dogri (macrolanguage) [macrolanguage] *\/\n+  {HB_TAG('d','r','h',' '),     HB_TAG('M','N','G',' ')},       \/* Darkhat (retired code) -> Mongolian *\/\n+  {HB_TAG('d','r','i',' '),     HB_TAG_NONE            },       \/* C'Lela != Dari *\/\n+  {HB_TAG('d','r','w',' '),     HB_TAG('D','R','I',' ')},       \/* Darwazi (retired code) -> Dari *\/\n+  {HB_TAG('d','r','w',' '),     HB_TAG('F','A','R',' ')},       \/* Darwazi (retired code) -> Persian *\/\n+  {HB_TAG('d','s','b',' '),     HB_TAG('L','S','B',' ')},       \/* Lower Sorbian *\/\n+  {HB_TAG('d','t','y',' '),     HB_TAG('N','E','P',' ')},       \/* Dotyali -> Nepali *\/\n+\/*{HB_TAG('d','u','j',' '),     HB_TAG('D','U','J',' ')},*\/     \/* Dhuwal (retired code) *\/\n+  {HB_TAG('d','u','n',' '),     HB_TAG_NONE            },       \/* Dusun Deyah != Dungan *\/\n+  {HB_TAG('d','u','p',' '),     HB_TAG('M','L','Y',' ')},       \/* Duano -> Malay *\/\n+  {HB_TAG('d','w','k',' '),     HB_TAG('K','U','I',' ')},       \/* Dawik Kui -> Kui *\/\n+  {HB_TAG('d','w','u',' '),     HB_TAG('D','U','J',' ')},       \/* Dhuwal *\/\n+  {HB_TAG('d','w','y',' '),     HB_TAG('D','U','J',' ')},       \/* Dhuwaya -> Dhuwal *\/\n+  {HB_TAG('d','y','u',' '),     HB_TAG('J','U','L',' ')},       \/* Dyula -> Jula *\/\n+  {HB_TAG('d','z','n',' '),     HB_TAG_NONE            },       \/* Dzando != Dzongkha *\/\n+  {HB_TAG('e','c','r',' '),     HB_TAG_NONE            },       \/* Eteocretan != Eastern Cree *\/\n+\/*{HB_TAG('e','f','i',' '),     HB_TAG('E','F','I',' ')},*\/     \/* Efik *\/\n+  {HB_TAG('e','k','k',' '),     HB_TAG('E','T','I',' ')},       \/* Standard Estonian -> Estonian *\/\n+  {HB_TAG('e','k','y',' '),     HB_TAG('K','R','N',' ')},       \/* Eastern Kayah -> Karen *\/\n+  {HB_TAG('e','m','k',' '),     HB_TAG('E','M','K',' ')},       \/* Eastern Maninkakan *\/\n+  {HB_TAG('e','m','k',' '),     HB_TAG('M','N','K',' ')},       \/* Eastern Maninkakan -> Maninka *\/\n+  {HB_TAG('e','m','y',' '),     HB_TAG('M','Y','N',' ')},       \/* Epigraphic Mayan -> Mayan *\/\n+  {HB_TAG('e','n','b',' '),     HB_TAG('K','A','L',' ')},       \/* Markweeta -> Kalenjin *\/\n+  {HB_TAG('e','n','f',' '),     HB_TAG('F','N','E',' ')},       \/* Forest Enets *\/\n+  {HB_TAG('e','n','h',' '),     HB_TAG('T','N','E',' ')},       \/* Tundra Enets *\/\n+  {HB_TAG('e','s','g',' '),     HB_TAG('G','O','N',' ')},       \/* Aheri Gondi -> Gondi *\/\n+  {HB_TAG('e','s','i',' '),     HB_TAG('I','P','K',' ')},       \/* North Alaskan Inupiatun -> Inupiat *\/\n+  {HB_TAG('e','s','k',' '),     HB_TAG('I','P','K',' ')},       \/* Northwest Alaska Inupiatun -> Inupiat *\/\n+\/*{HB_TAG('e','s','u',' '),     HB_TAG('E','S','U',' ')},*\/     \/* Central Yupik *\/\n+  {HB_TAG('e','t','o',' '),     HB_TAG('B','T','I',' ')},       \/* Eton (Cameroon) -> Beti *\/\n+  {HB_TAG('e','u','q',' '),     HB_TAG_NONE            },       \/* Basque [collection] != Basque *\/\n+  {HB_TAG('e','v','e',' '),     HB_TAG('E','V','N',' ')},       \/* Even *\/\n+  {HB_TAG('e','v','n',' '),     HB_TAG('E','V','K',' ')},       \/* Evenki *\/\n+  {HB_TAG('e','w','o',' '),     HB_TAG('B','T','I',' ')},       \/* Ewondo -> Beti *\/\n+  {HB_TAG('e','y','o',' '),     HB_TAG('K','A','L',' ')},       \/* Keiyo -> Kalenjin *\/\n+  {HB_TAG('f','a','b',' '),     HB_TAG('C','P','P',' ')},       \/* Fa d'Ambu -> Creoles *\/\n+  {HB_TAG('f','a','n',' '),     HB_TAG('F','A','N','0')},       \/* Fang (Equatorial Guinea) *\/\n+  {HB_TAG('f','a','n',' '),     HB_TAG('B','T','I',' ')},       \/* Fang (Equatorial Guinea) -> Beti *\/\n+  {HB_TAG('f','a','r',' '),     HB_TAG_NONE            },       \/* Fataleka != Persian *\/\n+  {HB_TAG('f','a','t',' '),     HB_TAG('F','A','T',' ')},       \/* Fanti *\/\n+  {HB_TAG('f','a','t',' '),     HB_TAG('A','K','A',' ')},       \/* Fanti -> Akan *\/\n+  {HB_TAG('f','b','l',' '),     HB_TAG('B','I','K',' ')},       \/* West Albay Bikol -> Bikol *\/\n+  {HB_TAG('f','f','m',' '),     HB_TAG('F','U','L',' ')},       \/* Maasina Fulfulde -> Fulah *\/\n+  {HB_TAG('f','i','l',' '),     HB_TAG('P','I','L',' ')},       \/* Filipino *\/\n+  {HB_TAG('f','l','m',' '),     HB_TAG('H','A','L',' ')},       \/* Halam (Falam Chin) (retired code) *\/\n+  {HB_TAG('f','l','m',' '),     HB_TAG('Q','I','N',' ')},       \/* Falam Chin (retired code) -> Chin *\/\n+  {HB_TAG('f','m','p',' '),     HB_TAG('F','M','P',' ')},       \/* Fefe *\/\n+  {HB_TAG('f','m','p',' '),     HB_TAG('B','M','L',' ')},       \/* Fe'fe' -> Bamileke *\/\n+  {HB_TAG('f','n','g',' '),     HB_TAG('C','P','P',' ')},       \/* Fanagalo -> Creoles *\/\n+\/*{HB_TAG('f','o','n',' '),     HB_TAG('F','O','N',' ')},*\/     \/* Fon *\/\n+  {HB_TAG('f','o','s',' '),     HB_TAG_NONE            },       \/* Siraya != Faroese *\/\n+  {HB_TAG('f','p','e',' '),     HB_TAG('C','P','P',' ')},       \/* Fernando Po Creole English -> Creoles *\/\n+\/*{HB_TAG('f','r','c',' '),     HB_TAG('F','R','C',' ')},*\/     \/* Cajun French *\/\n+\/*{HB_TAG('f','r','p',' '),     HB_TAG('F','R','P',' ')},*\/     \/* Arpitan *\/\n+  {HB_TAG('f','u','b',' '),     HB_TAG('F','U','L',' ')},       \/* Adamawa Fulfulde -> Fulah *\/\n+  {HB_TAG('f','u','c',' '),     HB_TAG('F','U','L',' ')},       \/* Pulaar -> Fulah *\/\n+  {HB_TAG('f','u','e',' '),     HB_TAG('F','U','L',' ')},       \/* Borgu Fulfulde -> Fulah *\/\n+  {HB_TAG('f','u','f',' '),     HB_TAG('F','T','A',' ')},       \/* Pular -> Futa *\/\n+  {HB_TAG('f','u','f',' '),     HB_TAG('F','U','L',' ')},       \/* Pular -> Fulah *\/\n+  {HB_TAG('f','u','h',' '),     HB_TAG('F','U','L',' ')},       \/* Western Niger Fulfulde -> Fulah *\/\n+  {HB_TAG('f','u','i',' '),     HB_TAG('F','U','L',' ')},       \/* Bagirmi Fulfulde -> Fulah *\/\n+  {HB_TAG('f','u','q',' '),     HB_TAG('F','U','L',' ')},       \/* Central-Eastern Niger Fulfulde -> Fulah *\/\n+  {HB_TAG('f','u','r',' '),     HB_TAG('F','R','L',' ')},       \/* Friulian *\/\n+  {HB_TAG('f','u','v',' '),     HB_TAG('F','U','V',' ')},       \/* Nigerian Fulfulde *\/\n+  {HB_TAG('f','u','v',' '),     HB_TAG('F','U','L',' ')},       \/* Nigerian Fulfulde -> Fulah *\/\n+  {HB_TAG('g','a','a',' '),     HB_TAG('G','A','D',' ')},       \/* Ga *\/\n+  {HB_TAG('g','a','c',' '),     HB_TAG('C','P','P',' ')},       \/* Mixed Great Andamanese -> Creoles *\/\n+  {HB_TAG('g','a','d',' '),     HB_TAG_NONE            },       \/* Gaddang != Ga *\/\n+  {HB_TAG('g','a','e',' '),     HB_TAG_NONE            },       \/* Guarequena != Scottish Gaelic (Gaelic) *\/\n+\/*{HB_TAG('g','a','g',' '),     HB_TAG('G','A','G',' ')},*\/     \/* Gagauz *\/\n+  {HB_TAG('g','a','l',' '),     HB_TAG_NONE            },       \/* Galolen != Galician *\/\n+  {HB_TAG('g','a','n',' '),     HB_TAG('Z','H','S',' ')},       \/* Gan Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('g','a','r',' '),     HB_TAG_NONE            },       \/* Galeya != Garshuni *\/\n+  {HB_TAG('g','a','w',' '),     HB_TAG_NONE            },       \/* Nobonob != Garhwali *\/\n+  {HB_TAG('g','a','x',' '),     HB_TAG('O','R','O',' ')},       \/* Borana-Arsi-Guji Oromo -> Oromo *\/\n+  {HB_TAG('g','a','z',' '),     HB_TAG('O','R','O',' ')},       \/* West Central Oromo -> Oromo *\/\n+  {HB_TAG('g','b','m',' '),     HB_TAG('G','A','W',' ')},       \/* Garhwali *\/\n+  {HB_TAG('g','c','e',' '),     HB_TAG('A','T','H',' ')},       \/* Galice -> Athapaskan *\/\n+  {HB_TAG('g','c','f',' '),     HB_TAG('C','P','P',' ')},       \/* Guadeloupean Creole French -> Creoles *\/\n+  {HB_TAG('g','c','l',' '),     HB_TAG('C','P','P',' ')},       \/* Grenadian Creole English -> Creoles *\/\n+  {HB_TAG('g','c','r',' '),     HB_TAG('C','P','P',' ')},       \/* Guianese Creole French -> Creoles *\/\n+  {HB_TAG('g','d','a',' '),     HB_TAG('R','A','J',' ')},       \/* Gade Lohar -> Rajasthani *\/\n+\/*{HB_TAG('g','e','z',' '),     HB_TAG('G','E','Z',' ')},*\/     \/* Geez *\/\n+  {HB_TAG('g','g','o',' '),     HB_TAG('G','O','N',' ')},       \/* Southern Gondi (retired code) -> Gondi *\/\n+  {HB_TAG('g','h','a',' '),     HB_TAG('B','B','R',' ')},       \/* Ghadams -> Berber *\/\n+  {HB_TAG('g','h','k',' '),     HB_TAG('K','R','N',' ')},       \/* Geko Karen -> Karen *\/\n+  {HB_TAG('g','h','o',' '),     HB_TAG('B','B','R',' ')},       \/* Ghomara -> Berber *\/\n+  {HB_TAG('g','i','b',' '),     HB_TAG('C','P','P',' ')},       \/* Gibanawa -> Creoles *\/\n+\/*{HB_TAG('g','i','h',' '),     HB_TAG('G','I','H',' ')},*\/     \/* Githabul *\/\n+  {HB_TAG('g','i','l',' '),     HB_TAG('G','I','L','0')},       \/* Kiribati (Gilbertese) *\/\n+  {HB_TAG('g','j','u',' '),     HB_TAG('R','A','J',' ')},       \/* Gujari -> Rajasthani *\/\n+  {HB_TAG('g','k','p',' '),     HB_TAG('G','K','P',' ')},       \/* Guinea Kpelle -> Kpelle (Guinea) *\/\n+  {HB_TAG('g','k','p',' '),     HB_TAG('K','P','L',' ')},       \/* Guinea Kpelle -> Kpelle *\/\n+  {HB_TAG('g','l','d',' '),     HB_TAG('N','A','N',' ')},       \/* Nanai *\/\n+\/*{HB_TAG('g','l','k',' '),     HB_TAG('G','L','K',' ')},*\/     \/* Gilaki *\/\n+  {HB_TAG('g','m','z',' '),     HB_TAG_NONE            },       \/* Mgbolizhia != Gumuz *\/\n+  {HB_TAG('g','n','b',' '),     HB_TAG('Q','I','N',' ')},       \/* Gangte -> Chin *\/\n+\/*{HB_TAG('g','n','n',' '),     HB_TAG('G','N','N',' ')},*\/     \/* Gumatj *\/\n+  {HB_TAG('g','n','o',' '),     HB_TAG('G','O','N',' ')},       \/* Northern Gondi -> Gondi *\/\n+  {HB_TAG('g','n','w',' '),     HB_TAG('G','U','A',' ')},       \/* Western Bolivian Guaran -> Guarani *\/\n+\/*{HB_TAG('g','o','g',' '),     HB_TAG('G','O','G',' ')},*\/     \/* Gogo *\/\n+  {HB_TAG('g','o','m',' '),     HB_TAG('K','O','K',' ')},       \/* Goan Konkani -> Konkani *\/\n+\/*{HB_TAG('g','o','n',' '),     HB_TAG('G','O','N',' ')},*\/     \/* Gondi [macrolanguage] *\/\n+  {HB_TAG('g','o','q',' '),     HB_TAG('C','P','P',' ')},       \/* Gorap -> Creoles *\/\n+  {HB_TAG('g','o','x',' '),     HB_TAG('B','A','D','0')},       \/* Gobu -> Banda *\/\n+  {HB_TAG('g','p','e',' '),     HB_TAG('C','P','P',' ')},       \/* Ghanaian Pidgin English -> Creoles *\/\n+  {HB_TAG('g','r','o',' '),     HB_TAG_NONE            },       \/* Groma != Garo *\/\n+  {HB_TAG('g','r','r',' '),     HB_TAG('B','B','R',' ')},       \/* Taznatit -> Berber *\/\n+  {HB_TAG('g','r','t',' '),     HB_TAG('G','R','O',' ')},       \/* Garo *\/\n+  {HB_TAG('g','r','u',' '),     HB_TAG('S','O','G',' ')},       \/* Kistane -> Sodo Gurage *\/\n+  {HB_TAG('g','s','w',' '),     HB_TAG('A','L','S',' ')},       \/* Alsatian *\/\n+  {HB_TAG('g','u','a',' '),     HB_TAG_NONE            },       \/* Shiki != Guarani *\/\n+\/*{HB_TAG('g','u','c',' '),     HB_TAG('G','U','C',' ')},*\/     \/* Wayuu *\/\n+\/*{HB_TAG('g','u','f',' '),     HB_TAG('G','U','F',' ')},*\/     \/* Gupapuyngu *\/\n+  {HB_TAG('g','u','g',' '),     HB_TAG('G','U','A',' ')},       \/* Paraguayan Guaran -> Guarani *\/\n+  {HB_TAG('g','u','i',' '),     HB_TAG('G','U','A',' ')},       \/* Eastern Bolivian Guaran -> Guarani *\/\n+  {HB_TAG('g','u','k',' '),     HB_TAG('G','M','Z',' ')},       \/* Gumuz *\/\n+  {HB_TAG('g','u','l',' '),     HB_TAG('C','P','P',' ')},       \/* Sea Island Creole English -> Creoles *\/\n+  {HB_TAG('g','u','n',' '),     HB_TAG('G','U','A',' ')},       \/* Mby Guaran -> Guarani *\/\n+\/*{HB_TAG('g','u','z',' '),     HB_TAG('G','U','Z',' ')},*\/     \/* Gusii *\/\n+  {HB_TAG('g','w','i',' '),     HB_TAG('A','T','H',' ')},       \/* Gwichin -> Athapaskan *\/\n+  {HB_TAG('g','y','n',' '),     HB_TAG('C','P','P',' ')},       \/* Guyanese Creole English -> Creoles *\/\n+  {HB_TAG('h','a','a',' '),     HB_TAG('A','T','H',' ')},       \/* Han -> Athapaskan *\/\n+  {HB_TAG('h','a','e',' '),     HB_TAG('O','R','O',' ')},       \/* Eastern Oromo -> Oromo *\/\n+  {HB_TAG('h','a','i',' '),     HB_TAG('H','A','I','0')},       \/* Haida [macrolanguage] *\/\n+  {HB_TAG('h','a','k',' '),     HB_TAG('Z','H','S',' ')},       \/* Hakka Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('h','a','l',' '),     HB_TAG_NONE            },       \/* Halang != Halam (Falam Chin) *\/\n+  {HB_TAG('h','a','r',' '),     HB_TAG('H','R','I',' ')},       \/* Harari *\/\n+\/*{HB_TAG('h','a','w',' '),     HB_TAG('H','A','W',' ')},*\/     \/* Hawaiian *\/\n+  {HB_TAG('h','a','x',' '),     HB_TAG('H','A','I','0')},       \/* Southern Haida -> Haida *\/\n+\/*{HB_TAG('h','a','y',' '),     HB_TAG('H','A','Y',' ')},*\/     \/* Haya *\/\n+\/*{HB_TAG('h','a','z',' '),     HB_TAG('H','A','Z',' ')},*\/     \/* Hazaragi *\/\n+  {HB_TAG('h','b','n',' '),     HB_TAG_NONE            },       \/* Heiban != Hammer-Banna *\/\n+  {HB_TAG('h','c','a',' '),     HB_TAG('C','P','P',' ')},       \/* Andaman Creole Hindi -> Creoles *\/\n+  {HB_TAG('h','d','n',' '),     HB_TAG('H','A','I','0')},       \/* Northern Haida -> Haida *\/\n+  {HB_TAG('h','e','a',' '),     HB_TAG('H','M','N',' ')},       \/* Northern Qiandong Miao -> Hmong *\/\n+\/*{HB_TAG('h','e','i',' '),     HB_TAG('H','E','I',' ')},*\/     \/* Heiltsuk *\/\n+\/*{HB_TAG('h','i','l',' '),     HB_TAG('H','I','L',' ')},*\/     \/* Hiligaynon *\/\n+  {HB_TAG('h','j','i',' '),     HB_TAG('M','L','Y',' ')},       \/* Haji -> Malay *\/\n+  {HB_TAG('h','l','t',' '),     HB_TAG('Q','I','N',' ')},       \/* Matu Chin -> Chin *\/\n+  {HB_TAG('h','m','a',' '),     HB_TAG('H','M','N',' ')},       \/* Southern Mashan Hmong -> Hmong *\/\n+  {HB_TAG('h','m','c',' '),     HB_TAG('H','M','N',' ')},       \/* Central Huishui Hmong -> Hmong *\/\n+  {HB_TAG('h','m','d',' '),     HB_TAG('H','M','D',' ')},       \/* Large Flowery Miao -> A-Hmao *\/\n+  {HB_TAG('h','m','d',' '),     HB_TAG('H','M','N',' ')},       \/* Large Flowery Miao -> Hmong *\/\n+  {HB_TAG('h','m','e',' '),     HB_TAG('H','M','N',' ')},       \/* Eastern Huishui Hmong -> Hmong *\/\n+  {HB_TAG('h','m','g',' '),     HB_TAG('H','M','N',' ')},       \/* Southwestern Guiyang Hmong -> Hmong *\/\n+  {HB_TAG('h','m','h',' '),     HB_TAG('H','M','N',' ')},       \/* Southwestern Huishui Hmong -> Hmong *\/\n+  {HB_TAG('h','m','i',' '),     HB_TAG('H','M','N',' ')},       \/* Northern Huishui Hmong -> Hmong *\/\n+  {HB_TAG('h','m','j',' '),     HB_TAG('H','M','N',' ')},       \/* Ge -> Hmong *\/\n+  {HB_TAG('h','m','l',' '),     HB_TAG('H','M','N',' ')},       \/* Luopohe Hmong -> Hmong *\/\n+  {HB_TAG('h','m','m',' '),     HB_TAG('H','M','N',' ')},       \/* Central Mashan Hmong -> Hmong *\/\n+\/*{HB_TAG('h','m','n',' '),     HB_TAG('H','M','N',' ')},*\/     \/* Hmong [macrolanguage] *\/\n+  {HB_TAG('h','m','p',' '),     HB_TAG('H','M','N',' ')},       \/* Northern Mashan Hmong -> Hmong *\/\n+  {HB_TAG('h','m','q',' '),     HB_TAG('H','M','N',' ')},       \/* Eastern Qiandong Miao -> Hmong *\/\n+  {HB_TAG('h','m','r',' '),     HB_TAG('Q','I','N',' ')},       \/* Hmar -> Chin *\/\n+  {HB_TAG('h','m','s',' '),     HB_TAG('H','M','N',' ')},       \/* Southern Qiandong Miao -> Hmong *\/\n+  {HB_TAG('h','m','w',' '),     HB_TAG('H','M','N',' ')},       \/* Western Mashan Hmong -> Hmong *\/\n+  {HB_TAG('h','m','y',' '),     HB_TAG('H','M','N',' ')},       \/* Southern Guiyang Hmong -> Hmong *\/\n+  {HB_TAG('h','m','z',' '),     HB_TAG('H','M','Z',' ')},       \/* Hmong Shua -> Hmong Shuat *\/\n+  {HB_TAG('h','m','z',' '),     HB_TAG('H','M','N',' ')},       \/* Hmong Shua -> Hmong *\/\n+\/*{HB_TAG('h','n','d',' '),     HB_TAG('H','N','D',' ')},*\/     \/* Southern Hindko -> Hindko *\/\n+  {HB_TAG('h','n','e',' '),     HB_TAG('C','H','H',' ')},       \/* Chhattisgarhi -> Chattisgarhi *\/\n+  {HB_TAG('h','n','j',' '),     HB_TAG('H','M','N',' ')},       \/* Hmong Njua -> Hmong *\/\n+  {HB_TAG('h','n','o',' '),     HB_TAG('H','N','D',' ')},       \/* Northern Hindko -> Hindko *\/\n+  {HB_TAG('h','o','c',' '),     HB_TAG('H','O',' ',' ')},       \/* Ho *\/\n+  {HB_TAG('h','o','i',' '),     HB_TAG('A','T','H',' ')},       \/* Holikachuk -> Athapaskan *\/\n+  {HB_TAG('h','o','j',' '),     HB_TAG('H','A','R',' ')},       \/* Hadothi -> Harauti *\/\n+  {HB_TAG('h','o','j',' '),     HB_TAG('R','A','J',' ')},       \/* Hadothi -> Rajasthani *\/\n+  {HB_TAG('h','r','a',' '),     HB_TAG('Q','I','N',' ')},       \/* Hrangkhol -> Chin *\/\n+  {HB_TAG('h','r','m',' '),     HB_TAG('H','M','N',' ')},       \/* Horned Miao -> Hmong *\/\n+  {HB_TAG('h','s','b',' '),     HB_TAG('U','S','B',' ')},       \/* Upper Sorbian *\/\n+  {HB_TAG('h','s','n',' '),     HB_TAG('Z','H','S',' ')},       \/* Xiang Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('h','u','j',' '),     HB_TAG('H','M','N',' ')},       \/* Northern Guiyang Hmong -> Hmong *\/\n+  {HB_TAG('h','u','p',' '),     HB_TAG('A','T','H',' ')},       \/* Hupa -> Athapaskan *\/\n+  {HB_TAG('h','u','s',' '),     HB_TAG('M','Y','N',' ')},       \/* Huastec -> Mayan *\/\n+  {HB_TAG('h','w','c',' '),     HB_TAG('C','P','P',' ')},       \/* Hawai'i Creole English -> Creoles *\/\n+  {HB_TAG('h','y','w',' '),     HB_TAG('H','Y','E',' ')},       \/* Western Armenian -> Armenian *\/\n+\/*{HB_TAG('i','b','a',' '),     HB_TAG('I','B','A',' ')},*\/     \/* Iban *\/\n+\/*{HB_TAG('i','b','b',' '),     HB_TAG('I','B','B',' ')},*\/     \/* Ibibio *\/\n+  {HB_TAG('i','b','y',' '),     HB_TAG('I','J','O',' ')},       \/* Ibani -> Ijo *\/\n+  {HB_TAG('i','c','r',' '),     HB_TAG('C','P','P',' ')},       \/* Islander Creole English -> Creoles *\/\n+  {HB_TAG('i','d','a',' '),     HB_TAG('L','U','H',' ')},       \/* Idakho-Isukha-Tiriki -> Luyia *\/\n+  {HB_TAG('i','d','b',' '),     HB_TAG('C','P','P',' ')},       \/* Indo-Portuguese -> Creoles *\/\n+  {HB_TAG('i','g','b',' '),     HB_TAG('E','B','I',' ')},       \/* Ebira *\/\n+  {HB_TAG('i','h','b',' '),     HB_TAG('C','P','P',' ')},       \/* Iha Based Pidgin -> Creoles *\/\n+  {HB_TAG('i','j','c',' '),     HB_TAG('I','J','O',' ')},       \/* Izon -> Ijo *\/\n+  {HB_TAG('i','j','e',' '),     HB_TAG('I','J','O',' ')},       \/* Biseni -> Ijo *\/\n+  {HB_TAG('i','j','n',' '),     HB_TAG('I','J','O',' ')},       \/* Kalabari -> Ijo *\/\n+\/*{HB_TAG('i','j','o',' '),     HB_TAG('I','J','O',' ')},*\/     \/* Ijo [collection] *\/\n+  {HB_TAG('i','j','s',' '),     HB_TAG('I','J','O',' ')},       \/* Southeast Ijo -> Ijo *\/\n+  {HB_TAG('i','k','e',' '),     HB_TAG('I','N','U',' ')},       \/* Eastern Canadian Inuktitut -> Inuktitut *\/\n+  {HB_TAG('i','k','e',' '),     HB_TAG('I','N','U','K')},       \/* Eastern Canadian Inuktitut -> Nunavik Inuktitut *\/\n+  {HB_TAG('i','k','t',' '),     HB_TAG('I','N','U',' ')},       \/* Inuinnaqtun -> Inuktitut *\/\n+\/*{HB_TAG('i','l','o',' '),     HB_TAG('I','L','O',' ')},*\/     \/* Iloko -> Ilokano *\/\n+  {HB_TAG('i','n','g',' '),     HB_TAG('A','T','H',' ')},       \/* Degexit'an -> Athapaskan *\/\n+  {HB_TAG('i','n','h',' '),     HB_TAG('I','N','G',' ')},       \/* Ingush *\/\n+  {HB_TAG('i','r','i',' '),     HB_TAG_NONE            },       \/* Rigwe != Irish *\/\n+\/*{HB_TAG('i','r','u',' '),     HB_TAG('I','R','U',' ')},*\/     \/* Irula *\/\n+  {HB_TAG('i','s','m',' '),     HB_TAG_NONE            },       \/* Masimasi != Inari Sami *\/\n+  {HB_TAG('i','t','z',' '),     HB_TAG('M','Y','N',' ')},       \/* Itz -> Mayan *\/\n+  {HB_TAG('i','x','l',' '),     HB_TAG('M','Y','N',' ')},       \/* Ixil -> Mayan *\/\n+  {HB_TAG('j','a','c',' '),     HB_TAG('M','Y','N',' ')},       \/* Popti' -> Mayan *\/\n+  {HB_TAG('j','a','k',' '),     HB_TAG('M','L','Y',' ')},       \/* Jakun -> Malay *\/\n+  {HB_TAG('j','a','m',' '),     HB_TAG('J','A','M',' ')},       \/* Jamaican Creole English -> Jamaican Creole *\/\n+  {HB_TAG('j','a','m',' '),     HB_TAG('C','P','P',' ')},       \/* Jamaican Creole English -> Creoles *\/\n+  {HB_TAG('j','a','n',' '),     HB_TAG_NONE            },       \/* Jandai != Japanese *\/\n+  {HB_TAG('j','a','x',' '),     HB_TAG('M','L','Y',' ')},       \/* Jambi Malay -> Malay *\/\n+  {HB_TAG('j','b','e',' '),     HB_TAG('B','B','R',' ')},       \/* Judeo-Berber -> Berber *\/\n+  {HB_TAG('j','b','n',' '),     HB_TAG('B','B','R',' ')},       \/* Nafusi -> Berber *\/\n+\/*{HB_TAG('j','b','o',' '),     HB_TAG('J','B','O',' ')},*\/     \/* Lojban *\/\n+\/*{HB_TAG('j','c','t',' '),     HB_TAG('J','C','T',' ')},*\/     \/* Krymchak *\/\n+  {HB_TAG('j','g','o',' '),     HB_TAG('B','M','L',' ')},       \/* Ngomba -> Bamileke *\/\n+  {HB_TAG('j','i','i',' '),     HB_TAG_NONE            },       \/* Jiiddu != Yiddish *\/\n+  {HB_TAG('j','k','m',' '),     HB_TAG('K','R','N',' ')},       \/* Mobwa Karen -> Karen *\/\n+  {HB_TAG('j','k','p',' '),     HB_TAG('K','R','N',' ')},       \/* Paku Karen -> Karen *\/\n+  {HB_TAG('j','u','d',' '),     HB_TAG_NONE            },       \/* Worodougou != Ladino *\/\n+  {HB_TAG('j','u','l',' '),     HB_TAG_NONE            },       \/* Jirel != Jula *\/\n+  {HB_TAG('j','v','d',' '),     HB_TAG('C','P','P',' ')},       \/* Javindo -> Creoles *\/\n+  {HB_TAG('k','a','a',' '),     HB_TAG('K','R','K',' ')},       \/* Karakalpak *\/\n+  {HB_TAG('k','a','b',' '),     HB_TAG('K','A','B','0')},       \/* Kabyle *\/\n+  {HB_TAG('k','a','b',' '),     HB_TAG('B','B','R',' ')},       \/* Kabyle -> Berber *\/\n+  {HB_TAG('k','a','c',' '),     HB_TAG_NONE            },       \/* Kachin != Kachchi *\/\n+  {HB_TAG('k','a','m',' '),     HB_TAG('K','M','B',' ')},       \/* Kamba (Kenya) *\/\n+  {HB_TAG('k','a','r',' '),     HB_TAG('K','R','N',' ')},       \/* Karen [collection] *\/\n+\/*{HB_TAG('k','a','w',' '),     HB_TAG('K','A','W',' ')},*\/     \/* Kawi (Old Javanese) *\/\n+  {HB_TAG('k','b','d',' '),     HB_TAG('K','A','B',' ')},       \/* Kabardian *\/\n+  {HB_TAG('k','b','y',' '),     HB_TAG('K','N','R',' ')},       \/* Manga Kanuri -> Kanuri *\/\n+  {HB_TAG('k','c','a',' '),     HB_TAG('K','H','K',' ')},       \/* Khanty -> Khanty-Kazim *\/\n+  {HB_TAG('k','c','a',' '),     HB_TAG('K','H','S',' ')},       \/* Khanty -> Khanty-Shurishkar *\/\n+  {HB_TAG('k','c','a',' '),     HB_TAG('K','H','V',' ')},       \/* Khanty -> Khanty-Vakhi *\/\n+  {HB_TAG('k','c','n',' '),     HB_TAG('C','P','P',' ')},       \/* Nubi -> Creoles *\/\n+\/*{HB_TAG('k','d','e',' '),     HB_TAG('K','D','E',' ')},*\/     \/* Makonde *\/\n+  {HB_TAG('k','d','r',' '),     HB_TAG('K','R','M',' ')},       \/* Karaim *\/\n+  {HB_TAG('k','d','t',' '),     HB_TAG('K','U','Y',' ')},       \/* Kuy *\/\n+  {HB_TAG('k','e','a',' '),     HB_TAG('K','E','A',' ')},       \/* Kabuverdianu (Crioulo) *\/\n+  {HB_TAG('k','e','a',' '),     HB_TAG('C','P','P',' ')},       \/* Kabuverdianu -> Creoles *\/\n+  {HB_TAG('k','e','b',' '),     HB_TAG_NONE            },       \/* Kl != Kebena *\/\n+  {HB_TAG('k','e','k',' '),     HB_TAG('K','E','K',' ')},       \/* Kekchi *\/\n+  {HB_TAG('k','e','k',' '),     HB_TAG('M','Y','N',' ')},       \/* Kekch -> Mayan *\/\n+  {HB_TAG('k','e','x',' '),     HB_TAG('K','K','N',' ')},       \/* Kukna -> Kokni *\/\n+  {HB_TAG('k','f','a',' '),     HB_TAG('K','O','D',' ')},       \/* Kodava -> Kodagu *\/\n+  {HB_TAG('k','f','r',' '),     HB_TAG('K','A','C',' ')},       \/* Kachhi -> Kachchi *\/\n+  {HB_TAG('k','f','x',' '),     HB_TAG('K','U','L',' ')},       \/* Kullu Pahari -> Kulvi *\/\n+  {HB_TAG('k','f','y',' '),     HB_TAG('K','M','N',' ')},       \/* Kumaoni *\/\n+  {HB_TAG('k','g','e',' '),     HB_TAG_NONE            },       \/* Komering != Khutsuri Georgian *\/\n+  {HB_TAG('k','h','a',' '),     HB_TAG('K','S','I',' ')},       \/* Khasi *\/\n+  {HB_TAG('k','h','b',' '),     HB_TAG('X','B','D',' ')},       \/* L *\/\n+  {HB_TAG('k','h','k',' '),     HB_TAG('M','N','G',' ')},       \/* Halh Mongolian -> Mongolian *\/\n+  {HB_TAG('k','h','n',' '),     HB_TAG_NONE            },       \/* Khandesi != Khamti Shan (Microsoft fonts) *\/\n+  {HB_TAG('k','h','s',' '),     HB_TAG_NONE            },       \/* Kasua != Khanty-Shurishkar *\/\n+  {HB_TAG('k','h','t',' '),     HB_TAG('K','H','T',' ')},       \/* Khamti -> Khamti Shan *\/\n+  {HB_TAG('k','h','t',' '),     HB_TAG('K','H','N',' ')},       \/* Khamti -> Khamti Shan (Microsoft fonts) *\/\n+  {HB_TAG('k','h','v',' '),     HB_TAG_NONE            },       \/* Khvarshi != Khanty-Vakhi *\/\n+\/*{HB_TAG('k','h','w',' '),     HB_TAG('K','H','W',' ')},*\/     \/* Khowar *\/\n+  {HB_TAG('k','i','s',' '),     HB_TAG_NONE            },       \/* Kis != Kisii *\/\n+  {HB_TAG('k','i','u',' '),     HB_TAG('K','I','U',' ')},       \/* Kirmanjki *\/\n+  {HB_TAG('k','i','u',' '),     HB_TAG('Z','Z','A',' ')},       \/* Kirmanjki -> Zazaki *\/\n+  {HB_TAG('k','j','b',' '),     HB_TAG('M','Y','N',' ')},       \/* Q'anjob'al -> Mayan *\/\n+\/*{HB_TAG('k','j','d',' '),     HB_TAG('K','J','D',' ')},*\/     \/* Southern Kiwai *\/\n+  {HB_TAG('k','j','h',' '),     HB_TAG('K','H','A',' ')},       \/* Khakas -> Khakass *\/\n+  {HB_TAG('k','j','p',' '),     HB_TAG('K','J','P',' ')},       \/* Pwo Eastern Karen -> Eastern Pwo Karen *\/\n+  {HB_TAG('k','j','p',' '),     HB_TAG('K','R','N',' ')},       \/* Pwo Eastern Karen -> Karen *\/\n+  {HB_TAG('k','j','t',' '),     HB_TAG('K','R','N',' ')},       \/* Phrae Pwo Karen -> Karen *\/\n+\/*{HB_TAG('k','j','z',' '),     HB_TAG('K','J','Z',' ')},*\/     \/* Bumthangkha *\/\n+  {HB_TAG('k','k','n',' '),     HB_TAG_NONE            },       \/* Kon Keu != Kokni *\/\n+  {HB_TAG('k','k','z',' '),     HB_TAG('A','T','H',' ')},       \/* Kaska -> Athapaskan *\/\n+  {HB_TAG('k','l','m',' '),     HB_TAG_NONE            },       \/* Migum != Kalmyk *\/\n+  {HB_TAG('k','l','n',' '),     HB_TAG('K','A','L',' ')},       \/* Kalenjin [macrolanguage] *\/\n+  {HB_TAG('k','m','b',' '),     HB_TAG('M','B','N',' ')},       \/* Kimbundu -> Mbundu *\/\n+  {HB_TAG('k','m','n',' '),     HB_TAG_NONE            },       \/* Awtuw != Kumaoni *\/\n+  {HB_TAG('k','m','o',' '),     HB_TAG_NONE            },       \/* Kwoma != Komo *\/\n+  {HB_TAG('k','m','r',' '),     HB_TAG('K','U','R',' ')},       \/* Northern Kurdish -> Kurdish *\/\n+  {HB_TAG('k','m','s',' '),     HB_TAG_NONE            },       \/* Kamasau != Komso *\/\n+  {HB_TAG('k','m','v',' '),     HB_TAG('C','P','P',' ')},       \/* Karipna Creole French -> Creoles *\/\n+  {HB_TAG('k','m','w',' '),     HB_TAG('K','M','O',' ')},       \/* Komo (Democratic Republic of Congo) *\/\n+\/*{HB_TAG('k','m','z',' '),     HB_TAG('K','M','Z',' ')},*\/     \/* Khorasani Turkish -> Khorasani Turkic *\/\n+  {HB_TAG('k','n','c',' '),     HB_TAG('K','N','R',' ')},       \/* Central Kanuri -> Kanuri *\/\n+  {HB_TAG('k','n','g',' '),     HB_TAG('K','O','N','0')},       \/* Koongo -> Kongo *\/\n+  {HB_TAG('k','n','j',' '),     HB_TAG('M','Y','N',' ')},       \/* Western Kanjobal -> Mayan *\/\n+  {HB_TAG('k','n','n',' '),     HB_TAG('K','O','K',' ')},       \/* Konkani *\/\n+  {HB_TAG('k','n','r',' '),     HB_TAG_NONE            },       \/* Kaningra != Kanuri *\/\n+  {HB_TAG('k','o','d',' '),     HB_TAG_NONE            },       \/* Kodi != Kodagu *\/\n+  {HB_TAG('k','o','h',' '),     HB_TAG_NONE            },       \/* Koyo != Korean Old Hangul *\/\n+  {HB_TAG('k','o','i',' '),     HB_TAG('K','O','P',' ')},       \/* Komi-Permyak *\/\n+  {HB_TAG('k','o','i',' '),     HB_TAG('K','O','M',' ')},       \/* Komi-Permyak -> Komi *\/\n+\/*{HB_TAG('k','o','k',' '),     HB_TAG('K','O','K',' ')},*\/     \/* Konkani [macrolanguage] *\/\n+  {HB_TAG('k','o','p',' '),     HB_TAG_NONE            },       \/* Waube != Komi-Permyak *\/\n+\/*{HB_TAG('k','o','s',' '),     HB_TAG('K','O','S',' ')},*\/     \/* Kosraean *\/\n+  {HB_TAG('k','o','y',' '),     HB_TAG('A','T','H',' ')},       \/* Koyukon -> Athapaskan *\/\n+  {HB_TAG('k','o','z',' '),     HB_TAG_NONE            },       \/* Korak != Komi-Zyrian *\/\n+  {HB_TAG('k','p','e',' '),     HB_TAG('K','P','L',' ')},       \/* Kpelle [macrolanguage] *\/\n+  {HB_TAG('k','p','l',' '),     HB_TAG_NONE            },       \/* Kpala != Kpelle *\/\n+  {HB_TAG('k','p','p',' '),     HB_TAG('K','R','N',' ')},       \/* Paku Karen (retired code) -> Karen *\/\n+  {HB_TAG('k','p','v',' '),     HB_TAG('K','O','Z',' ')},       \/* Komi-Zyrian *\/\n+  {HB_TAG('k','p','v',' '),     HB_TAG('K','O','M',' ')},       \/* Komi-Zyrian -> Komi *\/\n+  {HB_TAG('k','p','y',' '),     HB_TAG('K','Y','K',' ')},       \/* Koryak *\/\n+  {HB_TAG('k','q','s',' '),     HB_TAG('K','I','S',' ')},       \/* Northern Kissi -> Kisii *\/\n+  {HB_TAG('k','q','y',' '),     HB_TAG('K','R','T',' ')},       \/* Koorete *\/\n+  {HB_TAG('k','r','c',' '),     HB_TAG('K','A','R',' ')},       \/* Karachay-Balkar -> Karachay *\/\n+  {HB_TAG('k','r','c',' '),     HB_TAG('B','A','L',' ')},       \/* Karachay-Balkar -> Balkar *\/\n+  {HB_TAG('k','r','i',' '),     HB_TAG('K','R','I',' ')},       \/* Krio *\/\n+  {HB_TAG('k','r','i',' '),     HB_TAG('C','P','P',' ')},       \/* Krio -> Creoles *\/\n+  {HB_TAG('k','r','k',' '),     HB_TAG_NONE            },       \/* Kerek != Karakalpak *\/\n+\/*{HB_TAG('k','r','l',' '),     HB_TAG('K','R','L',' ')},*\/     \/* Karelian *\/\n+  {HB_TAG('k','r','m',' '),     HB_TAG_NONE            },       \/* Krim (retired code) != Karaim *\/\n+  {HB_TAG('k','r','n',' '),     HB_TAG_NONE            },       \/* Sapo != Karen *\/\n+  {HB_TAG('k','r','t',' '),     HB_TAG('K','N','R',' ')},       \/* Tumari Kanuri -> Kanuri *\/\n+  {HB_TAG('k','r','u',' '),     HB_TAG('K','U','U',' ')},       \/* Kurukh *\/\n+  {HB_TAG('k','s','h',' '),     HB_TAG('K','S','H','0')},       \/* Klsch -> Ripuarian *\/\n+  {HB_TAG('k','s','i',' '),     HB_TAG_NONE            },       \/* Krisa != Khasi *\/\n+  {HB_TAG('k','s','m',' '),     HB_TAG_NONE            },       \/* Kumba != Kildin Sami *\/\n+  {HB_TAG('k','s','s',' '),     HB_TAG('K','I','S',' ')},       \/* Southern Kisi -> Kisii *\/\n+  {HB_TAG('k','s','w',' '),     HB_TAG('K','S','W',' ')},       \/* Sgaw Karen *\/\n+  {HB_TAG('k','s','w',' '),     HB_TAG('K','R','N',' ')},       \/* S'gaw Karen -> Karen *\/\n+  {HB_TAG('k','t','b',' '),     HB_TAG('K','E','B',' ')},       \/* Kambaata -> Kebena *\/\n+  {HB_TAG('k','t','u',' '),     HB_TAG('K','O','N',' ')},       \/* Kituba (Democratic Republic of Congo) -> Kikongo *\/\n+  {HB_TAG('k','t','w',' '),     HB_TAG('A','T','H',' ')},       \/* Kato -> Athapaskan *\/\n+  {HB_TAG('k','u','i',' '),     HB_TAG_NONE            },       \/* Kuikro-Kalaplo != Kui *\/\n+  {HB_TAG('k','u','l',' '),     HB_TAG_NONE            },       \/* Kulere != Kulvi *\/\n+\/*{HB_TAG('k','u','m',' '),     HB_TAG('K','U','M',' ')},*\/     \/* Kumyk *\/\n+  {HB_TAG('k','u','u',' '),     HB_TAG('A','T','H',' ')},       \/* Upper Kuskokwim -> Athapaskan *\/\n+  {HB_TAG('k','u','w',' '),     HB_TAG('B','A','D','0')},       \/* Kpagua -> Banda *\/\n+  {HB_TAG('k','u','y',' '),     HB_TAG_NONE            },       \/* Kuuku-Ya'u != Kuy *\/\n+  {HB_TAG('k','v','b',' '),     HB_TAG('M','L','Y',' ')},       \/* Kubu -> Malay *\/\n+  {HB_TAG('k','v','l',' '),     HB_TAG('K','R','N',' ')},       \/* Kayaw -> Karen *\/\n+  {HB_TAG('k','v','q',' '),     HB_TAG('K','R','N',' ')},       \/* Geba Karen -> Karen *\/\n+  {HB_TAG('k','v','r',' '),     HB_TAG('M','L','Y',' ')},       \/* Kerinci -> Malay *\/\n+  {HB_TAG('k','v','t',' '),     HB_TAG('K','R','N',' ')},       \/* Lahta Karen -> Karen *\/\n+  {HB_TAG('k','v','u',' '),     HB_TAG('K','R','N',' ')},       \/* Yinbaw Karen -> Karen *\/\n+  {HB_TAG('k','v','y',' '),     HB_TAG('K','R','N',' ')},       \/* Yintale Karen -> Karen *\/\n+\/*{HB_TAG('k','w','k',' '),     HB_TAG('K','W','K',' ')},*\/     \/* Kwakiutl -> Kwakwala *\/\n+  {HB_TAG('k','w','w',' '),     HB_TAG('C','P','P',' ')},       \/* Kwinti -> Creoles *\/\n+  {HB_TAG('k','w','y',' '),     HB_TAG('K','O','N','0')},       \/* San Salvador Kongo -> Kongo *\/\n+  {HB_TAG('k','x','c',' '),     HB_TAG('K','M','S',' ')},       \/* Konso -> Komso *\/\n+  {HB_TAG('k','x','d',' '),     HB_TAG('M','L','Y',' ')},       \/* Brunei -> Malay *\/\n+  {HB_TAG('k','x','f',' '),     HB_TAG('K','R','N',' ')},       \/* Manumanaw Karen -> Karen *\/\n+  {HB_TAG('k','x','k',' '),     HB_TAG('K','R','N',' ')},       \/* Zayein Karen -> Karen *\/\n+  {HB_TAG('k','x','l',' '),     HB_TAG('K','U','U',' ')},       \/* Nepali Kurux (retired code) -> Kurukh *\/\n+  {HB_TAG('k','x','u',' '),     HB_TAG('K','U','I',' ')},       \/* Kui (India) (retired code) *\/\n+  {HB_TAG('k','y','k',' '),     HB_TAG_NONE            },       \/* Kamayo != Koryak *\/\n+  {HB_TAG('k','y','u',' '),     HB_TAG('K','Y','U',' ')},       \/* Western Kayah *\/\n+  {HB_TAG('k','y','u',' '),     HB_TAG('K','R','N',' ')},       \/* Western Kayah -> Karen *\/\n+  {HB_TAG('l','a','c',' '),     HB_TAG('M','Y','N',' ')},       \/* Lacandon -> Mayan *\/\n+  {HB_TAG('l','a','d',' '),     HB_TAG('J','U','D',' ')},       \/* Ladino *\/\n+  {HB_TAG('l','a','h',' '),     HB_TAG_NONE            },       \/* Lahnda [macrolanguage] != Lahuli *\/\n+  {HB_TAG('l','a','k',' '),     HB_TAG_NONE            },       \/* Laka (Nigeria) (retired code) != Lak *\/\n+  {HB_TAG('l','a','m',' '),     HB_TAG_NONE            },       \/* Lamba != Lambani *\/\n+  {HB_TAG('l','a','z',' '),     HB_TAG_NONE            },       \/* Aribwatsa != Laz *\/\n+  {HB_TAG('l','b','e',' '),     HB_TAG('L','A','K',' ')},       \/* Lak *\/\n+  {HB_TAG('l','b','j',' '),     HB_TAG('L','D','K',' ')},       \/* Ladakhi *\/\n+  {HB_TAG('l','b','l',' '),     HB_TAG('B','I','K',' ')},       \/* Libon Bikol -> Bikol *\/\n+  {HB_TAG('l','c','e',' '),     HB_TAG('M','L','Y',' ')},       \/* Loncong -> Malay *\/\n+  {HB_TAG('l','c','f',' '),     HB_TAG('M','L','Y',' ')},       \/* Lubu -> Malay *\/\n+  {HB_TAG('l','d','i',' '),     HB_TAG('K','O','N','0')},       \/* Laari -> Kongo *\/\n+  {HB_TAG('l','d','k',' '),     HB_TAG_NONE            },       \/* Leelau != Ladakhi *\/\n+\/*{HB_TAG('l','e','f',' '),     HB_TAG('L','E','F',' ')},*\/     \/* Lelemi *\/\n+\/*{HB_TAG('l','e','z',' '),     HB_TAG('L','E','Z',' ')},*\/     \/* Lezghian -> Lezgi *\/\n+  {HB_TAG('l','i','f',' '),     HB_TAG('L','M','B',' ')},       \/* Limbu *\/\n+\/*{HB_TAG('l','i','j',' '),     HB_TAG('L','I','J',' ')},*\/     \/* Ligurian *\/\n+  {HB_TAG('l','i','r',' '),     HB_TAG('C','P','P',' ')},       \/* Liberian English -> Creoles *\/\n+\/*{HB_TAG('l','i','s',' '),     HB_TAG('L','I','S',' ')},*\/     \/* Lisu *\/\n+  {HB_TAG('l','i','w',' '),     HB_TAG('M','L','Y',' ')},       \/* Col -> Malay *\/\n+  {HB_TAG('l','i','y',' '),     HB_TAG('B','A','D','0')},       \/* Banda-Bambari -> Banda *\/\n+\/*{HB_TAG('l','j','p',' '),     HB_TAG('L','J','P',' ')},*\/     \/* Lampung Api -> Lampung *\/\n+  {HB_TAG('l','k','b',' '),     HB_TAG('L','U','H',' ')},       \/* Kabras -> Luyia *\/\n+\/*{HB_TAG('l','k','i',' '),     HB_TAG('L','K','I',' ')},*\/     \/* Laki *\/\n+  {HB_TAG('l','k','o',' '),     HB_TAG('L','U','H',' ')},       \/* Khayo -> Luyia *\/\n+  {HB_TAG('l','k','s',' '),     HB_TAG('L','U','H',' ')},       \/* Kisa -> Luyia *\/\n+  {HB_TAG('l','l','d',' '),     HB_TAG('L','A','D',' ')},       \/* Ladin *\/\n+  {HB_TAG('l','m','a',' '),     HB_TAG_NONE            },       \/* East Limba != Low Mari *\/\n+  {HB_TAG('l','m','b',' '),     HB_TAG_NONE            },       \/* Merei != Limbu *\/\n+  {HB_TAG('l','m','n',' '),     HB_TAG('L','A','M',' ')},       \/* Lambadi -> Lambani *\/\n+\/*{HB_TAG('l','m','o',' '),     HB_TAG('L','M','O',' ')},*\/     \/* Lombard *\/\n+  {HB_TAG('l','m','w',' '),     HB_TAG_NONE            },       \/* Lake Miwok != Lomwe *\/\n+  {HB_TAG('l','n','a',' '),     HB_TAG('B','A','D','0')},       \/* Langbashe -> Banda *\/\n+  {HB_TAG('l','n','l',' '),     HB_TAG('B','A','D','0')},       \/* South Central Banda -> Banda *\/\n+\/*{HB_TAG('l','o','m',' '),     HB_TAG('L','O','M',' ')},*\/     \/* Loma (Liberia) *\/\n+  {HB_TAG('l','o','u',' '),     HB_TAG('C','P','P',' ')},       \/* Louisiana Creole -> Creoles *\/\n+\/*{HB_TAG('l','p','o',' '),     HB_TAG('L','P','O',' ')},*\/     \/* Lipo *\/\n+\/*{HB_TAG('l','r','c',' '),     HB_TAG('L','R','C',' ')},*\/     \/* Northern Luri -> Luri *\/\n+  {HB_TAG('l','r','i',' '),     HB_TAG('L','U','H',' ')},       \/* Marachi -> Luyia *\/\n+  {HB_TAG('l','r','m',' '),     HB_TAG('L','U','H',' ')},       \/* Marama -> Luyia *\/\n+  {HB_TAG('l','r','t',' '),     HB_TAG('C','P','P',' ')},       \/* Larantuka Malay -> Creoles *\/\n+  {HB_TAG('l','s','b',' '),     HB_TAG_NONE            },       \/* Burundian Sign Language != Lower Sorbian *\/\n+  {HB_TAG('l','s','m',' '),     HB_TAG('L','U','H',' ')},       \/* Saamia -> Luyia *\/\n+  {HB_TAG('l','t','g',' '),     HB_TAG('L','V','I',' ')},       \/* Latgalian -> Latvian *\/\n+  {HB_TAG('l','t','h',' '),     HB_TAG_NONE            },       \/* Thur != Lithuanian *\/\n+  {HB_TAG('l','t','o',' '),     HB_TAG('L','U','H',' ')},       \/* Tsotso -> Luyia *\/\n+  {HB_TAG('l','t','s',' '),     HB_TAG('L','U','H',' ')},       \/* Tachoni -> Luyia *\/\n+\/*{HB_TAG('l','u','a',' '),     HB_TAG('L','U','A',' ')},*\/     \/* Luba-Lulua *\/\n+\/*{HB_TAG('l','u','o',' '),     HB_TAG('L','U','O',' ')},*\/     \/* Luo (Kenya and Tanzania) *\/\n+  {HB_TAG('l','u','s',' '),     HB_TAG('M','I','Z',' ')},       \/* Lushai -> Mizo *\/\n+  {HB_TAG('l','u','s',' '),     HB_TAG('Q','I','N',' ')},       \/* Lushai -> Chin *\/\n+  {HB_TAG('l','u','y',' '),     HB_TAG('L','U','H',' ')},       \/* Luyia [macrolanguage] *\/\n+  {HB_TAG('l','u','z',' '),     HB_TAG('L','R','C',' ')},       \/* Southern Luri -> Luri *\/\n+  {HB_TAG('l','v','i',' '),     HB_TAG_NONE            },       \/* Lavi != Latvian *\/\n+  {HB_TAG('l','v','s',' '),     HB_TAG('L','V','I',' ')},       \/* Standard Latvian -> Latvian *\/\n+  {HB_TAG('l','w','g',' '),     HB_TAG('L','U','H',' ')},       \/* Wanga -> Luyia *\/\n+  {HB_TAG('l','z','h',' '),     HB_TAG('Z','H','T',' ')},       \/* Literary Chinese -> Chinese, Traditional *\/\n+  {HB_TAG('l','z','z',' '),     HB_TAG('L','A','Z',' ')},       \/* Laz *\/\n+\/*{HB_TAG('m','a','d',' '),     HB_TAG('M','A','D',' ')},*\/     \/* Madurese -> Madura *\/\n+\/*{HB_TAG('m','a','g',' '),     HB_TAG('M','A','G',' ')},*\/     \/* Magahi *\/\n+  {HB_TAG('m','a','i',' '),     HB_TAG('M','T','H',' ')},       \/* Maithili *\/\n+  {HB_TAG('m','a','j',' '),     HB_TAG_NONE            },       \/* Jalapa De Daz Mazatec != Majang *\/\n+  {HB_TAG('m','a','k',' '),     HB_TAG('M','K','R',' ')},       \/* Makasar *\/\n+  {HB_TAG('m','a','m',' '),     HB_TAG('M','A','M',' ')},       \/* Mam *\/\n+  {HB_TAG('m','a','m',' '),     HB_TAG('M','Y','N',' ')},       \/* Mam -> Mayan *\/\n+  {HB_TAG('m','a','n',' '),     HB_TAG('M','N','K',' ')},       \/* Mandingo [macrolanguage] -> Maninka *\/\n+  {HB_TAG('m','a','p',' '),     HB_TAG_NONE            },       \/* Austronesian [collection] != Mapudungun *\/\n+  {HB_TAG('m','a','w',' '),     HB_TAG_NONE            },       \/* Mampruli != Marwari *\/\n+  {HB_TAG('m','a','x',' '),     HB_TAG('M','L','Y',' ')},       \/* North Moluccan Malay -> Malay *\/\n+  {HB_TAG('m','a','x',' '),     HB_TAG('C','P','P',' ')},       \/* North Moluccan Malay -> Creoles *\/\n+  {HB_TAG('m','b','f',' '),     HB_TAG('C','P','P',' ')},       \/* Baba Malay -> Creoles *\/\n+  {HB_TAG('m','b','n',' '),     HB_TAG_NONE            },       \/* Macagun != Mbundu *\/\n+\/*{HB_TAG('m','b','o',' '),     HB_TAG('M','B','O',' ')},*\/     \/* Mbo (Cameroon) *\/\n+  {HB_TAG('m','c','h',' '),     HB_TAG_NONE            },       \/* Maquiritari != Manchu *\/\n+  {HB_TAG('m','c','m',' '),     HB_TAG('C','P','P',' ')},       \/* Malaccan Creole Portuguese -> Creoles *\/\n+  {HB_TAG('m','c','r',' '),     HB_TAG_NONE            },       \/* Menya != Moose Cree *\/\n+  {HB_TAG('m','c','t',' '),     HB_TAG('B','T','I',' ')},       \/* Mengisa -> Beti *\/\n+  {HB_TAG('m','d','e',' '),     HB_TAG_NONE            },       \/* Maba (Chad) != Mende *\/\n+  {HB_TAG('m','d','f',' '),     HB_TAG('M','O','K',' ')},       \/* Moksha *\/\n+\/*{HB_TAG('m','d','r',' '),     HB_TAG('M','D','R',' ')},*\/     \/* Mandar *\/\n+  {HB_TAG('m','d','y',' '),     HB_TAG('M','L','E',' ')},       \/* Male (Ethiopia) *\/\n+  {HB_TAG('m','e','n',' '),     HB_TAG('M','D','E',' ')},       \/* Mende (Sierra Leone) *\/\n+  {HB_TAG('m','e','o',' '),     HB_TAG('M','L','Y',' ')},       \/* Kedah Malay -> Malay *\/\n+\/*{HB_TAG('m','e','r',' '),     HB_TAG('M','E','R',' ')},*\/     \/* Meru *\/\n+  {HB_TAG('m','f','a',' '),     HB_TAG('M','F','A',' ')},       \/* Pattani Malay *\/\n+  {HB_TAG('m','f','a',' '),     HB_TAG('M','L','Y',' ')},       \/* Pattani Malay -> Malay *\/\n+  {HB_TAG('m','f','b',' '),     HB_TAG('M','L','Y',' ')},       \/* Bangka -> Malay *\/\n+  {HB_TAG('m','f','e',' '),     HB_TAG('M','F','E',' ')},       \/* Morisyen *\/\n+  {HB_TAG('m','f','e',' '),     HB_TAG('C','P','P',' ')},       \/* Morisyen -> Creoles *\/\n+  {HB_TAG('m','f','p',' '),     HB_TAG('C','P','P',' ')},       \/* Makassar Malay -> Creoles *\/\n+  {HB_TAG('m','h','c',' '),     HB_TAG('M','Y','N',' ')},       \/* Mocho -> Mayan *\/\n+  {HB_TAG('m','h','r',' '),     HB_TAG('L','M','A',' ')},       \/* Eastern Mari -> Low Mari *\/\n+  {HB_TAG('m','h','v',' '),     HB_TAG('A','R','K',' ')},       \/* Arakanese (retired code) -> Rakhine *\/\n+  {HB_TAG('m','i','n',' '),     HB_TAG('M','I','N',' ')},       \/* Minangkabau *\/\n+  {HB_TAG('m','i','n',' '),     HB_TAG('M','L','Y',' ')},       \/* Minangkabau -> Malay *\/\n+  {HB_TAG('m','i','z',' '),     HB_TAG_NONE            },       \/* Coatzospan Mixtec != Mizo *\/\n+  {HB_TAG('m','k','n',' '),     HB_TAG('C','P','P',' ')},       \/* Kupang Malay -> Creoles *\/\n+  {HB_TAG('m','k','r',' '),     HB_TAG_NONE            },       \/* Malas != Makasar *\/\n+  {HB_TAG('m','k','u',' '),     HB_TAG('M','N','K',' ')},       \/* Konyanka Maninka -> Maninka *\/\n+\/*{HB_TAG('m','k','w',' '),     HB_TAG('M','K','W',' ')},*\/     \/* Kituba (Congo) *\/\n+  {HB_TAG('m','l','e',' '),     HB_TAG_NONE            },       \/* Manambu != Male *\/\n+  {HB_TAG('m','l','n',' '),     HB_TAG_NONE            },       \/* Malango != Malinke *\/\n+  {HB_TAG('m','l','q',' '),     HB_TAG('M','L','N',' ')},       \/* Western Maninkakan -> Malinke *\/\n+  {HB_TAG('m','l','q',' '),     HB_TAG('M','N','K',' ')},       \/* Western Maninkakan -> Maninka *\/\n+  {HB_TAG('m','l','r',' '),     HB_TAG_NONE            },       \/* Vame != Malayalam Reformed *\/\n+  {HB_TAG('m','m','r',' '),     HB_TAG('H','M','N',' ')},       \/* Western Xiangxi Miao -> Hmong *\/\n+  {HB_TAG('m','n','c',' '),     HB_TAG('M','C','H',' ')},       \/* Manchu *\/\n+  {HB_TAG('m','n','d',' '),     HB_TAG_NONE            },       \/* Mond != Mandinka *\/\n+  {HB_TAG('m','n','g',' '),     HB_TAG_NONE            },       \/* Eastern Mnong != Mongolian *\/\n+  {HB_TAG('m','n','h',' '),     HB_TAG('B','A','D','0')},       \/* Mono (Democratic Republic of Congo) -> Banda *\/\n+\/*{HB_TAG('m','n','i',' '),     HB_TAG('M','N','I',' ')},*\/     \/* Manipuri *\/\n+  {HB_TAG('m','n','k',' '),     HB_TAG('M','N','D',' ')},       \/* Mandinka *\/\n+  {HB_TAG('m','n','k',' '),     HB_TAG('M','N','K',' ')},       \/* Mandinka -> Maninka *\/\n+  {HB_TAG('m','n','p',' '),     HB_TAG('Z','H','S',' ')},       \/* Min Bei Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('m','n','s',' '),     HB_TAG('M','A','N',' ')},       \/* Mansi *\/\n+  {HB_TAG('m','n','w',' '),     HB_TAG('M','O','N',' ')},       \/* Mon *\/\n+  {HB_TAG('m','n','w',' '),     HB_TAG('M','O','N','T')},       \/* Mon -> Thailand Mon *\/\n+  {HB_TAG('m','n','x',' '),     HB_TAG_NONE            },       \/* Manikion != Manx *\/\n+  {HB_TAG('m','o','d',' '),     HB_TAG('C','P','P',' ')},       \/* Mobilian -> Creoles *\/\n+\/*{HB_TAG('m','o','h',' '),     HB_TAG('M','O','H',' ')},*\/     \/* Mohawk *\/\n+  {HB_TAG('m','o','k',' '),     HB_TAG_NONE            },       \/* Morori != Moksha *\/\n+  {HB_TAG('m','o','p',' '),     HB_TAG('M','Y','N',' ')},       \/* Mopn Maya -> Mayan *\/\n+  {HB_TAG('m','o','r',' '),     HB_TAG_NONE            },       \/* Moro != Moroccan *\/\n+\/*{HB_TAG('m','o','s',' '),     HB_TAG('M','O','S',' ')},*\/     \/* Mossi *\/\n+  {HB_TAG('m','p','e',' '),     HB_TAG('M','A','J',' ')},       \/* Majang *\/\n+  {HB_TAG('m','q','g',' '),     HB_TAG('M','L','Y',' ')},       \/* Kota Bangun Kutai Malay -> Malay *\/\n+  {HB_TAG('m','r','h',' '),     HB_TAG('Q','I','N',' ')},       \/* Mara Chin -> Chin *\/\n+  {HB_TAG('m','r','j',' '),     HB_TAG('H','M','A',' ')},       \/* Western Mari -> High Mari *\/\n+  {HB_TAG('m','s','c',' '),     HB_TAG('M','N','K',' ')},       \/* Sankaran Maninka -> Maninka *\/\n+  {HB_TAG('m','s','h',' '),     HB_TAG('M','L','G',' ')},       \/* Masikoro Malagasy -> Malagasy *\/\n+  {HB_TAG('m','s','i',' '),     HB_TAG('M','L','Y',' ')},       \/* Sabah Malay -> Malay *\/\n+  {HB_TAG('m','s','i',' '),     HB_TAG('C','P','P',' ')},       \/* Sabah Malay -> Creoles *\/\n+  {HB_TAG('m','t','h',' '),     HB_TAG_NONE            },       \/* Munggui != Maithili *\/\n+  {HB_TAG('m','t','r',' '),     HB_TAG('M','A','W',' ')},       \/* Mewari -> Marwari *\/\n+  {HB_TAG('m','t','s',' '),     HB_TAG_NONE            },       \/* Yora != Maltese *\/\n+  {HB_TAG('m','u','d',' '),     HB_TAG('C','P','P',' ')},       \/* Mednyj Aleut -> Creoles *\/\n+  {HB_TAG('m','u','i',' '),     HB_TAG('M','L','Y',' ')},       \/* Musi -> Malay *\/\n+  {HB_TAG('m','u','n',' '),     HB_TAG_NONE            },       \/* Munda [collection] != Mundari *\/\n+  {HB_TAG('m','u','p',' '),     HB_TAG('R','A','J',' ')},       \/* Malvi -> Rajasthani *\/\n+  {HB_TAG('m','u','q',' '),     HB_TAG('H','M','N',' ')},       \/* Eastern Xiangxi Miao -> Hmong *\/\n+\/*{HB_TAG('m','u','s',' '),     HB_TAG('M','U','S',' ')},*\/     \/* Creek -> Muscogee *\/\n+  {HB_TAG('m','v','b',' '),     HB_TAG('A','T','H',' ')},       \/* Mattole -> Athapaskan *\/\n+  {HB_TAG('m','v','e',' '),     HB_TAG('M','A','W',' ')},       \/* Marwari (Pakistan) *\/\n+  {HB_TAG('m','v','f',' '),     HB_TAG('M','N','G',' ')},       \/* Peripheral Mongolian -> Mongolian *\/\n+  {HB_TAG('m','w','k',' '),     HB_TAG('M','N','K',' ')},       \/* Kita Maninkakan -> Maninka *\/\n+\/*{HB_TAG('m','w','l',' '),     HB_TAG('M','W','L',' ')},*\/     \/* Mirandese *\/\n+  {HB_TAG('m','w','q',' '),     HB_TAG('Q','I','N',' ')},       \/* Mn Chin -> Chin *\/\n+  {HB_TAG('m','w','r',' '),     HB_TAG('M','A','W',' ')},       \/* Marwari [macrolanguage] *\/\n+  {HB_TAG('m','w','w',' '),     HB_TAG('M','W','W',' ')},       \/* Hmong Daw *\/\n+  {HB_TAG('m','w','w',' '),     HB_TAG('H','M','N',' ')},       \/* Hmong Daw -> Hmong *\/\n+  {HB_TAG('m','y','m',' '),     HB_TAG('M','E','N',' ')},       \/* Meen *\/\n+\/*{HB_TAG('m','y','n',' '),     HB_TAG('M','Y','N',' ')},*\/     \/* Mayan [collection] *\/\n+  {HB_TAG('m','y','q',' '),     HB_TAG('M','N','K',' ')},       \/* Forest Maninka (retired code) -> Maninka *\/\n+  {HB_TAG('m','y','v',' '),     HB_TAG('E','R','Z',' ')},       \/* Erzya *\/\n+  {HB_TAG('m','z','b',' '),     HB_TAG('B','B','R',' ')},       \/* Tumzabt -> Berber *\/\n+\/*{HB_TAG('m','z','n',' '),     HB_TAG('M','Z','N',' ')},*\/     \/* Mazanderani *\/\n+  {HB_TAG('m','z','s',' '),     HB_TAG('C','P','P',' ')},       \/* Macanese -> Creoles *\/\n+  {HB_TAG('n','a','g',' '),     HB_TAG('N','A','G',' ')},       \/* Naga Pidgin -> Naga-Assamese *\/\n+  {HB_TAG('n','a','g',' '),     HB_TAG('C','P','P',' ')},       \/* Naga Pidgin -> Creoles *\/\n+\/*{HB_TAG('n','a','h',' '),     HB_TAG('N','A','H',' ')},*\/     \/* Nahuatl [collection] *\/\n+  {HB_TAG('n','a','n',' '),     HB_TAG('Z','H','S',' ')},       \/* Min Nan Chinese -> Chinese, Simplified *\/\n+\/*{HB_TAG('n','a','p',' '),     HB_TAG('N','A','P',' ')},*\/     \/* Neapolitan *\/\n+  {HB_TAG('n','a','s',' '),     HB_TAG_NONE            },       \/* Naasioi != Naskapi *\/\n+  {HB_TAG('n','a','z',' '),     HB_TAG('N','A','H',' ')},       \/* Coatepec Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','c','h',' '),     HB_TAG('N','A','H',' ')},       \/* Central Huasteca Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','c','i',' '),     HB_TAG('N','A','H',' ')},       \/* Classical Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','c','j',' '),     HB_TAG('N','A','H',' ')},       \/* Northern Puebla Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','c','l',' '),     HB_TAG('N','A','H',' ')},       \/* Michoacn Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','c','r',' '),     HB_TAG_NONE            },       \/* Ncane != N-Cree *\/\n+  {HB_TAG('n','c','x',' '),     HB_TAG('N','A','H',' ')},       \/* Central Puebla Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','d','b',' '),     HB_TAG_NONE            },       \/* Kenswei Nsei != Ndebele *\/\n+\/*{HB_TAG('n','d','c',' '),     HB_TAG('N','D','C',' ')},*\/     \/* Ndau *\/\n+  {HB_TAG('n','d','g',' '),     HB_TAG_NONE            },       \/* Ndengereko != Ndonga *\/\n+\/*{HB_TAG('n','d','s',' '),     HB_TAG('N','D','S',' ')},*\/     \/* Low Saxon *\/\n+  {HB_TAG('n','e','f',' '),     HB_TAG('C','P','P',' ')},       \/* Nefamese -> Creoles *\/\n+\/*{HB_TAG('n','e','w',' '),     HB_TAG('N','E','W',' ')},*\/     \/* Newari *\/\n+\/*{HB_TAG('n','g','a',' '),     HB_TAG('N','G','A',' ')},*\/     \/* Ngbaka *\/\n+  {HB_TAG('n','g','l',' '),     HB_TAG('L','M','W',' ')},       \/* Lomwe *\/\n+  {HB_TAG('n','g','m',' '),     HB_TAG('C','P','P',' ')},       \/* Ngatik Men's Creole -> Creoles *\/\n+  {HB_TAG('n','g','o',' '),     HB_TAG('S','X','T',' ')},       \/* Ngoni (retired code) -> Sutu *\/\n+  {HB_TAG('n','g','r',' '),     HB_TAG_NONE            },       \/* Engdewu != Nagari *\/\n+  {HB_TAG('n','g','u',' '),     HB_TAG('N','A','H',' ')},       \/* Guerrero Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','c',' '),     HB_TAG('N','A','H',' ')},       \/* Tabasco Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','d',' '),     HB_TAG('G','U','A',' ')},       \/* Chirip -> Guarani *\/\n+  {HB_TAG('n','h','e',' '),     HB_TAG('N','A','H',' ')},       \/* Eastern Huasteca Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','g',' '),     HB_TAG('N','A','H',' ')},       \/* Tetelcingo Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','i',' '),     HB_TAG('N','A','H',' ')},       \/* Zacatln-Ahuacatln-Tepetzintla Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','k',' '),     HB_TAG('N','A','H',' ')},       \/* Isthmus-Cosoleacaque Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','m',' '),     HB_TAG('N','A','H',' ')},       \/* Morelos Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','n',' '),     HB_TAG('N','A','H',' ')},       \/* Central Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','p',' '),     HB_TAG('N','A','H',' ')},       \/* Isthmus-Pajapan Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','q',' '),     HB_TAG('N','A','H',' ')},       \/* Huaxcaleca Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','t',' '),     HB_TAG('N','A','H',' ')},       \/* Ometepec Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','v',' '),     HB_TAG('N','A','H',' ')},       \/* Temascaltepec Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','w',' '),     HB_TAG('N','A','H',' ')},       \/* Western Huasteca Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','x',' '),     HB_TAG('N','A','H',' ')},       \/* Isthmus-Mecayapan Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','y',' '),     HB_TAG('N','A','H',' ')},       \/* Northern Oaxaca Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','h','z',' '),     HB_TAG('N','A','H',' ')},       \/* Santa Mara La Alta Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','i','q',' '),     HB_TAG('K','A','L',' ')},       \/* Nandi -> Kalenjin *\/\n+  {HB_TAG('n','i','s',' '),     HB_TAG_NONE            },       \/* Nimi != Nisi *\/\n+\/*{HB_TAG('n','i','u',' '),     HB_TAG('N','I','U',' ')},*\/     \/* Niuean *\/\n+  {HB_TAG('n','i','v',' '),     HB_TAG('G','I','L',' ')},       \/* Gilyak *\/\n+  {HB_TAG('n','j','t',' '),     HB_TAG('C','P','P',' ')},       \/* Ndyuka-Trio Pidgin -> Creoles *\/\n+  {HB_TAG('n','j','z',' '),     HB_TAG('N','I','S',' ')},       \/* Nyishi -> Nisi *\/\n+  {HB_TAG('n','k','o',' '),     HB_TAG_NONE            },       \/* Nkonya != NKo *\/\n+  {HB_TAG('n','k','x',' '),     HB_TAG('I','J','O',' ')},       \/* Nkoroo -> Ijo *\/\n+  {HB_TAG('n','l','a',' '),     HB_TAG('B','M','L',' ')},       \/* Ngombale -> Bamileke *\/\n+  {HB_TAG('n','l','e',' '),     HB_TAG('L','U','H',' ')},       \/* East Nyala -> Luyia *\/\n+  {HB_TAG('n','l','n',' '),     HB_TAG('N','A','H',' ')},       \/* Durango Nahuatl (retired code) -> Nahuatl *\/\n+  {HB_TAG('n','l','v',' '),     HB_TAG('N','A','H',' ')},       \/* Orizaba Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','n','h',' '),     HB_TAG('B','M','L',' ')},       \/* Ngiemboon -> Bamileke *\/\n+  {HB_TAG('n','n','z',' '),     HB_TAG('B','M','L',' ')},       \/* Nda'nda' -> Bamileke *\/\n+  {HB_TAG('n','o','d',' '),     HB_TAG('N','T','A',' ')},       \/* Northern Thai -> Northern Tai *\/\n+\/*{HB_TAG('n','o','e',' '),     HB_TAG('N','O','E',' ')},*\/     \/* Nimadi *\/\n+\/*{HB_TAG('n','o','g',' '),     HB_TAG('N','O','G',' ')},*\/     \/* Nogai *\/\n+\/*{HB_TAG('n','o','v',' '),     HB_TAG('N','O','V',' ')},*\/     \/* Novial *\/\n+  {HB_TAG('n','p','i',' '),     HB_TAG('N','E','P',' ')},       \/* Nepali *\/\n+  {HB_TAG('n','p','l',' '),     HB_TAG('N','A','H',' ')},       \/* Southeastern Puebla Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','q','o',' '),     HB_TAG('N','K','O',' ')},       \/* NKo *\/\n+  {HB_TAG('n','s','k',' '),     HB_TAG('N','A','S',' ')},       \/* Naskapi *\/\n+  {HB_TAG('n','s','m',' '),     HB_TAG_NONE            },       \/* Sumi Naga != Northern Sami *\/\n+\/*{HB_TAG('n','s','o',' '),     HB_TAG('N','S','O',' ')},*\/     \/* Northern Sotho *\/\n+  {HB_TAG('n','s','u',' '),     HB_TAG('N','A','H',' ')},       \/* Sierra Negra Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','t','o',' '),     HB_TAG_NONE            },       \/* Ntomba != Esperanto *\/\n+  {HB_TAG('n','u','e',' '),     HB_TAG('B','A','D','0')},       \/* Ngundu -> Banda *\/\n+  {HB_TAG('n','u','u',' '),     HB_TAG('B','A','D','0')},       \/* Ngbundu -> Banda *\/\n+  {HB_TAG('n','u','z',' '),     HB_TAG('N','A','H',' ')},       \/* Tlamacazapa Nahuatl -> Nahuatl *\/\n+  {HB_TAG('n','w','e',' '),     HB_TAG('B','M','L',' ')},       \/* Ngwe -> Bamileke *\/\n+  {HB_TAG('n','y','d',' '),     HB_TAG('L','U','H',' ')},       \/* Nyore -> Luyia *\/\n+\/*{HB_TAG('n','y','m',' '),     HB_TAG('N','Y','M',' ')},*\/     \/* Nyamwezi *\/\n+  {HB_TAG('n','y','n',' '),     HB_TAG('N','K','L',' ')},       \/* Nyankole *\/\n+\/*{HB_TAG('n','z','a',' '),     HB_TAG('N','Z','A',' ')},*\/     \/* Tigon Mbembe -> Mbembe Tigon *\/\n+\/*{HB_TAG('o','j','b',' '),     HB_TAG('O','J','B',' ')},*\/     \/* Northwestern Ojibwa -> Ojibway *\/\n+  {HB_TAG('o','j','c',' '),     HB_TAG('O','J','B',' ')},       \/* Central Ojibwa -> Ojibway *\/\n+  {HB_TAG('o','j','g',' '),     HB_TAG('O','J','B',' ')},       \/* Eastern Ojibwa -> Ojibway *\/\n+  {HB_TAG('o','j','s',' '),     HB_TAG('O','C','R',' ')},       \/* Severn Ojibwa -> Oji-Cree *\/\n+  {HB_TAG('o','j','s',' '),     HB_TAG('O','J','B',' ')},       \/* Severn Ojibwa -> Ojibway *\/\n+  {HB_TAG('o','j','w',' '),     HB_TAG('O','J','B',' ')},       \/* Western Ojibwa -> Ojibway *\/\n+  {HB_TAG('o','k','d',' '),     HB_TAG('I','J','O',' ')},       \/* Okodia -> Ijo *\/\n+  {HB_TAG('o','k','i',' '),     HB_TAG('K','A','L',' ')},       \/* Okiek -> Kalenjin *\/\n+  {HB_TAG('o','k','m',' '),     HB_TAG('K','O','H',' ')},       \/* Middle Korean (10th-16th cent.) -> Korean Old Hangul *\/\n+  {HB_TAG('o','k','r',' '),     HB_TAG('I','J','O',' ')},       \/* Kirike -> Ijo *\/\n+  {HB_TAG('o','n','x',' '),     HB_TAG('C','P','P',' ')},       \/* Onin Based Pidgin -> Creoles *\/\n+  {HB_TAG('o','o','r',' '),     HB_TAG('C','P','P',' ')},       \/* Oorlams -> Creoles *\/\n+  {HB_TAG('o','r','c',' '),     HB_TAG('O','R','O',' ')},       \/* Orma -> Oromo *\/\n+  {HB_TAG('o','r','n',' '),     HB_TAG('M','L','Y',' ')},       \/* Orang Kanaq -> Malay *\/\n+  {HB_TAG('o','r','o',' '),     HB_TAG_NONE            },       \/* Orokolo != Oromo *\/\n+  {HB_TAG('o','r','r',' '),     HB_TAG('I','J','O',' ')},       \/* Oruma -> Ijo *\/\n+  {HB_TAG('o','r','s',' '),     HB_TAG('M','L','Y',' ')},       \/* Orang Seletar -> Malay *\/\n+  {HB_TAG('o','r','y',' '),     HB_TAG('O','R','I',' ')},       \/* Odia (formerly Oriya) *\/\n+  {HB_TAG('o','t','w',' '),     HB_TAG('O','J','B',' ')},       \/* Ottawa -> Ojibway *\/\n+  {HB_TAG('o','u','a',' '),     HB_TAG('B','B','R',' ')},       \/* Tagargrent -> Berber *\/\n+  {HB_TAG('p','a','a',' '),     HB_TAG_NONE            },       \/* Papuan [collection] != Palestinian Aramaic *\/\n+\/*{HB_TAG('p','a','g',' '),     HB_TAG('P','A','G',' ')},*\/     \/* Pangasinan *\/\n+  {HB_TAG('p','a','l',' '),     HB_TAG_NONE            },       \/* Pahlavi != Pali *\/\n+\/*{HB_TAG('p','a','m',' '),     HB_TAG('P','A','M',' ')},*\/     \/* Pampanga -> Pampangan *\/\n+  {HB_TAG('p','a','p',' '),     HB_TAG('P','A','P','0')},       \/* Papiamento -> Papiamentu *\/\n+  {HB_TAG('p','a','p',' '),     HB_TAG('C','P','P',' ')},       \/* Papiamento -> Creoles *\/\n+  {HB_TAG('p','a','s',' '),     HB_TAG_NONE            },       \/* Papasena != Pashto *\/\n+\/*{HB_TAG('p','a','u',' '),     HB_TAG('P','A','U',' ')},*\/     \/* Palauan *\/\n+  {HB_TAG('p','b','t',' '),     HB_TAG('P','A','S',' ')},       \/* Southern Pashto -> Pashto *\/\n+  {HB_TAG('p','b','u',' '),     HB_TAG('P','A','S',' ')},       \/* Northern Pashto -> Pashto *\/\n+\/*{HB_TAG('p','c','c',' '),     HB_TAG('P','C','C',' ')},*\/     \/* Bouyei *\/\n+\/*{HB_TAG('p','c','d',' '),     HB_TAG('P','C','D',' ')},*\/     \/* Picard *\/\n+  {HB_TAG('p','c','e',' '),     HB_TAG('P','L','G',' ')},       \/* Ruching Palaung -> Palaung *\/\n+  {HB_TAG('p','c','k',' '),     HB_TAG('Q','I','N',' ')},       \/* Paite Chin -> Chin *\/\n+  {HB_TAG('p','c','m',' '),     HB_TAG('C','P','P',' ')},       \/* Nigerian Pidgin -> Creoles *\/\n+\/*{HB_TAG('p','d','c',' '),     HB_TAG('P','D','C',' ')},*\/     \/* Pennsylvania German *\/\n+  {HB_TAG('p','d','u',' '),     HB_TAG('K','R','N',' ')},       \/* Kayan -> Karen *\/\n+  {HB_TAG('p','e','a',' '),     HB_TAG('C','P','P',' ')},       \/* Peranakan Indonesian -> Creoles *\/\n+  {HB_TAG('p','e','l',' '),     HB_TAG('M','L','Y',' ')},       \/* Pekal -> Malay *\/\n+  {HB_TAG('p','e','s',' '),     HB_TAG('F','A','R',' ')},       \/* Iranian Persian -> Persian *\/\n+  {HB_TAG('p','e','y',' '),     HB_TAG('C','P','P',' ')},       \/* Petjo -> Creoles *\/\n+  {HB_TAG('p','g','a',' '),     HB_TAG('A','R','A',' ')},       \/* Sudanese Creole Arabic -> Arabic *\/\n+  {HB_TAG('p','g','a',' '),     HB_TAG('C','P','P',' ')},       \/* Sudanese Creole Arabic -> Creoles *\/\n+\/*{HB_TAG('p','h','k',' '),     HB_TAG('P','H','K',' ')},*\/     \/* Phake *\/\n+  {HB_TAG('p','i','h',' '),     HB_TAG('P','I','H',' ')},       \/* Pitcairn-Norfolk -> Norfolk *\/\n+  {HB_TAG('p','i','h',' '),     HB_TAG('C','P','P',' ')},       \/* Pitcairn-Norfolk -> Creoles *\/\n+  {HB_TAG('p','i','l',' '),     HB_TAG_NONE            },       \/* Yom != Filipino *\/\n+  {HB_TAG('p','i','s',' '),     HB_TAG('C','P','P',' ')},       \/* Pijin -> Creoles *\/\n+  {HB_TAG('p','k','h',' '),     HB_TAG('Q','I','N',' ')},       \/* Pankhu -> Chin *\/\n+  {HB_TAG('p','k','o',' '),     HB_TAG('K','A','L',' ')},       \/* Pkoot -> Kalenjin *\/\n+  {HB_TAG('p','l','g',' '),     HB_TAG_NONE            },       \/* Pilag != Palaung *\/\n+  {HB_TAG('p','l','k',' '),     HB_TAG_NONE            },       \/* Kohistani Shina != Polish *\/\n+  {HB_TAG('p','l','l',' '),     HB_TAG('P','L','G',' ')},       \/* Shwe Palaung -> Palaung *\/\n+  {HB_TAG('p','l','n',' '),     HB_TAG('C','P','P',' ')},       \/* Palenquero -> Creoles *\/\n+  {HB_TAG('p','l','p',' '),     HB_TAG('P','A','P',' ')},       \/* Palpa (retired code) *\/\n+  {HB_TAG('p','l','t',' '),     HB_TAG('M','L','G',' ')},       \/* Plateau Malagasy -> Malagasy *\/\n+  {HB_TAG('p','m','l',' '),     HB_TAG('C','P','P',' ')},       \/* Lingua Franca -> Creoles *\/\n+\/*{HB_TAG('p','m','s',' '),     HB_TAG('P','M','S',' ')},*\/     \/* Piemontese *\/\n+  {HB_TAG('p','m','y',' '),     HB_TAG('C','P','P',' ')},       \/* Papuan Malay -> Creoles *\/\n+\/*{HB_TAG('p','n','b',' '),     HB_TAG('P','N','B',' ')},*\/     \/* Western Panjabi *\/\n+  {HB_TAG('p','o','c',' '),     HB_TAG('M','Y','N',' ')},       \/* Poqomam -> Mayan *\/\n+  {HB_TAG('p','o','h',' '),     HB_TAG('P','O','H',' ')},       \/* Poqomchi' -> Pocomchi *\/\n+  {HB_TAG('p','o','h',' '),     HB_TAG('M','Y','N',' ')},       \/* Poqomchi' -> Mayan *\/\n+\/*{HB_TAG('p','o','n',' '),     HB_TAG('P','O','N',' ')},*\/     \/* Pohnpeian *\/\n+  {HB_TAG('p','o','v',' '),     HB_TAG('C','P','P',' ')},       \/* Upper Guinea Crioulo -> Creoles *\/\n+  {HB_TAG('p','p','a',' '),     HB_TAG('B','A','G',' ')},       \/* Pao (retired code) -> Baghelkhandi *\/\n+  {HB_TAG('p','r','e',' '),     HB_TAG('C','P','P',' ')},       \/* Principense -> Creoles *\/\n+\/*{HB_TAG('p','r','o',' '),     HB_TAG('P','R','O',' ')},*\/     \/* Old Provenal (to 1500) -> Provenal \/ Old Provenal *\/\n+  {HB_TAG('p','r','s',' '),     HB_TAG('D','R','I',' ')},       \/* Dari *\/\n+  {HB_TAG('p','r','s',' '),     HB_TAG('F','A','R',' ')},       \/* Dari -> Persian *\/\n+  {HB_TAG('p','s','e',' '),     HB_TAG('M','L','Y',' ')},       \/* Central Malay -> Malay *\/\n+  {HB_TAG('p','s','t',' '),     HB_TAG('P','A','S',' ')},       \/* Central Pashto -> Pashto *\/\n+  {HB_TAG('p','u','b',' '),     HB_TAG('Q','I','N',' ')},       \/* Purum -> Chin *\/\n+  {HB_TAG('p','u','z',' '),     HB_TAG('Q','I','N',' ')},       \/* Purum Naga (retired code) -> Chin *\/\n+  {HB_TAG('p','w','o',' '),     HB_TAG('P','W','O',' ')},       \/* Pwo Western Karen -> Western Pwo Karen *\/\n+  {HB_TAG('p','w','o',' '),     HB_TAG('K','R','N',' ')},       \/* Pwo Western Karen -> Karen *\/\n+  {HB_TAG('p','w','w',' '),     HB_TAG('K','R','N',' ')},       \/* Pwo Northern Karen -> Karen *\/\n+  {HB_TAG('q','u','b',' '),     HB_TAG('Q','W','H',' ')},       \/* Huallaga Hunuco Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','u','b',' '),     HB_TAG('Q','U','Z',' ')},       \/* Huallaga Hunuco Quechua -> Quechua *\/\n+  {HB_TAG('q','u','c',' '),     HB_TAG('Q','U','C',' ')},       \/* Kiche *\/\n+  {HB_TAG('q','u','c',' '),     HB_TAG('M','Y','N',' ')},       \/* K'iche' -> Mayan *\/\n+  {HB_TAG('q','u','d',' '),     HB_TAG('Q','V','I',' ')},       \/* Caldern Highland Quichua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','u','d',' '),     HB_TAG('Q','U','Z',' ')},       \/* Caldern Highland Quichua -> Quechua *\/\n+  {HB_TAG('q','u','f',' '),     HB_TAG('Q','U','Z',' ')},       \/* Lambayeque Quechua -> Quechua *\/\n+  {HB_TAG('q','u','g',' '),     HB_TAG('Q','V','I',' ')},       \/* Chimborazo Highland Quichua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','u','g',' '),     HB_TAG('Q','U','Z',' ')},       \/* Chimborazo Highland Quichua -> Quechua *\/\n+  {HB_TAG('q','u','h',' '),     HB_TAG('Q','U','H',' ')},       \/* South Bolivian Quechua -> Quechua (Bolivia) *\/\n+  {HB_TAG('q','u','h',' '),     HB_TAG('Q','U','Z',' ')},       \/* South Bolivian Quechua -> Quechua *\/\n+  {HB_TAG('q','u','k',' '),     HB_TAG('Q','U','Z',' ')},       \/* Chachapoyas Quechua -> Quechua *\/\n+  {HB_TAG('q','u','l',' '),     HB_TAG('Q','U','H',' ')},       \/* North Bolivian Quechua -> Quechua (Bolivia) *\/\n+  {HB_TAG('q','u','l',' '),     HB_TAG('Q','U','Z',' ')},       \/* North Bolivian Quechua -> Quechua *\/\n+  {HB_TAG('q','u','m',' '),     HB_TAG('M','Y','N',' ')},       \/* Sipacapense -> Mayan *\/\n+  {HB_TAG('q','u','p',' '),     HB_TAG('Q','V','I',' ')},       \/* Southern Pastaza Quechua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','u','p',' '),     HB_TAG('Q','U','Z',' ')},       \/* Southern Pastaza Quechua -> Quechua *\/\n+  {HB_TAG('q','u','r',' '),     HB_TAG('Q','W','H',' ')},       \/* Yanahuanca Pasco Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','u','r',' '),     HB_TAG('Q','U','Z',' ')},       \/* Yanahuanca Pasco Quechua -> Quechua *\/\n+  {HB_TAG('q','u','s',' '),     HB_TAG('Q','U','H',' ')},       \/* Santiago del Estero Quichua -> Quechua (Bolivia) *\/\n+  {HB_TAG('q','u','s',' '),     HB_TAG('Q','U','Z',' ')},       \/* Santiago del Estero Quichua -> Quechua *\/\n+  {HB_TAG('q','u','v',' '),     HB_TAG('M','Y','N',' ')},       \/* Sacapulteco -> Mayan *\/\n+  {HB_TAG('q','u','w',' '),     HB_TAG('Q','V','I',' ')},       \/* Tena Lowland Quichua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','u','w',' '),     HB_TAG('Q','U','Z',' ')},       \/* Tena Lowland Quichua -> Quechua *\/\n+  {HB_TAG('q','u','x',' '),     HB_TAG('Q','W','H',' ')},       \/* Yauyos Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','u','x',' '),     HB_TAG('Q','U','Z',' ')},       \/* Yauyos Quechua -> Quechua *\/\n+  {HB_TAG('q','u','y',' '),     HB_TAG('Q','U','Z',' ')},       \/* Ayacucho Quechua -> Quechua *\/\n+\/*{HB_TAG('q','u','z',' '),     HB_TAG('Q','U','Z',' ')},*\/     \/* Cusco Quechua -> Quechua *\/\n+  {HB_TAG('q','v','a',' '),     HB_TAG('Q','W','H',' ')},       \/* Ambo-Pasco Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','v','a',' '),     HB_TAG('Q','U','Z',' ')},       \/* Ambo-Pasco Quechua -> Quechua *\/\n+  {HB_TAG('q','v','c',' '),     HB_TAG('Q','U','Z',' ')},       \/* Cajamarca Quechua -> Quechua *\/\n+  {HB_TAG('q','v','e',' '),     HB_TAG('Q','U','Z',' ')},       \/* Eastern Apurmac Quechua -> Quechua *\/\n+  {HB_TAG('q','v','h',' '),     HB_TAG('Q','W','H',' ')},       \/* Huamales-Dos de Mayo Hunuco Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','v','h',' '),     HB_TAG('Q','U','Z',' ')},       \/* Huamales-Dos de Mayo Hunuco Quechua -> Quechua *\/\n+  {HB_TAG('q','v','i',' '),     HB_TAG('Q','V','I',' ')},       \/* Imbabura Highland Quichua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','v','i',' '),     HB_TAG('Q','U','Z',' ')},       \/* Imbabura Highland Quichua -> Quechua *\/\n+  {HB_TAG('q','v','j',' '),     HB_TAG('Q','V','I',' ')},       \/* Loja Highland Quichua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','v','j',' '),     HB_TAG('Q','U','Z',' ')},       \/* Loja Highland Quichua -> Quechua *\/\n+  {HB_TAG('q','v','l',' '),     HB_TAG('Q','W','H',' ')},       \/* Cajatambo North Lima Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','v','l',' '),     HB_TAG('Q','U','Z',' ')},       \/* Cajatambo North Lima Quechua -> Quechua *\/\n+  {HB_TAG('q','v','m',' '),     HB_TAG('Q','W','H',' ')},       \/* Margos-Yarowilca-Lauricocha Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','v','m',' '),     HB_TAG('Q','U','Z',' ')},       \/* Margos-Yarowilca-Lauricocha Quechua -> Quechua *\/\n+  {HB_TAG('q','v','n',' '),     HB_TAG('Q','W','H',' ')},       \/* North Junn Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','v','n',' '),     HB_TAG('Q','U','Z',' ')},       \/* North Junn Quechua -> Quechua *\/\n+  {HB_TAG('q','v','o',' '),     HB_TAG('Q','V','I',' ')},       \/* Napo Lowland Quechua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','v','o',' '),     HB_TAG('Q','U','Z',' ')},       \/* Napo Lowland Quechua -> Quechua *\/\n+  {HB_TAG('q','v','p',' '),     HB_TAG('Q','W','H',' ')},       \/* Pacaraos Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','v','p',' '),     HB_TAG('Q','U','Z',' ')},       \/* Pacaraos Quechua -> Quechua *\/\n+  {HB_TAG('q','v','s',' '),     HB_TAG('Q','U','Z',' ')},       \/* San Martn Quechua -> Quechua *\/\n+  {HB_TAG('q','v','w',' '),     HB_TAG('Q','W','H',' ')},       \/* Huaylla Wanca Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','v','w',' '),     HB_TAG('Q','U','Z',' ')},       \/* Huaylla Wanca Quechua -> Quechua *\/\n+  {HB_TAG('q','v','z',' '),     HB_TAG('Q','V','I',' ')},       \/* Northern Pastaza Quichua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','v','z',' '),     HB_TAG('Q','U','Z',' ')},       \/* Northern Pastaza Quichua -> Quechua *\/\n+  {HB_TAG('q','w','a',' '),     HB_TAG('Q','W','H',' ')},       \/* Corongo Ancash Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','w','a',' '),     HB_TAG('Q','U','Z',' ')},       \/* Corongo Ancash Quechua -> Quechua *\/\n+  {HB_TAG('q','w','c',' '),     HB_TAG('Q','U','Z',' ')},       \/* Classical Quechua -> Quechua *\/\n+  {HB_TAG('q','w','h',' '),     HB_TAG('Q','W','H',' ')},       \/* Huaylas Ancash Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','w','h',' '),     HB_TAG('Q','U','Z',' ')},       \/* Huaylas Ancash Quechua -> Quechua *\/\n+  {HB_TAG('q','w','s',' '),     HB_TAG('Q','W','H',' ')},       \/* Sihuas Ancash Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','w','s',' '),     HB_TAG('Q','U','Z',' ')},       \/* Sihuas Ancash Quechua -> Quechua *\/\n+  {HB_TAG('q','w','t',' '),     HB_TAG('A','T','H',' ')},       \/* Kwalhioqua-Tlatskanai -> Athapaskan *\/\n+  {HB_TAG('q','x','a',' '),     HB_TAG('Q','W','H',' ')},       \/* Chiquin Ancash Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','x','a',' '),     HB_TAG('Q','U','Z',' ')},       \/* Chiquin Ancash Quechua -> Quechua *\/\n+  {HB_TAG('q','x','c',' '),     HB_TAG('Q','W','H',' ')},       \/* Chincha Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','x','c',' '),     HB_TAG('Q','U','Z',' ')},       \/* Chincha Quechua -> Quechua *\/\n+  {HB_TAG('q','x','h',' '),     HB_TAG('Q','W','H',' ')},       \/* Panao Hunuco Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','x','h',' '),     HB_TAG('Q','U','Z',' ')},       \/* Panao Hunuco Quechua -> Quechua *\/\n+  {HB_TAG('q','x','l',' '),     HB_TAG('Q','V','I',' ')},       \/* Salasaca Highland Quichua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','x','l',' '),     HB_TAG('Q','U','Z',' ')},       \/* Salasaca Highland Quichua -> Quechua *\/\n+  {HB_TAG('q','x','n',' '),     HB_TAG('Q','W','H',' ')},       \/* Northern Conchucos Ancash Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','x','n',' '),     HB_TAG('Q','U','Z',' ')},       \/* Northern Conchucos Ancash Quechua -> Quechua *\/\n+  {HB_TAG('q','x','o',' '),     HB_TAG('Q','W','H',' ')},       \/* Southern Conchucos Ancash Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','x','o',' '),     HB_TAG('Q','U','Z',' ')},       \/* Southern Conchucos Ancash Quechua -> Quechua *\/\n+  {HB_TAG('q','x','p',' '),     HB_TAG('Q','U','Z',' ')},       \/* Puno Quechua -> Quechua *\/\n+  {HB_TAG('q','x','r',' '),     HB_TAG('Q','V','I',' ')},       \/* Caar Highland Quichua -> Quechua (Ecuador) *\/\n+  {HB_TAG('q','x','r',' '),     HB_TAG('Q','U','Z',' ')},       \/* Caar Highland Quichua -> Quechua *\/\n+  {HB_TAG('q','x','t',' '),     HB_TAG('Q','W','H',' ')},       \/* Santa Ana de Tusi Pasco Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','x','t',' '),     HB_TAG('Q','U','Z',' ')},       \/* Santa Ana de Tusi Pasco Quechua -> Quechua *\/\n+  {HB_TAG('q','x','u',' '),     HB_TAG('Q','U','Z',' ')},       \/* Arequipa-La Unin Quechua -> Quechua *\/\n+  {HB_TAG('q','x','w',' '),     HB_TAG('Q','W','H',' ')},       \/* Jauja Wanca Quechua -> Quechua (Peru) *\/\n+  {HB_TAG('q','x','w',' '),     HB_TAG('Q','U','Z',' ')},       \/* Jauja Wanca Quechua -> Quechua *\/\n+  {HB_TAG('r','a','g',' '),     HB_TAG('L','U','H',' ')},       \/* Logooli -> Luyia *\/\n+\/*{HB_TAG('r','a','j',' '),     HB_TAG('R','A','J',' ')},*\/     \/* Rajasthani [macrolanguage] *\/\n+  {HB_TAG('r','a','l',' '),     HB_TAG('Q','I','N',' ')},       \/* Ralte -> Chin *\/\n+\/*{HB_TAG('r','a','r',' '),     HB_TAG('R','A','R',' ')},*\/     \/* Rarotongan *\/\n+  {HB_TAG('r','b','b',' '),     HB_TAG('P','L','G',' ')},       \/* Rumai Palaung -> Palaung *\/\n+  {HB_TAG('r','b','l',' '),     HB_TAG('B','I','K',' ')},       \/* Miraya Bikol -> Bikol *\/\n+  {HB_TAG('r','c','f',' '),     HB_TAG('C','P','P',' ')},       \/* Runion Creole French -> Creoles *\/\n+\/*{HB_TAG('r','e','j',' '),     HB_TAG('R','E','J',' ')},*\/     \/* Rejang *\/\n+\/*{HB_TAG('r','h','g',' '),     HB_TAG('R','H','G',' ')},*\/     \/* Rohingya *\/\n+\/*{HB_TAG('r','i','a',' '),     HB_TAG('R','I','A',' ')},*\/     \/* Riang (India) *\/\n+  {HB_TAG('r','i','f',' '),     HB_TAG('R','I','F',' ')},       \/* Tarifit *\/\n+  {HB_TAG('r','i','f',' '),     HB_TAG('B','B','R',' ')},       \/* Tarifit -> Berber *\/\n+\/*{HB_TAG('r','i','t',' '),     HB_TAG('R','I','T',' ')},*\/     \/* Ritharrngu -> Ritarungo *\/\n+  {HB_TAG('r','k','i',' '),     HB_TAG('A','R','K',' ')},       \/* Rakhine *\/\n+\/*{HB_TAG('r','k','w',' '),     HB_TAG('R','K','W',' ')},*\/     \/* Arakwal *\/\n+  {HB_TAG('r','m','c',' '),     HB_TAG('R','O','Y',' ')},       \/* Carpathian Romani -> Romany *\/\n+  {HB_TAG('r','m','f',' '),     HB_TAG('R','O','Y',' ')},       \/* Kalo Finnish Romani -> Romany *\/\n+  {HB_TAG('r','m','l',' '),     HB_TAG('R','O','Y',' ')},       \/* Baltic Romani -> Romany *\/\n+  {HB_TAG('r','m','n',' '),     HB_TAG('R','O','Y',' ')},       \/* Balkan Romani -> Romany *\/\n+  {HB_TAG('r','m','o',' '),     HB_TAG('R','O','Y',' ')},       \/* Sinte Romani -> Romany *\/\n+  {HB_TAG('r','m','s',' '),     HB_TAG_NONE            },       \/* Romanian Sign Language != Romansh *\/\n+  {HB_TAG('r','m','w',' '),     HB_TAG('R','O','Y',' ')},       \/* Welsh Romani -> Romany *\/\n+  {HB_TAG('r','m','y',' '),     HB_TAG('R','M','Y',' ')},       \/* Vlax Romani *\/\n+  {HB_TAG('r','m','y',' '),     HB_TAG('R','O','Y',' ')},       \/* Vlax Romani -> Romany *\/\n+  {HB_TAG('r','m','z',' '),     HB_TAG('A','R','K',' ')},       \/* Marma -> Rakhine *\/\n+  {HB_TAG('r','o','m',' '),     HB_TAG('R','O','Y',' ')},       \/* Romany [macrolanguage] *\/\n+  {HB_TAG('r','o','p',' '),     HB_TAG('C','P','P',' ')},       \/* Kriol -> Creoles *\/\n+  {HB_TAG('r','t','c',' '),     HB_TAG('Q','I','N',' ')},       \/* Rungtu Chin -> Chin *\/\n+\/*{HB_TAG('r','t','m',' '),     HB_TAG('R','T','M',' ')},*\/     \/* Rotuman *\/\n+  {HB_TAG('r','u','e',' '),     HB_TAG('R','S','Y',' ')},       \/* Rusyn *\/\n+\/*{HB_TAG('r','u','p',' '),     HB_TAG('R','U','P',' ')},*\/     \/* Aromanian *\/\n+  {HB_TAG('r','w','r',' '),     HB_TAG('M','A','W',' ')},       \/* Marwari (India) *\/\n+  {HB_TAG('s','a','d',' '),     HB_TAG_NONE            },       \/* Sandawe != Sadri *\/\n+  {HB_TAG('s','a','h',' '),     HB_TAG('Y','A','K',' ')},       \/* Yakut -> Sakha *\/\n+  {HB_TAG('s','a','m',' '),     HB_TAG('P','A','A',' ')},       \/* Samaritan Aramaic -> Palestinian Aramaic *\/\n+\/*{HB_TAG('s','a','s',' '),     HB_TAG('S','A','S',' ')},*\/     \/* Sasak *\/\n+\/*{HB_TAG('s','a','t',' '),     HB_TAG('S','A','T',' ')},*\/     \/* Santali *\/\n+  {HB_TAG('s','a','y',' '),     HB_TAG_NONE            },       \/* Saya != Sayisi *\/\n+  {HB_TAG('s','c','f',' '),     HB_TAG('C','P','P',' ')},       \/* San Miguel Creole French -> Creoles *\/\n+  {HB_TAG('s','c','h',' '),     HB_TAG('Q','I','N',' ')},       \/* Sakachep -> Chin *\/\n+  {HB_TAG('s','c','i',' '),     HB_TAG('C','P','P',' ')},       \/* Sri Lankan Creole Malay -> Creoles *\/\n+  {HB_TAG('s','c','k',' '),     HB_TAG('S','A','D',' ')},       \/* Sadri *\/\n+\/*{HB_TAG('s','c','n',' '),     HB_TAG('S','C','N',' ')},*\/     \/* Sicilian *\/\n+\/*{HB_TAG('s','c','o',' '),     HB_TAG('S','C','O',' ')},*\/     \/* Scots *\/\n+  {HB_TAG('s','c','s',' '),     HB_TAG('S','C','S',' ')},       \/* North Slavey *\/\n+  {HB_TAG('s','c','s',' '),     HB_TAG('S','L','A',' ')},       \/* North Slavey -> Slavey *\/\n+  {HB_TAG('s','c','s',' '),     HB_TAG('A','T','H',' ')},       \/* North Slavey -> Athapaskan *\/\n+  {HB_TAG('s','d','c',' '),     HB_TAG('S','R','D',' ')},       \/* Sassarese Sardinian -> Sardinian *\/\n+  {HB_TAG('s','d','h',' '),     HB_TAG('K','U','R',' ')},       \/* Southern Kurdish -> Kurdish *\/\n+  {HB_TAG('s','d','n',' '),     HB_TAG('S','R','D',' ')},       \/* Gallurese Sardinian -> Sardinian *\/\n+  {HB_TAG('s','d','s',' '),     HB_TAG('B','B','R',' ')},       \/* Sened -> Berber *\/\n+  {HB_TAG('s','e','h',' '),     HB_TAG('S','N','A',' ')},       \/* Sena *\/\n+  {HB_TAG('s','e','k',' '),     HB_TAG('A','T','H',' ')},       \/* Sekani -> Athapaskan *\/\n+\/*{HB_TAG('s','e','l',' '),     HB_TAG('S','E','L',' ')},*\/     \/* Selkup *\/\n+  {HB_TAG('s','e','z',' '),     HB_TAG('Q','I','N',' ')},       \/* Senthang Chin -> Chin *\/\n+  {HB_TAG('s','f','m',' '),     HB_TAG('S','F','M',' ')},       \/* Small Flowery Miao *\/\n+  {HB_TAG('s','f','m',' '),     HB_TAG('H','M','N',' ')},       \/* Small Flowery Miao -> Hmong *\/\n+\/*{HB_TAG('s','g','a',' '),     HB_TAG('S','G','A',' ')},*\/     \/* Old Irish (to 900) *\/\n+  {HB_TAG('s','g','c',' '),     HB_TAG('K','A','L',' ')},       \/* Kipsigis -> Kalenjin *\/\n+  {HB_TAG('s','g','o',' '),     HB_TAG_NONE            },       \/* Songa (retired code) != Sango *\/\n+\/*{HB_TAG('s','g','s',' '),     HB_TAG('S','G','S',' ')},*\/     \/* Samogitian *\/\n+  {HB_TAG('s','g','w',' '),     HB_TAG('C','H','G',' ')},       \/* Sebat Bet Gurage -> Chaha Gurage *\/\n+  {HB_TAG('s','h','i',' '),     HB_TAG('S','H','I',' ')},       \/* Tachelhit *\/\n+  {HB_TAG('s','h','i',' '),     HB_TAG('B','B','R',' ')},       \/* Tachelhit -> Berber *\/\n+  {HB_TAG('s','h','l',' '),     HB_TAG('Q','I','N',' ')},       \/* Shendu -> Chin *\/\n+\/*{HB_TAG('s','h','n',' '),     HB_TAG('S','H','N',' ')},*\/     \/* Shan *\/\n+  {HB_TAG('s','h','u',' '),     HB_TAG('A','R','A',' ')},       \/* Chadian Arabic -> Arabic *\/\n+  {HB_TAG('s','h','y',' '),     HB_TAG('B','B','R',' ')},       \/* Tachawit -> Berber *\/\n+  {HB_TAG('s','i','b',' '),     HB_TAG_NONE            },       \/* Sebop != Sibe *\/\n+\/*{HB_TAG('s','i','d',' '),     HB_TAG('S','I','D',' ')},*\/     \/* Sidamo *\/\n+  {HB_TAG('s','i','g',' '),     HB_TAG_NONE            },       \/* Paasaal != Silte Gurage *\/\n+  {HB_TAG('s','i','z',' '),     HB_TAG('B','B','R',' ')},       \/* Siwi -> Berber *\/\n+  {HB_TAG('s','j','d',' '),     HB_TAG('K','S','M',' ')},       \/* Kildin Sami *\/\n+  {HB_TAG('s','j','o',' '),     HB_TAG('S','I','B',' ')},       \/* Xibe -> Sibe *\/\n+  {HB_TAG('s','j','s',' '),     HB_TAG('B','B','R',' ')},       \/* Senhaja De Srair -> Berber *\/\n+  {HB_TAG('s','k','g',' '),     HB_TAG('M','L','G',' ')},       \/* Sakalava Malagasy -> Malagasy *\/\n+  {HB_TAG('s','k','r',' '),     HB_TAG('S','R','K',' ')},       \/* Saraiki *\/\n+  {HB_TAG('s','k','s',' '),     HB_TAG_NONE            },       \/* Maia != Skolt Sami *\/\n+  {HB_TAG('s','k','w',' '),     HB_TAG('C','P','P',' ')},       \/* Skepi Creole Dutch -> Creoles *\/\n+  {HB_TAG('s','k','y',' '),     HB_TAG_NONE            },       \/* Sikaiana != Slovak *\/\n+  {HB_TAG('s','l','a',' '),     HB_TAG_NONE            },       \/* Slavic [collection] != Slavey *\/\n+  {HB_TAG('s','m','a',' '),     HB_TAG('S','S','M',' ')},       \/* Southern Sami *\/\n+  {HB_TAG('s','m','d',' '),     HB_TAG('M','B','N',' ')},       \/* Sama (retired code) -> Mbundu *\/\n+  {HB_TAG('s','m','j',' '),     HB_TAG('L','S','M',' ')},       \/* Lule Sami *\/\n+  {HB_TAG('s','m','l',' '),     HB_TAG_NONE            },       \/* Central Sama != Somali *\/\n+  {HB_TAG('s','m','n',' '),     HB_TAG('I','S','M',' ')},       \/* Inari Sami *\/\n+  {HB_TAG('s','m','s',' '),     HB_TAG('S','K','S',' ')},       \/* Skolt Sami *\/\n+  {HB_TAG('s','m','t',' '),     HB_TAG('Q','I','N',' ')},       \/* Simte -> Chin *\/\n+  {HB_TAG('s','n','b',' '),     HB_TAG('I','B','A',' ')},       \/* Sebuyau (retired code) -> Iban *\/\n+  {HB_TAG('s','n','h',' '),     HB_TAG_NONE            },       \/* Shinabo (retired code) != Sinhala (Sinhalese) *\/\n+\/*{HB_TAG('s','n','k',' '),     HB_TAG('S','N','K',' ')},*\/     \/* Soninke *\/\n+  {HB_TAG('s','o','g',' '),     HB_TAG_NONE            },       \/* Sogdian != Sodo Gurage *\/\n+\/*{HB_TAG('s','o','p',' '),     HB_TAG('S','O','P',' ')},*\/     \/* Songe *\/\n+  {HB_TAG('s','p','v',' '),     HB_TAG('O','R','I',' ')},       \/* Sambalpuri -> Odia (formerly Oriya) *\/\n+  {HB_TAG('s','p','y',' '),     HB_TAG('K','A','L',' ')},       \/* Sabaot -> Kalenjin *\/\n+  {HB_TAG('s','r','b',' '),     HB_TAG_NONE            },       \/* Sora != Serbian *\/\n+  {HB_TAG('s','r','c',' '),     HB_TAG('S','R','D',' ')},       \/* Logudorese Sardinian -> Sardinian *\/\n+  {HB_TAG('s','r','k',' '),     HB_TAG_NONE            },       \/* Serudung Murut != Saraiki *\/\n+  {HB_TAG('s','r','m',' '),     HB_TAG('C','P','P',' ')},       \/* Saramaccan -> Creoles *\/\n+  {HB_TAG('s','r','n',' '),     HB_TAG('C','P','P',' ')},       \/* Sranan Tongo -> Creoles *\/\n+  {HB_TAG('s','r','o',' '),     HB_TAG('S','R','D',' ')},       \/* Campidanese Sardinian -> Sardinian *\/\n+\/*{HB_TAG('s','r','r',' '),     HB_TAG('S','R','R',' ')},*\/     \/* Serer *\/\n+  {HB_TAG('s','r','s',' '),     HB_TAG('A','T','H',' ')},       \/* Sarsi -> Athapaskan *\/\n+  {HB_TAG('s','s','h',' '),     HB_TAG('A','R','A',' ')},       \/* Shihhi Arabic -> Arabic *\/\n+  {HB_TAG('s','s','l',' '),     HB_TAG_NONE            },       \/* Western Sisaala != South Slavey *\/\n+  {HB_TAG('s','s','m',' '),     HB_TAG_NONE            },       \/* Semnam != Southern Sami *\/\n+  {HB_TAG('s','t','a',' '),     HB_TAG('C','P','P',' ')},       \/* Settla -> Creoles *\/\n+\/*{HB_TAG('s','t','q',' '),     HB_TAG('S','T','Q',' ')},*\/     \/* Saterfriesisch -> Saterland Frisian *\/\n+  {HB_TAG('s','t','v',' '),     HB_TAG('S','I','G',' ')},       \/* Silt'e -> Silte Gurage *\/\n+\/*{HB_TAG('s','u','k',' '),     HB_TAG('S','U','K',' ')},*\/     \/* Sukuma *\/\n+  {HB_TAG('s','u','q',' '),     HB_TAG('S','U','R',' ')},       \/* Suri *\/\n+  {HB_TAG('s','u','r',' '),     HB_TAG_NONE            },       \/* Mwaghavul != Suri *\/\n+\/*{HB_TAG('s','v','a',' '),     HB_TAG('S','V','A',' ')},*\/     \/* Svan *\/\n+  {HB_TAG('s','v','c',' '),     HB_TAG('C','P','P',' ')},       \/* Vincentian Creole English -> Creoles *\/\n+  {HB_TAG('s','v','e',' '),     HB_TAG_NONE            },       \/* Serili != Swedish *\/\n+  {HB_TAG('s','w','b',' '),     HB_TAG('C','M','R',' ')},       \/* Maore Comorian -> Comorian *\/\n+  {HB_TAG('s','w','c',' '),     HB_TAG('S','W','K',' ')},       \/* Congo Swahili -> Swahili *\/\n+  {HB_TAG('s','w','h',' '),     HB_TAG('S','W','K',' ')},       \/* Swahili *\/\n+  {HB_TAG('s','w','k',' '),     HB_TAG_NONE            },       \/* Malawi Sena != Swahili *\/\n+  {HB_TAG('s','w','n',' '),     HB_TAG('B','B','R',' ')},       \/* Sawknah -> Berber *\/\n+  {HB_TAG('s','w','v',' '),     HB_TAG('M','A','W',' ')},       \/* Shekhawati -> Marwari *\/\n+\/*{HB_TAG('s','x','u',' '),     HB_TAG('S','X','U',' ')},*\/     \/* Upper Saxon *\/\n+  {HB_TAG('s','y','c',' '),     HB_TAG('S','Y','R',' ')},       \/* Classical Syriac -> Syriac *\/\n+\/*{HB_TAG('s','y','l',' '),     HB_TAG('S','Y','L',' ')},*\/     \/* Sylheti *\/\n+\/*{HB_TAG('s','y','r',' '),     HB_TAG('S','Y','R',' ')},*\/     \/* Syriac [macrolanguage] *\/\n+\/*{HB_TAG('s','z','l',' '),     HB_TAG('S','Z','L',' ')},*\/     \/* Silesian *\/\n+  {HB_TAG('t','a','a',' '),     HB_TAG('A','T','H',' ')},       \/* Lower Tanana -> Athapaskan *\/\n+\/*{HB_TAG('t','a','b',' '),     HB_TAG('T','A','B',' ')},*\/     \/* Tabassaran -> Tabasaran *\/\n+  {HB_TAG('t','a','j',' '),     HB_TAG_NONE            },       \/* Eastern Tamang != Tajiki *\/\n+  {HB_TAG('t','a','q',' '),     HB_TAG('T','M','H',' ')},       \/* Tamasheq -> Tamashek *\/\n+  {HB_TAG('t','a','q',' '),     HB_TAG('B','B','R',' ')},       \/* Tamasheq -> Berber *\/\n+  {HB_TAG('t','a','s',' '),     HB_TAG('C','P','P',' ')},       \/* Tay Boi -> Creoles *\/\n+  {HB_TAG('t','a','u',' '),     HB_TAG('A','T','H',' ')},       \/* Upper Tanana -> Athapaskan *\/\n+  {HB_TAG('t','c','b',' '),     HB_TAG('A','T','H',' ')},       \/* Tanacross -> Athapaskan *\/\n+  {HB_TAG('t','c','e',' '),     HB_TAG('A','T','H',' ')},       \/* Southern Tutchone -> Athapaskan *\/\n+  {HB_TAG('t','c','h',' '),     HB_TAG('C','P','P',' ')},       \/* Turks And Caicos Creole English -> Creoles *\/\n+  {HB_TAG('t','c','p',' '),     HB_TAG('Q','I','N',' ')},       \/* Tawr Chin -> Chin *\/\n+  {HB_TAG('t','c','s',' '),     HB_TAG('C','P','P',' ')},       \/* Torres Strait Creole -> Creoles *\/\n+  {HB_TAG('t','c','y',' '),     HB_TAG('T','U','L',' ')},       \/* Tulu -> Tumbuka *\/\n+  {HB_TAG('t','c','z',' '),     HB_TAG('Q','I','N',' ')},       \/* Thado Chin -> Chin *\/\n+\/*{HB_TAG('t','d','d',' '),     HB_TAG('T','D','D',' ')},*\/     \/* Tai Na -> Dehong Dai *\/\n+  {HB_TAG('t','d','x',' '),     HB_TAG('M','L','G',' ')},       \/* Tandroy-Mahafaly Malagasy -> Malagasy *\/\n+  {HB_TAG('t','e','c',' '),     HB_TAG('K','A','L',' ')},       \/* Terik -> Kalenjin *\/\n+  {HB_TAG('t','e','m',' '),     HB_TAG('T','M','N',' ')},       \/* Timne -> Temne *\/\n+\/*{HB_TAG('t','e','t',' '),     HB_TAG('T','E','T',' ')},*\/     \/* Tetum *\/\n+  {HB_TAG('t','e','z',' '),     HB_TAG('B','B','R',' ')},       \/* Tetserret -> Berber *\/\n+  {HB_TAG('t','f','n',' '),     HB_TAG('A','T','H',' ')},       \/* Tanaina -> Athapaskan *\/\n+  {HB_TAG('t','g','h',' '),     HB_TAG('C','P','P',' ')},       \/* Tobagonian Creole English -> Creoles *\/\n+  {HB_TAG('t','g','j',' '),     HB_TAG('N','I','S',' ')},       \/* Tagin -> Nisi *\/\n+  {HB_TAG('t','g','n',' '),     HB_TAG_NONE            },       \/* Tandaganon != Tongan *\/\n+  {HB_TAG('t','g','r',' '),     HB_TAG_NONE            },       \/* Tareng != Tigre *\/\n+  {HB_TAG('t','g','x',' '),     HB_TAG('A','T','H',' ')},       \/* Tagish -> Athapaskan *\/\n+  {HB_TAG('t','g','y',' '),     HB_TAG_NONE            },       \/* Togoyo != Tigrinya *\/\n+  {HB_TAG('t','h','t',' '),     HB_TAG('A','T','H',' ')},       \/* Tahltan -> Athapaskan *\/\n+  {HB_TAG('t','h','v',' '),     HB_TAG('T','M','H',' ')},       \/* Tahaggart Tamahaq -> Tamashek *\/\n+  {HB_TAG('t','h','v',' '),     HB_TAG('B','B','R',' ')},       \/* Tahaggart Tamahaq -> Berber *\/\n+  {HB_TAG('t','h','z',' '),     HB_TAG('T','M','H',' ')},       \/* Tayart Tamajeq -> Tamashek *\/\n+  {HB_TAG('t','h','z',' '),     HB_TAG('B','B','R',' ')},       \/* Tayart Tamajeq -> Berber *\/\n+  {HB_TAG('t','i','a',' '),     HB_TAG('B','B','R',' ')},       \/* Tidikelt Tamazight -> Berber *\/\n+  {HB_TAG('t','i','g',' '),     HB_TAG('T','G','R',' ')},       \/* Tigre *\/\n+\/*{HB_TAG('t','i','v',' '),     HB_TAG('T','I','V',' ')},*\/     \/* Tiv *\/\n+\/*{HB_TAG('t','j','l',' '),     HB_TAG('T','J','L',' ')},*\/     \/* Tai Laing *\/\n+  {HB_TAG('t','j','o',' '),     HB_TAG('B','B','R',' ')},       \/* Temacine Tamazight -> Berber *\/\n+  {HB_TAG('t','k','g',' '),     HB_TAG('M','L','G',' ')},       \/* Tesaka Malagasy -> Malagasy *\/\n+  {HB_TAG('t','k','m',' '),     HB_TAG_NONE            },       \/* Takelma != Turkmen *\/\n+\/*{HB_TAG('t','l','i',' '),     HB_TAG('T','L','I',' ')},*\/     \/* Tlingit *\/\n+  {HB_TAG('t','m','g',' '),     HB_TAG('C','P','P',' ')},       \/* Ternateo -> Creoles *\/\n+  {HB_TAG('t','m','h',' '),     HB_TAG('T','M','H',' ')},       \/* Tamashek [macrolanguage] *\/\n+  {HB_TAG('t','m','h',' '),     HB_TAG('B','B','R',' ')},       \/* Tamashek [macrolanguage] -> Berber *\/\n+  {HB_TAG('t','m','n',' '),     HB_TAG_NONE            },       \/* Taman (Indonesia) != Temne *\/\n+  {HB_TAG('t','m','w',' '),     HB_TAG('M','L','Y',' ')},       \/* Temuan -> Malay *\/\n+  {HB_TAG('t','n','a',' '),     HB_TAG_NONE            },       \/* Tacana != Tswana *\/\n+  {HB_TAG('t','n','e',' '),     HB_TAG_NONE            },       \/* Tinoc Kallahan (retired code) != Tundra Enets *\/\n+  {HB_TAG('t','n','f',' '),     HB_TAG('D','R','I',' ')},       \/* Tangshewi (retired code) -> Dari *\/\n+  {HB_TAG('t','n','f',' '),     HB_TAG('F','A','R',' ')},       \/* Tangshewi (retired code) -> Persian *\/\n+  {HB_TAG('t','n','g',' '),     HB_TAG_NONE            },       \/* Tobanga != Tonga *\/\n+  {HB_TAG('t','o','d',' '),     HB_TAG('T','O','D','0')},       \/* Toma *\/\n+  {HB_TAG('t','o','i',' '),     HB_TAG('T','N','G',' ')},       \/* Tonga (Zambia) *\/\n+  {HB_TAG('t','o','j',' '),     HB_TAG('M','Y','N',' ')},       \/* Tojolabal -> Mayan *\/\n+  {HB_TAG('t','o','l',' '),     HB_TAG('A','T','H',' ')},       \/* Tolowa -> Athapaskan *\/\n+  {HB_TAG('t','o','r',' '),     HB_TAG('B','A','D','0')},       \/* Togbo-Vara Banda -> Banda *\/\n+  {HB_TAG('t','p','i',' '),     HB_TAG('T','P','I',' ')},       \/* Tok Pisin *\/\n+  {HB_TAG('t','p','i',' '),     HB_TAG('C','P','P',' ')},       \/* Tok Pisin -> Creoles *\/\n+  {HB_TAG('t','r','f',' '),     HB_TAG('C','P','P',' ')},       \/* Trinidadian Creole English -> Creoles *\/\n+  {HB_TAG('t','r','k',' '),     HB_TAG_NONE            },       \/* Turkic [collection] != Turkish *\/\n+  {HB_TAG('t','r','u',' '),     HB_TAG('T','U','A',' ')},       \/* Turoyo -> Turoyo Aramaic *\/\n+  {HB_TAG('t','r','u',' '),     HB_TAG('S','Y','R',' ')},       \/* Turoyo -> Syriac *\/\n+  {HB_TAG('t','s','g',' '),     HB_TAG_NONE            },       \/* Tausug != Tsonga *\/\n+\/*{HB_TAG('t','s','j',' '),     HB_TAG('T','S','J',' ')},*\/     \/* Tshangla *\/\n+  {HB_TAG('t','t','c',' '),     HB_TAG('M','Y','N',' ')},       \/* Tektiteko -> Mayan *\/\n+  {HB_TAG('t','t','m',' '),     HB_TAG('A','T','H',' ')},       \/* Northern Tutchone -> Athapaskan *\/\n+  {HB_TAG('t','t','q',' '),     HB_TAG('T','M','H',' ')},       \/* Tawallammat Tamajaq -> Tamashek *\/\n+  {HB_TAG('t','t','q',' '),     HB_TAG('B','B','R',' ')},       \/* Tawallammat Tamajaq -> Berber *\/\n+  {HB_TAG('t','u','a',' '),     HB_TAG_NONE            },       \/* Wiarumus != Turoyo Aramaic *\/\n+  {HB_TAG('t','u','l',' '),     HB_TAG_NONE            },       \/* Tula != Tumbuka *\/\n+\/*{HB_TAG('t','u','m',' '),     HB_TAG('T','U','M',' ')},*\/     \/* Tumbuka -> Tulu *\/\n+  {HB_TAG('t','u','u',' '),     HB_TAG('A','T','H',' ')},       \/* Tututni -> Athapaskan *\/\n+  {HB_TAG('t','u','v',' '),     HB_TAG_NONE            },       \/* Turkana != Tuvin *\/\n+  {HB_TAG('t','u','y',' '),     HB_TAG('K','A','L',' ')},       \/* Tugen -> Kalenjin *\/\n+\/*{HB_TAG('t','v','l',' '),     HB_TAG('T','V','L',' ')},*\/     \/* Tuvalu *\/\n+  {HB_TAG('t','v','y',' '),     HB_TAG('C','P','P',' ')},       \/* Timor Pidgin -> Creoles *\/\n+  {HB_TAG('t','x','c',' '),     HB_TAG('A','T','H',' ')},       \/* Tsetsaut -> Athapaskan *\/\n+  {HB_TAG('t','x','y',' '),     HB_TAG('M','L','G',' ')},       \/* Tanosy Malagasy -> Malagasy *\/\n+  {HB_TAG('t','y','v',' '),     HB_TAG('T','U','V',' ')},       \/* Tuvinian -> Tuvin *\/\n+\/*{HB_TAG('t','y','z',' '),     HB_TAG('T','Y','Z',' ')},*\/     \/* Ty *\/\n+  {HB_TAG('t','z','h',' '),     HB_TAG('M','Y','N',' ')},       \/* Tzeltal -> Mayan *\/\n+  {HB_TAG('t','z','j',' '),     HB_TAG('M','Y','N',' ')},       \/* Tz'utujil -> Mayan *\/\n+  {HB_TAG('t','z','m',' '),     HB_TAG('T','Z','M',' ')},       \/* Central Atlas Tamazight -> Tamazight *\/\n+  {HB_TAG('t','z','m',' '),     HB_TAG('B','B','R',' ')},       \/* Central Atlas Tamazight -> Berber *\/\n+  {HB_TAG('t','z','o',' '),     HB_TAG('T','Z','O',' ')},       \/* Tzotzil *\/\n+  {HB_TAG('t','z','o',' '),     HB_TAG('M','Y','N',' ')},       \/* Tzotzil -> Mayan *\/\n+  {HB_TAG('u','b','l',' '),     HB_TAG('B','I','K',' ')},       \/* Buhi'non Bikol -> Bikol *\/\n+\/*{HB_TAG('u','d','m',' '),     HB_TAG('U','D','M',' ')},*\/     \/* Udmurt *\/\n+  {HB_TAG('u','k','i',' '),     HB_TAG('K','U','I',' ')},       \/* Kui (India) *\/\n+  {HB_TAG('u','l','n',' '),     HB_TAG('C','P','P',' ')},       \/* Unserdeutsch -> Creoles *\/\n+\/*{HB_TAG('u','m','b',' '),     HB_TAG('U','M','B',' ')},*\/     \/* Umbundu *\/\n+  {HB_TAG('u','n','r',' '),     HB_TAG('M','U','N',' ')},       \/* Mundari *\/\n+  {HB_TAG('u','r','k',' '),     HB_TAG('M','L','Y',' ')},       \/* Urak Lawoi' -> Malay *\/\n+  {HB_TAG('u','s','p',' '),     HB_TAG('M','Y','N',' ')},       \/* Uspanteco -> Mayan *\/\n+  {HB_TAG('u','z','n',' '),     HB_TAG('U','Z','B',' ')},       \/* Northern Uzbek -> Uzbek *\/\n+  {HB_TAG('u','z','s',' '),     HB_TAG('U','Z','B',' ')},       \/* Southern Uzbek -> Uzbek *\/\n+  {HB_TAG('v','a','p',' '),     HB_TAG('Q','I','N',' ')},       \/* Vaiphei -> Chin *\/\n+\/*{HB_TAG('v','e','c',' '),     HB_TAG('V','E','C',' ')},*\/     \/* Venetian *\/\n+  {HB_TAG('v','i','c',' '),     HB_TAG('C','P','P',' ')},       \/* Virgin Islands Creole English -> Creoles *\/\n+  {HB_TAG('v','i','t',' '),     HB_TAG_NONE            },       \/* Viti != Vietnamese *\/\n+  {HB_TAG('v','k','k',' '),     HB_TAG('M','L','Y',' ')},       \/* Kaur -> Malay *\/\n+  {HB_TAG('v','k','p',' '),     HB_TAG('C','P','P',' ')},       \/* Korlai Creole Portuguese -> Creoles *\/\n+  {HB_TAG('v','k','t',' '),     HB_TAG('M','L','Y',' ')},       \/* Tenggarong Kutai Malay -> Malay *\/\n+  {HB_TAG('v','l','s',' '),     HB_TAG('F','L','E',' ')},       \/* Vlaams -> Dutch (Flemish) *\/\n+  {HB_TAG('v','m','w',' '),     HB_TAG('M','A','K',' ')},       \/* Makhuwa *\/\n+\/*{HB_TAG('v','r','o',' '),     HB_TAG('V','R','O',' ')},*\/     \/* Vro *\/\n+  {HB_TAG('w','a','g',' '),     HB_TAG_NONE            },       \/* Wa'ema != Wagdi *\/\n+\/*{HB_TAG('w','a','r',' '),     HB_TAG('W','A','R',' ')},*\/     \/* Waray (Philippines) -> Waray-Waray *\/\n+  {HB_TAG('w','b','m',' '),     HB_TAG('W','A',' ',' ')},       \/* Wa *\/\n+  {HB_TAG('w','b','r',' '),     HB_TAG('W','A','G',' ')},       \/* Wagdi *\/\n+  {HB_TAG('w','b','r',' '),     HB_TAG('R','A','J',' ')},       \/* Wagdi -> Rajasthani *\/\n+\/*{HB_TAG('w','c','i',' '),     HB_TAG('W','C','I',' ')},*\/     \/* Waci Gbe *\/\n+  {HB_TAG('w','e','a',' '),     HB_TAG('K','R','N',' ')},       \/* Wewaw -> Karen *\/\n+  {HB_TAG('w','e','s',' '),     HB_TAG('C','P','P',' ')},       \/* Cameroon Pidgin -> Creoles *\/\n+  {HB_TAG('w','e','u',' '),     HB_TAG('Q','I','N',' ')},       \/* Rawngtu Chin -> Chin *\/\n+  {HB_TAG('w','l','c',' '),     HB_TAG('C','M','R',' ')},       \/* Mwali Comorian -> Comorian *\/\n+  {HB_TAG('w','l','e',' '),     HB_TAG('S','I','G',' ')},       \/* Wolane -> Silte Gurage *\/\n+  {HB_TAG('w','l','k',' '),     HB_TAG('A','T','H',' ')},       \/* Wailaki -> Athapaskan *\/\n+  {HB_TAG('w','n','i',' '),     HB_TAG('C','M','R',' ')},       \/* Ndzwani Comorian -> Comorian *\/\n+  {HB_TAG('w','r','y',' '),     HB_TAG('M','A','W',' ')},       \/* Merwari -> Marwari *\/\n+  {HB_TAG('w','s','g',' '),     HB_TAG('G','O','N',' ')},       \/* Adilabad Gondi -> Gondi *\/\n+\/*{HB_TAG('w','t','m',' '),     HB_TAG('W','T','M',' ')},*\/     \/* Mewati *\/\n+  {HB_TAG('w','u','u',' '),     HB_TAG('Z','H','S',' ')},       \/* Wu Chinese -> Chinese, Simplified *\/\n+  {HB_TAG('x','a','l',' '),     HB_TAG('K','L','M',' ')},       \/* Kalmyk *\/\n+  {HB_TAG('x','a','l',' '),     HB_TAG('T','O','D',' ')},       \/* Kalmyk -> Todo *\/\n+  {HB_TAG('x','a','n',' '),     HB_TAG('S','E','K',' ')},       \/* Xamtanga -> Sekota *\/\n+  {HB_TAG('x','b','d',' '),     HB_TAG_NONE            },       \/* Bindal != L *\/\n+\/*{HB_TAG('x','j','b',' '),     HB_TAG('X','J','B',' ')},*\/     \/* Minjungbal -> Minjangbal *\/\n+\/*{HB_TAG('x','k','f',' '),     HB_TAG('X','K','F',' ')},*\/     \/* Khengkha *\/\n+  {HB_TAG('x','m','g',' '),     HB_TAG('B','M','L',' ')},       \/* Mengaka -> Bamileke *\/\n+  {HB_TAG('x','m','m',' '),     HB_TAG('M','L','Y',' ')},       \/* Manado Malay -> Malay *\/\n+  {HB_TAG('x','m','m',' '),     HB_TAG('C','P','P',' ')},       \/* Manado Malay -> Creoles *\/\n+  {HB_TAG('x','m','v',' '),     HB_TAG('M','L','G',' ')},       \/* Antankarana Malagasy -> Malagasy *\/\n+  {HB_TAG('x','m','w',' '),     HB_TAG('M','L','G',' ')},       \/* Tsimihety Malagasy -> Malagasy *\/\n+  {HB_TAG('x','n','j',' '),     HB_TAG('S','X','T',' ')},       \/* Ngoni (Tanzania) -> Sutu *\/\n+  {HB_TAG('x','n','q',' '),     HB_TAG('S','X','T',' ')},       \/* Ngoni (Mozambique) -> Sutu *\/\n+  {HB_TAG('x','n','r',' '),     HB_TAG('D','G','R',' ')},       \/* Kangri -> Dogri (macrolanguage) *\/\n+\/*{HB_TAG('x','o','g',' '),     HB_TAG('X','O','G',' ')},*\/     \/* Soga *\/\n+  {HB_TAG('x','p','e',' '),     HB_TAG('X','P','E',' ')},       \/* Liberia Kpelle -> Kpelle (Liberia) *\/\n+  {HB_TAG('x','p','e',' '),     HB_TAG('K','P','L',' ')},       \/* Liberia Kpelle -> Kpelle *\/\n+  {HB_TAG('x','s','l',' '),     HB_TAG('S','S','L',' ')},       \/* South Slavey *\/\n+  {HB_TAG('x','s','l',' '),     HB_TAG('S','L','A',' ')},       \/* South Slavey -> Slavey *\/\n+  {HB_TAG('x','s','l',' '),     HB_TAG('A','T','H',' ')},       \/* South Slavey -> Athapaskan *\/\n+  {HB_TAG('x','s','t',' '),     HB_TAG('S','I','G',' ')},       \/* Silt'e (retired code) -> Silte Gurage *\/\n+\/*{HB_TAG('x','u','b',' '),     HB_TAG('X','U','B',' ')},*\/     \/* Betta Kurumba -> Bette Kuruma *\/\n+\/*{HB_TAG('x','u','j',' '),     HB_TAG('X','U','J',' ')},*\/     \/* Jennu Kurumba -> Jennu Kuruma *\/\n+  {HB_TAG('x','u','p',' '),     HB_TAG('A','T','H',' ')},       \/* Upper Umpqua -> Athapaskan *\/\n+  {HB_TAG('x','w','o',' '),     HB_TAG('T','O','D',' ')},       \/* Written Oirat -> Todo *\/\n+  {HB_TAG('y','a','j',' '),     HB_TAG('B','A','D','0')},       \/* Banda-Yangere -> Banda *\/\n+  {HB_TAG('y','a','k',' '),     HB_TAG_NONE            },       \/* Yakama != Sakha *\/\n+\/*{HB_TAG('y','a','o',' '),     HB_TAG('Y','A','O',' ')},*\/     \/* Yao *\/\n+\/*{HB_TAG('y','a','p',' '),     HB_TAG('Y','A','P',' ')},*\/     \/* Yapese *\/\n+  {HB_TAG('y','b','a',' '),     HB_TAG_NONE            },       \/* Yala != Yoruba *\/\n+  {HB_TAG('y','b','b',' '),     HB_TAG('B','M','L',' ')},       \/* Yemba -> Bamileke *\/\n+  {HB_TAG('y','b','d',' '),     HB_TAG('A','R','K',' ')},       \/* Yangbye (retired code) -> Rakhine *\/\n+  {HB_TAG('y','d','d',' '),     HB_TAG('J','I','I',' ')},       \/* Eastern Yiddish -> Yiddish *\/\n+\/*{HB_TAG('y','g','p',' '),     HB_TAG('Y','G','P',' ')},*\/     \/* Gepo *\/\n+  {HB_TAG('y','i','h',' '),     HB_TAG('J','I','I',' ')},       \/* Western Yiddish -> Yiddish *\/\n+  {HB_TAG('y','i','m',' '),     HB_TAG_NONE            },       \/* Yimchungru Naga != Yi Modern *\/\n+\/*{HB_TAG('y','n','a',' '),     HB_TAG('Y','N','A',' ')},*\/     \/* Aluo *\/\n+  {HB_TAG('y','o','s',' '),     HB_TAG('Q','I','N',' ')},       \/* Yos (retired code) -> Chin *\/\n+  {HB_TAG('y','u','a',' '),     HB_TAG('M','Y','N',' ')},       \/* Yucateco -> Mayan *\/\n+  {HB_TAG('y','u','e',' '),     HB_TAG('Z','H','H',' ')},       \/* Yue Chinese -> Chinese, Traditional, Hong Kong SAR *\/\n+\/*{HB_TAG('y','w','q',' '),     HB_TAG('Y','W','Q',' ')},*\/     \/* Wuding-Luquan Yi *\/\n+  {HB_TAG('z','c','h',' '),     HB_TAG('Z','H','A',' ')},       \/* Central Hongshuihe Zhuang -> Zhuang *\/\n+  {HB_TAG('z','d','j',' '),     HB_TAG('C','M','R',' ')},       \/* Ngazidja Comorian -> Comorian *\/\n+\/*{HB_TAG('z','e','a',' '),     HB_TAG('Z','E','A',' ')},*\/     \/* Zeeuws -> Zealandic *\/\n+  {HB_TAG('z','e','h',' '),     HB_TAG('Z','H','A',' ')},       \/* Eastern Hongshuihe Zhuang -> Zhuang *\/\n+  {HB_TAG('z','e','n',' '),     HB_TAG('B','B','R',' ')},       \/* Zenaga -> Berber *\/\n+  {HB_TAG('z','g','b',' '),     HB_TAG('Z','H','A',' ')},       \/* Guibei Zhuang -> Zhuang *\/\n+  {HB_TAG('z','g','h',' '),     HB_TAG('Z','G','H',' ')},       \/* Standard Moroccan Tamazight *\/\n+  {HB_TAG('z','g','h',' '),     HB_TAG('B','B','R',' ')},       \/* Standard Moroccan Tamazight -> Berber *\/\n+  {HB_TAG('z','g','m',' '),     HB_TAG('Z','H','A',' ')},       \/* Minz Zhuang -> Zhuang *\/\n+  {HB_TAG('z','g','n',' '),     HB_TAG('Z','H','A',' ')},       \/* Guibian Zhuang -> Zhuang *\/\n+  {HB_TAG('z','h','d',' '),     HB_TAG('Z','H','A',' ')},       \/* Dai Zhuang -> Zhuang *\/\n+  {HB_TAG('z','h','n',' '),     HB_TAG('Z','H','A',' ')},       \/* Nong Zhuang -> Zhuang *\/\n+  {HB_TAG('z','l','j',' '),     HB_TAG('Z','H','A',' ')},       \/* Liujiang Zhuang -> Zhuang *\/\n+  {HB_TAG('z','l','m',' '),     HB_TAG('M','L','Y',' ')},       \/* Malay *\/\n+  {HB_TAG('z','l','n',' '),     HB_TAG('Z','H','A',' ')},       \/* Lianshan Zhuang -> Zhuang *\/\n+  {HB_TAG('z','l','q',' '),     HB_TAG('Z','H','A',' ')},       \/* Liuqian Zhuang -> Zhuang *\/\n+  {HB_TAG('z','m','i',' '),     HB_TAG('M','L','Y',' ')},       \/* Negeri Sembilan Malay -> Malay *\/\n+  {HB_TAG('z','m','z',' '),     HB_TAG('B','A','D','0')},       \/* Mbandja -> Banda *\/\n+  {HB_TAG('z','n','d',' '),     HB_TAG_NONE            },       \/* Zande [collection] != Zande *\/\n+  {HB_TAG('z','n','e',' '),     HB_TAG('Z','N','D',' ')},       \/* Zande *\/\n+  {HB_TAG('z','o','m',' '),     HB_TAG('Q','I','N',' ')},       \/* Zou -> Chin *\/\n+  {HB_TAG('z','q','e',' '),     HB_TAG('Z','H','A',' ')},       \/* Qiubei Zhuang -> Zhuang *\/\n+  {HB_TAG('z','s','m',' '),     HB_TAG('M','L','Y',' ')},       \/* Standard Malay -> Malay *\/\n+  {HB_TAG('z','u','m',' '),     HB_TAG('L','R','C',' ')},       \/* Kumzari -> Luri *\/\n+  {HB_TAG('z','y','b',' '),     HB_TAG('Z','H','A',' ')},       \/* Yongbei Zhuang -> Zhuang *\/\n+  {HB_TAG('z','y','g',' '),     HB_TAG('Z','H','A',' ')},       \/* Yang Zhuang -> Zhuang *\/\n+  {HB_TAG('z','y','j',' '),     HB_TAG('Z','H','A',' ')},       \/* Youjiang Zhuang -> Zhuang *\/\n+  {HB_TAG('z','y','n',' '),     HB_TAG('Z','H','A',' ')},       \/* Yongnan Zhuang -> Zhuang *\/\n+  {HB_TAG('z','y','p',' '),     HB_TAG('Q','I','N',' ')},       \/* Zyphe Chin -> Chin *\/\n+\/*{HB_TAG('z','z','a',' '),     HB_TAG('Z','Z','A',' ')},*\/     \/* Zazaki [macrolanguage] *\/\n+  {HB_TAG('z','z','j',' '),     HB_TAG('Z','H','A',' ')},       \/* Zuojiang Zhuang -> Zhuang *\/\n+};\n+#endif\n+\n@@ -1603,1 +1641,1 @@\n-static bool\n+static inline bool\n@@ -1609,57 +1647,1 @@\n-  if (subtag_matches (lang_str, limit, \"-fonnapa\"))\n-  {\n-    \/* Undetermined; North American Phonetic Alphabet *\/\n-    tags[0] = HB_TAG('A','P','P','H');  \/* Phonetic transcriptionAmericanist conventions *\/\n-    *count = 1;\n-    return true;\n-  }\n-  if (subtag_matches (lang_str, limit, \"-polyton\"))\n-  {\n-    \/* Modern Greek (1453-); Polytonic Greek *\/\n-    tags[0] = HB_TAG('P','G','R',' ');  \/* Polytonic Greek *\/\n-    *count = 1;\n-    return true;\n-  }\n-  if (subtag_matches (lang_str, limit, \"-arevmda\"))\n-  {\n-    \/* Armenian; Western Armenian (retired code) *\/\n-    tags[0] = HB_TAG('H','Y','E',' ');  \/* Armenian *\/\n-    *count = 1;\n-    return true;\n-  }\n-  if (subtag_matches (lang_str, limit, \"-provenc\"))\n-  {\n-    \/* Occitan (post 1500); Provenal *\/\n-    tags[0] = HB_TAG('P','R','O',' ');  \/* Provenal \/ Old Provenal *\/\n-    *count = 1;\n-    return true;\n-  }\n-  if (subtag_matches (lang_str, limit, \"-fonipa\"))\n-  {\n-    \/* Undetermined; International Phonetic Alphabet *\/\n-    tags[0] = HB_TAG('I','P','P','H');  \/* Phonetic transcriptionIPA conventions *\/\n-    *count = 1;\n-    return true;\n-  }\n-  if (subtag_matches (lang_str, limit, \"-geok\"))\n-  {\n-    \/* Undetermined; Khutsuri (Asomtavruli and Nuskhuri) *\/\n-    tags[0] = HB_TAG('K','G','E',' ');  \/* Khutsuri Georgian *\/\n-    *count = 1;\n-    return true;\n-  }\n-  if (subtag_matches (lang_str, limit, \"-syre\"))\n-  {\n-    \/* Undetermined; Syriac (Estrangelo variant) *\/\n-    tags[0] = HB_TAG('S','Y','R','E');  \/* Syriac, Estrangela script-variant (equivalent to ISO 15924 'Syre') *\/\n-    *count = 1;\n-    return true;\n-  }\n-  if (subtag_matches (lang_str, limit, \"-syrj\"))\n-  {\n-    \/* Undetermined; Syriac (Western variant) *\/\n-    tags[0] = HB_TAG('S','Y','R','J');  \/* Syriac, Western script-variant (equivalent to ISO 15924 'Syrj') *\/\n-    *count = 1;\n-    return true;\n-  }\n-  if (subtag_matches (lang_str, limit, \"-syrn\"))\n+  if (limit - lang_str >= 7)\n@@ -1667,4 +1649,65 @@\n-    \/* Undetermined; Syriac (Eastern variant) *\/\n-    tags[0] = HB_TAG('S','Y','R','N');  \/* Syriac, Eastern script-variant (equivalent to ISO 15924 'Syrn') *\/\n-    *count = 1;\n-    return true;\n+    const char *p = strchr (lang_str, '-');\n+    if (!p || p >= limit || limit - p < 5) goto out;\n+    if (subtag_matches (p, limit, \"-fonnapa\", 8))\n+    {\n+      \/* Undetermined; North American Phonetic Alphabet *\/\n+      tags[0] = HB_TAG('A','P','P','H');  \/* Phonetic transcriptionAmericanist conventions *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (subtag_matches (p, limit, \"-polyton\", 8))\n+    {\n+      \/* Modern Greek (1453-); Polytonic Greek *\/\n+      tags[0] = HB_TAG('P','G','R',' ');  \/* Polytonic Greek *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (subtag_matches (p, limit, \"-arevmda\", 8))\n+    {\n+      \/* Armenian; Western Armenian (retired code) *\/\n+      tags[0] = HB_TAG('H','Y','E',' ');  \/* Armenian *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (subtag_matches (p, limit, \"-provenc\", 8))\n+    {\n+      \/* Occitan (post 1500); Provenal *\/\n+      tags[0] = HB_TAG('P','R','O',' ');  \/* Provenal \/ Old Provenal *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (subtag_matches (p, limit, \"-fonipa\", 7))\n+    {\n+      \/* Undetermined; International Phonetic Alphabet *\/\n+      tags[0] = HB_TAG('I','P','P','H');  \/* Phonetic transcriptionIPA conventions *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (subtag_matches (p, limit, \"-geok\", 5))\n+    {\n+      \/* Undetermined; Khutsuri (Asomtavruli and Nuskhuri) *\/\n+      tags[0] = HB_TAG('K','G','E',' ');  \/* Khutsuri Georgian *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (subtag_matches (p, limit, \"-syre\", 5))\n+    {\n+      \/* Undetermined; Syriac (Estrangelo variant) *\/\n+      tags[0] = HB_TAG('S','Y','R','E');  \/* Syriac, Estrangela script-variant (equivalent to ISO 15924 'Syre') *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (subtag_matches (p, limit, \"-syrj\", 5))\n+    {\n+      \/* Undetermined; Syriac (Western variant) *\/\n+      tags[0] = HB_TAG('S','Y','R','J');  \/* Syriac, Western script-variant (equivalent to ISO 15924 'Syrj') *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (subtag_matches (p, limit, \"-syrn\", 5))\n+    {\n+      \/* Undetermined; Syriac (Eastern variant) *\/\n+      tags[0] = HB_TAG('S','Y','R','N');  \/* Syriac, Eastern script-variant (equivalent to ISO 15924 'Syrn') *\/\n+      *count = 1;\n+      return true;\n+    }\n@@ -1672,0 +1715,1 @@\n+out:\n@@ -1684,1 +1728,1 @@\n-    if (lang_matches (&lang_str[1], \"do-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"do-hant-hk\", 10))\n@@ -1691,1 +1735,1 @@\n-    if (lang_matches (&lang_str[1], \"do-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"do-hant-mo\", 10))\n@@ -1704,1 +1748,1 @@\n-    if (lang_matches (&lang_str[1], \"jy-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"jy-hant-hk\", 10))\n@@ -1711,1 +1755,1 @@\n-    if (lang_matches (&lang_str[1], \"jy-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"jy-hant-mo\", 10))\n@@ -1724,1 +1768,1 @@\n-    if (lang_matches (&lang_str[1], \"mn-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"mn-hant-hk\", 10))\n@@ -1731,1 +1775,1 @@\n-    if (lang_matches (&lang_str[1], \"mn-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"mn-hant-mo\", 10))\n@@ -1744,1 +1788,1 @@\n-    if (lang_matches (&lang_str[1], \"np-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"np-hant-hk\", 10))\n@@ -1751,1 +1795,1 @@\n-    if (lang_matches (&lang_str[1], \"np-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"np-hant-mo\", 10))\n@@ -1764,1 +1808,1 @@\n-    if (lang_matches (&lang_str[1], \"px-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"px-hant-hk\", 10))\n@@ -1771,1 +1815,1 @@\n-    if (lang_matches (&lang_str[1], \"px-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"px-hant-mo\", 10))\n@@ -1784,1 +1828,1 @@\n-    if (lang_matches (&lang_str[1], \"sp-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"sp-hant-hk\", 10))\n@@ -1791,1 +1835,1 @@\n-    if (lang_matches (&lang_str[1], \"sp-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"sp-hant-mo\", 10))\n@@ -1804,1 +1848,1 @@\n-    if (lang_matches (&lang_str[1], \"zh-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"zh-hant-hk\", 10))\n@@ -1811,1 +1855,1 @@\n-    if (lang_matches (&lang_str[1], \"zh-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"zh-hant-mo\", 10))\n@@ -1824,1 +1868,1 @@\n-    if (lang_matches (&lang_str[1], \"zo-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"zo-hant-hk\", 10))\n@@ -1831,1 +1875,1 @@\n-    if (lang_matches (&lang_str[1], \"zo-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"zo-hant-mo\", 10))\n@@ -1844,1 +1888,1 @@\n-    if (lang_matches (&lang_str[1], \"do-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"do-hans\", 7))\n@@ -1851,1 +1895,1 @@\n-    if (lang_matches (&lang_str[1], \"do-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"do-hant\", 7))\n@@ -1858,1 +1902,1 @@\n-    if (lang_matches (&lang_str[1], \"jy-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"jy-hans\", 7))\n@@ -1865,1 +1909,1 @@\n-    if (lang_matches (&lang_str[1], \"jy-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"jy-hant\", 7))\n@@ -1872,1 +1916,1 @@\n-    if (lang_matches (&lang_str[1], \"mn-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"mn-hans\", 7))\n@@ -1879,1 +1923,1 @@\n-    if (lang_matches (&lang_str[1], \"mn-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"mn-hant\", 7))\n@@ -1886,1 +1930,1 @@\n-    if (lang_matches (&lang_str[1], \"np-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"np-hans\", 7))\n@@ -1893,1 +1937,1 @@\n-    if (lang_matches (&lang_str[1], \"np-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"np-hant\", 7))\n@@ -1900,1 +1944,1 @@\n-    if (lang_matches (&lang_str[1], \"px-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"px-hans\", 7))\n@@ -1907,1 +1951,1 @@\n-    if (lang_matches (&lang_str[1], \"px-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"px-hant\", 7))\n@@ -1914,1 +1958,1 @@\n-    if (lang_matches (&lang_str[1], \"sp-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"sp-hans\", 7))\n@@ -1921,1 +1965,1 @@\n-    if (lang_matches (&lang_str[1], \"sp-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"sp-hant\", 7))\n@@ -1928,1 +1972,1 @@\n-    if (lang_matches (&lang_str[1], \"zh-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"zh-hans\", 7))\n@@ -1935,1 +1979,1 @@\n-    if (lang_matches (&lang_str[1], \"zh-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"zh-hant\", 7))\n@@ -1942,1 +1986,1 @@\n-    if (lang_matches (&lang_str[1], \"zo-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"zo-hans\", 7))\n@@ -1949,1 +1993,1 @@\n-    if (lang_matches (&lang_str[1], \"zo-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"zo-hant\", 7))\n@@ -1957,1 +2001,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -1965,1 +2009,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -1979,1 +2023,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -1987,1 +2031,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -1995,1 +2039,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2009,1 +2053,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2017,1 +2061,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2025,1 +2069,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2039,1 +2083,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2047,1 +2091,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2055,1 +2099,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2069,1 +2113,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2077,1 +2121,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2085,1 +2129,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2099,1 +2143,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2107,1 +2151,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2115,1 +2159,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2129,1 +2173,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2137,1 +2181,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2145,1 +2189,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2159,1 +2203,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2167,1 +2211,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2175,1 +2219,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2189,1 +2233,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2198,1 +2242,1 @@\n-    if (lang_matches (&lang_str[1], \"an-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"an-hant-hk\", 10))\n@@ -2205,1 +2249,1 @@\n-    if (lang_matches (&lang_str[1], \"an-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"an-hant-mo\", 10))\n@@ -2218,1 +2262,1 @@\n-    if (lang_matches (&lang_str[1], \"an-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"an-hans\", 7))\n@@ -2225,1 +2269,1 @@\n-    if (lang_matches (&lang_str[1], \"an-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"an-hant\", 7))\n@@ -2232,1 +2276,1 @@\n-    if (lang_matches (&lang_str[1], \"a-latg\"))\n+    if (lang_matches (&lang_str[1], limit, \"a-latg\", 6))\n@@ -2240,1 +2284,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2248,1 +2292,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2262,1 +2306,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2271,1 +2315,1 @@\n-    if (lang_matches (&lang_str[1], \"ak-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"ak-hant-hk\", 10))\n@@ -2278,1 +2322,1 @@\n-    if (lang_matches (&lang_str[1], \"ak-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"ak-hant-mo\", 10))\n@@ -2291,1 +2335,1 @@\n-    if (lang_matches (&lang_str[1], \"sn-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"sn-hant-hk\", 10))\n@@ -2298,1 +2342,1 @@\n-    if (lang_matches (&lang_str[1], \"sn-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"sn-hant-mo\", 10))\n@@ -2311,1 +2355,1 @@\n-    if (lang_matches (&lang_str[1], \"ak-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"ak-hans\", 7))\n@@ -2318,1 +2362,1 @@\n-    if (lang_matches (&lang_str[1], \"ak-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"ak-hant\", 7))\n@@ -2325,1 +2369,1 @@\n-    if (lang_matches (&lang_str[1], \"sn-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"sn-hans\", 7))\n@@ -2332,1 +2376,1 @@\n-    if (lang_matches (&lang_str[1], \"sn-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"sn-hant\", 7))\n@@ -2340,1 +2384,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2348,1 +2392,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2362,1 +2406,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2370,1 +2414,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2378,1 +2422,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2392,1 +2436,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2430,1 +2474,1 @@\n-    if (lang_matches (&lang_str[1], \"zh-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"zh-hans\", 7))\n@@ -2439,1 +2483,1 @@\n-    if (lang_matches (&lang_str[1], \"np-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"np-hant-hk\", 10))\n@@ -2446,1 +2490,1 @@\n-    if (lang_matches (&lang_str[1], \"np-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"np-hant-mo\", 10))\n@@ -2459,1 +2503,1 @@\n-    if (lang_matches (&lang_str[1], \"np-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"np-hans\", 7))\n@@ -2466,1 +2510,1 @@\n-    if (lang_matches (&lang_str[1], \"np-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"np-hant\", 7))\n@@ -2474,1 +2518,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2482,1 +2526,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2496,1 +2540,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2503,0 +2547,8 @@\n+    if (0 == strncmp (&lang_str[1], \"nw-\", 3)\n+        && subtag_matches (lang_str, limit, \"-th\", 3))\n+    {\n+      \/* Mon; Thailand *\/\n+      tags[0] = HB_TAG('M','O','N','T');  \/* Thailand Mon *\/\n+      *count = 1;\n+      return true;\n+    }\n@@ -2505,1 +2557,1 @@\n-    if (lang_matches (&lang_str[1], \"an-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"an-hant-hk\", 10))\n@@ -2512,1 +2564,1 @@\n-    if (lang_matches (&lang_str[1], \"an-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"an-hant-mo\", 10))\n@@ -2525,1 +2577,1 @@\n-    if (lang_matches (&lang_str[1], \"an-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"an-hans\", 7))\n@@ -2532,1 +2584,1 @@\n-    if (lang_matches (&lang_str[1], \"an-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"an-hant\", 7))\n@@ -2540,1 +2592,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2548,1 +2600,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2562,1 +2614,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2579,8 +2631,2 @@\n-      unsigned int i;\n-      hb_tag_t possible_tags[] = {\n-        HB_TAG('N','Y','N',' '),  \/* Norwegian Nynorsk (Nynorsk, Norwegian) *\/\n-        HB_TAG('N','O','R',' '),  \/* Norwegian *\/\n-      };\n-      for (i = 0; i < 2 && i < *count; i++)\n-        tags[i] = possible_tags[i];\n-      *count = i;\n+      tags[0] = HB_TAG('N','Y','N',' ');  \/* Norwegian Nynorsk (Nynorsk, Norwegian) *\/\n+      *count = 1;\n@@ -2592,1 +2638,1 @@\n-        && subtag_matches (lang_str, limit, \"-md\"))\n+        && subtag_matches (lang_str, limit, \"-md\", 3))\n@@ -2595,2 +2641,8 @@\n-      tags[0] = HB_TAG('M','O','L',' ');  \/* Moldavian *\/\n-      *count = 1;\n+      unsigned int i;\n+      hb_tag_t possible_tags[] = {\n+        HB_TAG('M','O','L',' '),  \/* Moldavian *\/\n+        HB_TAG('R','O','M',' '),  \/* Romanian *\/\n+      };\n+      for (i = 0; i < 2 && i < *count; i++)\n+        tags[i] = possible_tags[i];\n+      *count = i;\n@@ -2601,1 +2653,1 @@\n-    if (lang_matches (&lang_str[1], \"uu-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"uu-hant-hk\", 10))\n@@ -2608,1 +2660,1 @@\n-    if (lang_matches (&lang_str[1], \"uu-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"uu-hant-mo\", 10))\n@@ -2621,1 +2673,1 @@\n-    if (lang_matches (&lang_str[1], \"uu-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"uu-hans\", 7))\n@@ -2628,1 +2680,1 @@\n-    if (lang_matches (&lang_str[1], \"uu-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"uu-hant\", 7))\n@@ -2636,1 +2688,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2644,1 +2696,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2658,1 +2710,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2667,1 +2719,1 @@\n-    if (lang_matches (&lang_str[1], \"ue-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"ue-hans\", 7))\n@@ -2676,1 +2728,1 @@\n-    if (lang_matches (&lang_str[1], \"h-hant-hk\"))\n+    if (lang_matches (&lang_str[1], limit, \"h-hant-hk\", 9))\n@@ -2683,1 +2735,1 @@\n-    if (lang_matches (&lang_str[1], \"h-hant-mo\"))\n+    if (lang_matches (&lang_str[1], limit, \"h-hant-mo\", 9))\n@@ -2703,1 +2755,1 @@\n-    if (lang_matches (&lang_str[1], \"h-hans\"))\n+    if (lang_matches (&lang_str[1], limit, \"h-hans\", 6))\n@@ -2710,1 +2762,1 @@\n-    if (lang_matches (&lang_str[1], \"h-hant\"))\n+    if (lang_matches (&lang_str[1], limit, \"h-hant\", 6))\n@@ -2725,1 +2777,1 @@\n-        && subtag_matches (lang_str, limit, \"-hk\"))\n+        && subtag_matches (lang_str, limit, \"-hk\", 3))\n@@ -2733,1 +2785,1 @@\n-        && subtag_matches (lang_str, limit, \"-mo\"))\n+        && subtag_matches (lang_str, limit, \"-mo\", 3))\n@@ -2747,1 +2799,1 @@\n-        && subtag_matches (lang_str, limit, \"-tw\"))\n+        && subtag_matches (lang_str, limit, \"-tw\", 3))\n@@ -2771,1 +2823,1 @@\n-static hb_language_t\n+static inline hb_language_t\n@@ -2785,1 +2837,1 @@\n-    return hb_language_from_string (\"ath\", -1);  \/* Athapascan [family] *\/\n+    return hb_language_from_string (\"ath\", -1);  \/* Athapascan [collection] *\/\n@@ -2787,1 +2839,1 @@\n-    return hb_language_from_string (\"ber\", -1);  \/* Berber [family] *\/\n+    return hb_language_from_string (\"ber\", -1);  \/* Berber [collection] *\/\n@@ -2791,1 +2843,1 @@\n-    return hb_language_from_string (\"btk\", -1);  \/* Batak [family] *\/\n+    return hb_language_from_string (\"btk\", -1);  \/* Batak [collection] *\/\n@@ -2793,1 +2845,1 @@\n-    return hb_language_from_string (\"crp\", -1);  \/* Creoles and pidgins [family] *\/\n+    return hb_language_from_string (\"crp\", -1);  \/* Creoles and pidgins [collection] *\/\n@@ -2810,0 +2862,2 @@\n+  case HB_TAG('H','M','A',' '):  \/* High Mari *\/\n+    return hb_language_from_string (\"mrj\", -1);  \/* Western Mari *\/\n@@ -2819,1 +2873,1 @@\n-    return hb_language_from_string (\"ijo\", -1);  \/* Ijo [family] *\/\n+    return hb_language_from_string (\"ijo\", -1);  \/* Ijo [collection] *\/\n@@ -2845,1 +2899,1 @@\n-    return hb_language_from_string (\"kar\", -1);  \/* Karen [family] *\/\n+    return hb_language_from_string (\"kar\", -1);  \/* Karen [collection] *\/\n@@ -2850,0 +2904,2 @@\n+  case HB_TAG('L','M','A',' '):  \/* Low Mari *\/\n+    return hb_language_from_string (\"mhr\", -1);  \/* Eastern Mari *\/\n@@ -2866,0 +2922,2 @@\n+  case HB_TAG('M','O','N','T'):  \/* Thailand Mon *\/\n+    return hb_language_from_string (\"mnw-TH\", -1);  \/* Mon; Thailand *\/\n@@ -2867,1 +2925,1 @@\n-    return hb_language_from_string (\"myn\", -1);  \/* Mayan [family] *\/\n+    return hb_language_from_string (\"myn\", -1);  \/* Mayan [collection] *\/\n@@ -2869,1 +2927,1 @@\n-    return hb_language_from_string (\"nah\", -1);  \/* Nahuatl [family] *\/\n+    return hb_language_from_string (\"nah\", -1);  \/* Nahuatl [collection] *\/\n@@ -2896,0 +2954,2 @@\n+  case HB_TAG('R','O','M',' '):  \/* Romanian *\/\n+    return hb_language_from_string (\"ro\", -1);  \/* Romanian *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-tag-table.hh","additions":1823,"deletions":1763,"binary":false,"changes":3586,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    case HB_SCRIPT_MATH:                return HB_OT_TAG_MATH_SCRIPT;\n@@ -66,0 +67,2 @@\n+  if (unlikely (tag == HB_OT_TAG_MATH_SCRIPT))\n+    return HB_SCRIPT_MATH;\n@@ -189,1 +192,1 @@\n-static bool\n+static inline bool\n@@ -192,1 +195,2 @@\n-                const char *subtag)\n+                const char *subtag,\n+                unsigned    subtag_len)\n@@ -194,0 +198,3 @@\n+  if (likely ((unsigned) (limit - lang_str) < subtag_len))\n+    return false;\n+\n@@ -198,1 +205,1 @@\n-    if (!ISALNUM (s[strlen (subtag)]))\n+    if (!ISALNUM (s[subtag_len]))\n@@ -200,1 +207,1 @@\n-    lang_str = s + strlen (subtag);\n+    lang_str = s + subtag_len;\n@@ -204,2 +211,5 @@\n-static hb_bool_t\n-lang_matches (const char *lang_str, const char *spec)\n+static bool\n+lang_matches (const char *lang_str,\n+              const char *limit,\n+              const char *spec,\n+              unsigned    spec_len)\n@@ -207,1 +217,2 @@\n-  unsigned int len = strlen (spec);\n+  if (likely ((unsigned) (limit - lang_str) < spec_len))\n+    return false;\n@@ -209,2 +220,2 @@\n-  return strncmp (lang_str, spec, len) == 0 &&\n-         (lang_str[len] == '\\0' || lang_str[len] == '-');\n+  return strncmp (lang_str, spec, spec_len) == 0 &&\n+         (lang_str[spec_len] == '\\0' || lang_str[spec_len] == '-');\n@@ -215,1 +226,1 @@\n-  char language[4];\n+  hb_tag_t language;\n@@ -218,1 +229,1 @@\n-  int cmp (const char *a) const\n+  int cmp (hb_tag_t a) const\n@@ -220,11 +231,1 @@\n-    const char *b = this->language;\n-    unsigned int da, db;\n-    const char *p;\n-\n-    p = strchr (a, '-');\n-    da = p ? (unsigned int) (p - a) : strlen (a);\n-\n-    p = strchr (b, '-');\n-    db = p ? (unsigned int) (p - b) : strlen (b);\n-\n-    return strncmp (a, b, hb_max (da, db));\n+    return a < this->language ? -1 : a > this->language ? +1 : 0;\n@@ -265,2 +266,0 @@\n-  const char *s;\n-  unsigned int tag_idx;\n@@ -268,0 +267,1 @@\n+#ifndef HB_NO_LANGUAGE_LONG\n@@ -271,0 +271,1 @@\n+#endif\n@@ -273,1 +274,3 @@\n-  s = strchr (lang_str, '-');\n+#ifndef HB_NO_LANGUAGE_LONG\n+  const char *s; s = strchr (lang_str, '-');\n+#endif\n@@ -275,0 +278,1 @@\n+#ifndef HB_NO_LANGUAGE_LONG\n@@ -283,1 +287,12 @@\n-    if (hb_sorted_array (ot_languages).bfind (lang_str, &tag_idx))\n+#endif\n+    const LangTag *ot_languages = nullptr;\n+    unsigned ot_languages_len = 0;\n+    const char *dash = strchr (lang_str, '-');\n+    unsigned first_len = dash ? dash - lang_str : limit - lang_str;\n+    if (first_len == 2)\n+    {\n+      ot_languages = ot_languages2;\n+      ot_languages_len = ARRAY_LENGTH (ot_languages2);\n+    }\n+#ifndef HB_NO_LANGUAGE_LONG\n+    else if (first_len == 3)\n@@ -285,0 +300,14 @@\n+      ot_languages = ot_languages3;\n+      ot_languages_len = ARRAY_LENGTH (ot_languages3);\n+    }\n+#endif\n+\n+    hb_tag_t lang_tag = hb_tag_from_string (lang_str, first_len);\n+\n+    static hb_atomic_int_t last_tag_idx; \/* Poor man's cache. *\/\n+    unsigned tag_idx = last_tag_idx.get_relaxed ();\n+\n+    if (likely (tag_idx < ot_languages_len && ot_languages[tag_idx].language == lang_tag) ||\n+        hb_sorted_array (ot_languages, ot_languages_len).bfind (lang_tag, &tag_idx))\n+    {\n+      last_tag_idx.set_relaxed (tag_idx);\n@@ -287,1 +316,1 @@\n-             0 == strcmp (ot_languages[tag_idx].language, ot_languages[tag_idx - 1].language))\n+             ot_languages[tag_idx].language == ot_languages[tag_idx - 1].language)\n@@ -291,1 +320,1 @@\n-           tag_idx + i < ARRAY_LENGTH (ot_languages) &&\n+           tag_idx + i < ot_languages_len &&\n@@ -293,1 +322,1 @@\n-           0 == strcmp (ot_languages[tag_idx + i].language, ot_languages[tag_idx].language);\n+           ot_languages[tag_idx + i].language == ot_languages[tag_idx].language;\n@@ -301,0 +330,1 @@\n+#ifndef HB_NO_LANGUAGE_LONG\n@@ -309,0 +339,1 @@\n+#endif\n@@ -453,0 +484,1 @@\n+#ifndef HB_NO_LANGUAGE_LONG\n@@ -458,0 +490,1 @@\n+#endif\n@@ -459,3 +492,15 @@\n-  for (i = 0; i < ARRAY_LENGTH (ot_languages); i++)\n-    if (ot_languages[i].tag == tag)\n-      return hb_language_from_string (ot_languages[i].language, -1);\n+  char buf[4];\n+  for (i = 0; i < ARRAY_LENGTH (ot_languages2); i++)\n+    if (ot_languages2[i].tag == tag)\n+    {\n+      hb_tag_to_string (ot_languages2[i].language, buf);\n+      return hb_language_from_string (buf, 2);\n+    }\n+#ifndef HB_NO_LANGUAGE_LONG\n+  for (i = 0; i < ARRAY_LENGTH (ot_languages3); i++)\n+    if (ot_languages3[i].tag == tag)\n+    {\n+      hb_tag_to_string (ot_languages3[i].language, buf);\n+      return hb_language_from_string (buf, 3);\n+    }\n+#endif\n@@ -525,1 +570,1 @@\n-      buf = (unsigned char *) malloc (len + 16);\n+      buf = (unsigned char *) hb_malloc (len + 16);\n@@ -547,1 +592,1 @@\n-        free (buf);\n+        hb_free (buf);\n@@ -557,1 +602,1 @@\n-  for (unsigned int i = 1; i < ARRAY_LENGTH (ot_languages); i++)\n+  for (unsigned int i = 1; i < ARRAY_LENGTH (ot_languages2); i++)\n@@ -559,1 +604,1 @@\n-    int c = ot_languages[i].cmp (&ot_languages[i - 1]);\n+    int c = ot_languages2[i].cmp (&ot_languages2[i - 1]);\n@@ -562,2 +607,2 @@\n-      fprintf (stderr, \"ot_languages not sorted at index %d: %s %d %s\\n\",\n-               i, ot_languages[i-1].language, c, ot_languages[i].language);\n+      fprintf (stderr, \"ot_languages2 not sorted at index %d: %08x %d %08x\\n\",\n+               i, ot_languages2[i-1].language, c, ot_languages2[i].language);\n@@ -567,0 +612,12 @@\n+#ifndef HB_NO_LANGUAGE_LONG\n+  for (unsigned int i = 1; i < ARRAY_LENGTH (ot_languages3); i++)\n+  {\n+    int c = ot_languages3[i].cmp (&ot_languages3[i - 1]);\n+    if (c > 0)\n+    {\n+      fprintf (stderr, \"ot_languages3 not sorted at index %d: %08x %d %08x\\n\",\n+               i, ot_languages3[i-1].language, c, ot_languages3[i].language);\n+      abort();\n+    }\n+  }\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-tag.cc","additions":95,"deletions":38,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-struct SegmentMaps : ArrayOf<AxisValueMap>\n+struct SegmentMaps : Array16Of<AxisValueMap>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-avar-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright  2021  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ *\/\n+\n+#ifndef HB_OT_VAR_COMMON_HH\n+#define HB_OT_VAR_COMMON_HH\n+\n+#include \"hb-ot-layout-common.hh\"\n+\n+\n+namespace OT {\n+\n+struct DeltaSetIndexMapFormat0\n+{\n+  friend struct DeltaSetIndexMap;\n+\n+  private:\n+  DeltaSetIndexMapFormat0* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->start_embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+\n+    unsigned total_size = min_size + mapCount * get_width ();\n+    HBUINT8 *p = c->allocate_size<HBUINT8> (total_size);\n+    if (unlikely (!p)) return_trace (nullptr);\n+\n+    memcpy (p, this, HBUINT8::static_size * total_size);\n+    return_trace (out);\n+  }\n+\n+  template <typename T>\n+  bool serialize (hb_serialize_context_t *c, const T &plan)\n+  {\n+    unsigned int width = plan.get_width ();\n+    unsigned int inner_bit_count = plan.get_inner_bit_count ();\n+    const hb_array_t<const uint32_t> output_map = plan.get_output_map ();\n+\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (output_map.length && ((((inner_bit_count-1)&~0xF)!=0) || (((width-1)&~0x3)!=0))))\n+      return_trace (false);\n+    if (unlikely (!c->extend_min (this))) return_trace (false);\n+\n+    entryFormat = ((width-1)<<4)|(inner_bit_count-1);\n+    mapCount = output_map.length;\n+    HBUINT8 *p = c->allocate_size<HBUINT8> (width * output_map.length);\n+    if (unlikely (!p)) return_trace (false);\n+    for (unsigned int i = 0; i < output_map.length; i++)\n+    {\n+      unsigned int v = output_map[i];\n+      unsigned int outer = v >> 16;\n+      unsigned int inner = v & 0xFFFF;\n+      unsigned int u = (outer << inner_bit_count) | inner;\n+      for (unsigned int w = width; w > 0;)\n+      {\n+        p[--w] = u;\n+        u >>= 8;\n+      }\n+      p += width;\n+    }\n+    return_trace (true);\n+  }\n+\n+  uint32_t map (unsigned int v) const \/* Returns 16.16 outer.inner. *\/\n+  {\n+    \/* If count is zero, pass value unchanged.  This takes\n+     * care of direct mapping for advance map. *\/\n+    if (!mapCount)\n+      return v;\n+\n+    if (v >= mapCount)\n+      v = mapCount - 1;\n+\n+    unsigned int u = 0;\n+    { \/* Fetch it. *\/\n+      unsigned int w = get_width ();\n+      const HBUINT8 *p = mapDataZ.arrayZ + w * v;\n+      for (; w; w--)\n+        u = (u << 8) + *p++;\n+    }\n+\n+    { \/* Repack it. *\/\n+      unsigned int n = get_inner_bit_count ();\n+      unsigned int outer = u >> n;\n+      unsigned int inner = u & ((1 << n) - 1);\n+      u = (outer<<16) | inner;\n+    }\n+\n+    return u;\n+  }\n+\n+  unsigned get_map_count () const       { return mapCount; }\n+  unsigned get_width () const           { return ((entryFormat >> 4) & 3) + 1; }\n+  unsigned get_inner_bit_count () const { return (entryFormat & 0xF) + 1; }\n+\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  c->check_range (mapDataZ.arrayZ,\n+                                  mapCount,\n+                                  get_width ()));\n+  }\n+\n+  protected:\n+  HBUINT8       format;         \/* Format identifier--format = 0 *\/\n+  HBUINT8       entryFormat;    \/* A packed field that describes the compressed\n+                                 * representation of delta-set indices. *\/\n+  HBUINT16      mapCount;       \/* The number of mapping entries. *\/\n+  UnsizedArrayOf<HBUINT8>\n+                mapDataZ;       \/* The delta-set index mapping data. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (4, mapDataZ);\n+};\n+\n+struct DeltaSetIndexMapFormat1\n+{\n+  friend struct DeltaSetIndexMap;\n+\n+  private:\n+  DeltaSetIndexMapFormat1* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    auto *out = c->start_embed (this);\n+    if (unlikely (!out)) return_trace (nullptr);\n+\n+    unsigned total_size = min_size + mapCount * get_width ();\n+    HBUINT8 *p = c->allocate_size<HBUINT8> (total_size);\n+    if (unlikely (!p)) return_trace (nullptr);\n+\n+    memcpy (p, this, HBUINT8::static_size * total_size);\n+    return_trace (out);\n+  }\n+\n+  unsigned get_map_count () const       { return mapCount; }\n+  unsigned get_width () const           { return ((entryFormat >> 4) & 3) + 1; }\n+  unsigned get_inner_bit_count () const { return (entryFormat & 0xF) + 1; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  c->check_range (mapDataZ.arrayZ,\n+                                  mapCount,\n+                                  get_width ()));\n+  }\n+\n+  protected:\n+  HBUINT8       format;         \/* Format identifier--format = 1 *\/\n+  HBUINT8       entryFormat;    \/* A packed field that describes the compressed\n+                                 * representation of delta-set indices. *\/\n+  HBUINT32      mapCount;       \/* The number of mapping entries. *\/\n+  UnsizedArrayOf<HBUINT8>\n+                mapDataZ;       \/* The delta-set index mapping data. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (6, mapDataZ);\n+};\n+\n+struct DeltaSetIndexMap\n+{\n+  template <typename T>\n+  bool serialize (hb_serialize_context_t *c, const T &plan)\n+  {\n+    TRACE_SERIALIZE (this);\n+    switch (u.format) {\n+    case 0: return_trace (u.format0.serialize (c, plan));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  uint32_t map (unsigned v) const\n+  {\n+    switch (u.format) {\n+    case 0: return (u.format0.map (v));\n+    default:return v;\n+    }\n+  }\n+\n+  unsigned get_map_count () const\n+  {\n+    switch (u.format) {\n+    case 0: return u.format0.get_map_count ();\n+    case 1: return u.format1.get_map_count ();\n+    default:return 0;\n+    }\n+  }\n+\n+  unsigned get_width () const\n+  {\n+    switch (u.format) {\n+    case 0: return u.format0.get_width ();\n+    case 1: return u.format1.get_width ();\n+    default:return 0;\n+    }\n+  }\n+\n+  unsigned get_inner_bit_count () const\n+  {\n+    switch (u.format) {\n+    case 0: return u.format0.get_inner_bit_count ();\n+    case 1: return u.format1.get_inner_bit_count ();\n+    default:return 0;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 0: return_trace (u.format0.sanitize (c));\n+    case 1: return_trace (u.format1.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  DeltaSetIndexMap* copy (hb_serialize_context_t *c) const\n+  {\n+    TRACE_SERIALIZE (this);\n+    switch (u.format) {\n+    case 0: return_trace (reinterpret_cast<DeltaSetIndexMap *> (u.format0.copy (c)));\n+    case 1: return_trace (reinterpret_cast<DeltaSetIndexMap *> (u.format1.copy (c)));\n+    default:return_trace (nullptr);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT8                       format;         \/* Format identifier *\/\n+  DeltaSetIndexMapFormat0       format0;\n+  DeltaSetIndexMapFormat1       format1;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (1, format);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_VAR_COMMON_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-common.hh","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -145,1 +145,1 @@\n-  protected:\n+  public:\n@@ -147,0 +147,1 @@\n+  protected:\n@@ -150,0 +151,1 @@\n+  public:\n@@ -214,1 +216,1 @@\n-    return axes.lfind (tag, axis_index) && (axes[*axis_index].get_axis_deprecated (info), true);\n+    return axes.lfind (tag, axis_index) && ((void) axes[*axis_index].get_axis_deprecated (info), true);\n@@ -217,1 +219,0 @@\n-\n@@ -223,1 +224,1 @@\n-    return axes.lfind (tag, &i) && (axes[i].get_axis_info (i, info), true);\n+    return axes.lfind (tag, &i) && ((void) axes[i].get_axis_info (i, info), true);\n@@ -265,1 +266,1 @@\n-                                                         .sub_array (0, *coords_length);\n+                                                         .sub_array (0, coords_length);\n@@ -292,1 +293,1 @@\n-  protected:\n+  public:\n@@ -306,1 +307,1 @@\n-  OffsetTo<AxisRecord>\n+  Offset16To<AxisRecord>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-fvar-table.hh","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -48,3 +48,4 @@\n-  uint8_t flag;\n-  float x, y;\n-  bool is_end_point;\n+  float x = 0.f;\n+  float y = 0.f;\n+  uint8_t flag = 0;\n+  bool is_end_point = false;\n@@ -58,3 +59,6 @@\n-    resize (old_len + a.length);\n-    for (unsigned int i = 0; i < a.length; i++)\n-      (*this)[old_len + i] = a[i];\n+    if (unlikely (!resize (old_len + a.length)))\n+      return;\n+    auto arrayZ = this->arrayZ + old_len;\n+    unsigned count = a.length;\n+    for (unsigned int i = 0; i < count; i++)\n+      arrayZ[i] = a.arrayZ[i];\n@@ -65,1 +69,6 @@\n-    for (unsigned int i = 0; i < length; i++)\n+    if (matrix[0] == 1.f && matrix[1] == 0.f &&\n+        matrix[2] == 0.f && matrix[3] == 1.f)\n+      return;\n+    auto arrayZ = this->arrayZ;\n+    unsigned count = length;\n+    for (unsigned i = 0; i < count; i++)\n@@ -67,1 +76,1 @@\n-      contour_point_t &p = (*this)[i];\n+      contour_point_t &p = arrayZ[i];\n@@ -76,2 +85,6 @@\n-    for (unsigned int i = 0; i < length; i++)\n-      (*this)[i].translate (delta);\n+    if (delta.x == 0.f && delta.y == 0.f)\n+      return;\n+    auto arrayZ = this->arrayZ;\n+    unsigned count = length;\n+    for (unsigned i = 0; i < count; i++)\n+      arrayZ[i].translate (delta);\n@@ -92,1 +105,1 @@\n-  float calculate_scalar (const int *coords, unsigned int coord_count,\n+  float calculate_scalar (hb_array_t<int> coords, unsigned int coord_count,\n@@ -211,1 +224,1 @@\n-        if (!unpack_points (p, shared_indices, var_data_bytes)) return false;\n+        if (!unpack_points (p, shared_indices, (const HBUINT8 *) (var_data_bytes.arrayZ + var_data_bytes.length))) return false;\n@@ -261,1 +274,1 @@\n-                             const hb_bytes_t &bytes)\n+                             const HBUINT8 *end)\n@@ -269,1 +282,1 @@\n-    if (unlikely (!bytes.check_range (p))) return false;\n+    if (unlikely (p + 1 > end)) return false;\n@@ -274,1 +287,1 @@\n-      if (unlikely (!bytes.check_range (p))) return false;\n+      if (unlikely (p + 1 > end)) return false;\n@@ -277,1 +290,1 @@\n-    points.resize (count);\n+    if (unlikely (!points.resize (count))) return false;\n@@ -283,1 +296,1 @@\n-      if (unlikely (!bytes.check_range (p))) return false;\n+      if (unlikely (p + 1 > end)) return false;\n@@ -291,2 +304,1 @@\n-          if (unlikely (!bytes.check_range ((const HBUINT16 *) p)))\n-            return false;\n+          if (unlikely (p + HBUINT16::static_size > end)) return false;\n@@ -302,1 +314,1 @@\n-          if (unlikely (!bytes.check_range (p))) return false;\n+          if (unlikely (p + 1 > end)) return false;\n@@ -314,1 +326,1 @@\n-                             const hb_bytes_t &bytes)\n+                             const HBUINT8 *end)\n@@ -327,1 +339,1 @@\n-      if (unlikely (!bytes.check_range (p))) return false;\n+      if (unlikely (p + 1 > end)) return false;\n@@ -337,2 +349,1 @@\n-          if (unlikely (!bytes.check_range ((const HBUINT16 *) p)))\n-            return false;\n+          if (unlikely (p + HBUINT16::static_size > end)) return false;\n@@ -345,2 +356,1 @@\n-          if (unlikely (!bytes.check_range (p)))\n-            return false;\n+          if (unlikely (p + 1 > end)) return false;\n@@ -377,1 +387,1 @@\n-  OffsetTo<HBUINT8>\n+  Offset16To<HBUINT8>\n@@ -393,1 +403,0 @@\n-                  (glyphCount == c->get_num_glyphs ()) &&\n@@ -397,3 +406,1 @@\n-                     c->check_array (get_short_offset_array (), glyphCount+1)) &&\n-                  c->check_array (((const HBUINT8*)&(this+dataZ)) + get_offset (0),\n-                                  get_offset (glyphCount) - get_offset (0)));\n+                     c->check_array (get_short_offset_array (), glyphCount+1)));\n@@ -402,1 +409,1 @@\n-  \/* GlyphVariationData not sanitized here; must be checked while accessing each glyph varation data *\/\n+  \/* GlyphVariationData not sanitized here; must be checked while accessing each glyph variation data *\/\n@@ -422,1 +429,3 @@\n-    for (hb_codepoint_t gid = 0; gid < num_glyphs; gid++)\n+    for (hb_codepoint_t gid = (c->plan->flags & HB_SUBSET_FLAGS_NOTDEF_OUTLINE) ? 0 : 1;\n+         gid < num_glyphs;\n+         gid++)\n@@ -452,1 +461,3 @@\n-    for (hb_codepoint_t gid = 0; gid < num_glyphs; gid++)\n+    for (hb_codepoint_t gid = (c->plan->flags & HB_SUBSET_FLAGS_NOTDEF_OUTLINE) ? 0 : 1;\n+         gid < num_glyphs;\n+         gid++)\n@@ -481,1 +492,3 @@\n-    unsigned length = get_offset (glyph+1) - start_offset;\n+    unsigned end_offset = get_offset (glyph+1);\n+    if (unlikely (end_offset < start_offset)) return hb_bytes_t ();\n+    unsigned length = end_offset - start_offset;\n@@ -489,1 +502,4 @@\n-  { return is_long_offset () ? get_long_offset_array ()[i] : get_short_offset_array ()[i] * 2; }\n+  {\n+    if (unlikely (i > glyphCount)) return 0;\n+    return is_long_offset () ? get_long_offset_array ()[i] : get_short_offset_array ()[i] * 2;\n+  }\n@@ -497,1 +513,1 @@\n-    void init (hb_face_t *face)\n+    accelerator_t (hb_face_t *face)\n@@ -499,1 +515,1 @@\n-    void fini () { table.destroy (); }\n+    ~accelerator_t () { table.destroy (); }\n@@ -502,2 +518,0 @@\n-    struct x_getter { static float get (const contour_point_t &p) { return p.x; } };\n-    struct y_getter { static float get (const contour_point_t &p) { return p.y; } };\n@@ -505,1 +519,0 @@\n-    template <typename T>\n@@ -508,1 +521,2 @@\n-                              unsigned int target, unsigned int prev, unsigned int next)\n+                              unsigned int target, unsigned int prev, unsigned int next,\n+                              float contour_point_t::*m)\n@@ -510,5 +524,5 @@\n-      float target_val = T::get (points[target]);\n-      float prev_val = T::get (points[prev]);\n-      float next_val = T::get (points[next]);\n-      float prev_delta = T::get (deltas[prev]);\n-      float next_delta = T::get (deltas[next]);\n+      float target_val = points[target].*m;\n+      float prev_val = points[prev].*m;\n+      float next_val = points[next].*m;\n+      float prev_delta =  deltas[prev].*m;\n+      float next_delta =  deltas[next].*m;\n@@ -525,1 +539,1 @@\n-      return (1.f - r) * prev_delta + r * next_delta;\n+      return prev_delta + r * (next_delta - prev_delta);\n@@ -535,2 +549,1 @@\n-      \/* num_coords should exactly match gvar's axisCount due to how GlyphVariationData tuples are aligned *\/\n-      if (!font->num_coords || font->num_coords != table->axisCount) return true;\n+      if (!font->num_coords) return true;\n@@ -550,1 +563,1 @@\n-      orig_points.resize (points.length);\n+      if (unlikely (!orig_points.resize (points.length))) return false;\n@@ -552,1 +565,1 @@\n-        orig_points[i] = points[i];\n+        orig_points.arrayZ[i] = points.arrayZ[i];\n@@ -555,1 +568,1 @@\n-      deltas.resize (points.length);\n+      if (unlikely (!deltas.resize (points.length))) return false;\n@@ -562,2 +575,2 @@\n-      int *coords = font->coords;\n-      unsigned num_coords = font->num_coords;\n+      auto coords = hb_array (font->coords, font->num_coords);\n+      unsigned num_coords = table->axisCount;\n@@ -565,0 +578,4 @@\n+\n+      hb_vector_t<unsigned int> private_indices;\n+      hb_vector_t<int> x_deltas;\n+      hb_vector_t<int> y_deltas;\n@@ -574,4 +591,5 @@\n-        hb_bytes_t bytes ((const char *) p, length);\n-        hb_vector_t<unsigned int> private_indices;\n-        if (iterator.current_tuple->has_private_points () &&\n-            !GlyphVariationData::unpack_points (p, private_indices, bytes))\n+        const HBUINT8 *end = p + length;\n+\n+        bool has_private_points = iterator.current_tuple->has_private_points ();\n+        if (has_private_points &&\n+            !GlyphVariationData::unpack_points (p, private_indices, end))\n@@ -579,1 +597,1 @@\n-        const hb_array_t<unsigned int> &indices = private_indices.length ? private_indices : shared_indices;\n+        const hb_array_t<unsigned int> &indices = has_private_points ? private_indices : shared_indices;\n@@ -583,8 +601,4 @@\n-        hb_vector_t<int> x_deltas;\n-        x_deltas.resize (num_deltas);\n-        if (!GlyphVariationData::unpack_deltas (p, x_deltas, bytes))\n-          return false;\n-        hb_vector_t<int> y_deltas;\n-        y_deltas.resize (num_deltas);\n-        if (!GlyphVariationData::unpack_deltas (p, y_deltas, bytes))\n-          return false;\n+        if (unlikely (!x_deltas.resize (num_deltas))) return false;\n+        if (unlikely (!GlyphVariationData::unpack_deltas (p, x_deltas, end))) return false;\n+        if (unlikely (!y_deltas.resize (num_deltas))) return false;\n+        if (unlikely (!GlyphVariationData::unpack_deltas (p, y_deltas, end))) return false;\n@@ -597,3 +611,4 @@\n-          deltas[pt_index].flag = 1;    \/* this point is referenced, i.e., explicit deltas specified *\/\n-          deltas[pt_index].x += x_deltas[i] * scalar;\n-          deltas[pt_index].y += y_deltas[i] * scalar;\n+          if (unlikely (pt_index >= deltas.length)) continue;\n+          deltas.arrayZ[pt_index].flag = 1;     \/* this point is referenced, i.e., explicit deltas specified *\/\n+          deltas.arrayZ[pt_index].x += x_deltas.arrayZ[i] * scalar;\n+          deltas.arrayZ[pt_index].y += y_deltas.arrayZ[i] * scalar;\n@@ -643,2 +658,2 @@\n-              deltas[i].x = infer_delta<x_getter> (orig_points.as_array (), deltas.as_array (), i, prev, next);\n-              deltas[i].y = infer_delta<y_getter> (orig_points.as_array (), deltas.as_array (), i, prev, next);\n+              deltas[i].x = infer_delta (orig_points.as_array (), deltas.as_array (), i, prev, next, &contour_point_t::x);\n+              deltas[i].y = infer_delta (orig_points.as_array (), deltas.as_array (), i, prev, next, &contour_point_t::y);\n@@ -648,1 +663,1 @@\n-no_more_gaps:\n+        no_more_gaps:\n@@ -655,2 +670,2 @@\n-          points[i].x += deltas[i].x;\n-          points[i].y += deltas[i].y;\n+          points.arrayZ[i].x += deltas.arrayZ[i].x;\n+          points.arrayZ[i].y += deltas.arrayZ[i].y;\n@@ -679,1 +694,1 @@\n-  LNNOffsetTo<UnsizedArrayOf<F2DOT14>>\n+  NNOffset32To<UnsizedArrayOf<F2DOT14>>\n@@ -687,1 +702,1 @@\n-  LOffsetTo<GlyphVariationData>\n+  Offset32To<GlyphVariationData>\n@@ -694,1 +709,1 @@\n-  DEFINE_SIZE_MIN (20);\n+  DEFINE_SIZE_ARRAY (20, offsetZ);\n@@ -697,1 +712,3 @@\n-struct gvar_accelerator_t : gvar::accelerator_t {};\n+struct gvar_accelerator_t : gvar::accelerator_t {\n+  gvar_accelerator_t (hb_face_t *face) : gvar::accelerator_t (face) {}\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-gvar-table.hh","additions":97,"deletions":80,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-\n+#include \"hb-ot-var-common.hh\"\n@@ -36,86 +36,0 @@\n-struct DeltaSetIndexMap\n-{\n-  bool sanitize (hb_sanitize_context_t *c) const\n-  {\n-    TRACE_SANITIZE (this);\n-    return_trace (c->check_struct (this) &&\n-                  c->check_range (mapDataZ.arrayZ,\n-                                  mapCount,\n-                                  get_width ()));\n-  }\n-\n-  template <typename T>\n-  bool serialize (hb_serialize_context_t *c, const T &plan)\n-  {\n-    unsigned int width = plan.get_width ();\n-    unsigned int inner_bit_count = plan.get_inner_bit_count ();\n-    const hb_array_t<const unsigned int> output_map = plan.get_output_map ();\n-\n-    TRACE_SERIALIZE (this);\n-    if (unlikely (output_map.length && ((((inner_bit_count-1)&~0xF)!=0) || (((width-1)&~0x3)!=0))))\n-      return_trace (false);\n-    if (unlikely (!c->extend_min (*this))) return_trace (false);\n-\n-    format = ((width-1)<<4)|(inner_bit_count-1);\n-    mapCount = output_map.length;\n-    HBUINT8 *p = c->allocate_size<HBUINT8> (width * output_map.length);\n-    if (unlikely (!p)) return_trace (false);\n-    for (unsigned int i = 0; i < output_map.length; i++)\n-    {\n-      unsigned int v = output_map[i];\n-      unsigned int outer = v >> 16;\n-      unsigned int inner = v & 0xFFFF;\n-      unsigned int u = (outer << inner_bit_count) | inner;\n-      for (unsigned int w = width; w > 0;)\n-      {\n-        p[--w] = u;\n-        u >>= 8;\n-      }\n-      p += width;\n-    }\n-    return_trace (true);\n-  }\n-\n-  unsigned int map (unsigned int v) const \/* Returns 16.16 outer.inner. *\/\n-  {\n-    \/* If count is zero, pass value unchanged.  This takes\n-     * care of direct mapping for advance map. *\/\n-    if (!mapCount)\n-      return v;\n-\n-    if (v >= mapCount)\n-      v = mapCount - 1;\n-\n-    unsigned int u = 0;\n-    { \/* Fetch it. *\/\n-      unsigned int w = get_width ();\n-      const HBUINT8 *p = mapDataZ.arrayZ + w * v;\n-      for (; w; w--)\n-        u = (u << 8) + *p++;\n-    }\n-\n-    { \/* Repack it. *\/\n-      unsigned int n = get_inner_bit_count ();\n-      unsigned int outer = u >> n;\n-      unsigned int inner = u & ((1 << n) - 1);\n-      u = (outer<<16) | inner;\n-    }\n-\n-    return u;\n-  }\n-\n-  unsigned int get_map_count () const       { return mapCount; }\n-  unsigned int get_width () const           { return ((format >> 4) & 3) + 1; }\n-  unsigned int get_inner_bit_count () const { return (format & 0xF) + 1; }\n-\n-  protected:\n-  HBUINT16      format;         \/* A packed field that describes the compressed\n-                                 * representation of delta-set indices. *\/\n-  HBUINT16      mapCount;       \/* The number of mapping entries. *\/\n-  UnsizedArrayOf<HBUINT8>\n-                mapDataZ;       \/* The delta-set index mapping data. *\/\n-\n-  public:\n-  DEFINE_SIZE_ARRAY (4, mapDataZ);\n-};\n-\n@@ -220,1 +134,1 @@\n-        unsigned int v = input_map->map (old_gid);\n+        uint32_t v = input_map->map (old_gid);\n@@ -237,1 +151,1 @@\n-  hb_array_t<const unsigned int> get_output_map () const { return output_map.as_array (); }\n+  hb_array_t<const uint32_t> get_output_map () const { return output_map.as_array (); }\n@@ -244,1 +158,1 @@\n-  hb_vector_t<unsigned int> output_map;\n+  hb_vector_t<uint32_t> output_map;\n@@ -266,3 +180,0 @@\n-    for (unsigned int i = 0; i < inner_maps.length; i++)\n-      inner_maps[i].init ();\n-\n@@ -275,1 +186,1 @@\n-      retain_adv_map = plan->retain_gids;\n+      retain_adv_map = plan->flags & HB_SUBSET_FLAGS_RETAIN_GIDS;\n@@ -318,2 +229,2 @@\n-    inner_maps.fini_deep ();\n-    index_map_plans.fini_deep ();\n+    inner_maps.fini ();\n+    index_map_plans.fini ();\n@@ -370,1 +281,1 @@\n-    else if (unlikely (!advMap.serialize (c, this).serialize (c, im_plans[index_map_subset_plan_t::ADV_INDEX])))\n+    else if (unlikely (!advMap.serialize_serialize (c, im_plans[index_map_subset_plan_t::ADV_INDEX])))\n@@ -374,1 +285,1 @@\n-    else if (unlikely (!lsbMap.serialize (c, this).serialize (c, im_plans[index_map_subset_plan_t::LSB_INDEX])))\n+    else if (unlikely (!lsbMap.serialize_serialize (c, im_plans[index_map_subset_plan_t::LSB_INDEX])))\n@@ -378,1 +289,1 @@\n-    else if (unlikely (!rsbMap.serialize (c, this).serialize (c, im_plans[index_map_subset_plan_t::RSB_INDEX])))\n+    else if (unlikely (!rsbMap.serialize_serialize (c, im_plans[index_map_subset_plan_t::RSB_INDEX])))\n@@ -401,2 +312,4 @@\n-    if (unlikely (!out->varStore.serialize (c->serializer, out)\n-                     .serialize (c->serializer, hvar_plan.var_store, hvar_plan.inner_maps.as_array ())))\n+    if (unlikely (!out->varStore\n+                      .serialize_serialize (c->serializer,\n+                                            hvar_plan.var_store,\n+                                            hvar_plan.inner_maps.as_array ())))\n@@ -409,1 +322,3 @@\n-  float get_advance_var (hb_codepoint_t glyph, hb_font_t *font) const\n+  float get_advance_var (hb_codepoint_t  glyph,\n+                         hb_font_t      *font,\n+                         VariationStore::cache_t *store_cache = nullptr) const\n@@ -411,2 +326,5 @@\n-    unsigned int varidx = (this+advMap).map (glyph);\n-    return (this+varStore).get_delta (varidx, font->coords, font->num_coords);\n+    uint32_t varidx = (this+advMap).map (glyph);\n+    return (this+varStore).get_delta (varidx,\n+                                      font->coords,\n+                                      font->num_coords,\n+                                      store_cache);\n@@ -419,1 +337,1 @@\n-    unsigned int varidx = (this+lsbMap).map (glyph);\n+    uint32_t varidx = (this+lsbMap).map (glyph);\n@@ -425,1 +343,1 @@\n-  protected:\n+  public:\n@@ -428,1 +346,1 @@\n-  LOffsetTo<VariationStore>\n+  Offset32To<VariationStore>\n@@ -430,1 +348,1 @@\n-  LOffsetTo<DeltaSetIndexMap>\n+  Offset32To<DeltaSetIndexMap>\n@@ -432,1 +350,1 @@\n-  LOffsetTo<DeltaSetIndexMap>\n+  Offset32To<DeltaSetIndexMap>\n@@ -434,1 +352,1 @@\n-  LOffsetTo<DeltaSetIndexMap>\n+  Offset32To<DeltaSetIndexMap>\n@@ -469,1 +387,1 @@\n-    else if (unlikely (!vorgMap.serialize (c, this).serialize (c, im_plans[index_map_subset_plan_t::VORG_INDEX])))\n+    else if (unlikely (!vorgMap.serialize_serialize (c, im_plans[index_map_subset_plan_t::VORG_INDEX])))\n@@ -478,1 +396,1 @@\n-  LOffsetTo<DeltaSetIndexMap>\n+  Offset32To<DeltaSetIndexMap>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-hvar-table.hh","additions":30,"deletions":112,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  OffsetTo<VariationStore>\n+  Offset16To<VariationStore>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-mvar-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,0 +306,3 @@\n+ * The normalized values have 14 bits of fixed-point sub-integer precision as per\n+ * OpenType specification.\n+ *\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var.cc","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n- * @min_value: The mininum value on the variation axis that the font covers\n+ * @min_value: The minimum value on the variation axis that the font covers\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  HBGlyphID     glyph;\n+  HBGlyphID16   glyph;\n@@ -128,1 +128,1 @@\n-  SortedArrayOf<VertOriginMetric>\n+  SortedArray16Of<VertOriginMetric>\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-vorg-table.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    for (chunk_t *_ : chunks) ::free (_);\n+    for (chunk_t *_ : chunks) hb_free (_);\n@@ -54,1 +54,1 @@\n-      chunk_t *chunk = (chunk_t *) calloc (1, sizeof (chunk_t));\n+      chunk_t *chunk = (chunk_t *) hb_calloc (1, sizeof (chunk_t));\n@@ -68,1 +68,1 @@\n-  void free (T* obj)\n+  void release (T* obj)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-pool.hh","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright  2020  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef HB_PRIORITY_QUEUE_HH\n+#define HB_PRIORITY_QUEUE_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-vector.hh\"\n+\n+\/*\n+ * hb_priority_queue_t\n+ *\n+ * Priority queue implemented as a binary heap. Supports extract minimum\n+ * and insert operations.\n+ *\/\n+struct hb_priority_queue_t\n+{\n+ private:\n+  typedef hb_pair_t<int64_t, unsigned> item_t;\n+  hb_vector_t<item_t> heap;\n+\n+ public:\n+\n+  void reset () { heap.resize (0); }\n+\n+  bool in_error () const { return heap.in_error (); }\n+\n+  void insert (int64_t priority, unsigned value)\n+  {\n+    heap.push (item_t (priority, value));\n+    if (unlikely (heap.in_error ())) return;\n+    bubble_up (heap.length - 1);\n+  }\n+\n+  item_t pop_minimum ()\n+  {\n+    assert (!is_empty ());\n+\n+    item_t result = heap.arrayZ[0];\n+\n+    heap.arrayZ[0] = heap.arrayZ[heap.length - 1];\n+    heap.shrink (heap.length - 1);\n+    bubble_down (0);\n+\n+    return result;\n+  }\n+\n+  const item_t& minimum ()\n+  {\n+    return heap[0];\n+  }\n+\n+  bool is_empty () const { return heap.length == 0; }\n+  explicit operator bool () const { return !is_empty (); }\n+  unsigned int get_population () const { return heap.length; }\n+\n+  \/* Sink interface. *\/\n+  hb_priority_queue_t& operator << (item_t item)\n+  { insert (item.first, item.second); return *this; }\n+\n+ private:\n+\n+  static constexpr unsigned parent (unsigned index)\n+  {\n+    return (index - 1) \/ 2;\n+  }\n+\n+  static constexpr unsigned left_child (unsigned index)\n+  {\n+    return 2 * index + 1;\n+  }\n+\n+  static constexpr unsigned right_child (unsigned index)\n+  {\n+    return 2 * index + 2;\n+  }\n+\n+  void bubble_down (unsigned index)\n+  {\n+    assert (index <= heap.length);\n+\n+    unsigned left = left_child (index);\n+    unsigned right = right_child (index);\n+\n+    bool has_left = left < heap.length;\n+    if (!has_left)\n+      \/\/ If there's no left, then there's also no right.\n+      return;\n+\n+    bool has_right = right < heap.length;\n+    if (heap.arrayZ[index].first <= heap.arrayZ[left].first\n+        && (!has_right || heap[index].first <= heap.arrayZ[right].first))\n+      return;\n+\n+    if (!has_right || heap.arrayZ[left].first < heap.arrayZ[right].first)\n+    {\n+      swap (index, left);\n+      bubble_down (left);\n+      return;\n+    }\n+\n+    swap (index, right);\n+    bubble_down (right);\n+  }\n+\n+  void bubble_up (unsigned index)\n+  {\n+    assert (index <= heap.length);\n+\n+    if (index == 0) return;\n+\n+    unsigned parent_index = parent (index);\n+    if (heap.arrayZ[parent_index].first <= heap.arrayZ[index].first)\n+      return;\n+\n+    swap (index, parent_index);\n+    bubble_up (parent_index);\n+  }\n+\n+  void swap (unsigned a, unsigned b)\n+  {\n+    assert (a <= heap.length);\n+    assert (b <= heap.length);\n+    hb_swap (heap.arrayZ[a], heap.arrayZ[b]);\n+  }\n+};\n+\n+#endif \/* HB_PRIORITY_QUEUE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-priority-queue.hh","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright  2020  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef HB_REPACKER_HH\n+#define HB_REPACKER_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-map.hh\"\n+#include \"hb-priority-queue.hh\"\n+#include \"hb-serialize.hh\"\n+#include \"hb-vector.hh\"\n+#include \"graph\/graph.hh\"\n+#include \"graph\/serialize.hh\"\n+\n+using graph::graph_t;\n+\n+\/*\n+ * For a detailed writeup on the overflow resolution algorithm see:\n+ * docs\/repacker.md\n+ *\/\n+\n+static inline\n+bool _try_isolating_subgraphs (const hb_vector_t<graph::overflow_record_t>& overflows,\n+                               graph_t& sorted_graph)\n+{\n+  unsigned space = 0;\n+  hb_set_t roots_to_isolate;\n+\n+  for (int i = overflows.length - 1; i >= 0; i--)\n+  {\n+    const graph::overflow_record_t& r = overflows[i];\n+\n+    unsigned root;\n+    unsigned overflow_space = sorted_graph.space_for (r.parent, &root);\n+    if (!overflow_space) continue;\n+    if (sorted_graph.num_roots_for_space (overflow_space) <= 1) continue;\n+\n+    if (!space) {\n+      space = overflow_space;\n+    }\n+\n+    if (space == overflow_space)\n+      roots_to_isolate.add(root);\n+  }\n+\n+  if (!roots_to_isolate) return false;\n+\n+  unsigned maximum_to_move = hb_max ((sorted_graph.num_roots_for_space (space) \/ 2u), 1u);\n+  if (roots_to_isolate.get_population () > maximum_to_move) {\n+    \/\/ Only move at most half of the roots in a space at a time.\n+    unsigned extra = roots_to_isolate.get_population () - maximum_to_move;\n+    while (extra--) {\n+      unsigned root = HB_SET_VALUE_INVALID;\n+      roots_to_isolate.previous (&root);\n+      roots_to_isolate.del (root);\n+    }\n+  }\n+\n+  DEBUG_MSG (SUBSET_REPACK, nullptr,\n+             \"Overflow in space %d (%d roots). Moving %d roots to space %d.\",\n+             space,\n+             sorted_graph.num_roots_for_space (space),\n+             roots_to_isolate.get_population (),\n+             sorted_graph.next_space ());\n+\n+  sorted_graph.isolate_subgraph (roots_to_isolate);\n+  sorted_graph.move_to_new_space (roots_to_isolate);\n+\n+  return true;\n+}\n+\n+static inline\n+bool _process_overflows (const hb_vector_t<graph::overflow_record_t>& overflows,\n+                         hb_set_t& priority_bumped_parents,\n+                         graph_t& sorted_graph)\n+{\n+  bool resolution_attempted = false;\n+\n+  \/\/ Try resolving the furthest overflows first.\n+  for (int i = overflows.length - 1; i >= 0; i--)\n+  {\n+    const graph::overflow_record_t& r = overflows[i];\n+    const auto& child = sorted_graph.vertices_[r.child];\n+    if (child.is_shared ())\n+    {\n+      \/\/ The child object is shared, we may be able to eliminate the overflow\n+      \/\/ by duplicating it.\n+      if (!sorted_graph.duplicate (r.parent, r.child)) continue;\n+      return true;\n+    }\n+\n+    if (child.is_leaf () && !priority_bumped_parents.has (r.parent))\n+    {\n+      \/\/ This object is too far from it's parent, attempt to move it closer.\n+      \/\/\n+      \/\/ TODO(garretrieger): initially limiting this to leaf's since they can be\n+      \/\/                     moved closer with fewer consequences. However, this can\n+      \/\/                     likely can be used for non-leafs as well.\n+      \/\/ TODO(garretrieger): also try lowering priority of the parent. Make it\n+      \/\/                     get placed further up in the ordering, closer to it's children.\n+      \/\/                     this is probably preferable if the total size of the parent object\n+      \/\/                     is < then the total size of the children (and the parent can be moved).\n+      \/\/                     Since in that case moving the parent will cause a smaller increase in\n+      \/\/                     the length of other offsets.\n+      if (sorted_graph.raise_childrens_priority (r.parent)) {\n+        priority_bumped_parents.add (r.parent);\n+        resolution_attempted = true;\n+      }\n+      continue;\n+    }\n+\n+    \/\/ TODO(garretrieger): add additional offset resolution strategies\n+    \/\/ - Promotion to extension lookups.\n+    \/\/ - Table splitting.\n+  }\n+\n+  return resolution_attempted;\n+}\n+\n+\/*\n+ * Attempts to modify the topological sorting of the provided object graph to\n+ * eliminate offset overflows in the links between objects of the graph. If a\n+ * non-overflowing ordering is found the updated graph is serialized it into the\n+ * provided serialization context.\n+ *\n+ * If necessary the structure of the graph may be modified in ways that do not\n+ * affect the functionality of the graph. For example shared objects may be\n+ * duplicated.\n+ *\n+ * For a detailed writeup describing how the algorithm operates see:\n+ * docs\/repacker.md\n+ *\/\n+template<typename T>\n+inline hb_blob_t*\n+hb_resolve_overflows (const T& packed,\n+                      hb_tag_t table_tag,\n+                      unsigned max_rounds = 20) {\n+  graph_t sorted_graph (packed);\n+  sorted_graph.sort_shortest_distance ();\n+\n+  bool will_overflow = graph::will_overflow (sorted_graph);\n+  if (!will_overflow)\n+  {\n+    return graph::serialize (sorted_graph);\n+  }\n+\n+  if ((table_tag == HB_OT_TAG_GPOS\n+       ||  table_tag == HB_OT_TAG_GSUB)\n+      && will_overflow)\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"Assigning spaces to 32 bit subgraphs.\");\n+    if (sorted_graph.assign_32bit_spaces ())\n+      sorted_graph.sort_shortest_distance ();\n+  }\n+\n+  unsigned round = 0;\n+  hb_vector_t<graph::overflow_record_t> overflows;\n+  \/\/ TODO(garretrieger): select a good limit for max rounds.\n+  while (!sorted_graph.in_error ()\n+         && graph::will_overflow (sorted_graph, &overflows)\n+         && round++ < max_rounds) {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"=== Overflow resolution round %d ===\", round);\n+    print_overflows (sorted_graph, overflows);\n+\n+    hb_set_t priority_bumped_parents;\n+\n+    if (!_try_isolating_subgraphs (overflows, sorted_graph))\n+    {\n+      if (!_process_overflows (overflows, priority_bumped_parents, sorted_graph))\n+      {\n+        DEBUG_MSG (SUBSET_REPACK, nullptr, \"No resolution available :(\");\n+        break;\n+      }\n+    }\n+\n+    sorted_graph.sort_shortest_distance ();\n+  }\n+\n+  if (sorted_graph.in_error ())\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"Sorted graph in error state.\");\n+    return nullptr;\n+  }\n+\n+  if (graph::will_overflow (sorted_graph))\n+  {\n+    DEBUG_MSG (SUBSET_REPACK, nullptr, \"Offset overflow resolution failed.\");\n+    return nullptr;\n+  }\n+\n+  return graph::serialize (sorted_graph);\n+}\n+\n+#endif \/* HB_REPACKER_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-repacker.hh","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -108,1 +108,1 @@\n-#define HB_SANITIZE_MAX_OPS_FACTOR 8\n+#define HB_SANITIZE_MAX_OPS_FACTOR 64\n@@ -126,0 +126,1 @@\n+        recursion_depth (0),\n@@ -148,1 +149,1 @@\n-  ( obj.sanitize (this, hb_forward<Ts> (ds)...) )\n+  ( obj.sanitize (this, std::forward<Ts> (ds)...) )\n@@ -151,1 +152,1 @@\n-  ( obj.dispatch (this, hb_forward<Ts> (ds)...) )\n+  ( obj.dispatch (this, std::forward<Ts> (ds)...) )\n@@ -155,1 +156,1 @@\n-  ( _dispatch (obj, hb_prioritize, hb_forward<Ts> (ds)...) )\n+  ( _dispatch (obj, hb_prioritize, std::forward<Ts> (ds)...) )\n@@ -208,0 +209,1 @@\n+    this->recursion_depth = 0;\n@@ -236,1 +238,1 @@\n-               this->max_ops-- > 0);\n+               (this->max_ops -= len) > 0);\n@@ -281,0 +283,12 @@\n+  bool check_start_recursion (int max_depth)\n+  {\n+    if (unlikely (recursion_depth >= max_depth)) return false;\n+    return ++recursion_depth;\n+  }\n+\n+  bool end_recursion (bool result)\n+  {\n+    recursion_depth--;\n+    return result;\n+  }\n+\n@@ -392,0 +406,1 @@\n+  int recursion_depth;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-sanitize.hh","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#ifdef HB_EXPERIMENTAL_API\n+#include \"hb-subset-repacker.h\"\n+#endif\n@@ -44,0 +47,10 @@\n+enum hb_serialize_error_t {\n+  HB_SERIALIZE_ERROR_NONE =            0x00000000u,\n+  HB_SERIALIZE_ERROR_OTHER =           0x00000001u,\n+  HB_SERIALIZE_ERROR_OFFSET_OVERFLOW = 0x00000002u,\n+  HB_SERIALIZE_ERROR_OUT_OF_ROOM =     0x00000004u,\n+  HB_SERIALIZE_ERROR_INT_OVERFLOW =    0x00000008u,\n+  HB_SERIALIZE_ERROR_ARRAY_OVERFLOW =  0x00000010u\n+};\n+HB_MARK_AS_FLAG_T (hb_serialize_error_t);\n+\n@@ -54,0 +67,2 @@\n+\n+\n@@ -56,1 +71,31 @@\n-    void fini () { links.fini (); }\n+    void fini () {\n+      real_links.fini ();\n+      virtual_links.fini ();\n+    }\n+\n+    object_t () = default;\n+\n+#ifdef HB_EXPERIMENTAL_API\n+    object_t (const hb_object_t &o)\n+    {\n+      head = o.head;\n+      tail = o.tail;\n+      next = nullptr;\n+      real_links.alloc (o.num_real_links);\n+      for (unsigned i = 0 ; i < o.num_real_links; i++)\n+        real_links.push (o.real_links[i]);\n+\n+      virtual_links.alloc (o.num_virtual_links);\n+      for (unsigned i = 0; i < o.num_virtual_links; i++)\n+        virtual_links.push (o.virtual_links[i]);\n+    }\n+#endif\n+\n+    friend void swap (object_t& a, object_t& b)\n+    {\n+      hb_swap (a.head, b.head);\n+      hb_swap (a.tail, b.tail);\n+      hb_swap (a.next, b.next);\n+      hb_swap (a.real_links, b.real_links);\n+      hb_swap (a.virtual_links, b.virtual_links);\n+    }\n@@ -60,0 +105,2 @@\n+      \/\/ Virtual links aren't considered for equality since they don't affect the functionality\n+      \/\/ of the object.\n@@ -61,1 +108,1 @@\n-          && (links.length == o.links.length)\n+          && (real_links.length == o.real_links.length)\n@@ -63,1 +110,1 @@\n-          && links.as_bytes () == o.links.as_bytes ();\n+          && real_links.as_bytes () == o.real_links.as_bytes ();\n@@ -67,0 +114,2 @@\n+      \/\/ Virtual links aren't considered for equality since they don't affect the functionality\n+      \/\/ of the object.\n@@ -68,1 +117,1 @@\n-             links.as_bytes ().hash ();\n+          real_links.as_bytes ().hash ();\n@@ -73,2 +122,2 @@\n-      bool is_wide: 1;\n-      bool is_signed: 1;\n+      unsigned width: 3;\n+      unsigned is_signed: 1;\n@@ -76,2 +125,2 @@\n-      unsigned position: 28;\n-      unsigned bias;\n+      unsigned bias : 26;\n+      unsigned position;\n@@ -79,0 +128,14 @@\n+\n+      link_t () = default;\n+\n+#ifdef HB_EXPERIMENTAL_API\n+      link_t (const hb_link_t &o)\n+      {\n+        width = o.width;\n+        is_signed = 0;\n+        whence = 0;\n+        position = o.position;\n+        bias = 0;\n+        objidx = o.objidx;\n+      }\n+#endif\n@@ -83,1 +146,2 @@\n-    hb_vector_t<link_t> links;\n+    hb_vector_t<link_t> real_links;\n+    hb_vector_t<link_t> virtual_links;\n@@ -85,0 +149,5 @@\n+\n+    auto all_links () const HB_AUTO_RETURN\n+        (( hb_concat (this->real_links, this->virtual_links) ));\n+    auto all_links_writer () HB_AUTO_RETURN\n+        (( hb_concat (this->real_links.writer (), this->virtual_links.writer ()) ));\n@@ -92,1 +161,3 @@\n-    unsigned num_links;\n+    unsigned num_real_links;\n+    unsigned num_virtual_links;\n+    hb_serialize_error_t errors;\n@@ -96,1 +167,2 @@\n-  { return snapshot_t { head, tail, current, current->links.length }; }\n+  { return snapshot_t {\n+      head, tail, current, current->real_links.length, current->virtual_links.length, errors }; }\n@@ -120,1 +192,21 @@\n-  bool in_error () const { return !this->successful; }\n+  bool in_error () const { return bool (errors); }\n+\n+  bool successful () const { return !bool (errors); }\n+\n+  HB_NODISCARD bool ran_out_of_room () const { return errors & HB_SERIALIZE_ERROR_OUT_OF_ROOM; }\n+  HB_NODISCARD bool offset_overflow () const { return errors & HB_SERIALIZE_ERROR_OFFSET_OVERFLOW; }\n+  HB_NODISCARD bool only_offset_overflow () const { return errors == HB_SERIALIZE_ERROR_OFFSET_OVERFLOW; }\n+  HB_NODISCARD bool only_overflow () const\n+  {\n+    return errors == HB_SERIALIZE_ERROR_OFFSET_OVERFLOW\n+        || errors == HB_SERIALIZE_ERROR_INT_OVERFLOW\n+        || errors == HB_SERIALIZE_ERROR_ARRAY_OVERFLOW;\n+  }\n+\n+  void reset (void *start_, unsigned int size)\n+  {\n+    start = (char*) start_;\n+    end = start + size;\n+    reset ();\n+    current = nullptr;\n+  }\n@@ -124,2 +216,1 @@\n-    this->successful = true;\n-    this->ran_out_of_room = false;\n+    this->errors = HB_SERIALIZE_ERROR_NONE;\n@@ -132,0 +223,1 @@\n+    this->packed_map.init ();\n@@ -134,2 +226,6 @@\n-  bool check_success (bool success)\n-  { return this->successful && (success || (err_other_error (), false)); }\n+  bool check_success (bool success,\n+                      hb_serialize_error_t err_type = HB_SERIALIZE_ERROR_OTHER)\n+  {\n+    return successful ()\n+        && (success || err (err_type));\n+  }\n@@ -138,2 +234,8 @@\n-  bool check_equal (T1 &&v1, T2 &&v2)\n-  { return check_success ((long long) v1 == (long long) v2); }\n+  bool check_equal (T1 &&v1, T2 &&v2, hb_serialize_error_t err_type)\n+  {\n+    if ((long long) v1 != (long long) v2)\n+    {\n+      return err (err_type);\n+    }\n+    return true;\n+  }\n@@ -142,2 +244,2 @@\n-  bool check_assign (T1 &v1, T2 &&v2)\n-  { return check_equal (v1 = v2, v2); }\n+  bool check_assign (T1 &v1, T2 &&v2, hb_serialize_error_t err_type)\n+  { return check_equal (v1 = v2, v2, err_type); }\n@@ -149,2 +251,2 @@\n-  { return propagate_error (hb_forward<T1> (o1)) &&\n-           propagate_error (hb_forward<Ts> (os)...); }\n+  { return propagate_error (std::forward<T1> (o1)) &&\n+           propagate_error (std::forward<Ts> (os)...); }\n@@ -170,1 +272,1 @@\n-                     this->successful ? \"successful\" : \"UNSUCCESSFUL\");\n+                     successful () ? \"successful\" : \"UNSUCCESSFUL\");\n@@ -175,1 +277,7 @@\n-    if (unlikely (in_error())) return;\n+    if (unlikely (in_error()))\n+    {\n+      \/\/ Offset overflows that occur before link resolution cannot be handled\n+      \/\/ by repacking, so set a more general error.\n+      if (offset_overflow ()) err (HB_SERIALIZE_ERROR_OTHER);\n+      return;\n+    }\n@@ -215,1 +323,1 @@\n-    object_pool.free (obj);\n+    object_pool.release (obj);\n@@ -218,1 +326,1 @@\n-  \/* Set share to false when an object is unlikely sharable with others\n+  \/* Set share to false when an object is unlikely shareable with others\n@@ -236,1 +344,2 @@\n-      assert (!obj->links.length);\n+      assert (!obj->real_links.length);\n+      assert (!obj->virtual_links.length);\n@@ -246,0 +355,1 @@\n+        merge_virtual_links (obj, objidx);\n@@ -278,1 +388,2 @@\n-    if (unlikely (in_error ())) return;\n+    \/\/ Overflows that happened after the snapshot will be erased by the revert.\n+    if (unlikely (in_error () && !only_overflow ())) return;\n@@ -280,1 +391,3 @@\n-    current->links.shrink (snap.num_links);\n+    current->real_links.shrink (snap.num_real_links);\n+    current->virtual_links.shrink (snap.num_virtual_links);\n+    errors = snap.errors;\n@@ -310,0 +423,29 @@\n+  \/\/ Adds a virtual link from the current object to objidx. A virtual link is not associated with\n+  \/\/ an actual offset field. They are solely used to enforce ordering constraints between objects.\n+  \/\/ Adding a virtual link from object a to object b will ensure that object b is always packed after\n+  \/\/ object a in the final serialized order.\n+  \/\/\n+  \/\/ This is useful in certain situations where there needs to be a specific ordering in the\n+  \/\/ final serialization. Such as when platform bugs require certain orderings, or to provide\n+  \/\/  guidance to the repacker for better offset overflow resolution.\n+  void add_virtual_link (objidx_t objidx)\n+  {\n+    if (unlikely (in_error ())) return;\n+\n+    if (!objidx)\n+      return;\n+\n+    assert (current);\n+\n+    auto& link = *current->virtual_links.push ();\n+    if (current->virtual_links.in_error ())\n+      err (HB_SERIALIZE_ERROR_OTHER);\n+\n+    link.width = 0;\n+    link.objidx = objidx;\n+    link.is_signed = 0;\n+    link.whence = 0;\n+    link.position = 0;\n+    link.bias = 0;\n+  }\n+\n@@ -315,1 +457,0 @@\n-    static_assert (sizeof (T) == 2 || sizeof (T) == 4, \"\");\n@@ -324,1 +465,3 @@\n-    auto& link = *current->links.push ();\n+    auto& link = *current->real_links.push ();\n+    if (current->real_links.in_error ())\n+      err (HB_SERIALIZE_ERROR_OTHER);\n@@ -326,2 +469,14 @@\n-    link.is_wide = sizeof (T) == 4;\n-    link.is_signed = hb_is_signed (hb_unwrap_type (T));\n+    link.width = sizeof (T);\n+    link.objidx = objidx;\n+    if (unlikely (!sizeof (T)))\n+    {\n+      \/\/ This link is not associated with an actual offset and exists merely to enforce\n+      \/\/ an ordering constraint.\n+      link.is_signed = 0;\n+      link.whence = 0;\n+      link.position = 0;\n+      link.bias = 0;\n+      return;\n+    }\n+\n+    link.is_signed = std::is_signed<hb_unwrap_type (T)>::value;\n@@ -331,1 +486,0 @@\n-    link.objidx = objidx;\n@@ -351,1 +505,1 @@\n-      for (const object_t::link_t &link : parent->links)\n+      for (const object_t::link_t &link : parent->real_links)\n@@ -354,1 +508,1 @@\n-        if (unlikely (!child)) { err_other_error(); return; }\n+        if (unlikely (!child)) { err (HB_SERIALIZE_ERROR_OTHER); return; }\n@@ -366,1 +520,2 @@\n-          if (link.is_wide)\n+          assert (link.width == 2 || link.width == 4);\n+          if (link.width == 4)\n@@ -373,1 +528,2 @@\n-          if (link.is_wide)\n+          assert (link.width == 2 || link.width == 3 || link.width == 4);\n+          if (link.width == 4)\n@@ -375,0 +531,2 @@\n+          else if (link.width == 3)\n+            assign_offset<uint32_t, 3> (parent, link, offset);\n@@ -399,1 +557,1 @@\n-  { return start_embed (hb_addressof (obj)); }\n+  { return start_embed (std::addressof (obj)); }\n@@ -401,3 +559,4 @@\n-  \/* Following two functions exist to allow setting breakpoint on. *\/\n-  void err_ran_out_of_room () { this->ran_out_of_room = true; }\n-  void err_other_error () { this->successful = false; }\n+  bool err (hb_serialize_error_t err_type)\n+  {\n+    return !bool ((errors = (errors | err_type)));\n+  }\n@@ -406,1 +565,1 @@\n-  Type *allocate_size (unsigned int size)\n+  Type *allocate_size (size_t size)\n@@ -408,1 +567,1 @@\n-    if (unlikely (!this->successful)) return nullptr;\n+    if (unlikely (in_error ())) return nullptr;\n@@ -410,1 +569,1 @@\n-    if (this->tail - this->head < ptrdiff_t (size))\n+    if (unlikely (size > INT_MAX || this->tail - this->head < ptrdiff_t (size)))\n@@ -412,2 +571,1 @@\n-      err_ran_out_of_room ();\n-      this->successful = false;\n+      err (HB_SERIALIZE_ERROR_OUT_OF_ROOM);\n@@ -416,1 +574,1 @@\n-    memset (this->head, 0, size);\n+    hb_memset (this->head, 0, size);\n@@ -437,1 +595,1 @@\n-  { return embed (hb_addressof (obj)); }\n+  { return embed (std::addressof (obj)); }\n@@ -441,1 +599,1 @@\n-  (Type *, src.copy (this, hb_forward<Ts> (ds)...))\n+  (Type *, src.copy (this, std::forward<Ts> (ds)...))\n@@ -456,1 +614,1 @@\n-  { return _copy (src, hb_prioritize, hb_forward<Ts> (ds)...); }\n+  { return _copy (src, hb_prioritize, std::forward<Ts> (ds)...); }\n@@ -459,1 +617,1 @@\n-  { return copy (*src, hb_forward<Ts> (ds)...); }\n+  { return copy (*src, std::forward<Ts> (ds)...); }\n@@ -465,1 +623,1 @@\n-  { for (decltype (*it) _ : it) copy (_, hb_forward<Ts> (ds)...); }\n+  { for (decltype (*it) _ : it) copy (_, std::forward<Ts> (ds)...); }\n@@ -471,1 +629,1 @@\n-  Type *extend_size (Type *obj, unsigned int size)\n+  Type *extend_size (Type *obj, size_t size)\n@@ -477,2 +635,3 @@\n-    assert ((char *) obj + size >= this->head);\n-    if (unlikely (!this->allocate_size<Type> (((char *) obj) + size - this->head))) return nullptr;\n+    assert ((size_t) (this->head - (char *) obj) <= size);\n+    if (unlikely (((char *) obj + size < (char *) obj) ||\n+                  !this->allocate_size<Type> (((char *) obj) + size - this->head))) return nullptr;\n@@ -482,2 +641,2 @@\n-  Type *extend_size (Type &obj, unsigned int size)\n-  { return extend_size (hb_addressof (obj), size); }\n+  Type *extend_size (Type &obj, size_t size)\n+  { return extend_size (std::addressof (obj), size); }\n@@ -488,1 +647,1 @@\n-  Type *extend_min (Type &obj) { return extend_min (hb_addressof (obj)); }\n+  Type *extend_min (Type &obj) { return extend_min (std::addressof (obj)); }\n@@ -492,1 +651,1 @@\n-  { return extend_size (obj, obj->get_size (hb_forward<Ts> (ds)...)); }\n+  { return extend_size (obj, obj->get_size (std::forward<Ts> (ds)...)); }\n@@ -495,1 +654,1 @@\n-  { return extend (hb_addressof (obj), hb_forward<Ts> (ds)...); }\n+  { return extend (std::addressof (obj), std::forward<Ts> (ds)...); }\n@@ -500,1 +659,1 @@\n-    assert (this->successful);\n+    assert (successful ());\n@@ -505,1 +664,5 @@\n-    char *p = (char *) malloc (len);\n+    \/\/ If len is zero don't hb_malloc as the memory won't get properly\n+    \/\/ cleaned up later.\n+    if (!len) return hb_bytes_t ();\n+\n+    char *p = (char *) hb_malloc (len);\n@@ -520,1 +683,1 @@\n-                           (char *) b.arrayZ, free);\n+                           (char *) b.arrayZ, hb_free);\n@@ -523,0 +686,3 @@\n+  const hb_vector_t<object_t *>& object_graph() const\n+  { return packed; }\n+\n@@ -524,1 +690,1 @@\n-  template <typename T>\n+  template <typename T, unsigned Size = sizeof (T)>\n@@ -527,1 +693,1 @@\n-    auto &off = * ((BEInt<T> *) (parent->head + link.position));\n+    auto &off = * ((BEInt<T, Size> *) (parent->head + link.position));\n@@ -529,1 +695,1 @@\n-    check_assign (off, offset);\n+    check_assign (off, offset, HB_SERIALIZE_ERROR_OFFSET_OVERFLOW);\n@@ -532,1 +698,1 @@\n-  public: \/* TODO Make private. *\/\n+  public:\n@@ -535,2 +701,1 @@\n-  bool successful;\n-  bool ran_out_of_room;\n+  hb_serialize_error_t errors;\n@@ -540,0 +705,7 @@\n+  void merge_virtual_links (const object_t* from, objidx_t to_idx) {\n+    object_t* to = packed[to_idx];\n+    for (const auto& l : from->virtual_links) {\n+      to->virtual_links.push (l);\n+    }\n+  }\n+\n@@ -550,1 +722,1 @@\n-  hb_hashmap_t<const object_t *, objidx_t, nullptr, 0> packed_map;\n+  hb_hashmap_t<const object_t *, objidx_t> packed_map;\n@@ -553,1 +725,0 @@\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-serialize.hh","additions":243,"deletions":72,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * The set digests here implement various \"filters\" that support\n+ * The set-digests here implement various \"filters\" that support\n@@ -43,3 +43,15 @@\n- * The frozen-set can be used instead of a digest, to trade more\n- * memory for 100% accuracy, but in practice, that doesn't look like\n- * an attractive trade-off.\n+ * The way these are used is that the filter is first populated by\n+ * a lookup's or subtable's Coverage table(s), and then when we\n+ * want to apply the lookup or subtable to a glyph, before trying\n+ * to apply, we ask the filter if the glyph may be covered. If it's\n+ * not, we return early.\n+ *\n+ * We use these filters both at the lookup-level, and then again,\n+ * at the subtable-level. Both have performance win.\n+ *\n+ * The main filter we use is a combination of three bits-pattern\n+ * filters. A bits-pattern filter checks a number of bits (5 or 6)\n+ * of the input number (glyph-id in this case) and checks whether\n+ * its pattern is amongst the patterns of any of the accepted values.\n+ * The accepted patterns are represented as a \"long\" integer. The\n+ * check is done using four bitwise operations only.\n@@ -49,1 +61,1 @@\n-struct hb_set_digest_lowest_bits_t\n+struct hb_set_digest_bits_pattern_t\n@@ -90,0 +102,2 @@\n+  void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }\n+  template <typename T>\n@@ -99,0 +113,2 @@\n+  template <typename T>\n+  bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }\n@@ -101,1 +117,1 @@\n-  { return !!(mask & mask_for (g)); }\n+  { return mask & mask_for (g); }\n@@ -138,0 +154,2 @@\n+  void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }\n+  template <typename T>\n@@ -144,0 +162,2 @@\n+  template <typename T>\n+  bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }\n@@ -163,3 +183,1 @@\n-typedef hb_set_digest_combiner_t\n-<\n-  hb_set_digest_lowest_bits_t<unsigned long, 4>,\n+using hb_set_digest_t =\n@@ -168,2 +186,6 @@\n-    hb_set_digest_lowest_bits_t<unsigned long, 0>,\n-    hb_set_digest_lowest_bits_t<unsigned long, 9>\n+    hb_set_digest_bits_pattern_t<unsigned long, 4>,\n+    hb_set_digest_combiner_t\n+    <\n+      hb_set_digest_bits_pattern_t<unsigned long, 0>,\n+      hb_set_digest_bits_pattern_t<unsigned long, 9>\n+    >\n@@ -171,1 +193,1 @@\n-> hb_set_digest_t;\n+;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set-digest.hh","additions":34,"deletions":12,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * hb_set_create: (Xconstructor)\n+ * hb_set_create:\n@@ -112,1 +112,1 @@\n-  free (set);\n+  hb_free (set);\n@@ -172,1 +172,20 @@\n-  return set->successful;\n+  return !set->in_error ();\n+}\n+\n+\/**\n+ * hb_set_copy:\n+ * @set: A set\n+ *\n+ * Allocate a copy of @set.\n+ *\n+ * Return value: Newly-allocated set.\n+ *\n+ * Since: 2.8.2\n+ **\/\n+hb_set_t *\n+hb_set_copy (const hb_set_t *set)\n+{\n+  hb_set_t *copy = hb_set_create ();\n+  if (unlikely (!copy)) return nullptr;\n+  copy->set (*set);\n+  return copy;\n@@ -186,3 +205,1 @@\n-  if (unlikely (hb_object_is_immutable (set)))\n-    return;\n-\n+  \/* Immutible-safe. *\/\n@@ -239,0 +256,1 @@\n+  \/* Immutible-safe. *\/\n@@ -242,0 +260,23 @@\n+\/**\n+ * hb_set_add_sorted_array:\n+ * @set: A set\n+ * @sorted_codepoints: (array length=num_codepoints): Array of codepoints to add\n+ * @num_codepoints: Length of @sorted_codepoints\n+ *\n+ * Adds @num_codepoints codepoints to a set at once.\n+ * The codepoints array must be in increasing order,\n+ * with size at least @num_codepoints.\n+ *\n+ * Since: 4.1.0\n+ *\/\n+HB_EXTERN void\n+hb_set_add_sorted_array (hb_set_t             *set,\n+                         const hb_codepoint_t *sorted_codepoints,\n+                         unsigned int          num_codepoints)\n+{\n+  \/* Immutible-safe. *\/\n+  set->add_sorted_array (sorted_codepoints,\n+                         num_codepoints,\n+                         sizeof(hb_codepoint_t));\n+}\n+\n@@ -258,0 +299,1 @@\n+  \/* Immutible-safe. *\/\n@@ -274,0 +316,1 @@\n+  \/* Immutible-safe. *\/\n@@ -286,0 +329,3 @@\n+ * If @last is #HB_SET_VALUE_INVALID, then all values\n+ * greater than or equal to @first are removed.\n+ *\n@@ -293,0 +339,1 @@\n+  \/* Immutible-safe. *\/\n@@ -312,1 +359,18 @@\n-  return set->is_equal (other);\n+  return set->is_equal (*other);\n+}\n+\n+\/**\n+ * hb_set_hash:\n+ * @set: A set\n+ *\n+ * Creates a hash representing @set.\n+ *\n+ * Return value:\n+ * A hash of @set.\n+ *\n+ * Since: 4.4.0\n+ **\/\n+HB_EXTERN unsigned int\n+hb_set_hash (const hb_set_t *set)\n+{\n+  return set->hash ();\n@@ -330,1 +394,1 @@\n-  return set->is_subset (larger_set);\n+  return set->is_subset (*larger_set);\n@@ -346,1 +410,2 @@\n-  set->set (other);\n+  \/* Immutible-safe. *\/\n+  set->set (*other);\n@@ -362,1 +427,2 @@\n-  set->union_ (other);\n+  \/* Immutible-safe. *\/\n+  set->union_ (*other);\n@@ -378,1 +444,2 @@\n-  set->intersect (other);\n+  \/* Immutible-safe. *\/\n+  set->intersect (*other);\n@@ -394,1 +461,2 @@\n-  set->subtract (other);\n+  \/* Immutible-safe. *\/\n+  set->subtract (*other);\n@@ -411,1 +479,2 @@\n-  set->symmetric_difference (other);\n+  \/* Immutible-safe. *\/\n+  set->symmetric_difference (*other);\n@@ -414,1 +483,0 @@\n-#ifndef HB_DISABLE_DEPRECATED\n@@ -421,3 +489,1 @@\n- * Since: 0.9.10\n- *\n- * Deprecated: 1.6.1\n+ * Since: 3.0.0\n@@ -426,1 +492,1 @@\n-hb_set_invert (hb_set_t *set HB_UNUSED)\n+hb_set_invert (hb_set_t *set)\n@@ -428,0 +494,2 @@\n+  \/* Immutible-safe. *\/\n+  set->invert ();\n@@ -429,1 +497,0 @@\n-#endif\n@@ -568,0 +635,25 @@\n+\n+\/**\n+ * hb_set_next_many:\n+ * @set: A set\n+ * @codepoint: Outputting codepoints starting after this one.\n+ *             Use #HB_SET_VALUE_INVALID to get started.\n+ * @out: (array length=size): An array of codepoints to write to.\n+ * @size: The maximum number of codepoints to write out.\n+ *\n+ * Finds the next element in @set that is greater than @codepoint. Writes out\n+ * codepoints to @out, until either the set runs out of elements, or @size\n+ * codepoints are written, whichever comes first.\n+ *\n+ * Return value: the number of values written.\n+ *\n+ * Since: 4.2.0\n+ **\/\n+unsigned int\n+hb_set_next_many (const hb_set_t *set,\n+                  hb_codepoint_t  codepoint,\n+                  hb_codepoint_t *out,\n+                  unsigned int    size)\n+{\n+  return set->next_many (codepoint, out, size);\n+}\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set.cc","additions":111,"deletions":19,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+HB_EXTERN hb_set_t *\n+hb_set_copy (const hb_set_t *set);\n+\n@@ -94,0 +97,3 @@\n+HB_EXTERN void\n+hb_set_invert (hb_set_t *set);\n+\n@@ -107,0 +113,5 @@\n+HB_EXTERN void\n+hb_set_add_sorted_array (hb_set_t             *set,\n+                         const hb_codepoint_t *sorted_codepoints,\n+                         unsigned int          num_codepoints);\n+\n@@ -120,0 +131,3 @@\n+HB_EXTERN unsigned int\n+hb_set_hash (const hb_set_t *set);\n+\n@@ -177,0 +191,6 @@\n+\/* Pass HB_SET_VALUE_INVALID in to get started. *\/\n+HB_EXTERN unsigned int\n+hb_set_next_many (const hb_set_t *set,\n+                  hb_codepoint_t  codepoint,\n+                  hb_codepoint_t *out,\n+                  unsigned int    size);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set.h","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright  2021 Behdad Esfahbod\n@@ -31,1 +32,1 @@\n-#include \"hb-machinery.hh\"\n+#include \"hb-bit-set-invertible.hh\"\n@@ -34,8 +35,2 @@\n-\/*\n- * hb_set_t\n- *\/\n-\n-\/* TODO Keep a free-list so we can free pages that are completely zeroed.  At that\n- * point maybe also use a sentinel value for \"all-1\" pages? *\/\n-\n-struct hb_set_t\n+template <typename impl_t>\n+struct hb_sparseset_t\n@@ -43,3 +38,2 @@\n-  HB_DELETE_COPY_ASSIGN (hb_set_t);\n-  hb_set_t ()  { init (); }\n-  ~hb_set_t () { fini (); }\n+  hb_object_header_t header;\n+  impl_t s;\n@@ -47,3 +41,2 @@\n-  struct page_map_t\n-  {\n-    int cmp (const page_map_t &o) const { return (int) o.major - (int) major; }\n+  hb_sparseset_t () { init (); }\n+  ~hb_sparseset_t () { fini (); }\n@@ -51,3 +44,5 @@\n-    uint32_t major;\n-    uint32_t index;\n-  };\n+  hb_sparseset_t (const hb_sparseset_t& other) : hb_sparseset_t () { set (other); }\n+  hb_sparseset_t (hb_sparseset_t&& other) : hb_sparseset_t () { s = std::move (other.s); }\n+  hb_sparseset_t& operator = (const hb_sparseset_t& other) { set (other); return *this; }\n+  hb_sparseset_t& operator = (hb_sparseset_t&& other) { s = std::move (other.s); return *this; }\n+  friend void swap (hb_sparseset_t& a, hb_sparseset_t& b) { hb_swap (a.s, b.s); }\n@@ -55,1 +50,1 @@\n-  struct page_t\n+  hb_sparseset_t (std::initializer_list<hb_codepoint_t> lst) : hb_sparseset_t ()\n@@ -57,163 +52,6 @@\n-    void init0 () { v.clear (); }\n-    void init1 () { v.clear (0xFF); }\n-\n-    unsigned int len () const\n-    { return ARRAY_LENGTH_CONST (v); }\n-\n-    bool is_empty () const\n-    {\n-      for (unsigned int i = 0; i < len (); i++)\n-        if (v[i])\n-          return false;\n-      return true;\n-    }\n-\n-    void add (hb_codepoint_t g) { elt (g) |= mask (g); }\n-    void del (hb_codepoint_t g) { elt (g) &= ~mask (g); }\n-    bool get (hb_codepoint_t g) const { return elt (g) & mask (g); }\n-\n-    void add_range (hb_codepoint_t a, hb_codepoint_t b)\n-    {\n-      elt_t *la = &elt (a);\n-      elt_t *lb = &elt (b);\n-      if (la == lb)\n-        *la |= (mask (b) << 1) - mask(a);\n-      else\n-      {\n-        *la |= ~(mask (a) - 1);\n-        la++;\n-\n-        memset (la, 0xff, (char *) lb - (char *) la);\n-\n-        *lb |= ((mask (b) << 1) - 1);\n-      }\n-    }\n-\n-    void del_range (hb_codepoint_t a, hb_codepoint_t b)\n-    {\n-      elt_t *la = &elt (a);\n-      elt_t *lb = &elt (b);\n-      if (la == lb)\n-        *la &= ~((mask (b) << 1) - mask(a));\n-      else\n-      {\n-        *la &= mask (a) - 1;\n-        la++;\n-\n-        memset (la, 0, (char *) lb - (char *) la);\n-\n-        *lb &= ~((mask (b) << 1) - 1);\n-      }\n-    }\n-\n-    bool is_equal (const page_t *other) const\n-    {\n-      return 0 == hb_memcmp (&v, &other->v, sizeof (v));\n-    }\n-\n-    unsigned int get_population () const\n-    {\n-      unsigned int pop = 0;\n-      for (unsigned int i = 0; i < len (); i++)\n-        pop += hb_popcount (v[i]);\n-      return pop;\n-    }\n-\n-    bool next (hb_codepoint_t *codepoint) const\n-    {\n-      unsigned int m = (*codepoint + 1) & MASK;\n-      if (!m)\n-      {\n-        *codepoint = INVALID;\n-        return false;\n-      }\n-      unsigned int i = m \/ ELT_BITS;\n-      unsigned int j = m & ELT_MASK;\n-\n-      const elt_t vv = v[i] & ~((elt_t (1) << j) - 1);\n-      for (const elt_t *p = &vv; i < len (); p = &v[++i])\n-        if (*p)\n-        {\n-          *codepoint = i * ELT_BITS + elt_get_min (*p);\n-          return true;\n-        }\n-\n-      *codepoint = INVALID;\n-      return false;\n-    }\n-    bool previous (hb_codepoint_t *codepoint) const\n-    {\n-      unsigned int m = (*codepoint - 1) & MASK;\n-      if (m == MASK)\n-      {\n-        *codepoint = INVALID;\n-        return false;\n-      }\n-      unsigned int i = m \/ ELT_BITS;\n-      unsigned int j = m & ELT_MASK;\n-\n-      \/* Fancy mask to avoid shifting by elt_t bitsize, which is undefined. *\/\n-      const elt_t mask = j < 8 * sizeof (elt_t) - 1 ?\n-                         ((elt_t (1) << (j + 1)) - 1) :\n-                         (elt_t) -1;\n-      const elt_t vv = v[i] & mask;\n-      const elt_t *p = &vv;\n-      while (true)\n-      {\n-        if (*p)\n-        {\n-          *codepoint = i * ELT_BITS + elt_get_max (*p);\n-          return true;\n-        }\n-        if ((int) i <= 0) break;\n-        p = &v[--i];\n-      }\n-\n-      *codepoint = INVALID;\n-      return false;\n-    }\n-    hb_codepoint_t get_min () const\n-    {\n-      for (unsigned int i = 0; i < len (); i++)\n-        if (v[i])\n-          return i * ELT_BITS + elt_get_min (v[i]);\n-      return INVALID;\n-    }\n-    hb_codepoint_t get_max () const\n-    {\n-      for (int i = len () - 1; i >= 0; i--)\n-        if (v[i])\n-          return i * ELT_BITS + elt_get_max (v[i]);\n-      return 0;\n-    }\n-\n-    typedef unsigned long long elt_t;\n-    static constexpr unsigned PAGE_BITS = 512;\n-    static_assert ((PAGE_BITS & ((PAGE_BITS) - 1)) == 0, \"\");\n-\n-    static unsigned int elt_get_min (const elt_t &elt) { return hb_ctz (elt); }\n-    static unsigned int elt_get_max (const elt_t &elt) { return hb_bit_storage (elt) - 1; }\n-\n-    typedef hb_vector_size_t<elt_t, PAGE_BITS \/ 8> vector_t;\n-\n-    static constexpr unsigned ELT_BITS = sizeof (elt_t) * 8;\n-    static constexpr unsigned ELT_MASK = ELT_BITS - 1;\n-    static constexpr unsigned BITS = sizeof (vector_t) * 8;\n-    static constexpr unsigned MASK = BITS - 1;\n-    static_assert ((unsigned) PAGE_BITS == (unsigned) BITS, \"\");\n-\n-    elt_t &elt (hb_codepoint_t g) { return v[(g & MASK) \/ ELT_BITS]; }\n-    elt_t const &elt (hb_codepoint_t g) const { return v[(g & MASK) \/ ELT_BITS]; }\n-    elt_t mask (hb_codepoint_t g) const { return elt_t (1) << (g & ELT_MASK); }\n-\n-    vector_t v;\n-  };\n-  static_assert (page_t::PAGE_BITS == sizeof (page_t) * 8, \"\");\n-\n-  hb_object_header_t header;\n-  bool successful; \/* Allocations successful *\/\n-  mutable unsigned int population;\n-  hb_sorted_vector_t<page_map_t> page_map;\n-  hb_vector_t<page_t> pages;\n-\n-  void init_shallow ()\n+    for (auto&& item : lst)\n+      add (item);\n+  }\n+  template <typename Iterable,\n+           hb_requires (hb_is_iterable (Iterable))>\n+  hb_sparseset_t (const Iterable &o) : hb_sparseset_t ()\n@@ -221,4 +59,1 @@\n-    successful = true;\n-    population = 0;\n-    page_map.init ();\n-    pages.init ();\n+    hb_copy (o, *this);\n@@ -226,0 +61,2 @@\n+\n+  void init_shallow () { s.init (); }\n@@ -231,6 +68,1 @@\n-  void fini_shallow ()\n-  {\n-    population = 0;\n-    page_map.fini ();\n-    pages.fini ();\n-  }\n+  void fini_shallow () { s.fini (); }\n@@ -243,33 +75,0 @@\n-  bool in_error () const { return !successful; }\n-\n-  bool resize (unsigned int count)\n-  {\n-    if (unlikely (count > pages.length && !successful)) return false;\n-    if (!pages.resize (count) || !page_map.resize (count))\n-    {\n-      pages.resize (page_map.length);\n-      successful = false;\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  void reset ()\n-  {\n-    successful = true;\n-    clear ();\n-  }\n-\n-  void clear ()\n-  {\n-    if (resize (0))\n-      population = 0;\n-  }\n-  bool is_empty () const\n-  {\n-    unsigned int count = pages.length;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (!pages[i].is_empty ())\n-        return false;\n-    return true;\n-  }\n@@ -278,1 +77,2 @@\n-  void dirty () { population = UINT_MAX; }\n+  void err () { s.err (); }\n+  bool in_error () const { return s.in_error (); }\n@@ -280,36 +80,9 @@\n-  void add (hb_codepoint_t g)\n-  {\n-    if (unlikely (!successful)) return;\n-    if (unlikely (g == INVALID)) return;\n-    dirty ();\n-    page_t *page = page_for_insert (g); if (unlikely (!page)) return;\n-    page->add (g);\n-  }\n-  bool add_range (hb_codepoint_t a, hb_codepoint_t b)\n-  {\n-    if (unlikely (!successful)) return true; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/657 *\/\n-    if (unlikely (a > b || a == INVALID || b == INVALID)) return false;\n-    dirty ();\n-    unsigned int ma = get_major (a);\n-    unsigned int mb = get_major (b);\n-    if (ma == mb)\n-    {\n-      page_t *page = page_for_insert (a); if (unlikely (!page)) return false;\n-      page->add_range (a, b);\n-    }\n-    else\n-    {\n-      page_t *page = page_for_insert (a); if (unlikely (!page)) return false;\n-      page->add_range (a, major_start (ma + 1) - 1);\n-\n-      for (unsigned int m = ma + 1; m < mb; m++)\n-      {\n-        page = page_for_insert (major_start (m)); if (unlikely (!page)) return false;\n-        page->init1 ();\n-      }\n-\n-      page = page_for_insert (b); if (unlikely (!page)) return false;\n-      page->add_range (major_start (mb), b);\n-    }\n-    return true;\n-  }\n+  void alloc (unsigned sz) { s.alloc (sz); }\n+  void reset () { s.reset (); }\n+  void clear () { s.clear (); }\n+  void invert () { s.invert (); }\n+  bool is_empty () const { return s.is_empty (); }\n+  uint32_t hash () const { return s.hash (); }\n+\n+  void add (hb_codepoint_t g) { s.add (g); }\n+  bool add_range (hb_codepoint_t a, hb_codepoint_t b) { return s.add_range (a, b); }\n@@ -319,21 +92,3 @@\n-  {\n-    if (unlikely (!successful)) return;\n-    if (!count) return;\n-    dirty ();\n-    hb_codepoint_t g = *array;\n-    while (count)\n-    {\n-      unsigned int m = get_major (g);\n-      page_t *page = page_for_insert (g); if (unlikely (!page)) return;\n-      unsigned int start = major_start (m);\n-      unsigned int end = major_start (m + 1);\n-      do\n-      {\n-        page->add (g);\n-\n-        array = &StructAtOffsetUnaligned<T> (array, stride);\n-        count--;\n-      }\n-      while (count && (g = *array, start <= g && g < end));\n-    }\n-  }\n+  { s.add_array (array, count, stride); }\n+  template <typename T>\n+  void add_array (const hb_array_t<const T>& arr) { add_array (&arr, arr.len ()); }\n@@ -345,37 +100,3 @@\n-  {\n-    if (unlikely (!successful)) return true; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/657 *\/\n-    if (!count) return true;\n-    dirty ();\n-    hb_codepoint_t g = *array;\n-    hb_codepoint_t last_g = g;\n-    while (count)\n-    {\n-      unsigned int m = get_major (g);\n-      page_t *page = page_for_insert (g); if (unlikely (!page)) return false;\n-      unsigned int end = major_start (m + 1);\n-      do\n-      {\n-        \/* If we try harder we can change the following comparison to <=;\n-         * Not sure if it's worth it. *\/\n-        if (g < last_g) return false;\n-        last_g = g;\n-        page->add (g);\n-\n-        array = (const T *) ((const char *) array + stride);\n-        count--;\n-      }\n-      while (count && (g = *array, g < end));\n-    }\n-    return true;\n-  }\n-\n-  void del (hb_codepoint_t g)\n-  {\n-    \/* TODO perform op even if !successful. *\/\n-    if (unlikely (!successful)) return;\n-    page_t *page = page_for (g);\n-    if (!page)\n-      return;\n-    dirty ();\n-    page->del (g);\n-  }\n+  { return s.add_sorted_array (array, count, stride); }\n+  template <typename T>\n+  bool add_sorted_array (const hb_sorted_array_t<const T>& arr) { return add_sorted_array (&arr, arr.len ()); }\n@@ -383,21 +104,2 @@\n-  private:\n-  void del_pages (int ds, int de)\n-  {\n-    if (ds <= de)\n-    {\n-      \/\/ Pre-allocate the workspace that compact() will need so we can bail on allocation failure\n-      \/\/ before attempting to rewrite the page map.\n-      hb_vector_t<unsigned> compact_workspace;\n-      if (unlikely (!allocate_compact_workspace (compact_workspace))) return;\n-\n-      unsigned int write_index = 0;\n-      for (unsigned int i = 0; i < page_map.length; i++)\n-      {\n-        int m = (int) page_map[i].major;\n-        if (m < ds || de < m)\n-          page_map[write_index++] = page_map[i];\n-      }\n-      compact (compact_workspace, write_index);\n-      resize (write_index);\n-    }\n-  }\n+  void del (hb_codepoint_t g) { s.del (g); }\n+  void del_range (hb_codepoint_t a, hb_codepoint_t b) { s.del_range (a, b); }\n@@ -405,40 +107,1 @@\n-\n-  public:\n-  void del_range (hb_codepoint_t a, hb_codepoint_t b)\n-  {\n-    \/* TODO perform op even if !successful. *\/\n-    if (unlikely (!successful)) return;\n-    if (unlikely (a > b || a == INVALID || b == INVALID)) return;\n-    dirty ();\n-    unsigned int ma = get_major (a);\n-    unsigned int mb = get_major (b);\n-    \/* Delete pages from ds through de if ds <= de. *\/\n-    int ds = (a == major_start (ma))? (int) ma: (int) (ma + 1);\n-    int de = (b + 1 == major_start (mb + 1))? (int) mb: ((int) mb - 1);\n-    if (ds > de || (int) ma < ds)\n-    {\n-      page_t *page = page_for (a);\n-      if (page)\n-      {\n-        if (ma == mb)\n-          page->del_range (a, b);\n-        else\n-          page->del_range (a, major_start (ma + 1) - 1);\n-      }\n-    }\n-    if (de < (int) mb && ma != mb)\n-    {\n-      page_t *page = page_for (b);\n-      if (page)\n-        page->del_range (major_start (mb), b);\n-    }\n-    del_pages (ds, de);\n-  }\n-\n-  bool get (hb_codepoint_t g) const\n-  {\n-    const page_t *page = page_for (g);\n-    if (!page)\n-      return false;\n-    return page->get (g);\n-  }\n+  bool get (hb_codepoint_t g) const { return s.get (g); }\n@@ -451,0 +114,1 @@\n+\n@@ -455,1 +119,1 @@\n-  hb_set_t& operator << (hb_codepoint_t v)\n+  hb_sparseset_t& operator << (hb_codepoint_t v)\n@@ -457,1 +121,1 @@\n-  hb_set_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)\n+  hb_sparseset_t& operator << (const hb_pair_t<hb_codepoint_t, hb_codepoint_t>& range)\n@@ -461,63 +125,1 @@\n-  {\n-    hb_codepoint_t c = first - 1;\n-    return next (&c) && c <= last;\n-  }\n-  void set (const hb_set_t *other)\n-  {\n-    if (unlikely (!successful)) return;\n-    unsigned int count = other->pages.length;\n-    if (!resize (count))\n-      return;\n-    population = other->population;\n-    memcpy ((void *) pages, (const void *) other->pages, count * pages.item_size);\n-    memcpy ((void *) page_map, (const void *) other->page_map, count * page_map.item_size);\n-  }\n-\n-  bool is_equal (const hb_set_t *other) const\n-  {\n-    if (get_population () != other->get_population ())\n-      return false;\n-\n-    unsigned int na = pages.length;\n-    unsigned int nb = other->pages.length;\n-\n-    unsigned int a = 0, b = 0;\n-    for (; a < na && b < nb; )\n-    {\n-      if (page_at (a).is_empty ()) { a++; continue; }\n-      if (other->page_at (b).is_empty ()) { b++; continue; }\n-      if (page_map[a].major != other->page_map[b].major ||\n-          !page_at (a).is_equal (&other->page_at (b)))\n-        return false;\n-      a++;\n-      b++;\n-    }\n-    for (; a < na; a++)\n-      if (!page_at (a).is_empty ()) { return false; }\n-    for (; b < nb; b++)\n-      if (!other->page_at (b).is_empty ()) { return false; }\n-\n-    return true;\n-  }\n-\n-  bool is_subset (const hb_set_t *larger_set) const\n-  {\n-    if (get_population () > larger_set->get_population ())\n-      return false;\n-\n-    \/* TODO Optimize to use pages. *\/\n-    hb_codepoint_t c = INVALID;\n-    while (next (&c))\n-      if (!larger_set->has (c))\n-        return false;\n-\n-    return true;\n-  }\n-\n-  bool allocate_compact_workspace(hb_vector_t<unsigned>& workspace)\n-  {\n-    if (unlikely(!workspace.resize (pages.length)))\n-    {\n-      successful = false;\n-      return false;\n-    }\n+  { return s.intersects (first, last); }\n@@ -525,2 +127,1 @@\n-    return true;\n-  }\n+  void set (const hb_sparseset_t &other) { s.set (other.s); }\n@@ -528,0 +129,3 @@\n+  bool is_equal (const hb_sparseset_t &other) const { return s.is_equal (other.s); }\n+  bool operator == (const hb_set_t &other) const { return is_equal (other); }\n+  bool operator != (const hb_set_t &other) const { return !is_equal (other); }\n@@ -529,9 +133,1 @@\n-  \/*\n-   * workspace should be a pre-sized vector allocated to hold at exactly pages.length\n-   * elements.\n-   *\/\n-  void compact (hb_vector_t<unsigned>& workspace,\n-                unsigned int length)\n-  {\n-    assert(workspace.length == pages.length);\n-    hb_vector_t<unsigned>& old_index_to_page_map_index = workspace;\n+  bool is_subset (const hb_sparseset_t &larger_set) const { return s.is_subset (larger_set.s); }\n@@ -539,4 +135,4 @@\n-    hb_fill (old_index_to_page_map_index.writer(), 0xFFFFFFFF);\n-    \/* TODO(iter) Rewrite as dagger? *\/\n-    for (unsigned i = 0; i < length; i++)\n-      old_index_to_page_map_index[page_map[i].index] =  i;\n+  void union_ (const hb_sparseset_t &other) { s.union_ (other.s); }\n+  void intersect (const hb_sparseset_t &other) { s.intersect (other.s); }\n+  void subtract (const hb_sparseset_t &other) { s.subtract (other.s); }\n+  void symmetric_difference (const hb_sparseset_t &other) { s.symmetric_difference (other.s); }\n@@ -544,226 +140,2 @@\n-    compact_pages (old_index_to_page_map_index);\n-  }\n-\n-  void compact_pages (const hb_vector_t<unsigned>& old_index_to_page_map_index)\n-  {\n-    unsigned int write_index = 0;\n-    for (unsigned int i = 0; i < pages.length; i++)\n-    {\n-      if (old_index_to_page_map_index[i] == 0xFFFFFFFF) continue;\n-\n-      if (write_index < i)\n-        pages[write_index] = pages[i];\n-\n-      page_map[old_index_to_page_map_index[i]].index = write_index;\n-      write_index++;\n-    }\n-  }\n-\n-  template <typename Op>\n-  void process (const Op& op, const hb_set_t *other)\n-  {\n-    const bool passthru_left = op (1, 0);\n-    const bool passthru_right = op (0, 1);\n-\n-    if (unlikely (!successful)) return;\n-\n-    dirty ();\n-\n-    unsigned int na = pages.length;\n-    unsigned int nb = other->pages.length;\n-    unsigned int next_page = na;\n-\n-    unsigned int count = 0, newCount = 0;\n-    unsigned int a = 0, b = 0;\n-    unsigned int write_index = 0;\n-\n-    \/\/ Pre-allocate the workspace that compact() will need so we can bail on allocation failure\n-    \/\/ before attempting to rewrite the page map.\n-    hb_vector_t<unsigned> compact_workspace;\n-    if (!passthru_left && unlikely (!allocate_compact_workspace (compact_workspace))) return;\n-\n-    for (; a < na && b < nb; )\n-    {\n-      if (page_map[a].major == other->page_map[b].major)\n-      {\n-        if (!passthru_left)\n-        {\n-          \/\/ Move page_map entries that we're keeping from the left side set\n-          \/\/ to the front of the page_map vector. This isn't necessary if\n-          \/\/ passthru_left is set since no left side pages will be removed\n-          \/\/ in that case.\n-          if (write_index < a)\n-            page_map[write_index] = page_map[a];\n-          write_index++;\n-        }\n-\n-        count++;\n-        a++;\n-        b++;\n-      }\n-      else if (page_map[a].major < other->page_map[b].major)\n-      {\n-        if (passthru_left)\n-          count++;\n-        a++;\n-      }\n-      else\n-      {\n-        if (passthru_right)\n-          count++;\n-        b++;\n-      }\n-    }\n-    if (passthru_left)\n-      count += na - a;\n-    if (passthru_right)\n-      count += nb - b;\n-\n-    if (!passthru_left)\n-    {\n-      na  = write_index;\n-      next_page = write_index;\n-      compact (compact_workspace, write_index);\n-    }\n-\n-    if (!resize (count))\n-      return;\n-\n-    newCount = count;\n-\n-    \/* Process in-place backward. *\/\n-    a = na;\n-    b = nb;\n-    for (; a && b; )\n-    {\n-      if (page_map[a - 1].major == other->page_map[b - 1].major)\n-      {\n-        a--;\n-        b--;\n-        count--;\n-        page_map[count] = page_map[a];\n-        page_at (count).v = op (page_at (a).v, other->page_at (b).v);\n-      }\n-      else if (page_map[a - 1].major > other->page_map[b - 1].major)\n-      {\n-        a--;\n-        if (passthru_left)\n-        {\n-          count--;\n-          page_map[count] = page_map[a];\n-        }\n-      }\n-      else\n-      {\n-        b--;\n-        if (passthru_right)\n-        {\n-          count--;\n-          page_map[count].major = other->page_map[b].major;\n-          page_map[count].index = next_page++;\n-          page_at (count).v = other->page_at (b).v;\n-        }\n-      }\n-    }\n-    if (passthru_left)\n-      while (a)\n-      {\n-        a--;\n-        count--;\n-        page_map[count] = page_map [a];\n-      }\n-    if (passthru_right)\n-      while (b)\n-      {\n-        b--;\n-        count--;\n-        page_map[count].major = other->page_map[b].major;\n-        page_map[count].index = next_page++;\n-        page_at (count).v = other->page_at (b).v;\n-      }\n-    assert (!count);\n-    if (pages.length > newCount)\n-      \/\/ This resize() doesn't need to be checked because we can't get here\n-      \/\/ if the set is currently in_error() and this only resizes downwards\n-      \/\/ which will always succeed if the set is not in_error().\n-      resize (newCount);\n-  }\n-\n-  void union_ (const hb_set_t *other)\n-  {\n-    process (hb_bitwise_or, other);\n-  }\n-  void intersect (const hb_set_t *other)\n-  {\n-    process (hb_bitwise_and, other);\n-  }\n-  void subtract (const hb_set_t *other)\n-  {\n-    process (hb_bitwise_sub, other);\n-  }\n-  void symmetric_difference (const hb_set_t *other)\n-  {\n-    process (hb_bitwise_xor, other);\n-  }\n-  bool next (hb_codepoint_t *codepoint) const\n-  {\n-    if (unlikely (*codepoint == INVALID)) {\n-      *codepoint = get_min ();\n-      return *codepoint != INVALID;\n-    }\n-\n-    page_map_t map = {get_major (*codepoint), 0};\n-    unsigned int i;\n-    page_map.bfind (map, &i, HB_BFIND_NOT_FOUND_STORE_CLOSEST);\n-    if (i < page_map.length && page_map[i].major == map.major)\n-    {\n-      if (pages[page_map[i].index].next (codepoint))\n-      {\n-        *codepoint += page_map[i].major * page_t::PAGE_BITS;\n-        return true;\n-      }\n-      i++;\n-    }\n-    for (; i < page_map.length; i++)\n-    {\n-      hb_codepoint_t m = pages[page_map[i].index].get_min ();\n-      if (m != INVALID)\n-      {\n-        *codepoint = page_map[i].major * page_t::PAGE_BITS + m;\n-        return true;\n-      }\n-    }\n-    *codepoint = INVALID;\n-    return false;\n-  }\n-  bool previous (hb_codepoint_t *codepoint) const\n-  {\n-    if (unlikely (*codepoint == INVALID)) {\n-      *codepoint = get_max ();\n-      return *codepoint != INVALID;\n-    }\n-\n-    page_map_t map = {get_major (*codepoint), 0};\n-    unsigned int i;\n-    page_map.bfind (map, &i, HB_BFIND_NOT_FOUND_STORE_CLOSEST);\n-    if (i < page_map.length && page_map[i].major == map.major)\n-    {\n-      if (pages[page_map[i].index].previous (codepoint))\n-      {\n-        *codepoint += page_map[i].major * page_t::PAGE_BITS;\n-        return true;\n-      }\n-    }\n-    i--;\n-    for (; (int) i >= 0; i--)\n-    {\n-      hb_codepoint_t m = pages[page_map[i].index].get_max ();\n-      if (m != INVALID)\n-      {\n-        *codepoint = page_map[i].major * page_t::PAGE_BITS + m;\n-        return true;\n-      }\n-    }\n-    *codepoint = INVALID;\n-    return false;\n-  }\n+  bool next (hb_codepoint_t *codepoint) const { return s.next (codepoint); }\n+  bool previous (hb_codepoint_t *codepoint) const { return s.previous (codepoint); }\n@@ -771,17 +143,1 @@\n-  {\n-    hb_codepoint_t i;\n-\n-    i = *last;\n-    if (!next (&i))\n-    {\n-      *last = *first = INVALID;\n-      return false;\n-    }\n-\n-    \/* TODO Speed up. *\/\n-    *last = *first = i;\n-    while (next (&i) && i == *last + 1)\n-      (*last)++;\n-\n-    return true;\n-  }\n+  { return s.next_range (first, last); }\n@@ -789,2 +145,3 @@\n-  {\n-    hb_codepoint_t i;\n+  { return s.previous_range (first, last); }\n+  unsigned int next_many (hb_codepoint_t codepoint, hb_codepoint_t *out, unsigned int size) const\n+  { return s.next_many (codepoint, out, size); }\n@@ -792,6 +149,3 @@\n-    i = *first;\n-    if (!previous (&i))\n-    {\n-      *last = *first = INVALID;\n-      return false;\n-    }\n+  unsigned int get_population () const { return s.get_population (); }\n+  hb_codepoint_t get_min () const { return s.get_min (); }\n+  hb_codepoint_t get_max () const { return s.get_max (); }\n@@ -799,39 +153,1 @@\n-    \/* TODO Speed up. *\/\n-    *last = *first = i;\n-    while (previous (&i) && i == *first - 1)\n-      (*first)--;\n-\n-    return true;\n-  }\n-\n-  unsigned int get_population () const\n-  {\n-    if (population != UINT_MAX)\n-      return population;\n-\n-    unsigned int pop = 0;\n-    unsigned int count = pages.length;\n-    for (unsigned int i = 0; i < count; i++)\n-      pop += pages[i].get_population ();\n-\n-    population = pop;\n-    return pop;\n-  }\n-  hb_codepoint_t get_min () const\n-  {\n-    unsigned int count = pages.length;\n-    for (unsigned int i = 0; i < count; i++)\n-      if (!page_at (i).is_empty ())\n-        return page_map[i].major * page_t::PAGE_BITS + page_at (i).get_min ();\n-    return INVALID;\n-  }\n-  hb_codepoint_t get_max () const\n-  {\n-    unsigned int count = pages.length;\n-    for (int i = count - 1; i >= 0; i++)\n-      if (!page_at (i).is_empty ())\n-        return page_map[(unsigned) i].major * page_t::PAGE_BITS + page_at (i).get_max ();\n-    return INVALID;\n-  }\n-\n-  static constexpr hb_codepoint_t INVALID = HB_SET_VALUE_INVALID;\n+  static constexpr hb_codepoint_t INVALID = impl_t::INVALID;\n@@ -842,29 +158,2 @@\n-  struct iter_t : hb_iter_with_fallback_t<iter_t, hb_codepoint_t>\n-  {\n-    static constexpr bool is_sorted_iterator = true;\n-    iter_t (const hb_set_t &s_ = Null (hb_set_t),\n-            bool init = true) : s (&s_), v (INVALID), l(0)\n-    {\n-      if (init)\n-      {\n-        l = s->get_population () + 1;\n-        __next__ ();\n-      }\n-    }\n-\n-    typedef hb_codepoint_t __item_t__;\n-    hb_codepoint_t __item__ () const { return v; }\n-    bool __more__ () const { return v != INVALID; }\n-    void __next__ () { s->next (&v); if (l) l--; }\n-    void __prev__ () { s->previous (&v); }\n-    unsigned __len__ () const { return l; }\n-    iter_t end () const { return iter_t (*s, false); }\n-    bool operator != (const iter_t& o) const\n-    { return s != o.s || v != o.v; }\n-\n-    protected:\n-    const hb_set_t *s;\n-    hb_codepoint_t v;\n-    unsigned l;\n-  };\n-  iter_t iter () const { return iter_t (*this); }\n+  using iter_t = typename impl_t::iter_t;\n+  iter_t iter () const { return iter_t (this->s); }\n@@ -872,0 +161,1 @@\n+};\n@@ -873,39 +163,14 @@\n-  protected:\n-\n-  page_t *page_for_insert (hb_codepoint_t g)\n-  {\n-    page_map_t map = {get_major (g), pages.length};\n-    unsigned int i;\n-    if (!page_map.bfind (map, &i, HB_BFIND_NOT_FOUND_STORE_CLOSEST))\n-    {\n-      if (!resize (pages.length + 1))\n-        return nullptr;\n-\n-      pages[map.index].init0 ();\n-      memmove (page_map + i + 1,\n-               page_map + i,\n-               (page_map.length - 1 - i) * page_map.item_size);\n-      page_map[i] = map;\n-    }\n-    return &pages[page_map[i].index];\n-  }\n-  page_t *page_for (hb_codepoint_t g)\n-  {\n-    page_map_t key = {get_major (g)};\n-    const page_map_t *found = page_map.bsearch (key);\n-    if (found)\n-      return &pages[found->index];\n-    return nullptr;\n-  }\n-  const page_t *page_for (hb_codepoint_t g) const\n-  {\n-    page_map_t key = {get_major (g)};\n-    const page_map_t *found = page_map.bsearch (key);\n-    if (found)\n-      return &pages[found->index];\n-    return nullptr;\n-  }\n-  page_t &page_at (unsigned int i) { return pages[page_map[i].index]; }\n-  const page_t &page_at (unsigned int i) const { return pages[page_map[i].index]; }\n-  unsigned int get_major (hb_codepoint_t g) const { return g \/ page_t::PAGE_BITS; }\n-  hb_codepoint_t major_start (unsigned int major) const { return major * page_t::PAGE_BITS; }\n+struct hb_set_t : hb_sparseset_t<hb_bit_set_invertible_t>\n+{\n+  using sparseset = hb_sparseset_t<hb_bit_set_invertible_t>;\n+\n+  ~hb_set_t () = default;\n+  hb_set_t () : sparseset () {};\n+  hb_set_t (const hb_set_t &o) : sparseset ((sparseset &) o) {};\n+  hb_set_t (hb_set_t&& o) : sparseset (std::move ((sparseset &) o)) {}\n+  hb_set_t& operator = (const hb_set_t&) = default;\n+  hb_set_t& operator = (hb_set_t&&) = default;\n+  hb_set_t (std::initializer_list<hb_codepoint_t> lst) : sparseset (lst) {}\n+  template <typename Iterable,\n+            hb_requires (hb_is_iterable (Iterable))>\n+  hb_set_t (const Iterable &o) : sparseset (o) {}\n@@ -914,0 +179,2 @@\n+static_assert (hb_set_t::INVALID == HB_SET_VALUE_INVALID, \"\");\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set.hh","additions":86,"deletions":819,"binary":false,"changes":905,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  if (copy && num_user_features && !(features = (hb_feature_t *) calloc (num_user_features, sizeof (hb_feature_t))))\n+  if (copy && num_user_features && !(features = (hb_feature_t *) hb_calloc (num_user_features, sizeof (hb_feature_t))))\n@@ -133,1 +133,1 @@\n-  ::free (features);\n+  ::hb_free (features);\n@@ -173,1 +173,1 @@\n- * hb_shape_plan_create: (Xconstructor)\n+ * hb_shape_plan_create:\n@@ -201,1 +201,1 @@\n- * hb_shape_plan_create2: (Xconstructor)\n+ * hb_shape_plan_create2:\n@@ -234,1 +234,2 @@\n-  assert (props->direction != HB_DIRECTION_INVALID);\n+  if (unlikely (props->direction == HB_DIRECTION_INVALID))\n+    return hb_shape_plan_get_empty ();\n@@ -267,1 +268,1 @@\n-  shape_plan->key.free ();\n+  shape_plan->key.fini ();\n@@ -269,1 +270,1 @@\n-  free (shape_plan);\n+  hb_free (shape_plan);\n@@ -323,2 +324,2 @@\n-  shape_plan->key.free ();\n-  free (shape_plan);\n+  shape_plan->key.fini ();\n+  hb_free (shape_plan);\n@@ -407,1 +408,1 @@\n-  if (unlikely (hb_object_is_inert (shape_plan)))\n+  if (unlikely (!hb_object_is_valid (shape_plan)))\n@@ -532,1 +533,1 @@\n-  bool dont_cache = hb_object_is_inert (face);\n+  bool dont_cache = !hb_object_is_valid (face);\n@@ -563,1 +564,1 @@\n-  hb_face_t::plan_node_t *node = (hb_face_t::plan_node_t *) calloc (1, sizeof (hb_face_t::plan_node_t));\n+  hb_face_t::plan_node_t *node = (hb_face_t::plan_node_t *) hb_calloc (1, sizeof (hb_face_t::plan_node_t));\n@@ -573,1 +574,1 @@\n-    free (node);\n+    hb_free (node);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape-plan.cc","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  HB_INTERNAL void free () { ::free ((void *) user_features); }\n+  HB_INTERNAL void fini () { hb_free ((void *) user_features); }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape-plan.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,3 +51,1 @@\n-#if HB_USE_ATEXIT\n-static void free_static_shaper_list ();\n-#endif\n+static inline void free_static_shaper_list ();\n@@ -55,1 +53,1 @@\n-static const char *nil_shaper_list[] = {nullptr};\n+static const char * const nil_shaper_list[] = {nullptr};\n@@ -62,1 +60,1 @@\n-    const char **shaper_list = (const char **) calloc (1 + HB_SHAPERS_COUNT, sizeof (const char *));\n+    const char **shaper_list = (const char **) hb_calloc (1 + HB_SHAPERS_COUNT, sizeof (const char *));\n@@ -72,3 +70,1 @@\n-#if HB_USE_ATEXIT\n-    atexit (free_static_shaper_list);\n-#endif\n+    hb_atexit (free_static_shaper_list);\n@@ -79,2 +75,2 @@\n-  { free (l); }\n-  static const char ** get_null ()\n+  { hb_free (l); }\n+  static const char * const * get_null ()\n@@ -84,2 +80,1 @@\n-#if HB_USE_ATEXIT\n-static\n+static inline\n@@ -90,1 +85,0 @@\n-#endif\n@@ -135,0 +129,12 @@\n+  if (unlikely (!buffer->len))\n+    return true;\n+\n+  buffer->enter ();\n+\n+  hb_buffer_t *text_buffer = nullptr;\n+  if (buffer->flags & HB_BUFFER_FLAG_VERIFY)\n+  {\n+    text_buffer = hb_buffer_create ();\n+    hb_buffer_append (text_buffer, buffer, 0, -1);\n+  }\n+\n@@ -139,0 +145,1 @@\n+\n@@ -140,0 +147,4 @@\n+\n+  if (buffer->max_ops <= 0)\n+    buffer->shaping_failed = true;\n+\n@@ -142,0 +153,15 @@\n+  if (text_buffer)\n+  {\n+    if (res && buffer->successful && !buffer->shaping_failed\n+            && text_buffer->successful\n+            && !buffer->verify (text_buffer,\n+                                font,\n+                                features,\n+                                num_features,\n+                                shaper_list))\n+      res = false;\n+    hb_buffer_destroy (text_buffer);\n+  }\n+\n+  buffer->leave ();\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape.cc","additions":39,"deletions":13,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-static const hb_shaper_entry_t all_shapers[] = {\n+static const hb_shaper_entry_t _hb_all_shapers[] = {\n@@ -38,1 +38,1 @@\n-static_assert (0 != ARRAY_LENGTH_CONST (all_shapers), \"No shaper enabled.\");\n+static_assert (0 != ARRAY_LENGTH_CONST (_hb_all_shapers), \"No shaper enabled.\");\n@@ -41,3 +41,1 @@\n-#if HB_USE_ATEXIT\n-static void free_static_shapers ();\n-#endif\n+static inline void free_static_shapers ();\n@@ -45,1 +43,1 @@\n-static struct hb_shapers_lazy_loader_t : hb_lazy_loader_t<const hb_shaper_entry_t,\n+static struct hb_shapers_lazy_loader_t : hb_lazy_loader_t<hb_shaper_entry_t,\n@@ -54,1 +52,1 @@\n-    hb_shaper_entry_t *shapers = (hb_shaper_entry_t *) calloc (1, sizeof (all_shapers));\n+    hb_shaper_entry_t *shapers = (hb_shaper_entry_t *) hb_calloc (1, sizeof (_hb_all_shapers));\n@@ -58,1 +56,1 @@\n-    memcpy (shapers, all_shapers, sizeof (all_shapers));\n+    memcpy (shapers, _hb_all_shapers, sizeof (_hb_all_shapers));\n@@ -69,1 +67,1 @@\n-      for (unsigned int j = i; j < ARRAY_LENGTH (all_shapers); j++)\n+      for (unsigned int j = i; j < ARRAY_LENGTH (_hb_all_shapers); j++)\n@@ -86,3 +84,1 @@\n-#if HB_USE_ATEXIT\n-    atexit (free_static_shapers);\n-#endif\n+    hb_atexit (free_static_shapers);\n@@ -92,2 +88,2 @@\n-  static void destroy (const hb_shaper_entry_t *p) { free ((void *) p); }\n-  static const hb_shaper_entry_t *get_null ()      { return all_shapers; }\n+  static void destroy (hb_shaper_entry_t *p) { hb_free (p); }\n+  static const hb_shaper_entry_t *get_null ()      { return _hb_all_shapers; }\n@@ -96,2 +92,1 @@\n-#if HB_USE_ATEXIT\n-static\n+static inline\n@@ -102,1 +97,0 @@\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shaper.cc","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"hb-ot-glyf-table.hh\"\n@@ -46,0 +47,1 @@\n+DEFINE_NULL_NAMESPACE_BYTES (OT, VarIdx) =  {0xFF,0xFF,0xFF,0xFF};\n@@ -54,0 +56,3 @@\n+\/* hb_map_t *\/\n+\n+const hb_codepoint_t minus_1 = -1;\n@@ -57,0 +62,25 @@\n+#ifndef HB_NO_BORING_EXPANSION\n+static inline unsigned\n+load_num_glyphs_from_loca (const hb_face_t *face)\n+{\n+  unsigned ret = 0;\n+\n+  unsigned indexToLocFormat = face->table.head->indexToLocFormat;\n+\n+  if (indexToLocFormat <= 1)\n+  {\n+    bool short_offset = 0 == indexToLocFormat;\n+    hb_blob_t *loca_blob = face->table.loca.get_blob ();\n+    ret = hb_max (1u, loca_blob->length \/ (short_offset ? 2 : 4)) - 1;\n+  }\n+\n+  return ret;\n+}\n+#endif\n+\n+static inline unsigned\n+load_num_glyphs_from_maxp (const hb_face_t *face)\n+{\n+  return face->table.maxp->get_num_glyphs ();\n+}\n+\n@@ -60,4 +90,7 @@\n-  hb_sanitize_context_t c = hb_sanitize_context_t ();\n-  c.set_num_glyphs (0); \/* So we don't recurse ad infinitum. *\/\n-  hb_blob_t *maxp_blob = c.reference_table<OT::maxp> (this);\n-  const OT::maxp *maxp_table = maxp_blob->as<OT::maxp> ();\n+  unsigned ret = 0;\n+\n+#ifndef HB_NO_BORING_EXPANSION\n+  ret = hb_max (ret, load_num_glyphs_from_loca (this));\n+#endif\n+\n+  ret = hb_max (ret, load_num_glyphs_from_maxp (this));\n@@ -65,1 +98,0 @@\n-  unsigned int ret = maxp_table->get_num_glyphs ();\n@@ -67,1 +99,0 @@\n-  hb_blob_destroy (maxp_blob);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-static.cc","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#ifdef HB_EXPERIMENTAL_API\n@@ -39,17 +38,4 @@\n- * hb_style_tag_t:\n- * @HB_STYLE_TAG_ITALIC: Used to vary between non-italic and italic.\n- * A value of 0 can be interpreted as \"Roman\" (non-italic); a value of 1 can\n- * be interpreted as (fully) italic.\n- * @HB_STYLE_TAG_OPTICAL_SIZE: Used to vary design to suit different text sizes.\n- * Non-zero. Values can be interpreted as text size, in points.\n- * @HB_STYLE_TAG_SLANT: Used to vary between upright and slanted text. Values\n- * must be greater than -90 and less than +90. Values can be interpreted as\n- * the angle, in counter-clockwise degrees, of oblique slant from whatever the\n- * designer considers to be upright for that font design.\n- * @HB_STYLE_TAG_WIDTH: Used to vary width of text from narrower to wider.\n- * Non-zero. Values can be interpreted as a percentage of whatever the font\n- * designer considers normal width for that font design.\n- * @HB_STYLE_TAG_WEIGHT: Used to vary stroke thicknesses or other design details\n- * to give variation from lighter to blacker. Values can be interpreted in direct\n- * comparison to values for usWeightClass in the OS\/2 table,\n- * or the CSS font-weight property.\n+ * SECTION:hb-style\n+ * @title: hb-style\n+ * @short_description: Font Styles\n+ * @include: hb.h\n@@ -57,3 +43,1 @@\n- * Defined by https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/dvaraxisreg\n- *\n- * Since: EXPERIMENTAL\n+ * Functions for fetching style information from fonts.\n@@ -61,6 +45,0 @@\n-typedef enum {\n-  HB_STYLE_TAG_ITALIC           = HB_TAG ('i','t','a','l'),\n-  HB_STYLE_TAG_OPTICAL_SIZE     = HB_TAG ('o','p','s','z'),\n-  HB_STYLE_TAG_SLANT            = HB_TAG ('s','l','n','t'),\n-  HB_STYLE_TAG_WIDTH            = HB_TAG ('w','d','t','h'),\n-  HB_STYLE_TAG_WEIGHT           = HB_TAG ('w','g','h','t'),\n@@ -68,3 +46,11 @@\n-  \/*< private >*\/\n-  _HB_STYLE_TAG_MAX_VALUE       = HB_TAG_MAX_SIGNED \/*< skip >*\/\n-} hb_style_tag_t;\n+static inline float\n+_hb_angle_to_ratio (float a)\n+{\n+  return tanf (a * float (-M_PI \/ 180.));\n+}\n+\n+static inline float\n+_hb_ratio_to_angle (float r)\n+{\n+  return atanf (r) * float (-180. \/ M_PI);\n+}\n@@ -77,1 +63,1 @@\n- * Searches variation axes of a hb_font_t object for a specific axis first,\n+ * Searches variation axes of a #hb_font_t object for a specific axis first,\n@@ -83,1 +69,1 @@\n- * Since: EXPERIMENTAL\n+ * Since: 3.0.0\n@@ -86,1 +72,1 @@\n-hb_style_get_value (hb_font_t *font, hb_tag_t tag)\n+hb_style_get_value (hb_font_t *font, hb_style_tag_t style_tag)\n@@ -88,1 +74,3 @@\n-  hb_style_tag_t style_tag = (hb_style_tag_t) tag;\n+  if (unlikely (style_tag == HB_STYLE_TAG_SLANT_RATIO))\n+    return _hb_angle_to_ratio (hb_style_get_value (font, HB_STYLE_TAG_SLANT_ANGLE));\n+\n@@ -115,1 +103,1 @@\n-    unsigned int lower, upper;\n+    unsigned int lower, design, upper;\n@@ -118,0 +106,2 @@\n+           : hb_ot_layout_get_size_params (face, &design, nullptr, nullptr, nullptr, nullptr)\n+           ? design \/ 10.f\n@@ -120,2 +110,9 @@\n-  case HB_STYLE_TAG_SLANT:\n-    return face->table.post->table->italicAngle.to_float ();\n+  case HB_STYLE_TAG_SLANT_ANGLE:\n+  {\n+    float angle = face->table.post->table->italicAngle.to_float ();\n+\n+    if (font->slant)\n+      angle = _hb_ratio_to_angle (font->slant + _hb_angle_to_ratio (angle));\n+\n+    return angle;\n+  }\n@@ -125,1 +122,3 @@\n-           : (face->table.head->is_condensed () ? 75 : 100);\n+           : (face->table.head->is_condensed () ? 75 :\n+              face->table.head->is_expanded () ? 125 :\n+              100);\n@@ -136,1 +135,0 @@\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-style.cc","additions":37,"deletions":39,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -36,1 +36,40 @@\n-#ifdef HB_EXPERIMENTAL_API\n+\/**\n+ * hb_style_tag_t:\n+ * @HB_STYLE_TAG_ITALIC: Used to vary between non-italic and italic.\n+ * A value of 0 can be interpreted as \"Roman\" (non-italic); a value of 1 can\n+ * be interpreted as (fully) italic.\n+ * @HB_STYLE_TAG_OPTICAL_SIZE: Used to vary design to suit different text sizes.\n+ * Non-zero. Values can be interpreted as text size, in points.\n+ * @HB_STYLE_TAG_SLANT_ANGLE: Used to vary between upright and slanted text. Values\n+ * must be greater than -90 and less than +90. Values can be interpreted as\n+ * the angle, in counter-clockwise degrees, of oblique slant from whatever the\n+ * designer considers to be upright for that font design. Typical right-leaning\n+ * Italic fonts have a negative slant angle (typically around -12)\n+ * @HB_STYLE_TAG_SLANT_RATIO: same as @HB_STYLE_TAG_SLANT_ANGLE expression as ratio.\n+ * Typical right-leaning Italic fonts have a positive slant ratio (typically around 0.2)\n+ * @HB_STYLE_TAG_WIDTH: Used to vary width of text from narrower to wider.\n+ * Non-zero. Values can be interpreted as a percentage of whatever the font\n+ * designer considers normal width for that font design.\n+ * @HB_STYLE_TAG_WEIGHT: Used to vary stroke thicknesses or other design details\n+ * to give variation from lighter to blacker. Values can be interpreted in direct\n+ * comparison to values for usWeightClass in the OS\/2 table,\n+ * or the CSS font-weight property.\n+ *\n+ * Defined by [OpenType Design-Variation Axis Tag Registry](https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/dvaraxisreg).\n+ *\n+ * Since: 3.0.0\n+ **\/\n+typedef enum\n+{\n+  HB_STYLE_TAG_ITALIC           = HB_TAG ('i','t','a','l'),\n+  HB_STYLE_TAG_OPTICAL_SIZE     = HB_TAG ('o','p','s','z'),\n+  HB_STYLE_TAG_SLANT_ANGLE      = HB_TAG ('s','l','n','t'),\n+  HB_STYLE_TAG_SLANT_RATIO      = HB_TAG ('S','l','n','t'),\n+  HB_STYLE_TAG_WIDTH            = HB_TAG ('w','d','t','h'),\n+  HB_STYLE_TAG_WEIGHT           = HB_TAG ('w','g','h','t'),\n+\n+  \/*< private >*\/\n+  _HB_STYLE_TAG_MAX_VALUE       = HB_TAG_MAX_SIGNED \/*< skip >*\/\n+} hb_style_tag_t;\n+\n+\n@@ -38,2 +77,1 @@\n-hb_style_get_value (hb_font_t *font, hb_tag_t style_tag);\n-#endif\n+hb_style_get_value (hb_font_t *font, hb_style_tag_t style_tag);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-style.h","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -41,3 +41,2 @@\n-\/**\n- * hb_plan_subset_cff_fdselect\n- * Determine an optimal FDSelect format according to a provided plan.\n+\n+\/* Determine an optimal FDSelect format according to a provided plan.\n@@ -47,1 +46,1 @@\n- **\/\n+ *\/\n@@ -172,4 +171,1 @@\n-\/**\n- * hb_serialize_cff_fdselect\n- * Serialize a subset FDSelect format planned above.\n- **\/\n+\/* Serialize a subset FDSelect format planned above. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-cff-common.cc","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  void reset () { buff.resize (0); }\n+  void reset () { buff.reset (); }\n@@ -47,1 +47,2 @@\n-    if (unlikely (buff.push (b) == &Crap (unsigned char)))\n+    buff.push (b);\n+    if (unlikely (buff.in_error ()))\n@@ -110,1 +111,1 @@\n-  void copy_str (const byte_str_t &str)\n+  void copy_str (const hb_ubytes_t &str)\n@@ -113,1 +114,4 @@\n-    if (unlikely (!buff.resize (offset + str.length)))\n+    \/* Manually resize buffer since faster. *\/\n+    if ((signed) (buff.length + str.length) <= buff.allocated)\n+      buff.length += str.length;\n+    else if (unlikely (!buff.resize (offset + str.length)))\n@@ -118,6 +122,1 @@\n-    if (unlikely (buff.length < offset + str.length))\n-    {\n-      set_error ();\n-      return;\n-    }\n-    memcpy (&buff[offset], &str[0], str.length);\n+    memcpy (buff.arrayZ + offset, &str[0], str.length);\n@@ -256,1 +255,1 @@\n-      const byte_str_t str = (*acc.charStrings)[glyph];\n+      const hb_ubytes_t str = (*acc.charStrings)[glyph];\n@@ -260,3 +259,6 @@\n-      cs_interpreter_t<ENV, OPSET, flatten_param_t> interp;\n-      interp.env.init (str, acc, fd);\n-      flatten_param_t  param = { flat_charstrings[i], plan->drop_hints };\n+      ENV env (str, acc, fd);\n+      cs_interpreter_t<ENV, OPSET, flatten_param_t> interp (env);\n+      flatten_param_t  param = {\n+        flat_charstrings[i],\n+        (bool) (plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n+      };\n@@ -275,4 +277,1 @@\n-  subr_closures_t () : valid (false), global_closure (nullptr)\n-  { local_closures.init (); }\n-\n-  void init (unsigned int fd_count)\n+  subr_closures_t (unsigned int fd_count) : valid (false), global_closure (), local_closures ()\n@@ -281,3 +280,0 @@\n-    global_closure = hb_set_create ();\n-    if (global_closure == hb_set_get_empty ())\n-      valid = false;\n@@ -286,15 +282,0 @@\n-\n-    for (unsigned int i = 0; i < local_closures.length; i++)\n-    {\n-      local_closures[i] = hb_set_create ();\n-      if (local_closures[i] == hb_set_get_empty ())\n-        valid = false;\n-    }\n-  }\n-\n-  void fini ()\n-  {\n-    hb_set_destroy (global_closure);\n-    for (unsigned int i = 0; i < local_closures.length; i++)\n-      hb_set_destroy (local_closures[i]);\n-    local_closures.fini ();\n@@ -305,1 +286,1 @@\n-    hb_set_clear (global_closure);\n+    global_closure.clear();\n@@ -307,1 +288,1 @@\n-      hb_set_clear (local_closures[i]);\n+      local_closures[i].clear();\n@@ -312,2 +293,2 @@\n-  hb_set_t  *global_closure;\n-  hb_vector_t<hb_set_t *> local_closures;\n+  hb_set_t  global_closure;\n+  hb_vector_t<hb_set_t> local_closures;\n@@ -320,1 +301,0 @@\n-    op_str_t::init ();\n@@ -327,2 +307,0 @@\n-  void fini () { op_str_t::fini (); }\n-\n@@ -341,3 +319,3 @@\n-  bool    drop_flag : 1;\n-  bool    keep_flag : 1;\n-  bool    skip_flag : 1;\n+  bool    drop_flag;\n+  bool    keep_flag;\n+  bool    skip_flag;\n@@ -416,10 +394,0 @@\n-  void init (unsigned int len_ = 0)\n-  {\n-    SUPER::init ();\n-    if (unlikely (!resize (len_)))\n-      return;\n-    for (unsigned int i = 0; i < length; i++)\n-      (*this)[i].init ();\n-  }\n-  void fini () { SUPER::fini_deep (); }\n-\n@@ -432,13 +400,13 @@\n-  void init (parsed_cs_str_t *parsed_charstring_,\n-             parsed_cs_str_vec_t *parsed_global_subrs_, parsed_cs_str_vec_t *parsed_local_subrs_,\n-             hb_set_t *global_closure_, hb_set_t *local_closure_,\n-             bool drop_hints_)\n-  {\n-    parsed_charstring = parsed_charstring_;\n-    current_parsed_str = parsed_charstring;\n-    parsed_global_subrs = parsed_global_subrs_;\n-    parsed_local_subrs = parsed_local_subrs_;\n-    global_closure = global_closure_;\n-    local_closure = local_closure_;\n-    drop_hints = drop_hints_;\n-  }\n+  subr_subset_param_t (parsed_cs_str_t *parsed_charstring_,\n+                       parsed_cs_str_vec_t *parsed_global_subrs_,\n+                       parsed_cs_str_vec_t *parsed_local_subrs_,\n+                       hb_set_t *global_closure_,\n+                       hb_set_t *local_closure_,\n+                       bool drop_hints_) :\n+      current_parsed_str (parsed_charstring_),\n+      parsed_charstring (parsed_charstring_),\n+      parsed_global_subrs (parsed_global_subrs_),\n+      parsed_local_subrs (parsed_local_subrs_),\n+      global_closure (global_closure_),\n+      local_closure (local_closure_),\n+      drop_hints (drop_hints_) {}\n@@ -496,1 +464,1 @@\n-  void create (hb_set_t *closure)\n+  void create (const hb_set_t *closure)\n@@ -502,0 +470,1 @@\n+    resize (closure->get_population ());\n@@ -526,1 +495,1 @@\n-  subr_remaps_t ()\n+  subr_remaps_t (unsigned int fdCount)\n@@ -528,11 +497,1 @@\n-    global_remap.init ();\n-    local_remaps.init ();\n-  }\n-\n-  ~subr_remaps_t () { fini (); }\n-\n-  void init (unsigned int fdCount)\n-  {\n-    if (unlikely (!local_remaps.resize (fdCount))) return;\n-    for (unsigned int i = 0; i < fdCount; i++)\n-      local_remaps[i].init ();\n+    local_remaps.resize (fdCount);\n@@ -548,1 +507,1 @@\n-    global_remap.create (closures.global_closure);\n+    global_remap.create (&closures.global_closure);\n@@ -550,7 +509,1 @@\n-      local_remaps[i].create (closures.local_closures[i]);\n-  }\n-\n-  void fini ()\n-  {\n-    global_remap.fini ();\n-    local_remaps.fini_deep ();\n+      local_remaps[i].create (&closures.local_closures[i]);\n@@ -567,15 +520,2 @@\n-    : acc (acc_), plan (plan_)\n-  {\n-    parsed_charstrings.init ();\n-    parsed_global_subrs.init ();\n-    parsed_local_subrs.init ();\n-  }\n-\n-  ~subr_subsetter_t ()\n-  {\n-    closures.fini ();\n-    remaps.fini ();\n-    parsed_charstrings.fini_deep ();\n-    parsed_global_subrs.fini_deep ();\n-    parsed_local_subrs.fini_deep ();\n-  }\n+      : acc (acc_), plan (plan_), closures(acc_.fdCount), remaps(acc_.fdCount)\n+  {}\n@@ -599,5 +539,2 @@\n-    closures.init (acc.fdCount);\n-    remaps.init (acc.fdCount);\n-\n-    parsed_charstrings.init (plan->num_output_glyphs ());\n-    parsed_global_subrs.init (acc.globalSubrs->count);\n+    parsed_charstrings.resize (plan->num_output_glyphs ());\n+    parsed_global_subrs.resize (acc.globalSubrs->count);\n@@ -615,1 +552,1 @@\n-      parsed_local_subrs[i].init (acc.privateDicts[i].localSubrs->count);\n+      parsed_local_subrs[i].resize (acc.privateDicts[i].localSubrs->count);\n@@ -627,1 +564,1 @@\n-      const byte_str_t str = (*acc.charStrings)[glyph];\n+      const hb_ubytes_t str = (*acc.charStrings)[glyph];\n@@ -632,2 +569,2 @@\n-      cs_interpreter_t<ENV, OPSET, subr_subset_param_t> interp;\n-      interp.env.init (str, acc, fd);\n+      ENV env (str, acc, fd);\n+      cs_interpreter_t<ENV, OPSET, subr_subset_param_t> interp (env);\n@@ -635,5 +572,7 @@\n-      subr_subset_param_t  param;\n-      param.init (&parsed_charstrings[i],\n-                  &parsed_global_subrs,  &parsed_local_subrs[fd],\n-                  closures.global_closure, closures.local_closures[fd],\n-                  plan->drop_hints);\n+      parsed_charstrings[i].alloc (str.length);\n+      subr_subset_param_t  param (&parsed_charstrings[i],\n+                                  &parsed_global_subrs,\n+                                  &parsed_local_subrs[fd],\n+                                  &closures.global_closure,\n+                                  &closures.local_closures[fd],\n+                                  plan->flags & HB_SUBSET_FLAGS_NO_HINTING);\n@@ -648,1 +587,1 @@\n-    if (plan->drop_hints)\n+    if (plan->flags & HB_SUBSET_FLAGS_NO_HINTING)\n@@ -659,5 +598,6 @@\n-        subr_subset_param_t  param;\n-        param.init (&parsed_charstrings[i],\n-                    &parsed_global_subrs,  &parsed_local_subrs[fd],\n-                    closures.global_closure, closures.local_closures[fd],\n-                    plan->drop_hints);\n+        subr_subset_param_t  param (&parsed_charstrings[i],\n+                                    &parsed_global_subrs,\n+                                    &parsed_local_subrs[fd],\n+                                    &closures.global_closure,\n+                                    &closures.local_closures[fd],\n+                                    plan->flags & HB_SUBSET_FLAGS_NO_HINTING);\n@@ -684,5 +624,6 @@\n-        subr_subset_param_t  param;\n-        param.init (&parsed_charstrings[i],\n-                    &parsed_global_subrs,  &parsed_local_subrs[fd],\n-                    closures.global_closure, closures.local_closures[fd],\n-                    plan->drop_hints);\n+        subr_subset_param_t  param (&parsed_charstrings[i],\n+                                    &parsed_global_subrs,\n+                                    &parsed_local_subrs[fd],\n+                                    &closures.global_closure,\n+                                    &closures.local_closures[fd],\n+                                    plan->flags & HB_SUBSET_FLAGS_NO_HINTING);\n@@ -915,1 +856,1 @@\n-    buff.init ();\n+    unsigned count = str.get_count ();\n@@ -918,0 +859,1 @@\n+    buff.alloc (count * 3);\n@@ -926,1 +868,1 @@\n-    for (unsigned int i = 0; i < str.get_count(); i++)\n+    for (unsigned int i = 0; i < count; i++)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-cff-common.hh","additions":74,"deletions":132,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-          supp_op.str = byte_str_t (&opstr.str + opstr.last_arg_offset, opstr.str.length - opstr.last_arg_offset);\n+          supp_op.str = hb_ubytes_t (&opstr.str + opstr.last_arg_offset, opstr.str.length - opstr.last_arg_offset);\n@@ -273,2 +273,3 @@\n-    bool  two_byte = false;\n-    for (unsigned int i = (*this).length; i > 0; i--)\n+    bool two_byte = false;\n+    unsigned count = this->length;\n+    for (unsigned int i = count; i; i--)\n@@ -276,4 +277,3 @@\n-      code_pair_t &pair = (*this)[i - 1];\n-      unsigned int  nLeft = last_glyph - pair.glyph - 1;\n-      if (nLeft >= 0x100)\n-        two_byte = true;\n+      code_pair_t &pair = arrayZ[i - 1];\n+      unsigned int nLeft = last_glyph - pair.glyph - 1;\n+      two_byte |= nLeft >= 0x100;\n@@ -365,6 +365,0 @@\n-    : info (),\n-      orig_fdcount (0),\n-      subset_fdcount (1),\n-      subset_fdselect_format (0),\n-      drop_hints (false),\n-      desubroutinize(false)\n@@ -372,11 +366,0 @@\n-    topdict_mod.init ();\n-    subset_fdselect_ranges.init ();\n-    fdmap.init ();\n-    subset_charstrings.init ();\n-    subset_globalsubrs.init ();\n-    subset_localsubrs.init ();\n-    fontdicts_mod.init ();\n-    subset_enc_code_ranges.init ();\n-    subset_enc_supp_codes.init ();\n-    subset_charset_ranges.init ();\n-    sidmap.init ();\n@@ -387,15 +370,0 @@\n-  ~cff_subset_plan ()\n-  {\n-    topdict_mod.fini ();\n-    subset_fdselect_ranges.fini ();\n-    fdmap.fini ();\n-    subset_charstrings.fini_deep ();\n-    subset_globalsubrs.fini_deep ();\n-    subset_localsubrs.fini_deep ();\n-    fontdicts_mod.fini ();\n-    subset_enc_code_ranges.fini ();\n-    subset_enc_supp_codes.fini ();\n-    subset_charset_ranges.fini ();\n-    sidmap.fini ();\n-  }\n-\n@@ -405,1 +373,1 @@\n-    unsigned int  size0, size1, supp_size;\n+    unsigned int  size0, size1;\n@@ -415,1 +383,0 @@\n-    supp_size = 0;\n@@ -451,1 +418,0 @@\n-        supp_size += SuppEncoding::static_size * supp_codes.length;\n@@ -479,0 +445,3 @@\n+    bool use_glyph_to_sid_map = plan->num_output_glyphs () > plan->source->get_num_glyphs () \/ 8.;\n+    hb_map_t *glyph_to_sid_map = use_glyph_to_sid_map ? acc.create_glyph_to_sid_map () : nullptr;\n+\n@@ -488,1 +457,1 @@\n-      sid = acc.glyph_to_sid (old_glyph);\n+      sid = glyph_to_sid_map ? glyph_to_sid_map->get (old_glyph) : acc.glyph_to_sid (old_glyph);\n@@ -501,0 +470,3 @@\n+    if (glyph_to_sid_map)\n+      hb_map_destroy (glyph_to_sid_map);\n+\n@@ -548,2 +520,2 @@\n-    drop_hints = plan->drop_hints;\n-    desubroutinize = plan->desubroutinize;\n+    drop_hints = plan->flags & HB_SUBSET_FLAGS_NO_HINTING;\n+    desubroutinize = plan->flags & HB_SUBSET_FLAGS_DESUBROUTINIZE;\n@@ -677,3 +649,3 @@\n-  unsigned int    orig_fdcount;\n-  unsigned int    subset_fdcount;\n-  unsigned int    subset_fdselect_format;\n+  unsigned int    orig_fdcount = 0;\n+  unsigned int    subset_fdcount = 1;\n+  unsigned int    subset_fdselect_format = 0;\n@@ -691,1 +663,1 @@\n-  bool          drop_hints;\n+  bool          drop_hints = false;\n@@ -707,1 +679,1 @@\n-  bool          desubroutinize;\n+  bool          desubroutinize = false;\n@@ -922,6 +894,0 @@\n-\/**\n- * hb_subset_cff1:\n- * Subsets the CFF table according to a provided plan.\n- *\n- * Return value: subsetted cff table.\n- **\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-cff1.cc","additions":22,"deletions":56,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-struct cff2_cs_opset_flatten_t : cff2_cs_opset_t<cff2_cs_opset_flatten_t, flatten_param_t>\n+struct cff2_cs_opset_flatten_t : cff2_cs_opset_t<cff2_cs_opset_flatten_t, flatten_param_t, blend_arg_t>\n@@ -72,1 +72,1 @@\n-  static void flush_args_and_op (op_code_t op, cff2_cs_interp_env_t &env, flatten_param_t& param)\n+  static void flush_args_and_op (op_code_t op, cff2_cs_interp_env_t<blend_arg_t> &env, flatten_param_t& param)\n@@ -100,1 +100,1 @@\n-  static void flush_args (cff2_cs_interp_env_t &env, flatten_param_t& param)\n+  static void flush_args (cff2_cs_interp_env_t<blend_arg_t> &env, flatten_param_t& param)\n@@ -125,1 +125,1 @@\n-  static void flatten_blends (const blend_arg_t &arg, unsigned int i, cff2_cs_interp_env_t &env, flatten_param_t& param)\n+  static void flatten_blends (const blend_arg_t &arg, unsigned int i, cff2_cs_interp_env_t<blend_arg_t> &env, flatten_param_t& param)\n@@ -152,1 +152,1 @@\n-  static void flush_op (op_code_t op, cff2_cs_interp_env_t &env, flatten_param_t& param)\n+  static void flush_op (op_code_t op, cff2_cs_interp_env_t<blend_arg_t> &env, flatten_param_t& param)\n@@ -166,2 +166,2 @@\n-  typedef cff2_cs_opset_t<cff2_cs_opset_flatten_t, flatten_param_t> SUPER;\n-  typedef cs_opset_t<blend_arg_t, cff2_cs_opset_flatten_t, cff2_cs_opset_flatten_t, cff2_cs_interp_env_t, flatten_param_t> CSOPSET;\n+  typedef cff2_cs_opset_t<cff2_cs_opset_flatten_t, flatten_param_t, blend_arg_t> SUPER;\n+  typedef cs_opset_t<blend_arg_t, cff2_cs_opset_flatten_t, cff2_cs_opset_flatten_t, cff2_cs_interp_env_t<blend_arg_t>, flatten_param_t> CSOPSET;\n@@ -170,1 +170,1 @@\n-struct cff2_cs_opset_subr_subset_t : cff2_cs_opset_t<cff2_cs_opset_subr_subset_t, subr_subset_param_t>\n+struct cff2_cs_opset_subr_subset_t : cff2_cs_opset_t<cff2_cs_opset_subr_subset_t, subr_subset_param_t, blend_arg_t>\n@@ -172,1 +172,1 @@\n-  static void process_op (op_code_t op, cff2_cs_interp_env_t &env, subr_subset_param_t& param)\n+  static void process_op (op_code_t op, cff2_cs_interp_env_t<blend_arg_t> &env, subr_subset_param_t& param)\n@@ -204,1 +204,1 @@\n-                                 cff2_cs_interp_env_t &env, subr_subset_param_t& param,\n+                                 cff2_cs_interp_env_t<blend_arg_t> &env, subr_subset_param_t& param,\n@@ -215,1 +215,1 @@\n-  typedef cff2_cs_opset_t<cff2_cs_opset_subr_subset_t, subr_subset_param_t> SUPER;\n+  typedef cff2_cs_opset_t<cff2_cs_opset_subr_subset_t, subr_subset_param_t, blend_arg_t> SUPER;\n@@ -218,1 +218,1 @@\n-struct cff2_subr_subsetter_t : subr_subsetter_t<cff2_subr_subsetter_t, CFF2Subrs, const OT::cff2::accelerator_subset_t, cff2_cs_interp_env_t, cff2_cs_opset_subr_subset_t>\n+struct cff2_subr_subsetter_t : subr_subsetter_t<cff2_subr_subsetter_t, CFF2Subrs, const OT::cff2::accelerator_subset_t, cff2_cs_interp_env_t<blend_arg_t>, cff2_cs_opset_subr_subset_t>\n@@ -223,1 +223,1 @@\n-  static void complete_parsed_str (cff2_cs_interp_env_t &env, subr_subset_param_t& param, parsed_cs_str_t &charstring)\n+  static void complete_parsed_str (cff2_cs_interp_env_t<blend_arg_t> &env, subr_subset_param_t& param, parsed_cs_str_t &charstring)\n@@ -236,23 +236,0 @@\n-  cff2_subset_plan ()\n-    : orig_fdcount (0),\n-      subset_fdcount(1),\n-      subset_fdselect_size (0),\n-      subset_fdselect_format (0),\n-      drop_hints (false),\n-      desubroutinize (false)\n-  {\n-    subset_fdselect_ranges.init ();\n-    fdmap.init ();\n-    subset_charstrings.init ();\n-    subset_globalsubrs.init ();\n-    subset_localsubrs.init ();\n-  }\n-\n-  ~cff2_subset_plan ()\n-  {\n-    subset_fdselect_ranges.fini ();\n-    fdmap.fini ();\n-    subset_charstrings.fini_deep ();\n-    subset_globalsubrs.fini_deep ();\n-    subset_localsubrs.fini_deep ();\n-  }\n@@ -265,2 +242,2 @@\n-    drop_hints = plan->drop_hints;\n-    desubroutinize = plan->desubroutinize;\n+    drop_hints = plan->flags & HB_SUBSET_FLAGS_NO_HINTING;\n+    desubroutinize = plan->flags & HB_SUBSET_FLAGS_DESUBROUTINIZE;\n@@ -271,1 +248,1 @@\n-      subr_flattener_t<const OT::cff2::accelerator_subset_t, cff2_cs_interp_env_t, cff2_cs_opset_flatten_t>\n+      subr_flattener_t<const OT::cff2::accelerator_subset_t, cff2_cs_interp_env_t<blend_arg_t>, cff2_cs_opset_flatten_t>\n@@ -323,4 +300,4 @@\n-  unsigned int    orig_fdcount;\n-  unsigned int    subset_fdcount;\n-  unsigned int    subset_fdselect_size;\n-  unsigned int    subset_fdselect_format;\n+  unsigned int    orig_fdcount = 0;\n+  unsigned int    subset_fdcount = 1;\n+  unsigned int    subset_fdselect_size = 0;\n+  unsigned int    subset_fdselect_format = 0;\n@@ -335,2 +312,2 @@\n-  bool      drop_hints;\n-  bool      desubroutinize;\n+  bool      drop_hints = false;\n+  bool      desubroutinize = false;\n@@ -473,4 +450,0 @@\n-\/**\n- * hb_subset_cff2:\n- * Subsets the CFF2 table according to a provided subset context.\n- **\/\n@@ -480,6 +453,2 @@\n-  OT::cff2::accelerator_subset_t acc;\n-  acc.init (c->plan->source);\n-  bool result = likely (acc.is_valid ()) && _hb_subset_cff2 (acc, c);\n-  acc.fini ();\n-\n-  return result;\n+  OT::cff2::accelerator_subset_t acc (c->plan->source);\n+  return acc.is_valid () && _hb_subset_cff2 (acc, c);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-cff2.cc","additions":24,"deletions":55,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -33,1 +33,4 @@\n- * Return value: New subset input.\n+ * Creates a new subset input object.\n+ *\n+ * Return value: (transfer full): New subset input, or %NULL if failed. Destroy\n+ * with hb_subset_input_destroy().\n@@ -38,1 +41,1 @@\n-hb_subset_input_create_or_fail ()\n+hb_subset_input_create_or_fail (void)\n@@ -45,11 +48,13 @@\n-  input->unicodes = hb_set_create ();\n-  input->glyphs = hb_set_create ();\n-  input->name_ids = hb_set_create ();\n-  hb_set_add_range (input->name_ids, 0, 6);\n-  input->name_languages = hb_set_create ();\n-  hb_set_add (input->name_languages, 0x0409);\n-  input->drop_tables = hb_set_create ();\n-  input->drop_hints = false;\n-  input->desubroutinize = false;\n-  input->retain_gids = false;\n-  input->name_legacy = false;\n+  for (auto& set : input->sets_iter ())\n+    set = hb_set_create ();\n+\n+  if (input->in_error ())\n+  {\n+    hb_subset_input_destroy (input);\n+    return nullptr;\n+  }\n+\n+  input->flags = HB_SUBSET_FLAGS_DEFAULT;\n+\n+  hb_set_add_range (input->sets.name_ids, 0, 6);\n+  hb_set_add (input->sets.name_languages, 0x0409);\n@@ -59,3 +64,0 @@\n-    HB_TAG ('G', 'S', 'U', 'B'),\n-    HB_TAG ('G', 'P', 'O', 'S'),\n-    HB_TAG ('G', 'D', 'E', 'F'),\n@@ -84,0 +86,70 @@\n+  input->sets.drop_tables->add_array (default_drop_tables, ARRAY_LENGTH (default_drop_tables));\n+\n+  hb_tag_t default_no_subset_tables[] = {\n+    HB_TAG ('a', 'v', 'a', 'r'),\n+    HB_TAG ('f', 'v', 'a', 'r'),\n+    HB_TAG ('g', 'a', 's', 'p'),\n+    HB_TAG ('c', 'v', 't', ' '),\n+    HB_TAG ('f', 'p', 'g', 'm'),\n+    HB_TAG ('p', 'r', 'e', 'p'),\n+    HB_TAG ('V', 'D', 'M', 'X'),\n+    HB_TAG ('D', 'S', 'I', 'G'),\n+    HB_TAG ('M', 'V', 'A', 'R'),\n+    HB_TAG ('c', 'v', 'a', 'r'),\n+    HB_TAG ('S', 'T', 'A', 'T'),\n+  };\n+  input->sets.no_subset_tables->add_array (default_no_subset_tables,\n+                                         ARRAY_LENGTH (default_no_subset_tables));\n+\n+  \/\/copied from _layout_features_groups in fonttools\n+  hb_tag_t default_layout_features[] = {\n+    \/\/ default shaper\n+    \/\/ common\n+    HB_TAG ('r', 'v', 'r', 'n'),\n+    HB_TAG ('c', 'c', 'm', 'p'),\n+    HB_TAG ('l', 'i', 'g', 'a'),\n+    HB_TAG ('l', 'o', 'c', 'l'),\n+    HB_TAG ('m', 'a', 'r', 'k'),\n+    HB_TAG ('m', 'k', 'm', 'k'),\n+    HB_TAG ('r', 'l', 'i', 'g'),\n+\n+    \/\/fractions\n+    HB_TAG ('f', 'r', 'a', 'c'),\n+    HB_TAG ('n', 'u', 'm', 'r'),\n+    HB_TAG ('d', 'n', 'o', 'm'),\n+\n+    \/\/horizontal\n+    HB_TAG ('c', 'a', 'l', 't'),\n+    HB_TAG ('c', 'l', 'i', 'g'),\n+    HB_TAG ('c', 'u', 'r', 's'),\n+    HB_TAG ('k', 'e', 'r', 'n'),\n+    HB_TAG ('r', 'c', 'l', 't'),\n+\n+    \/\/vertical\n+    HB_TAG ('v', 'a', 'l', 't'),\n+    HB_TAG ('v', 'e', 'r', 't'),\n+    HB_TAG ('v', 'k', 'r', 'n'),\n+    HB_TAG ('v', 'p', 'a', 'l'),\n+    HB_TAG ('v', 'r', 't', '2'),\n+\n+    \/\/ltr\n+    HB_TAG ('l', 't', 'r', 'a'),\n+    HB_TAG ('l', 't', 'r', 'm'),\n+\n+    \/\/rtl\n+    HB_TAG ('r', 't', 'l', 'a'),\n+    HB_TAG ('r', 't', 'l', 'm'),\n+\n+    \/\/random\n+    HB_TAG ('r', 'a', 'n', 'd'),\n+\n+    \/\/justify\n+    HB_TAG ('j', 'a', 'l', 't'), \/\/ HarfBuzz doesn't use; others might\n+\n+    \/\/private\n+    HB_TAG ('H', 'a', 'r', 'f'),\n+    HB_TAG ('H', 'A', 'R', 'F'),\n+    HB_TAG ('B', 'u', 'z', 'z'),\n+    HB_TAG ('B', 'U', 'Z', 'Z'),\n+\n+    \/\/shapers\n@@ -85,1 +157,11 @@\n-  input->drop_tables->add_array (default_drop_tables, ARRAY_LENGTH (default_drop_tables));\n+    \/\/arabic\n+    HB_TAG ('i', 'n', 'i', 't'),\n+    HB_TAG ('m', 'e', 'd', 'i'),\n+    HB_TAG ('f', 'i', 'n', 'a'),\n+    HB_TAG ('i', 's', 'o', 'l'),\n+    HB_TAG ('m', 'e', 'd', '2'),\n+    HB_TAG ('f', 'i', 'n', '2'),\n+    HB_TAG ('f', 'i', 'n', '3'),\n+    HB_TAG ('c', 's', 'w', 'h'),\n+    HB_TAG ('m', 's', 'e', 't'),\n+    HB_TAG ('s', 't', 'c', 'h'),\n@@ -87,0 +169,42 @@\n+    \/\/hangul\n+    HB_TAG ('l', 'j', 'm', 'o'),\n+    HB_TAG ('v', 'j', 'm', 'o'),\n+    HB_TAG ('t', 'j', 'm', 'o'),\n+\n+    \/\/tibetan\n+    HB_TAG ('a', 'b', 'v', 's'),\n+    HB_TAG ('b', 'l', 'w', 's'),\n+    HB_TAG ('a', 'b', 'v', 'm'),\n+    HB_TAG ('b', 'l', 'w', 'm'),\n+\n+    \/\/indic\n+    HB_TAG ('n', 'u', 'k', 't'),\n+    HB_TAG ('a', 'k', 'h', 'n'),\n+    HB_TAG ('r', 'p', 'h', 'f'),\n+    HB_TAG ('r', 'k', 'r', 'f'),\n+    HB_TAG ('p', 'r', 'e', 'f'),\n+    HB_TAG ('b', 'l', 'w', 'f'),\n+    HB_TAG ('h', 'a', 'l', 'f'),\n+    HB_TAG ('a', 'b', 'v', 'f'),\n+    HB_TAG ('p', 's', 't', 'f'),\n+    HB_TAG ('c', 'f', 'a', 'r'),\n+    HB_TAG ('v', 'a', 't', 'u'),\n+    HB_TAG ('c', 'j', 'c', 't'),\n+    HB_TAG ('i', 'n', 'i', 't'),\n+    HB_TAG ('p', 'r', 'e', 's'),\n+    HB_TAG ('a', 'b', 'v', 's'),\n+    HB_TAG ('b', 'l', 'w', 's'),\n+    HB_TAG ('p', 's', 't', 's'),\n+    HB_TAG ('h', 'a', 'l', 'n'),\n+    HB_TAG ('d', 'i', 's', 't'),\n+    HB_TAG ('a', 'b', 'v', 'm'),\n+    HB_TAG ('b', 'l', 'w', 'm'),\n+  };\n+\n+  input->sets.layout_features->add_array (default_layout_features, ARRAY_LENGTH (default_layout_features));\n+\n+  if (input->in_error ())\n+  {\n+    hb_subset_input_destroy (input);\n+    return nullptr;\n+  }\n@@ -92,2 +216,1 @@\n- * @subset_input: a subset_input.\n- *\n+ * @input: a #hb_subset_input_t object.\n@@ -95,0 +218,1 @@\n+ * Increases the reference count on @input.\n@@ -96,1 +220,1 @@\n- * Return value:\n+ * Return value: @input.\n@@ -101,1 +225,1 @@\n-hb_subset_input_reference (hb_subset_input_t *subset_input)\n+hb_subset_input_reference (hb_subset_input_t *input)\n@@ -103,1 +227,1 @@\n-  return hb_object_reference (subset_input);\n+  return hb_object_reference (input);\n@@ -108,1 +232,4 @@\n- * @subset_input: a subset_input.\n+ * @input: a #hb_subset_input_t object.\n+ *\n+ * Decreases the reference count on @input, and if it reaches zero, destroys\n+ * @input, freeing all memory.\n@@ -113,1 +240,1 @@\n-hb_subset_input_destroy (hb_subset_input_t *subset_input)\n+hb_subset_input_destroy (hb_subset_input_t *input)\n@@ -115,1 +242,1 @@\n-  if (!hb_object_destroy (subset_input)) return;\n+  if (!hb_object_destroy (input)) return;\n@@ -117,5 +244,2 @@\n-  hb_set_destroy (subset_input->unicodes);\n-  hb_set_destroy (subset_input->glyphs);\n-  hb_set_destroy (subset_input->name_ids);\n-  hb_set_destroy (subset_input->name_languages);\n-  hb_set_destroy (subset_input->drop_tables);\n+  for (hb_set_t* set : input->sets_iter ())\n+    hb_set_destroy (set);\n@@ -123,1 +247,1 @@\n-  free (subset_input);\n+  hb_free (input);\n@@ -128,1 +252,7 @@\n- * @subset_input: a subset_input.\n+ * @input: a #hb_subset_input_t object.\n+ *\n+ * Gets the set of Unicode code points to retain, the caller should modify the\n+ * set as needed.\n+ *\n+ * Return value: (transfer none): pointer to the #hb_set_t of Unicode code\n+ * points.\n@@ -133,1 +263,1 @@\n-hb_subset_input_unicode_set (hb_subset_input_t *subset_input)\n+hb_subset_input_unicode_set (hb_subset_input_t *input)\n@@ -135,1 +265,1 @@\n-  return subset_input->unicodes;\n+  return input->sets.unicodes;\n@@ -140,1 +270,6 @@\n- * @subset_input: a subset_input.\n+ * @input: a #hb_subset_input_t object.\n+ *\n+ * Gets the set of glyph IDs to retain, the caller should modify the set as\n+ * needed.\n+ *\n+ * Return value: (transfer none): pointer to the #hb_set_t of glyph IDs.\n@@ -145,13 +280,1 @@\n-hb_subset_input_glyph_set (hb_subset_input_t *subset_input)\n-{\n-  return subset_input->glyphs;\n-}\n-\n-HB_EXTERN hb_set_t *\n-hb_subset_input_nameid_set (hb_subset_input_t *subset_input)\n-{\n-  return subset_input->name_ids;\n-}\n-\n-HB_EXTERN hb_set_t *\n-hb_subset_input_namelangid_set (hb_subset_input_t *subset_input)\n+hb_subset_input_glyph_set (hb_subset_input_t *input)\n@@ -159,1 +282,1 @@\n-  return subset_input->name_languages;\n+  return input->sets.glyphs;\n@@ -162,0 +285,11 @@\n+\/**\n+ * hb_subset_input_set:\n+ * @input: a #hb_subset_input_t object.\n+ * @set_type: a #hb_subset_sets_t set type.\n+ *\n+ * Gets the set of the specified type.\n+ *\n+ * Return value: (transfer none): pointer to the #hb_set_t of the specified type.\n+ *\n+ * Since: 2.9.1\n+ **\/\n@@ -163,1 +297,1 @@\n-hb_subset_input_drop_tables_set (hb_subset_input_t *subset_input)\n+hb_subset_input_set (hb_subset_input_t *input, hb_subset_sets_t set_type)\n@@ -165,1 +299,1 @@\n-  return subset_input->drop_tables;\n+  return input->sets_iter () [set_type];\n@@ -168,22 +302,12 @@\n-HB_EXTERN void\n-hb_subset_input_set_drop_hints (hb_subset_input_t *subset_input,\n-                                hb_bool_t drop_hints)\n-{\n-  subset_input->drop_hints = drop_hints;\n-}\n-\n-HB_EXTERN hb_bool_t\n-hb_subset_input_get_drop_hints (hb_subset_input_t *subset_input)\n-{\n-  return subset_input->drop_hints;\n-}\n-\n-HB_EXTERN void\n-hb_subset_input_set_desubroutinize (hb_subset_input_t *subset_input,\n-                                    hb_bool_t desubroutinize)\n-{\n-  subset_input->desubroutinize = desubroutinize;\n-}\n-\n-HB_EXTERN hb_bool_t\n-hb_subset_input_get_desubroutinize (hb_subset_input_t *subset_input)\n+\/**\n+ * hb_subset_input_get_flags:\n+ * @input: a #hb_subset_input_t object.\n+ *\n+ * Gets all of the subsetting flags in the input object.\n+ *\n+ * Return value: the subsetting flags bit field.\n+ *\n+ * Since: 2.9.0\n+ **\/\n+HB_EXTERN hb_subset_flags_t\n+hb_subset_input_get_flags (hb_subset_input_t *input)\n@@ -191,1 +315,1 @@\n-  return subset_input->desubroutinize;\n+  return (hb_subset_flags_t) input->flags;\n@@ -195,4 +319,8 @@\n- * hb_subset_input_set_retain_gids:\n- * @subset_input: a subset_input.\n- * @retain_gids: If true the subsetter will not renumber glyph ids.\n- * Since: 2.4.0\n+ * hb_subset_input_set_flags:\n+ * @input: a #hb_subset_input_t object.\n+ * @value: bit field of flags\n+ *\n+ * Sets all of the flags in the input object to the values specified by the bit\n+ * field.\n+ *\n+ * Since: 2.9.0\n@@ -201,2 +329,2 @@\n-hb_subset_input_set_retain_gids (hb_subset_input_t *subset_input,\n-                                 hb_bool_t retain_gids)\n+hb_subset_input_set_flags (hb_subset_input_t *input,\n+                           unsigned value)\n@@ -204,1 +332,1 @@\n-  subset_input->retain_gids = retain_gids;\n+  input->flags = (hb_subset_flags_t) value;\n@@ -208,3 +336,12 @@\n- * hb_subset_input_get_retain_gids:\n- * Returns: value of retain_gids.\n- * Since: 2.4.0\n+ * hb_subset_input_set_user_data: (skip)\n+ * @input: a #hb_subset_input_t object.\n+ * @key: The user-data key to set\n+ * @data: A pointer to the user data\n+ * @destroy: (nullable): A callback to call when @data is not needed anymore\n+ * @replace: Whether to replace an existing data with the same key\n+ *\n+ * Attaches a user-data key\/data pair to the given subset input object.\n+ *\n+ * Return value: %true if success, %false otherwise\n+ *\n+ * Since: 2.9.0\n@@ -212,2 +349,6 @@\n-HB_EXTERN hb_bool_t\n-hb_subset_input_get_retain_gids (hb_subset_input_t *subset_input)\n+hb_bool_t\n+hb_subset_input_set_user_data (hb_subset_input_t  *input,\n+                               hb_user_data_key_t *key,\n+                               void *              data,\n+                               hb_destroy_func_t   destroy,\n+                               hb_bool_t           replace)\n@@ -215,1 +356,1 @@\n-  return subset_input->retain_gids;\n+  return hb_object_set_user_data (input, key, data, destroy, replace);\n@@ -218,9 +359,15 @@\n-HB_EXTERN void\n-hb_subset_input_set_name_legacy (hb_subset_input_t *subset_input,\n-                                 hb_bool_t name_legacy)\n-{\n-  subset_input->name_legacy = name_legacy;\n-}\n-\n-HB_EXTERN hb_bool_t\n-hb_subset_input_get_name_legacy (hb_subset_input_t *subset_input)\n+\/**\n+ * hb_subset_input_get_user_data: (skip)\n+ * @input: a #hb_subset_input_t object.\n+ * @key: The user-data key to query\n+ *\n+ * Fetches the user data associated with the specified key,\n+ * attached to the specified subset input object.\n+ *\n+ * Return value: (transfer none): A pointer to the user data\n+ *\n+ * Since: 2.9.0\n+ **\/\n+void *\n+hb_subset_input_get_user_data (const hb_subset_input_t *input,\n+                               hb_user_data_key_t     *key)\n@@ -228,1 +375,1 @@\n-  return subset_input->name_legacy;\n+  return hb_object_get_user_data (input, key);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-input.cc","additions":244,"deletions":97,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"hb-map.hh\"\n+#include \"hb-set.hh\"\n@@ -37,0 +39,2 @@\n+HB_MARK_AS_FLAG_T (hb_subset_flags_t);\n+\n@@ -41,17 +45,36 @@\n-  hb_set_t *unicodes;\n-  hb_set_t *glyphs;\n-  hb_set_t *name_ids;\n-  hb_set_t *name_languages;\n-  hb_set_t *drop_tables;\n-\n-  bool drop_hints;\n-  bool desubroutinize;\n-  bool retain_gids;\n-  bool name_legacy;\n-  \/* TODO\n-   *\n-   * features\n-   * lookups\n-   * name_ids\n-   * ...\n-   *\/\n+  struct sets_t {\n+    hb_set_t *glyphs;\n+    hb_set_t *unicodes;\n+    hb_set_t *no_subset_tables;\n+    hb_set_t *drop_tables;\n+    hb_set_t *name_ids;\n+    hb_set_t *name_languages;\n+    hb_set_t *layout_features;\n+  };\n+\n+  union {\n+    sets_t sets;\n+    hb_set_t* set_ptrs[sizeof (sets_t) \/ sizeof (hb_set_t*)];\n+  };\n+\n+  unsigned flags;\n+\n+  inline unsigned num_sets () const\n+  {\n+    return sizeof (set_ptrs) \/ sizeof (hb_set_t*);\n+  }\n+\n+  inline hb_array_t<hb_set_t*> sets_iter ()\n+  {\n+    return hb_array_t<hb_set_t*> (set_ptrs, num_sets ());\n+  }\n+\n+  bool in_error () const\n+  {\n+    for (unsigned i = 0; i < num_sets (); i++)\n+    {\n+      if (unlikely (set_ptrs[i]->in_error ()))\n+        return true;\n+    }\n+    return false;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-input.hh","additions":40,"deletions":17,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"hb-ot-color-colrv1-closure.hh\"\n@@ -40,0 +41,1 @@\n+#include \"hb-ot-math-table.hh\"\n@@ -41,0 +43,2 @@\n+using OT::Layout::GSUB::GSUB;\n+using OT::Layout::GPOS;\n@@ -42,0 +46,1 @@\n+typedef hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> script_langsys_map;\n@@ -57,1 +62,17 @@\n-#ifndef HB_NO_SUBSET_LAYOUT\n+static void\n+_remap_palette_indexes (const hb_set_t *palette_indexes,\n+                        hb_map_t       *mapping \/* OUT *\/)\n+{\n+  unsigned new_idx = 0;\n+  for (unsigned palette_index : palette_indexes->iter ())\n+  {\n+    if (palette_index == 0xFFFF)\n+    {\n+      mapping->set (palette_index, palette_index);\n+      continue;\n+    }\n+    mapping->set (palette_index, new_idx);\n+    new_idx++;\n+  }\n+}\n+\n@@ -69,5 +90,10 @@\n-static inline void\n-_gsub_closure_glyphs_lookups_features (hb_face_t *face,\n-                                       hb_set_t *gids_to_retain,\n-                                       hb_map_t *gsub_lookups,\n-                                       hb_map_t *gsub_features)\n+#ifndef HB_NO_SUBSET_LAYOUT\n+typedef void (*layout_collect_func_t) (hb_face_t *face, hb_tag_t table_tag, const hb_tag_t *scripts, const hb_tag_t *languages, const hb_tag_t *features, hb_set_t *lookup_indexes \/* OUT *\/);\n+\n+\n+template <typename T>\n+static void _collect_layout_indices (hb_face_t            *face,\n+                                     const T&              table,\n+                                     const hb_set_t       *layout_features_to_retain,\n+                                     layout_collect_func_t layout_collect_func,\n+                                     hb_set_t             *indices \/* OUT *\/)\n@@ -75,15 +101,3 @@\n-  hb_set_t lookup_indices;\n-  hb_ot_layout_collect_lookups (face,\n-                                HB_OT_TAG_GSUB,\n-                                nullptr,\n-                                nullptr,\n-                                nullptr,\n-                                &lookup_indices);\n-  hb_ot_layout_lookups_substitute_closure (face,\n-                                           &lookup_indices,\n-                                           gids_to_retain);\n-  hb_blob_ptr_t<OT::GSUB> gsub = hb_sanitize_context_t ().reference_table<OT::GSUB> (face);\n-  gsub->closure_lookups (face,\n-                         gids_to_retain,\n-                         &lookup_indices);\n-  _remap_indexes (&lookup_indices, gsub_lookups);\n+  hb_vector_t<hb_tag_t> features;\n+  if (!features.alloc (table.get_feature_count () + 1))\n+    return;\n@@ -91,12 +105,43 @@\n-  \/\/ Collect and prune features\n-  hb_set_t feature_indices;\n-  hb_ot_layout_collect_features (face,\n-                                 HB_OT_TAG_GSUB,\n-                                 nullptr,\n-                                 nullptr,\n-                                 nullptr,\n-                                 &feature_indices);\n-  gsub->prune_features (gsub_lookups, &feature_indices);\n-  _remap_indexes (&feature_indices, gsub_features);\n-\n-  gsub.destroy ();\n+  hb_set_t visited_features;\n+  bool retain_all_features = true;\n+  for (unsigned i = 0; i < table.get_feature_count (); i++)\n+  {\n+    hb_tag_t tag = table.get_feature_tag (i);\n+    if (!tag) continue;\n+    if (!layout_features_to_retain->has (tag))\n+    {\n+      retain_all_features = false;\n+      continue;\n+    }\n+\n+    if (visited_features.has (tag))\n+      continue;\n+\n+    features.push (tag);\n+    visited_features.add (tag);\n+  }\n+\n+  if (!features)\n+    return;\n+\n+  \/\/ The collect function needs a null element to signal end of the array.\n+  features.push (0);\n+\n+  if (retain_all_features)\n+  {\n+    \/\/ Looking for all features, trigger the faster collection method.\n+    layout_collect_func (face,\n+                         T::tableTag,\n+                         nullptr,\n+                         nullptr,\n+                         nullptr,\n+                         indices);\n+    return;\n+  }\n+\n+  layout_collect_func (face,\n+                       T::tableTag,\n+                       nullptr,\n+                       nullptr,\n+                       features.arrayZ,\n+                       indices);\n@@ -105,0 +150,1 @@\n+template <typename T>\n@@ -106,4 +152,6 @@\n-_gpos_closure_lookups_features (hb_face_t      *face,\n-                                const hb_set_t *gids_to_retain,\n-                                hb_map_t       *gpos_lookups,\n-                                hb_map_t       *gpos_features)\n+_closure_glyphs_lookups_features (hb_face_t          *face,\n+                                  hb_set_t           *gids_to_retain,\n+                                  const hb_set_t     *layout_features_to_retain,\n+                                  hb_map_t           *lookups,\n+                                  hb_map_t           *features,\n+                                  script_langsys_map *langsys_map)\n@@ -111,0 +159,2 @@\n+  hb_blob_ptr_t<T> table = hb_sanitize_context_t ().reference_table<T> (face);\n+  hb_tag_t table_tag = table->tableTag;\n@@ -112,9 +162,12 @@\n-  hb_ot_layout_collect_lookups (face,\n-                                HB_OT_TAG_GPOS,\n-                                nullptr,\n-                                nullptr,\n-                                nullptr,\n-                                &lookup_indices);\n-  hb_blob_ptr_t<OT::GPOS> gpos = hb_sanitize_context_t ().reference_table<OT::GPOS> (face);\n-  gpos->closure_lookups (face,\n-                         gids_to_retain,\n+  _collect_layout_indices<T> (face,\n+                              *table,\n+                              layout_features_to_retain,\n+                              hb_ot_layout_collect_lookups,\n+                              &lookup_indices);\n+\n+  if (table_tag == HB_OT_TAG_GSUB)\n+    hb_ot_layout_lookups_substitute_closure (face,\n+                                            &lookup_indices,\n+                                             gids_to_retain);\n+  table->closure_lookups (face,\n+                          gids_to_retain,\n@@ -122,1 +175,1 @@\n-  _remap_indexes (&lookup_indices, gpos_lookups);\n+  _remap_indexes (&lookup_indices, lookups);\n@@ -126,9 +179,15 @@\n-  hb_ot_layout_collect_features (face,\n-                                 HB_OT_TAG_GPOS,\n-                                 nullptr,\n-                                 nullptr,\n-                                 nullptr,\n-                                 &feature_indices);\n-  gpos->prune_features (gpos_lookups, &feature_indices);\n-  _remap_indexes (&feature_indices, gpos_features);\n-  gpos.destroy ();\n+  _collect_layout_indices<T> (face,\n+                              *table,\n+                              layout_features_to_retain,\n+                              hb_ot_layout_collect_features,\n+                              &feature_indices);\n+\n+  table->prune_features (lookups, &feature_indices);\n+  hb_map_t duplicate_feature_map;\n+  table->find_duplicate_features (lookups, &feature_indices, &duplicate_feature_map);\n+\n+  feature_indices.clear ();\n+  table->prune_langsys (&duplicate_feature_map, langsys_map, &feature_indices);\n+  _remap_indexes (&feature_indices, features);\n+\n+  table.destroy ();\n@@ -136,0 +195,1 @@\n+\n@@ -147,1 +207,1 @@\n-  hb_blob_ptr_t<OT::GPOS> gpos = hb_sanitize_context_t ().reference_table<OT::GPOS> (face);\n+  hb_blob_ptr_t<GPOS> gpos = hb_sanitize_context_t ().reference_table<GPOS> (face);\n@@ -173,2 +233,1 @@\n-  OT::cmap::accelerator_t cmap;\n-  cmap.init (face);\n+  OT::cmap::accelerator_t cmap (face);\n@@ -176,1 +235,30 @@\n-  cmap.fini ();\n+}\n+\n+static void _colr_closure (hb_face_t *face,\n+                           hb_map_t *layers_map,\n+                           hb_map_t *palettes_map,\n+                           hb_set_t *glyphs_colred)\n+{\n+  OT::COLR::accelerator_t colr (face);\n+  if (!colr.is_valid ()) return;\n+\n+  unsigned iteration_count = 0;\n+  hb_set_t palette_indices, layer_indices;\n+  unsigned glyphs_num;\n+  {\n+    glyphs_num = glyphs_colred->get_population ();\n+    \/\/ Collect all glyphs referenced by COLRv0\n+    hb_set_t glyphset_colrv0;\n+    for (hb_codepoint_t gid : glyphs_colred->iter ())\n+      colr.closure_glyphs (gid, &glyphset_colrv0);\n+\n+    glyphs_colred->union_ (glyphset_colrv0);\n+\n+    \/\/closure for COLRv1\n+    colr.closure_forV1 (glyphs_colred, &layer_indices, &palette_indices);\n+  } while (iteration_count++ <= HB_CLOSURE_MAX_STAGES &&\n+           glyphs_num != glyphs_colred->get_population ());\n+\n+  colr.closure_V0palette_indices (glyphs_colred, &palette_indices);\n+  _remap_indexes (&layer_indices, layers_map);\n+  _remap_palette_indexes (&palette_indices, palettes_map);\n@@ -179,0 +267,11 @@\n+static inline void\n+_math_closure (hb_face_t           *face,\n+               hb_set_t            *glyphset)\n+{\n+  hb_blob_ptr_t<OT::MATH> math = hb_sanitize_context_t ().reference_table<OT::MATH> (face);\n+  if (math->has_data ())\n+    math->closure_glyphs (glyphset);\n+  math.destroy ();\n+}\n+\n+\n@@ -183,2 +282,62 @@\n-  hb_codepoint_t gid = HB_SET_VALUE_INVALID;\n-  while (glyphs->next (&gid))\n+  glyphs->del_range (num_glyphs, HB_SET_VALUE_INVALID);\n+}\n+\n+static void\n+_populate_unicodes_to_retain (const hb_set_t *unicodes,\n+                              const hb_set_t *glyphs,\n+                              hb_subset_plan_t *plan)\n+{\n+  OT::cmap::accelerator_t cmap (plan->source);\n+\n+  unsigned size_threshold = plan->source->get_num_glyphs ();\n+  if (glyphs->is_empty () && unicodes->get_population () < size_threshold)\n+  {\n+    \/\/ This is approach to collection is faster, but can only be used  if glyphs\n+    \/\/ are not being explicitly added to the subset and the input unicodes set is\n+    \/\/ not excessively large (eg. an inverted set).\n+    plan->unicode_to_new_gid_list.alloc (unicodes->get_population ());\n+    for (hb_codepoint_t cp : *unicodes)\n+    {\n+      hb_codepoint_t gid;\n+      if (!cmap.get_nominal_glyph (cp, &gid))\n+      {\n+        DEBUG_MSG(SUBSET, nullptr, \"Drop U+%04X; no gid\", cp);\n+        continue;\n+      }\n+\n+      plan->codepoint_to_glyph->set (cp, gid);\n+      plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n+    }\n+  }\n+  else\n+  {\n+    \/\/ This approach is slower, but can handle adding in glyphs to the subset and will match\n+    \/\/ them with cmap entries.\n+    hb_map_t unicode_glyphid_map;\n+    hb_set_t cmap_unicodes;\n+    cmap.collect_mapping (&cmap_unicodes, &unicode_glyphid_map);\n+    plan->unicode_to_new_gid_list.alloc (hb_min(unicodes->get_population ()\n+                                                + glyphs->get_population (),\n+                                                cmap_unicodes.get_population ()));\n+\n+    for (hb_codepoint_t cp : cmap_unicodes)\n+    {\n+      hb_codepoint_t gid = unicode_glyphid_map[cp];\n+      if (!unicodes->has (cp) && !glyphs->has (gid))\n+        continue;\n+\n+      plan->codepoint_to_glyph->set (cp, gid);\n+      plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n+    }\n+\n+    \/* Add gids which where requested, but not mapped in cmap *\/\n+    for (hb_codepoint_t gid : *glyphs)\n+    {\n+      if (gid >= plan->source->get_num_glyphs ())\n+        break;\n+      plan->_glyphset_gsub->add (gid);\n+    }\n+  }\n+\n+  auto &arr = plan->unicode_to_new_gid_list;\n+  if (arr.length)\n@@ -186,2 +345,2 @@\n-    if (gid >= num_glyphs)\n-      glyphs->del (gid);\n+    plan->unicodes->add_sorted_array (&arr.arrayZ->first, arr.length, sizeof (*arr.arrayZ));\n+    plan->_glyphset_gsub->add_array (&arr.arrayZ->second, arr.length, sizeof (*arr.arrayZ));\n@@ -191,0 +350,29 @@\n+#ifndef HB_COMPOSITE_OPERATIONS_PER_GLYPH\n+#define HB_COMPOSITE_OPERATIONS_PER_GLYPH 64\n+#endif\n+\n+static unsigned\n+_glyf_add_gid_and_children (const OT::glyf_accelerator_t &glyf,\n+                            hb_codepoint_t gid,\n+                            hb_set_t *gids_to_retain,\n+                            int operation_count,\n+                            unsigned depth = 0)\n+{\n+  if (unlikely (depth++ > HB_MAX_NESTING_LEVEL)) return operation_count;\n+  if (unlikely (--operation_count < 0)) return operation_count;\n+  \/* Check if is already visited *\/\n+  if (gids_to_retain->has (gid)) return operation_count;\n+\n+  gids_to_retain->add (gid);\n+\n+  for (auto item : glyf.glyph_for_gid (gid).get_composite_iterator ())\n+    operation_count =\n+      _glyf_add_gid_and_children (glyf,\n+                                  item.glyphIndex,\n+                                  gids_to_retain,\n+                                  operation_count,\n+                                  depth);\n+\n+  return operation_count;\n+}\n+\n@@ -193,2 +381,0 @@\n-                          const hb_set_t *unicodes,\n-                          const hb_set_t *input_glyphs_to_retain,\n@@ -199,2 +385,1 @@\n-  OT::cmap::accelerator_t cmap;\n-  OT::glyf::accelerator_t glyf;\n+  OT::glyf_accelerator_t glyf (plan->source);\n@@ -202,1 +387,1 @@\n-  OT::cff1::accelerator_t cff;\n+  OT::cff1::accelerator_t cff (plan->source);\n@@ -204,7 +389,0 @@\n-  OT::COLR::accelerator_t colr;\n-  cmap.init (plan->source);\n-  glyf.init (plan->source);\n-#ifndef HB_NO_SUBSET_CFF\n-  cff.init (plan->source);\n-#endif\n-  colr.init (plan->source);\n@@ -213,15 +391,0 @@\n-  hb_set_union (plan->_glyphset_gsub, input_glyphs_to_retain);\n-\n-  hb_codepoint_t cp = HB_SET_VALUE_INVALID;\n-  while (unicodes->next (&cp))\n-  {\n-    hb_codepoint_t gid;\n-    if (!cmap.get_nominal_glyph (cp, &gid))\n-    {\n-      DEBUG_MSG(SUBSET, nullptr, \"Drop U+%04X; no gid\", cp);\n-      continue;\n-    }\n-    plan->unicodes->add (cp);\n-    plan->codepoint_to_glyph->set (cp, gid);\n-    plan->_glyphset_gsub->add (gid);\n-  }\n@@ -234,1 +397,7 @@\n-    _gsub_closure_glyphs_lookups_features (plan->source, plan->_glyphset_gsub, plan->gsub_lookups, plan->gsub_features);\n+    _closure_glyphs_lookups_features<GSUB> (\n+        plan->source,\n+        plan->_glyphset_gsub,\n+        plan->layout_features,\n+        plan->gsub_lookups,\n+        plan->gsub_features,\n+        plan->gsub_langsys);\n@@ -237,1 +406,7 @@\n-    _gpos_closure_lookups_features (plan->source, plan->_glyphset_gsub, plan->gpos_lookups, plan->gpos_features);\n+    _closure_glyphs_lookups_features<GPOS> (\n+        plan->source,\n+        plan->_glyphset_gsub,\n+        plan->layout_features,\n+        plan->gpos_lookups,\n+        plan->gpos_features,\n+        plan->gpos_langsys);\n@@ -241,6 +416,18 @@\n-  \/\/ Populate a full set of glyphs to retain by adding all referenced\n-  \/\/ composite glyphs.\n-  hb_codepoint_t gid = HB_SET_VALUE_INVALID;\n-  while (plan->_glyphset_gsub->next (&gid))\n-  {\n-    glyf.add_gid_and_children (gid, plan->_glyphset);\n+  hb_set_set (plan->_glyphset_mathed, plan->_glyphset_gsub);\n+  _math_closure (plan->source, plan->_glyphset_mathed);\n+  _remove_invalid_gids (plan->_glyphset_mathed, plan->source->get_num_glyphs ());\n+\n+  hb_set_t cur_glyphset = *plan->_glyphset_mathed;\n+  _colr_closure (plan->source, plan->colrv1_layers, plan->colr_palettes, &cur_glyphset);\n+  _remove_invalid_gids (&cur_glyphset, plan->source->get_num_glyphs ());\n+\n+  hb_set_set (plan->_glyphset_colred, &cur_glyphset);\n+\n+  \/* Populate a full set of glyphs to retain by adding all referenced\n+   * composite glyphs. *\/\n+  if (glyf.has_data ())\n+    for (hb_codepoint_t gid : cur_glyphset)\n+      _glyf_add_gid_and_children (glyf, gid, plan->_glyphset,\n+                                  cur_glyphset.get_population () * HB_COMPOSITE_OPERATIONS_PER_GLYPH);\n+  else\n+    plan->_glyphset->union_ (cur_glyphset);\n@@ -248,1 +435,2 @@\n-    if (cff.is_valid ())\n+  if (cff.is_valid ())\n+    for (hb_codepoint_t gid : cur_glyphset)\n@@ -251,3 +439,0 @@\n-    if (colr.is_valid ())\n-      colr.closure_glyphs (gid, plan->_glyphset);\n-  }\n@@ -257,0 +442,1 @@\n+\n@@ -265,0 +451,1 @@\n+}\n@@ -266,5 +453,12 @@\n-#ifndef HB_NO_SUBSET_CFF\n-  cff.fini ();\n-#endif\n-  glyf.fini ();\n-  cmap.fini ();\n+static void\n+_create_glyph_map_gsub (const hb_set_t* glyph_set_gsub,\n+                        const hb_map_t* glyph_map,\n+                        hb_map_t* out)\n+{\n+  + hb_iter (glyph_set_gsub)\n+  | hb_map ([&] (hb_codepoint_t gid) {\n+    return hb_pair_t<hb_codepoint_t, hb_codepoint_t> (gid,\n+                                                      glyph_map->get (gid));\n+  })\n+  | hb_sink (out)\n+  ;\n@@ -281,0 +475,4 @@\n+  unsigned pop = all_gids_to_retain->get_population ();\n+  reverse_glyph_map->resize (pop);\n+  glyph_map->resize (pop);\n+\n@@ -287,1 +485,3 @@\n-  } else {\n+  }\n+  else\n+  {\n@@ -295,4 +495,3 @@\n-    unsigned max_glyph =\n-    + hb_iter (all_gids_to_retain)\n-    | hb_reduce (hb_max, 0u)\n-    ;\n+    hb_codepoint_t max_glyph = HB_SET_VALUE_INVALID;\n+    hb_set_previous (all_gids_to_retain, &max_glyph);\n+\n@@ -321,1 +520,4 @@\n- * hb_subset_plan_create:\n+ * hb_subset_plan_create_or_fail:\n+ * @face: font face to create the plan for.\n+ * @input: a #hb_subset_input_t input.\n+ *\n@@ -326,1 +528,3 @@\n- * Return value: New subset plan.\n+ * Return value: (transfer full): New subset plan. Destroy with\n+ * hb_subset_plan_destroy(). If there is a failure creating the plan\n+ * nullptr will be returned.\n@@ -328,1 +532,1 @@\n- * Since: 1.7.5\n+ * Since: 4.0.0\n@@ -331,2 +535,2 @@\n-hb_subset_plan_create (hb_face_t         *face,\n-                       hb_subset_input_t *input)\n+hb_subset_plan_create_or_fail (hb_face_t         *face,\n+                               const hb_subset_input_t *input)\n@@ -336,1 +540,1 @@\n-    return const_cast<hb_subset_plan_t *> (&Null (hb_subset_plan_t));\n+    return nullptr;\n@@ -339,4 +543,1 @@\n-  plan->drop_hints = input->drop_hints;\n-  plan->desubroutinize = input->desubroutinize;\n-  plan->retain_gids = input->retain_gids;\n-  plan->name_legacy = input->name_legacy;\n+  plan->flags = input->flags;\n@@ -344,1 +545,4 @@\n-  plan->name_ids = hb_set_reference (input->name_ids);\n+\n+  plan->unicode_to_new_gid_list.init ();\n+\n+  plan->name_ids = hb_set_copy (input->sets.name_ids);\n@@ -346,3 +550,5 @@\n-  plan->name_languages = hb_set_reference (input->name_languages);\n-  plan->glyphs_requested = hb_set_reference (input->glyphs);\n-  plan->drop_tables = hb_set_reference (input->drop_tables);\n+  plan->name_languages = hb_set_copy (input->sets.name_languages);\n+  plan->layout_features = hb_set_copy (input->sets.layout_features);\n+  plan->glyphs_requested = hb_set_copy (input->sets.glyphs);\n+  plan->drop_tables = hb_set_copy (input->sets.drop_tables);\n+  plan->no_subset_tables = hb_set_copy (input->sets.no_subset_tables);\n@@ -354,0 +560,2 @@\n+  plan->_glyphset_mathed = hb_set_create ();\n+  plan->_glyphset_colred = hb_set_create ();\n@@ -357,0 +565,1 @@\n+  plan->glyph_map_gsub = hb_map_create ();\n@@ -359,0 +568,6 @@\n+\n+  if (plan->check_success (plan->gsub_langsys = hb_object_create<script_langsys_map> ()))\n+    plan->gsub_langsys->init_shallow ();\n+  if (plan->check_success (plan->gpos_langsys = hb_object_create<script_langsys_map> ()))\n+    plan->gpos_langsys->init_shallow ();\n+\n@@ -361,0 +576,2 @@\n+  plan->colrv1_layers = hb_map_create ();\n+  plan->colr_palettes = hb_map_create ();\n@@ -364,0 +581,7 @@\n+  if (unlikely (plan->in_error ())) {\n+    hb_subset_plan_destroy (plan);\n+    return nullptr;\n+  }\n+\n+  _populate_unicodes_to_retain (input->sets.unicodes, input->sets.glyphs, plan);\n+\n@@ -365,5 +589,3 @@\n-                            input->unicodes,\n-                            input->glyphs,\n-                            !input->drop_tables->has (HB_OT_TAG_GSUB),\n-                            !input->drop_tables->has (HB_OT_TAG_GPOS),\n-                            !input->drop_tables->has (HB_OT_TAG_GDEF));\n+                            !input->sets.drop_tables->has (HB_OT_TAG_GSUB),\n+                            !input->sets.drop_tables->has (HB_OT_TAG_GPOS),\n+                            !input->sets.drop_tables->has (HB_OT_TAG_GDEF));\n@@ -372,1 +594,1 @@\n-                                  input->retain_gids,\n+                                  input->flags & HB_SUBSET_FLAGS_RETAIN_GIDS,\n@@ -378,0 +600,17 @@\n+  _create_glyph_map_gsub (\n+      plan->_glyphset_gsub,\n+      plan->glyph_map,\n+      plan->glyph_map_gsub);\n+\n+  \/\/ Now that we have old to new gid map update the unicode to new gid list.\n+  for (unsigned i = 0; i < plan->unicode_to_new_gid_list.length; i++)\n+  {\n+    \/\/ Use raw array access for performance.\n+    plan->unicode_to_new_gid_list.arrayZ[i].second =\n+        plan->glyph_map->get(plan->unicode_to_new_gid_list.arrayZ[i].second);\n+  }\n+\n+  if (unlikely (plan->in_error ())) {\n+    hb_subset_plan_destroy (plan);\n+    return nullptr;\n+  }\n@@ -383,0 +622,4 @@\n+ * @plan: a #hb_subset_plan_t\n+ *\n+ * Decreases the reference count on @plan, and if it reaches zero, destroys\n+ * @plan, freeing all memory.\n@@ -384,1 +627,1 @@\n- * Since: 1.7.5\n+ * Since: 4.0.0\n@@ -392,0 +635,1 @@\n+  plan->unicode_to_new_gid_list.fini ();\n@@ -394,0 +638,1 @@\n+  hb_set_destroy (plan->layout_features);\n@@ -396,0 +641,1 @@\n+  hb_set_destroy (plan->no_subset_tables);\n@@ -401,0 +647,1 @@\n+  hb_map_destroy (plan->glyph_map_gsub);\n@@ -403,0 +650,2 @@\n+  hb_set_destroy (plan->_glyphset_mathed);\n+  hb_set_destroy (plan->_glyphset_colred);\n@@ -407,0 +656,2 @@\n+  hb_map_destroy (plan->colrv1_layers);\n+  hb_map_destroy (plan->colr_palettes);\n@@ -410,0 +661,110 @@\n+  if (plan->gsub_langsys)\n+  {\n+    hb_object_destroy (plan->gsub_langsys);\n+    plan->gsub_langsys->fini_shallow ();\n+    hb_free (plan->gsub_langsys);\n+  }\n+\n+  if (plan->gpos_langsys)\n+  {\n+    hb_object_destroy (plan->gpos_langsys);\n+    plan->gpos_langsys->fini_shallow ();\n+    hb_free (plan->gpos_langsys);\n+  }\n+\n+  hb_free (plan);\n+}\n+\n+\/**\n+ * hb_subset_plan_old_to_new_glyph_mapping:\n+ * @plan: a subsetting plan.\n+ *\n+ * Returns the mapping between glyphs in the original font to glyphs in the\n+ * subset that will be produced by @plan\n+ *\n+ * Return value: (transfer none):\n+ * A pointer to the #hb_map_t of the mapping.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+const hb_map_t*\n+hb_subset_plan_old_to_new_glyph_mapping (const hb_subset_plan_t *plan)\n+{\n+  return plan->glyph_map;\n+}\n+\n+\/**\n+ * hb_subset_plan_new_to_old_glyph_mapping:\n+ * @plan: a subsetting plan.\n+ *\n+ * Returns the mapping between glyphs in the subset that will be produced by\n+ * @plan and the glyph in the original font.\n+ *\n+ * Return value: (transfer none):\n+ * A pointer to the #hb_map_t of the mapping.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+const hb_map_t*\n+hb_subset_plan_new_to_old_glyph_mapping (const hb_subset_plan_t *plan)\n+{\n+  return plan->reverse_glyph_map;\n+}\n+\n+\/**\n+ * hb_subset_plan_unicode_to_old_glyph_mapping:\n+ * @plan: a subsetting plan.\n+ *\n+ * Returns the mapping between codepoints in the original font and the\n+ * associated glyph id in the original font.\n+ *\n+ * Return value: (transfer none):\n+ * A pointer to the #hb_map_t of the mapping.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+const hb_map_t*\n+hb_subset_plan_unicode_to_old_glyph_mapping (const hb_subset_plan_t *plan)\n+{\n+  return plan->codepoint_to_glyph;\n+}\n+\n+\/**\n+ * hb_subset_plan_reference: (skip)\n+ * @plan: a #hb_subset_plan_t object.\n+ *\n+ * Increases the reference count on @plan.\n+ *\n+ * Return value: @plan.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+hb_subset_plan_t *\n+hb_subset_plan_reference (hb_subset_plan_t *plan)\n+{\n+  return hb_object_reference (plan);\n+}\n+\n+\/**\n+ * hb_subset_plan_set_user_data: (skip)\n+ * @plan: a #hb_subset_plan_t object.\n+ * @key: The user-data key to set\n+ * @data: A pointer to the user data\n+ * @destroy: (nullable): A callback to call when @data is not needed anymore\n+ * @replace: Whether to replace an existing data with the same key\n+ *\n+ * Attaches a user-data key\/data pair to the given subset plan object.\n+ *\n+ * Return value: %true if success, %false otherwise\n+ *\n+ * Since: 4.0.0\n+ **\/\n+hb_bool_t\n+hb_subset_plan_set_user_data (hb_subset_plan_t   *plan,\n+                              hb_user_data_key_t *key,\n+                              void               *data,\n+                              hb_destroy_func_t   destroy,\n+                              hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (plan, key, data, destroy, replace);\n+}\n@@ -411,1 +772,17 @@\n-  free (plan);\n+\/**\n+ * hb_subset_plan_get_user_data: (skip)\n+ * @plan: a #hb_subset_plan_t object.\n+ * @key: The user-data key to query\n+ *\n+ * Fetches the user data associated with the specified key,\n+ * attached to the specified subset plan object.\n+ *\n+ * Return value: (transfer none): A pointer to the user data\n+ *\n+ * Since: 4.0.0\n+ **\/\n+void *\n+hb_subset_plan_get_user_data (const hb_subset_plan_t *plan,\n+                              hb_user_data_key_t     *key)\n+{\n+  return hb_object_get_user_data (plan, key);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.cc","additions":512,"deletions":135,"binary":false,"changes":647,"status":"modified"},{"patch":"@@ -42,5 +42,2 @@\n-  bool successful : 1;\n-  bool drop_hints : 1;\n-  bool desubroutinize : 1;\n-  bool retain_gids : 1;\n-  bool name_legacy : 1;\n+  bool successful;\n+  unsigned flags;\n@@ -50,0 +47,1 @@\n+  hb_vector_t<hb_pair_t<hb_codepoint_t, hb_codepoint_t>> unicode_to_new_gid_list;\n@@ -57,0 +55,3 @@\n+  \/\/layout features which will be preserved\n+  hb_set_t *layout_features;\n+\n@@ -60,0 +61,3 @@\n+  \/\/ Tables which should not be processed, just pass them through.\n+  hb_set_t *no_subset_tables;\n+\n@@ -69,0 +73,1 @@\n+  hb_map_t *glyph_map_gsub;\n@@ -77,0 +82,2 @@\n+  hb_set_t *_glyphset_mathed;\n+  hb_set_t *_glyphset_colred;\n@@ -82,1 +89,5 @@\n-  \/\/active features we'd like to retain\n+  \/\/active langsys we'd like to retain\n+  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *gsub_langsys;\n+  hb_hashmap_t<unsigned, hb::unique_ptr<hb_set_t>> *gpos_langsys;\n+\n+  \/\/active features after removing redundant langsys and prune_features\n@@ -86,0 +97,4 @@\n+  \/\/active layers\/palettes we'd like to retain\n+  hb_map_t *colrv1_layers;\n+  hb_map_t *colr_palettes;\n+\n@@ -188,9 +203,0 @@\n-typedef struct hb_subset_plan_t hb_subset_plan_t;\n-\n-HB_INTERNAL hb_subset_plan_t *\n-hb_subset_plan_create (hb_face_t           *face,\n-                       hb_subset_input_t   *input);\n-\n-HB_INTERNAL void\n-hb_subset_plan_destroy (hb_subset_plan_t *plan);\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.hh","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"hb-ot-color-cpal-table.hh\"\n@@ -44,0 +45,1 @@\n+#include \"hb-ot-post-table-v2subset.hh\"\n@@ -53,0 +55,127 @@\n+#include \"hb-ot-math-table.hh\"\n+#include \"hb-repacker.hh\"\n+\n+using OT::Layout::GSUB::GSUB;\n+using OT::Layout::GPOS;\n+\n+\/**\n+ * SECTION:hb-subset\n+ * @title: hb-subset\n+ * @short_description: Subsets font files.\n+ * @include: hb-subset.h\n+ *\n+ * Subsetting reduces the codepoint coverage of font files and removes all data\n+ * that is no longer needed. A subset input describes the desired subset. The input is\n+ * provided along with a font to the subsetting operation. Output is a new font file\n+ * containing only the data specified in the input.\n+ *\n+ * Currently most outline and bitmap tables are supported: glyf, CFF, CFF2, sbix,\n+ * COLR, and CBDT\/CBLC. This also includes fonts with variable outlines via OpenType\n+ * variations. Notably EBDT\/EBLC and SVG are not supported. Layout subsetting is supported\n+ * only for OpenType Layout tables (GSUB, GPOS, GDEF). Notably subsetting of graphite or AAT tables\n+ * is not yet supported.\n+ *\n+ * Fonts with graphite or AAT tables may still be subsetted but will likely need to use the\n+ * retain glyph ids option and configure the subset to pass through the layout tables untouched.\n+ *\/\n+\n+\/*\n+ * The list of tables in the open type spec. Used to check for tables that may need handling\n+ * if we are unable to list the tables in a face.\n+ *\/\n+static hb_tag_t known_tables[] {\n+  HB_TAG ('a', 'v', 'a', 'r'),\n+  HB_OT_TAG_BASE,\n+  HB_OT_TAG_CBDT,\n+  HB_OT_TAG_CBLC,\n+  HB_OT_TAG_cff1,\n+  HB_OT_TAG_cff2,\n+  HB_OT_TAG_cmap,\n+  HB_OT_TAG_COLR,\n+  HB_OT_TAG_CPAL,\n+  HB_TAG ('c', 'v', 'a', 'r'),\n+  HB_TAG ('c', 'v', 't', ' '),\n+  HB_TAG ('D', 'S', 'I', 'G'),\n+  HB_TAG ('E', 'B', 'D', 'T'),\n+  HB_TAG ('E', 'B', 'L', 'C'),\n+  HB_TAG ('E', 'B', 'S', 'C'),\n+  HB_TAG ('f', 'p', 'g', 'm'),\n+  HB_TAG ('f', 'v', 'a', 'r'),\n+  HB_TAG ('g', 'a', 's', 'p'),\n+  HB_OT_TAG_GDEF,\n+  HB_OT_TAG_glyf,\n+  HB_OT_TAG_GPOS,\n+  HB_OT_TAG_GSUB,\n+  HB_OT_TAG_gvar,\n+  HB_OT_TAG_hdmx,\n+  HB_OT_TAG_head,\n+  HB_OT_TAG_hhea,\n+  HB_OT_TAG_hmtx,\n+  HB_OT_TAG_HVAR,\n+  HB_OT_TAG_JSTF,\n+  HB_TAG ('k', 'e', 'r', 'n'),\n+  HB_OT_TAG_loca,\n+  HB_TAG ('L', 'T', 'S', 'H'),\n+  HB_OT_TAG_MATH,\n+  HB_OT_TAG_maxp,\n+  HB_TAG ('M', 'E', 'R', 'G'),\n+  HB_TAG ('m', 'e', 't', 'a'),\n+  HB_TAG ('M', 'V', 'A', 'R'),\n+  HB_TAG ('P', 'C', 'L', 'T'),\n+  HB_OT_TAG_post,\n+  HB_TAG ('p', 'r', 'e', 'p'),\n+  HB_OT_TAG_sbix,\n+  HB_TAG ('S', 'T', 'A', 'T'),\n+  HB_TAG ('S', 'V', 'G', ' '),\n+  HB_TAG ('V', 'D', 'M', 'X'),\n+  HB_OT_TAG_vhea,\n+  HB_OT_TAG_vmtx,\n+  HB_OT_TAG_VORG,\n+  HB_OT_TAG_VVAR,\n+  HB_OT_TAG_name,\n+  HB_OT_TAG_OS2\n+};\n+\n+static bool _table_is_empty (const hb_face_t *face, hb_tag_t tag)\n+{\n+  hb_blob_t* blob = hb_face_reference_table (face, tag);\n+  bool result = (blob == hb_blob_get_empty ());\n+  hb_blob_destroy (blob);\n+  return result;\n+}\n+\n+static unsigned int\n+_get_table_tags (const hb_subset_plan_t* plan,\n+                 unsigned int  start_offset,\n+                 unsigned int *table_count, \/* IN\/OUT *\/\n+                 hb_tag_t     *table_tags \/* OUT *\/)\n+{\n+  unsigned num_tables = hb_face_get_table_tags (plan->source, 0, nullptr, nullptr);\n+  if (num_tables)\n+    return hb_face_get_table_tags (plan->source, start_offset, table_count, table_tags);\n+\n+  \/\/ If face has 0 tables associated with it, assume that it was built from\n+  \/\/ hb_face_create_tables and thus is unable to list its tables. Fallback to\n+  \/\/ checking each table type we can handle for existence instead.\n+  auto it =\n+      hb_concat (\n+          + hb_array (known_tables)\n+          | hb_filter ([&] (hb_tag_t tag) {\n+            return !_table_is_empty (plan->source, tag) && !plan->no_subset_tables->has (tag);\n+          })\n+          | hb_map ([] (hb_tag_t tag) -> hb_tag_t { return tag; }),\n+\n+          plan->no_subset_tables->iter ()\n+          | hb_filter([&] (hb_tag_t tag) {\n+            return !_table_is_empty (plan->source, tag);\n+          }));\n+\n+  it += start_offset;\n+\n+  unsigned num_written = 0;\n+  while (bool (it) && num_written < *table_count)\n+    table_tags[num_written++] = *it++;\n+\n+  *table_count = num_written;\n+  return num_written;\n+}\n@@ -56,1 +185,3 @@\n-_plan_estimate_subset_table_size (hb_subset_plan_t *plan, unsigned table_len)\n+_plan_estimate_subset_table_size (hb_subset_plan_t *plan,\n+                                  unsigned table_len,\n+                                  bool same_size)\n@@ -61,1 +192,1 @@\n-  if (unlikely (!src_glyphs))\n+  if (unlikely (!src_glyphs) || same_size)\n@@ -67,0 +198,61 @@\n+\/*\n+ * Repack the serialization buffer if any offset overflows exist.\n+ *\/\n+static hb_blob_t*\n+_repack (hb_tag_t tag, const hb_serialize_context_t& c)\n+{\n+  if (tag != HB_OT_TAG_GPOS\n+      &&  tag != HB_OT_TAG_GSUB)\n+  {\n+    \/\/ Check for overflow in a non-handled table.\n+    return c.successful () ? c.copy_blob () : nullptr;\n+  }\n+\n+  if (!c.offset_overflow ())\n+    return c.copy_blob ();\n+\n+  hb_blob_t* result = hb_resolve_overflows (c.object_graph (), tag);\n+\n+  if (unlikely (!result))\n+  {\n+    DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c offset overflow resolution failed.\",\n+               HB_UNTAG (tag));\n+    return nullptr;\n+  }\n+\n+  return result;\n+}\n+\n+template<typename TableType>\n+static\n+bool\n+_try_subset (const TableType *table,\n+             hb_vector_t<char>* buf,\n+             hb_subset_context_t* c \/* OUT *\/)\n+{\n+  c->serializer->start_serialize<TableType> ();\n+  if (c->serializer->in_error ()) return false;\n+\n+  bool needed = table->subset (c);\n+  if (!c->serializer->ran_out_of_room ())\n+  {\n+    c->serializer->end_serialize ();\n+    return needed;\n+  }\n+\n+  unsigned buf_size = buf->allocated;\n+  buf_size = buf_size * 2 + 16;\n+  DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c ran out of room; reallocating to %u bytes.\",\n+             HB_UNTAG (c->table_tag), buf_size);\n+\n+  if (unlikely (!buf->alloc (buf_size)))\n+  {\n+    DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c failed to reallocate %u bytes.\",\n+               HB_UNTAG (c->table_tag), buf_size);\n+    return needed;\n+  }\n+\n+  c->serializer->reset (buf->arrayZ, buf->allocated);\n+  return _try_subset (table, buf, c);\n+}\n+\n@@ -69,1 +261,1 @@\n-_subset (hb_subset_plan_t *plan)\n+_subset (hb_subset_plan_t *plan, hb_vector_t<char> &buf)\n@@ -71,1 +263,0 @@\n-  bool result = false;\n@@ -76,1 +267,1 @@\n-  if (source_blob->data)\n+  if (!source_blob->data)\n@@ -78,29 +269,5 @@\n-    hb_vector_t<char> buf;\n-    \/* TODO Not all tables are glyph-related.  'name' table size for example should not be\n-     * affected by number of glyphs.  Accommodate that. *\/\n-    unsigned buf_size = _plan_estimate_subset_table_size (plan, source_blob->length);\n-    DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c initial estimated table size: %u bytes.\", HB_UNTAG (tag), buf_size);\n-    if (unlikely (!buf.alloc (buf_size)))\n-    {\n-      DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c failed to allocate %u bytes.\", HB_UNTAG (tag), buf_size);\n-      hb_blob_destroy (source_blob);\n-      return false;\n-    }\n-  retry:\n-    hb_serialize_context_t serializer ((void *) buf, buf_size);\n-    serializer.start_serialize<TableType> ();\n-    hb_subset_context_t c (source_blob, plan, &serializer, tag);\n-    bool needed = table->subset (&c);\n-    if (serializer.ran_out_of_room)\n-    {\n-      buf_size += (buf_size >> 1) + 32;\n-      DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c ran out of room; reallocating to %u bytes.\", HB_UNTAG (tag), buf_size);\n-      if (unlikely (!buf.alloc (buf_size)))\n-      {\n-        DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c failed to reallocate %u bytes.\", HB_UNTAG (tag), buf_size);\n-        hb_blob_destroy (source_blob);\n-        return false;\n-      }\n-      goto retry;\n-    }\n-    serializer.end_serialize ();\n+    DEBUG_MSG (SUBSET, nullptr,\n+               \"OT::%c%c%c%c::subset sanitize failed on source table.\", HB_UNTAG (tag));\n+    hb_blob_destroy (source_blob);\n+    return false;\n+  }\n@@ -108,1 +275,5 @@\n-    result = !serializer.in_error ();\n+  \/* Tables that we want to allocate same space as the source table. For GSUB\/GPOS it's\n+   * because those are expensive to subset, so giving them more room is fine. *\/\n+  bool same_size_table = TableType::tableTag == HB_OT_TAG_GSUB ||\n+                         TableType::tableTag == HB_OT_TAG_GPOS ||\n+                         TableType::tableTag == HB_OT_TAG_name;\n@@ -110,14 +281,8 @@\n-    if (result)\n-    {\n-      if (needed)\n-      {\n-        hb_blob_t *dest_blob = serializer.copy_blob ();\n-        DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c final subset table size: %u bytes.\", HB_UNTAG (tag), dest_blob->length);\n-        result = c.plan->add_table (tag, dest_blob);\n-        hb_blob_destroy (dest_blob);\n-      }\n-      else\n-      {\n-        DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c::subset table subsetted to empty.\", HB_UNTAG (tag));\n-      }\n-    }\n+  unsigned buf_size = _plan_estimate_subset_table_size (plan, source_blob->length, same_size_table);\n+  DEBUG_MSG (SUBSET, nullptr,\n+             \"OT::%c%c%c%c initial estimated table size: %u bytes.\", HB_UNTAG (tag), buf_size);\n+  if (unlikely (!buf.alloc (buf_size)))\n+  {\n+    DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c failed to allocate %u bytes.\", HB_UNTAG (tag), buf_size);\n+    hb_blob_destroy (source_blob);\n+    return false;\n@@ -125,2 +290,0 @@\n-  else\n-    DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c::subset sanitize failed on source table.\", HB_UNTAG (tag));\n@@ -128,0 +291,6 @@\n+  bool needed = false;\n+  hb_serialize_context_t serializer (buf.arrayZ, buf.allocated);\n+  {\n+    hb_subset_context_t c (source_blob, plan, &serializer, tag);\n+    needed = _try_subset (table, &buf, &c);\n+  }\n@@ -129,1 +298,26 @@\n-  DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c::subset %s\", HB_UNTAG (tag), result ? \"success\" : \"FAILED!\");\n+\n+  if (serializer.in_error () && !serializer.only_offset_overflow ())\n+  {\n+    DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c::subset FAILED!\", HB_UNTAG (tag));\n+    return false;\n+  }\n+\n+  if (!needed)\n+  {\n+    DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c::subset table subsetted to empty.\", HB_UNTAG (tag));\n+    return true;\n+  }\n+\n+  bool result = false;\n+  hb_blob_t *dest_blob = _repack (tag, serializer);\n+  if (dest_blob)\n+  {\n+    DEBUG_MSG (SUBSET, nullptr,\n+               \"OT::%c%c%c%c final subset table size: %u bytes.\",\n+               HB_UNTAG (tag), dest_blob->length);\n+    result = plan->add_table (tag, dest_blob);\n+    hb_blob_destroy (dest_blob);\n+  }\n+\n+  DEBUG_MSG (SUBSET, nullptr, \"OT::%c%c%c%c::subset %s\",\n+             HB_UNTAG (tag), result ? \"success\" : \"FAILED!\");\n@@ -136,0 +330,8 @@\n+\n+  if (!hb_face_get_table_tags (source, 0, nullptr, nullptr)) {\n+    \/\/ If face has 0 tables associated with it, assume that it was built from\n+    \/\/ hb_face_create_tables and thus is unable to list its tables. Fallback to\n+    \/\/ checking if the blob associated with tag is empty.\n+    return !_table_is_empty (source, tag);\n+  }\n+\n@@ -138,1 +340,1 @@\n-  while ((hb_face_get_table_tags (source, offset, &num_tables, table_tags), num_tables))\n+  while (((void) hb_face_get_table_tags (source, offset, &num_tables, table_tags), num_tables))\n@@ -162,1 +364,1 @@\n-    return plan->drop_hints;\n+    return plan->flags & HB_SUBSET_FLAGS_NO_HINTING;\n@@ -182,1 +384,1 @@\n-_subset_table (hb_subset_plan_t *plan, hb_tag_t tag)\n+_passthrough (hb_subset_plan_t *plan, hb_tag_t tag)\n@@ -184,0 +386,15 @@\n+  hb_blob_t *source_table = hb_face_reference_table (plan->source, tag);\n+  bool result = plan->add_table (tag, source_table);\n+  hb_blob_destroy (source_table);\n+  return result;\n+}\n+\n+static bool\n+_subset_table (hb_subset_plan_t *plan,\n+               hb_vector_t<char> &buf,\n+               hb_tag_t tag)\n+{\n+  if (plan->no_subset_tables->has (tag)) {\n+    return _passthrough (plan, tag);\n+  }\n+\n@@ -187,3 +404,3 @@\n-  case HB_OT_TAG_glyf: return _subset<const OT::glyf> (plan);\n-  case HB_OT_TAG_hdmx: return _subset<const OT::hdmx> (plan);\n-  case HB_OT_TAG_name: return _subset<const OT::name> (plan);\n+  case HB_OT_TAG_glyf: return _subset<const OT::glyf> (plan, buf);\n+  case HB_OT_TAG_hdmx: return _subset<const OT::hdmx> (plan, buf);\n+  case HB_OT_TAG_name: return _subset<const OT::name> (plan, buf);\n@@ -193,1 +410,1 @@\n-    return _subset<const OT::head> (plan);\n+    return _subset<const OT::head> (plan, buf);\n@@ -195,1 +412,1 @@\n-  case HB_OT_TAG_hmtx: return _subset<const OT::hmtx> (plan);\n+  case HB_OT_TAG_hmtx: return _subset<const OT::hmtx> (plan, buf);\n@@ -197,3 +414,3 @@\n-  case HB_OT_TAG_vmtx: return _subset<const OT::vmtx> (plan);\n-  case HB_OT_TAG_maxp: return _subset<const OT::maxp> (plan);\n-  case HB_OT_TAG_sbix: return _subset<const OT::sbix> (plan);\n+  case HB_OT_TAG_vmtx: return _subset<const OT::vmtx> (plan, buf);\n+  case HB_OT_TAG_maxp: return _subset<const OT::maxp> (plan, buf);\n+  case HB_OT_TAG_sbix: return _subset<const OT::sbix> (plan, buf);\n@@ -201,5 +418,6 @@\n-  case HB_OT_TAG_cmap: return _subset<const OT::cmap> (plan);\n-  case HB_OT_TAG_OS2 : return _subset<const OT::OS2 > (plan);\n-  case HB_OT_TAG_post: return _subset<const OT::post> (plan);\n-  case HB_OT_TAG_COLR: return _subset<const OT::COLR> (plan);\n-  case HB_OT_TAG_CBLC: return _subset<const OT::CBLC> (plan);\n+  case HB_OT_TAG_cmap: return _subset<const OT::cmap> (plan, buf);\n+  case HB_OT_TAG_OS2 : return _subset<const OT::OS2 > (plan, buf);\n+  case HB_OT_TAG_post: return _subset<const OT::post> (plan, buf);\n+  case HB_OT_TAG_COLR: return _subset<const OT::COLR> (plan, buf);\n+  case HB_OT_TAG_CPAL: return _subset<const OT::CPAL> (plan, buf);\n+  case HB_OT_TAG_CBLC: return _subset<const OT::CBLC> (plan, buf);\n@@ -207,0 +425,1 @@\n+  case HB_OT_TAG_MATH: return _subset<const OT::MATH> (plan, buf);\n@@ -209,3 +428,3 @@\n-  case HB_OT_TAG_cff1: return _subset<const OT::cff1> (plan);\n-  case HB_OT_TAG_cff2: return _subset<const OT::cff2> (plan);\n-  case HB_OT_TAG_VORG: return _subset<const OT::VORG> (plan);\n+  case HB_OT_TAG_cff1: return _subset<const OT::cff1> (plan, buf);\n+  case HB_OT_TAG_cff2: return _subset<const OT::cff2> (plan, buf);\n+  case HB_OT_TAG_VORG: return _subset<const OT::VORG> (plan, buf);\n@@ -215,6 +434,6 @@\n-  case HB_OT_TAG_GDEF: return _subset<const OT::GDEF> (plan);\n-  case HB_OT_TAG_GSUB: return _subset<const OT::GSUB> (plan);\n-  case HB_OT_TAG_GPOS: return _subset<const OT::GPOS> (plan);\n-  case HB_OT_TAG_gvar: return _subset<const OT::gvar> (plan);\n-  case HB_OT_TAG_HVAR: return _subset<const OT::HVAR> (plan);\n-  case HB_OT_TAG_VVAR: return _subset<const OT::VVAR> (plan);\n+  case HB_OT_TAG_GDEF: return _subset<const OT::GDEF> (plan, buf);\n+  case HB_OT_TAG_GSUB: return _subset<const GSUB> (plan, buf);\n+  case HB_OT_TAG_GPOS: return _subset<const GPOS> (plan, buf);\n+  case HB_OT_TAG_gvar: return _subset<const OT::gvar> (plan, buf);\n+  case HB_OT_TAG_HVAR: return _subset<const OT::HVAR> (plan, buf);\n+  case HB_OT_TAG_VVAR: return _subset<const OT::VVAR> (plan, buf);\n@@ -224,4 +443,5 @@\n-    hb_blob_t *source_table = hb_face_reference_table (plan->source, tag);\n-    bool result = plan->add_table (tag, source_table);\n-    hb_blob_destroy (source_table);\n-    return result;\n+    if (plan->flags & HB_SUBSET_FLAGS_PASSTHROUGH_UNRECOGNIZED)\n+      return _passthrough (plan, tag);\n+\n+    \/\/ Drop table\n+    return true;\n@@ -232,1 +452,1 @@\n- * hb_subset:\n+ * hb_subset_or_fail:\n@@ -236,1 +456,4 @@\n- * Subsets a font according to provided input.\n+ * Subsets a font according to provided input. Returns nullptr\n+ * if the subset operation fails.\n+ *\n+ * Since: 2.9.0\n@@ -239,1 +462,1 @@\n-hb_subset (hb_face_t *source, hb_subset_input_t *input)\n+hb_subset_or_fail (hb_face_t *source, const hb_subset_input_t *input)\n@@ -243,3 +466,29 @@\n-  hb_subset_plan_t *plan = hb_subset_plan_create (source, input);\n-  if (unlikely (plan->in_error ()))\n-    return hb_face_get_empty ();\n+  hb_subset_plan_t *plan = hb_subset_plan_create_or_fail (source, input);\n+  if (unlikely (!plan)) {\n+    return nullptr;\n+  }\n+\n+  hb_face_t * result = hb_subset_plan_execute_or_fail (plan);\n+  hb_subset_plan_destroy (plan);\n+  return result;\n+}\n+\n+\n+\/**\n+ * hb_subset_plan_execute_or_fail:\n+ * @plan: a subsetting plan.\n+ *\n+ * Executes the provided subsetting @plan.\n+ *\n+ * Return value:\n+ * on success returns a reference to generated font subset. If the subsetting operation fails\n+ * returns nullptr.\n+ *\n+ * Since: 4.0.0\n+ **\/\n+hb_face_t *\n+hb_subset_plan_execute_or_fail (hb_subset_plan_t *plan)\n+{\n+  if (unlikely (!plan || plan->in_error ())) {\n+    return nullptr;\n+  }\n@@ -251,1 +500,4 @@\n-  while ((hb_face_get_table_tags (source, offset, &num_tables, table_tags), num_tables))\n+  hb_vector_t<char> buf;\n+  buf.alloc (4096 - 16);\n+\n+  while (((void) _get_table_tags (plan, offset, &num_tables, table_tags), num_tables))\n@@ -258,1 +510,1 @@\n-      success = _subset_table (plan, tag);\n+      success = _subset_table (plan, buf, tag);\n@@ -263,3 +515,0 @@\n-end:\n-\n-  hb_face_t *result = success ? hb_face_reference (plan->dest) : hb_face_get_empty ();\n@@ -267,2 +516,2 @@\n-  hb_subset_plan_destroy (plan);\n-  return result;\n+end:\n+  return success ? hb_face_reference (plan->dest) : nullptr;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":343,"deletions":94,"binary":false,"changes":437,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-\/*\n- * hb_subset_input_t\n+\/**\n+ * hb_subset_input_t:\n@@ -42,0 +42,76 @@\n+\/**\n+ * hb_subset_plan_t:\n+ *\n+ * Contains information about how the subset operation will be executed.\n+ * Such as mappings from the old glyph ids to the new ones in the subset.\n+ *\/\n+\n+typedef struct hb_subset_plan_t hb_subset_plan_t;\n+\n+\/**\n+ * hb_subset_flags_t:\n+ * @HB_SUBSET_FLAGS_DEFAULT: all flags at their default value of false.\n+ * @HB_SUBSET_FLAGS_NO_HINTING: If set hinting instructions will be dropped in\n+ * the produced subset. Otherwise hinting instructions will be retained.\n+ * @HB_SUBSET_FLAGS_RETAIN_GIDS: If set glyph indices will not be modified in\n+ * the produced subset. If glyphs are dropped their indices will be retained\n+ * as an empty glyph.\n+ * @HB_SUBSET_FLAGS_DESUBROUTINIZE: If set and subsetting a CFF font the\n+ * subsetter will attempt to remove subroutines from the CFF glyphs.\n+ * @HB_SUBSET_FLAGS_NAME_LEGACY: If set non-unicode name records will be\n+ * retained in the subset.\n+ * @HB_SUBSET_FLAGS_SET_OVERLAPS_FLAG:  If set the subsetter will set the\n+ * OVERLAP_SIMPLE flag on each simple glyph.\n+ * @HB_SUBSET_FLAGS_PASSTHROUGH_UNRECOGNIZED: If set the subsetter will not\n+ * drop unrecognized tables and instead pass them through untouched.\n+ * @HB_SUBSET_FLAGS_NOTDEF_OUTLINE: If set the notdef glyph outline will be\n+ * retained in the final subset.\n+ * @HB_SUBSET_FLAGS_GLYPH_NAMES: If set the PS glyph names will be retained\n+ * in the final subset.\n+ * @HB_SUBSET_FLAGS_NO_PRUNE_UNICODE_RANGES: If set then the unicode ranges in\n+ * OS\/2 will not be recalculated.\n+ *\n+ * List of boolean properties that can be configured on the subset input.\n+ *\n+ * Since: 2.9.0\n+ **\/\n+typedef enum { \/*< flags >*\/\n+  HB_SUBSET_FLAGS_DEFAULT =                  0x00000000u,\n+  HB_SUBSET_FLAGS_NO_HINTING =               0x00000001u,\n+  HB_SUBSET_FLAGS_RETAIN_GIDS =              0x00000002u,\n+  HB_SUBSET_FLAGS_DESUBROUTINIZE =           0x00000004u,\n+  HB_SUBSET_FLAGS_NAME_LEGACY =              0x00000008u,\n+  HB_SUBSET_FLAGS_SET_OVERLAPS_FLAG =        0x00000010u,\n+  HB_SUBSET_FLAGS_PASSTHROUGH_UNRECOGNIZED = 0x00000020u,\n+  HB_SUBSET_FLAGS_NOTDEF_OUTLINE =           0x00000040u,\n+  HB_SUBSET_FLAGS_GLYPH_NAMES =              0x00000080u,\n+  HB_SUBSET_FLAGS_NO_PRUNE_UNICODE_RANGES =  0x00000100u,\n+} hb_subset_flags_t;\n+\n+\/**\n+ * hb_subset_sets_t:\n+ * @HB_SUBSET_SETS_GLYPH_INDEX: the set of glyph indexes to retain in the subset.\n+ * @HB_SUBSET_SETS_UNICODE: the set of unicode codepoints to retain in the subset.\n+ * @HB_SUBSET_SETS_NO_SUBSET_TABLE_TAG: the set of table tags which specifies tables that should not be\n+ * subsetted.\n+ * @HB_SUBSET_SETS_DROP_TABLE_TAG: the set of table tags which specifies tables which will be dropped\n+ * in the subset.\n+ * @HB_SUBSET_SETS_NAME_ID: the set of name ids that will be retained.\n+ * @HB_SUBSET_SETS_NAME_LANG_ID: the set of name lang ids that will be retained.\n+ * @HB_SUBSET_SETS_LAYOUT_FEATURE_TAG: the set of layout feature tags that will be retained\n+ * in the subset.\n+ *\n+ * List of sets that can be configured on the subset input.\n+ *\n+ * Since: 2.9.1\n+ **\/\n+typedef enum {\n+  HB_SUBSET_SETS_GLYPH_INDEX = 0,\n+  HB_SUBSET_SETS_UNICODE,\n+  HB_SUBSET_SETS_NO_SUBSET_TABLE_TAG,\n+  HB_SUBSET_SETS_DROP_TABLE_TAG,\n+  HB_SUBSET_SETS_NAME_ID,\n+  HB_SUBSET_SETS_NAME_LANG_ID,\n+  HB_SUBSET_SETS_LAYOUT_FEATURE_TAG,\n+} hb_subset_sets_t;\n+\n@@ -46,1 +122,1 @@\n-hb_subset_input_reference (hb_subset_input_t *subset_input);\n+hb_subset_input_reference (hb_subset_input_t *input);\n@@ -49,1 +125,1 @@\n-hb_subset_input_destroy (hb_subset_input_t *subset_input);\n+hb_subset_input_destroy (hb_subset_input_t *input);\n@@ -51,2 +127,6 @@\n-HB_EXTERN hb_set_t *\n-hb_subset_input_unicode_set (hb_subset_input_t *subset_input);\n+HB_EXTERN hb_bool_t\n+hb_subset_input_set_user_data (hb_subset_input_t  *input,\n+                               hb_user_data_key_t *key,\n+                               void *              data,\n+                               hb_destroy_func_t   destroy,\n+                               hb_bool_t           replace);\n@@ -54,2 +134,3 @@\n-HB_EXTERN hb_set_t *\n-hb_subset_input_glyph_set (hb_subset_input_t *subset_input);\n+HB_EXTERN void *\n+hb_subset_input_get_user_data (const hb_subset_input_t *input,\n+                               hb_user_data_key_t      *key);\n@@ -58,1 +139,1 @@\n-hb_subset_input_nameid_set (hb_subset_input_t *subset_input);\n+hb_subset_input_unicode_set (hb_subset_input_t *input);\n@@ -61,1 +142,1 @@\n-hb_subset_input_namelangid_set (hb_subset_input_t *subset_input);\n+hb_subset_input_glyph_set (hb_subset_input_t *input);\n@@ -64,1 +145,1 @@\n-hb_subset_input_drop_tables_set (hb_subset_input_t *subset_input);\n+hb_subset_input_set (hb_subset_input_t *input, hb_subset_sets_t set_type);\n@@ -66,5 +147,2 @@\n-HB_EXTERN void\n-hb_subset_input_set_drop_hints (hb_subset_input_t *subset_input,\n-                                hb_bool_t drop_hints);\n-HB_EXTERN hb_bool_t\n-hb_subset_input_get_drop_hints (hb_subset_input_t *subset_input);\n+HB_EXTERN hb_subset_flags_t\n+hb_subset_input_get_flags (hb_subset_input_t *input);\n@@ -73,4 +151,2 @@\n-hb_subset_input_set_desubroutinize (hb_subset_input_t *subset_input,\n-                                    hb_bool_t desubroutinize);\n-HB_EXTERN hb_bool_t\n-hb_subset_input_get_desubroutinize (hb_subset_input_t *subset_input);\n+hb_subset_input_set_flags (hb_subset_input_t *input,\n+                           unsigned value);\n@@ -78,5 +154,9 @@\n-HB_EXTERN void\n-hb_subset_input_set_retain_gids (hb_subset_input_t *subset_input,\n-                                 hb_bool_t retain_gids);\n-HB_EXTERN hb_bool_t\n-hb_subset_input_get_retain_gids (hb_subset_input_t *subset_input);\n+HB_EXTERN hb_face_t *\n+hb_subset_or_fail (hb_face_t *source, const hb_subset_input_t *input);\n+\n+HB_EXTERN hb_face_t *\n+hb_subset_plan_execute_or_fail (hb_subset_plan_t *plan);\n+\n+HB_EXTERN hb_subset_plan_t *\n+hb_subset_plan_create_or_fail (hb_face_t                 *face,\n+                               const hb_subset_input_t   *input);\n@@ -85,4 +165,1 @@\n-hb_subset_input_set_name_legacy (hb_subset_input_t *subset_input,\n-                                 hb_bool_t name_legacy);\n-HB_EXTERN hb_bool_t\n-hb_subset_input_get_name_legacy (hb_subset_input_t *subset_input);\n+hb_subset_plan_destroy (hb_subset_plan_t *plan);\n@@ -90,3 +167,23 @@\n-\/* hb_subset () *\/\n-HB_EXTERN hb_face_t *\n-hb_subset (hb_face_t *source, hb_subset_input_t *input);\n+HB_EXTERN const hb_map_t*\n+hb_subset_plan_old_to_new_glyph_mapping (const hb_subset_plan_t *plan);\n+\n+HB_EXTERN const hb_map_t*\n+hb_subset_plan_new_to_old_glyph_mapping (const hb_subset_plan_t *plan);\n+\n+HB_EXTERN const hb_map_t*\n+hb_subset_plan_unicode_to_old_glyph_mapping (const hb_subset_plan_t *plan);\n+\n+\n+HB_EXTERN hb_subset_plan_t *\n+hb_subset_plan_reference (hb_subset_plan_t *plan);\n+\n+HB_EXTERN hb_bool_t\n+hb_subset_plan_set_user_data (hb_subset_plan_t   *plan,\n+                              hb_user_data_key_t *key,\n+                              void               *data,\n+                              hb_destroy_func_t   destroy,\n+                              hb_bool_t           replace);\n+\n+HB_EXTERN void *\n+hb_subset_plan_get_user_data (const hb_subset_plan_t *plan,\n+                              hb_user_data_key_t     *key);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.h","additions":129,"deletions":32,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  ( obj.subset (this, hb_forward<Ts> (ds)...) )\n+  ( obj.subset (this, std::forward<Ts> (ds)...) )\n@@ -51,1 +51,1 @@\n-  ( obj.dispatch (this, hb_forward<Ts> (ds)...) )\n+  ( obj.dispatch (this, std::forward<Ts> (ds)...) )\n@@ -55,1 +55,1 @@\n-  ( _dispatch (obj, hb_prioritize, hb_forward<Ts> (ds)...) )\n+  ( _dispatch (obj, hb_prioritize, std::forward<Ts> (ds)...) )\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.hh","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n- * on file with this description: Unicode 13.0.0\n+ * on file with this description: Unicode 14.0.0\n@@ -16,1 +16,1 @@\n-_hb_ucd_sc_map[157] =\n+_hb_ucd_sc_map[163] =\n@@ -96,1 +96,4 @@\n-                   HB_SCRIPT_YEZIDI,\n+                   HB_SCRIPT_YEZIDI,           HB_SCRIPT_CYPRO_MINOAN,\n+               HB_SCRIPT_OLD_UYGHUR,                 HB_SCRIPT_TANGSA,\n+                     HB_SCRIPT_TOTO,               HB_SCRIPT_VITHKUQI,\n+                     HB_SCRIPT_MATH,\n@@ -1068,1 +1071,1 @@\n-_hb_ucd_u8[32480] =\n+_hb_ucd_u8[33120] =\n@@ -1074,12 +1077,0 @@\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 28,\n-   29, 26, 30, 31, 32, 33, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 34, 35, 35, 35, 35,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 37, 38, 39, 40,\n-   41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,\n-   26, 57, 58, 59, 59, 59, 59, 59, 26, 26, 60, 59, 59, 59, 59, 59,\n-   59, 59, 26, 61, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 26, 62, 59, 63, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 64, 26, 26, 65, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 66, 67, 59, 59, 59, 59, 68, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 69, 70, 71, 72, 73, 74, 59, 59,\n-   75, 76, 59, 59, 77, 59, 78, 79, 80, 81, 73, 82, 83, 84, 59, 59,\n@@ -1087,0 +1078,11 @@\n+   28, 26, 29, 30, 31, 32, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n+   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 33, 34, 34, 34, 34,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 37, 38, 39,\n+   40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,\n+   26, 56, 57, 58, 58, 58, 58, 59, 26, 26, 60, 58, 58, 58, 58, 58,\n+   58, 58, 26, 61, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 26, 62, 58, 63, 26, 26, 26, 26, 26, 26, 26, 26,\n+   26, 26, 26, 64, 26, 26, 65, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 66, 67, 68, 58, 58, 58, 58, 69, 58,\n+   58, 58, 58, 58, 58, 58, 58, 70, 71, 72, 73, 74, 75, 76, 58, 77,\n+   78, 79, 58, 80, 81, 58, 82, 83, 84, 85, 75, 86, 87, 88, 58, 58,\n@@ -1091,115 +1093,116 @@\n-   26, 26, 26, 85, 26, 26, 26, 26, 26, 26, 26, 86, 87, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 88, 26, 26, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 89, 59, 59, 59, 59, 59, 59, 26, 90, 59, 59,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 91, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   92, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 93,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 94,\n+   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n+   26, 26, 26, 89, 26, 26, 26, 26, 26, 26, 26, 90, 91, 26, 26, 26,\n+   26, 26, 26, 26, 26, 26, 26, 92, 26, 26, 26, 26, 26, 26, 26, 26,\n+   26, 26, 26, 26, 26, 93, 58, 58, 58, 58, 58, 58, 26, 94, 58, 58,\n+   26, 26, 26, 26, 26, 26, 26, 26, 26, 95, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   96, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 97,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n+   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 98,\n@@ -1258,1 +1261,1 @@\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 21,  1,  2, 21, 21,\n+   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 21,  1, 21, 21, 21,\n@@ -1278,4 +1281,3 @@\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n+    7,  7,  7,  7,  7,  7,  7,  7, 24,  7,  7,  7,  7,  7,  7,  2,\n+    1,  1,  2,  2,  2,  2,  2,  2, 12, 12, 12, 12, 12, 12, 12, 12,\n+    7,  7,  7,  7,  7,  7,  7,  7,  7,  6, 12, 12, 12, 12, 12, 12,\n@@ -1323,1 +1325,1 @@\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  7, 12, 12,\n+    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2, 12,  7, 12, 12,\n@@ -1325,1 +1327,1 @@\n-    2,  2,  2,  2,  2, 12, 12,  2,  7,  7,  7,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2, 12, 12,  2,  7,  7,  7,  2,  2,  7,  2,  2,\n@@ -1330,1 +1332,1 @@\n-    2,  2,  2,  2,  2, 10, 10,  2,  2,  2,  2,  2,  2,  2,  7,  2,\n+    2,  2,  2,  2,  2, 10, 10,  2,  2,  2,  2,  2,  2,  7,  7,  2,\n@@ -1347,0 +1349,1 @@\n+    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -1390,3 +1393,2 @@\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,\n-    7,  7, 12, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    7,  7, 12, 12, 12, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+    7,  7, 12, 12, 12, 10,  2,  2,  2,  2,  2,  2,  2,  2,  2,  7,\n+    7,  7, 12, 12, 10, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -1394,0 +1396,1 @@\n+    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  2,  7,  7,\n@@ -1400,1 +1403,1 @@\n-   21, 21, 21, 21, 21, 21, 17, 21, 21, 21, 21, 12, 12, 12,  1,  2,\n+   21, 21, 21, 21, 21, 21, 17, 21, 21, 21, 21, 12, 12, 12,  1, 12,\n@@ -1422,1 +1425,1 @@\n-   12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  2,\n@@ -1425,1 +1428,1 @@\n-   10, 10, 12, 10, 10,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,\n+   10, 10, 12, 10, 10,  7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,\n@@ -1427,1 +1430,1 @@\n-   12, 12, 12, 12, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,\n+   12, 12, 12, 12, 26, 26, 26, 26, 26, 26, 26, 26, 26, 21, 21,  2,\n@@ -1446,1 +1449,0 @@\n-   12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  2, 12, 12, 12, 12, 12,\n@@ -1469,0 +1471,1 @@\n+   23,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -1471,0 +1474,1 @@\n+   12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -1512,2 +1516,0 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  2,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  2,\n@@ -1528,1 +1530,1 @@\n-   26, 26, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+   26, 26, 21, 21, 21, 22, 18, 22, 18, 22, 18, 22, 18, 17,  2,  2,\n@@ -1561,2 +1563,3 @@\n-    2,  2,  9,  5,  9,  9,  9,  9,  5,  9,  5,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  9,  5,  7,  6,  6,  5,  7,  7,  7,  7,  7,\n+    9,  5,  9,  5,  9,  9,  9,  9,  5,  9,  5,  2,  2,  2,  2,  2,\n+    9,  5,  2,  5,  2,  5,  9,  5,  9,  5,  2,  2,  2,  2,  2,  2,\n+    2,  2,  6,  6,  6,  9,  5,  7,  6,  6,  5,  7,  7,  7,  7,  7,\n@@ -1604,1 +1607,1 @@\n-   24, 24,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+   24, 24, 24,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -1608,1 +1611,2 @@\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 23, 26,  2,  2,\n+    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2, 26,\n+    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 23, 26, 26, 26,\n@@ -1614,0 +1618,1 @@\n+    7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n@@ -1644,0 +1649,1 @@\n+    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -1645,0 +1651,6 @@\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,\n+    9,  9,  9,  2,  9,  9,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n+    5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n+    5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  2,  5,  5,  2,  2,  2,\n+    6,  6,  6,  6,  6,  6,  2,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n+    6,  2,  6,  6,  6,  6,  6,  6,  6,  6,  6,  2,  2,  2,  2,  2,\n@@ -1678,0 +1690,1 @@\n+    7,  7, 12, 12, 12, 12, 21, 21, 21, 21,  2,  2,  2,  2,  2,  2,\n@@ -1683,1 +1696,1 @@\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 12,\n+   12,  7,  7, 12, 12,  7,  2,  2,  2,  2,  2,  2,  2,  2,  2, 12,\n@@ -1685,1 +1698,1 @@\n-   21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  1,  2,  2,\n+   21, 21, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  1,  2,  2,\n@@ -1722,1 +1735,1 @@\n-   12, 12, 12, 12, 12, 12, 10, 12,  7,  2,  2,  2,  2,  2,  2,  2,\n+   12, 12, 12, 12, 12, 12, 10, 12,  7, 21,  2,  2,  2,  2,  2,  2,\n@@ -1759,0 +1772,1 @@\n+    7, 21, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -1774,0 +1788,1 @@\n+    6,  6,  6,  6,  2,  6,  6,  6,  6,  6,  6,  6,  2,  6,  6,  2,\n@@ -1778,0 +1793,2 @@\n+   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,  2,  2,\n+   12, 12, 12, 12, 12, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -1783,1 +1800,0 @@\n-   26, 26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2,  2,  2,\n@@ -1821,0 +1837,2 @@\n+    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  7,  5,  5,  5,  5,  5,\n+    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  2,\n@@ -1826,0 +1844,1 @@\n+    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 12,  2,\n@@ -1828,0 +1847,1 @@\n+    7,  7,  7,  7,  7,  7,  7,  2,  7,  7,  7,  7,  2,  7,  7,  2,\n@@ -1829,1 +1849,0 @@\n-   12, 12, 12, 12, 12, 12, 12,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n@@ -1850,0 +1869,1 @@\n+   26, 26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2,  2,  2,\n@@ -1852,0 +1872,1 @@\n+   26, 26, 26, 26, 26, 26, 26, 26,  2,  2,  2,  2,  2, 26, 26, 26,\n@@ -1853,3 +1874,1 @@\n-   26, 26, 26, 26, 26, 26, 26, 26, 26,  2, 26, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  2, 26, 26, 26,\n-   26, 26, 26, 26, 26,  2,  2,  2, 26, 26, 26,  2,  2,  2,  2,  2,\n+   26, 26, 26, 26, 26,  2,  2,  2, 26, 26, 26, 26, 26,  2,  2,  2,\n@@ -1894,3 +1913,3 @@\n-    0,  0,  0,  0, 54, 55,  0,  0,  0,  0, 56,  0,  0, 57, 58,  0,\n-   59, 60, 61, 62, 63, 64, 65,  0, 66, 67,  0, 68, 69, 70, 71,  0,\n-   60,  0, 72, 73, 74, 75,  0,  0, 69,  0, 76, 77,  0,  0,  0,  0,\n+    0,  0,  0,  0, 54, 55,  0,  0,  0,  0, 56,  0,  0, 57, 58, 59,\n+   60, 61, 62, 63, 64, 65, 66,  0, 67, 68,  0, 69, 70, 71, 72,  0,\n+   61,  0, 73, 74, 75, 76,  0,  0, 70,  0, 77, 78,  0,  0,  0,  0,\n@@ -1906,1 +1925,1 @@\n-    0,  0,  0,  0,  0, 78, 79,  0,  0,  0,  0,  0,  0,  0,  0, 80,\n+    0,  0,  0,  0,  0, 79, 80,  0,  0,  0,  0,  0,  0,  0,  0, 81,\n@@ -1916,1 +1935,1 @@\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 81,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0, 82,  0,  0,  0,  0,  0,  0,\n@@ -1919,1 +1938,1 @@\n-    0,  0, 82, 83, 84,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 83, 84, 85,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -1921,2 +1940,2 @@\n-   85,  0, 79,  0,  0, 86,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 87, 88,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   86,  0, 80,  0,  0, 87,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0, 88, 89,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -1931,9 +1950,8 @@\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41,  1,\n-   42, 43, 44, 45,  0,  0,  0,  0,  0,  0,  0, 46,  0, 47, 48,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 46,  0, 47,  0,  0,\n-    0,  0,  0, 49,  0,  0,  0,  0,  0,  0,  0, 46,  0, 47,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 47,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 47, 50,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 51,  0, 47,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 52,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 53,  0, 54,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 41,  0,  0,  0,  0,  0, 42, 43,  1,\n+   44, 45, 46, 47,  0,  0,  0,  0,  0,  0,  0, 48,  0, 49, 50,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 48,  0, 49,  0,  0,\n+    0,  0,  0, 51,  0,  0,  0,  0,  0,  0,  0, 48,  0, 49,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 49,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 48,  0, 49, 52,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 53,  0, 49,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 54,  0,  0,\n@@ -1941,3 +1959,4 @@\n-    0,  0,  0,  0,  0,  0,  0, 57,  0,  0, 58, 59,  0,  0,  0,  0,\n-    0,  0, 60, 61, 62,  0,  0,  0,  0,  0,  0,  0, 63,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 64, 65,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 57,  0, 58,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 59,  0,  0, 60, 61,  0,  0,  0,  0,\n+    0,  0, 62, 63, 64,  0,  0,  0,  0,  0,  0,  0, 65,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 66, 67,  0,  0,  0,  0,\n@@ -1945,28 +1964,28 @@\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 66,\n-    0,  0,  0,  0,  0,  0, 67,  0,  0,  0, 67,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 52, 68,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 69,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 70,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 71, 72,  0,  0,  0,  0,  0,  0,  0,  0,\n-   73,  0, 66, 74,  0,  0,  0,  0,  0,  0, 75, 76, 72,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 46,  0, 67,  0,  0,  0,\n-    0, 77, 78,  0,  0,  0,  0,  0,  0, 79,  0,  0,  0,  0,  0,  0,\n-   80,  0, 79,  0,  0,  0,  0,  0,  0,  0, 64,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 81, 82,\n-   83, 84, 85, 86,  0,  0,  0,  0,  0,  0,  0,  0, 87, 88, 89,  1,\n-    1,  1, 90, 91,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 92, 93,\n-   94, 95, 96,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 71, 86,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0, 97,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    1,  1,  1,  1,  0,  0,  0,  0,  0, 98,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 99,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 71,100,101,  0,  0,  0, 26,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 86,  0,102,  0,  0,  0,  0, 67,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 67,  0,  0,  0,\n-    1,  1, 86,  0,  0,  0,  0,  0,  0,103,  0,  0,  0,  0,104,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,105,  0, 73,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,106,107,108,  0,  0,  0,\n-    0,  0,102,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 47,  0,  0,  0,  0,  0,109,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,110,111,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 68,\n+    0,  0,  0,  0,  0,  0, 69,  0,  0,  0, 70,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 54, 71,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0, 72,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 73,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 74, 75,  0,  0,  0,  0,  0,  0,  0,  0,\n+   76,  0, 68, 77,  0,  0,  0,  0,  0,  0, 78, 79, 80, 81,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 48,  0, 70,  0,  0,  0,\n+    0, 82, 83,  0,  0,  0,  0,  0,  0, 84,  0,  0,  0,  0,  0,  0,\n+   85,  0, 84,  0,  0,  0,  0,  0,  0,  0, 66,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 86, 87,\n+   88, 89, 90, 91,  0,  0,  0,  0,  0,  0,  0,  0, 92, 93, 94,  1,\n+    1,  1, 95, 96,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 97, 98,\n+   99,100,101,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0, 74, 91,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,102,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    1,  1,  1,  1,  0,  0,  0,  0,  0,103,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,104,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0, 74,105,106,  0,  0,  0, 26,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 91,  0,107,  0,  0,  0,  0, 70,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 70,  0,  0,  0,\n+    1,  1, 91,  0,  0,  0,  0,  0,  0,108,  0,  0,  0,  0,109,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,110,  0, 76,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,111,112,113,  0,  0,  0,\n+    0,  0,107,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0, 49,  0,  0,  0,  0,  0,114,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,115,116,  0,  0,  0,  0,  0,  0,\n@@ -1975,36 +1994,37 @@\n-   72,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 26,112,  0,113,  0,  0,  0,  0,  0,114,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-  115,  0,  0,  0,  0,  0,  0,  0,100,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,116,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,117,118, 72,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,102,  0,  0,  0,\n-    0,  0,  0, 97,  0,  0,  0,  0,  0,  0,  0,119,  0,  0,  0,  0,\n-    0,  0,  0,  0,112,  0,  0,  0,  0,  0, 51,  0,  0,  0,  0,  0,\n-    0,  0,105,  0,  0,  0,  0,  0,  0,  0,  0,  0, 73,120,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,121,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,122,  0,  0,  0,  0,  0,  0,  0,  0,  0,123,  0, 47,  0,  0,\n-   26,124,124,  0,  0,  0,  0,  0,  0,  0,  0,  0,125,  0,  0, 49,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,126,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 97,127,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 97,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,128,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,104,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,129,105,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   73,  0,  0,  0,  0,  0,  0,  0,  0,  0, 67,  0, 97,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,130,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,131,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 97,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,132,  0,  0,  0,  0,  0,  0,  0,133,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,134,  0,  0,  0,  0,135,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-  136,137,138,139,140,141,  0,  0,  0,142,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,143,  0,  0,  0,\n-    0,  0,  0,  0,133,  1,  1,144,145,112,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,100,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,146,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,100,147,  0,  0,\n+   75,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 26,117,  0,118,  0,  0,  0,  0,  0,119,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+  120,  0,  0,  0,  0,  0,  0,  0,105,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,121,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,122,123, 75,  0,\n+    0,  0,  0,  0,124,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,107,  0,  0,  0,\n+    0,  0, 76,102,  0,  0,  0,  0,  0,  0,  0,125,  0,  0,  0,  0,\n+    0,  0,  0,  0,117,  0,  0,  0,  0,  0, 53,  0,  0,  0,  0,  0,\n+    0,  0,110,  0,  0,  0,  0,  0,  0,  0,  0,  0, 76,126,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,127,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,128,  0,  0,  0,  0,  0,  0,  0,  0,  0,129,  0, 49,  0,  0,\n+   26,130,130,  0,  0,  0,  0,  0,  0,  0,  0,  0,131,  0,  0, 51,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,132,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,102,133,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,102,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,134,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,109,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,135,110,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   76,  0,  0,  0,  0,  0,  0,  0,  0,  0, 70,  0,102,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,136,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,137,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,102,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,138,  0,  0,  0,  0,  0,  0,  0,139,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,140,  0,  0,  0,  0,141,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+  142,143,144,145,146,147,  0,  0,  0,148,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,149,  0,  0,  0,\n+    0,  0,  0,  0,139,  1,  1,150,151,117,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0, 51,  0,  0,  0,  0,  0,  0,\n+    0,105,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,152,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,105,153,  0,  0,\n@@ -2031,1 +2051,2 @@\n-  230,230,  0,  0,  0,220,220,220,  0,  0,  0,  0,  0,  0,  0,220,\n+  230,230,  0,  0,  0,220,220,220,  0,  0,  0,  0,230,220,220,220,\n+  230,230,230,230,  0,  0,230,230,230,230,230,220,220,220,220,220,\n@@ -2045,26 +2066,28 @@\n-    9,  0,  0,  0,  0,  0,  0,  0,  0,230,  0,  0,  0,228,  0,  0,\n-    0,  0,  0,  0,  0,222,230,220,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,230,220,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,\n-    0,  0,  0,  0,230,230,230,230,230,  0,  0,220,230,230,230,230,\n-  230,220,220,220,220,220,220,230,230,220,  0,220,  0,  0,  0,230,\n-  220,230,230,230,230,230,230,230,  0,  0,  0,  0,  0,  0,  9,  9,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  7,  0,230,230,230,  0,\n-    1,220,220,220,220,220,230,230,220,220,220,220,230,  0,  1,  1,\n-    1,  1,  1,  1,  1,  0,  0,  0,  0,220,  0,  0,  0,  0,  0,  0,\n-  230,  0,  0,  0,230,230,  0,  0,  0,  0,  0,  0,230,230,220,230,\n-  230,230,230,230,230,230,220,230,230,234,214,220,202,230,230,230,\n-  230,230,230,230,230,230,230,230,230,230,232,228,228,220,  0,230,\n-  233,220,230,220,230,230,  1,  1,230,230,230,230,  1,  1,  1,230,\n-  230,  0,  0,  0,  0,230,  0,  0,  0,  1,  1,230,220,230,  1,  1,\n-  220,220,220,220,230,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  9,  0,  0,218,228,232,222,224,224,  0,  8,  8,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,230,230,230,230,230,230,230,230,\n-  230,230,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,220,\n-  220,220,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,  7,\n-    0,  0,  0,  0,230,  0,230,230,220,  0,  0,230,230,  0,  0,  0,\n-    0,  0,230,230,  0,230,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 26,  0,230,230,230,230,230,230,230,220,220,220,220,220,\n-  220,220,230,230,230,230,230,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,220,  0,230,230,  1,220,  0,  0,  0,  0,  9,  0,  0,  0,  0,\n-    0,230,220,  0,  0,  0,  0,230,230,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,220,220,230,230,230,220,230,220,220,220,  0,  9,  7,  0,\n+    9,  9,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,\n+    0,230,  0,  0,  0,228,  0,  0,  0,  0,  0,  0,  0,222,230,220,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,230,220,  0,  0,  0,\n+    0,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,230,230,230,230,\n+  230,  0,  0,220,230,230,230,230,230,220,220,220,220,220,220,230,\n+  230,220,  0,220,220,230,230,220,220,230,230,230,230,230,220,230,\n+  230,230,230,  0,  0,  0,  0,230,220,230,230,230,230,230,230,230,\n+    0,  0,  0,  0,  0,  0,  9,  9,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  7,  0,230,230,230,  0,  1,220,220,220,220,220,230,230,\n+  220,220,220,220,230,  0,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,\n+    0,220,  0,  0,  0,  0,  0,  0,230,  0,  0,  0,230,230,  0,  0,\n+    0,  0,  0,  0,230,230,220,230,230,230,230,230,230,230,220,230,\n+  230,234,214,220,202,230,230,230,230,230,230,230,230,230,230,230,\n+  230,230,232,228,228,220,218,230,233,220,230,220,230,230,  1,  1,\n+  230,230,230,230,  1,  1,  1,230,230,  0,  0,  0,  0,230,  0,  0,\n+    0,  1,  1,230,220,230,  1,  1,220,220,220,220,230,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  0,  0,218,228,\n+  232,222,224,224,  0,  8,  8,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+  230,230,230,230,230,230,230,230,230,230,  0,  0,  0,  0,  0,  0,\n+    0,  0,  9,  0,  0,  0,  0,220,220,220,  0,  0,  0,  0,  0,  9,\n+    0,  0,  0,  0,  0,  0,  0,  7,  0,  0,  0,  0,230,  0,230,230,\n+  220,  0,  0,230,230,  0,  0,  0,  0,  0,230,230,  0,230,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 26,  0,230,230,230,230,\n+  230,230,230,220,220,220,220,220,220,220,230,230,230,230,230,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,220,  0,230,230,  1,220,  0,\n+    0,  0,  0,  9,  0,  0,  0,  0,  0,230,220,  0,  0,  0,  0,230,\n+  230,  0,  0,  0,  0,  0,  0,  0,  0,  0,220,220,230,230,230,220,\n+  230,220,220,220,  0,  0,230,220,230,220,  0,  0,  0,  9,  7,  0,\n@@ -2138,1 +2161,1 @@\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0, 26, 34,  9,  0,  0,  0,  0,\n@@ -2158,12 +2181,12 @@\n-   25, 25, 25, 27, 28, 28, 29, 30, 31, 32, 33, 33, 33, 33, 33, 33,\n-   33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,\n-   52, 53, 54, 55, 56, 57, 58, 35, 35, 35, 35, 35, 59, 59, 60, 35,\n-   35, 35, 35, 35, 35, 35, 61, 62, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 63, 64, 35, 65, 66, 66, 66, 66,\n-   66, 66, 66, 66, 66, 66, 66, 67, 66, 68, 69, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 70, 71, 35, 35,\n-   35, 35, 72, 35, 35, 35, 35, 35, 35, 35, 35, 35, 73, 74, 75, 76,\n-   77, 78, 35, 35, 79, 80, 35, 35, 81, 35, 82, 83, 84, 85, 17, 86,\n-   87, 88, 35, 35, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n+   25, 25, 25, 25, 27, 27, 28, 29, 30, 31, 32, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\n+   51, 52, 53, 54, 55, 56, 57, 34, 34, 34, 34, 58, 59, 59, 60, 34,\n+   34, 34, 34, 34, 34, 34, 61, 62, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 63, 64, 34, 65, 66, 66, 66, 66,\n+   66, 66, 66, 66, 66, 66, 66, 67, 66, 68, 69, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 70, 71, 72, 34, 34,\n+   34, 34, 73, 34, 34, 34, 34, 34, 34, 34, 34, 74, 75, 76, 77, 78,\n+   79, 80, 34, 81, 82, 83, 34, 84, 85, 34, 86, 87, 88, 89, 17, 90,\n+   91, 92, 34, 34, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n@@ -2174,119 +2197,119 @@\n-   25, 25, 25, 25, 25, 25, 25, 89, 25, 25, 25, 25, 25, 25, 25, 90,\n-   91, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 92, 25, 25, 25, 25,\n-   25, 25, 25, 25, 25, 25, 25, 25, 25, 93, 35, 35, 35, 35, 35, 35,\n-   25, 94, 35, 35, 25, 25, 25, 25, 25, 25, 25, 25, 25, 95, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35, 35, 35, 35, 96,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   19,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0,\n-    0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19,  0,  0,  0,  0,  0,\n-   26, 26,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n-    1,  1,  1,  1,  1,  1,  9,  9,  9,  9,  0,  9,  9,  9,  2,  2,\n-    9,  9,  9,  9,  0,  9,  2,  2,  2,  2,  9,  0,  9,  0,  9,  9,\n-    9,  2,  9,  2,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9, 55, 55, 55, 55, 55, 55, 55, 55,\n-   55, 55, 55, 55, 55, 55,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n-    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  1,  1,  6,  6,  6,\n-    6,  6,  6,  6,  6,  6,  2,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n-    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n-    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2,  4,\n-    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n-    4,  2,  2,  4,  4,  4,  2, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  2,  2,\n-    2,  2,  2,  2,  2,  2, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14,  2,  2,  2,  2, 14, 14, 14, 14, 14, 14,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  0,  3,  3,  3,  3,\n-    3,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  0,  3,  2,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n+   25, 25, 25, 25, 25, 25, 25, 93, 25, 25, 25, 25, 25, 25, 25, 94,\n+   95, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 96, 25, 25, 25, 25,\n+   25, 25, 25, 25, 25, 25, 25, 25, 25, 97, 34, 34, 34, 34, 34, 34,\n+   25, 98, 34, 34, 25, 25, 25, 25, 25, 25, 25, 25, 25, 99, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34,100,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n+   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n+   19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   19,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n+   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0, 19, 19,\n+   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0,\n+    0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19,  0,  0,  0,  0,  0,\n+   26, 26,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n+    1,  1,  1,  1,  1,  1,  9,  9,  9,  9,  0,  9,  9,  9,  2,  2,\n+    9,  9,  9,  9,  0,  9,  2,  2,  2,  2,  9,  0,  9,  0,  9,  9,\n+    9,  2,  9,  2,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9, 55, 55, 55, 55, 55, 55, 55, 55,\n+   55, 55, 55, 55, 55, 55,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,\n+    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  1,  1,  6,  6,  6,\n+    6,  6,  6,  6,  6,  6,  2,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n+    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n+    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  2,  4,\n+    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n+    4,  2,  2,  4,  4,  4,  2, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n+   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n+   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  2,  2,\n+    2,  2,  2,  2,  2,  2, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n+   14,  2,  2,  2,  2, 14, 14, 14, 14, 14, 14,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  0,  3,  3,  3,  3,\n+    3,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n+    3,  0,  3,  3,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n@@ -2310,4 +2333,2 @@\n-   37,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  2,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,\n+   37,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n+    3,  3,  3,  3,  3,  2,  3,  3,  2,  2,  2,  2,  2,  2,  3,  3,\n@@ -2362,1 +2383,1 @@\n-    2,  2,  2, 23, 23, 23, 23, 23, 23, 23, 23,  2, 23, 23, 23,  2,\n+    2,  2, 23, 23, 23, 23, 23, 23, 23, 23, 23,  2, 23, 23, 23,  2,\n@@ -2364,1 +2385,1 @@\n-   23,  2,  2,  2,  2,  2, 23, 23, 23, 23,  2,  2, 23, 23, 23, 23,\n+   23,  2,  2, 23,  2,  2, 23, 23, 23, 23,  2,  2, 23, 23, 23, 23,\n@@ -2372,1 +2393,1 @@\n-    2,  2,  2,  2, 16,  2, 16, 16, 16, 16,  2,  2, 16, 16, 16, 16,\n+    2,  2,  2, 16, 16,  2, 16, 16, 16, 16,  2,  2, 16, 16, 16, 16,\n@@ -2392,1 +2413,2 @@\n-   24, 24,  2,  2,  2,  2,  2, 18, 18,  2, 18,  2, 18, 18, 18, 18,\n+   24, 24,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  2, 18, 18,  2, 18,  2, 18, 18, 18, 18,\n@@ -2427,2 +2449,2 @@\n-   45, 45, 45,  2, 45, 45, 45, 45, 45, 45, 45,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n+   45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2, 45, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n@@ -2438,1 +2460,1 @@\n-   32, 32, 32, 32, 32,  2, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n@@ -2461,2 +2483,2 @@\n-   91, 91, 91, 91,  2,  2,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,\n+   91, 91, 91, 91,  2,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n+    1,  1,  1,  1,  1,  2, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,\n@@ -2464,2 +2486,2 @@\n-   62, 62,  2,  2,  2,  2, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,\n-   62, 62, 62,  2,  2,  2, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76,\n+   62, 62, 62,  2,  2,  2, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,\n+   62, 62, 62, 62, 62,  2, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76,\n@@ -2483,2 +2505,1 @@\n-   19, 19, 19, 19, 19,  9,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n-    2,  1,  1,  1,  1,  1,  9,  9,  9,  9,  9,  9,  2,  2,  9,  9,\n+   19, 19, 19, 19, 19,  9,  9,  9,  9,  9,  9,  9,  2,  2,  9,  9,\n@@ -2495,1 +2516,3 @@\n-   19, 19, 19,  2,  2,  2,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,\n+   19, 19, 19,  2,  2,  2,  0,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  9,  0,  0,  0,\n@@ -2505,2 +2528,1 @@\n-   56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n-   56, 56, 56, 56, 56,  2, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55,\n+   56, 56, 56, 56, 56, 56, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55,\n@@ -2513,2 +2535,2 @@\n-   30, 30, 30, 30, 30,  2,  0,  0,  0,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   30, 30, 30, 30, 30,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n@@ -2536,2 +2558,1 @@\n-    0,  0,  0,  0,  0,  0, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-   13, 13, 13,  2,  2,  2, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,\n+    0,  0,  0,  0,  0,  0, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,\n@@ -2547,2 +2568,3 @@\n-    0, 19, 19, 19, 19, 19,  2,  2, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19,\n+    0, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n+   19,  2,  2,  2,  2,  2, 19, 19,  2, 19,  2, 19, 19, 19, 19, 19,\n+    2,  2,  2,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19, 19, 19,\n@@ -2590,3 +2612,2 @@\n-   14, 14, 14, 14, 14, 14,  3,  3,  2,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  0,  0,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,\n+   14, 14, 14, 14, 14, 14,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,\n@@ -2594,1 +2615,3 @@\n-    3,  3,  3,  3,  2,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n+    3,  3,  3,  3,  0,  0,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,\n+    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  2,\n+    2,  2,  2,  2,  2,  3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n@@ -2597,1 +2620,2 @@\n-    0,  0,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n+    0,  0,  2,  2,  2,  2,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,\n+    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n@@ -2645,1 +2669,5 @@\n-    2,  2,  2,  2,  2,104,110,110,110,110,110,110,110,110,110,110,\n+    2,  2,  2,  2,  2,104,161,161,161,161,161,161,161,161,161,161,\n+  161,  2,161,161,161,161,161,161,161,  2,161,161,  2,161,161,161,\n+  161,161,161,161,161,161,161,161,  2,161,161,161,161,161,161,161,\n+  161,161,161,161,161,161,161,161,  2,161,161,161,161,161,161,161,\n+    2,161,161,  2,  2,  2,110,110,110,110,110,110,110,110,110,110,\n@@ -2649,1 +2677,3 @@\n-    2,  2,  2,  2,  2,  2, 47, 47, 47, 47, 47, 47,  2,  2, 47,  2,\n+    2,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19,  2, 19, 19, 19,\n+   19, 19, 19, 19, 19, 19, 19,  2, 19, 19, 19, 19, 19, 19, 19, 19,\n+   19,  2,  2,  2,  2,  2, 47, 47, 47, 47, 47, 47,  2,  2, 47,  2,\n@@ -2695,2 +2725,1 @@\n-    2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  2,156,156,156,156,156,156,156,156,156,156,\n+    2,  2,  2,  2,  2,  2,156,156,156,156,156,156,156,156,156,156,\n@@ -2703,0 +2732,2 @@\n+    2,  2,  2,  2,  2,  2,158,158,158,158,158,158,158,158,158,158,\n+  158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,\n@@ -2710,1 +2741,1 @@\n-   94, 94, 94, 94, 94, 94,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+   94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,  2,  2,  2,  2,\n@@ -2712,1 +2743,1 @@\n-   85, 85, 85, 85, 85, 85, 85, 85,  2,  2,  2,  2,  2,  2,  2,  2,\n+   85, 85, 85, 85, 85, 85, 85, 85, 85,  2,  2,  2,  2,  2,  2,  2,\n@@ -2755,2 +2786,1 @@\n-  102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,  2,\n-    2,  2,  2,  2,  2,  2,102,102,102,102,102,102,102,102,102,102,\n+  102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,\n@@ -2760,1 +2790,2 @@\n-  126,126,  2,  2,  2,  2,142,142,142,142,142,142,142,142,142,142,\n+  126,126,  2,  2,  2,  2,126,126,126,126,126,126,126,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,142,142,142,142,142,142,142,142,142,142,\n@@ -2808,0 +2839,2 @@\n+    2,  2,  2,  2,  2,  2,157,157,157,157,157,157,157,157,157,157,\n+  157,157,157,157,157,157,157,157,157,  2,  2,  2,  2,  2,  2,  2,\n@@ -2817,1 +2850,4 @@\n-    2,  2,  2,  2,115,115,103,103,103,103,103,103,103,103,103,103,\n+    2,  2,  2,  2,115,115,159,159,159,159,159,159,159,159,159,159,\n+  159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,\n+  159,159,159,159,159,  2,159,159,159,159,159,159,159,159,159,159,\n+    2,  2,  2,  2,  2,  2,103,103,103,103,103,103,103,103,103,103,\n@@ -2830,1 +2866,1 @@\n-    2,  2,  2,  2,  2, 99,136,139,  0,  0,155,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2, 99,136,139, 13, 13,155,  2,  2,  2,  2,  2,\n@@ -2837,3 +2873,4 @@\n-    2,  2,  2,  2,  2,  2, 17, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15,  2, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2, 17, 17, 17, 17,  2, 17, 17, 17, 17, 17,\n+   17, 17,  2, 17, 17,  2, 17, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n+   15, 15, 15, 15, 15, 15, 17, 17, 17,  2,  2,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,\n@@ -2848,1 +2885,3 @@\n-    2,  2,105,105,105,105,  0,  0,  0,  0,  0,  0,  2,  2,  2,  2,\n+    2,  2,105,105,105,105,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n+    1,  1,  1,  1,  2,  2,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  2,  2,  2,  2,\n@@ -2854,2 +2893,2 @@\n-    1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,\n-    2,  2,  2,  2,  2,  2,  9,  9,  9,  9,  9,  9,  2,  2,  2,  2,\n+    1,  1,  1,  1,  0,  0,  9,  9,  9,  9,  9,  9,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,\n@@ -2871,1 +2910,2 @@\n-  131,131,131,131,131,131, 56, 56, 56, 56, 56, 56, 56,  2, 56, 56,\n+  131,131,131,131,131,131, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n+   19, 19, 19, 19, 19,  2, 56, 56, 56, 56, 56, 56, 56,  2, 56, 56,\n@@ -2878,1 +2918,3 @@\n-    2,  2,  2,  2,151,151,152,152,152,152,152,152,152,152,152,152,\n+    2,  2,  2,  2,151,151,160,160,160,160,160,160,160,160,160,160,\n+  160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,\n+  160,160,160,160,160,  2,152,152,152,152,152,152,152,152,152,152,\n@@ -2880,1 +2922,3 @@\n-    2,  2,  2,  2,  2,152,113,113,113,113,113,113,113,113,113,113,\n+    2,  2,  2,  2,  2,152, 30, 30, 30, 30, 30, 30, 30,  2, 30, 30,\n+   30, 30,  2, 30, 30,  2, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n+   30, 30, 30, 30, 30,  2,113,113,113,113,113,113,113,113,113,113,\n@@ -2887,2 +2931,1 @@\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  2,  2,  3,  3,  3,  3,  2,  3,  3,  3,  3,  3,\n+    2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  2,  3,  3,  3,  3,  3,\n@@ -2898,1 +2941,2 @@\n-    2,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  0,  0,  0,  0,\n+    2,  3,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  0,  0,  0,  0,\n@@ -2902,4 +2946,3 @@\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  2,  2,  2,  0,  0,\n-    0,  2,  2,  2,  2,  2, 13, 13, 13, 13, 13,  2,  2,  2,  2,  2,\n+    2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  2,  2,\n+    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  2,  2,  2,  0,  0,\n+    0,  0,  0,  2,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,\n@@ -3102,1 +3145,1 @@\n-_hb_ucd_u16[11328] =\n+_hb_ucd_u16[11584] =\n@@ -3112,8 +3155,8 @@\n-    48,  67,  68,  69,  48,  70,  71,  72,  72,  72,  48,  73,  74,  75,  76,  32,\n-    77,  48,  48,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,\n-    91,  84,  85,  92,  93,  94,  95,  96,  97,  98,  85,  99, 100, 101,  89, 102,\n-   103,  84,  85, 104, 105, 106,  89, 107, 108, 109, 110, 111, 112, 113,  95, 114,\n-   115, 116,  85, 117, 118, 119,  89, 120, 121, 116,  85, 122, 123, 124,  89, 125,\n-   126, 116,  48, 127, 128, 129,  89, 130, 131, 132,  48, 133, 134, 135,  95, 136,\n-   137,  48,  48, 138, 139, 140,  72,  72, 141,  48, 142, 143, 144, 145,  72,  72,\n-   146, 147, 148, 149, 150,  48, 151, 152, 153, 154,  32, 155, 156, 157,  72,  72,\n+    48,  67,  68,  69,  48,  70,  71,  48,  72,  73,  48,  48,  74,  32,  75,  32,\n+    76,  48,  48,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,\n+    90,  83,  84,  91,  92,  93,  94,  95,  96,  97,  84,  98,  99, 100,  88, 101,\n+   102,  83,  84, 103, 104, 105,  88, 106, 107, 108, 109, 110, 111, 112,  94, 113,\n+   114, 115,  84, 116, 117, 118,  88, 119, 120, 115,  84, 121, 122, 123,  88, 124,\n+   125, 115,  48, 126, 127, 128,  88, 129, 130, 131,  48, 132, 133, 134,  94, 135,\n+   136,  48,  48, 137, 138, 139, 140, 140, 141,  48, 142, 143, 144, 145, 140, 140,\n+   146, 147, 148, 149, 150,  48, 151, 152, 153, 154,  32, 155, 156, 157, 140, 140,\n@@ -3127,1 +3170,1 @@\n-   184, 185,  48, 186,  48, 187, 184, 188,  48,  48,  48, 189, 190, 191, 192, 193,\n+    48, 184,  48, 185,  48, 186, 187, 188,  48,  48,  48, 189, 190, 191, 192, 193,\n@@ -3130,1 +3173,1 @@\n-    48, 210,  48,  48,  48, 211, 212, 213, 192, 192, 214, 215, 216,  72,  72,  72,\n+    48, 210,  48,  48,  48, 211, 212, 213, 192, 192, 214, 215, 216, 140, 140, 140,\n@@ -3133,11 +3176,11 @@\n-    11,  11, 236,  27,  27,  27, 237, 238,  11, 239,  27,  27,  32,  32,  32, 240,\n-    13,  13,  13,  13,  13,  13,  13,  13,  13, 241,  13,  13,  13,  13,  13,  13,\n-   242, 243, 242, 242, 243, 244, 242, 245, 246, 246, 246, 247, 248, 249, 250, 251,\n-   252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 262,  72, 263, 264, 216,\n-   265, 266, 267, 268, 269, 270, 271, 271, 272, 273, 274, 209, 275, 276, 209, 277,\n-   278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n-   279, 209, 280, 209, 209, 209, 209, 281, 209, 282, 278, 283, 209, 284, 285, 209,\n-   209, 209, 286,  72, 287,  72, 270, 270, 270, 288, 209, 209, 209, 209, 289, 270,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 290, 291, 209, 209, 292,\n-   209, 209, 209, 209, 209, 209, 293, 209, 209, 209, 209, 209, 209, 209, 209, 209,\n-   209, 209, 209, 209, 209, 209, 294, 295, 270, 296, 209, 209, 297, 278, 298, 278,\n+    11,  11, 236,  27,  27,  27, 237, 238,  11, 239,  27,  27,  32,  32,  32,  32,\n+    13,  13,  13,  13,  13,  13,  13,  13,  13, 240,  13,  13,  13,  13,  13,  13,\n+   241, 242, 241, 241, 242, 243, 241, 244, 245, 245, 245, 246, 247, 248, 249, 250,\n+   251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 261, 262, 263, 264, 265,\n+   266, 267, 268, 269, 270, 271, 272, 272, 273, 274, 275, 209, 276, 277, 209, 278,\n+   279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n+   280, 209, 281, 209, 209, 209, 209, 282, 209, 283, 279, 284, 209, 285, 286, 209,\n+   209, 209, 287, 140, 288, 140, 271, 271, 271, 289, 209, 209, 209, 209, 290, 271,\n+   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 291, 292, 209, 209, 293,\n+   209, 209, 209, 209, 209, 209, 294, 209, 209, 209, 209, 209, 209, 209, 209, 209,\n+   209, 209, 209, 209, 209, 209, 295, 296, 271, 297, 209, 209, 298, 279, 299, 279,\n@@ -3145,10 +3188,10 @@\n-   278, 278, 278, 278, 278, 278, 278, 278, 299, 300, 278, 278, 278, 301, 278, 302,\n-   278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n-   209, 209, 209, 278, 303, 209, 209, 304, 209, 305, 209, 209, 209, 209, 209, 209,\n-     9,   9, 306,  11,  11, 307, 308, 309,  13,  13,  13,  13,  13,  13, 310, 311,\n-    11,  11, 312,  48,  48,  48, 313, 314,  48, 315, 316, 316, 316, 316,  32,  32,\n-   317, 318, 319, 320, 321, 322,  72,  72, 209, 323, 209, 209, 209, 209, 209, 324,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 325,  72, 326,\n-   327, 328, 329, 330, 137,  48,  48,  48,  48, 331, 178,  48,  48,  48,  48, 332,\n-   333,  48,  48, 137,  48,  48,  48,  48, 200, 334,  48,  48, 209, 209, 324,  48,\n-   209, 335, 336, 209, 337, 338, 209, 209, 336, 209, 209, 338, 209, 209, 209, 209,\n+   279, 279, 279, 279, 279, 279, 279, 279, 300, 301, 279, 279, 279, 302, 279, 303,\n+   279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279, 279,\n+   209, 209, 209, 279, 304, 209, 209, 305, 209, 306, 209, 209, 209, 209, 209, 209,\n+     9,   9,   9,  11,  11,  11, 307, 308,  13,  13,  13,  13,  13,  13, 309, 310,\n+    11,  11, 311,  48,  48,  48, 312, 313,  48, 314, 315, 315, 315, 315,  32,  32,\n+   316, 317, 318, 319, 320, 321, 140, 140, 209, 322, 209, 209, 209, 209, 209, 323,\n+   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 324, 140, 325,\n+   326, 327, 328, 329, 136,  48,  48,  48,  48, 330, 178,  48,  48,  48,  48, 331,\n+   332,  48,  48, 136,  48,  48,  48,  48, 200, 333,  48,  48, 209, 209, 323,  48,\n+   209, 334, 335, 209, 336, 337, 209, 209, 335, 209, 209, 337, 209, 209, 209, 209,\n@@ -3160,0 +3203,1 @@\n+    48, 338,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n@@ -3161,2 +3205,1 @@\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 151,\n-    48, 339,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n+    48,  48,  48,  48,  48,  48,  48,  48, 151, 209, 209, 209, 287,  48,  48, 229,\n@@ -3164,4 +3207,2 @@\n-    48,  48,  48,  48,  48,  48,  48,  48, 151, 209, 209, 209, 286,  48,  48, 229,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n-   340,  48, 341,  72,  13,  13, 342, 343,  13, 344,  48,  48,  48,  48, 345, 346,\n-    31, 347, 348, 349,  13,  13,  13, 350, 351, 352, 353, 354, 355,  72,  72, 356,\n+   339,  48, 340, 140,  13,  13, 341, 342,  13, 343,  48,  48,  48,  48, 344, 345,\n+    31, 346, 347, 348,  13,  13,  13, 349, 350, 351, 352, 353, 354, 355, 140, 356,\n@@ -3169,1 +3210,1 @@\n-    64,  48, 365,  48, 366, 367,  48, 151,  77,  48,  48, 368, 369, 370, 371, 372,\n+    64,  48, 365,  48, 366, 367,  48, 151,  76,  48,  48, 368, 369, 370, 371, 372,\n@@ -3171,1 +3212,1 @@\n-   383, 384, 316,  11,  11, 385, 386,  11,  11,  11,  11,  11,  48,  48, 387, 192,\n+   383, 384, 315,  11,  11, 385, 386,  11,  11,  11,  11,  11,  48,  48, 387, 192,\n@@ -3180,1 +3221,1 @@\n-    48,  48,  48,  48,  48,  48, 204,  48,  48,  48,  48,  48,  48, 207,  72,  72,\n+    48,  48,  48,  48,  48,  48, 204,  48,  48,  48,  48,  48,  48, 207, 140, 140,\n@@ -3183,9 +3224,9 @@\n-    48,  48,  48, 400,  72,  48,  48,  48,  48, 401,  48,  48,  74,  72,  72, 402,\n-    32, 403,  32, 404, 405, 406, 407,  73,  48,  48,  48,  48,  48,  48,  48, 408,\n-   409,   2,   3,   4,   5, 410, 411, 412,  48, 413,  48, 200, 414, 415, 416, 417,\n-   418,  48, 172, 419, 204, 204,  72,  72,  48,  48,  48,  48,  48,  48,  48,  71,\n-   420, 270, 270, 421, 271, 271, 271, 422, 423, 424, 425,  72,  72, 209, 209, 426,\n-    72,  72,  72,  72,  72,  72,  72,  72,  48, 151,  48,  48,  48, 101, 427, 428,\n-    48,  48, 429,  48, 430,  48,  48, 431,  48, 432,  48,  48, 433, 434,  72,  72,\n-     9,   9, 435,  11,  11,  48,  48,  48,  48, 204, 192,   9,   9, 436,  11, 437,\n-    48,  48,  74,  48,  48,  48, 438,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n+    48,  48,  48, 400, 209,  48,  48,  48,  48, 401,  48,  48, 402, 140, 140, 403,\n+    32, 404,  32, 405, 406, 407, 408, 409,  48,  48,  48,  48,  48,  48,  48, 410,\n+   411,   2,   3,   4,   5, 412, 413, 414,  48, 415,  48, 200, 416, 417, 418, 419,\n+   420,  48, 172, 421, 204, 204, 140, 140,  48,  48,  48,  48,  48,  48,  48,  71,\n+   422, 271, 271, 423, 272, 272, 272, 424, 425, 426, 427, 140, 140, 209, 209, 428,\n+   140, 140, 140, 140, 140, 140, 140, 140,  48, 151,  48,  48,  48, 100, 429, 430,\n+    48,  48, 431,  48, 432,  48,  48, 433,  48, 434,  48,  48, 435, 436, 140, 140,\n+     9,   9, 437,  11,  11,  48,  48,  48,  48, 204, 192,   9,   9, 438,  11, 439,\n+    48,  48, 440,  48,  48,  48, 441, 442, 442, 443, 444, 445, 140, 140, 140, 140,\n@@ -3193,25 +3234,25 @@\n-    48,  48,  48, 315,  48, 199,  74,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-   439,  48,  48, 440,  48, 441,  48, 442,  48, 200, 443,  72,  72,  72,  48, 444,\n-    48, 445,  48, 446,  72,  72,  72,  72,  48,  48,  48, 447, 270, 448, 270, 270,\n-   449, 450,  48, 451, 452, 453,  48, 454,  48, 455,  72,  72, 456,  48, 457, 458,\n-    48,  48,  48, 459,  48, 460,  48, 461,  48, 462, 463,  72,  72,  72,  72,  72,\n-    48,  48,  48,  48, 196,  72,  72,  72,   9,   9,   9, 464,  11,  11,  11, 465,\n-    48,  48, 466, 192,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72, 270, 467,  48,  48, 468, 469,  72,  72,  72,  72,\n-    48, 455, 470,  48,  62, 471,  72,  72,  72,  72,  72,  48, 472,  72,  48, 315,\n-   473,  48,  48, 474, 475, 448, 476, 477, 222,  48,  48, 478, 479,  48, 196, 192,\n-   480,  48, 481, 482, 483,  48,  48, 484, 222,  48,  48, 485, 486, 487, 488, 489,\n-    48,  98, 490, 491,  72,  72,  72,  72, 492, 493, 494,  48,  48, 495, 496, 192,\n-   497,  84,  85, 498, 499, 500, 501, 502,  72,  72,  72,  72,  72,  72,  72,  72,\n-    48,  48,  48, 503, 504, 505, 469,  72,  48,  48,  48, 506, 507, 192,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  48,  48, 508, 509, 510, 511,  72,  72,\n-    48,  48,  48, 512, 513, 192, 514,  72,  48,  48, 515, 516, 192,  72,  72,  72,\n-    48, 173, 517, 518,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    48,  48, 490, 519,  72,  72,  72,  72,  72,  72,   9,   9,  11,  11, 148, 520,\n-   521, 522,  48, 523, 524, 192,  72,  72,  72,  72, 525,  48,  48, 526, 527,  72,\n-   528,  48,  48, 529, 530, 531,  48,  48, 532, 533, 534,  72,  48,  48,  48, 196,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    85,  48, 508, 535, 536, 148, 175, 537,  48, 538, 539, 540,  72,  72,  72,  72,\n-   541,  48,  48, 542, 543, 192, 544,  48, 545, 546, 192,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  48, 547,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72, 101, 270, 548, 549, 550,\n+    48,  48,  48, 314,  48, 199, 440, 140, 446,  27,  27, 447, 140, 140, 140, 140,\n+   448,  48,  48, 449,  48, 450,  48, 451,  48, 200, 452, 140, 140, 140,  48, 453,\n+    48, 454,  48, 455, 140, 140, 140, 140,  48,  48,  48, 456, 271, 457, 271, 271,\n+   458, 459,  48, 460, 461, 462,  48, 463,  48, 464, 140, 140, 465,  48, 466, 467,\n+    48,  48,  48, 468,  48, 469,  48, 470,  48, 471, 472, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48, 196, 140, 140, 140,   9,   9,   9, 473,  11,  11,  11, 474,\n+    48,  48, 475, 192, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 271, 476,  48,  48, 477, 478, 140, 140, 140, 140,\n+    48, 464, 479,  48,  62, 480, 140,  48, 481, 140, 140,  48, 482, 140,  48, 314,\n+   483,  48,  48, 484, 485, 457, 486, 487, 222,  48,  48, 488, 489,  48, 196, 192,\n+   490,  48, 491, 492, 493,  48,  48, 494, 222,  48,  48, 495, 496, 497, 498, 499,\n+    48,  97, 500, 501, 140, 140, 140, 140, 502, 503, 504,  48,  48, 505, 506, 192,\n+   507,  83,  84, 508, 509, 510, 511, 512, 140, 140, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48, 513, 514, 515, 478, 140,  48,  48,  48, 516, 517, 192, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140,  48,  48, 518, 519, 520, 521, 140, 140,\n+    48,  48,  48, 522, 523, 192, 524, 140,  48,  48, 525, 526, 192, 140, 140, 140,\n+    48, 173, 527, 528, 314, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+    48,  48, 500, 529, 140, 140, 140, 140, 140, 140,   9,   9,  11,  11, 148, 530,\n+   531, 532,  48, 533, 534, 192, 140, 140, 140, 140, 535,  48,  48, 536, 537, 140,\n+   538,  48,  48, 539, 540, 541,  48,  48, 542, 543, 544,  48,  48,  48,  48, 196,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+    84,  48, 518, 545, 546, 148, 175, 547,  48, 548, 549, 550, 140, 140, 140, 140,\n+   551,  48,  48, 552, 553, 192, 554,  48, 555, 556, 192, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,  48, 557,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 100, 271, 558, 559, 560,\n@@ -3219,13 +3260,15 @@\n-    48,  48,  48,  48,  48,  48,  48,  48,  48, 207,  72,  72,  72,  72,  72,  72,\n-   271, 271, 271, 271, 271, 271, 551, 552,  48,  48,  48,  48,  48,  48,  48,  48,\n-    48,  48,  48,  48, 388,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    48,  48, 200, 553,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    48,  48,  48,  48, 315,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    48,  48,  48, 196,  48, 200, 370,  72,  72,  72,  72,  72,  72,  48, 204, 554,\n-    48,  48,  48, 555, 556, 557, 558, 559,  48,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,   9,   9,  11,  11, 270, 560,  72,  72,  72,  72,  72,  72,\n-    48,  48,  48,  48, 561, 562, 563, 563, 564, 565,  72,  72,  72,  72, 566, 567,\n+    48,  48,  48,  48,  48,  48,  48,  48,  48, 207, 140, 140, 140, 140, 140, 140,\n+   272, 272, 272, 272, 272, 272, 561, 562,  48,  48,  48,  48,  48,  48,  48,  48,\n+    48,  48,  48,  48, 388, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140,  48,  48,  48,  48,  48,  48, 563,\n+    48,  48, 200, 564, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48, 314, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48, 196,  48, 200, 370,  48,  48,  48,  48, 200, 192,  48, 204, 565,\n+    48,  48,  48, 566, 567, 568, 569, 570,  48, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140,   9,   9,  11,  11, 271, 571, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48, 572, 573, 574, 574, 575, 576, 140, 140, 140, 140, 577, 578,\n@@ -3233,3 +3276,5 @@\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  74,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 199,  72,  72,\n-   196,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n+    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 440,\n+    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 199, 140, 140,\n+   196, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 579,\n@@ -3237,1 +3282,1 @@\n-    48, 200,  72,  72,  72, 568, 569,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n+    48,  48, 580, 140, 140, 580, 581,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n@@ -3239,11 +3284,14 @@\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    48,  48,  48,  48,  48,  48,  71, 151, 196, 570, 571,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 325,\n-   209, 209, 572, 209, 209, 209, 573, 574, 575, 209, 576, 209, 209, 209, 577,  72,\n-   209, 209, 209, 209, 578,  72,  72,  72,  72,  72,  72,  72,  72,  72, 270, 579,\n-   209, 209, 209, 209, 209, 286, 270, 452,  72,  72,  72,  72,  72,  72,  72,  72,\n-     9, 580,  11, 581, 582, 583, 242,   9, 584, 585, 586, 587, 588,   9, 580,  11,\n-   589, 590,  11, 591, 592, 593, 594,   9, 595,  11,   9, 580,  11, 581, 582,  11,\n-   242,   9, 584, 594,   9, 595,  11,   9, 580,  11, 596,   9, 597, 598, 599, 600,\n-    11, 601,   9, 602, 603, 604, 605,  11, 606,   9, 607,  11, 608, 609, 609, 609,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48,  48,  48,  71, 151, 196, 582, 583, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+    32,  32, 584,  32, 585, 209, 209, 209, 209, 209, 209, 209, 323, 140, 140, 140,\n+   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 324,\n+   209, 209, 586, 209, 209, 209, 587, 588, 589, 209, 590, 209, 209, 209, 288, 140,\n+   209, 209, 209, 209, 591, 140, 140, 140, 140, 140, 140, 140, 140, 140, 271, 592,\n+   209, 209, 209, 209, 209, 287, 271, 461, 140, 140, 140, 140, 140, 140, 140, 140,\n+     9, 593,  11, 594, 595, 596, 241,   9, 597, 598, 599, 600, 601,   9, 593,  11,\n+   602, 603,  11, 604, 605, 606, 607,   9, 608,  11,   9, 593,  11, 594, 595,  11,\n+   241,   9, 597, 607,   9, 608,  11,   9, 593,  11, 609,   9, 610, 611, 612, 613,\n+    11, 614,   9, 615, 616, 617, 618,  11, 619,   9, 620,  11, 621, 622, 622, 622,\n+   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209,\n@@ -3251,0 +3299,23 @@\n+    32,  32,  32, 623,  32,  32, 624, 625, 626, 627,  45, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   628, 629, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   630, 631, 632, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+    48,  48, 151, 633, 634, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140,  48, 635, 140,  48,  48, 636, 637,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 638, 200,\n+    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 639, 585, 140, 140,\n+     9,   9, 597,  11, 640, 370, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 498, 271, 271, 641, 642, 140, 140, 140, 140,\n+   498, 271, 643, 644, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   645,  48, 646, 647, 648, 649, 650, 651, 652, 206, 653, 206, 140, 140, 140, 654,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   209, 209, 325, 209, 209, 209, 209, 209, 209, 323, 334, 655, 655, 655, 209, 324,\n+   656, 209, 209, 209, 209, 209, 209, 209, 209, 209, 657, 140, 140, 140, 658, 209,\n+   659, 209, 209, 325, 660, 661, 324, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 662,\n+   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 663, 426, 426,\n+   209, 209, 209, 209, 209, 209, 209, 323, 209, 209, 209, 209, 209, 660, 325, 427,\n+   325, 209, 209, 209, 664, 176, 209, 209, 664, 209, 657, 661, 140, 140, 140, 140,\n@@ -3252,23 +3323,3 @@\n-    32,  32,  32, 610,  32,  32, 611, 612, 613, 614,  45,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-   615, 616, 617,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    48,  48, 151, 618, 619,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  48,  48, 620, 621,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 622, 623,  72,  72,\n-     9,   9, 584,  11, 624, 370,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72, 488, 270, 270, 625, 626,  72,  72,  72,  72,\n-   488, 270, 627, 628,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-   629,  48, 630, 631, 632, 633, 634, 635, 636, 206, 637, 206,  72,  72,  72, 638,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-   209, 209, 326, 209, 209, 209, 209, 209, 209, 324, 335, 639, 639, 639, 209, 325,\n-   640, 209, 209, 209, 209, 209, 209, 209, 209, 209, 641,  72,  72,  72, 642, 209,\n-   643, 209, 209, 326, 577, 644, 325,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 645,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 209, 646, 424, 424,\n-   209, 209, 209, 209, 209, 209, 209, 324, 209, 209, 209, 209, 209, 577, 326,  72,\n-   326, 209, 209, 209, 646, 176, 209, 209, 646, 209, 641, 644,  72,  72,  72,  72,\n-   209, 209, 209, 209, 209, 209, 209, 647, 209, 209, 209, 209, 648, 209, 209, 209,\n-   209, 209, 209, 209, 209, 324, 641, 649, 286, 209, 577, 286, 643, 286,  72,  72,\n-   209, 209, 209, 209, 209, 209, 209, 209, 209, 650, 209, 209, 287,  72,  72, 192,\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 204,  72,  72,\n+   209, 209, 209, 209, 209, 323, 657, 665, 287, 209, 426, 288, 324, 176, 664, 287,\n+   209, 209, 209, 209, 209, 209, 209, 209, 209, 666, 209, 209, 288, 140, 140, 192,\n+    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 140, 140,\n@@ -3277,1 +3328,1 @@\n-    48,  48,  48, 205,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n+    48,  48,  48, 196,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,\n@@ -3280,1 +3331,1 @@\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 469,  48,  48,  48,  48,  48,\n+    48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 478,  48,  48,  48,  48,  48,\n@@ -3283,3 +3334,3 @@\n-    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 101,  72,\n-    48, 204,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n+    48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 100, 140,\n+    48, 204, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n@@ -3287,3 +3338,3 @@\n-    48,  48,  48,  48,  71,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,\n-   651,  72, 652, 652, 652, 652, 652, 652,  72,  72,  72,  72,  72,  72,  72,  72,\n-    32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  72,\n+    48,  48,  48,  48,  71, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140,\n+   667, 140, 668, 668, 668, 668, 668, 668, 140, 140, 140, 140, 140, 140, 140, 140,\n+    32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 140,\n@@ -3291,1 +3342,1 @@\n-   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 653,\n+   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 669,\n@@ -3293,1 +3344,1 @@\n-   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 654,\n+   391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 391, 670,\n@@ -3302,22 +3353,22 @@\n-    39,  39,  40,  41,  42,  43,  44,  45,  45,  45,  27,  46,  47,  48,  49,  27,\n-    50,  50,  50,  50,  50,  51,  52,  50,  53,  54,  55,  56,  57,  58,  59,  60,\n-    61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,\n-    77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,  92,\n-    93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106, 107, 108,\n-   109, 110, 111, 111, 112, 113, 114, 111, 115, 116, 117, 118, 119, 120, 121, 122,\n-   123, 124, 124, 125, 124, 126,  45,  45, 127, 128, 129, 130, 131, 132,  45,  45,\n-   133, 133, 133, 133, 134, 133, 135, 136, 133, 134, 133, 137, 137, 138,  45,  45,\n-   139, 139, 139, 139, 139, 139, 139, 139, 139, 139, 140, 140, 141, 140, 140, 142,\n-   143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143,\n-   144, 144, 144, 144, 145, 146, 144, 144, 145, 144, 144, 147, 148, 149, 144, 144,\n-   144, 148, 144, 144, 144, 150, 144, 151, 144, 152, 153, 153, 153, 153, 153, 154,\n-   155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155,\n-   155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155, 155,\n-   155, 155, 155, 155, 155, 155, 155, 155, 156, 157, 158, 158, 158, 158, 159, 160,\n-   161, 162, 163, 164, 165, 166, 167, 168, 169, 169, 169, 169, 169, 170, 171, 171,\n-   172, 173, 174, 174, 174, 174, 174, 175, 174, 174, 176, 155, 155, 155, 155, 177,\n-   178, 179, 180, 180, 181, 182, 183, 184, 185, 185, 186, 185, 187, 188, 169, 169,\n-   189, 190, 191, 191, 191, 192, 191, 193, 194, 194, 195,   8, 196,  45,  45,  45,\n-   197, 197, 197, 197, 198, 197, 197, 199, 200, 200, 200, 200, 201, 201, 201, 202,\n-   203, 203, 203, 204, 205, 206, 206, 206, 207, 140, 140, 208, 209, 210, 211, 212,\n-     4,   4, 213,   4,   4, 214, 215, 216,   4,   4,   4, 217,   8,   8,   8, 218,\n+    39,  39,  40,  41,  42,  43,  44,  27,  45,  46,  27,  27,  27,  27,  47,  27,\n+    48,  48,  48,  48,  48,  49,  50,  48,  51,  52,  53,  54,  55,  56,  57,  58,\n+    59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,\n+    75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,\n+    91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,\n+   107, 108, 109, 109, 110, 111, 112, 109, 113, 114, 115, 116, 117, 118, 119, 120,\n+   121, 122, 122, 123, 122, 124, 125, 125, 126, 127, 128, 129, 130, 131, 125, 125,\n+   132, 132, 132, 132, 133, 132, 134, 135, 132, 133, 132, 136, 136, 137, 125, 125,\n+   138, 138, 138, 138, 138, 138, 138, 138, 138, 138, 139, 139, 140, 139, 139, 141,\n+   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+   143, 143, 143, 143, 144, 145, 143, 143, 144, 143, 143, 146, 147, 148, 143, 143,\n+   143, 147, 143, 143, 143, 149, 143, 150, 143, 151, 152, 152, 152, 152, 152, 153,\n+   154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n+   154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154, 154,\n+   154, 154, 154, 154, 154, 154, 154, 154, 155, 156, 157, 157, 157, 157, 158, 159,\n+   160, 161, 162, 163, 164, 165, 166, 167, 168, 168, 168, 168, 168, 169, 170, 170,\n+   171, 172, 173, 173, 173, 173, 173, 174, 173, 173, 175, 154, 154, 154, 154, 176,\n+   177, 178, 179, 179, 180, 181, 182, 183, 184, 184, 185, 184, 186, 187, 168, 168,\n+   188, 189, 190, 190, 190, 191, 190, 192, 193, 193, 194,   8, 195, 125, 125, 125,\n+   196, 196, 196, 196, 197, 196, 196, 198, 199, 199, 199, 199, 200, 200, 200, 201,\n+   202, 202, 202, 203, 204, 205, 205, 205, 206, 139, 139, 207, 208, 209, 210, 211,\n+     4,   4, 212,   4,   4, 213, 214, 215,   4,   4,   4, 216,   8,   8,   8,   8,\n@@ -3325,2 +3376,2 @@\n-    11, 219,  11,  11, 219, 220,  11, 221,  11,  11,  11, 222, 222, 223,  11, 224,\n-   225,   0,   0,   0,   0,   0, 226, 227, 228, 229,   0,   0,  45,   8,   8, 196,\n+    11, 217,  11,  11, 217, 218,  11, 219,  11,  11,  11, 220, 220, 221,  11, 222,\n+   223,   0,   0,   0,   0,   0, 224, 225, 226, 227,   0,   0, 228,   8,   8, 229,\n@@ -3330,1 +3381,1 @@\n-     0,   0, 234,  45, 235,  45,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0, 234, 125, 235, 125,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n@@ -3336,34 +3387,32 @@\n-   239, 239, 240, 239, 239, 240,   4,   4, 241, 241, 241, 241, 241, 241, 241, 242,\n-   140, 140, 141, 243, 243, 243, 244, 245, 144, 246, 247, 247, 247, 247,  14,  14,\n-     0,   0,   0,   0,   0, 248,  45,  45, 249, 250, 249, 249, 249, 249, 249, 251,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 252,  45, 253,\n-   254,   0, 255, 256, 257, 258, 258, 258, 258, 259, 260, 261, 261, 261, 261, 262,\n-   263, 264, 264, 265, 143, 143, 143, 143, 266,   0, 264, 264,   0,   0, 267, 261,\n-   143, 266,   0,   0,   0,   0, 143, 268,   0,   0,   0,   0,   0, 261, 261, 269,\n-   261, 261, 261, 261, 261, 270,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,   0,   0,   0,   0,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 271,\n-   272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272,\n-   272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272, 272,\n-   272, 272, 272, 272, 272, 272, 272, 272, 273, 272, 272, 272, 274, 275, 275, 275,\n-   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n-   276, 276, 277,  45,  14,  14,  14,  14,  14,  14, 278, 278, 278, 278, 278, 279,\n-     0,   0, 280,   4,   4,   4,   4,   4, 281,   4,   4,   4, 282,  45,  45, 283,\n-   284, 284, 285, 286, 287, 287, 287, 288, 289, 289, 289, 289, 290, 291,  50,  50,\n-   292, 292, 293, 294, 294, 295, 143, 296, 297, 297, 297, 297, 298, 299, 139, 300,\n-   301, 301, 301, 302, 303, 304, 139, 139, 305, 305, 305, 305, 306, 307, 308, 309,\n-   310, 311, 247,   4,   4, 312, 313, 153, 153, 153, 153, 153, 308, 308, 314, 315,\n-   143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143,\n-   143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143,\n-   143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 143,\n-   143, 143, 143, 143, 143, 143, 143, 143, 143, 143, 316, 143, 317, 143, 143, 318,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 319, 249, 249, 249, 249, 249, 249, 320,  45,  45,\n-   321, 322,  21, 323, 324,  27,  27,  27,  27,  27,  27,  27, 325,  48,  27,  27,\n+   239, 239, 239, 239, 239, 239,   4,   4, 240, 240, 240, 240, 240, 240, 240, 241,\n+   139, 139, 140, 242, 242, 242, 243, 244, 143, 245, 246, 246, 246, 246,  14,  14,\n+     0,   0,   0,   0,   0, 247, 125, 125, 248, 249, 248, 248, 248, 248, 248, 250,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 251, 125, 252,\n+   253,   0, 254, 255, 256, 257, 257, 257, 257, 258, 259, 260, 260, 260, 260, 261,\n+   262, 263, 263, 264, 142, 142, 142, 142, 265,   0, 263, 263,   0,   0, 266, 260,\n+   142, 265,   0,   0,   0,   0, 142, 267,   0,   0,   0,   0,   0, 260, 260, 268,\n+   260, 260, 260, 260, 260, 269,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,   0,   0,   0,   0,\n+   270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270,\n+   270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270,\n+   270, 270, 270, 270, 270, 270, 270, 270, 271, 270, 270, 270, 272, 273, 273, 273,\n+   274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274, 274,\n+   274, 274, 275, 125,  14,  14,  14,  14,  14,  14, 276, 276, 276, 276, 276, 277,\n+     0,   0, 278,   4,   4,   4,   4,   4, 279,   4,   4,   4, 280, 281, 125, 282,\n+   283, 283, 284, 285, 286, 286, 286, 287, 288, 288, 288, 288, 289, 290,  48,  48,\n+   291, 291, 292, 293, 293, 294, 142, 295, 296, 296, 296, 296, 297, 298, 138, 299,\n+   300, 300, 300, 301, 302, 303, 138, 138, 304, 304, 304, 304, 305, 306, 307, 308,\n+   309, 310, 246,   4,   4, 311, 312, 152, 152, 152, 152, 152, 307, 307, 313, 314,\n+   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 142,\n+   142, 142, 142, 142, 142, 142, 142, 142, 142, 142, 315, 142, 316, 142, 142, 317,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 318, 248, 248, 248, 248, 248, 248, 319, 125, 125,\n+   320, 321,  21, 322, 323,  27,  27,  27,  27,  27,  27,  27, 324, 325,  27,  27,\n@@ -3371,45 +3420,36 @@\n-    27,  27,  27, 326,  45,  27,  27,  27,  27, 327,  27,  27,  47,  45,  45, 328,\n-     8, 286, 329,   0,   0, 330, 331,  46,  27,  27,  27,  27,  27,  27,  27, 332,\n-   333,   0,   1,   2,   1,   2, 334, 260, 261, 335, 143, 266, 336, 337, 338, 339,\n-   340, 341, 342, 343, 344, 344,  45,  45, 341, 341, 341, 341, 341, 341, 341, 345,\n-   346,   0,   0, 347,  11,  11,  11,  11, 348, 349, 350,  45,  45,   0,   0, 351,\n-    45,  45,  45,  45,  45,  45,  45,  45, 352, 353, 354, 354, 354, 355, 356, 253,\n-   357, 357, 358, 359, 360, 361, 361, 362, 363, 364, 365, 365, 366, 367,  45,  45,\n-   368, 368, 368, 368, 368, 369, 369, 369, 370, 371, 372, 373, 373, 374, 373, 375,\n-   376, 376, 377, 378, 378, 378, 379,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380, 380,\n-   380, 380, 380, 381, 380, 382, 383,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   384, 385, 385, 386, 387, 388, 389, 389, 390, 391, 392,  45,  45,  45, 393, 394,\n-   395, 396, 397, 398,  45,  45,  45,  45, 399, 399, 400, 401, 400, 402, 400, 400,\n-   403, 404, 405, 406, 407, 407, 408, 408, 409, 409,  45,  45, 410, 410, 411, 412,\n-   413, 413, 413, 414, 415, 416, 417, 418, 419, 420, 421,  45,  45,  45,  45,  45,\n-   422, 422, 422, 422, 423,  45,  45,  45, 424, 424, 424, 425, 424, 424, 424, 426,\n-   427, 427, 428, 429,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  27, 430, 431, 431, 432, 433,  45,  45,  45,  45,\n-   434, 434, 435, 436, 436, 437,  45,  45,  45,  45,  45, 438, 439,  45, 440, 441,\n-   442, 442, 442, 442, 443, 444, 442, 445, 446, 446, 446, 446, 447, 448, 449, 450,\n-   451, 451, 451, 452, 453, 454, 454, 455, 456, 456, 456, 456, 456, 456, 457, 458,\n-   459, 460, 459, 461,  45,  45,  45,  45, 462, 463, 464, 465, 465, 465, 466, 467,\n-   468, 469, 470, 471, 472, 473, 474, 475,  45,  45,  45,  45,  45,  45,  45,  45,\n-   476, 476, 476, 476, 476, 477, 478,  45, 479, 479, 479, 479, 480, 481,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45, 482, 482, 482, 483, 482, 484,  45,  45,\n-   485, 485, 485, 485, 486, 487, 488,  45, 489, 489, 489, 490, 491,  45,  45,  45,\n-   492, 493, 494, 492,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   495, 495, 495, 496,  45,  45,  45,  45,  45,  45, 497, 497, 497, 497, 497, 498,\n-   499, 500, 501, 502, 503, 504,  45,  45,  45,  45, 505, 506, 506, 505, 507,  45,\n-   508, 508, 508, 508, 509, 510, 510, 510, 510, 510, 511,  45, 512, 512, 512, 513,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   514, 515, 515, 516, 517, 515, 518, 519, 519, 520, 521, 522,  45,  45,  45,  45,\n-   523, 524, 524, 525, 526, 527, 528, 529, 530, 531, 532,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45, 533, 534,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45, 535, 536, 536, 536, 537,\n-   538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538,\n-   538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538,\n-   538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538, 538,\n-   538, 538, 538, 538, 538, 538, 538, 538, 538, 539,  45,  45,  45,  45,  45,  45,\n-   538, 538, 538, 538, 538, 538, 540, 541, 538, 538, 538, 538, 538, 538, 538, 538,\n-   538, 538, 538, 538, 542,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543,\n-   543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543, 543,\n-   543, 543, 544, 545,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n+    27,  27,  27, 326,  27,  27,  27,  27,  27, 327,  27,  27, 328, 125, 125,  27,\n+     8, 285, 329,   0,   0, 330, 331, 332,  27,  27,  27,  27,  27,  27,  27, 333,\n+   334,   0,   1,   2,   1,   2, 335, 259, 260, 336, 142, 265, 337, 338, 339, 340,\n+   341, 342, 343, 344, 345, 345, 125, 125, 342, 342, 342, 342, 342, 342, 342, 346,\n+   347,   0,   0, 348,  11,  11,  11,  11, 349, 350, 351, 125, 125,   0,   0, 352,\n+   125, 125, 125, 125, 125, 125, 125, 125, 353, 354, 355, 355, 355, 356, 357, 252,\n+   358, 358, 359, 360, 361, 362, 362, 363, 364, 365, 366, 366, 367, 368, 125, 125,\n+   369, 369, 369, 369, 369, 370, 370, 370, 371, 372, 373, 374, 374, 375, 374, 376,\n+   377, 377, 378, 379, 379, 379, 380, 381, 381, 382, 383, 384, 125, 125, 125, 125,\n+   385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385, 385,\n+   385, 385, 385, 386, 385, 387, 388, 125, 389,   4,   4, 390, 125, 125, 125, 125,\n+   391, 392, 392, 393, 394, 395, 396, 396, 397, 398, 399, 125, 125, 125, 400, 401,\n+   402, 403, 404, 405, 125, 125, 125, 125, 406, 406, 407, 408, 407, 409, 407, 407,\n+   410, 411, 412, 413, 414, 414, 415, 415, 416, 416, 125, 125, 417, 417, 418, 419,\n+   420, 420, 420, 421, 422, 423, 424, 425, 426, 427, 428, 125, 125, 125, 125, 125,\n+   429, 429, 429, 429, 430, 125, 125, 125, 431, 431, 431, 432, 431, 431, 431, 433,\n+   434, 434, 435, 436, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125,  27,  45, 437, 437, 438, 439, 125, 125, 125, 125,\n+   440, 440, 441, 442, 442, 443, 125, 444, 445, 125, 125, 446, 447, 125, 448, 449,\n+   450, 450, 450, 450, 451, 452, 450, 453, 454, 454, 454, 454, 455, 456, 457, 458,\n+   459, 459, 459, 460, 461, 462, 462, 463, 464, 464, 464, 464, 464, 464, 465, 466,\n+   467, 468, 467, 469, 125, 125, 125, 125, 470, 471, 472, 473, 473, 473, 474, 475,\n+   476, 477, 478, 479, 480, 481, 482, 483, 125, 125, 125, 125, 125, 125, 125, 125,\n+   484, 484, 484, 484, 484, 485, 486, 125, 487, 487, 487, 487, 488, 489, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 490, 490, 490, 491, 490, 492, 125, 125,\n+   493, 493, 493, 493, 494, 495, 496, 125, 497, 497, 497, 498, 498, 125, 125, 125,\n+   499, 500, 501, 499, 502, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   503, 503, 503, 504, 125, 125, 125, 125, 125, 125, 505, 505, 505, 505, 505, 506,\n+   507, 508, 509, 510, 511, 512, 125, 125, 125, 125, 513, 514, 514, 513, 515, 125,\n+   516, 516, 516, 516, 517, 518, 518, 518, 518, 518, 519, 154, 520, 520, 520, 521,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   522, 523, 523, 524, 525, 523, 526, 527, 527, 528, 529, 530, 125, 125, 125, 125,\n+   531, 532, 532, 533, 534, 535, 536, 537, 538, 539, 540, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 541, 542,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 543, 544, 544, 544, 545,\n+   546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546,\n@@ -3418,69 +3458,88 @@\n-   546, 546, 546, 546, 547,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n-   278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n-   278, 278, 278, 548, 549, 550, 551,  45,  45,  45,  45,  45,  45, 552, 553, 554,\n-   555, 555, 555, 555, 556, 557, 558, 559, 555,  45,  45,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45, 560, 560, 560, 560, 560, 561,  45,  45,  45,  45,  45,  45,\n-   562, 562, 562, 562, 563, 562, 562, 562, 564, 562,  45,  45,  45,  45, 565, 566,\n-   567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567,\n-   567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567,\n-   567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567,\n-   567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 568,\n-   567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567, 567,\n-   569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 569,\n-   569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 569, 570,  45,  45,\n-   571,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   572, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258, 258,\n-   258, 573,  45,  45,  45, 574, 575, 576, 576, 576, 576, 576, 576, 576, 576, 576,\n-   576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 577,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   578, 578, 578, 578, 578, 578, 579, 580, 581, 582, 267,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 583,\n-     0,   0, 584,   0,   0,   0, 585, 586, 587,   0, 588,   0,   0,   0, 589,  45,\n-    11,  11,  11,  11, 590,  45,  45,  45,  45,  45,  45,  45,  45,  45,   0, 267,\n-     0,   0,   0,   0,   0, 234,   0, 589,  45,  45,  45,  45,  45,  45,  45,  45,\n-     0,   0,   0,   0,   0, 226,   0,   0,   0, 591, 592, 593, 594,   0,   0,   0,\n-   595, 596,   0, 597, 598, 599,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 600,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 601,   0,   0,   0,\n-   602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602,\n-   602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602,\n-   602, 602, 602, 602, 602, 602, 602, 602, 603, 604, 605,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   606, 607, 608,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   609, 609, 610, 611, 612,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45, 613, 613, 613, 614,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   615, 615, 615, 615, 615, 615, 615, 615, 615, 615, 615, 615, 616, 617,  45,  45,\n-   618, 618, 618, 618, 619, 620,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45, 333,   0,   0,   0, 621,  45,  45,  45,  45,\n-   333,   0,   0, 622,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   623,  27, 624, 625, 626, 627, 628, 629, 630, 631, 632, 631,  45,  45,  45, 325,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-     0,   0, 253,   0,   0,   0,   0,   0,   0, 267, 228, 333, 333, 333,   0, 583,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 622,  45,  45,  45, 633,   0,\n-   634,   0,   0, 253, 589, 635, 583,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 636, 349, 349,\n-     0,   0,   0,   0,   0,   0,   0, 267,   0,   0,   0,   0,   0, 589, 253,  45,\n-   253,   0,   0,   0, 636, 286,   0,   0, 636,   0, 622, 635,  45,  45,  45,  45,\n-     0,   0,   0,   0,   0,   0,   0, 637,   0,   0,   0,   0, 638,   0,   0,   0,\n-     0,   0,   0,   0,   0, 267, 622, 639, 234,   0, 589, 234, 248, 234,  45,  45,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0, 330,   0,   0, 235,  45,  45, 286,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 319,  45,  45,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 640, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 319, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 566, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 641,  45,\n-   249, 319,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-    45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n-   249, 249, 249, 249, 642,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,  45,\n-   643,  45,   0,   0,   0,   0,   0,   0,  45,  45,  45,  45,  45,  45,  45,  45,\n+   546, 546, 546, 546, 546, 546, 546, 546, 546, 547, 125, 125, 125, 125, 125, 125,\n+   546, 546, 546, 546, 546, 546, 548, 549, 546, 546, 546, 546, 546, 546, 546, 546,\n+   546, 546, 546, 546, 550, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 551, 551, 551, 551, 551, 551, 552,\n+   553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553,\n+   553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553, 553,\n+   553, 553, 554, 555, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556,\n+   556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556,\n+   556, 556, 556, 556, 557, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n+   276, 276, 276, 558, 559, 560, 561, 562, 562, 562, 562, 563, 564, 565, 566, 567,\n+   568, 568, 568, 568, 569, 570, 571, 572, 568, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 573, 573, 573, 573, 573, 574, 125, 125, 125, 125, 125, 125,\n+   575, 575, 575, 575, 576, 575, 575, 575, 577, 575, 125, 125, 125, 125, 578, 579,\n+   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580,\n+   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580,\n+   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580,\n+   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 581,\n+   580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580, 580,\n+   582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582,\n+   582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 582, 583, 125, 125,\n+   584, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 585,\n+   586, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257, 257,\n+   257, 257, 587, 125, 125, 588, 589, 590, 590, 590, 590, 590, 590, 590, 590, 590,\n+   590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 591,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   592, 592, 592, 592, 592, 592, 593, 594, 595, 596, 266, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+     8,   8, 597,   8, 598,   0,   0,   0,   0,   0,   0,   0, 266, 125, 125, 125,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 599,\n+     0,   0, 600,   0,   0,   0, 601, 602, 603,   0, 604,   0,   0,   0, 235, 125,\n+    11,  11,  11,  11, 605, 125, 125, 125, 125, 125, 125, 125, 125, 125,   0, 266,\n+     0,   0,   0,   0,   0, 234,   0, 606, 125, 125, 125, 125, 125, 125, 125, 125,\n+     0,   0,   0,   0,   0, 224,   0,   0,   0, 607, 608, 609, 610,   0,   0,   0,\n+   611, 612,   0, 613, 614, 615,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 616,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 617,   0,   0,   0,\n+   618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618,\n+   618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618, 618,\n+   618, 618, 618, 618, 618, 618, 618, 618, 619, 620, 621, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+     4, 622, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   623, 624, 625, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   626, 626, 627, 628, 629, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 630, 631, 125, 632, 632, 632, 633,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 634, 635,\n+   636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 636, 637, 638, 125, 125,\n+   639, 639, 639, 639, 640, 641, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 334,   0,   0,   0, 642, 125, 125, 125, 125,\n+   334,   0,   0, 247, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   643,  27, 644, 645, 646, 647, 648, 649, 650, 651, 652, 651, 125, 125, 125, 653,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+     0,   0, 252,   0,   0,   0,   0,   0,   0, 266, 226, 334, 334, 334,   0, 599,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 247, 125, 125, 125, 654,   0,\n+   655,   0,   0, 252, 606, 656, 599, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 657, 350, 350,\n+     0,   0,   0,   0,   0,   0,   0, 266,   0,   0,   0,   0,   0, 606, 252, 228,\n+   252,   0,   0,   0, 658, 285,   0,   0, 658,   0, 247, 656, 125, 125, 125, 125,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0, 266, 247, 659, 234,   0, 350, 235, 599, 285, 658, 234,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0, 330,   0,   0, 235, 125, 125, 285,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 125, 125,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 660, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 318, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 579, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 661, 125,\n+   248, 318, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248, 248,\n+   248, 248, 248, 248, 662, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125, 125,\n+   663, 125,   0,   0,   0,   0,   0,   0, 125, 125, 125, 125, 125, 125, 125, 125,\n@@ -3839,1 +3898,1 @@\n-  return u<125259u?_hb_ucd_u8[15060+(((_hb_ucd_u8[13636+(((_hb_ucd_u8[12656+(u>>3>>4)])<<4)+((u>>3)&15u))])<<3)+((u)&7u))]:0;\n+  return u<125259u?_hb_ucd_u8[15332+(((_hb_ucd_u8[13892+(((_hb_ucd_u8[12912+(u>>3>>4)])<<4)+((u>>3)&15u))])<<3)+((u)&7u))]:0;\n@@ -3849,1 +3908,1 @@\n-  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[16372+(((_hb_ucd_b4(16244+_hb_ucd_u8,u>>2>>6))<<6)+((u>>2)&63u))])<<2)+((u)&3u)]:0;\n+  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[16692+(((_hb_ucd_b4(16564+_hb_ucd_u8,u>>2>>6))<<6)+((u>>2)&63u))])<<2)+((u)&3u)]:0;\n@@ -3854,1 +3913,1 @@\n-  return u<918000u?_hb_ucd_u8[19126+(((_hb_ucd_u16[3040+(((_hb_ucd_u8[17332+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:2;\n+  return u<918000u?_hb_ucd_u8[19446+(((_hb_ucd_u16[3168+(((_hb_ucd_u8[17652+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:2;\n@@ -3859,1 +3918,1 @@\n-  return u<195102u?_hb_ucd_u16[6144+(((_hb_ucd_u8[29430+(u>>6)])<<6)+((u)&63u))]:0;\n+  return u<195102u?_hb_ucd_u16[6400+(((_hb_ucd_u8[30070+(u>>6)])<<6)+((u)&63u))]:0;\n@@ -3866,1 +3925,1 @@\n-_hb_ucd_u8[17508] =\n+_hb_ucd_u8[17936] =\n@@ -3869,3 +3928,3 @@\n-    7,  7,  7,  9, 10, 11,  7,  7,  7,  7, 12, 13, 14, 14, 14, 15,\n-   16, 17, 18, 19, 20, 21, 22, 21, 23, 21, 21, 21, 21, 24,  7,  7,\n-   25, 26, 21, 21, 21, 21, 27, 28, 21, 21, 29, 30, 31, 32, 33, 34,\n+    7,  7,  7,  7,  9, 10,  7,  7,  7,  7, 11, 12, 13, 13, 13, 14,\n+   15, 16, 17, 18, 19, 20, 21, 22, 23, 22, 22, 22, 22, 24,  7,  7,\n+   25, 26, 22, 22, 22, 27, 28, 29, 22, 30, 31, 32, 33, 34, 35, 36,\n@@ -3873,29 +3932,29 @@\n-    7,  7,  7,  7, 35,  7, 36, 37,  7, 38,  7,  7,  7, 39, 21, 40,\n-    7,  7, 41, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   42, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 43,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 44,\n+    7,  7,  7,  7, 37,  7, 38, 39,  7, 40,  7,  7,  7, 41, 22, 42,\n+    7,  7, 43, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   44, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 45,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 46,\n@@ -3911,4 +3970,4 @@\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 91,\n-   92, 34, 34, 34, 34, 34, 34, 34, 34, 93, 34, 34, 94, 95, 96, 97,\n-   98, 99,100,101,102,103,104,105, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,106,\n+   91, 34, 34, 34, 34, 34, 34, 34, 34, 92, 34, 34, 93, 94, 95, 96,\n+   97, 98, 99,100,101,102,103,104, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,105,\n+  106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,\n@@ -3916,31 +3975,33 @@\n-  108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,\n-  108,108, 34, 34,109,110,111,112, 34, 34,113,114,115,116,117,118,\n-  119,120,121,122,123,124,125,126,127,128,129,123, 34, 34,130,123,\n-  131,132,133,134,135,136,137,138,139,140,141,123,142,143,144,145,\n-  146,147,148,149,150,151,152,123,153,154,123,155,156,157,158,123,\n-  159,160,161,162,163,164,123,123,165,166,167,168,123,169,123,170,\n-   34, 34, 34, 34, 34, 34, 34,171,172, 34,173,123,123,123,123,123,\n-  123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,\n-   34, 34, 34, 34, 34, 34, 34, 34,174,123,123,123,123,123,123,123,\n-  123,123,123,123,123,123,123,123, 34, 34, 34, 34,175,123,123,123,\n-   34, 34, 34, 34,176,177,178,179,123,123,123,123,180,181,182,183,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,184,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34,185,186,123,123,123,123,123,\n-   34, 34,187, 34, 34,188,123,123,123,123,123,123,123,123,123,123,\n-  123,123,123,123,123,123,123,123,189,190,123,123,123,123,123,123,\n-   69,191,192,193,194,195,196,123,197,198,199,200,201,202,203,204,\n-   69, 69, 69, 69,205,206,123,123,123,123,123,123,123,123,123,123,\n-  207,123,208,123,123,209,123,123,123,123,123,123,123,123,123,123,\n-   34,210,211,123,123,123,123,123,212,213,214,123,215,216,123,123,\n-  217,218,219,220,221,123, 69,222, 69, 69, 69, 69, 69,223,224,225,\n-  226,227,228,229,230,231, 69,232,123,123,123,123,123,123,123,123,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,233, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,234, 34,\n-  235, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,236, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34,237,123,123,123,123,123,123,123,123,\n-   34, 34, 34, 34,238,123,123,123,123,123,123,123,123,123,123,123,\n-   34, 34, 34, 34, 34, 34,239,123,123,123,123,123,123,123,123,123,\n-  240,123,241,242,123,123,123,123,123,123,123,123,123,123,123,123,\n-  108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,243,\n-  108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,244,\n+  107,107, 34, 34,108,109,110,111, 34, 34,112,113,114,115,116,117,\n+  118,119,120,121,122,123,124,125,126,127,128,129, 34, 34,130,131,\n+  132,133,134,135,136,137,138,139,140,141,142,122,143,144,145,146,\n+  147,148,149,150,151,152,153,122,154,155,122,156,157,158,159,122,\n+  160,161,162,163,164,165,122,122,166,167,168,169,122,170,122,171,\n+   34, 34, 34, 34, 34, 34, 34,172,173, 34,174,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,175,\n+   34, 34, 34, 34, 34, 34, 34, 34,176,122,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122, 34, 34, 34, 34,177,122,122,122,\n+   34, 34, 34, 34,178,179,180,181,122,122,122,122,182,183,184,185,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,186,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34,187,188,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,189,\n+   34, 34,190, 34, 34,191,122,122,122,122,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,192,193,122,122,122,122,122,122,\n+  122,122,122,122,122,122,122,122,122,122,122,122,122,122,194,195,\n+   69,196,197,198,199,200,201,122,202,203,204,205,206,207,208,209,\n+   69, 69, 69, 69,210,211,122,122,122,122,122,122,122,122,212,122,\n+  213,122,214,122,122,215,122,122,122,122,122,122,122,122,122,216,\n+   34,217,218,122,122,122,122,122,219,220,221,122,222,223,122,122,\n+  224,225,226,227,228,122, 69,229, 69, 69, 69, 69, 69,230,231,232,\n+  233,234, 69, 69,235,236, 69,237,122,122,122,122,122,122,122,122,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,238, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,239, 34,\n+  240, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,241, 34, 34,\n+   34, 34, 34, 34, 34, 34, 34,242,122,122,122,122,122,122,122,122,\n+   34, 34, 34, 34,243,122,122,122,122,122,122,122,122,122,122,122,\n+   34, 34, 34, 34, 34, 34,244,122,122,122,122,122,122,122,122,122,\n+  245,122,246,247,122,122,122,122,122,122,122,122,122,122,122,122,\n+  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,248,\n+  107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,249,\n@@ -3983,35 +4044,35 @@\n-   44, 44, 44, 44, 44, 44, 44, 44, 36, 36, 61, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 44, 44, 44, 44, 44, 57, 43, 43, 43, 43, 43, 43,\n-   43, 82, 43, 43, 43, 43, 43, 43, 43, 83, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 83, 71, 84, 85, 43, 43, 43, 83, 84, 85, 84,\n-   70, 43, 43, 43, 36, 36, 36, 36, 36, 43,  2,  7,  7,  7,  7,  7,\n-   86, 36, 36, 36, 36, 36, 36, 36, 70, 84, 62, 36, 36, 36, 61, 62,\n-   61, 62, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 61, 36, 36, 36,\n-   61, 61, 44, 36, 36, 44, 71, 84, 85, 43, 80, 87, 88, 87, 85, 61,\n-   44, 44, 44, 87, 44, 44, 36, 62, 36, 43, 44,  7,  7,  7,  7,  7,\n-   36, 20, 27, 27, 27, 56, 63, 80, 57, 83, 62, 36, 36, 61, 44, 62,\n-   61, 36, 62, 61, 36, 44, 80, 84, 85, 80, 44, 57, 80, 57, 43, 44,\n-   57, 44, 44, 44, 62, 36, 61, 61, 44, 44, 44,  7,  7,  7,  7,  7,\n-   43, 36, 70, 64, 44, 44, 44, 44, 57, 83, 62, 36, 36, 36, 36, 62,\n-   36, 62, 36, 36, 36, 36, 36, 36, 61, 36, 62, 36, 36, 44, 71, 84,\n-   85, 43, 43, 57, 83, 87, 85, 44, 61, 44, 44, 44, 44, 44, 44, 44,\n-   66, 44, 44, 44, 62, 43, 43, 43, 57, 84, 62, 36, 36, 36, 61, 62,\n-   61, 36, 62, 36, 36, 44, 71, 85, 85, 43, 80, 87, 88, 87, 85, 44,\n-   44, 44, 57, 83, 44, 44, 36, 62, 78, 27, 27, 27, 44, 44, 44, 44,\n-   44, 71, 62, 36, 36, 61, 44, 36, 61, 36, 36, 44, 62, 61, 61, 36,\n-   44, 62, 61, 44, 36, 61, 44, 36, 36, 36, 36, 36, 36, 44, 44, 84,\n-   83, 88, 44, 84, 88, 84, 85, 44, 61, 44, 44, 87, 44, 44, 44, 44,\n-   27, 89, 67, 67, 56, 90, 44, 44, 83, 84, 71, 36, 36, 36, 61, 36,\n-   61, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 44, 62, 43,\n-   83, 84, 88, 43, 80, 43, 43, 44, 44, 44, 57, 80, 36, 61, 44, 44,\n-   44, 44, 44, 91, 27, 27, 27, 89, 70, 84, 72, 36, 36, 36, 61, 36,\n-   36, 36, 62, 36, 36, 44, 71, 85, 84, 84, 88, 83, 88, 84, 43, 44,\n-   44, 44, 87, 88, 44, 44, 44, 61, 62, 61, 44, 44, 44, 44, 44, 44,\n-   43, 84, 36, 36, 36, 36, 61, 36, 36, 36, 36, 36, 36, 70, 71, 84,\n-   85, 43, 80, 84, 88, 84, 85, 77, 44, 44, 36, 92, 27, 27, 27, 93,\n-   27, 27, 27, 27, 89, 36, 36, 36, 57, 84, 62, 36, 36, 36, 36, 36,\n-   36, 36, 36, 61, 44, 36, 36, 36, 36, 62, 36, 36, 36, 36, 62, 44,\n-   36, 36, 36, 61, 44, 80, 44, 87, 84, 43, 80, 80, 84, 84, 84, 84,\n-   44, 84, 64, 44, 44, 44, 44, 44, 62, 36, 36, 36, 36, 36, 36, 36,\n-   70, 36, 43, 43, 43, 80, 44, 94, 36, 36, 36, 75, 43, 43, 43, 60,\n-    7,  7,  7,  7,  7,  2, 44, 44, 62, 61, 61, 36, 36, 61, 36, 36,\n+   36, 36, 36, 36, 82, 36, 36, 61, 65, 44, 44, 44, 43, 43, 43, 43,\n+   36, 36, 36, 36, 83, 43, 43, 43, 43, 84, 43, 43, 43, 43, 43, 43,\n+   43, 85, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 85, 71, 86,\n+   87, 43, 43, 43, 85, 86, 87, 86, 70, 43, 43, 43, 36, 36, 36, 36,\n+   36, 43,  2,  7,  7,  7,  7,  7, 88, 36, 36, 36, 36, 36, 36, 36,\n+   70, 86, 62, 36, 36, 36, 61, 62, 61, 62, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 61, 36, 36, 36, 61, 61, 44, 36, 36, 44, 71, 86,\n+   87, 43, 80, 89, 90, 89, 87, 61, 44, 44, 44, 89, 44, 44, 36, 62,\n+   36, 43, 44,  7,  7,  7,  7,  7, 36, 20, 27, 27, 27, 56, 63, 80,\n+   57, 85, 62, 36, 36, 61, 44, 62, 61, 36, 62, 61, 36, 44, 80, 86,\n+   87, 80, 44, 57, 80, 57, 43, 44, 57, 44, 44, 44, 62, 36, 61, 61,\n+   44, 44, 44,  7,  7,  7,  7,  7, 43, 36, 70, 64, 44, 44, 44, 44,\n+   57, 85, 62, 36, 36, 36, 36, 62, 36, 62, 36, 36, 36, 36, 36, 36,\n+   61, 36, 62, 36, 36, 44, 71, 86, 87, 43, 43, 57, 85, 89, 87, 44,\n+   61, 44, 44, 44, 44, 44, 44, 44, 66, 44, 44, 44, 62, 43, 43, 43,\n+   57, 86, 62, 36, 36, 36, 61, 62, 61, 36, 62, 36, 36, 44, 71, 87,\n+   87, 43, 80, 89, 90, 89, 87, 44, 44, 44, 57, 85, 44, 44, 36, 62,\n+   78, 27, 27, 27, 44, 44, 44, 44, 44, 71, 62, 36, 36, 61, 44, 36,\n+   61, 36, 36, 44, 62, 61, 61, 36, 44, 62, 61, 44, 36, 61, 44, 36,\n+   36, 36, 36, 36, 36, 44, 44, 86, 85, 90, 44, 86, 90, 86, 87, 44,\n+   61, 44, 44, 89, 44, 44, 44, 44, 27, 91, 67, 67, 56, 92, 44, 44,\n+   85, 86, 71, 36, 36, 36, 61, 36, 61, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 44, 71, 43, 85, 86, 90, 43, 80, 43, 43, 44,\n+   44, 44, 57, 80, 36, 61, 62, 44, 44, 44, 44, 93, 27, 27, 27, 91,\n+   70, 86, 72, 36, 36, 36, 61, 36, 36, 36, 62, 36, 36, 44, 71, 87,\n+   86, 86, 90, 85, 90, 86, 43, 44, 44, 44, 89, 90, 44, 44, 62, 61,\n+   62, 61, 44, 44, 44, 44, 44, 44, 43, 86, 36, 36, 36, 36, 61, 36,\n+   36, 36, 36, 36, 36, 70, 71, 86, 87, 43, 80, 86, 90, 86, 87, 77,\n+   44, 44, 36, 94, 27, 27, 27, 95, 27, 27, 27, 27, 91, 36, 36, 36,\n+   57, 86, 62, 36, 36, 36, 36, 36, 36, 36, 36, 61, 44, 36, 36, 36,\n+   36, 62, 36, 36, 36, 36, 62, 44, 36, 36, 36, 61, 44, 80, 44, 89,\n+   86, 43, 80, 80, 86, 86, 86, 86, 44, 86, 64, 44, 44, 44, 44, 44,\n+   62, 36, 36, 36, 36, 36, 36, 36, 70, 36, 43, 43, 43, 80, 44, 96,\n+   36, 36, 36, 75, 43, 43, 43, 60,  7,  7,  7,  7,  7,  2, 44, 44,\n+   44, 44, 44, 44, 44, 44, 44, 44, 62, 61, 61, 36, 36, 61, 36, 36,\n@@ -4020,2 +4081,2 @@\n-   77, 67,  2,  2,  2,  2,  2,  2,  2, 95, 95, 67, 43, 67, 67, 67,\n-    7,  7,  7,  7,  7, 27, 27, 27, 27, 27, 50, 50, 50,  4,  4, 84,\n+   77, 67,  2,  2,  2,  2,  2,  2,  2, 97, 97, 67, 43, 67, 67, 67,\n+    7,  7,  7,  7,  7, 27, 27, 27, 27, 27, 50, 50, 50,  4,  4, 86,\n@@ -4023,1 +4084,1 @@\n-   57, 43, 43, 43, 43, 43, 43, 83, 43, 43, 60, 43, 36, 36, 70, 43,\n+   57, 43, 43, 43, 43, 43, 43, 85, 43, 43, 60, 43, 36, 36, 70, 43,\n@@ -4025,5 +4086,5 @@\n-   67, 67, 67, 76, 67, 67, 90, 67,  2,  2, 95, 67, 21, 64, 44, 44,\n-   36, 36, 36, 36, 36, 92, 85, 43, 83, 43, 43, 43, 85, 83, 85, 71,\n-    7,  7,  7,  7,  7,  2,  2,  2, 36, 36, 36, 84, 43, 36, 36, 43,\n-   71, 84, 96, 92, 84, 84, 84, 36, 70, 43, 71, 36, 36, 36, 36, 36,\n-   36, 83, 85, 83, 84, 84, 85, 92,  7,  7,  7,  7,  7, 84, 85, 67,\n+   67, 67, 67, 76, 67, 67, 92, 67,  2,  2, 97, 67, 21, 64, 44, 44,\n+   36, 36, 36, 36, 36, 94, 87, 43, 85, 43, 43, 43, 87, 85, 87, 71,\n+    7,  7,  7,  7,  7,  2,  2,  2, 36, 36, 36, 86, 43, 36, 36, 43,\n+   71, 86, 98, 94, 86, 86, 86, 36, 70, 43, 71, 36, 36, 36, 36, 36,\n+   36, 85, 87, 85, 86, 86, 87, 94,  7,  7,  7,  7,  7, 86, 87, 67,\n@@ -4034,1 +4095,1 @@\n-    2,  2,  2,  2, 97, 27, 27, 27, 27, 27, 27, 27, 27, 27, 98, 44,\n+    2,  2,  2,  2, 99, 27, 27, 27, 27, 27, 27, 27, 27, 27,100, 44,\n@@ -4036,7 +4097,7 @@\n-   99, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 77, 72,\n-  100, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,101,102, 44,\n-   36, 36, 36, 36, 36, 63,  2,103,104, 36, 36, 36, 61, 44, 44, 44,\n-   36, 36, 36, 36, 36, 36, 61, 36, 36, 43, 80, 44, 44, 44, 44, 44,\n-   36, 43, 60, 64, 44, 44, 44, 44, 36, 43, 44, 44, 44, 44, 44, 44,\n-   61, 43, 44, 44, 44, 44, 44, 44, 36, 36, 43, 85, 43, 43, 43, 84,\n-   84, 84, 84, 83, 85, 43, 43, 43, 43, 43,  2, 86,  2, 66, 70, 44,\n+  101, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 77, 72,\n+  102, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,103,104, 44,\n+   36, 36, 36, 36, 36, 63,  2,105,106, 36, 36, 36, 61, 44, 44, 44,\n+   36, 43, 85, 44, 44, 44, 44, 62, 36, 43,107, 64, 44, 44, 44, 44,\n+   36, 43, 44, 44, 44, 44, 44, 44, 36, 36, 36, 36, 36, 36, 61, 36,\n+   61, 43, 44, 44, 44, 44, 44, 44, 36, 36, 43, 87, 43, 43, 43, 86,\n+   86, 86, 86, 85, 87, 43, 43, 43, 43, 43,  2, 88,  2, 66, 70, 44,\n@@ -4044,1 +4105,1 @@\n-    2,  2,  2,105,  2, 59, 43, 68, 36,106, 36, 36, 36, 36, 36, 36,\n+    2,  2,  2,108,  2, 59, 43, 84, 36, 83, 36, 36, 36, 36, 36, 36,\n@@ -4047,2 +4108,2 @@\n-   36, 36, 36, 36, 36, 36, 36, 61, 43, 83, 84, 85, 83, 84, 44, 44,\n-   84, 83, 84, 84, 85, 43, 44, 44, 90, 44,  2,  7,  7,  7,  7,  7,\n+   36, 36, 36, 36, 36, 36, 36, 61, 43, 85, 86, 87, 85, 86, 44, 44,\n+   86, 85, 86, 86, 87, 43, 44, 44, 92, 44,  2,  7,  7,  7,  7,  7,\n@@ -4051,10 +4112,10 @@\n-    7,  7,  7,  7,  7, 98, 44, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n-   36, 36, 36, 70, 83, 85, 44,  2, 36, 36, 92, 83, 43, 43, 43, 80,\n-   83, 83, 85, 43, 43, 43, 83, 84, 84, 85, 43, 43, 43, 43, 80, 57,\n-    2,  2,  2, 86,  2,  2,  2, 44, 43, 43, 43, 43, 43, 43, 43,107,\n-   80, 44, 44, 44, 44, 44, 44, 44, 43, 43, 96, 36, 36, 36, 36, 36,\n-   36, 36, 83, 43, 43, 83, 83, 84, 84, 83, 96, 36, 36, 36, 44, 44,\n-   95, 67, 67, 67, 67, 50, 43, 43, 43, 43, 67, 67, 67, 67, 90, 44,\n-   43, 96, 36, 36, 36, 36, 36, 36, 92, 43, 43, 84, 43, 85, 43, 36,\n-   36, 36, 36, 83, 43, 84, 85, 85, 43, 84, 44, 44, 44, 44,  2,  2,\n-   36, 36, 84, 84, 84, 84, 43, 43, 43, 43, 84, 43, 44, 91,  2,  2,\n+    7,  7,  7,  7,  7,100, 44, 67, 67, 67, 67, 67, 67, 67, 67, 67,\n+   36, 36, 36, 70, 85, 87, 44,  2, 36, 36, 94, 85, 43, 43, 43, 80,\n+   85, 85, 87, 43, 43, 43, 85, 86, 86, 87, 43, 43, 43, 43, 80, 57,\n+    2,  2,  2, 88,  2,  2,  2, 44, 43, 43, 43, 43, 43, 43, 43,109,\n+   43, 43, 43, 43, 43, 43, 43, 80, 43, 43, 98, 36, 36, 36, 36, 36,\n+   36, 36, 85, 43, 43, 85, 85, 86, 86, 85, 98, 36, 36, 36, 61, 44,\n+   97, 67, 67, 67, 67, 50, 43, 43, 43, 43, 67, 67, 67, 67, 21, 64,\n+   43, 98, 36, 36, 36, 36, 36, 36, 94, 43, 43, 86, 43, 87, 43, 36,\n+   36, 36, 36, 85, 43, 86, 87, 87, 43, 86, 44, 44, 44, 44,  2,  2,\n+   36, 36, 86, 86, 86, 86, 43, 43, 43, 43, 86, 43, 44, 93,  2,  2,\n@@ -4062,1 +4123,1 @@\n-   16, 16, 16, 16,108, 44, 44, 44, 11, 11, 11, 11, 11, 47, 48, 11,\n+   16, 16, 16, 16,110, 44, 44, 44, 11, 11, 11, 11, 11, 47, 48, 11,\n@@ -4064,1 +4125,1 @@\n-   83, 43, 43, 43, 71, 36, 70, 36, 36, 36, 71, 92, 43, 61, 44, 44,\n+   85, 43, 43, 43, 71, 36, 70, 36, 36, 36, 71, 94, 43, 61, 44, 44,\n@@ -4066,63 +4127,63 @@\n-   16, 16, 16, 16, 45, 16, 16, 16, 16, 16, 16, 16, 16,109, 40, 40,\n-   43, 43, 43, 43, 43, 57, 43, 43, 32, 32, 32, 16, 16, 16, 16, 32,\n-   16, 16, 16, 16, 11, 11, 11, 11, 16, 16, 16, 44, 11, 11, 11, 44,\n-   16, 16, 16, 16, 48, 48, 48, 48, 16, 16, 16, 16, 16, 16, 16, 44,\n-   16, 16, 16, 16,110,110,110,110, 16, 16,108, 16, 11, 11,111,112,\n-   41, 16,108, 16, 11, 11,111, 41, 16, 16, 44, 16, 11, 11,113, 41,\n-   16, 16, 16, 16, 11, 11,114, 41, 44, 16,108, 16, 11, 11,111,115,\n-  116,116,116,116,116,117, 65, 65,118,118,118,  2,119,120,119,120,\n-    2,  2,  2,  2,121, 65, 65,122,  2,  2,  2,  2,123,124,  2,125,\n-  126,  2,127,128,  2,  2,  2,  2,  2,  9,126,  2,  2,  2,  2,129,\n-   65, 65, 68, 65, 65, 65, 65, 65,130, 44, 27, 27, 27,  8,127,131,\n-   27, 27, 27, 27, 27,  8,127,102, 40, 40, 40, 40, 40, 40, 81, 44,\n-   20, 20, 20, 20, 20, 20, 20, 20, 43, 43, 43, 43, 43, 43,132, 51,\n-  107, 51,107, 43, 43, 43, 43, 43, 67,133, 67,134, 67, 34, 11, 16,\n-   11, 32,134, 67, 49, 11, 11, 67, 67, 67,133,133,133, 11, 11,135,\n-   11, 11, 35, 36, 39, 67, 16, 11,  8,  8, 49, 16, 16, 26, 67,136,\n-   27, 27, 27, 27, 27, 27, 27, 27,103,103,103,103,103,103,103,103,\n-  103,137,138,103,139, 67, 44, 44,  8,  8,140, 67, 67,  8, 67, 67,\n-  140, 26, 67,140, 67, 67, 67,140, 67, 67, 67, 67, 67, 67, 67,  8,\n-   67,140,140, 67, 67, 67, 67, 67, 67, 67,  8,  8,  8,  8,  8,  8,\n-    8,  8,  8,  8,  8,  8,  8,  8, 67, 67, 67, 67,  4,  4, 67, 67,\n-    8, 67, 67, 67,141,142, 67, 67, 67, 67, 67, 67, 67, 67,140, 67,\n-   67, 67, 67, 67, 67, 26,  8,  8,  8,  8, 67, 67, 67, 67, 67, 67,\n-   67, 67, 67, 67, 67, 67,  8,  8,  8, 67, 67, 67, 67, 67, 67, 67,\n-   67, 67, 67, 90, 44, 44, 44, 44, 67, 67, 67, 67, 67, 90, 44, 44,\n-   27, 27, 27, 27, 27, 27, 67, 67, 67, 67, 67, 67, 67, 27, 27, 27,\n-   67, 67, 67, 26, 67, 67, 67, 67, 26, 67, 67, 67, 67, 67, 67, 67,\n-   67, 67, 67, 67,  8,  8,  8,  8, 67, 67, 67, 67, 67, 67, 67, 26,\n-   67, 67, 67, 67,  4,  4,  4,  4,  4,  4,  4, 27, 27, 27, 27, 27,\n-   27, 27, 67, 67, 67, 67, 67, 67,  8,  8,127,143,  8,  8,  8,  8,\n-    8,  8,  8,  4,  4,  4,  4,  4,  8,127,144,144,144,144,144,144,\n-  144,144,144,144,143,  8,  8,  8,  8,  8,  8,  8,  4,  4,  8,  8,\n-    8,  8,  8,  8,  8,  8,  4,  8,  8,  8,140, 26,  8,  8,140, 67,\n-   67, 67, 44, 67, 67, 67, 67, 67, 67, 67, 67, 55, 67, 67, 67, 67,\n-   11, 11, 11, 11, 11, 11, 11, 47, 16, 16, 16, 16, 16, 16, 16,108,\n-   32, 11, 32, 34, 34, 34, 34, 11, 32, 32, 34, 16, 16, 16, 40, 11,\n-   32, 32,136, 67, 67,134, 34,145, 43, 32, 44, 44, 91,  2, 97,  2,\n-   16, 16, 16,146, 44, 44,146, 44, 36, 36, 36, 36, 44, 44, 44, 52,\n-   64, 44, 44, 44, 44, 44, 44, 57, 36, 36, 36, 61, 44, 44, 44, 44,\n-   36, 36, 36, 61, 36, 36, 36, 61,  2,119,119,  2,123,124,119,  2,\n-    2,  2,  2,  6,  2,105,119,  2,119,  4,  4,  4,  4,  2,  2, 86,\n-    2,  2,  2,  2,  2,118,  2,  2,105,147,  2,  2,  2,  2,  2,  2,\n-   67, 64, 44, 44, 44, 44, 44, 44, 67, 67, 67, 67, 67, 55, 67, 67,\n-   67, 67, 44, 44, 44, 44, 44, 44, 67, 67, 67, 44, 44, 44, 44, 44,\n-   67, 67, 67, 67, 67, 67, 44, 44,  1,  2,148,149,  4,  4,  4,  4,\n-    4, 67,  4,  4,  4,  4,150,151,152,103,103,103,103, 43, 43, 84,\n-  153, 40, 40, 67,103,154, 63, 67, 36, 36, 36, 61, 57,155,156, 69,\n-   36, 36, 36, 36, 36, 63, 40, 69, 44, 44, 62, 36, 36, 36, 36, 36,\n-   67, 27, 27, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 90,\n-   27, 27, 27, 27, 27, 67, 67, 67, 67, 67, 67, 67, 27, 27, 27, 27,\n-  157, 27, 27, 27, 27, 27, 27, 27, 36, 36,106, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36,158,  2,  7,  7,  7,  7,  7, 36, 44, 44,\n-   32, 32, 32, 32, 32, 32, 32, 70, 51,159, 43, 43, 43, 43, 43, 86,\n-   32, 32, 32, 32, 32, 32, 40, 43, 36, 36, 36,103,103,103,103,103,\n-   43,  2,  2,  2, 44, 44, 44, 44, 41, 41, 41,156, 40, 40, 40, 40,\n-   41, 32, 32, 32, 32, 32, 32, 32, 16, 32, 32, 32, 32, 32, 32, 32,\n-   45, 16, 16, 16, 34, 34, 34, 32, 32, 32, 32, 32, 42,160, 34, 35,\n-   32, 32, 16, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 11, 11, 32,\n-   11, 11, 32, 32, 32, 32, 32, 32, 44, 32, 11, 11, 34,108, 44, 44,\n-   44, 44, 48, 35, 40, 35, 36, 36, 36, 71, 36, 71, 36, 70, 36, 36,\n-   36, 92, 85, 83, 67, 67, 80, 44, 27, 27, 27, 67,161, 44, 44, 44,\n-   36, 36,  2,  2, 44, 44, 44, 44, 84, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 84, 84, 84, 84, 84, 84, 84, 84, 43, 44, 44, 44, 44,  2,\n+   16, 16, 16, 16, 45, 16, 16, 16, 16, 16, 16, 16, 16,111, 40, 40,\n+   32, 32, 32, 16, 16, 16, 16, 32, 16, 16, 16, 16, 11, 11, 11, 11,\n+   16, 16, 16, 44, 11, 11, 11, 44, 16, 16, 16, 16, 48, 48, 48, 48,\n+   16, 16, 16, 16, 16, 16, 16, 44, 16, 16, 16, 16,112,112,112,112,\n+   16, 16,110, 16, 11, 11,113,114, 41, 16,110, 16, 11, 11,113, 41,\n+   16, 16, 44, 16, 11, 11,115, 41, 16, 16, 16, 16, 11, 11,116, 41,\n+   44, 16,110, 16, 11, 11,113,117,118,118,118,118,118,119, 65, 65,\n+  120,120,120,  2,121,122,121,122,  2,  2,  2,  2,123, 65, 65,124,\n+    2,  2,  2,  2,125,126,  2,127,128,  2,129,130,  2,  2,  2,  2,\n+    2,  9,128,  2,  2,  2,  2,131, 65, 65,132, 65, 65, 65, 65, 65,\n+  133, 44, 27, 27, 27,  8,129,134, 27, 27, 27, 27, 27,  8,129,104,\n+   40, 40, 40, 40, 40, 40, 81, 44, 20, 20, 20, 20, 20, 20, 20, 20,\n+  135, 44, 44, 44, 44, 44, 44, 44, 43, 43, 43, 43, 43, 43,136, 51,\n+  109, 51,109, 43, 43, 43, 43, 43, 80, 44, 44, 44, 44, 44, 44, 44,\n+   67,137, 67,138, 67, 34, 11, 16, 11, 32,138, 67, 49, 11, 11, 67,\n+   67, 67,137,137,137, 11, 11,139, 11, 11, 35, 36, 39, 67, 16, 11,\n+    8,  8, 49, 16, 16, 26, 67,140, 27, 27, 27, 27, 27, 27, 27, 27,\n+  105,105,105,105,105,105,105,105,105,141,142,105,143, 67, 44, 44,\n+    8,  8,144, 67, 67,  8, 67, 67,144, 26, 67,144, 67, 67, 67,144,\n+   67, 67, 67, 67, 67, 67, 67,  8, 67,144,144, 67, 67, 67, 67, 67,\n+   67, 67,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n+   67, 67, 67, 67,  4,  4, 67, 67,  8, 67, 67, 67,145,146, 67, 67,\n+   67, 67, 67, 67, 67, 67,144, 67, 67, 67, 67, 67, 67, 26,  8,  8,\n+    8,  8, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67,  8,  8,\n+    8, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 92, 44, 44, 44, 44,\n+   67, 67, 67, 67, 67, 92, 44, 44, 27, 27, 27, 27, 27, 27, 67, 67,\n+   67, 67, 67, 67, 67, 27, 27, 27, 67, 67, 67, 26, 67, 67, 67, 67,\n+   26, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67,  8,  8,  8,  8,\n+   67, 67, 67, 67, 67, 67, 67, 26, 67, 67, 67, 67,  4,  4,  4,  4,\n+    4,  4,  4, 27, 27, 27, 27, 27, 27, 27, 67, 67, 67, 67, 67, 67,\n+    8,  8,129,147,  8,  8,  8,  8,  8,  8,  8,  4,  4,  4,  4,  4,\n+    8,129,148,148,148,148,148,148,148,148,148,148,147,  8,  8,  8,\n+    8,  8,  8,  8,  4,  4,  8,  8,  8,  8,  8,  8,  8,  8,  4,  8,\n+    8,  8,144, 26,  8,  8,144, 67, 67, 67, 44, 67, 67, 67, 67, 67,\n+   67, 67, 67, 55, 67, 67, 67, 67, 32, 11, 32, 34, 34, 34, 34, 11,\n+   32, 32, 34, 16, 16, 16, 40, 11, 32, 32,140, 67, 67,138, 34,149,\n+   43, 32, 44, 44, 93,  2, 99,  2, 16, 16, 16,150, 44, 44,150, 44,\n+   36, 36, 36, 36, 44, 44, 44, 52, 64, 44, 44, 44, 44, 44, 44, 57,\n+   36, 36, 36, 61, 44, 44, 44, 44, 36, 36, 36, 61, 36, 36, 36, 61,\n+    2,121,121,  2,125,126,121,  2,  2,  2,  2,  6,  2,108,121,  2,\n+  121,  4,  4,  4,  4,  2,  2, 88,  2,  2,  2,  2,  2,120,  2,  2,\n+  108,151,  2,  2,  2,  2,  2,  2, 67,  2,152,148,148,148,153, 44,\n+   67, 67, 67, 67, 67, 55, 67, 67, 67, 67, 44, 44, 44, 44, 44, 44,\n+   67, 67, 67, 44, 44, 44, 44, 44, 67, 67, 67, 67, 67, 67, 44, 44,\n+    1,  2,154,155,  4,  4,  4,  4,  4, 67,  4,  4,  4,  4,156,157,\n+  158,105,105,105,105, 43, 43, 86,159, 40, 40, 67,105,160, 63, 67,\n+   36, 36, 36, 61, 57,161,162, 69, 36, 36, 36, 36, 36, 63, 40, 69,\n+   44, 44, 62, 36, 36, 36, 36, 36, 67, 27, 27, 67, 67, 67, 67, 67,\n+   67, 67, 67, 67, 67, 67, 67, 92, 27, 27, 27, 27, 27, 67, 67, 67,\n+   67, 67, 67, 67, 27, 27, 27, 27,163, 27, 27, 27, 27, 27, 27, 27,\n+   36, 36, 83, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,164,  2,\n+    7,  7,  7,  7,  7, 36, 44, 44, 32, 32, 32, 32, 32, 32, 32, 70,\n+   51,165, 43, 43, 43, 43, 43, 88, 32, 32, 32, 32, 32, 32, 40, 43,\n+   36, 36, 36,105,105,105,105,105, 43,  2,  2,  2, 44, 44, 44, 44,\n+   41, 41, 41,162, 40, 40, 40, 40, 41, 32, 32, 32, 32, 32, 32, 32,\n+   16, 32, 32, 32, 32, 32, 32, 32, 45, 16, 16, 16, 34, 34, 34, 32,\n+   32, 32, 32, 32, 42,166, 34, 35, 32, 32, 16, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 32, 11, 11, 32, 11, 11, 32, 32, 32, 32, 32, 32,\n+   32, 32, 11, 11, 34,110, 44, 44, 32,150,150, 32, 32, 44, 44, 44,\n+   44, 40,167, 35, 40, 35, 36, 36, 36, 71, 36, 71, 36, 70, 36, 36,\n+   36, 94, 87, 85, 67, 67, 80, 44, 27, 27, 27, 67,168, 44, 44, 44,\n+   36, 36,  2,  2, 44, 44, 44, 44, 86, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 86, 86, 86, 86, 86, 86, 86, 86, 43, 44, 44, 44, 44,  2,\n@@ -4130,2 +4191,2 @@\n-   36, 36, 36, 70, 43, 43, 43, 43, 43, 84, 44, 44, 44, 44, 44, 91,\n-   36, 70, 84, 43, 43, 84, 43, 84,162,  2,  2,  2,  2,  2,  2, 52,\n+   36, 36, 36, 70, 43, 43, 43, 43, 43, 86, 44, 44, 44, 44, 44, 93,\n+   36, 70, 86, 43, 43, 86, 43, 86,107,  2,  2,  2,  2,  2,  2, 52,\n@@ -4133,3 +4194,3 @@\n-    7,  7,  7,  7,  7, 36, 36, 61, 36, 36, 36, 36, 70, 43, 43, 83,\n-   85, 83, 85, 80, 44, 44, 44, 44, 36, 70, 36, 36, 36, 36, 83, 44,\n-    7,  7,  7,  7,  7, 44,  2,  2, 69, 36, 36, 77, 67, 92, 83, 36,\n+    7,  7,  7,  7,  7, 36, 36, 61, 36, 36, 36, 36, 70, 43, 43, 85,\n+   87, 85, 87, 80, 44, 44, 44, 44, 36, 70, 36, 36, 36, 36, 85, 44,\n+    7,  7,  7,  7,  7, 44,  2,  2, 69, 36, 36, 77, 67, 94, 85, 36,\n@@ -4137,4 +4198,4 @@\n-   44, 44, 44, 44, 44, 62,106,  2, 36, 36, 36, 36, 36, 92, 43, 84,\n-    2,106,163, 80, 44, 44, 44, 44, 62, 36, 36, 61, 62, 36, 36, 61,\n-   62, 36, 36, 61, 44, 44, 44, 44, 16, 16, 16, 16, 16,112, 40, 40,\n-   16, 16, 16, 16,109, 41, 44, 44, 36, 92, 85, 84, 83,162, 85, 44,\n+   44, 44, 44, 44, 44, 62, 83,  2, 36, 36, 36, 36, 36, 94, 43, 86,\n+    2, 83,169, 80, 44, 44, 44, 44, 62, 36, 36, 61, 62, 36, 36, 61,\n+   62, 36, 36, 61, 44, 44, 44, 44, 16, 16, 16, 16, 16,114, 40, 40,\n+   16, 16, 16, 16,111, 41, 44, 44, 36, 94, 87, 86, 85,107, 87, 44,\n@@ -4142,3 +4203,3 @@\n-  164,164,164,164,164,164,164,164,165,165,165,165,165,165,165,165,\n-   16, 16, 16,108, 44, 44, 44, 44, 44,146, 16, 16, 44, 44, 62, 71,\n-   36, 36, 36, 36,166, 36, 36, 36, 36, 36, 36, 61, 36, 36, 61, 61,\n+  170,170,170,170,170,170,170,170,171,171,171,171,171,171,171,171,\n+   16, 16, 16,110, 44, 44, 44, 44, 44,150, 16, 16, 44, 44, 62, 71,\n+   36, 36, 36, 36,172, 36, 36, 36, 36, 36, 36, 61, 36, 36, 61, 61,\n@@ -4146,7 +4207,8 @@\n-   41, 44, 44, 44, 44, 44, 44, 44, 44, 62, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36,144, 44, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36,161, 44,  2,  2,  2,167,128, 44, 44, 44,\n-    6,168,169,144,144,144,144,144,144,144,128,167,128,  2,125,170,\n-    2, 64,  2,  2,150,144,144,128,  2,171,  8,172, 66,  2, 44, 44,\n-   36, 36, 36, 36, 36, 36, 61, 79, 91,  2,  3,  2,  4,  5,  6,  2,\n-   16, 16, 16, 16, 16, 17, 18,127,128,  4,  2, 36, 36, 36, 36, 36,\n+   41,117, 44, 44, 44, 44, 44, 44, 44, 62, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 36,148, 44, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 44, 44, 44, 55, 36, 36, 36, 36, 36, 36,168, 67,\n+    2,  2,  2,152,130, 44, 44, 44,  6,173,174,148,148,148,148,148,\n+  148,148,130,152,130,  2,127,175,  2, 64,  2,  2,156,148,148,130,\n+    2,176,  8,177, 66,  2, 44, 44, 36, 36, 61, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 61, 79, 93,  2,  3,  2,  4,  5,  6,  2,\n+   16, 16, 16, 16, 16, 17, 18,129,130,  4,  2, 36, 36, 36, 36, 36,\n@@ -4155,1 +4217,1 @@\n-   20,173, 56,174, 26,  8,140, 90, 44, 44, 44, 44, 79, 65, 67, 44,\n+   20,178, 56,135, 26,  8,144, 92, 44, 44, 44, 44, 79, 65, 67, 44,\n@@ -4157,4 +4219,4 @@\n-    2, 64, 44,175, 27, 27, 27, 27, 27, 27, 44, 55, 67, 67, 67, 67,\n-  103,103,139, 27, 89, 67, 67, 67, 67, 67, 67, 67, 67, 27, 67, 90,\n-   67, 67, 67, 67, 67, 67, 90, 44, 90, 44, 44, 44, 44, 44, 44, 44,\n-   67, 67, 67, 67, 67, 67, 50, 44,176, 27, 27, 27, 27, 27, 27, 27,\n+    2, 64, 44,179, 27, 27, 27, 27, 27, 27, 44, 55, 67, 67, 67, 67,\n+  105,105,143, 27, 91, 67, 67, 67, 67, 67, 67, 67, 67, 27, 67, 92,\n+   67, 67, 67, 67, 67, 67, 92, 44, 92, 44, 44, 44, 44, 44, 44, 44,\n+   67, 67, 67, 67, 67, 67, 50, 44,180, 27, 27, 27, 27, 27, 27, 27,\n@@ -4162,3 +4224,3 @@\n-  149, 36, 36, 36, 36,177, 44, 44, 36, 36, 36, 43, 43, 80, 44, 44,\n-   36, 36, 36, 36, 36, 36, 36, 91, 36, 36, 44, 44, 36, 36, 36, 36,\n-  178,103,103, 44, 44, 44, 44, 44, 11, 11, 11, 11, 16, 16, 16, 16,\n+  155, 36, 36, 36, 36,181, 44, 44, 36, 36, 36, 43, 43, 80, 44, 44,\n+   36, 36, 36, 36, 36, 36, 36, 93, 36, 36, 44, 44, 36, 36, 36, 36,\n+  182,105,105, 44, 44, 44, 44, 44, 11, 11, 11, 11, 16, 16, 16, 16,\n@@ -4166,18 +4228,22 @@\n-   36, 36, 44, 44, 44, 44, 44, 91, 36, 36, 36, 44, 61, 36, 36, 36,\n-   36, 36, 36, 62, 61, 44, 61, 62, 36, 36, 36, 91, 27, 27, 27, 27,\n-   36, 36, 36, 77,157, 27, 27, 27, 44, 44, 44,175, 27, 27, 27, 27,\n-   36, 61, 36, 44, 44,175, 27, 27, 36, 36, 36, 27, 27, 27, 44, 91,\n-   36, 36, 36, 36, 36, 44, 44, 91, 36, 36, 36, 36, 44, 44, 27, 36,\n-   44, 27, 27, 27, 27, 27, 27, 27, 70, 43, 57, 80, 44, 44, 43, 43,\n-   36, 36, 62, 36, 62, 36, 36, 36, 36, 36, 36, 44, 43, 80, 44, 57,\n-   27, 27, 27, 27, 98, 44, 44, 44,  2,  2,  2,  2, 64, 44, 44, 44,\n-   36, 36, 36, 36, 36, 36,179, 30, 36, 36, 36, 36, 36, 36,179, 27,\n-   36, 36, 36, 36, 78, 36, 36, 36, 36, 36, 70, 80, 44,175, 27, 27,\n-    2,  2,  2, 64, 44, 44, 44, 44, 36, 36, 36, 44, 91,  2,  2,  2,\n-   36, 36, 36, 44, 27, 27, 27, 27, 36, 61, 44, 44, 27, 27, 27, 27,\n-   36, 44, 44, 44, 91,  2, 64, 44, 44, 44, 44, 44,175, 27, 27, 27,\n-   11, 47, 44, 44, 44, 44, 44, 44, 16,108, 44, 44, 44, 27, 27, 27,\n-   36, 36, 43, 43, 44, 44, 44, 44, 27, 27, 27, 27, 27, 27, 27, 98,\n-   36, 36, 36, 36, 36, 57,180, 44, 36, 44, 44, 44, 44, 44, 44, 44,\n-   27, 27, 27, 93, 44, 44, 44, 44,176, 27, 30,  2,  2, 44, 44, 44,\n-   36, 36,179, 27, 27, 27, 44, 44, 85, 96, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 44, 44, 44, 44, 36, 36, 44, 44, 44, 44, 44, 93,\n+   11, 11, 11, 11, 11, 47, 11, 11, 11, 47, 11,150, 16, 16, 16, 16,\n+   16,150, 16, 16, 16, 16, 16, 16, 16,150, 16, 16, 16,150,110, 44,\n+   40, 40, 40, 52, 40, 40, 40, 40, 81, 40, 40, 40, 40, 81, 44, 44,\n+   36, 36, 36, 44, 61, 36, 36, 36, 36, 36, 36, 62, 61, 44, 61, 62,\n+   36, 36, 36, 93, 27, 27, 27, 27, 36, 36, 36, 77,163, 27, 27, 27,\n+   44, 44, 44,179, 27, 27, 27, 27, 36, 61, 36, 44, 44,179, 27, 27,\n+   36, 36, 36, 27, 27, 27, 44, 93, 36, 36, 36, 36, 36, 44, 44, 93,\n+   36, 36, 36, 36, 44, 44, 27, 36, 44, 27, 27, 27, 27, 27, 27, 27,\n+   70, 43, 57, 80, 44, 44, 43, 43, 36, 36, 62, 36, 62, 36, 36, 36,\n+   36, 36, 36, 44, 43, 80, 44, 57, 27, 27, 27, 27,100, 44, 44, 44,\n+    2,  2,  2,  2, 64, 44, 44, 44, 36, 36, 36, 36, 36, 36,183, 30,\n+   36, 36, 36, 36, 36, 36,183, 27, 36, 36, 36, 36, 78, 36, 36, 36,\n+   36, 36, 70, 80, 44,179, 27, 27,  2,  2,  2, 64, 44, 44, 44, 44,\n+   36, 36, 36, 44, 93,  2,  2,  2, 36, 36, 36, 44, 27, 27, 27, 27,\n+   36, 61, 44, 44, 27, 27, 27, 27, 36, 44, 44, 44, 93,  2, 64, 44,\n+   44, 44, 44, 44,179, 27, 27, 27, 11, 47, 44, 44, 44, 44, 44, 44,\n+   16,110, 44, 44, 44, 27, 27, 27, 36, 36, 43, 43, 44, 44, 44, 44,\n+   27, 27, 27, 27, 27, 27, 27,100, 36, 36, 36, 36, 36, 57,184, 44,\n+   36, 44, 44, 44, 44, 44, 44, 44, 27, 27, 27, 95, 44, 44, 44, 44,\n+  180, 27, 30,  2,  2, 44, 44, 44, 36, 43, 43,  2,  2, 44, 44, 44,\n+   36, 36,183, 27, 27, 27, 44, 44, 87, 98, 36, 36, 36, 36, 36, 36,\n@@ -4185,8 +4251,8 @@\n-   27, 27, 27,  7,  7,  7,  7,  7, 44, 44, 44, 44, 44, 44, 44, 57,\n-   84, 85, 43, 83, 85, 60,181,  2,  2, 44, 44, 44, 44, 44, 79, 44,\n-   43, 71, 36, 36, 36, 36, 36, 36, 36, 36, 36, 70, 43, 43, 85, 43,\n-   43, 43, 80,  7,  7,  7,  7,  7,  2,  2, 92, 96, 44, 44, 44, 44,\n-   36, 70,  2, 61, 44, 44, 44, 44, 36, 92, 84, 43, 43, 43, 43, 83,\n-   96, 36, 63,  2, 59, 43, 60, 85,  7,  7,  7,  7,  7, 63, 63,  2,\n-  175, 27, 27, 27, 27, 27, 27, 27, 27, 27, 98, 44, 44, 44, 44, 44,\n-   36, 36, 36, 36, 36, 36, 84, 85, 43, 84, 83, 43,  2,  2,  2, 80,\n+   27, 27, 27,  7,  7,  7,  7,  7, 71, 70, 71, 44, 44, 44, 44, 57,\n+   86, 87, 43, 85, 87, 60,185,  2,  2, 80, 44, 44, 44, 44, 79, 44,\n+   43, 71, 36, 36, 36, 36, 36, 36, 36, 36, 36, 70, 43, 43, 87, 43,\n+   43, 43, 80,  7,  7,  7,  7,  7,  2,  2, 94, 98, 44, 44, 44, 44,\n+   36, 70,  2, 61, 44, 44, 44, 44, 36, 94, 86, 43, 43, 43, 43, 85,\n+   98, 36, 63,  2, 59, 43, 60, 87,  7,  7,  7,  7,  7, 63, 63,  2,\n+  179, 27, 27, 27, 27, 27, 27, 27, 27, 27,100, 44, 44, 44, 44, 44,\n+   36, 36, 36, 36, 36, 36, 86, 87, 43, 86, 85, 43,  2,  2,  2, 80,\n@@ -4195,7 +4261,7 @@\n-   84, 85, 43, 43, 43, 80, 44, 44, 43, 84, 62, 36, 36, 36, 61, 62,\n-   61, 36, 62, 36, 36, 57, 71, 84, 83, 84, 88, 87, 88, 87, 84, 44,\n-   61, 44, 44, 87, 44, 44, 62, 36, 36, 84, 44, 43, 43, 43, 80, 44,\n-   43, 43, 80, 44, 44, 44, 44, 44, 36, 36, 92, 84, 43, 43, 43, 43,\n-   84, 43, 83, 71, 36, 63,  2,  2,  7,  7,  7,  7,  7,  2, 91, 71,\n-   84, 85, 43, 43, 83, 83, 84, 85, 83, 43, 36, 72, 44, 44, 44, 44,\n-   36, 36, 36, 36, 36, 36, 36, 92, 84, 43, 43, 44, 84, 84, 43, 85,\n+   86, 87, 43, 43, 43, 80, 44, 44, 43, 86, 62, 36, 36, 36, 61, 62,\n+   61, 36, 62, 36, 36, 57, 71, 86, 85, 86, 90, 89, 90, 89, 86, 44,\n+   61, 44, 44, 89, 44, 44, 62, 36, 36, 86, 44, 43, 43, 43, 80, 44,\n+   43, 43, 80, 44, 44, 44, 44, 44, 36, 36, 94, 86, 43, 43, 43, 43,\n+   86, 43, 85, 71, 36, 63,  2,  2,  7,  7,  7,  7,  7,  2, 93, 71,\n+   86, 87, 43, 43, 85, 85, 86, 87, 85, 43, 36, 72, 44, 44, 44, 44,\n+   36, 36, 36, 36, 36, 36, 36, 94, 86, 43, 43, 44, 86, 86, 43, 87,\n@@ -4203,12 +4269,12 @@\n-   84, 85, 43, 43, 43, 83, 85, 85, 60,  2, 61, 44, 44, 44, 44, 44,\n-    2,  2,  2,  2,  2,  2, 64, 44, 36, 36, 36, 36, 36, 70, 85, 84,\n-   43, 43, 43, 85, 61, 44, 44, 44, 84, 43, 43, 85, 43, 43, 44, 44,\n-    7,  7,  7,  7,  7, 27,  2, 95, 43, 43, 43, 43, 85, 60, 44, 44,\n-   27, 98, 44, 44, 44, 44, 44, 62, 36, 36, 36, 61, 62, 44, 36, 36,\n-   36, 36, 62, 61, 36, 36, 36, 36, 84, 84, 84, 87, 88, 57, 83, 71,\n-   96, 85,  2, 64, 44, 44, 44, 44, 36, 36, 36, 36, 44, 36, 36, 36,\n-   92, 84, 43, 43, 44, 43, 84, 84, 71, 72, 88, 44, 44, 44, 44, 44,\n-   70, 43, 43, 43, 43, 71, 36, 36, 36, 70, 43, 43, 83, 70, 43, 60,\n-    2,  2,  2, 59, 44, 44, 44, 44, 70, 43, 43, 83, 85, 43, 36, 36,\n-   36, 36, 36, 36, 36, 43, 43, 43, 43, 43, 43, 83, 43,  2, 72,  2,\n-    2, 64, 44, 44, 44, 44, 44, 44, 43, 43, 43, 80, 43, 43, 43, 85,\n+   86, 87, 43, 43, 43, 85, 87, 87, 60,  2, 61, 44, 44, 44, 44, 44,\n+    2,  2,  2,  2,  2,  2, 64, 44, 36, 36, 36, 36, 36, 70, 87, 86,\n+   43, 43, 43, 87, 63, 44, 44, 44, 86, 43, 43, 87, 43, 43, 44, 44,\n+    7,  7,  7,  7,  7, 27,  2, 97, 43, 43, 43, 43, 87, 60, 44, 44,\n+   27,100, 44, 44, 44, 44, 44, 62, 36, 36, 36, 61, 62, 44, 36, 36,\n+   36, 36, 62, 61, 36, 36, 36, 36, 86, 86, 86, 89, 90, 57, 85, 71,\n+   98, 87,  2, 64, 44, 44, 44, 44, 36, 36, 36, 36, 44, 36, 36, 36,\n+   94, 86, 43, 43, 44, 43, 86, 86, 71, 72, 90, 44, 44, 44, 44, 44,\n+   70, 43, 43, 43, 43, 71, 36, 36, 36, 70, 43, 43, 85, 70, 43, 60,\n+    2,  2,  2, 59, 44, 44, 44, 44, 70, 43, 43, 85, 87, 43, 36, 36,\n+   36, 36, 36, 36, 36, 43, 43, 43, 43, 43, 43, 85, 43,  2, 72,  2,\n+    2, 64, 44, 44, 44, 44, 44, 44, 43, 43, 43, 80, 43, 43, 43, 87,\n@@ -4216,2 +4282,2 @@\n-   44, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 87, 43, 43, 43,\n-   83, 43, 85, 80, 44, 44, 44, 44, 36, 36, 36, 61, 36, 62, 36, 36,\n+   44, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 89, 43, 43, 43,\n+   85, 43, 87, 80, 44, 44, 44, 44, 36, 36, 36, 61, 36, 62, 36, 36,\n@@ -4219,12 +4285,13 @@\n-   36, 36, 36, 62, 61, 36, 36, 36, 36, 36, 36, 36, 36, 84, 84, 88,\n-   43, 87, 85, 85, 61, 44, 44, 44, 36, 70, 83,162, 64, 44, 44, 44,\n-   27, 27, 89, 67, 67, 67, 56, 20,161, 67, 67, 67, 67, 67, 67, 67,\n-   67, 44, 44, 44, 44, 44, 44, 91,103,103,103,103,103,103,103,177,\n-    2,  2, 64, 44, 44, 44, 44, 44, 65, 65, 65, 65, 68, 44, 44, 44,\n-   43, 43, 60, 44, 44, 44, 44, 44, 43, 43, 43, 60,  2,  2, 67, 67,\n-   40, 40, 95, 44, 44, 44, 44, 44,  7,  7,  7,  7,  7,175, 27, 27,\n-   27, 62, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 44, 44, 62, 36,\n-   27, 27, 27, 30,  2, 64, 44, 44, 36, 36, 36, 36, 36, 61, 44, 57,\n-   92, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84,\n-   84, 84, 84, 84, 44, 44, 44, 57, 43, 74, 40, 40, 40, 40, 40, 40,\n-   40, 86, 80, 44, 44, 44, 44, 44, 84, 44, 44, 44, 44, 44, 44, 44,\n+   36, 36, 36, 62, 61, 36, 36, 36, 36, 36, 36, 36, 36, 86, 86, 90,\n+   43, 89, 87, 87, 61, 44, 44, 44, 36, 70, 85,107, 64, 44, 44, 44,\n+   27, 27, 91, 67, 67, 67, 56, 20,168, 67, 67, 67, 67, 67, 67, 67,\n+   67, 44, 44, 44, 44, 44, 44, 93,105,105,105,105,105,105,105,181,\n+    2,  2, 64, 44, 44, 44, 44, 44, 63, 64, 44, 44, 44, 44, 44, 44,\n+   65, 65, 65, 65,132, 44, 44, 44, 43, 43, 60, 44, 44, 44, 44, 44,\n+   43, 43, 43, 60,  2,  2, 67, 67, 40, 40, 97, 44, 44, 44, 44, 44,\n+    7,  7,  7,  7,  7,179, 27, 27, 27, 62, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 44, 44, 62, 36, 27, 27, 27, 30,  2, 64, 44, 44,\n+   36, 36, 36, 36, 36, 61, 44, 57, 94, 86, 86, 86, 86, 86, 86, 86,\n+   86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 44, 44, 44, 57,\n+   43, 74, 40, 40, 40, 40, 40, 40, 40, 88, 80, 44, 44, 44, 44, 44,\n+   86, 44, 44, 44, 44, 44, 44, 44, 40, 40, 52, 40, 40, 40, 52, 81,\n@@ -4233,28 +4300,30 @@\n-   67, 67, 67, 90, 55, 67, 67, 67, 67, 67,182, 85, 43, 67,182, 84,\n-   84,183, 65, 65, 65, 82, 43, 43, 43, 76, 50, 43, 43, 43, 67, 67,\n-   67, 67, 67, 67, 67, 43, 43, 67, 67, 67, 67, 67, 90, 44, 44, 44,\n-   67, 43, 76, 44, 44, 44, 44, 44, 27, 27, 44, 44, 44, 44, 44, 44,\n-   11, 11, 11, 11, 11, 16, 16, 16, 16, 16, 11, 11, 11, 11, 11, 11,\n-   11, 11, 11, 11, 11, 11, 11, 16, 16, 16,108, 16, 16, 16, 16, 16,\n-   11, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 47, 11,\n-   44, 47, 48, 47, 48, 11, 47, 11, 11, 11, 11, 16, 16,146,146, 16,\n-   16, 16,146, 16, 16, 16, 16, 16, 16, 16, 11, 48, 11, 47, 48, 11,\n-   11, 11, 47, 11, 11, 11, 47, 16, 16, 16, 16, 16, 11, 48, 11, 47,\n-   11, 11, 47, 47, 44, 11, 11, 11, 47, 16, 16, 16, 16, 16, 16, 16,\n-   16, 16, 16, 16, 16, 16, 11, 11, 11, 11, 11, 16, 16, 16, 16, 16,\n-   16, 16, 16, 44, 11, 11, 11, 11, 31, 16, 16, 16, 16, 16, 16, 16,\n-   16, 16, 16, 16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 11, 11, 11,\n-   11, 11, 11, 11, 11, 31, 16, 16, 16, 16, 33, 16, 16, 16, 11, 11,\n-   11, 11, 31, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 33,\n-   16, 16, 16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 31,\n-   16, 16, 16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 31, 16, 16, 16,\n-   16, 33, 16, 16, 16, 32, 44,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-   43, 43, 43, 76, 67, 50, 43, 43, 43, 43, 43, 43, 43, 43, 76, 67,\n-   67, 67, 50, 67, 67, 67, 67, 67, 67, 67, 76, 21,  2,  2, 44, 44,\n-   44, 44, 44, 44, 44, 57, 43, 43, 43, 43, 43, 80, 43, 43, 43, 43,\n-   43, 43, 43, 43, 80, 57, 43, 43, 43, 57, 80, 43, 43, 80, 44, 44,\n-   43, 43, 43, 74, 40, 40, 40, 44,  7,  7,  7,  7,  7, 44, 44, 77,\n-   36, 36, 36, 36, 36, 36, 43, 43,  7,  7,  7,  7,  7, 44, 44, 94,\n-   36, 36, 61,175, 27, 27, 27, 27, 43, 43, 43, 80, 44, 44, 44, 44,\n-   16, 16, 43, 43, 43, 74, 44, 44, 27, 27, 27, 27, 27, 27,157, 27,\n-  184, 27, 98, 44, 44, 44, 44, 44, 27, 27, 27, 27, 27, 27, 27,157,\n+   43, 43, 43, 43, 43, 43, 43, 44, 43, 43, 43, 80, 44, 44, 44, 44,\n+   67, 67, 67, 92, 55, 67, 67, 67, 67, 67,186, 87, 43, 67,186, 86,\n+   86,187, 65, 65, 65, 84, 43, 43, 43, 76, 50, 43, 43, 43, 67, 67,\n+   67, 67, 67, 67, 67, 43, 43, 67, 67, 43, 76, 44, 44, 44, 44, 44,\n+   27, 27, 44, 44, 44, 44, 44, 44, 11, 11, 11, 11, 11, 16, 16, 16,\n+   16, 16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 16,\n+   16, 16,110, 16, 16, 16, 16, 16, 11, 16, 16, 16, 16, 16, 16, 16,\n+   16, 16, 16, 16, 16, 16, 47, 11, 44, 47, 48, 47, 48, 11, 47, 11,\n+   11, 11, 11, 16, 16,150,150, 16, 16, 16,150, 16, 16, 16, 16, 16,\n+   16, 16, 11, 48, 11, 47, 48, 11, 11, 11, 47, 11, 11, 11, 47, 16,\n+   16, 16, 16, 16, 11, 48, 11, 47, 11, 11, 47, 47, 44, 11, 11, 11,\n+   47, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 11, 11,\n+   11, 11, 11, 16, 16, 16, 16, 16, 16, 16, 16, 44, 11, 11, 11, 11,\n+   31, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 33, 16, 16,\n+   16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 31, 16, 16,\n+   16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 31, 16, 16, 16, 16, 16,\n+   16, 16, 16, 16, 16, 16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 11,\n+   11, 11, 11, 11, 11, 11, 11, 31, 16, 16, 16, 16, 33, 16, 16, 16,\n+   11, 11, 11, 11, 31, 16, 16, 16, 16, 33, 16, 16, 16, 32, 44,  7,\n+    7,  7,  7,  7,  7,  7,  7,  7, 43, 43, 43, 76, 67, 50, 43, 43,\n+   43, 43, 43, 43, 43, 43, 76, 67, 67, 67, 50, 67, 67, 67, 67, 67,\n+   67, 67, 76, 21,  2,  2, 44, 44, 44, 44, 44, 44, 44, 57, 43, 43,\n+   16, 16, 16, 16, 16, 39, 16, 16, 16, 16, 16, 16, 16, 16, 16,110,\n+   43, 43, 43, 80, 43, 43, 43, 43, 43, 43, 43, 43, 80, 57, 43, 43,\n+   43, 57, 80, 43, 43, 80, 44, 44, 43, 43, 43, 74, 40, 40, 40, 44,\n+    7,  7,  7,  7,  7, 44, 44, 77, 36, 36, 36, 36, 36, 36, 36, 80,\n+   36, 36, 36, 36, 36, 36, 43, 43,  7,  7,  7,  7,  7, 44, 44, 96,\n+   36, 36, 36, 61, 36, 36, 62, 61, 36, 36, 61,179, 27, 27, 27, 27,\n+   16, 16, 43, 43, 43, 74, 44, 44, 27, 27, 27, 27, 27, 27,163, 27,\n+  188, 27,100, 44, 44, 44, 44, 44, 27, 27, 27, 27, 27, 27, 27,163,\n@@ -4267,8 +4336,8 @@\n-   27, 27, 27, 27, 27, 27, 89, 67, 67, 67, 67, 67, 67, 67, 67, 44,\n-   44, 44, 44, 67, 67, 67, 67, 67, 67, 90, 44, 44, 44, 44, 44, 44,\n-   67, 44, 44, 44, 44, 44, 44, 44, 67, 67, 67, 67, 67, 25, 41, 41,\n-   67, 67, 67, 67, 44, 44, 44, 44, 67, 67, 67, 67, 90, 67, 67, 67,\n-   67, 67, 67, 67, 67, 67, 55, 67, 67, 67, 90, 44, 67, 90, 44, 44,\n-   67, 90, 67, 67, 67, 67, 67, 67, 79, 44, 44, 44, 44, 44, 44, 44,\n-   65, 65, 65, 65, 65, 65, 65, 65,165,165,165,165,165,165,165, 44,\n-  165,165,165,165,165,165,165,  0,  0,  0, 29, 21, 21, 21, 23, 21,\n+   27, 27, 27, 27, 27, 27, 91, 67, 67, 67, 67, 67, 67, 67, 67, 44,\n+   44, 44, 44, 67, 67, 67, 67, 67, 67, 92, 44, 44, 44, 44, 44, 44,\n+   67, 67, 67, 67, 92, 44, 44, 44, 67, 44, 44, 44, 44, 44, 44, 44,\n+   67, 67, 67, 67, 67, 25, 41, 41, 67, 67, 67, 67, 44, 44, 55, 67,\n+   67, 67, 67, 67, 44, 44, 44, 44, 67, 67, 92, 44, 67, 67, 92, 44,\n+   67, 92, 67, 67, 67, 67, 67, 67, 79, 44, 44, 44, 44, 44, 44, 44,\n+   65, 65, 65, 65, 65, 65, 65, 65,171,171,171,171,171,171,171, 44,\n+  171,171,171,171,171,171,171,  0,  0,  0, 29, 21, 21, 21, 23, 21,\n@@ -4283,92 +4352,93 @@\n-    1,  2,  6,  7,  7, 12, 12,  7, 21,  7, 12,  1, 12,  6,  6, 12,\n-   12, 26,  7, 26, 26,  7,  2,  1, 12,  2,  6,  2,  1, 12, 12, 10,\n-   10, 10, 10, 12, 21,  6,  2, 10, 10,  2, 15, 26, 26,  2,  2, 21,\n-    7, 10, 15,  7,  2, 23, 21, 26, 10,  7, 21, 15, 15,  2, 17,  7,\n-   29,  7,  7, 22, 18,  2, 14, 14, 14,  7, 17, 21,  7,  6, 11, 12,\n-    5,  2,  5,  6,  8,  8,  8, 24,  5, 24,  2, 24,  9, 24, 24,  2,\n-   29, 29, 29,  1, 17, 17, 20, 19, 22, 20, 27, 28,  1, 29, 21, 20,\n-   19, 21, 21, 16, 16, 21, 25, 22, 18, 21, 21, 29, 15,  6, 18,  6,\n-   12, 11,  9, 26, 26,  9, 26,  5,  5, 26, 14,  9,  5, 14, 14, 15,\n-   25, 26, 26, 22, 18, 26, 18, 25, 18, 22,  5, 12,  2,  5, 22, 21,\n-   26,  6,  7, 14, 17, 22, 18, 18, 26, 14, 17,  6, 14,  6, 12, 24,\n-   24,  6, 26, 15,  6, 21, 11, 21, 24,  9, 23, 26, 10, 21,  6, 10,\n-    4,  4,  3,  3,  7, 25, 21, 22, 17, 16, 16, 22, 16, 16, 25, 17,\n-   25,  2, 25, 24, 23,  2,  2, 15, 12, 15, 14,  2, 21, 14,  7, 15,\n-   12, 17, 21,  1, 26, 10, 10,  1, 23, 15,  0,  1,  2,  3,  4,  5,\n-    6,  7,  8,  9,  0, 10, 11, 12, 13,  0, 14,  0,  0,  0,  0,  0,\n-   15,  0, 16,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17, 18, 19,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 20,  0, 21, 22, 23,  0,  0,  0, 24,\n-   25, 26, 27, 28, 29, 30, 31, 32, 33,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 34,\n-    0, 35,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0, 36,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 37, 38,  0,  0,  0,  0,  0,  0, 39, 40,  0,  0, 41,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  0,  0,  0,  0,\n-    0,  0,  0,  0,  5,  0,  0,  0,  0,  0,  0,  0,  6,  7,  8,  0,\n-    9,  0, 10, 11,  0,  0, 12, 13, 14, 15, 16,  0,  0,  0,  0, 17,\n-   18, 19, 20,  0,  0,  0, 21, 22,  0, 23, 24,  0,  0, 23, 25, 26,\n-    0, 23, 25,  0,  0, 23, 25,  0,  0, 23, 25,  0,  0,  0, 25,  0,\n-    0,  0, 27,  0,  0, 23, 25,  0,  0, 28, 25,  0,  0,  0, 29,  0,\n-    0, 30, 31,  0,  0, 32, 33,  0, 34, 35,  0, 36, 37,  0, 38,  0,\n-    0, 39,  0,  0, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0, 42, 42,  0,  0,  0,  0, 43,  0,\n-    0,  0,  0,  0,  0, 44,  0,  0,  0, 45,  0,  0,  0,  0,  0,  0,\n-   46,  0,  0, 47,  0, 48, 49,  0,  0, 50, 51, 52,  0, 53,  0, 54,\n-    0, 55,  0,  0,  0,  0, 56, 57,  0,  0,  0,  0,  0,  0, 58, 59,\n-    0,  0,  0,  0,  0,  0, 60, 61,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 62,  0,  0,  0, 63,  0,  0,  0, 64,\n-    0, 65,  0,  0, 66,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0, 67, 68,  0,  0, 69,  0,  0,  0,  0,  0,  0,  0,  0,\n-   70, 71,  0,  0,  0,  0, 51, 72,  0, 73, 74,  0,  0, 75, 76,  0,\n-    0,  0,  0,  0,  0, 77, 78, 79,  0,  0,  0,  0,  0,  0,  0, 25,\n-    0,  0,  0,  0,  0,  0,  0,  0, 80,  0,  0,  0,  0,  0,  0,  0,\n-    0, 81,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 82,\n-    0,  0,  0,  0,  0,  0,  0, 49,  0,  0,  0, 83,  0,  0,  0,  0,\n-   84, 85,  0,  0,  0,  0,  0, 86,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0, 87,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 88,  0,  0,  0,  0, 89,  0,  0,  0,  0,  0,\n-    0,  0, 70, 63,  0, 90,  0,  0, 91, 92,  0, 75,  0,  0, 93,  0,\n-    0, 94,  0,  0,  0,  0,  0, 95,  0, 96, 25, 97,  0,  0,  0,  0,\n-    0,  0, 98,  0,  0,  0, 99,  0,  0,  0,  0,  0,  0, 63,100,  0,\n-    0, 63,  0,  0,  0,101,  0,  0,  0,102,  0,  0,  0,  0,  0,  0,\n-    0, 90,  0,  0,  0,  0,  0,  0,  0,103,104,  0,  0,  0,  0, 76,\n-    0, 42,105,  0,106,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 63,  0,  0,  0,  0,  0,  0,  0,  0,107,  0,108,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,109,  0,110,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,111,\n-    0,  0,  0,  0,112,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,113,114,115,  0,  0,\n-    0,  0,116,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-  117,118,  0,  0,  0,  0,  0,  0,  0,110,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,119,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,120,  0,  0,  0,121,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  3,  4,\n-    5,  6,  7,  4,  4,  8,  9, 10,  1, 11, 12, 13, 14, 15, 16, 17,\n-   18,  1,  1,  1,  0,  0,  0,  0, 19,  1,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 20, 21, 22,  1, 23,  4, 21, 24, 25, 26, 27, 28,\n-   29, 30,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1, 31,  0,\n-    0,  0, 32, 33, 34, 35,  1, 36,  0,  0,  0,  0, 37,  0,  0,  0,\n-    0,  0,  0,  0,  0, 38,  1, 39, 14, 39, 40, 41,  0,  0,  0,  0,\n-    0,  0,  0,  0, 42,  0,  0,  0,  0,  0,  0,  0, 43, 36, 44, 45,\n-   21, 45, 46,  0,  0,  0,  0,  0,  0,  0, 19,  1, 21,  0,  0, 47,\n-    0,  0,  0,  0,  0, 38, 48,  1,  1, 49, 49, 50,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 51,  0,  0,  0,  0,  0, 52,  1,  1,  1,\n-   53, 21, 43, 54, 55, 21, 35,  1,  0,  0,  0,  0,  0,  0,  0, 56,\n-    0,  0,  0, 57, 58, 59,  0,  0,  0,  0,  0, 57,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 60,  0,  0,  0, 57,  0, 61,  0,  0,\n-    0,  0,  0,  0,  0,  0, 62, 63,  0,  0, 64,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 65,  0,  0,  0, 66,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 67,  0,  0,  0, 68,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 69,  0,  0,  0,  0,  0,  0, 70, 71,  0,\n-    0,  0,  0,  0, 72, 73, 74, 75, 76, 77,  0,  0,  0,  0,  0,  0,\n-    0, 78,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 79, 80,  0,\n+    1, 21,  6,  7,  7, 12, 12,  7, 21,  7, 12,  1, 12,  6,  6, 12,\n+   12, 26,  7, 26, 26,  7,  2,  1, 12,  2,  6,  2, 24,  7,  7,  6,\n+    1, 12, 12, 10, 10, 10, 10, 12, 21,  6,  2, 10, 10,  2, 15, 26,\n+   26,  2,  2, 21,  7, 10, 15,  7,  2, 23, 21, 26, 10,  7, 21, 15,\n+   15,  2, 17,  7, 29,  7,  7, 22, 18,  2, 14, 14, 14,  7, 10, 21,\n+   17, 21, 11, 12,  5,  2,  5,  6,  8,  8,  8, 24,  5, 24,  2, 24,\n+    9, 24, 24,  2, 29, 29, 29,  1, 17, 17, 20, 19, 22, 20, 27, 28,\n+    1, 29, 21, 20, 19, 21, 21, 16, 16, 21, 25, 22, 18, 21, 21, 29,\n+    1,  2, 15,  6, 18,  6, 23,  2, 12, 11,  9, 26, 26,  9, 26,  5,\n+    5, 26, 14,  9,  5, 14, 14, 15, 25, 26, 26, 22, 18, 26, 18, 25,\n+   18, 22,  5, 12,  2,  5, 22, 21, 21, 22, 18, 17, 26,  6,  7, 14,\n+   17, 22, 18, 18, 26, 14, 17,  6, 14,  6, 12, 24, 24,  6, 26, 15,\n+    6, 21, 11, 21, 24,  9,  6,  9, 23, 26,  6, 10,  4,  4,  3,  3,\n+    7, 25, 17, 16, 16, 22, 16, 16, 25, 17, 25,  2, 25, 24,  2, 15,\n+   12, 15, 14,  2, 21, 14,  7, 15, 12, 17, 21,  1, 26, 10, 10,  1,\n+   23, 15,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  0, 10, 11, 12,\n+   13,  0, 14,  0,  0,  0,  0,  0, 15,  0, 16,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 17, 18, 19,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20,\n+    0, 21, 22, 23,  0,  0,  0, 24, 25, 26, 27, 28, 29, 30, 31, 32,\n+   33,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 34,  0, 35,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   36,  0,  0,  0,  0,  0,  0,  0,  0,  0, 37, 38,  0,  0,  0,  0,\n+    0,  0, 39, 40,  0,  0, 41,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    1,  2,  3,  4,  0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,\n+    0,  0,  0,  0,  6,  7,  8,  0,  9,  0, 10, 11,  0,  0, 12, 13,\n+   14, 15, 16,  0,  0,  0,  0, 17, 18, 19, 20,  0, 21,  0, 22, 23,\n+    0, 24, 25,  0,  0, 24, 26, 27,  0, 24, 26,  0,  0, 24, 26,  0,\n+    0, 24, 26,  0,  0,  0, 26,  0,  0, 24, 28,  0,  0, 24, 26,  0,\n+    0, 29, 26,  0,  0,  0, 30,  0,  0, 31, 32,  0,  0, 33, 34,  0,\n+   35, 36,  0, 37, 38,  0, 39,  0,  0, 40,  0,  0, 41,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 42,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   43, 44,  0,  0,  0,  0, 45,  0,  0,  0,  0,  0,  0, 46,  0,  0,\n+    0, 47,  0,  0,  0,  0,  0,  0, 48,  0,  0, 49,  0, 50, 51,  0,\n+    0, 52, 53, 54,  0, 55,  0, 56,  0, 57,  0,  0,  0,  0, 58, 59,\n+    0,  0,  0,  0,  0,  0, 60, 61,  0,  0,  0,  0,  0,  0, 62, 63,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 64,\n+    0,  0,  0, 65,  0,  0,  0, 66,  0, 67,  0,  0, 68,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 69, 70,  0,  0, 71,\n+    0,  0,  0,  0,  0,  0,  0,  0, 72, 73,  0,  0,  0,  0, 53, 74,\n+    0, 75, 76,  0,  0, 77, 78,  0,  0,  0,  0,  0,  0, 79, 80, 81,\n+    0,  0,  0,  0,  0,  0,  0, 26,  0,  0,  0,  0,  0,  0,  0,  0,\n+   82,  0,  0,  0,  0,  0,  0,  0,  0, 83,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 84,  0,  0,  0,  0,  0,  0,  0, 85,\n+    0,  0,  0, 86,  0,  0,  0,  0, 87, 88,  0,  0,  0,  0,  0, 89,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0, 90,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 91,  0,  0,\n+    0,  0, 92,  0, 93,  0,  0,  0,  0,  0, 72, 94,  0, 95,  0,  0,\n+   96, 97,  0, 77,  0,  0, 98,  0,  0, 99,  0,  0,  0,  0,  0,100,\n+    0,101, 26,102,  0,  0,  0,  0,  0,  0,103,  0,  0,  0,104,  0,\n+    0,  0,  0,  0,  0, 65,105,  0,  0, 65,  0,  0,  0,106,  0,  0,\n+    0,107,  0,  0,  0,  0,  0,  0,  0, 95,  0,  0,  0,  0,  0,  0,\n+    0,108,109,  0,  0,  0,  0, 78,  0, 44,110,  0,111,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0, 65,  0,  0,  0,  0,  0,  0,\n+    0,  0,112,  0,113,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,114,\n+    0,115,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,116,  0,  0,  0,  0,117,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,118,119,120,  0,  0,  0,  0,121,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,122,123,  0,  0,  0,  0,  0,  0,\n+    0,115,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,124,  0,125,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,126,  0,\n+    0,  0,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    1,  1,  1,  1,  1,  2,  3,  4,  5,  6,  7,  4,  4,  8,  9, 10,\n+    1, 11, 12, 13, 14, 15, 16, 17, 18,  1,  1,  1,  0,  0,  0,  0,\n+   19,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20, 21, 22,  1,\n+   23,  4, 21, 24, 25, 26, 27, 28, 29, 30,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  1,  1, 31,  0,  0,  0, 32, 33, 34, 35,  1, 36,\n+    0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0,  0, 38,  1, 39,\n+   14, 39, 40, 41,  0,  0,  0,  0,  0,  0,  0,  0, 42,  0,  0,  0,\n+    0,  0,  0,  0, 43, 36, 44, 45, 21, 45, 46,  0,  0,  0,  0,  0,\n+    0,  0, 19,  1, 21,  0,  0, 47,  0,  0,  0,  0,  0, 38, 48,  1,\n+    1, 49, 49, 50,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 51,  0,\n+    0,  0,  0,  0,  0,  0, 52,  1,  0,  0, 38, 14,  4,  1,  1,  1,\n+   53, 21, 43, 52, 54, 21, 35,  1,  0,  0,  0,  0,  0,  0,  0, 55,\n+    0,  0,  0, 56, 57, 58,  0,  0,  0,  0,  0, 56,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 59,  0,  0,  0, 56,  0, 60,  0,  0,\n+    0,  0,  0,  0,  0,  0, 61, 62,  0,  0, 63,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 64,  0,  0,  0, 65,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 66,  0,  0,  0, 67,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 68,  0,  0,  0,  0,  0,  0, 69, 70,  0,\n+    0,  0,  0,  0, 71, 72, 73, 74, 75, 76,  0,  0,  0,  0,  0,  0,\n+    0, 77,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 78, 79,  0,\n@@ -4376,73 +4446,76 @@\n-    0,  0,  0,  0,  0, 63,  0,  0,  0,  0,  0,  0, 64,  0,  0, 81,\n-    0,  0, 82,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 83,  0,\n-    0,  0,  0,  0,  0, 19, 84,  0, 63,  0,  0,  0,  0, 49,  1, 85,\n-    0,  0,  0,  0,  1, 54, 15, 86, 84,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 56,  0,  0,  0, 63,  0,  0,  0,  0,  0,  0,\n-    0,  0, 19, 10,  1,  0,  0,  0,  0,  0, 87,  0,  0,  0,  0,  0,\n-    0, 88,  0,  0, 87,  0,  0,  0,  0,  0,  0,  0,  0, 79,  0,  0,\n-    0,  0,  0,  0, 89,  9, 12,  4, 90,  8, 91, 47,  0, 59, 50,  0,\n-   21,  1, 21, 92, 93,  1,  1,  1,  1,  1,  1,  1,  1, 94, 95, 96,\n-    0,  0,  0,  0, 97,  1, 98, 59, 81, 99,100,  4, 59,  0,  0,  0,\n-    0,  0,  0, 19, 50,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 62,\n-    1,  1,  1,  1,  1,  1,  1,  1,  0,  0,101,102,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,103,  0,  0,  0,  0, 19,  0,  1,  1, 50,\n-    0,  0,  0,  0,  0,  0,  0, 38,  0,  0,  0,  0, 50,  0,  0,  0,\n-    0, 64,  0,  0,  0,  0,  0,  0,  0,  0,  0, 63,  0,  0,  0,  0,\n-    1,  1,  1,  1, 50,  0,  0,  0,  0,  0, 52, 69,  0,  0,  0,  0,\n-    0,  0,  0,  0, 62,  0,  0,  0,  0,  0,  0,  0, 79,  0,  0,  0,\n-   63,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,104,105, 59, 38,\n-   81,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 64,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,106,  1, 14,  4, 12,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 47,  0,  0,  0,  0,  0, 38, 89,  0,\n-    0,  0,  0,107,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,108, 62,\n-    0,109,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,\n-    0,  0, 19, 59,  0,  0,  0,  0,  0,110, 14, 54, 84,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,111,  0, 89,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 62, 63,  0,  0, 63,  0, 88,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,111,  0,  0,  0,  0,112,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 79, 56,  0, 38,  1, 59,  1, 59,  0,  0,\n-   64, 88,  0,  0,  0,  0,  0, 60,113,  0,  0,  0,  0,  0,  0,  0,\n-   56,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,113,  0,  0,\n-    0,  0, 62,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 80,\n-   79,  0,  0,  0,  0,  0,  0,  0,  0, 62,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 57,  0, 88,114,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0, 62,  0,  0,  0,  0,  0,  0,  8, 91,  0,  0,\n-    0,  0,  0,  0,  1, 89,  0,  0,  0,  0,  0,  0,115,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,116,  0,117,118,119,120,  0, 52,  4,\n-  121, 49, 23,  0,  0,  0,  0,  0,  0,  0, 38, 50,  0,  0,  0,  0,\n-   38, 59,  0,  0,  0,  0,  0,  0,  1, 89,  1,  1,  1,  1, 39,  1,\n-   48,104, 89,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,\n-    0,  0,  0,  0,  4,121,  0,  0,  0,  1,122,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,230,230,230,230,230,232,220,220,220,220,232,216,\n-  220,220,220,220,220,202,202,220,220,220,220,202,202,220,220,220,\n-    1,  1,  1,  1,  1,220,220,220,220,230,230,230,230,240,230,220,\n-  220,220,230,230,230,220,220,  0,230,230,230,220,220,220,220,230,\n-  232,220,220,230,233,234,234,233,234,234,233,230,  0,  0,  0,230,\n-    0,220,230,230,230,230,220,230,230,230,222,220,230,230,220,220,\n-  230,222,228,230, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20,\n-   21, 22,  0, 23,  0, 24, 25,  0,230,220,  0, 18, 30, 31, 32,  0,\n-    0,  0,  0, 27, 28, 29, 30, 31, 32, 33, 34,230,230,220,220,230,\n-  220,230,230,220, 35,  0,  0,  0,  0,  0,230,230,230,  0,  0,230,\n-  230,  0,220,230,230,220,  0,  0,  0, 36,  0,  0,230,220,230,230,\n-  220,220,230,220,220,230,220,230,220,230,230,  0,  0,220,  0,  0,\n-  230,230,  0,230,  0,230,230,230,230,230,  0,  0,  0,220,220,220,\n-    0,  0,  0,220,230,230,  0,220,230,220,220,220, 27, 28, 29,230,\n-    7,  0,  0,  0,  0,  9,  0,  0,  0,230,220,230,230,  0,  0,  0,\n-    0,  0,230,  0,  0, 84, 91,  0,  0,  0,  0,  9,  9,  0,  0,  0,\n-    0,  0,  9,  0,103,103,  9,  0,107,107,107,107,118,118,  9,  0,\n-  122,122,122,122,220,220,  0,  0,  0,220,  0,220,  0,216,  0,  0,\n-    0,129,130,  0,132,  0,  0,  0,  0,  0,130,130,130,130,  0,  0,\n-  130,  0,230,230,  9,  0,230,230,  0,  0,220,  0,  0,  0,  0,  7,\n-    0,  9,  9,  0,  0,230,  0,  0,  0,228,  0,  0,  0,222,230,220,\n-  220,  0,  0,  0,230,  0,  0,220,230,220,  0,220,  0,  0,  9,  9,\n-    0,  0,  7,  0,230,230,230,  0,230,  0,  1,  1,  1,  0,  0,  0,\n-  230,234,214,220,202,230,230,230,230,230,232,228,228,220,  0,230,\n-  233,220,230,220,230,230,  1,  1,  1,  1,  1,230,  0,  1,  1,230,\n-  220,230,  1,  1,  0,  0,218,228,232,222,224,224,  0,  8,  8,  0,\n-  230,  0,230,230,220,  0,  0,230,  0,  0, 26,  0,  0,220,  0,230,\n-  230,  1,220,  0,  0,230,220,  0,  0,  0,220,220,  0,  9,  7,  0,\n-    0,  7,  9,  0,  0,  0,  9,  7,  9,  9,  0,  0,  6,  6,  0,  0,\n-    0,  0,  1,  0,  0,216,216,  1,  1,  1,  0,  0,  0,226,216,216,\n-  216,216,216,  0,220,220,220,  0,230,230,  7,  0, 16, 17, 17, 17,\n-   17, 17, 17, 33, 17, 17, 17, 19, 17, 17, 17, 17, 20,101, 17,113,\n-  129,169, 17, 27, 28, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+    0,  0,  0,  0,  0, 80,  0,  0,  0,  0,  0,  0,  0, 62,  0,  0,\n+    0,  0,  0,  0, 63,  0,  0, 81,  0,  0, 82,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 83,  0,  0,  0,  0,  0,  0, 19, 84,  0,\n+   62,  0,  0,  0,  0, 49,  1, 85,  0,  0,  0,  0,  1, 52, 15, 86,\n+   36, 10, 21, 87,  0,  0,  0,  0,  0,  0,  0,  0,  0, 55,  0,  0,\n+    0, 62,  0,  0,  0,  0,  0,  0,  0,  0, 19, 10,  1,  0,  0,  0,\n+    0,  0, 88,  0,  0,  0,  0,  0,  0, 89,  0,  0, 88,  0,  0,  0,\n+    0,  0,  0,  0,  0, 78,  0,  0,  0,  0,  0,  0, 87,  9, 12,  4,\n+   90,  8, 91, 47,  0, 58, 50,  0, 21,  1, 21, 92, 93,  1,  1,  1,\n+    1,  1,  1,  1,  1, 94, 95, 96,  0,  0,  0,  0, 97,  1, 98, 58,\n+   81, 99,100,  4, 58,  0,  0,  0,  0,  0,  0, 19, 50,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 61,  1,  1,  1,  1,  1,  1,  1,  1,\n+    0,  0,101,102,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,103,  0,\n+    0,  0,  0, 19,  0,  1,  1, 50,  0,  0,  0,  0,  0,  0,  0, 38,\n+    0,  0,  0,  0, 50,  0,  0,  0,  0, 63,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0, 62,  0,  0,  0,  0,  1,  1,  1,  1, 50,  0,  0,  0,\n+    0,  0,104, 68,  0,  0,  0,  0,  0,  0,  0,  0, 61,  0,  0,  0,\n+    0,  0,  0,  0, 78,  0,  0,  0, 62,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,105,106, 58, 38, 81,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 63,  0,  0,  0,  0,  0,  0,  0,  0,  0,107,\n+    1, 14,  4, 12,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 47,\n+   84,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 38, 87,  0,\n+    0,  0,  0,108,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,109, 61,\n+    0,110,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,\n+    0,  0, 19, 58,  0,  0,  0,  0,  0,111, 14, 52, 84,  0,  0,  0,\n+  112, 41,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 62,  0,  0, 61,\n+    0,  0,  0,  0,  0,  0,113,  0, 87,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0, 61, 62,  0,  0, 62,  0, 89,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,113,  0,  0,  0,  0,114,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 78, 55,  0, 38,  1, 58,  1, 58,  0,  0,\n+   63, 89,  0,  0,  0,  0,  0, 59,115,  0,  0,  0,  0,  0,  0,  0,\n+   55,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,115,  0,  0,\n+    0,  0, 61,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 79,\n+   78,  0,  0,  0,  0,  0,  0,  0,  0, 61,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 56,  0, 89, 80,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 61,  0,  0,  0,  0,  0,  0,  8, 91,  0,  0,\n+    0,  0,  0,  0,  1, 87,  0,  0,  0,  0,  0,  0,116,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,117,  0,118,119,120,121,  0,104,  4,\n+  122, 49, 23,  0,  0,  0,  0,  0,  0,  0, 38, 50,  0,  0,  0,  0,\n+   38, 58,  0,  0,  0,  0,  0,  0,  1, 87,  1,  1,  1,  1, 39,  1,\n+   48,105, 87,  0,  0,  0,  0,  0,  0,  0,  0, 59,  0,  0,  0,  0,\n+    0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  4,122,  0,  0,\n+    0,  1,123,  0,  0,  0,  0,  0,  0,  0,  0,  0,230,230,230,230,\n+  230,232,220,220,220,220,232,216,220,220,220,220,220,202,202,220,\n+  220,220,220,202,202,220,220,220,  1,  1,  1,  1,  1,220,220,220,\n+  220,230,230,230,230,240,230,220,220,220,230,230,230,220,220,  0,\n+  230,230,230,220,220,220,220,230,232,220,220,230,233,234,234,233,\n+  234,234,233,230,  0,  0,  0,230,  0,220,230,230,230,230,220,230,\n+  230,230,222,220,230,230,220,220,230,222,228,230, 10, 11, 12, 13,\n+   14, 15, 16, 17, 18, 19, 19, 20, 21, 22,  0, 23,  0, 24, 25,  0,\n+  230,220,  0, 18, 30, 31, 32,  0,  0,  0,  0, 27, 28, 29, 30, 31,\n+   32, 33, 34,230,230,220,220,230,220,230,230,220, 35,  0,  0,  0,\n+    0,  0,230,230,230,  0,  0,230,230,  0,220,230,230,220,  0,  0,\n+    0, 36,  0,  0,230,220,230,230,220,220,230,220,220,230,220,230,\n+  220,230,230,  0,  0,220,  0,  0,230,230,  0,230,  0,230,230,230,\n+  230,230,  0,  0,  0,220,220,220,230,220,220,220,230,230,  0,220,\n+   27, 28, 29,230,  7,  0,  0,  0,  0,  9,  0,  0,  0,230,220,230,\n+  230,  0,  0,  0,  0,  0,230,  0,  0, 84, 91,  0,  0,  0,  0,  9,\n+    9,  0,  0,  0,  0,  0,  9,  0,103,103,  9,  0,107,107,107,107,\n+  118,118,  9,  0,122,122,122,122,220,220,  0,  0,  0,220,  0,220,\n+    0,216,  0,  0,  0,129,130,  0,132,  0,  0,  0,  0,  0,130,130,\n+  130,130,  0,  0,130,  0,230,230,  9,  0,230,230,  0,  0,220,  0,\n+    0,  0,  0,  7,  0,  9,  9,  0,  9,  9,  0,  0,  0,230,  0,  0,\n+    0,228,  0,  0,  0,222,230,220,220,  0,  0,  0,230,  0,  0,220,\n+  230,220,  0,220,230,230,230,  0,  0,  0,  9,  9,  0,  0,  7,  0,\n+  230,  0,  1,  1,  1,  0,  0,  0,230,234,214,220,202,230,230,230,\n+  230,230,232,228,228,220,218,230,233,220,230,220,230,230,  1,  1,\n+    1,  1,  1,230,  0,  1,  1,230,220,230,  1,  1,  0,  0,218,228,\n+  232,222,224,224,  0,  8,  8,  0,  0,  0,  0,220,230,  0,230,230,\n+  220,  0,  0,230,  0,  0, 26,  0,  0,220,  0,230,230,  1,220,  0,\n+    0,230,220,  0,  0,  0,220,220,  0,  0,230,220,  0,  9,  7,  0,\n+    0,  7,  9,  0,  0,  0,  9,  7,  6,  6,  0,  0,  0,  0,  1,  0,\n+    0,216,216,  1,  1,  1,  0,  0,  0,226,216,216,216,216,216,  0,\n+  220,220,220,  0,230,230,  7,  0, 16, 17, 17, 17, 17, 17, 17, 33,\n+   17, 17, 17, 19, 17, 17, 17, 17, 20,101, 17,113,129,169, 17, 27,\n+   28, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n@@ -4454,33 +4527,33 @@\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,237,  0,  1,  2,  2,\n-    0,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  6,  7,  8,\n-    9,  0,  0,  0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 20,  0,  0, 21, 22,  0,  0,  0,  0,\n-   23, 24, 25, 26,  0, 27,  0, 28, 29, 30, 31, 32,  0,  0,  0,  0,\n-    0,  0,  0, 33, 34, 35,  0,  0,  0,  0,  0,  0, 36,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 37, 38,  0,  0,  0,  0,  1,  2, 39, 40,\n-    0,  1,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,\n-    0,  0,  0,  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  5,  0,\n-    0,  0,  6,  0,  0,  0,  0,  0,  0,  0,  7,  1,  0,  0,  0,  0,\n-    0,  0,  8,  9,  0,  0,  0,  0,  0,  0, 10,  0,  0, 10,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0, 10,\n-    0,  0,  0,  0,  0,  0, 11, 12,  0, 13,  0, 14, 15, 16,  0,  0,\n-    0,  0,  0,  1, 17, 18,  0, 19,  7,  1,  0,  0,  0, 20, 20,  7,\n-   20, 20, 20, 20, 20, 20, 20,  8, 21,  0, 22,  0,  7, 23, 24,  0,\n-   20, 20, 25,  0,  0,  0, 26, 27,  1,  7, 20, 20, 20, 20, 20,  1,\n-   28, 29, 30, 31,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0, 10,  0,\n-    0,  0,  0,  0,  0,  0, 20, 20, 20,  1,  0,  0,  8, 21, 32,  4,\n-    0, 10,  0, 33,  7, 20, 20, 20,  0,  0,  0,  0,  8, 34, 34, 35,\n-   36, 34, 37,  0, 38,  1, 20, 20,  0,  0, 39,  0,  1,  1,  0,  8,\n-   21,  1, 20,  0,  0,  0,  1,  0,  0, 40,  1,  1,  0,  0,  8, 21,\n-    0,  1,  0,  1,  0,  1,  0,  0,  0,  0, 26, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 21,  7, 20, 41, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 21,  0, 42, 43, 44,  0, 45,  0,  8, 21,  0,  0,  0,  0,  0,\n-    0,  0,  0, 46,  7,  1, 10,  1,  0,  0,  0,  1, 20, 20,  1,  0,\n-    0,  0,  0,  0,  0,  0, 20, 20,  1, 20, 20,  0,  0,  0,  0,  0,\n-    0,  0, 26, 21,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  3, 47, 48,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,\n-    4,  5,  6,  7,  7,  8,  7,  7,  7,  7,  7,  7,  7,  7,  7,  9,\n-   10, 11, 12, 12, 12, 12, 13, 14, 14, 14, 14, 15, 16, 17, 18, 19,\n-   20, 14, 21, 14, 22, 14, 14, 14, 14, 23, 24, 24, 25, 26, 14, 14,\n-   14, 14, 27, 28, 14, 14, 29, 30, 31, 32, 33, 34,  7,  7,  7,  7,\n+   17, 17, 17, 17, 17, 17, 17,237,  0,  1,  2,  2,  0,  3,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  5,  0,  0,  0,  0,  6,  7,  8,  9,  0,  0,  0,\n+   10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0, 20,  0,  0, 21, 22,  0,  0,  0,  0, 23, 24, 25, 26,\n+    0, 27,  0, 28, 29, 30, 31, 32,  0,  0,  0,  0,  0,  0,  0, 33,\n+   34, 35, 36,  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 38, 39,  0,  0,  0,  0,  1,  2, 40, 41,  0,  1,  2,  2,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  2,\n+    0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  5,  0,  0,  0,  6,  0,\n+    0,  0,  0,  0,  0,  0,  7,  1,  0,  0,  0,  0,  0,  0,  8,  9,\n+    0,  0,  0,  0,  0,  0, 10,  0,  0, 10,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0, 10,  0,  0,  0,  0,\n+    0,  0, 11, 12,  0, 13,  0, 14, 15, 16,  0,  0,  0,  0,  0,  1,\n+   17, 18,  0, 19,  7,  1,  0,  0,  0, 20, 20,  7, 20, 20, 20, 20,\n+   20, 20, 20,  8, 21,  0, 22,  0,  7, 23, 24,  0, 20, 20, 25,  0,\n+    0,  0, 26, 27,  1,  7, 20, 20, 20, 20, 20,  1, 28, 29, 30, 31,\n+    0,  0, 20,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,  0,  0,\n+    0,  0, 20, 20, 20,  1,  0,  0,  8, 21, 32,  4,  0, 10,  0, 33,\n+    7, 20, 20, 20,  0,  0,  0,  0,  8, 34, 34, 35, 36, 34, 37,  0,\n+   38,  1, 20, 20,  0,  0, 39,  0,  1,  1,  0,  8, 21,  1, 20,  0,\n+    0,  0,  1,  0,  0, 40,  1,  1,  0,  0,  8, 21,  0,  1,  0,  1,\n+    0,  1,  0,  0,  0,  0, 26, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+   21,  7, 20, 41, 34, 34, 34, 34, 34, 34, 34, 34, 34, 21,  0, 42,\n+   43, 44,  0, 45,  0,  8, 21,  0,  0,  0,  0,  0,  0,  0,  0, 46,\n+    7,  1, 10,  1,  0,  0,  0,  1, 20, 20,  1,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 26, 34,  9,  0,  0, 20, 20,  1, 20, 20,  0,\n+    0,  0,  0,  0,  0,  0, 26, 21,  0,  1,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  3, 47, 48,  0,  0,  0,  0,  0,  0,  0,\n+    0,  1,  2,  3,  4,  5,  6,  7,  7,  8,  7,  7,  7,  7,  7,  7,\n+    7,  7,  7,  7,  9, 10, 11, 11, 11, 11, 12, 13, 13, 13, 13, 14,\n+   15, 16, 17, 18, 19, 20, 21, 13, 22, 13, 13, 13, 13, 23, 24, 24,\n+   25, 26, 13, 13, 13, 27, 28, 29, 13, 30, 31, 32, 33, 34, 35, 36,\n@@ -4488,209 +4561,211 @@\n-   35,  7, 36, 37,  7, 38,  7,  7,  7, 39, 14, 40,  7,  7, 41, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 42,  0,  0,  1,\n-    2,  2,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,\n-   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n-   32, 32, 33, 34, 35, 36, 37, 37, 37, 37, 37, 38, 39, 40, 41, 42,\n-   43, 44, 45, 46, 47, 48, 49, 50, 51, 52,  2,  2, 53, 54, 55, 56,\n-   57, 58, 59, 59, 59, 59, 60, 59, 59, 59, 59, 59, 59, 59, 61, 61,\n-   59, 59, 59, 59, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,\n-   74, 75, 76, 77, 78, 59, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 79, 70, 70, 70, 70, 70, 70,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 80, 81, 81,\n-   81, 81, 81, 81, 81, 81, 81, 82, 83, 83, 84, 85, 86, 87, 88, 89,\n-   90, 91, 92, 93, 94, 95, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n-   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n-   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 96, 97, 97,\n-   97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,\n-   70, 70, 98, 99,100,101,102,102,103,104,105,106,107,108,109,110,\n-  111,112, 97,113,114,115,116,117,118, 97,119,119,120, 97,121,122,\n-  123,124,125,126,127,128,129,130,131, 97,132,133,134,135,136,137,\n-  138,139,140,141,142, 97,143,144, 97,145,146,147,148, 97,149,150,\n-  151,152,153,154, 97, 97,155,156,157,158, 97,159, 97,160,161,161,\n-  161,161,161,161,161,162,163,161,164, 97, 97, 97, 97, 97,165,165,\n-  165,165,165,165,165,165,166, 97, 97, 97, 97, 97, 97, 97, 97, 97,\n-   97, 97, 97, 97, 97, 97,167,167,167,167,168, 97, 97, 97,169,169,\n-  169,169,170,171,172,173, 97, 97, 97, 97,174,175,176,177,178,178,\n-  178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,\n-  178,178,178,178,178,178,178,178,178,178,178,178,178,179,178,178,\n-  178,178,178,178,180,180,180,181,182, 97, 97, 97, 97, 97,183,184,\n-  185,186,186,187, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,\n-   97, 97, 97, 97, 97, 97,188,189, 97, 97, 97, 97, 97, 97, 59,190,\n-  191,192,193,194,195, 97,196,197,198, 59, 59,199, 59,200,201,201,\n-  201,201,201,202, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,203, 97,\n-  204, 97, 97,205, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,206,207,\n-  208, 97, 97, 97, 97, 97,209,210,211, 97,212,213, 97, 97,214,215,\n-   59,216,217, 97, 59, 59, 59, 59, 59, 59, 59,218,219,220,221,222,\n-  223,224,225,226, 59,227, 97, 97, 97, 97, 97, 97, 97, 97, 70, 70,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,228, 70, 70, 70, 70,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,229, 70,230, 70,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n-   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,231, 70, 70, 70, 70,\n-   70, 70, 70, 70, 70,232, 97, 97, 97, 97, 97, 97, 97, 97, 70, 70,\n-   70, 70,233, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 70, 70,\n-   70, 70, 70, 70,234, 97, 97, 97, 97, 97, 97, 97, 97, 97,235, 97,\n-  236,237,  0,  1,  2,  2,  0,  1,  2,  2,  2,  3,  4,  5,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19,  0,  0,  0,  0,  0,  0,  0,\n-   19,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19,  0, 19,  0,\n-    0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19,  0,  0,  0,  0,  0,\n-   26, 26,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  9,  9,\n-    9,  9,  0,  9,  9,  9,  2,  2,  9,  9,  9,  9,  0,  9,  2,  2,\n-    2,  2,  9,  0,  9,  0,  9,  9,  9,  2,  9,  2,  9,  9,  9,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,  9,  9,  9,\n-   55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55,  6,  6,\n-    6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  1,  1,  6,  2,  4,\n-    4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n-    4,  4,  4,  4,  4,  2,  4,  4,  4,  2,  2,  4,  4,  4,  2, 14,\n-   14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  2,  2,\n-    2,  2,  2,  2,  2,  2, 14, 14, 14,  2,  2,  2,  2, 14, 14, 14,\n-   14, 14, 14,  2,  2,  2,  3,  3,  3,  3,  3,  0,  3,  3,  3,  3,\n-    3,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  0,  3,  2,  3,  0,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n-    3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  3,  3,  1,  3,\n-    3,  3,  3,  3,  3,  3, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37,\n-   37, 37, 37, 37,  2, 37, 37, 37, 37,  2,  2, 37, 37, 37, 38, 38,\n-   38, 38, 38, 38, 38, 38, 38, 38,  2,  2,  2,  2,  2,  2, 64, 64,\n-   64, 64, 64, 64, 64, 64, 64, 64, 64,  2,  2, 64, 64, 64, 90, 90,\n-   90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,  2,  2, 90, 90,\n-   90, 90, 90, 90, 90,  2, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95,\n-   95, 95,  2,  2, 95,  2, 37, 37, 37,  2,  2,  2,  2,  2,  3,  3,\n-    3,  3,  3,  2,  3,  3,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,\n-    0,  3,  3,  3,  3,  3,  7,  7,  7,  7,  7,  7,  7,  7,  7,  1,\n-    1,  1,  1,  7,  7,  7,  7,  7,  7,  7,  0,  0,  7,  7,  5,  5,\n-    5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  5,  2,  2,  5,  5,  2,\n-    2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  2,\n-    5,  5,  5,  5,  5,  5,  5,  2,  5,  2,  2,  2,  5,  5,  5,  5,\n-    2,  2,  5,  5,  5,  5,  5,  2,  2,  5,  5,  5,  5,  2,  2,  2,\n-    2,  2,  2,  2,  2,  5,  2,  2,  2,  2,  5,  5,  2,  5,  5,  5,\n-    5,  5,  2,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  2,  2, 11,\n-   11, 11,  2, 11, 11, 11, 11, 11, 11,  2,  2,  2,  2, 11, 11,  2,\n-    2, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,  2,\n-   11, 11, 11, 11, 11, 11, 11,  2, 11, 11,  2, 11, 11,  2, 11, 11,\n-    2,  2, 11,  2, 11, 11, 11,  2,  2, 11, 11, 11,  2,  2,  2, 11,\n-    2,  2,  2,  2,  2,  2,  2, 11, 11, 11, 11,  2, 11,  2,  2,  2,\n-    2,  2,  2,  2, 11, 11, 11, 11, 11, 11, 11, 11, 11,  2,  2, 10,\n-   10, 10,  2, 10, 10, 10, 10, 10, 10, 10, 10, 10,  2, 10, 10, 10,\n-    2, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,  2,\n-   10, 10, 10, 10, 10, 10, 10,  2, 10, 10,  2, 10, 10, 10, 10, 10,\n-    2,  2, 10, 10, 10, 10, 10, 10,  2, 10, 10, 10,  2,  2, 10,  2,\n-    2,  2,  2,  2,  2,  2, 10, 10, 10, 10,  2,  2, 10, 10, 10, 10,\n-    2,  2,  2,  2,  2,  2,  2, 10, 10, 10, 10, 10, 10, 10,  2, 21,\n-   21, 21,  2, 21, 21, 21, 21, 21, 21, 21, 21,  2,  2, 21, 21,  2,\n-    2, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,  2,\n-   21, 21, 21, 21, 21, 21, 21,  2, 21, 21,  2, 21, 21, 21, 21, 21,\n-    2,  2, 21, 21, 21, 21, 21,  2,  2, 21, 21, 21,  2,  2,  2,  2,\n-    2,  2,  2, 21, 21, 21,  2,  2,  2,  2, 21, 21,  2, 21, 21, 21,\n-   21, 21,  2,  2, 21, 21,  2,  2, 22, 22,  2, 22, 22, 22, 22, 22,\n-   22,  2,  2,  2, 22, 22, 22,  2, 22, 22, 22, 22,  2,  2,  2, 22,\n-   22,  2, 22,  2, 22, 22,  2,  2,  2, 22, 22,  2,  2,  2, 22, 22,\n-   22, 22, 22, 22, 22, 22, 22, 22,  2,  2,  2,  2, 22, 22, 22,  2,\n-    2,  2,  2,  2,  2, 22,  2,  2,  2,  2,  2,  2, 22, 22, 22, 22,\n-   22,  2,  2,  2,  2,  2, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n-   23, 23, 23,  2, 23, 23, 23,  2, 23, 23, 23, 23, 23, 23, 23, 23,\n-    2,  2,  2, 23, 23, 23, 23,  2, 23, 23, 23, 23,  2,  2,  2,  2,\n-    2,  2,  2, 23, 23,  2, 23, 23, 23,  2,  2,  2,  2,  2, 23, 23,\n-   23, 23,  2,  2, 23, 23,  2,  2,  2,  2,  2,  2,  2, 23, 16, 16,\n-   16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  2, 16, 16, 16,  2,\n-   16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  2, 16, 16, 16, 16, 16,\n-    2,  2, 16, 16, 16, 16, 16,  2, 16, 16, 16, 16,  2,  2,  2,  2,\n-    2,  2,  2, 16, 16,  2,  2,  2,  2,  2,  2,  2, 16,  2, 16, 16,\n-   16, 16,  2,  2, 16, 16,  2, 16, 16,  2,  2,  2,  2,  2, 20, 20,\n-   20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,  2, 20, 20, 20,  2,\n-   20, 20, 20, 20, 20, 20,  2,  2,  2,  2, 20, 20, 20, 20, 20, 20,\n-   20, 20,  2,  2, 20, 20,  2, 36, 36, 36,  2, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,  2,  2,  2,\n-   36, 36, 36, 36, 36, 36, 36, 36,  2, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36,  2, 36,  2,  2,  2,  2, 36,  2,  2,  2,  2, 36, 36, 36,\n-   36, 36, 36,  2, 36,  2,  2,  2,  2,  2,  2,  2, 36, 36,  2,  2,\n-   36, 36, 36,  2,  2,  2,  2, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n-   24, 24, 24, 24, 24, 24, 24, 24, 24,  2,  2,  2,  2,  0, 24, 24,\n-   24, 24,  2,  2,  2,  2,  2, 18, 18,  2, 18,  2, 18, 18, 18, 18,\n-   18,  2, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,\n-   18, 18,  2, 18,  2, 18, 18, 18, 18, 18, 18, 18,  2,  2, 18, 18,\n-   18, 18, 18,  2, 18,  2, 18, 18,  2,  2, 18, 18, 18, 18, 25, 25,\n-   25, 25, 25, 25, 25, 25,  2, 25, 25, 25, 25, 25, 25, 25, 25, 25,\n-   25, 25, 25,  2,  2,  2, 25, 25, 25, 25, 25,  2, 25, 25, 25, 25,\n-   25, 25, 25,  0,  0,  0,  0, 25, 25,  2,  2,  2,  2,  2, 33, 33,\n-   33, 33, 33, 33, 33, 33,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n-    8,  8,  8,  8,  2,  8,  2,  2,  2,  2,  2,  8,  2,  2,  8,  8,\n-    8,  0,  8,  8,  8,  8, 12, 12, 12, 12, 12, 12, 12, 12, 30, 30,\n-   30, 30, 30, 30, 30, 30, 30,  2, 30, 30, 30, 30,  2,  2, 30, 30,\n-   30, 30, 30, 30, 30,  2, 30, 30, 30,  2,  2, 30, 30, 30, 30, 30,\n-   30, 30, 30,  2,  2,  2, 30, 30,  2,  2,  2,  2,  2,  2, 29, 29,\n-   29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,  2,  2, 28, 28,\n-   28, 28, 28, 28, 28, 28, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34,  2,  2,  2, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,\n-   35,  0,  0,  0, 35, 35, 35,  2,  2,  2,  2,  2,  2,  2, 45, 45,\n-   45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45,  2, 45, 45, 45, 45,\n-   45, 45, 45,  2,  2,  2, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,\n-   44, 44, 44,  0,  0,  2, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,\n-   43, 43,  2,  2,  2,  2, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,\n-   46, 46, 46,  2, 46, 46, 46,  2, 46, 46,  2,  2,  2,  2, 31, 31,\n-   31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31,  2,  2, 31, 31,\n-    2,  2,  2,  2,  2,  2, 32, 32,  0,  0, 32,  0, 32, 32, 32, 32,\n-   32, 32, 32, 32, 32,  2, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n-    2,  2,  2,  2,  2,  2, 32,  2,  2,  2,  2,  2,  2,  2, 32, 32,\n-   32,  2,  2,  2,  2,  2, 28, 28, 28, 28, 28, 28,  2,  2, 48, 48,\n-   48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,  2, 48, 48,\n-   48, 48,  2,  2,  2,  2, 48,  2,  2,  2, 48, 48, 48, 48, 52, 52,\n-   52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,  2,  2, 52, 52,\n-   52, 52, 52,  2,  2,  2, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,\n-   58, 58,  2,  2,  2,  2, 58, 58,  2,  2,  2,  2,  2,  2, 58, 58,\n-   58,  2,  2,  2, 58, 58, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54,\n-   54, 54,  2,  2, 54, 54, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91,\n-   91, 91, 91, 91, 91,  2, 91, 91, 91, 91, 91,  2,  2, 91, 91, 91,\n-    2,  2,  2,  2,  2,  2, 91, 91, 91, 91, 91, 91,  2,  2,  1,  2,\n-    2,  2,  2,  2,  2,  2, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,\n-   62, 62,  2,  2,  2,  2, 62, 62, 62, 62, 62,  2,  2,  2, 76, 76,\n-   76, 76, 76, 76, 76, 76, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93,\n-   93, 93,  2,  2,  2,  2,  2,  2,  2,  2, 93, 93, 93, 93, 70, 70,\n-   70, 70, 70, 70, 70, 70,  2,  2,  2, 70, 70, 70, 70, 70, 70, 70,\n-    2,  2,  2, 70, 70, 70, 73, 73, 73, 73, 73, 73, 73, 73,  6,  2,\n-    2,  2,  2,  2,  2,  2,  8,  8,  8,  2,  2,  8,  8,  8,  1,  1,\n-    1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  0,\n-    0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  1,  1,\n-    0,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19,  9,  9,  9,  9,\n-    9,  6, 19, 19, 19, 19, 19, 19, 19, 19, 19,  9,  9,  9,  9,  9,\n-   19, 19, 19, 19,  9,  9,  9,  9,  9, 19, 19, 19, 19, 19,  6, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  9,  1,  1,\n-    2,  1,  1,  1,  1,  1,  9,  9,  9,  9,  9,  9,  2,  2,  2,  9,\n-    2,  9,  2,  9,  2,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,\n-    9,  9,  2,  2,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  2,  2,\n-    9,  9,  9,  2,  9,  9,  9,  9,  9,  9,  9,  9,  9,  2,  0,  0,\n-    0,  0,  1,  1,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0, 19,\n-    2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19,  0,  0,\n-    0,  0,  0,  0,  0,  2, 19, 19, 19, 19, 19,  2,  2,  2,  0,  0,\n-    0,  0,  0,  0,  9,  0,  0,  0, 19, 19,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 19,  0, 19,  0,  0,  0,  2,  2,  2,  2,  0,  0,\n-    0,  2,  2,  2,  2,  2, 27, 27, 27, 27, 27, 27, 27, 27,  0,  0,\n-    0,  0,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  2,  0, 56, 56,\n-   56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56,  2, 55, 55,\n-   55, 55,  2,  2,  2,  2,  2, 55, 55, 55, 55, 55, 55, 55, 61, 61,\n-   61, 61, 61, 61, 61, 61,  2,  2,  2,  2,  2,  2,  2, 61, 61,  2,\n-    2,  2,  2,  2,  2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-    2, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2,  2,  2,  2, 13, 13,\n-   13, 13, 13, 13,  2,  2,  0,  0,  0,  0,  2,  2,  2,  2,  0,  0,\n-    0,  0,  0, 13,  0, 13,  0, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n-    1,  1,  1,  1, 12, 12, 13, 13, 13, 13,  0,  0,  0,  0,  2, 15,\n+    7,  7,  7,  7, 37,  7, 38, 39,  7, 40,  7,  7,  7, 41, 13, 42,\n+    7,  7, 43, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,\n+   44,  0,  0,  1,  2,  2,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,\n+   12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,\n+   28, 29, 30, 31, 32, 32, 33, 34, 35, 36, 37, 37, 37, 37, 37, 38,\n+   39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,  2,  2,\n+   53, 54, 55, 56, 57, 58, 59, 59, 59, 59, 60, 59, 59, 59, 59, 59,\n+   59, 59, 61, 61, 59, 59, 59, 59, 62, 63, 64, 65, 66, 67, 68, 69,\n+   70, 71, 72, 73, 74, 75, 76, 77, 78, 59, 70, 70, 70, 70, 70, 70,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 79, 70, 70,\n+   70, 70, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81, 82, 82, 83, 84,\n+   85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 32, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+   32, 95, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 70, 70, 97, 98, 99,100,101,101,102,103,104,105,\n+  106,107,108,109,110,111, 96,112,113,114,115,116,117,118,119,119,\n+  120,121,122,123,124,125,126,127,128,129,130,131,132, 96,133,134,\n+  135,136,137,138,139,140,141,142,143, 96,144,145, 96,146,147,148,\n+  149, 96,150,151,152,153,154,155, 96, 96,156,157,158,159, 96,160,\n+   96,161,162,162,162,162,162,162,162,163,164,162,165, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96,166,167,167,167,167,167,167,167,167,168, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96,169,169,169,169,170, 96,\n+   96, 96,171,171,171,171,172,173,174,175, 96, 96, 96, 96,176,177,\n+  178,179,180,180,180,180,180,180,180,180,180,180,180,180,180,180,\n+  180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,\n+  180,181,180,180,180,180,180,180,182,182,182,183,184, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96,185,186,187,188,189,189,190, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96,191,192, 96, 96, 96, 96,\n+   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+  193,194, 59,195,196,197,198,199,200, 96,201,202,203, 59, 59,204,\n+   59,205,206,206,206,206,206,207, 96, 96, 96, 96, 96, 96, 96, 96,\n+  208, 96,209, 96,210, 96, 96,211, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96,212,213,214,215, 96, 96, 96, 96, 96,216,217,218, 96,219,220,\n+   96, 96,221,222, 59,223,224, 96, 59, 59, 59, 59, 59, 59, 59,225,\n+  226,227,228,229, 59, 59,230,231, 59,232, 96, 96, 96, 96, 96, 96,\n+   96, 96, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,233,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+  234, 70,235, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70,236,\n+   70, 70, 70, 70, 70, 70, 70, 70, 70,237, 96, 96, 96, 96, 96, 96,\n+   96, 96, 70, 70, 70, 70,238, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96, 70, 70, 70, 70, 70, 70,239, 96, 96, 96, 96, 96, 96, 96,\n+   96, 96,240, 96,241,242,  0,  1,  2,  2,  0,  1,  2,  2,  2,  3,\n+    4,  5,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19,\n+   19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,  0,  0,  0,\n+    0,  0,  0,  0, 19,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19, 19,\n+   19,  0, 19,  0,  0,  0,  0,  0,  0,  0, 19, 19, 19, 19, 19,  0,\n+    0,  0,  0,  0, 26, 26,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,\n+    1,  1,  9,  9,  9,  9,  0,  9,  9,  9,  2,  2,  9,  9,  9,  9,\n+    0,  9,  2,  2,  2,  2,  9,  0,  9,  0,  9,  9,  9,  2,  9,  2,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,\n+    9,  9,  9,  9, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55,\n+   55, 55,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  6,  1,\n+    1,  6,  2,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,\n+    4,  4,  4,  4,  4,  4,  4,  4,  4,  2,  4,  4,  4,  2,  2,  4,\n+    4,  4,  2, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,\n+   14, 14,  2,  2,  2,  2,  2,  2,  2,  2, 14, 14, 14,  2,  2,  2,\n+    2, 14, 14, 14, 14, 14, 14,  2,  2,  2,  3,  3,  3,  3,  3,  0,\n+    3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n+    3,  3,  3,  3,  3,  0,  3,  3,  3,  0,  0,  3,  3,  3,  3,  3,\n+    3,  3,  3,  3,  3,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n+    3,  3,  1,  3,  3,  3,  3,  3,  3,  3, 37, 37, 37, 37, 37, 37,\n+   37, 37, 37, 37, 37, 37, 37, 37,  2, 37, 37, 37, 37,  2,  2, 37,\n+   37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 38, 38,  2,  2,  2,  2,\n+    2,  2, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,  2,  2, 64,\n+   64, 64, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,\n+    2,  2, 90, 90, 90, 90, 90, 90, 90,  2, 95, 95, 95, 95, 95, 95,\n+   95, 95, 95, 95, 95, 95,  2,  2, 95,  2, 37, 37, 37,  2,  2,  2,\n+    2,  2,  3,  3,  3,  3,  3,  3,  3,  2,  3,  3,  2,  2,  2,  2,\n+    2,  2,  3,  3,  0,  3,  3,  3,  3,  3,  7,  7,  7,  7,  7,  7,\n+    7,  7,  7,  1,  1,  1,  1,  7,  7,  7,  7,  7,  7,  7,  0,  0,\n+    7,  7,  5,  5,  5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  5,  2,\n+    2,  5,  5,  2,  2,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,\n+    5,  5,  5,  2,  5,  5,  5,  5,  5,  5,  5,  2,  5,  2,  2,  2,\n+    5,  5,  5,  5,  2,  2,  5,  5,  5,  5,  5,  2,  2,  5,  5,  5,\n+    5,  2,  2,  2,  2,  2,  2,  2,  2,  5,  2,  2,  2,  2,  5,  5,\n+    2,  5,  5,  5,  5,  5,  2,  2,  5,  5,  5,  5,  5,  5,  5,  5,\n+    5,  2,  2, 11, 11, 11,  2, 11, 11, 11, 11, 11, 11,  2,  2,  2,\n+    2, 11, 11,  2,  2, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,\n+   11, 11, 11,  2, 11, 11, 11, 11, 11, 11, 11,  2, 11, 11,  2, 11,\n+   11,  2, 11, 11,  2,  2, 11,  2, 11, 11, 11,  2,  2, 11, 11, 11,\n+    2,  2,  2, 11,  2,  2,  2,  2,  2,  2,  2, 11, 11, 11, 11,  2,\n+   11,  2,  2,  2,  2,  2,  2,  2, 11, 11, 11, 11, 11, 11, 11, 11,\n+   11,  2,  2, 10, 10, 10,  2, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n+    2, 10, 10, 10,  2, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n+   10, 10, 10,  2, 10, 10, 10, 10, 10, 10, 10,  2, 10, 10,  2, 10,\n+   10, 10, 10, 10,  2,  2, 10, 10, 10, 10, 10, 10,  2, 10, 10, 10,\n+    2,  2, 10,  2,  2,  2,  2,  2,  2,  2, 10, 10, 10, 10,  2,  2,\n+   10, 10, 10, 10,  2,  2,  2,  2,  2,  2,  2, 10, 10, 10, 10, 10,\n+   10, 10,  2, 21, 21, 21,  2, 21, 21, 21, 21, 21, 21, 21, 21,  2,\n+    2, 21, 21,  2,  2, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21,  2, 21, 21, 21, 21, 21, 21, 21,  2, 21, 21,  2, 21,\n+   21, 21, 21, 21,  2,  2, 21, 21, 21, 21, 21,  2,  2, 21, 21, 21,\n+    2,  2,  2,  2,  2,  2,  2, 21, 21, 21,  2,  2,  2,  2, 21, 21,\n+    2, 21, 21, 21, 21, 21,  2,  2, 21, 21,  2,  2, 22, 22,  2, 22,\n+   22, 22, 22, 22, 22,  2,  2,  2, 22, 22, 22,  2, 22, 22, 22, 22,\n+    2,  2,  2, 22, 22,  2, 22,  2, 22, 22,  2,  2,  2, 22, 22,  2,\n+    2,  2, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,  2,  2,  2,  2,\n+   22, 22, 22,  2,  2,  2,  2,  2,  2, 22,  2,  2,  2,  2,  2,  2,\n+   22, 22, 22, 22, 22,  2,  2,  2,  2,  2, 23, 23, 23, 23, 23, 23,\n+   23, 23, 23, 23, 23, 23, 23,  2, 23, 23, 23,  2, 23, 23, 23, 23,\n+   23, 23, 23, 23,  2,  2, 23, 23, 23, 23, 23,  2, 23, 23, 23, 23,\n+    2,  2,  2,  2,  2,  2,  2, 23, 23,  2, 23, 23, 23,  2,  2, 23,\n+    2,  2, 23, 23, 23, 23,  2,  2, 23, 23,  2,  2,  2,  2,  2,  2,\n+    2, 23, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  2,\n+   16, 16, 16,  2, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,  2, 16,\n+   16, 16, 16, 16,  2,  2, 16, 16, 16, 16, 16,  2, 16, 16, 16, 16,\n+    2,  2,  2,  2,  2,  2,  2, 16, 16,  2, 16, 16, 16, 16,  2,  2,\n+   16, 16,  2, 16, 16,  2,  2,  2,  2,  2, 20, 20, 20, 20, 20, 20,\n+   20, 20, 20, 20, 20, 20, 20,  2, 20, 20, 20,  2, 20, 20, 20, 20,\n+   20, 20,  2,  2,  2,  2, 20, 20, 20, 20, 20, 20, 20, 20,  2,  2,\n+   20, 20,  2, 36, 36, 36,  2, 36, 36, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 36, 36, 36,  2,  2,  2, 36, 36, 36, 36,\n+   36, 36, 36, 36,  2, 36, 36, 36, 36, 36, 36, 36, 36, 36,  2, 36,\n+    2,  2,  2,  2, 36,  2,  2,  2,  2, 36, 36, 36, 36, 36, 36,  2,\n+   36,  2,  2,  2,  2,  2,  2,  2, 36, 36,  2,  2, 36, 36, 36,  2,\n+    2,  2,  2, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n+   24, 24, 24, 24, 24,  2,  2,  2,  2,  0, 24, 24, 24, 24,  2,  2,\n+    2,  2,  2, 18, 18,  2, 18,  2, 18, 18, 18, 18, 18,  2, 18, 18,\n+   18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,  2, 18,\n+    2, 18, 18, 18, 18, 18, 18, 18,  2,  2, 18, 18, 18, 18, 18,  2,\n+   18,  2, 18, 18,  2,  2, 18, 18, 18, 18, 25, 25, 25, 25, 25, 25,\n+   25, 25,  2, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,  2,\n+    2,  2, 25, 25, 25, 25, 25,  2, 25, 25, 25, 25, 25, 25, 25,  0,\n+    0,  0,  0, 25, 25,  2,  2,  2,  2,  2, 33, 33, 33, 33, 33, 33,\n+   33, 33,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n+    2,  8,  2,  2,  2,  2,  2,  8,  2,  2,  8,  8,  8,  0,  8,  8,\n+    8,  8, 12, 12, 12, 12, 12, 12, 12, 12, 30, 30, 30, 30, 30, 30,\n+   30, 30, 30,  2, 30, 30, 30, 30,  2,  2, 30, 30, 30, 30, 30, 30,\n+   30,  2, 30, 30, 30,  2,  2, 30, 30, 30, 30, 30, 30, 30, 30,  2,\n+    2,  2, 30, 30,  2,  2,  2,  2,  2,  2, 29, 29, 29, 29, 29, 29,\n+   29, 29, 29, 29, 29, 29, 29, 29,  2,  2, 28, 28, 28, 28, 28, 28,\n+   28, 28, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,  2,\n+    2,  2, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35,  0,  0,  0,\n+   35, 35, 35,  2,  2,  2,  2,  2,  2,  2, 45, 45, 45, 45, 45, 45,\n+   45, 45, 45, 45, 45, 45, 45, 45,  2,  2,  2,  2,  2,  2,  2,  2,\n+    2, 45, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44,  0,\n+    0,  2, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,  2,  2,\n+    2,  2, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46,  2,\n+   46, 46, 46,  2, 46, 46,  2,  2,  2,  2, 31, 31, 31, 31, 31, 31,\n+   31, 31, 31, 31, 31, 31, 31, 31,  2,  2, 31, 31,  2,  2,  2,  2,\n+    2,  2, 32, 32,  0,  0, 32,  0, 32, 32, 32, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32,  2,  2,  2,  2,  2,  2, 32,  2,  2,  2,  2,  2,\n+    2,  2, 32, 32, 32,  2,  2,  2,  2,  2, 28, 28, 28, 28, 28, 28,\n+    2,  2, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,\n+   48,  2, 48, 48, 48, 48,  2,  2,  2,  2, 48,  2,  2,  2, 48, 48,\n+   48, 48, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    2,  2, 52, 52, 52, 52, 52,  2,  2,  2, 58, 58, 58, 58, 58, 58,\n+   58, 58, 58, 58, 58, 58,  2,  2,  2,  2, 58, 58,  2,  2,  2,  2,\n+    2,  2, 58, 58, 58,  2,  2,  2, 58, 58, 54, 54, 54, 54, 54, 54,\n+   54, 54, 54, 54, 54, 54,  2,  2, 54, 54, 91, 91, 91, 91, 91, 91,\n+   91, 91, 91, 91, 91, 91, 91, 91, 91,  2, 91, 91, 91, 91, 91,  2,\n+    2, 91, 91, 91,  2,  2,  2,  2,  2,  2, 91, 91, 91, 91, 91, 91,\n+    2,  2,  1,  1,  1,  1,  1,  1,  1,  2, 62, 62, 62, 62, 62, 62,\n+   62, 62, 62, 62, 62, 62, 62,  2,  2,  2, 62, 62, 62, 62, 62, 62,\n+   62,  2, 76, 76, 76, 76, 76, 76, 76, 76, 93, 93, 93, 93, 93, 93,\n+   93, 93, 93, 93, 93, 93,  2,  2,  2,  2,  2,  2,  2,  2, 93, 93,\n+   93, 93, 70, 70, 70, 70, 70, 70, 70, 70,  2,  2,  2, 70, 70, 70,\n+   70, 70, 70, 70,  2,  2,  2, 70, 70, 70, 73, 73, 73, 73, 73, 73,\n+   73, 73,  6,  2,  2,  2,  2,  2,  2,  2,  8,  8,  8,  2,  2,  8,\n+    8,  8,  1,  1,  1,  0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,\n+    1,  1,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  1,  0,\n+    0,  0,  1,  1,  0,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19,\n+    9,  9,  9,  9,  9,  6, 19, 19, 19, 19, 19, 19, 19, 19, 19,  9,\n+    9,  9,  9,  9, 19, 19, 19, 19,  9,  9,  9,  9,  9, 19, 19, 19,\n+   19, 19,  6, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,\n+   19,  9,  9,  9,  9,  9,  9,  9,  2,  2,  2,  9,  2,  9,  2,  9,\n+    2,  9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  9,  9,  9,  2,  2,\n+    9,  9,  9,  9,  9,  9,  2,  9,  9,  9,  2,  2,  9,  9,  9,  2,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  2,  0,  0,  0,  0,  1,  1,\n+    0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0, 19,  2,  2,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0, 19,  0,  0,  0,  0,  0,  0,\n+    0,  2, 19, 19, 19, 19, 19,  2,  2,  2,  0,  2,  2,  2,  2,  2,\n+    2,  2,  1,  2,  2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,\n+    9,  0,  0,  0, 19, 19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   19,  0, 19,  0,  0,  0,  2,  2,  2,  2,  0,  0,  0,  2,  2,  2,\n+    2,  2, 27, 27, 27, 27, 27, 27, 27, 27,  0,  0,  0,  0,  2,  2,\n+    0,  0,  0,  0,  0,  0,  0,  0,  2,  0, 56, 56, 56, 56, 56, 56,\n+   56, 56, 55, 55, 55, 55,  2,  2,  2,  2,  2, 55, 55, 55, 55, 55,\n+   55, 55, 61, 61, 61, 61, 61, 61, 61, 61,  2,  2,  2,  2,  2,  2,\n+    2, 61, 61,  2,  2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,\n+    2,  2, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,  2, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13,  2,  2,  2,  2, 13, 13, 13, 13, 13, 13,\n+    2,  2,  0,  0,  0,  0,  2,  2,  2,  2,  0,  0,  0,  0,  0, 13,\n+    0, 13,  0, 13, 13, 13, 13, 13, 13, 13, 13, 13,  1,  1,  1,  1,\n+   12, 12, 13, 13, 13, 13,  0,  0,  0,  0,  2, 15, 15, 15, 15, 15,\n@@ -4698,193 +4773,203 @@\n-   15, 15, 15, 15, 15,  2,  2,  1,  1,  0,  0, 15, 15, 15,  0, 17,\n-   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n-   17,  0,  0, 17, 17, 17,  2,  2,  2,  2,  2, 26, 26, 26, 26, 26,\n-   26, 26, 26, 26, 26, 26,  2, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n-   12, 12, 12, 12, 12,  2, 12, 12, 12, 12, 12, 12, 12,  0, 17, 17,\n-   17, 17, 17, 17, 17,  0, 13, 13, 13, 13, 13,  2,  2,  2, 39, 39,\n-   39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,  2,  2,  2, 39, 39,\n-   39, 39, 39, 39, 39,  2, 86, 86, 86, 86, 86, 86, 86, 86, 77, 77,\n-   77, 77, 77, 77, 77, 77, 77, 77, 77, 77,  2,  2,  2,  2, 79, 79,\n-   79, 79, 79, 79, 79, 79,  0,  0, 19, 19, 19, 19, 19, 19,  0,  0,\n-    0, 19, 19, 19, 19, 19,  2,  2, 19, 19, 19, 19, 19, 19, 19, 19,\n-   19,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 19, 19, 19, 60, 60,\n-   60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,  2,  2,  2,  0,  0,\n-    2,  2,  2,  2,  2,  2, 65, 65, 65, 65, 65, 65, 65, 65, 75, 75,\n-   75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75,  2,  2,  2,  2,\n-    2,  2,  2,  2, 75, 75, 75, 75,  2,  2,  2,  2,  2,  2, 69, 69,\n-   69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69,  0, 69, 74, 74,\n-   74, 74, 74, 74, 74, 74, 74, 74, 74, 74,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2, 74, 12, 12, 12, 12, 12,  2,  2,  2, 84, 84,\n-   84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84,  2,  0, 84, 84,\n-    2,  2,  2,  2, 84, 84, 33, 33, 33, 33, 33, 33, 33,  2, 68, 68,\n-   68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,  2, 68, 68,\n-   68, 68, 68, 68,  2,  2, 68, 68,  2,  2, 68, 68, 68, 68, 92, 92,\n-   92, 92, 92, 92, 92, 92, 92, 92, 92,  2,  2,  2,  2,  2,  2,  2,\n-    2, 92, 92, 92, 92, 92, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87, 87, 87,  2,  2, 30, 30, 30, 30, 30, 30,  2, 19, 19,\n-   19,  0, 19, 19, 19, 19, 19, 19, 19, 19, 19,  9, 19, 19, 19, 19,\n-    0,  0,  2,  2,  2,  2, 87, 87, 87, 87, 87, 87,  2,  2, 87, 87,\n-    2,  2,  2,  2,  2,  2, 12, 12, 12, 12,  2,  2,  2,  2,  2,  2,\n-    2, 12, 12, 12, 12, 12, 13, 13,  2,  2,  2,  2,  2,  2, 19, 19,\n-   19, 19, 19, 19, 19,  2,  2,  2,  2,  4,  4,  4,  4,  4,  2,  2,\n-    2,  2,  2, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,  2, 14, 14,\n-   14, 14, 14,  2, 14,  2, 14, 14,  2, 14, 14,  2, 14, 14,  3,  3,\n-    2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  0,  0,  2,  2,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  2,  1,  1,\n-    1,  1,  1,  1,  6,  6,  0,  0,  0,  2,  0,  0,  0,  0,  3,  3,\n-    3,  3,  3,  2,  2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 17, 17, 17, 17, 17, 17, 17, 17,  0,  0,  2,  2,\n-   12, 12, 12, 12, 12, 12,  2,  2, 12, 12, 12,  2,  2,  2,  2,  0,\n-    0,  0,  0,  0,  2,  2, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\n-   49, 49,  2, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,  2, 49, 49,\n-   49,  2, 49, 49,  2, 49, 49, 49, 49, 49, 49, 49,  2,  2, 49, 49,\n-   49,  2,  2,  2,  2,  2,  0,  0,  0,  2,  2,  2,  2,  0,  0,  0,\n-    0,  0,  2,  2,  2,  0,  0,  0,  0,  0,  0,  2,  2,  2,  9,  2,\n-    2,  2,  2,  2,  2,  2,  0,  0,  0,  0,  0,  1,  2,  2, 71, 71,\n-   71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71,  2,  2,  2, 67, 67,\n-   67, 67, 67, 67, 67, 67, 67,  2,  2,  2,  2,  2,  2,  2,  1,  0,\n-    0,  0,  0,  0,  0,  0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,\n-   42, 42,  2,  2,  2,  2,  2,  2,  2,  2,  2, 42, 42, 42, 41, 41,\n-   41, 41, 41, 41, 41, 41, 41, 41, 41,  2,  2,  2,  2,  2,118,118,\n-  118,118,118,118,118,118,118,118,118,  2,  2,  2,  2,  2, 53, 53,\n-   53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53,  2, 53, 59, 59,\n-   59, 59, 59, 59, 59, 59, 59, 59, 59, 59,  2,  2,  2,  2, 59, 59,\n-   59, 59, 59, 59,  2,  2, 40, 40, 40, 40, 40, 40, 40, 40, 51, 51,\n-   51, 51, 51, 51, 51, 51, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n-   50, 50, 50, 50,  2,  2, 50, 50,  2,  2,  2,  2,  2,  2,135,135,\n-  135,135,135,135,135,135,135,135,135,135,  2,  2,  2,  2,106,106,\n-  106,106,106,106,106,106,104,104,104,104,104,104,104,104,104,104,\n-  104,104,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,104,110,110,\n-  110,110,110,110,110,110,110,110,110,110,110,110,110,  2,110,110,\n-  110,110,110,110,  2,  2, 47, 47, 47, 47, 47, 47,  2,  2, 47,  2,\n-   47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,\n-   47, 47, 47, 47,  2, 47, 47,  2,  2,  2, 47,  2,  2, 47, 81, 81,\n-   81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81,  2, 81,120,120,\n-  120,120,120,120,120,120,116,116,116,116,116,116,116,116,116,116,\n-  116,116,116,116,116,  2,  2,  2,  2,  2,  2,  2,  2,116,128,128,\n-  128,128,128,128,128,128,128,128,128,  2,128,128,  2,  2,  2,  2,\n-    2,128,128,128,128,128, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66,\n-   66, 66,  2,  2,  2, 66, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72,\n-    2,  2,  2,  2,  2, 72, 98, 98, 98, 98, 98, 98, 98, 98, 97, 97,\n-   97, 97, 97, 97, 97, 97,  2,  2,  2,  2, 97, 97, 97, 97,  2,  2,\n-   97, 97, 97, 97, 97, 97, 57, 57, 57, 57,  2, 57, 57,  2,  2,  2,\n-    2,  2, 57, 57, 57, 57, 57, 57, 57, 57,  2, 57, 57, 57,  2, 57,\n-   57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,\n-   57, 57, 57, 57,  2,  2, 57, 57, 57,  2,  2,  2,  2, 57, 57,  2,\n-    2,  2,  2,  2,  2,  2, 88, 88, 88, 88, 88, 88, 88, 88,117,117,\n-  117,117,117,117,117,117,112,112,112,112,112,112,112,112,112,112,\n-  112,112,112,112,112,  2,  2,  2,  2,112,112,112,112,112, 78, 78,\n-   78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,  2,  2,  2, 78,\n-   78, 78, 78, 78, 78, 78, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83,\n-   83, 83, 83, 83,  2,  2, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82,\n-   82,  2,  2,  2,  2,  2,122,122,122,122,122,122,122,122,122,122,\n-    2,  2,  2,  2,  2,  2,  2,122,122,122,122,  2,  2,  2,  2,122,\n-  122,122,122,122,122,122, 89, 89, 89, 89, 89, 89, 89, 89, 89,  2,\n-    2,  2,  2,  2,  2,  2,130,130,130,130,130,130,130,130,130,130,\n-  130,  2,  2,  2,  2,  2,  2,  2,130,130,130,130,130,130,144,144,\n-  144,144,144,144,144,144,144,144,  2,  2,  2,  2,  2,  2,  3,  3,\n-    3,  3,  3,  3,  3,  2,156,156,156,156,156,156,156,156,156,156,\n-    2,156,156,156,  2,  2,156,156,  2,  2,  2,  2,  2,  2,147,147,\n-  147,147,147,147,147,147,148,148,148,148,148,148,148,148,148,148,\n-    2,  2,  2,  2,  2,  2,153,153,153,153,153,153,153,153,153,153,\n-  153,153,  2,  2,  2,  2,149,149,149,149,149,149,149,149,149,149,\n-  149,149,149,149,149,  2, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,\n-   94, 94, 94, 94,  2,  2,  2,  2, 94, 94, 94, 94, 94, 94,  2,  2,\n-    2,  2,  2,  2,  2, 94, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 85,  2,  2,101,101,\n-  101,101,101,101,101,101,101,  2,  2,  2,  2,  2,  2,  2,101,101,\n-    2,  2,  2,  2,  2,  2, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n-   96, 96, 96,  2, 96, 96,111,111,111,111,111,111,111,111,111,111,\n-  111,111,111,111,111,  2,100,100,100,100,100,100,100,100,  2, 36,\n-   36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,  2,  2,  2,108,108,\n-  108,108,108,108,108,108,108,108,  2,108,108,108,108,108,108,108,\n-  108,108,108,108,108,  2,129,129,129,129,129,129,129,  2,129,  2,\n-  129,129,129,129,  2,129,129,129,129,129,129,129,129,129,129,129,\n-  129,129,129,129,  2,129,129,129,  2,  2,  2,  2,  2,  2,109,109,\n-  109,109,109,109,109,109,109,109,109,  2,  2,  2,  2,  2,109,109,\n-    2,  2,  2,  2,  2,  2,107,107,107,107,  2,107,107,107,107,107,\n-  107,107,107,  2,  2,107,107,  2,  2,107,107,107,107,107,107,107,\n-  107,107,107,107,107,107,107,  2,107,107,107,107,107,107,107,  2,\n-  107,107,  2,107,107,107,107,107,  2,  1,107,107,107,107,107,  2,\n-    2,107,107,107,  2,  2,107,  2,  2,  2,  2,  2,  2,107,  2,  2,\n-    2,  2,  2,107,107,107,107,107,107,107,  2,  2,107,107,107,107,\n-  107,107,107,  2,  2,  2,137,137,137,137,137,137,137,137,137,137,\n-  137,137,  2,137,137,137,137,137,  2,  2,  2,  2,  2,  2,124,124,\n-  124,124,124,124,124,124,124,124,  2,  2,  2,  2,  2,  2,123,123,\n-  123,123,123,123,123,123,123,123,123,123,123,123,  2,  2,114,114,\n-  114,114,114,114,114,114,114,114,114,114,114,  2,  2,  2,114,114,\n-    2,  2,  2,  2,  2,  2, 32, 32, 32, 32, 32,  2,  2,  2,102,102,\n-  102,102,102,102,102,102,102,  2,  2,  2,  2,  2,  2,  2,102,102,\n-    2,  2,  2,  2,  2,  2,126,126,126,126,126,126,126,126,126,126,\n-  126,  2,  2,126,126,126,126,126,126,126,  2,  2,  2,  2,142,142,\n-  142,142,142,142,142,142,142,142,142,142,  2,  2,  2,  2,125,125,\n-  125,125,125,125,125,125,125,125,125,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2,125,154,154,154,154,154,154,154,  2,  2,154,\n-    2,  2,154,154,154,154,154,154,154,154,  2,154,154,  2,154,154,\n-  154,154,154,154,154,154,154,154,154,154,154,154,  2,154,154,  2,\n-    2,154,154,154,154,154,154,154,  2,  2,  2,  2,  2,  2,150,150,\n-  150,150,150,150,150,150,  2,  2,150,150,150,150,150,150,150,150,\n-  150,150,150,  2,  2,  2,141,141,141,141,141,141,141,141,140,140,\n-  140,140,140,140,140,140,140,140,140,  2,  2,  2,  2,  2,121,121,\n-  121,121,121,121,121,121,121,  2,  2,  2,  2,  2,  2,  2,133,133,\n-  133,133,133,133,133,133,133,  2,133,133,133,133,133,133,133,133,\n-  133,133,133,133,133,  2,133,133,133,133,133,133,  2,  2,133,133,\n-  133,133,133,  2,  2,  2,134,134,134,134,134,134,134,134,  2,  2,\n-  134,134,134,134,134,134,  2,134,134,134,134,134,134,134,134,134,\n-  134,134,134,134,134,  2,138,138,138,138,138,138,138,  2,138,138,\n-    2,138,138,138,138,138,138,138,138,138,138,138,138,138,  2,  2,\n-  138,  2,138,138,  2,138,138,138,  2,  2,  2,  2,  2,  2,143,143,\n-  143,143,143,143,  2,143,143,  2,143,143,143,143,143,143,143,143,\n-  143,143,143,143,143,143,143,143,143,143,143,143,143,  2,143,143,\n-    2,143,143,143,143,143,143,  2,  2,  2,  2,  2,  2,  2,143,143,\n-    2,  2,  2,  2,  2,  2,145,145,145,145,145,145,145,145,145,  2,\n-    2,  2,  2,  2,  2,  2, 86,  2,  2,  2,  2,  2,  2,  2, 22, 22,\n-    2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 22, 63, 63,\n-   63, 63, 63, 63, 63, 63, 63, 63,  2,  2,  2,  2,  2,  2, 63, 63,\n-   63, 63, 63, 63, 63,  2, 63, 63, 63, 63, 63,  2,  2,  2, 63, 63,\n-   63, 63,  2,  2,  2,  2, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80,\n-   80, 80, 80, 80, 80,  2, 80,  2,  2,  2,  2,  2,  2,  2,127,127,\n-  127,127,127,127,127,127,127,127,127,127,127,127,127,  2, 79,  2,\n-    2,  2,  2,  2,  2,  2,115,115,115,115,115,115,115,115,115,115,\n-  115,115,115,115,115,  2,115,115,  2,  2,  2,  2,115,115,103,103,\n-  103,103,103,103,103,103,103,103,103,103,103,103,  2,  2,119,119,\n-  119,119,119,119,119,119,119,119,119,119,119,119,  2,  2,119,119,\n-    2,119,119,119,119,119,  2,  2,  2,  2,  2,119,119,119,146,146,\n-  146,146,146,146,146,146,146,146,146,  2,  2,  2,  2,  2, 99, 99,\n-   99, 99, 99, 99, 99, 99, 99, 99, 99,  2,  2,  2,  2, 99,  2,  2,\n-    2,  2,  2,  2,  2, 99,136,139,  0,  0,155,  2,  2,  2,136,136,\n-  136,136,136,136,136,136,155,155,155,155,155,155,155,155,155,155,\n-  155,155,155,155,  2,  2,136,  2,  2,  2,  2,  2,  2,  2, 17, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2, 17, 17, 17, 17,139,139,139,139,139,139,139,139,139,139,\n-  139,139,  2,  2,  2,  2,105,105,105,105,105,105,105,105,105,105,\n-  105,  2,  2,  2,  2,  2,105,105,105,105,105,  2,  2,  2,105,  2,\n-    2,  2,  2,  2,  2,  2,105,105,  2,  2,105,105,105,105,  0,  0,\n-    0,  0,  0,  0,  2,  2,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,\n-    1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,\n-    1,  1,  1,  1,  0,  0,  0,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n-    0,  2,  2,  0,  0,  2,  2,  0,  0,  0,  0,  2,  0,  0,  0,  0,\n-    2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  0,\n-    0,  2,  2,  0,  0,  0,  0,  0,  2,  0,  0,  0,  0,  2,  0,  0,\n-    0,  0,  0,  2,  0,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  2,\n-    0,  0,  0,  0,  0,  0,131,131,131,131,131,131,131,131,131,131,\n-  131,131,  2,  2,  2,  2,  2,  2,  2,131,131,131,131,131,  2,131,\n-  131,131,131,131,131,131, 56,  2,  2, 56, 56, 56, 56, 56, 56, 56,\n-    2, 56, 56,  2, 56, 56, 56, 56, 56,  2,  2,  2,  2,  2,151,151,\n-  151,151,151,151,151,151,151,151,151,151,151,  2,  2,  2,151,151,\n-  151,151,151,151,  2,  2,151,151,  2,  2,  2,  2,151,151,152,152,\n-  152,152,152,152,152,152,152,152,  2,  2,  2,  2,  2,152,113,113,\n-  113,113,113,113,113,113,113,113,113,113,113,  2,  2,113,113,113,\n-  113,113,113,113,113,  2,132,132,132,132,132,132,132,132,132,132,\n-  132,132,  2,  2,  2,  2,132,132,  2,  2,  2,  2,132,132,  3,  3,\n-    3,  3,  2,  3,  3,  3,  2,  3,  3,  2,  3,  2,  2,  3,  2,  3,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,  2,  3,\n-    2,  3,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,  2,  3,  2,  3,\n-    2,  3,  2,  3,  3,  3,  2,  3,  2,  3,  2,  3,  2,  3,  2,  3,\n-    3,  3,  3,  2,  3,  2,  3,  3,  2,  3,  3,  3,  3,  3,  3,  3,\n-    3,  3,  2,  2,  2,  2,  2,  3,  3,  3,  2,  3,  3,  3,  2,  2,\n-    2,  2,  2,  2,  0,  0, 15,  0,  0,  2,  2,  2,  2,  2, 13,  2,\n-    2,  2,  2,  2,  2,  2, 13, 13, 13,  2,  2,  2,  2,  2,  2,  0,\n-    2,  2,  2,  2,  2,  2,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n-    9,  9,  9, 10,  9, 11, 12, 13,  9,  9,  9, 14,  9,  9, 15,  9,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   15,  2,  2,  1,  1,  0,  0, 15, 15, 15,  0, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,  0,  0, 17,\n+   17, 17,  2,  2,  2,  2,  2, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n+   26, 26,  2, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n+   12,  2, 12, 12, 12, 12, 12, 12, 12,  0, 17, 17, 17, 17, 17, 17,\n+   17,  0, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,  2,\n+    2,  2, 39, 39, 39, 39, 39, 39, 39,  2, 86, 86, 86, 86, 86, 86,\n+   86, 86, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,  2,  2,\n+    2,  2, 79, 79, 79, 79, 79, 79, 79, 79,  0,  0, 19, 19, 19, 19,\n+   19, 19,  0,  0,  0, 19, 19, 19, 19, 19, 19, 19, 19,  2,  2,  2,\n+    2,  2, 19, 19,  2, 19,  2, 19, 19, 19, 19, 19,  2,  2,  2,  2,\n+    2,  2,  2,  2, 19, 19, 19, 19, 19, 19, 60, 60, 60, 60, 60, 60,\n+   60, 60, 60, 60, 60, 60, 60,  2,  2,  2,  0,  0,  2,  2,  2,  2,\n+    2,  2, 65, 65, 65, 65, 65, 65, 65, 65, 75, 75, 75, 75, 75, 75,\n+   75, 75, 75, 75, 75, 75, 75, 75,  2,  2,  2,  2,  2,  2,  2,  2,\n+   75, 75, 75, 75,  2,  2,  2,  2,  2,  2, 69, 69, 69, 69, 69, 69,\n+   69, 69, 69, 69, 69, 69, 69, 69,  0, 69, 74, 74, 74, 74, 74, 74,\n+   74, 74, 74, 74, 74, 74,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+    2, 74, 12, 12, 12, 12, 12,  2,  2,  2, 84, 84, 84, 84, 84, 84,\n+   84, 84, 84, 84, 84, 84, 84, 84,  2,  0, 84, 84,  2,  2,  2,  2,\n+   84, 84, 33, 33, 33, 33, 33, 33, 33,  2, 68, 68, 68, 68, 68, 68,\n+   68, 68, 68, 68, 68, 68, 68, 68, 68,  2, 68, 68, 68, 68, 68, 68,\n+    2,  2, 68, 68,  2,  2, 68, 68, 68, 68, 92, 92, 92, 92, 92, 92,\n+   92, 92, 92, 92, 92,  2,  2,  2,  2,  2,  2,  2,  2, 92, 92, 92,\n+   92, 92, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+   87,  2,  2, 30, 30, 30, 30, 30, 30,  2, 19, 19, 19,  0, 19, 19,\n+   19, 19, 19, 19, 19, 19, 19,  9, 19, 19, 19, 19,  0,  0,  2,  2,\n+    2,  2, 87, 87, 87, 87, 87, 87,  2,  2, 87, 87,  2,  2,  2,  2,\n+    2,  2, 12, 12, 12, 12,  2,  2,  2,  2,  2,  2,  2, 12, 12, 12,\n+   12, 12, 13, 13,  2,  2,  2,  2,  2,  2, 19, 19, 19, 19, 19, 19,\n+   19,  2,  2,  2,  2,  4,  4,  4,  4,  4,  2,  2,  2,  2,  2, 14,\n+   14, 14, 14, 14, 14, 14, 14, 14, 14,  2, 14, 14, 14, 14, 14,  2,\n+   14,  2, 14, 14,  2, 14, 14,  2, 14, 14,  3,  3,  3,  2,  2,  2,\n+    2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,\n+    0,  0,  2,  2,  3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,\n+    2,  3,  1,  1,  1,  1,  1,  1,  6,  6,  0,  0,  0,  2,  0,  0,\n+    0,  0,  3,  3,  3,  3,  3,  2,  3,  3,  3,  3,  3,  3,  3,  2,\n+    2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   17, 17, 17, 17, 17, 17, 17, 17,  0,  0,  2,  2, 12, 12, 12, 12,\n+   12, 12,  2,  2, 12, 12, 12,  2,  2,  2,  2,  0,  0,  0,  0,  0,\n+    2,  2, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,  2, 49,\n+   49, 49, 49, 49, 49, 49, 49, 49, 49,  2, 49, 49, 49,  2, 49, 49,\n+    2, 49, 49, 49, 49, 49, 49, 49,  2,  2, 49, 49, 49,  2,  2,  2,\n+    2,  2,  0,  0,  0,  2,  2,  2,  2,  0,  0,  0,  0,  0,  2,  2,\n+    2,  0,  0,  0,  0,  0,  0,  2,  2,  2,  9,  2,  2,  2,  2,  2,\n+    2,  2,  0,  0,  0,  0,  0,  1,  2,  2, 71, 71, 71, 71, 71, 71,\n+   71, 71, 71, 71, 71, 71, 71,  2,  2,  2, 67, 67, 67, 67, 67, 67,\n+   67, 67, 67,  2,  2,  2,  2,  2,  2,  2,  1,  0,  0,  0,  0,  0,\n+    0,  0, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42,  2,  2,\n+    2,  2,  2,  2,  2,  2,  2, 42, 42, 42, 41, 41, 41, 41, 41, 41,\n+   41, 41, 41, 41, 41,  2,  2,  2,  2,  2,118,118,118,118,118,118,\n+  118,118,118,118,118,  2,  2,  2,  2,  2, 53, 53, 53, 53, 53, 53,\n+   53, 53, 53, 53, 53, 53, 53, 53,  2, 53, 59, 59, 59, 59, 59, 59,\n+   59, 59, 59, 59, 59, 59,  2,  2,  2,  2, 59, 59, 59, 59, 59, 59,\n+    2,  2, 40, 40, 40, 40, 40, 40, 40, 40, 51, 51, 51, 51, 51, 51,\n+   51, 51, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,\n+    2,  2, 50, 50,  2,  2,  2,  2,  2,  2,135,135,135,135,135,135,\n+  135,135,135,135,135,135,  2,  2,  2,  2,106,106,106,106,106,106,\n+  106,106,104,104,104,104,104,104,104,104,104,104,104,104,  2,  2,\n+    2,  2,  2,  2,  2,  2,  2,  2,  2,104,161,161,161,161,161,161,\n+  161,161,161,161,161,  2,161,161,161,161,161,161,161,  2,161,161,\n+    2,161,161,161,  2,161,161,161,161,161,161,161,  2,161,161,  2,\n+    2,  2,110,110,110,110,110,110,110,110,110,110,110,110,110,110,\n+  110,  2,110,110,110,110,110,110,  2,  2, 19, 19, 19, 19, 19, 19,\n+    2, 19, 19,  2, 19, 19, 19, 19, 19, 19, 47, 47, 47, 47, 47, 47,\n+    2,  2, 47,  2, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,\n+   47, 47, 47, 47, 47, 47, 47, 47,  2, 47, 47,  2,  2,  2, 47,  2,\n+    2, 47, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81,\n+    2, 81,120,120,120,120,120,120,120,120,116,116,116,116,116,116,\n+  116,116,116,116,116,116,116,116,116,  2,  2,  2,  2,  2,  2,  2,\n+    2,116,128,128,128,128,128,128,128,128,128,128,128,  2,128,128,\n+    2,  2,  2,  2,  2,128,128,128,128,128, 66, 66, 66, 66, 66, 66,\n+   66, 66, 66, 66, 66, 66,  2,  2,  2, 66, 72, 72, 72, 72, 72, 72,\n+   72, 72, 72, 72,  2,  2,  2,  2,  2, 72, 98, 98, 98, 98, 98, 98,\n+   98, 98, 97, 97, 97, 97, 97, 97, 97, 97,  2,  2,  2,  2, 97, 97,\n+   97, 97,  2,  2, 97, 97, 97, 97, 97, 97, 57, 57, 57, 57,  2, 57,\n+   57,  2,  2,  2,  2,  2, 57, 57, 57, 57, 57, 57, 57, 57,  2, 57,\n+   57, 57,  2, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,\n+   57, 57, 57, 57, 57, 57, 57, 57,  2,  2, 57, 57, 57,  2,  2,  2,\n+    2, 57, 57,  2,  2,  2,  2,  2,  2,  2, 88, 88, 88, 88, 88, 88,\n+   88, 88,117,117,117,117,117,117,117,117,112,112,112,112,112,112,\n+  112,112,112,112,112,112,112,112,112,  2,  2,  2,  2,112,112,112,\n+  112,112, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,\n+    2,  2,  2, 78, 78, 78, 78, 78, 78, 78, 83, 83, 83, 83, 83, 83,\n+   83, 83, 83, 83, 83, 83, 83, 83,  2,  2, 82, 82, 82, 82, 82, 82,\n+   82, 82, 82, 82, 82,  2,  2,  2,  2,  2,122,122,122,122,122,122,\n+  122,122,122,122,  2,  2,  2,  2,  2,  2,  2,122,122,122,122,  2,\n+    2,  2,  2,122,122,122,122,122,122,122, 89, 89, 89, 89, 89, 89,\n+   89, 89, 89,  2,  2,  2,  2,  2,  2,  2,130,130,130,130,130,130,\n+  130,130,130,130,130,  2,  2,  2,  2,  2,  2,  2,130,130,130,130,\n+  130,130,144,144,144,144,144,144,144,144,144,144,  2,  2,  2,  2,\n+    2,  2,156,156,156,156,156,156,156,156,156,156,  2,156,156,156,\n+    2,  2,156,156,  2,  2,  2,  2,  2,  2,147,147,147,147,147,147,\n+  147,147,148,148,148,148,148,148,148,148,148,148,  2,  2,  2,  2,\n+    2,  2,158,158,158,158,158,158,158,158,158,158,  2,  2,  2,  2,\n+    2,  2,153,153,153,153,153,153,153,153,153,153,153,153,  2,  2,\n+    2,  2,149,149,149,149,149,149,149,149,149,149,149,149,149,149,\n+  149,  2, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,\n+    2,  2,  2,  2, 94, 94, 94, 94, 94, 94,  2,  2,  2,  2,  2,  2,\n+    2, 94, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  2, 85,  2,  2,101,101,101,101,101,101,\n+  101,101,101,  2,  2,  2,  2,  2,  2,  2,101,101,  2,  2,  2,  2,\n+    2,  2, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  2,\n+   96, 96,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n+  111,  2,100,100,100,100,100,100,100,100,  2, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 36,  2,  2,  2,108,108,108,108,108,108,\n+  108,108,108,108,  2,108,108,108,108,108,108,108,108,108,108,108,\n+  108,  2,129,129,129,129,129,129,129,  2,129,  2,129,129,129,129,\n+    2,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,\n+    2,129,129,129,  2,  2,  2,  2,  2,  2,109,109,109,109,109,109,\n+  109,109,109,109,109,  2,  2,  2,  2,  2,109,109,  2,  2,  2,  2,\n+    2,  2,107,107,107,107,  2,107,107,107,107,107,107,107,107,  2,\n+    2,107,107,  2,  2,107,107,107,107,107,107,107,107,107,107,107,\n+  107,107,107,  2,107,107,107,107,107,107,107,  2,107,107,  2,107,\n+  107,107,107,107,  2,  1,107,107,107,107,107,  2,  2,107,107,107,\n+    2,  2,107,  2,  2,  2,  2,  2,  2,107,  2,  2,  2,  2,  2,107,\n+  107,107,107,107,107,107,  2,  2,107,107,107,107,107,107,107,  2,\n+    2,  2,137,137,137,137,137,137,137,137,137,137,137,137,  2,137,\n+  137,137,137,137,  2,  2,  2,  2,  2,  2,124,124,124,124,124,124,\n+  124,124,124,124,  2,  2,  2,  2,  2,  2,123,123,123,123,123,123,\n+  123,123,123,123,123,123,123,123,  2,  2,114,114,114,114,114,114,\n+  114,114,114,114,114,114,114,  2,  2,  2,114,114,  2,  2,  2,  2,\n+    2,  2, 32, 32, 32, 32, 32,  2,  2,  2,102,102,102,102,102,102,\n+  102,102,102,102,  2,  2,  2,  2,  2,  2,126,126,126,126,126,126,\n+  126,126,126,126,126,  2,  2,126,126,126,126,126,126,126,  2,  2,\n+    2,  2,126,126,126,126,126,126,126,  2,142,142,142,142,142,142,\n+  142,142,142,142,142,142,  2,  2,  2,  2,125,125,125,125,125,125,\n+  125,125,125,125,125,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,\n+    2,125,154,154,154,154,154,154,154,  2,  2,154,  2,  2,154,154,\n+  154,154,154,154,154,154,  2,154,154,  2,154,154,154,154,154,154,\n+  154,154,154,154,154,154,154,154,  2,154,154,  2,  2,154,154,154,\n+  154,154,154,154,  2,  2,  2,  2,  2,  2,150,150,150,150,150,150,\n+  150,150,  2,  2,150,150,150,150,150,150,150,150,150,150,150,  2,\n+    2,  2,141,141,141,141,141,141,141,141,140,140,140,140,140,140,\n+  140,140,140,140,140,  2,  2,  2,  2,  2,121,121,121,121,121,121,\n+  121,121,121,  2,  2,  2,  2,  2,  2,  2,133,133,133,133,133,133,\n+  133,133,133,  2,133,133,133,133,133,133,133,133,133,133,133,133,\n+  133,  2,133,133,133,133,133,133,  2,  2,133,133,133,133,133,  2,\n+    2,  2,134,134,134,134,134,134,134,134,  2,  2,134,134,134,134,\n+  134,134,  2,134,134,134,134,134,134,134,134,134,134,134,134,134,\n+  134,  2,138,138,138,138,138,138,138,  2,138,138,  2,138,138,138,\n+  138,138,138,138,138,138,138,138,138,138,  2,  2,138,  2,138,138,\n+    2,138,138,138,  2,  2,  2,  2,  2,  2,143,143,143,143,143,143,\n+    2,143,143,  2,143,143,143,143,143,143,143,143,143,143,143,143,\n+  143,143,143,143,143,143,143,143,143,  2,143,143,  2,143,143,143,\n+  143,143,143,  2,  2,  2,  2,  2,  2,  2,143,143,  2,  2,  2,  2,\n+    2,  2,145,145,145,145,145,145,145,145,145,  2,  2,  2,  2,  2,\n+    2,  2, 86,  2,  2,  2,  2,  2,  2,  2, 22, 22,  2,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  2,  2,  2, 22, 63, 63, 63, 63, 63, 63,\n+   63, 63, 63, 63,  2,  2,  2,  2,  2,  2, 63, 63, 63, 63, 63, 63,\n+   63,  2, 63, 63, 63, 63, 63,  2,  2,  2, 63, 63, 63, 63,  2,  2,\n+    2,  2,157,157,157,157,157,157,157,157,157,157,157,  2,  2,  2,\n+    2,  2, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80,\n+   80,  2, 80,  2,  2,  2,  2,  2,  2,  2,127,127,127,127,127,127,\n+  127,127,127,127,127,127,127,127,127,  2, 79,  2,  2,  2,  2,  2,\n+    2,  2,115,115,115,115,115,115,115,115,115,115,115,115,115,115,\n+  115,  2,115,115,  2,  2,  2,  2,115,115,159,159,159,159,159,159,\n+  159,159,159,159,159,159,159,159,159,  2,159,159,  2,  2,  2,  2,\n+    2,  2,103,103,103,103,103,103,103,103,103,103,103,103,103,103,\n+    2,  2,119,119,119,119,119,119,119,119,119,119,119,119,119,119,\n+    2,  2,119,119,  2,119,119,119,119,119,  2,  2,  2,  2,  2,119,\n+  119,119,146,146,146,146,146,146,146,146,146,146,146,  2,  2,  2,\n+    2,  2, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,  2,  2,  2,\n+    2, 99,  2,  2,  2,  2,  2,  2,  2, 99,136,139, 13, 13,155,  2,\n+    2,  2,136,136,136,136,136,136,136,136,155,155,155,155,155,155,\n+  155,155,155,155,155,155,155,155,  2,  2,136,  2,  2,  2,  2,  2,\n+    2,  2, 17, 17, 17, 17,  2, 17, 17, 17, 17, 17, 17, 17,  2, 17,\n+   17,  2, 17, 15, 15, 15, 15, 15, 15, 15, 17, 17, 17,  2,  2,  2,\n+    2,  2, 15, 15, 15,  2,  2,  2,  2,  2,  2,  2,  2,  2, 17, 17,\n+   17, 17,139,139,139,139,139,139,139,139,139,139,139,139,  2,  2,\n+    2,  2,105,105,105,105,105,105,105,105,105,105,105,  2,  2,  2,\n+    2,  2,105,105,105,105,105,  2,  2,  2,105,  2,  2,  2,  2,  2,\n+    2,  2,105,105,  2,  2,105,105,105,105,  1,  1,  1,  1,  1,  1,\n+    2,  2,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,\n+    1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,\n+    0,  0,  2,  2,  0,  2,  2,  0,  0,  2,  2,  0,  0,  0,  0,  2,\n+    0,  0,  0,  0,  2,  0,  2,  0,  0,  0,  0,  0,  0,  0,  2,  0,\n+    0,  0,  0,  0,  0,  2,  2,  0,  0,  0,  0,  0,  2,  0,  0,  0,\n+    0,  2,  0,  0,  0,  0,  0,  2,  0,  2,  2,  2,  0,  0,  0,  0,\n+    0,  0,  0,  2,  0,  0,  0,  0,  0,  0,131,131,131,131,131,131,\n+  131,131,131,131,131,131,  2,  2,  2,  2,  2,  2,  2,131,131,131,\n+  131,131,  2,131,131,131,131,131,131,131, 56, 56, 56, 56, 56, 56,\n+   56,  2, 56,  2,  2, 56, 56, 56, 56, 56, 56, 56,  2, 56, 56,  2,\n+   56, 56, 56, 56, 56,  2,  2,  2,  2,  2,151,151,151,151,151,151,\n+  151,151,151,151,151,151,151,  2,  2,  2,151,151,151,151,151,151,\n+    2,  2,151,151,  2,  2,  2,  2,151,151,160,160,160,160,160,160,\n+  160,160,160,160,160,160,160,160,160,  2,152,152,152,152,152,152,\n+  152,152,152,152,  2,  2,  2,  2,  2,152, 30, 30, 30, 30,  2, 30,\n+   30,  2,113,113,113,113,113,113,113,113,113,113,113,113,113,  2,\n+    2,113,113,113,113,113,113,113,113,  2,132,132,132,132,132,132,\n+  132,132,132,132,132,132,  2,  2,  2,  2,132,132,  2,  2,  2,  2,\n+  132,132,  3,  3,  3,  3,  2,  3,  3,  3,  2,  3,  3,  2,  3,  2,\n+    2,  3,  2,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  2,  3,  3,\n+    3,  3,  2,  3,  2,  3,  2,  2,  2,  2,  2,  2,  3,  2,  2,  2,\n+    2,  3,  2,  3,  2,  3,  2,  3,  3,  3,  2,  3,  2,  3,  2,  3,\n+    2,  3,  2,  3,  3,  3,  3,  2,  3,  2,  3,  3,  2,  3,  3,  3,\n+    3,  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  3,  3,  3,  2,  3,\n+    3,  3,  2,  2,  2,  2,  2,  2,  0,  0, 15,  0,  0,  2,  2,  2,\n+    2,  2,  2,  2,  2,  2,  2,  0,  0,  0, 13,  2,  2,  2,  2,  2,\n+    2,  2, 13, 13, 13,  2,  2,  2,  2,  2,  2,  0,  2,  2,  2,  2,\n+    2,  2,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  9,  9,  9, 10,\n+    9, 11, 12, 13,  9,  9,  9, 14,  9,  9, 15,  9,  9,  9,  9,  9,\n@@ -4896,2 +4981,2 @@\n-    9,  9, 16, 17,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 18, 19,\n-   20,  9, 21,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 16, 17,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 18, 19, 20,  9, 21,  9,\n@@ -4902,1 +4987,0 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 22,  9,\n@@ -4904,0 +4988,1 @@\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 22,  9,  9,  9,  9,  9,\n@@ -4912,51 +4997,51 @@\n-    9,  9, 23, 24,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,  0,  0, 13, 14,\n-   15, 16, 17, 18, 19, 20, 21, 22,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0, 23,  0,  0, 24, 25, 26, 27, 28,\n-   29, 30,  0,  0, 31, 32,  0, 33,  0, 34,  0, 35,  0,  0,  0,  0,\n-   36, 37, 38, 39,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   41, 42,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 43, 44,  0, 45,  0,  0,  0,  0,  0,  0,\n-   46, 47,  0,  0,  0,  0,  0, 48,  0, 49,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0, 50, 51,  0,  0,  0, 52,  0,  0,\n-   53,  0,  0,  0,  0,  0,  0,  0, 54,  0,  0,  0,  0,  0,  0,  0,\n-   55,  0,  0,  0,  0,  0,  0,  0, 56,  0,  0,  0,  0,  0,  0,  0,\n-    0, 57,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0, 58, 59, 60, 61, 62, 63, 64, 65,\n-    0,  0,  0,  0,  0,  0, 66,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 67, 68,  0, 69, 70,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82,\n-   83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98,\n-   99,100,101,102,103,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,104,  0,  0,  0,  0,  0,  0,105,106,  0,\n-  107,  0,  0,  0,108,  0,109,  0,110,  0,111,112,113,  0,114,  0,\n-    0,  0,115,  0,  0,  0,116,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,117,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,118,119,120,121,  0,122,123,124,\n-  125,126,  0,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,128,129,130,131,132,133,134,135,136,137,138,139,\n-  140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,\n-  156,157,  0,  0,  0,158,159,160,161,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,162,163,  0,\n-    0,  0,  0,  0,  0,  0,164,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,165,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,166,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,167,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,168,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,169,170,  0,  0,  0,  0,171,\n-  172,  0,  0,  0,173,174,175,176,177,178,179,180,181,182,183,184,\n-  185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,\n-  201,202,203,204,205,206,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    1,  2,  3,  4,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 23, 24,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,\n+    5,  6,  7,  8,  9, 10, 11, 12,  0,  0, 13, 14, 15, 16, 17, 18,\n+   19, 20, 21, 22,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0, 23,  0,  0, 24, 25, 26, 27, 28, 29, 30,  0,  0,\n+   31, 32,  0, 33,  0, 34,  0, 35,  0,  0,  0,  0, 36, 37, 38, 39,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 42,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 43, 44,  0, 45,  0,  0,  0,  0,  0,  0, 46, 47,  0,  0,\n+    0,  0,  0, 48,  0, 49,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0, 50, 51,  0,  0,  0, 52,  0,  0, 53,  0,  0,  0,\n+    0,  0,  0,  0, 54,  0,  0,  0,  0,  0,  0,  0, 55,  0,  0,  0,\n+    0,  0,  0,  0, 56,  0,  0,  0,  0,  0,  0,  0,  0, 57,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0, 58, 59, 60, 61, 62, 63, 64, 65,  0,  0,  0,  0,\n+    0,  0, 66,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   67, 68,  0, 69, 70,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\n+   87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,\n+  103,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,104,  0,  0,  0,  0,  0,  0,105,106,  0,107,  0,  0,  0,\n+  108,  0,109,  0,110,  0,111,112,113,  0,114,  0,  0,  0,115,  0,\n+    0,  0,116,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,117,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,118,119,120,121,  0,122,123,124,125,126,  0,127,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n+  144,145,146,147,148,149,150,151,152,153,154,155,156,157,  0,  0,\n+    0,158,159,160,161,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,162,163,  0,  0,  0,  0,  0,\n+    0,  0,164,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,165,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,166,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,167,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,168,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,169,170,  0,  0,  0,  0,171,172,  0,  0,  0,\n+  173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,\n+  189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,\n+  205,206,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,\n@@ -4965,1 +5050,1 @@\n-_hb_ucd_u16[9080] =\n+_hb_ucd_u16[9200] =\n@@ -4975,8 +5060,8 @@\n-    48,  67,  68,  69,  48,  70,  71,  72,  72,  72,  48,  73,  74,  75,  76,  32,\n-    77,  48,  48,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,\n-    91,  84,  85,  92,  93,  94,  95,  96,  97,  98,  85,  99, 100, 101,  89, 102,\n-   103,  84,  85, 104, 105, 106,  89, 107, 108, 109, 110, 111, 112, 113,  95, 114,\n-   115, 116,  85, 117, 118, 119,  89, 120, 121, 116,  85, 122, 123, 124,  89, 125,\n-   126, 116,  48, 127, 128, 129,  89, 130, 131, 132,  48, 133, 134, 135,  95, 136,\n-   137,  48,  48, 138, 139, 140,  72,  72, 141,  48, 142, 143, 144, 145,  72,  72,\n-   146, 147, 148, 149, 150,  48, 151, 152, 153, 154,  32, 155, 156, 157,  72,  72,\n+    48,  67,  68,  69,  48,  70,  71,  48,  72,  73,  48,  48,  74,  32,  75,  32,\n+    76,  48,  48,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,\n+    90,  83,  84,  91,  92,  93,  94,  95,  96,  97,  84,  98,  99, 100,  88, 101,\n+   102,  83,  84, 103, 104, 105,  88, 106, 107, 108, 109, 110, 111, 112,  94, 113,\n+   114, 115,  84, 116, 117, 118,  88, 119, 120, 115,  84, 121, 122, 123,  88, 124,\n+   125, 115,  48, 126, 127, 128,  88, 129, 130, 131,  48, 132, 133, 134,  94, 135,\n+   136,  48,  48, 137, 138, 139, 140, 140, 141,  48, 142, 143, 144, 145, 140, 140,\n+   146, 147, 148, 149, 150,  48, 151, 152, 153, 154,  32, 155, 156, 157, 140, 140,\n@@ -4988,1 +5073,1 @@\n-   184, 185,  48, 186,  48, 187, 184, 188,  48,  48,  48, 189, 190, 191, 192, 193,\n+    48, 184,  48, 185,  48, 186, 187, 188,  48,  48,  48, 189, 190, 191, 192, 193,\n@@ -4991,1 +5076,1 @@\n-    48, 210,  48,  48,  48, 211, 212, 213, 192, 192, 214, 215, 216,  72,  72,  72,\n+    48, 210,  48,  48,  48, 211, 212, 213, 192, 192, 214, 215, 216, 140, 140, 140,\n@@ -4994,269 +5079,194 @@\n-    11,  11, 236,  27,  27,  27, 237, 238,  11, 239,  27,  27,  32,  32,  32, 240,\n-    13,  13,  13,  13,  13,  13,  13,  13,  13, 241,  13,  13,  13,  13,  13,  13,\n-   242, 243, 242, 242, 243, 244, 242, 245, 246, 246, 246, 247, 248, 249, 250, 251,\n-   252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 262,  72, 263, 264, 216,\n-   265, 266, 267, 268, 269, 270, 271, 271, 272, 273, 274, 209, 275, 276, 209, 277,\n-   278, 278, 278, 278, 278, 278, 278, 278, 279, 209, 280, 209, 209, 209, 209, 281,\n-   209, 282, 278, 283, 209, 284, 285, 209, 209, 209, 286,  72, 287,  72, 270, 270,\n-   270, 288, 209, 209, 209, 209, 289, 270, 209, 209, 209, 209, 209, 209, 209, 209,\n-   209, 209, 209, 290, 291, 209, 209, 292, 209, 209, 209, 209, 209, 209, 293, 209,\n-   209, 209, 209, 209, 209, 209, 294, 295, 270, 296, 209, 209, 297, 278, 298, 278,\n-   299, 300, 278, 278, 278, 301, 278, 302, 209, 209, 209, 278, 303, 209, 209, 304,\n-   209, 305, 209, 209, 209, 209, 209, 209,   9,   9, 306,  11,  11, 307, 308, 309,\n-    13,  13,  13,  13,  13,  13, 310, 311,  11,  11, 312,  48,  48,  48, 313, 314,\n-    48, 315, 316, 316, 316, 316,  32,  32, 317, 318, 319, 320, 321, 322,  72,  72,\n-   209, 323, 209, 209, 209, 209, 209, 324, 209, 209, 209, 209, 209, 325,  72, 326,\n-   327, 328, 329, 330, 137,  48,  48,  48,  48, 331, 178,  48,  48,  48,  48, 332,\n-   333,  48,  48, 137,  48,  48,  48,  48, 200, 334,  48,  48, 209, 209, 324,  48,\n-   209, 335, 336, 209, 337, 338, 209, 209, 336, 209, 209, 338, 209, 209, 209, 209,\n-    48,  48,  48,  48, 209, 209, 209, 209,  48,  48,  48,  48,  48,  48,  48, 151,\n-    48, 339,  48,  48,  48,  48,  48,  48, 151, 209, 209, 209, 286,  48,  48, 229,\n-   340,  48, 341,  72,  13,  13, 342, 343,  13, 344,  48,  48,  48,  48, 345, 346,\n-    31, 347, 348, 349,  13,  13,  13, 350, 351, 352, 353, 354, 355,  72,  72, 356,\n-   357,  48, 358, 359,  48,  48,  48, 360, 361,  48,  48, 362, 363, 192,  32, 364,\n-    64,  48, 365,  48, 366, 367,  48, 151,  77,  48,  48, 368, 369, 370, 371, 372,\n-    48,  48, 373, 374, 375, 376,  48, 377,  48,  48,  48, 378, 379, 380, 381, 382,\n-   383, 384, 316,  11,  11, 385, 386,  11,  11,  11,  11,  11,  48,  48, 387, 192,\n-    48,  48, 388,  48, 389,  48,  48, 206, 390, 390, 390, 390, 390, 390, 390, 390,\n-   391, 391, 391, 391, 391, 391, 391, 391,  48,  48,  48,  48,  48,  48, 204,  48,\n-    48,  48,  48,  48,  48, 207,  72,  72, 392, 393, 394, 395, 396,  48,  48,  48,\n-    48,  48,  48, 397, 398, 399,  48,  48,  48,  48,  48, 400,  72,  48,  48,  48,\n-    48, 401,  48,  48,  74,  72,  72, 402,  32, 403,  32, 404, 405, 406, 407,  73,\n-    48,  48,  48,  48,  48,  48,  48, 408, 409,   2,   3,   4,   5, 410, 411, 412,\n-    48, 413,  48, 200, 414, 415, 416, 417, 418,  48, 172, 419, 204, 204,  72,  72,\n-    48,  48,  48,  48,  48,  48,  48,  71, 420, 270, 270, 421, 271, 271, 271, 422,\n-   423, 424, 425,  72,  72, 209, 209, 426,  72,  72,  72,  72,  72,  72,  72,  72,\n-    48, 151,  48,  48,  48, 101, 427, 428,  48,  48, 429,  48, 430,  48,  48, 431,\n-    48, 432,  48,  48, 433, 434,  72,  72,   9,   9, 435,  11,  11,  48,  48,  48,\n-    48, 204, 192,   9,   9, 436,  11, 437,  48,  48,  74,  48,  48,  48, 438,  72,\n-    48,  48,  48, 315,  48, 199,  74,  72, 439,  48,  48, 440,  48, 441,  48, 442,\n-    48, 200, 443,  72,  72,  72,  48, 444,  48, 445,  48, 446,  72,  72,  72,  72,\n-    48,  48,  48, 447, 270, 448, 270, 270, 449, 450,  48, 451, 452, 453,  48, 454,\n-    48, 455,  72,  72, 456,  48, 457, 458,  48,  48,  48, 459,  48, 460,  48, 461,\n-    48, 462, 463,  72,  72,  72,  72,  72,  48,  48,  48,  48, 196,  72,  72,  72,\n-     9,   9,   9, 464,  11,  11,  11, 465,  48,  48, 466, 192,  72,  72,  72,  72,\n-    72,  72,  72,  72,  72,  72, 270, 467,  48,  48, 468, 469,  72,  72,  72,  72,\n-    48, 455, 470,  48,  62, 471,  72,  72,  72,  72,  72,  48, 472,  72,  48, 315,\n-   473,  48,  48, 474, 475, 448, 476, 477, 222,  48,  48, 478, 479,  48, 196, 192,\n-   480,  48, 481, 482, 483,  48,  48, 484, 222,  48,  48, 485, 486, 487, 488, 489,\n-    48,  98, 490, 491,  72,  72,  72,  72, 492, 493, 494,  48,  48, 495, 496, 192,\n-   497,  84,  85, 498, 499, 500, 501, 502,  48,  48,  48, 503, 504, 505, 469,  72,\n-    48,  48,  48, 506, 507, 192,  72,  72,  48,  48, 508, 509, 510, 511,  72,  72,\n-    48,  48,  48, 512, 513, 192, 514,  72,  48,  48, 515, 516, 192,  72,  72,  72,\n-    48, 173, 517, 518,  72,  72,  72,  72,  48,  48, 490, 519,  72,  72,  72,  72,\n-    72,  72,   9,   9,  11,  11, 148, 520, 521, 522,  48, 523, 524, 192,  72,  72,\n-    72,  72, 525,  48,  48, 526, 527,  72, 528,  48,  48, 529, 530, 531,  48,  48,\n-   532, 533, 534,  72,  48,  48,  48, 196,  85,  48, 508, 535, 536, 148, 175, 537,\n-    48, 538, 539, 540,  72,  72,  72,  72, 541,  48,  48, 542, 543, 192, 544,  48,\n-   545, 546, 192,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  72,  48, 547,\n-    72,  72,  72, 101, 270, 548, 549, 550,  48, 207,  72,  72,  72,  72,  72,  72,\n-   271, 271, 271, 271, 271, 271, 551, 552,  48,  48,  48,  48, 388,  72,  72,  72,\n-    48,  48, 200, 553,  72,  72,  72,  72,  48,  48,  48,  48, 315,  72,  72,  72,\n-    48,  48,  48, 196,  48, 200, 370,  72,  72,  72,  72,  72,  72,  48, 204, 554,\n-    48,  48,  48, 555, 556, 557, 558, 559,  48,  72,  72,  72,  72,  72,  72,  72,\n-    72,  72,  72,  72,   9,   9,  11,  11, 270, 560,  72,  72,  72,  72,  72,  72,\n-    48,  48,  48,  48, 561, 562, 563, 563, 564, 565,  72,  72,  72,  72, 566, 567,\n-    48,  48,  48,  48,  48,  48,  48,  74,  48,  48,  48,  48,  48, 199,  72,  72,\n-   196,  72,  72,  72,  72,  72,  72,  72,  48, 200,  72,  72,  72, 568, 569,  48,\n-    48,  48,  48,  48,  48,  48,  48, 206,  48,  48,  48,  48,  48,  48,  71, 151,\n-   196, 570, 571,  72,  72,  72,  72,  72, 209, 209, 209, 209, 209, 209, 209, 325,\n-   209, 209, 572, 209, 209, 209, 573, 574, 575, 209, 576, 209, 209, 209, 577,  72,\n-   209, 209, 209, 209, 578,  72,  72,  72,  72,  72,  72,  72,  72,  72, 270, 579,\n-   209, 209, 209, 209, 209, 286, 270, 452,   9, 580,  11, 581, 582, 583, 242,   9,\n-   584, 585, 586, 587, 588,   9, 580,  11, 589, 590,  11, 591, 592, 593, 594,   9,\n-   595,  11,   9, 580,  11, 581, 582,  11, 242,   9, 584, 594,   9, 595,  11,   9,\n-   580,  11, 596,   9, 597, 598, 599, 600,  11, 601,   9, 602, 603, 604, 605,  11,\n-   606,   9, 607,  11, 608, 609, 609, 609,  32,  32,  32, 610,  32,  32, 611, 612,\n-   613, 614,  45,  72,  72,  72,  72,  72, 615, 616, 617,  72,  72,  72,  72,  72,\n-    48,  48, 151, 618, 619,  72,  72,  72,  72,  72,  72,  72,  48,  48, 620, 621,\n-    48,  48,  48,  48, 622, 623,  72,  72,   9,   9, 584,  11, 624, 370,  72,  72,\n-    72,  72,  72,  72,  72,  72,  72, 488, 270, 270, 625, 626,  72,  72,  72,  72,\n-   488, 270, 627, 628,  72,  72,  72,  72, 629,  48, 630, 631, 632, 633, 634, 635,\n-   636, 206, 637, 206,  72,  72,  72, 638, 209, 209, 326, 209, 209, 209, 209, 209,\n-   209, 324, 335, 639, 639, 639, 209, 325, 640, 209, 209, 209, 209, 209, 209, 209,\n-   209, 209, 641,  72,  72,  72, 642, 209, 643, 209, 209, 326, 577, 644, 325,  72,\n-   209, 209, 209, 209, 209, 209, 209, 645, 209, 209, 209, 209, 209, 646, 424, 424,\n-   209, 209, 209, 209, 209, 209, 209, 324, 209, 209, 209, 209, 209, 577, 326,  72,\n-   326, 209, 209, 209, 646, 176, 209, 209, 646, 209, 641, 644,  72,  72,  72,  72,\n-   209, 209, 209, 209, 209, 209, 209, 647, 209, 209, 209, 209, 648, 209, 209, 209,\n-   209, 209, 209, 209, 209, 324, 641, 649, 286, 209, 577, 286, 643, 286,  72,  72,\n-   209, 650, 209, 209, 287,  72,  72, 192,  48,  48,  48,  48,  48, 204,  72,  72,\n-    48,  48,  48, 205,  48,  48,  48,  48,  48, 204,  48,  48,  48,  48,  48,  48,\n-    48,  48, 469,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48,  48, 101,  72,\n-    48, 204,  72,  72,  72,  72,  72,  72,  48,  48,  48,  48,  71,  72,  72,  72,\n-   651,  72, 652, 652, 652, 652, 652, 652,  32,  32,  32,  32,  32,  32,  32,  32,\n-    32,  32,  32,  32,  32,  32,  32,  72, 391, 391, 391, 391, 391, 391, 391, 653,\n-   391, 391, 391, 391, 391, 391, 391, 654,   0,   0,   0,   0,   0,   0,   0,   0,\n-     1,   2,   2,   3,   1,   2,   2,   3,   0,   0,   0,   0,   0,   4,   0,   4,\n-     2,   2,   5,   2,   2,   2,   5,   2,   2,   2,   2,   2,   2,   2,   2,   2,\n-     2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   6,\n-     0,   0,   0,   0,   7,   8,   0,   0,   9,   9,   9,   9,   9,   9,   9,   9,\n-     9,   9,   9,   9,   9,   9,  10,  11,  12,  13,  14,  14,  15,  14,  14,  14,\n-    14,  14,  14,  14,  16,  17,  14,  14,  18,  18,  18,  18,  18,  18,  18,  18,\n-    18,  18,  18,  18,  18,  18,  18,  18,  19,  18,  18,  18,  18,  18,  18,  18,\n-    18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  20,  21,\n-    21,  21,  22,  20,  21,  21,  21,  21,  21,  23,  24,  25,  25,  25,  25,  25,\n-    25,  26,  25,  25,  25,  27,  28,  26,  29,  30,  31,  32,  31,  31,  31,  31,\n-    33,  34,  35,  31,  31,  31,  36,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n-    31,  31,  31,  29,  31,  31,  31,  31,  37,  38,  37,  37,  37,  37,  37,  37,\n-    37,  39,  31,  31,  31,  31,  31,  31,  40,  40,  40,  40,  40,  40,  41,  26,\n-    42,  42,  42,  42,  42,  42,  42,  43,  44,  44,  44,  44,  44,  45,  44,  46,\n-    47,  47,  47,  48,  37,  49,  26,  26,  26,  26,  26,  26,  31,  31,  50,  31,\n-    31,  26,  51,  31,  52,  31,  31,  31,  53,  53,  53,  53,  53,  53,  53,  53,\n-    53,  53,  54,  53,  55,  53,  53,  53,  56,  57,  58,  59,  59,  60,  61,  62,\n-    57,  63,  64,  65,  66,  59,  59,  67,  68,  69,  70,  71,  71,  72,  73,  74,\n-    69,  75,  76,  77,  78,  71,  79,  26,  80,  81,  82,  83,  83,  84,  85,  86,\n-    81,  87,  88,  26,  89,  83,  90,  91,  92,  93,  94,  95,  95,  96,  97,  98,\n-    93,  99, 100, 101, 102,  95,  95,  26, 103, 104, 105, 106, 107, 104, 108, 109,\n-   104, 105, 110,  26, 111, 108, 108, 112, 113, 114, 115, 113, 113, 115, 113, 116,\n-   114, 117, 118, 119, 120, 113, 121, 113, 122, 123, 124, 122, 122, 124, 125, 126,\n-   123, 127, 128, 129, 130, 122, 131,  26, 132, 133, 134, 132, 132, 132, 132, 132,\n-   133, 134, 135, 132, 136, 132, 132, 132, 137, 138, 139, 140, 138, 138, 141, 142,\n-   139, 143, 144, 138, 145, 138, 146,  26, 147, 148, 148, 148, 148, 148, 148, 149,\n-   148, 148, 148, 150,  26,  26,  26,  26, 151, 152, 153, 153, 154, 153, 153, 155,\n-   156, 155, 153, 157,  26,  26,  26,  26, 158, 158, 158, 158, 158, 158, 158, 158,\n-   158, 159, 158, 158, 158, 160, 159, 158, 158, 158, 158, 159, 158, 158, 158, 161,\n-   158, 161, 162, 163,  26,  26,  26,  26, 164, 164, 164, 164, 164, 164, 164, 164,\n-   164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 164, 165, 165, 165, 165,\n-   166, 167, 165, 165, 165, 165, 165, 168, 169, 169, 169, 169, 169, 169, 169, 169,\n-   169, 169, 169, 169, 169, 169, 169, 169, 170, 170, 170, 170, 170, 170, 170, 170,\n-   170, 171, 172, 171, 170, 170, 170, 170, 170, 171, 170, 170, 170, 170, 171, 172,\n-   171, 170, 172, 170, 170, 170, 170, 170, 170, 170, 171, 170, 170, 170, 170, 170,\n-   170, 170, 170, 173, 170, 170, 170, 174, 170, 170, 170, 175, 176, 176, 176, 176,\n-   176, 176, 176, 176, 176, 176, 177, 177, 178, 178, 178, 178, 178, 178, 178, 178,\n-   178, 178, 178, 178, 178, 178, 178, 178, 179, 179, 179, 180, 181, 181, 181, 181,\n-   181, 181, 181, 181, 181, 182, 181, 183, 184, 185, 186,  26, 187, 187, 188,  26,\n-   189, 189, 190,  26, 191, 192, 193,  26, 194, 194, 194, 194, 194, 194, 194, 194,\n-   194, 194, 194, 195, 194, 196, 194, 196, 197, 198, 199, 200, 199, 199, 199, 199,\n-   199, 199, 199, 199, 199, 199, 199, 201, 199, 199, 199, 199, 199, 202, 178, 178,\n-   178, 178, 178, 178, 178, 178, 203,  26, 204, 204, 204, 205, 204, 206, 204, 206,\n-   207, 204, 208, 208, 208, 209, 210,  26, 211, 211, 211, 211, 211, 212, 211, 211,\n-   211, 213, 211, 214, 194, 194, 194, 194, 215, 215, 215, 216, 217, 217, 217, 217,\n-   217, 217, 217, 218, 217, 217, 217, 219, 217, 220, 217, 220, 217, 221,   9,   9,\n-   222,  26,  26,  26,  26,  26,  26,  26, 223, 223, 223, 223, 223, 223, 223, 223,\n-   223, 224, 223, 223, 223, 223, 223, 225, 226, 226, 226, 226, 226, 226, 226, 226,\n-   227, 227, 227, 227, 227, 227, 228, 229, 230, 230, 230, 230, 230, 230, 230, 231,\n-   230, 232, 233, 233, 233, 233, 233, 233,  18, 234, 165, 165, 165, 165, 165, 235,\n-   226,  26, 236,   9, 237, 238, 239, 240,   2,   2,   2,   2, 241, 242,   2,   2,\n-     2,   2,   2, 243, 244, 245,   2, 246,   2,   2,   2,   2,   2,   2,   2, 247,\n-     9,   9,   9,   9,   9,   9,   9, 248,  14,  14, 249, 249,  14,  14,  14,  14,\n-   249, 249,  14, 250,  14,  14,  14, 249,  14,  14,  14,  14,  14,  14, 251,  14,\n-   251,  14, 252, 253,  14,  14, 254, 255,   0, 256,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0, 257,   0, 258, 259,   0, 260,   2, 261,   0,   0,   0,   0,\n-    26,  26,   9,   9,   9,   9, 222,  26,   0,   0,   0,   0, 262, 263,   4,   0,\n-     0, 264,   0,   0,   2,   2,   2,   2,   2, 265,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 260,  26,  26,  26,\n-     0, 266,  26,  26,   0,   0,   0,   0, 267, 267, 267, 267, 267, 267, 267, 267,\n-   267, 267, 267, 267, 267, 267, 267, 267,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0, 268,   0,   0,   0, 269,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0, 270, 270, 270, 270, 270, 271, 270, 270,\n-   270, 270, 270, 271,   2,   2,   2,   2,  17,  17,  17,  17,  17,  17,  17,  17,\n-    17,  17,  17,  17,  17,  17, 272, 273, 165, 165, 165, 165, 166, 167, 274, 274,\n-   274, 274, 274, 274, 274, 275, 276, 275, 170, 170, 172,  26, 172, 172, 172, 172,\n-   172, 172, 172, 172,  18,  18,  18,  18,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0, 266,  26,  26,  26,  26,  26, 277, 277, 277, 278, 277, 277, 277, 277,\n-   277, 277, 277, 277, 277, 277, 279,  26, 277, 277, 277, 277, 277, 277, 277, 277,\n-   277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n-   277, 277, 280,  26,  26,  26,   0, 281, 282,   0,   0,   0, 283, 284,   0, 285,\n-   286, 287, 287, 287, 287, 287, 287, 287, 287, 287, 288, 289, 290, 291, 291, 291,\n-   291, 291, 291, 291, 291, 291, 291, 292, 293, 294, 294, 294, 294, 294, 295, 169,\n-   169, 169, 169, 169, 169, 169, 169, 169, 169, 296,   0,   0, 294, 294, 294, 294,\n-     0,   0,   0,   0, 281,  26, 291, 291, 169, 169, 169, 296,   0,   0,   0,   0,\n-     0,   0,   0,   0, 169, 169, 169, 297,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0, 291, 291, 291, 291, 291, 298, 291, 291, 291, 291, 291, 291, 291, 291,\n-   291, 291, 291,   0,   0,   0,   0,   0, 277, 277, 277, 277, 277, 277, 277, 277,\n-     0,   0,   0,   0,   0,   0,   0,   0, 277, 277, 277, 277, 277, 277, 277, 277,\n-   277, 277, 277, 277, 277, 277, 277, 299, 300, 300, 300, 300, 300, 300, 300, 300,\n-   300, 300, 300, 300, 300, 300, 300, 300, 300, 301, 300, 300, 300, 300, 300, 300,\n-   302,  26, 303, 303, 303, 303, 303, 303, 304, 304, 304, 304, 304, 304, 304, 304,\n-   304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 305,  26,  26,\n-    18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18, 306, 306, 306, 306,\n-   306, 306, 306, 306, 306, 306, 306,  26,   0,   0,   0,   0, 307,   2,   2,   2,\n-     2,   2,   2,   2,   2,   2,   2,   2,   2, 308,   2,   2,   2,   2,   2,   2,\n-   309, 310,  26,  26,  26,  26, 311,   2, 312, 312, 312, 312, 312, 313,   0, 314,\n-   315, 315, 315, 315, 315, 315, 315,  26, 316, 316, 316, 316, 316, 316, 316, 316,\n-   317, 318, 316, 319,  53,  53,  53,  53, 320, 320, 320, 320, 320, 321, 322, 322,\n-   322, 322, 323, 324, 169, 169, 169, 325, 326, 326, 326, 326, 326, 326, 326, 326,\n-   326, 327, 326, 328, 164, 164, 164, 329, 330, 330, 330, 330, 330, 330, 331,  26,\n-   330, 332, 330, 333, 164, 164, 164, 164, 334, 334, 334, 334, 334, 334, 334, 334,\n-   335,  26,  26, 336, 337, 337, 338,  26, 339, 339, 339,  26, 172, 172,   2,   2,\n-     2,   2,   2, 340, 341, 342, 176, 176, 176, 176, 176, 176, 176, 176, 176, 176,\n-   337, 337, 337, 337, 337, 343, 337, 344, 169, 169, 169, 169, 345,  26, 169, 169,\n-   296, 346, 169, 169, 169, 169, 169, 345,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 277, 277, 277, 277, 277, 277, 277, 277,\n-   277, 277, 277, 277, 277, 280, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n-   277, 277, 277, 347,  26,  26,  26,  26, 348,  26, 349, 350,  25,  25, 351, 352,\n-   353,  25,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n-   354,  26,  51,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n-    31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31, 355,\n-    26,  26,  31,  31,  31,  31,  31,  31,  31,  31, 356,  31,  31,  31,  31,  31,\n-    31,  26,  26,  26,  26,  26,  31, 357,   9,   9,   0, 314,   9, 358,   0,   0,\n-     0,   0, 359,   0, 260, 281,  50,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n-    31,  31,  31,  31,  31,  31,  31, 360, 361,   0,   0,   0,   1,   2,   2,   3,\n-     1,   2,   2,   3, 362, 291, 290, 291, 291, 291, 291, 363, 169, 169, 169, 296,\n-   364, 364, 364, 365, 260, 260,  26, 366, 367, 368, 367, 367, 369, 367, 367, 370,\n-   367, 371, 367, 371,  26,  26,  26,  26, 367, 367, 367, 367, 367, 367, 367, 367,\n-   367, 367, 367, 367, 367, 367, 367, 372, 373,   0,   0,   0,   0,   0, 374,   0,\n-    14,  14,  14,  14,  14,  14,  14,  14,  14, 255,   0, 375, 376,  26,  26,  26,\n-    26,  26,   0,   0,   0,   0,   0, 377, 378, 378, 378, 379, 380, 380, 380, 380,\n-   380, 380, 381,  26, 382,   0,   0, 281, 383, 383, 383, 383, 384, 385, 386, 386,\n-   386, 387, 388, 388, 388, 388, 388, 389, 390, 390, 390, 391, 392, 392, 392, 392,\n-   393, 392, 394,  26,  26,  26,  26,  26, 395, 395, 395, 395, 395, 395, 395, 395,\n-   395, 395, 396, 396, 396, 396, 396, 396, 397, 397, 397, 398, 397, 399, 400, 400,\n-   400, 400, 401, 400, 400, 400, 400, 401, 402, 402, 402, 402, 402,  26, 403, 403,\n-   403, 403, 403, 403, 404, 405,  26,  26, 406, 406, 406, 406, 406, 406, 406, 406,\n-   406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 406, 407,  26,\n-   406, 406, 408,  26, 406,  26,  26,  26, 409, 410, 411, 411, 411, 411, 412, 413,\n-   414, 414, 415, 414, 416, 416, 416, 416, 417, 417, 417, 418, 419, 417,  26,  26,\n-    26,  26,  26,  26, 420, 420, 421, 422, 423, 423, 423, 424, 425, 425, 425, 426,\n-    26,  26,  26,  26,  26,  26,  26,  26, 427, 427, 427, 427, 428, 428, 428, 429,\n-   428, 428, 430, 428, 428, 428, 428, 428, 431, 432, 433, 434, 435, 435, 436, 437,\n-   435, 438, 435, 438, 439, 439, 439, 439, 440, 440, 440, 440,  26,  26,  26,  26,\n-   441, 441, 441, 441, 442, 443, 442,  26, 444, 444, 444, 444, 444, 444, 445, 446,\n-   447, 447, 448, 447, 449, 449, 450, 449, 451, 451, 452, 453,  26, 454,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 455, 455, 455, 455, 455, 455, 455, 455,\n-   455, 456,  26,  26,  26,  26,  26,  26, 457, 457, 457, 457, 457, 457, 458,  26,\n-   457, 457, 457, 457, 457, 457, 458, 459, 460, 460, 460, 460, 460,  26, 460, 461,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,  31,  31,  31, 462, 463, 463, 463, 463, 463, 464, 465,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 466, 466, 466, 466, 466,  26, 467, 467,\n-   467, 467, 467, 468,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 469, 469,\n-   469, 470,  26,  26, 471, 471, 472,  26, 473, 473, 473, 473, 473, 473, 473, 473,\n-   473, 474, 475, 473, 473, 473,  26, 476, 477, 477, 477, 477, 477, 477, 477, 477,\n-   478, 479, 480, 480, 480, 481, 480, 482, 483, 483, 483, 483, 483, 483, 484, 483,\n-   483,  26, 485, 485, 485, 485, 486,  26, 487, 487, 487, 487, 487, 487, 487, 487,\n-   487, 487, 487, 487, 488, 138, 489,  26, 490, 490, 491, 490, 490, 490, 490, 492,\n-    26,  26,  26,  26,  26,  26,  26,  26, 493, 494, 495, 496, 495, 497, 498, 498,\n-   498, 498, 498, 498, 498, 499, 498, 500, 501, 502, 503, 504, 504, 505, 506, 507,\n-   502, 508, 509, 510, 511, 512, 512,  26, 513, 513, 513, 513, 513, 513, 513, 513,\n-   513, 513, 513, 514, 515,  26,  26,  26, 516, 516, 516, 516, 516, 516, 516, 516,\n-   516,  26, 516, 517,  26,  26,  26,  26, 518, 518, 518, 518, 518, 518, 519, 518,\n-   518, 518, 518, 519,  26,  26,  26,  26, 520, 520, 520, 520, 520, 520, 520, 520,\n-   521,  26, 520, 522, 199, 523,  26,  26, 524, 524, 524, 524, 524, 524, 524, 525,\n-   524, 526,  26,  26,  26,  26,  26,  26, 527, 527, 527, 528, 527, 529, 527, 527,\n-    26,  26,  26,  26,  26,  26,  26,  26, 530, 530, 530, 530, 530, 530, 530, 531,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 532, 532, 532, 532,\n-   532, 532, 532, 532, 532, 532, 533, 534, 535, 536, 537, 538, 538, 538, 539, 540,\n-   535,  26, 538, 541,  26,  26,  26,  26,  26,  26,  26,  26, 542, 543, 542, 542,\n-   542, 542, 542, 543, 544,  26,  26,  26, 545, 545, 545, 545, 545, 545, 545, 545,\n-   545,  26, 546, 546, 546, 546, 546, 546, 546, 546, 546, 546, 547,  26,  26,  26,\n-   548, 548, 548, 548, 548, 548, 548, 549, 550, 551, 550, 550, 550, 550, 552, 550,\n-   553,  26, 550, 550, 550, 554, 555, 555, 555, 555, 556, 555, 555, 557, 558,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 559, 560, 561, 561, 561, 561, 559, 562,\n-   561,  26, 561, 563, 564, 565, 566, 566, 566, 567, 568, 569, 566, 570,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26, 571, 571, 571, 572,  26,  26,  26,  26,  26,  26, 573,  26,\n-   108, 108, 108, 108, 108, 108, 574, 575, 576, 576, 576, 576, 576, 576, 576, 576,\n-   576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 576, 577,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 576, 576, 576, 576, 576, 576, 576, 576,\n-   576, 576, 576, 576, 576, 578, 579,  26, 576, 576, 576, 576, 576, 576, 576, 576,\n-   580,  26,  26,  26,  26,  26,  26,  26, 581, 581, 581, 581, 581, 581, 581, 581,\n-   581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 581, 582, 581, 583,\n-    26,  26,  26,  26,  26,  26,  26,  26, 584, 584, 584, 584, 584, 584, 584, 584,\n-   584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584,\n-   585,  26,  26,  26,  26,  26,  26,  26, 306, 306, 306, 306, 306, 306, 306, 306,\n-   306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 306, 586,\n-   587, 587, 587, 588, 587, 589,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26, 590, 590, 590, 591, 591,  26, 592, 592, 592, 592, 592, 592, 592, 592,\n-   593,  26, 592, 594, 594, 592, 592, 595, 592, 592,  26,  26,  26,  26,  26,  26,\n+    11,  11, 236,  27,  27,  27, 237, 238,  11, 239,  27,  27,  32,  32,  32,  32,\n+    13,  13,  13,  13,  13,  13,  13,  13,  13, 240,  13,  13,  13,  13,  13,  13,\n+   241, 242, 241, 241, 242, 243, 241, 244, 245, 245, 245, 246, 247, 248, 249, 250,\n+   251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 261, 262, 263, 264, 265,\n+   266, 267, 268, 269, 270, 271, 272, 272, 273, 274, 275, 209, 276, 277, 209, 278,\n+   279, 279, 279, 279, 279, 279, 279, 279, 280, 209, 281, 209, 209, 209, 209, 282,\n+   209, 283, 279, 284, 209, 285, 286, 209, 209, 209, 287, 140, 288, 140, 271, 271,\n+   271, 289, 209, 209, 209, 209, 290, 271, 209, 209, 209, 209, 209, 209, 209, 209,\n+   209, 209, 209, 291, 292, 209, 209, 293, 209, 209, 209, 209, 209, 209, 294, 209,\n+   209, 209, 209, 209, 209, 209, 295, 296, 271, 297, 209, 209, 298, 279, 299, 279,\n+   300, 301, 279, 279, 279, 302, 279, 303, 209, 209, 209, 279, 304, 209, 209, 305,\n+   209, 306, 209, 209, 209, 209, 209, 209,   9,   9,   9,  11,  11,  11, 307, 308,\n+    13,  13,  13,  13,  13,  13, 309, 310,  11,  11, 311,  48,  48,  48, 312, 313,\n+    48, 314, 315, 315, 315, 315,  32,  32, 316, 317, 318, 319, 320, 321, 140, 140,\n+   209, 322, 209, 209, 209, 209, 209, 323, 209, 209, 209, 209, 209, 324, 140, 325,\n+   326, 327, 328, 329, 136,  48,  48,  48,  48, 330, 178,  48,  48,  48,  48, 331,\n+   332,  48,  48, 136,  48,  48,  48,  48, 200, 333,  48,  48, 209, 209, 323,  48,\n+   209, 334, 335, 209, 336, 337, 209, 209, 335, 209, 209, 337, 209, 209, 209, 209,\n+    48,  48,  48,  48, 209, 209, 209, 209,  48, 338,  48,  48,  48,  48,  48,  48,\n+   151, 209, 209, 209, 287,  48,  48, 229, 339,  48, 340, 140,  13,  13, 341, 342,\n+    13, 343,  48,  48,  48,  48, 344, 345,  31, 346, 347, 348,  13,  13,  13, 349,\n+   350, 351, 352, 353, 354, 355, 140, 356, 357,  48, 358, 359,  48,  48,  48, 360,\n+   361,  48,  48, 362, 363, 192,  32, 364,  64,  48, 365,  48, 366, 367,  48, 151,\n+    76,  48,  48, 368, 369, 370, 371, 372,  48,  48, 373, 374, 375, 376,  48, 377,\n+    48,  48,  48, 378, 379, 380, 381, 382, 383, 384, 315,  11,  11, 385, 386,  11,\n+    11,  11,  11,  11,  48,  48, 387, 192,  48,  48, 388,  48, 389,  48,  48, 206,\n+   390, 390, 390, 390, 390, 390, 390, 390, 391, 391, 391, 391, 391, 391, 391, 391,\n+    48,  48,  48,  48,  48,  48, 204,  48,  48,  48,  48,  48,  48, 207, 140, 140,\n+   392, 393, 394, 395, 396,  48,  48,  48,  48,  48,  48, 397, 398, 399,  48,  48,\n+    48,  48,  48, 400, 209,  48,  48,  48,  48, 401,  48,  48, 402, 140, 140, 403,\n+    32, 404,  32, 405, 406, 407, 408, 409,  48,  48,  48,  48,  48,  48,  48, 410,\n+   411,   2,   3,   4,   5, 412, 413, 414,  48, 415,  48, 200, 416, 417, 418, 419,\n+   420,  48, 172, 421, 204, 204, 140, 140,  48,  48,  48,  48,  48,  48,  48,  71,\n+   422, 271, 271, 423, 272, 272, 272, 424, 425, 426, 427, 140, 140, 209, 209, 428,\n+   140, 140, 140, 140, 140, 140, 140, 140,  48, 151,  48,  48,  48, 100, 429, 430,\n+    48,  48, 431,  48, 432,  48,  48, 433,  48, 434,  48,  48, 435, 436, 140, 140,\n+     9,   9, 437,  11,  11,  48,  48,  48,  48, 204, 192,   9,   9, 438,  11, 439,\n+    48,  48, 440,  48,  48,  48, 441, 442, 442, 443, 444, 445, 140, 140, 140, 140,\n+    48,  48,  48, 314,  48, 199, 440, 140, 446,  27,  27, 447, 140, 140, 140, 140,\n+   448,  48,  48, 449,  48, 450,  48, 451,  48, 200, 452, 140, 140, 140,  48, 453,\n+    48, 454,  48, 455, 140, 140, 140, 140,  48,  48,  48, 456, 271, 457, 271, 271,\n+   458, 459,  48, 460, 461, 462,  48, 463,  48, 464, 140, 140, 465,  48, 466, 467,\n+    48,  48,  48, 468,  48, 469,  48, 470,  48, 471, 472, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48, 196, 140, 140, 140,   9,   9,   9, 473,  11,  11,  11, 474,\n+    48,  48, 475, 192, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 271, 476,\n+    48,  48, 477, 478, 140, 140, 140, 140,  48, 464, 479,  48,  62, 480, 140,  48,\n+   481, 140, 140,  48, 482, 140,  48, 314, 483,  48,  48, 484, 485, 457, 486, 487,\n+   222,  48,  48, 488, 489,  48, 196, 192, 490,  48, 491, 492, 493,  48,  48, 494,\n+   222,  48,  48, 495, 496, 497, 498, 499,  48,  97, 500, 501, 140, 140, 140, 140,\n+   502, 503, 504,  48,  48, 505, 506, 192, 507,  83,  84, 508, 509, 510, 511, 512,\n+    48,  48,  48, 513, 514, 515, 478, 140,  48,  48,  48, 516, 517, 192, 140, 140,\n+    48,  48, 518, 519, 520, 521, 140, 140,  48,  48,  48, 522, 523, 192, 524, 140,\n+    48,  48, 525, 526, 192, 140, 140, 140,  48, 173, 527, 528, 314, 140, 140, 140,\n+    48,  48, 500, 529, 140, 140, 140, 140, 140, 140,   9,   9,  11,  11, 148, 530,\n+   531, 532,  48, 533, 534, 192, 140, 140, 140, 140, 535,  48,  48, 536, 537, 140,\n+   538,  48,  48, 539, 540, 541,  48,  48, 542, 543, 544,  48,  48,  48,  48, 196,\n+    84,  48, 518, 545, 546, 148, 175, 547,  48, 548, 549, 550, 140, 140, 140, 140,\n+   551,  48,  48, 552, 553, 192, 554,  48, 555, 556, 192, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140,  48, 557, 140, 140, 140, 100, 271, 558, 559, 560,\n+    48, 207, 140, 140, 140, 140, 140, 140, 272, 272, 272, 272, 272, 272, 561, 562,\n+    48,  48,  48,  48, 388, 140, 140, 140, 140,  48,  48,  48,  48,  48,  48, 563,\n+    48,  48, 200, 564, 140, 140, 140, 140,  48,  48,  48,  48, 314, 140, 140, 140,\n+    48,  48,  48, 196,  48, 200, 370,  48,  48,  48,  48, 200, 192,  48, 204, 565,\n+    48,  48,  48, 566, 567, 568, 569, 570,  48, 140, 140, 140, 140, 140, 140, 140,\n+   140, 140, 140, 140,   9,   9,  11,  11, 271, 571, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48, 572, 573, 574, 574, 575, 576, 140, 140, 140, 140, 577, 578,\n+    48,  48,  48,  48,  48,  48,  48, 440,  48,  48,  48,  48,  48, 199, 140, 140,\n+   196, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 140, 579,\n+    48,  48, 580, 140, 140, 580, 581,  48,  48,  48,  48,  48,  48,  48,  48, 206,\n+    48,  48,  48,  48,  48,  48,  71, 151, 196, 582, 583, 140, 140, 140, 140, 140,\n+    32,  32, 584,  32, 585, 209, 209, 209, 209, 209, 209, 209, 323, 140, 140, 140,\n+   209, 209, 209, 209, 209, 209, 209, 324, 209, 209, 586, 209, 209, 209, 587, 588,\n+   589, 209, 590, 209, 209, 209, 288, 140, 209, 209, 209, 209, 591, 140, 140, 140,\n+   140, 140, 140, 140, 140, 140, 271, 592, 209, 209, 209, 209, 209, 287, 271, 461,\n+     9, 593,  11, 594, 595, 596, 241,   9, 597, 598, 599, 600, 601,   9, 593,  11,\n+   602, 603,  11, 604, 605, 606, 607,   9, 608,  11,   9, 593,  11, 594, 595,  11,\n+   241,   9, 597, 607,   9, 608,  11,   9, 593,  11, 609,   9, 610, 611, 612, 613,\n+    11, 614,   9, 615, 616, 617, 618,  11, 619,   9, 620,  11, 621, 622, 622, 622,\n+    32,  32,  32, 623,  32,  32, 624, 625, 626, 627,  45, 140, 140, 140, 140, 140,\n+   628, 629, 140, 140, 140, 140, 140, 140, 630, 631, 632, 140, 140, 140, 140, 140,\n+    48,  48, 151, 633, 634, 140, 140, 140, 140,  48, 635, 140,  48,  48, 636, 637,\n+   140, 140, 140, 140, 140, 140, 638, 200,  48,  48,  48,  48, 639, 585, 140, 140,\n+     9,   9, 597,  11, 640, 370, 140, 140, 140, 140, 140, 140, 140, 140, 140, 498,\n+   271, 271, 641, 642, 140, 140, 140, 140, 498, 271, 643, 644, 140, 140, 140, 140,\n+   645,  48, 646, 647, 648, 649, 650, 651, 652, 206, 653, 206, 140, 140, 140, 654,\n+   209, 209, 325, 209, 209, 209, 209, 209, 209, 323, 334, 655, 655, 655, 209, 324,\n+   656, 209, 209, 209, 209, 209, 209, 209, 209, 209, 657, 140, 140, 140, 658, 209,\n+   659, 209, 209, 325, 660, 661, 324, 140, 209, 209, 209, 209, 209, 209, 209, 662,\n+   209, 209, 209, 209, 209, 663, 426, 426, 209, 209, 209, 209, 209, 209, 209, 323,\n+   209, 209, 209, 209, 209, 660, 325, 427, 325, 209, 209, 209, 664, 176, 209, 209,\n+   664, 209, 657, 661, 140, 140, 140, 140, 209, 209, 209, 209, 209, 323, 657, 665,\n+   287, 209, 426, 288, 324, 176, 664, 287, 209, 666, 209, 209, 288, 140, 140, 192,\n+    48,  48,  48,  48,  48,  48, 140, 140,  48,  48,  48, 196,  48,  48,  48,  48,\n+    48, 204,  48,  48,  48,  48,  48,  48,  48,  48, 478,  48,  48,  48,  48,  48,\n+    48,  48,  48,  48,  48,  48, 100, 140,  48, 204, 140, 140, 140, 140, 140, 140,\n+    48,  48,  48,  48,  71, 140, 140, 140, 667, 140, 668, 668, 668, 668, 668, 668,\n+    32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32,  32, 140,\n+   391, 391, 391, 391, 391, 391, 391, 669, 391, 391, 391, 391, 391, 391, 391, 670,\n+     0,   0,   0,   0,   0,   0,   0,   0,   1,   2,   2,   3,   1,   2,   2,   3,\n+     0,   0,   0,   0,   0,   4,   0,   4,   2,   2,   5,   2,   2,   2,   5,   2,\n+     2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,\n+     2,   2,   2,   2,   2,   2,   2,   6,   0,   0,   0,   0,   7,   8,   0,   0,\n+     9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,  10,  11,\n+    12,  13,  14,  14,  15,  14,  14,  14,  14,  14,  14,  14,  16,  17,  14,  14,\n+    18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,\n+    19,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,  18,\n+    18,  18,  18,  18,  18,  18,  20,  21,  21,  21,  22,  20,  21,  21,  21,  21,\n+    21,  23,  24,  25,  25,  25,  25,  25,  25,  26,  25,  25,  25,  27,  28,  26,\n+    29,  30,  31,  32,  31,  31,  31,  31,  33,  34,  35,  31,  31,  31,  36,  31,\n+    31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  29,  31,  31,  31,  31,\n+    37,  38,  37,  37,  37,  37,  37,  37,  37,  39,  31,  31,  31,  31,  31,  31,\n+    40,  40,  40,  40,  40,  40,  41,  26,  42,  42,  42,  42,  42,  42,  42,  43,\n+    44,  44,  44,  44,  44,  45,  44,  46,  47,  47,  47,  48,  37,  49,  31,  31,\n+    31,  50,  51,  31,  31,  31,  31,  31,  31,  31,  31,  31,  52,  31,  31,  31,\n+    53,  53,  53,  53,  53,  53,  53,  53,  53,  53,  54,  53,  55,  53,  53,  53,\n+    56,  57,  58,  59,  59,  60,  61,  62,  57,  63,  64,  65,  66,  59,  59,  67,\n+    68,  69,  70,  71,  71,  72,  73,  74,  69,  75,  76,  77,  78,  71,  79,  26,\n+    80,  81,  82,  83,  83,  84,  85,  86,  81,  87,  88,  26,  89,  83,  90,  91,\n+    92,  93,  94,  95,  95,  96,  97,  98,  93,  99, 100, 101, 102,  95,  95,  26,\n+   103, 104, 105, 106, 107, 104, 108, 109, 104, 105, 110,  26, 111, 108, 108, 112,\n+   113, 114, 115, 113, 113, 115, 113, 116, 114, 117, 118, 119, 120, 113, 121, 113,\n+   122, 123, 124, 122, 122, 124, 125, 126, 123, 127, 128, 128, 129, 122, 130,  26,\n+   131, 132, 133, 131, 131, 131, 131, 131, 132, 133, 134, 131, 135, 131, 131, 131,\n+   136, 137, 138, 139, 137, 137, 140, 141, 138, 142, 143, 137, 144, 137, 145,  26,\n+   146, 147, 147, 147, 147, 147, 147, 148, 147, 147, 147, 149,  26,  26,  26,  26,\n+   150, 151, 152, 152, 153, 152, 152, 154, 155, 154, 152, 156,  26,  26,  26,  26,\n+   157, 157, 157, 157, 157, 157, 157, 157, 157, 158, 157, 157, 157, 159, 158, 157,\n+   157, 157, 157, 158, 157, 157, 157, 160, 157, 160, 161, 162,  26,  26,  26,  26,\n+   163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163,\n+   163, 163, 163, 163, 164, 164, 164, 164, 165, 166, 164, 164, 164, 164, 164, 167,\n+   168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168,\n+   169, 169, 169, 169, 169, 169, 169, 169, 169, 170, 171, 170, 169, 169, 169, 169,\n+   169, 170, 169, 169, 169, 169, 170, 171, 170, 169, 171, 169, 169, 169, 169, 169,\n+   169, 169, 170, 169, 169, 169, 169, 169, 169, 169, 169, 172, 169, 169, 169, 173,\n+   169, 169, 169, 174, 175, 175, 175, 175, 175, 175, 175, 175, 175, 175, 176, 176,\n+   177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177, 177,\n+   178, 178, 178, 179, 180, 180, 180, 180, 180, 180, 180, 180, 180, 181, 180, 182,\n+   183, 183, 184, 185, 186, 186, 187,  26, 188, 188, 189,  26, 190, 191, 192,  26,\n+   193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 193, 194, 193, 195, 193, 195,\n+   196, 197, 197, 198, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 197, 199,\n+   197, 197, 197, 197, 197, 200, 177, 177, 177, 177, 177, 177, 177, 177, 201,  26,\n+   202, 202, 202, 203, 202, 204, 202, 204, 205, 202, 206, 206, 206, 207, 208,  26,\n+   209, 209, 209, 209, 209, 210, 209, 209, 209, 211, 209, 212, 193, 193, 193, 193,\n+   213, 213, 213, 214, 215, 215, 215, 215, 215, 215, 215, 216, 215, 215, 215, 217,\n+   215, 218, 215, 218, 215, 219,   9,   9,   9, 220,  26,  26,  26,  26,  26,  26,\n+   221, 221, 221, 221, 221, 221, 221, 221, 221, 222, 221, 221, 221, 221, 221, 223,\n+   224, 224, 224, 224, 224, 224, 224, 224, 225, 225, 225, 225, 225, 225, 226, 227,\n+   228, 228, 228, 228, 228, 228, 228, 229, 228, 230, 231, 231, 231, 231, 231, 231,\n+    18, 232, 164, 164, 164, 164, 164, 233, 224,  26, 234,   9, 235, 236, 237, 238,\n+     2,   2,   2,   2, 239, 240,   2,   2,   2,   2,   2, 241, 242, 243,   2, 244,\n+     2,   2,   2,   2,   2,   2,   2, 245,   9,   9,   9,   9,   9,   9,   9,   9,\n+    14,  14, 246, 246,  14,  14,  14,  14, 246, 246,  14, 247,  14,  14,  14, 246,\n+    14,  14,  14,  14,  14,  14, 248,  14, 248,  14, 249, 250,  14,  14, 251, 252,\n+     0, 253,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 254,   0, 255, 256,\n+     0, 257,   2, 258,   0,   0,   0,   0, 259,  26,   9,   9,   9,   9, 260,  26,\n+     0,   0,   0,   0, 261, 262,   4,   0,   0, 263,   0,   0,   2,   2,   2,   2,\n+     2, 264,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0, 257,  26,  26,  26,   0, 265,  26,  26,   0,   0,   0,   0,\n+   266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 267,   0,\n+     0,   0, 268,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+   269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269, 269,   2,   2,   2,   2,\n+    17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,  17, 270, 271,\n+   164, 164, 164, 164, 165, 166, 272, 272, 272, 272, 272, 272, 272, 273, 274, 273,\n+   169, 169, 171,  26, 171, 171, 171, 171, 171, 171, 171, 171,  18,  18,  18,  18,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 275,  26,  26,  26,  26,\n+   276, 276, 276, 277, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 278,  26,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 279,  26,  26,  26,   0, 280,\n+   281,   0,   0,   0, 282, 283,   0, 284, 285, 286, 286, 286, 286, 286, 286, 286,\n+   286, 286, 287, 288, 289, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 291,\n+   292, 293, 293, 293, 293, 293, 294, 168, 168, 168, 168, 168, 168, 168, 168, 168,\n+   168, 295,   0,   0, 293, 293, 293, 293,   0,   0,   0,   0, 280,  26, 290, 290,\n+   168, 168, 168, 295,   0,   0,   0,   0,   0,   0,   0,   0, 168, 168, 168, 296,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 290, 290, 290, 290, 290, 297,\n+   290, 290, 290, 290, 290, 290, 290, 290, 290, 290, 290,   0,   0,   0,   0,   0,\n+   276, 276, 276, 276, 276, 276, 276, 276,   0,   0,   0,   0,   0,   0,   0,   0,\n+   298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298,\n+   298, 299, 298, 298, 298, 298, 298, 298, 300,  26, 301, 301, 301, 301, 301, 301,\n+   302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302, 302,\n+   302, 302, 302, 302, 302, 303,  26,  26,  18,  18,  18,  18,  18,  18,  18,  18,\n+    18,  18,  18,  18, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304,  26,\n+     0,   0,   0,   0, 305,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,\n+     2, 306,   2,   2,   2,   2,   2,   2,   2, 307, 308, 309,  26,  26, 310,   2,\n+   311, 311, 311, 311, 311, 312,   0, 313, 314, 314, 314, 314, 314, 314, 314,  26,\n+   315, 315, 315, 315, 315, 315, 315, 315, 316, 317, 315, 318,  53,  53,  53,  53,\n+   319, 319, 319, 319, 319, 320, 321, 321, 321, 321, 322, 323, 168, 168, 168, 324,\n+   325, 325, 325, 325, 325, 325, 325, 325, 325, 326, 325, 327, 163, 163, 163, 328,\n+   329, 329, 329, 329, 329, 329, 330,  26, 329, 331, 329, 332, 163, 163, 163, 163,\n+   333, 333, 333, 333, 333, 333, 333, 333, 334,  26,  26, 335, 336, 336, 337,  26,\n+   338, 338, 338,  26, 171, 171,   2,   2,   2,   2,   2, 339, 340, 341, 175, 175,\n+   175, 175, 175, 175, 175, 175, 175, 175, 336, 336, 336, 336, 336, 342, 336, 343,\n+   168, 168, 168, 168, 344,  26, 168, 168, 295, 345, 168, 168, 168, 168, 168, 344,\n@@ -5264,62 +5274,144 @@\n-   596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 597,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 598, 598, 598, 598, 598, 598, 598, 598,\n-   598, 599, 598, 598, 598, 598, 598, 598, 598, 600, 598, 598,  26,  26,  26,  26,\n-    26,  26,  26,  26, 601,  26, 347,  26, 602, 602, 602, 602, 602, 602, 602, 602,\n-   602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602, 602,\n-   602, 602, 602, 602, 602, 602, 602,  26, 603, 603, 603, 603, 603, 603, 603, 603,\n-   603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603, 603,\n-   603, 603, 604,  26,  26,  26,  26,  26, 602, 605,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 606, 287, 287, 287, 287, 287, 287, 287,\n-   287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287,\n-   287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 287, 288,  26,  26,  26,  26,\n-    26,  26, 607,  26, 608,  26, 609, 609, 609, 609, 609, 609, 609, 609, 609, 609,\n-   609, 609, 609, 609, 609, 609, 609, 609, 609, 609, 609, 609, 609, 609, 609, 609,\n-   609, 609, 609, 609, 609, 609, 609, 610, 611, 611, 611, 611, 611, 611, 611, 611,\n-   611, 611, 611, 611, 611, 612, 611, 613, 611, 614, 611, 615, 281,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0, 616,  26,   0,   0,   0,   0, 260, 361,   0,   0,\n-     0,   0,   0,   0, 617, 618,   0, 619, 620, 621,   0,   0,   0, 622,   0,   0,\n-     0,   0,   0,   0,   0, 623,  26,  26,  14,  14,  14,  14,  14,  14,  14,  14,\n-   249,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,   0,   0, 281,  26,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0, 260,  26,   0,   0,   0, 623,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0, 257,   0,   0,   0,   0,   0,   0,   0,   0, 257, 624, 625,   0, 626,\n-   627,   0,   0,   0,   0,   0,   0,   0, 269, 628, 257, 257,   0,   0,   0, 629,\n-   630, 631, 632,   0,   0,   0,   0,   0,   0,   0,   0,   0, 616,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0, 268,   0,   0,   0,   0,   0,   0, 633, 633, 633, 633, 633, 633, 633, 633,\n-   633, 633, 633, 633, 633, 633, 633, 633, 633, 634,  26, 635, 636, 633,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 271, 270, 270, 637, 638, 639,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 640, 640, 640, 640, 640, 641, 640, 642,\n-   640, 643,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-   644, 644, 644, 644, 644, 644, 644, 645, 646, 646, 646, 646, 646, 646, 646, 646,\n-   646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646, 646,\n-   647, 646, 648,  26,  26,  26,  26,  26, 649, 649, 649, 649, 649, 649, 649, 649,\n-   649, 650, 649, 651,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26, 361,   0,   0,   0,   0,   0,   0,   0, 375,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 361,   0,   0,   0,   0,   0,   0, 616,\n-    26,  26,  26,  26,  26,  26,  26,  26, 652,  31,  31,  31, 653, 654, 655, 656,\n-   657, 658, 653, 659, 653, 655, 655, 660,  31, 661,  31, 662, 663, 661,  31, 662,\n-    26,  26,  26,  26,  26,  26, 354,  26,   0,   0,   0,   0,   0, 281,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 281,  26,   0, 260, 361,   0,\n-   361,   0, 361,   0,   0,   0, 616,  26,   0,   0,   0,   0,   0, 616,  26,  26,\n-    26,  26,  26,  26, 664,   0,   0,   0, 665,  26,   0,   0,   0,   0,   0, 281,\n-     0, 623, 314,  26, 616,  26,  26,  26,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,  26,   0, 375,   0, 375,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0, 281,  26,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0, 623,   0, 281,  26,  26,   0, 281,   0,   0,   0,   0,   0,   0,\n-     0,  26,   0, 314,   0,   0,   0,   0,   0,  26,   0,   0,   0, 616, 314,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0, 632,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0, 627,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0, 281,  26,   0, 616, 375, 266, 260,  26,   0,   0,   0, 623, 260,  26,\n-   266,  26, 260,  26,  26,  26,  26,  26,   0,   0, 359,   0,   0,   0,   0,   0,\n-     0, 266,  26,  26,  26,  26,   0, 314, 277, 277, 277, 277, 277, 277, 277, 277,\n-   277, 277, 277, 280,  26,  26,  26,  26, 277, 277, 277, 277, 277, 277, 299,  26,\n-   277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 280, 277, 277, 277, 277,\n-   277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 347,  26, 277, 277,\n-   277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277, 277,\n-   277, 277, 277, 277, 666,  26,  26,  26, 277, 277, 277, 280,  26,  26,  26,  26,\n-    26,  26,  26,  26,  26,  26,  26,  26, 277, 277, 277, 277, 277, 277, 277, 277,\n-   277, 667,  26,  26,  26,  26,  26,  26, 668,  26,  26,  26,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   9,   9,   9,   9,   9,   9,   9,   9,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 279, 276, 276,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 346,  26,  26,  26,  26,\n+   347,  26, 348, 349,  25,  25, 350, 351, 352,  25,  31,  31,  31,  31,  31,  31,\n+    31,  31,  31,  31,  31,  31,  31,  31, 353,  26, 354,  31,  31,  31,  31,  31,\n+    31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,\n+    31,  31,  31,  31,  31,  31,  31, 355,  31,  31,  31,  31,  31,  31,  31,  31,\n+    31,  31, 356,  31,  31,  31,  31,  31,  31, 357,  26,  26,  26,  26,  31,  31,\n+     9,   9,   0, 313,   9, 358,   0,   0,   0,   0, 359,   0, 257, 280, 360,  31,\n+    31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31, 361,\n+   362,   0,   0,   0,   1,   2,   2,   3,   1,   2,   2,   3, 363, 290, 289, 290,\n+   290, 290, 290, 364, 168, 168, 168, 295, 365, 365, 365, 366, 257, 257,  26, 367,\n+   368, 369, 368, 368, 370, 368, 368, 371, 368, 372, 368, 372,  26,  26,  26,  26,\n+   368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 368, 373,\n+   374,   0,   0,   0,   0,   0, 375,   0,  14,  14,  14,  14,  14,  14,  14,  14,\n+    14, 252,   0, 376, 377,  26,  26,  26,  26,  26,   0,   0,   0,   0,   0, 378,\n+   379, 379, 379, 380, 381, 381, 381, 381, 381, 381, 382,  26, 383,   0,   0, 280,\n+   384, 384, 384, 384, 385, 386, 387, 387, 387, 388, 389, 389, 389, 389, 389, 390,\n+   391, 391, 391, 392, 393, 393, 393, 393, 394, 393, 395,  26,  26,  26,  26,  26,\n+   396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 397, 397, 397, 397, 397, 397,\n+   398, 398, 398, 399, 398, 400, 401, 401, 401, 401, 402, 401, 401, 401, 401, 402,\n+   403, 403, 403, 403, 403,  26, 404, 404, 404, 404, 404, 404, 405, 406, 407, 408,\n+   407, 408, 409, 407, 410, 407, 410, 411,  26,  26,  26,  26,  26,  26,  26,  26,\n+   412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412, 412,\n+   412, 412, 412, 412, 412, 412, 413,  26, 412, 412, 414,  26, 412,  26,  26,  26,\n+   415,   2,   2,   2,   2,   2, 416, 307,  26,  26,  26,  26,  26,  26,  26,  26,\n+   417, 418, 419, 419, 419, 419, 420, 421, 422, 422, 423, 422, 424, 424, 424, 424,\n+   425, 425, 425, 426, 427, 425,  26,  26,  26,  26,  26,  26, 428, 428, 429, 430,\n+   431, 431, 431, 432, 433, 433, 433, 434,  26,  26,  26,  26,  26,  26,  26,  26,\n+   435, 435, 435, 435, 436, 436, 436, 437, 436, 436, 438, 436, 436, 436, 436, 436,\n+   439, 440, 441, 442, 443, 443, 444, 445, 443, 446, 443, 446, 447, 447, 447, 447,\n+   448, 448, 448, 448,  26,  26,  26,  26, 449, 449, 449, 449, 450, 451, 450,  26,\n+   452, 452, 452, 452, 452, 452, 453, 454, 455, 455, 456, 455, 457, 457, 458, 457,\n+   459, 459, 460, 461,  26, 462,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   463, 463, 463, 463, 463, 463, 463, 463, 463, 464,  26,  26,  26,  26,  26,  26,\n+   465, 465, 465, 465, 465, 465, 466,  26, 465, 465, 465, 465, 465, 465, 466, 467,\n+   468, 468, 468, 468, 468,  26, 468, 469,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  31,  31,  31,  50,\n+   470, 470, 470, 470, 470, 471, 472,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   473, 473, 473, 473, 473,  26, 474, 474, 474, 474, 474, 475,  26,  26, 476, 476,\n+   476, 477,  26,  26,  26,  26, 478, 478, 478, 479,  26,  26, 480, 480, 481,  26,\n+   482, 482, 482, 482, 482, 482, 482, 482, 482, 483, 484, 482, 482, 482, 483, 485,\n+   486, 486, 486, 486, 486, 486, 486, 486, 487, 488, 489, 489, 489, 490, 489, 491,\n+   492, 492, 492, 492, 492, 492, 493, 492, 492,  26, 494, 494, 494, 494, 495,  26,\n+   496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 497, 137, 498,  26,\n+   499, 499, 500, 499, 499, 499, 499, 501,  26,  26,  26,  26,  26,  26,  26,  26,\n+   502, 503, 504, 505, 504, 506, 507, 507, 507, 507, 507, 507, 507, 508, 507, 509,\n+   510, 511, 512, 513, 513, 514, 515, 516, 511, 517, 518, 519, 520, 521, 521,  26,\n+   522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 522, 523, 524,  26,  26,  26,\n+   525, 525, 525, 525, 525, 525, 525, 525, 525,  26, 525, 526,  26,  26,  26,  26,\n+   527, 527, 527, 527, 527, 527, 528, 527, 527, 527, 527, 528,  26,  26,  26,  26,\n+   529, 529, 529, 529, 529, 529, 529, 529, 530,  26, 529, 531, 197, 532,  26,  26,\n+   533, 533, 533, 533, 533, 533, 533, 534, 533, 534,  26,  26,  26,  26,  26,  26,\n+   535, 535, 535, 536, 535, 537, 535, 535, 538,  26,  26,  26,  26,  26,  26,  26,\n+   539, 539, 539, 539, 539, 539, 539, 540,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26, 541, 541, 541, 541, 541, 541, 541, 541, 541, 541, 542, 543,\n+   544, 545, 546, 547, 547, 547, 548, 549, 544,  26, 547, 550,  26,  26,  26,  26,\n+    26,  26,  26,  26, 551, 552, 551, 551, 551, 551, 551, 552, 553,  26,  26,  26,\n+   554, 554, 554, 554, 554, 554, 554, 554, 554,  26, 555, 555, 555, 555, 555, 555,\n+   555, 555, 555, 555, 556,  26, 177, 177, 557, 557, 557, 557, 557, 557, 557, 558,\n+   559, 560, 559, 559, 559, 559, 561, 559, 562,  26, 559, 559, 559, 563, 564, 564,\n+   564, 564, 565, 564, 564, 566, 567,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   568, 569, 570, 570, 570, 570, 568, 571, 570,  26, 570, 572, 573, 574, 575, 575,\n+   575, 576, 577, 578, 575, 579,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 580, 580, 580, 581,\n+    26,  26,  26,  26,  26,  26, 582,  26, 108, 108, 108, 108, 108, 108, 583, 584,\n+   585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585,\n+   585, 585, 585, 586,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 587, 588,  26,\n+   585, 585, 585, 585, 585, 585, 585, 585, 589,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 591,  26,\n+   592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592, 592,\n+   592, 592, 592, 592, 592, 593, 592, 594,  26,  26,  26,  26,  26,  26,  26,  26,\n+   595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595, 595,\n+   595, 595, 595, 595, 595, 595, 595, 595, 596,  26,  26,  26,  26,  26,  26,  26,\n+   304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304, 304,\n+   304, 304, 304, 304, 304, 304, 304, 597, 598, 598, 598, 599, 598, 600, 601, 601,\n+   601, 601, 601, 601, 601, 601, 601, 602, 601, 603, 604, 604, 604, 605, 605,  26,\n+   606, 606, 606, 606, 606, 606, 606, 606, 607,  26, 606, 608, 608, 606, 606, 609,\n+   606, 606,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26, 610, 610, 610, 610, 610, 610, 610, 610,\n+   610, 610, 610, 611,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   612, 612, 612, 612, 612, 612, 612, 612, 612, 613, 612, 612, 612, 612, 612, 612,\n+   612, 614, 612, 612,  26,  26,  26,  26,  26,  26,  26,  26, 615,  26, 346,  26,\n+   616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616,\n+   616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616, 616,  26,\n+   617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 617,\n+   617, 617, 617, 617, 617, 617, 617, 617, 617, 617, 618,  26,  26,  26,  26,  26,\n+   616, 619,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 620, 621,\n+   622, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286,\n+   286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286, 286,\n+   286, 286, 286, 286, 623,  26,  26,  26,  26,  26, 624,  26, 625,  26, 626, 626,\n+   626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626,\n+   626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 626, 627,\n+   628, 628, 628, 628, 628, 628, 628, 628, 628, 628, 628, 628, 628, 629, 628, 630,\n+   628, 631, 628, 632, 280,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+     9,   9,   9,   9,   9, 633,   9,   9, 220,  26,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 280,  26,  26,  26,  26,  26,  26,  26,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 275,  26,\n+     0,   0,   0,   0, 257, 362,   0,   0,   0,   0,   0,   0, 634, 635,   0, 636,\n+   637, 638,   0,   0,   0, 639,   0,   0,   0,   0,   0,   0,   0, 265,  26,  26,\n+    14,  14,  14,  14,  14,  14,  14,  14, 246,  26,  26,  26,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,   0,   0, 280,  26,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 257,  26,   0,   0,   0, 259,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 254,   0,   0,   0,   0,   0,\n+     0,   0,   0, 254, 640, 641,   0, 642, 643,   0,   0,   0,   0,   0,   0,   0,\n+   268, 644, 254, 254,   0,   0,   0, 645, 646, 647, 648,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0, 275,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0, 267,   0,   0,   0,   0,   0,   0,\n+   649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649, 649,\n+   649, 650,  26, 651, 652, 649,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+     2,   2,   2, 347,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   653, 269, 269, 654, 655, 656,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   657, 657, 657, 657, 657, 658, 657, 659, 657, 660,  26,  26,  26,  26,  26,  26,\n+    26,  26, 661, 661, 661, 662,  26,  26, 663, 663, 663, 663, 663, 663, 663, 664,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 171, 665, 169, 171,\n+   666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666, 666,\n+   666, 666, 666, 666, 666, 666, 666, 666, 667, 666, 668,  26,  26,  26,  26,  26,\n+   669, 669, 669, 669, 669, 669, 669, 669, 669, 670, 669, 671,  26,  26,  26,  26,\n+    26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26, 362,   0,\n+     0,   0,   0,   0,   0,   0, 376,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   362,   0,   0,   0,   0,   0,   0, 275,  26,  26,  26,  26,  26,  26,  26,  26,\n+   672,  31,  31,  31, 673, 674, 675, 676, 677, 678, 673, 679, 673, 675, 675, 680,\n+    31, 681,  31, 682, 683, 681,  31, 682,  26,  26,  26,  26,  26,  26,  51,  26,\n+     0,   0,   0,   0,   0, 280,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0, 280,  26,   0, 257, 362,   0, 362,   0, 362,   0,   0,   0, 275,  26,\n+     0,   0,   0,   0,   0, 275,  26,  26,  26,  26,  26,  26, 684,   0,   0,   0,\n+   685,  26,   0,   0,   0,   0,   0, 280,   0, 259, 313,  26, 275,  26,  26,  26,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 686,   0, 376,   0, 376,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 280,  26,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 259,   0, 280, 259,  26,\n+     0, 280,   0,   0,   0,   0,   0,   0,   0,  26,   0, 313,   0,   0,   0,   0,\n+     0,  26,   0,   0,   0, 275, 313,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 280,  26,   0, 275, 376, 376,\n+   257,  26,   0,   0,   0, 376,   0, 265, 275,  26,   0, 313,   0,  26, 257,  26,\n+     0,   0, 359,   0,   0,   0,   0,   0,   0, 265,  26,  26,  26,  26,   0, 313,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,  26,  26,  26,  26,\n+   276, 276, 276, 276, 276, 276, 276, 687, 276, 276, 276, 276, 276, 276, 276, 276,\n+   276, 276, 276, 279, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n+   276, 276, 276, 276, 346,  26, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 687,  26,  26,  26,\n+   276, 276, 276, 279,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,  26,\n+   276, 276, 276, 276, 276, 276, 276, 276, 276, 688,  26,  26,  26,  26,  26,  26,\n+   689,  26,  26,  26,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n@@ -5327,69 +5419,1 @@\n-     9,   9,   9,   9,   9,   9,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0, 939, 940, 941, 942, 946, 948,   0, 962,\n-   969, 970, 971, 976,1001,1002,1003,1008,   0,1033,1040,1041,1042,1043,1047,   0,\n-     0,1080,1081,1082,1086,1110,   0,   0,1124,1125,1126,1127,1131,1133,   0,1147,\n-  1154,1155,1156,1161,1187,1188,1189,1193,   0,1219,1226,1227,1228,1229,1233,   0,\n-     0,1267,1268,1269,1273,1298,   0,1303, 943,1128, 944,1129, 954,1139, 958,1143,\n-   959,1144, 960,1145, 961,1146, 964,1149,   0,   0, 973,1158, 974,1159, 975,1160,\n-   983,1168, 978,1163, 988,1173, 990,1175, 991,1176, 993,1178, 994,1179,   0,   0,\n-  1004,1190,1005,1191,1006,1192,1014,1199,1007,   0,   0,   0,1016,1201,1020,1206,\n-     0,1022,1208,1025,1211,1023,1209,   0,   0,   0,   0,1032,1218,1037,1223,1035,\n-  1221,   0,   0,   0,1044,1230,1045,1231,1049,1235,   0,   0,1058,1244,1064,1250,\n-  1060,1246,1066,1252,1067,1253,1072,1258,1069,1255,1077,1264,1074,1261,   0,   0,\n-  1083,1270,1084,1271,1085,1272,1088,1275,1089,1276,1096,1283,1103,1290,1111,1299,\n-  1115,1118,1307,1120,1309,1121,1310,   0,1053,1239,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,1093,1280,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0, 949,1134,1010,1195,1050,1236,1090,1277,1341,1368,1340,\n-  1367,1342,1369,1339,1366,   0,1320,1347,1418,1419,1323,1350,   0,   0, 992,1177,\n-  1018,1204,1055,1241,1416,1417,1415,1424,1202,   0,   0,   0, 987,1172,   0,   0,\n-  1031,1217,1321,1348,1322,1349,1338,1365, 950,1135, 951,1136, 979,1164, 980,1165,\n-  1011,1196,1012,1197,1051,1237,1052,1238,1061,1247,1062,1248,1091,1278,1092,1279,\n-  1071,1257,1076,1263,   0,   0, 997,1182,   0,   0,   0,   0,   0,   0, 945,1130,\n-   982,1167,1337,1364,1335,1362,1046,1232,1422,1423,1113,1301,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   8,   9,   0,  10,1425,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,1314,1427,   5,\n-  1434,1438,1443,   0,1450,   0,1455,1461,1514,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1446,1458,1468,1476,1480,1486,1517,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1489,1503,1494,1500,1508,   0,   0,   0,   0,1520,1521,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1526,1528,   0,1525,   0,   0,   0,1522,\n-     0,   0,   0,   0,1536,1532,1539,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1534,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1556,   0,   0,   0,   0,   0,   0,1548,1550,   0,1547,   0,   0,   0,1567,\n-     0,   0,   0,   0,1558,1554,1561,   0,   0,   0,   0,   0,   0,   0,1568,1569,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1529,1551,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1523,1545,1524,1546,   0,   0,1527,1549,\n-     0,   0,1570,1571,1530,1552,1531,1553,   0,   0,1533,1555,1535,1557,1537,1559,\n-     0,   0,1572,1573,1544,1566,1538,1560,1540,1562,1541,1563,1542,1564,   0,   0,\n-  1543,1565,   0,   0,   0,   0,   0,   0,   0,   0,1606,1607,1609,1608,1610,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1613,   0,1611,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1612,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1620,   0,   0,   0,   0,   0,   0,   0,1623,   0,   0,1624,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1614,1615,1616,1617,1618,1619,1621,1622,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1628,1629,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1625,1626,   0,1627,   0,   0,   0,1634,   0,   0,1635,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1630,1631,1632,   0,   0,1633,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1639,   0,   0,1638,1640,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1636,1637,   0,   0,   0,   0,   0,   0,1641,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1642,1644,1643,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1645,   0,   0,   0,   0,   0,   0,   0,1646,   0,   0,   0,   0,   0,   0,1648,\n-  1649,   0,1647,1650,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1651,1653,1652,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1654,   0,1655,1657,1656,   0,   0,   0,   0,1659,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,1660,   0,   0,   0,   0,1661,   0,   0,   0,   0,1662,\n-     0,   0,   0,   0,1663,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1658,   0,   0,   0,   0,   0,   0,   0,   0,   0,1664,   0,1665,1673,   0,\n-  1674,   0,   0,   0,   0,   0,   0,   0,   0,1666,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1668,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,1669,   0,   0,   0,   0,1670,   0,   0,   0,   0,1671,\n-     0,   0,   0,   0,1672,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1667,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1675,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1676,   0,\n-  1677,   0,1678,   0,1679,   0,1680,   0,   0,   0,1681,   0,   0,   0,   0,   0,\n+     9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   0,   0,\n@@ -5397,138 +5421,206 @@\n-     0,   0,   0,1682,   0,1683,   0,   0,1684,1685,   0,1686,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0, 953,1138, 955,1140, 956,1141, 957,1142,\n-  1324,1351, 963,1148, 965,1150, 968,1153, 966,1151, 967,1152,1378,1380,1379,1381,\n-   984,1169, 985,1170,1420,1421, 986,1171, 989,1174, 995,1180, 998,1183, 996,1181,\n-   999,1184,1000,1185,1015,1200,1329,1356,1017,1203,1019,1205,1021,1207,1024,1210,\n-  1687,1688,1027,1213,1026,1212,1028,1214,1029,1215,1030,1216,1034,1220,1036,1222,\n-  1039,1225,1038,1224,1334,1361,1336,1363,1382,1384,1383,1385,1056,1242,1057,1243,\n-  1059,1245,1063,1249,1689,1690,1065,1251,1068,1254,1070,1256,1386,1387,1388,1389,\n-  1691,1692,1073,1259,1075,1262,1079,1266,1078,1265,1095,1282,1098,1285,1097,1284,\n-  1390,1391,1392,1393,1099,1286,1100,1287,1101,1288,1102,1289,1105,1292,1104,1291,\n-  1106,1294,1107,1295,1108,1296,1114,1302,1119,1308,1122,1311,1123,1312,1186,1260,\n-  1293,1305,   0,1394,   0,   0,   0,   0, 952,1137, 947,1132,1317,1344,1316,1343,\n-  1319,1346,1318,1345,1693,1695,1371,1375,1370,1374,1373,1377,1372,1376,1694,1696,\n-   981,1166, 977,1162, 972,1157,1326,1353,1325,1352,1328,1355,1327,1354,1697,1698,\n-  1009,1194,1013,1198,1054,1240,1048,1234,1331,1358,1330,1357,1333,1360,1332,1359,\n-  1699,1700,1396,1401,1395,1400,1398,1403,1397,1402,1399,1404,1094,1281,1087,1274,\n-  1406,1411,1405,1410,1408,1413,1407,1412,1409,1414,1109,1297,1117,1306,1116,1304,\n-  1112,1300,   0,   0,   0,   0,   0,   0,1471,1472,1701,1705,1702,1706,1703,1707,\n-  1430,1431,1715,1719,1716,1720,1717,1721,1477,1478,1729,1731,1730,1732,   0,   0,\n-  1435,1436,1733,1735,1734,1736,   0,   0,1481,1482,1737,1741,1738,1742,1739,1743,\n-  1439,1440,1751,1755,1752,1756,1753,1757,1490,1491,1765,1768,1766,1769,1767,1770,\n-  1447,1448,1771,1774,1772,1775,1773,1776,1495,1496,1777,1779,1778,1780,   0,   0,\n-  1451,1452,1781,1783,1782,1784,   0,   0,1504,1505,1785,1788,1786,1789,1787,1790,\n-     0,1459,   0,1791,   0,1792,   0,1793,1509,1510,1794,1798,1795,1799,1796,1800,\n-  1462,1463,1808,1812,1809,1813,1810,1814,1467,  21,1475,  22,1479,  23,1485,  24,\n-  1493,  27,1499,  28,1507,  29,   0,   0,1704,1708,1709,1710,1711,1712,1713,1714,\n-  1718,1722,1723,1724,1725,1726,1727,1728,1740,1744,1745,1746,1747,1748,1749,1750,\n-  1754,1758,1759,1760,1761,1762,1763,1764,1797,1801,1802,1803,1804,1805,1806,1807,\n-  1811,1815,1816,1817,1818,1819,1820,1821,1470,1469,1822,1474,1465,   0,1473,1825,\n-  1429,1428,1426,  12,1432,   0,  26,   0,   0,1315,1823,1484,1466,   0,1483,1829,\n-  1433,  13,1437,  14,1441,1826,1827,1828,1488,1487,1513,  19,   0,   0,1492,1515,\n-  1445,1444,1442,  15,   0,1831,1832,1833,1502,1501,1516,  25,1497,1498,1506,1518,\n-  1457,1456,1454,  17,1453,1313,  11,   3,   0,   0,1824,1512,1519,   0,1511,1830,\n-  1449,  16,1460,  18,1464,   4,   0,   0,  30,  31,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  20,   0,\n-     0,   0,   2,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1834,1835,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1836,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,1837,1839,1838,   0,   0,   0,   0,1840,   0,   0,   0,\n-     0,1841,   0,   0,1842,   0,   0,   0,   0,   0,   0,   0,1843,   0,1844,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1845,   0,   0,1846,   0,   0,1847,\n-     0,1848,   0,   0,   0,   0,   0,   0, 937,   0,1850,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,1849, 936, 938,1851,1852,   0,   0,1853,1854,   0,   0,\n-  1855,1856,   0,   0,   0,   0,   0,   0,1857,1858,   0,   0,1861,1862,   0,   0,\n-  1863,1864,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1867,1868,1869,1870,1859,1860,1865,1866,   0,   0,   0,   0,\n-     0,   0,1871,1872,1873,1874,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,  32,  33,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1875,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1877,   0,1878,   0,1879,   0,1880,   0,1881,   0,1882,   0,\n-  1883,   0,1884,   0,1885,   0,1886,   0,1887,   0,1888,   0,   0,1889,   0,1890,\n-     0,1891,   0,   0,   0,   0,   0,   0,1892,1893,   0,1894,1895,   0,1896,1897,\n-     0,1898,1899,   0,1900,1901,   0,   0,   0,   0,   0,   0,1876,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1902,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,1904,   0,1905,   0,1906,   0,1907,   0,1908,   0,1909,   0,\n-  1910,   0,1911,   0,1912,   0,1913,   0,1914,   0,1915,   0,   0,1916,   0,1917,\n-     0,1918,   0,   0,   0,   0,   0,   0,1919,1920,   0,1921,1922,   0,1923,1924,\n-     0,1925,1926,   0,1927,1928,   0,   0,   0,   0,   0,   0,1903,   0,   0,1929,\n-  1930,1931,1932,   0,   0,   0,1933,   0, 710, 385, 724, 715, 455, 103, 186, 825,\n-   825, 242, 751, 205, 241, 336, 524, 601, 663, 676, 688, 738, 411, 434, 474, 500,\n-   649, 746, 799, 108, 180, 416, 482, 662, 810, 275, 462, 658, 692, 344, 618, 679,\n-   293, 388, 440, 492, 740, 116, 146, 168, 368, 414, 481, 527, 606, 660, 665, 722,\n-   781, 803, 809, 538, 553, 588, 642, 758, 811, 701, 233, 299, 573, 612, 487, 540,\n-   714, 779, 232, 267, 412, 445, 457, 585, 594, 766, 167, 613, 149, 148, 560, 589,\n-   648, 768, 708, 345, 411, 704, 105, 259, 313, 496, 518, 174, 542, 120, 307, 101,\n-   430, 372, 584, 183, 228, 529, 650, 697, 424, 732, 428, 349, 632, 355, 517, 110,\n-   135, 147, 403, 580, 624, 700, 750, 170, 193, 245, 297, 374, 463, 543, 763, 801,\n-   812, 815, 162, 384, 420, 730, 287, 330, 337, 366, 459, 476, 509, 558, 591, 610,\n-   726, 652, 734, 759, 154, 163, 198, 473, 683, 697, 292, 311, 353, 423, 572, 494,\n-   113, 217, 259, 280, 314, 499, 506, 603, 608, 752, 778, 782, 788, 117, 557, 748,\n-   774, 320, 109, 126, 260, 265, 373, 411, 479, 523, 655, 737, 823, 380, 765, 161,\n-   395, 398, 438, 451, 502, 516, 537, 583, 791, 136, 340, 769, 122, 273, 446, 727,\n-   305, 322, 400, 496, 771, 155, 190, 269, 377, 391, 406, 432, 501, 519, 599, 684,\n-   687, 749, 776, 175, 452, 191, 480, 510, 659, 772, 805, 813, 397, 444, 619, 566,\n-   568, 575, 491, 471, 707, 111, 636, 156, 153, 288, 346, 578, 256, 435, 383, 729,\n-   680, 767, 694, 295, 128, 210,   0,   0, 227,   0, 379,   0,   0, 150, 493, 525,\n-   544, 551, 552, 556, 783, 576, 604,   0, 661,   0, 703,   0,   0, 735, 743,   0,\n-     0,   0, 793, 794, 795, 808, 741, 773, 118, 127, 130, 166, 169, 177, 207, 213,\n-   215, 226, 229, 268, 270, 317, 327, 329, 335, 369, 375, 381, 404, 441, 448, 458,\n-   477, 484, 503, 539, 545, 547, 546, 548, 549, 550, 554, 555, 561, 564, 569, 591,\n-   593, 595, 598, 607, 620, 625, 625, 651, 690, 695, 705, 706, 716, 717, 733, 735,\n-   777, 786, 790, 315, 869, 623,   0,   0, 102, 145, 134, 115, 129, 138, 165, 171,\n-   207, 202, 206, 212, 227, 231, 240, 243, 250, 254, 294, 296, 303, 308, 319, 325,\n-   321, 329, 326, 335, 341, 357, 360, 362, 370, 379, 388, 389, 393, 421, 424, 438,\n-   456, 454, 458, 465, 477, 535, 485, 490, 493, 507, 512, 514, 521, 522, 525, 526,\n-   528, 533, 532, 541, 565, 569, 574, 586, 591, 597, 607, 637, 647, 674, 691, 693,\n-   695, 698, 703, 699, 705, 704, 702, 706, 709, 717, 728, 736, 747, 754, 770, 777,\n-   783, 784, 786, 787, 790, 802, 825, 848, 847, 857,  55,  65,  66, 883, 892, 916,\n-   822, 824,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,1586,   0,1605,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1602,1603,1934,1935,1574,1575,1576,1577,1579,1580,1581,1583,1584,   0,\n-  1585,1587,1588,1589,1591,   0,1592,   0,1593,1594,   0,1595,1596,   0,1598,1599,\n-  1600,1601,1604,1582,1578,1590,1597,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1936,   0,1937,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1938,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1939,1940,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1941,1942,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1944,1943,   0,1945,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,1946,1947,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1948,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1949,1950,1951,1952,1953,1954,1955,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1956,1957,1958,1960,1959,1961,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0, 106, 104, 107, 826, 114, 118, 119, 121,\n-   123, 124, 127, 125,  34, 830, 130, 131, 132, 137, 827,  35, 133, 139, 829, 142,\n-   143, 112, 144, 145, 924, 151, 152,  37, 157, 158, 159, 160,  38, 165, 166, 169,\n-   171, 172, 173, 174, 176, 177, 178, 179, 181, 182, 182, 182, 833, 468, 184, 185,\n-   834, 187, 188, 189, 196, 192, 194, 195, 197, 199, 200, 201, 203, 204, 204, 206,\n-   208, 209, 211, 218, 213, 219, 214, 216, 153, 234, 221, 222, 223, 220, 225, 224,\n-   230, 835, 235, 236, 237, 238, 239, 244, 836, 837, 247, 248, 249, 246, 251,  39,\n-    40, 253, 255, 255, 838, 257, 258, 259, 261, 839, 262, 263, 301, 264,  41, 266,\n-   270, 272, 271, 841, 274, 842, 277, 276, 278, 281, 282,  42, 283, 284, 285, 286,\n-    43, 843,  44, 289, 290, 291, 293, 934, 298, 845, 845, 621, 300, 300,  45, 852,\n-   894, 302, 304,  46, 306, 309, 310, 312, 316,  48,  47, 317, 846, 318, 323, 324,\n-   325, 324, 328, 329, 333, 331, 332, 334, 335, 336, 338, 339, 342, 343, 347, 351,\n-   849, 350, 348, 352, 354, 359, 850, 361, 358, 356,  49, 363, 365, 367, 364,  50,\n-   369, 371, 851, 376, 386, 378,  53, 381,  52,  51, 140, 141, 387, 382, 614,  78,\n-   388, 389, 390, 394, 392, 856,  54, 399, 396, 402, 404, 858, 405, 401, 407,  55,\n-   408, 409, 410, 413, 859, 415,  56, 417, 860, 418,  57, 419, 422, 424, 425, 861,\n-   840, 862, 426, 863, 429, 431, 427, 433, 437, 441, 438, 439, 442, 443, 864, 436,\n-   449, 450,  58, 454, 453, 865, 447, 460, 866, 867, 461, 466, 465, 464,  59, 467,\n-   470, 469, 472, 828, 475, 868, 478, 870, 483, 485, 486, 871, 488, 489, 872, 873,\n-   495, 497,  60, 498,  61,  61, 504, 505, 507, 508, 511,  62, 513, 874, 515, 875,\n-   518, 844, 520, 876, 877, 878,  63,  64, 528, 880, 879, 881, 882, 530, 531, 531,\n-   533,  66, 534,  67,  68, 884, 536, 538, 541,  69, 885, 549, 886, 887, 556, 559,\n-    70, 561, 562, 563, 888, 889, 889, 567,  71, 890, 570, 571,  72, 891, 577,  73,\n-   581, 579, 582, 893, 587,  74, 590, 592, 596,  75, 895, 896,  76, 897, 600, 898,\n-   602, 605, 607, 899, 900, 609, 901, 611, 853,  77, 615, 616,  79, 617, 252, 902,\n-   903, 854, 855, 621, 622, 731,  80, 627, 626, 628, 164, 629, 630, 631, 633, 904,\n-   632, 634, 639, 640, 635, 641, 646, 651, 638, 643, 644, 645, 905, 907, 906,  81,\n-   653, 654, 656, 911, 657, 908,  82,  83, 909, 910,  84, 664, 665, 666, 667, 669,\n-   668, 671, 670, 674, 672, 673, 675,  85, 677, 678,  86, 681, 682, 912, 685, 686,\n-    87, 689,  36, 913, 914,  88,  89, 696, 702, 709, 711, 915, 712, 713, 718, 719,\n-   917, 831, 721, 720, 723, 832, 725, 728, 918, 919, 739, 742, 744, 920, 745, 753,\n-   756, 757, 755, 760, 761, 921, 762,  90, 764, 922,  91, 775, 279, 780, 923, 925,\n-    92,  93, 785, 926,  94, 927, 787, 787, 789, 928, 792,  95, 796, 797, 798, 800,\n-    96, 929, 802, 804, 806,  97,  98, 807, 930,  99, 931, 932, 933, 814, 100, 816,\n-   817, 818, 819, 820, 821, 935,   0,   0,\n+   939, 940, 941, 942, 946, 948,   0, 962, 969, 970, 971, 976,1001,1002,1003,1008,\n+     0,1033,1040,1041,1042,1043,1047,   0,   0,1080,1081,1082,1086,1110,   0,   0,\n+  1124,1125,1126,1127,1131,1133,   0,1147,1154,1155,1156,1161,1187,1188,1189,1193,\n+     0,1219,1226,1227,1228,1229,1233,   0,   0,1267,1268,1269,1273,1298,   0,1303,\n+   943,1128, 944,1129, 954,1139, 958,1143, 959,1144, 960,1145, 961,1146, 964,1149,\n+     0,   0, 973,1158, 974,1159, 975,1160, 983,1168, 978,1163, 988,1173, 990,1175,\n+   991,1176, 993,1178, 994,1179,   0,   0,1004,1190,1005,1191,1006,1192,1014,1199,\n+  1007,   0,   0,   0,1016,1201,1020,1206,   0,1022,1208,1025,1211,1023,1209,   0,\n+     0,   0,   0,1032,1218,1037,1223,1035,1221,   0,   0,   0,1044,1230,1045,1231,\n+  1049,1235,   0,   0,1058,1244,1064,1250,1060,1246,1066,1252,1067,1253,1072,1258,\n+  1069,1255,1077,1264,1074,1261,   0,   0,1083,1270,1084,1271,1085,1272,1088,1275,\n+  1089,1276,1096,1283,1103,1290,1111,1299,1115,1118,1307,1120,1309,1121,1310,   0,\n+  1053,1239,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1093,\n+  1280,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 949,1134,1010,\n+  1195,1050,1236,1090,1277,1341,1368,1340,1367,1342,1369,1339,1366,   0,1320,1347,\n+  1418,1419,1323,1350,   0,   0, 992,1177,1018,1204,1055,1241,1416,1417,1415,1424,\n+  1202,   0,   0,   0, 987,1172,   0,   0,1031,1217,1321,1348,1322,1349,1338,1365,\n+   950,1135, 951,1136, 979,1164, 980,1165,1011,1196,1012,1197,1051,1237,1052,1238,\n+  1061,1247,1062,1248,1091,1278,1092,1279,1071,1257,1076,1263,   0,   0, 997,1182,\n+     0,   0,   0,   0,   0,   0, 945,1130, 982,1167,1337,1364,1335,1362,1046,1232,\n+  1422,1423,1113,1301,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     8,   9,   0,  10,1425,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,\n+     0,   0,   0,   0,   0,1314,1427,   5,1434,1438,1443,   0,1450,   0,1455,1461,\n+  1514,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1446,1458,1468,1476,1480,1486,\n+  1517,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1489,1503,1494,1500,1508,   0,\n+     0,   0,   0,1520,1521,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1526,1528,   0,1525,   0,   0,   0,1522,   0,   0,   0,   0,1536,1532,1539,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1534,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1556,   0,   0,   0,   0,   0,   0,\n+  1548,1550,   0,1547,   0,   0,   0,1567,   0,   0,   0,   0,1558,1554,1561,   0,\n+     0,   0,   0,   0,   0,   0,1568,1569,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1529,1551,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1523,1545,1524,1546,   0,   0,1527,1549,   0,   0,1570,1571,1530,1552,1531,1553,\n+     0,   0,1533,1555,1535,1557,1537,1559,   0,   0,1572,1573,1544,1566,1538,1560,\n+  1540,1562,1541,1563,1542,1564,   0,   0,1543,1565,   0,   0,   0,   0,   0,   0,\n+     0,   0,1606,1607,1609,1608,1610,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1613,   0,1611,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1612,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1620,   0,   0,   0,   0,   0,   0,\n+     0,1623,   0,   0,1624,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1614,1615,1616,1617,1618,1619,1621,1622,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1628,1629,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1625,1626,   0,1627,\n+     0,   0,   0,1634,   0,   0,1635,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1630,1631,1632,   0,   0,1633,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1639,   0,   0,1638,1640,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1636,1637,   0,   0,\n+     0,   0,   0,   0,1641,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1642,1644,1643,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1645,   0,   0,   0,   0,   0,   0,   0,\n+  1646,   0,   0,   0,   0,   0,   0,1648,1649,   0,1647,1650,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1651,1653,1652,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1654,   0,1655,1657,1656,   0,\n+     0,   0,   0,1659,   0,   0,   0,   0,   0,   0,   0,   0,   0,1660,   0,   0,\n+     0,   0,1661,   0,   0,   0,   0,1662,   0,   0,   0,   0,1663,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1658,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1664,   0,1665,1673,   0,1674,   0,   0,   0,   0,   0,   0,   0,\n+     0,1666,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1668,   0,   0,   0,   0,   0,   0,   0,   0,   0,1669,   0,   0,\n+     0,   0,1670,   0,   0,   0,   0,1671,   0,   0,   0,   0,1672,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1667,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1675,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1676,   0,1677,   0,1678,   0,1679,   0,1680,   0,\n+     0,   0,1681,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1682,   0,1683,   0,   0,\n+  1684,1685,   0,1686,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+   953,1138, 955,1140, 956,1141, 957,1142,1324,1351, 963,1148, 965,1150, 968,1153,\n+   966,1151, 967,1152,1378,1380,1379,1381, 984,1169, 985,1170,1420,1421, 986,1171,\n+   989,1174, 995,1180, 998,1183, 996,1181, 999,1184,1000,1185,1015,1200,1329,1356,\n+  1017,1203,1019,1205,1021,1207,1024,1210,1687,1688,1027,1213,1026,1212,1028,1214,\n+  1029,1215,1030,1216,1034,1220,1036,1222,1039,1225,1038,1224,1334,1361,1336,1363,\n+  1382,1384,1383,1385,1056,1242,1057,1243,1059,1245,1063,1249,1689,1690,1065,1251,\n+  1068,1254,1070,1256,1386,1387,1388,1389,1691,1692,1073,1259,1075,1262,1079,1266,\n+  1078,1265,1095,1282,1098,1285,1097,1284,1390,1391,1392,1393,1099,1286,1100,1287,\n+  1101,1288,1102,1289,1105,1292,1104,1291,1106,1294,1107,1295,1108,1296,1114,1302,\n+  1119,1308,1122,1311,1123,1312,1186,1260,1293,1305,   0,1394,   0,   0,   0,   0,\n+   952,1137, 947,1132,1317,1344,1316,1343,1319,1346,1318,1345,1693,1695,1371,1375,\n+  1370,1374,1373,1377,1372,1376,1694,1696, 981,1166, 977,1162, 972,1157,1326,1353,\n+  1325,1352,1328,1355,1327,1354,1697,1698,1009,1194,1013,1198,1054,1240,1048,1234,\n+  1331,1358,1330,1357,1333,1360,1332,1359,1699,1700,1396,1401,1395,1400,1398,1403,\n+  1397,1402,1399,1404,1094,1281,1087,1274,1406,1411,1405,1410,1408,1413,1407,1412,\n+  1409,1414,1109,1297,1117,1306,1116,1304,1112,1300,   0,   0,   0,   0,   0,   0,\n+  1471,1472,1701,1705,1702,1706,1703,1707,1430,1431,1715,1719,1716,1720,1717,1721,\n+  1477,1478,1729,1731,1730,1732,   0,   0,1435,1436,1733,1735,1734,1736,   0,   0,\n+  1481,1482,1737,1741,1738,1742,1739,1743,1439,1440,1751,1755,1752,1756,1753,1757,\n+  1490,1491,1765,1768,1766,1769,1767,1770,1447,1448,1771,1774,1772,1775,1773,1776,\n+  1495,1496,1777,1779,1778,1780,   0,   0,1451,1452,1781,1783,1782,1784,   0,   0,\n+  1504,1505,1785,1788,1786,1789,1787,1790,   0,1459,   0,1791,   0,1792,   0,1793,\n+  1509,1510,1794,1798,1795,1799,1796,1800,1462,1463,1808,1812,1809,1813,1810,1814,\n+  1467,  21,1475,  22,1479,  23,1485,  24,1493,  27,1499,  28,1507,  29,   0,   0,\n+  1704,1708,1709,1710,1711,1712,1713,1714,1718,1722,1723,1724,1725,1726,1727,1728,\n+  1740,1744,1745,1746,1747,1748,1749,1750,1754,1758,1759,1760,1761,1762,1763,1764,\n+  1797,1801,1802,1803,1804,1805,1806,1807,1811,1815,1816,1817,1818,1819,1820,1821,\n+  1470,1469,1822,1474,1465,   0,1473,1825,1429,1428,1426,  12,1432,   0,  26,   0,\n+     0,1315,1823,1484,1466,   0,1483,1829,1433,  13,1437,  14,1441,1826,1827,1828,\n+  1488,1487,1513,  19,   0,   0,1492,1515,1445,1444,1442,  15,   0,1831,1832,1833,\n+  1502,1501,1516,  25,1497,1498,1506,1518,1457,1456,1454,  17,1453,1313,  11,   3,\n+     0,   0,1824,1512,1519,   0,1511,1830,1449,  16,1460,  18,1464,   4,   0,   0,\n+    30,  31,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,  20,   0,   0,   0,   2,   6,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1834,1835,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1836,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1837,1839,1838,\n+     0,   0,   0,   0,1840,   0,   0,   0,   0,1841,   0,   0,1842,   0,   0,   0,\n+     0,   0,   0,   0,1843,   0,1844,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1845,   0,   0,1846,   0,   0,1847,   0,1848,   0,   0,   0,   0,   0,   0,\n+   937,   0,1850,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1849, 936, 938,\n+  1851,1852,   0,   0,1853,1854,   0,   0,1855,1856,   0,   0,   0,   0,   0,   0,\n+  1857,1858,   0,   0,1861,1862,   0,   0,1863,1864,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1867,1868,1869,1870,\n+  1859,1860,1865,1866,   0,   0,   0,   0,   0,   0,1871,1872,1873,1874,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,  32,  33,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1875,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1877,   0,1878,   0,\n+  1879,   0,1880,   0,1881,   0,1882,   0,1883,   0,1884,   0,1885,   0,1886,   0,\n+  1887,   0,1888,   0,   0,1889,   0,1890,   0,1891,   0,   0,   0,   0,   0,   0,\n+  1892,1893,   0,1894,1895,   0,1896,1897,   0,1898,1899,   0,1900,1901,   0,   0,\n+     0,   0,   0,   0,1876,   0,   0,   0,   0,   0,   0,   0,   0,   0,1902,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1904,   0,1905,   0,\n+  1906,   0,1907,   0,1908,   0,1909,   0,1910,   0,1911,   0,1912,   0,1913,   0,\n+  1914,   0,1915,   0,   0,1916,   0,1917,   0,1918,   0,   0,   0,   0,   0,   0,\n+  1919,1920,   0,1921,1922,   0,1923,1924,   0,1925,1926,   0,1927,1928,   0,   0,\n+     0,   0,   0,   0,1903,   0,   0,1929,1930,1931,1932,   0,   0,   0,1933,   0,\n+   710, 385, 724, 715, 455, 103, 186, 825, 825, 242, 751, 205, 241, 336, 524, 601,\n+   663, 676, 688, 738, 411, 434, 474, 500, 649, 746, 799, 108, 180, 416, 482, 662,\n+   810, 275, 462, 658, 692, 344, 618, 679, 293, 388, 440, 492, 740, 116, 146, 168,\n+   368, 414, 481, 527, 606, 660, 665, 722, 781, 803, 809, 538, 553, 588, 642, 758,\n+   811, 701, 233, 299, 573, 612, 487, 540, 714, 779, 232, 267, 412, 445, 457, 585,\n+   594, 766, 167, 613, 149, 148, 560, 589, 648, 768, 708, 345, 411, 704, 105, 259,\n+   313, 496, 518, 174, 542, 120, 307, 101, 430, 372, 584, 183, 228, 529, 650, 697,\n+   424, 732, 428, 349, 632, 355, 517, 110, 135, 147, 403, 580, 624, 700, 750, 170,\n+   193, 245, 297, 374, 463, 543, 763, 801, 812, 815, 162, 384, 420, 730, 287, 330,\n+   337, 366, 459, 476, 509, 558, 591, 610, 726, 652, 734, 759, 154, 163, 198, 473,\n+   683, 697, 292, 311, 353, 423, 572, 494, 113, 217, 259, 280, 314, 499, 506, 603,\n+   608, 752, 778, 782, 788, 117, 557, 748, 774, 320, 109, 126, 260, 265, 373, 411,\n+   479, 523, 655, 737, 823, 380, 765, 161, 395, 398, 438, 451, 502, 516, 537, 583,\n+   791, 136, 340, 769, 122, 273, 446, 727, 305, 322, 400, 496, 771, 155, 190, 269,\n+   377, 391, 406, 432, 501, 519, 599, 684, 687, 749, 776, 175, 452, 191, 480, 510,\n+   659, 772, 805, 813, 397, 444, 619, 566, 568, 575, 491, 471, 707, 111, 636, 156,\n+   153, 288, 346, 578, 256, 435, 383, 729, 680, 767, 694, 295, 128, 210,   0,   0,\n+   227,   0, 379,   0,   0, 150, 493, 525, 544, 551, 552, 556, 783, 576, 604,   0,\n+   661,   0, 703,   0,   0, 735, 743,   0,   0,   0, 793, 794, 795, 808, 741, 773,\n+   118, 127, 130, 166, 169, 177, 207, 213, 215, 226, 229, 268, 270, 317, 327, 329,\n+   335, 369, 375, 381, 404, 441, 448, 458, 477, 484, 503, 539, 545, 547, 546, 548,\n+   549, 550, 554, 555, 561, 564, 569, 591, 593, 595, 598, 607, 620, 625, 625, 651,\n+   690, 695, 705, 706, 716, 717, 733, 735, 777, 786, 790, 315, 869, 623,   0,   0,\n+   102, 145, 134, 115, 129, 138, 165, 171, 207, 202, 206, 212, 227, 231, 240, 243,\n+   250, 254, 294, 296, 303, 308, 319, 325, 321, 329, 326, 335, 341, 357, 360, 362,\n+   370, 379, 388, 389, 393, 421, 424, 438, 456, 454, 458, 465, 477, 535, 485, 490,\n+   493, 507, 512, 514, 521, 522, 525, 526, 528, 533, 532, 541, 565, 569, 574, 586,\n+   591, 597, 607, 637, 647, 674, 691, 693, 695, 698, 703, 699, 705, 704, 702, 706,\n+   709, 717, 728, 736, 747, 754, 770, 777, 783, 784, 786, 787, 790, 802, 825, 848,\n+   847, 857,  55,  65,  66, 883, 892, 916, 822, 824,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1586,   0,1605,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1602,1603,1934,1935,1574,1575,\n+  1576,1577,1579,1580,1581,1583,1584,   0,1585,1587,1588,1589,1591,   0,1592,   0,\n+  1593,1594,   0,1595,1596,   0,1598,1599,1600,1601,1604,1582,1578,1590,1597,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1936,   0,1937,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1938,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1939,1940,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1941,1942,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1944,1943,   0,1945,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1946,1947,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1948,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1949,1950,\n+  1951,1952,1953,1954,1955,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1956,1957,1958,1960,1959,\n+  1961,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+   106, 104, 107, 826, 114, 118, 119, 121, 123, 124, 127, 125,  34, 830, 130, 131,\n+   132, 137, 827,  35, 133, 139, 829, 142, 143, 112, 144, 145, 924, 151, 152,  37,\n+   157, 158, 159, 160,  38, 165, 166, 169, 171, 172, 173, 174, 176, 177, 178, 179,\n+   181, 182, 182, 182, 833, 468, 184, 185, 834, 187, 188, 189, 196, 192, 194, 195,\n+   197, 199, 200, 201, 203, 204, 204, 206, 208, 209, 211, 218, 213, 219, 214, 216,\n+   153, 234, 221, 222, 223, 220, 225, 224, 230, 835, 235, 236, 237, 238, 239, 244,\n+   836, 837, 247, 248, 249, 246, 251,  39,  40, 253, 255, 255, 838, 257, 258, 259,\n+   261, 839, 262, 263, 301, 264,  41, 266, 270, 272, 271, 841, 274, 842, 277, 276,\n+   278, 281, 282,  42, 283, 284, 285, 286,  43, 843,  44, 289, 290, 291, 293, 934,\n+   298, 845, 845, 621, 300, 300,  45, 852, 894, 302, 304,  46, 306, 309, 310, 312,\n+   316,  48,  47, 317, 846, 318, 323, 324, 325, 324, 328, 329, 333, 331, 332, 334,\n+   335, 336, 338, 339, 342, 343, 347, 351, 849, 350, 348, 352, 354, 359, 850, 361,\n+   358, 356,  49, 363, 365, 367, 364,  50, 369, 371, 851, 376, 386, 378,  53, 381,\n+    52,  51, 140, 141, 387, 382, 614,  78, 388, 389, 390, 394, 392, 856,  54, 399,\n+   396, 402, 404, 858, 405, 401, 407,  55, 408, 409, 410, 413, 859, 415,  56, 417,\n+   860, 418,  57, 419, 422, 424, 425, 861, 840, 862, 426, 863, 429, 431, 427, 433,\n+   437, 441, 438, 439, 442, 443, 864, 436, 449, 450,  58, 454, 453, 865, 447, 460,\n+   866, 867, 461, 466, 465, 464,  59, 467, 470, 469, 472, 828, 475, 868, 478, 870,\n+   483, 485, 486, 871, 488, 489, 872, 873, 495, 497,  60, 498,  61,  61, 504, 505,\n+   507, 508, 511,  62, 513, 874, 515, 875, 518, 844, 520, 876, 877, 878,  63,  64,\n+   528, 880, 879, 881, 882, 530, 531, 531, 533,  66, 534,  67,  68, 884, 536, 538,\n+   541,  69, 885, 549, 886, 887, 556, 559,  70, 561, 562, 563, 888, 889, 889, 567,\n+    71, 890, 570, 571,  72, 891, 577,  73, 581, 579, 582, 893, 587,  74, 590, 592,\n+   596,  75, 895, 896,  76, 897, 600, 898, 602, 605, 607, 899, 900, 609, 901, 611,\n+   853,  77, 615, 616,  79, 617, 252, 902, 903, 854, 855, 621, 622, 731,  80, 627,\n+   626, 628, 164, 629, 630, 631, 633, 904, 632, 634, 639, 640, 635, 641, 646, 651,\n+   638, 643, 644, 645, 905, 907, 906,  81, 653, 654, 656, 911, 657, 908,  82,  83,\n+   909, 910,  84, 664, 665, 666, 667, 669, 668, 671, 670, 674, 672, 673, 675,  85,\n+   677, 678,  86, 681, 682, 912, 685, 686,  87, 689,  36, 913, 914,  88,  89, 696,\n+   702, 709, 711, 915, 712, 713, 718, 719, 917, 831, 721, 720, 723, 832, 725, 728,\n+   918, 919, 739, 742, 744, 920, 745, 753, 756, 757, 755, 760, 761, 921, 762,  90,\n+   764, 922,  91, 775, 279, 780, 923, 925,  92,  93, 785, 926,  94, 927, 787, 787,\n+   789, 928, 792,  95, 796, 797, 798, 800,  96, 929, 802, 804, 806,  97,  98, 807,\n+   930,  99, 931, 932, 933, 814, 100, 816, 817, 818, 819, 820, 821, 935,   0,   0,\n@@ -5557,1 +5649,1 @@\n-  return u<1114110u?_hb_ucd_u8[6504+(((_hb_ucd_u8[1264+(((_hb_ucd_u16[((_hb_ucd_u8[544+(((_hb_ucd_u8[u>>1>>3>>3>>4])<<4)+((u>>1>>3>>3)&15u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:2;\n+  return u<1114110u?_hb_ucd_u8[6664+(((_hb_ucd_u8[1296+(((_hb_ucd_u16[((_hb_ucd_u8[544+(((_hb_ucd_u8[u>>1>>3>>3>>4])<<4)+((u>>1>>3>>3)&15u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:2;\n@@ -5562,1 +5654,1 @@\n-  return u<125259u?_hb_ucd_u8[8768+(((_hb_ucd_u8[7792+(((_hb_ucd_u8[7120+(((_hb_ucd_u8[6874+(u>>2>>3>>4)])<<4)+((u>>2>>3)&15u))])<<3)+((u>>2)&7u))])<<2)+((u)&3u))]:0;\n+  return u<125259u?_hb_ucd_u8[8984+(((_hb_ucd_u8[7960+(((_hb_ucd_u8[7288+(((_hb_ucd_u8[7042+(u>>2>>3>>4)])<<4)+((u>>2>>3)&15u))])<<3)+((u>>2)&7u))])<<2)+((u)&3u))]:0;\n@@ -5572,1 +5664,1 @@\n-  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[9508+(((_hb_ucd_u8[9388+(((_hb_ucd_b4(9260+_hb_ucd_u8,u>>2>>3>>3))<<3)+((u>>2>>3)&7u))])<<3)+((u>>2)&7u))])<<2)+((u)&3u)]:0;\n+  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[9728+(((_hb_ucd_u8[9608+(((_hb_ucd_b4(9480+_hb_ucd_u8,u>>2>>3>>3))<<3)+((u>>2>>3)&7u))])<<3)+((u>>2)&7u))])<<2)+((u)&3u)]:0;\n@@ -5577,1 +5669,1 @@\n-  return u<918000u?_hb_ucd_u8[10974+(((_hb_ucd_u16[1960+(((_hb_ucd_u8[10286+(((_hb_ucd_u8[9836+(u>>3>>4>>4)])<<4)+((u>>3>>4)&15u))])<<4)+((u>>3)&15u))])<<3)+((u)&7u))]:2;\n+  return u<918000u?_hb_ucd_u8[11234+(((_hb_ucd_u16[2000+(((_hb_ucd_u8[10514+(((_hb_ucd_u8[10064+(u>>3>>4>>4)])<<4)+((u>>3>>4)&15u))])<<4)+((u>>3)&15u))])<<3)+((u)&7u))]:2;\n@@ -5582,1 +5674,1 @@\n-  return u<195102u?_hb_ucd_u16[5768+(((_hb_ucd_u8[16708+(((_hb_ucd_u8[16326+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:0;\n+  return u<195102u?_hb_ucd_u16[5888+(((_hb_ucd_u8[17136+(((_hb_ucd_u8[16754+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:0;\n@@ -5589,1 +5681,1 @@\n-_hb_ucd_u8[13344] =\n+_hb_ucd_u8[13602] =\n@@ -5591,17 +5683,34 @@\n-    0,  1,  2,  3,  4,  5,  5,  5,  5,  5,  6,  5,  5,  7,  8,  9,\n-   10, 11, 12, 13, 14, 15, 16,  5, 17, 15, 15, 18, 15, 19, 20, 21,\n-    5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5, 22, 23,\n-    5, 24, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-   25, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,\n-    8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n-    8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n+    0,  1,  2,  3,  4,  5,  6,  7,  7,  8,  7,  7,  7,  7,  7,  7,\n+    7,  7,  7,  7,  9, 10,  7,  7,  7,  7,  7, 11, 12, 12, 12, 13,\n+   14, 15, 16, 17, 18, 19, 20, 21, 22, 21, 21, 21, 21, 23,  7,  7,\n+    7, 24, 21, 21, 21, 25, 26, 27, 21, 28, 29, 30, 31, 32, 33, 34,\n+    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n+    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 35, 21, 36,\n+    7,  7, 37, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   38, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n+   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n+   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n+   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n+   12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n@@ -5616,1 +5725,0 @@\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n@@ -5618,2 +5726,0 @@\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n@@ -5622,1 +5728,0 @@\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n@@ -5624,16 +5729,9 @@\n-  100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,\n-  100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,\n-  100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,\n-  100,100, 34, 34, 34, 34,101,102, 34, 34,103,104,105,106,107,108,\n-   34, 34,109,110,111,112,113,114,115,116,117,111, 34, 34, 34,111,\n-  118,119,120,121,122,123,124,125, 34,126,127,111,128,129,130,131,\n-  132,133,134,135,136,137,138,111,139,140,111,141,142,143,144,111,\n-  145,146,147,148,149,150,111,111,151,152,153,154,111,155,111,156,\n-   34, 34, 34, 34, 34, 34, 34, 34,157, 34, 34,111,111,111,111,111,\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n-   34, 34, 34, 34, 34, 34, 34, 34,158,111,111,111,111,111,111,111,\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n-  111,111,111,111,111,111,111,111, 34, 34, 34, 34, 34,111,111,111,\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n+  100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,\n+  100,100, 34, 34, 34, 34,101,102, 34, 34,103,104,105,106,107,108,\n+   34, 34,109,110,111,112,113,114,115,116,117,118, 34, 34, 34,119,\n+  120,121,122,123,124,125,126,127, 34,128,129,111,130,131,132,133,\n+  134,135,136,137,138,139,140,111,141,142,111,143,144,145,146,111,\n+  147,148,149,150,151,152,111,111,153,154,155,156,111,157,111,158,\n+   34, 34, 34, 34, 34, 34, 34, 34,159, 34, 34,111,111,111,111,111,\n+  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,160,\n+   34, 34, 34, 34, 34, 34, 34, 34,161,111,111,111,111,111,111,111,\n@@ -5641,2 +5739,2 @@\n-   34, 34, 34, 34,159,160,161, 34,111,111,111,111,162,163,164,165,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+  111,111,111,111,111,111,111,111, 34, 34, 34, 34, 34,111,111,111,\n+   34, 34, 34, 34,162,163,164, 34,111,111,111,111,165,166,167,168,\n@@ -5644,0 +5742,1 @@\n+  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,119,\n@@ -5645,8 +5744,8 @@\n-  111,111,111,111,111,111,111,111, 34,166,111,111,111,111,111,111,\n-   67, 67,167,168,169,128, 65,111,170,171,172,173,174,175,176,177,\n-   67, 67, 67, 67,178,179,111,111,111,111,111,111,111,111,111,111,\n-  180,111,181,111,111,182,111,111,111,111,111,111,111,111,111,111,\n-   34,183,184,111,111,111,111,111,128,185,186,111, 34,187,111,111,\n-   67, 67,188, 67, 67,111, 67,189, 67, 67, 67, 67, 67, 67, 67, 67,\n-   67, 67, 67, 67, 67, 67, 67,190,111,111,111,111,111,111,111,111,\n-   34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n+  111,111,111,111,111,111,111,111, 34,169,111,111,111,111,111,111,\n+  111,111,111,111,111,111,111,111,111,111,111,111,111,111,170, 67,\n+   67, 67,171,172,173,130, 65,111,174,175,176,177,178,179,180,181,\n+   67, 67, 67, 67,182,183,111,111,111,111,111,111,111,111,184,111,\n+  185,111,186,111,111,187,111,111,111,111,111,111,111,111,111, 34,\n+   34,188,189,111,111,111,111,111,130,190,191,111, 34,192,111,111,\n+   67, 67,193, 67, 67,111, 67,194, 67, 67, 67, 67, 67, 67, 67, 67,\n+   67, 67, 67, 67, 67, 67, 67,195,111,111,111,111,111,111,111,111,\n@@ -5654,1 +5753,0 @@\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n@@ -5657,3 +5755,1 @@\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n-  191,111,180,180,111,111,111,111,111,111,111,111,111,111,111,111,\n-  111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,\n+  196,111,185,185,111,111,111,111,111,111,111,111,111,111,111,111,\n@@ -5685,5 +5781,5 @@\n-   43, 43, 43, 43, 43, 57, 59,  2, 62, 36, 36, 36, 36, 63, 43, 43,\n-    7,  7,  7,  7,  7,  2,  2, 36, 64, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 65, 43, 43, 43, 66, 47, 43, 43, 67, 68, 69, 43, 43, 36,\n-    7,  7,  7,  7,  7, 36, 70, 71,  2,  2,  2,  2,  2,  2,  2, 72,\n-   63, 36, 36, 36, 36, 36, 36, 36, 43, 43, 43, 43, 43, 43, 64, 36,\n+   43, 43, 43, 43, 43, 57, 62,  2, 63, 36, 36, 36, 36, 64, 43, 43,\n+    7,  7,  7,  7,  7,  2,  2, 36, 65, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 66, 43, 43, 43, 67, 47, 43, 43, 68, 69, 70, 43, 43, 36,\n+    7,  7,  7,  7,  7, 36, 71, 72,  2,  2,  2,  2,  2,  2,  2, 73,\n+   64, 36, 36, 36, 36, 36, 36, 36, 43, 43, 43, 43, 43, 43, 65, 36,\n@@ -5691,9 +5787,10 @@\n-   36, 36, 36, 36, 36, 63, 43, 43, 43, 43, 40, 21,  2, 40, 68, 20,\n-   36, 36, 36, 43, 43, 68, 43, 43, 43, 43, 68, 43, 68, 43, 43, 43,\n-    2,  2,  2,  2,  2,  2,  2,  2, 36, 36, 36, 36, 63, 43, 43,  2,\n-   36, 63, 43, 43, 43, 43, 43, 43, 43, 73, 43, 43, 43, 43, 43, 43,\n-   43, 74, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 74, 64, 75,\n-   76, 43, 43, 43, 74, 75, 76, 75, 63, 43, 43, 43, 36, 36, 36, 36,\n-   36, 43,  2,  7,  7,  7,  7,  7, 77, 36, 36, 36, 36, 36, 36, 36,\n-   63, 75, 78, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 64, 75,\n-   76, 43, 43, 74, 75, 75, 76, 36, 36, 36, 36, 79, 75, 75, 36, 36,\n+   36, 36, 36, 36, 36, 64, 43, 43, 43, 43, 40, 21,  2, 40, 69, 20,\n+   36, 36, 36, 43, 43, 69, 43, 43, 43, 43, 69, 43, 69, 43, 43, 43,\n+    2,  2,  2,  2,  2,  2,  2,  2, 36, 36, 36, 36, 64, 43, 43,  2,\n+   36, 36, 36, 36, 74, 36, 36, 36, 59, 59, 59, 59, 43, 43, 43, 43,\n+   36, 36, 36, 36, 75, 43, 43, 43, 43, 76, 43, 43, 43, 43, 43, 43,\n+   43, 77, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 77, 65, 78,\n+   79, 43, 43, 43, 77, 78, 79, 78, 64, 43, 43, 43, 36, 36, 36, 36,\n+   36, 43,  2,  7,  7,  7,  7,  7, 80, 36, 36, 36, 36, 36, 36, 36,\n+   64, 78, 81, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 65, 78,\n+   79, 43, 43, 77, 78, 78, 79, 36, 36, 36, 36, 82, 78, 78, 36, 36,\n@@ -5701,20 +5798,20 @@\n-   43, 74, 78, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 43, 75,\n-   76, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 64, 36, 36, 36,\n-   36, 36, 36,  7,  7,  7,  7,  7, 43, 36, 63,  2,  2,  2,  2,  2,\n-   76, 43, 43, 43, 74, 75, 76, 43, 60, 20, 20, 20, 80, 43, 43, 43,\n-   43, 75, 78, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 64, 76,\n-   76, 43, 43, 74, 75, 75, 76, 43, 43, 43, 43, 74, 75, 75, 36, 36,\n-   71, 27, 27, 27, 27, 27, 27, 27, 43, 64, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 75, 74, 75, 75, 75, 75, 75, 76, 43,\n-   36, 36, 36, 79, 75, 75, 75, 75, 75, 75, 75,  7,  7,  7,  7,  7,\n-   27, 81, 61, 61, 53, 61, 61, 61, 74, 75, 64, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36, 43, 74, 75, 75, 43, 43, 43, 43, 43,\n-   43, 43, 43, 43, 36, 36, 36, 36,  7,  7,  7, 82, 27, 27, 27, 81,\n-   63, 75, 65, 36, 36, 36, 36, 36, 75, 75, 75, 74, 75, 75, 43, 43,\n-   43, 43, 74, 75, 75, 75, 75, 36, 83, 36, 36, 36, 36, 36, 36, 36,\n-   43, 75, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 63, 64, 75,\n-   76, 43, 43, 75, 75, 75, 76, 70, 61, 61, 36, 79, 27, 27, 27, 84,\n-   27, 27, 27, 27, 81, 36, 36, 36, 36, 36, 36, 36, 36, 43, 43, 74,\n-   75, 43, 43, 43, 75, 75, 75, 75,  7, 75,  2,  2,  2,  2,  2,  2,\n-   63, 36, 43, 43, 43, 43, 43, 85, 36, 36, 36, 68, 43, 43, 43, 57,\n-    7,  7,  7,  7,  7,  2,  2,  2, 63, 36, 43, 43, 43, 43, 64, 36,\n+   43, 77, 81, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 43, 78,\n+   79, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 65, 36, 36, 36,\n+   36, 36, 36,  7,  7,  7,  7,  7, 43, 36, 64,  2,  2,  2,  2,  2,\n+   79, 43, 43, 43, 77, 78, 79, 43, 60, 20, 20, 20, 83, 43, 43, 43,\n+   43, 78, 81, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 65, 79,\n+   79, 43, 43, 77, 78, 78, 79, 43, 43, 43, 43, 77, 78, 78, 36, 36,\n+   72, 27, 27, 27, 27, 27, 27, 27, 43, 65, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 36, 78, 77, 78, 78, 78, 78, 78, 79, 43,\n+   36, 36, 36, 82, 78, 78, 78, 78, 78, 78, 78,  7,  7,  7,  7,  7,\n+   27, 84, 61, 61, 53, 61, 61, 61, 77, 78, 65, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 65, 43, 77, 78, 78, 43, 43, 43, 43, 43,\n+   43, 43, 43, 43, 36, 36, 36, 36,  7,  7,  7, 85, 27, 27, 27, 84,\n+   64, 78, 66, 36, 36, 36, 36, 36, 78, 78, 78, 77, 78, 78, 43, 43,\n+   43, 43, 77, 78, 78, 78, 81, 36, 86, 36, 36, 36, 36, 36, 36, 36,\n+   43, 78, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 64, 65, 78,\n+   79, 43, 43, 78, 78, 78, 79, 71, 61, 61, 36, 82, 27, 27, 27, 87,\n+   27, 27, 27, 27, 84, 36, 36, 36, 36, 36, 36, 36, 36, 43, 43, 77,\n+   78, 43, 43, 43, 78, 78, 78, 78,  7, 78,  2,  2,  2,  2,  2,  2,\n+   64, 36, 43, 43, 43, 43, 43, 88, 36, 36, 36, 69, 43, 43, 43, 57,\n+    7,  7,  7,  7,  7,  2,  2,  2, 64, 36, 43, 43, 43, 43, 65, 36,\n@@ -5722,10 +5819,10 @@\n-   70, 61,  2,  2,  2,  2,  2,  2,  2, 86, 86, 61, 43, 61, 61, 61,\n-    7,  7,  7,  7,  7, 27, 27, 27, 27, 27, 47, 47, 47,  4,  4, 75,\n-   63, 43, 43, 43, 43, 43, 43, 74, 43, 43, 57, 43, 36, 36, 63, 43,\n-   43, 43, 43, 43, 43, 43, 43, 61, 61, 61, 61, 69, 61, 61, 61, 61,\n-    2,  2, 86, 61, 21,  2,  2,  2, 36, 36, 36, 36, 36, 79, 76, 43,\n-   74, 43, 43, 43, 76, 74, 76, 64, 36, 36, 36, 75, 43, 36, 36, 43,\n-   64, 75, 78, 79, 75, 75, 75, 36, 63, 43, 64, 36, 36, 36, 36, 36,\n-   36, 74, 76, 74, 75, 75, 76, 79,  7,  7,  7,  7,  7, 75, 76, 61,\n-   16, 16, 16, 16, 16, 50, 44, 16, 36, 36, 36, 36, 36, 36, 63, 43,\n-    2,  2,  2,  2, 87, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n+   71, 61,  2,  2,  2,  2,  2,  2,  2, 89, 89, 61, 43, 61, 61, 61,\n+    7,  7,  7,  7,  7, 27, 27, 27, 27, 27, 47, 47, 47,  4,  4, 78,\n+   64, 43, 43, 43, 43, 43, 43, 77, 43, 43, 57, 43, 36, 36, 64, 43,\n+   43, 43, 43, 43, 43, 43, 43, 61, 61, 61, 61, 70, 61, 61, 61, 61,\n+    2,  2, 89, 61, 21,  2,  2,  2, 36, 36, 36, 36, 36, 82, 79, 43,\n+   77, 43, 43, 43, 79, 77, 79, 65, 36, 36, 36, 78, 43, 36, 36, 43,\n+   65, 78, 81, 82, 78, 78, 78, 36, 64, 43, 65, 36, 36, 36, 36, 36,\n+   36, 77, 79, 77, 78, 78, 79, 82,  7,  7,  7,  7,  7, 78, 79, 61,\n+   16, 16, 16, 16, 16, 50, 44, 16, 36, 36, 36, 36, 36, 36, 64, 43,\n+    2,  2,  2,  2, 90, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,\n@@ -5733,60 +5830,61 @@\n-   88, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 70, 65,\n-   89, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 90, 91, 91,\n-   36, 36, 36, 36, 36, 58,  2, 92, 93, 36, 36, 36, 36, 36, 36, 36,\n-   36, 43, 43, 43, 43, 43, 43, 43, 36, 43, 57,  2,  2,  2,  2,  2,\n-   36, 36, 43, 76, 43, 43, 43, 75, 75, 75, 75, 74, 76, 43, 43, 43,\n-   43, 43,  2, 77,  2, 60, 63, 43,  7,  7,  7,  7,  7,  7,  7,  7,\n-    2,  2,  2, 94,  2, 56, 43, 59, 36, 95, 36, 36, 36, 36, 36, 36,\n-   36, 36, 63, 64, 36, 36, 36, 36, 36, 36, 36, 36, 63, 36, 36, 36,\n-   43, 74, 75, 76, 74, 75, 75, 75, 75, 74, 75, 75, 76, 43, 43, 43,\n-   61, 61,  2,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 27, 27, 61,\n-   36, 36, 36, 63, 74, 76, 43,  2, 36, 36, 79, 74, 43, 43, 43, 43,\n-   74, 74, 76, 43, 43, 43, 74, 75, 75, 76, 43, 43, 43, 43, 43, 43,\n-    2,  2,  2, 77,  2,  2,  2,  2, 43, 43, 43, 43, 43, 43, 43, 96,\n-   43, 43, 78, 36, 36, 36, 36, 36, 36, 36, 74, 43, 43, 74, 74, 75,\n-   75, 74, 78, 36, 36, 36, 36, 36, 86, 61, 61, 61, 61, 47, 43, 43,\n-   43, 43, 61, 61, 61, 61, 61, 61, 43, 78, 36, 36, 36, 36, 36, 36,\n-   79, 43, 43, 75, 43, 76, 43, 36, 36, 36, 36, 74, 43, 75, 76, 76,\n-   43, 75, 75, 75, 75, 75,  2,  2, 36, 36, 75, 75, 75, 75, 43, 43,\n-   43, 43, 75, 43, 43, 57,  2,  2,  7,  7,  7,  7,  7,  7, 83, 36,\n-   36, 36, 36, 36, 40, 40, 40,  2, 43, 57, 43, 43, 43, 43, 43, 43,\n-   74, 43, 43, 43, 64, 36, 63, 36, 36, 36, 64, 79, 43, 36, 36, 36,\n-   16, 16, 16, 16, 16, 16, 40, 40, 40, 40, 40, 40, 40, 44, 16, 16,\n-   16, 16, 16, 16, 44, 16, 16, 16, 16, 16, 16, 16, 16, 97, 40, 40,\n-   32, 32, 32, 16, 16, 16, 16, 32, 16, 16, 16, 16, 11, 11, 11, 11,\n-   16, 16, 16, 16, 34, 11, 11, 11, 16, 16, 16, 16, 98, 98, 98, 98,\n-   16, 16, 16, 16, 11, 11, 99,100, 41, 16, 16, 16, 11, 11, 99, 41,\n-   16, 16, 16, 16, 11, 11,101, 41,102,102,102,102,102,103, 59, 59,\n-   51, 51, 51,  2,104,105,104,105,  2,  2,  2,  2,106, 59, 59,107,\n-    2,  2,  2,  2,108,109,  2,110,111,  2,112,113,  2,  2,  2,  2,\n-    2,  9,111,  2,  2,  2,  2,114, 59, 59, 59, 59, 59, 59, 59, 59,\n-  115, 40, 27, 27, 27,  8,112,116, 27, 27, 27, 27, 27,  8,112, 91,\n-   20, 20, 20, 20, 20, 20, 20, 20, 43, 43, 43, 43, 43, 43,117, 48,\n-   96, 48, 96, 43, 43, 43, 43, 43, 61,118, 61,119, 61, 34, 11, 16,\n-   11, 32,119, 61, 46, 11, 11, 61, 61, 61,118,118,118, 11, 11,120,\n-   11, 11, 35, 36, 39, 61, 16, 11,  8,  8, 46, 16, 16, 26, 61,121,\n-   92, 92, 92, 92, 92, 92, 92, 92, 92,122,123, 92,124, 61, 61, 61,\n-    8,  8,125, 61, 61,  8, 61, 61,125, 26, 61,125, 61, 61, 61,125,\n-   61, 61, 61, 61, 61, 61, 61,  8, 61,125,125, 61, 61, 61, 61, 61,\n-   61, 61,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,\n-   61, 61, 61, 61,  4,  4, 61, 61,  8, 61, 61, 61,126,127, 61, 61,\n-   61, 61, 61, 61, 61, 61,125, 61, 61, 61, 61, 61, 61, 26,  8,  8,\n-    8,  8, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  8,  8,\n-    8, 61, 61, 61, 61, 61, 61, 61, 27, 27, 27, 27, 27, 27, 61, 61,\n-   61, 61, 61, 61, 61, 27, 27, 27, 61, 61, 61, 26, 61, 61, 61, 61,\n-   26, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61,  8,  8,  8,  8,\n-   61, 61, 61, 61, 61, 61, 61, 26, 61, 61, 61, 61,  4,  4,  4,  4,\n-    4,  4,  4, 27, 27, 27, 27, 27, 27, 27, 61, 61, 61, 61, 61, 61,\n-    8,  8,112,128,  8,  8,  8,  8,  8,  8,  8,  4,  4,  4,  4,  4,\n-    8,112,129,129,129,129,129,129,129,129,129,129,128,  8,  8,  8,\n-    8,  8,  8,  8,  4,  4,  8,  8,  8,  8,  8,  8,  8,  8,  4,  8,\n-    8,  8,125, 26,  8,  8,125, 61, 32, 11, 32, 34, 34, 34, 34, 11,\n-   32, 32, 34, 16, 16, 16, 40, 11, 32, 32,121, 61, 61,119, 34,130,\n-   43, 32, 16, 16, 50,  2, 87,  2, 36, 36, 36, 36, 36, 36, 36, 95,\n-    2,  2,  2,  2,  2,  2,  2, 56,  2,104,104,  2,108,109,104,  2,\n-    2,  2,  2,  6,  2, 94,104,  2,104,  4,  4,  4,  4,  2,  2, 77,\n-    2,  2,  2,  2,  2, 51,  2,  2, 94,131,  2,  2,  2,  2,  2,  2,\n-   61,  2,  2,  2,  2,  2,  2,  2,  1,  2,132,133,  4,  4,  4,  4,\n-    4, 61,  4,  4,  4,  4,134, 91,135, 92, 92, 92, 92, 43, 43, 75,\n-  136, 40, 40, 61, 92,137, 58, 61, 71, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 63,138,139, 62, 36, 36, 36, 36, 36, 58, 40, 62,\n+   91, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 71, 66,\n+   92, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 93, 94, 94,\n+   36, 36, 36, 36, 36, 58,  2, 95, 96, 36, 36, 36, 36, 36, 36, 36,\n+   36, 43, 77, 78, 78, 78, 78, 81, 36, 43, 97,  2,  2,  2,  2,  2,\n+   36, 43, 43, 43, 43, 43, 43, 43, 36, 36, 43, 79, 43, 43, 43, 78,\n+   78, 78, 78, 77, 79, 43, 43, 43, 43, 43,  2, 80,  2, 60, 64, 43,\n+    7,  7,  7,  7,  7,  7,  7,  7,  2,  2,  2, 98,  2, 56, 43, 76,\n+   36, 75, 36, 36, 36, 36, 36, 36, 36, 36, 64, 65, 36, 36, 36, 36,\n+   36, 36, 36, 36, 64, 36, 36, 36, 43, 77, 78, 79, 77, 78, 78, 78,\n+   78, 77, 78, 78, 79, 43, 43, 43, 61, 61,  2,  7,  7,  7,  7,  7,\n+    7,  7,  7,  7,  7, 27, 27, 61, 36, 36, 36, 64, 77, 79, 43,  2,\n+   36, 36, 82, 77, 43, 43, 43, 43, 77, 77, 79, 43, 43, 43, 77, 78,\n+   78, 79, 43, 43, 43, 43, 43, 43,  2,  2,  2, 80,  2,  2,  2,  2,\n+   43, 43, 43, 43, 43, 43, 43, 99, 43, 43, 81, 36, 36, 36, 36, 36,\n+   36, 36, 77, 43, 43, 77, 77, 78, 78, 77, 81, 36, 36, 36, 36, 36,\n+   89, 61, 61, 61, 61, 47, 43, 43, 43, 43, 61, 61, 61, 61, 21,  2,\n+   43, 81, 36, 36, 36, 36, 36, 36, 82, 43, 43, 78, 43, 79, 43, 36,\n+   36, 36, 36, 77, 43, 78, 79, 79, 43, 78, 78, 78, 78, 78,  2,  2,\n+   36, 36, 78, 78, 78, 78, 43, 43, 43, 43, 78, 43, 43, 57,  2,  2,\n+    7,  7,  7,  7,  7,  7, 86, 36, 36, 36, 36, 36, 40, 40, 40,  2,\n+   43, 57, 43, 43, 43, 43, 43, 43, 77, 43, 43, 43, 65, 36, 64, 36,\n+   36, 36, 65, 82, 43, 36, 36, 36, 16, 16, 16, 16, 16, 16, 40, 40,\n+   40, 40, 40, 40, 40, 44, 16, 16, 16, 16, 16, 16, 44, 16, 16, 16,\n+   16, 16, 16, 16, 16,100, 40, 40, 32, 32, 32, 16, 16, 16, 16, 32,\n+   16, 16, 16, 16, 11, 11, 11, 11, 16, 16, 16, 16, 34, 11, 11, 11,\n+   16, 16, 16, 16,101,101,101,101, 16, 16, 16, 16, 11, 11,102,103,\n+   41, 16, 16, 16, 11, 11,102, 41, 16, 16, 16, 16, 11, 11,104, 41,\n+  105,105,105,105,105,106, 59, 59, 51, 51, 51,  2,107,108,107,108,\n+    2,  2,  2,  2,109, 59, 59,110,  2,  2,  2,  2,111,112,  2,113,\n+  114,  2,115,116,  2,  2,  2,  2,  2,  9,114,  2,  2,  2,  2,117,\n+   59, 59, 59, 59, 59, 59, 59, 59,118, 40, 27, 27, 27,  8,115,119,\n+   27, 27, 27, 27, 27,  8,115, 94, 20, 20, 20, 20, 20, 20, 20, 20,\n+   43, 43, 43, 43, 43, 43,120, 48, 99, 48, 99, 43, 43, 43, 43, 43,\n+   61,121, 61,122, 61, 34, 11, 16, 11, 32,122, 61, 46, 11, 11, 61,\n+   61, 61,121,121,121, 11, 11,123, 11, 11, 35, 36, 39, 61, 16, 11,\n+    8,  8, 46, 16, 16, 26, 61,124, 95, 95, 95, 95, 95, 95, 95, 95,\n+   95,125,126, 95,127, 61, 61, 61,  8,  8,128, 61, 61,  8, 61, 61,\n+  128, 26, 61,128, 61, 61, 61,128, 61, 61, 61, 61, 61, 61, 61,  8,\n+   61,128,128, 61, 61, 61, 61, 61, 61, 61,  8,  8,  8,  8,  8,  8,\n+    8,  8,  8,  8,  8,  8,  8,  8, 61, 61, 61, 61,  4,  4, 61, 61,\n+    8, 61, 61, 61,129,130, 61, 61, 61, 61, 61, 61, 61, 61,128, 61,\n+   61, 61, 61, 61, 61, 26,  8,  8,  8,  8, 61, 61, 61, 61, 61, 61,\n+   61, 61, 61, 61, 61, 61,  8,  8,  8, 61, 61, 61, 61, 61, 61, 61,\n+   27, 27, 27, 27, 27, 27, 61, 61, 61, 61, 61, 61, 61, 27, 27, 27,\n+   61, 61, 61, 26, 61, 61, 61, 61, 26, 61, 61, 61, 61, 61, 61, 61,\n+   61, 61, 61, 61,  8,  8,  8,  8, 61, 61, 61, 61, 61, 61, 61, 26,\n+   61, 61, 61, 61,  4,  4,  4,  4,  4,  4,  4, 27, 27, 27, 27, 27,\n+   27, 27, 61, 61, 61, 61, 61, 61,  8,  8,115,131,  8,  8,  8,  8,\n+    8,  8,  8,  4,  4,  4,  4,  4,  8,115,132,132,132,132,132,132,\n+  132,132,132,132,131,  8,  8,  8,  8,  8,  8,  8,  4,  4,  8,  8,\n+    8,  8,  8,  8,  8,  8,  4,  8,  8,  8,128, 26,  8,  8,128, 61,\n+   32, 11, 32, 34, 34, 34, 34, 11, 32, 32, 34, 16, 16, 16, 40, 11,\n+   32, 32,124, 61, 61,122, 34,133, 43, 32, 16, 16, 50,  2, 90,  2,\n+   36, 36, 36, 36, 36, 36, 36, 75,  2,  2,  2,  2,  2,  2,  2, 56,\n+    2,107,107,  2,111,112,107,  2,  2,  2,  2,  6,  2, 98,107,  2,\n+  107,  4,  4,  4,  4,  2,  2, 80,  2,  2,  2,  2,  2, 51,  2,  2,\n+   98,134,  2,  2,  2,  2,  2,  2, 61,  2,135,132,132,132,136, 51,\n+   51, 51, 51, 51, 51, 51, 51, 51,  1,  2,137,138,  4,  4,  4,  4,\n+    4, 61,  4,  4,  4,  4,139, 94,140, 95, 95, 95, 95, 43, 43, 78,\n+  141, 40, 40, 61, 95,142, 58, 61, 72, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 64,143,144, 63, 36, 36, 36, 36, 36, 58, 40, 63,\n@@ -5794,5 +5892,5 @@\n-   61, 61, 61, 61, 27, 27, 27, 27,140, 27, 27, 27, 27, 27, 27, 27,\n-   36, 36, 95, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,141,  2,\n-   32, 32, 32, 32, 32, 32, 32, 63, 48,142, 43, 43, 43, 43, 43, 77,\n-   32, 32, 32, 32, 32, 32, 40, 43, 36, 36, 36, 92, 92, 92, 92, 92,\n-   43,  2,  2,  2,  2,  2,  2,  2, 41, 41, 41,139, 40, 40, 40, 40,\n+   61, 61, 61, 61, 27, 27, 27, 27,145, 27, 27, 27, 27, 27, 27, 27,\n+   36, 36, 75, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,146,  2,\n+   32, 32, 32, 32, 32, 32, 32, 64, 48,147, 43, 43, 43, 43, 43, 80,\n+   32, 32, 32, 32, 32, 32, 40, 43, 36, 36, 36, 95, 95, 95, 95, 95,\n+   43,  2,  2,  2,  2,  2,  2,  2, 41, 41, 41,144, 40, 40, 40, 40,\n@@ -5800,1 +5898,1 @@\n-   44, 16, 16, 16, 34, 34, 34, 32, 32, 32, 32, 32, 42,143, 34, 35,\n+   44, 16, 16, 16, 34, 34, 34, 32, 32, 32, 32, 32, 42,148, 34, 35,\n@@ -5802,38 +5900,39 @@\n-   11, 11, 32, 32, 32, 32, 32, 32, 16, 32, 11, 11, 34, 16, 16, 16,\n-   16, 16, 34, 35, 40, 35, 36, 36, 36, 64, 36, 64, 36, 63, 36, 36,\n-   36, 79, 76, 74, 61, 61, 43, 43, 27, 27, 27, 61,144, 61, 61, 61,\n-   36, 36,  2,  2,  2,  2,  2,  2, 75, 36, 36, 36, 36, 36, 36, 36,\n-   36, 36, 75, 75, 75, 75, 75, 75, 75, 75, 43, 43, 43, 43, 43,  2,\n-   43, 36, 36, 36,  2, 65, 65, 63, 36, 36, 36, 43, 43, 43, 43,  2,\n-   36, 36, 36, 63, 43, 43, 43, 43, 43, 75, 75, 75, 75, 75, 75,145,\n-   36, 63, 75, 43, 43, 75, 43, 75,145,  2,  2,  2,  2,  2,  2, 77,\n-    7,  7,  7,  7,  7,  7,  7,  2, 36, 36, 63, 62, 36, 36, 36, 36,\n-   36, 36, 36, 36, 63, 43, 43, 74, 76, 74, 76, 43, 43, 43, 43, 43,\n-   36, 63, 36, 36, 36, 36, 74, 75,  7,  7,  7,  7,  7,  7,  2,  2,\n-   62, 36, 36, 70, 61, 79, 74, 36, 64, 43, 64, 63, 64, 36, 36, 43,\n-   36, 36, 36, 36, 36, 36, 95,  2, 36, 36, 36, 36, 36, 79, 43, 75,\n-    2, 95,146, 43, 43, 43, 43, 43, 16, 16, 16, 16, 16,100, 40, 40,\n-   16, 16, 16, 16, 97, 41, 41, 41, 36, 79, 76, 75, 74,145, 76, 43,\n-  147,147,147,147,147,147,147,147,148,148,148,148,148,148,148,148,\n-   16, 16, 16, 16, 16, 16, 35, 64, 36, 36, 36, 36,149, 36, 36, 36,\n-   36, 41, 41, 41, 41, 41, 41, 41, 41,150, 36, 36, 36, 36, 36, 36,\n-   36, 36, 36, 36, 36, 36, 36,129,151,151,151,151,151,151,151,151,\n-   36, 36, 36, 36, 36, 36,144, 61,  2,  2,  2,152,113,  2,  2,  2,\n-    6,153,154,129,129,129,129,129,129,129,113,152,113,  2,110,155,\n-    2,  2,  2,  2,134,129,129,113,  2,156,  8,  8, 60,  2,  2,  2,\n-   36, 36, 36, 36, 36, 36, 36,157,  2,  2,  3,  2,  4,  5,  6,  2,\n-   16, 16, 16, 16, 16, 17, 18,112,113,  4,  2, 36, 36, 36, 36, 36,\n-   62, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 40,\n-   20,158, 53, 20, 26,  8,125, 61, 61, 61, 61, 61,159, 59, 61, 61,\n-    2,  2,  2, 87, 27, 27, 27, 27, 27, 27, 27, 81, 61, 61, 61, 61,\n-   92, 92,124, 27, 81, 61, 61, 61, 61, 61, 61, 61, 61, 27, 61, 61,\n-   61, 61, 61, 61, 61, 61, 47, 43,160,160,160,160,160,160,160,160,\n-  161, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 84, 36,\n-  133, 36, 36, 36, 36, 92, 92, 92, 36, 36, 36, 36, 36, 36, 36, 58,\n-  162, 92, 92, 92, 92, 92, 92, 92, 36, 36, 36, 58, 27, 27, 27, 27,\n-   36, 36, 36, 70,140, 27, 27, 27, 36, 36, 36,163, 27, 27, 27, 27,\n-   36, 36, 36, 36, 36,163, 27, 27, 36, 36, 36, 27, 27, 27, 27, 30,\n-   36, 36, 36, 36, 36, 36, 27, 36, 63, 43, 43, 43, 43, 43, 43, 43,\n-   36, 36, 36, 36, 43, 43, 43, 43, 36, 36, 36, 36, 36, 36,163, 30,\n-   36, 36, 36, 36, 36, 36,163, 27, 36, 36, 36, 36, 71, 36, 36, 36,\n-   36, 36, 63, 43, 43,161, 27, 27, 36, 36, 36, 36, 58,  2,  2,  2,\n+   11, 11, 32, 32, 32, 32, 32, 32, 32, 32, 11, 11, 34, 16, 16, 16,\n+   32, 16, 16, 32, 32, 16, 16, 16, 16, 40,149, 35, 40, 35, 36, 36,\n+   36, 65, 36, 65, 36, 64, 36, 36, 36, 82, 79, 77, 61, 61, 43, 43,\n+   27, 27, 27, 61,150, 61, 61, 61, 36, 36,  2,  2,  2,  2,  2,  2,\n+   78, 36, 36, 36, 36, 36, 36, 36, 36, 36, 78, 78, 78, 78, 78, 78,\n+   78, 78, 43, 43, 43, 43, 43,  2, 43, 36, 36, 36,  2, 66, 66, 64,\n+   36, 36, 36, 43, 43, 43, 43,  2, 36, 36, 36, 64, 43, 43, 43, 43,\n+   43, 78, 78, 78, 78, 78, 78, 97, 36, 64, 78, 43, 43, 78, 43, 78,\n+   97,  2,  2,  2,  2,  2,  2, 80,  7,  7,  7,  7,  7,  7,  7,  2,\n+   36, 36, 64, 63, 36, 36, 36, 36, 36, 36, 36, 36, 64, 43, 43, 77,\n+   79, 77, 79, 43, 43, 43, 43, 43, 36, 64, 36, 36, 36, 36, 77, 78,\n+    7,  7,  7,  7,  7,  7,  2,  2, 63, 36, 36, 71, 61, 82, 77, 36,\n+   65, 43, 65, 64, 65, 36, 36, 43, 36, 36, 36, 36, 36, 36, 75,  2,\n+   36, 36, 36, 36, 36, 82, 43, 78,  2, 75,151, 43, 43, 43, 43, 43,\n+   16, 16, 16, 16, 16,103, 40, 40, 16, 16, 16, 16,100, 41, 41, 41,\n+   36, 82, 79, 78, 77, 97, 79, 43,152,152,152,152,152,152,152,152,\n+  153,153,153,153,153,153,153,153, 16, 16, 16, 16, 16, 16, 35, 65,\n+   36, 36, 36, 36,154, 36, 36, 36, 36, 41, 41, 41, 41, 41, 41, 41,\n+   41, 74, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,132,\n+   36, 36, 36, 36, 36, 36, 36, 71, 36, 36, 36, 36, 36, 36,150, 61,\n+    2,  2,  2,135,116,  2,  2,  2,  6,155,156,132,132,132,132,132,\n+  132,132,116,135,116,  2,113,157,  2,  2,  2,  2,139,132,132,116,\n+    2,158,  8,  8, 60,  2,  2,  2, 36, 36, 36, 36, 36, 36, 36,159,\n+    2,  2,  3,  2,  4,  5,  6,  2, 16, 16, 16, 16, 16, 17, 18,115,\n+  116,  4,  2, 36, 36, 36, 36, 36, 63, 36, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 36, 40, 20,160, 53, 20, 26,  8,128, 61,\n+   61, 61, 61, 61,161, 59, 61, 61,  2,  2,  2, 90, 27, 27, 27, 27,\n+   27, 27, 27, 84, 61, 61, 61, 61, 95, 95,127, 27, 84, 61, 61, 61,\n+   61, 61, 61, 61, 61, 27, 61, 61, 61, 61, 61, 61, 61, 61, 47, 43,\n+  162,162,162,162,162,162,162,162,163, 27, 27, 27, 27, 27, 27, 27,\n+   27, 27, 27, 27, 27, 27, 87, 36,138, 36, 36, 36, 36, 95, 95, 95,\n+   36, 36, 36, 36, 36, 36, 36, 58,164, 95, 95, 95, 95, 95, 95, 95,\n+   11, 11, 11, 32, 16, 16, 16, 16, 36, 36, 36, 58, 27, 27, 27, 27,\n+   36, 36, 36, 71,145, 27, 27, 27, 36, 36, 36,165, 27, 27, 27, 27,\n+   36, 36, 36, 36, 36,165, 27, 27, 36, 36, 36, 27, 27, 27, 27, 30,\n+   36, 36, 36, 36, 36, 36, 27, 36, 64, 43, 43, 43, 43, 43, 43, 43,\n+   36, 36, 36, 36, 43, 43, 43, 43, 36, 36, 36, 36, 36, 36,165, 30,\n+   36, 36, 36, 36, 36, 36,165, 27, 36, 36, 36, 36, 72, 36, 36, 36,\n+   36, 36, 64, 43, 43,163, 27, 27, 36, 36, 36, 36, 58,  2,  2,  2,\n@@ -5841,207 +5940,212 @@\n-   36, 36, 43, 43, 43, 43, 43, 43, 36, 36, 36, 36, 36, 63,164, 51,\n-   27, 27, 27, 84, 36, 36, 36, 36,161, 27, 30,  2,  2,  2,  2,  2,\n-   36, 36,163, 27, 27, 27, 27, 27, 76, 78, 36, 36, 36, 36, 36, 36,\n-   43, 43, 43, 57,  2,  2,  2,  2,  2, 27, 27, 27, 27, 27, 27, 27,\n-   27, 27, 27,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,165,\n-   75, 76, 43, 74, 76, 57, 72,  2,  2,  2,  2,  2,  2,  2, 72, 59,\n-   36, 36, 36, 63, 43, 43, 76, 43, 43, 43, 43,  7,  7,  7,  7,  7,\n-    2,  2, 79, 78, 36, 36, 36, 36, 36, 63,  2, 36, 36, 36, 36, 36,\n-   36, 79, 75, 43, 43, 43, 43, 74, 78, 36, 58,  2, 56, 43, 57, 76,\n-    7,  7,  7,  7,  7, 58, 58,  2, 87, 27, 27, 27, 27, 27, 27, 27,\n-   36, 36, 36, 36, 36, 36, 75, 76, 43, 75, 74, 43,  2,  2,  2, 43,\n-   36, 36, 36, 36, 36, 36, 36, 63, 74, 75, 75, 75, 75, 75, 75, 75,\n-   36, 36, 36, 79, 75, 75, 78, 36, 36, 75, 75, 43, 43, 43, 43, 43,\n-   36, 36, 79, 75, 43, 43, 43, 43, 75, 43, 74, 64, 36, 58,  2,  2,\n-    7,  7,  7,  7,  7,  2,  2, 64, 75, 76, 43, 43, 74, 74, 75, 76,\n-   74, 43, 36, 65, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 79,\n-   75, 43, 43, 43, 75, 75, 43, 76, 57,  2,  2,  2,  2,  2,  2,  2,\n-    2,  2,  2,  2, 36, 36, 43, 43, 75, 76, 43, 43, 43, 74, 76, 76,\n-   57,  2, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 63, 76, 75,\n-   43, 43, 43, 76, 36, 36, 36, 36, 75, 43, 43, 76, 43, 43, 43, 43,\n-    7,  7,  7,  7,  7, 27,  2, 86, 43, 43, 43, 43, 76, 57,  2,  2,\n-   27, 27, 27, 27, 27, 27, 27, 84, 75, 75, 75, 75, 75, 76, 74, 64,\n-   78, 76,  2,  2,  2,  2,  2,  2, 79, 75, 43, 43, 43, 43, 75, 75,\n-   64, 65, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75,\n-   63, 43, 43, 43, 43, 64, 36, 36, 36, 63, 43, 43, 74, 63, 43, 57,\n-    2,  2,  2, 56, 43, 43, 43, 43, 63, 43, 43, 74, 76, 43, 36, 36,\n-   36, 36, 36, 36, 36, 43, 43, 43, 43, 43, 43, 74, 43,  2, 65,  2,\n-   43, 43, 43, 43, 43, 43, 43, 76, 58,  2,  2,  2,  2,  2,  2,  2,\n-    2, 36, 36, 36, 36, 36, 36, 36, 43, 43, 43, 43, 74, 43, 43, 43,\n-   74, 43, 76, 43, 43, 43, 43, 43, 43, 43, 43, 63, 43, 43, 43, 43,\n-   36, 36, 36, 36, 36, 75, 75, 75, 43, 74, 76, 76, 36, 36, 36, 36,\n-   36, 63, 74,145,  2,  2,  2,  2, 27, 27, 81, 61, 61, 61, 53, 20,\n-  144, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 21,\n-   43, 43, 57,  2,  2,  2,  2,  2, 43, 43, 43, 57,  2,  2, 61, 61,\n-   40, 40, 86, 61, 61, 61, 61, 61,  7,  7,  7,  7,  7,166, 27, 27,\n-   27, 84, 36, 36, 36, 36, 36, 36, 27, 27, 27, 30,  2,  2,  2,  2,\n-   79, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 76,\n-   43, 67, 40, 40, 40, 40, 40, 40, 40, 77, 43, 43, 43, 43, 43, 43,\n-   36, 36, 36, 36, 36, 36, 47, 57, 61, 61,167, 76, 43, 61,167, 75,\n-   75,168, 59, 59, 59, 73, 43, 43, 43, 69, 47, 43, 43, 43, 61, 61,\n-   61, 61, 61, 61, 61, 43, 43, 61, 61, 43, 69, 61, 61, 61, 61, 61,\n-   11, 11, 11, 11, 11, 16, 16, 16, 16, 16, 11, 11, 11, 11, 11, 11,\n-   11, 11, 11, 11, 11, 11, 11, 16, 11, 16, 16, 16, 16, 16, 16, 16,\n-   16, 16, 16, 16, 16, 16, 11, 11, 11, 11, 11, 16, 16, 16, 16, 16,\n-   31, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 33, 16, 16,\n-   16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 31, 16, 16,\n-   16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 31, 16, 16, 16, 16, 16,\n-   16, 16, 16, 16, 16, 16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 11,\n-   11, 11, 11, 11, 11, 11, 11, 31, 16, 16, 16, 16, 33, 16, 16, 16,\n-   11, 11, 11, 11, 31, 16, 16, 16, 16, 33, 16, 16, 16, 32, 16,  7,\n-   43, 43, 43, 69, 61, 47, 43, 43, 43, 43, 43, 43, 43, 43, 69, 61,\n-   61, 61, 47, 61, 61, 61, 61, 61, 61, 61, 69, 21,  2,  2,  2,  2,\n-    2,  2,  2,  2,  2, 56, 43, 43, 43, 43, 43, 67, 40, 40, 40, 40,\n-    7,  7,  7,  7,  7,  7,  7, 70, 36, 36, 36, 36, 36, 36, 43, 43,\n-    7,  7,  7,  7,  7,  7,  7,169, 16, 16, 43, 43, 43, 67, 40, 40,\n-   27, 27, 27, 27, 27, 27,140, 27,170, 27, 27, 27, 27, 27, 27, 27,\n-   27, 27, 27, 27, 27, 27, 27,140, 27, 27, 27, 27, 27, 27, 81, 61,\n-   61, 61, 61, 61, 61, 25, 41, 41,  0,  0, 29, 21, 21, 21, 23, 21,\n-   22, 18, 21, 25, 21, 17, 13, 13, 25, 25, 25, 21, 21,  9,  9,  9,\n-    9, 22, 21, 18, 24, 16, 24,  5,  5,  5,  5, 22, 25, 18, 25,  0,\n-   23, 23, 26, 21, 24, 26,  7, 20, 25,  1, 26, 24, 26, 25, 15, 15,\n-   24, 15,  7, 19, 15, 21,  9, 25,  9,  5,  5, 25,  5,  9,  5,  7,\n-    7,  7,  9,  8,  8,  5,  7,  5,  6,  6, 24, 24,  6, 24, 12, 12,\n-    6,  5,  9, 21, 25,  9, 26, 12, 11, 11,  9,  6,  5, 21, 17, 17,\n-   17, 26, 26, 23, 23, 12, 17, 12, 21, 12, 12, 21,  7, 21,  1,  1,\n-   21, 23, 26, 26,  6,  7,  7, 12, 12,  7, 21,  7, 12,  1, 12,  6,\n-    6, 12, 12, 26,  7, 26, 26,  7, 21,  1,  1, 12, 12, 10, 10, 10,\n-   10, 12, 21,  6, 10,  7,  7, 10, 23,  7, 15, 26, 13, 21, 13,  7,\n-   15,  7, 12, 23, 21, 26, 21, 15, 17,  7, 29,  7,  7, 22, 18, 18,\n-   14, 14, 14,  7, 17, 21,  7,  6, 11, 12,  5,  6,  8,  8,  8, 24,\n-    5, 24,  9, 24, 29, 29, 29,  1, 20, 19, 22, 20, 27, 28,  1, 29,\n-   21, 20, 19, 21, 21, 16, 16, 21, 25, 22, 18, 21, 21, 29, 15,  6,\n-   18,  6, 12, 11,  9, 26, 26,  9, 26,  5,  5, 26, 14,  9,  5, 14,\n-   14, 15, 25, 26, 26, 22, 18, 26, 18, 25, 18, 22,  5, 12, 22, 21,\n-   26,  6,  7, 14, 17, 22, 26, 14, 17,  6, 14,  6, 12, 24, 24,  6,\n-   26, 15,  6, 21, 11, 21, 24,  9, 23, 26, 10, 21,  6, 10,  4,  4,\n-    3,  3,  7, 25, 24,  7, 22, 22, 21, 22, 17, 16, 16, 22, 16, 16,\n-   25, 17,  7,  1, 25, 24, 26,  1,  2,  2, 12, 15, 21, 14,  7, 15,\n-   12, 17, 13, 12, 13, 15, 26, 10, 10,  1, 13, 23, 23, 15,  0,  1,\n-    2,  3,  4,  5,  6,  7,  8,  9,  0, 10, 11, 12, 13,  0, 14,  0,\n-    0,  0,  0,  0, 15,  0, 16,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 17, 18, 19,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 20,  0, 21, 22, 23,\n-    0,  0,  0, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0, 34,  0, 35,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 36,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 37, 38,  0,  0,  0,  0,  0,  0, 39, 40,\n-    0,  0, 41,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    1,  2,  0,  0,  0,  0,  3,  0,  0,  0,  4,  5,  6,  7,  0,  8,\n-    9, 10,  0, 11, 12, 13,  0, 14, 15, 16, 15, 17, 15, 18, 15, 18,\n-   15, 18,  0, 18,  0, 19, 15, 18, 20, 18,  0, 21, 22, 23, 24, 25,\n-   26, 27, 28, 29, 30,  0, 31,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0, 32,  0,  0,  0,  0,  0,  0, 33,  0,  0, 34,  0,  0, 35,  0,\n-   36,  0,  0,  0, 37, 38, 39, 40, 41, 42, 43, 44, 45,  0,  0, 46,\n-    0,  0,  0, 47,  0,  0,  0, 48,  0,  0,  0,  0,  0,  0,  0, 49,\n-    0, 50,  0, 51, 52,  0, 53,  0,  0,  0,  0,  0,  0, 54, 55, 56,\n-    0,  0,  0,  0, 57,  0,  0, 58, 59, 60, 61, 62,  0,  0, 63, 64,\n-    0,  0,  0, 65,  0,  0,  0,  0, 66,  0,  0,  0, 67,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 68,  0,  0,  0, 69,\n-    0, 70,  0,  0, 71,  0,  0, 72,  0,  0,  0,  0,  0,  0,  0,  0,\n-   73,  0,  0,  0,  0,  0, 74,  0,  0, 75,  0,  0,  0, 76, 77,  0,\n-   78, 61,  0, 79, 80,  0,  0, 81, 82, 83,  0,  0,  0, 84,  0, 85,\n-    0,  0, 50, 86, 50,  0, 87,  0, 88,  0,  0,  0, 77,  0,  0,  0,\n-   89, 90,  0, 91, 92, 93, 94,  0,  0,  0,  0,  0, 50,  0,  0,  0,\n-    0, 95, 96,  0,  0,  0,  0, 97, 98,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0, 99,  0,  0,100,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,101,102,  0,  0,103,  0,  0,  0,  0,  0,  0,104,  0,  0,  0,\n-   98,  0,  0,  0,  0,  0,  0,105,  0,  0,  0,  0,  0,  0,  0,106,\n-    0,107,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  0,\n-    8,  0,  0,  0,  0,  9, 10, 11, 12,  0,  0,  0,  0, 13,  0,  0,\n-   14, 15,  0, 16,  0, 17, 18,  0,  0, 19,  0, 20, 21,  0,  0,  0,\n-    0,  0, 22, 23,  0, 24, 25,  0,  0, 26,  0,  0,  0, 27, 28, 29,\n-    0,  0,  0, 30, 31, 32,  0,  0, 31,  0,  0, 33, 31,  0,  0,  0,\n-   31, 34,  0,  0,  0,  0,  0, 35, 36,  0,  0,  0,  0,  0,  0, 37,\n-   38,  0,  0,  0,  0,  0,  0, 39, 40,  0,  0,  0,  0, 41,  0, 42,\n-    0,  0,  0, 43, 44,  0,  0,  0, 45,  0,  0,  0,  0,  0,  0, 46,\n-   47,  0,  0,  0,  0, 48,  0,  0,  0, 49,  0, 49,  0, 50,  0,  0,\n-    0,  0, 51,  0,  0,  0,  0, 52,  0, 53,  0,  0,  0,  0, 54, 55,\n-    0,  0,  0, 56, 57,  0,  0,  0,  0,  0,  0, 58, 49,  0, 59, 60,\n-    0,  0, 61,  0,  0,  0, 62, 63,  0,  0,  0, 64,  0, 65, 66, 67,\n-   68, 69,  1, 70,  0, 71, 72, 73,  0,  0, 74, 75,  0,  0,  0, 76,\n-    0,  0,  1,  1,  0,  0, 77,  0,  0, 78,  0,  0,  0,  0, 74, 79,\n-    0, 80,  0,  0,  0,  0,  0, 75, 81,  0, 82,  0, 49,  0,  1, 75,\n-    0,  0, 83,  0,  0, 84,  0,  0,  0,  0,  0, 85, 54,  0,  0,  0,\n-    0,  0,  0, 86, 87,  0,  0, 81,  0,  0, 31,  0,  0, 88,  0,  0,\n-    0,  0, 89,  0,  0,  0,  0, 47,  0,  0, 57,  0,  0,  0,  0, 90,\n-   91,  0,  0, 92,  0,  0, 93,  0,  0,  0, 94,  0,  0,  0, 95,  0,\n-   96, 57,  0,  0, 81,  0,  0, 76,  0,  0,  0, 97, 98,  0,  0, 99,\n-  100,  0,  0,  0,  0,  0,  0,101,  0,  0,102,  0,  0,  0,  0,103,\n-   31,  0,104,105,106, 33,  0,  0,107,  0,  0,  0,108,  0,  0,  0,\n-    0,  0,  0,109,  0,  0,110,  0,  0,  0,  0,111, 85,  0,  0,  0,\n-    0,  0, 54,  0,  0,  0,  0, 49,112,  0,  0,  0,  0,113,  0,  0,\n-  114,  0,  0,  0,  0,112,  0,  0,  0,  0,  0,115,  0,  0,  0,116,\n-    0,  0,  0,117,  0,118,  0,  0,  0,  0,119,120,121,  0,122,  0,\n-  123,  0,  0,  0,124,125,126,  0,  0,  0,127,  0,  0,128,  0,  0,\n-  129,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  2,  3,  4,\n-    5,  6,  7,  4,  4,  8,  9, 10,  1, 11, 12, 13, 14, 15, 16, 17,\n-   18,  1,  1,  1, 19,  1,  0,  0, 20, 21, 22,  1, 23,  4, 21, 24,\n-   25, 26, 27, 28, 29, 30,  0,  0,  1,  1, 31,  0,  0,  0, 32, 33,\n-   34, 35,  1, 36, 37,  0,  0,  0,  0, 38,  1, 39, 14, 39, 40, 41,\n-   42,  0,  0,  0, 43, 36, 44, 45, 21, 45, 46,  0,  0,  0, 19,  1,\n-   21,  0,  0, 47,  0, 38, 48,  1,  1, 49, 49, 50,  0,  0, 51,  0,\n-   52,  1,  1,  1, 53, 21, 43, 54, 55, 21, 35,  1,  0,  0,  0, 56,\n-    0,  0,  0, 57, 58, 59,  0,  0,  0,  0,  0, 60,  0, 61,  0,  0,\n-    0,  0, 62, 63,  0,  0, 64,  0,  0,  0, 65,  0,  0,  0, 66,  0,\n-    0,  0, 67,  0,  0,  0, 68,  0,  0,  0, 69,  0,  0, 70, 71,  0,\n-   72, 73, 74, 75, 76, 77,  0,  0,  0, 78,  0,  0,  0, 79, 80,  0,\n-    0,  0,  0, 47,  0,  0,  0, 49,  0, 63,  0,  0, 64,  0,  0, 81,\n-    0,  0, 82,  0,  0,  0, 83,  0,  0, 19, 84,  0, 63,  0,  0,  0,\n-    0, 49,  1, 85,  1, 54, 15, 86, 84,  0,  0,  0,  0, 56,  0,  0,\n-    0,  0, 19, 10,  1,  0,  0,  0,  0,  0, 87,  0,  0, 88,  0,  0,\n-   87,  0,  0,  0,  0, 79,  0,  0, 89,  9, 12,  4, 90,  8, 91, 47,\n-    0, 59, 50,  0, 21,  1, 21, 92, 93,  1,  1,  1,  1, 94, 95, 96,\n-   97,  1, 98, 59, 81, 99,100,  4, 59,  0,  0,  0,  0,  0,  0, 19,\n-   50,  0,  0,  0,  0,  0,  0, 62,  0,  0,101,102,  0,  0,103,  0,\n-    0,  1,  1, 50,  0,  0,  0, 38,  0, 64,  0,  0,  0,  0,  0, 63,\n-    0,  0, 52, 69, 62,  0,  0,  0, 79,  0,  0,  0,104,105, 59, 38,\n-   81,  0,  0,  0,  0,  0,  0,106,  1, 14,  4, 12,  0, 38, 89,  0,\n-    0,  0,  0,107,  0,  0,108, 62,  0,109,  0,  0,  0,  1,  0,  0,\n-    0,  0, 19, 59,  0,110, 14, 54,  0,  0,111,  0, 89,  0,  0,  0,\n-   62, 63,  0,  0, 63,  0, 88,  0,  0,111,  0,  0,  0,  0,112,  0,\n-    0,  0, 79, 56,  0, 38,  1, 59,  1, 59,  0,  0, 64, 88,  0,  0,\n-  113,  0,  0,  0, 56,  0,  0,  0,  0,113,  0,  0,  0,  0, 62,  0,\n-    0,  0,  0, 80,  0, 62,  0,  0,  0,  0, 57,  0, 88,114,  0,  0,\n-    8, 91,  0,  0,  1, 89,  0,  0,115,  0,  0,  0,  0,  0,  0,116,\n-    0,117,118,119,120,  0, 52,  4,121, 49, 23,  0,  0,  0, 38, 50,\n-   38, 59,  0,  0,  1, 89,  1,  1,  1,  1, 39,  1, 48,104, 89,  0,\n-    0,  0,  0,  1,  4,121,  0,  0,  0,  1,122,  0,  0,  0,  0,  0,\n-  230,230,230,230,230,232,220,220,220,220,232,216,220,220,220,220,\n-  220,202,202,220,220,220,220,202,202,220,220,220,  1,  1,  1,  1,\n-    1,220,220,220,220,230,230,230,230,240,230,220,220,220,230,230,\n-  230,220,220,  0,230,230,230,220,220,220,220,230,232,220,220,230,\n-  233,234,234,233,234,234,233,230,  0,  0,  0,230,  0,220,230,230,\n-  230,230,220,230,230,230,222,220,230,230,220,220,230,222,228,230,\n-   10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22,  0, 23,\n-    0, 24, 25,  0,230,220,  0, 18, 30, 31, 32,  0,  0,  0,  0, 27,\n-   28, 29, 30, 31, 32, 33, 34,230,230,220,220,230,220,230,230,220,\n-   35,  0,  0,  0,  0,  0,230,230,230,  0,  0,230,230,  0,220,230,\n-  230,220,  0,  0,  0, 36,  0,  0,230,220,230,230,220,220,230,220,\n-  220,230,220,230,220,230,230,  0,  0,220,  0,  0,230,230,  0,230,\n-    0,230,230,230,230,230,  0,  0,  0,220,220,220,  0,  0,  0,220,\n-  230,230,  0,220,230,220,220,220, 27, 28, 29,230,  7,  0,  0,  0,\n-    0,  9,  0,  0,  0,230,220,230,230,  0,  0,  0,  0,  0,230,  0,\n-    0, 84, 91,  0,  0,  0,  0,  9,  9,  0,  0,  0,  0,  0,  9,  0,\n-  103,103,  9,  0,107,107,107,107,118,118,  9,  0,122,122,122,122,\n-  220,220,  0,  0,  0,220,  0,220,  0,216,  0,  0,  0,129,130,  0,\n-  132,  0,  0,  0,  0,  0,130,130,130,130,  0,  0,130,  0,230,230,\n-    9,  0,230,230,  0,  0,220,  0,  0,  0,  0,  7,  0,  9,  9,  0,\n-    0,230,  0,  0,  0,228,  0,  0,  0,222,230,220,220,  0,  0,  0,\n-  230,  0,  0,220,230,220,  0,220,  0,  0,  9,  9,  0,  0,  7,  0,\n-  230,230,230,  0,230,  0,  1,  1,  1,  0,  0,  0,230,234,214,220,\n-  202,230,230,230,230,230,232,228,228,220,  0,230,233,220,230,220,\n-  230,230,  1,  1,  1,  1,  1,230,  0,  1,  1,230,220,230,  1,  1,\n-    0,  0,218,228,232,222,224,224,  0,  8,  8,  0,230,  0,230,230,\n-  220,  0,  0,230,  0,  0, 26,  0,  0,220,  0,230,230,  1,220,  0,\n-    0,230,220,  0,  0,  0,220,220,  0,  9,  7,  0,  0,  7,  9,  0,\n-    0,  0,  9,  7,  9,  9,  0,  0,  6,  6,  0,  0,  0,  0,  1,  0,\n-    0,216,216,  1,  1,  1,  0,  0,  0,226,216,216,216,216,216,  0,\n-  220,220,220,  0,230,230,  7,  0, 16, 17, 17, 33, 17, 49, 17, 17,\n-   84, 97,135,145, 26, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   36, 36, 43, 43, 43, 43, 43, 43, 36, 36, 36, 36, 36, 64,166, 51,\n+   27, 27, 27, 87, 36, 36, 36, 36,163, 27, 30,  2,  2,  2,  2,  2,\n+   36, 43, 43,  2,  2,  2,  2,  2, 36, 36,165, 27, 27, 27, 27, 27,\n+   79, 81, 36, 36, 36, 36, 36, 36, 43, 43, 43, 57,  2,  2,  2,  2,\n+    2, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,  7,  7,  7,  7,  7,\n+   65, 64, 65, 36, 36, 36, 36, 64, 78, 79, 43, 77, 79, 57, 73,  2,\n+    2, 43, 43, 43, 43, 43, 67, 59, 36, 36, 36, 64, 43, 43, 79, 43,\n+   43, 43, 43,  7,  7,  7,  7,  7,  2,  2, 82, 81, 36, 36, 36, 36,\n+   36, 64,  2, 36, 36, 36, 36, 36, 36, 82, 78, 43, 43, 43, 43, 77,\n+   81, 36, 58,  2, 56, 43, 57, 79,  7,  7,  7,  7,  7, 58, 58,  2,\n+   90, 27, 27, 27, 27, 27, 27, 27, 36, 36, 36, 36, 36, 36, 78, 79,\n+   43, 78, 77, 43,  2,  2,  2, 43, 36, 36, 36, 36, 36, 36, 36, 64,\n+   77, 78, 78, 78, 78, 78, 78, 78, 36, 36, 36, 82, 78, 78, 81, 36,\n+   36, 78, 78, 43, 43, 43, 43, 43, 36, 36, 82, 78, 43, 43, 43, 43,\n+   78, 43, 77, 65, 36, 58,  2,  2,  7,  7,  7,  7,  7,  2,  2, 65,\n+   78, 79, 43, 43, 77, 77, 78, 79, 77, 43, 36, 66, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 36, 36, 82, 78, 43, 43, 43, 78, 78, 43, 79,\n+   57,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2, 36, 36, 43, 43,\n+   78, 79, 43, 43, 43, 77, 79, 79, 57,  2, 36, 36, 36, 36, 36, 36,\n+   36, 36, 36, 36, 36, 64, 79, 78, 43, 43, 43, 79, 58,  2,  2,  2,\n+   78, 43, 43, 79, 43, 43, 43, 43,  7,  7,  7,  7,  7, 27,  2, 89,\n+   43, 43, 43, 43, 79, 57,  2,  2, 27, 27, 27, 27, 27, 27, 27, 87,\n+   78, 78, 78, 78, 78, 79, 77, 65, 81, 79,  2,  2,  2,  2,  2,  2,\n+   82, 78, 43, 43, 43, 43, 78, 78, 65, 66, 78, 78, 78, 78, 78, 78,\n+   78, 78, 78, 78, 78, 78, 78, 78, 64, 43, 43, 43, 43, 65, 36, 36,\n+   36, 64, 43, 43, 77, 64, 43, 57,  2,  2,  2, 56, 43, 43, 43, 43,\n+   64, 43, 43, 77, 79, 43, 36, 36, 36, 36, 36, 36, 36, 43, 43, 43,\n+   43, 43, 43, 77, 43,  2, 66,  2, 43, 43, 43, 43, 43, 43, 43, 79,\n+   58,  2,  2,  2,  2,  2,  2,  2,  2, 36, 36, 36, 36, 36, 36, 36,\n+   43, 43, 43, 43, 77, 43, 43, 43, 77, 43, 79, 43, 43, 43, 43, 43,\n+   43, 43, 43, 64, 43, 43, 43, 43, 36, 36, 36, 36, 36, 78, 78, 78,\n+   43, 77, 79, 79, 36, 36, 36, 36, 36, 64, 77, 97,  2,  2,  2,  2,\n+   27, 27, 84, 61, 61, 61, 53, 20,150, 61, 61, 61, 61, 61, 61, 61,\n+   61, 61, 61, 61, 61, 61, 61, 21, 43, 43, 57,  2,  2,  2,  2,  2,\n+   43, 43, 43, 57,  2,  2, 61, 61, 40, 40, 89, 61, 61, 61, 61, 61,\n+    7,  7,  7,  7,  7,167, 27, 27, 27, 87, 36, 36, 36, 36, 36, 36,\n+   27, 27, 27, 30,  2,  2,  2,  2, 82, 78, 78, 78, 78, 78, 78, 78,\n+   78, 78, 78, 78, 78, 78, 78, 79, 43, 68, 40, 40, 40, 40, 40, 40,\n+   40, 80, 43, 43, 43, 43, 43, 43, 36, 36, 36, 36, 36, 36, 47, 57,\n+   61, 61,168, 79, 43, 61,168, 78, 78,169, 59, 59, 59, 76, 43, 43,\n+   43, 70, 47, 43, 43, 43, 61, 61, 61, 61, 61, 61, 61, 43, 43, 61,\n+   61, 43, 70, 61, 61, 61, 61, 61, 11, 11, 11, 11, 11, 16, 16, 16,\n+   16, 16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 16,\n+   11, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 11, 11,\n+   11, 11, 11, 16, 16, 16, 16, 16, 31, 16, 16, 16, 16, 16, 16, 16,\n+   16, 16, 16, 16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 11, 11, 11,\n+   11, 11, 11, 11, 11, 31, 16, 16, 16, 16, 33, 16, 16, 16, 11, 11,\n+   11, 11, 31, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 33,\n+   16, 16, 16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 31,\n+   16, 16, 16, 16, 33, 16, 16, 16, 11, 11, 11, 11, 31, 16, 16, 16,\n+   16, 33, 16, 16, 16, 32, 16,  7, 43, 43, 43, 70, 61, 47, 43, 43,\n+   43, 43, 43, 43, 43, 43, 70, 61, 61, 61, 47, 61, 61, 61, 61, 61,\n+   61, 61, 70, 21,  2,  2,  2,  2,  2,  2,  2,  2,  2, 56, 43, 43,\n+   16, 16, 16, 16, 16, 39, 16, 16, 43, 43, 43, 68, 40, 40, 40, 40,\n+    7,  7,  7,  7,  7,  7,  7, 71, 36, 36, 36, 36, 36, 36, 36, 43,\n+   36, 36, 36, 36, 36, 36, 43, 43,  7,  7,  7,  7,  7,  7,  7,170,\n+   16, 16, 43, 43, 43, 68, 40, 40, 27, 27, 27, 27, 27, 27,145, 27,\n+  171, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,145,\n+   27, 27, 27, 27, 27, 27, 84, 61, 61, 61, 61, 61, 61, 25, 41, 41,\n+    0,  0, 29, 21, 21, 21, 23, 21, 22, 18, 21, 25, 21, 17, 13, 13,\n+   25, 25, 25, 21, 21,  9,  9,  9,  9, 22, 21, 18, 24, 16, 24,  5,\n+    5,  5,  5, 22, 25, 18, 25,  0, 23, 23, 26, 21, 24, 26,  7, 20,\n+   25,  1, 26, 24, 26, 25, 15, 15, 24, 15,  7, 19, 15, 21,  9, 25,\n+    9,  5,  5, 25,  5,  9,  5,  7,  7,  7,  9,  8,  8,  5,  7,  5,\n+    6,  6, 24, 24,  6, 24, 12, 12,  6,  5,  9, 21, 25,  9, 26, 12,\n+   11, 11,  9,  6,  5, 21, 17, 17, 17, 26, 26, 23, 23, 12, 17, 12,\n+   21, 12, 12, 21,  7, 21,  1,  1, 21, 23, 26, 26,  1, 21,  6,  7,\n+    7, 12, 12,  7, 21,  7, 12,  1, 12,  6,  6, 12, 12, 26,  7, 26,\n+   26,  7, 21,  1, 24,  7,  7,  6,  1, 12, 12, 10, 10, 10, 10, 12,\n+   21,  6, 10,  7,  7, 10, 23,  7, 15, 26, 13, 21, 13,  7, 15,  7,\n+   12, 23, 21, 26, 21, 15, 17,  7, 29,  7,  7, 22, 18, 18, 14, 14,\n+   14,  7, 10, 21, 17, 21, 11, 12,  5,  6,  8,  8,  8, 24,  5, 24,\n+    9, 24, 29, 29, 29,  1, 20, 19, 22, 20, 27, 28,  1, 29, 21, 20,\n+   19, 21, 21, 16, 16, 21, 25, 22, 18, 21, 21, 29, 15,  6, 18,  6,\n+   12, 11,  9, 26, 26,  9, 26,  5,  5, 26, 14,  9,  5, 14, 14, 15,\n+   25, 26, 26, 22, 18, 26, 18, 25, 18, 22,  5, 12, 22, 21, 21, 22,\n+   18, 17, 26,  6,  7, 14, 17, 22, 26, 14, 17,  6, 14,  6, 12, 24,\n+   24,  6, 26, 15,  6, 21, 11, 21, 24,  9,  6,  9, 23, 26,  6, 10,\n+    4,  4,  3,  3,  7, 25, 17, 16, 16, 22, 16, 16, 25, 17,  7,  1,\n+   25, 24, 26,  1,  2,  2, 12, 15, 21, 14,  7, 15, 12, 17, 13, 15,\n+   26, 10, 10,  1, 13, 23, 23, 15,  0,  1,  2,  3,  4,  5,  6,  7,\n+    8,  9,  0, 10, 11, 12, 13,  0, 14,  0,  0,  0,  0,  0, 15,  0,\n+   16,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 17, 18, 19,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 20,  0, 21, 22, 23,  0,  0,  0, 24, 25, 26,\n+   27, 28, 29, 30, 31, 32, 33,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 34,  0, 35,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 36,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   37, 38,  0,  0,  0,  0,  0,  0, 39, 40,  0,  0, 41,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  0,  0,  0,  0,\n+    3,  0,  0,  0,  4,  5,  6,  7,  0,  8,  9, 10,  0, 11, 12, 13,\n+   14, 15, 16, 17, 16, 18, 16, 19, 16, 19, 16, 19,  0, 19, 16, 20,\n+   16, 19, 21, 19,  0, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,  0,\n+   32,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 33,  0,  0,  0,  0,\n+    0,  0, 34,  0,  0, 35,  0,  0, 36,  0, 37,  0,  0,  0, 38, 39,\n+   40, 41, 42, 43, 44, 45, 46,  0,  0, 47,  0,  0,  0, 48,  0,  0,\n+    0, 49,  0,  0,  0,  0,  0,  0,  0, 50,  0, 51,  0, 52, 53,  0,\n+   54,  0,  0,  0,  0,  0,  0, 55, 56, 57,  0,  0,  0,  0, 58,  0,\n+    0, 59, 60, 61, 62, 63,  0,  0, 64, 65,  0,  0,  0, 66,  0,  0,\n+    0,  0, 67,  0,  0,  0, 68,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 69,  0,  0,  0, 70,  0, 71,  0,  0, 72,  0,\n+    0, 73,  0,  0,  0,  0,  0,  0,  0,  0, 74,  0,  0,  0,  0,  0,\n+   75,  0,  0, 76, 77,  0,  0, 78, 79,  0, 80, 62,  0, 81, 82,  0,\n+    0, 83, 84, 85,  0,  0,  0, 86,  0, 87,  0,  0, 51, 88, 51,  0,\n+   89,  0, 90,  0,  0,  0, 79,  0,  0,  0, 91, 92,  0, 93, 94, 95,\n+   96,  0,  0,  0,  0,  0, 51,  0,  0,  0,  0, 97, 98,  0,  0,  0,\n+    0, 99,100,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,101,  0,  0,\n+  102,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,103,104,  0,  0,105,\n+    0,  0,  0,  0,  0,  0,106,  0,  0,  0,100,  0,  0,  0,  0,  0,\n+  107,108,  0,  0,  0,  0,  0,  0,  0,109,  0,110,  0,  0,  0,  0,\n+    0,  0,  1,  2,  3,  4,  5,  6,  7,  0,  8,  0,  0,  0,  0,  9,\n+   10, 11, 12,  0,  0,  0,  0, 13,  0,  0, 14, 15,  0, 16,  0, 17,\n+   18,  0,  0, 19,  0, 20, 21,  0,  0,  0,  0,  0, 22, 23,  0, 24,\n+   25,  0,  0, 26,  0,  0,  0, 27,  0,  0, 28, 29, 30, 31,  0,  0,\n+    0, 32, 33, 34,  0,  0, 33,  0,  0, 35, 33,  0,  0,  0, 33, 36,\n+    0,  0,  0,  0,  0, 37, 38,  0,  0,  0,  0,  0,  0, 39, 40,  0,\n+    0,  0,  0,  0,  0, 41, 42,  0,  0,  0,  0, 43,  0, 44,  0,  0,\n+    0, 45, 46,  0,  0,  0, 47,  0,  0,  0,  0,  0,  0, 48, 49,  0,\n+    0,  0,  0, 50,  0,  0,  0, 51,  0, 52,  0, 53,  0,  0,  0,  0,\n+   54,  0,  0,  0,  0, 55,  0, 56,  0,  0,  0,  0, 57, 58,  0,  0,\n+    0, 59, 60,  0,  0,  0,  0,  0,  0, 61, 52,  0, 62, 63,  0,  0,\n+   64,  0,  0,  0, 65, 66,  0,  0,  0, 67,  0, 68, 69, 70, 71, 72,\n+    1, 73,  0, 74, 75, 76,  0,  0, 77, 78,  0,  0,  0, 79,  0,  0,\n+    1,  1,  0,  0, 80,  0,  0, 81,  0,  0,  0,  0, 77, 82,  0, 83,\n+    0,  0,  0,  0,  0, 78, 84,  0, 85,  0, 52,  0,  1, 78,  0,  0,\n+   86,  0,  0, 87,  0,  0,  0,  0,  0, 88, 57,  0,  0,  0,  0,  0,\n+    0, 89, 90,  0,  0, 84,  0,  0, 33,  0,  0, 91,  0,  0,  0,  0,\n+   92,  0,  0,  0,  0, 49,  0,  0, 93,  0,  0,  0,  0, 94, 95,  0,\n+    0, 96,  0,  0, 97,  0,  0,  0, 98,  0,  0,  0, 99,  0,100, 93,\n+    0,  0,101,  0,  0,  0, 84,  0,  0,102,  0,  0,  0,103,104,  0,\n+    0,105,106,  0,  0,  0,  0,  0,  0,107,  0,  0,108,  0,  0,  0,\n+    0,109, 33,  0,110,111,112, 35,  0,  0,113,  0,  0,  0,114,  0,\n+    0,  0,  0,  0,  0,115,  0,  0,116,  0,  0,  0,  0,117, 88,  0,\n+    0,  0,  0,  0, 57,  0,  0,  0,  0, 52,118,  0,  0,  0,  0,119,\n+    0,  0,120,  0,  0,  0,  0,118,  0,  0,  0,  0,  0,121,  0,  0,\n+    0,122,  0,  0,  0,123,  0,124,  0,  0,  0,  0,125,126,127,  0,\n+  128,  0,129,  0,  0,  0,130,131,132,  0,  0,  0, 35,  0,  0,  0,\n+  133,  0,  0,134,  0,  0,135,  0,  0,  0,  0,  0,  0,  0,  1,  1,\n+    1,  1,  1,  2,  3,  4,  5,  6,  7,  4,  4,  8,  9, 10,  1, 11,\n+   12, 13, 14, 15, 16, 17, 18,  1,  1,  1, 19,  1,  0,  0, 20, 21,\n+   22,  1, 23,  4, 21, 24, 25, 26, 27, 28, 29, 30,  0,  0,  1,  1,\n+   31,  0,  0,  0, 32, 33, 34, 35,  1, 36, 37,  0,  0,  0,  0, 38,\n+    1, 39, 14, 39, 40, 41, 42,  0,  0,  0, 43, 36, 44, 45, 21, 45,\n+   46,  0,  0,  0, 19,  1, 21,  0,  0, 47,  0, 38, 48,  1,  1, 49,\n+   49, 50,  0,  0, 51,  0,  0,  0, 52,  1,  0,  0, 38, 14,  4,  1,\n+    1,  1, 53, 21, 43, 52, 54, 21, 35,  1,  0,  0,  0, 55,  0,  0,\n+    0, 56, 57, 58,  0,  0,  0,  0,  0, 59,  0, 60,  0,  0,  0,  0,\n+   61, 62,  0,  0, 63,  0,  0,  0, 64,  0,  0,  0, 65,  0,  0,  0,\n+   66,  0,  0,  0, 67,  0,  0,  0, 68,  0,  0, 69, 70,  0, 71, 72,\n+   73, 74, 75, 76,  0,  0,  0, 77,  0,  0,  0, 78, 79,  0,  0,  0,\n+    0, 47,  0,  0,  0, 49,  0, 80,  0,  0,  0, 62,  0,  0, 63,  0,\n+    0, 81,  0,  0, 82,  0,  0,  0, 83,  0,  0, 19, 84,  0, 62,  0,\n+    0,  0,  0, 49,  1, 85,  1, 52, 15, 86, 36, 10, 21, 87,  0, 55,\n+    0,  0,  0,  0, 19, 10,  1,  0,  0,  0,  0,  0, 88,  0,  0, 89,\n+    0,  0, 88,  0,  0,  0,  0, 78,  0,  0, 87,  9, 12,  4, 90,  8,\n+   91, 47,  0, 58, 50,  0, 21,  1, 21, 92, 93,  1,  1,  1,  1, 94,\n+   95, 96, 97,  1, 98, 58, 81, 99,100,  4, 58,  0,  0,  0,  0,  0,\n+    0, 19, 50,  0,  0,  0,  0,  0,  0, 61,  0,  0,101,102,  0,  0,\n+  103,  0,  0,  1,  1, 50,  0,  0,  0, 38,  0, 63,  0,  0,  0,  0,\n+    0, 62,  0,  0,104, 68, 61,  0,  0,  0, 78,  0,  0,  0,105,106,\n+   58, 38, 81,  0,  0,  0,  0,  0,  0,107,  1, 14,  4, 12, 84,  0,\n+    0,  0,  0, 38, 87,  0,  0,  0,  0,108,  0,  0,109, 61,  0,110,\n+    0,  0,  0,  1,  0,  0,  0,  0, 19, 58,  0,111, 14, 52,112, 41,\n+    0,  0, 62,  0,  0, 61,  0,  0,113,  0, 87,  0,  0,  0, 61, 62,\n+    0,  0, 62,  0, 89,  0,  0,113,  0,  0,  0,  0,114,  0,  0,  0,\n+   78, 55,  0, 38,  1, 58,  1, 58,  0,  0, 63, 89,  0,  0,115,  0,\n+    0,  0, 55,  0,  0,  0,  0,115,  0,  0,  0,  0, 61,  0,  0,  0,\n+    0, 79,  0, 61,  0,  0,  0,  0, 56,  0, 89, 80,  0,  0,  8, 91,\n+    0,  0,  1, 87,  0,  0,116,  0,  0,  0,  0,  0,  0,117,  0,118,\n+  119,120,121,  0,104,  4,122, 49, 23,  0,  0,  0, 38, 50, 38, 58,\n+    0,  0,  1, 87,  1,  1,  1,  1, 39,  1, 48,105, 87,  0,  0,  0,\n+    0,  1,  4,122,  0,  0,  0,  1,123,  0,  0,  0,  0,  0,230,230,\n+  230,230,230,232,220,220,220,220,232,216,220,220,220,220,220,202,\n+  202,220,220,220,220,202,202,220,220,220,  1,  1,  1,  1,  1,220,\n+  220,220,220,230,230,230,230,240,230,220,220,220,230,230,230,220,\n+  220,  0,230,230,230,220,220,220,220,230,232,220,220,230,233,234,\n+  234,233,234,234,233,230,  0,  0,  0,230,  0,220,230,230,230,230,\n+  220,230,230,230,222,220,230,230,220,220,230,222,228,230, 10, 11,\n+   12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22,  0, 23,  0, 24,\n+   25,  0,230,220,  0, 18, 30, 31, 32,  0,  0,  0,  0, 27, 28, 29,\n+   30, 31, 32, 33, 34,230,230,220,220,230,220,230,230,220, 35,  0,\n+    0,  0,  0,  0,230,230,230,  0,  0,230,230,  0,220,230,230,220,\n+    0,  0,  0, 36,  0,  0,230,220,230,230,220,220,230,220,220,230,\n+  220,230,220,230,230,  0,  0,220,  0,  0,230,230,  0,230,  0,230,\n+  230,230,230,230,  0,  0,  0,220,220,220,230,220,220,220,230,230,\n+    0,220, 27, 28, 29,230,  7,  0,  0,  0,  0,  9,  0,  0,  0,230,\n+  220,230,230,  0,  0,  0,  0,  0,230,  0,  0, 84, 91,  0,  0,  0,\n+    0,  9,  9,  0,  0,  0,  0,  0,  9,  0,103,103,  9,  0,107,107,\n+  107,107,118,118,  9,  0,122,122,122,122,220,220,  0,  0,  0,220,\n+    0,220,  0,216,  0,  0,  0,129,130,  0,132,  0,  0,  0,  0,  0,\n+  130,130,130,130,  0,  0,130,  0,230,230,  9,  0,230,230,  0,  0,\n+  220,  0,  0,  0,  0,  7,  0,  9,  9,  0,  9,  9,  0,  0,  0,230,\n+    0,  0,  0,228,  0,  0,  0,222,230,220,220,  0,  0,  0,230,  0,\n+    0,220,230,220,  0,220,230,230,230,  0,  0,  0,  9,  9,  0,  0,\n+    7,  0,230,  0,  1,  1,  1,  0,  0,  0,230,234,214,220,202,230,\n+  230,230,230,230,232,228,228,220,218,230,233,220,230,220,230,230,\n+    1,  1,  1,  1,  1,230,  0,  1,  1,230,220,230,  1,  1,  0,  0,\n+  218,228,232,222,224,224,  0,  8,  8,  0,  0,  0,  0,220,230,  0,\n+  230,230,220,  0,  0,230,  0,  0, 26,  0,  0,220,  0,230,230,  1,\n+  220,  0,  0,230,220,  0,  0,  0,220,220,  0,  0,230,220,  0,  9,\n+    7,  0,  0,  7,  9,  0,  0,  0,  9,  7,  6,  6,  0,  0,  0,  0,\n+    1,  0,  0,216,216,  1,  1,  1,  0,  0,  0,226,216,216,216,216,\n+  216,  0,220,220,220,  0,230,230,  7,  0, 16, 17, 17, 17, 17, 17,\n+   17, 33, 17, 17, 17, 19, 17, 17, 17, 17, 20,101, 17,113,129,169,\n+   17, 27, 28, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n@@ -6050,42 +6154,39 @@\n-   17, 17, 17, 17, 17, 17, 17,177,  0,  1,  2,  3,  3,  3,  3,  3,\n-    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  4,  3,  3,  3,\n-    3,  3,  5,  3,  3,  3,  3,  3,  6,  7,  8,  3,  3,  3,  3,  3,\n-    9, 10, 11, 12, 13,  3,  3,  3,  3,  3,  3,  3,  3, 14,  3, 15,\n-    3,  3,  3,  3,  3,  3, 16, 17, 18, 19, 20, 21,  3,  3,  3, 22,\n-   23,  3,  3,  3,  3,  3,  3,  3, 24,  3,  3,  3,  3,  3,  3,  3,\n-    3, 25,  3,  3, 26, 27,  0,  1,  0,  0,  0,  0,  0,  1,  0,  2,\n-    0,  0,  0,  3,  0,  0,  0,  3,  0,  0,  0,  0,  0,  4,  0,  5,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  6,\n-    0,  0,  0,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  8,\n-    9,  0,  0,  0,  0,  0,  0,  9,  0,  9,  0,  0,  0,  0,  0,  0,\n-    0, 10, 11, 12, 13,  0,  0, 14, 15, 16,  6,  0, 17, 18, 19, 19,\n-   19, 20, 21, 22, 23, 24, 19, 25,  0, 26, 27, 19, 19, 28, 29, 30,\n-    0, 31,  0,  0,  0,  8,  0,  0,  0,  0,  0,  0,  0, 19, 28,  0,\n-   32, 33,  9, 34, 35, 19,  0,  0, 36, 37, 38, 39, 40, 19,  0, 41,\n-   42, 43, 44, 31,  0,  1, 45, 42,  0,  0,  0,  0,  0, 32, 14, 14,\n-    0,  0,  0,  0, 14,  0,  0, 46, 47, 47, 47, 47, 48, 49, 47, 47,\n-   47, 47, 50, 51, 52, 53, 43, 21,  0,  0,  0,  0,  0,  0,  0, 54,\n-    6, 55,  0, 14, 19,  1,  0,  0,  0, 19, 56, 31,  0,  0,  0,  0,\n-    0,  0,  0, 57, 14,  0,  0,  0,  0,  1,  0,  2,  0,  0,  0,  3,\n-    0,  0,  0, 58, 59,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,\n-    0,  0,  2,  3,  0,  4,  5,  0,  0,  6,  0,  0,  0,  7,  0,  0,\n-    0,  1,  1,  0,  0,  8,  9,  0,  8,  9,  0,  0,  0,  0,  8,  9,\n-   10, 11, 12,  0,  0,  0, 13,  0,  0,  0,  0, 14, 15, 16, 17,  0,\n-    0,  0,  1,  0,  0, 18, 19,  0,  0,  0, 20,  0,  0,  0,  1,  1,\n-    1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  0,  8, 21,  9,  0,  0,\n-   22,  0,  0,  0,  0,  1,  0, 23, 24, 25,  0,  0, 26,  0,  0,  0,\n-    8, 21, 27,  0,  1,  0,  0,  1,  1,  1,  1,  0,  1, 28, 29, 30,\n-    0, 31, 32, 20,  1,  1,  0,  0,  0,  8, 21,  9,  1,  4,  5,  0,\n-    0,  0, 33,  9,  0,  1,  1,  1,  0,  8, 21, 21, 21, 21, 34,  1,\n-   35, 21, 21, 21,  9, 36,  0,  0, 37, 38,  1,  0, 39,  0,  0,  0,\n-    1,  0,  1,  0,  0,  0,  0,  8, 21,  9,  1,  0,  0,  0, 40,  0,\n-    8, 21, 21, 21, 21, 21, 21, 21, 21,  9,  0,  1,  1,  1,  1,  8,\n-   21, 21, 21,  9,  0,  0,  0, 41,  0, 42, 43,  0,  0,  0,  1, 44,\n-    0,  0,  0, 45,  8,  9,  1,  0,  1,  0,  1,  1,  8, 21, 21,  9,\n-    0,  4,  5,  8,  9,  1,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,\n-    7,  8,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  9, 10, 11, 11,\n-   11, 11, 11, 12, 12, 12, 12, 13, 14, 15, 16, 17, 18, 12, 19, 12,\n-   20, 12, 12, 12, 12, 21, 22, 22, 22, 23, 12, 12, 12, 12, 24, 25,\n-   12, 12, 26, 27, 28, 29, 30, 31,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n-    7,  7,  7,  7,  7, 32, 12, 33,  7,  7, 34, 12, 12, 12, 12, 12,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17,237,  0,  1,  2,  2,  0,  3,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  4,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  5,  0,  0,  0,  0,  6,  7,  8,  9,  0,\n+    0,  0, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 20,  0,  0, 21, 22,  0,  0,  0,  0, 23, 24,\n+   25, 26,  0, 27,  0, 28, 29, 30, 31, 32,  0,  0,  0,  0,  0,  0,\n+    0, 33, 34, 35, 36,  0,  0,  0,  0,  0, 37,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0, 38, 39,  0,  0,  0,  0,  1,  2, 40, 41,  0,  1,\n+    2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,\n+    0,  2,  0,  0,  0,  0,  0,  0,  3,  4,  0,  0,  5,  0,  0,  0,\n+    6,  0,  0,  0,  0,  0,  0,  0,  7,  1,  0,  0,  0,  0,  0,  0,\n+    8,  9,  0,  0,  0,  0,  0,  0, 10,  0,  0, 10,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0, 10,  0,  0,\n+    0,  0,  0,  0, 11, 12,  0, 13,  0, 14, 15, 16,  0,  0,  0,  0,\n+    0,  1, 17, 18,  0, 19,  7,  1,  0,  0,  0, 20, 20,  7, 20, 20,\n+   20, 20, 20, 20, 20,  8, 21,  0, 22,  0,  7, 23, 24,  0, 20, 20,\n+   25,  0,  0,  0, 26, 27,  1,  7, 20, 20, 20, 20, 20,  1, 28, 29,\n+   30, 31,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0, 10,  0,  0,  0,\n+    0,  0,  0,  0, 20, 20, 20,  1,  0,  0,  8, 21, 32,  4,  0, 10,\n+    0, 33,  7, 20, 20, 20,  0,  0,  0,  0,  8, 34, 34, 35, 36, 34,\n+   37,  0, 38,  1, 20, 20,  0,  0, 39,  0,  1,  1,  0,  8, 21,  1,\n+   20,  0,  0,  0,  1,  0,  0, 40,  1,  1,  0,  0,  8, 21,  0,  1,\n+    0,  1,  0,  1,  0,  0,  0,  0, 26, 34, 34, 34, 34, 34, 34, 34,\n+   34, 34, 21,  7, 20, 41, 34, 34, 34, 34, 34, 34, 34, 34, 34, 21,\n+    0, 42, 43, 44,  0, 45,  0,  8, 21,  0,  0,  0,  0,  0,  0,  0,\n+    0, 46,  7,  1, 10,  1,  0,  0,  0,  1, 20, 20,  1,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 26, 34,  9,  0,  0, 20, 20,  1, 20,\n+   20,  0,  0,  0,  0,  0,  0,  0, 26, 21,  0,  1,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  3, 47, 48,  0,  0,  0,  0,  0,\n+    0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  7,  8,  7,  7,  7,  7,\n+    7,  7,  7,  7,  7,  7,  9, 10, 11, 11, 11, 11, 11, 12, 12, 12,\n+   12, 13, 14, 15, 16, 17, 18, 19, 20, 12, 21, 12, 12, 12, 12, 22,\n+   23, 23, 23, 24, 12, 12, 12, 25, 26, 27, 12, 28, 29, 30, 31, 32,\n+   33, 34,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,\n+    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 35,\n+   12, 36,  7,  7, 37, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,\n@@ -6113,8 +6214,7 @@\n-   12, 12, 12, 12, 12, 12, 12, 12, 35,  0,  0,  1,  2,  2,  2,  3,\n-    4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n-   20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 32, 33, 33,\n-   33, 34, 35, 35, 35, 35, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,\n-   45, 46, 47, 48, 49, 50,  2,  2, 51, 51, 52, 53, 54, 55, 56, 56,\n-   56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 57, 57, 56, 56, 56, 56,\n-   56, 56, 58, 59, 60, 61, 56, 62, 62, 63, 64, 65, 66, 67, 68, 69,\n-   70, 56, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,\n+   12, 12, 38,  0,  0,  1,  2,  2,  2,  3,  4,  5,  6,  7,  8,  9,\n+   10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,\n+   26, 27, 28, 29, 30, 31, 32, 32, 33, 33, 33, 34, 35, 35, 35, 35,\n+   35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\n+    2,  2, 51, 51, 52, 53, 54, 55, 56, 56, 56, 56, 56, 56, 56, 56,\n+   56, 56, 56, 56, 57, 57, 56, 56, 56, 56, 56, 56, 58, 59, 60, 61,\n+   56, 62, 62, 63, 64, 65, 66, 67, 68, 69, 70, 56, 62, 62, 62, 62,\n@@ -6122,16 +6222,11 @@\n-   62, 62, 62, 62, 62, 71, 62, 62, 62, 62, 72, 72, 72, 72, 72, 72,\n-   72, 72, 72, 73, 74, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\n-   85, 86, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n-   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 87, 87, 87, 87, 87, 87,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 62, 62, 62, 62,\n-   88, 89, 89, 89, 90, 89, 91, 92, 93, 94, 95, 95, 96, 97, 87, 98,\n-   99,100,101,102,103, 87,104,104,104, 87,105,106,107,108,109,110,\n-  111,112,113,114,115, 87, 89,116,117,118,119,120,121,122,123,124,\n-  125, 87,126,127, 87,128,129,130,131, 87,132,133,134,135,136,137,\n-   87, 87,138,139,140,141, 87,142, 87,143,144,144,144,144,144,144,\n-  144,144,144,144,144, 87, 87, 87, 87, 87,145,145,145,145,145,145,\n-  145,145,145, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n-   87, 87,146,146,146,146,146, 87, 87, 87,147,147,147,147,148,149,\n-  150,150, 87, 87, 87, 87,151,151,152,153,154,154,154,154,154,154,\n-  154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,\n-  155,155,155,155,154, 87, 87, 87, 87, 87,156,157,158,159,159,159,\n+   62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 71,\n+   62, 62, 62, 62, 72, 72, 72, 72, 72, 72, 72, 72, 72, 73, 74, 74,\n+   75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 32, 32, 32, 32,\n+   32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n+   32, 32, 32, 32, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+   87, 87, 87, 87, 87, 87, 62, 62, 62, 62, 88, 89, 89, 89, 90, 89,\n+   91, 92, 93, 94, 95, 95, 96, 97, 87, 98, 99,100,101,102,103,104,\n+  105,105,105,  2,106,107,108,109,110,111,112,113,114,115,116, 87,\n+   89,117,118,119,120,121,122,123,124,125,126, 87,127,128, 87,129,\n+  130,131,132, 87,133,134,135,136,137,138, 87, 87,139,140,141,142,\n+   87,143, 87,144,145,145,145,145,145,145,145,145,145,145,145, 87,\n@@ -6139,214 +6234,227 @@\n-   87, 87,160,161, 87, 87, 87, 87, 87, 87, 56, 56,162,163, 51, 56,\n-   56, 87, 56, 56, 56, 56, 56, 56, 56, 56,164,164,164,164,164,164,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87,165, 87,166, 87, 87,167,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87,168,168,169, 87, 87, 87,\n-   87, 87, 56, 56, 56, 87, 89, 89, 87, 87, 56, 56, 56, 56,170, 87,\n-   56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n-   56, 56, 87, 87, 87, 87, 87, 87, 87, 87, 62, 62, 62, 62, 62, 62,\n-   62, 62, 87, 87, 87, 87, 87, 87, 87, 87, 62, 62, 62, 62, 62, 87,\n-   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 62, 62, 62, 62, 62, 62,\n-   62, 87, 87, 87, 87, 87, 87, 87, 87, 87, 56, 87,171,171,  0,  1,\n-    2,  2,  0,  1,  2,  2,  2,  3,  4,  5,  0,  0,  0,  0,  1,  2,\n-    1,  2,  0,  0,  3,  3,  4,  5,  4,  5,  4,  4,  4,  4,  4,  4,\n-    4,  4,  4,  4,  4,  6,  0,  0,  7,  0,  8,  8,  8,  8,  8,  8,\n-    8,  9, 10, 11, 11, 11, 11, 11, 12, 11, 13, 13, 13, 13, 13, 13,\n-   13, 13, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 15, 16, 16,\n-   16, 16, 16, 17, 18, 18, 18, 18, 18, 18, 19, 20, 21, 21, 22, 23,\n-   21, 24, 21, 21, 21, 21, 21, 25, 21, 21, 26, 26, 26, 26, 26, 21,\n-   21, 21, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30,\n-   26, 26, 21, 21, 21, 21, 21, 21, 31, 21, 32, 32, 32, 32, 32, 33,\n-   34, 32, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36,\n-   36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38,\n-   38, 38, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 40,\n-   40, 40, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42,\n-   42, 42, 43, 43, 43, 43, 43, 43, 43, 43, 44, 44, 44, 45, 44, 44,\n-   44, 44, 46, 46, 46, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 47,\n-   47, 47, 47, 47, 47, 47, 47, 48, 47, 47, 49, 49, 49, 49, 49, 49,\n-   49, 49, 49, 49, 50, 50, 50, 50, 50, 51, 52, 52, 52, 52, 52, 52,\n-   52, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54,\n-   54, 54, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 57, 57, 57, 57,\n-   58, 57, 59, 59, 60, 61, 62, 62, 63, 63, 64, 64, 64, 64, 64, 64,\n-   64, 64, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 55, 55, 55,\n-   55, 55, 67, 67, 67, 67, 67, 68, 68, 68, 69, 69, 69, 69, 69, 69,\n-   64, 64, 70, 70, 71, 71, 71, 71, 71, 71, 71, 71, 71,  8,  8,  8,\n-    8,  8, 72, 72, 72, 72, 72, 72, 72, 72, 73, 73, 73, 73, 74, 74,\n-   74, 74, 75, 75, 75, 75, 75, 76, 76, 76, 13, 50, 50, 50, 73, 77,\n-   78, 79,  4,  4, 80,  4,  4, 81, 82, 83,  4,  4,  4, 84,  8,  8,\n-    8,  8, 11, 11, 11, 11, 11, 11, 11, 11, 85,  0,  0,  0,  0,  0,\n-    0, 86,  0,  4,  0,  0,  0,  8,  8,  8,  0,  0, 87, 88, 89,  0,\n-    4,  4,  6,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 90, 90, 90, 90, 90, 90, 90, 90, 91, 91, 91, 91, 91, 91,\n-    4,  4, 92, 92, 92, 92, 92, 92, 92, 92, 50, 50, 50, 93, 93, 93,\n-   93, 93, 53, 53, 53, 53, 53, 53, 13, 13, 94, 94, 94, 94, 94, 94,\n-   94, 94, 94, 94, 94, 94, 94, 94, 94,  0, 95,  0, 96, 97, 98, 99,\n-   99, 99, 99,100,101,102,102,102,102,103,104,104,104,105, 52, 52,\n-   52, 52, 52,  0,104,104,  0,  0,  0,102, 52, 52,  0,  0,  0,  0,\n-   52,106,  0,  0,  0,  0,  0,102,102,107,102,102,102,102,102,108,\n-    0,  0, 94, 94, 94, 94,  0,  0,  0,  0,109,109,109,109,109,109,\n-  109,109,109,109,109,109,109,110,110,110,111,111,111,111,111,111,\n-  111,111,111,111,111,111, 13, 13, 13, 13, 13, 13,112,112,112,112,\n-  112,112,  0,  0,113,  4,  4,  4,  4,  4,114,  4,  4,  4,  4,  4,\n-    4,  4,115,115,115,  0,116,116,116,116,117,117,117,117,117,117,\n-   32, 32,118,118,119,120,120,120, 52, 52,121,121,121,121,122,121,\n-   49, 49,123,123,123,123,123,123, 49, 49,124,124,124,124,124,124,\n-  125,125, 53, 53, 53,  4,  4,126,127, 54, 54, 54, 54, 54,125,125,\n-  125,125,128,128,128,128,128,128,128,128,  4,129, 18, 18, 18, 21,\n-   21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,130,  0, 21,\n-   21, 21,  8,  0,131,  0,  0,  0,  0, 21, 21, 21, 21, 21, 21, 21,\n-   21,132,  0,  0,  1,  2,  1,  2,133,101,102,134, 52, 52, 52, 52,\n-    0,  0,135,135,135,135,135,135,135,135,  0,  0,  0,  0, 11, 11,\n-   11, 11, 11,  0, 11, 11, 11,  0,  0,136,137,137,138,138,138,138,\n-  139,  0,140,140,140,141,141,142,142,142,143,143,144,144,144,144,\n-  144,144,145,145,145,145,145,146,146,146,147,147,147,148,148,148,\n-  148,148,149,149,149,150,150,150,150,150,151,151,151,151,151,151,\n-  151,151,152,152,152,152,153,153,154,154,155,155,155,155,155,155,\n-  156,156,157,157,158,158,158,158,158,158,159,159,160,160,160,160,\n-  160,160,161,161,161,161,161,161,162,162,163,163,163,163,164,164,\n-  164,164,165,165,165,165,166,166,167,167,168,168,168,168,168,168,\n-  168,168,169,169,169,169,169,169,169,169,170,170,170,170,170,170,\n-  170,170,171,171,171,171,171,171,171,171,172,172,172,172,172,172,\n-  172,172,173,173,173,174,174,174,174,174,175,175,175,175,175,175,\n-  176,176,177,177,177,177,177,177,177,177,178,178,178,178,178,179,\n-  179,179,180,180,180,180,180,181,181,181,182,182,182,182,182,182,\n-  183, 43,184,184,184,184,184,184,184,184,185,185,185,186,186,186,\n-  186,186,187,187,187,188,187,187,187,187,189,189,189,189,189,189,\n-  189,189,190,190,190,190,190,190,190,190,191,191,191,191,191,191,\n-  191,191,192,192,192,192,192,192, 66, 66,193,193,193,193,193,193,\n-  193,193,194,194,194,194,194,194,194,194,195,195,195,195,195,195,\n-  195,195,196,196,196,196,196,196,196,196,197,197,197,197,197,197,\n-  197,197,198,198,198,198,198,198,198,198,199,199,199,199,199,200,\n-  200,200,200,200,200,200,201,201,201,201,202,202,202,202,202,202,\n-  202,203,203,203,203,203,203,203,203,203,204,204,204,204,204,204,\n-  205,205,205,205,205,205,205,205,205,205,206,206,206,206,206,206,\n-  206,206,110,110,110,110, 39, 39, 39, 39,207,207,207,207,207,207,\n-  207,207,208,208,208,208,208,208,208,208,209,209,209,209,209,209,\n-  209,209,112,112,112,112,112,112,112,112,112,112,112,112,210,210,\n-  210,210,211,211,211,211,211,211,211,211,212,212,212,212,212,212,\n-  212,212,213,213,213,213,213,213,213,213,214,214,214,214,214,214,\n-  214,214,214,214,214,214,214,214,215, 94,216,216,216,216,216,216,\n-  216,216,217,217,217,217,217,217,217,217,218, 99, 99, 99, 99, 99,\n-   99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,\n-  219,220,220,220,220,220,220,220,220,220,221,221,221,221,221,221,\n-  221,221,221,221,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-  222,223,224,  0,225,  0,  0,  0,  0,  0,226,226,226,226,226,226,\n-  226,226, 91, 91, 91, 91, 91, 91, 91, 91,227,227,227,227,227,227,\n-  227,227,228,228,228,228,228,228,228,228,229,229,229,229,229,229,\n-  229,229,230,230,230,230,230,230,230,230,231,  0,  0,  0,  0,  0,\n-    0,  0,  8,  8,  8,  8,  8,  8,  8,  8,  0,  0,  0,  0,  1,  2,\n-    2,  2,  2,  2,  3,  0,  0,  0,  4,  0,  2,  2,  2,  2,  2,  3,\n-    2,  2,  2,  2,  5,  0,  2,  5,  6,  0,  7,  7,  7,  7,  8,  9,\n-    8, 10,  8, 11,  8,  8,  8,  8,  8,  8, 12, 13, 13, 13, 14, 14,\n-   14, 14, 14, 15, 14, 14, 16, 17, 17, 17, 17, 17, 17, 17, 18, 19,\n-   19, 19, 19, 19, 19, 19, 20, 21, 20, 22, 20, 20, 23, 23, 20, 20,\n-   20, 20, 22, 20, 24,  7,  7, 25, 20, 20, 26, 20, 20, 20, 20, 20,\n-   20, 21, 27, 27, 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30,\n-   30, 30, 31, 31, 31, 31, 32, 20, 20, 20, 33, 33, 33, 33, 34, 35,\n-   33, 33, 33, 36, 33, 33, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39,\n-   39, 39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43,\n-   43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46,\n-   46, 47, 48, 48, 48, 48, 49, 49, 49, 49, 49, 50, 51, 49, 52, 52,\n-   52, 52, 53, 53, 53, 53, 53, 53, 54, 53, 55, 55, 55, 55, 56, 56,\n-   56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59, 60, 60,\n-   60, 60, 60, 60, 61, 62, 63, 63, 63, 63, 64, 64, 64, 64, 64, 65,\n-    0,  0, 66, 66, 66, 66, 67, 67, 67, 67, 68, 68, 68, 68, 69, 70,\n-   71, 71, 71, 71, 71, 71, 72, 72, 72, 72, 73, 73, 73, 73, 74, 74,\n-   74, 74, 75, 75, 75, 75, 76, 76, 76, 76, 77, 77, 77, 77, 78, 78,\n-   78, 78, 79, 79, 79, 79, 80, 80, 80, 80, 81, 81, 81, 81, 82,  7,\n-    7,  7, 83,  7, 84, 85,  0, 84, 86,  0,  2, 87, 88,  2,  2,  2,\n-    2, 89, 90, 87, 91,  2,  2,  2, 92,  2,  2,  2,  2, 93,  0,  0,\n-    0, 86,  1,  0,  0, 94,  0, 95, 96,  0,  4,  0,  0,  0,  0,  0,\n-    0,  4, 97, 97, 97, 97, 98, 98, 98, 98, 13, 13, 13, 13, 99, 99,\n-   99, 99,100,100,100,100,  0,101,  0,  0,102,100,103,104,  0,  0,\n-  100,  0,105,106,106,106,106,106,106,106,106,106,107,105,108,109,\n-  109,109,109,109,109,109,109,109,110,108,111,111,111,111,112, 55,\n-   55, 55, 55, 55, 55,113,109,109,109,110,109,109,  0,  0,114,114,\n-  114,114,115,115,115,115,116,116,116,116,117,117,117,117, 96,  2,\n-    2,  2,  2,  2, 94,  2,118,118,118,118,119,119,119,119,120,120,\n-  120,120,121,121,121,121,121,121,121,122,123,123,123,123,124,124,\n-  124,124,124,124,124,125,126,126,126,126,127,127,127,127,128,128,\n-  128,128,  2,  2,  3,  2,  2,129,130,  0,131,131,131,131,132, 17,\n-   17, 18, 20, 20, 20,133,  7,  7,  7,134, 20, 20, 20, 23,  0,135,\n-  109,109,109,109,109,136,137,137,137,137,  0,  0,  0,138,139,139,\n-  139,139,140,140,140,140, 84,  0,  0,  0,141,141,141,141,142,142,\n-  142,142,143,143,143,143,144,144,144,144,145,145,145,145,146,146,\n-  146,146,147,147,147,147,148,148,148,148,149,149,149,149,150,150,\n-  150,150,151,151,151,151,152,152,152,152,153,153,153,153,154,154,\n-  154,154,155,155,155,155,156,156,156,156,157,157,157,157,158,158,\n-  158,158,159,159,159,159,160,160,160,160,161,161,161,161,162,162,\n-  162,162,163,163,163,163,164,164,164,164,165,165,165,165,166,166,\n-  166,166,167,167,167,167,168,168,168,168,169,169,169,169,170,170,\n-  170,170,171,171,171,171,172,172,172,172,173,173,173,173,174,174,\n-  174,174,175,175,175,175,176,176,176,176,177,177,177,177,178,178,\n-  178,178,179,179,179,179,180,180,180,180,181,181,181,181,182,182,\n-  182,182,183,183,183,183,184, 45, 45, 45,185,185,185,185,186,186,\n-  186,186,187,187,187,187,188,188,188,188,188,188,189,188,190,190,\n-  190,190,191,191,191,191,192,192,192,192,193,193,193,193,194,194,\n-  194,194,195,195,195,195,196,196,196,196,197,197,197,197,198,198,\n-  198,198,199,199,199,199,200,200,200,200,201,201,201,201,202,202,\n-  202,202,203,203,203,203,204,204,204,204,205,205,205,205,206,206,\n-  206,206,207,207,207,207,208,208,208,208,209,209,209,209,210,210,\n-  210,210,211,211,211,211,212,212,212,212,213,213,213,213,214,214,\n-  214,214,215,215,215,215,216,217,217,217,218,218,218,218,217,217,\n-  217,217,219,106,106,106,106,109,109,109,220,220,220,220,221,221,\n-  221,221,  0,222, 86,  0,  0,  0,222,  7, 82,138,  7,  0,  0,  0,\n-  223, 86,224,224,224,224,225,225,225,225,226,226,226,226,227,227,\n-  227,227,228,228,228,228,229,  0,  0,  0,  0,  0,  0,  0,  0, 19,\n-   19, 19, 19, 19, 19, 19, 19, 19, 19,  0,  0,  0, 19,  0, 19,  0,\n-    0,  0,  0,  0, 26, 26,  1,  1,  1,  1,  9,  9,  9,  9,  0,  9,\n-    9,  9,  9,  9,  0,  9,  9,  0,  9,  0,  9,  9, 55, 55, 55, 55,\n-   55, 55,  6,  6,  6,  6,  6,  1,  1,  6,  6,  4,  4,  4,  4,  4,\n-    4,  4,  4, 14, 14, 14, 14, 14, 14, 14,  3,  3,  3,  3,  3,  0,\n-    3,  3,  0,  3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  1,  1,  1,\n-    3,  3,  1,  3,  3,  3, 37, 37, 37, 37, 38, 38, 38, 38, 64, 64,\n-   64, 64, 90, 90, 90, 90, 95, 95, 95, 95,  3,  3,  0,  3,  7,  7,\n-    7,  7,  7,  1,  1,  1,  1,  7,  7,  7,  0,  0,  7,  7,  5,  5,\n-    5,  5, 11, 11, 11, 11, 10, 10, 10, 10, 21, 21, 21, 21, 22, 22,\n-   22, 22, 23, 23, 23, 23, 16, 16, 16, 16, 20, 20, 20, 20, 36, 36,\n-   36, 36, 24, 24, 24, 24, 24, 24, 24,  0, 18, 18, 18, 18, 25, 25,\n-   25, 25, 25,  0,  0,  0,  0, 25, 25, 25, 33, 33, 33, 33,  8,  8,\n-    8,  8,  8,  8,  8,  0, 12, 12, 12, 12, 30, 30, 30, 30, 29, 29,\n-   29, 29, 28, 28, 28, 28, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35,\n-   35,  0,  0,  0, 35, 35, 45, 45, 45, 45, 44, 44, 44, 44, 44,  0,\n-    0,  0, 43, 43, 43, 43, 46, 46, 46, 46, 31, 31, 31, 31, 32, 32,\n-    0,  0, 32,  0, 32, 32, 32, 32, 32, 32, 48, 48, 48, 48, 52, 52,\n-   52, 52, 58, 58, 58, 58, 54, 54, 54, 54, 91, 91, 91, 91, 62, 62,\n-   62, 62, 76, 76, 76, 76, 93, 93, 93, 93, 70, 70, 70, 70, 73, 73,\n-   73, 73,  1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  0,  0,  1,\n-    0,  0,  1,  1,  0,  0, 19, 19,  9,  9,  9,  9,  9,  6, 19,  9,\n-    9,  9,  9,  9, 19, 19,  9,  9,  9, 19,  6, 19, 19, 19, 19, 19,\n-   19,  9,  0,  0,  0, 19,  0,  0,  9,  0,  0,  0, 19, 19, 27, 27,\n-   27, 27, 56, 56, 56, 56, 61, 61, 61, 61, 13, 13, 13, 13,  0, 13,\n-    0, 13,  0, 13, 13, 13, 13, 13,  1,  1,  1,  1, 12, 12,  0, 15,\n-   15, 15, 15, 15, 15, 15, 15,  1,  1,  0,  0, 17, 17, 17, 17, 17,\n-   17, 17, 17, 17, 17,  0, 26, 26, 26, 26, 26, 12, 12, 12, 12, 12,\n-   12,  0, 39, 39, 39, 39, 86, 86, 86, 86, 77, 77, 77, 77, 79, 79,\n-   79, 79, 60, 60, 60, 60, 65, 65, 65, 65, 75, 75, 75, 75, 69, 69,\n-   69, 69, 69, 69,  0, 69, 74, 74, 74, 74, 84, 84, 84, 84, 84, 84,\n-   84,  0, 68, 68, 68, 68, 92, 92, 92, 92, 87, 87, 87, 87, 19,  9,\n-   19, 19, 19, 19,  0,  0,  2,  2,  2,  2, 19, 19, 19,  4,  3,  3,\n-    0,  0,  1,  1,  6,  6,  0,  0, 17, 17, 17, 17,  0,  0, 49, 49,\n-   49, 49,  0,  1,  1,  1, 71, 71, 71, 71, 67, 67, 67, 67, 42, 42,\n-   42, 42, 41, 41, 41, 41,118,118,118,118, 53, 53, 53, 53, 59, 59,\n-   59, 59, 40, 40, 40, 40, 51, 51, 51, 51, 50, 50, 50, 50,135,135,\n-  135,135,106,106,106,106,104,104,104,104,110,110,110,110, 47, 47,\n-   47, 47, 81, 81, 81, 81,120,120,120,120,116,116,116,116,128,128,\n-  128,128, 66, 66, 66, 66, 72, 72, 72, 72, 98, 98, 98, 98, 97, 97,\n-   97, 97, 57, 57, 57, 57, 88, 88, 88, 88,117,117,117,117,112,112,\n-  112,112, 78, 78, 78, 78, 83, 83, 83, 83, 82, 82, 82, 82,122,122,\n-  122,122, 89, 89, 89, 89,130,130,130,130,144,144,144,144,156,156,\n-  156,156,147,147,147,147,148,148,148,148,153,153,153,153,149,149,\n-  149,149, 94, 94, 94, 94, 85, 85, 85, 85,101,101,101,101, 96, 96,\n-   96, 96,111,111,111,111,100,100,100,100,100, 36, 36, 36,108,108,\n-  108,108,129,129,129,129,109,109,109,109,107,107,107,107,107,107,\n-  107,  1,137,137,137,137,124,124,124,124,123,123,123,123,114,114,\n-  114,114,102,102,102,102,126,126,126,126,142,142,142,142,125,125,\n-  125,125,154,154,154,154,150,150,150,150,141,141,141,141,140,140,\n-  140,140,121,121,121,121,133,133,133,133,134,134,134,134,138,138,\n-  138,138,143,143,143,143,145,145,145,145, 63, 63, 63, 63, 80, 80,\n-   80, 80,127,127,127,127,115,115,115,115,103,103,103,103,119,119,\n-  119,119,146,146,146,146, 99, 99, 99, 99,136,139,  0,  0,155,155,\n-  155,155,136,136,136,136, 17, 15, 15, 15,139,139,139,139,105,105,\n-  105,105,  0,  0,  0,  1,  0,  0,  1,  1,131,131,131,131,151,151,\n-  151,151,152,152,152,152,113,113,113,113,132,132,132,132, 15,  0,\n-    0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  9,  9,  9, 10,\n-    9, 11, 12, 13,  9,  9,  9, 14,  9,  9, 15,  9,  9,  9,  9,  9,\n+   87, 87, 87,146,147,147,147,147,147,147,147,147,147, 87, 87, 87,\n+   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,148,148,148,148,\n+  148, 87, 87, 87,149,149,149,149,150,151,152,152, 87, 87, 87, 87,\n+  153,153,154,155,156,156,156,156,156,156,156,156,156,156,156,156,\n+  156,156,156,156,156,156,156,156,156,156,157,157,157,157,156, 87,\n+   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+   87, 87, 87,158,159,160,161,162,162,162, 87, 87, 87, 87, 87, 87,\n+   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,163,164, 87, 87,\n+   87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,\n+   87, 87,165, 56, 56, 56,166,167, 51, 56, 56, 87, 56, 56, 56, 56,\n+   56, 56, 56, 56,168,168,168,168,168,168, 87, 87, 87, 87, 87, 87,\n+   87, 87,  2, 87,169, 87,170, 87, 87,171, 87, 87, 87, 87, 87, 87,\n+   87, 87, 87, 33,172,172,173, 87, 87, 87, 87, 87, 56, 56, 56, 87,\n+   89, 89, 87, 87, 56, 56, 56, 56,174, 87, 56, 56, 56, 56, 56, 56,\n+   56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 87, 87, 87, 87,\n+   87, 87, 87, 87, 62, 62, 62, 62, 62, 62, 62, 62, 87, 87, 87, 87,\n+   87, 87, 87, 87, 62, 62, 62, 62, 62, 87, 87, 87, 87, 87, 87, 87,\n+   87, 87, 87, 87, 62, 62, 62, 62, 62, 62, 62, 87, 87, 87, 87, 87,\n+   87, 87, 87, 87, 56, 87,175,175,  0,  1,  2,  2,  0,  1,  2,  2,\n+    2,  3,  4,  5,  0,  0,  0,  0,  1,  2,  1,  2,  0,  0,  3,  3,\n+    4,  5,  4,  5,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  6,\n+    0,  0,  7,  0,  8,  8,  8,  8,  8,  8,  8,  9, 10, 11, 11, 11,\n+   11, 11, 12, 11, 13, 13, 13, 13, 13, 13, 13, 13, 14, 13, 13, 13,\n+   13, 13, 13, 13, 13, 13, 13, 15, 16, 16, 16, 16, 16, 17, 18, 18,\n+   18, 18, 18, 18, 19, 20, 21, 21, 22, 23, 21, 24, 21, 21, 21, 21,\n+   21, 25, 21, 21, 26, 26, 26, 26, 26, 21, 21, 21, 27, 27, 27, 27,\n+   28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 26, 21, 21, 21, 21, 21,\n+   21, 21, 31, 21, 32, 32, 32, 32, 32, 33, 34, 32, 35, 35, 35, 35,\n+   35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 37, 37, 37, 37,\n+   37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39,\n+   39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41,\n+   41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43,\n+   43, 43, 43, 43, 44, 44, 44, 45, 44, 44, 44, 44, 46, 46, 46, 46,\n+   46, 46, 46, 46, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,\n+   47, 48, 47, 47, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50, 50,\n+   50, 50, 50, 51, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53,\n+   53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55,\n+   55, 55, 55, 55, 56, 56, 57, 57, 57, 57, 58, 57, 59, 59, 60, 61,\n+   62, 62, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 65, 66, 66, 66,\n+   66, 66, 66, 66, 66, 66, 66, 55, 55, 55, 55, 55, 67, 67, 67, 67,\n+   67, 68, 68, 68, 69, 69, 69, 69, 69, 69, 64, 64, 70, 70, 71, 71,\n+   71, 71, 71, 71, 71, 71, 71,  8,  8,  8,  8,  8, 72, 72, 72, 72,\n+   72, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75,\n+   75, 76, 76, 76, 13, 50, 50, 50, 73, 77, 78, 79,  4,  4, 80,  4,\n+    4, 81, 82, 83,  4,  4,  4, 84,  8,  8,  8,  8, 11, 11, 11, 11,\n+   11, 11, 11, 11, 85,  0,  0,  0,  0,  0,  0, 86,  0,  4,  0,  0,\n+    0,  8,  8,  8,  0,  0, 87, 88, 89,  0,  4,  4,  6,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 90, 90, 90, 90,\n+   90, 90, 90, 90, 91, 91, 91, 91, 91, 91,  4,  4, 92, 92, 92, 92,\n+   92, 92, 92, 92, 50, 50, 50, 93, 93, 93, 93, 93, 53, 53, 53, 53,\n+   53, 53, 13, 13, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94,\n+   94, 94, 94,  0, 95,  0, 96, 97, 98, 99, 99, 99, 99,100,101,102,\n+  102,102,102,103,104,104,104,105, 52, 52, 52, 52, 52,  0,104,104,\n+    0,  0,  0,102, 52, 52,  0,  0,  0,  0, 52,106,  0,  0,  0,  0,\n+    0,102,102,107,102,102,102,102,102,108,  0,  0, 94, 94, 94, 94,\n+    0,  0,  0,  0,109,109,109,109,109,109,109,109,109,109,109,109,\n+  109,110,110,110,111,111,111,111,111,111,111,111,111,111,111,111,\n+   13, 13, 13, 13, 13, 13,112,112,112,112,112,112,  0,  0,113,  4,\n+    4,  4,  4,  4,114,  4,  4,  4,  4,  4,  4,  4,115,115,115,  0,\n+  116,116,116,116,117,117,117,117,117,117, 32, 32,118,118,119,120,\n+  120,120, 52, 52,121,121,121,121,122,121, 49, 49,123,123,123,123,\n+  123,123, 49, 49,124,124,124,124,124,124,125,125, 53, 53, 53,  4,\n+    4,126,127, 54, 54, 54, 54, 54,125,125,125,125,128,128,128,128,\n+  128,128,128,128,  4,129, 18, 18, 18, 21, 21, 21, 21, 21, 21, 21,\n+   21, 21, 21, 21, 21, 21, 21,130, 21, 21, 21, 21,  8,  0,131,  0,\n+    0,  0,  0, 21, 21, 21, 21, 21, 21, 21, 21,132,  0,  0,  1,  2,\n+    1,  2,133,101,102,134, 52, 52, 52, 52,  0,  0,135,135,135,135,\n+  135,135,135,135,  0,  0,  0,  0, 11, 11, 11, 11, 11,  0, 11, 11,\n+   11,  0,  0,136,137,137,138,138,138,138,139,  0,140,140,140,141,\n+  141,142,142,142,143,143,144,144,144,144,144,144,145,145,145,145,\n+  145,146,146,146,147,147,147,148,148,148,148,148,149,149,149,150,\n+  150,150,150,151,151,151,151,151,151,151,151,151,152,152,152,152,\n+  152,152,152,152,153,153,153,153,154,154,155,155,156,156,156,156,\n+  156,156,157,157,158,158,159,159,159,159,159,159,160,160,161,161,\n+  161,161,161,161,162,162,162,162,162,162,163,163,164,164,164,164,\n+  165,165,165,165,166,166,166,166,167,167,168,168,169,169,169,169,\n+  169,169,169,169,170,170,170,170,170,170,170,170,171,171,171,171,\n+  171,171,171,171,172,172,172,172,172,172,172,172,173,173,173,173,\n+  173,173,173,173,174,174,174,175,175,175,175,176,176,176,176,177,\n+  177,177,178,178,179,179,179,179,179,179,179,179,180,180,180,180,\n+  180,181,181,181,182,182,182,182,182,183,183,183,184,184,184,184,\n+  184,184,185, 43,186,186,186,186,186,186,186,186,187,187,187,188,\n+  188,188,188,188,189,189,189,190,189,189,189,189,191,191,191,191,\n+  191,191,191,191,192,192,192,192,192,192,192,192,193,193,193,193,\n+  193,193,193,193,194,194,194,194,194,194, 66, 66,195,195,195,195,\n+  195,195,195,195,196,196,196,196,196,196,196,196,197,197,197,197,\n+  197,197,197,197,198,198,198,198,198,198,198,198,199,199,199,199,\n+  199,199,199,199,200,200,200,200,200,200,200,200,201,201,201,201,\n+  201,202,202,202,202,202,202, 55,203,203,203,203,204,204,204,204,\n+  204,204,204,205,205,205,205,205,205,205,205,205,206,206,206,206,\n+  206,206,207,207,207,207,207,207,207,207,207,207,208,208,208,208,\n+  208,208,208,208,110,110,110,110, 39, 39, 39, 39,209,209,209,209,\n+  209,209,209,209,210,210,210,210,210,210,210,210,211,211,211,211,\n+  211,211,211,211,212,212,212,212,212,212,212,212,112,112,112,112,\n+  112,112,112,112,112,112,112,112,213,213,213,214,214,214,214,214,\n+  214,215,215,215,216,216,216,216,216,216,216,216,217,217,217,217,\n+  217,217,217,217,218,218,218,218,218,218,218,218,218,218,218,218,\n+  218,218,219, 94,220,220,220,220,220,220,220,220,221,221,221,221,\n+  221,221,221,221,102,102,102,102,102,102,102,102,222, 99, 99, 99,\n+   99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,102,102,\n+  102, 99,223,224,224,224,224,224,224,224,224,224,225,225,225,225,\n+  225,225,225,225,225,225,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,\n+    8,  0,  0,  0,  0,  0,  0,  0,  0,  0,226,227,228,  0,229,  0,\n+    0,  0,  0,  0,230,230,230,230,230,230,230,230, 91, 91, 91, 91,\n+   91, 91, 91, 91,231,231,231,231,231,231,231,231,232,232,232,232,\n+  233,233,233,233,234,234,234,234,234,234,234,234,235,235,235,235,\n+  235,235,235,235,236,  0,  0,  0,  0,  0,  0,  0,  8,  8,  8,  8,\n+    8,  8,  8,  8,  0,  0,  0,  0,  1,  2,  2,  2,  2,  2,  3,  0,\n+    0,  0,  4,  0,  2,  2,  2,  2,  2,  3,  2,  2,  2,  2,  5,  0,\n+    2,  5,  6,  0,  7,  7,  7,  7,  8,  9,  8, 10,  8, 11,  8,  8,\n+    8,  8,  8,  8, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 14, 14,\n+   16, 17, 17, 17, 17, 17, 17, 17, 18, 19, 19, 19, 19, 19, 19, 19,\n+   20, 21, 20, 22, 20, 20, 23, 23, 20, 20, 20, 20, 22, 20, 24,  7,\n+    7, 25, 20, 20, 26, 20, 20, 20, 20, 20, 20, 21, 27, 27, 27, 27,\n+   28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31,\n+   32, 20, 20, 20, 33, 33, 33, 33, 34, 35, 33, 33, 33, 36, 33, 33,\n+   37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40,\n+   41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43, 44, 44, 44, 44,\n+   45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 47, 48, 48, 48, 48,\n+   49, 49, 49, 49, 49, 50, 51, 49, 52, 52, 52, 52, 53, 53, 53, 53,\n+   53, 53, 54, 53, 55, 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57,\n+   58, 58, 58, 58, 59, 59, 59, 59, 60, 60, 60, 60, 60, 60, 61, 62,\n+   63, 63, 63, 63, 64, 64, 64, 64, 64, 65,  0,  0, 66, 66, 66, 66,\n+   67, 67, 67, 67, 68, 68, 68, 68, 69, 70, 71, 71, 71, 71, 71, 71,\n+   72, 72, 72, 72, 73, 73, 73, 73, 74, 74, 74, 74, 75, 75, 75, 75,\n+   76, 76, 76, 76, 77, 77, 77, 77, 78, 78, 78, 78, 79, 79, 79, 79,\n+   80, 80, 80, 80, 81, 81, 81, 81, 82,  7,  7,  7, 83,  7, 84, 85,\n+    0, 84, 86,  0,  2, 87, 88,  2,  2,  2,  2, 89, 90, 87, 91,  2,\n+    2,  2, 92,  2,  2,  2,  2, 93,  0,  0,  0, 86,  1,  0,  0, 94,\n+    0, 95, 96,  0,  4,  0,  0,  0,  0,  0,  0,  4, 97, 97, 97, 97,\n+   98, 98, 98, 98, 13, 13, 13, 13, 99, 99, 99, 99,100,100,100,100,\n+    0,101,  0,  0,102,100,103,104,  0,  0,100,  0,105,106,106,106,\n+  106,106,106,106,106,106,107,105,108,109,109,109,109,109,109,109,\n+  109,109,110,108,111,111,111,111,112, 55, 55, 55, 55, 55, 55,113,\n+  109,109,109,110,109,109,  0,  0,114,114,114,114,115,115,115,115,\n+  116,116,116,116,117,117,117,117, 96,  2,  2,  2,  2,  2, 94,  2,\n+  118,118,118,118,119,119,119,119,120,120,120,120,121,121,121,121,\n+  121,121,121,122,123,123,123,123,124,124,124,124,124,124,124,125,\n+  126,126,126,126,127,127,127,127,128,128,128,128,  2,  2,  3,  2,\n+    2,129,130,  0,131,131,131,131,132, 17, 17, 18, 20, 20, 20,133,\n+    7,  7,  7,134, 20, 20, 20, 23,  0,135,109,109,109,109,109,136,\n+  137,137,137,137,  0,  0,  0,138,139,139,139,139,140,140,140,140,\n+   84,  0,  0,  0,141,141,141,141,142,142,142,142,143,143,143,143,\n+  144,144,144,144,145,145,145,145,146,146,146,146,147,147,147,147,\n+  148,148,148,148,149,149,149,149,150,150,150,150,151,151,151,151,\n+  152,152,152,152,153,153,153,153,154,154,154,154,155,155,155,155,\n+  156,156,156,156,157,157,157,157,158,158,158,158,159,159,159,159,\n+  160,160,160,160,161,161,161,161,162,162,162,162,163,163,163,163,\n+  164,164,164,164,165,165,165,165,166,166,166,166,167,167,167,167,\n+  168,168,168,168,169,169,169,169,170,170,170,170,171,171,171,171,\n+  172,172,172,172,173,173,173,173,174,174,174,174,175,175,175,175,\n+  176,176,176,176,177,177,177,177,178,178,178,178,179,179,179,179,\n+  180,180,180,180,181,181,181,181,182,182,182,182,183,183,183,183,\n+  184,184,184,184,185,185,185,185,186, 45, 45, 45,187,187,187,187,\n+  188,188,188,188,189,189,189,189,190,190,190,190,190,190,191,190,\n+  192,192,192,192,193,193,193,193,194,194,194,194,195,195,195,195,\n+  196,196,196,196,197,197,197,197,198,198,198,198,199,199,199,199,\n+  200,200,200,200,201,201,201,201,202,202,202,202,203,203,203,203,\n+  204,204,204,204,205,205,205,205,206,206,206,206,207,207,207,207,\n+  208,208,208,208,209,209,209,209,210,210,210,210,211,211,211,211,\n+  212,212,212,212,213,213,213,213,214,214,214,214,215,215,215,215,\n+  216,216,216,216,217,217,217,217,218,218,218,218,219,219,219,219,\n+  220,221,221,221,222,222,222,222,221,221,221,221,223,106,106,106,\n+  106,109,109,109,224,224,224,224,225,225,225,225,  0,226, 86,  0,\n+    0,  0,226,  7, 82,138,  7,  0,  0,  0,227, 86,228,228,228,228,\n+  229,229,229,229,230,230,230,230,231,231,231,231,232,232,232,232,\n+  233,233,233,233,234,  0,  0,  0,  0,  0,  0,  0,  0, 19, 19, 19,\n+   19, 19, 19, 19, 19, 19, 19,  0,  0,  0, 19,  0, 19,  0,  0,  0,\n+    0,  0, 26, 26,  1,  1,  1,  1,  9,  9,  9,  9,  0,  9,  9,  9,\n+    9,  9,  0,  9,  9,  0,  9,  0,  9,  9, 55, 55, 55, 55, 55, 55,\n+    6,  6,  6,  6,  6,  1,  1,  6,  6,  4,  4,  4,  4,  4,  4,  4,\n+    4, 14, 14, 14, 14, 14, 14, 14,  3,  3,  3,  3,  3,  0,  3,  3,\n+    0,  3,  3,  3,  3,  3,  3,  0,  3,  3,  3,  1,  1,  1,  3,  3,\n+    1,  3,  3,  3, 37, 37, 37, 37, 38, 38, 38, 38, 64, 64, 64, 64,\n+   90, 90, 90, 90, 95, 95, 95, 95,  3,  3,  0,  3,  7,  7,  7,  7,\n+    7,  1,  1,  1,  1,  7,  7,  7,  0,  0,  7,  7,  5,  5,  5,  5,\n+   11, 11, 11, 11, 10, 10, 10, 10, 21, 21, 21, 21, 22, 22, 22, 22,\n+   23, 23, 23, 23, 16, 16, 16, 16, 20, 20, 20, 20, 36, 36, 36, 36,\n+   24, 24, 24, 24, 24, 24, 24,  0, 18, 18, 18, 18, 25, 25, 25, 25,\n+   25,  0,  0,  0,  0, 25, 25, 25, 33, 33, 33, 33,  8,  8,  8,  8,\n+    8,  8,  8,  0, 12, 12, 12, 12, 30, 30, 30, 30, 29, 29, 29, 29,\n+   28, 28, 28, 28, 34, 34, 34, 34, 35, 35, 35, 35, 35, 35, 35,  0,\n+    0,  0, 35, 35, 45, 45, 45, 45, 44, 44, 44, 44, 44,  0,  0,  0,\n+   43, 43, 43, 43, 46, 46, 46, 46, 31, 31, 31, 31, 32, 32,  0,  0,\n+   32,  0, 32, 32, 32, 32, 32, 32, 48, 48, 48, 48, 52, 52, 52, 52,\n+   58, 58, 58, 58, 54, 54, 54, 54, 91, 91, 91, 91, 62, 62, 62, 62,\n+   76, 76, 76, 76, 93, 93, 93, 93, 70, 70, 70, 70, 73, 73, 73, 73,\n+    1,  1,  1,  0,  1,  0,  1,  1,  1,  0,  0,  0,  0,  1,  0,  0,\n+    1,  1,  0,  0, 19, 19,  9,  9,  9,  9,  9,  6, 19,  9,  9,  9,\n+    9,  9, 19, 19,  9,  9,  9, 19,  6, 19, 19, 19, 19, 19, 19,  9,\n+    0,  0,  0, 19,  0,  0,  9,  0,  0,  0, 19, 19, 27, 27, 27, 27,\n+   56, 56, 56, 56, 61, 61, 61, 61, 13, 13, 13, 13,  0, 13,  0, 13,\n+    0, 13, 13, 13, 13, 13,  1,  1,  1,  1, 12, 12,  0, 15, 15, 15,\n+   15, 15, 15, 15, 15,  1,  1,  0,  0, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17,  0, 26, 26, 26, 26, 26, 12, 12, 12, 12, 12, 12,  0,\n+   39, 39, 39, 39, 86, 86, 86, 86, 77, 77, 77, 77, 79, 79, 79, 79,\n+   60, 60, 60, 60, 65, 65, 65, 65, 75, 75, 75, 75, 69, 69, 69, 69,\n+   69, 69,  0, 69, 74, 74, 74, 74, 84, 84, 84, 84, 84, 84, 84,  0,\n+   68, 68, 68, 68, 92, 92, 92, 92, 87, 87, 87, 87, 19,  9, 19, 19,\n+   19, 19,  0,  0,  2,  2,  2,  2, 19, 19, 19,  4,  3,  3,  0,  0,\n+    1,  1,  6,  6,  0,  0, 17, 17, 17, 17,  0,  0, 49, 49, 49, 49,\n+    0,  1,  1,  1, 71, 71, 71, 71, 67, 67, 67, 67, 42, 42, 42, 42,\n+   41, 41, 41, 41,118,118,118,118, 53, 53, 53, 53, 59, 59, 59, 59,\n+   40, 40, 40, 40, 51, 51, 51, 51, 50, 50, 50, 50,135,135,135,135,\n+  106,106,106,106,104,104,104,104,161,161,161,161,110,110,110,110,\n+   47, 47, 47, 47, 81, 81, 81, 81,120,120,120,120,116,116,116,116,\n+  128,128,128,128, 66, 66, 66, 66, 72, 72, 72, 72, 98, 98, 98, 98,\n+   97, 97, 97, 97, 57, 57, 57, 57, 88, 88, 88, 88,117,117,117,117,\n+  112,112,112,112, 78, 78, 78, 78, 83, 83, 83, 83, 82, 82, 82, 82,\n+  122,122,122,122, 89, 89, 89, 89,130,130,130,130,144,144,144,144,\n+  156,156,156,156,147,147,147,147,148,148,148,148,158,158,158,158,\n+  153,153,153,153,149,149,149,149, 94, 94, 94, 94, 85, 85, 85, 85,\n+  101,101,101,101, 96, 96, 96, 96,111,111,111,111,100,100,100,100,\n+  100, 36, 36, 36,108,108,108,108,129,129,129,129,109,109,109,109,\n+  107,107,107,107,107,107,107,  1,137,137,137,137,124,124,124,124,\n+  123,123,123,123,114,114,114,114,102,102,102,102,126,126,126,126,\n+  142,142,142,142,125,125,125,125,154,154,154,154,150,150,150,150,\n+  141,141,141,141,140,140,140,140,121,121,121,121,133,133,133,133,\n+  134,134,134,134,138,138,138,138,143,143,143,143,145,145,145,145,\n+   63, 63, 63, 63,157,157,157,157, 80, 80, 80, 80,127,127,127,127,\n+  115,115,115,115,159,159,159,159,103,103,103,103,119,119,119,119,\n+  146,146,146,146, 99, 99, 99, 99,136,139, 13, 13,155,155,155,155,\n+  136,136,136,136, 17, 15, 15, 15,139,139,139,139,105,105,105,105,\n+    0,  0,  0,  1,  0,  0,  1,  1,131,131,131,131,151,151,151,151,\n+  160,160,160,160,152,152,152,152,113,113,113,113,132,132,132,132,\n+   15,  0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  9,  9,\n+    9, 10,  9, 11, 12, 13,  9,  9,  9, 14,  9,  9, 15,  9,  9,  9,\n@@ -6358,2 +6466,0 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 16, 17,\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 18, 19, 20,  9, 21,  9,\n@@ -6361,0 +6467,2 @@\n+   16, 17,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 18, 19, 20,  9,\n+   21,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n@@ -6365,1 +6473,1 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 22,  9,  9,  9,  9,  9,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 22,  9,  9,  9,\n@@ -6374,9 +6482,8 @@\n-    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 23, 24,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,\n-    5,  6,  7,  8,  9, 10, 11, 12,  0,  0, 13, 14, 15, 16, 17, 18,\n-   19, 20, 21, 22,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 23,  0,  0, 24, 25, 26, 27, 28, 29, 30,  0,  0,\n-   31, 32,  0, 33,  0, 34,  0, 35,  0,  0,  0,  0, 36, 37, 38, 39,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 42,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,\n+   23, 24,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,\n+    3,  4,  5,  6,  7,  8,  9, 10, 11, 12,  0,  0, 13, 14, 15, 16,\n+   17, 18, 19, 20, 21, 22,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 23,  0,  0, 24, 25, 26, 27, 28, 29, 30,\n+    0,  0, 31, 32,  0, 33,  0, 34,  0, 35,  0,  0,  0,  0, 36, 37,\n+   38, 39,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0, 40,  0,  0,  0,  0,  0,  0,  0,  0,  0, 41, 42,\n@@ -6384,5 +6491,0 @@\n-    0,  0, 43, 44,  0, 45,  0,  0,  0,  0,  0,  0, 46, 47,  0,  0,\n-    0,  0,  0, 48,  0, 49,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0, 50, 51,  0,  0,  0, 52,  0,  0, 53,  0,  0,  0,\n-    0,  0,  0,  0, 54,  0,  0,  0,  0,  0,  0,  0, 55,  0,  0,  0,\n-    0,  0,  0,  0, 56,  0,  0,  0,  0,  0,  0,  0,  0, 57,  0,  0,\n@@ -6390,2 +6492,5 @@\n-    0,  0,  0,  0, 58, 59, 60, 61, 62, 63, 64, 65,  0,  0,  0,  0,\n-    0,  0, 66,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0, 43, 44,  0, 45,  0,  0,  0,  0,  0,  0, 46, 47,\n+    0,  0,  0,  0,  0, 48,  0, 49,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0, 50, 51,  0,  0,  0, 52,  0,  0, 53,  0,\n+    0,  0,  0,  0,  0,  0, 54,  0,  0,  0,  0,  0,  0,  0, 55,  0,\n+    0,  0,  0,  0,  0,  0, 56,  0,  0,  0,  0,  0,  0,  0,  0, 57,\n@@ -6393,0 +6498,2 @@\n+    0,  0,  0,  0,  0,  0, 58, 59, 60, 61, 62, 63, 64, 65,  0,  0,\n+    0,  0,  0,  0, 66,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -6396,8 +6503,0 @@\n-   67, 68,  0, 69, 70,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-   71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,\n-   87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,\n-  103,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,104,  0,  0,  0,  0,  0,  0,105,106,  0,107,  0,  0,  0,\n-  108,  0,109,  0,110,  0,111,112,113,  0,114,  0,  0,  0,115,  0,\n-    0,  0,116,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,117,  0,  0,\n@@ -6405,1 +6504,8 @@\n-    0,  0,  0,  0,118,119,120,121,  0,122,123,124,125,126,  0,127,\n+    0,  0, 67, 68,  0, 69, 70,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,\n+   85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,\n+  101,102,103,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,104,  0,  0,  0,  0,  0,  0,105,106,  0,107,  0,\n+    0,  0,108,  0,109,  0,110,  0,111,112,113,  0,114,  0,  0,  0,\n+  115,  0,  0,  0,116,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,117,\n@@ -6407,0 +6513,2 @@\n+    0,  0,  0,  0,  0,  0,118,119,120,121,  0,122,123,124,125,126,\n+    0,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -6408,5 +6516,5 @@\n-  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n-  144,145,146,147,148,149,150,151,152,153,154,155,156,157,  0,  0,\n-    0,158,159,160,161,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,162,163,  0,  0,  0,  0,  0,\n-    0,  0,164,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,128,129,130,131,132,133,134,135,136,137,138,139,140,141,\n+  142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,\n+    0,  0,  0,158,159,160,161,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,162,163,  0,  0,  0,\n+    0,  0,  0,  0,164,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -6414,3 +6522,3 @@\n-    0,  0,  0,  0,165,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,166,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,167,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,165,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,166,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,167,  0,  0,\n@@ -6418,1 +6526,1 @@\n-    0,  0,  0,168,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,168,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -6420,5 +6528,6 @@\n-    0,  0,  0,  0,  0,169,170,  0,  0,  0,  0,171,172,  0,  0,  0,\n-  173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,\n-  189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,\n-  205,206,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,\n+    0,  0,  0,  0,  0,  0,  0,169,170,  0,  0,  0,  0,171,172,  0,\n+    0,  0,173,174,175,176,177,178,179,180,181,182,183,184,185,186,\n+  187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,\n+  203,204,205,206,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  2,\n+    3,  4,\n@@ -6427,1 +6536,1 @@\n-_hb_ucd_u16[4848] =\n+_hb_ucd_u16[4888] =\n@@ -6437,88 +6546,261 @@\n-    47,  64,  65,  66,  47,  67,  47,  47,  47,  47,  47,  47,  47,  68,  69,  32,\n-    70,  47,  47,  71,  72,  73,  74,  75,  76,  47,  47,  77,  78,  79,  80,  81,\n-    82,  47,  47,  83,  84,  85,  86,  87,  82,  47,  47,  77,  88,  47,  80,  89,\n-    90,  47,  47,  91,  92,  93,  80,  94,  95,  47,  47,  96,  97,  98,  99, 100,\n-   101,  47,  47, 102, 103, 104,  80, 105, 106,  47,  47,  91, 107, 108,  80, 109,\n-   110,  47,  47, 111, 112, 113,  80, 114,  90,  47,  47,  47, 115, 116,  99, 117,\n-    47,  47,  47, 118, 119, 120,  66,  66,  47,  47,  47, 121, 122, 123,  47,  47,\n-   124, 125, 126, 127,  47,  47,  47, 128, 129,  32,  32, 130, 131, 132,  66,  66,\n-    47,  47, 133, 134, 120, 135, 136, 137, 138, 139,   9,   9,   9,  11,  11, 140,\n-    47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47, 141, 142, 143,\n-    47, 144,   9,   9,   9,   9,   9, 145, 146,  47,  47,  47,  47,  47,  47,  47,\n-    47,  47,  47,  47,  47,  47, 147,  47, 148, 149,  47,  47,  47,  47, 150, 151,\n-    47, 152,  47, 153,  47, 152,  47, 152,  47,  47,  47, 154, 155, 156, 157, 143,\n-   158, 157,  47,  47, 159,  47,  47,  47, 160,  47, 161,  47,  47,  47,  47,  47,\n-    47,  47, 162, 163, 164,  47,  47,  47,  47,  47,  47,  47,  47, 165, 144, 144,\n-    47, 166,  47,  47,  47, 167, 168, 169, 157, 157, 170, 171,  32,  32,  32,  32,\n-   172,  47,  47, 173, 174, 120, 175, 176, 177,  47, 178,  61,  47,  47, 179, 180,\n-    47,  47, 181, 182, 183,  61,  47, 184,  11,   9,   9,   9,  66, 185, 186, 187,\n-    11,  11, 188,  27,  27,  27, 189, 190,  11, 191,  27,  27,  32,  32,  32,  32,\n-    13,  13,  13,  13,  13,  13,  13,  13,  13, 192,  13,  13,  13,  13,  13,  13,\n-   193, 193, 193, 193, 193, 194, 193,  11, 195, 195, 195, 196, 197, 198, 198, 197,\n-   199, 200, 201, 202, 203, 204, 205, 206, 207,  27, 208, 208, 208, 209, 210,  32,\n-   211, 212, 213, 214, 215, 143, 216, 216, 217, 218, 219, 144, 220, 221, 144, 222,\n-   223, 223, 223, 223, 223, 223, 223, 223, 224, 144, 225, 144, 144, 144, 144, 226,\n-   144, 227, 223, 228, 144, 229, 230, 144, 144, 144, 144, 144, 144, 144, 143, 143,\n-   143, 231, 144, 144, 144, 144, 232, 143, 144, 144, 144, 144, 144, 144, 144, 144,\n-   144, 144, 144, 233, 234, 144, 144, 235, 144, 144, 144, 144, 144, 144, 236, 144,\n-   144, 144, 144, 144, 144, 144, 237, 238, 143, 239, 144, 144, 240, 223, 241, 223,\n-   242, 243, 223, 223, 223, 244, 223, 245, 144, 144, 144, 223, 246, 144, 144, 144,\n-     9,   9,   9,  11,  11,  11, 247, 248,  13,  13,  13,  13,  13,  13, 249, 250,\n-    11,  11,  11,  47,  47,  47, 251, 252,  47,  47,  47,  47,  47,  47,  32,  32,\n-   253, 254, 255, 256, 257, 258,  66,  66, 259, 260, 261, 262, 263,  47,  47,  47,\n-    47, 264, 146,  47,  47,  47,  47, 265,  47, 266,  47,  47, 144, 144, 144,  47,\n-   144, 144, 267, 144, 268, 269, 144, 144, 267, 144, 144, 269, 144, 144, 144, 144,\n-    47,  47,  47,  47, 144, 144, 144, 144,  47, 270,  47,  47,  47,  47,  47,  47,\n-    47, 144, 144, 144, 144,  47,  47, 184, 271,  47,  61,  47,  13,  13, 272, 273,\n-    13, 274,  47,  47,  47,  47, 275, 276,  31, 277, 278, 279,  13,  13,  13, 280,\n-   281, 282, 283, 284, 285,  11,  11, 286, 287,  47, 288, 289,  47,  47,  47, 290,\n-   291,  47,  47, 292, 293, 157,  32, 294,  61,  47, 295,  47, 296, 297,  47,  47,\n-    70,  47,  47, 298, 299, 300, 301,  61,  47,  47, 302, 303, 304, 305,  47, 306,\n-    47,  47,  47, 307,  58, 308, 309, 310,  47,  47,  47,  11,  11, 311, 312,  11,\n-    11,  11,  11,  11,  47,  47, 313, 157, 314, 314, 314, 314, 314, 314, 314, 314,\n-   315, 315, 315, 315, 315, 315, 315, 315,  11, 316, 317,  47,  47,  47,  47,  47,\n-    47,  47,  47, 318,  31, 319,  47,  47,  47,  47,  47, 320, 321,  47,  47,  47,\n-    47,  47,  47,  47,  47,  47,  47, 322,  32, 323,  32, 324, 325, 326, 327,  47,\n-    47,  47,  47,  47,  47,  47,  47, 328, 329,   2,   3,   4,   5, 330, 331, 332,\n-    47, 333,  47,  47,  47,  47, 334, 335, 336, 143, 143, 337, 216, 216, 216, 338,\n-   339, 144, 144, 144, 144, 144, 144, 340, 341, 341, 341, 341, 341, 341, 341, 341,\n-    47,  47,  47,  47,  47,  47, 342, 143,  47,  47, 343,  47, 344,  47,  47,  60,\n-    47, 345,  47,  47,  47, 346, 216, 216,   9,   9, 145,  11,  11,  47,  47,  47,\n-    47,  47, 157,   9,   9, 145,  11,  11,  47,  47,  47,  47,  47,  47, 345,  66,\n-    47,  47,  47,  47,  47, 347,  47, 348,  47,  47, 349, 143, 143, 143,  47, 350,\n-    47, 351,  47, 345,  66,  66,  66,  66,  47,  47,  47, 352, 143, 143, 143, 143,\n-   353,  47,  47, 354, 143,  66,  47, 355,  47, 356, 143, 143, 357,  47, 358,  66,\n-    47,  47,  47, 359,  47, 360,  47, 360,  47, 359, 142, 143, 143, 143, 143, 143,\n-     9,   9,   9,   9,  11,  11,  11, 361,  47,  47, 362, 157, 157, 157, 157, 157,\n-   143, 143, 143, 143, 143, 143, 143, 143,  47,  47, 363,  47,  47,  47,  47,  47,\n-    47, 356, 364,  47,  60, 365,  66,  66,  47,  47,  47,  47, 366, 143,  47,  47,\n-   367,  47,  47, 354, 368, 369, 370, 371, 177,  47,  47, 372, 373,  47,  47, 157,\n-    95,  47, 374, 375, 376,  47,  47, 377, 177,  47,  47, 378, 379, 380, 381, 143,\n-    47,  47, 382, 383,  32,  32,  32,  32,  47,  47, 359,  47,  47, 384, 169, 157,\n-    90,  47,  47, 111, 385, 386, 387,  32,  47,  47,  47, 388, 389, 390,  47,  47,\n-    47,  47,  47, 391, 392, 157, 157, 157,  47,  47, 393, 394, 395, 396,  32,  32,\n-    47,  47,  47, 397, 398, 157,  66,  66,  47,  47, 399, 400, 157, 157, 157, 157,\n-    47, 141, 401, 402, 144, 144, 144, 144,  47,  47, 382, 403,  66,  66,  66,  66,\n-     9,   9,   9,   9,  11,  11, 126, 404,  47,  47,  47, 405, 406, 157, 157, 157,\n-    47,  47,  47,  47,  47, 407, 408, 409, 410,  47,  47, 411, 412, 413,  47,  47,\n-   414, 415,  66,  66,  47,  47,  47,  47,  47,  47, 393, 416, 417, 126, 143, 418,\n-    47, 152, 419, 420,  32,  32,  32,  32,  47,  47,  47, 353, 421, 157,  47,  47,\n-   422, 423, 157, 157, 157, 157, 157, 157,  47,  47,  47,  47,  47,  47,  47, 424,\n-    47,  47,  47,  47, 143, 425, 426, 427, 216, 216, 216, 216, 216, 216, 216,  66,\n-    47,  47,  47, 205, 205, 205, 205, 205,  47,  47,  47,  47,  47,  47, 300,  66,\n-    47,  47,  47,  47,  47,  47,  47, 428,  47,  47,  47, 429, 430, 431, 432,  47,\n-     9,   9,   9,   9,   9,   9,  11,  11, 143, 433,  66,  66,  66,  66,  66,  66,\n-    47,  47,  47,  47, 384, 434, 409, 409, 435, 436,  27,  27,  27,  27, 437, 409,\n-    47, 438, 205, 205, 205, 205, 205, 205, 144, 144, 144, 144, 144, 144, 439, 440,\n-   441, 144, 442, 144, 144, 144, 144, 144, 144, 144, 144, 144, 443, 144, 144, 144,\n-     9, 444,  11, 445, 446,  11, 193,   9, 447, 448,   9, 449,  11,   9, 444,  11,\n-   445, 446,  11, 193,   9, 447, 448,   9, 449,  11,   9, 444,  11, 445, 446,  11,\n-   193,   9, 447, 448,   9, 449,  11,   9, 444,  11, 193,   9, 450, 451, 452, 453,\n-    11, 454,   9, 455, 456, 457, 458,  11, 459,   9, 460,  11, 461, 157, 157, 157,\n-    32,  32,  32, 462,  32,  32, 463, 464, 465, 466,  32,  32,  32,  32,  32,  32,\n-    32,  32,  32,  32,  32,  32,  32,  32,  47,  47,  47, 467, 468, 144, 144, 144,\n-    47,  47,  47,  47,  47,  47, 469, 470,  47,  47,  47,  47, 349,  32,  32,  32,\n-     9,   9, 447,  11, 471, 300,  66,  66, 143, 143, 472, 473, 143, 143, 143, 143,\n-   143, 143, 474, 143, 143, 143, 143, 143,  47,  47,  47,  47,  47,  47,  47, 223,\n-   475, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 144, 476,\n-   144, 144, 144, 144, 144, 144, 144, 157, 205, 205, 205, 205, 205, 205, 205, 205,\n+    47,  64,  65,  66,  47,  67,  47,  47,  68,  69,  47,  47,  70,  32,  71,  32,\n+    72,  47,  47,  73,  74,  75,  76,  77,  78,  47,  47,  79,  80,  81,  82,  83,\n+    84,  47,  47,  85,  86,  87,  88,  89,  84,  47,  47,  79,  90,  47,  82,  91,\n+    92,  47,  47,  93,  94,  95,  82,  96,  97,  47,  47,  98,  99, 100, 101, 102,\n+   103,  47,  47, 104, 105, 106,  82, 107, 108,  47,  47,  93, 109, 110,  82, 111,\n+   112,  47,  47, 113, 114, 115,  82, 116,  92,  47,  47,  47, 117, 118, 101, 119,\n+    47,  47,  47, 120, 121, 122,  66,  66,  47,  47,  47, 123, 124, 125,  47,  47,\n+   126, 127, 128, 129,  47,  47,  47, 130, 131,  32,  32, 132, 133, 134,  66,  66,\n+    47,  47, 135, 136, 122, 137, 138, 139, 140, 141,   9,   9,   9,  11,  11, 142,\n+    47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47,  47, 143, 144, 145,\n+    47, 146,   9,   9,   9,   9,   9, 147, 148,  47,  47,  47,  47,  47,  47,  47,\n+    47,  47,  47,  47,  47,  47, 149,  47, 150, 151,  47,  47,  47,  47, 152, 153,\n+    47, 154,  47, 155,  47, 156,  47, 156,  47,  47,  47, 157, 158, 159, 160, 145,\n+   161, 160,  47,  47, 162,  47,  47,  47, 163,  47, 164,  47,  47,  47,  47,  47,\n+    47,  47, 165, 166, 167,  47,  47,  47,  47,  47,  47,  47,  47, 168, 146, 146,\n+    47, 169,  47,  47,  47, 170, 171, 172, 160, 160, 173, 174,  32,  32,  32,  32,\n+   175,  47,  47, 176, 177, 122, 178, 179, 180,  47, 181,  61,  47,  47, 182, 183,\n+    47,  47, 184, 185, 186,  61,  47, 187,  11,   9,   9,   9,  66, 188, 189, 190,\n+    11,  11, 191,  27,  27,  27, 192, 193,  11, 194,  27,  27,  32,  32,  32,  32,\n+    13,  13,  13,  13,  13,  13,  13,  13,  13, 195,  13,  13,  13,  13,  13,  13,\n+   196, 196, 196, 196, 196, 197, 196,  11, 198, 198, 198, 199, 200, 201, 201, 200,\n+   202, 203, 204, 205, 206, 207, 208, 209, 210,  27, 211, 211, 211, 212, 213,  32,\n+   214, 215, 216, 217, 218, 145, 219, 219, 220, 221, 222, 146, 223, 224, 146, 225,\n+   226, 226, 226, 226, 226, 226, 226, 226, 227, 146, 228, 146, 146, 146, 146, 229,\n+   146, 230, 226, 231, 146, 232, 233, 146, 146, 146, 146, 146, 146, 146, 145, 145,\n+   145, 234, 146, 146, 146, 146, 235, 145, 146, 146, 146, 146, 146, 146, 146, 146,\n+   146, 146, 146, 236, 237, 146, 146, 238, 146, 146, 146, 146, 146, 146, 239, 146,\n+   146, 146, 146, 146, 146, 146, 240, 241, 145, 242, 146, 146, 243, 226, 244, 226,\n+   245, 246, 226, 226, 226, 247, 226, 248, 146, 146, 146, 226, 249, 146, 146, 146,\n+     9,   9,   9,  11,  11,  11, 250, 251,  13,  13,  13,  13,  13,  13, 252, 253,\n+    11,  11,  11,  47,  47,  47, 254, 255,  47,  47,  47,  47,  47,  47,  32,  32,\n+   256, 257, 258, 259, 260, 261, 262, 262, 263, 264, 265, 266, 267,  47,  47,  47,\n+    47, 268, 148,  47,  47,  47,  47, 269,  47, 270,  47,  47, 146, 146, 146,  47,\n+   146, 146, 271, 146, 272, 273, 146, 146, 271, 146, 146, 273, 146, 146, 146, 146,\n+    47,  47,  47,  47, 146, 146, 146, 146,  47, 274,  47,  47,  47,  47,  47,  47,\n+    47, 146, 146, 146, 146,  47,  47, 187, 275,  47,  61,  47,  13,  13, 276, 277,\n+    13, 278,  47,  47,  47,  47, 279, 280,  31, 281, 282, 283,  13,  13,  13, 284,\n+   285, 286, 287, 288, 289, 290,  11, 291, 292,  47, 293, 294,  47,  47,  47, 295,\n+   296,  47,  47, 297, 298, 160,  32, 299,  61,  47, 300,  47, 301, 302,  47,  47,\n+    72,  47,  47, 303, 304, 305, 306,  61,  47,  47, 307, 308, 309, 310,  47, 311,\n+    47,  47,  47, 312,  58, 313, 314, 315,  47,  47,  47,  11,  11, 316, 317,  11,\n+    11,  11,  11,  11,  47,  47, 318, 160, 319, 319, 319, 319, 319, 319, 319, 319,\n+   320, 320, 320, 320, 320, 320, 320, 320,  11, 321, 322,  47,  47,  47,  47,  47,\n+    47,  47,  47, 323,  31, 324,  47,  47,  47,  47,  47, 325, 146,  47,  47,  47,\n+    47,  47,  47,  47, 326, 146, 146, 327,  32, 328,  32, 329, 330, 331, 332,  47,\n+    47,  47,  47,  47,  47,  47,  47, 333, 334,   2,   3,   4,   5, 335, 336, 337,\n+    47, 338,  47,  47,  47,  47, 339, 340, 341, 145, 145, 342, 219, 219, 219, 343,\n+   344, 146, 146, 146, 146, 146, 146, 345, 346, 346, 346, 346, 346, 346, 346, 346,\n+    47,  47,  47,  47,  47,  47, 347, 145,  47,  47, 348,  47, 349,  47,  47,  60,\n+    47, 350,  47,  47,  47, 351, 219, 219,   9,   9, 147,  11,  11,  47,  47,  47,\n+    47,  47, 160,   9,   9, 147,  11,  11,  47,  47,  47,  47,  47,  47, 350,   9,\n+     9, 352,  11,  11,  11,  11,  11,  11,  27,  27,  27,  27,  27,  27,  27,  27,\n+    47,  47,  47,  47,  47, 353,  47, 354,  47,  47, 355, 145, 145, 145,  47, 356,\n+    47, 357,  47, 350,  66,  66,  66,  66,  47,  47,  47, 358, 145, 145, 145, 145,\n+   359,  47,  47, 360, 145,  66,  47, 361,  47, 362, 145, 145, 363,  47, 364,  66,\n+    47,  47,  47, 365,  47, 366,  47, 366,  47, 365, 144, 145, 145, 145, 145, 145,\n+     9,   9,   9,   9,  11,  11,  11, 367,  47,  47, 368, 160, 160, 160, 160, 160,\n+   145, 145, 145, 145, 145, 145, 145, 145,  47,  47, 369,  47,  47,  47,  47,  47,\n+    47, 362, 370,  47,  60, 371,  66,  47, 372,  66,  66,  47, 373, 145,  47,  47,\n+   374,  47,  47, 360, 375, 376, 377, 378, 180,  47,  47, 379, 380,  47,  47, 160,\n+    97,  47, 381, 382, 383,  47,  47, 384, 180,  47,  47, 385, 386, 387, 388, 145,\n+    47,  47, 389, 390,  32,  32,  32,  32,  47,  47, 365,  47,  47, 391, 172, 160,\n+    92,  47,  47, 113, 392, 393, 394,  32,  47,  47,  47, 395, 396, 397,  47,  47,\n+    47,  47,  47, 398, 399, 160, 160, 160,  47,  47, 400, 401, 402, 403,  32,  32,\n+    47,  47,  47, 404, 405, 160,  66,  66,  47,  47, 406, 407, 160, 160, 160, 160,\n+    47, 143, 408, 409,  47,  47,  47,  47,  47,  47, 389, 410,  66,  66,  66,  66,\n+     9,   9,   9,   9,  11,  11, 128, 411,  47,  47,  47, 412, 413, 160, 160, 160,\n+    47,  47,  47,  47,  47, 414, 415, 416, 417,  47,  47, 418, 419, 420,  47,  47,\n+   421, 422,  66,  47,  47,  47,  47,  47,  47,  47, 400, 423, 424, 128, 145, 425,\n+    47, 156, 426, 427,  32,  32,  32,  32,  47,  47,  47, 359, 428, 160,  47,  47,\n+   429, 430, 160, 160, 160, 160, 160, 160,  47,  47,  47,  47,  47,  47,  47, 431,\n+    47,  47,  47,  47, 145, 432, 433, 434, 219, 219, 219, 219, 219, 219, 219,  66,\n+    47,  47,  47,  47,  47,  47,  47, 424,  47,  47,  47, 208, 208, 208, 208, 208,\n+    47,  47,  47,  47,  47,  47, 305,  47,  47,  47,  47,  47, 160,  47,  47, 435,\n+    47,  47,  47, 436, 437, 438, 439,  47,   9,   9,   9,   9,   9,   9,  11,  11,\n+   145, 440,  66,  66,  66,  66,  66,  66,  47,  47,  47,  47, 391, 441, 416, 416,\n+   442, 443,  27,  27,  27,  27, 444, 416,  47, 445, 208, 208, 208, 208, 208, 208,\n+    32,  32,  32,  32,  32, 146, 146, 146, 146, 146, 146, 146, 146, 146, 446, 447,\n+   448, 146, 449, 146, 146, 146, 146, 146, 146, 146, 146, 146, 450, 146, 146, 146,\n+     9, 451,  11, 452, 453,  11, 196,   9, 454, 455,   9, 456,  11,   9, 451,  11,\n+   452, 453,  11, 196,   9, 454, 455,   9, 456,  11,   9, 451,  11, 452, 453,  11,\n+   196,   9, 454, 455,   9, 456,  11,   9, 451,  11, 196,   9, 457, 458, 459, 460,\n+    11, 461,   9, 462, 463, 464, 465,  11, 466,   9, 467,  11, 468, 160, 160, 160,\n+    32,  32,  32, 469,  32,  32, 470, 471, 472, 473,  32,  32,  32,  32,  32,  32,\n+   474,  11,  11,  11,  11,  11,  11,  11,  32,  32,  32,  32,  32,  32,  32,  32,\n+    47,  47,  47, 475, 476, 146, 146, 146,  47,  47, 477,  32,  47,  47, 478, 479,\n+    47,  47,  47,  47, 355,  32,  32,  32,   9,   9, 454,  11, 480, 305,  66,  66,\n+   145, 145, 481, 482, 145, 145, 145, 145, 145, 145, 483, 145, 145, 145, 145, 145,\n+    47,  47,  47,  47,  47,  47,  47, 226, 484, 146, 146, 146, 146, 146, 146, 146,\n+   146, 146, 146, 146, 146, 146, 146, 485, 146, 146, 146, 146, 146, 146, 146, 160,\n+   208, 208, 208, 208, 208, 208, 208, 208,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 939, 940, 941, 942, 946, 948,   0, 962,\n+   969, 970, 971, 976,1001,1002,1003,1008,   0,1033,1040,1041,1042,1043,1047,   0,\n+     0,1080,1081,1082,1086,1110,   0,   0,1124,1125,1126,1127,1131,1133,   0,1147,\n+  1154,1155,1156,1161,1187,1188,1189,1193,   0,1219,1226,1227,1228,1229,1233,   0,\n+     0,1267,1268,1269,1273,1298,   0,1303, 943,1128, 944,1129, 954,1139, 958,1143,\n+   959,1144, 960,1145, 961,1146, 964,1149,   0,   0, 973,1158, 974,1159, 975,1160,\n+   983,1168, 978,1163, 988,1173, 990,1175, 991,1176, 993,1178, 994,1179,   0,   0,\n+  1004,1190,1005,1191,1006,1192,1014,1199,1007,   0,   0,   0,1016,1201,1020,1206,\n+     0,1022,1208,1025,1211,1023,1209,   0,   0,   0,   0,1032,1218,1037,1223,1035,\n+  1221,   0,   0,   0,1044,1230,1045,1231,1049,1235,   0,   0,1058,1244,1064,1250,\n+  1060,1246,1066,1252,1067,1253,1072,1258,1069,1255,1077,1264,1074,1261,   0,   0,\n+  1083,1270,1084,1271,1085,1272,1088,1275,1089,1276,1096,1283,1103,1290,1111,1299,\n+  1115,1118,1307,1120,1309,1121,1310,   0,1053,1239,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,1093,1280,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0, 949,1134,1010,1195,1050,1236,1090,1277,1341,1368,1340,\n+  1367,1342,1369,1339,1366,   0,1320,1347,1418,1419,1323,1350,   0,   0, 992,1177,\n+  1018,1204,1055,1241,1416,1417,1415,1424,1202,   0,   0,   0, 987,1172,   0,   0,\n+  1031,1217,1321,1348,1322,1349,1338,1365, 950,1135, 951,1136, 979,1164, 980,1165,\n+  1011,1196,1012,1197,1051,1237,1052,1238,1061,1247,1062,1248,1091,1278,1092,1279,\n+  1071,1257,1076,1263,   0,   0, 997,1182,   0,   0,   0,   0,   0,   0, 945,1130,\n+   982,1167,1337,1364,1335,1362,1046,1232,1422,1423,1113,1301,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   8,   9,   0,  10,1425,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   7,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,1314,1427,   5,\n+  1434,1438,1443,   0,1450,   0,1455,1461,1514,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1446,1458,1468,1476,1480,1486,1517,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1489,1503,1494,1500,1508,   0,   0,   0,   0,1520,1521,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1526,1528,   0,1525,   0,   0,   0,1522,\n+     0,   0,   0,   0,1536,1532,1539,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1534,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1556,   0,   0,   0,   0,   0,   0,1548,1550,   0,1547,   0,   0,   0,1567,\n+     0,   0,   0,   0,1558,1554,1561,   0,   0,   0,   0,   0,   0,   0,1568,1569,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1529,1551,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1523,1545,1524,1546,   0,   0,1527,1549,\n+     0,   0,1570,1571,1530,1552,1531,1553,   0,   0,1533,1555,1535,1557,1537,1559,\n+     0,   0,1572,1573,1544,1566,1538,1560,1540,1562,1541,1563,1542,1564,   0,   0,\n+  1543,1565,   0,   0,   0,   0,   0,   0,   0,   0,1606,1607,1609,1608,1610,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,1613,   0,1611,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1612,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1620,   0,   0,   0,   0,   0,   0,   0,1623,   0,   0,1624,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1614,1615,1616,1617,1618,1619,1621,1622,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1628,1629,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1625,1626,   0,1627,   0,   0,   0,1634,   0,   0,1635,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1630,1631,1632,   0,   0,1633,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1639,   0,   0,1638,1640,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1636,1637,   0,   0,   0,   0,   0,   0,1641,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1642,1644,1643,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1645,   0,   0,   0,   0,   0,   0,   0,1646,   0,   0,   0,   0,   0,   0,1648,\n+  1649,   0,1647,1650,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1651,1653,1652,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1654,   0,1655,1657,1656,   0,   0,   0,   0,1659,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1660,   0,   0,   0,   0,1661,   0,   0,   0,   0,1662,\n+     0,   0,   0,   0,1663,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1658,   0,   0,   0,   0,   0,   0,   0,   0,   0,1664,   0,1665,1673,   0,\n+  1674,   0,   0,   0,   0,   0,   0,   0,   0,1666,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1668,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1669,   0,   0,   0,   0,1670,   0,   0,   0,   0,1671,\n+     0,   0,   0,   0,1672,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,1667,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1675,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1676,   0,\n+  1677,   0,1678,   0,1679,   0,1680,   0,   0,   0,1681,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1682,   0,1683,   0,   0,1684,1685,   0,1686,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 953,1138, 955,1140, 956,1141, 957,1142,\n+  1324,1351, 963,1148, 965,1150, 968,1153, 966,1151, 967,1152,1378,1380,1379,1381,\n+   984,1169, 985,1170,1420,1421, 986,1171, 989,1174, 995,1180, 998,1183, 996,1181,\n+   999,1184,1000,1185,1015,1200,1329,1356,1017,1203,1019,1205,1021,1207,1024,1210,\n+  1687,1688,1027,1213,1026,1212,1028,1214,1029,1215,1030,1216,1034,1220,1036,1222,\n+  1039,1225,1038,1224,1334,1361,1336,1363,1382,1384,1383,1385,1056,1242,1057,1243,\n+  1059,1245,1063,1249,1689,1690,1065,1251,1068,1254,1070,1256,1386,1387,1388,1389,\n+  1691,1692,1073,1259,1075,1262,1079,1266,1078,1265,1095,1282,1098,1285,1097,1284,\n+  1390,1391,1392,1393,1099,1286,1100,1287,1101,1288,1102,1289,1105,1292,1104,1291,\n+  1106,1294,1107,1295,1108,1296,1114,1302,1119,1308,1122,1311,1123,1312,1186,1260,\n+  1293,1305,   0,1394,   0,   0,   0,   0, 952,1137, 947,1132,1317,1344,1316,1343,\n+  1319,1346,1318,1345,1693,1695,1371,1375,1370,1374,1373,1377,1372,1376,1694,1696,\n+   981,1166, 977,1162, 972,1157,1326,1353,1325,1352,1328,1355,1327,1354,1697,1698,\n+  1009,1194,1013,1198,1054,1240,1048,1234,1331,1358,1330,1357,1333,1360,1332,1359,\n+  1699,1700,1396,1401,1395,1400,1398,1403,1397,1402,1399,1404,1094,1281,1087,1274,\n+  1406,1411,1405,1410,1408,1413,1407,1412,1409,1414,1109,1297,1117,1306,1116,1304,\n+  1112,1300,   0,   0,   0,   0,   0,   0,1471,1472,1701,1705,1702,1706,1703,1707,\n+  1430,1431,1715,1719,1716,1720,1717,1721,1477,1478,1729,1731,1730,1732,   0,   0,\n+  1435,1436,1733,1735,1734,1736,   0,   0,1481,1482,1737,1741,1738,1742,1739,1743,\n+  1439,1440,1751,1755,1752,1756,1753,1757,1490,1491,1765,1768,1766,1769,1767,1770,\n+  1447,1448,1771,1774,1772,1775,1773,1776,1495,1496,1777,1779,1778,1780,   0,   0,\n+  1451,1452,1781,1783,1782,1784,   0,   0,1504,1505,1785,1788,1786,1789,1787,1790,\n+     0,1459,   0,1791,   0,1792,   0,1793,1509,1510,1794,1798,1795,1799,1796,1800,\n+  1462,1463,1808,1812,1809,1813,1810,1814,1467,  21,1475,  22,1479,  23,1485,  24,\n+  1493,  27,1499,  28,1507,  29,   0,   0,1704,1708,1709,1710,1711,1712,1713,1714,\n+  1718,1722,1723,1724,1725,1726,1727,1728,1740,1744,1745,1746,1747,1748,1749,1750,\n+  1754,1758,1759,1760,1761,1762,1763,1764,1797,1801,1802,1803,1804,1805,1806,1807,\n+  1811,1815,1816,1817,1818,1819,1820,1821,1470,1469,1822,1474,1465,   0,1473,1825,\n+  1429,1428,1426,  12,1432,   0,  26,   0,   0,1315,1823,1484,1466,   0,1483,1829,\n+  1433,  13,1437,  14,1441,1826,1827,1828,1488,1487,1513,  19,   0,   0,1492,1515,\n+  1445,1444,1442,  15,   0,1831,1832,1833,1502,1501,1516,  25,1497,1498,1506,1518,\n+  1457,1456,1454,  17,1453,1313,  11,   3,   0,   0,1824,1512,1519,   0,1511,1830,\n+  1449,  16,1460,  18,1464,   4,   0,   0,  30,  31,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  20,   0,\n+     0,   0,   2,   6,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1834,1835,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1836,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1837,1839,1838,   0,   0,   0,   0,1840,   0,   0,   0,\n+     0,1841,   0,   0,1842,   0,   0,   0,   0,   0,   0,   0,1843,   0,1844,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0,   0,1845,   0,   0,1846,   0,   0,1847,\n+     0,1848,   0,   0,   0,   0,   0,   0, 937,   0,1850,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1849, 936, 938,1851,1852,   0,   0,1853,1854,   0,   0,\n+  1855,1856,   0,   0,   0,   0,   0,   0,1857,1858,   0,   0,1861,1862,   0,   0,\n+  1863,1864,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1867,1868,1869,1870,1859,1860,1865,1866,   0,   0,   0,   0,\n+     0,   0,1871,1872,1873,1874,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,  32,  33,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1875,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1877,   0,1878,   0,1879,   0,1880,   0,1881,   0,1882,   0,\n+  1883,   0,1884,   0,1885,   0,1886,   0,1887,   0,1888,   0,   0,1889,   0,1890,\n+     0,1891,   0,   0,   0,   0,   0,   0,1892,1893,   0,1894,1895,   0,1896,1897,\n+     0,1898,1899,   0,1900,1901,   0,   0,   0,   0,   0,   0,1876,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1902,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,1904,   0,1905,   0,1906,   0,1907,   0,1908,   0,1909,   0,\n+  1910,   0,1911,   0,1912,   0,1913,   0,1914,   0,1915,   0,   0,1916,   0,1917,\n+     0,1918,   0,   0,   0,   0,   0,   0,1919,1920,   0,1921,1922,   0,1923,1924,\n+     0,1925,1926,   0,1927,1928,   0,   0,   0,   0,   0,   0,1903,   0,   0,1929,\n+  1930,1931,1932,   0,   0,   0,1933,   0, 710, 385, 724, 715, 455, 103, 186, 825,\n+   825, 242, 751, 205, 241, 336, 524, 601, 663, 676, 688, 738, 411, 434, 474, 500,\n+   649, 746, 799, 108, 180, 416, 482, 662, 810, 275, 462, 658, 692, 344, 618, 679,\n+   293, 388, 440, 492, 740, 116, 146, 168, 368, 414, 481, 527, 606, 660, 665, 722,\n+   781, 803, 809, 538, 553, 588, 642, 758, 811, 701, 233, 299, 573, 612, 487, 540,\n+   714, 779, 232, 267, 412, 445, 457, 585, 594, 766, 167, 613, 149, 148, 560, 589,\n+   648, 768, 708, 345, 411, 704, 105, 259, 313, 496, 518, 174, 542, 120, 307, 101,\n+   430, 372, 584, 183, 228, 529, 650, 697, 424, 732, 428, 349, 632, 355, 517, 110,\n+   135, 147, 403, 580, 624, 700, 750, 170, 193, 245, 297, 374, 463, 543, 763, 801,\n+   812, 815, 162, 384, 420, 730, 287, 330, 337, 366, 459, 476, 509, 558, 591, 610,\n+   726, 652, 734, 759, 154, 163, 198, 473, 683, 697, 292, 311, 353, 423, 572, 494,\n+   113, 217, 259, 280, 314, 499, 506, 603, 608, 752, 778, 782, 788, 117, 557, 748,\n+   774, 320, 109, 126, 260, 265, 373, 411, 479, 523, 655, 737, 823, 380, 765, 161,\n+   395, 398, 438, 451, 502, 516, 537, 583, 791, 136, 340, 769, 122, 273, 446, 727,\n+   305, 322, 400, 496, 771, 155, 190, 269, 377, 391, 406, 432, 501, 519, 599, 684,\n+   687, 749, 776, 175, 452, 191, 480, 510, 659, 772, 805, 813, 397, 444, 619, 566,\n+   568, 575, 491, 471, 707, 111, 636, 156, 153, 288, 346, 578, 256, 435, 383, 729,\n+   680, 767, 694, 295, 128, 210,   0,   0, 227,   0, 379,   0,   0, 150, 493, 525,\n+   544, 551, 552, 556, 783, 576, 604,   0, 661,   0, 703,   0,   0, 735, 743,   0,\n+     0,   0, 793, 794, 795, 808, 741, 773, 118, 127, 130, 166, 169, 177, 207, 213,\n+   215, 226, 229, 268, 270, 317, 327, 329, 335, 369, 375, 381, 404, 441, 448, 458,\n+   477, 484, 503, 539, 545, 547, 546, 548, 549, 550, 554, 555, 561, 564, 569, 591,\n+   593, 595, 598, 607, 620, 625, 625, 651, 690, 695, 705, 706, 716, 717, 733, 735,\n+   777, 786, 790, 315, 869, 623,   0,   0, 102, 145, 134, 115, 129, 138, 165, 171,\n+   207, 202, 206, 212, 227, 231, 240, 243, 250, 254, 294, 296, 303, 308, 319, 325,\n+   321, 329, 326, 335, 341, 357, 360, 362, 370, 379, 388, 389, 393, 421, 424, 438,\n+   456, 454, 458, 465, 477, 535, 485, 490, 493, 507, 512, 514, 521, 522, 525, 526,\n+   528, 533, 532, 541, 565, 569, 574, 586, 591, 597, 607, 637, 647, 674, 691, 693,\n+   695, 698, 703, 699, 705, 704, 702, 706, 709, 717, 728, 736, 747, 754, 770, 777,\n+   783, 784, 786, 787, 790, 802, 825, 848, 847, 857,  55,  65,  66, 883, 892, 916,\n+   822, 824,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,1586,   0,1605,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1602,1603,1934,1935,1574,1575,1576,1577,1579,1580,1581,1583,1584,   0,\n+  1585,1587,1588,1589,1591,   0,1592,   0,1593,1594,   0,1595,1596,   0,1598,1599,\n+  1600,1601,1604,1582,1578,1590,1597,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1936,   0,1937,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1938,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1939,1940,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1941,1942,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,1944,1943,   0,1945,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,1946,1947,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+  1948,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,1949,1950,1951,1952,1953,1954,1955,   0,   0,   0,\n@@ -6526,206 +6808,36 @@\n-   939, 940, 941, 942, 946, 948,   0, 962, 969, 970, 971, 976,1001,1002,1003,1008,\n-     0,1033,1040,1041,1042,1043,1047,   0,   0,1080,1081,1082,1086,1110,   0,   0,\n-  1124,1125,1126,1127,1131,1133,   0,1147,1154,1155,1156,1161,1187,1188,1189,1193,\n-     0,1219,1226,1227,1228,1229,1233,   0,   0,1267,1268,1269,1273,1298,   0,1303,\n-   943,1128, 944,1129, 954,1139, 958,1143, 959,1144, 960,1145, 961,1146, 964,1149,\n-     0,   0, 973,1158, 974,1159, 975,1160, 983,1168, 978,1163, 988,1173, 990,1175,\n-   991,1176, 993,1178, 994,1179,   0,   0,1004,1190,1005,1191,1006,1192,1014,1199,\n-  1007,   0,   0,   0,1016,1201,1020,1206,   0,1022,1208,1025,1211,1023,1209,   0,\n-     0,   0,   0,1032,1218,1037,1223,1035,1221,   0,   0,   0,1044,1230,1045,1231,\n-  1049,1235,   0,   0,1058,1244,1064,1250,1060,1246,1066,1252,1067,1253,1072,1258,\n-  1069,1255,1077,1264,1074,1261,   0,   0,1083,1270,1084,1271,1085,1272,1088,1275,\n-  1089,1276,1096,1283,1103,1290,1111,1299,1115,1118,1307,1120,1309,1121,1310,   0,\n-  1053,1239,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1093,\n-  1280,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 949,1134,1010,\n-  1195,1050,1236,1090,1277,1341,1368,1340,1367,1342,1369,1339,1366,   0,1320,1347,\n-  1418,1419,1323,1350,   0,   0, 992,1177,1018,1204,1055,1241,1416,1417,1415,1424,\n-  1202,   0,   0,   0, 987,1172,   0,   0,1031,1217,1321,1348,1322,1349,1338,1365,\n-   950,1135, 951,1136, 979,1164, 980,1165,1011,1196,1012,1197,1051,1237,1052,1238,\n-  1061,1247,1062,1248,1091,1278,1092,1279,1071,1257,1076,1263,   0,   0, 997,1182,\n-     0,   0,   0,   0,   0,   0, 945,1130, 982,1167,1337,1364,1335,1362,1046,1232,\n-  1422,1423,1113,1301,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     8,   9,   0,  10,1425,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,\n-     0,   0,   0,   0,   0,1314,1427,   5,1434,1438,1443,   0,1450,   0,1455,1461,\n-  1514,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1446,1458,1468,1476,1480,1486,\n-  1517,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1489,1503,1494,1500,1508,   0,\n-     0,   0,   0,1520,1521,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1526,1528,   0,1525,   0,   0,   0,1522,   0,   0,   0,   0,1536,1532,1539,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1534,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1556,   0,   0,   0,   0,   0,   0,\n-  1548,1550,   0,1547,   0,   0,   0,1567,   0,   0,   0,   0,1558,1554,1561,   0,\n-     0,   0,   0,   0,   0,   0,1568,1569,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1529,1551,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1523,1545,1524,1546,   0,   0,1527,1549,   0,   0,1570,1571,1530,1552,1531,1553,\n-     0,   0,1533,1555,1535,1557,1537,1559,   0,   0,1572,1573,1544,1566,1538,1560,\n-  1540,1562,1541,1563,1542,1564,   0,   0,1543,1565,   0,   0,   0,   0,   0,   0,\n-     0,   0,1606,1607,1609,1608,1610,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-  1613,   0,1611,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1612,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1620,   0,   0,   0,   0,   0,   0,\n-     0,1623,   0,   0,1624,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1614,1615,1616,1617,1618,1619,1621,1622,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1628,1629,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1625,1626,   0,1627,\n-     0,   0,   0,1634,   0,   0,1635,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1630,1631,1632,   0,   0,1633,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1639,   0,   0,1638,1640,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1636,1637,   0,   0,\n-     0,   0,   0,   0,1641,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1642,1644,1643,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1645,   0,   0,   0,   0,   0,   0,   0,\n-  1646,   0,   0,   0,   0,   0,   0,1648,1649,   0,1647,1650,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1651,1653,1652,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1654,   0,1655,1657,1656,   0,\n-     0,   0,   0,1659,   0,   0,   0,   0,   0,   0,   0,   0,   0,1660,   0,   0,\n-     0,   0,1661,   0,   0,   0,   0,1662,   0,   0,   0,   0,1663,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1658,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1664,   0,1665,1673,   0,1674,   0,   0,   0,   0,   0,   0,   0,\n-     0,1666,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,1668,   0,   0,   0,   0,   0,   0,   0,   0,   0,1669,   0,   0,\n-     0,   0,1670,   0,   0,   0,   0,1671,   0,   0,   0,   0,1672,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,1667,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1675,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,1676,   0,1677,   0,1678,   0,1679,   0,1680,   0,\n-     0,   0,1681,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1682,   0,1683,   0,   0,\n-  1684,1685,   0,1686,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   953,1138, 955,1140, 956,1141, 957,1142,1324,1351, 963,1148, 965,1150, 968,1153,\n-   966,1151, 967,1152,1378,1380,1379,1381, 984,1169, 985,1170,1420,1421, 986,1171,\n-   989,1174, 995,1180, 998,1183, 996,1181, 999,1184,1000,1185,1015,1200,1329,1356,\n-  1017,1203,1019,1205,1021,1207,1024,1210,1687,1688,1027,1213,1026,1212,1028,1214,\n-  1029,1215,1030,1216,1034,1220,1036,1222,1039,1225,1038,1224,1334,1361,1336,1363,\n-  1382,1384,1383,1385,1056,1242,1057,1243,1059,1245,1063,1249,1689,1690,1065,1251,\n-  1068,1254,1070,1256,1386,1387,1388,1389,1691,1692,1073,1259,1075,1262,1079,1266,\n-  1078,1265,1095,1282,1098,1285,1097,1284,1390,1391,1392,1393,1099,1286,1100,1287,\n-  1101,1288,1102,1289,1105,1292,1104,1291,1106,1294,1107,1295,1108,1296,1114,1302,\n-  1119,1308,1122,1311,1123,1312,1186,1260,1293,1305,   0,1394,   0,   0,   0,   0,\n-   952,1137, 947,1132,1317,1344,1316,1343,1319,1346,1318,1345,1693,1695,1371,1375,\n-  1370,1374,1373,1377,1372,1376,1694,1696, 981,1166, 977,1162, 972,1157,1326,1353,\n-  1325,1352,1328,1355,1327,1354,1697,1698,1009,1194,1013,1198,1054,1240,1048,1234,\n-  1331,1358,1330,1357,1333,1360,1332,1359,1699,1700,1396,1401,1395,1400,1398,1403,\n-  1397,1402,1399,1404,1094,1281,1087,1274,1406,1411,1405,1410,1408,1413,1407,1412,\n-  1409,1414,1109,1297,1117,1306,1116,1304,1112,1300,   0,   0,   0,   0,   0,   0,\n-  1471,1472,1701,1705,1702,1706,1703,1707,1430,1431,1715,1719,1716,1720,1717,1721,\n-  1477,1478,1729,1731,1730,1732,   0,   0,1435,1436,1733,1735,1734,1736,   0,   0,\n-  1481,1482,1737,1741,1738,1742,1739,1743,1439,1440,1751,1755,1752,1756,1753,1757,\n-  1490,1491,1765,1768,1766,1769,1767,1770,1447,1448,1771,1774,1772,1775,1773,1776,\n-  1495,1496,1777,1779,1778,1780,   0,   0,1451,1452,1781,1783,1782,1784,   0,   0,\n-  1504,1505,1785,1788,1786,1789,1787,1790,   0,1459,   0,1791,   0,1792,   0,1793,\n-  1509,1510,1794,1798,1795,1799,1796,1800,1462,1463,1808,1812,1809,1813,1810,1814,\n-  1467,  21,1475,  22,1479,  23,1485,  24,1493,  27,1499,  28,1507,  29,   0,   0,\n-  1704,1708,1709,1710,1711,1712,1713,1714,1718,1722,1723,1724,1725,1726,1727,1728,\n-  1740,1744,1745,1746,1747,1748,1749,1750,1754,1758,1759,1760,1761,1762,1763,1764,\n-  1797,1801,1802,1803,1804,1805,1806,1807,1811,1815,1816,1817,1818,1819,1820,1821,\n-  1470,1469,1822,1474,1465,   0,1473,1825,1429,1428,1426,  12,1432,   0,  26,   0,\n-     0,1315,1823,1484,1466,   0,1483,1829,1433,  13,1437,  14,1441,1826,1827,1828,\n-  1488,1487,1513,  19,   0,   0,1492,1515,1445,1444,1442,  15,   0,1831,1832,1833,\n-  1502,1501,1516,  25,1497,1498,1506,1518,1457,1456,1454,  17,1453,1313,  11,   3,\n-     0,   0,1824,1512,1519,   0,1511,1830,1449,  16,1460,  18,1464,   4,   0,   0,\n-    30,  31,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,  20,   0,   0,   0,   2,   6,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1834,1835,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1836,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1837,1839,1838,\n-     0,   0,   0,   0,1840,   0,   0,   0,   0,1841,   0,   0,1842,   0,   0,   0,\n-     0,   0,   0,   0,1843,   0,1844,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,1845,   0,   0,1846,   0,   0,1847,   0,1848,   0,   0,   0,   0,   0,   0,\n-   937,   0,1850,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1849, 936, 938,\n-  1851,1852,   0,   0,1853,1854,   0,   0,1855,1856,   0,   0,   0,   0,   0,   0,\n-  1857,1858,   0,   0,1861,1862,   0,   0,1863,1864,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1867,1868,1869,1870,\n-  1859,1860,1865,1866,   0,   0,   0,   0,   0,   0,1871,1872,1873,1874,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,  32,  33,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1875,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1877,   0,1878,   0,\n-  1879,   0,1880,   0,1881,   0,1882,   0,1883,   0,1884,   0,1885,   0,1886,   0,\n-  1887,   0,1888,   0,   0,1889,   0,1890,   0,1891,   0,   0,   0,   0,   0,   0,\n-  1892,1893,   0,1894,1895,   0,1896,1897,   0,1898,1899,   0,1900,1901,   0,   0,\n-     0,   0,   0,   0,1876,   0,   0,   0,   0,   0,   0,   0,   0,   0,1902,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1904,   0,1905,   0,\n-  1906,   0,1907,   0,1908,   0,1909,   0,1910,   0,1911,   0,1912,   0,1913,   0,\n-  1914,   0,1915,   0,   0,1916,   0,1917,   0,1918,   0,   0,   0,   0,   0,   0,\n-  1919,1920,   0,1921,1922,   0,1923,1924,   0,1925,1926,   0,1927,1928,   0,   0,\n-     0,   0,   0,   0,1903,   0,   0,1929,1930,1931,1932,   0,   0,   0,1933,   0,\n-   710, 385, 724, 715, 455, 103, 186, 825, 825, 242, 751, 205, 241, 336, 524, 601,\n-   663, 676, 688, 738, 411, 434, 474, 500, 649, 746, 799, 108, 180, 416, 482, 662,\n-   810, 275, 462, 658, 692, 344, 618, 679, 293, 388, 440, 492, 740, 116, 146, 168,\n-   368, 414, 481, 527, 606, 660, 665, 722, 781, 803, 809, 538, 553, 588, 642, 758,\n-   811, 701, 233, 299, 573, 612, 487, 540, 714, 779, 232, 267, 412, 445, 457, 585,\n-   594, 766, 167, 613, 149, 148, 560, 589, 648, 768, 708, 345, 411, 704, 105, 259,\n-   313, 496, 518, 174, 542, 120, 307, 101, 430, 372, 584, 183, 228, 529, 650, 697,\n-   424, 732, 428, 349, 632, 355, 517, 110, 135, 147, 403, 580, 624, 700, 750, 170,\n-   193, 245, 297, 374, 463, 543, 763, 801, 812, 815, 162, 384, 420, 730, 287, 330,\n-   337, 366, 459, 476, 509, 558, 591, 610, 726, 652, 734, 759, 154, 163, 198, 473,\n-   683, 697, 292, 311, 353, 423, 572, 494, 113, 217, 259, 280, 314, 499, 506, 603,\n-   608, 752, 778, 782, 788, 117, 557, 748, 774, 320, 109, 126, 260, 265, 373, 411,\n-   479, 523, 655, 737, 823, 380, 765, 161, 395, 398, 438, 451, 502, 516, 537, 583,\n-   791, 136, 340, 769, 122, 273, 446, 727, 305, 322, 400, 496, 771, 155, 190, 269,\n-   377, 391, 406, 432, 501, 519, 599, 684, 687, 749, 776, 175, 452, 191, 480, 510,\n-   659, 772, 805, 813, 397, 444, 619, 566, 568, 575, 491, 471, 707, 111, 636, 156,\n-   153, 288, 346, 578, 256, 435, 383, 729, 680, 767, 694, 295, 128, 210,   0,   0,\n-   227,   0, 379,   0,   0, 150, 493, 525, 544, 551, 552, 556, 783, 576, 604,   0,\n-   661,   0, 703,   0,   0, 735, 743,   0,   0,   0, 793, 794, 795, 808, 741, 773,\n-   118, 127, 130, 166, 169, 177, 207, 213, 215, 226, 229, 268, 270, 317, 327, 329,\n-   335, 369, 375, 381, 404, 441, 448, 458, 477, 484, 503, 539, 545, 547, 546, 548,\n-   549, 550, 554, 555, 561, 564, 569, 591, 593, 595, 598, 607, 620, 625, 625, 651,\n-   690, 695, 705, 706, 716, 717, 733, 735, 777, 786, 790, 315, 869, 623,   0,   0,\n-   102, 145, 134, 115, 129, 138, 165, 171, 207, 202, 206, 212, 227, 231, 240, 243,\n-   250, 254, 294, 296, 303, 308, 319, 325, 321, 329, 326, 335, 341, 357, 360, 362,\n-   370, 379, 388, 389, 393, 421, 424, 438, 456, 454, 458, 465, 477, 535, 485, 490,\n-   493, 507, 512, 514, 521, 522, 525, 526, 528, 533, 532, 541, 565, 569, 574, 586,\n-   591, 597, 607, 637, 647, 674, 691, 693, 695, 698, 703, 699, 705, 704, 702, 706,\n-   709, 717, 728, 736, 747, 754, 770, 777, 783, 784, 786, 787, 790, 802, 825, 848,\n-   847, 857,  55,  65,  66, 883, 892, 916, 822, 824,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1586,   0,1605,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1602,1603,1934,1935,1574,1575,\n-  1576,1577,1579,1580,1581,1583,1584,   0,1585,1587,1588,1589,1591,   0,1592,   0,\n-  1593,1594,   0,1595,1596,   0,1598,1599,1600,1601,1604,1582,1578,1590,1597,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1936,   0,1937,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1938,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1939,1940,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1941,1942,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1944,1943,   0,1945,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1946,1947,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,1948,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1949,1950,\n-  1951,1952,1953,1954,1955,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-     0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,1956,1957,1958,1960,1959,\n-  1961,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n-   106, 104, 107, 826, 114, 118, 119, 121, 123, 124, 127, 125,  34, 830, 130, 131,\n-   132, 137, 827,  35, 133, 139, 829, 142, 143, 112, 144, 145, 924, 151, 152,  37,\n-   157, 158, 159, 160,  38, 165, 166, 169, 171, 172, 173, 174, 176, 177, 178, 179,\n-   181, 182, 182, 182, 833, 468, 184, 185, 834, 187, 188, 189, 196, 192, 194, 195,\n-   197, 199, 200, 201, 203, 204, 204, 206, 208, 209, 211, 218, 213, 219, 214, 216,\n-   153, 234, 221, 222, 223, 220, 225, 224, 230, 835, 235, 236, 237, 238, 239, 244,\n-   836, 837, 247, 248, 249, 246, 251,  39,  40, 253, 255, 255, 838, 257, 258, 259,\n-   261, 839, 262, 263, 301, 264,  41, 266, 270, 272, 271, 841, 274, 842, 277, 276,\n-   278, 281, 282,  42, 283, 284, 285, 286,  43, 843,  44, 289, 290, 291, 293, 934,\n-   298, 845, 845, 621, 300, 300,  45, 852, 894, 302, 304,  46, 306, 309, 310, 312,\n-   316,  48,  47, 317, 846, 318, 323, 324, 325, 324, 328, 329, 333, 331, 332, 334,\n-   335, 336, 338, 339, 342, 343, 347, 351, 849, 350, 348, 352, 354, 359, 850, 361,\n-   358, 356,  49, 363, 365, 367, 364,  50, 369, 371, 851, 376, 386, 378,  53, 381,\n-    52,  51, 140, 141, 387, 382, 614,  78, 388, 389, 390, 394, 392, 856,  54, 399,\n-   396, 402, 404, 858, 405, 401, 407,  55, 408, 409, 410, 413, 859, 415,  56, 417,\n-   860, 418,  57, 419, 422, 424, 425, 861, 840, 862, 426, 863, 429, 431, 427, 433,\n-   437, 441, 438, 439, 442, 443, 864, 436, 449, 450,  58, 454, 453, 865, 447, 460,\n-   866, 867, 461, 466, 465, 464,  59, 467, 470, 469, 472, 828, 475, 868, 478, 870,\n-   483, 485, 486, 871, 488, 489, 872, 873, 495, 497,  60, 498,  61,  61, 504, 505,\n-   507, 508, 511,  62, 513, 874, 515, 875, 518, 844, 520, 876, 877, 878,  63,  64,\n-   528, 880, 879, 881, 882, 530, 531, 531, 533,  66, 534,  67,  68, 884, 536, 538,\n-   541,  69, 885, 549, 886, 887, 556, 559,  70, 561, 562, 563, 888, 889, 889, 567,\n-    71, 890, 570, 571,  72, 891, 577,  73, 581, 579, 582, 893, 587,  74, 590, 592,\n-   596,  75, 895, 896,  76, 897, 600, 898, 602, 605, 607, 899, 900, 609, 901, 611,\n-   853,  77, 615, 616,  79, 617, 252, 902, 903, 854, 855, 621, 622, 731,  80, 627,\n-   626, 628, 164, 629, 630, 631, 633, 904, 632, 634, 639, 640, 635, 641, 646, 651,\n-   638, 643, 644, 645, 905, 907, 906,  81, 653, 654, 656, 911, 657, 908,  82,  83,\n-   909, 910,  84, 664, 665, 666, 667, 669, 668, 671, 670, 674, 672, 673, 675,  85,\n-   677, 678,  86, 681, 682, 912, 685, 686,  87, 689,  36, 913, 914,  88,  89, 696,\n-   702, 709, 711, 915, 712, 713, 718, 719, 917, 831, 721, 720, 723, 832, 725, 728,\n-   918, 919, 739, 742, 744, 920, 745, 753, 756, 757, 755, 760, 761, 921, 762,  90,\n-   764, 922,  91, 775, 279, 780, 923, 925,  92,  93, 785, 926,  94, 927, 787, 787,\n-   789, 928, 792,  95, 796, 797, 798, 800,  96, 929, 802, 804, 806,  97,  98, 807,\n-   930,  99, 931, 932, 933, 814, 100, 816, 817, 818, 819, 820, 821, 935,   0,   0,\n+     0,   0,   0,1956,1957,1958,1960,1959,1961,   0,   0,   0,   0,   0,   0,   0,\n+     0,   0,   0,   0,   0,   0,   0,   0, 106, 104, 107, 826, 114, 118, 119, 121,\n+   123, 124, 127, 125,  34, 830, 130, 131, 132, 137, 827,  35, 133, 139, 829, 142,\n+   143, 112, 144, 145, 924, 151, 152,  37, 157, 158, 159, 160,  38, 165, 166, 169,\n+   171, 172, 173, 174, 176, 177, 178, 179, 181, 182, 182, 182, 833, 468, 184, 185,\n+   834, 187, 188, 189, 196, 192, 194, 195, 197, 199, 200, 201, 203, 204, 204, 206,\n+   208, 209, 211, 218, 213, 219, 214, 216, 153, 234, 221, 222, 223, 220, 225, 224,\n+   230, 835, 235, 236, 237, 238, 239, 244, 836, 837, 247, 248, 249, 246, 251,  39,\n+    40, 253, 255, 255, 838, 257, 258, 259, 261, 839, 262, 263, 301, 264,  41, 266,\n+   270, 272, 271, 841, 274, 842, 277, 276, 278, 281, 282,  42, 283, 284, 285, 286,\n+    43, 843,  44, 289, 290, 291, 293, 934, 298, 845, 845, 621, 300, 300,  45, 852,\n+   894, 302, 304,  46, 306, 309, 310, 312, 316,  48,  47, 317, 846, 318, 323, 324,\n+   325, 324, 328, 329, 333, 331, 332, 334, 335, 336, 338, 339, 342, 343, 347, 351,\n+   849, 350, 348, 352, 354, 359, 850, 361, 358, 356,  49, 363, 365, 367, 364,  50,\n+   369, 371, 851, 376, 386, 378,  53, 381,  52,  51, 140, 141, 387, 382, 614,  78,\n+   388, 389, 390, 394, 392, 856,  54, 399, 396, 402, 404, 858, 405, 401, 407,  55,\n+   408, 409, 410, 413, 859, 415,  56, 417, 860, 418,  57, 419, 422, 424, 425, 861,\n+   840, 862, 426, 863, 429, 431, 427, 433, 437, 441, 438, 439, 442, 443, 864, 436,\n+   449, 450,  58, 454, 453, 865, 447, 460, 866, 867, 461, 466, 465, 464,  59, 467,\n+   470, 469, 472, 828, 475, 868, 478, 870, 483, 485, 486, 871, 488, 489, 872, 873,\n+   495, 497,  60, 498,  61,  61, 504, 505, 507, 508, 511,  62, 513, 874, 515, 875,\n+   518, 844, 520, 876, 877, 878,  63,  64, 528, 880, 879, 881, 882, 530, 531, 531,\n+   533,  66, 534,  67,  68, 884, 536, 538, 541,  69, 885, 549, 886, 887, 556, 559,\n+    70, 561, 562, 563, 888, 889, 889, 567,  71, 890, 570, 571,  72, 891, 577,  73,\n+   581, 579, 582, 893, 587,  74, 590, 592, 596,  75, 895, 896,  76, 897, 600, 898,\n+   602, 605, 607, 899, 900, 609, 901, 611, 853,  77, 615, 616,  79, 617, 252, 902,\n+   903, 854, 855, 621, 622, 731,  80, 627, 626, 628, 164, 629, 630, 631, 633, 904,\n+   632, 634, 639, 640, 635, 641, 646, 651, 638, 643, 644, 645, 905, 907, 906,  81,\n+   653, 654, 656, 911, 657, 908,  82,  83, 909, 910,  84, 664, 665, 666, 667, 669,\n+   668, 671, 670, 674, 672, 673, 675,  85, 677, 678,  86, 681, 682, 912, 685, 686,\n+    87, 689,  36, 913, 914,  88,  89, 696, 702, 709, 711, 915, 712, 713, 718, 719,\n+   917, 831, 721, 720, 723, 832, 725, 728, 918, 919, 739, 742, 744, 920, 745, 753,\n+   756, 757, 755, 760, 761, 921, 762,  90, 764, 922,  91, 775, 279, 780, 923, 925,\n+    92,  93, 785, 926,  94, 927, 787, 787, 789, 928, 792,  95, 796, 797, 798, 800,\n+    96, 929, 802, 804, 806,  97,  98, 807, 930,  99, 931, 932, 933, 814, 100, 816,\n+   817, 818, 819, 820, 821, 935,   0,   0,\n@@ -6734,1 +6846,1 @@\n-_hb_ucd_i16[92] =\n+_hb_ucd_i16[196] =\n@@ -6736,6 +6848,13 @@\n-      0,    0,    1,   -1,    2,    0,   -2,    0,    0,    2,    0,   -2,    0,   16,    0,  -16,\n-      0,    1,   -1,    0,    3,    3,    3,   -3,   -3,   -3,    0, 2016,    0, 2527, 1923, 1914,\n-   1918,    0, 2250,    0,    0,  138,    0,    7,   -7,    0,   -1,    1, 1824,    0, 2104,    0,\n-   2108, 2106,    0, 2106, 1316,    0,   -1, -138,    8,    8,    8,    0,    7,    7,   -8,   -8,\n-     -8,   -7,-1316,    1,   -1,    3,   -3,    1,    0,-1914,-1918,    0,    0,-1923,-1824,    0,\n-      0,-2016,-2104,    0,    0,-2106,-2108,-2106,-2250,    0,-2527,    0,\n+      0,    0,    0,    0,    1,   -1,    0,    0,    2,    0,   -2,    0,    0,    0,    0,    2,\n+      0,   -2,    0,    0,    0,    0,    0,   16,    0,    0,    0,  -16,    0,    0,    1,   -1,\n+      0,    0,    0,    1,   -1,    0,    0,    0,    0,    1,   -1,    0,    3,    3,    3,   -3,\n+     -3,   -3,    0,    0,    0, 2016,    0,    0,    0,    0,    0, 2527, 1923, 1914, 1918,    0,\n+   2250,    0,    0,    0,    0,    0,    0,  138,    0,    7,    0,    0,   -7,    0,    0,    0,\n+      1,   -1,    1,   -1,   -1,    1,   -1,    0, 1824,    0,    0,    0,    0,    0, 2104,    0,\n+   2108, 2106,    0, 2106, 1316,    0,    0,    0,    0,    1,   -1,    1,   -1, -138,    0,    0,\n+      1,   -1,    8,    8,    8,    0,    7,    7,    0,    0,   -8,   -8,   -8,   -7,   -7,    0,\n+      1,   -1,    0,    2,-1316,    1,   -1,    0,   -1,    1,   -1,    1,   -1,    3,    1,   -1,\n+     -3,    1,   -1,    1,   -1,    0,    0,-1914,-1918,    0,    0,-1923,-1824,    0,    0,    0,\n+      0,-2016,    0,    0,    1,   -1,    0,    1,    0,    0,-2104,    0,    0,    0,    0,-2106,\n+  -2108,-2106,    0,    0,    1,   -1,-2250,    0,    0,    0,-2527,    0,    0,   -2,    0,    1,\n+     -1,    0,    1,   -1,\n@@ -6747,1 +6866,1 @@\n-  return u<1114112u?_hb_ucd_u8[4920+(((_hb_ucd_u8[1104+(((_hb_ucd_u16[((_hb_ucd_u8[272+(((_hb_ucd_u8[u>>1>>3>>3>>5])<<5)+((u>>1>>3>>3)&31u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:2;\n+  return u<1114112u?_hb_ucd_u8[5056+(((_hb_ucd_u8[1168+(((_hb_ucd_u16[((_hb_ucd_u8[544+(((_hb_ucd_u8[u>>1>>3>>3>>4])<<4)+((u>>1>>3>>3)&15u))])<<3)+((u>>1>>3)&7u)])<<3)+((u>>1)&7u))])<<1)+((u)&1u))]:2;\n@@ -6752,1 +6871,1 @@\n-  return u<125259u?_hb_ucd_u8[6796+(((_hb_ucd_u8[6276+(((_hb_ucd_u8[5844+(((_hb_ucd_u8[5508+(((_hb_ucd_u8[5262+(u>>2>>2>>2>>3)])<<3)+((u>>2>>2>>2)&7u))])<<2)+((u>>2>>2)&3u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:0;\n+  return u<125259u?_hb_ucd_u8[6970+(((_hb_ucd_u8[6426+(((_hb_ucd_u8[5982+(((_hb_ucd_u8[5646+(((_hb_ucd_u8[5400+(u>>2>>2>>2>>3)])<<3)+((u>>2>>2>>2)&7u))])<<2)+((u>>2>>2)&3u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:0;\n@@ -6762,1 +6881,1 @@\n-  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[7672+(((_hb_ucd_u8[7448+(((_hb_ucd_u8[7352+(((_hb_ucd_b4(7288+_hb_ucd_u8,u>>1>>2>>3>>3))<<3)+((u>>1>>2>>3)&7u))])<<3)+((u>>1>>2)&7u))])<<2)+((u>>1)&3u))])<<1)+((u)&1u)]:0;\n+  return u<65380u?_hb_ucd_i16[((_hb_ucd_u8[7714+(((_hb_ucd_u8[7594+(((_hb_ucd_b4(7466+_hb_ucd_u8,u>>2>>3>>3))<<3)+((u>>2>>3)&7u))])<<3)+((u>>2)&7u))])<<2)+((u)&3u)]:0;\n@@ -6767,1 +6886,1 @@\n-  return u<918016u?_hb_ucd_u8[11242+(((_hb_ucd_u8[10314+(((_hb_ucd_u8[8938+(((_hb_ucd_u8[8362+(((_hb_ucd_u8[7912+(u>>2>>2>>3>>4)])<<4)+((u>>2>>2>>3)&15u))])<<3)+((u>>2>>2)&7u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:2;\n+  return u<918016u?_hb_ucd_u8[11480+(((_hb_ucd_u8[10532+(((_hb_ucd_u8[9124+(((_hb_ucd_u8[8500+(((_hb_ucd_u8[8050+(u>>2>>2>>3>>4)])<<4)+((u>>2>>2>>3)&15u))])<<3)+((u>>2>>2)&7u))])<<2)+((u>>2)&3u))])<<2)+((u)&3u))]:2;\n@@ -6772,1 +6891,1 @@\n-  return u<195102u?_hb_ucd_u16[1536+(((_hb_ucd_u8[12544+(((_hb_ucd_u8[12162+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:0;\n+  return u<195102u?_hb_ucd_u16[1576+(((_hb_ucd_u8[12802+(((_hb_ucd_u8[12420+(u>>4>>5)])<<5)+((u>>4)&31u))])<<4)+((u)&15u))]:0;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ucd-table.hh","additions":3458,"deletions":3339,"binary":false,"changes":6797,"status":"modified"},{"patch":"@@ -206,1 +206,0 @@\n-#if HB_USE_ATEXIT\n@@ -208,1 +207,0 @@\n-#endif\n@@ -225,3 +223,1 @@\n-#if HB_USE_ATEXIT\n-    atexit (free_static_ucd_funcs);\n-#endif\n+    hb_atexit (free_static_ucd_funcs);\n@@ -233,2 +229,1 @@\n-#if HB_USE_ATEXIT\n-static\n+static inline\n@@ -239,1 +234,0 @@\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ucd.cc","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -9,3 +9,3 @@\n- * # emoji-data.txt\n- * # Date: 2020-01-28, 20:52:38 GMT\n- * #  2020 Unicode, Inc.\n+ * # emoji-data-14.0.0.txt\n+ * # Date: 2021-08-26, 17:22:22 GMT\n+ * #  2021 Unicode, Inc.\n@@ -16,1 +16,1 @@\n- * # Version: 13.0\n+ * # Used with Emoji Version 14.0 and subsequent minor revisions (if any)\n@@ -27,1 +27,1 @@\n-_hb_emoji_u8[448] =\n+_hb_emoji_u8[544] =\n@@ -29,1 +29,5 @@\n-    0,  0,  0,  0, 33,  3,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+   16, 17, 17, 17, 50, 20, 21, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,\n+   17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,118,152,\n+    0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n@@ -31,26 +35,28 @@\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 84,118,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  2,  0,  0,  3,\n-    0,  0,  0,  0,  0,  0,  4,  5,  6,  7,  8,  7,  9, 10, 11,  0,\n-    0,  0,  0,  0, 12,  0,  0,  0,  0,  0,  0,  0, 13,  0,  0,  0,\n-    7,  7,  7, 14, 15, 16, 17, 18, 19, 20,  7,  7,  7,  7,  7, 21,\n-    7,  7,  7,  7, 22, 23,  7,  7,  7, 24,  7, 14,  0, 25,  0, 26,\n-   27, 28, 29, 14, 30, 31,  7,  7,  7,  7,  7, 14,  0,  0,  0,  0,\n-    7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7, 22,\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,240,  1,  0,  2,  0,  0,\n-    0,  0,  0,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0,254,  7,  3,\n-    0,  0,  0,  0,  0,  4,  0,  0,  0,  0,  0,  0,  0,  0,  0, 56,\n-  159,255,243,255,255,255,255,255,255,255,255,255,255,255,255,255,\n-   31,  0,255,255,255,255,255,255, 31,255,  3,  0,  0,  0,  8,  0,\n-    0,  0, 24,  0,120,  0,  0,  0,  0,  0, 96,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,  0, 16,  0, 96,  0,  0,  8,  0,  0,  0,  0,\n-  255,255,255,255,255,255,255,127,  0, 96,  0,  0,  0,  0,  0,  0,\n-    0,  0,  0,  0,  0,240,  1, 64,  0,  0,254,  3,  0,224,255,255,\n-  255,255,255,255, 31,  0,  0,  0,254,127,  0,  0,  0,  0,252,115,\n-    0,254,255,255,255,255,255,255,255,255,255,255,255,255,255,  3,\n-  255,255,255,255,255,255,255, 31,192,255,255,255,255,255,255,255,\n-  255,127,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,240,127,\n-    0,  0,224,255,255,255,255,127,  0,112,  0,  0,  0,  0,  0,  0,\n-    0,127,  0,124,  0,  0,  0,  0,  0,127,  0,  0,  0,192,255,255,\n-    0,240,255,255,255,255,255,243,159,255,255,255,255,255,255,255,\n+    2,  3,  0,  0,  4,  0,  5,  0,  0,  0,  0,  0,  6,  0,  7,  8,\n+    0,  0,  0,  9,  0,  0, 10, 11, 12, 13, 14, 13, 15, 16, 17,  0,\n+    0,  0,  0,  0, 18,  0,  0,  0,  0,  0,  0,  0, 19, 20,  0,  0,\n+   21,  0,  0,  0,  0,  0,  0,  0,  0,  0, 22,  0,  0,  0,  0,  0,\n+   13, 13, 13, 13, 23, 24, 25, 26, 27, 28, 13, 13, 13, 13, 13, 29,\n+   13, 13, 13, 13, 30, 31, 13, 13, 13, 32, 13, 13,  0, 33,  0, 34,\n+   35, 36, 37, 13, 38, 39, 13, 13, 13, 13, 13, 13,  0,  0,  0,  0,\n+   13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 30,\n+    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 66,  0,  0,\n+    0,  0,  0,  0,  0,  0,  0, 16,  0,  2,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  4,  0,  0,  2,  0,  0,240,  3,  0,  6,  0,  0,\n+    0,  0,  0, 12,  0,  1,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,\n+    0,128,  0,  0,  0,254, 15,  7,  4,  0,  0,  0,  0,  0,  0,  0,\n+    0,  0,  0,  0,  0, 12, 64,  0,  1,  0,  0,  0,  0,  0,  0,120,\n+  191,255,247,255,255,255,255,255,255,255,255,255,255,255,255,255,\n+   63,  0,255,255,255,255,255,255, 63,255, 87, 32,  2,  1, 24,  0,\n+  144, 80,184,  0,248,  0,  0,  0,  0,  0,224,  0,  2,  0,  1,128,\n+    0,  0,  0,  0,  0,  0, 48,  0,224,  0,  0, 24,  0,  0,  0,  0,\n+    0,  0, 33,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1, 32,\n+    0,  0,128,  2,  0,  0,  0,  0,  0,224,  0,  0,  0,128,  0,  0,\n+    0,  0,  0,  0,  0,240,  3,192,  0, 64,254,  7,  0,224,255,255,\n+  255,255,255,255, 63,  0,  0,  0,254,255,  0,  4,  0,128,252,247,\n+    0,254,255,255,255,255,255,255,255,255,255,255,255,255,255,  7,\n+  255,255,255,255,255,255,255, 63,192,255,255,255,255,255,255,255,\n+  255,255,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,240,255,\n+    0,  0,224,255,255,255,255,255,  0,240,  0,  0,  0,  0,  0,  0,\n+    0,255,  0,252,  0,  0,  0,  0,  0,255,  0,  0,  0,192,255,255,\n+    0,240,255,255,255,255,255,247,191,255,255,255,255,255,255,255,\n@@ -72,1 +78,1 @@\n-  return u<131069u?_hb_emoji_b1(192+_hb_emoji_u8,((_hb_emoji_u8[64+(((_hb_emoji_b4(_hb_emoji_u8,u>>6>>4))<<4)+((u>>6)&15u))])<<6)+((u)&63u)):0;\n+  return u<131070u?_hb_emoji_b1(224+_hb_emoji_u8,((_hb_emoji_u8[64+(((_hb_emoji_b4(_hb_emoji_u8,u>>6>>4))<<4)+((u>>6)&15u))])<<6)+((u)&63u)):0;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-unicode-emoji-table.hh","additions":39,"deletions":33,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n- * hb_unicode_funcs_create: (Xconstructor)\n+ * hb_unicode_funcs_create:\n@@ -271,1 +271,1 @@\n-  free (ufuncs);\n+  hb_free (ufuncs);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-unicode.cc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,2 +108,1 @@\n-    \/* XXX This hack belongs to the USE shaper (for Tai Tham):\n-     * Reorder SAKOT to ensure it comes after any tone marks. *\/\n+    \/* Reorder SAKOT to ensure it comes after any tone marks. *\/\n@@ -111,3 +110,1 @@\n-\n-    \/* XXX This hack belongs to the Tibetan shaper:\n-     * Reorder PADMA to ensure it comes after any vowel marks. *\/\n+    \/* Reorder PADMA to ensure it comes after any vowel marks. *\/\n@@ -124,1 +121,1 @@\n-    \/* U+180B..180D MONGOLIAN FREE VARIATION SELECTORs are handled in the\n+    \/* U+180B..180D, U+180F MONGOLIAN FREE VARIATION SELECTORs are handled in the\n@@ -139,1 +136,1 @@\n-   * Unicode 7.0:\n+   * Unicode 14.0:\n@@ -148,0 +145,1 @@\n+   * 180F          # Mn       MONGOLIAN FREE VARIATION SELECTOR FOUR\n@@ -292,2 +290,2 @@\n-#define HB_MODIFIED_COMBINING_CLASS_CCC18 21 \/* qamats *\/\n-#define HB_MODIFIED_COMBINING_CLASS_CCC19 14 \/* holam *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC18 21 \/* qamats & qamats qatan *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC19 14 \/* holam & holam haser for vav*\/\n@@ -362,0 +360,7 @@\n+#define HB_UNICODE_GENERAL_CATEGORY_IS_LETTER(gen_cat) \\\n+        (FLAG_UNSAFE (gen_cat) & \\\n+         (FLAG (HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER)))\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-unicode.hh","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"hb-meta.hh\"\n@@ -35,2 +36,3 @@\n-template <typename Type>\n-struct hb_vector_t\n+template <typename Type,\n+          bool sorted=false>\n+struct hb_vector_t : std::conditional<sorted, hb_vector_t<Type, false>, hb_empty_t>::type\n@@ -40,0 +42,2 @@\n+  using array_t = typename std::conditional<sorted, hb_sorted_array_t<Type>, hb_array_t<Type>>::type;\n+  using c_array_t = typename std::conditional<sorted, hb_sorted_array_t<const Type>, hb_array_t<const Type>>::type;\n@@ -41,2 +45,3 @@\n-  hb_vector_t ()  { init (); }\n-  hb_vector_t (const hb_vector_t &o)\n+  hb_vector_t () = default;\n+  hb_vector_t (std::nullptr_t) : hb_vector_t () {}\n+  hb_vector_t (std::initializer_list<Type> lst) : hb_vector_t ()\n@@ -44,2 +49,10 @@\n-    init ();\n-    alloc (o.length);\n+    alloc (lst.size ());\n+    for (auto&& item : lst)\n+      push (item);\n+  }\n+  template <typename Iterable,\n+            hb_requires (hb_is_iterable (Iterable))>\n+  hb_vector_t (const Iterable &o) : hb_vector_t ()\n+  {\n+    if (hb_iter (o).is_random_access_iterator)\n+      alloc (hb_len (hb_iter (o)));\n@@ -48,0 +61,6 @@\n+  hb_vector_t (const hb_vector_t &o) : hb_vector_t ()\n+  {\n+    alloc (o.length);\n+    if (unlikely (in_error ())) return;\n+    copy_vector (o);\n+  }\n@@ -57,2 +76,0 @@\n-  private:\n-  int allocated; \/* == -1 means allocation failed. *\/\n@@ -60,1 +77,2 @@\n-  unsigned int length;\n+  int allocated = 0; \/* == -1 means allocation failed. *\/\n+  unsigned int length = 0;\n@@ -62,1 +80,1 @@\n-  Type *arrayZ;\n+  Type *arrayZ = nullptr;\n@@ -72,1 +90,2 @@\n-    free (arrayZ);\n+    shrink_vector (0);\n+    hb_free (arrayZ);\n@@ -75,7 +94,0 @@\n-  void fini_deep ()\n-  {\n-    unsigned int count = length;\n-    for (unsigned int i = 0; i < count; i++)\n-      arrayZ[i].fini ();\n-    fini ();\n-  }\n@@ -90,0 +102,7 @@\n+  friend void swap (hb_vector_t& a, hb_vector_t& b)\n+  {\n+    hb_swap (a.allocated, b.allocated);\n+    hb_swap (a.length, b.length);\n+    hb_swap (a.arrayZ, b.arrayZ);\n+  }\n+\n@@ -94,1 +113,4 @@\n-    hb_copy (o, *this);\n+    if (unlikely (in_error ())) return *this;\n+\n+    copy_vector (o);\n+\n@@ -99,5 +121,1 @@\n-    fini ();\n-    allocated = o.allocated;\n-    length = o.length;\n-    arrayZ = o.arrayZ;\n-    o.init ();\n+    hb_swap (*this, o);\n@@ -137,1 +155,1 @@\n-  hb_vector_t& operator << (T&& v) { push (hb_forward<T> (v)); return *this; }\n+  hb_vector_t& operator << (T&& v) { push (std::forward<T> (v)); return *this; }\n@@ -139,2 +157,2 @@\n-  hb_array_t<      Type> as_array ()       { return hb_array (arrayZ, length); }\n-  hb_array_t<const Type> as_array () const { return hb_array (arrayZ, length); }\n+  array_t   as_array ()       { return hb_array (arrayZ, length); }\n+  c_array_t as_array () const { return hb_array (arrayZ, length); }\n@@ -143,2 +161,2 @@\n-  typedef hb_array_t<const Type>   iter_t;\n-  typedef hb_array_t<      Type> writer_t;\n+  typedef c_array_t   iter_t;\n+  typedef array_t   writer_t;\n@@ -150,1 +168,1 @@\n-  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int count) const\n+  c_array_t sub_array (unsigned int start_offset, unsigned int count) const\n@@ -152,1 +170,1 @@\n-  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/) const\n+  c_array_t sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/) const\n@@ -154,1 +172,1 @@\n-  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int count)\n+  array_t sub_array (unsigned int start_offset, unsigned int count)\n@@ -156,1 +174,1 @@\n-  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/)\n+  array_t sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/)\n@@ -174,1 +192,1 @@\n-    return &arrayZ[length - 1];\n+    return std::addressof (arrayZ[length - 1]);\n@@ -176,1 +194,4 @@\n-  template <typename T>\n+  template <typename T,\n+            typename T2 = Type,\n+            hb_enable_if (!std::is_copy_constructible<T2>::value &&\n+                          std::is_copy_assignable<T>::value)>\n@@ -180,1 +201,6 @@\n-    *p = hb_forward<T> (v);\n+    if (p == &Crap (Type))\n+      \/\/ If push failed to allocate then don't copy v, since this may cause\n+      \/\/ the created copy to leak memory since we won't have stored a\n+      \/\/ reference to it.\n+      return p;\n+    *p = std::forward<T> (v);\n@@ -183,0 +209,16 @@\n+  template <typename T,\n+            typename T2 = Type,\n+            hb_enable_if (std::is_copy_constructible<T2>::value)>\n+  Type *push (T&& v)\n+  {\n+    if (unlikely (!alloc (length + 1)))\n+      \/\/ If push failed to allocate then don't copy v, since this may cause\n+      \/\/ the created copy to leak memory since we won't have stored a\n+      \/\/ reference to it.\n+      return &Crap (Type);\n+\n+    \/* Emplace. *\/\n+    length++;\n+    Type *p = std::addressof (arrayZ[length - 1]);\n+    return new (p) Type (std::forward<T> (v));\n+  }\n@@ -186,0 +228,122 @@\n+  template <typename T = Type,\n+            hb_enable_if (hb_is_trivially_copy_assignable(T))>\n+  Type *\n+  realloc_vector (unsigned new_allocated)\n+  {\n+    return (Type *) hb_realloc (arrayZ, new_allocated * sizeof (Type));\n+  }\n+  template <typename T = Type,\n+            hb_enable_if (!hb_is_trivially_copy_assignable(T))>\n+  Type *\n+  realloc_vector (unsigned new_allocated)\n+  {\n+    Type *new_array = (Type *) hb_malloc (new_allocated * sizeof (Type));\n+    if (likely (new_array))\n+    {\n+      for (unsigned i = 0; i < length; i++)\n+        new (std::addressof (new_array[i])) Type ();\n+      for (unsigned i = 0; i < (unsigned) length; i++)\n+        new_array[i] = std::move (arrayZ[i]);\n+      unsigned old_length = length;\n+      shrink_vector (0);\n+      length = old_length;\n+      hb_free (arrayZ);\n+    }\n+    return new_array;\n+  }\n+\n+  template <typename T = Type,\n+            hb_enable_if (hb_is_trivially_constructible(T))>\n+  void\n+  grow_vector (unsigned size)\n+  {\n+    memset (arrayZ + length, 0, (size - length) * sizeof (*arrayZ));\n+    length = size;\n+  }\n+  template <typename T = Type,\n+            hb_enable_if (!hb_is_trivially_constructible(T))>\n+  void\n+  grow_vector (unsigned size)\n+  {\n+    while (length < size)\n+    {\n+      length++;\n+      new (std::addressof (arrayZ[length - 1])) Type ();\n+    }\n+  }\n+\n+  template <typename T = Type,\n+            hb_enable_if (hb_is_trivially_copyable (T))>\n+  void\n+  copy_vector (const hb_vector_t &other)\n+  {\n+    length = other.length;\n+    hb_memcpy ((void *) arrayZ, (const void *) other.arrayZ, length * item_size);\n+  }\n+  template <typename T = Type,\n+            hb_enable_if (!hb_is_trivially_copyable (T) &&\n+                           std::is_copy_constructible<T>::value)>\n+  void\n+  copy_vector (const hb_vector_t &other)\n+  {\n+    length = 0;\n+    while (length < other.length)\n+    {\n+      length++;\n+      new (std::addressof (arrayZ[length - 1])) Type (other.arrayZ[length - 1]);\n+    }\n+  }\n+  template <typename T = Type,\n+            hb_enable_if (!hb_is_trivially_copyable (T) &&\n+                          !std::is_copy_constructible<T>::value &&\n+                          std::is_default_constructible<T>::value &&\n+                          std::is_copy_assignable<T>::value)>\n+  void\n+  copy_vector (const hb_vector_t &other)\n+  {\n+    length = 0;\n+    while (length < other.length)\n+    {\n+      length++;\n+      new (std::addressof (arrayZ[length - 1])) Type ();\n+      arrayZ[length - 1] = other.arrayZ[length - 1];\n+    }\n+  }\n+\n+  template <typename T = Type,\n+            hb_enable_if (hb_is_trivially_destructible(T))>\n+  void\n+  shrink_vector (unsigned size)\n+  {\n+    length = size;\n+  }\n+  template <typename T = Type,\n+            hb_enable_if (!hb_is_trivially_destructible(T))>\n+  void\n+  shrink_vector (unsigned size)\n+  {\n+    while ((unsigned) length > size)\n+    {\n+      arrayZ[(unsigned) length - 1].~Type ();\n+      length--;\n+    }\n+  }\n+\n+  template <typename T = Type,\n+            hb_enable_if (hb_is_trivially_copy_assignable(T))>\n+  void\n+  shift_down_vector (unsigned i)\n+  {\n+    memmove (static_cast<void *> (&arrayZ[i - 1]),\n+             static_cast<void *> (&arrayZ[i]),\n+             (length - i) * sizeof (Type));\n+  }\n+  template <typename T = Type,\n+            hb_enable_if (!hb_is_trivially_copy_assignable(T))>\n+  void\n+  shift_down_vector (unsigned i)\n+  {\n+    for (; i < length; i++)\n+      arrayZ[i - 1] = std::move (arrayZ[i]);\n+  }\n+\n@@ -207,1 +371,1 @@\n-      new_array = (Type *) realloc (arrayZ, new_allocated * sizeof (Type));\n+      new_array = realloc_vector (new_allocated);\n@@ -228,1 +392,3 @@\n-      memset (arrayZ + length, 0, (size - length) * sizeof (*arrayZ));\n+      grow_vector (size);\n+    else if (size < length)\n+      shrink_vector (size);\n@@ -237,1 +403,4 @@\n-    return hb_move (arrayZ[--length]); \/* Does this move actually work? *\/\n+    Type v = arrayZ[length - 1];\n+    arrayZ[length - 1].~Type ();\n+    length--;\n+    return v;\n@@ -244,3 +413,2 @@\n-    memmove (static_cast<void *> (&arrayZ[i]),\n-             static_cast<void *> (&arrayZ[i + 1]),\n-             (length - i - 1) * sizeof (Type));\n+    shift_down_vector (i + 1);\n+    arrayZ[length - 1].~Type ();\n@@ -253,3 +421,2 @@\n-     if (size < length)\n-       length = size;\n-  }\n+    if (size >= length)\n+      return;\n@@ -257,15 +424,1 @@\n-  template <typename T>\n-  Type *find (T v)\n-  {\n-    for (unsigned int i = 0; i < length; i++)\n-      if (arrayZ[i] == v)\n-        return &arrayZ[i];\n-    return nullptr;\n-  }\n-  template <typename T>\n-  const Type *find (T v) const\n-  {\n-    for (unsigned int i = 0; i < length; i++)\n-      if (arrayZ[i] == v)\n-        return &arrayZ[i];\n-    return nullptr;\n+    shrink_vector (size);\n@@ -274,0 +427,2 @@\n+\n+  \/* Sorting API. *\/\n@@ -279,0 +434,1 @@\n+  \/* Unsorted search API. *\/\n@@ -288,1 +444,0 @@\n-};\n@@ -290,16 +445,3 @@\n-template <typename Type>\n-struct hb_sorted_vector_t : hb_vector_t<Type>\n-{\n-  hb_sorted_array_t<      Type> as_array ()       { return hb_sorted_array (this->arrayZ, this->length); }\n-  hb_sorted_array_t<const Type> as_array () const { return hb_sorted_array (this->arrayZ, this->length); }\n-\n-  \/* Iterator. *\/\n-  typedef hb_sorted_array_t<const Type> const_iter_t;\n-  typedef hb_sorted_array_t<      Type>       iter_t;\n-  const_iter_t  iter () const { return as_array (); }\n-  const_iter_t citer () const { return as_array (); }\n-        iter_t  iter ()       { return as_array (); }\n-  operator       iter_t ()       { return iter (); }\n-  operator const_iter_t () const { return iter (); }\n-\n-  template <typename T>\n+  \/* Sorted search API. *\/\n+  template <typename T,\n+            bool Sorted=sorted, hb_enable_if (Sorted)>\n@@ -308,1 +450,2 @@\n-  template <typename T>\n+  template <typename T,\n+            bool Sorted=sorted, hb_enable_if (Sorted)>\n@@ -311,1 +454,2 @@\n-  template <typename T>\n+  template <typename T,\n+            bool Sorted=sorted, hb_enable_if (Sorted)>\n@@ -313,1 +457,1 @@\n-              hb_bfind_not_found_t not_found = HB_BFIND_NOT_FOUND_DONT_STORE,\n+              hb_not_found_t not_found = HB_NOT_FOUND_DONT_STORE,\n@@ -318,0 +462,3 @@\n+template <typename Type>\n+using hb_sorted_vector_t = hb_vector_t<Type, true>;\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-vector.hh","additions":227,"deletions":80,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#define HB_VERSION_MAJOR 2\n+#define HB_VERSION_MAJOR 4\n@@ -50,1 +50,1 @@\n-#define HB_VERSION_MINOR 8\n+#define HB_VERSION_MINOR 4\n@@ -56,1 +56,1 @@\n-#define HB_VERSION_MICRO 0\n+#define HB_VERSION_MICRO 1\n@@ -63,1 +63,1 @@\n-#define HB_VERSION_STRING \"2.8.0\"\n+#define HB_VERSION_STRING \"4.4.1\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-version.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-\n@@ -65,0 +64,1 @@\n+#pragma GCC diagnostic error   \"-Wbitwise-instead-of-logical\"\n@@ -67,0 +67,1 @@\n+#pragma GCC diagnostic error   \"-Wcomma\"\n@@ -120,0 +121,3 @@\n+#if defined(__GNUC__) && !defined(__clang__)\n+#pragma GCC diagnostic ignored \"-Wunused-result\"                \/\/ TODO fix\n+#endif\n@@ -182,0 +186,3 @@\n+#if defined(_MSC_VER) && !defined(_USE_MATH_DEFINES)\n+# define _USE_MATH_DEFINES\n+#endif\n@@ -223,4 +230,9 @@\n-#define malloc hb_malloc_impl\n-#define calloc hb_calloc_impl\n-#define realloc hb_realloc_impl\n-#define free hb_free_impl\n+#define hb_malloc hb_malloc_impl\n+#define hb_calloc hb_calloc_impl\n+#define hb_realloc hb_realloc_impl\n+#define hb_free hb_free_impl\n+#else\n+#define hb_malloc malloc\n+#define hb_calloc calloc\n+#define hb_realloc realloc\n+#define hb_free free\n@@ -338,1 +350,0 @@\n-#define hb_success_t HB_NODISCARD bool\n@@ -379,1 +390,1 @@\n-#  elif WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)\n+#  elif !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)\n@@ -401,0 +412,3 @@\n+#define HB_STMT_START do\n+#define HB_STMT_END   while (0)\n+\n@@ -429,1 +443,1 @@\n-#endif\n+#endif \/* defined(HAVE_ATEXIT) && !defined(HB_USE_ATEXIT) *\/\n@@ -436,3 +450,12 @@\n-\n-#define HB_STMT_START do\n-#define HB_STMT_END   while (0)\n+#ifndef hb_atexit\n+#if !HB_USE_ATEXIT\n+#  define hb_atexit(_) HB_STMT_START { if (0) (_) (); } HB_STMT_END\n+#else \/* HB_USE_ATEXIT *\/\n+#  ifdef HAVE_ATEXIT\n+#    define hb_atexit atexit\n+#  else\n+     template <void (*function) (void)> struct hb_atexit_t { ~hb_atexit_t () { function (); } };\n+#    define hb_atexit(f) static hb_atexit_t<f> _hb_atexit_##__LINE__;\n+#  endif\n+#endif\n+#endif\n@@ -450,0 +473,1 @@\n+#include \"hb-cplusplus.hh\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb.hh","additions":35,"deletions":11,"binary":false,"changes":46,"status":"modified"}]}