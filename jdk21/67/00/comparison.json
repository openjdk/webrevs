{"files":[{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2023, Rivos Inc. All rights reserved.\n@@ -33,2 +34,2 @@\n-const char* VM_Version::_uarch = \"\";\n-const char* VM_Version::_vm_mode = \"\";\n+#include <ctype.h>\n+\n@@ -37,0 +38,10 @@\n+#define DEF_RV_FEATURE(NAME, PRETTY, BIT, FSTRING, FLAGF)       \\\n+VM_Version::NAME##RVFeatureValue VM_Version::NAME(PRETTY, BIT, FSTRING);\n+RV_FEATURE_FLAGS(DEF_RV_FEATURE)\n+\n+#define ADD_RV_FEATURE_IN_LIST(NAME, PRETTY, BIT, FSTRING, FLAGF) \\\n+    &VM_Version::NAME,\n+VM_Version::RVFeatureValue* VM_Version::_feature_list[] = {\n+RV_FEATURE_FLAGS(ADD_RV_FEATURE_IN_LIST)\n+  nullptr};\n+\n@@ -44,1 +55,1 @@\n-  get_os_cpu_info();\n+  setup_cpu_available_features();\n@@ -47,1 +58,1 @@\n-  if (get_satp_mode() > VM_SV48) {\n+  if (satp_mode.value() > VM_SV48 || satp_mode.value() < VM_MBARE) {\n@@ -49,2 +60,3 @@\n-      err_msg(\"Unsupported satp mode: %s. Only satp modes up to sv48 are supported for now.\",\n-              _vm_mode));\n+      err_msg(\n+         \"Unsupported satp mode: SV%d. Only satp modes up to sv48 are supported for now.\",\n+         (int)satp_mode.value()));\n@@ -168,1 +180,1 @@\n-    if (!(_features & CPU_V)) {\n+    if (!ext_V.enabled()) {\n@@ -173,1 +185,1 @@\n-      _initial_vector_length = get_current_vector_length();\n+      _initial_vector_length = cpu_vector_length();\n@@ -177,1 +189,1 @@\n-  if (UseRVC && !(_features & CPU_C)) {\n+  if (UseRVC && !ext_C.enabled()) {\n@@ -188,1 +200,5 @@\n-    FLAG_SET_DEFAULT(AvoidUnalignedAccesses, true);\n+    if (unaligned_access.value() != MISALIGNED_FAST) {\n+      FLAG_SET_DEFAULT(AvoidUnalignedAccesses, true);\n+    } else {\n+      FLAG_SET_DEFAULT(AvoidUnalignedAccesses, false);\n+    }\n@@ -211,10 +227,0 @@\n-  char buf[512];\n-  buf[0] = '\\0';\n-  if (_uarch != nullptr && strcmp(_uarch, \"\") != 0) snprintf(buf, sizeof(buf), \"%s,\", _uarch);\n-  strcat(buf, \"rv64\");\n-#define ADD_FEATURE_IF_SUPPORTED(id, name, bit) if (_features & CPU_##id) strcat(buf, name);\n-  CPU_FEATURE_FLAGS(ADD_FEATURE_IF_SUPPORTED)\n-#undef ADD_FEATURE_IF_SUPPORTED\n-\n-  _features_string = os::strdup(buf);\n-\n@@ -336,1 +342,1 @@\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", _features_string);\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", features_string());\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":27,"deletions":21,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+ * Copyright (c) 2023, Rivos Inc. All rights reserved.\n@@ -33,0 +34,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n@@ -35,0 +38,2 @@\n+class RiscvHwprobe;\n+\n@@ -36,4 +41,24 @@\n-#ifdef COMPILER2\n-private:\n-  static void c2_initialize();\n-#endif \/\/ COMPILER2\n+  friend RiscvHwprobe;\n+ private:\n+  class RVFeatureValue {\n+    const char* const _pretty;\n+    const bool        _feature_string;\n+    const uint64_t    _feature_bit;\n+    bool              _enabled;\n+    int64_t           _value;\n+   public:\n+    RVFeatureValue(const char* pretty, int bit_num, bool fstring) :\n+      _pretty(pretty), _feature_string(fstring), _feature_bit(nth_bit(bit_num)),\n+      _enabled(false), _value(-1) {\n+    }\n+    void enable_feature(int64_t value = 0) {\n+      _enabled = true;\n+      _value = value;\n+    }\n+    const char* const pretty()   { return _pretty; }\n+    const uint64_t feature_bit() { return _feature_bit; }\n+    const bool feature_string()  { return _feature_string; }\n+    bool enabled()               { return _enabled; }\n+    int64_t value()              { return _value; }\n+    virtual void update_flag() = 0;\n+  };\n@@ -41,8 +66,109 @@\n-\/\/ VM modes (satp.mode) privileged ISA 1.10\n-enum VM_MODE {\n-  VM_MBARE = 0,\n-  VM_SV39  = 8,\n-  VM_SV48  = 9,\n-  VM_SV57  = 10,\n-  VM_SV64  = 11\n-};\n+  #define UPDATE_DEFAULT(flag)        \\\n+  void update_flag() {                \\\n+      assert(enabled(), \"Must be.\");  \\\n+      if (FLAG_IS_DEFAULT(flag)) {    \\\n+        FLAG_SET_DEFAULT(flag, true); \\\n+      }                               \\\n+  }                                   \\\n+\n+  #define NO_UPDATE_DEFAULT           \\\n+  void update_flag() {}               \\\n+\n+  \/\/ Frozen standard extensions\n+  \/\/ I RV64I\n+  \/\/ M Integer Multiplication and Division\n+  \/\/ A Atomic Instructions\n+  \/\/ F Single-Precision Floating-Point\n+  \/\/ D Single-Precision Floating-Point\n+  \/\/ (G = M + A + F + D)\n+  \/\/ Q Quad-Precision Floating-Point\n+  \/\/ C Compressed Instructions\n+  \/\/ H Hypervisor\n+  \/\/\n+  \/\/ Others, open and non-standard\n+  \/\/ V Vector\n+  \/\/\n+  \/\/ Cache Management Operations\n+  \/\/ Zicbom Cache Block Management Operations\n+  \/\/ Zicboz Cache Block Zero Operations\n+  \/\/ Zicbop Cache Block Prefetch Operations\n+  \/\/\n+  \/\/ Bit-manipulation\n+  \/\/ Zba Address generation instructions\n+  \/\/ Zbb Basic bit-manipulation\n+  \/\/ Zbc Carry-less multiplication\n+  \/\/ Zbs Single-bit instructions\n+  \/\/\n+  \/\/ Zicsr Control and Status Register (CSR) Instructions\n+  \/\/ Zifencei Instruction-Fetch Fence\n+  \/\/ Zic64b Cache blocks must be 64 bytes in size, naturally aligned in the address space.\n+  \/\/ Zihintpause Pause instruction HINT\n+  \/\/\n+  \/\/ Other features and settings\n+  \/\/ mvendorid Manufactory JEDEC id encoded, ISA vol 2 3.1.2..\n+  \/\/ marchid   Id for microarch. Mvendorid plus marchid uniquely identify the microarch.\n+  \/\/ mimpid    A unique encoding of the version of the processor implementation.\n+  \/\/ unaligned_access Unaligned memory accesses (unknown, unspported, emulated, slow, firmware, fast)\n+  \/\/ satp mode SATP bits (number of virtual addr bits) mbare, sv39, sv48, sv57, sv64\n+\n+  #define RV_NO_FLAG_BIT (BitsPerWord+1) \/\/ nth_bit will return 0 on values larger than BitsPerWord\n+\n+  \/\/ declaration name  , extension name,    bit pos ,in str, mapped flag)\n+  #define RV_FEATURE_FLAGS(decl)                                                                \\\n+  decl(ext_I           , \"i\"           ,    ('I' - 'A'), true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_M           , \"m\"           ,    ('M' - 'A'), true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_A           , \"a\"           ,    ('A' - 'A'), true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_F           , \"f\"           ,    ('F' - 'A'), true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_D           , \"d\"           ,    ('D' - 'A'), true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_C           , \"c\"           ,    ('C' - 'A'), true , UPDATE_DEFAULT(UseRVC))         \\\n+  decl(ext_Q           , \"q\"           ,    ('Q' - 'A'), true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_H           , \"h\"           ,    ('H' - 'A'), true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_V           , \"v\"           ,    ('V' - 'A'), true , UPDATE_DEFAULT(UseRVV))         \\\n+  decl(ext_Zicbom      , \"Zicbom\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicbom))      \\\n+  decl(ext_Zicboz      , \"Zicboz\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicboz))      \\\n+  decl(ext_Zicbop      , \"Zicbop\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicbop))      \\\n+  decl(ext_Zba         , \"Zba\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZba))         \\\n+  decl(ext_Zbb         , \"Zbb\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbb))         \\\n+  decl(ext_Zbc         , \"Zbc\"         , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_Zbs         , \"Zbs\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbs))         \\\n+  decl(ext_Zicsr       , \"Zicsr\"       , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_Zifencei    , \"Zifencei\"    , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)              \\\n+  decl(ext_Zic64b      , \"Zic64b\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZic64b))      \\\n+  decl(ext_Zihintpause , \"Zihintpause\" , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZihintpause)) \\\n+  decl(mvendorid       , \"VendorId\"    , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)              \\\n+  decl(marchid         , \"ArchId\"      , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)              \\\n+  decl(mimpid          , \"ImpId\"       , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)              \\\n+  decl(unaligned_access, \"Unaligned\"   , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)              \\\n+  decl(satp_mode       , \"SATP\"        , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)              \\\n+\n+  #define DECLARE_RV_FEATURE(NAME, PRETTY, BIT, FSTRING, FLAGF)        \\\n+  struct NAME##RVFeatureValue : public RVFeatureValue {                \\\n+    NAME##RVFeatureValue(const char* pretty, int bit, bool fstring) :  \\\n+      RVFeatureValue(pretty, bit, fstring) {}                          \\\n+    FLAGF;                                                             \\\n+  };                                                                   \\\n+  static NAME##RVFeatureValue NAME;                                    \\\n+\n+  RV_FEATURE_FLAGS(DECLARE_RV_FEATURE)\n+  #undef DECLARE_RV_FEATURE\n+\n+  \/\/ VM modes (satp.mode) privileged ISA 1.10\n+  enum VM_MODE : int {\n+    VM_NOTSET = -1,\n+    VM_MBARE  = 0,\n+    VM_SV39   = 39,\n+    VM_SV48   = 48,\n+    VM_SV57   = 57,\n+    VM_SV64   = 64\n+  };\n+\n+  static VM_MODE parse_satp_mode(const char* vm_mode);\n+\n+  \/\/ Values from riscv_hwprobe()\n+  enum UNALIGNED_ACCESS : int {\n+    MISALIGNED_UNKNOWN     = 0,\n+    MISALIGNED_EMULATED    = 1,\n+    MISALIGNED_SLOW        = 2,\n+    MISALIGNED_FAST        = 3,\n+    MISALIGNED_UNSUPPORTED = 4\n+  };\n@@ -50,3 +176,14 @@\n-protected:\n-  static const char* _uarch;\n-  static const char* _vm_mode;\n+  \/\/ Null terminated list\n+  static RVFeatureValue* _feature_list[];\n+\n+  \/\/ Enables features in _feature_list\n+  static void setup_cpu_available_features();\n+  \/\/ Helper for specific queries\n+  static void os_aux_features();\n+  static char* os_uarch_additional_features();\n+  static void vendor_features();\n+  \/\/ Vendors specific features\n+  static void rivos_features();\n+\n+  \/\/ Determine vector length iff ext_V\/UseRVV\n+  static uint32_t cpu_vector_length();\n@@ -54,3 +191,0 @@\n-  static void get_os_cpu_info();\n-  static uint32_t get_current_vector_length();\n-  static VM_MODE get_satp_mode();\n@@ -58,1 +192,5 @@\n-public:\n+#ifdef COMPILER2\n+  static void c2_initialize();\n+#endif \/\/ COMPILER2\n+\n+ public:\n@@ -61,0 +199,1 @@\n+  static void initialize_cpu_information();\n@@ -65,17 +204,0 @@\n-\n-  enum Feature_Flag {\n-#define CPU_FEATURE_FLAGS(decl)               \\\n-    decl(I,            \"i\",            8)     \\\n-    decl(M,            \"m\",           12)     \\\n-    decl(A,            \"a\",            0)     \\\n-    decl(F,            \"f\",            5)     \\\n-    decl(D,            \"d\",            3)     \\\n-    decl(C,            \"c\",            2)     \\\n-    decl(V,            \"v\",           21)\n-\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1 << bit),\n-    CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_FLAG)\n-#undef DECLARE_CPU_FEATURE_FLAG\n-  };\n-\n-  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":158,"deletions":36,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"riscv_hwprobe.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+#include <sched.h>\n+#include <sys\/syscall.h>\n+#include <unistd.h>\n+\n+\/\/ Syscall defined in kernel 6.4 and the defines will be in asm\/hwprobe.h\n+#define RISCV_HWPROBE_KEY_MVENDORID     0\n+#define RISCV_HWPROBE_KEY_MARCHID       1\n+#define RISCV_HWPROBE_KEY_MIMPID        2\n+\n+#define RISCV_HWPROBE_KEY_BASE_BEHAVIOR 3\n+#define   RISCV_HWPROBE_BASE_BEHAVIOR_IMA       (1 << 0)\n+\n+#define RISCV_HWPROBE_KEY_IMA_EXT_0     4\n+#define   RISCV_HWPROBE_IMA_FD                  (1 << 0)\n+#define   RISCV_HWPROBE_IMA_C                   (1 << 1)\n+\n+#define RISCV_HWPROBE_KEY_CPUPERF_0     5\n+#define   RISCV_HWPROBE_MISALIGNED_UNKNOWN      (0 << 0)\n+#define   RISCV_HWPROBE_MISALIGNED_EMULATED     (1 << 0)\n+#define   RISCV_HWPROBE_MISALIGNED_SLOW         (2 << 0)\n+#define   RISCV_HWPROBE_MISALIGNED_FAST         (3 << 0)\n+#define   RISCV_HWPROBE_MISALIGNED_UNSUPPORTED  (4 << 0)\n+#define   RISCV_HWPROBE_MISALIGNED_MASK         (7 << 0)\n+\n+#ifndef NR_riscv_hwprobe\n+#ifndef NR_arch_specific_syscall\n+#define NR_arch_specific_syscall 244\n+#endif\n+#define NR_riscv_hwprobe (NR_arch_specific_syscall + 14)\n+#endif\n+\n+struct riscv_hwprobe {\n+    int64_t key;\n+    uint64_t value;\n+};\n+\n+long sys_riscv_hwprobe(struct riscv_hwprobe *pairs, size_t pairc,\n+                       size_t cpuc, cpu_set_t *cpus,\n+                       unsigned int flags) {\n+  return syscall(NR_riscv_hwprobe, pairs, pairc, cpuc, cpus, 0 \/* flags*\/);\n+}\n+\n+static bool rw_hwprobe_completed = false;\n+\n+static struct riscv_hwprobe query[] = {{RISCV_HWPROBE_KEY_MVENDORID, 0},\n+                                       {RISCV_HWPROBE_KEY_MARCHID,   0},\n+                                       {RISCV_HWPROBE_KEY_MIMPID,    0},\n+                                       {RISCV_HWPROBE_KEY_BASE_BEHAVIOR, 0},\n+                                       {RISCV_HWPROBE_KEY_IMA_EXT_0,     0},\n+                                       {RISCV_HWPROBE_KEY_CPUPERF_0,     0}};\n+\n+bool RiscvHwprobe::probe_features() {\n+  assert(!rw_hwprobe_completed, \"Called twice.\");\n+  int ret = sys_riscv_hwprobe(&query[0], sizeof(query) \/ sizeof(query[0]), 0, nullptr, 0);\n+  rw_hwprobe_completed = true;\n+  if (ret != 0) {\n+    log_debug(os, cpu)(\"riscv_hwprobe unsupported\");\n+    return false;\n+  }\n+  log_debug(os, cpu)(\"riscv_hwprobe supported\");\n+  add_features_from_query_result();\n+  return true;\n+}\n+\n+static bool is_valid(int64_t key) {\n+  return query[key].key != -1;\n+}\n+\n+static bool is_set(int64_t key, uint64_t value_mask) {\n+  if (is_valid(key)) {\n+    return query[key].value & value_mask != 0;\n+  }\n+  return false;\n+}\n+\n+void RiscvHwprobe::add_features_from_query_result() {\n+  assert(rw_hwprobe_completed, \"hwprobe not init yet.\");\n+\n+  if (is_valid(RISCV_HWPROBE_KEY_MVENDORID)) {\n+    VM_Version::mvendorid.enable_feature(query[RISCV_HWPROBE_KEY_MVENDORID].value);\n+  }\n+  if (is_valid(RISCV_HWPROBE_KEY_MARCHID)) {\n+    VM_Version::marchid.enable_feature(query[RISCV_HWPROBE_KEY_MARCHID].value);\n+  }\n+  if (is_valid(RISCV_HWPROBE_KEY_MIMPID)) {\n+    VM_Version::mimpid.enable_feature(query[RISCV_HWPROBE_KEY_MIMPID].value);\n+  }\n+  if (is_set(RISCV_HWPROBE_KEY_BASE_BEHAVIOR, RISCV_HWPROBE_BASE_BEHAVIOR_IMA)) {\n+    VM_Version::ext_I.enable_feature();\n+    VM_Version::ext_M.enable_feature();\n+    VM_Version::ext_A.enable_feature();\n+  }\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_IMA_FD)) {\n+    VM_Version::ext_F.enable_feature();\n+    VM_Version::ext_D.enable_feature();\n+  }\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_IMA_C)) {\n+    VM_Version::ext_C.enable_feature();\n+  }\n+  if (is_valid(RISCV_HWPROBE_KEY_CPUPERF_0)) {\n+    VM_Version::unaligned_access.enable_feature(\n+       query[RISCV_HWPROBE_KEY_CPUPERF_0].value & RISCV_HWPROBE_MISALIGNED_MASK);\n+  }\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_RISCV_HWPROBE_LINUX_HPP\n+#define OS_LINUX_RISCV_HWPROBE_LINUX_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class RiscvHwprobe: public AllStatic {\n+  static void add_features_from_query_result();\n+ public:\n+  static bool probe_features();\n+};\n+\n+#endif \/\/ OS_LINUX_RISCV_HWPROBE_LINUX_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2023, Rivos Inc. All rights reserved.\n@@ -28,0 +29,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"riscv_hwprobe.hpp\"\n@@ -33,0 +36,1 @@\n+#include <ctype.h>\n@@ -36,1 +40,1 @@\n-#define HWCAP_ISA_I  (1 << ('I' - 'A'))\n+#define HWCAP_ISA_I  nth_bit('I' - 'A')\n@@ -40,1 +44,1 @@\n-#define HWCAP_ISA_M  (1 << ('M' - 'A'))\n+#define HWCAP_ISA_M  nth_bit('M' - 'A')\n@@ -44,1 +48,1 @@\n-#define HWCAP_ISA_A  (1 << ('A' - 'A'))\n+#define HWCAP_ISA_A  nth_bit('A' - 'A')\n@@ -48,1 +52,1 @@\n-#define HWCAP_ISA_F  (1 << ('F' - 'A'))\n+#define HWCAP_ISA_F  nth_bit('F' - 'A')\n@@ -52,1 +56,1 @@\n-#define HWCAP_ISA_D  (1 << ('D' - 'A'))\n+#define HWCAP_ISA_D  nth_bit('D' - 'A')\n@@ -56,1 +60,9 @@\n-#define HWCAP_ISA_C  (1 << ('C' - 'A'))\n+#define HWCAP_ISA_C  nth_bit('C' - 'A')\n+#endif\n+\n+#ifndef HWCAP_ISA_Q\n+#define HWCAP_ISA_Q  nth_bit('Q' - 'A')\n+#endif\n+\n+#ifndef HWCAP_ISA_H\n+#define HWCAP_ISA_H  nth_bit('H' - 'A')\n@@ -60,1 +72,1 @@\n-#define HWCAP_ISA_V  (1 << ('V' - 'A'))\n+#define HWCAP_ISA_V  nth_bit('V' - 'A')\n@@ -73,2 +85,2 @@\n-uint32_t VM_Version::get_current_vector_length() {\n-  assert(_features & CPU_V, \"should not call this\");\n+uint32_t VM_Version::cpu_vector_length() {\n+  assert(ext_V.enabled(), \"should not call this\");\n@@ -78,2 +90,73 @@\n-VM_Version::VM_MODE VM_Version::get_satp_mode() {\n-  if (!strcmp(_vm_mode, \"sv39\")) {\n+void VM_Version::setup_cpu_available_features() {\n+\n+  assert(ext_I.feature_bit() == HWCAP_ISA_I, \"Bit for I must follow Linux HWCAP\");\n+  assert(ext_M.feature_bit() == HWCAP_ISA_M, \"Bit for M must follow Linux HWCAP\");\n+  assert(ext_A.feature_bit() == HWCAP_ISA_A, \"Bit for A must follow Linux HWCAP\");\n+  assert(ext_F.feature_bit() == HWCAP_ISA_F, \"Bit for F must follow Linux HWCAP\");\n+  assert(ext_D.feature_bit() == HWCAP_ISA_D, \"Bit for D must follow Linux HWCAP\");\n+  assert(ext_C.feature_bit() == HWCAP_ISA_C, \"Bit for C must follow Linux HWCAP\");\n+  assert(ext_Q.feature_bit() == HWCAP_ISA_Q, \"Bit for Q must follow Linux HWCAP\");\n+  assert(ext_H.feature_bit() == HWCAP_ISA_H, \"Bit for H must follow Linux HWCAP\");\n+  assert(ext_V.feature_bit() == HWCAP_ISA_V, \"Bit for V must follow Linux HWCAP\");\n+\n+  if (!RiscvHwprobe::probe_features()) {\n+    os_aux_features();\n+  }\n+  char* uarch = os_uarch_additional_features();\n+  vendor_features();\n+\n+  char buf[1024] = {};\n+  if (uarch != nullptr && strcmp(uarch, \"\") != 0) {\n+    \/\/ Use at max half the buffer.\n+    snprintf(buf, sizeof(buf)\/2, \"%s,\", uarch);\n+  }\n+  os::free((void*) uarch);\n+  strcat(buf, \"rv64\");\n+  int i = 0;\n+  while (_feature_list[i] != nullptr) {\n+    if (_feature_list[i]->enabled()) {\n+      log_debug(os, cpu)(\"Enabled RV64 feature \\\"%s\\\" (%ld)\",\n+             _feature_list[i]->pretty(),\n+             _feature_list[i]->value());\n+      \/\/ The feature string\n+      if (_feature_list[i]->feature_string()) {\n+        const char* tmp = _feature_list[i]->pretty();\n+        if (strlen(tmp) == 1) {\n+          strcat(buf, tmp);\n+        } else {\n+          \/\/ Feature string is expected to be lower case.\n+          \/\/ Turn Zxxx into zxxx\n+          char prebuf[3] = {};\n+          assert(strlen(tmp) > 1, \"Must be\");\n+          prebuf[0] = '_';\n+          prebuf[1] = (char)tolower(tmp[0]);\n+          strcat(buf, prebuf);\n+          strcat(buf, &tmp[1]);\n+        }\n+      }\n+      \/\/ Feature bit\n+      if (_feature_list[i]->feature_bit() != 0) {\n+        _features |= _feature_list[i]->feature_bit();\n+      }\n+      \/\/ Change flag default\n+      _feature_list[i]->update_flag();\n+    }\n+    i++;\n+  }\n+\n+  _features_string = os::strdup(buf);\n+}\n+\n+void VM_Version::os_aux_features() {\n+  uint64_t auxv = getauxval(AT_HWCAP);\n+  int i = 0;\n+  while (_feature_list[i] != nullptr) {\n+    if ((_feature_list[i]->feature_bit() & auxv) != 0) {\n+      _feature_list[i]->enable_feature();\n+    }\n+    i++;\n+  }\n+}\n+\n+VM_Version::VM_MODE VM_Version::parse_satp_mode(const char* vm_mode) {\n+  if (!strcmp(vm_mode, \"sv39\")) {\n@@ -81,1 +164,1 @@\n-  } else if (!strcmp(_vm_mode, \"sv48\")) {\n+  } else if (!strcmp(vm_mode, \"sv48\")) {\n@@ -83,1 +166,1 @@\n-  } else if (!strcmp(_vm_mode, \"sv57\")) {\n+  } else if (!strcmp(vm_mode, \"sv57\")) {\n@@ -85,1 +168,1 @@\n-  } else if (!strcmp(_vm_mode, \"sv64\")) {\n+  } else if (!strcmp(vm_mode, \"sv64\")) {\n@@ -92,1 +175,3 @@\n-void VM_Version::get_os_cpu_info() {\n+char* VM_Version::os_uarch_additional_features() {\n+  char* ret = nullptr;\n+  VM_MODE mode = VM_NOTSET;\n@@ -94,1 +179,4 @@\n-  uint64_t auxv = getauxval(AT_HWCAP);\n+  FILE *f = fopen(\"\/proc\/cpuinfo\", \"r\");\n+  if (f == nullptr) {\n+    return nullptr;\n+  }\n@@ -96,24 +184,5 @@\n-  static_assert(CPU_I == HWCAP_ISA_I, \"Flag CPU_I must follow Linux HWCAP\");\n-  static_assert(CPU_M == HWCAP_ISA_M, \"Flag CPU_M must follow Linux HWCAP\");\n-  static_assert(CPU_A == HWCAP_ISA_A, \"Flag CPU_A must follow Linux HWCAP\");\n-  static_assert(CPU_F == HWCAP_ISA_F, \"Flag CPU_F must follow Linux HWCAP\");\n-  static_assert(CPU_D == HWCAP_ISA_D, \"Flag CPU_D must follow Linux HWCAP\");\n-  static_assert(CPU_C == HWCAP_ISA_C, \"Flag CPU_C must follow Linux HWCAP\");\n-  static_assert(CPU_V == HWCAP_ISA_V, \"Flag CPU_V must follow Linux HWCAP\");\n-\n-  \/\/ RISC-V has four bit-manipulation ISA-extensions: Zba\/Zbb\/Zbc\/Zbs.\n-  \/\/ Availability for those extensions could not be queried from HWCAP.\n-  \/\/ TODO: Add proper detection for those extensions.\n-  _features = auxv & (\n-      HWCAP_ISA_I |\n-      HWCAP_ISA_M |\n-      HWCAP_ISA_A |\n-      HWCAP_ISA_F |\n-      HWCAP_ISA_D |\n-      HWCAP_ISA_C |\n-      HWCAP_ISA_V);\n-\n-  if (FILE *f = fopen(\"\/proc\/cpuinfo\", \"r\")) {\n-    char buf[512], *p;\n-    while (fgets(buf, sizeof (buf), f) != nullptr) {\n-      if ((p = strchr(buf, ':')) != nullptr) {\n+  char buf[512], *p;\n+  while (fgets(buf, sizeof (buf), f) != nullptr &&\n+         (mode == VM_NOTSET || ret == nullptr)) {\n+    if ((p = strchr(buf, ':')) != nullptr) {\n+      if (mode == VM_NOTSET) {\n@@ -121,11 +190,7 @@\n-          if (_vm_mode[0] != '\\0') {\n-            continue;\n-          }\n-          char* vm_mode = os::strdup(p + 2);\n-          vm_mode[strcspn(vm_mode, \"\\n\")] = '\\0';\n-          _vm_mode = vm_mode;\n-        } else if (strncmp(buf, \"uarch\", sizeof \"uarch\" - 1) == 0) {\n-          char* uarch = os::strdup(p + 2);\n-          uarch[strcspn(uarch, \"\\n\")] = '\\0';\n-          _uarch = uarch;\n-          break;\n+          mode = VM_Version::parse_satp_mode(p);\n+        }\n+      }\n+      if (ret == nullptr) {\n+        if (strncmp(buf, \"uarch\", sizeof \"uarch\" - 1) == 0) {\n+          ret = os::strdup(p + 2);\n+          ret[strcspn(ret, \"\\n\")] = '\\0';\n@@ -135,1 +200,0 @@\n-    fclose(f);\n@@ -137,0 +201,53 @@\n+  if (mode == VM_NOTSET) {\n+    mode = VM_MBARE;\n+  }\n+  fclose(f);\n+  satp_mode.enable_feature(mode);\n+  return ret;\n+}\n+\n+void VM_Version::vendor_features() {\n+  \/\/ JEDEC encoded as ((bank - 1) << 7) | (0x7f & JEDEC)\n+  static constexpr int RIVOS_MVENDORID = 0x6cf; \/\/ JEDEC: 0x4f, Bank: 14\n+\n+  if (!mvendorid.enabled()) {\n+    return;\n+  }\n+  switch (mvendorid.value()) {\n+    case RIVOS_MVENDORID:\n+    rivos_features();\n+    break;\n+    default:\n+    break;\n+  }\n+}\n+\n+void VM_Version::rivos_features() {\n+  \/\/ Enable common features not dependent on marchid\/mimpid.\n+  ext_I.enable_feature();\n+  ext_M.enable_feature();\n+  ext_A.enable_feature();\n+  ext_F.enable_feature();\n+  ext_D.enable_feature();\n+  ext_C.enable_feature();\n+  ext_H.enable_feature();\n+  ext_V.enable_feature();\n+\n+  ext_Zicbom.enable_feature();\n+  ext_Zicboz.enable_feature();\n+  ext_Zicbop.enable_feature();\n+\n+  ext_Zba.enable_feature();\n+  ext_Zbb.enable_feature();\n+  ext_Zbs.enable_feature();\n+\n+  ext_Zicsr.enable_feature();\n+  ext_Zifencei.enable_feature();\n+  ext_Zic64b.enable_feature();\n+  ext_Zihintpause.enable_feature();\n+\n+  unaligned_access.enable_feature(MISALIGNED_FAST);\n+  satp_mode.enable_feature(VM_SV48);\n+\n+  \/\/ Features dependent on march\/mimpid.\n+  \/\/ I.e. march.value() and mimplid.value()\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":169,"deletions":52,"binary":false,"changes":221,"status":"modified"}]}