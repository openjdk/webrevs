{"files":[{"patch":"@@ -4227,1 +4227,2 @@\n-            break; \/\/ Chain traversal fails.\n+            \/\/ Should not be allowed by SuperWord::mark_reductions\n+            return; \/\/ bail out of optimization\n@@ -4248,2 +4249,3 @@\n-        DEBUG_ONLY( current->dump(1); )\n-        assert(false, \"scalar_input is neither phi nor a matchin reduction\");\n+        \/\/ scalar_input is neither phi nor a matching reduction\n+        \/\/ Can for example be scalar reduction when we have\n+        \/\/ partial vectorization.\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    @Run(test = {\"test1\", \"test2\"})\n+    @Run(test = {\"test1\", \"test2\", \"test3\"})\n@@ -67,0 +67,8 @@\n+\n+        for (int i = 0; i < ITER; i++) {\n+            int r1 = test3(data, i);\n+            int r2 = ref3(data, i);\n+            if (r1 != r2) {\n+                throw new RuntimeException(\"Wrong result test3: \" + r1 + \" != \" + r2);\n+            }\n+        }\n@@ -143,0 +151,34 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\",\n+                  IRNode.MUL_VI, \"> 0\",\n+                  IRNode.ADD_VI, \"= 0\", \/\/ reduction not moved out of loop\n+                  IRNode.ADD_REDUCTION_VI, \"> 0\",},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static int test3(int[] data, int sum) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            \/\/ Partial vectorization of reduction chain -> cannot move out of loop\n+            sum += 11 * data[i+0]; \/\/ vec 1\n+            sum += 13 & data[i+1]; \/\/ ---------- breaks vec 1 -> scalar reductions\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            sum += 11 * data[i+4]; \/\/ vec 2 -> vectorizes -> vector reduction\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum;\n+    }\n+\n+    static int ref3(int[] data, int sum) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            sum += 11 * data[i+0];\n+            sum += 13 & data[i+1];\n+            sum += 11 * data[i+2];\n+            sum += 11 * data[i+3];\n+            sum += 11 * data[i+4];\n+            sum += 11 * data[i+5];\n+            sum += 11 * data[i+6];\n+            sum += 11 * data[i+7];\n+        }\n+        return sum;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReduction.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug JDK-8310130\n+ * @summary Special test cases for PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+ *          Here a case with partial vectorization of the reduction.\n+ * @requires vm.bits == \"64\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestUnorderedReductionPartialVectorization\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+\n+public class TestUnorderedReductionPartialVectorization {\n+    static final int RANGE = 1024;\n+    static final int ITER  = 10;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\"})\n+    @Warmup(0)\n+    public void runTests() throws Exception {\n+        int[] data = new int[RANGE];\n+\n+        init(data);\n+        for (int i = 0; i < ITER; i++) {\n+            long r1 = test1(data, i);\n+            long r2 = ref1(data, i);\n+            if (r1 != r2) {\n+                throw new RuntimeException(\"Wrong result test1: \" + r1 + \" != \" + r2);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \"> 0\",\n+                  IRNode.OR_REDUCTION_V, \"> 0\",},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\"})\n+    static long test1(int[] data, long sum) {\n+        for (int i = 0; i < data.length; i++) {\n+            \/\/ Mixing int and long ops means we only end up allowing half of the int\n+            \/\/ loads in one pack, and we have two int packs. The first pack has one\n+            \/\/ of the pairs missing because of the store, which creates a dependency.\n+            \/\/ The first pack is rejected and left as scalar, the second pack succeeds\n+            \/\/ with vectorization. That means we have a mixed scalar\/vector reduction\n+            \/\/ chain. This way it is possible that a vector-reduction has a scalar\n+            \/\/ reduction as input, which is neigher a phi nor a vector reduction.\n+            \/\/ In such a case, we must bail out of the optimization in\n+            \/\/ PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+            int v = data[i]; \/\/ int read\n+            data[0] = 0;     \/\/ ruin the first pack\n+            sum |= v;        \/\/ long reduction\n+        }\n+        return sum;\n+    }\n+\n+    static long ref1(int[] data, long sum) {\n+        for (int i = 0; i < data.length; i++) {\n+            int v = data[i];\n+            data[0] = 0;\n+            sum |= v;\n+        }\n+        return sum;\n+    }\n+\n+    static void init(int[] data) {\n+        for (int i = 0; i < RANGE; i++) {\n+            data[i] = i + 1;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}