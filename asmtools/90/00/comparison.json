{"files":[{"patch":"@@ -30,1 +30,1 @@\n-PRODUCT_BUILDNUMBER =12\n+PRODUCT_BUILDNUMBER =14\n","filename":"build\/productinfo.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,6 +30,16 @@\n-    UNKNOWN,\n-    ClassFile,\n-    field_info,\n-    method_info,\n-    record_component_info,\n-    Code\n+    unknown(\"Unknown\"),\n+    class_file(\"ClassFile\"),\n+    field_info(\"field_info\"),\n+    method_info(\"method_info\"),\n+    record_component_info(\"record_component_info\"),\n+    code_atribute(\"Code\");\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    private final String description;\n+\n+    ELocation(String description) {\n+        this.description = description;\n+    }\n","filename":"src\/org\/openjdk\/asmtools\/common\/structure\/ELocation.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        this.attributeLocation = ELocation.ClassFile;\n+        this.attributeLocation = ELocation.class_file;\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ClassData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -489,2 +489,2 @@\n-        return 2 + 2 + 4 \/\/ for max_stack, max_locals, and cur_pc\n-                + curPC \/\/      + 2+trap_table.size()*8\n+        return 2 + 2 + 4    \/\/ for max_stack, max_locals, and cur_pc\n+                + curPC     \/\/      + 2+trap_table.size()*8\n@@ -510,0 +510,9 @@\n+    \/**\n+     * Checks if the code attribute is empty, i.e., it contains no instructions.\n+     *\n+     * @return true if the code attribute is empty, false otherwise\n+     *\/\n+    public boolean isEmpty() {\n+        return curPC == 0;\n+    }\n+\n@@ -520,3 +529,0 @@\n-    \/**\n-     *\n-     *\/\n@@ -529,3 +535,0 @@\n-    \/**\n-     *\n-     *\/\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/CodeAttr.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,4 +25,1 @@\n-import java.util.Arrays;\n-import java.util.EnumSet;\n-import java.util.Optional;\n-import java.util.Set;\n+import java.util.*;\n@@ -82,1 +79,1 @@\n-        CLASS_NAME(\"Class Name\");              \/\/ The token can be used as Class Name\n+        CLASS_NAME(\"Class Name\");               \/\/ The token can be used as Class Name\n@@ -539,0 +536,11 @@\n+\n+    public static String asString(List<Token> tokens) {\n+        StringBuilder sb = new StringBuilder(\"\");\n+        for (Token token : tokens) {\n+            if(sb .length() > 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append('\\'').append(token.parseKey()).append('\\'');\n+        }\n+        return sb.toString();\n+    }\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/JasmTokens.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    protected ELocation attributeLocation = ELocation.UNKNOWN;\n+    protected ELocation attributeLocation = ELocation.unknown;\n@@ -115,0 +115,7 @@\n+        if (this.signatureAttr != null) {\n+            CPXAttr cpx = (CPXAttr) signatureAttr;\n+            if (value_cpx.cpIndex != cpx.cell.cpIndex) {\n+                environment.warning(\"warn.redeclared.attribute\", SIGNATURE.parseKey(),\n+                        this.attributeLocation.getDescription());\n+            }\n+        }\n@@ -123,1 +130,1 @@\n-                        SIGNATURE.parseKey(), ELocation.ClassFile.toString());\n+                        SIGNATURE.parseKey(), this.attributeLocation.getDescription());\n@@ -129,0 +136,9 @@\n+    \/**\n+     * Retrieves the signature attribute associated with this member.\n+     *\n+     * @return the signature attribute, or null if it has not been set\n+     *\/\n+    public AttrData getSignatureAttr() {\n+        return signatureAttr;\n+    }\n+\n@@ -156,25 +172,19 @@\n-    public void addAnnotations(ArrayList<AnnotationData> list) {\n-        for (AnnotationData item : list) {\n-            boolean invisible = item.invisible;\n-\n-            if (item instanceof TypeAnnotationData typeAnnotationData) {\n-                \/\/ Type Annotations\n-                if (invisible) {\n-                    if (type_annotAttrInv == null) {\n-                        type_annotAttrInv = new DataVectorAttr<>(pool,\n-                                EAttribute.ATT_RuntimeInvisibleTypeAnnotations);\n-                    }\n-                    type_annotAttrInv.add(typeAnnotationData);\n-                } else {\n-                    if (type_annotAttrVis == null) {\n-                        type_annotAttrVis = new DataVectorAttr<>(pool,\n-                                EAttribute.ATT_RuntimeVisibleTypeAnnotations);\n-                    }\n-                    type_annotAttrVis.add(typeAnnotationData);\n-                }\n-            } else {\n-                \/\/ Regular Annotations\n-                if (invisible) {\n-                    if (annotAttrInv == null) {\n-                        annotAttrInv = new DataVectorAttr<>(pool,\n-                                EAttribute.ATT_RuntimeInvisibleAnnotations);\n+    public MemberData<T> addAnnotations(ArrayList<AnnotationData> list) {\n+        if( list != null ) {\n+            for (AnnotationData item : list) {\n+                boolean invisible = item.invisible;\n+\n+                if (item instanceof TypeAnnotationData typeAnnotationData) {\n+                    \/\/ Type Annotations\n+                    if (invisible) {\n+                        if (type_annotAttrInv == null) {\n+                            type_annotAttrInv = new DataVectorAttr<>(pool,\n+                                    EAttribute.ATT_RuntimeInvisibleTypeAnnotations);\n+                        }\n+                        type_annotAttrInv.add(typeAnnotationData);\n+                    } else {\n+                        if (type_annotAttrVis == null) {\n+                            type_annotAttrVis = new DataVectorAttr<>(pool,\n+                                    EAttribute.ATT_RuntimeVisibleTypeAnnotations);\n+                        }\n+                        type_annotAttrVis.add(typeAnnotationData);\n@@ -182,1 +192,0 @@\n-                    annotAttrInv.add(item);\n@@ -184,3 +193,13 @@\n-                    if (annotAttrVis == null) {\n-                        annotAttrVis = new DataVectorAttr<>(pool,\n-                                EAttribute.ATT_RuntimeVisibleAnnotations);\n+                    \/\/ Regular Annotations\n+                    if (invisible) {\n+                        if (annotAttrInv == null) {\n+                            annotAttrInv = new DataVectorAttr<>(pool,\n+                                    EAttribute.ATT_RuntimeInvisibleAnnotations);\n+                        }\n+                        annotAttrInv.add(item);\n+                    } else {\n+                        if (annotAttrVis == null) {\n+                            annotAttrVis = new DataVectorAttr<>(pool,\n+                                    EAttribute.ATT_RuntimeVisibleAnnotations);\n+                        }\n+                        annotAttrVis.add(item);\n@@ -188,1 +207,0 @@\n-                    annotAttrVis.add(item);\n@@ -192,0 +210,1 @@\n+        return this;\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/MemberData.java","additions":52,"deletions":33,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,0 +145,1 @@\n+        this.addExceptions(exc_table);\n@@ -147,3 +148,0 @@\n-        if ((exc_table != null) && (!exc_table.isEmpty())) {\n-            exceptions = new DataVectorAttr<>(classData.pool, EAttribute.ATT_Exceptions, exc_table);\n-        }\n@@ -156,0 +154,29 @@\n+    public void addExceptions(ArrayList<ConstCell<?>> exc_table) {\n+        if ((exc_table != null) && (!exc_table.isEmpty())) {\n+            if (exceptions == null) {\n+                exceptions = new DataVectorAttr<>(classData.pool, EAttribute.ATT_Exceptions, exc_table);\n+            } else {\n+                exceptions.addAll(exc_table);\n+            }\n+        }\n+    }\n+\n+    public DataVectorAttr<ConstCell<?>> getExceptions() {\n+        return exceptions;\n+    }\n+\n+    public boolean hasExceptions() {\n+        return (exceptions != null) && (!exceptions.isEmpty());\n+    }\n+\n+    \/**\n+     * Retrieves the default annotation attribute associated with this method.\n+     * The default annotation is used to store the default value of an annotation\n+     * method.\n+     *\n+     * @return the default annotation attribute, or null if it has not been set\n+     *\/\n+    public DefaultAnnotationAttr getDefaultAnnotation() {\n+        return defaultAnnot;\n+    }\n+\n@@ -173,1 +200,1 @@\n-    public void addDefaultAnnotation(DefaultAnnotationAttr data) {\n+    public void setDefaultAnnotation(DefaultAnnotationAttr data) {\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/MethodData.java","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,1 +205,2 @@\n-        boolean invisible = isInvisibleAnnotationToken(scanner.stringValue);\n+        TypeAnnotationData ta;\n+        boolean isInvisible = isInvisibleAnnotationToken(scanner.stringValue);\n@@ -207,5 +208,9 @@\n-        scanner.debugScan(\"     [ParserAnnotation.parseTypeAnnotation]: id = \" + scanner.stringValue + \" \");\n-        String annoName = \"L\" + scanner.stringValue + \";\";\n-        TypeAnnotationData anno = new TypeAnnotationData(parser.pool.findUTF8Cell(annoName), invisible);\n-        scanner.scan();\n-        scanner.debugScan(\"     [ParserAnnotation.parseTypeAnnotation]:new Type annotation: \" + annoName + \" \");\n+        if (scanner.token == CPINDEX) {\n+            int cpIndex = scanner.intValue;\n+            scanner.debugScan(\"     [ParserAnnotation.parseTypeAnnotation]: cpIndex = #%d\".formatted(cpIndex));\n+            ta = new TypeAnnotationData(parser.pool.getCell(cpIndex), isInvisible);\n+        } else {\n+            String value = scanner.stringValue;\n+            scanner.debugScan(\"     [ParserAnnotation.parseTypeAnnotation]: value = %s\".formatted(value));\n+            ta = new TypeAnnotationData(parser.pool.findUTF8Cell(value), isInvisible);\n+        }\n@@ -213,0 +218,1 @@\n+        scanner.scan();\n@@ -216,1 +222,1 @@\n-        _scanAnnotation(anno);\n+        _scanAnnotation(ta);\n@@ -219,1 +225,1 @@\n-        _scanTypeTarget(anno);\n+        _scanTypeTarget(ta);\n@@ -223,1 +229,1 @@\n-            _scanTargetPath(anno);\n+            _scanTargetPath(ta);\n@@ -227,1 +233,1 @@\n-        return anno;\n+        return ta;\n@@ -237,0 +243,2 @@\n+        AnnotationData ad;\n+        boolean isInvisible = isInvisibleAnnotationToken(scanner.stringValue);\n@@ -238,1 +246,0 @@\n-        boolean invisible = isInvisibleAnnotationToken(scanner.stringValue);\n@@ -240,1 +247,0 @@\n-        String annoName = \"L\" + scanner.stringValue + \";\";\n@@ -242,4 +248,9 @@\n-        AnnotationData anno = new AnnotationData(parser.pool.findUTF8Cell(annoName), invisible);\n-        scanner.scan();\n-        scanner.debugScan(\"[ParserAnnotation.parseAnnotation]: new annotation: \" + annoName);\n-        _scanAnnotation(anno);\n+        if (scanner.token == CPINDEX) {\n+            int cpIndex = scanner.intValue;\n+            scanner.debugScan(\"     [ParserAnnotation.parseAnnotation]: cpIndex = #%d\".formatted(cpIndex));\n+            ad = new AnnotationData(parser.pool.getCell(cpIndex), isInvisible);\n+        } else {\n+            String value = scanner.stringValue;\n+            scanner.debugScan(\"     [ParserAnnotation.parseAnnotation]: value = %s\".formatted(value));\n+            ad = new AnnotationData(parser.pool.findUTF8Cell(value), isInvisible);\n+        }\n@@ -247,1 +258,3 @@\n-        return anno;\n+        scanner.scan();\n+        _scanAnnotation(ad);\n+        return ad;\n@@ -353,2 +366,0 @@\n-    \/* ************************* Private Members  *************************** *\/\n-\n@@ -441,1 +452,1 @@\n-            case IDENT:\n+            case IDENT, STRINGVAL:\n@@ -444,2 +455,1 @@\n-                String desc = parser.encodeClassString(scanner.stringValue);\n-\n+                String desc = scanner.stringValue;\n@@ -461,1 +471,0 @@\n-\n@@ -466,1 +475,1 @@\n-     * Scans an annotation enum val.\n+     * Scans an annotation enum value.\n@@ -468,1 +477,0 @@\n-     * @param name Annotation Name\n@@ -472,1 +480,1 @@\n-    private EnumElemValue scanAnnotationEnum(String name) throws SyntaxError {\n+    private EnumElemValue scanAnnotationEnum() throws SyntaxError {\n@@ -474,1 +482,1 @@\n-        EnumElemValue enumval = null;\n+        EnumElemValue enumval;\n@@ -476,1 +484,1 @@\n-            case IDENT:\n+            case IDENT, STRINGVAL:\n@@ -478,1 +486,2 @@\n-                String enumClassName = scanner.stringValue;\n+                String type = scanner.stringValue;\n+                ConstElemValue typeConst = new ConstElemValue(AE_STRING.tag(), parser.pool.findUTF8Cell(type));\n@@ -480,1 +489,1 @@\n-                \/\/ could be a string identifying enum class and name\n+                scanner.expect(Token.FIELD);\n@@ -482,8 +491,9 @@\n-                    case IDENT:\n-                        \/\/ could be a string identifying enum class and name\n-                        String enumTypeName = scanner.stringValue;\n-                        environment.traceln(\"[ParserAnnotation.scanAnnotationEnum]:: Constant Enum Field: \" + name + \" = \" + enumClassName + \" \" + enumTypeName);\n-                        String encodedClass = parser.encodeClassString(enumClassName);\n-                        ConstElemValue classConst = new ConstElemValue(AE_STRING.tag(), parser.pool.findUTF8Cell(encodedClass));\n-                        ConstElemValue typeConst = new ConstElemValue(AE_STRING.tag(), parser.pool.findUTF8Cell(enumTypeName));\n-                        enumval = new EnumElemValue(classConst.constCell, typeConst.constCell);\n+                    case IDENT, STRINGVAL:\n+                        String name = scanner.stringValue;\n+                        ConstElemValue nameConst = new ConstElemValue(AE_STRING.tag(), parser.pool.findUTF8Cell(name));\n+                        enumval = new EnumElemValue(typeConst.constCell, nameConst.constCell);\n+                        scanner.scan();\n+                        break;\n+                    case CPINDEX:\n+                        int nameCpx = scanner.intValue;\n+                        enumval = new EnumElemValue(typeConst.constCell, parser.pool.getCell(nameCpx));\n@@ -493,1 +503,1 @@\n-                        environment.error(scanner.pos, \"err.incorrect.annot.enum\", scanner.stringValue);\n+                        environment.error(scanner.pos, \"err.incorrect.annot.enum.name\", scanner.stringValue);\n@@ -498,1 +508,1 @@\n-                int typeNmCPX = Integer.parseInt(scanner.stringValue);\n+                int typeCpx = scanner.intValue;\n@@ -500,5 +510,6 @@\n-                \/\/need two indexes to form a proper enum\n-                if (scanner.token == CPINDEX) {\n-                    int ConstNmCPX = Integer.parseInt(scanner.stringValue);\n-                    environment.traceln(\"[ParserAnnotation.scanAnnotationEnum]:: Enumeration Field: \" + name + \" = #\" + typeNmCPX + \" #\" + ConstNmCPX);\n-                    enumval = new EnumElemValue(parser.pool.getCell(typeNmCPX), parser.pool.getCell(ConstNmCPX));\n+                if( scanner.token == Token.FIELD ) {\n+                    \/\/ skip \".\" if found\n+                    \/\/ the new format uses \".\" to separate type and name:\n+                    \/\/ @+#24 \/* java\/lang\/annotation\/Retention *\/ {\n+                    \/\/   #11 \/* value *\/ = enum #16.#17 \/* \"Ljava\/lang\/annotation\/RetentionPolicy;\".RUNTIME *\/\n+                    \/\/ }\n@@ -506,3 +517,18 @@\n-                } else {\n-                    environment.error(scanner.pos, \"err.incorrect.annot.enum.cpx\");\n-                    throw new SyntaxError();\n+                }\n+                \/\/need two indexes to form a proper enum\n+                switch (scanner.token) {\n+                    case CPINDEX:\n+                        int nameCpx = scanner.intValue;\n+                        enumval = new EnumElemValue(parser.pool.getCell(typeCpx), parser.pool.getCell(nameCpx));\n+                        scanner.scan();\n+                        break;\n+                    case IDENT, STRINGVAL:\n+                        \/\/ could be a string identifying enum class and name\n+                        String enumName = scanner.stringValue;\n+                        ConstElemValue nameConst = new ConstElemValue(AE_STRING.tag(), parser.pool.findUTF8Cell(enumName));\n+                        enumval = new EnumElemValue(parser.pool.getCell(typeCpx), nameConst.constCell);\n+                        scanner.scan();\n+                        break;\n+                    default:\n+                        environment.error(scanner.pos, \"err.incorrect.annot.enum.name\", scanner.stringValue);\n+                        throw new SyntaxError();\n@@ -511,0 +537,3 @@\n+            default:\n+                environment.error(scanner.pos, \"err.incorrect.annot.enum.type\", scanner.stringValue);\n+                throw new SyntaxError();\n@@ -571,1 +600,1 @@\n-                dataWriter = scanAnnotationEnum(name);\n+                dataWriter = scanAnnotationEnum();\n@@ -898,1 +927,6 @@\n-     * Element Value for Enums\n+     * Element Value for Enums:\n+     * type_name_index\n+     * The constant_pool entry at that index must be a CONSTANT_Utf8_info structure representing a field descriptor(4.3.2).\n+     *\n+     * const_name_index\n+     * The constant_pool entry gives the simple name of the enum constant represented by this element_value structure.\n@@ -903,1 +937,1 @@\n-        ConstCell value;\n+        ConstCell name;\n@@ -905,1 +939,1 @@\n-        EnumElemValue(ConstCell type, ConstCell value) {\n+        EnumElemValue(ConstCell type, ConstCell name) {\n@@ -907,1 +941,1 @@\n-            this.value = value;\n+            this.name = name;\n@@ -914,1 +948,1 @@\n-            value.write(out);\n+            name.write(out);\n@@ -925,1 +959,1 @@\n-            this.value = visitConstCell(this.value, pool);\n+            this.name = visitConstCell(this.name, pool);\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/ParseAnnotation.java","additions":90,"deletions":56,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -125,4 +125,0 @@\n-    String encodeClassString(String classname) {\n-        return \"L\" + classname + \";\";\n-    }\n-\n@@ -845,1 +841,0 @@\n-        DefaultAnnotationAttr defAnnot = null;\n@@ -860,2 +855,1 @@\n-        \/\/ Parse the optional attribute: signature\n-        ConstCell signatureCell = null;\n+        MethodData curMethod = (MethodData) classData.StartMethod(mod, nameCell, typeCell, null).addAnnotations(memberAnnotations);\n@@ -863,11 +857,8 @@\n-        if (scanner.token.in(COLON, SIGNATURE)) {\n-            \/\/ Signature expected\n-            if (scanner.token == COLON) {\n-                scanner.scan();\n-                if (scanner.token == SIGNATURE) {\n-                    scanner.scan();\n-                }\n-                signatureCell = parseName();\n-            } else if (scanner.token == SIGNATURE) {\n-                scanner.scan();\n-                signatureCell = parseName();\n+        \/\/ Parse the optional attribute(s): signature\n+        \/\/ :SIGNATURE or :#d\n+        if (scanner.token == COLON) {\n+            scanner.scan();\n+            if (!scanner.expectOneOfToken(CPINDEX, IDENT, STRINGVAL)) {\n+                environment.error(scanner.pos, \"err.name.expected\",\n+                        \"\\\"\" + scanner.token.parseKey() + \"\\\"\");\n+                throw new SyntaxError();\n@@ -875,2 +866,4 @@\n-            if (scanner.token == SEMICOLON) {\n-                scanner.scan();\n+            \/\/ Signature expected\n+            ConstCell signatureCell = parseName();\n+            if (signatureCell != null) {\n+                curMethod.setSignatureAttr(signatureCell);\n@@ -879,1 +872,7 @@\n-        ArrayList<ConstCell<?>> exceptionList = null;\n+        boolean nextAttributeExpected = false, endClassExpected = false;\n+        if (scanner.token == SEMICOLON) {\n+            \/\/ probably method header is closed\n+            \/\/ public varargs abstract Method #5:#6:#15;\n+            endClassExpected = true;\n+        }\n+        \/\/ Parse the optional attribute(s): signature, exceptions, default annotation\n@@ -883,2 +882,16 @@\n-                \/\/ Parse throws clause\n-                case THROWS -> exceptionList = parseThrowsClause();\n+                \/\/ Parse throws clause, it expected to be the last clause.\n+                case THROWS -> {\n+                    if (curMethod.hasExceptions()) {\n+                        environment.warning(scanner.pos, \"warn.method_info.attribute.repeated\",\n+                                ATT_Exceptions.parseKey());\n+                    }\n+                    nextAttributeExpected = false;\n+                    ArrayList<ConstCell<?>> exceptions = parseThrowsClause(curMethod.getExceptions());\n+                    curMethod.addExceptions(exceptions);\n+                    if( scanner.token == SEMICOLON ) {\n+                        parseNext = false;\n+                        scanner.scan();\n+                    } else if( scanner.expectOneOfToken(STACK, LOCAL, LBRACE) ) {\n+                        parseNext = false;\n+                    }\n+                }\n@@ -886,2 +899,58 @@\n-                case DEFAULT -> defAnnot = annotParser.parseDefaultAnnotation();\n-                default -> parseNext = false;\n+                case DEFAULT -> {\n+                    if (curMethod.getDefaultAnnotation() != null) {\n+                        environment.throwErrorException(scanner.pos, \"err.method_info.attribute.repeated\",\n+                                ATT_AnnotationDefault.parseKey());\n+                    }\n+                    DefaultAnnotationAttr defAnnot = annotParser.parseDefaultAnnotation();\n+                    if (defAnnot != null) {\n+                        curMethod.setDefaultAnnotation(defAnnot);\n+                    }\n+                    if (scanner.token == SEMICOLON) {\n+                        endClassExpected = true;\n+                        parseNext = false;\n+                    } else if (scanner.expectOneOfToken(SIGNATURE, THROWS)) {\n+                        continue;\n+                    }\n+                    scanner.scan();\n+                }\n+                \/\/ parse signature\n+                case SIGNATURE -> {\n+                    scanner.scan();\n+                    if (curMethod.getSignatureAttr() != null) {\n+                        environment.warning(scanner.pos, \"warn.method_info.attribute.repeated\",\n+                                ATT_Signature.parseKey());\n+                    }\n+                    nextAttributeExpected = false;\n+                    ConstCell signatureCell = parseName();\n+                    if (signatureCell != null) {\n+                        curMethod.setSignatureAttr(signatureCell);\n+                    }\n+                }\n+                case SEMICOLON -> {\n+                    parseNext = false;\n+                    scanner.scan();\n+                }\n+                case COMMA -> {\n+                    nextAttributeExpected = true;\n+                    scanner.scan();\n+                }\n+                default -> {\n+                    if (nextAttributeExpected) {\n+                        ArrayList<JasmTokens.Token> expected = new ArrayList<>();\n+                        if (curMethod.getDefaultAnnotation() == null) {\n+                            expected.add(DEFAULT);\n+                        }\n+                        if (!curMethod.hasExceptions()) {\n+                            expected.add(THROWS);\n+                        }\n+                        if (curMethod.getSignatureAttr() == null) {\n+                            expected.add(SIGNATURE);\n+                        }\n+                        if (expected.size() != 1) {\n+                            environment.throwErrorException(scanner.prevPos, \"err.one.of.N.token.expected\", JasmTokens.asString(expected));\n+                        } else {\n+                            environment.throwErrorException(scanner.prevPos, \"err.token.expected\", expected.get(0).parseKey());\n+                        }\n+                    }\n+                    parseNext = false;\n+                }\n@@ -891,18 +960,15 @@\n-        MethodData curMethod = classData.StartMethod(mod, nameCell, typeCell, exceptionList);\n-        if (signatureCell != null) {\n-            curMethod.setSignatureAttr(signatureCell);\n-        }\n-\n-        Indexer max_stack = null, max_locals = null;\n-\n-        if (scanner.token == STACK) {\n-            scanner.scan();\n-            max_stack = parseUInt(2);\n-        }\n-        if (scanner.token == LOCAL) {\n-            scanner.scan();\n-            max_locals = parseUInt(2);\n-        }\n-        if (scanner.token == INTVAL) {\n-            annotParser.parseParamAnnotation(paramCount, curMethod);\n-        }\n+        if (!endClassExpected) {\n+            Indexer max_stack = null, max_locals = null;\n+            do {\n+                if (scanner.token == STACK) {\n+                    scanner.scan();\n+                    max_stack = parseUInt(2);\n+                }\n+                if (scanner.token == LOCAL) {\n+                    scanner.scan();\n+                    max_locals = parseUInt(2);\n+                }\n+                if (scanner.token == INTVAL) {\n+                    annotParser.parseParamAnnotation(paramCount, curMethod);\n+                }\n+            } while (scanner.token.in(STACK, LOCAL, INTVAL));\n@@ -910,13 +976,4 @@\n-        if (scanner.token == SEMICOLON) {\n-            if ((max_stack != null) || (max_locals != null)) {\n-                environment.error(\"err.token.expected\", LBRACE.parseKey());\n-            }\n-            scanner.scan();\n-        } else if (!EModifier.isAbstract(mod)) {\n-            scanner.expect(LBRACE);\n-            curCodeAttr = curMethod.startCode(paramCount, max_stack, max_locals);\n-            parseCodeAttribute();\n-            curCodeAttr.endCode();\n-            scanner.expect(RBRACE);\n-        } else { \/\/ abstract method could have empty body {} and even not empty\n-            if (scanner.token == LBRACE) {\n+            if (scanner.token == SEMICOLON) {\n+                if ((max_stack != null) || (max_locals != null)) {\n+                    environment.error(\"err.token.expected\", LBRACE.parseKey());\n+                }\n@@ -924,0 +981,2 @@\n+            } else if (!EModifier.isAbstract(mod)) {\n+                scanner.expect(LBRACE);\n@@ -928,0 +987,8 @@\n+            } else { \/\/ abstract method could have empty body {} and even not empty\n+                if (scanner.token == LBRACE) {\n+                    scanner.scan();\n+                    curCodeAttr = curMethod.startCode(paramCount, max_stack, max_locals);\n+                    parseCodeAttribute();\n+                    curCodeAttr.endCode();\n+                    scanner.expect(RBRACE);\n+                }\n@@ -930,6 +997,0 @@\n-        if (defAnnot != null) {\n-            curMethod.addDefaultAnnotation(defAnnot);\n-        }\n-        if (memberAnnotations != null) {\n-            curMethod.addAnnotations(memberAnnotations);\n-        }\n@@ -937,1 +998,0 @@\n-\n@@ -939,1 +999,0 @@\n-\n@@ -973,1 +1032,1 @@\n-    private ArrayList<ConstCell<?>> parseThrowsClause() {\n+    private ArrayList<ConstCell<?>> parseThrowsClause(DataVectorAttr<ConstCell<?>> exceptionList) {\n@@ -978,1 +1037,1 @@\n-            if (list.contains(exc)) {\n+            if (exceptionList != null && exceptionList.contains(exc)) {\n@@ -980,3 +1039,0 @@\n-            } else {\n-                list.add(exc);\n-                environment.traceln(() -> \"THROWS:\" + exc.cpIndex);\n@@ -984,0 +1040,1 @@\n+            list.add(exc);\n@@ -985,1 +1042,0 @@\n-                scanner.scan();\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/Parser.java","additions":126,"deletions":70,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-     *\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/RecordData.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * with their closing counter part. This is useful during error recovery.<p>\n+ * with their closing counterpart. This is useful during error recovery.<p>\n@@ -174,1 +174,1 @@\n-            environment.error(pos, \"err.one.of.tokens.expected\", list);\n+            environment.error(pos, \"err.one.of.N.token.expected\", list);\n@@ -178,1 +178,0 @@\n-\n@@ -963,1 +962,0 @@\n-\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/Scanner.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,2 @@\n-warn.sign.repeated=Signature repeated\n+warn.method_info.attribute.repeated=The {0} attribute repeated in the method_info structure\n+err.method_info.attribute.repeated=The {0} attribute repeated in the method_info structure\n@@ -73,1 +74,0 @@\n-err.one.of.tokens.expected=One of the tokens {0} is expected.\n@@ -77,1 +77,1 @@\n-err.one.of.N.token.expected=One of \\\"{0}\\\" tokens is expected\n+err.one.of.N.token.expected=One of {0} tokens is expected\n@@ -230,3 +230,4 @@\n-err.incorrect.annot.class=Incorrect Annotation (class), expected class name or CPX), got \\\"{0}\\\"\n-err.incorrect.annot.enum=Incorrect Annotation (enum), expected type field IDENT, \\\"{0}\\\"\n-err.incorrect.annot.enum.cpx==Incorrect Annotation (enum), expected type field CPX\n+err.incorrect.annot.class=Incorrect Annotation (class), expected class name or CP index, got \\\"{0}\\\"\n+err.incorrect.annot.enum.type=Incorrect Annotation (enum), expected type_name or CP index, got \\\"{0}\\\"\n+err.incorrect.annot.enum.name==Incorrect Annotation (enum), expected const_name or CP index, got \\\"{0}\\\"\n+\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/i18n.properties","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+    \/\/ Prints the annotation header.\n@@ -67,4 +68,9 @@\n-        String annotationName = pool.getString(type_cpx, index -> \"#\" + index);\n-        \/\/ converts class type to java class name\n-        if ((annotationName.startsWith(\"L\") || annotationName.startsWith(\"Q\")) && annotationName.endsWith(\";\")) {\n-            annotationName = annotationName.substring(1, annotationName.length() - 1);\n+        String annotationName = pool.getString(type_cpx, index -> null);\n+        if (printCPIndex) {\n+            annotationName = \"#\" + type_cpx + (annotationName != null && (!skipComments) ? \" \/* %s *\/\".formatted(annotationName) : \"\");\n+        } else {\n+            if (annotationName == null) {\n+                annotationName = \"#\" + type_cpx;\n+            } else {\n+                annotationName = \"\\\"\" + annotationName + \"\\\"\";\n+            }\n@@ -74,2 +80,3 @@\n-                print(DEFAULT_VALUE_PREFIX).print(invisible ? invisibleAnnotationToken : visibleAnnotationToken).print(annotationName);\n-                setCommentOffset(getCommentOffset() + DEFAULT_VALUE_PREFIX.length());\n+                println(\" \" + DEFAULT_VALUE_PREFIX);\n+                printIndent(invisible ? invisibleAnnotationToken : visibleAnnotationToken).print(annotationName);\n+                setCommentOffset(getCommentOffset());\n@@ -93,1 +100,3 @@\n-                    print(\" }\");\n+                    println();\n+                    decIndent();\n+                    printIndent(\"}\");\n@@ -101,1 +110,1 @@\n-                    println(\"{\");\n+                    println(\" {\");\n@@ -133,4 +142,0 @@\n-        \/\/ converts class type to java class name\n-        if ((annotationName.startsWith(\"L\") || annotationName.startsWith(\"Q\")) && annotationName.endsWith(\";\")) {\n-            annotationName = annotationName.substring(1, annotationName.length() - 1);\n-        }\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/AnnotationData.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -204,2 +204,1 @@\n-                case AE_CLASS -> sb.append(valueAsString(elementType.printValue(),\n-                        () -> pool.decodeClassDescriptor(cpx)));\n+                case AE_CLASS -> sb.append(valueAsString(elementType.printValue(), () -> pool.getName(cpx)));\n@@ -230,1 +229,1 @@\n-                print(DEFAULT_VALUE_PREFIX + \"%s }\", stringVal());\n+                print(getDefaultValuePrefix() + \"%s }\", stringVal());\n@@ -260,1 +259,1 @@\n-                String className = pool.decodeClassDescriptor(cpx1);\n+                String className = pool.getName(cpx1);\n@@ -264,4 +263,3 @@\n-                    if (skipComments) {\n-                        sb.append(format(\"#%d\", cpx1)).append(format(\" #%d\", cpx2));\n-                    } else {\n-                        sb.append(format(\"#%d \/* %s *\/\", cpx1, className)).append(format(\" #%d \/* %s *\/\", cpx2, name));\n+                    sb.append(format(\"#%d.#%d\", cpx1, cpx2));\n+                    if (!skipComments) {\n+                        sb.append(format(\" \/* %s.%s *\/\", className, name));\n@@ -270,1 +268,1 @@\n-                    sb.append(className).append(\" \").append(name);\n+                    sb.append(className).append(\".\").append(name);\n@@ -284,1 +282,1 @@\n-                print(DEFAULT_VALUE_PREFIX + \"%s }\", stringVal());\n+                print(getDefaultValuePrefix() + \"%s }\", stringVal());\n@@ -318,4 +316,5 @@\n-                switch (getAnnotationElementState()) {\n-                    case HAS_DEFAULT_VALUE -> printDefaultAnnotationElement(count, getItemsPerLine(count, annotationValues.get(0)));\n-                    case INLINED_ELEMENT -> printDefaultAnnotationElement(count, 1);\n-                    default -> printAnnotationElement(count);\n+                AnnotationElementState state = getAnnotationElementState();\n+                if (state == HAS_DEFAULT_VALUE || state == INLINED_ELEMENT) {\n+                    printDefaultAnnotationElement(count);\n+                } else {\n+                    printAnnotationElement(count);\n@@ -325,1 +324,1 @@\n-                print(DEFAULT_VALUE_PREFIX + \"{ } }\");\n+                print(getDefaultValuePrefix() + \"{ } }\");\n@@ -331,1 +330,0 @@\n-                \/\/ commentShift + \"default { { \".length()\n@@ -337,7 +335,5 @@\n-        private <P extends AnnotationValue<T>> int getItemsPerLine(int count, P value) {\n-            if (value instanceof Annotation_AnnotationValue) {\n-                return 1;\n-            } else if (value instanceof CPX_AnnotationValue) {\n-                return (count > 10) ? (count % 2 == 0 ? 4 : 6) : (count % 2 == 0 ? 2 : 3);\n-            }\n-            return 1;\n+        private int getItemsPerLine(int count, AnnotationElementType type) {\n+            return switch (type) {\n+                case AE_CLASS, AE_ANNOTATION, AE_ENUM, AE_ARRAY -> 1;\n+                default -> (count > 10) ? (count % 2 == 0 ? 4 : 6) : (count % 2 == 0 ? 2 : 3);\n+            };\n@@ -346,1 +342,1 @@\n-        public void printDefaultAnnotationElement(int count, int ItemsPerLine) throws IOException {\n+        public void printDefaultAnnotationElement(int count) throws IOException {\n@@ -348,1 +344,4 @@\n-            println(DEFAULT_VALUE_PREFIX + \"{ \");\n+            int ItemsPerLine = getAnnotationElementState() == INLINED_ELEMENT ? 1 :\n+                    getItemsPerLine(count, annotationValues.get(0).elementType);\n+\n+            println(getDefaultValuePrefix() + \"{ \");\n@@ -354,1 +353,2 @@\n-                        annotationValue instanceof CPX_AnnotationValue) {\n+                        annotationValue instanceof CPX_AnnotationValue ||\n+                        annotationValue instanceof CPX2_AnnotationValue) {\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/AnnotationElement.java","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -406,16 +406,0 @@\n-    \/**\n-     * Pulls the class name out of a string (at the CP index). (drops any array\n-     * descriptors, and the class descriptors (\"L\" and \";\")\n-     *\/\n-    public String decodeClassDescriptor(int cpx) {\n-        \/\/ enum type is encoded as a descriptor\n-        \/\/ need to remove '\"'s and L (class descriptor)\n-\n-        \/\/ TODO: might have to count '['s at the beginning for Arrays\n-        String rawEnumName = getName(cpx);\n-        int len = rawEnumName.length();\n-        int begin = (rawEnumName.startsWith(\"\\\"L\")) ? 2 : 0;\n-        int end = (begin > 0) ? len - 2 : len;\n-        return rawEnumName.substring(begin, end);\n-    }\n-\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/ConstantPool.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -284,0 +284,1 @@\n+        this.commentOffset = that.commentOffset;\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/Indenter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private String contextDefaultValuePrefix = null;\n@@ -349,0 +350,7 @@\n+\n+    protected String getDefaultValuePrefix() {\n+        if( contextDefaultValuePrefix == null ) {\n+            contextDefaultValuePrefix = printCPIndex ? DEFAULT_VALUE_PREFIX : \" \" + DEFAULT_VALUE_PREFIX;\n+        }\n+        return contextDefaultValuePrefix;\n+    }\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/MemberData.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.Arrays;\n@@ -284,0 +283,7 @@\n+     * [SystemInfo]?\n+     * [@(=|-)Annotations]*\n+     * [modifiers]* Method name:descriptor[:signature]?(1) [;]?(2)\n+     * 1) :signature if !table\n+     * 2) if !tableSignatureFormat AND !hasCode AND !hasAnnotationParameters AND !hasException\n+     * [default(;|,)(3)]  3) ; if\n+     *\n@@ -290,1 +296,3 @@\n-        boolean hasCodeInfo = code != null || hasAnnotationParameters() || hasExceptions;\n+        boolean hasCode = code != null;\n+\n+        boolean hasCodeInfo = hasCode || hasAnnotationParameters() || hasExceptions;\n@@ -311,1 +319,1 @@\n-            if (noExtraInfo) {\n+            if (noExtraInfo && !hasDefaultAnnotation()) {\n@@ -332,1 +340,1 @@\n-            if (noExtraInfo) {\n+            if (noExtraInfo && !hasDefaultAnnotation()) {\n@@ -334,4 +342,0 @@\n-            } else if (!hasAnnotationParameters() && tableSignatureFormat) {\n-                methSignature = methSignature.concat(\": \");\n-            } else {\n-                methSignature = methSignature.concat(\" \");\n@@ -350,2 +354,2 @@\n-            if (noExtraInfo) {\n-                print(\";\");\n+            if (!hasCodeInfo) {\n+                print(!tableSignatureFormat ? \";\" : \",\");\n@@ -360,0 +364,1 @@\n+            signature.terminateMethodSignature(!hasExceptions);\n@@ -378,2 +383,0 @@\n-            } else if (index == size - 1) {\n-                println();\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/MethodData.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    private String attributeTerminator = \";\";\n@@ -131,1 +132,1 @@\n-                print(\"#%d;\".formatted(cpIndex).concat(eol));\n+                print(\"#%d%s\".formatted(cpIndex,this.attributeTerminator).concat(eol));\n@@ -133,1 +134,1 @@\n-                print(PadRight(\"#%d;\".formatted(cpIndex), getPrintAttributeCommentPadding())).\n+                print(PadRight(\"#%d%s\".formatted(cpIndex,this.attributeTerminator), getPrintAttributeCommentPadding())).\n@@ -137,1 +138,1 @@\n-            print(sign.concat(\";\").concat(eol));\n+            print(sign.concat(\"%s\".formatted(this.attributeTerminator)).concat(eol));\n@@ -147,1 +148,1 @@\n-                print(\"#%d;\".formatted(cpIndex).concat(eol));\n+                print(\"#%d%s\".formatted(cpIndex,this.attributeTerminator).concat(eol));\n@@ -149,1 +150,1 @@\n-                print(PadRight(\"#%d;\".formatted(cpIndex), getPrintAttributeCommentPadding())).\n+                print(PadRight(\"#%d%s\".formatted(cpIndex,this.attributeTerminator), getPrintAttributeCommentPadding())).\n@@ -153,1 +154,1 @@\n-            print(sign.concat(\";\").concat(eol));\n+            print(sign.concat(\"%s\".formatted(this.attributeTerminator)).concat(eol));\n@@ -170,0 +171,4 @@\n+\n+    public void terminateMethodSignature(boolean value) {\n+        this.attributeTerminator = value ? \";\" : \",\";\n+    }\n","filename":"src\/org\/openjdk\/asmtools\/jdis\/SignatureData.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"}]}