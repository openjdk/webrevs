{"files":[{"patch":"@@ -40,1 +40,5 @@\n- * Utility class to share common tools\/methods.\n+ * Utility class for string operations related to ASM tools.\n+ * <p>\n+ * This class provides methods for removing comments from strings,\n+ * converting UTF-8 strings to printable formats, and handling character\n+ * encoding in a way that is suitable for assembly tools.\n@@ -99,12 +103,1 @@\n-            char c = utf8.charAt(k);\n-            switch (c) {\n-                case '\\t' -> sb.append('\\\\').append('t');\n-                case '\\n' -> sb.append('\\\\').append('n');\n-                case '\\r' -> sb.append('\\\\').append('r');\n-                case '\\b' -> sb.append('\\\\').append('b');\n-                case '\\f' -> sb.append('\\\\').append('f');\n-                case '\\\"' -> sb.append('\\\\').append('\\\"');\n-                case '\\'' -> sb.append('\\\\').append('\\'');\n-                case '\\\\' -> sb.append('\\\\').append('\\\\');\n-                default -> sb.append(Character.isISOControl(c) ? String.format(\"\\\\u%04x\", (int) c) : c);\n-            }\n+            sb.append(charToUtf8String(utf8.charAt(k)));\n@@ -115,0 +108,46 @@\n+    \/**\n+     * Converts CONSTANT_Utf8_info string to a printable list of strings\n+     * @param utf8      UTF8 string taken from within ConstantPool of a class file\n+     * @param strLength the maximum length of each string in the resulting list\n+     * @return list of strings for jcod\/jasm\n+     *\/\n+    public static List<String> Utf8ToStringList(String utf8, int strLength) {\n+        List<String> list = new ArrayList<>();\n+        String s = \"\";\n+        for (int k = 0; k < utf8.length(); k++) {\n+            if (s.length() >= strLength) {\n+                list.add(s);\n+                s = \"\";\n+            }\n+            s += charToUtf8String(utf8.charAt(k));\n+        }\n+        if (!s.isEmpty()) {\n+            list.add(s);\n+        }\n+        return list;\n+    }\n+\n+    \/**\n+     * Converts a character to its UTF-8 string representation.\n+     * <p>\n+     * Control characters and special characters are escaped using the appropriate escape sequences.\n+     * Other characters are returned as is.\n+     *\n+     * @param c the character to convert\n+     * @return the UTF-8 string representation of the character\n+     *\/\n+    public static String charToUtf8String(char c) {\n+        return switch (c) {\n+            case '\\t' -> \"\\\\\".concat(\"t\");\n+            case '\\n' -> \"\\\\\".concat(\"n\");\n+            case '\\r' -> \"\\\\\".concat(\"r\");\n+            case '\\b' -> \"\\\\\".concat(\"b\");\n+            case '\\f' -> \"\\\\\".concat(\"f\");\n+            case '\\\"' -> \"\\\\\".concat(\"\\\"\");\n+            case '\\'' -> \"\\\\\".concat(\"\\'\");\n+            case '\\\\' -> \"\\\\\".concat(\"\\\\\");\n+            default -> Character.isISOControl(c) ? String.format(\"\\\\u%04x\", (int) c) : Character.toString(c);\n+        };\n+    }\n+\n+\n@@ -176,1 +215,1 @@\n-        } catch (NegativeArraySizeException negativeArraySizeException ) {\n+        } catch (NegativeArraySizeException negativeArraySizeException) {\n@@ -215,14 +254,3 @@\n-            String formattedStr = Utf8ToString(rawString);\n-            if (formattedStr.chars().filter(c -> !isPrintableChar((char) c)).findAny().isEmpty()) {\n-                int length = formattedStr.length();\n-                list = new ArrayList<>();\n-                for (int i = 0; i < length; i += CHARS_IN_LINE) {\n-                    \/\/ The case when subSequence splits string in between \\ && n, \\ && t etc.\n-                    int idx = Math.min(length, i + CHARS_IN_LINE);\n-                    String item = formattedStr.substring(i, idx);\n-                    if (item.endsWith(\"\\\\\") && !item.endsWith(\"\\\\\\\\\")) {\n-                        item = item.concat(formattedStr.substring(idx, idx + 1));\n-                        i++;\n-                    }\n-                    list.add(item);\n-                }\n+            String cleanedString = removeNonPrintableAscii(rawString);\n+            if (cleanedString != null && !cleanedString.isEmpty() && !cleanedString.chars().anyMatch(c -> !isPrintableChar((char) c))) {\n+                list = Utf8ToStringList(rawString, CHARS_IN_LINE);\n@@ -234,0 +262,26 @@\n+    \/**\n+     * Removes non-printable ASCII characters from the given input string.\n+     * <p>\n+     * Non-printable ASCII characters are those with ASCII values outside the range of 32 (space) to 126 (tilde).\n+     *\n+     * @param input the input string to be processed\n+     * @return a new string with non-printable ASCII characters removed, or null if the input is null\n+     *\/\n+    public static String removeNonPrintableAscii(String input) {\n+        if (input == null) return null;\n+        StringBuilder result = new StringBuilder();\n+        for (char c : input.toCharArray()) {\n+            if (c >= 32 && c <= 126) {\n+                result.append(c);\n+            }\n+        }\n+        return result.toString();\n+    }\n+\n+    \/**\n+     * Converts a list of strings to a formatted string representation.\n+     * The output is enclosed in parentheses and elements are separated by commas.\n+     *\n+     * @param list the list of strings to convert\n+     * @return a formatted string representation of the list\n+     *\/\n@@ -238,0 +292,12 @@\n+    \/**\n+     * Converts a list of strings to a formatted string representation.\n+     * The output is enclosed in square brackets and elements are separated by a specified delimiter.\n+     *\n+     * @param list       the list of strings to convert\n+     * @param separators a string containing the prefix, delimiter, and postfix characters\n+     *                  (e.g., \"[,]\"), where:\n+     *                  - first character is the prefix,\n+     *                  - second character is the delimiter,\n+     *                  - third character is the postfix.\n+     * @return a formatted string representation of the list\n+     *\/\n@@ -246,0 +312,7 @@\n+    \/**\n+     * Converts an array of integers to a hex string representation.\n+     * Each integer is converted to its hexadecimal format and joined with commas.\n+     *\n+     * @param array the array of integers to convert\n+     * @return a string representation of the array in hexadecimal format\n+     *\/\n@@ -255,0 +328,8 @@\n+    \/**\n+     * Checks if the character is printable.\n+     * A character is considered printable if it is not a control character,\n+     * is not undefined, and belongs to a valid Unicode block that is not SPECIALS.\n+     *\n+     * @param c the character to check\n+     * @return true if the character is printable, false otherwise\n+     *\/\n","filename":"src\/org\/openjdk\/asmtools\/asmutils\/StringUtils.java","additions":109,"deletions":28,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-                            error(position, \"invalid.escape.char\");\n+                            error(position, \"err.invalid.escape.char\");\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/JasmEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-            default -> throw new RuntimeException(\"SourceDebugExtension_attribute is not initialized\");\n+            case NONE -> true; \/\/ not initialized\n@@ -88,1 +88,1 @@\n-            default -> throw new RuntimeException(\"SourceDebugExtension_attribute is not initialized\");\n+            case NONE -> 0;\n@@ -97,1 +97,1 @@\n-            default -> throw new RuntimeException(\"SourceDebugExtension_attribute is not initialized\");\n+            case  NONE -> out.write(0);\n","filename":"src\/org\/openjdk\/asmtools\/jasm\/SourceDebugExtensionAttr.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import org.openjdk.asmtools.lib.script.TestScript;\n@@ -51,1 +52,1 @@\n-public class NestHostTests {\n+public class NestHostTests extends TestScript {\n@@ -117,2 +118,2 @@\n-        resourceDir = new File(Objects.requireNonNull(this.getClass().\n-                getResource(\"Test01.jasm\")).getFile()).getParentFile();\n+        \/\/ initialize resource directory\n+        super.init(\"Test01.jasm\");\n@@ -124,35 +125,1 @@\n-        \/\/ jasm to class in memory\n-        \/\/ jasm.setDebug(true);\n-        LogAndBinResults binResult = jasm.compile(List.of(resourceDir + File.separator + resourceName));\n-        \/\/ class produced correctly\n-        Assertions.assertTrue(binResult.log.toString().isEmpty());\n-        Assertions.assertEquals(0, binResult.result);\n-\n-        \/\/ class to jasm\n-        LogAndTextResults textResult = new Jdis().setArgs(args).decode(binResult.getAsByteInput());\n-\n-        Assertions.assertEquals(0, textResult.result);\n-        String jasmText = textResult.getResultAsString(Function.identity());\n-        String normJasmText = funcNormalizeText.apply(jasmText);\n-        for (Consumer<String> testConsumer : tests) {\n-            testConsumer.accept(normJasmText);\n-        }\n-        \/\/ jasm to class\n-        binResult = jasm.compile(new StringInput(jasmText));\n-        \/\/ class produced correctly\n-        Assertions.assertEquals(0, binResult.result);\n-        Assertions.assertTrue(binResult.log.toString().isEmpty());\n-        \/\/ class to jasm\n-        textResult = new Jdis().setArgs(args).decode(binResult.getAsByteInput());\n-        Assertions.assertEquals(0, textResult.result);\n-        jasmText = textResult.getResultAsString(Function.identity());\n-        normJasmText = funcNormalizeText.apply(jasmText);\n-        for (Consumer<String> testConsumer : tests) {\n-            testConsumer.accept(normJasmText);\n-        }\n-        \/\/ class to jcod\n-        textResult = new Jdec().setArgs(EToolArguments.JDEC_G).decode(binResult.getAsByteInput());\n-        Assertions.assertEquals(0, textResult.result);\n-        \/\/ jcod to class\n-        binResult = jcoder.compile(new StringInput(textResult.getResultAsString(Function.identity())));\n-        Assertions.assertEquals(0, binResult.result);\n+        super.jasmTest(resourceName, args, tests);\n@@ -164,17 +131,1 @@\n-        \/\/ jcod to class in memory\n-        LogAndBinResults binResult = jcoder.compile(List.of(resourceDir + File.separator + resourceName));\n-        \/\/ class produced correctly\n-        Assertions.assertEquals(0, binResult.result);\n-        Assertions.assertTrue(binResult.log.toString().isEmpty());\n-        \/\/ class to jcod\n-        LogAndTextResults textResult = new Jdec().setArgs(args).decode(binResult.getAsByteInput());\n-        String jcoderText = textResult.getResultAsString(funcNormalizeText);\n-        Assertions.assertEquals(0, textResult.result);\n-        for (Consumer<String> testConsumer : tests) {\n-            testConsumer.accept(jcoderText);\n-        }\n-        \/\/ class to jasm twice\n-        textResult = new Jdis().setArgs(EToolArguments.JDIS_G_T_LNT_LVT).decode(binResult.getAsByteInput());\n-        Assertions.assertEquals(0, textResult.result);\n-        textResult = new Jdis().setArgs(EToolArguments.JDIS_GG_NC_LNT_LVT).decode(binResult.getAsByteInput());\n-        Assertions.assertEquals(0, textResult.result);\n+        super.jcoderTest(resourceName, args, tests);\n","filename":"test\/java\/org\/openjdk\/asmtools\/attribute\/NestHost\/NestHostTests.java","additions":6,"deletions":55,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.asmtools.attribute.SourceDebugExtension;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.openjdk.asmtools.lib.action.EToolArguments;\n+import org.openjdk.asmtools.lib.script.TestScript;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.matchesPattern;\n+import static org.hamcrest.core.AllOf.allOf;\n+import static org.openjdk.asmtools.lib.utility.StringUtils.funcSubStrCount;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class SourceDebugExtensionTests extends TestScript {\n+\n+    private static Stream<Arguments> getJasmParameters() {\n+        return Stream.of(\n+                Arguments.of(\"SourceDebugExt01.jasm\",\n+                        EToolArguments.JDIS_G, List.of(\n+                                (Consumer<String>) (text) -> assertThat(text, allOf(\n+                                        containsString(\"\\\"SMAP\\\\nSourceDebugExt01.java\\\\nJava\\\\n*S Java\\\\n*F\\\\n+ 1 SourceDebugExt01.java\\\\n\\\";\"),\n+                                        containsString(\"\\\"SourceDebugExt01.java\\\\n*L\\\\n1#1,5:1\\\\n*E\\\";\"),\n+                                        matchesPattern(\".*const #\\\\d\\\\d = Utf8 \\\"SourceDebugExtension\\\";.*\")\n+                                )),\n+                                (Consumer<String>) (text) ->\n+                                        Assertions.assertEquals(2, funcSubStrCount.apply(text, \"SourceDebugExtension\"))\n+                        )\n+                ),\n+                Arguments.of(\"SourceDebugExt02.jasm\",\n+                        EToolArguments.JDIS_G_T, List.of(\n+                                (Consumer<String>) (text) -> assertThat(text, allOf(\n+                                        containsString(\"SourceDebugExtension { }\"),\n+                                        matchesPattern(\".*const #\\\\d\\\\d = Utf8 \\\"SourceDebugExtension\\\";.*\")\n+                                )),\n+                                (Consumer<String>) (text) ->\n+                                        Assertions.assertEquals(2, funcSubStrCount.apply(text, \"SourceDebugExtension\"))\n+                        )\n+                ),\n+                Arguments.of(\"SourceDebugExt03.jasm\",\n+                        EToolArguments.JDIS, List.of(\n+                                (Consumer<String>) (text) -> assertThat(text, allOf(\n+                                        containsString(\"SourceDebugExtension { 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x00 0x0B 0x0C; 0x0D 0x0E 0x0F; }\")\n+                                )),\n+                                (Consumer<String>) (text) ->\n+                                        Assertions.assertEquals(1, funcSubStrCount.apply(text, \"SourceDebugExtension\"))\n+                        )\n+                )\n+        );\n+    }\n+\n+    @BeforeAll\n+    public void init() throws IOException {\n+        \/\/ initialize resource directory\n+        super.init(\"SourceDebugExt01.jasm\");\n+        \/\/ enable warnings for Jasm tests\n+        super.enableToolsWarnings();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getJasmParameters\")\n+    public void jasmTest(String resourceName, EToolArguments args, List<Consumer<String>> tests) {\n+        super.jasmTest(resourceName, args, tests);\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/asmtools\/attribute\/SourceDebugExtension\/SourceDebugExtensionTests.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+package org.openjdk.asmtools.lib.script;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.openjdk.asmtools.common.inputs.StringInput;\n+import org.openjdk.asmtools.lib.action.*;\n+import org.openjdk.asmtools.lib.log.LogAndBinResults;\n+import org.openjdk.asmtools.lib.log.LogAndTextResults;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.openjdk.asmtools.lib.utility.StringUtils.funcNormalizeText;\n+\n+public class TestScript {\n+    protected Jasm jasm = new Jasm();\n+    private Jcoder jcoder = new Jcoder();\n+    protected File resourceDir;\n+    protected boolean warningsEnabled = false;\n+\n+    public void init(String resource) throws IOException {\n+        if (resource == null) {\n+            throw new IOException(\"Resource not declared\");\n+        }\n+        URL url = this.getClass().getResource(resource);\n+        if (url == null) {\n+            fail(\"Resource \\\"%s\\\" not found.\".formatted(resource));\n+        }\n+        this.resourceDir = new File(url.getFile()).getParentFile();\n+        if (!this.resourceDir.exists() || !this.resourceDir.isDirectory()) {\n+            fail(\"Resource directory does not exist or is not a directory: \" + this.resourceDir);\n+        } else if (DebugHelper.isDebug()) {\n+            fail(\"Resource directory initialized: \" + this.resourceDir.getAbsolutePath());\n+        }\n+    }\n+\n+    public void jasmTest(String resourceName, EToolArguments args, List<Consumer<String>> tests) {\n+        \/\/ jasm to class in memory\n+        \/\/ jasm.setDebug(true);\n+        LogAndBinResults binResult = jasm.compile(List.of(resourceDir + File.separator + resourceName));\n+        \/\/ class produced correctly\n+        if( !warningsEnabled )\n+            Assertions.assertTrue(binResult.log.toString().isEmpty());\n+        Assertions.assertEquals(0, binResult.result);\n+\n+        \/\/ class to jasm\n+        LogAndTextResults textResult = new Jdis().setArgs(args).decode(binResult.getAsByteInput());\n+\n+        Assertions.assertEquals(0, textResult.result);\n+        String jasmText = textResult.getResultAsString(Function.identity());\n+        String normJasmText = funcNormalizeText.apply(jasmText);\n+        for (Consumer<String> testConsumer : tests) {\n+            testConsumer.accept(normJasmText);\n+        }\n+        \/\/ jasm to class\n+        binResult = jasm.compile(new StringInput(jasmText));\n+        \/\/ class produced correctly\n+        Assertions.assertEquals(0, binResult.result);\n+        if( !warningsEnabled )\n+            Assertions.assertTrue(binResult.log.toString().isEmpty());\n+        \/\/ class to jasm\n+        textResult = new Jdis().setArgs(args).decode(binResult.getAsByteInput());\n+        Assertions.assertEquals(0, textResult.result);\n+        jasmText = textResult.getResultAsString(Function.identity());\n+        normJasmText = funcNormalizeText.apply(jasmText);\n+        for (Consumer<String> testConsumer : tests) {\n+            testConsumer.accept(normJasmText);\n+        }\n+        \/\/ class to jcod\n+        textResult = new Jdec().setArgs(EToolArguments.JDEC_G).decode(binResult.getAsByteInput());\n+        Assertions.assertEquals(0, textResult.result);\n+        \/\/ jcod to class\n+        binResult = jcoder.compile(new StringInput(textResult.getResultAsString(Function.identity())));\n+        Assertions.assertEquals(0, binResult.result);\n+    }\n+\n+    public void jcoderTest(String resourceName, EToolArguments args, List<Consumer<String>> tests) {\n+        \/\/ jcod to class in memory\n+        LogAndBinResults binResult = jcoder.compile(List.of(resourceDir + File.separator + resourceName));\n+        \/\/ class produced correctly\n+        Assertions.assertEquals(0, binResult.result);\n+        if( !warningsEnabled )\n+            Assertions.assertTrue(binResult.log.toString().isEmpty());\n+        \/\/ class to jcod\n+        LogAndTextResults textResult = new Jdec().setArgs(args).decode(binResult.getAsByteInput());\n+        String jcoderText = textResult.getResultAsString(funcNormalizeText);\n+        Assertions.assertEquals(0, textResult.result);\n+        for (Consumer<String> testConsumer : tests) {\n+            testConsumer.accept(jcoderText);\n+        }\n+        \/\/ class to jasm twice\n+        textResult = new Jdis().setArgs(EToolArguments.JDIS_G_T_LNT_LVT).decode(binResult.getAsByteInput());\n+        Assertions.assertEquals(0, textResult.result);\n+        textResult = new Jdis().setArgs(EToolArguments.JDIS_GG_NC_LNT_LVT).decode(binResult.getAsByteInput());\n+        Assertions.assertEquals(0, textResult.result);\n+    }\n+\n+    protected void enableToolsWarnings() {\n+        this.warningsEnabled = true;\n+    }\n+}\n","filename":"test\/java\/org\/openjdk\/asmtools\/lib\/script\/TestScript.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,20 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n+package javasoft\/sqe\/tests\/api\/java\/lang\/classfile\/resources\/jasm\/atr;\n+\n+public super class SourceDebugExt01 version 66:0\n+{\n+  public Method \"<init>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  SourceDebugExtension {\n+    \"SMAP\\nSourceDebugExt01.java\\nJava\\n*S Java\\n*F\\n+ 1 SourceDebugExt01.java\\nSou\";\n+    \"rceDebugExt01.java\\n*L\\n1#1,5:1\\n*E\";\n+  }\n+} \/\/ end Class SourceDebugExt01 compiled from \"SourceDebugExt01.java\"\n","filename":"test\/resources\/org\/openjdk\/asmtools\/attribute\/SourceDebugExtension\/SourceDebugExt01.jasm","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n+package javasoft\/sqe\/tests\/api\/java\/lang\/classfile\/resources\/jasm\/atr;\n+\n+public super class SourceDebugExt02 version 66:0\n+{\n+  public Method \"<init>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  SourceDebugExtension {\n+    \"\";\n+  }\n+} \/\/ end Class SourceDebugExt02 compiled from \"SourceDebugExt02.java\"\n","filename":"test\/resources\/org\/openjdk\/asmtools\/attribute\/SourceDebugExtension\/SourceDebugExt02.jasm","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * Copyright (c) 2025; Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n+package javasoft\/sqe\/tests\/api\/java\/lang\/classfile\/resources\/jasm\/atr;\n+\n+public super class SourceDebugExt03 version 66:0\n+{\n+  public Method \"<init>\":\"()V\"\n+    stack 1  locals 1\n+  {\n+         aload_0;\n+         invokespecial     Method java\/lang\/Object.\"<init>\":\"()V\";\n+         return;\n+  }\n+\n+  SourceDebugExtension {\n+    0x01; 0x02; 0x03; 0x04; 0x05; 0x06; 0x07; 0x08; 0x09; 0x0A; 0x00; 0x0B; 0x0C; 0x0D; 0x0E; 0x0F;\n+  }\n+} \/\/ end Class SourceDebugExt03 compiled from \"SourceDebugExt03.java\"\n","filename":"test\/resources\/org\/openjdk\/asmtools\/attribute\/SourceDebugExtension\/SourceDebugExt03.jasm","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"}]}