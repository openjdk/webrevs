{"files":[{"patch":"@@ -217,0 +217,1 @@\n+  int len = MAX2((int)(_oop_map->size()), 100000);\n@@ -218,1 +219,2 @@\n-  GrowableArray<TsanOopMapImpl::PendingMove> moves(MAX2((int)(_oop_map->size()), 100000));\n+  GrowableArray<TsanOopMapImpl::PendingMove> moves(len);\n+  GrowableArray<TsanOopMapImpl::MovedEntry> moved_entries(len);\n@@ -223,0 +225,1 @@\n+                                 &moved_entries,\n@@ -226,0 +229,7 @@\n+\n+    \/\/ Add back the entries with moved oops. New hashes for the entries\n+    \/\/ are computed using the new oop address.\n+    for (int i = 0; i < moved_entries.length(); i++) {\n+      const TsanOopMapImpl::MovedEntry &e = moved_entries.at(i);\n+      _oop_map->add_entry(e.key(), e.value());\n+    }\n","filename":"src\/hotspot\/share\/tsan\/tsanOopMap.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -73,0 +73,8 @@\n+bool TsanOopMapTable::add_entry(TsanOopMapTableKey *entry, size_t size) {\n+  bool added;\n+  size_t* v = _table.put_if_absent(*entry, size, &added);\n+  assert(added, \"must be\");\n+  assert(*v == size, \"sanity\");\n+  return added;\n+}\n+\n@@ -76,6 +84,2 @@\n-  if (obj->fast_no_hash_check()) {\n-    added = _table.put_when_absent(new_entry, size);\n-  } else {\n-    size_t* v = _table.put_if_absent(new_entry, size, &added);\n-    assert(*v == size, \"sanity\");\n-  }\n+  size_t* v = _table.put_if_absent(new_entry, size, &added);\n+  assert(*v == size, \"sanity\");\n@@ -117,0 +121,1 @@\n+         GrowableArray<TsanOopMapImpl::MovedEntry> *moved_entries,\n@@ -122,0 +127,1 @@\n+    GrowableArray<TsanOopMapImpl::MovedEntry> *_moved_entries;\n@@ -128,1 +134,2 @@\n-    IsDead(GrowableArray<TsanOopMapImpl::PendingMove> *moves,\n+    IsDead(GrowableArray<TsanOopMapImpl::MovedEntry> *moved_entries,\n+           GrowableArray<TsanOopMapImpl::PendingMove> *moves,\n@@ -131,1 +138,2 @@\n-           int  *n_downward_moves) : _moves(moves), _src_low(src_low), _src_high(src_high),\n+           int  *n_downward_moves) : _moved_entries(moved_entries), _moves(moves),\n+                                     _src_low(src_low), _src_high(src_high),\n@@ -154,0 +162,7 @@\n+\n+        TsanOopMapTableKey* new_entry = new TsanOopMapTableKey(entry);\n+        TsanOopMapImpl::MovedEntry moved_entry = {new_entry, size};\n+        _moved_entries->append(moved_entry);\n+\n+        \/\/ Unlink the entry without releasing the weak_handle.\n+        return true;\n@@ -157,1 +172,1 @@\n-  } is_dead(moves, src_low, src_high, dest_low, dest_high, n_downward_moves);\n+  } is_dead(moved_entries, moves, src_low, src_high, dest_low, dest_high, n_downward_moves);\n","filename":"src\/hotspot\/share\/tsan\/tsanOopMapTable.cpp","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+class TsanOopMapTableKey;\n+\n@@ -47,0 +49,7 @@\n+  struct MovedEntry {\n+    TsanOopMapTableKey* k;\n+    size_t v;\n+    TsanOopMapTableKey* key() const { return k; }\n+    size_t value() const { return v; }\n+  };\n+\n@@ -72,0 +81,13 @@\n+  \/\/ Compute the hash for the entry using the enclosed oop address.\n+  \/\/ Note that this would return a different hash value when an oop\n+  \/\/ enclosed by the entry is moved by GC. When that happens, we need\n+  \/\/ to remove the old entry from the tsanOopMap and insert a new\n+  \/\/ entry using re-computed hash. That's to prevent the same `oop`\n+  \/\/ being added to the tsanOopMap and notifing tsan (when `oop` is\n+  \/\/ moved) more than once.\n+  \/\/\n+  \/\/ We cannot use the `oop` identity hash here, as we need to compute\n+  \/\/ the hash when trying to add a new `oop` to the tsanOopMap. One of\n+  \/\/ the case is during InterpreterMacroAssembler::lock_object, which\n+  \/\/ may cause a new identity hash being computed for an `oop` in some\n+  \/\/ cases. That could be a hidden issue with `oop` identity hash.\n@@ -75,1 +97,1 @@\n-    return (unsigned int)entry._obj->identity_hash();\n+    return primitive_hash<oopDesc*>(entry.object_no_keepalive());\n@@ -79,1 +101,1 @@\n-    return lhs._obj == rhs._obj;\n+    return lhs.object_no_keepalive() == rhs.object_no_keepalive();\n@@ -104,0 +126,1 @@\n+  bool add_entry(TsanOopMapTableKey *entry, size_t size);\n@@ -112,0 +135,1 @@\n+           GrowableArray<TsanOopMapImpl::MovedEntry> *moved_entries,\n","filename":"src\/hotspot\/share\/tsan\/tsanOopMapTable.hpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"}]}