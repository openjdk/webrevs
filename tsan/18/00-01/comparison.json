{"files":[{"patch":"@@ -293,3 +293,0 @@\n-  \/\/ FIXME: Is this still needed?\n-#if INCLUDE_TSAN\n-#endif  \/\/ INCLUDE_TSAN\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -232,0 +232,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -756,2 +756,3 @@\n-      \/\/ fully_initialized and here. This is to read\/write of natives related\n-      \/\/ to class static initializer.\n+      \/\/ fully_initialized and here. Memory accesses from JNI native code\n+      \/\/ invoked from class static initializer may rely on this happens-before\n+      \/\/ edge to avoid reporting false positive data races. \n@@ -1204,7 +1205,7 @@\n-  if (state == fully_initialized) {\n-        TSAN_RUNTIME_ONLY(\n-        \/\/ Construct a happens-before edge between the write of _init_state to\n-        \/\/ fully_initialized and the later checking if it's initialized.\n-        SharedRuntime::tsan_release((address)java_mirror());\n-      );\n-  }\n+  TSAN_RUNTIME_ONLY(\n+    if (state == fully_initialized) {\n+      \/\/ Construct a happens-before edge between the write of _init_state to\n+      \/\/ fully_initialized and the later checking if it's initialized.\n+      SharedRuntime::tsan_release((address)java_mirror());\n+    }\n+  );\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -794,1 +794,1 @@\n-  ScopedReleaseAcquire releaseAcquire(p, offset);\n+  ScopedReleaseAcquire releaseAcquire(addr);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}