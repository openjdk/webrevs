{"files":[{"patch":"@@ -2,1 +2,2 @@\n-project=jdk-updates\n+project=tsan\n+repository=tsan\n@@ -7,1 +8,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,merge,executable,symlink,message,hg-tag,whitespace,problemlists\n","filename":".jcheck\/conf","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -785,0 +785,9 @@\n+  # With tsan enabled, process reaper often causes SOE. it makes jtreg test failure.\n+  ifeq ($(INCLUDE_TSAN), true)\n+    ifeq ($(call isTargetCpuArch, aarch64), true)\n+      $1_JTREG_BASIC_OPTIONS += -vmoption:-Djdk.lang.processReaperUseDefaultStackSize=true\n+      $1_JTREG_LAUNCHER_OPTIONS += -Djdk.lang.processReaperUseDefaultStackSize=true\n+      $$(info tsan enabled, process reaper will use default JVM stack size.)\n+    endif\n+  endif\n+\n","filename":"make\/RunTests.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -348,1 +348,9 @@\n-    if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n+    # Use -Os on aarch64 to work around known llvm issue,\n+    # (see https:\/\/bugs.llvm.org\/show_bug.cgi?id=44581) which makes release build crash in aarch64.\n+    if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+      C_O_FLAG_HIGHEST_JVM=\"-Os\"\n+      C_O_FLAG_HIGHEST=\"-Os\"\n+      C_O_FLAG_HI=\"-Os\"\n+      C_O_FLAG_NORM=\"-Os\"\n+      C_O_FLAG_DEBUG_JVM=\"\"\n+    elif test \"x$OPENJDK_TARGET_OS\" = xaix; then\n@@ -610,0 +618,6 @@\n+    # Disable experimental isel due to a known issue in llvm-8, which generates wrong debug info.\n+    # (see https:\/\/bugs.llvm.org\/show_bug.cgi?id=40887)\n+    if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+      TOOLCHAIN_CFLAGS_JVM=\"$TOOLCHAIN_CFLAGS_JVM -fno-experimental-isel\"\n+    fi\n+\n","filename":"make\/autoconf\/flags-cflags.m4","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -895,0 +895,1 @@\n+INCLUDE_TSAN:=@INCLUDE_TSAN@\n","filename":"make\/autoconf\/spec.gmk.in","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -739,0 +739,3 @@\n+\n+  TSAN_RUNTIME_ONLY(push_ptr(lock_reg));\n+\n@@ -843,0 +846,9 @@\n+\n+  TSAN_RUNTIME_ONLY(\n+    pop_ptr(lock_reg);\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_lock),\n+            lock_reg);\n+    popa();\n+  );\n@@ -861,0 +873,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_unlock),\n+            lock_reg);\n+    popa();\n+  );\n+\n@@ -1557,0 +1577,4 @@\n+  TSAN_RUNTIME_ONLY(call_VM(noreg,\n+                            CAST_FROM_FN_PTR(address,\n+                            SharedRuntime::tsan_interp_method_entry)));\n+\n@@ -1590,0 +1614,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    push(state);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                 SharedRuntime::tsan_interp_method_exit));\n+    pop(state);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1743,0 +1743,9 @@\n+  TSAN_RUNTIME_ONLY(\n+    \/\/ protect the args we've loaded\n+    save_args(masm, total_c_args, c_arg, out_regs);\n+    __ call_VM(noreg,\n+      CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_entry),\n+      rthread);\n+    restore_args(masm, total_c_args, c_arg, out_regs);\n+  );\n+\n@@ -1823,0 +1832,8 @@\n+\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg,\n+                 CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_lock),\n+                 obj_reg);\n+      __ popa();\n+    );\n@@ -1923,0 +1940,8 @@\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg,\n+                 CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_unlock),\n+                 obj_reg);\n+      __ popa();\n+    );\n+\n@@ -1970,0 +1995,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    save_native_result(masm, ret_type, stack_slots);\n+    __ call_VM_leaf(\n+         CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_exit));\n+    restore_native_result(masm, ret_type, stack_slots);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -753,0 +753,81 @@\n+#if INCLUDE_TSAN\n+\n+void TemplateTable::tsan_observe_load_or_store(const Address& field,\n+                                               TsanMemoryReadWriteFunction tsan_function) {\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+  if (!ThreadSanitizerJavaMemory) {\n+    return;\n+  }\n+\n+  __ pusha();\n+  __ push_d(v0);\n+  __ lea(c_rarg0, field);\n+  __ get_method(c_rarg1);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                  c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+  __ pop_d(v0);\n+  __ popa();\n+}\n+\n+void TemplateTable::tsan_observe_get_or_put(const Address &field,\n+                                            Register flags,\n+                                            TsanMemoryReadWriteFunction tsan_function,\n+                                            TosState tos) {\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+\n+  TsanMemoryReleaseAcquireFunction releaseAcquireFunction =\n+      tsan_release_acquire_method(tsan_function);\n+\n+  Label done, notAcquireRelease;\n+\n+  \/\/ We could save some instructions by only saving the registers we need.\n+  __ pusha();\n+  \/\/ pusha() doesn't save v0, which tsan_function clobbers and the\n+  \/\/ interpreter still needs.\n+  \/\/ This really only needs to be done for some of the float\/double accesses,\n+  \/\/ but it's here because it's cleaner.\n+  __ push_d(v0);\n+  \/\/ For volatile reads\/writes use an acquire\/release.\n+  \/\/ If a reference is annotated to be ignored, assume it's safe to\n+  \/\/ access the object it's referring to and create a happens-before relation\n+  \/\/ between the accesses to this reference.\n+  if (tos == atos) {\n+    int32_t acquire_release_mask = 1 << ConstantPoolCacheEntry::is_volatile_shift |\n+      1 << ConstantPoolCacheEntry::is_tsan_ignore_shift;\n+    \/\/ acquire_release_mask (0x8200000) can not be encoded into 'tst', but it can be\n+    \/\/ encoded into just one 'mov' instruction.\n+    __ mov(rscratch1, acquire_release_mask);\n+    __ tst(flags, rscratch1);\n+    __ br(Assembler::EQ, notAcquireRelease);\n+  } else {\n+    __ tbz(flags, ConstantPoolCacheEntry::is_volatile_shift, notAcquireRelease);\n+  }\n+\n+  __ lea(c_rarg0, field);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);\n+  if (ThreadSanitizerJavaMemory) {\n+    __ b(done);\n+    __ bind(notAcquireRelease);\n+\n+    \/\/ Ignore reads\/writes to final fields. They can't be racy.\n+    __ tbnz(flags, ConstantPoolCacheEntry::is_final_shift, done);\n+\n+    \/\/ Don't report races on tsan ignored fields.\n+    __ tbnz(flags, ConstantPoolCacheEntry::is_tsan_ignore_shift, done);\n+\n+    __ lea(c_rarg0, field);\n+    __ get_method(c_rarg1);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                    c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+\n+    __ bind(done);\n+  } else {\n+    __ bind(notAcquireRelease);\n+  }\n+  __ pop_d(v0);\n+  __ popa();\n+}\n+\n+\n+#endif\n+\n@@ -762,1 +843,3 @@\n-  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -774,1 +857,3 @@\n-  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -786,1 +871,3 @@\n-  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -798,1 +885,3 @@\n-  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -810,4 +899,4 @@\n-  do_oop_load(_masm,\n-              Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),\n-              r0,\n-              IS_ARRAY);\n+  Address addr(r0, r1, Address::uxtw(LogBytesPerHeapOop));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, UseCompressedOops ? SharedRuntime::tsan_read4\n+                                                                       : SharedRuntime::tsan_read8));\n+  do_oop_load(_masm, addr, r0, IS_ARRAY);\n@@ -825,1 +914,3 @@\n-  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(0)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(0));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));\n+  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -837,1 +928,3 @@\n-  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(1));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -843,0 +936,3 @@\n+#ifdef ASSERT\n+  TSAN_RUNTIME_ONLY(__ stop(\"bytecode rewrite should have been disabled in TSAN\"););\n+#endif\n@@ -866,1 +962,3 @@\n-  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(1));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -1060,1 +1158,3 @@\n-  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg, noreg);\n@@ -1072,1 +1172,3 @@\n-  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg, noreg);\n@@ -1084,1 +1186,3 @@\n-  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg \/* ftos *\/, noreg, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg \/* ftos *\/, noreg, noreg, noreg);\n@@ -1096,1 +1200,3 @@\n-  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg \/* dtos *\/, noreg, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg \/* dtos *\/, noreg, noreg, noreg);\n@@ -1111,1 +1217,3 @@\n-\n+  \/\/ do tsan write after r4 has been defined.\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(element_address, UseCompressedOops ? SharedRuntime::tsan_write4\n+                                                                                  : SharedRuntime::tsan_write8));\n@@ -1173,1 +1281,3 @@\n-  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(0));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));\n+  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg, noreg);\n@@ -1186,1 +1296,3 @@\n-  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(1));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));\n+  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg, noreg);\n@@ -2306,0 +2418,10 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Draw a happens-before edge from the class's static initializer to\n+      \/\/ this lookup.\n+      __ pusha();\n+      __ mov(c_rarg0, obj);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                                       SharedRuntime::tsan_acquire),\n+                                       c_rarg0);\n+      __ popa();\n+    );\n@@ -2510,0 +2632,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, btos));\n@@ -2523,0 +2646,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, ztos));\n@@ -2536,0 +2660,5 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,\n+                                            raw_flags,\n+                                            UseCompressedOops ? SharedRuntime::tsan_read4\n+                                                              : SharedRuntime::tsan_read8,\n+                                            atos));\n@@ -2547,0 +2676,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, itos));\n@@ -2559,0 +2689,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, ctos));\n@@ -2571,0 +2702,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, stos));\n@@ -2583,0 +2715,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, ltos));\n@@ -2595,0 +2728,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, ftos));\n@@ -2609,0 +2743,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, dtos));\n@@ -2716,0 +2851,1 @@\n+  \/\/ save raw flags in r5\n@@ -2745,0 +2881,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, btos));\n@@ -2760,0 +2897,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, ztos));\n@@ -2775,0 +2913,5 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,\n+                                              r5,\n+                                              UseCompressedOops ? SharedRuntime::tsan_write4\n+                                                                : SharedRuntime::tsan_write8,\n+                                              atos));\n@@ -2791,0 +2934,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, itos));\n@@ -2806,0 +2950,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, ctos));\n@@ -2821,0 +2966,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, stos));\n@@ -2836,0 +2982,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, ltos));\n@@ -2851,0 +2998,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, ftos));\n@@ -2868,0 +3016,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, dtos));\n@@ -3041,0 +3190,3 @@\n+#ifdef ASSERT\n+  TSAN_RUNTIME_ONLY(__ stop(\"bytecode rewrite should have been disabled in TSAN\"););\n+#endif\n@@ -3134,0 +3286,3 @@\n+#ifdef ASSERT\n+  TSAN_RUNTIME_ONLY(__ stop(\"bytecode rewrite should have been disabled in TSAN\"););\n+#endif\n@@ -3600,0 +3755,8 @@\n+\n+     TSAN_RUNTIME_ONLY(\n+      \/\/ return value of new oop is in r0.\n+      __ push(atos);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj), r0);\n+      __ pop(atos);\n+    );\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":181,"deletions":18,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -1221,0 +1221,1 @@\n+  TSAN_RUNTIME_ONLY(push_ptr(lock_reg));\n@@ -1330,0 +1331,9 @@\n+\n+  TSAN_RUNTIME_ONLY(\n+    pop_ptr(lock_reg);\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_lock),\n+            lock_reg);\n+    popa();\n+  );\n@@ -1349,0 +1359,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_unlock),\n+            lock_reg);\n+    popa();\n+  );\n+\n@@ -2080,0 +2098,4 @@\n+  TSAN_RUNTIME_ONLY(call_VM(noreg,\n+                            CAST_FROM_FN_PTR(address,\n+                                             SharedRuntime::tsan_interp_method_entry)));\n+\n@@ -2117,0 +2139,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    push(state);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                                  SharedRuntime::tsan_interp_method_exit));\n+    pop(state);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2114,0 +2114,9 @@\n+  TSAN_RUNTIME_ONLY(\n+    \/\/ protect the args we've loaded\n+    save_args(masm, total_c_args, c_arg, out_regs);\n+    __ call_VM(noreg,\n+      CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_entry),\n+      r15_thread);\n+    restore_args(masm, total_c_args, c_arg, out_regs);\n+  );\n+\n@@ -2197,0 +2206,8 @@\n+\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg,\n+                 CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_lock),\n+                 obj_reg);\n+      __ popa();\n+    );\n@@ -2302,0 +2319,8 @@\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                                         SharedRuntime::tsan_oop_unlock),\n+                 obj_reg);\n+      __ popa();\n+    );\n+\n@@ -2346,0 +2371,8 @@\n+\n+  TSAN_RUNTIME_ONLY(\n+    save_native_result(masm, ret_type, stack_slots);\n+    __ call_VM_leaf(\n+         CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_exit));\n+    restore_native_result(masm, ret_type, stack_slots);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -771,0 +771,97 @@\n+#if INCLUDE_TSAN\n+\n+void TemplateTable::tsan_observe_get_or_put(\n+    const Address &field,\n+    Register flags,\n+    TsanMemoryReadWriteFunction tsan_function,\n+    TosState tos) {\n+  assert(flags == rdx, \"flags should be in rdx register\");\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+\n+  TsanMemoryReleaseAcquireFunction releaseAcquireFunction =\n+      tsan_release_acquire_method(tsan_function);\n+\n+  Label done, notAcquireRelease;\n+\n+  \/\/ We could save some instructions by only saving the registers we need.\n+  __ pusha();\n+  \/\/ pusha() doesn't save xmm0, which tsan_function clobbers and the\n+  \/\/ interpreter still needs.\n+  \/\/ This really only needs to be done for some of the float\/double accesses,\n+  \/\/ but it's here because it's cleaner.\n+  __ push_d(xmm0);\n+  DEBUG_ONLY(\n+    __ pusha();\n+    __ movptr(c_rarg0, field.base());\n+    __ leaq(c_rarg1, field);\n+    __ subq(c_rarg1, field.base());\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),\n+                    c_rarg0 \/* oop *\/, c_rarg1 \/* index *\/);\n+    __ popa();\n+  );\n+  \/\/ For volatile reads\/writes use an acquire\/release.\n+  \/\/ If a reference is annotated to be ignored, assume it's safe to\n+  \/\/ access the object it's referring to and create a happens-before relation\n+  \/\/ between the accesses to this reference.\n+  int32_t acquire_release_mask = 1 << ConstantPoolCacheEntry::is_volatile_shift |\n+      ((tos == atos) ? 1 << ConstantPoolCacheEntry::is_tsan_ignore_shift : 0);\n+  __ testl(flags, acquire_release_mask);\n+  __ jcc(Assembler::zero, notAcquireRelease);\n+\n+  __ leaq(c_rarg0, field);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);\n+  if (ThreadSanitizerJavaMemory) {\n+    __ jmp(done);\n+\n+    __ bind(notAcquireRelease);\n+    \/\/ Ignore reads\/writes to final fields. They can't be racy.\n+    int32_t ignore_mask = 1 << ConstantPoolCacheEntry::is_final_shift |\n+        1 << ConstantPoolCacheEntry::is_tsan_ignore_shift;\n+    __ testl(flags, ignore_mask);\n+    __ jcc(Assembler::notZero, done);\n+\n+    __ leaq(c_rarg0, field);\n+    __ get_method(c_rarg1);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                    c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+\n+    __ bind(done);\n+  } else {\n+    __ bind(notAcquireRelease);\n+  }\n+  __ pop_d(xmm0);\n+  __ popa();\n+}\n+\n+void TemplateTable::tsan_observe_load_or_store(\n+    const Address& field, TsanMemoryReadWriteFunction tsan_function) {\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+  if (!ThreadSanitizerJavaMemory) {\n+    return;\n+  }\n+  \/\/ We could save some instructions by only saving the registers we need.\n+  __ pusha();\n+  \/\/ pusha() doesn't save xmm0, which tsan_function clobbers and the\n+  \/\/ interpreter still needs.\n+  \/\/ This really only needs to be done for some of the float\/double accesses,\n+  \/\/ but it's here because it's cleaner.\n+  __ push_d(xmm0);\n+  DEBUG_ONLY(\n+    __ pusha();\n+    __ movptr(c_rarg0, field.base());\n+    __ leaq(c_rarg1, field);\n+    __ subq(c_rarg1, field.base());\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),\n+                    c_rarg0 \/* oop *\/, c_rarg1 \/* index *\/);\n+    __ popa();\n+  );\n+  __ leaq(c_rarg0, field);\n+  __ get_method(c_rarg1);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                  c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+  __ pop_d(xmm0);\n+  __ popa();\n+}\n+\n+#endif  \/\/ INCLUDE_TSAN\n+\n@@ -776,4 +873,4 @@\n-  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_4,\n-                            arrayOopDesc::base_offset_in_bytes(T_INT)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_INT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -789,4 +886,5 @@\n-  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg \/* ltos *\/,\n-                    Address(rdx, rbx, Address::times_8,\n-                            arrayOopDesc::base_offset_in_bytes(T_LONG)),\n-                    noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_LONG));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg \/* ltos *\/, addr, noreg,\n+                    noreg);\n@@ -802,5 +900,5 @@\n-  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg \/* ftos *\/,\n-                    Address(rdx, rax,\n-                            Address::times_4,\n-                            arrayOopDesc::base_offset_in_bytes(T_FLOAT)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_FLOAT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg \/* ftos *\/, addr, noreg,\n+                    noreg);\n@@ -814,5 +912,5 @@\n-  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg \/* dtos *\/,\n-                    Address(rdx, rax,\n-                            Address::times_8,\n-                            arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_DOUBLE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg \/* dtos *\/, addr, noreg,\n+                    noreg);\n@@ -826,6 +924,7 @@\n-  do_oop_load(_masm,\n-              Address(rdx, rax,\n-                      UseCompressedOops ? Address::times_4 : Address::times_ptr,\n-                      arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n-              rax,\n-              IS_ARRAY);\n+  Address addr(rdx, rax,\n+               UseCompressedOops ? Address::times_4 : Address::times_ptr,\n+               arrayOopDesc::base_offset_in_bytes(T_OBJECT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(\n+      addr, UseCompressedOops ? SharedRuntime::tsan_read4\n+                              : SharedRuntime::tsan_read8));\n+  do_oop_load(_masm, addr, rax, IS_ARRAY);\n@@ -839,3 +938,4 @@\n-  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_BYTE)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_1,\n+               arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));\n+  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -849,3 +949,4 @@\n-  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_2,\n+               arrayOopDesc::base_offset_in_bytes(T_CHAR));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -875,3 +976,4 @@\n-  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_SHORT)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_2,\n+               arrayOopDesc::base_offset_in_bytes(T_SHORT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -1069,4 +1171,4 @@\n-  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_4,\n-                             arrayOopDesc::base_offset_in_bytes(T_INT)),\n-                     rax, noreg, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_INT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg, noreg);\n@@ -1083,4 +1185,5 @@\n-  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY,\n-                     Address(rcx, rbx, Address::times_8,\n-                             arrayOopDesc::base_offset_in_bytes(T_LONG)),\n-                     noreg \/* ltos *\/, noreg, noreg, noreg);\n+  Address addr(rcx, rbx, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_LONG));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, noreg \/* ltos *\/, noreg,\n+                     noreg, noreg);\n@@ -1097,4 +1200,5 @@\n-  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_4,\n-                             arrayOopDesc::base_offset_in_bytes(T_FLOAT)),\n-                     noreg \/* ftos *\/, noreg, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_FLOAT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg \/* ftos *\/, noreg,\n+                     noreg, noreg);\n@@ -1110,4 +1214,5 @@\n-  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_8,\n-                             arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),\n-                     noreg \/* dtos *\/, noreg, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_DOUBLE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg \/* dtos *\/,\n+                     noreg, noreg, noreg);\n@@ -1128,0 +1233,4 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(\n+      element_address, UseCompressedOops ? SharedRuntime::tsan_write4\n+                                         : SharedRuntime::tsan_write8));\n+\n@@ -1186,4 +1295,4 @@\n-  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx,Address::times_1,\n-                             arrayOopDesc::base_offset_in_bytes(T_BYTE)),\n-                     rax, noreg, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_1,\n+               arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));\n+  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg, noreg);\n@@ -1199,4 +1308,4 @@\n-  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_2,\n-                             arrayOopDesc::base_offset_in_bytes(T_CHAR)),\n-                     rax, noreg, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_2,\n+               arrayOopDesc::base_offset_in_bytes(T_CHAR));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));\n+  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg, noreg);\n@@ -2720,0 +2829,10 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Draw a happens-before edge from the class's static initializer to\n+      \/\/ this lookup.\n+      __ pusha();\n+      __ movq(c_rarg0, obj);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                                       SharedRuntime::tsan_acquire),\n+                      c_rarg0);\n+      __ popa();\n+    );\n@@ -2883,0 +3002,5 @@\n+  \/\/ During a TSAN instrumented run, move flags into rdx so we can later\n+  \/\/ examine whether the field is volatile or has been annotated to be ignored\n+  \/\/ by Tsan.\n+  TSAN_RUNTIME_ONLY(__ movl(rdx, flags));\n+\n@@ -2895,0 +3019,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read1, btos));\n@@ -2908,0 +3034,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read1, ztos));\n@@ -2921,0 +3049,4 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, UseCompressedOops ? SharedRuntime::tsan_read4\n+                                    : SharedRuntime::tsan_read8,\n+      atos));\n@@ -2932,0 +3064,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read4, itos));\n@@ -2944,0 +3078,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read2, ctos));\n@@ -2956,0 +3092,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read2, stos));\n@@ -2970,0 +3108,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read8, ltos));\n@@ -2981,0 +3121,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read4, ftos));\n@@ -2997,0 +3139,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read8, dtos));\n@@ -3132,2 +3276,0 @@\n-  __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);\n-  __ andl(rdx, 0x1);\n@@ -3136,1 +3278,1 @@\n-  __ testl(rdx, rdx);\n+  __ testl(rdx, 1 << ConstantPoolCacheEntry::is_volatile_shift);\n@@ -3173,0 +3315,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write1, btos));\n@@ -3188,0 +3332,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write1, ztos));\n@@ -3203,0 +3349,4 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, rdx,\n+        UseCompressedOops ? SharedRuntime::tsan_write4\n+                          : SharedRuntime::tsan_write8,\n+        atos));\n@@ -3219,0 +3369,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write4, itos));\n@@ -3234,0 +3386,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write2, ctos));\n@@ -3249,0 +3403,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write2, stos));\n@@ -3264,0 +3420,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write8, ltos));\n@@ -3282,0 +3440,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write4, ftos));\n@@ -3300,0 +3460,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write8, dtos));\n@@ -4083,0 +4245,8 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ return value of new oop is in rax.\n+      __ push(atos);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj),\n+                      rax);\n+      __ pop(atos);\n+    );\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":230,"deletions":60,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -656,0 +656,23 @@\n+\n+#if (INCLUDE_TSAN) && defined(AARCH64)\n+  \/\/ Current TSAN memory mapping for 48bits aarch64, a large continuous space could be allocated between\n+  \/\/ kMidAppMemBeg = 0x0aaaa00000000ull and kMidAppMemEnd = 0x0aaaf00000000ull, which is only 20GB size.\n+  \/\/ Take 16GB here for safer allocation.\n+  const julong max_avail_vmspace = 16ULL * G; \/\/ 16GB\n+  const u8 msb_in_aarch64 = 47; \/\/ Only support 48-bits space now.\n+\n+  \/\/ Based on tsan memory mapping for 48bits aarch64,\n+  \/\/ libjvm.so will be loaded between kHiAppMemBeg = 0x0ffff00000000ull and kHiAppMemEnd = 0x1000000000000ull\n+  u8 vm_addr_u8 = reinterpret_cast<u8>(&__FUNCTION__);\n+  \/\/ High address in 48bits user space is like 0x0000ffffxxxxxxxx.\n+  assert((vm_addr_u8  >> msb_in_aarch64) == 0x1, \"warning: allocation could fail in non 48-bit address space.\");\n+\n+  if (result) {\n+    *limit = MIN2(*limit, max_avail_vmspace);\n+  } else {\n+    *limit = max_avail_vmspace;\n+  }\n+\n+  result = true;\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -636,1 +636,2 @@\n-  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+  \/\/ TODO: TSAN requires being built with Clang, but stack alignment assertion fails with Clang.\n+  \/\/ assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+#if INCLUDE_TSAN\n+#include \"classfile\/tsanIgnoreList.hpp\"\n+#endif \/\/ INCLUDE_TSAN\n@@ -948,0 +951,1 @@\n+    _field_TsanIgnore,\n@@ -985,0 +989,5 @@\n+\n+#if INCLUDE_TSAN\n+  void set_tsan_ignore(bool tsan_ignore) { set_annotation(_field_TsanIgnore); }\n+  bool is_tsan_ignore() const { return has_annotation(_field_TsanIgnore); }\n+#endif  \/\/ INCLUDE_TSAN\n@@ -1533,0 +1542,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      if (ThreadSanitizerIgnoreFile != NULL &&\n+          TsanIgnoreList::match(_class_name, name, type)) {\n+        parsed_annotations.set_tsan_ignore(true);\n+      }\n+    );\n+\n@@ -1953,0 +1969,8 @@\n+#if INCLUDE_TSAN\n+    case VM_SYMBOL_ENUM_NAME(java_util_concurrent_annotation_LazyInit): {\n+      if (_location != _in_field) {\n+        break;  \/\/ only allow for fields\n+      }\n+      return _field_TsanIgnore;\n+    }\n+#endif  \/\/ INCLUDE_TSAN\n@@ -1971,0 +1995,5 @@\n+  TSAN_RUNTIME_ONLY(\n+    if (is_tsan_ignore())\n+      (f->field_flags_addr())->update_tsan_ignore(true);\n+  );\n+\n@@ -5372,0 +5401,19 @@\n+#if INCLUDE_TSAN\n+  if (ThreadSanitizer && !ik->is_interface()) {\n+    ik->ensure_space_for_methodids(0);\n+    int num_methods = ik->methods()->length();\n+    for (int index = 0; index < num_methods; index++) {\n+      \/\/ Make sure each method has a jmethodID.\n+      \/\/ This allows us to avoid allocating jmethodIDs during program execution.\n+      jmethodID id = ik->methods()->at(index)->jmethod_id();\n+#ifdef ASSERT\n+      u8 id_u8 = reinterpret_cast<u8>(id);\n+      assert((id_u8 & right_n_bits(3)) == 0, \"jmethodID is not aligned\");\n+      AARCH64_ONLY(id_u8 >>= 36;\n+                   assert(id_u8 == 0 || id_u8 == 0xaaa || id_u8 == 0xfff, \"jmethodID is not aligned\");\n+                   )\n+#endif\n+    }\n+  }\n+#endif \/\/ INCLUDE_TSAN\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -236,0 +236,3 @@\n+  TSAN_RUNTIME_ONLY(\n+      SharedRuntime::tsan_track_obj_with_size(obj(), (int)_allocator._word_size);\n+  );\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -200,0 +200,1 @@\n+  LOG_TAG(tsan) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -124,1 +124,2 @@\n-                                       bool is_volatile) {\n+                                       bool is_volatile,\n+                                       bool is_tsan_ignore) {\n@@ -131,1 +132,2 @@\n-                  ((is_final    ? 1 : 0) << is_final_shift),\n+                  ((is_final    ? 1 : 0) << is_final_shift) |\n+                  ((is_tsan_ignore ? 1 : 0) << is_tsan_ignore_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,0 +101,3 @@\n+#if INCLUDE_TSAN\n+#include \"runtime\/sharedRuntime.hpp\"\n+#endif\n@@ -751,0 +754,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Construct a happens-before edge between the write of _init_state to\n+      \/\/ fully_initialized and here. Memory accesses from JNI native code\n+      \/\/ invoked from class static initializer may rely on this happens-before\n+      \/\/ edge to avoid reporting false positive data races.\n+      SharedRuntime::tsan_acquire(cast_from_oop<address>(java_mirror()));\n+    );\n@@ -1246,0 +1256,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    if (state == fully_initialized) {\n+      \/\/ Construct a happens-before edge between the write of _init_state to\n+      \/\/ fully_initialized and the later checking if it's initialized.\n+      SharedRuntime::tsan_release(cast_from_oop<address>(java_mirror()));\n+    }\n+  );\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -98,0 +98,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -3223,0 +3226,8 @@\n+\/\/ java.lang.ref.Finalizer \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+JVM_ENTRY(jboolean, JVM_GetTsanEnabled(JNIEnv *env))\n+  TSAN_ONLY(return ThreadSanitizer;)\n+  NOT_TSAN(return JNI_FALSE;)\n+JVM_END\n+\n+\n@@ -3491,1 +3502,3 @@\n-  return new PlatformMutex();\n+  void *mon = new PlatformMutex();\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(mon));\n+  return mon;\n@@ -3497,0 +3510,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(mon));\n@@ -3504,0 +3518,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(mon));\n@@ -3510,0 +3525,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(mon));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -82,0 +82,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -3658,0 +3661,4 @@\n+\/\/ Tsan note: The JVMTI raw monitors are instrumented at JvmtiRawMonitor call\n+\/\/ sites instead of inside the JvmtiRawMonitor implementation. This seems\n+\/\/ cleaner, and mirrors instrumentation of JVM_RawMonitor* functions.\n+\n@@ -3667,0 +3674,2 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(rmonitor));\n+\n@@ -3689,0 +3698,1 @@\n+        TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));\n@@ -3707,0 +3717,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(rmonitor));\n@@ -3729,0 +3740,1 @@\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));\n@@ -3747,0 +3759,1 @@\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));\n@@ -3760,0 +3773,4 @@\n+\n+  \/\/ A wait is modeled in Tsan as a simple release-acquire pair.\n+  \/\/ The matching release annotation is below.\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));\n@@ -3763,0 +3780,2 @@\n+  \/\/ The matching acquire annotation is above.\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -75,0 +78,16 @@\n+\/\/ Tsan should know that the JVMTI TagMap is protected by a mutex.\n+class TsanMutexScope : public StackObj {\n+ private:\n+  Mutex *_lock;  \/\/ Keep my own reference, for destructor.\n+\n+ public:\n+  \/\/ Don't actually lock it, just tell tsan we did.\n+  TsanMutexScope(Mutex* mutex) : _lock(mutex) {\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(_lock));\n+  }\n+\n+  ~TsanMutexScope() {\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(_lock));\n+  }\n+};\n+\n@@ -87,0 +106,18 @@\n+  \/\/ TSAN Note: we cannot tell TSAN about the creation of this lock due to\n+  \/\/ this being seen as racy though is not really.\n+  \/\/\n+  \/\/ The JvmtiTagMap gets created by the first thread to call tag_map_for; which\n+  \/\/ uses a lock to create it if need be.\n+  \/\/\n+  \/\/ This means that this lock is created under a mutex but then,\n+  \/\/ subsequent uses do not have a lock to protect it (because not\n+  \/\/ needed in this case), however TSAN sees it as being needed because:\n+  \/\/  - Another thread can come and get the newly created JvmtiTagMap without a\n+  \/\/  lock and acquire the lock.\n+  \/\/  - This provokes a race for TSAN on the lock itself, though there is no\n+  \/\/  real issue.\n+  \/\/\n+  \/\/  Not creating the lock or having a fence mechanism to tell TSAN this is\n+  \/\/  safe (a fake lock around this lock for example) seem to be the only\n+  \/\/  solutions.\n+\n@@ -95,1 +132,0 @@\n-\n@@ -103,0 +139,2 @@\n+\n+  \/\/ TSAN Note: see above for the Tsan creation note.\n@@ -332,0 +370,1 @@\n+  TSAN_ONLY(TsanMutexScope tms(lock()));\n@@ -357,0 +396,1 @@\n+  TSAN_ONLY(TsanMutexScope tms(lock()));\n@@ -856,0 +896,2 @@\n+  JvmtiTagMap* _tag_map;\n+\n@@ -857,2 +899,3 @@\n-  VM_HeapIterateOperation(ObjectClosure* blk, GrowableArray<jlong>* objects) :\n-    _blk(blk), _dead_objects(objects) { }\n+  VM_HeapIterateOperation(ObjectClosure* blk, GrowableArray<jlong>* objects,\n+                          JvmtiTagMap* tag_map) :\n+    _blk(blk), _dead_objects(objects), _tag_map(tag_map) { }\n@@ -862,0 +905,6 @@\n+    \/\/ Simulates barrier synchronization on safepoint.\n+    \/\/ This annotation is reasonably minimal in number of tsan callbacks.\n+    \/\/ By passing the lock directly, we are not actually locking it, just\n+    \/\/ telling TSAN we are to \"simulate\" the lock.\n+    TSAN_ONLY(TsanMutexScope tms(_tag_map->lock()));\n+\n@@ -1112,1 +1161,1 @@\n-    VM_HeapIterateOperation op(&blk, &dead_objects);\n+    VM_HeapIterateOperation op(&blk, &dead_objects, this);\n@@ -1139,1 +1188,1 @@\n-    VM_HeapIterateOperation op(&blk, &dead_objects);\n+    VM_HeapIterateOperation op(&blk, &dead_objects, this);\n@@ -1312,0 +1361,1 @@\n+    TSAN_ONLY(TsanMutexScope tms(lock()));\n@@ -2935,0 +2985,5 @@\n+  \/\/ This annotation is reasonably minimal in number of tsan callbacks.\n+  \/\/ By passing the lock directly, we are not actually locking it, just\n+  \/\/ telling TSAN we are to \"simulate\" the lock.\n+  TSAN_ONLY(TsanMutexScope tms(_tag_map->lock()));\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":60,"deletions":5,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -3958,0 +3958,11 @@\n+  TSAN_RUNTIME_ONLY(\n+    \/\/ Currently TSAN is only implemented for interpreter.\n+    set_mode_flags(_int);\n+    \/\/ TSAN instrumentation is not implemented for the RewriteBytecodes\n+    \/\/ code paths because TSAN slows down the application so much that the\n+    \/\/ performance benefits from rewriting bytecodes is negligible.\n+    FLAG_SET_ERGO(RewriteBytecodes, false);\n+    FLAG_SET_ERGO(RewriteFrequentPairs, false);\n+    \/\/ Turn off CDS, it interferes with eagerly allocating jmethodIDs.\n+    no_shared_spaces(\"CDS is not compatible with TSAN\");\n+  );\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1967,0 +1967,11 @@\n+  TSAN_ONLY(product(bool, ThreadSanitizer, false,                           \\\n+          \"Enable ThreadSanitizer lock instrumentation\"))                   \\\n+                                                                            \\\n+  TSAN_ONLY(product(bool, ThreadSanitizerJavaMemory, true,                  \\\n+          \"Detect Java data races with ThreadSanitizer. \"                   \\\n+          \"This is only enabled if -XX:+ThreadSanitizer is set.\"))          \\\n+                                                                            \\\n+  TSAN_ONLY(product(ccstr, ThreadSanitizerIgnoreFile, NULL,                 \\\n+          \"File containing a list of ignored field patterns for \"           \\\n+          \"ThreadSanitizer.\"))                                              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -127,0 +127,4 @@\n+#if INCLUDE_TSAN\n+Mutex*   TsanOopMap_lock              = NULL;\n+#endif\n+\n@@ -301,0 +305,4 @@\n+  TSAN_RUNTIME_ONLY(\n+    MUTEX_DEFN(TsanOopMap_lock               , PaddedMutex  , nosafepoint);\n+  );\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,0 +84,4 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsanExternalDecls.hpp\"\n+#include \"tsan\/tsanOopMap.hpp\"\n+#endif\n@@ -1087,0 +1091,173 @@\n+#if INCLUDE_TSAN\n+\n+JRT_LEAF(void, SharedRuntime::verify_oop_index(oopDesc* obj, int index))\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+  assert(index >= 0, \"index is less than 0\");\n+  int obj_size_in_bytes = obj->size() * HeapWordSize;\n+  assert(index < obj_size_in_bytes, \"index %d >= obj size %d\", index, obj_size_in_bytes);\n+JRT_END\n+\n+\/\/ TSAN: method entry callback from interpreter\n+\/\/ (1) In order to have the line numbers in the call stack, we use the caller\n+\/\/     address instead of the method that's being called. This also matches\n+\/\/     the entry\/exit convention that TSAN uses for C++.\n+\/\/ We use JRT_ENTRY since call_VM_leaf doesn't set _last_Java_sp that we need.\n+JRT_ENTRY(void, SharedRuntime::tsan_interp_method_entry(JavaThread* current))\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  DEBUG_ONLY(NoHandleMark nhm;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+\n+  RegisterMap unused_reg_map(current,\n+                             RegisterMap::UpdateMap::skip,\n+                             RegisterMap::ProcessFrames::include,\n+                             RegisterMap::WalkContinuation::skip);\n+\n+  \/\/ These asserts should be removed once\n+  \/\/ we support more than just the interpreter for TSAN.\n+  assert(!current->last_frame().is_compiled_frame(),\n+         \"Current frame should not be a compiled frame\");\n+  const frame sender = current->last_frame().real_sender(&unused_reg_map);\n+  assert(!sender.is_compiled_frame(), \"Sender should not be a compiled frame\");\n+\n+  jmethodID jmethod_id = 0;\n+  u2 bci = 0;\n+  \/\/ TODO: is (0, 0) really the best we can do\n+  \/\/ when the sender isn't an interpreted frame?\n+  if (sender.is_interpreted_frame()) {\n+    jmethod_id = sender.interpreter_frame_method()->find_jmethod_id_or_null();\n+    bci = sender.interpreter_frame_bci();\n+  }\n+  __tsan_func_entry(tsan_code_location(jmethod_id, bci));\n+JRT_END\n+\n+\/\/ TSAN: method exit callback from interpreter\n+JRT_LEAF(void, SharedRuntime::tsan_interp_method_exit())\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  __tsan_func_exit();\n+JRT_END\n+\n+void SharedRuntime::tsan_oop_lock(Thread* thread, oop obj) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+\n+  TsanOopMap::add_oop(obj);\n+  __tsan_java_mutex_lock((julong)(oopDesc*)obj);\n+}\n+\n+void SharedRuntime::tsan_oop_unlock(Thread *thread, oop obj) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+  assert(TsanOopMap::exists(obj), \"oop seen in unlock but not tracked\");\n+\n+  __tsan_java_mutex_unlock((julong)(oopDesc*)obj);\n+}\n+\n+void SharedRuntime::tsan_oop_rec_lock(Thread* thread, oop obj, int rec) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+\n+  TsanOopMap::add_oop(obj);\n+  __tsan_java_mutex_lock_rec((julong)(oopDesc*)obj, rec);\n+}\n+\n+int SharedRuntime::tsan_oop_rec_unlock(Thread *thread, oop obj) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+  assert(TsanOopMap::exists(obj), \"oop seen in unlock but not tracked\");\n+\n+  return __tsan_java_mutex_unlock_rec((julong)(oopDesc*)obj);\n+}\n+\n+JRT_LEAF(void, SharedRuntime::tsan_interp_lock(JavaThread* thread,\n+                                               BasicObjectLock* elem))\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+  assert(elem != NULL, \"null elem\");\n+\n+  oop obj = elem->obj();\n+  tsan_oop_lock(thread, obj);\n+\n+  assert(obj == elem->obj(), \"oop changed\");\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+JRT_END\n+\n+JRT_LEAF(void, SharedRuntime::tsan_interp_unlock(JavaThread* thread,\n+                                                 BasicObjectLock* elem))\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+  assert(elem != NULL, \"null elem\");\n+\n+  oop obj = elem->obj();\n+  tsan_oop_unlock(thread, obj);\n+\n+  assert(obj == elem->obj(), \"oop changed\");\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+JRT_END\n+\n+\/\/ Should be JRT_LEAF, but this is called very early during VM startup, so we\n+\/\/ are sometimes in '_thread_in_vm' state.\n+\/\/ NOTE: DO NOT add operations that can safepoint, enter GC, or throw an\n+\/\/ exception!\n+void SharedRuntime::tsan_track_obj_with_size(oopDesc* obj, int size) {\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(oopDesc::is_oop(obj), \"Bad oopDesc passed to tsan_track_obj_with_size().\");\n+  TsanOopMap::add_oop_with_size(obj, size);\n+}\n+\n+JRT_LEAF(void, SharedRuntime::tsan_track_obj(oopDesc* obj))\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(oopDesc::is_oop(obj), \"Bad oopDesc passed to tsan_track_obj().\");\n+  TsanOopMap::add_oop(obj);\n+JRT_END\n+\n+\/\/ TODO: Make tsan_acquire\/release JRT_LEAF\n+\/\/ Currently it can't be JRT_LEAF because there are calls from the VM\n+\/\/ (instanceKlass.cpp), and JRT_LEAF only allows calls from Java\/native code.\n+\/\/ We need to figure out a better way of being able to call TSAN functions from\n+\/\/ the VM.\n+void SharedRuntime::tsan_acquire(void* address) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(address != NULL, \"Cannot acquire at address 0\");\n+  __tsan_java_acquire(address);\n+}\n+\n+void SharedRuntime::tsan_release(void* address) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(address != NULL, \"Cannot release at address 0\");\n+  __tsan_java_release(address);\n+}\n+\n+#define TSAN_MEMORY_ACCESS(name)                                               \\\n+  JRT_LEAF(void, SharedRuntime::tsan_##name(                                   \\\n+      void* addr,                                                              \\\n+      Method* method,                                                          \\\n+      address bcp))                                                            \\\n+    assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");                      \\\n+    assert(ThreadSanitizerJavaMemory, \"Need -XX:+ThreadSanitizerJavaMemory\");  \\\n+    jmethodID mid = method->find_jmethod_id_or_null();                         \\\n+    int bci = method->bci_from(bcp);                                           \\\n+    __tsan_##name##_pc(addr, tsan_code_location(mid, bci));                    \\\n+  JRT_END\n+\n+TSAN_MEMORY_ACCESS(read1)\n+TSAN_MEMORY_ACCESS(read2)\n+TSAN_MEMORY_ACCESS(read4)\n+TSAN_MEMORY_ACCESS(read8)\n+TSAN_MEMORY_ACCESS(write1)\n+TSAN_MEMORY_ACCESS(write2)\n+TSAN_MEMORY_ACCESS(write4)\n+TSAN_MEMORY_ACCESS(write8)\n+\n+#endif \/\/ INCLUDE_TSAN\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":177,"deletions":0,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -672,0 +672,1 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(current, obj()));\n@@ -685,0 +686,1 @@\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(current, obj));\n@@ -700,0 +702,1 @@\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));\n@@ -705,0 +708,1 @@\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));\n@@ -724,0 +728,7 @@\n+\n+  TSAN_ONLY(int tsan_rec = 0;)\n+  TSAN_RUNTIME_ONLY(\n+    tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());\n+    assert(tsan_rec > 0, \"tsan: unlocking unlocked mutex\");\n+  );\n+\n@@ -726,0 +737,2 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));\n+\n@@ -1784,0 +1797,4 @@\n+    \/\/ Note well -- this occurs ONLY on thread exit, and is a last ditch\n+    \/\/ effort to release all locks. Hence, we don't need to record tsan's\n+    \/\/ recursion count -- it will never be locked again.\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_unlock(_thread, (oop)mid->object()));\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import jdk.test.lib.management.InputArguments;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * Tsan Test Runner, which basically adds the VM options and runs a class name as a new\n+ * ProcessBuilder; returning the OutputAnalyzer of the process.\n+ *\/\n+public class TsanRunner {\n+  public static OutputAnalyzer runTsanTest(Class<?> klass, String... vmArgs) throws IOException {\n+    ArrayList<String> vmOpts = new ArrayList<>();\n+\n+    \/\/ Pass all VM options passed to this process, which include\n+    \/\/ all JTREG's system properties, and VM options from \"test.vm.opts\"\n+    \/\/ system property and from @run tag.\n+    String[] vmInputArgs = InputArguments.getVmInputArgs();\n+    Collections.addAll(vmOpts, vmInputArgs);\n+\n+    Collections.addAll(vmOpts, vmArgs);\n+    vmOpts.add(\"-XX:+ThreadSanitizer\");\n+    vmOpts.add(klass.getName());\n+\n+    ProcessBuilder pb =\n+        ProcessTools.createLimitedTestJavaProcessBuilder(vmOpts.toArray(new String[0]));\n+    return new OutputAnalyzer(pb.start());\n+  }\n+\n+  public static OutputAnalyzer runTsanTestExpectSuccess(\n+      Class<?> klass, String... vmArgs) throws IOException {\n+    return runTsanTest(klass, vmArgs)\n+        .shouldHaveExitValue(0)\n+        .shouldNotContain(\"WARNING: ThreadSanitizer: data race\");\n+  }\n+\n+  public static OutputAnalyzer runTsanTestExpectFailure(\n+      Class<?> klass, String... vmArgs) throws IOException {\n+    return runTsanTest(klass, vmArgs)\n+        .shouldHaveExitValue(66);\n+  }\n+\n+  public static OutputAnalyzer runTsanTestExpectSuccess(Class<?> klass) throws IOException {\n+    return runTsanTestExpectSuccess(klass, new String[0]);\n+  }\n+\n+  public static OutputAnalyzer runTsanTestExpectFailure(Class<?> klass) throws IOException {\n+    return runTsanTestExpectFailure(klass, new String[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/TsanRunner.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}