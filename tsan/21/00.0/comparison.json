{"files":[{"patch":"@@ -5,1 +5,1 @@\n-version=21\n+version=21.0.3\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,2 @@\n-      printf \"%.0f\", c; \\\n+      c = c + 0.5; \\\n+      printf \"%d\", c; \\\n@@ -359,1 +360,1 @@\n-    $(subst .sh,,$(subst .html,,$(subst .java,,$(suffix $(notdir $1)))))\n+    $(subst .jasm,,$(subst .sh,,$(subst .html,,$(subst .java,,$(suffix $(notdir $1))))))\n@@ -812,0 +813,1 @@\n+  # The minidumps are disabled by default on client Windows, so enable them\n@@ -814,0 +816,1 @@\n+    $1_JTREG_BASIC_OPTIONS += -vmoption:-XX:+CreateCoredumpOnCrash\n@@ -872,1 +875,1 @@\n-  clean-workdir-$1:\n+  clean-outputdirs-$1:\n@@ -874,0 +877,1 @@\n+\t$$(RM) -r $$($1_TEST_RESULTS_DIR)\n@@ -876,1 +880,1 @@\n-      $$(JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \\\n+      $$(JTREG_JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \\\n@@ -919,1 +923,1 @@\n-  run-test-$1: pre-run-test clean-workdir-$1\n+  run-test-$1: pre-run-test clean-outputdirs-$1\n@@ -956,1 +960,1 @@\n-  $1: run-test-$1 parse-test-$1 clean-workdir-$1\n+  $1: run-test-$1 parse-test-$1 clean-outputdirs-$1\n@@ -958,1 +962,1 @@\n-  TARGETS += $1 run-test-$1 parse-test-$1 clean-workdir-$1\n+  TARGETS += $1 run-test-$1 parse-test-$1 clean-outputdirs-$1\n","filename":"make\/RunTests.gmk","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,5 @@\n+        ],\n+        IF_TRUE: [\n+            # Add debug prefix map gcc system include paths, as they cause\n+            # non-deterministic debug paths depending on gcc path location.\n+            DEBUG_PREFIX_MAP_GCC_INCLUDE_PATHS\n@@ -161,0 +166,49 @@\n+# gcc will embed the full system include paths in the debug info\n+# resulting in non-deterministic debug symbol files and thus\n+# non-reproducible native libraries if gcc includes are located\n+# in different paths.\n+# Add -fdebug-prefix-map'ings for root and gcc include paths,\n+# pointing to a common set of folders so that the binaries are deterministic:\n+#  root include : \/usr\/include\n+#  gcc include  : \/usr\/local\/gcc_include\n+#  g++ include  : \/usr\/local\/gxx_include\n+AC_DEFUN([DEBUG_PREFIX_MAP_GCC_INCLUDE_PATHS],\n+[\n+    # Determine gcc system include paths.\n+    # Assume default roots to start with:\n+    GCC_ROOT_INCLUDE=\"\/usr\/include\"\n+\n+    # Determine is sysroot or devkit specified?\n+    if test \"x$SYSROOT\" != \"x\"; then\n+      GCC_ROOT_INCLUDE=\"${SYSROOT%\/}\/usr\/include\"\n+    fi\n+\n+    # Add root include mapping => \/usr\/include\n+    GCC_INCLUDE_DEBUG_MAP_FLAGS=\"-fdebug-prefix-map=${GCC_ROOT_INCLUDE}\/=\/usr\/include\/\"\n+\n+    # Add gcc system include mapping => \/usr\/local\/gcc_include\n+    #   Find location of stddef.h using build C compiler\n+    GCC_SYSTEM_INCLUDE=`$ECHO \"#include <stddef.h>\" | \\\n+                        $CC $CFLAGS -v -E - 2>&1 | \\\n+                        $GREP stddef | $TAIL -1 | $TR -s \" \" | $CUT -d'\"' -f2`\n+    if test \"x$GCC_SYSTEM_INCLUDE\" != \"x\"; then\n+      GCC_SYSTEM_INCLUDE=`$DIRNAME $GCC_SYSTEM_INCLUDE`\n+      GCC_INCLUDE_DEBUG_MAP_FLAGS=\"$GCC_INCLUDE_DEBUG_MAP_FLAGS \\\n+          -fdebug-prefix-map=${GCC_SYSTEM_INCLUDE}\/=\/usr\/local\/gcc_include\/\"\n+    fi\n+\n+    # Add g++ system include mapping => \/usr\/local\/gxx_include\n+    #   Find location of cstddef using build C++ compiler\n+    GXX_SYSTEM_INCLUDE=`$ECHO \"#include <cstddef>\" | \\\n+                        $CXX $CXXFLAGS -v -E -x c++ - 2>&1 | \\\n+                        $GREP cstddef | $TAIL -1 | $TR -s \" \" | $CUT -d'\"' -f2`\n+    if test \"x$GXX_SYSTEM_INCLUDE\" != \"x\"; then\n+      GXX_SYSTEM_INCLUDE=`$DIRNAME $GXX_SYSTEM_INCLUDE`\n+      GCC_INCLUDE_DEBUG_MAP_FLAGS=\"$GCC_INCLUDE_DEBUG_MAP_FLAGS \\\n+          -fdebug-prefix-map=${GXX_SYSTEM_INCLUDE}\/=\/usr\/local\/gxx_include\/\"\n+    fi\n+\n+    # Add to debug prefix cflags\n+    DEBUG_PREFIX_CFLAGS=\"$DEBUG_PREFIX_CFLAGS $GCC_INCLUDE_DEBUG_MAP_FLAGS\"\n+])\n+\n@@ -436,1 +490,1 @@\n-    CFLAGS_OS_DEF_JVM=\"-DLINUX\"\n+    CFLAGS_OS_DEF_JVM=\"-DLINUX -D_FILE_OFFSET_BITS=64\"\n@@ -833,0 +887,1 @@\n+    AC_SUBST(REPRODUCIBLE_CFLAGS)\n@@ -866,0 +921,16 @@\n+      if test \"x$FILE_MACRO_CFLAGS\" != x; then\n+        # Add -pathmap for all VS system include paths using Windows\n+        # full Long path name that is generated by the compiler\n+        # Not enabled under WSL as there is no easy way to obtain the\n+        # Windows full long paths, thus reproducible WSL builds will\n+        # depend on building with the same VS toolchain install location.\n+        if test \"x$OPENJDK_BUILD_OS_ENV\" != \"xwindows.wsl1\" && test \"x$OPENJDK_BUILD_OS_ENV\" != \"xwindows.wsl2\"; then\n+          for ipath in ${$3SYSROOT_CFLAGS}; do\n+              if test \"x${ipath:0:2}\" == \"x-I\"; then\n+                  ipath_path=${ipath#\"-I\"}\n+                  UTIL_FIXUP_WIN_LONG_PATH(ipath_path)\n+                  FILE_MACRO_CFLAGS=\"$FILE_MACRO_CFLAGS -pathmap:\\\"$ipath_path\\\"=vsi\"\n+              fi\n+          done\n+        fi\n+      fi\n","filename":"make\/autoconf\/flags-cflags.m4","additions":73,"deletions":2,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+JDK_RC_COMPANY_NAME:=@JDK_RC_COMPANY_NAME@\n@@ -427,0 +428,1 @@\n+REPRODUCIBLE_CFLAGS := @REPRODUCIBLE_CFLAGS@\n@@ -604,0 +606,1 @@\n+NMFLAGS:=@NMFLAGS@\n@@ -681,0 +684,3 @@\n+JTREG_JDK := @JTREG_JDK@\n+JTREG_JAVA = @FIXPATH@ $(JTREG_JDK)\/bin\/java $(JAVA_FLAGS_BIG) $(JAVA_FLAGS)\n+\n","filename":"make\/autoconf\/spec.gmk.in","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-    const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+    const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -695,0 +695,6 @@\n+    \/\/ check if already enabled - if so no re-enabling needed\n+    assert(sizeof(StackOverflow::StackGuardState) == 4, \"unexpected size\");\n+    ldrw(rscratch1, Address(rthread, JavaThread::stack_guard_state_offset()));\n+    cmpw(rscratch1, (u1)StackOverflow::stack_guard_enabled);\n+    br(Assembler::EQ, no_reserved_zone_enabling);\n+\n@@ -728,1 +734,1 @@\n-\/\/      c_rarg0, c_rarg1, c_rarg2, c_rarg3, .. (param regs)\n+\/\/      c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, .. (param regs)\n@@ -746,0 +752,2 @@\n+    const Register tmp2 = c_rarg4;\n+    const Register tmp3 = c_rarg5;\n@@ -766,1 +774,1 @@\n-      fast_lock(obj_reg, tmp, rscratch1, rscratch2, slow_case);\n+      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -881,0 +889,1 @@\n+    const Register tmp_reg    = c_rarg4;  \/\/ Temporary used by lightweight_unlock\n@@ -914,1 +923,1 @@\n-      fast_unlock(obj_reg, header_reg, swap_reg, rscratch1, slow_case);\n+      lightweight_unlock(obj_reg, header_reg, swap_reg, tmp_reg, slow_case);\n@@ -1694,1 +1703,1 @@\n-  assert_different_registers(obj, rscratch1);\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n@@ -1716,1 +1725,0 @@\n-  ldr(rscratch1, mdo_addr);\n@@ -1720,2 +1728,2 @@\n-  \/\/ There is a chance that the checks above (re-reading profiling\n-  \/\/ data from memory) fail if another thread has just set the\n+  \/\/ There is a chance that the checks above\n+  \/\/ fail if another thread has just set the\n@@ -1723,0 +1731,1 @@\n+  eor(obj, obj, rscratch1); \/\/ get back original value before XOR\n@@ -1735,0 +1744,4 @@\n+#ifdef ASSERT\n+  andr(obj, obj, TypeEntries::type_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1771,0 +1771,1 @@\n+  const Register lock_tmp = r14;  \/\/ Temporary used by lightweight_lock\/unlock\n@@ -1824,1 +1825,1 @@\n-      __ fast_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -1981,1 +1982,1 @@\n-      __ fast_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, lock_tmp, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3979,1 +3979,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -4082,1 +4082,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,6 @@\n+#ifdef _LP64\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+  assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+\n@@ -58,0 +64,4 @@\n+  testptr(mdo_addr, TypeEntries::null_seen);\n+  jccb(Assembler::notZero, next); \/\/ null already seen. Nothing to do anymore.\n+  \/\/ atomic update to prevent overwriting Klass* with 0\n+  lock();\n@@ -63,0 +73,3 @@\n+#ifdef _LP64\n+  mov(rscratch1, obj);\n+#endif\n@@ -77,0 +90,1 @@\n+#ifdef _LP64\n@@ -80,0 +94,1 @@\n+  mov(obj, rscratch1);\n@@ -83,0 +98,1 @@\n+#endif\n@@ -91,0 +107,4 @@\n+#ifdef ASSERT\n+  andptr(obj, TypeEntries::type_klass_mask);\n+  verify_klass_ptr(obj);\n+#endif\n@@ -1077,1 +1097,1 @@\n-    const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+    const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -1153,0 +1173,2 @@\n+    \/\/ check if already enabled - if so no re-enabling needed\n+    assert(sizeof(StackOverflow::StackGuardState) == 4, \"unexpected size\");\n@@ -1236,1 +1258,1 @@\n-      fast_lock_impl(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n+      lightweight_lock(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1383,1 +1405,1 @@\n-      fast_unlock_impl(obj_reg, swap_reg, header_reg, slow_case);\n+      lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2199,1 +2199,1 @@\n-      __ fast_lock_impl(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n@@ -2359,1 +2359,1 @@\n-      __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4492,1 +4492,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -4589,1 +4589,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"os_aix.hpp\"\n@@ -296,0 +297,1 @@\n+  static_assert(sizeof(off_t) == 8, \"Expected Large File Support in this file\");\n@@ -759,2 +761,4 @@\n-  int res = ::dlclose(lib);\n-  if (res == 0) {\n+  char ebuf[1024];\n+  bool res = os::pd_dll_unload(lib, ebuf, sizeof(ebuf));\n+\n+  if (res) {\n@@ -766,6 +770,1 @@\n-    const char* error_report = ::dlerror();\n-    if (error_report == nullptr) {\n-      error_report = \"dlerror returned no error description\";\n-    }\n-\n-                            l_path, p2i(lib), error_report);\n+                            l_path, p2i(lib), ebuf);\n@@ -774,1 +773,1 @@\n-                  l_path, p2i(lib), error_report);\n+                  l_path, p2i(lib), ebuf);\n@@ -776,2 +775,0 @@\n-  \/\/ Update the dll cache\n-  AIX_ONLY(LoadedLibraries::reload());\n@@ -782,1 +779,1 @@\n-  return (jlong) BSD_ONLY(::lseek) NOT_BSD(::lseek64)(fd, offset, whence);\n+  return (jlong) AIX_ONLY(::lseek64) NOT_AIX(::lseek)(fd, offset, whence);\n@@ -786,1 +783,1 @@\n-   return BSD_ONLY(::ftruncate) NOT_BSD(::ftruncate64)(fd, length);\n+   return AIX_ONLY(::ftruncate64) NOT_AIX(::ftruncate)(fd, length);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -574,1 +574,1 @@\n-  print_instructions(st, pc, sizeof(char));\n+  print_instructions(st, pc);\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4353,0 +4353,1 @@\n+        return;\n@@ -4360,0 +4361,1 @@\n+        return;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -406,9 +406,0 @@\n-MemRegion ObjArrayAllocator::obj_memory_range(oop obj) const {\n-  if (_do_zero) {\n-    return MemAllocator::obj_memory_range(obj);\n-  }\n-  ArrayKlass* array_klass = ArrayKlass::cast(_klass);\n-  const size_t hs = arrayOopDesc::header_size(array_klass->element_type());\n-  return MemRegion(cast_from_oop<HeapWord*>(obj) + hs, _word_size - hs);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+  LOG_TAG(trimnative) \/* trim native heap *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -854,1 +854,1 @@\n-\n+  ResourceMark rm(THREAD);\n@@ -856,1 +856,1 @@\n-  Symbol* message = java_lang_Throwable::detail_message(PENDING_EXCEPTION);\n+  const char* message = java_lang_Throwable::message_as_utf8(PENDING_EXCEPTION);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -781,0 +781,2 @@\n+  bool debug_logging_enabled = log_is_enabled(Debug, class, init);\n+\n@@ -783,0 +785,5 @@\n+    if (debug_logging_enabled) {\n+      ResourceMark rm(current);\n+      log_debug(class, init)(\"Thread \\\"%s\\\" waiting for linking of %s by thread \\\"%s\\\"\",\n+                             current->name(), external_name(), init_thread_name());\n+    }\n@@ -788,0 +795,5 @@\n+    if (debug_logging_enabled) {\n+      ResourceMark rm(current);\n+      log_debug(class, init)(\"Thread \\\"%s\\\" recursively linking %s\",\n+                             current->name(), external_name());\n+    }\n@@ -793,0 +805,5 @@\n+    if (debug_logging_enabled) {\n+      ResourceMark rm(current);\n+      log_debug(class, init)(\"Thread \\\"%s\\\" linking %s\",\n+                             current->name(), external_name());\n+    }\n@@ -795,0 +812,6 @@\n+  } else {\n+    if (debug_logging_enabled) {\n+      ResourceMark rm(current);\n+      log_debug(class, init)(\"Thread \\\"%s\\\" found %s already linked\",\n+                             current->name(), external_name());\n+      }\n@@ -1060,0 +1083,2 @@\n+  bool debug_logging_enabled = log_is_enabled(Debug, class, init);\n+\n@@ -1063,1 +1088,1 @@\n-    MonitorLocker ml(THREAD, _init_monitor);\n+    MonitorLocker ml(jt, _init_monitor);\n@@ -1067,0 +1092,6 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" waiting for initialization of %s by thread \\\"%s\\\"\",\n+                               jt->name(), external_name(), init_thread_name());\n+      }\n+\n@@ -1075,0 +1106,5 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" recursively initializing %s\",\n+                               jt->name(), external_name());\n+      }\n@@ -1081,0 +1117,5 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" found %s already initialized\",\n+                               jt->name(), external_name());\n+      }\n@@ -1087,0 +1128,5 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" found %s is in error state\",\n+                               jt->name(), external_name());\n+      }\n@@ -1093,0 +1139,5 @@\n+      if (debug_logging_enabled) {\n+        ResourceMark rm(jt);\n+        log_debug(class, init)(\"Thread \\\"%s\\\" is initializing %s\",\n+                               jt->name(), external_name());\n+      }\n@@ -1574,1 +1625,3 @@\n-    ls.print_cr(\"%s (\" PTR_FORMAT \")\", h_method() == nullptr ? \"(no method)\" : \"\", p2i(this));\n+    ls.print_cr(\"%s (\" PTR_FORMAT \") by thread \\\"%s\\\"\",\n+                h_method() == nullptr ? \"(no method)\" : \"\", p2i(this),\n+                THREAD->name());\n@@ -4080,0 +4133,17 @@\n+\/\/ This nulls out jmethodIDs for all methods in 'klass'\n+\/\/ It needs to be called explicitly for all previous versions of a class because these may not be cleaned up\n+\/\/ during class unloading.\n+\/\/ We can not use the jmethodID cache associated with klass directly because the 'previous' versions\n+\/\/ do not have the jmethodID cache filled in. Instead, we need to lookup jmethodID for each method and this\n+\/\/ is expensive - O(n) for one jmethodID lookup. For all contained methods it is O(n^2).\n+\/\/ The reason for expensive jmethodID lookup for each method is that there is no direct link between method and jmethodID.\n+void InstanceKlass::clear_jmethod_ids(InstanceKlass* klass) {\n+  Array<Method*>* method_refs = klass->methods();\n+  for (int k = 0; k < method_refs->length(); k++) {\n+    Method* method = method_refs->at(k);\n+    if (method != nullptr && method->is_obsolete()) {\n+      method->clear_jmethod_id();\n+    }\n+  }\n+}\n+\n@@ -4123,0 +4193,1 @@\n+      clear_jmethod_ids(pv_node); \/\/ jmethodID maintenance for the unloaded class\n@@ -4342,1 +4413,0 @@\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":73,"deletions":3,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1391,3 +1391,2 @@\n-      if ((holder == resolver.Carrier_klass\n-           || holder == vmClasses::VirtualThread_klass()\n-           || holder == vmClasses::Thread_klass())) {\n+      if (holder == vmClasses::Thread_klass()\n+          || holder == resolver.Carrier_klass) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1015,1 +1015,1 @@\n-  if (!JvmtiExport::can_support_virtual_threads()) {\n+  if (get_capabilities()->can_support_virtual_threads == 0) {\n@@ -1133,1 +1133,1 @@\n-  if (!JvmtiExport::can_support_virtual_threads()) {\n+  if (get_capabilities()->can_support_virtual_threads == 0) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2373,1 +2373,4 @@\n-        jvf->cb()->as_nmethod()->oops_do(_blk);\n+        \/\/ Need to apply load barriers for unmounted vthreads.\n+        nmethod* nm = jvf->cb()->as_nmethod();\n+        nm->run_nmethod_entry_barrier();\n+        nm->oops_do(_blk);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1907,2 +1907,1 @@\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n@@ -1915,9 +1914,0 @@\n-  if (UseHeavyMonitors) {\n-    if (FLAG_IS_CMDLINE(LockingMode) && LockingMode != LM_MONITOR) {\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"Conflicting -XX:+UseHeavyMonitors and -XX:LockingMode=%d flags\", LockingMode);\n-      return false;\n-    }\n-    FLAG_SET_CMDLINE(LockingMode, LM_MONITOR);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -298,0 +298,3 @@\n+  product(size_t, InlineCacheBufferSize, 10*K, EXPERIMENTAL,                \\\n+          \"InlineCacheBuffer size\")                                         \\\n+                                                                            \\\n@@ -1053,4 +1056,0 @@\n-  develop(bool, UseHeavyMonitors, false,                                    \\\n-          \"(Deprecated) Use heavyweight instead of lightweight Java \"       \\\n-          \"monitors\")                                                       \\\n-                                                                            \\\n@@ -1059,1 +1058,1 @@\n-          \"+UseHeavyMonitors\")                                              \\\n+          \"-XX:LockingMode=0 (LM_MONITOR)\")                                 \\\n@@ -1990,0 +1989,7 @@\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 0,                                  \\\n+          \"Interval, in ms, at which the JVM will trim the native heap if \" \\\n+          \"the platform supports that. Lower values will reclaim memory \"   \\\n+          \"more eagerly at the cost of higher overhead. A value of 0 \"      \\\n+          \"(default) disables native heap trimming.\")                       \\\n+          range(0, UINT_MAX)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -231,2 +231,2 @@\n-\n-    MUTEX_DEFN(MonitoringSupport_lock        , PaddedMutex  , service-1);      \/\/ used for serviceability monitoring support\n+  MUTEX_DEFN(MonitoringSupport_lock          , PaddedMutex  , service-1);        \/\/ used for serviceability monitoring support\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2052,1 +2052,2 @@\n-  if (caller.is_compiled_frame() && !caller.is_deoptimized_frame()) {\n+  if ((caller.is_compiled_frame() && !caller.is_deoptimized_frame()) ||\n+      (caller.is_native_frame() && ((CompiledMethod*)caller.cb())->method()->is_continuation_enter_intrinsic())) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -57,0 +57,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -1656,2 +1657,2 @@\n-    SuspendibleThreadSet::synchronize();\n-    SuspendibleThreadSet::desynchronize();\n+    Universe::heap()->safepoint_synchronize_begin();\n+    Universe::heap()->safepoint_synchronize_end();\n@@ -1661,2 +1662,4 @@\n-static size_t delete_monitors(GrowableArray<ObjectMonitor*>* delete_list) {\n-  size_t count = 0;\n+static size_t delete_monitors(Thread* current, GrowableArray<ObjectMonitor*>* delete_list,\n+                              LogStream* ls, elapsedTimer* timer_p) {\n+  NativeHeapTrimmer::SuspendMark sm(\"monitor deletion\");\n+  size_t deleted_count = 0;\n@@ -1665,1 +1668,6 @@\n-    count++;\n+    deleted_count++;\n+    if (current->is_Java_thread()) {\n+      \/\/ A JavaThread must check for a safepoint\/handshake and honor it.\n+      ObjectSynchronizer::chk_for_block_req(JavaThread::cast(current), \"deletion\", \"deleted_count\",\n+                                            deleted_count, ls, timer_p);\n+    }\n@@ -1667,1 +1675,1 @@\n-  return count;\n+  return deleted_count;\n@@ -1745,24 +1753,1 @@\n-    if (current->is_Java_thread()) {\n-      if (ls != NULL) {\n-        timer.stop();\n-        ls->print_cr(\"before setting blocked: unlinked_count=\" SIZE_FORMAT\n-                     \", in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\"\n-                     SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     unlinked_count, in_use_list_ceiling(),\n-                     _in_use_list.count(), _in_use_list.max());\n-      }\n-      \/\/ Mark the calling JavaThread blocked (safepoint safe) while we free\n-      \/\/ the ObjectMonitors so we don't delay safepoints whilst doing that.\n-      ThreadBlockInVM tbivm(JavaThread::cast(current));\n-      if (ls != NULL) {\n-        ls->print_cr(\"after setting blocked: in_use_list stats: ceiling=\"\n-                     SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     in_use_list_ceiling(), _in_use_list.count(), _in_use_list.max());\n-        timer.start();\n-      }\n-      deleted_count = delete_monitors(&delete_list);\n-      \/\/ ThreadBlockInVM is destroyed here\n-    } else {\n-      \/\/ A non-JavaThread can just free the ObjectMonitors:\n-      deleted_count = delete_monitors(&delete_list);\n-    }\n+    deleted_count = delete_monitors(current, &delete_list, ls, &timer);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":16,"deletions":31,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        ProcessTools.createJavaProcessBuilder(vmOpts.toArray(new String[0]));\n+        ProcessTools.createLimitedTestJavaProcessBuilder(vmOpts.toArray(new String[0]));\n","filename":"test\/hotspot\/jtreg\/tsan\/TsanRunner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}