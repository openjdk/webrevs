{"files":[{"patch":"@@ -54,78 +54,0 @@\n-  class TsanOopBitMap : public CHeapBitMap {\n-    public:\n-      TsanOopBitMap() : CHeapBitMap(mtInternal) {}\n-      TsanOopBitMap(idx_t size_in_bits) : CHeapBitMap(size_in_bits, mtInternal) {}\n-\n-      \/\/ Following functions are from JDK 11 BitMap. They no longer exist in JDK 21.\n-      static idx_t word_index(idx_t bit)  { return bit >> LogBitsPerWord; }\n-      static idx_t word_align_up(idx_t bit) {\n-        return align_up(bit, BitsPerWord);\n-      }\n-      static bool is_word_aligned(idx_t bit) {\n-        return word_align_up(bit) == bit;\n-      }\n-\n-      \/\/ This is from JDK 11 BitMap.\n-      idx_t get_next_one_offset(idx_t l_offset, idx_t r_offset) const {\n-        assert(l_offset <= size(), \"BitMap index out of bounds\");\n-        assert(r_offset <= size(), \"BitMap index out of bounds\");\n-        assert(l_offset <= r_offset, \"l_offset > r_offset ?\");\n-\n-        if (l_offset == r_offset) {\n-          return l_offset;\n-        }\n-        idx_t   index = word_index(l_offset);\n-        idx_t r_index = word_index(r_offset-1) + 1;\n-        idx_t res_offset = l_offset;\n-\n-        \/\/ check bits including and to the _left_ of offset's position\n-        idx_t pos = bit_in_word(res_offset);\n-        bm_word_t res = map(index) >> pos;\n-        if (res != 0) {\n-          \/\/ find the position of the 1-bit\n-          for (; !(res & 1); res_offset++) {\n-            res = res >> 1;\n-          }\n-\n-#ifdef ASSERT\n-          \/\/ In the following assert, if r_offset is not bitamp word aligned,\n-          \/\/ checking that res_offset is strictly less than r_offset is too\n-          \/\/ strong and will trip the assert.\n-          \/\/\n-          \/\/ Consider the case where l_offset is bit 15 and r_offset is bit 17\n-          \/\/ of the same map word, and where bits [15:16:17:18] == [00:00:00:01].\n-          \/\/ All the bits in the range [l_offset:r_offset) are 0.\n-          \/\/ The loop that calculates res_offset, above, would yield the offset\n-          \/\/ of bit 18 because it's in the same map word as l_offset and there\n-          \/\/ is a set bit in that map word above l_offset (i.e. res != NoBits).\n-          \/\/\n-          \/\/ In this case, however, we can assert is that res_offset is strictly\n-          \/\/ less than size() since we know that there is at least one set bit\n-          \/\/ at an offset above, but in the same map word as, r_offset.\n-          \/\/ Otherwise, if r_offset is word aligned then it will not be in the\n-          \/\/ same map word as l_offset (unless it equals l_offset). So either\n-          \/\/ there won't be a set bit between l_offset and the end of it's map\n-          \/\/ word (i.e. res == NoBits), or res_offset will be less than r_offset.\n-\n-          idx_t limit = is_word_aligned(r_offset) ? r_offset : size();\n-          assert(res_offset >= l_offset && res_offset < limit, \"just checking\");\n-#endif \/\/ ASSERT\n-          return MIN2(res_offset, r_offset);\n-        }\n-        \/\/ skip over all word length 0-bit runs\n-        for (index++; index < r_index; index++) {\n-          res = map(index);\n-          if (res != 0) {\n-            \/\/ found a 1, return the offset\n-            for (res_offset = bit_index(index); !(res & 1); res_offset++) {\n-              res = res >> 1;\n-            }\n-            assert(res & 1, \"tautology; see loop condition\");\n-            assert(res_offset >= l_offset, \"just checking\");\n-            return MIN2(res_offset, r_offset);\n-          }\n-        }\n-        return r_offset;\n-      }\n-  };\n-\n@@ -139,1 +61,1 @@\n-    TsanOopBitMap bitmap_;\n+    CHeapBitMap bitmap_;\n@@ -150,1 +72,1 @@\n-          bitmap_((mem_end - mem_begin) \/ HeapWordSize) {}\n+          bitmap_((mem_end - mem_begin) \/ HeapWordSize, mtInternal) {}\n@@ -157,1 +79,1 @@\n-      return bitmap_.get_next_one_offset(to_idx(from), idx_to) == idx_to;\n+      return bitmap_.find_first_set_bit(to_idx(from), idx_to) == idx_to;\n","filename":"src\/hotspot\/share\/tsan\/tsanOopMap.cpp","additions":3,"deletions":81,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -141,2 +141,0 @@\n-  \/\/ Used by Tsan,\n-  bm_word_t  map(idx_t word) const { return _map[word]; }\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}