{"files":[{"patch":"@@ -1,2 +1,37 @@\n-project=jdk\n-bugids=dup\n+;\n+; Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+; DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+;\n+; This code is free software; you can redistribute it and\/or modify it\n+; under the terms of the GNU General Public License version 2 only, as\n+; published by the Free Software Foundation.\n+;\n+; This code is distributed in the hope that it will be useful, but WITHOUT\n+; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; version 2 for more details (a copy is included in the LICENSE file that\n+; accompanied this code).\n+;\n+; You should have received a copy of the GNU General Public License version\n+; 2 along with this work; if not, write to the Free Software Foundation,\n+; Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+;\n+; Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+; or visit www.oracle.com if you need additional information or have any\n+; questions.\n+;\n+\n+[general]\n+project=tsan\n+repository=tsan\n+jbs=jdk\n+\n+[checks]\n+error=author,committer,whitespace,executable,symlink\n+\n+[census]\n+version=0\n+domain=openjdk.org\n+\n+[checks \"whitespace\"]\n+files=.*\\.java$|.*\\.cpp$|.*\\.hpp$|.*\\.c$|.*\\.h$\n","filename":".jcheck\/conf","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -852,0 +852,9 @@\n+  # With tsan enabled, process reaper often causes SOE. it makes jtreg test failure.\n+  ifeq ($(INCLUDE_TSAN), true)\n+    ifeq ($(call isTargetCpuArch, aarch64), true)\n+      $1_JTREG_BASIC_OPTIONS += -vmoption:-Djdk.lang.processReaperUseDefaultStackSize=true\n+      $1_JTREG_LAUNCHER_OPTIONS += -Djdk.lang.processReaperUseDefaultStackSize=true\n+      $$(info tsan enabled, process reaper will use default JVM stack size.)\n+    endif\n+  endif\n+\n","filename":"make\/RunTests.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -242,5 +242,15 @@\n-    C_O_FLAG_HIGHEST_JVM=\"-O3\"\n-    C_O_FLAG_HIGHEST=\"-O3\"\n-    C_O_FLAG_HI=\"-O3\"\n-    C_O_FLAG_NORM=\"-O2\"\n-    C_O_FLAG_DEBUG_JVM=\"-O0\"\n+    # Use -Os on aarch64 to work around known llvm issue,\n+    # (see https:\/\/bugs.llvm.org\/show_bug.cgi?id=44581) which makes release build crash in aarch64.\n+    if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+      C_O_FLAG_HIGHEST_JVM=\"-Os\"\n+      C_O_FLAG_HIGHEST=\"-Os\"\n+      C_O_FLAG_HI=\"-Os\"\n+      C_O_FLAG_NORM=\"-Os\"\n+      C_O_FLAG_DEBUG_JVM=\"\"\n+    else\n+      C_O_FLAG_HIGHEST_JVM=\"-O3\"\n+      C_O_FLAG_HIGHEST=\"-O3\"\n+      C_O_FLAG_HI=\"-O3\"\n+      C_O_FLAG_NORM=\"-O2\"\n+      C_O_FLAG_DEBUG_JVM=\"-O0\"\n+    fi\n@@ -486,0 +496,6 @@\n+    # Disable experimental isel due to a known issue in llvm-8, which generates wrong debug info.\n+    # (see https:\/\/bugs.llvm.org\/show_bug.cgi?id=40887)\n+    if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+      TOOLCHAIN_CFLAGS_JVM=\"$TOOLCHAIN_CFLAGS_JVM -fno-experimental-isel\"\n+    fi\n+\n","filename":"make\/autoconf\/flags-cflags.m4","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    serialgc services shenandoahgc static-build vm-structs zero zgc \\\n+    serialgc services shenandoahgc static-build tsan vm-structs zero zgc \\\n@@ -80,0 +80,1 @@\n+m4_define(jvm_feature_desc_tsan, [enable ThreadSanitizer support])\n@@ -382,0 +383,47 @@\n+###############################################################################\n+# Check if the feature 'tsan' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_TSAN],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(tsan, [\n+    AC_MSG_CHECKING([if platform is supported by TSAN])\n+    if test \"x$OPENJDK_TARGET_OS\" = \"xlinux\" && \\\n+        (test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || \\\n+         test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"); then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Support for --<enable|disable>-tsan-launcher flag.\n+#\n+# TODO(tsan-dev): Ideally we should use AC_DEFUN_ONCE. However, with AC_DEFUN_ONCE,\n+# we cannot read variables such as $INCLUDE_TSAN or $JVM_FEATURES_ACTIVE. They would\n+# become empty value.\n+AC_DEFUN([JVM_FEATURES_TSAN_LAUNCHER_FLAG],\n+[\n+  # Add a configure option --<enable|disable>-tsan-launcher to allow\n+  # more control on whether to link TSAN runtime with the launcher.\n+  AC_ARG_ENABLE(tsan-launcher, AS_HELP_STRING(\n+        [--enable-tsan-launcher],\n+        [link tsan runtime with the default JDK launcher. Default is consistent with whether tsan feature is enabled.]))\n+  AC_MSG_CHECKING([if tsan should be linked with JDK launcher])\n+  if test \"x$INCLUDE_TSAN\" = \"xtrue\"; then\n+    if test \"x$enable_tsan_launcher\" = \"xno\"; then\n+      AC_MSG_RESULT([no, forced])\n+      INCLUDE_TSAN=\"false\"\n+    else\n+      AC_MSG_RESULT([yes])\n+    fi\n+  else\n+    AC_MSG_RESULT([no, tsan feature is disabled])\n+    if test \"x$enable_tsan_launcher\" = \"xyes\"; then\n+      AC_MSG_ERROR([--enable-tsan-launcher can only be used when tsan feature is enabled.])\n+    fi\n+  fi\n+])\n+\n@@ -441,0 +489,1 @@\n+  JVM_FEATURES_CHECK_TSAN\n@@ -602,0 +651,3 @@\n+  if ! JVM_FEATURES_IS_ACTIVE(tsan); then\n+    INCLUDE_TSAN=\"false\"\n+  fi\n@@ -627,0 +679,1 @@\n+  INCLUDE_TSAN=\"true\"\n@@ -653,0 +706,2 @@\n+  JVM_FEATURES_TSAN_LAUNCHER_FLAG($INCLUDE_TSAN)\n+\n@@ -665,0 +720,1 @@\n+  AC_SUBST(INCLUDE_TSAN)\n","filename":"make\/autoconf\/jvm-features.m4","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -847,0 +847,1 @@\n+INCLUDE_TSAN:=@INCLUDE_TSAN@\n","filename":"make\/autoconf\/spec.gmk.in","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+# INCLUDE_TSAN   If true, pass compiler and linker flags for TSAN.\n@@ -142,0 +143,11 @@\n+  ifeq ($$($1_INCLUDE_TSAN), true)\n+    $1_CFLAGS += -DINCLUDE_TSAN\n+    # TSAN runtime needs to be statically or dynamically linked with the launcher\n+    # instead of libjvm.so, because initialization of TSAN runtime has to happen\n+    # early at program start.\n+    # '-fsanitize=thread' works as a link-only flag for either GCC or Clang.\n+    # With GCC, it dynamically links with libtsan.so; with Clang, it statically\n+    # links the runtime into the launcher's executable.\n+    $1_LDFLAGS += -fsanitize=thread\n+  endif\n+\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -178,0 +178,5 @@\n+ifneq ($(call check-jvm-feature, tsan), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_TSAN=0\n+  JVM_EXCLUDE_PATTERNS += tsan\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+TsanSymbolize\n","filename":"make\/hotspot\/symbols\/symbols-shared","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+JVM_GetTsanEnabled\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+    INCLUDE_TSAN := $(INCLUDE_TSAN), \\\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -187,0 +187,4 @@\n+ifeq ($(INCLUDE_TSAN), true)\n+  LIBJLI_CFLAGS += -DINCLUDE_TSAN\n+endif\n+\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -865,0 +865,7 @@\n+\n+    BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libAbstractNativeLoop := -fsanitize=thread\n+    ifeq ($(TOOLCHAIN_TYPE), gcc)\n+      # Ignore unresolved symbols from TSAN's runtime.\n+      # The symbols will be available at runtime as TSAN runtime is linked with the launcher.\n+      BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libAbstractNativeLoop := -Wl,--unresolved-symbols=ignore-in-object-files\n+    endif\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -707,0 +707,3 @@\n+\n+  TSAN_RUNTIME_ONLY(push_ptr(lock_reg));\n+\n@@ -789,0 +792,9 @@\n+\n+  TSAN_RUNTIME_ONLY(\n+    pop_ptr(lock_reg);\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_lock),\n+            lock_reg);\n+    popa();\n+  );\n@@ -807,0 +819,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_unlock),\n+            lock_reg);\n+    popa();\n+  );\n+\n@@ -1483,0 +1503,4 @@\n+  TSAN_RUNTIME_ONLY(call_VM(noreg,\n+                            CAST_FROM_FN_PTR(address,\n+                            SharedRuntime::tsan_interp_method_entry)));\n+\n@@ -1516,0 +1540,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    push(state);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                 SharedRuntime::tsan_interp_method_exit));\n+    pop(state);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1710,0 +1710,9 @@\n+  TSAN_RUNTIME_ONLY(\n+    \/\/ protect the args we've loaded\n+    save_args(masm, total_c_args, c_arg, out_regs);\n+    __ call_VM(noreg,\n+      CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_entry),\n+      rthread);\n+    restore_args(masm, total_c_args, c_arg, out_regs);\n+  );\n+\n@@ -1789,0 +1798,8 @@\n+\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg,\n+                 CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_lock),\n+                 obj_reg);\n+      __ popa();\n+    );\n@@ -1879,0 +1896,9 @@\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg,\n+                 CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_unlock),\n+                 obj_reg);\n+      __ popa();\n+    );\n+\n+\n@@ -1915,0 +1941,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    save_native_result(masm, ret_type, stack_slots);\n+    __ call_VM_leaf(\n+         CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_exit));\n+    restore_native_result(masm, ret_type, stack_slots);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -756,0 +756,81 @@\n+#if INCLUDE_TSAN\n+\n+void TemplateTable::tsan_observe_load_or_store(const Address& field,\n+                                               TsanMemoryReadWriteFunction tsan_function) {\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+  if (!ThreadSanitizerJavaMemory) {\n+    return;\n+  }\n+\n+  __ pusha();\n+  __ push_d(v0);\n+  __ lea(c_rarg0, field);\n+  __ get_method(c_rarg1);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                  c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+  __ pop_d(v0);\n+  __ popa();\n+}\n+\n+void TemplateTable::tsan_observe_get_or_put(const Address &field,\n+                                            Register flags,\n+                                            TsanMemoryReadWriteFunction tsan_function,\n+                                            TosState tos) {\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+\n+  TsanMemoryReleaseAcquireFunction releaseAcquireFunction =\n+      tsan_release_acquire_method(tsan_function);\n+\n+  Label done, notAcquireRelease;\n+\n+  \/\/ We could save some instructions by only saving the registers we need.\n+  __ pusha();\n+  \/\/ pusha() doesn't save v0, which tsan_function clobbers and the\n+  \/\/ interpreter still needs.\n+  \/\/ This really only needs to be done for some of the float\/double accesses,\n+  \/\/ but it's here because it's cleaner.\n+  __ push_d(v0);\n+  \/\/ For volatile reads\/writes use an acquire\/release.\n+  \/\/ If a reference is annotated to be ignored, assume it's safe to\n+  \/\/ access the object it's referring to and create a happens-before relation\n+  \/\/ between the accesses to this reference.\n+  if (tos == atos) {\n+    int32_t acquire_release_mask = 1 << ConstantPoolCacheEntry::is_volatile_shift |\n+      1 << ConstantPoolCacheEntry::is_tsan_ignore_shift;\n+    \/\/ acquire_release_mask (0x8200000) can not be encoded into 'tst', but it can be\n+    \/\/ encoded into just one 'mov' instruction.\n+    __ mov(rscratch1, acquire_release_mask);\n+    __ tst(flags, rscratch1);\n+    __ br(Assembler::EQ, notAcquireRelease);\n+  } else {\n+    __ tbz(flags, ConstantPoolCacheEntry::is_volatile_shift, notAcquireRelease);\n+  }\n+\n+  __ lea(c_rarg0, field);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);\n+  if (ThreadSanitizerJavaMemory) {\n+    __ b(done);\n+    __ bind(notAcquireRelease);\n+\n+    \/\/ Ignore reads\/writes to final fields. They can't be racy.\n+    __ tbnz(flags, ConstantPoolCacheEntry::is_final_shift, done);\n+\n+    \/\/ Don't report races on tsan ignored fields.\n+    __ tbnz(flags, ConstantPoolCacheEntry::is_tsan_ignore_shift, done);\n+\n+    __ lea(c_rarg0, field);\n+    __ get_method(c_rarg1);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                    c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+\n+    __ bind(done);\n+  } else {\n+    __ bind(notAcquireRelease);\n+  }\n+  __ pop_d(v0);\n+  __ popa();\n+}\n+\n+\n+#endif\n+\n@@ -765,1 +846,3 @@\n-  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -777,1 +860,3 @@\n-  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -789,1 +874,3 @@\n-  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -801,1 +888,3 @@\n-  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -813,4 +902,4 @@\n-  do_oop_load(_masm,\n-              Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),\n-              r0,\n-              IS_ARRAY);\n+  Address addr(r0, r1, Address::uxtw(LogBytesPerHeapOop));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, UseCompressedOops ? SharedRuntime::tsan_read4\n+                                                                       : SharedRuntime::tsan_read8));\n+  do_oop_load(_masm, addr, r0, IS_ARRAY);\n@@ -828,1 +917,3 @@\n-  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(0)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(0));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));\n+  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -840,1 +931,3 @@\n-  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(1));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -846,0 +939,3 @@\n+#ifdef ASSERT\n+  TSAN_RUNTIME_ONLY(__ stop(\"bytecode rewrite should have been disabled in TSAN\"););\n+#endif\n@@ -869,1 +965,3 @@\n-  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(1));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -1063,1 +1161,3 @@\n-  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);\n@@ -1075,1 +1175,3 @@\n-  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);\n@@ -1087,1 +1189,3 @@\n-  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg \/* ftos *\/, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg \/* ftos *\/, noreg, noreg);\n@@ -1099,1 +1203,3 @@\n-  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg \/* dtos *\/, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg \/* dtos *\/, noreg, noreg);\n@@ -1114,1 +1220,3 @@\n-\n+  \/\/ do tsan write after r4 has been defined.\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(element_address, UseCompressedOops ? SharedRuntime::tsan_write4\n+                                                                                  : SharedRuntime::tsan_write8));\n@@ -1176,1 +1284,3 @@\n-  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(0));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));\n+  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);\n@@ -1189,1 +1299,3 @@\n-  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(1));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));\n+  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);\n@@ -2381,0 +2493,19 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Draw a happens-before edge from the class's static initializer to\n+      \/\/ this lookup.\n+\n+      \/\/ java_lang_Class::_init_lock_offset may not have been initialized\n+      \/\/ when generating code. It will be initialized at runtime though.\n+      \/\/ So calculate its address and read from it at runtime.\n+      __ pusha();\n+      __ mov(c_rarg0, obj);\n+      Address init_lock_offset_address((address) java_lang_Class::init_lock_offset_addr(),\n+                                       relocInfo::none);\n+      __ lea(rscratch1, init_lock_offset_address);\n+      __ ldrw(rscratch1, Address(rscratch1, 0));\n+      __ add(c_rarg0, c_rarg0, rscratch1);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                                       SharedRuntime::tsan_acquire),\n+                                       c_rarg0);\n+      __ popa();\n+    );\n@@ -2516,0 +2647,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, btos));\n@@ -2529,0 +2661,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, ztos));\n@@ -2542,0 +2675,5 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,\n+                                            raw_flags,\n+                                            UseCompressedOops ? SharedRuntime::tsan_read4\n+                                                              : SharedRuntime::tsan_read8,\n+                                            atos));\n@@ -2553,0 +2691,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, itos));\n@@ -2565,0 +2704,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, ctos));\n@@ -2577,0 +2717,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, stos));\n@@ -2589,0 +2730,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, ltos));\n@@ -2601,0 +2743,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, ftos));\n@@ -2615,0 +2758,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, dtos));\n@@ -2722,0 +2866,1 @@\n+  \/\/ save raw flags in r5\n@@ -2751,0 +2896,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, btos));\n@@ -2766,0 +2912,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, ztos));\n@@ -2781,0 +2928,5 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,\n+                                              r5,\n+                                              UseCompressedOops ? SharedRuntime::tsan_write4\n+                                                                : SharedRuntime::tsan_write8,\n+                                              atos));\n@@ -2797,0 +2949,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, itos));\n@@ -2812,0 +2965,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, ctos));\n@@ -2827,0 +2981,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, stos));\n@@ -2842,0 +2997,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, ltos));\n@@ -2857,0 +3013,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, ftos));\n@@ -2874,0 +3031,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, dtos));\n@@ -3047,0 +3205,3 @@\n+#ifdef ASSERT\n+  TSAN_RUNTIME_ONLY(__ stop(\"bytecode rewrite should have been disabled in TSAN\"););\n+#endif\n@@ -3140,0 +3301,3 @@\n+#ifdef ASSERT\n+  TSAN_RUNTIME_ONLY(__ stop(\"bytecode rewrite should have been disabled in TSAN\"););\n+#endif\n@@ -3641,0 +3805,8 @@\n+\n+     TSAN_RUNTIME_ONLY(\n+      \/\/ return value of new oop is in r0.\n+      __ push(atos);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj), r0);\n+      __ pop(atos);\n+    );\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":190,"deletions":18,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -1178,0 +1178,1 @@\n+  TSAN_RUNTIME_ONLY(push_ptr(lock_reg));\n@@ -1257,0 +1258,9 @@\n+\n+  TSAN_RUNTIME_ONLY(\n+    pop_ptr(lock_reg);\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_lock),\n+            lock_reg);\n+    popa();\n+  );\n@@ -1276,0 +1286,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_unlock),\n+            lock_reg);\n+    popa();\n+  );\n+\n@@ -1992,0 +2010,4 @@\n+  TSAN_RUNTIME_ONLY(call_VM(noreg,\n+                            CAST_FROM_FN_PTR(address,\n+                                             SharedRuntime::tsan_interp_method_entry)));\n+\n@@ -2029,0 +2051,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    push(state);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                                  SharedRuntime::tsan_interp_method_exit));\n+    pop(state);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2445,0 +2445,9 @@\n+  TSAN_RUNTIME_ONLY(\n+    \/\/ protect the args we've loaded\n+    save_args(masm, total_c_args, c_arg, out_regs);\n+    __ call_VM(noreg,\n+      CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_entry),\n+      r15_thread);\n+    restore_args(masm, total_c_args, c_arg, out_regs);\n+  );\n+\n@@ -2524,0 +2533,8 @@\n+\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg,\n+                 CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_lock),\n+                 obj_reg);\n+      __ popa();\n+    );\n@@ -2659,0 +2676,8 @@\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                                         SharedRuntime::tsan_oop_unlock),\n+                 obj_reg);\n+      __ popa();\n+    );\n+\n@@ -2695,0 +2720,8 @@\n+\n+  TSAN_RUNTIME_ONLY(\n+    save_native_result(masm, ret_type, stack_slots);\n+    __ call_VM_leaf(\n+         CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_exit));\n+    restore_native_result(masm, ret_type, stack_slots);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -770,0 +770,97 @@\n+#if INCLUDE_TSAN\n+\n+void TemplateTable::tsan_observe_get_or_put(\n+    const Address &field,\n+    Register flags,\n+    TsanMemoryReadWriteFunction tsan_function,\n+    TosState tos) {\n+  assert(flags == rdx, \"flags should be in rdx register\");\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+\n+  TsanMemoryReleaseAcquireFunction releaseAcquireFunction =\n+      tsan_release_acquire_method(tsan_function);\n+\n+  Label done, notAcquireRelease;\n+\n+  \/\/ We could save some instructions by only saving the registers we need.\n+  __ pusha();\n+  \/\/ pusha() doesn't save xmm0, which tsan_function clobbers and the\n+  \/\/ interpreter still needs.\n+  \/\/ This really only needs to be done for some of the float\/double accesses,\n+  \/\/ but it's here because it's cleaner.\n+  __ push_d(xmm0);\n+  DEBUG_ONLY(\n+    __ pusha();\n+    __ movptr(c_rarg0, field.base());\n+    __ leaq(c_rarg1, field);\n+    __ subq(c_rarg1, field.base());\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),\n+                    c_rarg0 \/* oop *\/, c_rarg1 \/* index *\/);\n+    __ popa();\n+  );\n+  \/\/ For volatile reads\/writes use an acquire\/release.\n+  \/\/ If a reference is annotated to be ignored, assume it's safe to\n+  \/\/ access the object it's referring to and create a happens-before relation\n+  \/\/ between the accesses to this reference.\n+  int32_t acquire_release_mask = 1 << ConstantPoolCacheEntry::is_volatile_shift |\n+      ((tos == atos) ? 1 << ConstantPoolCacheEntry::is_tsan_ignore_shift : 0);\n+  __ testl(flags, acquire_release_mask);\n+  __ jcc(Assembler::zero, notAcquireRelease);\n+\n+  __ leaq(c_rarg0, field);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);\n+  if (ThreadSanitizerJavaMemory) {\n+    __ jmp(done);\n+\n+    __ bind(notAcquireRelease);\n+    \/\/ Ignore reads\/writes to final fields. They can't be racy.\n+    int32_t ignore_mask = 1 << ConstantPoolCacheEntry::is_final_shift |\n+        1 << ConstantPoolCacheEntry::is_tsan_ignore_shift;\n+    __ testl(flags, ignore_mask);\n+    __ jcc(Assembler::notZero, done);\n+\n+    __ leaq(c_rarg0, field);\n+    __ get_method(c_rarg1);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                    c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+\n+    __ bind(done);\n+  } else {\n+    __ bind(notAcquireRelease);\n+  }\n+  __ pop_d(xmm0);\n+  __ popa();\n+}\n+\n+void TemplateTable::tsan_observe_load_or_store(\n+    const Address& field, TsanMemoryReadWriteFunction tsan_function) {\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+  if (!ThreadSanitizerJavaMemory) {\n+    return;\n+  }\n+  \/\/ We could save some instructions by only saving the registers we need.\n+  __ pusha();\n+  \/\/ pusha() doesn't save xmm0, which tsan_function clobbers and the\n+  \/\/ interpreter still needs.\n+  \/\/ This really only needs to be done for some of the float\/double accesses,\n+  \/\/ but it's here because it's cleaner.\n+  __ push_d(xmm0);\n+  DEBUG_ONLY(\n+    __ pusha();\n+    __ movptr(c_rarg0, field.base());\n+    __ leaq(c_rarg1, field);\n+    __ subq(c_rarg1, field.base());\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),\n+                    c_rarg0 \/* oop *\/, c_rarg1 \/* index *\/);\n+    __ popa();\n+  );\n+  __ leaq(c_rarg0, field);\n+  __ get_method(c_rarg1);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                  c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+  __ pop_d(xmm0);\n+  __ popa();\n+}\n+\n+#endif  \/\/ INCLUDE_TSAN\n+\n@@ -775,4 +872,4 @@\n-  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_4,\n-                            arrayOopDesc::base_offset_in_bytes(T_INT)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_INT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -788,4 +885,5 @@\n-  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg \/* ltos *\/,\n-                    Address(rdx, rbx, Address::times_8,\n-                            arrayOopDesc::base_offset_in_bytes(T_LONG)),\n-                    noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_LONG));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg \/* ltos *\/, addr, noreg,\n+                    noreg);\n@@ -801,5 +899,5 @@\n-  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg \/* ftos *\/,\n-                    Address(rdx, rax,\n-                            Address::times_4,\n-                            arrayOopDesc::base_offset_in_bytes(T_FLOAT)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_FLOAT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg \/* ftos *\/, addr, noreg,\n+                    noreg);\n@@ -813,5 +911,5 @@\n-  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg \/* dtos *\/,\n-                    Address(rdx, rax,\n-                            Address::times_8,\n-                            arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_DOUBLE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg \/* dtos *\/, addr, noreg,\n+                    noreg);\n@@ -825,6 +923,7 @@\n-  do_oop_load(_masm,\n-              Address(rdx, rax,\n-                      UseCompressedOops ? Address::times_4 : Address::times_ptr,\n-                      arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n-              rax,\n-              IS_ARRAY);\n+  Address addr(rdx, rax,\n+               UseCompressedOops ? Address::times_4 : Address::times_ptr,\n+               arrayOopDesc::base_offset_in_bytes(T_OBJECT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(\n+      addr, UseCompressedOops ? SharedRuntime::tsan_read4\n+                              : SharedRuntime::tsan_read8));\n+  do_oop_load(_masm, addr, rax, IS_ARRAY);\n@@ -838,3 +937,4 @@\n-  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_BYTE)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_1,\n+               arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));\n+  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -848,3 +948,4 @@\n-  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_2,\n+               arrayOopDesc::base_offset_in_bytes(T_CHAR));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -874,3 +975,4 @@\n-  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_SHORT)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_2,\n+               arrayOopDesc::base_offset_in_bytes(T_SHORT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -1068,4 +1170,4 @@\n-  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_4,\n-                             arrayOopDesc::base_offset_in_bytes(T_INT)),\n-                     rax, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_INT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);\n@@ -1082,4 +1184,5 @@\n-  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY,\n-                     Address(rcx, rbx, Address::times_8,\n-                             arrayOopDesc::base_offset_in_bytes(T_LONG)),\n-                     noreg \/* ltos *\/, noreg, noreg);\n+  Address addr(rcx, rbx, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_LONG));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, noreg \/* ltos *\/, noreg,\n+                     noreg);\n@@ -1096,4 +1199,5 @@\n-  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_4,\n-                             arrayOopDesc::base_offset_in_bytes(T_FLOAT)),\n-                     noreg \/* ftos *\/, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_FLOAT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg \/* ftos *\/, noreg,\n+                     noreg);\n@@ -1109,4 +1213,5 @@\n-  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_8,\n-                             arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),\n-                     noreg \/* dtos *\/, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_DOUBLE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg \/* dtos *\/,\n+                     noreg, noreg);\n@@ -1127,0 +1232,4 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(\n+      element_address, UseCompressedOops ? SharedRuntime::tsan_write4\n+                                         : SharedRuntime::tsan_write8));\n+\n@@ -1187,4 +1296,4 @@\n-  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx,Address::times_1,\n-                             arrayOopDesc::base_offset_in_bytes(T_BYTE)),\n-                     rax, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_1,\n+               arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));\n+  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);\n@@ -1200,4 +1309,4 @@\n-  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_2,\n-                             arrayOopDesc::base_offset_in_bytes(T_CHAR)),\n-                     rax, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_2,\n+               arrayOopDesc::base_offset_in_bytes(T_CHAR));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));\n+  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);\n@@ -2797,0 +2906,20 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Draw a happens-before edge from the class's static initializer to\n+      \/\/ this lookup.\n+\n+      \/\/ java_lang_Class::_init_lock_offset may not have been initialized\n+      \/\/ when generating code. It will be initialized at runtime though.\n+      \/\/ So calculate its address and read from it at runtime.\n+      __ pusha();\n+      __ movq(c_rarg0, obj);\n+      AddressLiteral init_lock_offset_address(\n+          (address) java_lang_Class::init_lock_offset_addr(),\n+          relocInfo::none);\n+      __ lea(rax, init_lock_offset_address);\n+      __ movl(rax, Address(rax, 0));\n+      __ addq(c_rarg0, rax);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                                       SharedRuntime::tsan_acquire),\n+                      c_rarg0);\n+      __ popa();\n+    );\n@@ -2892,0 +3021,5 @@\n+  \/\/ During a TSAN instrumented run, move flags into rdx so we can later\n+  \/\/ examine whether the field is volatile or has been annotated to be ignored\n+  \/\/ by Tsan.\n+  TSAN_RUNTIME_ONLY(__ movl(rdx, flags));\n+\n@@ -2904,0 +3038,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read1, btos));\n@@ -2917,0 +3053,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read1, ztos));\n@@ -2930,0 +3068,4 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, UseCompressedOops ? SharedRuntime::tsan_read4\n+                                    : SharedRuntime::tsan_read8,\n+      atos));\n@@ -2941,0 +3083,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read4, itos));\n@@ -2953,0 +3097,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read2, ctos));\n@@ -2965,0 +3111,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read2, stos));\n@@ -2979,0 +3127,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read8, ltos));\n@@ -2990,0 +3140,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read4, ftos));\n@@ -3006,0 +3158,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read8, dtos));\n@@ -3141,2 +3295,0 @@\n-  __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);\n-  __ andl(rdx, 0x1);\n@@ -3145,1 +3297,1 @@\n-  __ testl(rdx, rdx);\n+  __ testl(rdx, 1 << ConstantPoolCacheEntry::is_volatile_shift);\n@@ -3182,0 +3334,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write1, btos));\n@@ -3197,0 +3351,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write1, ztos));\n@@ -3212,0 +3368,4 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, rdx,\n+        UseCompressedOops ? SharedRuntime::tsan_write4\n+                          : SharedRuntime::tsan_write8,\n+        atos));\n@@ -3228,0 +3388,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write4, itos));\n@@ -3243,0 +3405,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write2, ctos));\n@@ -3258,0 +3422,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write2, stos));\n@@ -3273,0 +3439,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write8, ltos));\n@@ -3291,0 +3459,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write4, ftos));\n@@ -3309,0 +3479,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write8, dtos));\n@@ -4133,0 +4305,8 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ return value of new oop is in rax.\n+      __ push(atos);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj),\n+                      rax);\n+      __ pop(atos);\n+    );\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":240,"deletions":60,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -557,0 +557,23 @@\n+\n+#if (INCLUDE_TSAN) && defined(AARCH64)\n+  \/\/ Current TSAN memory mapping for 48bits aarch64, a large continuous space could be allocated between\n+  \/\/ kMidAppMemBeg = 0x0aaaa00000000ull and kMidAppMemEnd = 0x0aaaf00000000ull, which is only 20GB size.\n+  \/\/ Take 16GB here for safer allocation.\n+  const julong max_avail_vmspace = 16ULL * G; \/\/ 16GB\n+  const u8 msb_in_aarch64 = 47; \/\/ Only support 48-bits space now.\n+\n+  \/\/ Based on tsan memory mapping for 48bits aarch64,\n+  \/\/ libjvm.so will be loaded between kHiAppMemBeg = 0x0ffff00000000ull and kHiAppMemEnd = 0x1000000000000ull\n+  u8 vm_addr_u8 = reinterpret_cast<u8>(&__FUNCTION__);\n+  \/\/ High address in 48bits user space is like 0x0000ffffxxxxxxxx.\n+  assert((vm_addr_u8  >> msb_in_aarch64) == 0x1, \"warning: allocation could fail in non 48-bit address space.\");\n+\n+  if (result) {\n+    *limit = MIN2(*limit, max_avail_vmspace);\n+  } else {\n+    *limit = max_avail_vmspace;\n+  }\n+\n+  result = true;\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -814,1 +814,2 @@\n-  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+  \/\/ TODO: TSAN requires being built with Clang, but stack alignment assertion fails with Clang.\n+  \/\/ assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#if INCLUDE_TSAN\n+#include \"classfile\/tsanIgnoreList.hpp\"\n+#endif \/\/ INCLUDE_TSAN\n@@ -1082,0 +1085,1 @@\n+    _field_TsanIgnore,\n@@ -1118,0 +1122,5 @@\n+\n+#if INCLUDE_TSAN\n+  void set_tsan_ignore(bool tsan_ignore) { set_annotation(_field_TsanIgnore); }\n+  bool is_tsan_ignore() const { return has_annotation(_field_TsanIgnore); }\n+#endif  \/\/ INCLUDE_TSAN\n@@ -1692,0 +1701,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      if (ThreadSanitizerIgnoreFile != NULL &&\n+          TsanIgnoreList::match(_class_name, name, type)) {\n+        parsed_annotations.set_tsan_ignore(true);\n+      }\n+    );\n+\n@@ -2126,0 +2142,8 @@\n+#if INCLUDE_TSAN\n+    case vmSymbols::VM_SYMBOL_ENUM_NAME(java_util_concurrent_annotation_LazyInit): {\n+      if (_location != _in_field) {\n+        break;  \/\/ only allow for fields\n+      }\n+      return _field_TsanIgnore;\n+    }\n+#endif  \/\/ INCLUDE_TSAN\n@@ -2138,0 +2162,5 @@\n+  TSAN_RUNTIME_ONLY(\n+    if (is_tsan_ignore())\n+      f->set_tsan_ignore(true);\n+  );\n+\n@@ -5937,0 +5966,20 @@\n+#if INCLUDE_TSAN\n+  if (ThreadSanitizer && !ik->is_interface()) {\n+    ik->ensure_space_for_methodids(0);\n+    int num_methods = ik->methods()->length();\n+    for (int index = 0; index < num_methods; index++) {\n+      \/\/ Make sure each method has a jmethodID.\n+      \/\/ This allows us to avoid allocating jmethodIDs during program execution.\n+      jmethodID id = ik->methods()->at(index)->jmethod_id();\n+#ifdef ASSERT\n+      u8 id_u8 = reinterpret_cast<u8>(id);\n+      assert((id_u8 & right_n_bits(3)) == 0, \"jmethodID is not aligned\");\n+      AMD64_ONLY(assert((id_u8 & left_n_bits(17)) == 0, \"jmethodID is not aligned\");)\n+      AARCH64_ONLY(id_u8 >>= 36;\n+                   assert(id_u8 == 0 || id_u8 == 0xaaa || id_u8 == 0xfff, \"jmethodID is not aligned\");\n+                   )\n+#endif\n+    }\n+  }\n+#endif \/\/ INCLUDE_TSAN\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1437,0 +1437,8 @@\n+\n+#if INCLUDE_TSAN\n+oop* java_lang_Class::init_lock_addr(oop java_class) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  return java_class->obj_field_addr_raw<oop>(_init_lock_offset);\n+}\n+#endif  \/\/ INCLUDE_TSAN\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -311,0 +311,4 @@\n+#if INCLUDE_TSAN\n+  static oop* init_lock_addr(oop java_class);\n+  static const int* init_lock_offset_addr() { return &_init_lock_offset; }\n+#endif  \/\/ INCLUDE_TSAN\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -612,0 +612,6 @@\n+\n+  TSAN_ONLY(int tsan_rec = 0;)\n+  TSAN_RUNTIME_ONLY(\n+    tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, lockObject());\n+    assert(tsan_rec > 0, \"tsan: unlocking unlocked mutex\");\n+  );\n@@ -616,0 +622,1 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, lockObject(), tsan_rec));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/tsanIgnoreList.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"memory\/resourceArea.inline.hpp\"\n+\n+static const int MAX_LINE_SIZE  = 1024;\n+\n+class FieldMatcher : public CHeapObj<mtClass> {\n+ public:\n+  enum Mode {\n+    Exact = 0,\n+    Prefix = 1,\n+    Any = 2,\n+    Unknown = -1\n+  };\n+\n+  FieldMatcher(const Symbol* class_name, Mode class_mode,\n+               const Symbol* field_name, Mode field_mode, FieldMatcher* next)\n+      : _class_name(class_name),\n+        _field_name(field_name),\n+        _class_mode(class_mode),\n+        _field_mode(field_mode),\n+        _next(next) { }\n+\n+  \/\/ Given a FieldMatcher as the head of linked-list, returns true if any\n+  \/\/ FieldMatcher in the list matches.\n+  static bool match_any(FieldMatcher* head,\n+                        const Symbol* class_name,\n+                        const Symbol* field_name) {\n+    while (head) {\n+      if (head->match(class_name, field_name)) {\n+        return true;\n+      }\n+      head = head->_next;\n+    }\n+    return false;\n+  }\n+\n+ protected:\n+  const Symbol* _class_name;\n+  const Symbol* _field_name;\n+  Mode _class_mode;\n+  Mode _field_mode;\n+  FieldMatcher* _next;\n+\n+  static bool match(const Symbol* candidate, const Symbol* match, Mode mode) {\n+    ResourceMark rm;\n+    switch (mode) {\n+      case Exact:\n+        return candidate == match;\n+      case Prefix: {\n+        const char* candidate_str = candidate->as_C_string();\n+        const char* match_str = match->as_C_string();\n+        return (strstr(candidate_str, match_str) == candidate_str);\n+      }\n+      case Any:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+\n+  bool match(const Symbol* class_name, const Symbol* field_name) {\n+    return (match(class_name, _class_name, _class_mode) &&\n+            match(field_name, _field_name, _field_mode));\n+  }\n+};\n+\n+FieldMatcher* TsanIgnoreList::_exact_match = NULL;\n+FieldMatcher* TsanIgnoreList::_prefix_match = NULL;\n+\n+\/\/ Detects the pattern-matching mode based on the presence and location of\n+\/\/ wildcard character, fixes the pattern inplace and returns the\n+\/\/ pattern-matching mode.\n+static FieldMatcher::Mode make_pattern(char* pattern) {\n+  const int len = strlen(pattern);\n+  \/\/ Inverse of Symbol::as_klass_external_name.\n+  \/\/ Turn all '.'s into '\/'s.\n+  for (int index = 0; index < len; index++) {\n+    if (pattern[index] == '.') {\n+      pattern[index] = '\/';\n+    }\n+  }\n+\n+  char* asterisk = strstr(pattern, \"*\");\n+  if (asterisk == NULL) {\n+    return FieldMatcher::Exact;\n+  }\n+  if (asterisk - pattern != len - 1) {\n+    warning(\"Unexpected location for '*' in \\\"%s\\\". \"\n+            \"Only prefix patterns are supported.\", pattern);\n+  }\n+  if (asterisk == pattern) {\n+    return FieldMatcher::Any;\n+  }\n+  pattern[len - 1] = '\\0';\n+  return FieldMatcher::Prefix;\n+}\n+\n+void TsanIgnoreList::parse_from_line(char* line) {\n+  EXCEPTION_MARK;\n+  char class_pattern[MAX_LINE_SIZE], field_pattern[MAX_LINE_SIZE];\n+  \/\/ Replace '#' with '\\0'.\n+  {\n+    char* comment = strchr(line, '#');\n+    if (comment != NULL) {\n+      *comment = '\\0';\n+    }\n+  }\n+  \/\/ Parse line.\n+  if (sscanf(line, \"%s %s\", class_pattern, field_pattern) != 2) {\n+    return;\n+  }\n+  \/\/ Get matcher mode from pattern.\n+  FieldMatcher::Mode class_mode = make_pattern(class_pattern);\n+  FieldMatcher::Mode field_mode = make_pattern(field_pattern);\n+  \/\/ If we match against Any, no need for a symbol, else create the symbol.\n+  Symbol* class_symbol = (class_mode == FieldMatcher::Any) ? NULL :\n+      SymbolTable::new_symbol(class_pattern);\n+  Symbol* field_symbol = (field_mode == FieldMatcher::Any) ? NULL :\n+      SymbolTable::new_symbol(field_pattern);\n+  \/\/ Add matcher to beginning of linked list.\n+  if (class_mode == FieldMatcher::Exact && field_mode == FieldMatcher::Exact) {\n+    _exact_match = new FieldMatcher(class_symbol, class_mode, field_symbol,\n+                                    field_mode, _exact_match);\n+  } else {\n+    _prefix_match = new FieldMatcher(class_symbol, class_mode, field_symbol,\n+                                     field_mode, _prefix_match);\n+  }\n+}\n+\n+void TsanIgnoreList::parse_from_file(FILE* stream) {\n+  char line[MAX_LINE_SIZE];\n+  while (fgets(line, sizeof(line), stream)) {\n+    if (strlen(line) == sizeof(line) - 1) {\n+      warning(\"TSAN ignore file (ThreadSanitizerIgnoreFile) contains a line longer \"\n+              \"than %d. This pattern will be truncated, and the rest of the \"\n+              \"file will not be processed for pattern matching.\",\n+              MAX_LINE_SIZE);\n+      break;\n+    }\n+    parse_from_line(line);\n+  }\n+  if (ferror(stream)) {\n+    warning(\"Error reading from TSAN ignore file\");\n+  }\n+}\n+\n+void TsanIgnoreList::init() {\n+  if (ThreadSanitizerIgnoreFile == NULL) {\n+    return;\n+  }\n+\n+  FILE* stream = fopen(ThreadSanitizerIgnoreFile, \"rt\");\n+  if (stream == NULL) {\n+    warning(\"TSAN ignore file (ThreadSanitizerIgnoreFile:%s) not found.\",\n+            ThreadSanitizerIgnoreFile);\n+    return;\n+  }\n+  parse_from_file(stream);\n+  fclose(stream);\n+}\n+\n+bool TsanIgnoreList::match(\n+    const Symbol* class_name, const Symbol* field_name,\n+    BasicType type) {\n+  \/\/ Wildcard matches are only for primitive types. References should be\n+  \/\/ added to list individually since they become release\/acquire.\n+  if (is_java_primitive(type) &&\n+      FieldMatcher::match_any(_prefix_match, class_name, field_name)) {\n+    return true;\n+  }\n+  return FieldMatcher::match_any(_exact_match, class_name, field_name);\n+}\n","filename":"src\/hotspot\/share\/classfile\/tsanIgnoreList.cpp","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CLASSFILE_TSANIGNORELIST_HPP\n+#define SHARE_CLASSFILE_TSANIGNORELIST_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+class FieldMatcher;\n+\n+\/\/ Loads a whitelist file (-XX:ThreadSanitizerIgnoreFile) containing class names\n+\/\/ and field names that will be ignored by Java TSAN instrumentation.\n+\/\/ Lines that start with '#' are considered comments.\n+\/\/ Fields with primitive type can be whitelisted with a wildcard prefix match\n+\/\/ for both field name and class name.\n+\/\/ Here are a few examples.\n+\/\/ To whitelist field myBaz in a class named com.foo.Bar\n+\/\/ com.foo.Bar myBaz\n+\/\/\n+\/\/ Every field with primitive type starting with my in that class:\n+\/\/ com.foo.Bar my*\n+\/\/\n+\/\/ And every primitive field in package com.foo:\n+\/\/ com.foo.* *\n+class TsanIgnoreList : AllStatic {\n+ public:\n+  static void init();\n+\n+  \/\/ Matches a class name and a field name with the whitelisted patterns.\n+  \/\/ type is the type of the field. Since we use ignored object reference\n+  \/\/ fields as a way to say that the object they point to is also safe to\n+  \/\/ pass around without synchronization, we only match primitive types with\n+  \/\/ wildcard patterns. References need to be whitelisted individually.\n+  static bool match(const Symbol* class_name, const Symbol* field_name,\n+                    BasicType type);\n+ private:\n+  static void parse_from_line(char* line);\n+  static void parse_from_file(FILE* stream);\n+\n+  static FieldMatcher* _prefix_match;\n+  static FieldMatcher* _exact_match;\n+};\n+\n+#endif  \/\/ SHARE_CLASSFILE_TSANIGNORELIST_HPP\n","filename":"src\/hotspot\/share\/classfile\/tsanIgnoreList.hpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -236,0 +236,1 @@\n+  template(java_util_concurrent_annotation_LazyInit,                         \"Ljava\/util\/concurrent\/annotation\/LazyInit;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,0 +206,4 @@\n+  \/\/ TODO(tsan): _reserved MemRegion is not available to all collectors.\n+  \/\/ Should we support collectors without _reserved MemRegion? See 8224815.\n+  TSAN_ONLY(MemRegion reserved_region() const { return _reserved; })\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -252,0 +252,3 @@\n+  TSAN_RUNTIME_ONLY(\n+      SharedRuntime::tsan_track_obj_with_size(obj(), (int)_allocator._word_size);\n+  );\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsanOopMap.hpp\"\n+#endif \/\/ INCLUDE_TSAN\n+\n@@ -43,1 +47,1 @@\n-#define HAVE_SERIAL_PHASES (INCLUDE_JVMTI || INCLUDE_JFR)\n+#define HAVE_SERIAL_PHASES (INCLUDE_JVMTI || INCLUDE_JFR || INCLUDE_TSAN)\n@@ -114,0 +118,1 @@\n+  TSAN_ONLY(case tsan: return \"TSAN weak processing\";)\n@@ -124,0 +129,1 @@\n+  TSAN_ONLY(case tsan: return &TsanOopMap::weak_oops_do;)\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorPhases.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,2 @@\n-    JFR_ONLY(jfr)\n+    JFR_ONLY(jfr TSAN_ONLY(COMMA))\n+    TSAN_ONLY(tsan)\n@@ -52,1 +53,1 @@\n-  static const uint serial_phase_count = 0 JVMTI_ONLY(+ 1) JFR_ONLY(+ 1);\n+  static const uint serial_phase_count = 0 JVMTI_ONLY(+ 1) JFR_ONLY(+ 1) TSAN_ONLY(+ 1);\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorPhases.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  f(CNT_PREFIX ## TSANWeakRoots,            DESC_PREFIX \"TSAN Weak Roots\")             \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"tsan\/tsanOopMap.hpp\"\n@@ -95,0 +96,6 @@\n+#if INCLUDE_TSAN\n+ShenandoahTSANWeakRoot::ShenandoahTSANWeakRoot(ShenandoahPhaseTimings::Phase phase) :\n+  ShenandoahWeakSerialRoot(&TsanOopMap::weak_oops_do, phase, ShenandoahPhaseTimings::TSANWeakRoots) {\n+}\n+#endif \/\/ INCLUDE_TSAN\n+\n@@ -98,0 +105,1 @@\n+  TSAN_ONLY(_tsan_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,0 +91,7 @@\n+#if INCLUDE_TSAN\n+class ShenandoahTSANWeakRoot : public ShenandoahWeakSerialRoot {\n+public:\n+  ShenandoahTSANWeakRoot(ShenandoahPhaseTimings::Phase phase);\n+};\n+#endif \/\/ INCLUDE_TSAN\n+\n@@ -95,0 +102,1 @@\n+  TSAN_ONLY(ShenandoahTSANWeakRoot   _tsan_weak_roots;)\n@@ -98,1 +106,2 @@\n-  JFR_ONLY(JVMTI_ONLY(COMMA)_jfr_weak_roots(phase)) {};\n+  JFR_ONLY(JVMTI_ONLY(COMMA)_jfr_weak_roots(phase))\n+  TSAN_ONLY(JVMTI_ONLY(COMMA)_tsan_weak_roots(phase)) {};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -312,0 +312,6 @@\n+\/*\n+ * java.lang.ref.Finalizer\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+JVM_GetTsanEnabled(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -727,0 +727,5 @@\n+  bool is_tsan_ignore = false;\n+#if INCLUDE_TSAN\n+  is_tsan_ignore = info.access_flags().is_stable() || info.access_flags().is_tsan_ignore();\n+#endif  \/\/ INCLUDE_TSAN\n+\n@@ -736,0 +741,1 @@\n+    is_tsan_ignore,\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#if INCLUDE_TSAN\n+#include \"runtime\/sharedRuntime.hpp\"\n+#endif\n@@ -70,0 +73,21 @@\n+#if INCLUDE_TSAN\n+\n+TemplateTable::TsanMemoryReleaseAcquireFunction TemplateTable::tsan_release_acquire_method(\n+    TsanMemoryReadWriteFunction tsan_function) {\n+  if (tsan_function == SharedRuntime::tsan_read1\n+      || tsan_function == SharedRuntime::tsan_read2\n+      || tsan_function == SharedRuntime::tsan_read4\n+      || tsan_function == SharedRuntime::tsan_read8) {\n+    return SharedRuntime::tsan_acquire;\n+  } else if (tsan_function == SharedRuntime::tsan_write1\n+      || tsan_function == SharedRuntime::tsan_write2\n+      || tsan_function == SharedRuntime::tsan_write4\n+      || tsan_function == SharedRuntime::tsan_write8) {\n+    return SharedRuntime::tsan_release;\n+  }\n+  ShouldNotReachHere();\n+  return NULL;\n+}\n+\n+#endif\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,0 +350,33 @@\n+#if INCLUDE_TSAN\n+   typedef void (*TsanMemoryReleaseAcquireFunction)(void* \/* address *\/);\n+\n+   typedef void (*TsanMemoryReadWriteFunction)(void* \/* address *\/,\n+                                               Method* \/* method *\/,\n+                                               address \/* bcp *\/);\n+\n+   \/\/ The corresponding tsan_acquire\/release function for a\n+   \/\/ TsanMemoryReadWriteFunction.\n+   static TsanMemoryReleaseAcquireFunction tsan_release_acquire_method(TsanMemoryReadWriteFunction tsan_function);\n+\n+   \/\/ Tell tsan that a member\/static variable has been read from or written to.\n+   \/\/ tsan_function must be one of the SharedRuntime::tsan_read\/write*\n+   \/\/ functions.\n+   \/\/ Flags is the register that contains the field cache entry flags bitfield.\n+   \/\/ Because the field may be volatile, for a write, this function must be\n+   \/\/ called before the write; for a read, this function must be called after\n+   \/\/ the read. This way the acquire\/release is ordered correctly relative to the\n+   \/\/ read\/write.\n+   static void tsan_observe_get_or_put(const Address &field,\n+                                       Register flags,\n+                                       TsanMemoryReadWriteFunction tsan_function,\n+                                       TosState tos);\n+\n+   \/\/ Tell tsan that an array has been read from or written to.\n+   \/\/ tsan_function must be one of the SharedRuntime::tsan_read\/write*\n+   \/\/ functions.\n+   \/\/ Unlike tsan_observe_get_or_put(), the ordering relative to the\n+   \/\/ read\/write does not matter since array loads\/stores are never volatile.\n+   static void tsan_observe_load_or_store(const Address& address,\n+                                          TsanMemoryReadWriteFunction tsan_function);\n+#endif\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+                                       bool is_tsan_ignore,\n@@ -143,1 +144,2 @@\n-                  ((is_final    ? 1 : 0) << is_final_shift),\n+                  ((is_final    ? 1 : 0) << is_final_shift) |\n+                  ((is_tsan_ignore ? 1 : 0) << is_tsan_ignore_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+    is_tsan_ignore_shift       = 27,  \/\/ Should the field be ignored by TSAN?\n@@ -227,0 +228,1 @@\n+    bool            is_tsan_ignore,              \/\/ the field should be ignored by TSAN\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -251,0 +251,10 @@\n+#if INCLUDE_TSAN\n+  bool is_tsan_ignore() const {\n+    return (access_flags() & JVM_ACC_FIELD_TSAN_IGNORE) != 0;\n+  }\n+  void set_tsan_ignore(bool z) {\n+    if (z) _shorts[access_flags_offset] |=  JVM_ACC_FIELD_TSAN_IGNORE;\n+    else   _shorts[access_flags_offset] &= ~JVM_ACC_FIELD_TSAN_IGNORE;\n+  }\n+#endif  \/\/ INCLUDE_TSAN\n+\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,0 +92,3 @@\n+#if INCLUDE_TSAN\n+#include \"runtime\/sharedRuntime.hpp\"\n+#endif\n@@ -828,0 +831,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Construct a happens-before edge between the write of _init_state to\n+      \/\/ fully_initialized and the later checking if it's initialized.\n+      void* const lock_address = reinterpret_cast<void*>(\n+          java_lang_Class::init_lock_addr(java_mirror()));\n+      SharedRuntime::tsan_release(lock_address);\n+    );\n@@ -849,0 +859,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Construct a happens-before edge between the write of _init_state to\n+      \/\/ fully_initialized and here.\n+      void* const lock_address = reinterpret_cast<void*>(\n+          java_lang_Class::init_lock_addr(java_mirror()));\n+      SharedRuntime::tsan_acquire(lock_address);\n+    );\n@@ -1211,0 +1228,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Construct a happens-before edge between the write of _init_state to\n+      \/\/ fully_initialized and the later checking if it's initialized.\n+      void* const lock_address = reinterpret_cast<void*>(\n+          java_lang_Class::init_lock_addr(java_mirror()));\n+      SharedRuntime::tsan_release(lock_address);\n+    );\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -3410,0 +3413,9 @@\n+\/\/ java.lang.ref.Finalizer \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+JVM_ENTRY(jboolean, JVM_GetTsanEnabled(JNIEnv *env))\n+  JVMWrapper(\"JVM_GetTsanEnabled\");\n+  TSAN_ONLY(return ThreadSanitizer;)\n+  NOT_TSAN(return JNI_FALSE;)\n+JVM_END\n+\n+\n@@ -3632,1 +3644,3 @@\n-  return new os::PlatformMutex();\n+  void *mon = new os::PlatformMutex();\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(mon));\n+  return mon;\n@@ -3639,0 +3653,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(mon));\n@@ -3647,0 +3662,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(mon));\n@@ -3654,0 +3670,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(mon));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -3226,0 +3229,4 @@\n+\/\/ Tsan note: The JVMTI raw monitors are instrumented at JvmtiRawMonitor call\n+\/\/ sites instead of inside the JvmtiRawMonitor implementation. This seems\n+\/\/ cleaner, and mirrors instrumentation of JVM_RawMonitor* functions.\n+\n@@ -3235,0 +3242,2 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(rmonitor));\n+\n@@ -3257,0 +3266,1 @@\n+        TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));\n@@ -3275,0 +3285,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(rmonitor));\n@@ -3318,0 +3329,1 @@\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));\n@@ -3336,0 +3348,1 @@\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));\n@@ -3349,0 +3362,4 @@\n+\n+  \/\/ A wait is modeled in Tsan as a simple release-acquire pair.\n+  \/\/ The matching release annotation is below.\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));\n@@ -3350,0 +3367,2 @@\n+  \/\/ The matching acquire annotation is above.\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -50,0 +53,1 @@\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,0 +62,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -380,0 +383,16 @@\n+\/\/ Tsan should know that the JVMTI TagMap is protected by a mutex.\n+class TsanMutexScope : public StackObj {\n+ private:\n+  Mutex *_lock;  \/\/ Keep my own reference, for destructor.\n+\n+ public:\n+  \/\/ Don't actually lock it, just tell tsan we did.\n+  TsanMutexScope(Mutex* mutex) : _lock(mutex) {\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(_lock));\n+  }\n+\n+  ~TsanMutexScope() {\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(_lock));\n+  }\n+};\n+\n@@ -448,0 +467,18 @@\n+  \/\/ TSAN Note: we cannot tell TSAN about the creation of this lock due to\n+  \/\/ this being seen as racy though is not really.\n+  \/\/\n+  \/\/ The JvmtiTagMap gets created by the first thread to call tag_map_for; which\n+  \/\/ uses a lock to create it if need be.\n+  \/\/\n+  \/\/ This means that this lock is created under a mutex but then,\n+  \/\/ subsequent uses do not have a lock to protect it (because not\n+  \/\/ needed in this case), however TSAN sees it as being needed because:\n+  \/\/  - Another thread can come and get the newly created JvmtiTagMap without a\n+  \/\/  lock and acquire the lock.\n+  \/\/  - This provokes a race for TSAN on the lock itself, though there is no\n+  \/\/  real issue.\n+  \/\/\n+  \/\/  Not creating the lock or having a fence mechanism to tell TSAN this is\n+  \/\/  safe (a fake lock around this lock for example) seem to be the only\n+  \/\/  solutions.\n+\n@@ -457,1 +494,0 @@\n-\n@@ -484,0 +520,2 @@\n+\n+  \/\/ TSAN Note: see above for the Tsan creation note.\n@@ -735,0 +773,1 @@\n+  TSAN_ONLY(TsanMutexScope tms(lock()));\n@@ -767,0 +806,1 @@\n+  TSAN_ONLY(TsanMutexScope tms(lock()));\n@@ -1266,0 +1306,2 @@\n+  JvmtiTagMap* _tag_map;\n+\n@@ -1267,1 +1309,4 @@\n-  VM_HeapIterateOperation(ObjectClosure* blk) { _blk = blk; }\n+  VM_HeapIterateOperation(ObjectClosure* blk, JvmtiTagMap* tag_map) {\n+    _blk = blk;\n+    _tag_map = tag_map;\n+  }\n@@ -1271,0 +1316,6 @@\n+    \/\/ Simulates barrier synchronization on safepoint.\n+    \/\/ This annotation is reasonably minimal in number of tsan callbacks.\n+    \/\/ By passing the lock directly, we are not actually locking it, just\n+    \/\/ telling TSAN we are to \"simulate\" the lock.\n+    TSAN_ONLY(TsanMutexScope tms(_tag_map->lock()));\n+\n@@ -1497,1 +1548,1 @@\n-  VM_HeapIterateOperation op(&blk);\n+  VM_HeapIterateOperation op(&blk, this);\n@@ -1514,1 +1565,1 @@\n-  VM_HeapIterateOperation op(&blk);\n+  VM_HeapIterateOperation op(&blk, this);\n@@ -1610,0 +1661,1 @@\n+    TSAN_ONLY(TsanMutexScope tms(lock()));\n@@ -3216,0 +3268,5 @@\n+  \/\/ This annotation is reasonably minimal in number of tsan callbacks.\n+  \/\/ By passing the lock directly, we are not actually locking it, just\n+  \/\/ telling TSAN we are to \"simulate\" the lock.\n+  TSAN_ONLY(TsanMutexScope tms(_tag_map->lock()));\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  inline Mutex* lock()                      { return &_lock; }\n@@ -68,0 +67,2 @@\n+  inline Mutex* lock()                      { return &_lock; }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsanExternalDecls.hpp\"\n+#endif\n@@ -268,0 +271,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    void* addr = index_oop_from_field_offset_long(p, offset);\n+    if (UseCompressedOops) {\n+      __tsan_read4_pc(addr, SharedRuntime::tsan_code_location(0, 0));\n+    } else {\n+      __tsan_read8_pc(addr, SharedRuntime::tsan_code_location(0, 0));\n+    }\n+  );\n@@ -275,0 +286,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    void* addr = index_oop_from_field_offset_long(p, offset);\n+    if (UseCompressedOops) {\n+      __tsan_write4_pc(addr, SharedRuntime::tsan_code_location(0, 0));\n+    } else {\n+      __tsan_write8_pc(addr, SharedRuntime::tsan_code_location(0, 0));\n+    }\n+  );\n@@ -282,0 +301,4 @@\n+  TSAN_RUNTIME_ONLY(\n+    void* addr = index_oop_from_field_offset_long(p, offset);\n+    __tsan_java_acquire(addr);\n+  );\n@@ -289,0 +312,4 @@\n+  TSAN_RUNTIME_ONLY(\n+    void* addr = index_oop_from_field_offset_long(p, offset);\n+    __tsan_java_release(addr);\n+  );\n@@ -297,1 +324,1 @@\n-#define DEFINE_GETSETOOP(java_type, Type) \\\n+#define DEFINE_GETSETOOP(java_type, Type, size) \\\n@@ -300,1 +327,6 @@\n-  return MemoryAccess<java_type>(thread, obj, offset).get(); \\\n+  java_type ret = MemoryAccess<java_type>(thread, obj, offset).get(); \\\n+  TSAN_RUNTIME_ONLY( \\\n+    void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \\\n+    __tsan_read##size##_pc(addr, SharedRuntime::tsan_code_location(0, 0)); \\\n+  ); \\\n+  return ret; \\\n@@ -304,0 +336,4 @@\n+  TSAN_RUNTIME_ONLY( \\\n+    void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \\\n+    __tsan_write##size##_pc(addr, SharedRuntime::tsan_code_location(0, 0)); \\\n+  ); \\\n@@ -309,8 +345,8 @@\n-DEFINE_GETSETOOP(jboolean, Boolean)\n-DEFINE_GETSETOOP(jbyte, Byte)\n-DEFINE_GETSETOOP(jshort, Short);\n-DEFINE_GETSETOOP(jchar, Char);\n-DEFINE_GETSETOOP(jint, Int);\n-DEFINE_GETSETOOP(jlong, Long);\n-DEFINE_GETSETOOP(jfloat, Float);\n-DEFINE_GETSETOOP(jdouble, Double);\n+DEFINE_GETSETOOP(jboolean, Boolean, 1)\n+DEFINE_GETSETOOP(jbyte, Byte, 1)\n+DEFINE_GETSETOOP(jshort, Short, 2);\n+DEFINE_GETSETOOP(jchar, Char, 2);\n+DEFINE_GETSETOOP(jint, Int, 4);\n+DEFINE_GETSETOOP(jlong, Long, 8);\n+DEFINE_GETSETOOP(jfloat, Float, 4);\n+DEFINE_GETSETOOP(jdouble, Double, 8);\n@@ -323,1 +359,6 @@\n-  return MemoryAccess<java_type>(thread, obj, offset).get_volatile(); \\\n+  java_type ret = MemoryAccess<java_type>(thread, obj, offset).get_volatile(); \\\n+  TSAN_RUNTIME_ONLY( \\\n+    void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \\\n+    __tsan_java_acquire(addr); \\\n+  ); \\\n+  return ret; \\\n@@ -327,0 +368,4 @@\n+  TSAN_RUNTIME_ONLY( \\\n+    void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \\\n+    __tsan_java_release(addr); \\\n+  ); \\\n@@ -911,0 +956,24 @@\n+\/\/ Calls __tsan_java_release() on construct and __tsan_java_acquire() on destruct.\n+class ScopedReleaseAcquire: public StackObj {\n+private:\n+  void* _addr;\n+public:\n+  ScopedReleaseAcquire(volatile void* addr) {\n+    TSAN_RUNTIME_ONLY(\n+      _addr = const_cast<void*>(addr);\n+      __tsan_java_release(_addr);\n+    );\n+  }\n+\n+  ScopedReleaseAcquire(oop obj, jlong offset) {\n+    TSAN_RUNTIME_ONLY(\n+      _addr = index_oop_from_field_offset_long(obj, offset);\n+      __tsan_java_release(_addr);\n+    );\n+  }\n+\n+  ~ScopedReleaseAcquire() {\n+    TSAN_RUNTIME_ONLY(__tsan_java_acquire(_addr));\n+  }\n+};\n+\n@@ -916,0 +985,1 @@\n+  ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -924,0 +994,1 @@\n+    ScopedReleaseAcquire releaseAcquire(addr);\n@@ -927,0 +998,1 @@\n+    ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -935,0 +1007,1 @@\n+    ScopedReleaseAcquire releaseAcquire(addr);\n@@ -938,0 +1011,1 @@\n+    ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -947,0 +1021,1 @@\n+  ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -956,0 +1031,1 @@\n+    ScopedReleaseAcquire releaseAcquire(addr);\n@@ -959,0 +1035,1 @@\n+    ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -968,0 +1045,1 @@\n+    ScopedReleaseAcquire releaseAcquire(addr);\n@@ -971,0 +1049,1 @@\n+    ScopedReleaseAcquire releaseAcquire(p, offset);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":90,"deletions":11,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -4113,0 +4113,12 @@\n+  TSAN_RUNTIME_ONLY(\n+    \/\/ Currently TSAN is only implemented for interpreter.\n+    set_mode_flags(_int);\n+    \/\/ TSAN instrumentation is not implemented for the RewriteBytecodes\n+    \/\/ code paths because TSAN slows down the application so much that the\n+    \/\/ performance benefits from rewriting bytecodes is negligible.\n+    FLAG_SET_ERGO(RewriteBytecodes, false);\n+    FLAG_SET_ERGO(RewriteFrequentPairs, false);\n+    \/\/ Turn off CDS, it interferes with eagerly allocating jmethodIDs.\n+    no_shared_spaces(\"CDS is not compatible with TSAN\");\n+  );\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2461,0 +2461,11 @@\n+                                                                            \\\n+  TSAN_ONLY(product(bool, ThreadSanitizer, false,                           \\\n+          \"Enable ThreadSanitizer lock instrumentation\"))                   \\\n+                                                                            \\\n+  TSAN_ONLY(product(bool, ThreadSanitizerJavaMemory, true,                  \\\n+          \"Detect Java data races with ThreadSanitizer. \"                   \\\n+          \"This is only enabled if -XX:+ThreadSanitizer is set.\"))          \\\n+                                                                            \\\n+  TSAN_ONLY(product(ccstr, ThreadSanitizerIgnoreFile, NULL,                 \\\n+          \"File containing a list of ignored field patterns for \"           \\\n+          \"ThreadSanitizer.\"))                                              \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+TSAN_ONLY(jint tsan_init();)\n@@ -95,0 +96,1 @@\n+TSAN_ONLY(void tsan_exit();)\n@@ -107,1 +109,0 @@\n-\n@@ -122,0 +123,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    status = tsan_init();\n+    if (status != JNI_OK) {\n+      return status;\n+    }\n+  );\n+\n@@ -172,0 +180,3 @@\n+\n+    TSAN_RUNTIME_ONLY(tsan_exit());\n+\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -134,0 +134,4 @@\n+#if INCLUDE_TSAN\n+Mutex*   TsanOopMap_lock              = NULL;\n+#endif\n+\n@@ -330,0 +334,4 @@\n+  TSAN_RUNTIME_ONLY(\n+    def(TsanOopMap_lock            , PaddedMutex  , special,     true,  _safepoint_check_never);\n+  );\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -141,0 +141,3 @@\n+#if INCLUDE_TSAN\n+extern Mutex*   TsanOopMap_lock;                 \/\/ guards shared map of oops\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,0 +80,4 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsanExternalDecls.hpp\"\n+#include \"tsan\/tsanOopMap.hpp\"\n+#endif\n@@ -1012,0 +1016,170 @@\n+#if INCLUDE_TSAN\n+\n+JRT_LEAF(void, SharedRuntime::verify_oop_index(oopDesc* obj, int index))\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+  assert(index >= 0, \"index is less than 0\");\n+  int obj_size_in_bytes = obj->size() * HeapWordSize;\n+  assert(index < obj_size_in_bytes, \"index %d >= obj size %d\", index, obj_size_in_bytes);\n+JRT_END\n+\n+\/\/ TSAN: method entry callback from interpreter\n+\/\/ (1) In order to have the line numbers in the call stack, we use the caller\n+\/\/     address instead of the method that's being called. This also matches\n+\/\/     the entry\/exit convention that TSAN uses for C++.\n+\/\/ We use JRT_ENTRY since call_VM_leaf doesn't set _last_Java_sp that we need.\n+JRT_ENTRY(void, SharedRuntime::tsan_interp_method_entry(JavaThread *thread))\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  DEBUG_ONLY(NoHandleMark nhm;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+\n+  RegisterMap unused_reg_map(thread, false);\n+\n+  \/\/ These asserts should be removed once\n+  \/\/ we support more than just the interpreter for TSAN.\n+  assert(!thread->last_frame().is_compiled_frame(),\n+         \"Current frame should not be a compiled frame\");\n+  const frame sender = thread->last_frame().real_sender(&unused_reg_map);\n+  assert(!sender.is_compiled_frame(), \"Sender should not be a compiled frame\");\n+\n+  jmethodID jmethod_id = 0;\n+  u2 bci = 0;\n+  \/\/ TODO: is (0, 0) really the best we can do\n+  \/\/ when the sender isn't an interpreted frame?\n+  if (sender.is_interpreted_frame()) {\n+    jmethod_id = sender.interpreter_frame_method()->find_jmethod_id_or_null();\n+    bci = sender.interpreter_frame_bci();\n+  }\n+  __tsan_func_entry(tsan_code_location(jmethod_id, bci));\n+JRT_END\n+\n+\/\/ TSAN: method exit callback from interpreter\n+JRT_LEAF(void, SharedRuntime::tsan_interp_method_exit())\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  __tsan_func_exit();\n+JRT_END\n+\n+void SharedRuntime::tsan_oop_lock(Thread* thread, oop obj) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+\n+  TsanOopMap::add_oop(obj);\n+  __tsan_java_mutex_lock((julong)(oopDesc*)obj);\n+}\n+\n+void SharedRuntime::tsan_oop_unlock(Thread *thread, oop obj) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+  assert(TsanOopMap::exists(obj), \"oop seen in unlock but not tracked\");\n+\n+  __tsan_java_mutex_unlock((julong)(oopDesc*)obj);\n+}\n+\n+void SharedRuntime::tsan_oop_rec_lock(Thread* thread, oop obj, int rec) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+\n+  TsanOopMap::add_oop(obj);\n+  __tsan_java_mutex_lock_rec((julong)(oopDesc*)obj, rec);\n+}\n+\n+int SharedRuntime::tsan_oop_rec_unlock(Thread *thread, oop obj) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+  assert(TsanOopMap::exists(obj), \"oop seen in unlock but not tracked\");\n+\n+  return __tsan_java_mutex_unlock_rec((julong)(oopDesc*)obj);\n+}\n+\n+JRT_LEAF(void, SharedRuntime::tsan_interp_lock(JavaThread* thread,\n+                                               BasicObjectLock* elem))\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+  assert(elem != NULL, \"null elem\");\n+\n+  oop obj = elem->obj();\n+  tsan_oop_lock(thread, obj);\n+\n+  assert(obj == elem->obj(), \"oop changed\");\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+JRT_END\n+\n+JRT_LEAF(void, SharedRuntime::tsan_interp_unlock(JavaThread* thread,\n+                                                 BasicObjectLock* elem))\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+  assert(elem != NULL, \"null elem\");\n+\n+  oop obj = elem->obj();\n+  tsan_oop_unlock(thread, obj);\n+\n+  assert(obj == elem->obj(), \"oop changed\");\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+JRT_END\n+\n+\/\/ Should be JRT_LEAF, but this is called very early during VM startup, so we\n+\/\/ are sometimes in '_thread_in_vm' state.\n+\/\/ NOTE: DO NOT add operations that can safepoint, enter GC, or throw an\n+\/\/ exception!\n+void SharedRuntime::tsan_track_obj_with_size(oopDesc* obj, int size) {\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(oopDesc::is_oop(obj), \"Bad oopDesc passed to tsan_track_obj_with_size().\");\n+  TsanOopMap::add_oop_with_size(obj, size);\n+}\n+\n+JRT_LEAF(void, SharedRuntime::tsan_track_obj(oopDesc* obj))\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(oopDesc::is_oop(obj), \"Bad oopDesc passed to tsan_track_obj().\");\n+  TsanOopMap::add_oop(obj);\n+JRT_END\n+\n+\/\/ TODO: Make tsan_acquire\/release JRT_LEAF\n+\/\/ Currently it can't be JRT_LEAF because there are calls from the VM\n+\/\/ (instanceKlass.cpp), and JRT_LEAF only allows calls from Java\/native code.\n+\/\/ We need to figure out a better way of being able to call TSAN functions from\n+\/\/ the VM.\n+void SharedRuntime::tsan_acquire(void* address) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(address != NULL, \"Cannot acquire at address 0\");\n+  __tsan_java_acquire(address);\n+}\n+\n+void SharedRuntime::tsan_release(void* address) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(address != NULL, \"Cannot release at address 0\");\n+  __tsan_java_release(address);\n+}\n+\n+#define TSAN_MEMORY_ACCESS(name)                                               \\\n+  JRT_LEAF(void, SharedRuntime::tsan_##name(                                   \\\n+      void* addr,                                                              \\\n+      Method* method,                                                          \\\n+      address bcp))                                                            \\\n+    assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");                      \\\n+    assert(ThreadSanitizerJavaMemory, \"Need -XX:+ThreadSanitizerJavaMemory\");  \\\n+    jmethodID mid = method->find_jmethod_id_or_null();                         \\\n+    int bci = method->bci_from(bcp);                                           \\\n+    __tsan_##name##_pc(addr, tsan_code_location(mid, bci));                    \\\n+  JRT_END\n+\n+TSAN_MEMORY_ACCESS(read1)\n+TSAN_MEMORY_ACCESS(read2)\n+TSAN_MEMORY_ACCESS(read4)\n+TSAN_MEMORY_ACCESS(read8)\n+TSAN_MEMORY_ACCESS(write1)\n+TSAN_MEMORY_ACCESS(write2)\n+TSAN_MEMORY_ACCESS(write4)\n+TSAN_MEMORY_ACCESS(write8)\n+\n+#endif \/\/ INCLUDE_TSAN\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -281,0 +281,91 @@\n+#if INCLUDE_TSAN\n+  \/\/ TSAN instrumentation\n+\n+  \/\/ TSAN uses a 64-bit value to identify code location.\n+  \/\/ TSAN uses the uppermost 3 bits (63:61) for the internal purposes.\n+  \/\/ If bit 60 is set, TSAN recognizes that the code location belongs to the\n+  \/\/ JVM, and will call __tsan_symbolize_external_ex() for symbolization rather\n+  \/\/ than TSAN's own symbolizer. See __sanitizer::kExternalPCBit and\n+  \/\/ __tsan::__tsan_symbolize_external_ex() in TSAN for more details.\n+  \/\/ The lower 60 bits may contain either a packed bytecode location, or an\n+  \/\/ instruction address inside the code generated by JIT compiler.\n+  \/\/ A packed code location has the method ID in bits 59:16 and the bytecode\n+  \/\/offset within method in bits 15:0. 44 bits (59:16) are enough to encode any\n+  \/\/ 47-bit 8-byte-aligned address, which is the maximum address space TSAN\n+  \/\/ allows. The next 16 bits are used for storing the bci.\n+  \/\/ | Tsan: 3 | TsanJava: 1 | jmethodID: 44 | BCI: 16 |\n+  static const int tsan_method_id_alignment_bits = 3;\n+  static const int tsan_bci_bits = 16;\n+  static const u8 tsan_bci_mask = right_n_bits(tsan_bci_bits);\n+  static const int tsan_method_id_shift = tsan_bci_bits -\n+      tsan_method_id_alignment_bits;\n+  static const u8 tsan_fake_pc_bit = 1L << 60;\n+  static void * tsan_code_location(jmethodID jmethod_id_ptr, u2 bci) {\n+    return (void *)(tsan_fake_pc_bit |\n+      (((u8)(jmethod_id_ptr)) << tsan_method_id_shift) | bci);\n+  }\n+  static jmethodID tsan_method_id_from_code_location(u8 loc) {\n+    u8 id =\n+        (loc & ~(tsan_fake_pc_bit | tsan_bci_mask)) >> tsan_method_id_shift;\n+\n+    \/\/ Typical method ID in aarch64 is like 0xffff_xxxx_xxxx_xxxx, which couldn't be represented by 47-bits.\n+    \/\/ But there are only 3 application memory regions in tsan for 48bits aarch64, the highest 4 bits\n+    \/\/ of addresses are 0x0, 0xa and 0xf respectively. The encoding function tsan_code_location() will\n+    \/\/ overwrite bit 47 for internal purpose, Therefore, we restore bit 47 here according to\n+    \/\/ the value of bits 46:44. if it is 0x2 or 0x7, restore bit 47 to 1.\n+#ifdef AARCH64\n+    u8 highest4bits = id >> 44;\n+    if (highest4bits == 0x7ULL || highest4bits == 0x2ULL) {\n+      id |= (0x1ULL << 47);\n+    }\n+#endif\n+\n+    return (jmethodID)id;\n+  }\n+  static u2 tsan_bci_from_code_location(u8 loc) {\n+    return (u2)(loc & tsan_bci_mask);\n+  }\n+\n+  \/\/ These functions are wrappers around TSAN callbacks,\n+  \/\/ which are listed in tsanExternalDecls.hpp. The VM uses only these\n+  \/\/ functions to push events to ThreadSanitizer.\n+\n+  \/\/ Verify that an oop is valid and that the index is within the object size.\n+  static void verify_oop_index(oopDesc* obj, int index);\n+\n+  \/\/ Java method entry\/exit from code run by template interpreter\n+  static void tsan_interp_method_entry(JavaThread *thread);\n+  static void tsan_interp_method_exit();\n+\n+  \/\/ Monitor acquire\/release in VM code\n+  \/\/ (e.g., generated native method wrapper, JNI heavyweight locks)\n+  static void tsan_oop_lock(Thread* thread, oop obj);\n+  static void tsan_oop_unlock(Thread* thread, oop obj);\n+  \/\/ Monitor acquire\/release in VM code; recursive lock variant (e.g., wait())\n+  static void tsan_oop_rec_lock(Thread* thread, oop obj, int rec);\n+  static int tsan_oop_rec_unlock(Thread* thread, oop obj);\n+\n+  \/\/ Monitor acquire\/release from code run by template interpreter\n+  static void tsan_interp_lock(JavaThread* thread, BasicObjectLock* elem);\n+  static void tsan_interp_unlock(JavaThread* thread, BasicObjectLock* elem);\n+\n+  \/\/ Address must point to an object in the Java heap.\n+  static void tsan_acquire(void* address);\n+  static void tsan_release(void* address);\n+\n+  \/\/ Called whenever an obj is created.\n+  static void tsan_track_obj_with_size(oopDesc* obj, int size);\n+  static void tsan_track_obj(oopDesc* obj);\n+\n+  \/\/ Memory reads\/writes from code run by template interpreter\n+  static void tsan_read1(void* addr, Method* method, address bcp);\n+  static void tsan_read2(void* addr, Method* method, address bcp);\n+  static void tsan_read4(void* addr, Method* method, address bcp);\n+  static void tsan_read8(void* addr, Method* method, address bcp);\n+  static void tsan_write1(void* addr, Method* method, address bcp);\n+  static void tsan_write2(void* addr, Method* method, address bcp);\n+  static void tsan_write4(void* addr, Method* method, address bcp);\n+  static void tsan_write8(void* addr, Method* method, address bcp);\n+\n+#endif \/\/ INCLUDE_TSAN\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -676,0 +676,8 @@\n+\/\/ NOTE(TSAN): We cannot instrument complete_exit\/reenter in ObjectSynchronizer\n+\/\/             in a manner similar to wait and waitUninterruptibly, because\n+\/\/             (1) recursion count stored by inflated monitor is different from\n+\/\/             the absolute recursion count tracked by Tsan, and (2) in the\n+\/\/             general case, we cannot merely store Tsan's recursion count\n+\/\/             once: we must track it for *each invocation* of complete_exit.\n+\/\/             Hence, the best place to instrument for Tsan is at the call site\n+\/\/             for complete_exit\/reenter. Luckily, there is only one call site.\n@@ -728,0 +736,1 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));\n@@ -746,0 +755,1 @@\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));\n@@ -761,0 +771,1 @@\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));\n@@ -766,0 +777,1 @@\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));\n@@ -788,0 +800,7 @@\n+\n+  TSAN_ONLY(int tsan_rec = 0;)\n+  TSAN_RUNTIME_ONLY(\n+    tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());\n+    assert(tsan_rec > 0, \"tsan: unlocking unlocked mutex\");\n+  );\n+\n@@ -790,0 +809,2 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));\n+\n@@ -810,0 +831,5 @@\n+  TSAN_ONLY(int tsan_rec;)\n+  TSAN_RUNTIME_ONLY(\n+    tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());\n+    assert(tsan_rec > 0, \"tsan: unlocking unlocked mutex\");\n+  );\n@@ -811,0 +837,1 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));\n@@ -2847,0 +2874,4 @@\n+      \/\/ Note well -- this occurs ONLY on thread exit, and is a last ditch\n+      \/\/ effort to release all locks. Hence, we don't need to record tsan's\n+      \/\/ recursion count -- it will never be locked again.\n+      TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_unlock(THREAD, (oop)mid->object()));\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/tsanIgnoreList.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"tsan\/tsanExternalDecls.hpp\"\n+#include \"tsan\/tsanOopMap.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+jint tsan_init() {\n+  TsanOopMap::initialize_map();  \/\/ This is probably early enough.\n+  TsanIgnoreList::init();\n+  if (__tsan_java_init == NULL) {  \/\/ We always need tsan runtime functions.\n+    vm_shutdown_during_initialization(\"libtsan cannot be located\");\n+    return JNI_ERR;\n+  }\n+  __tsan_java_init((julong)Universe::heap()->reserved_region().start(),\n+                   (julong)Universe::heap()->reserved_region().byte_size());\n+  return JNI_OK;\n+}\n+\n+void tsan_exit() {\n+  int status = __tsan_java_fini();\n+  if (status != 0) {\n+    vm_direct_exit(status);\n+  }\n+  TsanOopMap::destroy();\n+}\n+\n+\/\/ The type of the callback TSAN passes to __tsan_symbolize_external_ex.\n+\/\/ When __tsan_symbolize_external_ex has found a frame, it calls this callback,\n+\/\/ passing along opaque context and frame's location (function name, file\n+\/\/ where it is defined and line and column numbers). Note that we always pass\n+\/\/ -1 as a column.\n+typedef void (*AddFrameFunc)(void *ctx, const char *function, const char *file,\n+                             int line, int column);\n+\n+static void TsanSymbolizeMethod(Method* m, u2 bci, AddFrameFunc add_frame,\n+                                void* ctx) {\n+  char methodname_buf[256];\n+  char filename_buf[128];\n+\n+  m->name_and_sig_as_C_string(methodname_buf, sizeof(methodname_buf));\n+  Symbol* filename = m->method_holder()->source_file_name();\n+  if (filename != NULL) {\n+    filename->as_C_string(filename_buf, sizeof(filename_buf));\n+  } else {\n+    filename_buf[0] = filename_buf[1] = '?';\n+    filename_buf[2] = '\\0';\n+  }\n+\n+  add_frame(\n+      ctx, methodname_buf, filename_buf, m->line_number_from_bci(bci), -1);\n+}\n+\n+extern \"C\" {\n+\/\/ TSAN calls this to symbolize Java frames.\n+JNIEXPORT void TsanSymbolize(julong loc,\n+                             AddFrameFunc add_frame,\n+                             void *ctx) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+\n+  assert((loc & SharedRuntime::tsan_fake_pc_bit) != 0,\n+         \"TSAN should only ask the JVM to symbolize locations the JVM gave TSAN\"\n+        );\n+\n+  jmethodID method_id = SharedRuntime::tsan_method_id_from_code_location(loc);\n+  u2 bci = SharedRuntime::tsan_bci_from_code_location(loc);\n+  Method *m;\n+  if (method_id == 0) {\n+    add_frame(\n+        ctx, bci == 0 ? \"(Generated Stub)\" : \"(Unknown Method)\", NULL, -1, -1);\n+  } else if ((m = Method::checked_resolve_jmethod_id(method_id)) != NULL) {\n+    \/\/ Find a method by its jmethod_id. May fail if method has vanished since.\n+    TsanSymbolizeMethod(m, bci, add_frame, ctx);\n+  } else {\n+    add_frame(ctx, \"(Deleted method)\", NULL, -1, -1);\n+  }\n+}\n+}\n+\n+void TsanRawLockAcquired(const char *file, int line,\n+                         const volatile void *lock) {\n+  AnnotateRWLockAcquired(file, line, lock, 1);\n+}\n+\n+void TsanRawLockReleased(const char *file, int line,\n+                         const volatile void *lock) {\n+  AnnotateRWLockReleased(file, line, lock, 1);\n+}\n+\n+void TsanRawLockCreate(const char *file, int line, const volatile void *lock) {\n+  AnnotateRWLockCreate(file, line, lock);\n+}\n+\n+void TsanRawLockDestroy(const char *file, int line, const volatile void *lock) {\n+  AnnotateRWLockDestroy(file, line, lock);\n+}\n","filename":"src\/hotspot\/share\/tsan\/tsan.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_TSAN_TSAN_HPP\n+#define SHARE_TSAN_TSAN_HPP\n+\n+void TsanRawLockCreate(const char *file, int line, const volatile void *lock);\n+void TsanRawLockDestroy(const char *file, int line, const volatile void *lock);\n+void TsanRawLockAcquired(const char *file, int line, const volatile void *lock);\n+void TsanRawLockReleased(const char *file, int line, const volatile void *lock);\n+\n+#define TSAN_RAW_LOCK_CREATE(lock) \\\n+  TsanRawLockCreate(__FILE__, __LINE__, lock)\n+\n+#define TSAN_RAW_LOCK_DESTROY(lock) \\\n+  TsanRawLockDestroy(__FILE__, __LINE__, lock)\n+\n+#define TSAN_RAW_LOCK_ACQUIRED(lock) \\\n+  TsanRawLockAcquired(__FILE__, __LINE__, lock)\n+\n+#define TSAN_RAW_LOCK_RELEASED(lock) \\\n+  TsanRawLockReleased(__FILE__, __LINE__, lock)\n+\n+#endif  \/\/ SHARE_TSAN_TSAN_HPP\n","filename":"src\/hotspot\/share\/tsan\/tsan.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_TSAN_TSANEXTERNALDECLS_HPP\n+#define SHARE_TSAN_TSANEXTERNALDECLS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#define WEAK __attribute__((weak))\n+\n+\/\/ These declarations constitute the VM-ThreadSanitizer interface.\n+\/\/ These functions are the only way the VM notifies Tsan about critical events;\n+\/\/ they are \"push\" functions.\n+\/\/\n+\/\/ These functions must be declared as \"weak\" symbols: the function\n+\/\/ definitions are available only when the native Tsan library is loaded.\n+extern \"C\" {\n+  \/\/ Called after Java heap is set up.\n+  \/\/ It must be called before any other __tsan_java_* function.\n+  void __tsan_java_init(julong heap_begin, julong heap_size) WEAK;\n+  \/\/ Called after Java application exits.\n+  \/\/ It does not have to be the final function called.\n+  int __tsan_java_fini() WEAK;\n+\n+  \/\/ Called on Java method entry and exit.\n+  void __tsan_func_entry(void *pc) WEAK;\n+  void __tsan_func_exit() WEAK;\n+\n+  \/\/ Called when a Java object is allocated.\n+  void __tsan_java_alloc(void *addr, unsigned long size) WEAK;\n+  \/\/ Called at STW GC for all live but moved oops tracked by Tsan.\n+  void __tsan_java_move(void *src, void *dst, unsigned long size) WEAK;\n+  \/\/ Called at STW GC after an oop is collected.\n+  void __tsan_java_free(void *addr, unsigned long size) WEAK;\n+\n+  \/\/ Called when a thread enters an oop monitor.\n+  void __tsan_java_mutex_lock(julong addr) WEAK;\n+  \/\/ Called when a thread exits an oop monitor.\n+  void __tsan_java_mutex_unlock(julong addr) WEAK;\n+  \/\/ Called when a thread releases all recursive acquires for a monitor\n+  \/\/ (i.e., during a wait()).\n+  void __tsan_java_mutex_lock_rec(julong addr, int rec) WEAK;\n+  \/\/ Called when a thread re-acquires all previous recursive acquires.\n+  int __tsan_java_mutex_unlock_rec(julong addr) WEAK;\n+  \/\/ More primitive lock notification for internal VM double-checked locking.\n+  void __tsan_java_acquire(void* address) WEAK;\n+  void __tsan_java_release(void* address) WEAK;\n+\n+  void AnnotateRWLockCreate(const char *file, int line,\n+      const volatile void *lock) WEAK;\n+  void AnnotateRWLockDestroy(const char *file, int line,\n+      const volatile void *lock) WEAK;\n+  void AnnotateRWLockAcquired(const char *file, int line,\n+      const volatile void *lock, long is_w) WEAK;\n+  void AnnotateRWLockReleased(const char *file, int line,\n+      const volatile void *lock, long is_w) WEAK;\n+\n+  \/\/ Memory accesses.\n+  void __tsan_read1_pc(void *addr, void *pc) WEAK;\n+  void __tsan_read2_pc(void *addr, void *pc) WEAK;\n+  void __tsan_read4_pc(void *addr, void *pc) WEAK;\n+  void __tsan_read8_pc(void *addr, void *pc) WEAK;\n+\n+  void __tsan_write1_pc(void *addr, void *pc) WEAK;\n+  void __tsan_write2_pc(void *addr, void *pc) WEAK;\n+  void __tsan_write4_pc(void *addr, void *pc) WEAK;\n+  void __tsan_write8_pc(void *addr, void *pc) WEAK;\n+}\n+\n+#endif  \/\/ SHARE_TSAN_TSANEXTERNALDECLS_HPP\n","filename":"src\/hotspot\/share\/tsan\/tsanExternalDecls.hpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,537 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n+#include \"gc\/shared\/gcId.hpp\"\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"tsan\/tsanExternalDecls.hpp\"\n+#include \"tsan\/tsanOopMap.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n+extern \"C\" int jio_printf(const char *fmt, ...);\n+\n+#if 0\n+#define DEBUG_PRINT(...) jio_printf(__VA_ARGS__)\n+#else\n+#define DEBUG_PRINT(...)\n+#endif\n+namespace TsanOopMapImpl {\n+\n+  struct PendingMove {\n+    char *source_begin() const { return source_address; }\n+    char *source_end() const { return source_address + n_bytes; }\n+    char *target_begin() const { return target_address; }\n+    char *target_end() const { return target_address + n_bytes; }\n+    char *source_address;\n+    char *target_address;\n+    size_t n_bytes;  \/\/ number of bytes being moved\n+  };\n+\n+  \/\/ Our data\n+  class TsanOopSizeMap *oop_map = NULL;\n+\n+  \/**\n+   * TsanOopSizeMap is a hash map of {oopDesc * -> size}.\n+   *\/\n+  class TsanOopSizeMap : public CHeapObj<mtInternal> {\n+\n+    class TsanOop : public CHeapObj<mtInternal> {\n+      \/* We track the lifecycle (alloc\/move\/free) of interesting oops;\n+       * tsan needs to know. *\/\n+      oopDesc *_oop;  \/\/ key\n+\n+      \/* We cache the oop's size, since we cannot reliably determine it after\n+       * the oop is freed. Size is measured in number of HeapWords. *\/\n+      uintx _oop_size;  \/\/ value\n+\n+    public:\n+      TsanOop():_oop(NULL), _oop_size(0) {}\n+      void set_oop(oopDesc *o, uintx s) { _oop = o; _oop_size = s; }\n+      bool has_oop() const { return _oop != NULL; }\n+      oopDesc *get_oop() const { return _oop; }\n+      uintx get_oop_size() const { return _oop_size; }\n+    };\n+\n+    size_t _size;\n+    size_t _n_elements;\n+    float _load_factor;\n+    TsanOop *_buckets;\n+\n+    static uintx _hash64(uintx key) {\n+      key = ~key + (key << 21);\n+      key ^= (key >> 24);\n+      key += (key << 3) + (key << 8);\n+      key ^= (key >> 14);\n+      key += (key << 2) + (key << 4);\n+      key ^= (key >> 28);\n+      key += (key << 31);\n+      return key;\n+    }\n+\n+    static uintx _hash32(uintx key) {\n+      key = ~key + (key << 15);\n+      key ^= (key >> 12);\n+      key += (key << 2);\n+      key ^= (key >> 4);\n+      key *= 2057;\n+      key ^= (key >> 16);\n+      return key;\n+    }\n+\n+    TsanOop* find_bucket(oopDesc* o) {\n+      uintx h = reinterpret_cast<uintx>((address)o);\n+      TsanOop* bucket;\n+      do {\n+        h = hash(h);\n+        bucket = &_buckets[h % _size];\n+      } while (bucket->has_oop() && bucket->get_oop() != o);\n+      return bucket;\n+    }\n+\n+    static bool collect_oops(BoolObjectClosure* is_alive,\n+                             OopClosure* f,\n+                             GrowableArray<PendingMove>* moves,\n+                             int* n_downward_moves,\n+                             char** min_low,\n+                             char** max_high);\n+\n+    static void handle_overlapping_moves(GrowableArray<PendingMove>& moves,\n+                                         char* min_low,\n+                                         char* max_high);\n+\n+  public:\n+    TsanOopSizeMap(size_t initial_size)\n+        : _size(initial_size), _n_elements(0), _load_factor(0.7) {\n+      _buckets = new TsanOop[_size];\n+    }\n+\n+    ~TsanOopSizeMap() {\n+      delete [] _buckets;\n+    }\n+\n+    static uintx hash(uintx key) {\n+      return (sizeof(uintx) == 4) ? _hash32(key) : _hash64(key);\n+    }\n+\n+    \/\/ Put an oop and oop size into the hash map.\n+    \/\/ Ok to call multiple times on same oop.\n+    \/\/ Return true if seen for first time; else return false.\n+    \/\/ Synchronized in mutator threads with TsanOopMap_lock.\n+    bool put(oopDesc* o, uintx s) {\n+      TsanOop* bucket = find_bucket(o);\n+\n+      if (!bucket->has_oop()) {\n+        if (++_n_elements > _load_factor * _size) {\n+          grow();\n+          bucket = find_bucket(o);\n+        }\n+        bucket->set_oop(o, s);\n+        return true;\n+      } else {\n+        assert(s == bucket->get_oop_size(), \"same oop should have same size\");\n+        return false;\n+      }\n+    }\n+\n+    void grow(void) {\n+      TsanOop *old_buckets = _buckets;\n+      size_t old_size = _size;\n+      _size *= 2;\n+\n+      _buckets = new TsanOop[_size];\n+\n+      for (uintx i = 0; i < old_size; i++) {\n+        if (old_buckets[i].has_oop()) {\n+          put(old_buckets[i].get_oop(), old_buckets[i].get_oop_size());\n+        }\n+      }\n+      delete [] old_buckets;\n+    }\n+\n+    \/\/ Call this function at the end of the garbage collection to\n+    \/\/ notify TSan about object location changes and to build oops map.\n+    static void rebuild_oops_map(BoolObjectClosure *is_alive,\n+                                 OopClosure *pointer_adjuster);\n+\n+#ifdef ASSERT\n+    bool exists(oopDesc *o) const {\n+      uintx h = reinterpret_cast<uintx>((address)o);\n+      TsanOop *bucket = NULL;\n+\n+      do {\n+        h = hash(h);\n+        bucket = &_buckets[h % _size];\n+      } while (bucket->has_oop() && bucket->get_oop() != o);\n+\n+      return bucket->has_oop() && bucket->get_oop() == o;\n+    }\n+#endif\n+\n+    size_t size() const { return _size; }\n+    oopDesc *oop_at(size_t i) const { return _buckets[i].get_oop(); }\n+    uintx oop_size_at(size_t i) const { return _buckets[i].get_oop_size(); }\n+  };\n+\n+  \/\/ Two little callbacks used by sort.\n+  int lessThan(PendingMove *l, PendingMove *r) {\n+    char *left = l->target_begin();\n+    char *right = r->target_begin();\n+    return (left < right) ? -1 : (left == right ? 0 : 1);\n+  }\n+\n+  int moreThan(PendingMove *l, PendingMove *r) {\n+    return lessThan(r, l);\n+  }\n+\n+  \/\/ Maintains the occupancy state of the given heap memory area.\n+  \/\/ TsanOopSizeMap::rebuild_oop_map below uses an instance of this\n+  \/\/ class to order object moves, please see additional comments there.\n+  class OccupancyMap: public StackObj {\n+    \/\/ Internally it is a BitMap. A bit is set if the corresponding HeapWord\n+    \/\/ is currently occupied, cleared otherwise (HeapWord is Java object\n+    \/\/ allocation unit).\n+    char *mem_begin_;\n+    char *mem_end_;\n+    CHeapBitMap bitmap_;\n+    BitMap::idx_t to_idx(char *mem) const {\n+      return (mem - mem_begin_) \/ HeapWordSize;\n+    }\n+  public:\n+    \/\/ NOTE: The constructor creates a bitmap on the resource area.\n+    \/\/ The bitmap can be quite large (it is 16MB per every 1GB of heap,\n+    \/\/ so it is worth releasing it as soon as possible by creating a\n+    \/\/ ResourceMark.\n+    OccupancyMap(char *mem_begin, char *mem_end)\n+        : mem_begin_(mem_begin), mem_end_(mem_end),\n+          bitmap_((mem_end - mem_begin) \/ HeapWordSize) {}\n+    bool is_range_vacant(char *from, char *to) const {\n+      assert(from < to, \"bad range\");\n+      assert(from >= mem_begin_ && from < mem_end_,\n+             \"start address outside range\");\n+      assert(to > mem_begin_ && to <= mem_end_, \"end address outside range\");\n+      BitMap::idx_t idx_to = to_idx(to);\n+      return bitmap_.get_next_one_offset(to_idx(from), idx_to) == idx_to;\n+    }\n+    void range_occupy(char *from, char *to) {\n+      assert(from < to, \"range_occupy: bad range\");\n+      assert(from >= mem_begin_ && from < mem_end_,\n+             \"start address outside range\");\n+      assert(to > mem_begin_ && to <= mem_end_, \"end address outside range\");\n+      bitmap_.set_range(to_idx(from), to_idx(to));\n+    }\n+    void range_vacate(char *from, char *to) {\n+      assert(from < to, \"bad range\");\n+      assert(from >= mem_begin_ && from < mem_end_,\n+             \"start address outside range\");\n+      assert(to > mem_begin_ && to <= mem_end_, \"end address outside range\");\n+      bitmap_.clear_range(to_idx(from), to_idx(to));\n+    }\n+    int bit_count() const {\n+      return bitmap_.size();\n+    }\n+  };\n+\n+  bool TsanOopSizeMap::collect_oops(BoolObjectClosure* is_alive,\n+                                    OopClosure* pointer_adjuster,\n+                                    GrowableArray<PendingMove>* moves,\n+                                    int* n_downward_moves,\n+                                    char** min_low,\n+                                    char** max_high) {\n+    size_t map_size = oop_map->size();\n+\n+    \/\/ Traverse oop map. For each object that survived GC calculate its new\n+    \/\/ oop, add it to the new oop map, and append the move from the source oop\n+    \/\/ to the target one to the moves list. While doing that, collect oop\n+    \/\/ source and target ranges and count the moves that move an object\n+    \/\/ downwards (this is heuristics to order the moves, see below).\n+    TsanOopSizeMap* new_map = new TsanOopSizeMap(map_size \/ 2);\n+    *n_downward_moves = 0;\n+    bool disjoint_regions;\n+    char *source_low = reinterpret_cast<char *>(UINTPTR_MAX);\n+    char *source_high = NULL;\n+    char *target_low = reinterpret_cast<char *>(UINTPTR_MAX);\n+    char *target_high = NULL;\n+    size_t deleted_objects = 0;\n+    size_t unmoved_objects = 0;\n+    size_t total_size_words = 0;\n+    CollectedHeap *heap = Universe::heap();\n+    for (size_t i = 0; i < map_size; i++) {\n+      oopDesc *source_obj = oop_map->oop_at(i);\n+\n+      if (source_obj != NULL && heap->is_in(source_obj)) {\n+        uintx obj_size = oop_map->oop_size_at(i);\n+        size_t obj_size_bytes = obj_size * HeapWordSize;\n+        if (is_alive->do_object_b(source_obj)) {\n+          \/\/ The object survived GC, add its updated oop to the new oops map.\n+          oop target_oop = cast_to_oop((intptr_t)source_obj);\n+          pointer_adjuster->do_oop(&target_oop);\n+          \/\/ The memory pointed by target_oop may not be a valid oop yet,\n+          \/\/ for example the G1 full collector needs to adjust all pointers\n+          \/\/ first, then compacts and moves the objects. In this case\n+          \/\/ TsanOopSizeMap::rebuild_oops_map() is called during the adjust-\n+          \/\/ pointer phase, before the collector moves the objects. Thus,\n+          \/\/ we cannot use heap->is_in() or oopDesc::is_oop() to check\n+          \/\/ target_oop.\n+          assert(heap->is_in(target_oop), \"Adjustment failed\");\n+          oopDesc *target_obj = target_oop;\n+          new_map->put(target_obj, obj_size);\n+          if (target_obj == source_obj) {\n+            ++unmoved_objects;\n+            continue;\n+          }\n+          if (target_obj < source_obj) {\n+            ++(*n_downward_moves);\n+          }\n+          \/\/ Append to the moves list.\n+          PendingMove move = {(char *)source_obj, (char *)target_obj,\n+                              obj_size_bytes};\n+          total_size_words += obj_size;\n+          moves->append(move);\n+\n+          \/\/ Update source and target ranges.\n+          source_low = MIN2(source_low, move.source_begin());\n+          source_high = MAX2(source_high, move.source_end());\n+          target_low = MIN2(target_low, move.target_begin());\n+          target_high = MAX2(target_high, move.target_end());\n+        } else {  \/\/ dead!\n+          __tsan_java_free((char *)source_obj, obj_size_bytes);\n+          ++deleted_objects;\n+        }\n+      }\n+    }\n+\n+    \/\/ Update the oop map.\n+    delete TsanOopMapImpl::oop_map;\n+    TsanOopMapImpl::oop_map = new_map;\n+\n+    disjoint_regions = (source_low >= target_high || source_high <= target_low);\n+    log_debug(gc)(\n+          \"Tsan: map of \" SIZE_FORMAT \" objects, \" SIZE_FORMAT \" deleted, \"\n+          SIZE_FORMAT \" unmoved, \" SIZE_FORMAT \" to move \"\n+          \"(\" SIZE_FORMAT \" words), %soverlap\",\n+          map_size, deleted_objects, unmoved_objects, (size_t)moves->length(),\n+          total_size_words, disjoint_regions ? \"no \" : \"\");\n+\n+    *min_low = MIN2(source_low, target_low);\n+    *max_high = MAX2(source_high, target_high);\n+    return disjoint_regions;\n+  }\n+\n+  void TsanOopSizeMap::handle_overlapping_moves(GrowableArray<PendingMove>& moves,\n+                                                char* min_low,\n+                                                char* max_high) {\n+    \/\/ Populate occupied memory. The bitmap allocated by the OccupancyMap can\n+    \/\/ be fairly large, scope this code and insert a ResourceMark\n+    ResourceMark rm;\n+    OccupancyMap occupied_memory(min_low, max_high);\n+    DEBUG_PRINT(\"%s:%d: %d objects occupying %d words between %p and %p\\n\",\n+                __FUNCTION__, __LINE__, moves.length(),\n+                occupied_memory.bit_count(),\n+                MIN2(source_low, target_low),\n+                MAX2(source_high, target_high));\n+    for (int i = 0; i < moves.length(); ++i) {\n+      PendingMove &m = moves.at(i);\n+      occupied_memory.range_occupy(m.source_begin(), m.source_end());\n+    }\n+\n+    \/\/ Keep traversing moves list until everything is moved\n+    int passes = 0;\n+    for (int remaining_moves = moves.length(); remaining_moves > 0; ) {\n+      ++passes;\n+      int moves_this_cycle = 0;\n+      for (int i = 0; i < moves.length(); ++i) {\n+        if (moves.at(i).n_bytes == 0) {\n+           \/\/ Already moved this one.\n+           continue;\n+        }\n+\n+        \/\/ Check if this move is currently possible.\n+        \/\/ For this, everything in the target region that is not in the source\n+        \/\/ region has to be vacant.\n+        bool can_move;\n+        PendingMove &m = moves.at(i);\n+        if (m.target_begin() < m.source_begin()) {\n+          \/\/ '+++++++' is region being moved, lower addresses are to the left:\n+          \/\/ Moving downwards:\n+          \/\/         ++++++++         SOURCE\n+          \/\/    ++++++++              TARGET\n+          \/\/ or\n+          \/\/              ++++++++    SOURCE\n+          \/\/    ++++++++              TARGET\n+          can_move = occupied_memory.is_range_vacant(\n+              m.target_begin(), MIN2(m.target_end(), m.source_begin()));\n+        } else {\n+          \/\/ Moving upwards:\n+          \/\/    ++++++++              SOURCE\n+          \/\/         ++++++++         TARGET\n+          \/\/ or\n+          \/\/    ++++++++              SOURCE\n+          \/\/              ++++++++    TARGET\n+          can_move = occupied_memory.is_range_vacant(\n+              MAX2(m.source_end(), m.target_begin()), m.target_end());\n+        }\n+        if (can_move) {\n+          \/\/ Notify TSan, update occupied region.\n+          __tsan_java_move(m.source_begin(), m.target_begin(), m.n_bytes);\n+          occupied_memory.range_vacate(m.source_begin(), m.source_end());\n+          occupied_memory.range_occupy(m.target_begin(), m.target_end());\n+          \/\/ Indicate that this move has been done and remember that we\n+          \/\/ made some progress.\n+          m.n_bytes = 0;\n+          ++moves_this_cycle;\n+        }\n+      }\n+      \/\/ We have to make some progress, otherwise bail out:\n+      guarantee(moves_this_cycle, \"Impossible to reconcile GC\");\n+\n+      guarantee(remaining_moves >= moves_this_cycle,\n+                \"Excessive number of moves\");\n+      remaining_moves -= moves_this_cycle;\n+      DEBUG_PRINT(\"%s:%d: %d moved, %d remaining\\n\", __FUNCTION__, __LINE__,\n+                  moves_this_cycle, remaining_moves);\n+    }\n+    log_debug(gc)(\"Tsan: Move %d passes\", passes);\n+  }\n+\n+  void TsanOopSizeMap::rebuild_oops_map(BoolObjectClosure *is_alive,\n+                                        OopClosure *pointer_adjuster) {\n+    ResourceMark rm;\n+    GCTraceTime(Debug, gc) tt_top(\"Tsan relocate\");\n+    GCTraceCPUTime tcpu;\n+    GrowableArray<PendingMove> moves(MAX2((int)(oop_map->size() \/ 100),\n+                                          100000));\n+    bool disjoint_regions;\n+    int n_downward_moves;\n+    char *min_low, *max_high;\n+\n+    {\n+      GCTraceTime(Debug, gc) tt_collect(\"Collect oops\");\n+      disjoint_regions = collect_oops(is_alive, pointer_adjuster, &moves,\n+                                      &n_downward_moves, &min_low, &max_high);\n+    }\n+    if (moves.length() == 0) {\n+      return;\n+    }\n+\n+    \/\/ Notifying TSan is straightforward when source and target regions\n+    \/\/ do not overlap:\n+    if (disjoint_regions) {\n+      GCTraceTime(Debug, gc) tt_disjoint(\"Move between regions\");\n+\n+      for (int i = 0; i < moves.length(); ++i) {\n+        const PendingMove &m = moves.at(i);\n+        __tsan_java_move(m.source_begin(), m.target_begin(), m.n_bytes);\n+      }\n+      return;\n+    }\n+\n+    \/\/ Source and target ranges overlap, the moves need to be ordered to prevent\n+    \/\/ overwriting. Overall, this can take N^2 steps if only one object can be\n+    \/\/ moved during the array traversal; however, when we are dealing with\n+    \/\/ compacting garbage collector, observation shows that the overwhelming\n+    \/\/ majority of the objects move in one direction. If we sort the moves (in\n+    \/\/ the ascending order if dominant direction is downwards, in the descending\n+    \/\/ order otherwise), chances are we will be able to order the moves in a few\n+    \/\/ traversals of the moves array.\n+    {\n+      GCTraceTime(Debug, gc) tt_sort(\"Sort moves\");\n+\n+      moves.sort((2 * n_downward_moves > moves.length()) ? lessThan : moreThan);\n+      log_debug(gc)(\"Tsan: sort %d objects\", moves.length());\n+    }\n+\n+    {\n+      GCTraceTime(Debug, gc) tt_sort(\"Move\");\n+      handle_overlapping_moves(moves, min_low, max_high);\n+    }\n+  }\n+\n+}  \/\/ namespace TsanOopMapImpl\n+\n+\n+void TsanOopMap::initialize_map() {\n+  TsanOopMapImpl::oop_map = new TsanOopMapImpl::TsanOopSizeMap(512);\n+}\n+\n+void TsanOopMap::destroy() {\n+  delete TsanOopMapImpl::oop_map;\n+}\n+\n+void TsanOopMap::weak_oops_do(\n+    BoolObjectClosure* is_alive,\n+    OopClosure* pointer_adjuster) {\n+  if (!ThreadSanitizer) return;\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n+\n+  \/\/ We're mutating oopMap, but we don't need to acquire TsanOopMap_lock:\n+  \/\/ Mutation to map happens at (A) constructor (single threaded) and\n+  \/\/ (B) add (in mutator threads) and (C) do_weak_oops (single-threaded).\n+  \/\/ Calls between add are synchronized.\n+  \/\/ Calls between add and do_weak_oops are synchronized via STW GC.\n+  TsanOopMapImpl::TsanOopSizeMap::rebuild_oops_map(\n+      is_alive, pointer_adjuster);\n+}\n+\n+\/\/ Safe to deal with raw oop; for example this is called in a LEAF function\n+\/\/ There is no safepoint in this code: 1) special mutex is used, and\n+\/\/ 2) there is no VM state transition\n+\/\/ We cannot use ordinary VM mutex, as that requires a state transition.\n+void TsanOopMap::add_oop_with_size(oopDesc *addr, int size) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(TsanOopMapImpl::oop_map != NULL, \"TsanOopMap not initialized\");\n+  guarantee(addr != NULL, \"null oop\");\n+  bool alloc = false;\n+  {\n+    MutexLocker mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ N.B. addr->size() may not be available yet!\n+    alloc = TsanOopMapImpl::oop_map->put(addr, size);\n+  }\n+  if (alloc) {\n+    __tsan_java_alloc(addr, size * HeapWordSize);\n+  }\n+}\n+\n+void TsanOopMap::add_oop(oopDesc *addr) {\n+  \/\/ N.B. oop's size field must be init'ed; else addr->size() crashes.\n+  TsanOopMap::add_oop_with_size(addr, addr->size());\n+}\n+\n+#ifdef ASSERT\n+bool TsanOopMap::exists(oopDesc *addr) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(TsanOopMapImpl::oop_map != NULL, \"TsanOopMap not initialized\");\n+  guarantee(addr != NULL, \"null oop\");\n+  bool in_map = false;\n+  {\n+    MutexLocker mu(TsanOopMap_lock, Mutex::_no_safepoint_check_flag);\n+    in_map = TsanOopMapImpl::oop_map->exists(addr);\n+  }\n+  return in_map;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/tsan\/tsanOopMap.cpp","additions":537,"deletions":0,"binary":false,"changes":537,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_TSAN_TSANOOPMAP_HPP\n+#define SHARE_TSAN_TSANOOPMAP_HPP\n+\n+\/\/ Interface class to manage oop addresses for ThreadSanitizer.\n+\/\/ TSAN needs to keep track of all allocated Java objects, in order to keep\n+\/\/ TSAN's metadata updated. When an object becomes free or moved, there should\n+\/\/ be a call to __tsan_java_free or __tsan_java_move accordingly.\n+\/\/ The map is implemented as a hash map of oop address to oop size.\n+\/\/ Oop size must be cached, as it is unsafe to call size() after reference is\n+\/\/ collected.\n+\/\/ Turn it on with -XX:+ThreadSanitizer\n+\/\/\n+\/\/ Some invariants:\n+\/\/ 1. add_*() is only passed a live oop.\n+\/\/ 2. add_*() must be thread-safe wrt itself.\n+\/\/    (other functions are not called from a multithreaded context)\n+\n+class TsanOopMap : public AllStatic {\n+public:\n+  \/\/ Called by primordial thread to initialize oop mapping.\n+  static void initialize_map();\n+  static void destroy();\n+  \/\/ Called to clean up oops that have been saved in our mapping,\n+  \/\/ but which no longer have other references in the heap.\n+  static void weak_oops_do(BoolObjectClosure* is_alive,\n+                           OopClosure* f);\n+  \/\/ Main operation; must be thread-safe and safepoint-free.\n+  \/\/ Called when an object is used as a monitor.\n+  \/\/ The first time addr is seen, __tsan_java_alloc is called.\n+  static void add_oop(oopDesc* addr);\n+  static void add_oop_with_size(oopDesc* addr, int size);\n+\n+#ifdef ASSERT\n+  static bool exists(oopDesc* addr);\n+#endif\n+};\n+\n+#endif \/\/ SHARE_TSAN_TSANOOPMAP_HPP\n","filename":"src\/hotspot\/share\/tsan\/tsanOopMap.hpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -89,0 +89,1 @@\n+  JVM_ACC_FIELD_TSAN_IGNORE               = 0x00000200, \/\/ TSAN should ignore memory accesses to this field, same as JVM_ACC_INTERFACE\n@@ -94,1 +95,2 @@\n-                                       JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE,\n+                                       JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE |\n+                                       JVM_ACC_FIELD_TSAN_IGNORE,\n@@ -171,0 +173,3 @@\n+#if INCLUDE_TSAN\n+  bool is_tsan_ignore() const           { return (_flags & JVM_ACC_FIELD_TSAN_IGNORE) != 0; }\n+#endif  \/\/ INCLUDE_TSAN\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -272,0 +272,19 @@\n+#ifndef INCLUDE_TSAN\n+#define INCLUDE_TSAN 1\n+#endif\n+\n+#if INCLUDE_TSAN\n+#define TSAN_ONLY(code) code\n+#define TSAN_RUNTIME_ONLY(code) \\\n+    do { \\\n+      if (ThreadSanitizer) { \\\n+        code; \\\n+      } \\\n+    } while (0)\n+#define NOT_TSAN(code)\n+#else\n+#define TSAN_ONLY(code)\n+#define TSAN_RUNTIME_ONLY(code)\n+#define NOT_TSAN(code) code\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -87,0 +87,5 @@\n+                if (TSAN_ENABLED) {\n+                  \/\/ TODO: Move this call to when a batch of finalizers\n+                  \/\/ are added to the queue.\n+                  tsanFinalize();\n+                }\n@@ -179,0 +184,4 @@\n+    private final static boolean TSAN_ENABLED = isTsanEnabled();\n+    private static native boolean isTsanEnabled();\n+    private native void tsanFinalize();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Finalizer.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util.concurrent.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Use this annotation on a field that will be initialized lazily,\n+ * where races yield no semantic difference in the code.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+public @interface LazyInit {}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/annotation\/LazyInit.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -112,0 +112,1 @@\n+    exports java.util.concurrent.annotation;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -216,0 +216,34 @@\n+\n+#ifdef INCLUDE_TSAN\n+\/*\n+ * Because currently we link TSAN runtime with the launcher,\n+ * these functions have to reside in the launcher in order to properly\n+ * override TSAN's internal \"weak\" version of these functions when\n+ * the TSAN runtime is initialized, which happens in ELF .preinit_array.\n+ * 'visibility(\"default\")' is needed due to CFLAGS '-fvisibility=hidden'.\n+ *\/\n+\n+\/*\n+ * Override ThreadSanitizer's default race suppression list, so Java TSAN\n+ * does not report C\/C++ races within the JVM itself.\n+ *\/\n+__attribute__((visibility(\"default\"))) const char *__tsan_default_suppressions() {\n+  return (\"called_from_lib:\/libjvm.so\\n\"\n+          \"called_from_lib:\/libjimage.so\\n\"\n+          \/\/ Intentional races in java.lang.invoke.* related to counters\n+          \"race:^java.lang.invoke.\\n\"\n+          \/\/ classic lazy init on String.hash\n+          \/\/ TODO: use field suppression\n+          \"race_top:^java.lang.String.hashCode\\n\"\n+          \/\/ Suppress known, benign races in j.c.u\n+          \"race_top:^java.util.concurrent.ConcurrentHashMap\\n\");\n+}\n+\n+__attribute__((visibility(\"default\"))) void __tsan_symbolize_external_ex(\n+    uint64_t loc,\n+    TsanSymbolizeAddFrameFunc add_frame,\n+    void *ctx) {\n+  tsan_symbolize_func(loc, add_frame, ctx);\n+}\n+#endif \/\/ INCLUDE_TSAN\n+\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"java_lang_ref_Finalizer.h\"\n+\n+void __tsan_java_finalize() __attribute__((weak));\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_Finalizer_tsanFinalize(JNIEnv *env, jclass unused)\n+{\n+  __tsan_java_finalize();\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_lang_ref_Finalizer_isTsanEnabled(JNIEnv *env, jclass unused)\n+{\n+  return JVM_GetTsanEnabled(env);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjava\/Finalizer.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -222,0 +222,8 @@\n+#ifdef INCLUDE_TSAN\n+\/*\n+ * Function pointer to JVM's TSAN symbolize function.\n+ *\/\n+__attribute__((visibility(\"default\")))\n+TsanSymbolize_t tsan_symbolize_func = NULL;\n+#endif\n+\n@@ -301,0 +309,3 @@\n+#ifdef INCLUDE_TSAN\n+    tsan_symbolize_func = ifn.TsanSymbolize;\n+#endif\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -76,0 +76,7 @@\n+#ifdef INCLUDE_TSAN\n+typedef void (*TsanSymbolizeAddFrameFunc)(\n+    void *ctx, const char *function, const char *file, int line, int column);\n+typedef void (JNICALL *TsanSymbolize_t)(uint64_t, TsanSymbolizeAddFrameFunc, void *);\n+extern TsanSymbolize_t tsan_symbolize_func;\n+#endif\n+\n@@ -87,0 +94,3 @@\n+#ifdef INCLUDE_TSAN\n+    TsanSymbolize_t TsanSymbolize;\n+#endif\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -560,0 +560,9 @@\n+#ifdef INCLUDE_TSAN\n+    ifn->TsanSymbolize = (TsanSymbolize_t)\n+        dlsym(libjvm, \"TsanSymbolize\");\n+    if (ifn->TsanSymbolize == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+#endif\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This class forms the basis for a regression suite against Tsan\/Java.\n+ *\n+ * <p>This class abstracts away the tedium of setting up two threads to run a method in a loop.\n+ * Usually, we want to run the same method in two threads.\n+ *\n+ * <p>Usually, we want to set up a unique piece of shared data and access it in a variety of ways:\n+ * with synchronization, without, etc.\n+ *\n+ * <p>Each subclass will override run().\n+ *\/\n+abstract class AbstractLoop {\n+  static final int LOOPS = 50000;\n+  static final int LOOPS_SYNC = 500;\n+\n+  static final Thread.UncaughtExceptionHandler HANDLER =\n+      new Thread.UncaughtExceptionHandler() {\n+        @Override\n+        public void uncaughtException(Thread th, Throwable ex) {\n+          System.err.println(\"Uncaught Exception in thread \" + th.getName());\n+          ex.printStackTrace();\n+          System.exit(1);\n+        }\n+      };\n+\n+  \/** Implement only this method for symmetric behavior. *\/\n+  protected abstract void run(int i);\n+\n+  \/** Override this method for asymmetric behavior. *\/\n+  protected void run2(int i) {\n+    run(i);\n+  }\n+\n+  \/** Called before an iteration in runInTwoThreadsSync(). *\/\n+  protected void syncSetup() {\n+  }\n+\n+  \/** Repeatedly run run() in one thread and run2() in another thread in parallel. *\/\n+  final void runInTwoThreads() throws InterruptedException {\n+    System.err.println(\"Begin \" + name);\n+\n+    final Thread t1 =\n+        new Thread(\n+            () -> {\n+              for (int i = 0; i < LOOPS; i++) {\n+                AbstractLoop.this.run(i);\n+              }\n+            });\n+    final Thread t2 =\n+        new Thread(\n+            () -> {\n+              for (int i = 0; i < LOOPS; i++) {\n+                AbstractLoop.this.run2(i);\n+              }\n+            });\n+\n+    t1.setUncaughtExceptionHandler(HANDLER);\n+    t2.setUncaughtExceptionHandler(HANDLER);\n+    t1.start();\n+    t2.start();\n+\n+    t1.join();\n+    t2.join();\n+\n+    System.err.println(\"End   \" + name);\n+  }\n+\n+  \/** Create two threads to run run() and run2() in parallel, then join them, then repeat. *\/\n+  final void runInTwoThreadsSync() throws InterruptedException {\n+    System.err.println(\"Begin \" + name);\n+\n+    for (int i = 0; i < LOOPS_SYNC; i++) {\n+      AbstractLoop.this.syncSetup();\n+\n+      final int x = i;\n+      final Thread t1 =\n+          new Thread(\n+              () -> {\n+                AbstractLoop.this.run(x);\n+              });\n+      final Thread t2 =\n+          new Thread(\n+              () -> {\n+                AbstractLoop.this.run2(x);\n+              });\n+\n+      t1.setUncaughtExceptionHandler(HANDLER);\n+      t2.setUncaughtExceptionHandler(HANDLER);\n+      if (i % 2 == 0) {\n+        t1.start();\n+        t2.start();\n+      } else {\n+        t2.start();\n+        t1.start();\n+      }\n+\n+      t1.join();\n+      t2.join();\n+    }\n+\n+    System.err.println(\"End   \" + name);\n+  }\n+\n+  private String name;\n+\n+  public AbstractLoop() {\n+    name = this.getClass().getSimpleName();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/AbstractLoop.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This is a subclass of AbstractLoop that allows calling native code.\n+ *\/\n+abstract class AbstractNativeLoop extends AbstractLoop {\n+  static {\n+    System.loadLibrary(\"AbstractNativeLoop\");\n+  }\n+\n+  protected static native void writeNativeGlobal();\n+  protected static native void writeNativeGlobalSync();\n+  protected static native int readNativeGlobal();\n+\n+  protected static native long createRawLock();\n+  protected static native void writeRawLockedNativeGlobal(long lock);\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/AbstractNativeLoop.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test ChildThreadExceptionTest\n+ * @summary Test that exception in child thread would trigger non-zero exit code\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main ChildThreadExceptionTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ChildThreadExceptionTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTest(ChildThreadExceptionTestRunner.class, new String[0]).shouldNotHaveExitValue(0);\n+  }\n+}\n+\n+class ChildThreadExceptionTestRunner extends AbstractLoop {\n+  @Override\n+  protected void run(int i) {\n+    throw new NullPointerException();\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    ChildThreadExceptionTestRunner loop = new ChildThreadExceptionTestRunner();\n+    loop.runInTwoThreads();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/ChildThreadExceptionTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test FieldIgnoreAnyPrimitiveLoopTest\n+ * @summary Test that the field ignore list's wildcard matches a primitive.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main FieldIgnoreAnyPrimitiveLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class FieldIgnoreAnyPrimitiveLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    Path ignoreFile = Paths.get(System.getProperty(\"test.src\"), \"IgnoreFields\");\n+    TsanRunner.runTsanTestExpectSuccess(FieldIgnoreAnyPrimitiveLoopRunner.class, \"-XX:ThreadSanitizerIgnoreFile=\" + ignoreFile);\n+  }\n+}\n+\n+class FieldIgnoreAnyPrimitiveLoopRunner extends AbstractLoop {\n+  private int x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    FieldIgnoreAnyPrimitiveLoopRunner loop = new FieldIgnoreAnyPrimitiveLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/FieldIgnoreAnyPrimitiveLoopTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test FieldIgnoreAnyReferenceLoopTest\n+ * @summary Test that the field ignore list's wildcard doesn't match a\n+ *          reference.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main FieldIgnoreAnyReferenceLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class FieldIgnoreAnyReferenceLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    Path ignoreFile = Paths.get(System.getProperty(\"test.src\"), \"IgnoreFields\");\n+    TsanRunner.runTsanTestExpectFailure(FieldIgnoreAnyReferenceLoopRunner.class, \"-XX:ThreadSanitizerIgnoreFile=\" + ignoreFile)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 FieldIgnoreAnyReferenceLoopRunner.run(I)V FieldIgnoreAnyReferenceLoopTest.java:\");\n+  }\n+}\n+\n+class FieldIgnoreAnyReferenceLoopRunner extends AbstractLoop {\n+  private String x = \"\";\n+\n+  @Override\n+  protected void run(int i) {\n+    x = x.isEmpty() ? \" \" : \"\";\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    FieldIgnoreAnyReferenceLoopRunner loop = new FieldIgnoreAnyReferenceLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/FieldIgnoreAnyReferenceLoopTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test FieldIgnoreLoopTest\n+ * @summary Test that the field ignore list works.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main FieldIgnoreLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class FieldIgnoreLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    Path ignoreFile = Paths.get(System.getProperty(\"test.src\"), \"IgnoreFields\");\n+    TsanRunner.runTsanTestExpectSuccess(FieldIgnoreLoopRunner.class, \"-XX:ThreadSanitizerIgnoreFile=\" + ignoreFile);\n+  }\n+}\n+\n+class FieldIgnoreLoopRunner extends AbstractLoop {\n+  private int x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    FieldIgnoreLoopRunner loop = new FieldIgnoreLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/FieldIgnoreLoopTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test FieldIgnorePrefixLoopTest\n+ * @summary Test that the field ignore list prefix matching works.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main FieldIgnorePrefixLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class FieldIgnorePrefixLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    Path ignoreFile = Paths.get(System.getProperty(\"test.src\"), \"IgnoreFields\");\n+    TsanRunner.runTsanTestExpectSuccess(FieldIgnorePrefixLoopRunner.class, \"-XX:ThreadSanitizerIgnoreFile=\" + ignoreFile);\n+  }\n+}\n+\n+class FieldIgnorePrefixLoopRunner extends AbstractLoop {\n+  private int tsanIsAwesome = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    tsanIsAwesome = tsanIsAwesome + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    FieldIgnorePrefixLoopRunner loop = new FieldIgnorePrefixLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"tsanIsAwesome = \" + loop.tsanIsAwesome);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/FieldIgnorePrefixLoopTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test FieldIgnorePrefixNoMatchLoopTest\n+ * @summary Test that the field ignore list prefix matching works.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main FieldIgnorePrefixNoMatchLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class FieldIgnorePrefixNoMatchLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    Path ignoreFile = Paths.get(System.getProperty(\"test.src\"), \"IgnoreFields\");\n+    TsanRunner.runTsanTestExpectFailure(FieldIgnorePrefixNoMatchLoopRunner.class, \"-XX:ThreadSanitizerIgnoreFile=\" + ignoreFile)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 FieldIgnorePrefixNoMatchLoopRunner.run(I)V FieldIgnorePrefixNoMatchLoopTest.java:\");\n+  }\n+}\n+\n+class FieldIgnorePrefixNoMatchLoopRunner extends AbstractLoop {\n+  private int tsanIsGood = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    tsanIsGood = tsanIsGood + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    FieldIgnorePrefixNoMatchLoopRunner loop = new FieldIgnorePrefixNoMatchLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"tsanIsGood = \" + loop.tsanIsGood);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/FieldIgnorePrefixNoMatchLoopTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+# comment\n+FieldIgnoreLoopRunner x\n+# some other comment\n+FieldIgnoreAnyPrimitiveLoopRunner *\n+FieldIgnoreAnyReferenceLoopRunner *\n+\n+FieldIgnorePrefixLoopRunner tsanIsAwe*\n","filename":"test\/hotspot\/jtreg\/tsan\/IgnoreFields","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test JvmtiTaggerTest\n+ * @summary Test that JVMTI tag system is determined to be non-racy.\n+ * @library \/test\/lib\n+ * @build AbstractLoop AbstractNativeLoop TsanRunner\n+ * @run main\/othervm\/native JvmtiTaggerTest\n+ *\/\n+\n+import java.io.IOException;\n+\n+public class JvmtiTaggerTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(JvmtiTaggerLoopRunner.class,\n+        \"-agentlib:AbstractNativeLoop\");\n+  }\n+}\n+\n+class JvmtiTaggerLoopRunner extends AbstractNativeLoop {\n+  private static native boolean addTagAndReference(Object object);\n+  private static native boolean iterateOverTags();\n+\n+  @Override\n+  protected void run(int loopIndex) {\n+    \/\/ Just create objects for the first ten indices.\n+    if (loopIndex < 10) {\n+      Object object = new Object();\n+      if (!addTagAndReference(object)) {\n+        throw new RuntimeException(\"Adding a tag failed...\");\n+      }\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    JvmtiTaggerLoopRunner loop = new JvmtiTaggerLoopRunner();\n+    loop.runInTwoThreads();\n+\n+    if (!iterateOverTags()) {\n+      throw new RuntimeException(\"Didn't iterate correctly.\");\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/JvmtiTaggerTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test LazyInitLoopTest\n+ * @summary Test that a simple Java data race is not reported when annotated\n+ *          with java.util.concurrent.annotation.LazyInit.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main LazyInitLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.concurrent.annotation.LazyInit;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LazyInitLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(LazyInitLoopRunner.class);\n+  }\n+}\n+\n+class LazyInitLoopRunner extends AbstractLoop {\n+  @LazyInit\n+  private int x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    LazyInitLoopRunner loop = new LazyInitLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.format(\"x = %d\\n\", loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/LazyInitLoopTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test LazyInitReferenceLoopTest\n+ * @summary Test that accessing the member variables of a lazily initialized\n+ *          reference field annotated with\n+ *          java.util.concurrent.annotation.LazyInit does not cause TSAN to\n+ *          complain.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main LazyInitReferenceLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.concurrent.annotation.LazyInit;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LazyInitReferenceLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(LazyInitReferenceLoopRunner.class);\n+  }\n+}\n+\n+class LazyInitReferenceLoopRunner extends AbstractLoop {\n+  static class Foo {\n+    int bar;\n+  }\n+  @LazyInit\n+  Foo foo;\n+\n+  @Override\n+  public void run(int i) {\n+    foo = null;\n+    Foo f = foo;\n+    if (f == null) {\n+      f = new Foo();\n+      f.bar = 99;\n+      foo = f;\n+    }\n+    int ignore = f.bar;\n+    if (i == 0) {\n+      \/\/ We don't want to print on every iteration,\n+      \/\/ but also don't want the compiler to remove the read of f.bar.\n+      System.out.println(\"ignore: \" + ignore);\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    LazyInitReferenceLoopRunner loop = new LazyInitReferenceLoopRunner();\n+    loop.runInTwoThreads();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/LazyInitReferenceLoopTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyBooleanArrayLoopTest\n+ * @summary Test a simple Java non-racy memory access via a boolean array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyBooleanArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyBooleanArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyBooleanArrayLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyBooleanArrayLoopRunner extends AbstractLoop {\n+  private boolean[] x = new boolean[2];\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x[0] = !x[0];\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyBooleanArrayLoopRunner loop = new NonRacyBooleanArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyBooleanArrayLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyBooleanMemberLoopTest\n+ * @summary Test a simple Java non-racy memory access via a boolean field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyBooleanMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyBooleanMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyBooleanMemberLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyBooleanMemberLoopRunner extends AbstractLoop {\n+  private boolean x = false;\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = !x;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyBooleanMemberLoopRunner loop = new NonRacyBooleanMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyBooleanMemberLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyByteArrayLoopTest\n+ * @summary Test a simple Java non-racy memory access via a byte array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyByteArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyByteArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyByteArrayLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyByteArrayLoopRunner extends AbstractLoop {\n+  private byte[] x = new byte[2];\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x[0] = (byte) (x[0] + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyByteArrayLoopRunner loop = new NonRacyByteArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyByteArrayLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyByteMemberLoopTest\n+ * @summary Test a simple Java non-racy memory access via a byte field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyByteMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyByteMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyByteMemberLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyByteMemberLoopRunner extends AbstractLoop {\n+  private byte x = 0;\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = (byte) (x + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyByteMemberLoopRunner loop = new NonRacyByteMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyByteMemberLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyCasLoopTest\n+ * @summary Test that TSAN properly sees Unsafe CAS.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main NonRacyCasLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyCasLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyCasLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyCasLoopRunner extends AbstractLoop {\n+  int intVar = 0;\n+  long longVar = 0;\n+  Object objVar = null;\n+  int x, y, z;\n+\n+  static final long INT_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyCasLoopRunner.class, \"intVar\");\n+  static final long LONG_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyCasLoopRunner.class, \"longVar\");\n+  static final long OBJ_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyCasLoopRunner.class, \"objVar\");\n+\n+  @Override\n+  public void run(int i) {\n+    while (!UnsafeUtil.UNSAFE.compareAndSwapInt(this, INT_VAR_OFFSET, 0, 1)) {\n+      ;\n+    }\n+    x = x + 1;\n+    UnsafeUtil.UNSAFE.compareAndSwapInt(this, INT_VAR_OFFSET, 1, 0);\n+\n+    while (!UnsafeUtil.UNSAFE.compareAndSwapLong(this, LONG_VAR_OFFSET, 0, 1)) {\n+      ;\n+    }\n+    y = y + 1;\n+    UnsafeUtil.UNSAFE.compareAndSwapLong(this, LONG_VAR_OFFSET, 1, 0);\n+\n+    Object foo = new Object();\n+    while (!UnsafeUtil.UNSAFE.compareAndSwapObject(this, OBJ_VAR_OFFSET, null, foo)) {\n+      ;\n+    }\n+    z = z + 1;\n+    UnsafeUtil.UNSAFE.compareAndSwapObject(this, OBJ_VAR_OFFSET, foo, null);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyCasLoopRunner loop = new NonRacyCasLoopRunner();\n+    loop.runInTwoThreads();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyCasLoopTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyCharArrayLoopTest\n+ * @summary Test a simple Java non-racy memory access via a char array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyCharArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyCharArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyCharArrayLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyCharArrayLoopRunner extends AbstractLoop {\n+  private char[] x = new char[2];\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x[0] = (char) (x[0] + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyCharArrayLoopRunner loop = new NonRacyCharArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyCharArrayLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyCharMemberLoopTest\n+ * @summary Test a simple Java non-racy memory access via a char field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyCharMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyCharMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyCharMemberLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyCharMemberLoopRunner extends AbstractLoop {\n+  private char x = 0;\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = (char) (x + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyCharMemberLoopRunner loop = new NonRacyCharMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyCharMemberLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyDoubleArrayLoopTest\n+ * @summary Test a simple Java non-racy memory access via a double array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyDoubleArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyDoubleArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyDoubleArrayLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyDoubleArrayLoopRunner extends AbstractLoop {\n+  private double[] x = new double[2];\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x[0] = x[0] + 1.0;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyDoubleArrayLoopRunner loop = new NonRacyDoubleArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyDoubleArrayLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyDoubleMemberLoopTest\n+ * @summary Test a simple Java non-racy memory access via a double field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyDoubleMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyDoubleMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyDoubleMemberLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyDoubleMemberLoopRunner extends AbstractLoop {\n+  private double x = 0.0;\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1.0;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyDoubleMemberLoopRunner loop = new NonRacyDoubleMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyDoubleMemberLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyFinalizerLoopTest\n+ * @summary Test that finalizers are not racy.\n+ * @library \/test\/lib\n+ * @build TsanRunner\n+ * @run main NonRacyFinalizerLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyFinalizerLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyFinalizerLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyFinalizerLoopRunner {\n+  static class Foo {\n+    int x;\n+\n+    public Foo() {\n+      x = 5;\n+    }\n+\n+    @Override\n+    public void finalize() {\n+      x = 7;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    for (int i = 0; i < 100; ++i) {\n+      Foo foo = new Foo();\n+      foo.x = 5;\n+      System.gc();\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyFinalizerLoopTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyFloatArrayLoopTest\n+ * @summary Test a simple Java non-racy memory access via a float array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyFloatArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyFloatArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyFloatArrayLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyFloatArrayLoopRunner extends AbstractLoop {\n+  private float[] x = new float[2];\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x[0] = x[0] + 1.0f;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyFloatArrayLoopRunner loop = new NonRacyFloatArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyFloatArrayLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyFloatMemberLoopTest\n+ * @summary Test a simple Java non-racy memory access via a float field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyFloatMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyFloatMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyFloatMemberLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyFloatMemberLoopRunner extends AbstractLoop {\n+  private float x = 0;\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1.0f;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyFloatMemberLoopRunner loop = new NonRacyFloatMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyFloatMemberLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyGarbageCollectionLoopTest\n+ * @summary Test that objects are tracked correctly when garbage collection happens.\n+ * @library \/test\/lib\n+ * @requires vm.gc == null\n+ * @build AbstractLoop TsanRunner\n+ * @run main\/othervm -XX:+UseParallelGC NonRacyGarbageCollectionLoopTest\n+ * @run main\/othervm -XX:+UseG1GC NonRacyGarbageCollectionLoopTest\n+ * @run main\/othervm -XX:+UseSerialGC NonRacyGarbageCollectionLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyGarbageCollectionLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyGarbageCollectionLoopRunner.class, \"-Xms40m\", \"-Xmx40m\");\n+  }\n+}\n+\n+class NonRacyGarbageCollectionLoopRunner extends AbstractLoop {\n+  private static final int MEG = 1024 * 1024;\n+  \/\/ NOTE: If HEAP_SIZE changes, make sure also change -Xms and -Xmx values above.\n+  private static final int HEAP_SIZE = 40 * MEG;\n+  \/\/ Allocate byte arrays that sum up to about 4 times of heap size,\n+  \/\/ assuming 2 threads and each allocates AbstractLoop.LOOPS times.\n+  \/\/ Thus garbage collection must have happened and the same address\n+  \/\/ will be reused to allocate a new object.\n+  private static final int BYTE_ARRAY_LENGTH = HEAP_SIZE * 4 \/ 2 \/ AbstractLoop.LOOPS;\n+\n+  private volatile byte[] array;\n+\n+  @Override\n+  protected void run(int i) {\n+    byte[] arr = new byte[BYTE_ARRAY_LENGTH];\n+    for (int j = 0; j < BYTE_ARRAY_LENGTH; j++) {\n+      arr[j] = 42;\n+    }\n+    array = arr;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyGarbageCollectionLoopRunner loop = new NonRacyGarbageCollectionLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"array[0] = \" + loop.array[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyGarbageCollectionLoopTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyIntArrayLoopTest\n+ * @summary Test a simple Java non-racy memory access via an int array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyIntArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyIntArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyIntArrayLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyIntArrayLoopRunner extends AbstractLoop {\n+  private int[] x = new int[2];\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x[0] = x[0] + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyIntArrayLoopRunner loop = new NonRacyIntArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyIntArrayLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyIntMemberLoopTest\n+ * @summary Test a simple Java non-racy memory access via an int field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyIntMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyIntMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyIntMemberLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyIntMemberLoopRunner extends AbstractLoop {\n+  private int x = 0;\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyIntMemberLoopRunner loop = new NonRacyIntMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyIntMemberLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyLongArrayLoopTest\n+ * @summary Test a simple Java non-racy memory access via a long array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyLongArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyLongArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyLongArrayLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyLongArrayLoopRunner extends AbstractLoop {\n+  private long[] x = new long[2];\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x[0] = x[0] + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyLongArrayLoopRunner loop = new NonRacyLongArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyLongArrayLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyLongMemberLoopTest\n+ * @summary Test a simple Java non-racy memory access via a long field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyLongMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyLongMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyLongMemberLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyLongMemberLoopRunner extends AbstractLoop {\n+  private long x = 0;\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyLongMemberLoopRunner loop = new NonRacyLongMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyLongMemberLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyNativeLoopNativeSyncTest\n+ * @summary Test that native code protected by native synchronization is not racy.\n+ * @library \/test\/lib\n+ * @build AbstractLoop AbstractNativeLoop TsanRunner\n+ * @run main\/othervm\/native NonRacyNativeLoopNativeSyncTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyNativeLoopNativeSyncTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyNativeLoopNativeSyncRunner.class);\n+  }\n+}\n+\n+class NonRacyNativeLoopNativeSyncRunner extends AbstractNativeLoop {\n+  @Override\n+  protected void run(int i) {\n+    writeNativeGlobalSync();\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyNativeLoopNativeSyncRunner loop = new NonRacyNativeLoopNativeSyncRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"native_global = \" + loop.readNativeGlobal());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyNativeLoopNativeSyncTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyNativeLoopTest\n+ * @summary Test that native code protected by Java synchronization is not racy.\n+ * @library \/test\/lib\n+ * @build AbstractLoop AbstractNativeLoop TsanRunner\n+ * @run main\/othervm\/native NonRacyNativeLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyNativeLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyNativeLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyNativeLoopRunner extends AbstractNativeLoop {\n+  @Override\n+  protected synchronized void run(int i) {\n+    writeNativeGlobal();\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyNativeLoopRunner loop = new NonRacyNativeLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"native_global = \" + loop.readNativeGlobal());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyNativeLoopTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyShortArrayLoopTest\n+ * @summary Test a simple Java non-racy memory access via a short array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyShortArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyShortArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyShortArrayLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyShortArrayLoopRunner extends AbstractLoop {\n+  private short[] x = new short[2];\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x[0] = (short) (x[0] + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyShortArrayLoopRunner loop = new NonRacyShortArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyShortArrayLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyShortMemberLoopTest\n+ * @summary Test a simple Java non-racy memory access via a short field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyShortMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyShortMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyShortMemberLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyShortMemberLoopRunner extends AbstractLoop {\n+  private short x = 0;\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = (short) (x + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyShortMemberLoopRunner loop = new NonRacyShortMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyShortMemberLoopTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyStaticInitLoopTest\n+ * @summary Test that static initialization is not reported as racy later on.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyStaticInitLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+\n+public class NonRacyStaticInitLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyStaticInitLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyStaticInitLoopRunner {\n+  private static int x;\n+\n+  static {\n+    x = 5;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    Thread t =\n+        new Thread(\n+            () -> {\n+              x = 2;\n+            });\n+    t.start();\n+    t.join();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyStaticInitLoopTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyStringArrayLoopTest\n+ * @summary Test a simple Java non-racy memory access via a String array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyStringArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyStringArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyStringArrayLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyStringArrayLoopRunner extends AbstractLoop {\n+  private String[] x = new String[] {\"a\", \"b\"};\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    char c = x[0].charAt(0);\n+    x[0] = Character.toString(c);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyStringArrayLoopRunner loop = new NonRacyStringArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyStringArrayLoopTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyStringMemberLoopTest\n+ * @summary Test a simple Java non-racy memory access via a String field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyStringMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyStringMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyStringMemberLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyStringMemberLoopRunner extends AbstractLoop {\n+  private String x = \"a\";\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    char c = x.charAt(0);\n+    x = Character.toString(c);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyStringMemberLoopRunner loop = new NonRacyStringMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyStringMemberLoopTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacySyncBlockExceptionLoopTest\n+ * @summary Test a simple Java non-racy memory access via an int field in a\n+ *          synchronized block that throws an exception.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacySyncBlockExceptionLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacySyncBlockExceptionLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacySyncBlockExceptionLoopRunner.class);\n+  }\n+}\n+\n+class NonRacySyncBlockExceptionLoopRunner extends AbstractLoop {\n+  private static class LoopException extends Exception {}\n+  private int x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    try {\n+      synchronized (this) {\n+        x = x + 1;\n+        throw new LoopException();\n+      }\n+    } catch (LoopException e) {\n+      \/\/ expected\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacySyncBlockExceptionLoopRunner loop = new NonRacySyncBlockExceptionLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacySyncBlockExceptionLoopTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacySyncBlockLoopTest\n+ * @summary Test a simple Java non-racy memory access via an int field in a\n+ *          synchronized block.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacySyncBlockLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacySyncBlockLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacySyncBlockLoopRunner.class);\n+  }\n+}\n+\n+class NonRacySyncBlockLoopRunner extends AbstractLoop {\n+  private int x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    synchronized (this) {\n+      x = x + 1;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacySyncBlockLoopRunner loop = new NonRacySyncBlockLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacySyncBlockLoopTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyUnsafeLoopTest\n+ * @summary Test non-racy Unsafe accesses.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main NonRacyUnsafeLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyUnsafeLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyUnsafeLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyUnsafeLoopRunner extends AbstractLoop {\n+  byte byteVar = 0x42;\n+  char charVar = 'a';\n+  short shortVar = 10;\n+  int intVar = 11;\n+  long longVar = 12;\n+  float floatVar = 1.0f;\n+  double doubleVar = 2.0;\n+  String stringVar = \"f\";\n+\n+  static final long BYTE_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeLoopRunner.class, \"byteVar\");\n+  static final long CHAR_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeLoopRunner.class, \"charVar\");\n+  static final long SHORT_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeLoopRunner.class, \"shortVar\");\n+  static final long INT_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeLoopRunner.class, \"intVar\");\n+  static final long LONG_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeLoopRunner.class, \"longVar\");\n+  static final long FLOAT_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeLoopRunner.class, \"floatVar\");\n+  static final long DOUBLE_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeLoopRunner.class, \"doubleVar\");\n+  static final long STRING_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeLoopRunner.class, \"stringVar\");\n+\n+  @Override\n+  public synchronized void run(int i) {\n+    byteVar = (byte) (byteVar + 1);\n+    charVar = (char) (charVar + 1);\n+    shortVar = (short) (charVar + 1);\n+    intVar = intVar + 1;\n+    longVar = (long) (longVar + 2);\n+    floatVar = (float) (floatVar + 0.1);\n+    doubleVar = (double) (doubleVar + 0.01);\n+    char c = (char) (stringVar.charAt(0) + 1);\n+    stringVar = Character.toString(c);\n+  }\n+\n+  @Override\n+  public synchronized void run2(int i) {\n+    UnsafeUtil.UNSAFE.putByte(this, BYTE_VAR_OFFSET, (byte) (UnsafeUtil.UNSAFE.getByte(this, BYTE_VAR_OFFSET) + 1));\n+    UnsafeUtil.UNSAFE.putChar(this, CHAR_VAR_OFFSET, (char) (UnsafeUtil.UNSAFE.getChar(this, CHAR_VAR_OFFSET) + 1));\n+    UnsafeUtil.UNSAFE.putShort(this, SHORT_VAR_OFFSET, (short) (UnsafeUtil.UNSAFE.getShort(this, SHORT_VAR_OFFSET) + 2));\n+    UnsafeUtil.UNSAFE.putInt(this, INT_VAR_OFFSET, (int) (UnsafeUtil.UNSAFE.getInt(this, INT_VAR_OFFSET) + 3));\n+    UnsafeUtil.UNSAFE.putLong(this, LONG_VAR_OFFSET, (long) (UnsafeUtil.UNSAFE.getLong(this, LONG_VAR_OFFSET) + 4));\n+    UnsafeUtil.UNSAFE.putFloat(\n+        this, FLOAT_VAR_OFFSET, (float) (UnsafeUtil.UNSAFE.getFloat(this, FLOAT_VAR_OFFSET) + 0.1));\n+    UnsafeUtil.UNSAFE.putDouble(\n+        this, DOUBLE_VAR_OFFSET, (double) (UnsafeUtil.UNSAFE.getDouble(this, DOUBLE_VAR_OFFSET) + 0.2));\n+    char c = (char) (((String) UnsafeUtil.UNSAFE.getObject(this, STRING_VAR_OFFSET)).charAt(0) + 1);\n+    UnsafeUtil.UNSAFE.putObject(this, STRING_VAR_OFFSET, Character.toString(c));\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyUnsafeLoopRunner loop = new NonRacyUnsafeLoopRunner();\n+    loop.runInTwoThreads();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyUnsafeLoopTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyUnsafeVolatileLoopTest\n+ * @summary Test that unsafe volatile accesses properly introduce synchronization.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyUnsafeVolatileLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyUnsafeVolatileLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyUnsafeVolatileLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyUnsafeVolatileLoopRunner extends AbstractLoop {\n+  private byte b;\n+  private String s;\n+  static final long BYTE_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeVolatileLoopRunner.class, \"b\");\n+  static final long STRING_VAR_OFFSET =\n+      UnsafeUtil.objectFieldOffset(NonRacyUnsafeVolatileLoopRunner.class, \"s\");\n+  int data1;\n+  int data2;\n+\n+  @Override\n+  protected void syncSetup() {\n+    b = 1;\n+    s = \"a\";\n+  }\n+\n+  @Override\n+  protected void run(int i) {\n+    data1 = 42;\n+    UnsafeUtil.UNSAFE.putByteVolatile(this, BYTE_VAR_OFFSET, (byte) 2);\n+\n+    data2 = 43;\n+    UnsafeUtil.UNSAFE.putObjectVolatile(this, STRING_VAR_OFFSET, \"b\");\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    while (UnsafeUtil.UNSAFE.getByteVolatile(this, BYTE_VAR_OFFSET) != 2) {\n+      ;\n+    }\n+    int x = data1;\n+    while (!((String) UnsafeUtil.UNSAFE.getObjectVolatile(this, STRING_VAR_OFFSET)).equals(\"b\")) {\n+      ;\n+    }\n+    x = data2;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyUnsafeVolatileLoopRunner loop = new NonRacyUnsafeVolatileLoopRunner();\n+    loop.runInTwoThreadsSync();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyUnsafeVolatileLoopTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRacyVolatileLoopTest\n+ * @summary Test that volatile field accesses properly introduce synchronization.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main NonRacyVolatileLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NonRacyVolatileLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRacyVolatileLoopRunner.class);\n+  }\n+}\n+\n+class NonRacyVolatileLoopRunner extends AbstractLoop {\n+  private volatile byte b;\n+  private volatile String s;\n+  int data1;\n+  int data2;\n+\n+  @Override\n+  protected void syncSetup() {\n+    b = 1;\n+    s = \"a\";\n+  }\n+\n+  @Override\n+  protected void run(int i) {\n+    data1 = 42;\n+    b = 2;\n+\n+    data2 = 43;\n+    s = \"b\";\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    while (b != 2) {\n+      ;\n+    }\n+    int x = data1;\n+    while (!s.equals(\"b\")) {\n+      ;\n+    }\n+    x = data2;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRacyVolatileLoopRunner loop = new NonRacyVolatileLoopRunner();\n+    loop.runInTwoThreadsSync();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRacyVolatileLoopTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test NonRawRacyNativeLoopTest\n+ * @summary Test that native code protected by JVMTI synchronization is not racy.\n+ * @library \/test\/lib\n+ * @build AbstractLoop AbstractNativeLoop TsanRunner\n+ * @run main\/othervm\/native NonRawRacyNativeLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+\n+public class NonRawRacyNativeLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(NonRawRacyNativeLoopRunner.class,\n+        \"-agentlib:AbstractNativeLoop\");\n+  }\n+}\n+\n+class NonRawRacyNativeLoopRunner extends AbstractNativeLoop {\n+  private long lock;\n+\n+  NonRawRacyNativeLoopRunner() {\n+    \/\/ Both threads will use the same lock, so we should be not racy.\n+    lock = createRawLock();\n+  }\n+\n+  @Override\n+  protected void run(int i) {\n+    writeRawLockedNativeGlobal(lock);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    NonRawRacyNativeLoopRunner loop = new NonRawRacyNativeLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"native_global = \" + loop.readNativeGlobal());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/NonRawRacyNativeLoopTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyBooleanArrayLoopTest\n+ * @summary Test a simple Java data race via a boolean array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyBooleanArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyBooleanArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyBooleanArrayLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 1 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyBooleanArrayLoopRunner.run(I)V RacyBooleanArrayLoopTest.java:\");\n+  }\n+}\n+\n+class RacyBooleanArrayLoopRunner extends AbstractLoop {\n+  private boolean[] x = new boolean[2];\n+\n+  @Override\n+  protected void run(int i) {\n+    x[0] = !x[0];\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyBooleanArrayLoopRunner loop = new RacyBooleanArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyBooleanArrayLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyBooleanMemberLoopTest\n+ * @summary Test a simple Java data race via a boolean field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyBooleanMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyBooleanMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyBooleanMemberLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 1 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyBooleanMemberLoopRunner.run(I)V RacyBooleanMemberLoopTest.java:\");\n+  }\n+}\n+\n+class RacyBooleanMemberLoopRunner extends AbstractLoop {\n+  private boolean x = false;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = !x;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyBooleanMemberLoopRunner loop = new RacyBooleanMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyBooleanMemberLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyByteArrayLoopTest\n+ * @summary Test a simple Java data race via a byte array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyByteArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyByteArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyByteArrayLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 1 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyByteArrayLoopRunner.run(I)V RacyByteArrayLoopTest.java:\");\n+  }\n+}\n+\n+class RacyByteArrayLoopRunner extends AbstractLoop {\n+  private byte[] x = new byte[2];\n+\n+  @Override\n+  protected void run(int i) {\n+    x[0] = (byte) (x[0] + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyByteArrayLoopRunner loop = new RacyByteArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyByteArrayLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyByteMemberLoopTest\n+ * @summary Test a simple Java data race via a byte field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyByteMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyByteMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyByteMemberLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 1 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyByteMemberLoopRunner.run(I)V RacyByteMemberLoopTest.java:\");\n+  }\n+}\n+\n+class RacyByteMemberLoopRunner extends AbstractLoop {\n+  private byte x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = (byte) (x + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyByteMemberLoopRunner loop = new RacyByteMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyByteMemberLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyCharArrayLoopTest\n+ * @summary Test a simple Java data race via a char array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyCharArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyCharArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyCharArrayLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 2 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyCharArrayLoopRunner.run(I)V RacyCharArrayLoopTest.java:\");\n+  }\n+}\n+\n+class RacyCharArrayLoopRunner extends AbstractLoop {\n+  private char[] x = new char[2];\n+\n+  @Override\n+  protected void run(int i) {\n+    x[0] = (char) (x[0] + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyCharArrayLoopRunner loop = new RacyCharArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyCharArrayLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyCharMemberLoopTest\n+ * @summary Test a simple Java data race via a char field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyCharMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyCharMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyCharMemberLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 2 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyCharMemberLoopRunner.run(I)V RacyCharMemberLoopTest.java:\");\n+  }\n+}\n+\n+class RacyCharMemberLoopRunner extends AbstractLoop {\n+  private char x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = (char) (x + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyCharMemberLoopRunner loop = new RacyCharMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyCharMemberLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyDoubleArrayLoopTest\n+ * @summary Test a simple Java data race via a double array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyDoubleArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyDoubleArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyDoubleArrayLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 8 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyDoubleArrayLoopRunner.run(I)V RacyDoubleArrayLoopTest.java:\");\n+  }\n+}\n+\n+class RacyDoubleArrayLoopRunner extends AbstractLoop {\n+  private double[] x = new double[2];\n+\n+  @Override\n+  protected void run(int i) {\n+    x[0] = x[0] + 1.0;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyDoubleArrayLoopRunner loop = new RacyDoubleArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyDoubleArrayLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyDoubleMemberLoopTest\n+ * @summary Test a simple Java data race via a double field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyDoubleMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyDoubleMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyDoubleMemberLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 8 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyDoubleMemberLoopRunner.run(I)V RacyDoubleMemberLoopTest.java:\");\n+  }\n+}\n+\n+class RacyDoubleMemberLoopRunner extends AbstractLoop {\n+  private double x = 0.0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = x + 1.0;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyDoubleMemberLoopRunner loop = new RacyDoubleMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyDoubleMemberLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyFloatArrayLoopTest\n+ * @summary Test a simple Java data race via a float array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyFloatArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyFloatArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyFloatArrayLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyFloatArrayLoopRunner.run(I)V RacyFloatArrayLoopTest.java:\");\n+  }\n+}\n+\n+class RacyFloatArrayLoopRunner extends AbstractLoop {\n+  private float[] x = new float[2];\n+\n+  @Override\n+  protected void run(int i) {\n+    x[0] = x[0] + 1.0f;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyFloatArrayLoopRunner loop = new RacyFloatArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyFloatArrayLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyFloatMemberLoopTest\n+ * @summary Test a simple Java data race via a float field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyFloatMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyFloatMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyFloatMemberLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyFloatMemberLoopRunner.run(I)V RacyFloatMemberLoopTest.java:\");\n+  }\n+}\n+\n+class RacyFloatMemberLoopRunner extends AbstractLoop {\n+  private float x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = x + 1.0f;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyFloatMemberLoopRunner loop = new RacyFloatMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyFloatMemberLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyIntArrayLoopTest\n+ * @summary Test a simple Java data race via an int member array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyIntArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyIntArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyIntArrayLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyIntArrayLoopRunner.run(I)V RacyIntArrayLoopTest.java:\");\n+  }\n+}\n+\n+class RacyIntArrayLoopRunner extends AbstractLoop {\n+  private int[] x = new int[2];\n+\n+  @Override\n+  protected void run(int i) {\n+    x[0] = x[0] + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyIntArrayLoopRunner loop = new RacyIntArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyIntArrayLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyIntMemberLoopTest\n+ * @summary Test a simple Java data race via an int member field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyIntMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyIntMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyIntMemberLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyIntMemberLoopRunner.run(I)V RacyIntMemberLoopTest.java:\");\n+  }\n+}\n+\n+class RacyIntMemberLoopRunner extends AbstractLoop {\n+  private int x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyIntMemberLoopRunner loop = new RacyIntMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyIntMemberLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyIntMemberNoJavaMemLoopTest\n+ * @summary Test that a simple Java data race via an int member field is not\n+ *          reported when ThreadSanitizerJavaMemory is off.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyIntMemberNoJavaMemLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyIntMemberNoJavaMemLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(RacyIntMemberNoJavaMemLoopRunner.class,\n+        \"-XX:-ThreadSanitizerJavaMemory\");\n+  }\n+}\n+\n+class RacyIntMemberNoJavaMemLoopRunner extends AbstractLoop {\n+  private int x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyIntMemberNoJavaMemLoopRunner loop = new RacyIntMemberNoJavaMemLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyIntMemberNoJavaMemLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyLongArrayLoopTest\n+ * @summary Test a simple Java data race via a long array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyLongArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyLongArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyLongArrayLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 8 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyLongArrayLoopRunner.run(I)V RacyLongArrayLoopTest.java:\");\n+  }\n+}\n+\n+class RacyLongArrayLoopRunner extends AbstractLoop {\n+  private long[] x = new long[2];\n+\n+  @Override\n+  protected void run(int i) {\n+    x[0] = x[0] + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyLongArrayLoopRunner loop = new RacyLongArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyLongArrayLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyLongMemberLoopTest\n+ * @summary Test a simple Java data race via a long field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyLongMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyLongMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyLongMemberLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 8 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyLongMemberLoopRunner.run(I)V RacyLongMemberLoopTest.java:\");\n+  }\n+}\n+\n+class RacyLongMemberLoopRunner extends AbstractLoop {\n+  private long x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyLongMemberLoopRunner loop = new RacyLongMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyLongMemberLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyNativeLoopTest\n+ * @summary Test a simple native data race.\n+ * @library \/test\/lib\n+ * @build AbstractLoop AbstractNativeLoop TsanRunner\n+ * @run main\/othervm\/native RacyNativeLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyNativeLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyNativeLoopRunner.class)\n+        .shouldMatch(\"Write of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 Java_AbstractNativeLoop_writeNativeGlobal\")\n+        .shouldContain(\" #2 RacyNativeLoopRunner.run(I)V RacyNativeLoopTest.java:\");\n+  }\n+}\n+\n+class RacyNativeLoopRunner extends AbstractNativeLoop {\n+  @Override\n+  protected void run(int i) {\n+    writeNativeGlobal();\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyNativeLoopRunner loop = new RacyNativeLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"native_global = \" + loop.readNativeGlobal());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyNativeLoopTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyShortArrayLoopTest\n+ * @summary Test a simple Java data race via a short array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyShortArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyShortArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyShortArrayLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 2 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyShortArrayLoopRunner.run(I)V RacyShortArrayLoopTest.java:\");\n+  }\n+}\n+\n+class RacyShortArrayLoopRunner extends AbstractLoop {\n+  private short[] x = new short[2];\n+\n+  @Override\n+  protected void run(int i) {\n+    x[0] = (short) (x[0] + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyShortArrayLoopRunner loop = new RacyShortArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyShortArrayLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyShortMemberLoopTest\n+ * @summary Test a simple Java data race via a short field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyShortMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyShortMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyShortMemberLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 2 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyShortMemberLoopRunner.run(I)V RacyShortMemberLoopTest.java:\");\n+  }\n+}\n+\n+class RacyShortMemberLoopRunner extends AbstractLoop {\n+  private short x = 0;\n+\n+  @Override\n+  protected void run(int i) {\n+    x = (short) (x + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyShortMemberLoopRunner loop = new RacyShortMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyShortMemberLoopTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyStringArrayLoopTest\n+ * @summary Test a simple Java data race via a String array.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyStringArrayLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyStringArrayLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyStringArrayLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size [48] at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyStringArrayLoopRunner.run(I)V RacyStringArrayLoopTest.java:\");\n+  }\n+}\n+\n+class RacyStringArrayLoopRunner extends AbstractLoop {\n+  private String[] x = new String[] {\"a\", \"b\"};\n+\n+  @Override\n+  protected void run(int i) {\n+    char c = x[0].charAt(0);\n+    x[0] = Character.toString(c);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyStringArrayLoopRunner loop = new RacyStringArrayLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyStringArrayLoopTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyStringMemberLoopTest\n+ * @summary Test a simple Java data race via a String field.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main RacyStringMemberLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyStringMemberLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyStringMemberLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size [48] at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyStringMemberLoopRunner.run(I)V RacyStringMemberLoopTest.java:\");\n+  }\n+}\n+\n+class RacyStringMemberLoopRunner extends AbstractLoop {\n+  private String x = \"a\";\n+\n+  @Override\n+  protected void run(int i) {\n+    char c = x.charAt(0);\n+    x = Character.toString(c);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyStringMemberLoopRunner loop = new RacyStringMemberLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyStringMemberLoopTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafeGetBooleanLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.getBoolean.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafeGetBooleanLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafeGetBooleanLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafeGetBooleanLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 1 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafeGetBooleanLoopRunner.run(I)V RacyUnsafeGetBooleanLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.getBoolean(Ljava\/lang\/Object;J)Z Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafeGetBooleanLoopRunner extends AbstractLoop {\n+  private boolean x = false;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafeGetBooleanLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = !x;\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    boolean x = !UnsafeUtil.UNSAFE.getBoolean(this, X_OFFSET);\n+    synchronized (this) {\n+      this.x = x;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafeGetBooleanLoopRunner loop = new RacyUnsafeGetBooleanLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafeGetBooleanLoopTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafeGetByteLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.getByte.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafeGetByteLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafeGetByteLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafeGetByteLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 1 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafeGetByteLoopRunner.run(I)V RacyUnsafeGetByteLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.getByte(Ljava\/lang\/Object;J)B Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafeGetByteLoopRunner extends AbstractLoop {\n+  private byte x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafeGetByteLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = (byte) (x + 1);\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    byte x = (byte) (UnsafeUtil.UNSAFE.getByte(this, X_OFFSET) + 1);\n+    synchronized (this) {\n+      this.x = x;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafeGetByteLoopRunner loop = new RacyUnsafeGetByteLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafeGetByteLoopTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafeGetCharLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.getChar.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafeGetCharLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafeGetCharLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafeGetCharLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 2 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafeGetCharLoopRunner.run(I)V RacyUnsafeGetCharLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.getChar(Ljava\/lang\/Object;J)C Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafeGetCharLoopRunner extends AbstractLoop {\n+  private char x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafeGetCharLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = (char) (x + 1);\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    char x = (char) (UnsafeUtil.UNSAFE.getChar(this, X_OFFSET) + 1);\n+    synchronized (this) {\n+      this.x = x;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafeGetCharLoopRunner loop = new RacyUnsafeGetCharLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafeGetCharLoopTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafeGetDoubleLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.getDouble.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafeGetDoubleLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafeGetDoubleLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafeGetDoubleLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 8 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafeGetDoubleLoopRunner.run(I)V RacyUnsafeGetDoubleLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.getDouble(Ljava\/lang\/Object;J)D Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafeGetDoubleLoopRunner extends AbstractLoop {\n+  private double x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafeGetDoubleLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1.0;\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    double x = UnsafeUtil.UNSAFE.getDouble(this, X_OFFSET) + 1.0;\n+    synchronized (this) {\n+      this.x = x;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafeGetDoubleLoopRunner loop = new RacyUnsafeGetDoubleLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafeGetDoubleLoopTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafeGetFloatLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.getFloat.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafeGetFloatLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafeGetFloatLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafeGetFloatLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafeGetFloatLoopRunner.run(I)V RacyUnsafeGetFloatLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.getFloat(Ljava\/lang\/Object;J)F Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafeGetFloatLoopRunner extends AbstractLoop {\n+  private float x = 0.0f;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafeGetFloatLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1.0f;\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    float x = UnsafeUtil.UNSAFE.getFloat(this, X_OFFSET) + 1.0f;\n+    synchronized (this) {\n+      this.x = x;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafeGetFloatLoopRunner loop = new RacyUnsafeGetFloatLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafeGetFloatLoopTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafeGetIntLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.getInt.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafeGetIntLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafeGetIntLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafeGetIntLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafeGetIntLoopRunner.run(I)V RacyUnsafeGetIntLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.getInt(Ljava\/lang\/Object;J)I Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafeGetIntLoopRunner extends AbstractLoop {\n+  private int x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafeGetIntLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    int x = UnsafeUtil.UNSAFE.getInt(this, X_OFFSET) + 1;\n+    synchronized (this) {\n+      this.x = x;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafeGetIntLoopRunner loop = new RacyUnsafeGetIntLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafeGetIntLoopTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafeGetLongLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.getLong.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafeGetLongLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafeGetLongLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafeGetLongLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 8 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafeGetLongLoopRunner.run(I)V RacyUnsafeGetLongLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.getLong(Ljava\/lang\/Object;J)J Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafeGetLongLoopRunner extends AbstractLoop {\n+  private long x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafeGetLongLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    long x = UnsafeUtil.UNSAFE.getLong(this, X_OFFSET) + 1;\n+    synchronized (this) {\n+      this.x = x;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafeGetLongLoopRunner loop = new RacyUnsafeGetLongLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafeGetLongLoopTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafeGetShortLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.getShort.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafeGetShortLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafeGetShortLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafeGetShortLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 2 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafeGetShortLoopRunner.run(I)V RacyUnsafeGetShortLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.getShort(Ljava\/lang\/Object;J)S Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafeGetShortLoopRunner extends AbstractLoop {\n+  private short x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafeGetShortLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = (short) (x + 1);\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    short x = (short) (UnsafeUtil.UNSAFE.getShort(this, X_OFFSET) + 1);\n+    synchronized (this) {\n+      this.x = x;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafeGetShortLoopRunner loop = new RacyUnsafeGetShortLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafeGetShortLoopTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafeGetStringLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.getObject.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafeGetStringLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafeGetStringLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafeGetStringLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size (4|8) at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafeGetStringLoopRunner.run(I)V RacyUnsafeGetStringLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.getObject(Ljava\/lang\/Object;J)Ljava\/lang\/Object; Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafeGetStringLoopRunner extends AbstractLoop {\n+  private String x = \"a\";\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafeGetStringLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    char c = (char) (x.charAt(0) + 1);\n+    x = Character.toString(c);\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    String s = (String) UnsafeUtil.UNSAFE.getObject(this, X_OFFSET);\n+    char c = (char) (s.charAt(0) + 1);\n+    s = Character.toString(c);\n+    synchronized (this) {\n+      this.x = s;\n+    }\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafeGetStringLoopRunner loop = new RacyUnsafeGetStringLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafeGetStringLoopTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafePutBooleanLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.putBoolean.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafePutBooleanLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafePutBooleanLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafePutBooleanLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 1 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafePutBooleanLoopRunner.run(I)V RacyUnsafePutBooleanLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.putBoolean(Ljava\/lang\/Object;JZ)V Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafePutBooleanLoopRunner extends AbstractLoop {\n+  private boolean x = false;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafePutBooleanLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = !x;\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    boolean b;\n+    synchronized (this) {\n+      b = this.x;\n+    }\n+    UnsafeUtil.UNSAFE.putBoolean(this, X_OFFSET, !b);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafePutBooleanLoopRunner loop = new RacyUnsafePutBooleanLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafePutBooleanLoopTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafePutByteLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.putByte.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafePutByteLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafePutByteLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafePutByteLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 1 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafePutByteLoopRunner.run(I)V RacyUnsafePutByteLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.putByte(Ljava\/lang\/Object;JB)V Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafePutByteLoopRunner extends AbstractLoop {\n+  private byte x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafePutByteLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = (byte) (x + 1);\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    byte b;\n+    synchronized (this) {\n+      b = this.x;\n+    }\n+    UnsafeUtil.UNSAFE.putByte(this, X_OFFSET, (byte) (b + 1));\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafePutByteLoopRunner loop = new RacyUnsafePutByteLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafePutByteLoopTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafePutCharLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.putChar.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafePutCharLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafePutCharLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafePutCharLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 2 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafePutCharLoopRunner.run(I)V RacyUnsafePutCharLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.putChar(Ljava\/lang\/Object;JC)V Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafePutCharLoopRunner extends AbstractLoop {\n+  private char x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafePutCharLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = (char) (x + 1);\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    char c;\n+    synchronized (this) {\n+      c = this.x;\n+    }\n+    UnsafeUtil.UNSAFE.putChar(this, X_OFFSET, (char) (c + 1));\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafePutCharLoopRunner loop = new RacyUnsafePutCharLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafePutCharLoopTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafePutDoubleLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.putDouble.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafePutDoubleLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafePutDoubleLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafePutDoubleLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 8 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafePutDoubleLoopRunner.run(I)V RacyUnsafePutDoubleLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.putDouble(Ljava\/lang\/Object;JD)V Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafePutDoubleLoopRunner extends AbstractLoop {\n+  private double x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafePutDoubleLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1.0;\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    double d;\n+    synchronized (this) {\n+      d = this.x;\n+    }\n+    UnsafeUtil.UNSAFE.putDouble(this, X_OFFSET, d + 1.0);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafePutDoubleLoopRunner loop = new RacyUnsafePutDoubleLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafePutDoubleLoopTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafePutFloatLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.putFloat.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafePutFloatLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafePutFloatLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafePutFloatLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafePutFloatLoopRunner.run(I)V RacyUnsafePutFloatLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.putFloat(Ljava\/lang\/Object;JF)V Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafePutFloatLoopRunner extends AbstractLoop {\n+  private float x = 0.0f;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafePutFloatLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1.0f;\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    float f;\n+    synchronized (this) {\n+      f = this.x;\n+    }\n+    UnsafeUtil.UNSAFE.putFloat(this, X_OFFSET, f + 1.0f);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafePutFloatLoopRunner loop = new RacyUnsafePutFloatLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafePutFloatLoopTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafePutIntLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.putInt.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafePutIntLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafePutIntLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafePutIntLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 4 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafePutIntLoopRunner.run(I)V RacyUnsafePutIntLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.putInt(Ljava\/lang\/Object;JI)V Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafePutIntLoopRunner extends AbstractLoop {\n+  private int x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafePutIntLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  @Override\n+  protected void run2(int unused) {\n+    int i;\n+    synchronized (this) {\n+      i = this.x;\n+    }\n+\n+    UnsafeUtil.UNSAFE.putInt(this, X_OFFSET, i + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafePutIntLoopRunner loop = new RacyUnsafePutIntLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafePutIntLoopTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafePutLongLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.putLong.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafePutLongLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafePutLongLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafePutLongLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 8 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafePutLongLoopRunner.run(I)V RacyUnsafePutLongLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.putLong(Ljava\/lang\/Object;JJ)V Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafePutLongLoopRunner extends AbstractLoop {\n+  private long x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafePutLongLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = x + 1;\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    long l;\n+    synchronized (this) {\n+      l = this.x;\n+    }\n+    UnsafeUtil.UNSAFE.putLong(this, X_OFFSET, l + 1);\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafePutLongLoopRunner loop = new RacyUnsafePutLongLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafePutLongLoopTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafePutShortLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.putShort.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafePutShortLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafePutShortLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafePutShortLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size 2 at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafePutShortLoopRunner.run(I)V RacyUnsafePutShortLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.putShort(Ljava\/lang\/Object;JS)V Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafePutShortLoopRunner extends AbstractLoop {\n+  private short x = 0;\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafePutShortLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    x = (short) (x + 1);\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    short s;\n+    synchronized (this) {\n+      s = this.x;\n+    }\n+    UnsafeUtil.UNSAFE.putShort(this, X_OFFSET, (short) (s + 1));\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafePutShortLoopRunner loop = new RacyUnsafePutShortLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafePutShortLoopTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RacyUnsafePutStringLoopTest\n+ * @summary Test a racy sun.misc.Unsafe.putObject.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner UnsafeUtil\n+ * @run main RacyUnsafePutStringLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class RacyUnsafePutStringLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RacyUnsafePutStringLoopRunner.class)\n+        .shouldMatch(\"(Read|Write) of size (4|8) at 0x[0-9a-fA-F]+ by thread T[0-9]+\")\n+        .shouldContain(\" #0 RacyUnsafePutStringLoopRunner.run(I)V RacyUnsafePutStringLoopTest.java:\")\n+        .shouldContain(\" #0 (Generated Stub) <null>\")\n+        .shouldContain(\" #1 sun.misc.Unsafe.putObject(Ljava\/lang\/Object;JLjava\/lang\/Object;)V Unsafe.java:\");\n+  }\n+}\n+\n+class RacyUnsafePutStringLoopRunner extends AbstractLoop {\n+  private String x = \"a\";\n+  private static final long X_OFFSET = UnsafeUtil.objectFieldOffset(RacyUnsafePutStringLoopRunner.class, \"x\");\n+\n+  @Override\n+  protected synchronized void run(int i) {\n+    char c = (char) (x.charAt(0) + 1);\n+    x = Character.toString(c);\n+  }\n+\n+  @Override\n+  protected void run2(int i) {\n+    String s;\n+    synchronized (this) {\n+      s = this.x;\n+    }\n+    char c = (char) (s.charAt(0) + 1);\n+    UnsafeUtil.UNSAFE.putObject(this, X_OFFSET, Character.toString(c));\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RacyUnsafePutStringLoopRunner loop = new RacyUnsafePutStringLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"x = \" + loop.x);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RacyUnsafePutStringLoopTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test RawRacyNativeLoopTest\n+ * @summary Test that native code wrongly protected by JVMTI synchronization is racy.\n+ * @library \/test\/lib\n+ * @build AbstractLoop AbstractNativeLoop TsanRunner\n+ * @run main\/othervm\/native RawRacyNativeLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.ThreadLocal;\n+\n+public class RawRacyNativeLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectFailure(RawRacyNativeLoopRunner.class,\n+        \"-agentlib:AbstractNativeLoop\");\n+  }\n+}\n+\n+class RawRacyNativeLoopRunner extends AbstractNativeLoop {\n+  \/\/ Thread local variable containing a raw lock.\n+  private static final ThreadLocal<Long> lock =\n+      new ThreadLocal<>() {\n+        @Override protected Long initialValue() {\n+          return createRawLock();\n+        }\n+      };\n+\n+  @Override\n+  protected void run(int i) {\n+    writeRawLockedNativeGlobal(lock.get());\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    RawRacyNativeLoopRunner loop = new RawRacyNativeLoopRunner();\n+    loop.runInTwoThreads();\n+    System.out.println(\"native_global = \" + loop.readNativeGlobal());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/RawRacyNativeLoopTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test StringOperationsLoopTest\n+ * @summary Test that String concatenation\/hashCode is not reported as racy.\n+ *          TSAN may see String concatentation as racy due to usage of\n+ *          java.lang.invoke.*, which is racy. Those races should be\n+ *          suppressed.\n+ *          hashCode() is intentionally racy and should not be reported.\n+ * @library \/test\/lib\n+ * @build AbstractLoop TsanRunner\n+ * @run main StringOperationsLoopTest\n+ *\/\n+\n+import java.io.IOException;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class StringOperationsLoopTest {\n+  public static void main(String[] args) throws IOException {\n+    TsanRunner.runTsanTestExpectSuccess(StringOperationsLoopTestRunner.class);\n+  }\n+}\n+\n+class StringOperationsLoopTestRunner extends AbstractLoop {\n+  public static final String STRING = \"hi\";\n+\n+  @Override\n+  protected void run(int i) {\n+    int a = 0;\n+    String b = \"\" + a;\n+    STRING.hashCode();\n+  }\n+\n+  public static void main(String[] args) throws InterruptedException {\n+    StringOperationsLoopTestRunner loop = new StringOperationsLoopTestRunner();\n+    loop.runInTwoThreads();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/StringOperationsLoopTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import jdk.test.lib.management.InputArguments;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * Tsan Test Runner, which basically adds the VM options and runs a class name as a new\n+ * ProcessBuilder; returning the OutputAnalyzer of the process.\n+ *\/\n+public class TsanRunner {\n+  public static OutputAnalyzer runTsanTest(Class<?> klass, String... vmArgs) throws IOException {\n+    ArrayList<String> vmOpts = new ArrayList<>();\n+\n+    \/\/ Pass all VM options passed to this process, which include\n+    \/\/ all JTREG's system properties, and VM options from \"test.vm.opts\"\n+    \/\/ system property and from @run tag.\n+    String[] vmInputArgs = InputArguments.getVmInputArgs();\n+    Collections.addAll(vmOpts, vmInputArgs);\n+\n+    Collections.addAll(vmOpts, vmArgs);\n+    vmOpts.add(\"-XX:+ThreadSanitizer\");\n+    vmOpts.add(klass.getName());\n+\n+    ProcessBuilder pb =\n+        ProcessTools.createJavaProcessBuilder(vmOpts.toArray(new String[0]));\n+    return new OutputAnalyzer(pb.start());\n+  }\n+\n+  public static OutputAnalyzer runTsanTestExpectSuccess(\n+      Class<?> klass, String... vmArgs) throws IOException {\n+    return runTsanTest(klass, vmArgs)\n+        .shouldHaveExitValue(0)\n+        .shouldNotContain(\"WARNING: ThreadSanitizer: data race\");\n+  }\n+\n+  public static OutputAnalyzer runTsanTestExpectFailure(\n+      Class<?> klass, String... vmArgs) throws IOException {\n+    return runTsanTest(klass, vmArgs)\n+        .shouldHaveExitValue(66);\n+  }\n+\n+  public static OutputAnalyzer runTsanTestExpectSuccess(Class<?> klass) throws IOException {\n+    return runTsanTestExpectSuccess(klass, new String[0]);\n+  }\n+\n+  public static OutputAnalyzer runTsanTestExpectFailure(Class<?> klass) throws IOException {\n+    return runTsanTestExpectFailure(klass, new String[0]);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/TsanRunner.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import sun.misc.Unsafe;\n+\n+\/** Static utilities used mostly for dealing with Unsafe class. *\/\n+class UnsafeUtil {\n+  \/** Instance of sun.misc.Unsafe *\/\n+  static final Unsafe UNSAFE;\n+\n+  static {\n+    try {\n+      Field f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+      f.setAccessible(true);\n+      UNSAFE = (Unsafe) f.get(null);\n+    } catch (NoSuchFieldException | IllegalAccessException ex) {\n+      throw new RuntimeException(ex);\n+    }\n+  }\n+\n+  \/** A wrapper for sun.misc.Unsafe.objectFieldOffset. *\/\n+  static long objectFieldOffset(Class<?> klass, String fieldName) {\n+    try {\n+      return UNSAFE.objectFieldOffset(klass.getDeclaredField(fieldName));\n+    } catch (NoSuchFieldException ex) {\n+      throw new RuntimeException(ex);\n+    }\n+  }\n+\n+  private UnsafeUtil() {}\n+}\n+\n","filename":"test\/hotspot\/jtreg\/tsan\/UnsafeUtil.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2019 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019 Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <pthread.h>\n+#include <string.h>\n+\n+extern \"C\" {\n+\n+static int global;\n+static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n+static jvmtiEnv *jvmti = NULL;\n+\n+JNIEXPORT void JNICALL Java_AbstractNativeLoop_writeNativeGlobalSync(\n+    JNIEnv *env, jclass unused) {\n+  pthread_mutex_lock(&mutex);\n+  global = 30;\n+  pthread_mutex_unlock(&mutex);\n+}\n+\n+JNIEXPORT void JNICALL Java_AbstractNativeLoop_writeNativeGlobal(\n+    JNIEnv *env, jclass unused) {\n+  global = 31;\n+}\n+\n+JNIEXPORT jint JNICALL Java_AbstractNativeLoop_readNativeGlobal(JNIEnv *env,\n+                                                                jclass unused) {\n+  return global;\n+}\n+\n+JNIEXPORT jlong JNICALL Java_AbstractNativeLoop_createRawLock(JNIEnv *env,\n+                                                              jclass unused) {\n+  jrawMonitorID lock;\n+  jvmti->CreateRawMonitor(\"lock\", &lock);\n+  return reinterpret_cast<jlong>(lock);\n+}\n+\n+JNIEXPORT void JNICALL Java_AbstractNativeLoop_writeRawLockedNativeGlobal(\n+    JNIEnv *env, jclass unused, long lock) {\n+  jrawMonitorID raw_lock = reinterpret_cast<jrawMonitorID>(lock);\n+  jvmti->RawMonitorEnter(raw_lock);\n+  global = 32;\n+  jvmti->RawMonitorExit(raw_lock);\n+}\n+\n+JNIEXPORT jboolean JNICALL Java_JvmtiTaggerLoopRunner_addTagAndReference(\n+    JNIEnv *env, jclass unused, jobject object) {\n+  \/\/ Create a global reference so that GC won't take this object.\n+  env->NewGlobalRef(object);\n+\n+  \/\/ Create a pointer for the tag.\n+  int *ptr = new int;\n+  *ptr = 42;\n+  return jvmti->SetTag(object, reinterpret_cast<long>(ptr))\n+      == JVMTI_ERROR_NONE;\n+}\n+\n+static JNICALL jint PerObjectCallback(jlong class_tag, jlong size,\n+                                      jlong *tag_ptr, jint length,\n+                                      void *user_data) {\n+  int *sum_ptr = reinterpret_cast<int*>(user_data);\n+  int *ptr = reinterpret_cast<int*>(*tag_ptr);\n+\n+  \/\/ We don't use an atomic since it is not yet supported.\n+  pthread_mutex_lock(&mutex);\n+  *sum_ptr += *ptr;\n+  pthread_mutex_unlock(&mutex);\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+JNIEXPORT jboolean JNICALL Java_JvmtiTaggerLoopRunner_iterateOverTags(\n+    JNIEnv *env, jclass unused) {\n+  jvmtiHeapCallbacks callbacks;\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.heap_iteration_callback = &PerObjectCallback;\n+\n+  \/\/ TODO: we really do not need this mutex normally but TSAN is not happy with\n+  \/\/ the way things happen via the JVMTI call. We will need to support this at\n+  \/\/ some point (it comes from the VM Operation system...)\n+  \/\/ We don't use an atomic since it is not yet supported.\n+  pthread_mutex_lock(&mutex);\n+  int sum = 0;\n+  pthread_mutex_unlock(&mutex);\n+\n+  if (jvmti->IterateThroughHeap(JVMTI_HEAP_FILTER_UNTAGGED, NULL, &callbacks, &sum)\n+      != JVMTI_ERROR_NONE) {\n+    return false;\n+  }\n+\n+  \/\/ We don't use an atomic since it is not yet supported.\n+  pthread_mutex_lock(&mutex);\n+  int local_value = sum;\n+  pthread_mutex_unlock(&mutex);\n+  return local_value != 0;\n+}\n+\n+static\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  if (jvm->GetEnv(reinterpret_cast<void **>(&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  jvmtiCapabilities caps;\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_tag_objects = 1;\n+\n+  if (jvmti->AddCapabilities(&caps) != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT\n+jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT\n+jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT\n+jint JNICALL JNI_OnLoad(JavaVM *jvm, void *reserved) {\n+  return JNI_VERSION_1_8;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/tsan\/libAbstractNativeLoop.cpp","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}