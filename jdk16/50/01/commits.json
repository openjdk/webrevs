[{"commit":{"message":"Update copyright year to 2021."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp"},{"filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp"}],"sha":"873c250681e925e6e5fa3333cb6b8b758999ec1e"},{"commit":{"message":"8258384: AArch64: SVE verify_ptrue fails on some tests\n\nAfter applying [1], some Vector API tests fail with SIGILL on SVE\nsystem. The SIGILL was triggered by verify_ptrue before c2 compiled\nfunction returns, which means that the preserved p7 register (as ptrue)\nhas been clobbered before returning to c2 compiled code. (p7 is not\npreserved cross function calls, and system calls [2]).\n\nCurrently we try to reinitialize ptrue at each entrypoint of returning\nfrom non-c2 compiled code, which indicating possible C or system calls.\nHowever, there's still one entrypoint missing, exception handling, as\nwe may jump to c2 compiled code for exception handler. See\nOptoRuntime::generate_exception_blob().\n\nAdding reinitialize_ptrue before jumping back to c2 compiled code in\ngenerate_exception_blob() could solve those Vector API failures.\nActually I had that in my initial test patch [3], I don't know why I\nmissed that in final patch... I reran tests with the same approach of\n[3] and found that there's still something missing, the\nnmethod_entry_barrier() in c2 function prolog. The barrier may call to\nruntime code (see generate_method_entry_barrier()). To reduce the risk\nof missing such reinitialize_ptrue in newly added code in future, I\nthink it would be better to do the reinitialize in\npop_call_clobbered_registers().\n\nP.S. the SIGILL message is also not clear, it should print detailed\nmessage as indicated by MacroAssembler::stop() call. This is caused by\nJDK-8255711 removing the message printing code. This patch also adds it\nback, so that it could print detailed message for abort.\n\nTested with tier1-3 on SVE hardware. Also verified with the same\napproach of patch [3] with jtreg tests hotspot_all_no_apps and\njdk:tier1-3 passed without incorrect ptrue value assertion failure.\n\n[1] https:\/\/github.com\/openjdk\/jdk\/pull\/1621\n[2] https:\/\/github.com\/torvalds\/linux\/blob\/master\/Documentation\/arm64\/sve.rst\n[3] http:\/\/cr.openjdk.java.net\/~njian\/8231441\/0001-RFC-Block-one-caller-save-register-for-C2.patch"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp"},{"filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp"}],"sha":"a5754c7d5a0da1422179c5e06897c3f7fa7cf1ba"}]