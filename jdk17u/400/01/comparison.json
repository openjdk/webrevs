{"files":[{"patch":"@@ -266,0 +266,2 @@\n+    private record PushContinuationState(HeaderDecoder pushContDecoder, PushPromiseFrame pushContFrame) {}\n+    private volatile PushContinuationState pushContinuationState;\n@@ -776,2 +778,2 @@\n-                    if (frame instanceof DataFrame) {\n-                        dropDataFrame((DataFrame)frame);\n+                    if (frame instanceof DataFrame df) {\n+                        dropDataFrame(df);\n@@ -794,15 +796,15 @@\n-            if (frame instanceof PushPromiseFrame) {\n-                PushPromiseFrame pp = (PushPromiseFrame)frame;\n-                try {\n-                    handlePushPromise(stream, pp);\n-                } catch (UncheckedIOException e) {\n-                    protocolError(ResetFrame.PROTOCOL_ERROR, e.getMessage());\n-                    return;\n-                }\n-            } else if (frame instanceof HeaderFrame) {\n-                \/\/ decode headers (or continuation)\n-                try {\n-                    decodeHeaders((HeaderFrame) frame, stream.rspHeadersConsumer());\n-                } catch (UncheckedIOException e) {\n-                    debug.log(\"Error decoding headers: \" + e.getMessage(), e);\n-                    protocolError(ResetFrame.PROTOCOL_ERROR, e.getMessage());\n+\n+            \/\/ While push frame is not null, the only acceptable frame on this\n+            \/\/ stream is a Continuation frame\n+            if (pushContinuationState != null) {\n+                if (frame instanceof ContinuationFrame cf) {\n+                    try {\n+                        handlePushContinuation(stream, cf);\n+                    } catch (UncheckedIOException e) {\n+                        debug.log(\"Error handling Push Promise with Continuation: \" + e.getMessage(), e);\n+                        protocolError(ErrorFrame.PROTOCOL_ERROR, e.getMessage());\n+                        return;\n+                    }\n+                } else {\n+                    pushContinuationState = null;\n+                    protocolError(ErrorFrame.PROTOCOL_ERROR, \"Expected a Continuation frame but received \" + frame);\n@@ -811,1 +813,0 @@\n-                stream.incoming(frame);\n@@ -813,1 +814,20 @@\n-                stream.incoming(frame);\n+                if (frame instanceof PushPromiseFrame pp) {\n+                    try {\n+                        handlePushPromise(stream, pp);\n+                    } catch (UncheckedIOException e) {\n+                        protocolError(ErrorFrame.PROTOCOL_ERROR, e.getMessage());\n+                        return;\n+                    }\n+                } else if (frame instanceof HeaderFrame hf) {\n+                    \/\/ decode headers\n+                    try {\n+                        decodeHeaders(hf, stream.rspHeadersConsumer());\n+                    } catch (UncheckedIOException e) {\n+                        debug.log(\"Error decoding headers: \" + e.getMessage(), e);\n+                        protocolError(ErrorFrame.PROTOCOL_ERROR, e.getMessage());\n+                        return;\n+                    }\n+                    stream.incoming(frame);\n+                } else {\n+                    stream.incoming(frame);\n+                }\n@@ -844,0 +864,1 @@\n+        assert pushContinuationState == null;\n@@ -846,0 +867,19 @@\n+        int promisedStreamid = pp.getPromisedStream();\n+        if (pp.endHeaders()) {\n+            completePushPromise(promisedStreamid, parent, decoder.headers());\n+        } else {\n+            pushContinuationState = new PushContinuationState(decoder, pp);\n+        }\n+    }\n+\n+    private <T> void handlePushContinuation(Stream<T> parent, ContinuationFrame cf)\n+            throws IOException {\n+        var pcs = pushContinuationState;\n+        decodeHeaders(cf, pcs.pushContDecoder);\n+        \/\/ if all continuations are sent, set pushWithContinuation to null\n+        if (cf.endHeaders()) {\n+            completePushPromise(pcs.pushContFrame.getPromisedStream(), parent,\n+                    pcs.pushContDecoder.headers());\n+            pushContinuationState = null;\n+        }\n+    }\n@@ -847,0 +887,4 @@\n+    private <T> void completePushPromise(int promisedStreamid, Stream<T> parent, HttpHeaders headers)\n+            throws IOException {\n+        \/\/ Perhaps the following checks could be moved to handlePushPromise()\n+        \/\/ to reset the PushPromise stream earlier?\n@@ -848,1 +892,0 @@\n-        int promisedStreamid = pp.getPromisedStream();\n@@ -859,1 +902,0 @@\n-        HttpHeaders headers = decoder.headers();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":63,"deletions":21,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8263031\n+ * @summary Tests that the HttpClient can correctly receive a Push Promise\n+ *          Frame with the END_HEADERS flag unset followed by one or more\n+ *          Continuation Frames.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.http2.Http2TestServer\n+ *        jdk.httpclient.test.lib.http2.BodyOutputStream\n+ *        jdk.httpclient.test.lib.http2.OutgoingPushPromise\n+ * @run testng\/othervm PushPromiseContinuation\n+ *\/\n+\n+\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.ContinuationFrame;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import org.testng.TestException;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLSession;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiPredicate;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+import jdk.httpclient.test.lib.http2.OutgoingPushPromise;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+\n+public class PushPromiseContinuation {\n+\n+    static volatile HttpHeaders testHeaders;\n+    static volatile HttpHeadersBuilder testHeadersBuilder;\n+    static volatile int continuationCount;\n+    static final String mainPromiseBody = \"Main Promise Body\";\n+    static final String mainResponseBody = \"Main Response Body\";\n+    Http2TestServer server;\n+    URI uri;\n+\n+    \/\/ Set up simple client-side push promise handler\n+    ConcurrentMap<HttpRequest, CompletableFuture<HttpResponse<String>>> pushPromiseMap = new ConcurrentHashMap<>();\n+    HttpResponse.PushPromiseHandler<String> pph = (initial, pushRequest, acceptor) -> {\n+        HttpResponse.BodyHandler<String> s = HttpResponse.BodyHandlers.ofString(UTF_8);\n+        pushPromiseMap.put(pushRequest, acceptor.apply(s));\n+    };\n+\n+    @BeforeMethod\n+    public void beforeMethod() {\n+        pushPromiseMap = new ConcurrentHashMap<>();\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        server = new Http2TestServer(false, 0);\n+        server.addHandler(new ServerPushHandler(), \"\/\");\n+\n+        \/\/ Need to have a custom exchange supplier to manage the server's push\n+        \/\/ promise with continuation flow\n+        server.setExchangeSupplier(Http2LPPTestExchangeImpl::new);\n+\n+        System.err.println(\"PushPromiseContinuation: Server listening on port \" + server.getAddress().getPort());\n+        server.start();\n+        int port = server.getAddress().getPort();\n+        uri = new URI(\"http:\/\/localhost:\" + port + \"\/\");\n+    }\n+\n+    @AfterTest\n+    public void teardown() {\n+        pushPromiseMap = null;\n+        server.stop();\n+    }\n+\n+    \/**\n+     * Tests that when the client receives PushPromise Frame with the END_HEADERS\n+     * flag set to 0x0 and subsequently receives a continuation frame, no exception\n+     * is thrown and all headers from the PushPromise and Continuation Frames sent\n+     * by the server arrive at the client.\n+     *\/\n+    @Test\n+    public void testOneContinuation() {\n+        continuationCount = 1;\n+        HttpClient client = HttpClient.newHttpClient();\n+\n+        \/\/ Carry out request\n+        HttpRequest hreq = HttpRequest.newBuilder(uri).version(HttpClient.Version.HTTP_2).GET().build();\n+        CompletableFuture<HttpResponse<String>> cf =\n+                client.sendAsync(hreq, HttpResponse.BodyHandlers.ofString(UTF_8), pph);\n+        HttpResponse<String> resp = cf.join();\n+\n+        \/\/ Verify results\n+        verify(resp);\n+    }\n+\n+    \/**\n+     * Same as above, but tests for the case where two Continuation Frames are sent\n+     * with the END_HEADERS flag set only on the last frame.\n+     *\/\n+    @Test\n+    public void testTwoContinuations() {\n+        continuationCount = 2;\n+        HttpClient client = HttpClient.newHttpClient();\n+\n+        \/\/ Carry out request\n+        HttpRequest hreq = HttpRequest.newBuilder(uri).version(HttpClient.Version.HTTP_2).GET().build();\n+        CompletableFuture<HttpResponse<String>> cf =\n+                client.sendAsync(hreq, HttpResponse.BodyHandlers.ofString(UTF_8), pph);\n+        HttpResponse<String> resp = cf.join();\n+\n+        \/\/ Verify results\n+        verify(resp);\n+    }\n+\n+    @Test\n+    public void testThreeContinuations() {\n+        continuationCount = 3;\n+        HttpClient client = HttpClient.newHttpClient();\n+\n+        \/\/ Carry out request\n+        HttpRequest hreq = HttpRequest.newBuilder(uri).version(HttpClient.Version.HTTP_2).GET().build();\n+        CompletableFuture<HttpResponse<String>> cf =\n+                client.sendAsync(hreq, HttpResponse.BodyHandlers.ofString(UTF_8), pph);\n+        HttpResponse<String> resp = cf.join();\n+\n+        \/\/ Verify results\n+        verify(resp);\n+    }\n+\n+    private void verify(HttpResponse<String> resp) {\n+        assertEquals(resp.statusCode(), 200);\n+        assertEquals(resp.body(), mainResponseBody);\n+        if (pushPromiseMap.size() > 1) {\n+            System.err.println(pushPromiseMap.entrySet());\n+            throw new TestException(\"Results map size is greater than 1\");\n+        } else {\n+            \/\/ This will only iterate once\n+            for (HttpRequest r : pushPromiseMap.keySet()) {\n+                HttpResponse<String> serverPushResp = pushPromiseMap.get(r).join();\n+                \/\/ Received headers should be the same as the combined PushPromise\n+                \/\/ frame headers combined with the Continuation frame headers\n+                assertEquals(testHeaders, r.headers());\n+                \/\/ Check status code and push promise body are as expected\n+                assertEquals(serverPushResp.statusCode(), 200);\n+                assertEquals(serverPushResp.body(), mainPromiseBody);\n+            }\n+        }\n+    }\n+\n+    static class Http2LPPTestExchangeImpl extends Http2TestExchangeImpl {\n+\n+        HttpHeadersBuilder pushPromiseHeadersBuilder;\n+        List<ContinuationFrame> cfs;\n+\n+        Http2LPPTestExchangeImpl(int streamid, String method, HttpHeaders reqheaders,\n+                                 HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                                 SSLSession sslSession, BodyOutputStream os,\n+                                 Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+        }\n+\n+        private void setPushHeaders(String name, String value) {\n+            pushPromiseHeadersBuilder.setHeader(name, value);\n+            testHeadersBuilder.setHeader(name, value);\n+        }\n+\n+        private void assembleContinuations() {\n+            for (int i = 0; i < continuationCount; i++) {\n+                HttpHeadersBuilder builder = new HttpHeadersBuilder();\n+                for (int j = 0; j < 10; j++) {\n+                    String name = \"x-cont-\" + i + \"-\" + j;\n+                    builder.setHeader(name, \"data_\" + j);\n+                    testHeadersBuilder.setHeader(name, \"data_\" + j);\n+                }\n+\n+                ContinuationFrame cf = new ContinuationFrame(streamid, 0x0, conn.encodeHeaders(builder.build()));\n+                \/\/ If this is the last Continuation Frame, set the END_HEADERS flag.\n+                if (i >= continuationCount - 1) {\n+                    cf.setFlag(HeaderFrame.END_HEADERS);\n+                }\n+                cfs.add(cf);\n+            }\n+        }\n+\n+        @Override\n+        public void serverPush(URI uri, HttpHeaders headers, InputStream content) {\n+            pushPromiseHeadersBuilder = new HttpHeadersBuilder();\n+            testHeadersBuilder = new HttpHeadersBuilder();\n+            cfs = new ArrayList<>();\n+\n+            setPushHeaders(\":method\", \"GET\");\n+            setPushHeaders(\":scheme\", uri.getScheme());\n+            setPushHeaders(\":authority\", uri.getAuthority());\n+            setPushHeaders(\":path\", uri.getPath());\n+            for (Map.Entry<String,List<String>> entry : headers.map().entrySet()) {\n+                for (String value : entry.getValue()) {\n+                    setPushHeaders(entry.getKey(), value);\n+                }\n+            }\n+\n+            for (int i = 0; i < 10; i++) {\n+                setPushHeaders(\"x-push-header-\" + i, \"data_\" + i);\n+            }\n+\n+            \/\/ Create the Continuation Frame\/s, done before Push Promise Frame for test purposes\n+            \/\/ as testHeaders contains all headers used in all frames\n+            assembleContinuations();\n+\n+            HttpHeaders pushPromiseHeaders = pushPromiseHeadersBuilder.build();\n+            testHeaders = testHeadersBuilder.build();\n+            \/\/ Create the Push Promise Frame\n+            OutgoingPushPromise pp = new OutgoingPushPromise(streamid, uri, pushPromiseHeaders, content);\n+            \/\/ Indicates to the client that a continuation should be expected\n+            pp.setFlag(0x0);\n+\n+            try {\n+                \/\/ Schedule push promise and continuation for sending\n+                conn.addToOutputQ(pp);\n+                System.err.println(\"Server: Scheduled a Push Promise to Send\");\n+                for (ContinuationFrame cf : cfs) {\n+                    conn.addToOutputQ(cf);\n+                    System.err.println(\"Server: Scheduled a Continuation to Send\");\n+                }\n+            } catch (IOException ex) {\n+                System.err.println(\"Server: pushPromise exception: \" + ex);\n+            }\n+        }\n+    }\n+\n+    static class ServerPushHandler implements Http2Handler {\n+\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            System.err.println(\"Server: handle \" + exchange);\n+            try (InputStream is = exchange.getRequestBody()) {\n+                is.readAllBytes();\n+            }\n+\n+            if (exchange.serverPushAllowed()) {\n+                pushPromise(exchange);\n+            }\n+\n+            \/\/ response data for the main response\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                byte[] bytes = mainResponseBody.getBytes(UTF_8);\n+                exchange.sendResponseHeaders(200, bytes.length);\n+                os.write(bytes);\n+            }\n+        }\n+\n+        static final BiPredicate<String,String> ACCEPT_ALL = (x, y) -> true;\n+\n+\n+        private void pushPromise(Http2TestExchange exchange) throws IOException {\n+            URI requestURI = exchange.getRequestURI();\n+            URI uri = requestURI.resolve(\"\/promise\");\n+            InputStream is = new ByteArrayInputStream(mainPromiseBody.getBytes(UTF_8));\n+            Map<String, List<String>> map = new HashMap<>();\n+            map.put(\"x-promise\", List.of(\"promise-header\"));\n+            HttpHeaders headers = HttpHeaders.of(map, ACCEPT_ALL);\n+            exchange.serverPush(uri, headers, is);\n+            System.err.println(\"Server: Push Promise complete\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/PushPromiseContinuation.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -26,0 +26,6 @@\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import jdk.internal.net.http.frame.HeadersFrame;\n+\n+import javax.net.ssl.SSLSession;\n+import java.io.IOException;\n@@ -28,2 +34,0 @@\n-import java.io.IOException;\n-import java.net.URI;\n@@ -31,0 +35,1 @@\n+import java.net.URI;\n@@ -35,4 +40,0 @@\n-import javax.net.ssl.SSLSession;\n-import jdk.internal.net.http.common.HttpHeadersBuilder;\n-import jdk.internal.net.http.frame.HeaderFrame;\n-import jdk.internal.net.http.frame.HeadersFrame;\n@@ -196,0 +197,1 @@\n+        pp.setFlag(HeaderFrame.END_HEADERS);\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,27 @@\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.DataFrame;\n+import jdk.internal.net.http.frame.ErrorFrame;\n+import jdk.internal.net.http.frame.FramesDecoder;\n+import jdk.internal.net.http.frame.FramesEncoder;\n+import jdk.internal.net.http.frame.GoAwayFrame;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import jdk.internal.net.http.frame.HeadersFrame;\n+import jdk.internal.net.http.frame.Http2Frame;\n+import jdk.internal.net.http.frame.PingFrame;\n+import jdk.internal.net.http.frame.PushPromiseFrame;\n+import jdk.internal.net.http.frame.ResetFrame;\n+import jdk.internal.net.http.frame.SettingsFrame;\n+import jdk.internal.net.http.frame.WindowUpdateFrame;\n+import jdk.internal.net.http.hpack.Decoder;\n+import jdk.internal.net.http.hpack.DecodingCallback;\n+import jdk.internal.net.http.hpack.Encoder;\n+import sun.net.www.http.ChunkedInputStream;\n+import sun.net.www.http.HttpClient;\n+\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIMatcher;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.StandardConstants;\n@@ -30,1 +57,0 @@\n-import java.io.UncheckedIOException;\n@@ -33,0 +59,2 @@\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n@@ -35,2 +63,0 @@\n-import java.net.InetAddress;\n-import javax.net.ssl.*;\n@@ -40,1 +66,12 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.Random;\n@@ -42,1 +79,0 @@\n-import java.util.concurrent.ExecutorService;\n@@ -44,0 +80,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -45,7 +82,1 @@\n-import jdk.internal.net.http.common.HttpHeadersBuilder;\n-import jdk.internal.net.http.frame.*;\n-import jdk.internal.net.http.hpack.Decoder;\n-import jdk.internal.net.http.hpack.DecodingCallback;\n-import jdk.internal.net.http.hpack.Encoder;\n-import sun.net.www.http.ChunkedInputStream;\n-import sun.net.www.http.HttpClient;\n+\n@@ -915,1 +946,1 @@\n-                                                   HeaderFrame.END_HEADERS,\n+                                                   op.getFlags(),\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":44,"deletions":13,"binary":false,"changes":57,"status":"modified"}]}