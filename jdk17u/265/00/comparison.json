{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,3 @@\n+    \/\/ Maximum direct transfer size\n+    private static final int MAX_DIRECT_TRANSFER_SIZE;\n+\n@@ -625,1 +628,1 @@\n-    private long transferToArbitraryChannel(long position, int icount,\n+    private long transferToArbitraryChannel(long position, long count,\n@@ -630,1 +633,1 @@\n-        int c = Math.min(icount, TRANSFER_SIZE);\n+        int c = (int)Math.min(count, TRANSFER_SIZE);\n@@ -635,2 +638,2 @@\n-            while (tw < icount) {\n-                bb.limit(Math.min((int)(icount - tw), TRANSFER_SIZE));\n+            while (tw < count) {\n+                bb.limit((int)Math.min(count - tw, TRANSFER_SIZE));\n@@ -675,3 +678,0 @@\n-        int icount = (int)Math.min(count, Integer.MAX_VALUE);\n-        if ((sz - position) < icount)\n-            icount = (int)(sz - position);\n@@ -679,1 +679,2 @@\n-        long n;\n+        if ((sz - position) < count)\n+            count = (int)(sz - position);\n@@ -681,1 +682,4 @@\n-        \/\/ Attempt a direct transfer, if the kernel supports it\n+        \/\/ Attempt a direct transfer, if the kernel supports it, limiting\n+        \/\/ the number of bytes according to which platform\n+        int icount = (int)Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n+        long n;\n@@ -686,1 +690,1 @@\n-        if ((n = transferToTrustedChannel(position, icount, target)) >= 0)\n+        if ((n = transferToTrustedChannel(position, count, target)) >= 0)\n@@ -690,1 +694,1 @@\n-        return transferToArbitraryChannel(position, icount, target);\n+        return transferToArbitraryChannel(position, count, target);\n@@ -1351,0 +1355,3 @@\n+    \/\/ Retrieves the maximum size of a transfer\n+    private static native int maxDirectTransferSize0();\n+\n@@ -1357,0 +1364,1 @@\n+        MAX_DIRECT_TRANSFER_SIZE = maxDirectTransferSize0();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,0 +255,9 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileChannelImpl_maxDirectTransferSize0(JNIEnv* env, jobject this)\n+{\n+#if defined(LINUX)\n+    return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n+#else\n+    return java_lang_Integer_MAX_VALUE;\n+#endif\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,3 @@\n+\/\/ Integer.MAX_VALUE - 1 is the maximum transfer size for TransmitFile()\n+#define MAX_TRANSMIT_SIZE (java_lang_Integer_MAX_VALUE - 1)\n+\n@@ -159,2 +162,2 @@\n-    DWORD chunkSize = (count > java_lang_Integer_MAX_VALUE) ?\n-        java_lang_Integer_MAX_VALUE : (DWORD)count;\n+    DWORD chunkSize = (count > MAX_TRANSMIT_SIZE) ?\n+        MAX_TRANSMIT_SIZE : (DWORD)count;\n@@ -192,0 +195,7 @@\n+\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileChannelImpl_maxDirectTransferSize0(JNIEnv* env, jobject this)\n+{\n+    return MAX_TRANSMIT_SIZE;\n+}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8271308\n+ * @summary Verify that transferTo() copies more than Integer.MAX_VALUE bytes\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main Transfer2GPlus\n+ *\/\n+\n+import java.io.File;\n+import java.io.DataOutputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Platform;\n+\n+public class Transfer2GPlus {\n+    private static final int LINUX_MAX_TRANSFER_SIZE = 0x7ffff000;\n+\n+    private static final long BASE   = (long)Integer.MAX_VALUE;\n+    private static final int  EXTRA  = 1024;\n+    private static final long LENGTH = BASE + EXTRA;\n+\n+    public static void main(String[] args) throws IOException {\n+        Path src = Files.createTempFile(\"src\", \".dat\");\n+        src.toFile().deleteOnExit();\n+        byte[] b = createSrcFile(src);\n+        testToFileChannel(src, b);\n+        testToWritableByteChannel(src, b);\n+    }\n+\n+    \/\/ Create a file of size LENGTH with EXTRA random bytes at offset BASE.\n+    private static byte[] createSrcFile(Path src)\n+        throws IOException {\n+        RandomAccessFile raf = new RandomAccessFile(src.toString(), \"rw\");\n+        raf.setLength(LENGTH);\n+        raf.seek(BASE);\n+        Random r = new Random(System.nanoTime());\n+        byte[] b = new byte[EXTRA];\n+        r.nextBytes(b);\n+        raf.write(b);\n+        return b;\n+    }\n+\n+    \/\/ Exercises transferToDirectly() on Linux and transferToTrustedChannel()\n+    \/\/ on macOS and Windows.\n+    private static void testToFileChannel(Path src, byte[] expected)\n+        throws IOException {\n+        Path dst = Files.createTempFile(\"dst\", \".dat\");\n+        dst.toFile().deleteOnExit();\n+        try (FileChannel srcCh = FileChannel.open(src)) {\n+            try (FileChannel dstCh = FileChannel.open(dst,\n+                 StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+                long n;\n+                if ((n = srcCh.transferTo(0, LENGTH, dstCh)) < LENGTH) {\n+                    if (!Platform.isLinux())\n+                        throw new RuntimeException(\"Transfer too small: \" + n);\n+\n+                    if (n != 0x7ffff000)\n+                        throw new RuntimeException(\"Unexpected transfer size: \" + n);\n+                    if ((n += srcCh.transferTo(n, LENGTH, dstCh)) != LENGTH)\n+                        throw new RuntimeException(\"Unexpected total size: \" + n);\n+                }\n+\n+                if (dstCh.size() < LENGTH)\n+                    throw new RuntimeException(\"Target file too small: \" +\n+                        dstCh.size() + \" < \" + LENGTH);\n+\n+                System.out.println(\"Transferred \" + n + \" bytes\");\n+\n+                dstCh.position(BASE);\n+                ByteBuffer bb = ByteBuffer.allocate(EXTRA);\n+                dstCh.read(bb);\n+                if (!Arrays.equals(bb.array(), expected))\n+                    throw new RuntimeException(\"Unexpected values\");\n+            }\n+        }\n+    }\n+\n+    \/\/ Exercises transferToArbitraryChannel() on all platforms.\n+    private static void testToWritableByteChannel(Path src, byte[] expected)\n+        throws IOException {\n+        File file = File.createTempFile(\"dst\", \".dat\");\n+        file.deleteOnExit();\n+        try (FileChannel srcCh = FileChannel.open(src)) {\n+            \/\/ The FileOutputStream is wrapped so that newChannel() does not\n+            \/\/ return a FileChannelImpl and so make a faster path be taken.\n+            try (DataOutputStream stream =\n+                new DataOutputStream(new FileOutputStream(file))) {\n+                try (WritableByteChannel wbc = Channels.newChannel(stream)) {\n+                    long n;\n+                    if ((n = srcCh.transferTo(0, LENGTH, wbc)) < LENGTH)\n+                        throw new RuntimeException(\"Too few bytes transferred: \" +\n+                            n + \" < \" + LENGTH);\n+\n+                    System.out.println(\"Transferred \" + n + \" bytes\");\n+\n+                    RandomAccessFile raf = new RandomAccessFile(file, \"r\");\n+                    raf.seek(BASE);\n+                    byte[] b = new byte[EXTRA];\n+                    raf.read(b);\n+                    if (!Arrays.equals(b, expected))\n+                        throw new RuntimeException(\"Unexpected values\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfer2GPlus.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}