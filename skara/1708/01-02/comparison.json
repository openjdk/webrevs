{"files":[{"patch":"@@ -463,1 +463,1 @@\n-        if (pr.diffLimited()) {\n+        if (!backportDiff.complete() || !prDiff.complete()) {\n@@ -1279,2 +1279,1 @@\n-                \" This backport pull request is too large for skara bot to get the entire diff from the remote repository. \" +\n-                \"Therefore, skara bot can't evaluate whether this backport is clean or not.\" +\n+                \" This backport pull request is too large to be automatically evaluated as clean. \" +\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2099,0 +2099,67 @@\n+\n+\n+    @Test\n+    void incompleteBackport(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory(false)) {\n+\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                    .addCommitter(author.forge().currentUser().id())\n+                    .addReviewer(integrator.forge().currentUser().id())\n+                    .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                    .repo(integrator)\n+                    .censusRepo(censusBuilder.build())\n+                    .issueProject(issues)\n+                    .issuePRMap(new HashMap<>())\n+                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            var releaseBranch = localRepo.branch(masterHash, \"release\");\n+            localRepo.checkout(releaseBranch);\n+            var newFile = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile, \"hello\");\n+            localRepo.add(newFile);\n+            var issue1 = credentials.createIssue(issues, \"An issue\");\n+            var issue1Number = issue1.id().split(\"-\")[1];\n+            var originalMessage = issue1Number + \": An issue\\n\" +\n+                    \"\\n\" +\n+                    \"Reviewed-by: integrationreviewer2\";\n+            var releaseHash = localRepo.commit(originalMessage, \"integrationcommitter1\", \"integrationcommitter1@openjdk.org\");\n+            localRepo.push(releaseHash, author.authenticatedUrl(), \"refs\/heads\/release\", true);\n+\n+            \/\/ \"backport\" the new file to the master branch\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var editHash = localRepo.commit(\"Backport\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(editHash, author.authenticatedUrl(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"Backport \" + releaseHash.hex(), List.of());\n+            \/\/ Force the pr to return incomplete diff\n+            pr.setReturnCompleteDiff(false);\n+\n+            \/\/ The bot should reply with a backport message\n+            TestBotRunner.runPeriodicItems(bot);\n+            var comments = pr.comments();\n+            var backportComment = comments.get(1).body();\n+            assertTrue(backportComment.contains(\"This backport pull request has now been updated with issue\"));\n+            assertTrue(backportComment.contains(\"<!-- backport \" + releaseHash.hex() + \" -->\"));\n+            assertEquals(issue1Number + \": An issue\", pr.store().title());\n+            assertTrue(pr.store().labelNames().contains(\"backport\"));\n+            assertLastCommentContains(pr, \"This backport pull request is too large to be automatically evaluated as clean.\");\n+\n+            \/\/ The bot should not have added the \"clean\" label\n+            assertFalse(pr.store().labelNames().contains(\"clean\"));\n+        }\n+    }\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/BackportTests.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -340,5 +340,0 @@\n-\n-    @Override\n-    public boolean diffLimited() {\n-        return false;\n-    }\n","filename":"bots\/tester\/src\/test\/java\/org\/openjdk\/skara\/bots\/tester\/InMemoryPullRequest.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,7 +218,0 @@\n-    \/**\n-     * Returns true if the Diff returned by diff() is limited.\n-     * This method can only be called after invoking diff().\n-     * Calling it before diff() will result in a RuntimeException.\n-     *\/\n-    boolean diffLimited();\n-\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequest.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-    private Optional<Boolean> diffLimited = Optional.empty();\n@@ -756,1 +755,1 @@\n-            diffLimited = Optional.of(true);\n+            return repository.toDiff(targetHash, headHash(), files, false);\n@@ -758,1 +757,1 @@\n-            diffLimited = Optional.of(false);\n+            return repository.toDiff(targetHash, headHash(), files, true);\n@@ -760,1 +759,0 @@\n-        return repository.toDiff(targetHash, headHash(), files);\n@@ -830,8 +828,0 @@\n-\n-    @Override\n-    public boolean diffLimited() {\n-        if (diffLimited.isEmpty()) {\n-            throw new RuntimeException(\"Diff() has not been called. Can't evaluate if diff is limited\");\n-        }\n-        return diffLimited.get();\n-    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubPullRequest.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -534,1 +534,1 @@\n-    Diff toDiff(Hash from, Hash to, JSONValue files) {\n+    Diff toDiff(Hash from, Hash to, JSONValue files, boolean complete) {\n@@ -556,1 +556,1 @@\n-        return new Diff(from, to, patches);\n+        return new Diff(from, to, patches, complete);\n@@ -582,1 +582,13 @@\n-            diffs = List.of(toDiff(metadata.parents().get(0), hash, o.get(\"files\")));\n+            var totalAdditions = o.get(\"stats\").get(\"additions\").asInt();\n+            var totalDeletions = o.get(\"stats\").get(\"deletions\").asInt();\n+            var sumAdditions = 0;\n+            var sumDeletions = 0;\n+            for (var patch : o.get(\"files\").asArray()) {\n+                sumAdditions += patch.get(\"additions\").asInt();\n+                sumDeletions += patch.get(\"deletions\").asInt();\n+            }\n+            if (totalAdditions == sumAdditions && totalDeletions == sumDeletions) {\n+                diffs = List.of(toDiff(metadata.parents().get(0), hash, o.get(\"files\"), true));\n+            } else {\n+                diffs = List.of(toDiff(metadata.parents().get(0), hash, o.get(\"files\"), false));\n+            }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/github\/GitHubRepository.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-    private Optional<Boolean> diffLimited = Optional.empty();\n@@ -834,0 +833,1 @@\n+        boolean diffComplete;\n@@ -835,1 +835,1 @@\n-            diffLimited = Optional.of(true);\n+            diffComplete = false;\n@@ -837,5 +837,1 @@\n-            if (changes.get(\"changes\").asArray().size() < Integer.parseInt(json.get(\"changes_count\").asString())) {\n-                diffLimited = Optional.of(true);\n-            } else {\n-                diffLimited = Optional.of(false);\n-            }\n+            diffComplete = !changes.get(\"changes_count\").asString().contains(\"+\");\n@@ -844,1 +840,1 @@\n-        return repository.toDiff(targetHash, headHash(), changes.get(\"changes\"));\n+        return repository.toDiff(targetHash, headHash(), changes.get(\"changes\"), diffComplete);\n@@ -930,8 +926,0 @@\n-\n-    @Override\n-    public boolean diffLimited() {\n-        if (diffLimited.isEmpty()) {\n-            throw new RuntimeException(\"Diff() has not been called. Can't evaluate if diff is limited\");\n-        }\n-        return diffLimited.get();\n-    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabMergeRequest.java","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-    Diff toDiff(Hash from, Hash to, JSONValue o) {\n+    Diff toDiff(Hash from, Hash to, JSONValue o, boolean complete) {\n@@ -734,1 +734,1 @@\n-        return new Diff(from, to, patches);\n+        return new Diff(from, to, patches, complete);\n@@ -754,1 +754,5 @@\n-                diffs = List.of(toDiff(metadata.parents().get(0), hash, diff));\n+                \/\/ The diff here is limited by diff patch, diff files count, diff lines.\n+                \/\/ There is no feasible way to know if this diff is complete.\n+                \/\/ The diff here is only used to evaluate if a backport PR is clean or not,\n+                \/\/ assuming the diff is complete will not introduce any side effect.\n+                diffs = List.of(toDiff(metadata.parents().get(0), hash, diff, true));\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabRepository.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -499,2 +499,2 @@\n-    @EnabledIfTestProperties({\"github.user\", \"github.pat\", \"github.repository\", \"github.prId\"})\n-    void testIsDiffLimited() {\n+    @EnabledIfTestProperties({\"github.user\", \"github.pat\", \"github.repository\", \"github.prId\", \"github.repository.commitHash\"})\n+    void testDiffComplete() {\n@@ -504,0 +504,4 @@\n+        var commit = githubRepo.commit(new Hash(props.get(\"github.repository.commitHash\")), true);\n+        var diff = commit.get().parentDiffs().get(0);\n+        assertFalse(diff.complete());\n+\n@@ -505,2 +509,2 @@\n-        pr.diff();\n-        assertTrue(pr.diffLimited());\n+        var prDiff = pr.diff();\n+        assertFalse(prDiff.complete());\n","filename":"forge\/src\/test\/java\/org\/openjdk\/skara\/forge\/github\/GitHubIntegrationTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -394,2 +394,2 @@\n-            \"gitlab.repository\", \"gitlab.merge.request.id\"})\n-    void testIsDiffLimited() {\n+            \"gitlab.repository\", \"gitlab.merge.request.id\", \"gitlab.repository.commitHash\"})\n+    void testDiffComplete() {\n@@ -397,0 +397,4 @@\n+        var commit = gitLabRepo.commit(new Hash(props.get(\"gitlab.repository.commitHash\")), true);\n+        var diff = commit.get().parentDiffs().get(0);\n+        assertTrue(diff.complete());\n+\n@@ -398,2 +402,2 @@\n-        pr.diff();\n-        assertFalse(pr.diffLimited());\n+        var prDiff = pr.diff();\n+        assertFalse(prDiff.complete());\n","filename":"forge\/src\/test\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabIntegrationTests.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -271,8 +271,15 @@\n-        try {\n-            var targetLocalRepository = targetRepository.localRepository();\n-            var sourceLocalRepository = store().sourceRepository().localRepository();\n-            var sourceHash = headHash();\n-            if (!targetLocalRepository.root().equals(sourceLocalRepository.root())) {\n-                \/\/ The target and source repo are not same, fetch the source branch\n-                var sourceUri = URI.create(\"file:\/\/\" + sourceLocalRepository.root().toString());\n-                sourceHash = targetLocalRepository.fetch(sourceUri, sourceRef).orElseThrow();\n+        if (store().returnCompleteDiff()) {\n+            try {\n+                var targetLocalRepository = targetRepository.localRepository();\n+                var sourceLocalRepository = store().sourceRepository().localRepository();\n+                var sourceHash = headHash();\n+                if (!targetLocalRepository.root().equals(sourceLocalRepository.root())) {\n+                    \/\/ The target and source repo are not same, fetch the source branch\n+                    var sourceUri = URI.create(\"file:\/\/\" + sourceLocalRepository.root().toString());\n+                    sourceHash = targetLocalRepository.fetch(sourceUri, sourceRef).orElseThrow();\n+                }\n+                \/\/ Find the base hash of the source and target branches.\n+                var baseHash = targetLocalRepository.mergeBase(sourceHash, targetRepository.branchHash(targetRef()).orElseThrow());\n+                return targetLocalRepository.diff(baseHash, sourceHash);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n@@ -280,5 +287,2 @@\n-            \/\/ Find the base hash of the source and target branches.\n-            var baseHash = targetLocalRepository.mergeBase(sourceHash, targetRepository.branchHash(targetRef()).orElseThrow());\n-            return targetLocalRepository.diff(baseHash, sourceHash);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n+        } else {\n+            return new Diff(Hash.zero(), Hash.zero(), List.of(), false);\n@@ -354,3 +358,2 @@\n-    @Override\n-    public boolean diffLimited() {\n-        return false;\n+    public void setReturnCompleteDiff(boolean complete){\n+        this.store().setReturnCompleteDiff(complete);\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestPullRequest.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    private boolean returnCompleteDiff;\n@@ -65,0 +66,1 @@\n+        this.returnCompleteDiff = true;\n@@ -116,0 +118,4 @@\n+    public boolean returnCompleteDiff(){\n+        return returnCompleteDiff;\n+    }\n+\n@@ -153,0 +159,4 @@\n+\n+    public void setReturnCompleteDiff(boolean returnCompleteDiff) {\n+        this.returnCompleteDiff = returnCompleteDiff;\n+    }\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestPullRequestStore.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+    private final boolean complete;\n@@ -44,0 +45,8 @@\n+        this.complete = true;\n+    }\n+\n+    public Diff(Hash from, Hash to, List<Patch> patches, boolean complete) {\n+        this.from = from;\n+        this.to = to;\n+        this.patches = patches;\n+        this.complete = complete;\n@@ -58,0 +67,4 @@\n+    public boolean complete() {\n+        return complete;\n+    }\n+\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/Diff.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}