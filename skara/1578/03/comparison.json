{"files":[{"patch":"@@ -34,1 +34,1 @@\n-    static List<String> get(ReadOnlyRepository repository, Hash hash, HostUser botUser, List<Comment> comments, boolean reviewMerge) throws IOException {\n+    static List<String> get(JCheckConfiguration original, HostUser botUser, List<Comment> comments, boolean reviewMerge) throws IOException {\n@@ -41,1 +41,0 @@\n-        var currentConfiguration = JCheckConfiguration.from(repository, hash).orElseThrow();\n@@ -45,1 +44,1 @@\n-        var updatedLimits = ReviewersTracker.updatedRoleLimits(currentConfiguration, additionalReviewers.get().number(), additionalReviewers.get().role());\n+        var updatedLimits = ReviewersTracker.updatedRoleLimits(original, additionalReviewers.get().number(), additionalReviewers.get().role());\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/AdditionalConfiguration.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-    private final boolean reviewMerge;\n@@ -100,1 +99,0 @@\n-        this.reviewMerge = reviewMerge;\n@@ -108,1 +106,2 @@\n-                comments);\n+                comments,\n+                reviewMerge);\n@@ -1204,0 +1203,1 @@\n+        var jcheckType = \"jcheck\";\n@@ -1205,1 +1205,0 @@\n-        String jcheckType = \"jcheck\";\n@@ -1223,1 +1222,4 @@\n-\n+            var targetHash = checkablePullRequest.targetHash();\n+            var targetJCheckConf = checkablePullRequest.parseJCheckConfiguration(targetHash)\n+                                                    .orElseThrow(() -> new IllegalStateException(\"Missing .jcheck\/conf for \" + pr));\n+            var isJCheckConfUpdatedInMergePR = false;\n@@ -1231,7 +1233,10 @@\n-                    var commits = localRepo.commitMetadata(localRepo.mergeBase(\n-                            PullRequestUtils.targetHash(localRepo), pr.headHash()), commitHash);\n-                    var commitHashes = commits.stream()\n-                            .map(CommitMetadata::hash)\n-                            .collect(Collectors.toSet());\n-                    commitHashes.remove(pr.headHash());\n-                    for (Hash hash : commitHashes) {\n+                    var commits = localRepo.commitMetadata(localRepo.mergeBase(targetHash, pr.headHash()), pr.headHash(), true);\n+                    isJCheckConfUpdatedInMergePR = commits.stream().anyMatch(c -> {\n+                        try {\n+                            return isFileUpdated(Path.of(\".jcheck\").resolve(\"conf\"), c.hash());\n+                        } catch (IOException e) {\n+                            throw new UncheckedIOException(e);\n+                        }\n+                    });\n+                    for (var commit : commits) {\n+                        var hash = commit.hash();\n@@ -1239,3 +1244,12 @@\n-                        PullRequestCheckIssueVisitor visitor = checkablePullRequest.createVisitor(hash);\n-                        checkablePullRequest.executeChecks(hash, censusInstance, visitor, List.of(), hash);\n-                        mergeJCheckMessage.addAll(visitor.messages().stream()\n+                        var targetVisitor = checkablePullRequest.createVisitor(targetJCheckConf, hash);\n+                        checkablePullRequest.executeChecks(hash, censusInstance, targetVisitor, targetJCheckConf);\n+\n+                        var commitJCheckConf = checkablePullRequest.parseJCheckConfiguration(hash)\n+                                                .orElseThrow(() -> new IllegalStateException(\"No .jcheck\/conf present in tree for commit \" + hash));\n+                        var commitVisitor = checkablePullRequest.createVisitor(commitJCheckConf, hash);\n+                        if (isJCheckConfUpdatedInMergePR) {\n+                            checkablePullRequest.executeChecks(hash, censusInstance, commitVisitor, commitJCheckConf);\n+                        }\n+\n+                        mergeJCheckMessage.addAll(\n+                                Stream.concat(targetVisitor.messages().stream(), commitVisitor.messages().stream())\n@@ -1268,2 +1282,3 @@\n-            PullRequestCheckIssueVisitor visitor = checkablePullRequest.createVisitor(checkablePullRequest.targetHash());\n-            boolean needUpdateAdditionalProgresses = false;\n+\n+            var visitor = checkablePullRequest.createVisitor(targetJCheckConf, localHash);\n+            var needUpdateAdditionalProgresses = false;\n@@ -1278,11 +1293,15 @@\n-                jcheckType = \"jcheck\";\n-                var additionalConfiguration = AdditionalConfiguration.get(localRepo, localHash,\n-                        pr.repository().forge().currentUser(), comments, reviewMerge);\n-                checkablePullRequest.executeChecks(localHash, censusInstance, visitor, additionalConfiguration, checkablePullRequest.targetHash());\n-                \/\/ Don't need to run the second round if confOverride is set.\n-                if (workItem.bot.confOverrideRepository().isEmpty() && isFileUpdated(\".jcheck\/conf\", localHash)) {\n-                    jcheckType = \"second jcheck\";\n-                    PullRequestCheckIssueVisitor visitor2 = checkablePullRequest.createVisitor(pr.headHash());\n-                    log.info(\"Run jcheck again with the updated configuration\");\n-                    checkablePullRequest.executeChecks(localHash, censusInstance, visitor2, additionalConfiguration, pr.headHash());\n-                    secondJCheckMessage.addAll(visitor2.messages().stream()\n+                jcheckType = \"target jcheck\";\n+                checkablePullRequest.executeChecks(localHash, censusInstance, visitor, targetJCheckConf);\n+\n+                \/\/ If the PR updates .jcheck\/conf then Need to run JCheck again using the configuration\n+                \/\/ from the resulting commit. Not needed if we are overriding the JCheck configuration since\n+                \/\/ then we won't use the one in the repo anyway.\n+                if (workItem.bot.confOverrideRepository().isEmpty() &&\n+                    (isFileUpdated(Path.of(\".jcheck\").resolve(\"conf\"), localHash) || isJCheckConfUpdatedInMergePR)) {\n+                    jcheckType = \"source jcheck\";\n+                    var localJCheckConf = checkablePullRequest.parseJCheckConfiguration(localHash)\n+                                                               .orElseThrow(() -> new IllegalStateException(\"Missing .jcheck\/conf at localHash in PR \" + pr));\n+                    var localVisitor = checkablePullRequest.createVisitor(localJCheckConf, localHash);\n+                    log.info(\"Run jcheck against localHash with JCHeck configuration from localHash\");\n+                    checkablePullRequest.executeChecks(localHash, censusInstance, localVisitor, localJCheckConf);\n+                    secondJCheckMessage.addAll(localVisitor.messages().stream()\n@@ -1290,1 +1309,1 @@\n-                            .map(e -> e.append(\" (failed with the updated jcheck configuration)\"))\n+                            .map(e -> e.append(\" (failed with updated jcheck configuration in pull request)\"))\n@@ -1298,1 +1317,1 @@\n-            var confFile = localRepo.lines(Path.of(\".jcheck\/conf\"), localHash);\n+            var confFile = localRepo.lines(Path.of(\".jcheck\").resolve(\"conf\"), localHash);\n@@ -1433,2 +1452,2 @@\n-    private boolean isFileUpdated(String filename, Hash hash) throws IOException {\n-        return !localRepo.files(hash, Path.of(filename)).isEmpty() &&\n+    private boolean isFileUpdated(Path filename, Hash hash) throws IOException {\n+        return !localRepo.files(hash, filename).isEmpty() &&\n@@ -1438,2 +1457,2 @@\n-                                        .anyMatch(patch -> (patch.source().path().isPresent() && patch.source().path().get().toString().equals(filename))\n-                                                || ((patch.target().path().isPresent() && patch.target().path().get().toString().equals(filename))))));\n+                                        .anyMatch(patch -> (patch.source().path().isPresent() && patch.source().path().get().equals(filename))\n+                                                || ((patch.target().path().isPresent() && patch.target().path().get().equals(filename))))));\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":53,"deletions":34,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private final boolean reviewMerge;\n@@ -52,1 +53,1 @@\n-            HostedRepository jcheckRepo, String jcheckName, String jcheckRef, List<Comment> comments) {\n+            HostedRepository jcheckRepo, String jcheckName, String jcheckRef, List<Comment> comments, boolean reviewMerge) {\n@@ -57,0 +58,1 @@\n+        this.reviewMerge = reviewMerge;\n@@ -205,2 +207,2 @@\n-    PullRequestCheckIssueVisitor createVisitor(Hash hash) throws IOException {\n-        var checks = JCheck.checksFor(localRepo, hash);\n+    PullRequestCheckIssueVisitor createVisitor(JCheckConfiguration conf, Hash hash) throws IOException {\n+        var checks = JCheck.checksFor(conf, localRepo, hash);\n@@ -210,10 +212,7 @@\n-    void executeChecks(Hash localHash, CensusInstance censusInstance, PullRequestCheckIssueVisitor visitor,\n-                       List<String> additionalConfiguration, Hash hash) throws IOException {\n-        Optional<JCheckConfiguration> conf;\n-        if (confOverride != null) {\n-            conf = JCheck.parseConfiguration(confOverride, additionalConfiguration);\n-        } else {\n-            conf = JCheck.parseConfiguration(localRepo, hash, additionalConfiguration);\n-        }\n-        if (conf.isEmpty()) {\n-            throw new RuntimeException(\"Failed to parse jcheck configuration at: \" + hash + \" with extra: \" + additionalConfiguration);\n+    Optional<JCheckConfiguration> parseJCheckConfiguration(Hash hash) throws IOException {\n+        var original = confOverride == null ?\n+            JCheck.parseConfiguration(localRepo, hash, List.of()) :\n+            JCheck.parseConfiguration(confOverride, List.of());\n+\n+        if (original.isEmpty()) {\n+            throw new IllegalStateException(\"Cannot parse JCheck configuration for commit with hash \" + hash.hex());\n@@ -221,3 +220,11 @@\n-        visitor.setConfiguration(conf.get());\n-        try (var issues = JCheck.check(localRepo, censusInstance.census(), CommitMessageParsers.v1, localHash,\n-                                       conf.get())) {\n+\n+        var botUser = pr.repository().forge().currentUser();\n+        var additional = AdditionalConfiguration.get(original.get(), botUser, comments, reviewMerge);\n+        return confOverride == null ?\n+            JCheck.parseConfiguration(localRepo, hash, additional) :\n+            JCheck.parseConfiguration(confOverride, additional);\n+    }\n+\n+    void executeChecks(Hash localHash, CensusInstance censusInstance, PullRequestCheckIssueVisitor visitor, JCheckConfiguration conf) throws IOException {\n+        visitor.setConfiguration(conf);\n+        try (var issues = JCheck.check(localRepo, censusInstance.census(), CommitMessageParsers.v1, localHash, conf)) {\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckablePullRequest.java","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -200,1 +200,2 @@\n-                    allComments);\n+                    allComments,\n+                    bot.reviewMerge());\n@@ -226,1 +227,1 @@\n-            if (runJcheck(pr, censusInstance, allComments, reply, localRepo, checkablePr, localHash, bot.reviewMerge())) {\n+            if (runJcheck(pr, censusInstance, allComments, reply, checkablePr, localHash)) {\n@@ -262,6 +263,8 @@\n-    static boolean runJcheck(PullRequest pr, CensusInstance censusInstance, List<Comment> allComments, PrintWriter reply,\n-                      Repository localRepo, CheckablePullRequest checkablePr, Hash localHash, boolean reviewMerge) throws IOException {\n-        var issues = checkablePr.createVisitor(checkablePr.targetHash());\n-        var additionalConfiguration = AdditionalConfiguration.get(localRepo, localHash, pr.repository().forge().currentUser(), allComments, reviewMerge);\n-        checkablePr.executeChecks(localHash, censusInstance, issues, additionalConfiguration, checkablePr.targetHash());\n-        if (!issues.messages().isEmpty()) {\n+    static boolean runJcheck(PullRequest pr, CensusInstance censusInstance, List<Comment> allComments,\n+                             PrintWriter reply, CheckablePullRequest checkablePr, Hash localHash) throws IOException {\n+        var targetHash = checkablePr.targetHash();\n+        var jcheckConf = checkablePr.parseJCheckConfiguration(targetHash)\n+                                    .orElseThrow(() -> new IllegalStateException(\"No .jcheck\/conf found in commit with hash \" + targetHash.hex()));\n+        var visitor = checkablePr.createVisitor(jcheckConf, targetHash);\n+        checkablePr.executeChecks(localHash, censusInstance, visitor, jcheckConf);\n+        if (!visitor.messages().isEmpty()) {\n@@ -270,1 +273,1 @@\n-            issues.messages().stream()\n+            visitor.messages().stream()\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-                    allComments);\n+                    allComments,\n+                    bot.reviewMerge());\n@@ -128,1 +129,1 @@\n-            if (IntegrateCommand.runJcheck(pr, censusInstance, allComments, reply, localRepo, checkablePr, localHash, bot.reviewMerge())) {\n+            if (IntegrateCommand.runJcheck(pr, censusInstance, allComments, reply, checkablePr, localHash)) {\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.skara.jcheck.JCheck;\n@@ -65,1 +66,3 @@\n-            var additional = AdditionalConfiguration.get(localRepo, masterHash, bot.forge().currentUser(),\n+            var jcheckConf = JCheck.parseConfiguration(localRepo, masterHash, List.of());\n+            assertTrue(jcheckConf.isPresent());\n+            var additional = AdditionalConfiguration.get(jcheckConf.get(), bot.forge().currentUser(),\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/AdditionalConfigurationTests.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import org.openjdk.skara.vcs.Repository;\n@@ -1414,1 +1415,1 @@\n-            \/\/ Check the status - should throw because in edit hash, .jcheck\/conf is updated and it will trigger second jcheck\n+            \/\/ Check the status - should throw because in edit hash, .jcheck\/conf is updated and it will trigger source jcheck\n@@ -1425,1 +1426,1 @@\n-            assertEquals(\"Exception occurred during second jcheck - the operation will be retried\", check.title().get());\n+            assertEquals(\"Exception occurred during source jcheck - the operation will be retried\", check.title().get());\n@@ -2780,2 +2781,2 @@\n-            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with the updated jcheck configuration)\"));\n-            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with the updated jcheck configuration)\"));\n+            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with updated jcheck configuration in pull request)\"));\n+            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with updated jcheck configuration in pull request)\"));\n@@ -2788,2 +2789,2 @@\n-            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with the updated jcheck configuration)\"));\n-            assertFalse(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with the updated jcheck configuration)\"));\n+            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with updated jcheck configuration in pull request)\"));\n+            assertFalse(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with updated jcheck configuration in pull request)\"));\n@@ -2848,1 +2849,1 @@\n-            assertEquals(\"Exception occurred during second jcheck - the operation will be retried\", check.title().get());\n+            assertEquals(\"Exception occurred during source jcheck - the operation will be retried\", check.title().get());\n@@ -2858,2 +2859,2 @@\n-            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with the updated jcheck configuration)\"));\n-            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with the updated jcheck configuration)\"));\n+            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with updated jcheck configuration in pull request)\"));\n+            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with updated jcheck configuration in pull request)\"));\n@@ -3121,0 +3122,50 @@\n+    @Test\n+    void overrideJcheckConfAndAdditionalConf(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var conf = credentials.getHostedRepository();\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id());\n+            var checkBot = PullRequestBot.newBuilder()\n+                                         .repo(author)\n+                                         .censusRepo(censusBuilder.build())\n+                                         .confOverrideRepo(conf)\n+                                         .confOverrideName(\"jcheck.conf\")\n+                                         .confOverrideRef(\"jcheck-branch\")\n+                                         .reviewMerge(true)\n+                                         .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Create a different conf on a different branch\n+            var defaultConf = Files.readString(localRepo.root().resolve(\".jcheck\/conf\"), StandardCharsets.UTF_8);\n+            var newConf = defaultConf.replace(\"reviewers=1\", \"reviewers=0\");\n+            Files.writeString(localRepo.root().resolve(\"jcheck.conf\"), newConf, StandardCharsets.UTF_8);\n+            localRepo.add(localRepo.root().resolve(\"jcheck.conf\"));\n+            var confHash = localRepo.commit(\"Separate conf\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(confHash, author.authenticatedUrl(), \"jcheck-branch\", true);\n+            localRepo.checkout(masterHash, true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.authenticatedUrl(), \"edit\", true);\n+\n+            localRepo.checkout(masterHash, true);\n+            localRepo.branch(masterHash, \"dev\");\n+            localRepo.merge(editHash, Repository.FastForward.DISABLE);\n+            var mergeHash = localRepo.commit(\"Merge edit\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(mergeHash, author.authenticatedUrl(), \"dev\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"dev\", \"Merge edit\");\n+\n+            \/\/ Check the status (should become ready immediately as reviewercount is overridden to 0)\n+            \/\/ even though merge PRs should always be reviewed\n+            TestBotRunner.runPeriodicItems(checkBot);\n+            assertEquals(Set.of(\"rfr\", \"ready\", \"clean\"), new HashSet<>(pr.store().labelNames()));\n+        }\n+    }\n+\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/CheckTests.java","additions":60,"deletions":9,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -298,0 +298,12 @@\n+\n+    public static Set<Check> checksFor(JCheckConfiguration conf, ReadOnlyRepository repository, Hash hash) throws IOException {\n+        var jcheck = new JCheck(repository,\n+                                CommitMessageParsers.v1,\n+                                repository.range(hash),\n+                                Pattern.compile(\".*\"),\n+                                Pattern.compile(\".*\"),\n+                                List.of(),\n+                                conf,\n+                                null);\n+        return jcheck.checksForRange();\n+    }\n","filename":"jcheck\/src\/main\/java\/org\/openjdk\/skara\/jcheck\/JCheck.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}