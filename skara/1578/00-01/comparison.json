{"files":[{"patch":"@@ -34,1 +34,1 @@\n-    static List<String> get(Optional<JCheckConfiguration> conf, HostUser botUser, List<Comment> comments, boolean reviewMerge) throws IOException {\n+    static List<String> get(JCheckConfiguration original, HostUser botUser, List<Comment> comments, boolean reviewMerge) throws IOException {\n@@ -41,1 +41,0 @@\n-        var currentConfiguration = conf.orElseThrow();\n@@ -45,1 +44,1 @@\n-        var updatedLimits = ReviewersTracker.updatedRoleLimits(currentConfiguration, additionalReviewers.get().number(), additionalReviewers.get().role());\n+        var updatedLimits = ReviewersTracker.updatedRoleLimits(original, additionalReviewers.get().number(), additionalReviewers.get().role());\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/AdditionalConfiguration.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-    private final boolean reviewMerge;\n@@ -100,1 +99,0 @@\n-        this.reviewMerge = reviewMerge;\n@@ -108,1 +106,2 @@\n-                comments);\n+                comments,\n+                reviewMerge);\n@@ -1193,0 +1192,1 @@\n+        var jcheckType = \"jcheck\";\n@@ -1194,1 +1194,0 @@\n-        String jcheckType = \"jcheck\";\n@@ -1212,1 +1211,4 @@\n-\n+            var targetHash = checkablePullRequest.targetHash();\n+            var targetJCheckConf = checkablePullRequest.parseJCheckConfiguration(targetHash)\n+                                                    .orElseThrow(() -> new IllegalStateException(\"Missing .jcheck\/conf for \" + pr));\n+            var isJCheckConfUpdatedInMergePR = false;\n@@ -1220,7 +1222,10 @@\n-                    var commits = localRepo.commitMetadata(localRepo.mergeBase(\n-                            PullRequestUtils.targetHash(localRepo), pr.headHash()), commitHash);\n-                    var commitHashes = commits.stream()\n-                            .map(CommitMetadata::hash)\n-                            .collect(Collectors.toSet());\n-                    commitHashes.remove(pr.headHash());\n-                    for (Hash hash : commitHashes) {\n+                    var commits = localRepo.commitMetadata(localRepo.mergeBase(targetHash, pr.headHash()), pr.headHash(), true);\n+                    isJCheckConfUpdatedInMergePR = commits.stream().anyMatch(c -> {\n+                        try {\n+                            return isFileUpdated(Path.of(\".jcheck\").resolve(\"conf\"), c.hash());\n+                        } catch (IOException e) {\n+                            throw new UncheckedIOException(e);\n+                        }\n+                    });\n+                    for (var commit : commits) {\n+                        var hash = commit.hash();\n@@ -1228,3 +1233,8 @@\n-                        PullRequestCheckIssueVisitor visitor = checkablePullRequest.createVisitor(hash);\n-                        checkablePullRequest.executeChecks(hash, censusInstance, visitor, List.of(), hash);\n-                        mergeJCheckMessage.addAll(visitor.messages().stream()\n+                        var targetVisitor = checkablePullRequest.createVisitor(targetJCheckConf, hash);\n+                        checkablePullRequest.executeChecks(hash, censusInstance, targetVisitor, targetJCheckConf);\n+                        var commitJCheckConf = checkablePullRequest.parseJCheckConfiguration(hash)\n+                                                .orElseThrow(() -> new IllegalStateException(\"No .jcheck\/conf present in tree for commit \" + hash));\n+                        var commitVisitor = checkablePullRequest.createVisitor(commitJCheckConf, hash);\n+                        checkablePullRequest.executeChecks(hash, censusInstance, commitVisitor, commitJCheckConf);\n+                        mergeJCheckMessage.addAll(\n+                                Stream.concat(targetVisitor.messages().stream(), commitVisitor.messages().stream())\n@@ -1258,3 +1268,2 @@\n-            Hash jcheckConfHash = checkablePullRequest.targetHash();\n-            PullRequestCheckIssueVisitor visitor = checkablePullRequest.createVisitor(jcheckConfHash);\n-            boolean needUpdateAdditionalProgresses = false;\n+            var visitor = checkablePullRequest.createVisitor(targetJCheckConf, localHash);\n+            var needUpdateAdditionalProgresses = false;\n@@ -1269,12 +1278,15 @@\n-                jcheckType = \"jcheck\";\n-                var conf = checkablePullRequest.parseJCheckConfiguration(localRepo, jcheckConfHash);\n-                var additionalConfiguration = AdditionalConfiguration.get(conf,\n-                        pr.repository().forge().currentUser(), comments, reviewMerge);\n-                checkablePullRequest.executeChecks(localHash, censusInstance, visitor, additionalConfiguration, jcheckConfHash);\n-                \/\/ Don't need to run the second round if confOverride is set.\n-                if (workItem.bot.confOverrideRepository().isEmpty() && isFileUpdated(\".jcheck\/conf\", localHash)) {\n-                    jcheckType = \"second jcheck\";\n-                    PullRequestCheckIssueVisitor visitor2 = checkablePullRequest.createVisitor(pr.headHash());\n-                    log.info(\"Run jcheck again with the updated configuration\");\n-                    checkablePullRequest.executeChecks(localHash, censusInstance, visitor2, additionalConfiguration, pr.headHash());\n-                    secondJCheckMessage.addAll(visitor2.messages().stream()\n+                jcheckType = \"target jcheck\";\n+                checkablePullRequest.executeChecks(localHash, censusInstance, visitor, targetJCheckConf);\n+\n+                \/\/ If the PR updates .jcheck\/conf then Need to run JCheck again using the configuration\n+                \/\/ from the resulting commit. Not needed if we are overriding the JCheck configuration since\n+                \/\/ then we won't use the one in the repo anyway.\n+                if (workItem.bot.confOverrideRepository().isEmpty() &&\n+                    (isFileUpdated(Path.of(\".jcheck\").resolve(\"conf\"), localHash) || isJCheckConfUpdatedInMergePR)) {\n+                    jcheckType = \"source jcheck\";\n+                    var localJCheckConf = checkablePullRequest.parseJCheckConfiguration(localHash)\n+                                                               .orElseThrow(() -> new IllegalStateException(\"Missing .jcheck\/conf at localHash in PR \" + pr));\n+                    var localVisitor = checkablePullRequest.createVisitor(localJCheckConf, localHash);\n+                    log.info(\"Run jcheck against localHash with JCHeck configuration from localHash\");\n+                    checkablePullRequest.executeChecks(localHash, censusInstance, localVisitor, localJCheckConf);\n+                    secondJCheckMessage.addAll(localVisitor.messages().stream()\n@@ -1282,1 +1294,1 @@\n-                            .map(e -> e.append(\" (failed with the updated jcheck configuration)\"))\n+                            .map(e -> e.append(\" (failed with updated jcheck configuration in pull request)\"))\n@@ -1290,1 +1302,1 @@\n-            var confFile = localRepo.lines(Path.of(\".jcheck\/conf\"), localHash);\n+            var confFile = localRepo.lines(Path.of(\".jcheck\").resolve(\"conf\"), localHash);\n@@ -1425,2 +1437,2 @@\n-    private boolean isFileUpdated(String filename, Hash hash) throws IOException {\n-        return !localRepo.files(hash, Path.of(filename)).isEmpty() &&\n+    private boolean isFileUpdated(Path filename, Hash hash) throws IOException {\n+        return !localRepo.files(hash, filename).isEmpty() &&\n@@ -1430,2 +1442,2 @@\n-                                        .anyMatch(patch -> (patch.source().path().isPresent() && patch.source().path().get().toString().equals(filename))\n-                                                || ((patch.target().path().isPresent() && patch.target().path().get().toString().equals(filename))))));\n+                                        .anyMatch(patch -> (patch.source().path().isPresent() && patch.source().path().get().equals(filename))\n+                                                || ((patch.target().path().isPresent() && patch.target().path().get().equals(filename))))));\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":48,"deletions":36,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private final boolean reviewMerge;\n@@ -52,1 +53,1 @@\n-            HostedRepository jcheckRepo, String jcheckName, String jcheckRef, List<Comment> comments) {\n+            HostedRepository jcheckRepo, String jcheckName, String jcheckRef, List<Comment> comments, boolean reviewMerge) {\n@@ -57,0 +58,1 @@\n+        this.reviewMerge = reviewMerge;\n@@ -205,2 +207,2 @@\n-    PullRequestCheckIssueVisitor createVisitor(Hash hash) throws IOException {\n-        var checks = JCheck.checksFor(localRepo, hash);\n+    PullRequestCheckIssueVisitor createVisitor(JCheckConfiguration conf, Hash hash) throws IOException {\n+        var checks = JCheck.checksFor(conf, localRepo, hash);\n@@ -210,3 +212,4 @@\n-    Optional<JCheckConfiguration> parseJCheckConfiguration(ReadOnlyRepository repo, Hash hash) {\n-        return parseJCheckConfiguration(repo, hash, List.of());\n-    }\n+    Optional<JCheckConfiguration> parseJCheckConfiguration(Hash hash) throws IOException {\n+        var original = confOverride == null ?\n+            JCheck.parseConfiguration(localRepo, hash, List.of()) :\n+            JCheck.parseConfiguration(confOverride, List.of());\n@@ -214,3 +217,2 @@\n-    Optional<JCheckConfiguration> parseJCheckConfiguration(ReadOnlyRepository repo, Hash hash, List<String> additional) {\n-        if (confOverride != null) {\n-            return JCheck.parseConfiguration(confOverride, additional);\n+        if (original.isEmpty()) {\n+            throw new IllegalStateException(\"Cannot parse JCheck configuration for commit with hash \" + hash.hex());\n@@ -218,1 +220,6 @@\n-        return JCheck.parseConfiguration(localRepo, hash, additional);\n+\n+        var botUser = pr.repository().forge().currentUser();\n+        var additional = AdditionalConfiguration.get(original.get(), botUser, comments, reviewMerge);\n+        return confOverride == null ?\n+            JCheck.parseConfiguration(localRepo, hash, additional) :\n+            JCheck.parseConfiguration(confOverride, additional);\n@@ -221,9 +228,3 @@\n-    void executeChecks(Hash localHash, CensusInstance censusInstance, PullRequestCheckIssueVisitor visitor,\n-                       List<String> additionalConfiguration, Hash jcheckConfHash) throws IOException {\n-        var conf = parseJCheckConfiguration(localRepo, jcheckConfHash, additionalConfiguration);\n-        if (conf.isEmpty()) {\n-            throw new RuntimeException(\"Failed to parse jcheck configuration at: \" + jcheckConfHash + \" with extra: \" + additionalConfiguration);\n-        }\n-        visitor.setConfiguration(conf.get());\n-        try (var issues = JCheck.check(localRepo, censusInstance.census(), CommitMessageParsers.v1, localHash,\n-                                       conf.get())) {\n+    void executeChecks(Hash localHash, CensusInstance censusInstance, PullRequestCheckIssueVisitor visitor, JCheckConfiguration conf) throws IOException {\n+        visitor.setConfiguration(conf);\n+        try (var issues = JCheck.check(localRepo, censusInstance.census(), CommitMessageParsers.v1, localHash, conf)) {\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckablePullRequest.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -200,1 +200,2 @@\n-                    allComments);\n+                    allComments,\n+                    bot.reviewMerge());\n@@ -226,1 +227,1 @@\n-            if (runJcheck(pr, censusInstance, allComments, reply, localRepo, checkablePr, localHash, bot.reviewMerge())) {\n+            if (runJcheck(pr, censusInstance, allComments, reply, checkablePr, localHash)) {\n@@ -262,8 +263,8 @@\n-    static boolean runJcheck(PullRequest pr, CensusInstance censusInstance, List<Comment> allComments, PrintWriter reply,\n-                      Repository localRepo, CheckablePullRequest checkablePr, Hash localHash, boolean reviewMerge) throws IOException {\n-        var issues = checkablePr.createVisitor(checkablePr.targetHash());\n-        var jcheckConfHash = checkablePr.targetHash();\n-        var jcheckConf = checkablePr.parseJCheckConfiguration(localRepo, jcheckConfHash);\n-        var additionalConfiguration = AdditionalConfiguration.get(jcheckConf, pr.repository().forge().currentUser(), allComments, reviewMerge);\n-        checkablePr.executeChecks(localHash, censusInstance, issues, additionalConfiguration, jcheckConfHash);\n-        if (!issues.messages().isEmpty()) {\n+    static boolean runJcheck(PullRequest pr, CensusInstance censusInstance, List<Comment> allComments,\n+                             PrintWriter reply, CheckablePullRequest checkablePr, Hash localHash) throws IOException {\n+        var targetHash = checkablePr.targetHash();\n+        var jcheckConf = checkablePr.parseJCheckConfiguration(targetHash)\n+                                    .orElseThrow(() -> new IllegalStateException(\"No .jcheck\/conf found in commit with hash \" + targetHash.hex()));\n+        var visitor = checkablePr.createVisitor(jcheckConf, targetHash);\n+        checkablePr.executeChecks(localHash, censusInstance, visitor, jcheckConf);\n+        if (!visitor.messages().isEmpty()) {\n@@ -272,1 +273,1 @@\n-            issues.messages().stream()\n+            visitor.messages().stream()\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-                    allComments);\n+                    allComments,\n+                    bot.reviewMerge());\n@@ -128,1 +129,1 @@\n-            if (IntegrateCommand.runJcheck(pr, censusInstance, allComments, reply, localRepo, checkablePr, localHash, bot.reviewMerge())) {\n+            if (IntegrateCommand.runJcheck(pr, censusInstance, allComments, reply, checkablePr, localHash)) {\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import org.openjdk.skara.jcheck.JCheck;\n@@ -65,1 +66,3 @@\n-            var additional = AdditionalConfiguration.get(localRepo, masterHash, bot.forge().currentUser(),\n+            var jcheckConf = JCheck.parseConfiguration(localRepo, masterHash, List.of());\n+            assertTrue(jcheckConf.isPresent());\n+            var additional = AdditionalConfiguration.get(jcheckConf.get(), bot.forge().currentUser(),\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/AdditionalConfigurationTests.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1415,1 +1415,1 @@\n-            \/\/ Check the status - should throw because in edit hash, .jcheck\/conf is updated and it will trigger second jcheck\n+            \/\/ Check the status - should throw because in edit hash, .jcheck\/conf is updated and it will trigger source jcheck\n@@ -1426,1 +1426,1 @@\n-            assertEquals(\"Exception occurred during second jcheck - the operation will be retried\", check.title().get());\n+            assertEquals(\"Exception occurred during source jcheck - the operation will be retried\", check.title().get());\n@@ -2781,2 +2781,2 @@\n-            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with the updated jcheck configuration)\"));\n-            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with the updated jcheck configuration)\"));\n+            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with updated jcheck configuration in pull request)\"));\n+            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with updated jcheck configuration in pull request)\"));\n@@ -2789,2 +2789,2 @@\n-            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with the updated jcheck configuration)\"));\n-            assertFalse(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with the updated jcheck configuration)\"));\n+            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with updated jcheck configuration in pull request)\"));\n+            assertFalse(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with updated jcheck configuration in pull request)\"));\n@@ -2849,1 +2849,1 @@\n-            assertEquals(\"Exception occurred during second jcheck - the operation will be retried\", check.title().get());\n+            assertEquals(\"Exception occurred during source jcheck - the operation will be retried\", check.title().get());\n@@ -2859,2 +2859,2 @@\n-            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with the updated jcheck configuration)\"));\n-            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with the updated jcheck configuration)\"));\n+            assertTrue(pr.store().body().contains(\"Whitespace errors (failed with updated jcheck configuration in pull request)\"));\n+            assertTrue(pr.store().body().contains(\"Too few reviewers with at least role reviewer found (have 0, need at least 1) (failed with updated jcheck configuration in pull request)\"));\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/CheckTests.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -298,0 +298,12 @@\n+\n+    public static Set<Check> checksFor(JCheckConfiguration conf, ReadOnlyRepository repository, Hash hash) throws IOException {\n+        var jcheck = new JCheck(repository,\n+                                CommitMessageParsers.v1,\n+                                repository.range(hash),\n+                                Pattern.compile(\".*\"),\n+                                Pattern.compile(\".*\"),\n+                                List.of(),\n+                                conf,\n+                                null);\n+        return jcheck.checksForRange();\n+    }\n","filename":"jcheck\/src\/main\/java\/org\/openjdk\/skara\/jcheck\/JCheck.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}