{"files":[{"patch":"@@ -324,30 +324,28 @@\n-                    if (requestedVersion != null) {\n-                        var altFixedVersionIssue = findAltFixedVersionIssue(issue, branch);\n-                        if (altFixedVersionIssue.isPresent()) {\n-                            log.info(\"Found an already fixed backport \" + altFixedVersionIssue.get().id() + \" for \" + issue.id()\n-                                    + \" with fixVersion \" + Backports.mainFixVersion(altFixedVersionIssue.get()).orElseThrow());\n-                            issue = altFixedVersionIssue.get();\n-                            \/\/ Do not update fixVersion\n-                            requestedVersion = null;\n-                        } else {\n-                            var fixVersion = JdkVersion.parse(requestedVersion).orElseThrow();\n-                            var existing = Backports.findIssue(issue, fixVersion);\n-                            if (existing.isEmpty()) {\n-                                var issueFixVersion = Backports.mainFixVersion(issue);\n-                                try {\n-                                    if (issue.isOpen() && avoidForwardports && issueFixVersion.isPresent() && fixVersion.compareTo(issueFixVersion.get()) > 0) {\n-                                        log.info(\"Avoiding 'forwardport', creating new backport for \" + issue.id() + \" with fixVersion \" + issueFixVersion.get().raw());\n-                                        Backports.createBackport(issue, issueFixVersion.get().raw(), username.orElse(null), defaultSecurity(branch));\n-                                    } else {\n-                                        log.info(\"Creating new backport for \" + issue.id() + \" with fixVersion \" + requestedVersion);\n-                                        issue = Backports.createBackport(issue, requestedVersion, username.orElse(null), defaultSecurity(branch));\n-                                    }\n-                                } catch (UncheckedRestException e) {\n-                                    existing = Backports.findIssue(issue, fixVersion);\n-                                    if (existing.isPresent()) {\n-                                        log.info(\"Race condition occurred while creating backport issue, returning the existing backport for \" + issue.id() + \" and requested fixVersion \"\n-                                                + requestedVersion + \" \" + existing.get().id());\n-                                        issue = existing.get();\n-                                    } else {\n-                                        throw e;\n-                                    }\n+                    var altFixedVersionIssue = findAltFixedVersionIssue(issue, branch);\n+                    if (altFixedVersionIssue.isPresent()) {\n+                        log.info(\"Found an already fixed backport \" + altFixedVersionIssue.get().id() + \" for \" + issue.id()\n+                                + \" with fixVersion \" + Backports.mainFixVersion(altFixedVersionIssue.get()).orElseThrow());\n+                        issue = altFixedVersionIssue.get();\n+                        \/\/ Do not update fixVersion\n+                        requestedVersion = null;\n+                    } else if (requestedVersion != null) {\n+                        var fixVersion = JdkVersion.parse(requestedVersion).orElseThrow();\n+                        var existing = Backports.findIssue(issue, fixVersion);\n+                        if (existing.isEmpty()) {\n+                            var issueFixVersion = Backports.mainFixVersion(issue);\n+                            try {\n+                                if (issue.isOpen() && avoidForwardports && issueFixVersion.isPresent() && fixVersion.compareTo(issueFixVersion.get()) > 0) {\n+                                    log.info(\"Avoiding 'forwardport', creating new backport for \" + issue.id() + \" with fixVersion \" + issueFixVersion.get().raw());\n+                                    Backports.createBackport(issue, issueFixVersion.get().raw(), username.orElse(null), defaultSecurity(branch));\n+                                } else {\n+                                    log.info(\"Creating new backport for \" + issue.id() + \" with fixVersion \" + requestedVersion);\n+                                    issue = Backports.createBackport(issue, requestedVersion, username.orElse(null), defaultSecurity(branch));\n+                                }\n+                            } catch (UncheckedRestException e) {\n+                                existing = Backports.findIssue(issue, fixVersion);\n+                                if (existing.isPresent()) {\n+                                    log.info(\"Race condition occurred while creating backport issue, returning the existing backport for \" + issue.id() + \" and requested fixVersion \"\n+                                            + requestedVersion + \" \" + existing.get().id());\n+                                    issue = existing.get();\n+                                } else {\n+                                    throw e;\n@@ -355,4 +353,0 @@\n-                            } else {\n-                                log.info(\"Found existing backport for \" + issue.id() + \" and requested fixVersion \"\n-                                        + requestedVersion + \" \" + existing.get().id());\n-                                issue = existing.get();\n@@ -360,0 +354,4 @@\n+                        } else {\n+                            log.info(\"Found existing backport for \" + issue.id() + \" and requested fixVersion \"\n+                                    + requestedVersion + \" \" + existing.get().id());\n+                            issue = existing.get();\n@@ -375,0 +373,2 @@\n+                \/\/ If the issue here was found by findAltFixedVersionIssue(), issue.isFixed() should return true,\n+                \/\/ so issue notifier won't do anything to the issue except posting a comment\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/issue\/IssueNotifier.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2530,0 +2530,1 @@\n+            issue.setProperty(\"resolution\", JSON.object().put(\"name\", JSON.of(\"Delivered\")));\n@@ -2542,0 +2543,2 @@\n+            \/\/ The resolution of the issue should still be \"Delivered\"\n+            assertEquals(\"Delivered\", issue.properties().get(\"resolution\").get(\"name\").asString());\n","filename":"bots\/notify\/src\/test\/java\/org\/openjdk\/skara\/bots\/notify\/issue\/IssueNotifierTests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    private static final List<String> VALID_RESOLUTIONS = List.of(\"Fixed\", \"Delivered\");\n@@ -226,1 +227,1 @@\n-                return \"Fixed\".equals(resolution.get(\"name\").asString());\n+                return VALID_RESOLUTIONS.contains(resolution.get(\"name\").asString());\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/jira\/JiraIssue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+    private static final List<String> VALID_RESOLUTIONS = List.of(\"Fixed\", \"Delivered\");\n@@ -88,1 +89,1 @@\n-            return resolution().map(r -> r.equals(\"Fixed\")).orElse(Boolean.FALSE);\n+            return resolution().map(VALID_RESOLUTIONS::contains).orElse(Boolean.FALSE);\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestIssueTrackerIssue.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}