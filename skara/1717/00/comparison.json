{"files":[{"patch":"@@ -628,3 +628,10 @@\n-     * Lazy fetching and caching of the commitTitleToCommits map. The first time\n-     * this is called, the full map is built from the local repository. After that\n-     * it's just refreshed from the server.\n+     * Lazy fetching and caching of the commitTitleToCommits map. The map is only\n+     * cached for one set of branches. If called with a different set, the old\n+     * cache is invalidated and a new is rebuilt from scratch. In practice, an\n+     * instance of this class is only ever called with the same set of branches.\n+     * If that was to change we will need to rethink this.\n+     * <p>\n+     * The full map is built from the local repository. For incremental updates,\n+     * it's refreshed until it contains the same number of commits as the local\n+     * repository. The topo-order should guarantee that this gives us the same\n+     * set of commits.\n@@ -633,2 +640,2 @@\n-    private boolean commitTitleToCommitsInitialized = false;\n-    private ZonedDateTime lastCommitTime = ZonedDateTime.ofInstant(Instant.EPOCH, ZoneId.systemDefault());\n+    private Set<Branch> commitMapBranchSet;\n+    private int commitMapCount = 0;\n@@ -637,2 +644,12 @@\n-        if (!commitTitleToCommitsInitialized) {\n-            try {\n+        try {\n+            Set<Branch> branchSet = Set.copyOf(branches);\n+            if (!branchSet.equals(commitMapBranchSet)) {\n+                log.info(\"Invalidating commitTitleToCommits map for branch set: \" + branchSet + \" old set: \" + commitMapBranchSet);\n+                commitTitleToCommits.clear();\n+                commitMapCount = 0;\n+                commitMapBranchSet = branchSet;\n+            }\n+            int newSize = localRepo.commitCount(branches);\n+            if (newSize > commitMapCount) {\n+                int sizeBefore = commitMapCount;\n+                log.info(\"Adding \" + (newSize - sizeBefore) + \" new commit(s) to commitTitleToCommits map\");\n@@ -641,3 +658,19 @@\n-                    commitTitleToCommits.computeIfAbsent(title, t -> new LinkedHashSet<>()).add(commit.hash());\n-                    if (lastCommitTime.isBefore(commit.authored())) {\n-                        lastCommitTime = commit.authored();\n+                    SequencedSet<Hash> hashes = commitTitleToCommits.computeIfAbsent(title, t -> new LinkedHashSet<>());\n+                    if (!hashes.contains(commit.hash())) {\n+                        \/\/ We want to keep newer commits at the front for quicker lookup.\n+                        \/\/ Commits are iterated from newer to older so add last for the\n+                        \/\/ initial run. When updating, there will generally just be a small\n+                        \/\/ set of new commits in each run, so add them to the front.\n+                        if (sizeBefore == 0) {\n+                            hashes.add(commit.hash());\n+                        } else {\n+                            hashes.addFirst(commit.hash());\n+                        }\n+                        commitMapCount++;\n+                        \/\/ Only log each addition after the initial complete build is done\n+                        if (sizeBefore > 0) {\n+                            log.fine(\"Adding \" + commit.hash() + \" to commitTitleToCommits map\");\n+                        }\n+                    }\n+                    if (commitMapCount >= newSize) {\n+                        break;\n@@ -646,2 +679,2 @@\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n+            } else {\n+                log.fine(\"No commits added to commitTitleToCommits map\");\n@@ -649,1 +682,2 @@\n-            commitTitleToCommitsInitialized = true;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n@@ -651,20 +685,0 @@\n-        \/\/ Fetch eventual new commits\n-        var commits = request.get(\"repository\/commits\")\n-                .param(\"since\", lastCommitTime.format(DateTimeFormatter.ISO_DATE_TIME))\n-                .param(\"all\", \"true\")\n-                .execute()\n-                .asArray()\n-                .stream()\n-                .toList()\n-                .reversed();\n-\n-        for (var commit : commits) {\n-            var hash = new Hash(commit.get(\"id\").asString());\n-            var title = commit.get(\"title\").asString();\n-            commitTitleToCommits.computeIfAbsent(title, t -> new LinkedHashSet<>()).addFirst(hash);\n-            var authored = ZonedDateTime.parse(commit.get(\"authored_date\").asString());\n-            if (lastCommitTime.isBefore(authored)) {\n-                lastCommitTime = authored;\n-            }\n-        }\n-\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabRepository.java","additions":47,"deletions":33,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -318,0 +318,6 @@\n+\n+        \/\/ Pause here to update the local repository to trigger another code path\n+        var comments2 = gitLabRepo.recentCommitComments(localRepo, Set.of(), List.of(new Branch(\"master\")),\n+                ZonedDateTime.now().minus(Duration.ofDays(4)));\n+\n+        assertFalse(comments2.isEmpty());\n","filename":"forge\/src\/test\/java\/org\/openjdk\/skara\/forge\/gitlab\/GitLabIntegrationTests.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -351,0 +351,5 @@\n+    @Override\n+    public int commitCount(List<Branch> branches) throws IOException {\n+        return 0;\n+    }\n+\n","filename":"jcheck\/src\/test\/java\/org\/openjdk\/skara\/jcheck\/TestRepository.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -174,0 +174,2 @@\n+    int commitCount(List<Branch> branches) throws IOException;\n+\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/ReadOnlyRepository.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1713,0 +1713,10 @@\n+    @Override\n+    public int commitCount(List<Branch> branches) throws IOException {\n+        var args = new ArrayList<String>();\n+        args.addAll(List.of(\"git\", \"rev-list\", \"--count\"));\n+        args.addAll(branches.stream().map(Branch::name).toList());\n+        try (var p = capture(args)) {\n+            return Integer.parseInt(await(p).stdout().getFirst());\n+        }\n+    }\n+\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/git\/GitRepository.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1545,0 +1545,5 @@\n+    @Override\n+    public int commitCount(List<Branch> branches) throws IOException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/hg\/HgRepository.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3096,0 +3096,30 @@\n+\n+    @Test\n+    void testCommitCountWithBranchesWithGit() throws IOException {\n+        try (var dir = new TemporaryDirectory()) {\n+            var r = Repository.init(dir.path(), VCS.GIT);\n+\n+            var readme = dir.path().resolve(\"README\");\n+            Files.write(readme, List.of(\"Hello, world!\"));\n+            r.add(readme);\n+            var first = r.commit(\"Added README\", \"duke\", \"duke@openjdk.org\");\n+\n+            var b1 = r.branch(first, \"b1\");\n+            r.checkout(b1);\n+            Files.write(readme, List.of(\"One more line\"), WRITE, APPEND);\n+            r.add(readme);\n+            var second = r.commit(\"Modified README\", \"duke\", \"duke@openjdk.org\");\n+\n+            r.checkout(r.defaultBranch());\n+            var b2 = r.branch(first, \"b2\");\n+            r.checkout(b2);\n+            Files.write(readme, List.of(\"An additional line\"), WRITE, APPEND);\n+            r.add(readme);\n+            var third = r.commit(\"Additional line added to README\", \"duke\", \"duke@openjdk.org\");\n+\n+            assertEquals(3, r.commitCount());\n+            assertEquals(3, r.commitCount(List.of(new Branch(\"b1\"), new Branch(\"b2\"))));\n+            assertEquals(2, r.commitCount(List.of(new Branch(\"b1\"))));\n+            assertEquals(1, r.commitCount(List.of(r.defaultBranch())));\n+        }\n+    }\n","filename":"vcs\/src\/test\/java\/org\/openjdk\/skara\/vcs\/RepositoryTests.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}