{"files":[{"patch":"@@ -55,1 +55,0 @@\n-    private final JbsBackport jbsBackport;\n@@ -93,1 +92,1 @@\n-                  JbsBackport jbsBackport, boolean prOnly, boolean repoOnly, String buildName,\n+                  boolean prOnly, boolean repoOnly, String buildName,\n@@ -105,1 +104,0 @@\n-        this.jbsBackport = jbsBackport;\n@@ -310,1 +308,1 @@\n-                                    issue = jbsBackport.createBackport(issue, requestedVersion, username.orElse(null), defaultSecurity(branch));\n+                                    issue = Backports.createBackport(issue, requestedVersion, username.orElse(null), defaultSecurity(branch));\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/issue\/IssueNotifier.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -164,1 +164,0 @@\n-        var jbsBackport = new JbsBackport(issueProject.issueTracker());\n@@ -166,1 +165,1 @@\n-                setFixVersion, fixVersions, altFixVersions, jbsBackport, prOnly,\n+                setFixVersion, fixVersions, altFixVersions, prOnly,\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/issue\/IssueNotifierBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.skara.bots.notify.issue;\n-\n-import org.openjdk.skara.issuetracker.*;\n-import org.openjdk.skara.json.JSON;\n-import org.openjdk.skara.network.*;\n-\n-import java.net.URI;\n-import java.util.*;\n-import java.util.stream.Collectors;\n-\n-public class JbsBackport {\n-    private final IssueTracker.CustomEndpoint backportEndpoint;\n-\n-    JbsBackport(IssueTracker tracker) {\n-        this.backportEndpoint = tracker.lookupCustomEndpoint(\"\/rest\/jbs\/1.0\/backport\/\").orElseThrow(() ->\n-            new IllegalArgumentException(\"Issue tracker does not support backport endpoint\")\n-        );\n-    }\n-\n-    IssueTrackerIssue createBackport(IssueTrackerIssue primary, String fixVersion, String assignee, String defaultSecurity) {\n-        var body = JSON.object()\n-                       .put(\"parentIssueKey\", primary.id())\n-                       .put(\"fixVersion\", fixVersion);\n-\n-        if (assignee != null) {\n-            body = body.put(\"assignee\", assignee);\n-        }\n-\n-        if (primary.properties().containsKey(\"security\")) {\n-            body = body.put(\"level\", primary.properties().get(\"security\").asString());\n-        } else if (defaultSecurity != null) {\n-            body = body.put(\"level\", defaultSecurity);\n-        }\n-\n-        var response = backportEndpoint.post()\n-                                       .body(body)\n-                                       .execute();\n-        var issue = primary.project().issue(response.get(\"key\").asString()).orElseThrow();\n-\n-        \/\/ The backport should not have any labels set - if it does, clear them\n-        var labels = issue.labelNames();\n-        if (!labels.isEmpty()) {\n-            issue.setLabels(List.of());\n-        }\n-\n-        return issue;\n-    }\n-}\n","filename":"bots\/notify\/src\/main\/java\/org\/openjdk\/skara\/bots\/notify\/issue\/JbsBackport.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.skara.bots.notify.issue;\n-\n-import org.openjdk.skara.host.Credential;\n-import org.openjdk.skara.issuetracker.IssueTracker;\n-import org.openjdk.skara.issuetracker.IssueTrackerFactory;\n-import org.openjdk.skara.json.JSON;\n-import org.openjdk.skara.json.JSONObject;\n-import org.openjdk.skara.json.JSONValue;\n-import org.openjdk.skara.network.URIBuilder;\n-import org.openjdk.skara.proxy.HttpProxy;\n-import org.openjdk.skara.test.TestProperties;\n-import org.openjdk.skara.test.EnabledIfTestProperties;\n-\n-import java.util.*;\n-\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-\n-class JbsBackportIntegrationTests {\n-    private static TestProperties props;\n-    private static IssueTracker tracker;\n-\n-    @BeforeAll\n-    static void beforeAll() {\n-        props = TestProperties.load();\n-        if (props.contains(\"jira.uri\", \"jira.pat\")) {\n-            var factory = IssueTrackerFactory.getIssueTrackerFactories().stream().filter(f -> f.name().equals(\"jira\")).findFirst();\n-            if (factory.isEmpty()) {\n-                throw new IllegalStateException(\"'jira.uri' and 'jira.pat' has been configured but could not find IssueTrackerFactory for 'jira'\");\n-            }\n-            HttpProxy.setup();\n-            var uri = URIBuilder.base(props.get(\"jira.uri\")).build();\n-            var credential = new Credential(\"\", \"Bearer \" + props.get(\"jira.pat\"));\n-            tracker = factory.get().create(uri, credential, new JSONObject());\n-        }\n-    }\n-\n-    @Test\n-    @EnabledIfTestProperties({\"jira.uri\", \"jira.pat\"})\n-    void testBackportCreation() {\n-        var project = tracker.project(\"SKARA\");\n-        var issue = project.createIssue(\"Issue to backport\", List.of(\"This is just a test issue for testing backport\"), new HashMap<String, JSONValue>());\n-\n-        var jbsBackport = new JbsBackport(tracker);\n-        var backport = jbsBackport.createBackport(issue, \"1.0\", \"duke\", null);\n-        assertNotEquals(issue.id(), backport.id());\n-        var backportOfLink = backport.links().stream().filter(l -> l.relationship().equals(Optional.of(\"backport of\"))).findFirst();\n-        assertTrue(backportOfLink.isPresent());\n-        assertTrue(backportOfLink.get().issue().isPresent());\n-        assertEquals(issue.id(), backportOfLink.get().issue().get().id());\n-    }\n-}\n","filename":"bots\/notify\/src\/test\/java\/org\/openjdk\/skara\/bots\/notify\/issue\/JbsBackportIntegrationTests.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -107,2 +107,2 @@\n-        checkablePullRequest = new CheckablePullRequest(pr, localRepo, ignoreStaleReviews,\n-                workItem.bot.confOverrideRepository().orElse(null),\n+        var jcheckParser = new OverridingJCheckConfigurationParser(localRepo,\n+                workItem.bot.confOverrideRepository(),\n@@ -110,1 +110,3 @@\n-                workItem.bot.confOverrideRef(),\n+                workItem.bot.confOverrideRef());\n+        checkablePullRequest = new CheckablePullRequest(pr, localRepo, ignoreStaleReviews,\n+                jcheckParser,\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+import org.openjdk.skara.jbs.Backports;\n+import org.openjdk.skara.jbs.JdkVersion;\n+import org.openjdk.skara.json.JSON;\n@@ -657,0 +660,59 @@\n+\n+            \/\/ Check if the fixVersion of the issue is older than the fixVersion in the target branch. If so, update the\n+            \/\/ fixVersion of the issue to fixVersion of the target branch and create a backport with the fixVersion\n+            \/\/ from the original issue.\n+            \/\/\n+            \/\/ NOTE: The current implementation only works for the issue in the title, *NOT* for all issues solved by the PR\n+            if (bot.avoidForwardports()) {\n+                var m = ISSUE_ID_PATTERN.matcher(pr.title());\n+                Optional<IssueTrackerIssue> issue = m.matches() ? issueTrackerIssue(getMatchGroup(m, \"id\")) : Optional.empty();\n+                if (issue.isPresent()) {\n+                    \/\/ Check if a comment already has been added. If so the user must have reverted\n+                    \/\/ the actions done by the bot and the fixVersion should not be updated.\n+                    var avoidForwardportMarker = \"<!-- avoid forwardport \" + issue.get().id() + \" -->\";\n+                    var botUser = pr.repository().forge().currentUser();\n+                    var avoidForwardportComment = comments.stream()\n+                            .filter(c -> c.author().equals(botUser))\n+                            .filter(c -> c.body().contains(avoidForwardportMarker))\n+                            .findFirst();\n+                    if (avoidForwardportComment.isEmpty()) {\n+                        var parser = new OverridingJCheckConfigurationParser(pr.repository(),\n+                                                                            bot.confOverrideRepository(),\n+                                                                            bot.confOverrideName(),\n+                                                                            bot.confOverrideRef());\n+                        var jcheckConf = parser.parse(pr.targetHeadHash());\n+                        var targetFixVersion = jcheckConf.flatMap(c -> c.general().version())\n+                                                        .flatMap(v -> JdkVersion.parse(v));\n+                        if (targetFixVersion.isPresent()) {\n+                            var willCreateBackport = Backports.findIssue(issue.get(), targetFixVersion.get()).isEmpty();\n+                            if (willCreateBackport) {\n+                                var issueFixVersion = Backports.mainFixVersion(issue.get());\n+                                if (issueFixVersion.isPresent() &&\n+                                    targetFixVersion.get().compareTo(issueFixVersion.get()) > 0) {\n+                                    log.info(\"Avoiding forward-backport of issue '\" + issue.get().id() + \"' with fixVersion '\" + issueFixVersion.get().raw() +\n+                                             \"', repository fixVersion is '\" + targetFixVersion.get().raw() + \"'\");\n+                                    \/\/ This scenario would result in a \"forward-backport\" being created. Avoid it by\n+                                    \/\/ updating the fixVersion of the original issue and creating a backport with\n+                                    \/\/ the fixVersion from the original issue.\n+                                    issue.get().setProperty(\"fixVersions\",\n+                                                            JSON.array().add(targetFixVersion.get().raw()));\n+                                    var assignees = issue.get().assignees();\n+                                    var backport = assignees.isEmpty() ?\n+                                        Backports.createBackport(issue.get(), issueFixVersion.get().raw()) :\n+                                        Backports.createBackport(issue.get(), issueFixVersion.get().raw(), assignees.get(0).username());\n+                                    pr.addComment(avoidForwardportMarker + \"\\n\" + \"@\" + pr.author().username() + \" in order to avoid a \\\"forward backport\\\" the fix version for [\" +\n+                                                issue.get().title() + \"](\" + issue.get().webUrl() + \") has been set to `\" + targetFixVersion.get().raw() + \"`\" +\n+                                                \" and the backport issue [\" + backport.id() + \"](\" + backport.webUrl() + \") with fix version set to `\" +\n+                                                issueFixVersion.get().raw() + \"` has been created.\" +\n+                                                \"\\n\\n\" +\n+                                                \"If you wish to revert this action then set the fix version for [\" + issue.get().title() + \"](\" + issue.get().webUrl() + \")\" +\n+                                                \" to `\" + issueFixVersion.get().raw() + \"` and close the backport issue [\" + backport.id() + \"](\" + backport.webUrl() + \").\" +\n+                                                \" Be aware however that if you revert this action then a \\\"forward backport\\\" will be created if this pull request is integrated\" +\n+                                                \" (this is most likely _not_ what you want).\");\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckWorkItem.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private final List<String> confOverride;\n+    private final OverridingJCheckConfigurationParser jcheckConfParser;\n@@ -54,1 +54,2 @@\n-            HostedRepository jcheckRepo, String jcheckName, String jcheckRef, List<Comment> comments, MergePullRequestReviewConfiguration reviewMerge) {\n+                         OverridingJCheckConfigurationParser jcheckConfParser, List<Comment> comments,\n+                         MergePullRequestReviewConfiguration reviewMerge) {\n@@ -60,0 +61,1 @@\n+        this.jcheckConfParser = jcheckConfParser;\n@@ -61,7 +63,0 @@\n-        if (jcheckRepo != null) {\n-            confOverride = jcheckRepo.fileContents(jcheckName, jcheckRef).orElseThrow(\n-                    () -> new RuntimeException(\"Could not find \" + jcheckName + \" on ref \" + jcheckRef + \" in repo \" + jcheckRepo.name())\n-            ).lines().collect(Collectors.toList());\n-        } else {\n-            confOverride = null;\n-        }\n@@ -217,7 +212,4 @@\n-        var original = confOverride == null ?\n-            JCheck.parseConfiguration(localRepo, hash, List.of()) :\n-            JCheck.parseConfiguration(confOverride, List.of());\n-\n-        if (original.isEmpty()) {\n-            throw new IllegalStateException(\"Cannot parse JCheck configuration for commit with hash \" + hash.hex());\n-        }\n+        var errorMessage = \"Cannot parse JCheck configuration for commit with hash '\" + hash.hex() + \"'\";\n+        var original = jcheckConfParser.parse(hash).orElseThrow(() ->\n+                new IllegalStateException(errorMessage)\n+        );\n@@ -226,1 +218,1 @@\n-        var additional = AdditionalConfiguration.get(original.get(), botUser, comments, reviewMerge);\n+        var additional = AdditionalConfiguration.get(original, botUser, comments, reviewMerge);\n@@ -228,1 +220,1 @@\n-            return original.get();\n+            return original;\n@@ -230,5 +222,3 @@\n-        var result = confOverride == null ?\n-            JCheck.parseConfiguration(localRepo, hash, additional) :\n-            JCheck.parseConfiguration(confOverride, additional);\n-        return result.orElseThrow(\n-                    () -> new IllegalStateException(\"Cannot parse JCheck configuration with additional configuration for commit with hash \" + hash.hex()));\n+        return jcheckConfParser.parseWithAdditions(hash, additional).orElseThrow(() ->\n+                new IllegalStateException(errorMessage)\n+        );\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckablePullRequest.java","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -196,2 +196,2 @@\n-            var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews(),\n-                    bot.confOverrideRepository().orElse(null),\n+            var jcheckParser = new OverridingJCheckConfigurationParser(localRepo,\n+                    bot.confOverrideRepository(),\n@@ -199,1 +199,3 @@\n-                    bot.confOverrideRef(),\n+                    bot.confOverrideRef());\n+            var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews(),\n+                    jcheckParser,\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import org.openjdk.skara.forge.HostedRepository;\n+import org.openjdk.skara.jcheck.JCheck;\n+import org.openjdk.skara.jcheck.JCheckConfiguration;\n+import org.openjdk.skara.vcs.Repository;\n+import org.openjdk.skara.vcs.Hash;\n+\n+import java.util.*;\n+\n+class OverridingJCheckConfigurationParser {\n+    private final Repository localRepo;\n+    private final HostedRepository hostedRepo;\n+\n+    private final List<String> overridingConf;\n+\n+    OverridingJCheckConfigurationParser(Repository localRepo, Optional<HostedRepository> overridingRepository,\n+                                      String overridingConfName, String overridingRef) {\n+        this(localRepo, null, overridingRepository, overridingConfName, overridingRef);\n+    }\n+\n+    OverridingJCheckConfigurationParser(HostedRepository hostedRepo, Optional<HostedRepository> overridingRepository,\n+                                      String overridingConfName, String overridingRef) {\n+        this(null, hostedRepo, overridingRepository, overridingConfName, overridingRef);\n+    }\n+\n+    private OverridingJCheckConfigurationParser(Repository localRepo, HostedRepository hostedRepo,\n+                                              Optional<HostedRepository> overridingRepository,\n+                                              String overridingConfName, String overridingRef) {\n+        if (localRepo == null && hostedRepo == null) {\n+            throw new IllegalArgumentException(\"One of localRepo and hostedRepo must be non-null\");\n+        }\n+        if (localRepo != null && hostedRepo != null) {\n+            throw new IllegalArgumentException(\"Only one of localRepo and hostedRepo can be non-null\");\n+        }\n+\n+        this.localRepo = localRepo;\n+        this.hostedRepo = hostedRepo;\n+\n+        if (overridingRepository.isPresent()) {\n+            overridingConf =\n+                overridingRepository.get().fileContents(overridingConfName, overridingRef).orElseThrow(\n+                    () -> new RuntimeException(\"Could not find \" + overridingConfName + \" on ref \" +\n+                                               overridingRef + \" in repo \" +\n+                                               overridingRepository.get().name())\n+            ).lines().toList();\n+        } else {\n+            overridingConf = List.of();\n+        }\n+    }\n+\n+    private Optional<JCheckConfiguration> parseLocalOrHosted(Hash hash, List<String> additions) {\n+        if (localRepo != null) {\n+            return JCheck.parseConfiguration(localRepo, hash, additions);\n+        }\n+\n+        var hostedConf = hostedRepo.fileContents(\".jcheck\/conf\", hash.hex());\n+        if (hostedConf.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        return JCheck.parseConfiguration(hostedConf.get().lines().toList(), additions);\n+    }\n+\n+    Optional<JCheckConfiguration> parse(Hash hash) {\n+        return parseWithAdditions(hash, List.of());\n+\n+    }\n+\n+    Optional<JCheckConfiguration> parseWithAdditions(Hash hash, List<String> additions) {\n+        return overridingConf.isEmpty() ?\n+            parseLocalOrHosted(hash, additions) : JCheck.parseConfiguration(overridingConf, additions);\n+\n+    }\n+}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/OverridingJCheckConfigurationParser.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -84,0 +84,1 @@\n+    private final boolean avoidForwardports;\n@@ -98,1 +99,1 @@\n-                   Map<String, List<PRRecord>> issuePRMap, Approval approval, boolean versionMismatchWarning, boolean cleanCommandEnabled) {\n+                   Map<String, List<PRRecord>> issuePRMap, Approval approval, boolean versionMismatchWarning, boolean cleanCommandEnabled, boolean avoidForwardports) {\n@@ -136,0 +137,1 @@\n+        this.avoidForwardports = avoidForwardports;\n@@ -412,0 +414,4 @@\n+    public boolean avoidForwardports() {\n+        return avoidForwardports;\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBot.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+    private boolean avoidForwardports = false;\n@@ -260,0 +261,5 @@\n+    public PullRequestBotBuilder avoidForwardports(boolean avoidForwardports) {\n+        this.avoidForwardports = avoidForwardports;\n+        return this;\n+    }\n+\n@@ -266,1 +272,1 @@\n-                mergeSources, jcheckMerge, enableBackport, issuePRMap, approval, versionMismatchWarning, cleanCommandEnabled);\n+                mergeSources, jcheckMerge, enableBackport, issuePRMap, approval, versionMismatchWarning, cleanCommandEnabled, avoidForwardports);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotBuilder.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -270,0 +270,4 @@\n+            if (repo.value().contains(\"avoidForwardports\")) {\n+                botBuilder.avoidForwardports(repo.value().get(\"avoidForwardports\").asBoolean());\n+            }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotFactory.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-            var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews(),\n-                    bot.confOverrideRepository().orElse(null),\n+            var jcheckParser = new OverridingJCheckConfigurationParser(localRepo,\n+                    bot.confOverrideRepository(),\n@@ -102,1 +102,3 @@\n-                    bot.confOverrideRef(),\n+                    bot.confOverrideRef());\n+            var checkablePr = new CheckablePullRequest(pr, localRepo, bot.ignoreStaleReviews(),\n+                    jcheckParser,\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.skara.issuetracker.Issue;\n@@ -28,0 +29,1 @@\n+import org.openjdk.skara.json.JSON;\n@@ -2100,0 +2102,350 @@\n+\n+    @Test\n+    void avoidForwardports(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                    .repo(author)\n+                    .censusRepo(censusBuilder.build())\n+                    .issueProject(issues)\n+                    .issuePRMap(new HashMap<>())\n+                    .avoidForwardports(true)\n+                    .build();\n+\n+            \/\/ Add .jcheck\/conf with fixVersion=22\n+            var localRepoDir = tempFolder.path();\n+            var localRepo = Repository.init(localRepoDir, author.repositoryType());\n+            var jcheckConf = localRepoDir.resolve(\".jcheck\").resolve(\"conf\");\n+            Files.createDirectories(jcheckConf.getParent());\n+            Files.write(jcheckConf, List.of(\n+                \"[general]\",\n+                \"project=test\",\n+                \"jbs=tstprj\",\n+                \"version=22\",\n+                \"\",\n+                \"[checks]\",\n+                \"error=author,reviewrs,whitespace\",\n+                \"[census]\",\n+                \"version=0\",\n+                \"domain=openjdk.org\",\n+                \"\",\n+                \"[checks \\\"whitespace\\\"]\",\n+                \"files=.*\\\\.txt\",\n+                \"\",\n+                \"[checks \\\"reviewers\\\"]\",\n+                \"reviewers=1\"\n+            ));\n+            localRepo.add(jcheckConf);\n+            localRepo.commit(\"Added .jcheck\/conf\", \"duke\", \"duke@openjdk.org\");\n+\n+            \/\/ Populate \"remote\" repo\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Create issue with fixVersion=21 and \"fix\" it\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var issueTitle = \"An issue\";\n+            var issue = credentials.createIssue(issues, issueTitle);\n+            issue.setProperty(\"fixVersions\", JSON.array().add(\"21\"));\n+            var issueNumber = issue.id().split(\"-\")[1];\n+            var editHash = localRepo.commit(issueNumber + \": \" + issueTitle, \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(editHash, author.authenticatedUrl(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issueNumber + \": \" + issueTitle);\n+\n+            \/\/ The bot should reply with a message that the fixVersion has been updated and backport issue created\n+            TestBotRunner.runPeriodicItems(bot);\n+            var comment = pr.comments().get(1).body();\n+            assertTrue(comment.contains(\"<!-- avoid forwardport \" + issue.id() + \" -->\"));\n+            assertTrue(comment.contains(\"in order to avoid a \\\"forward backport\\\"\"));\n+            assertEquals(JSON.array().add(\"22\"), issue.properties().get(\"fixVersions\"));\n+\n+            var backportLink = issue.links().stream().filter(l -> l.relationship().equals(Optional.of(\"backported by\"))).findFirst();\n+            assertTrue(backportLink.isPresent());\n+            var backport = backportLink.get().issue();\n+            assertTrue(backport.isPresent());\n+            assertEquals(JSON.of(\"Backport\"), backport.get().properties().get(\"issuetype\"));\n+            assertEquals(JSON.array().add(\"21\"), backport.get().properties().get(\"fixVersions\"));\n+        }\n+    }\n+\n+    @Test\n+    void avoidForwardportsShouldNotRepeat(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                    .repo(author)\n+                    .censusRepo(censusBuilder.build())\n+                    .issueProject(issues)\n+                    .issuePRMap(new HashMap<>())\n+                    .avoidForwardports(true)\n+                    .build();\n+\n+            \/\/ Add .jcheck\/conf with fixVersion=22\n+            var localRepoDir = tempFolder.path();\n+            var localRepo = Repository.init(localRepoDir, author.repositoryType());\n+            var jcheckConf = localRepoDir.resolve(\".jcheck\").resolve(\"conf\");\n+            Files.createDirectories(jcheckConf.getParent());\n+            Files.write(jcheckConf, List.of(\n+                \"[general]\",\n+                \"project=test\",\n+                \"jbs=tstprj\",\n+                \"version=22\",\n+                \"\",\n+                \"[checks]\",\n+                \"error=author,reviewrs,whitespace\",\n+                \"[census]\",\n+                \"version=0\",\n+                \"domain=openjdk.org\",\n+                \"\",\n+                \"[checks \\\"whitespace\\\"]\",\n+                \"files=.*\\\\.txt\",\n+                \"\",\n+                \"[checks \\\"reviewers\\\"]\",\n+                \"reviewers=1\"\n+            ));\n+            localRepo.add(jcheckConf);\n+            localRepo.commit(\"Added .jcheck\/conf\", \"duke\", \"duke@openjdk.org\");\n+\n+            \/\/ Populate \"remote\" repo\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Create issue with fixVersion=21 and \"fix\" it\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var issueTitle = \"An issue\";\n+            var issue = credentials.createIssue(issues, issueTitle);\n+            issue.setProperty(\"fixVersions\", JSON.array().add(\"21\"));\n+            var issueNumber = issue.id().split(\"-\")[1];\n+            var editHash = localRepo.commit(issueNumber + \": \" + issueTitle, \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(editHash, author.authenticatedUrl(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issueNumber + \": \" + issueTitle);\n+\n+            \/\/ The bot should reply with a message that the fixVersion has been updated and backport issue created\n+            TestBotRunner.runPeriodicItems(bot);\n+            var comment = pr.comments().get(1).body();\n+            assertTrue(comment.contains(\"<!-- avoid forwardport \" + issue.id() + \" -->\"));\n+            assertTrue(comment.contains(\"in order to avoid a \\\"forward backport\\\"\"));\n+            assertEquals(JSON.array().add(\"22\"), issue.properties().get(\"fixVersions\"));\n+\n+            var backportLink = issue.links().stream().filter(l -> l.relationship().equals(Optional.of(\"backported by\"))).findFirst();\n+            assertTrue(backportLink.isPresent());\n+            var backport = backportLink.get().issue();\n+            assertTrue(backport.isPresent());\n+            assertEquals(JSON.of(\"Backport\"), backport.get().properties().get(\"issuetype\"));\n+            assertEquals(JSON.array().add(\"21\"), backport.get().properties().get(\"fixVersions\"));\n+\n+            \/\/ Revert the actions done by the bot\n+            issue.setProperty(\"fixVersions\", JSON.array().add(\"21\"));\n+            issue.removeLink(backportLink.get());\n+            backport.get().setState(Issue.State.CLOSED);\n+\n+            \/\/ Run the bot again, it should now not update the fixVersion nor create a backport\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertEquals(JSON.array().add(\"21\"), issue.properties().get(\"fixVersions\"));\n+            assertEquals(List.of(), issue.links());\n+        }\n+    }\n+\n+    @Test\n+    void avoidForwardportsIfIssueChanges(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                    .repo(author)\n+                    .censusRepo(censusBuilder.build())\n+                    .issueProject(issues)\n+                    .issuePRMap(new HashMap<>())\n+                    .avoidForwardports(true)\n+                    .build();\n+\n+            \/\/ Add .jcheck\/conf with fixVersion=22\n+            var localRepoDir = tempFolder.path();\n+            var localRepo = Repository.init(localRepoDir, author.repositoryType());\n+            var jcheckConf = localRepoDir.resolve(\".jcheck\").resolve(\"conf\");\n+            Files.createDirectories(jcheckConf.getParent());\n+            Files.write(jcheckConf, List.of(\n+                \"[general]\",\n+                \"project=test\",\n+                \"jbs=tstprj\",\n+                \"version=22\",\n+                \"\",\n+                \"[checks]\",\n+                \"error=author,reviewrs,whitespace\",\n+                \"[census]\",\n+                \"version=0\",\n+                \"domain=openjdk.org\",\n+                \"\",\n+                \"[checks \\\"whitespace\\\"]\",\n+                \"files=.*\\\\.txt\",\n+                \"\",\n+                \"[checks \\\"reviewers\\\"]\",\n+                \"reviewers=1\"\n+            ));\n+            localRepo.add(jcheckConf);\n+            localRepo.commit(\"Added .jcheck\/conf\", \"duke\", \"duke@openjdk.org\");\n+\n+            \/\/ Populate \"remote\" repo\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Create issue with fixVersion=21 and \"fix\" it\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var issueTitle = \"An issue\";\n+            var issue = credentials.createIssue(issues, issueTitle);\n+            issue.setProperty(\"fixVersions\", JSON.array().add(\"21\"));\n+            var issueNumber = issue.id().split(\"-\")[1];\n+            var editHash = localRepo.commit(issueNumber + \": \" + issueTitle, \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(editHash, author.authenticatedUrl(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issueNumber + \": \" + issueTitle);\n+\n+            \/\/ The bot should reply with a message that the fixVersion has been updated and backport issue created\n+            TestBotRunner.runPeriodicItems(bot);\n+            var comment = pr.comments().get(1).body();\n+            assertTrue(comment.contains(\"<!-- avoid forwardport \" + issue.id() + \" -->\"));\n+            assertTrue(comment.contains(\"in order to avoid a \\\"forward backport\\\"\"));\n+            assertEquals(JSON.array().add(\"22\"), issue.properties().get(\"fixVersions\"));\n+\n+            var backportLink = issue.links().stream().filter(l -> l.relationship().equals(Optional.of(\"backported by\"))).findFirst();\n+            assertTrue(backportLink.isPresent());\n+            var backport = backportLink.get().issue();\n+            assertTrue(backport.isPresent());\n+            assertEquals(JSON.of(\"Backport\"), backport.get().properties().get(\"issuetype\"));\n+            assertEquals(JSON.array().add(\"21\"), backport.get().properties().get(\"fixVersions\"));\n+\n+            \/\/ Revert the actions done by the bot\n+            issue.setProperty(\"fixVersions\", JSON.array().add(\"21\"));\n+            issue.removeLink(backportLink.get());\n+            backport.get().setState(Issue.State.CLOSED);\n+\n+            \/\/ Run the bot again, it should now not update the fixVersion nor create a backport\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertEquals(JSON.array().add(\"21\"), issue.properties().get(\"fixVersions\"));\n+            assertEquals(List.of(), issue.links());\n+\n+            \/\/ Change the issue that the PR solves\n+            var issue2 = credentials.createIssue(issues, \"Another issue\");\n+            issue2.setProperty(\"fixVersions\", JSON.array().add(\"21\"));\n+            var issue2Number = issue2.id().split(\"-\")[1];\n+            pr.setTitle(issue2Number + \": Another issue\");\n+\n+            \/\/ Run the bot again, it should now avoid a forwardport as the issue has changed\n+            TestBotRunner.runPeriodicItems(bot);\n+            var comment2 = pr.comments().get(pr.comments().size() - 1).body();\n+            assertTrue(comment2.contains(\"<!-- avoid forwardport \" + issue2.id() + \" -->\"));\n+            assertTrue(comment2.contains(\"in order to avoid a \\\"forward backport\\\"\"));\n+            assertEquals(JSON.array().add(\"22\"), issue2.properties().get(\"fixVersions\"));\n+        }\n+    }\n+\n+    @Test\n+    void avoidForwardportShouldNotRunForEqualFixVersions(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var issues = credentials.getIssueProject();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                    .repo(author)\n+                    .censusRepo(censusBuilder.build())\n+                    .issueProject(issues)\n+                    .issuePRMap(new HashMap<>())\n+                    .avoidForwardports(true)\n+                    .build();\n+\n+            \/\/ Add .jcheck\/conf with fixVersion=22\n+            var localRepoDir = tempFolder.path();\n+            var localRepo = Repository.init(localRepoDir, author.repositoryType());\n+            var jcheckConf = localRepoDir.resolve(\".jcheck\").resolve(\"conf\");\n+            Files.createDirectories(jcheckConf.getParent());\n+            Files.write(jcheckConf, List.of(\n+                \"[general]\",\n+                \"project=test\",\n+                \"jbs=tstprj\",\n+                \"version=22\",\n+                \"\",\n+                \"[checks]\",\n+                \"error=author,reviewrs,whitespace\",\n+                \"[census]\",\n+                \"version=0\",\n+                \"domain=openjdk.org\",\n+                \"\",\n+                \"[checks \\\"whitespace\\\"]\",\n+                \"files=.*\\\\.txt\",\n+                \"\",\n+                \"[checks \\\"reviewers\\\"]\",\n+                \"reviewers=1\"\n+            ));\n+            localRepo.add(jcheckConf);\n+            localRepo.commit(\"Added .jcheck\/conf\", \"duke\", \"duke@openjdk.org\");\n+\n+            \/\/ Populate \"remote\" repo\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Create issue with fixVersion=21 and \"fix\" it\n+            localRepo.checkout(localRepo.defaultBranch());\n+            var editBranch = localRepo.branch(masterHash, \"edit\");\n+            localRepo.checkout(editBranch);\n+            var newFile2 = localRepo.root().resolve(\"a_new_file.txt\");\n+            Files.writeString(newFile2, \"hello\");\n+            localRepo.add(newFile2);\n+            var issueTitle = \"An issue\";\n+            var issue = credentials.createIssue(issues, issueTitle);\n+            issue.setProperty(\"fixVersions\", JSON.array().add(\"22\"));\n+            var issueNumber = issue.id().split(\"-\")[1];\n+            var editHash = localRepo.commit(issueNumber + \": \" + issueTitle, \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(editHash, author.authenticatedUrl(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", issueNumber + \": \" + issueTitle);\n+\n+            \/\/ The bot should *not* reply with a message that the fixVersion has been updated and backport issue created\n+            TestBotRunner.runPeriodicItems(bot);\n+            assertEquals(1, pr.comments().size());\n+            var comment = pr.comments().get(0).body();\n+            assertFalse(comment.contains(\"<!-- avoid forwardport \" + issue.id() + \" -->\"));\n+            assertFalse(comment.contains(\"in order to avoid a \\\"forward backport\\\"\"));\n+            assertEquals(JSON.array().add(\"22\"), issue.properties().get(\"fixVersions\"));\n+\n+            var backportLink = issue.links().stream().filter(l -> l.relationship().equals(Optional.of(\"backported by\"))).findFirst();\n+            assertFalse(backportLink.isPresent());\n+        }\n+    }\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/BackportTests.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"modified"},{"patch":"@@ -124,0 +124,12 @@\n+    \/**\n+     * Returns the hash of the current HEAD of the target ref the request is intended to be merged into.\n+     *\n+     * Note that the target HEAD hash is constantly changing as new commits are integrated into the target ref.\n+     * @return\n+     *\/\n+    default Hash targetHeadHash() {\n+        return repository().branchHash(targetRef()).orElseThrow(() ->\n+            new IllegalStateException(\"Missing HEAD hash for branch '\" + targetRef() + \"'\")\n+        );\n+    }\n+\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+        requires 'org.openjdk.skara.network'\n+        requires 'org.openjdk.skara.proxy'\n@@ -38,0 +40,2 @@\n+    testImplementation project(':network')\n+    testImplementation project(':proxy')\n","filename":"jbs\/build.gradle","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.skara.json.JSON;\n@@ -543,0 +544,43 @@\n+\n+    public static IssueTrackerIssue createBackport(IssueTrackerIssue primary, String fixVersion) {\n+        return createBackport(primary, fixVersion, null);\n+    }\n+\n+    public static IssueTrackerIssue createBackport(IssueTrackerIssue primary, String fixVersion, String assignee) {\n+        return createBackport(primary, fixVersion, assignee, null);\n+    }\n+\n+    public static IssueTrackerIssue createBackport(IssueTrackerIssue primary, String fixVersion, String assignee, String defaultSecurity) {\n+        var backportEndpoint = primary.project()\n+                                      .issueTracker()\n+                                      .lookupCustomEndpoint(\"\/rest\/jbs\/1.0\/backport\/\")\n+                                      .orElseThrow(() ->\n+            new IllegalArgumentException(\"Issue tracker does not support backport endpoint\")\n+        );\n+        var body = JSON.object()\n+                       .put(\"parentIssueKey\", primary.id())\n+                       .put(\"fixVersion\", fixVersion);\n+\n+        if (assignee != null) {\n+            body = body.put(\"assignee\", assignee);\n+        }\n+\n+        if (primary.properties().containsKey(\"security\")) {\n+            body = body.put(\"level\", primary.properties().get(\"security\").asString());\n+        } else if (defaultSecurity != null) {\n+            body = body.put(\"level\", defaultSecurity);\n+        }\n+\n+        var response = backportEndpoint.post()\n+                                       .body(body)\n+                                       .execute();\n+        var issue = primary.project().issue(response.get(\"key\").asString()).orElseThrow();\n+\n+        \/\/ The backport should not have any labels set - if it does, clear them\n+        var labels = issue.labelNames();\n+        if (!labels.isEmpty()) {\n+            issue.setLabels(List.of());\n+        }\n+\n+        return issue;\n+    }\n","filename":"jbs\/src\/main\/java\/org\/openjdk\/skara\/jbs\/Backports.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.jbs;\n+\n+import org.openjdk.skara.host.Credential;\n+import org.openjdk.skara.issuetracker.IssueTracker;\n+import org.openjdk.skara.issuetracker.IssueTrackerFactory;\n+import org.openjdk.skara.json.JSON;\n+import org.openjdk.skara.json.JSONObject;\n+import org.openjdk.skara.json.JSONValue;\n+import org.openjdk.skara.network.URIBuilder;\n+import org.openjdk.skara.proxy.HttpProxy;\n+import org.openjdk.skara.test.TestProperties;\n+import org.openjdk.skara.test.EnabledIfTestProperties;\n+\n+import java.util.*;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\n+class BackportsIntegrationTests {\n+    private static TestProperties props;\n+    private static IssueTracker tracker;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        props = TestProperties.load();\n+        if (props.contains(\"jbs.uri\", \"jbs.pat\")) {\n+            var factory = IssueTrackerFactory.getIssueTrackerFactories().stream().filter(f -> f.name().equals(\"jira\")).findFirst();\n+            if (factory.isEmpty()) {\n+                throw new IllegalStateException(\"'jbs.uri' and 'jbs.pat' has been configured but could not find IssueTrackerFactory for 'jira'\");\n+            }\n+            HttpProxy.setup();\n+            var uri = URIBuilder.base(props.get(\"jbs.uri\")).build();\n+            var credential = new Credential(\"\", \"Bearer \" + props.get(\"jbs.pat\"));\n+            tracker = factory.get().create(uri, credential, new JSONObject());\n+        }\n+    }\n+\n+    @Test\n+    @EnabledIfTestProperties({\"jbs.uri\", \"jbs.pat\"})\n+    void testBackportCreation() {\n+        var project = tracker.project(\"SKARA\");\n+        var issue = project.createIssue(\"Issue to backport\", List.of(\"This is just a test issue for testing backport\"), new HashMap<String, JSONValue>());\n+\n+        var backport = Backports.createBackport(issue, \"1.0\", \"duke\", null);\n+        assertEquals(JSON.of(\"Backport\"), backport.properties().get(\"issuetype\"));\n+        assertEquals(JSON.array().add(\"1.0\"), backport.properties().get(\"fixVersions\"));\n+        assertNotEquals(issue.id(), backport.id());\n+\n+        var backportOfLink = backport.links().stream().filter(l -> l.relationship().equals(Optional.of(\"backport of\"))).findFirst();\n+        assertTrue(backportOfLink.isPresent());\n+        assertTrue(backportOfLink.get().issue().isPresent());\n+        assertEquals(issue.id(), backportOfLink.get().issue().get().id());\n+\n+        issue = project.issue(issue.id()).orElseThrow();\n+        var backportedByLink = issue.links().stream().filter(l -> l.relationship().equals(Optional.of(\"backported by\"))).findFirst();\n+        assertTrue(backportedByLink.isPresent());\n+        assertTrue(backportedByLink.get().issue().isPresent());\n+        assertEquals(backport.id(), backportedByLink.get().issue().get().id());\n+    }\n+}\n","filename":"jbs\/src\/test\/java\/org\/openjdk\/skara\/jbs\/BackportsIntegrationTests.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -104,1 +104,1 @@\n-                props.put(\"fixVersion\", body.get(\"fixVersion\"));\n+                props.put(\"fixVersions\", JSON.array().add(body.get(\"fixVersion\")));\n@@ -110,1 +110,1 @@\n-            var ignore = Set.of(\"assignee\", \"security\", \"fixVersion\", RESOLVED_IN_BUILD);\n+            var ignore = Set.of(\"issuetype\", \"assignee\", \"security\", \"fixVersions\", RESOLVED_IN_BUILD);\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestHost.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}