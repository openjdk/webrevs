{"files":[{"patch":"@@ -49,0 +49,1 @@\n+    branch,\n","filename":"bots\/common\/src\/main\/java\/org\/openjdk\/skara\/bots\/common\/CommandNameEnum.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import org.openjdk.skara.forge.HostedBranch;\n+import org.openjdk.skara.forge.HostedCommit;\n+import org.openjdk.skara.issuetracker.Comment;\n+import org.openjdk.skara.vcs.*;\n+import org.openjdk.skara.jcheck.JCheckConfiguration;\n+\n+import java.io.PrintWriter;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static org.openjdk.skara.bots.common.CommandNameEnum.branch;\n+\n+public class BranchCommand implements CommandHandler {\n+    private static final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.pr\");\n+\n+    private void showHelp(PrintWriter reply) {\n+        reply.println(\"Usage: `\/branch <name>`\");\n+    }\n+\n+    @Override\n+    public String description() {\n+        return \"create a branch\";\n+    }\n+\n+    @Override\n+    public String name() {\n+        return branch.name();\n+    }\n+\n+    @Override\n+    public boolean allowedInCommit() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean allowedInPullRequest() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void handle(PullRequestBot bot, HostedCommit commit, LimitedCensusInstance censusInstance,\n+            ScratchArea scratchArea, CommandInvocation command, List<Comment> allComments, PrintWriter reply) {\n+        try {\n+            if (!bot.integrators().contains(command.user().username())) {\n+                reply.println(\"Only integrators for this repository are allowed to use the `\/branch` command.\");\n+                return;\n+            }\n+            if (censusInstance.contributor(command.user()).isEmpty()) {\n+                reply.println(\"To use the `\/branch` command, you need to be in the OpenJDK [census](https:\/\/openjdk.org\/census)\"\n+                        + \" and your GitHub account needs to be linked with your OpenJDK username\"\n+                        + \" ([how to associate your GitHub account with your OpenJDK username]\"\n+                        + \"(https:\/\/wiki.openjdk.org\/display\/skara#Skara-AssociatingyourGitHubaccountandyourOpenJDKusername)).\");\n+                return;\n+            }\n+\n+            var args = command.args();\n+            if (args.isBlank()) {\n+                showHelp(reply);\n+                return;\n+            }\n+\n+            var parts = args.split(\" \");\n+            if (parts.length > 1) {\n+                showHelp(reply);\n+                return;\n+            }\n+            var branchName = parts[0];\n+\n+            var localRepoDir = scratchArea.get(this)\n+                    .resolve(bot.repo().name());\n+            var localRepo = bot.hostedRepositoryPool()\n+                               .orElseThrow(() -> new IllegalStateException(\"Missing repository pool for PR bot\"))\n+                               .materialize(bot.repo(), localRepoDir);\n+            localRepo.fetch(bot.repo().authenticatedUrl(), commit.hash().toString(), true);\n+\n+            var remoteBranches = bot.repo().branches();\n+            var remoteBranchNames = remoteBranches.stream()\n+                                                  .map(HostedBranch::name)\n+                                                  .collect(Collectors.toSet());\n+            if (remoteBranchNames.contains(branchName)) {\n+                var msg = \"A branch with name `\" + branchName + \"` already exists\";\n+                var remoteBranch = remoteBranches.stream().filter(r -> r.name().equals(branchName)).findFirst();\n+                if (remoteBranch.isPresent()) {\n+                    var hash = remoteBranch.get().hash();\n+                    var hashUrl = bot.repo().webUrl(hash);\n+                    msg += \" that refers to commit [\" + hash.abbreviate() + \"](\" + hashUrl + \").\";\n+                } else {\n+                    msg += \" (could not find the commit it refers to).\";\n+                }\n+                reply.println(msg);\n+                return;\n+            }\n+\n+            var jcheckConf = JCheckConfiguration.from(localRepo, commit.hash());\n+            var branchPattern = jcheckConf.isPresent() ? jcheckConf.get().repository().branches() : null;\n+            if (branchPattern != null && !branchName.matches(branchPattern)) {\n+                reply.println(\"The given branch name `\" + branchName + \"` is not of the form `\" + branchPattern + \"`.\");\n+                return;\n+            }\n+\n+            var branch = localRepo.branch(commit.hash(), branchName);\n+            log.info(\"Pushing branch '\" + branch + \"' to refer to commit: \" + commit.hash().hex());\n+            localRepo.push(commit.hash(), bot.repo().authenticatedUrl(), branch.name(), false, false);\n+            reply.println(\"The branch [\" + branch.name() + \"](\" + bot.repo().webUrl(branch) + \") was successfully created.\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/BranchCommand.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -67,0 +67,1 @@\n+            Map.entry(branch.name(), new BranchCommand()),\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CommandExtractor.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,310 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInfo;\n+import org.openjdk.skara.test.*;\n+import org.openjdk.skara.vcs.Branch;\n+import org.openjdk.skara.vcs.Repository;\n+import org.openjdk.skara.vcs.Reference;\n+import org.openjdk.skara.vcs.VCS;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.nio.file.StandardOpenOption;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class BranchCommitCommandTests {\n+    @Test\n+    void simple(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .integrators(Set.of(author.forge().currentUser().username()))\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Add a branch command\n+            author.addCommitComment(masterHash, \"\/branch next\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\"branch\"));\n+            assertTrue(botReply.body().contains(\"was successfully created\"));\n+\n+            var localAuthorRepoDir = tempFolder.path().resolve(\"author\");\n+            System.err.println(\"author.authenticatedUrl(): \" + author.authenticatedUrl());\n+            var localAuthorRepo = Repository.clone(author.authenticatedUrl(), localAuthorRepoDir);\n+            var next = new Branch(\"next\");\n+            localAuthorRepo.checkout(next);\n+            assertTrue(localAuthorRepo.branches().contains(next));\n+            var nextHead = localAuthorRepo.lookup(next);\n+            assertTrue(nextHead.isPresent());\n+            assertEquals(masterHash, nextHead.get().hash());\n+        }\n+    }\n+\n+    @Test\n+    void missingBranchName(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .integrators(Set.of(author.forge().currentUser().username()))\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Add an empty branch command\n+            author.addCommitComment(masterHash, \"\/branch\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\"Usage: `\/branch <name>`\"));\n+\n+            var localAuthorRepoDir = tempFolder.path().resolve(\"author\");\n+            var localAuthorRepo = Repository.clone(author.authenticatedUrl(), localAuthorRepoDir);\n+        }\n+    }\n+\n+    @Test\n+    void multipleBranchNames(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .integrators(Set.of(author.forge().currentUser().username()))\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Add a branch command\n+            author.addCommitComment(masterHash, \"\/branch a b c\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\"Usage: `\/branch <name>`\"));\n+\n+            var localAuthorRepoDir = tempFolder.path().resolve(\"author\");\n+            var localAuthorRepo = Repository.clone(author.authenticatedUrl(), localAuthorRepoDir);\n+            var remoteBranches = localAuthorRepo.remoteBranches(\"origin\")\n+                                                .stream()\n+                                                .map(Reference::name)\n+                                                .collect(Collectors.toSet());\n+            assertFalse(remoteBranches.contains(\"a\"));\n+            assertFalse(remoteBranches.contains(\"b\"));\n+            assertFalse(remoteBranches.contains(\"c\"));\n+        }\n+    }\n+\n+    @Test\n+    void existingBranch(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .integrators(Set.of(author.forge().currentUser().username()))\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Add a branch command\n+            author.addCommitComment(masterHash, \"\/branch next\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\"branch\"));\n+            assertTrue(botReply.body().contains(\"was successfully created\"));\n+\n+            var localAuthorRepoDir = tempFolder.path().resolve(\"author\");\n+            var localAuthorRepo = Repository.clone(author.authenticatedUrl(), localAuthorRepoDir);\n+            var next = new Branch(\"next\");\n+            localAuthorRepo.checkout(next);\n+            assertTrue(localAuthorRepo.branches().contains(next));\n+            var nextHead = localAuthorRepo.lookup(next);\n+            assertTrue(nextHead.isPresent());\n+            assertEquals(masterHash, nextHead.get().hash());\n+\n+            \/\/ Make another commit\n+            var anotherHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(anotherHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Try to re-create an existing branch\n+            author.addCommitComment(anotherHash, \"\/branch next\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            recentCommitComments = author.recentCommitComments();\n+            assertEquals(4, recentCommitComments.size());\n+            botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\"A branch with name `next` already exists\"));\n+            Pattern compilePattern = Pattern.compile(\".*\\\\[.*\\\\]\\\\(.*\\\\).*\", Pattern.MULTILINE | Pattern.DOTALL);\n+            assertTrue(compilePattern.matcher(botReply.body()).matches());\n+        }\n+    }\n+\n+    @Test\n+    void nonIntegrator(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Add a branch command\n+            author.addCommitComment(masterHash, \"\/branch next\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            assertTrue(botReply.body().contains(\"Only integrators for this repository are allowed to use the `\/branch` command\"));\n+\n+            var localAuthorRepoDir = tempFolder.path().resolve(\"author\");\n+            var localAuthorRepo = Repository.clone(author.authenticatedUrl(), localAuthorRepoDir);\n+            var remoteBranches = localAuthorRepo.remoteBranches(\"origin\")\n+                                                .stream()\n+                                                .map(Reference::name)\n+                                                .collect(Collectors.toSet());\n+            assertFalse(remoteBranches.contains(\"next\"));\n+        }\n+    }\n+\n+    @Test\n+    void nonConformingBranch(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addAuthor(author.forge().currentUser().id());\n+            var seedFolder = tempFolder.path().resolve(\"seed\");\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(author)\n+                                    .integrators(Set.of(author.forge().currentUser().username()))\n+                                    .censusRepo(censusBuilder.build())\n+                                    .censusLink(\"https:\/\/census.com\/{{contributor}}-profile\")\n+                                    .seedStorage(seedFolder)\n+                                    .forks(Map.of(author.name(), author))\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tempFolder.path(), author.repositoryType());\n+            var jcheckConf = localRepo.root().resolve(\".jcheck\").resolve(\"conf\");\n+            Files.write(jcheckConf, List.of(\"[repository]\", \"branches=foo\"), StandardOpenOption.APPEND);\n+            localRepo.add(List.of(Path.of(\".jcheck\", \"conf\")));\n+            localRepo.commit(\"Added branches spec\", \"testauthor\", \"ta@none.none\");\n+            var masterHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Add a branch command\n+            author.addCommitComment(masterHash, \"\/branch bar\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            var recentCommitComments = author.recentCommitComments();\n+            assertEquals(2, recentCommitComments.size());\n+            var botReply = recentCommitComments.get(0);\n+            System.out.println(botReply);\n+            assertTrue(botReply.body().contains(\"The given branch name `bar` is not of the form `foo`\"));\n+\n+            var localAuthorRepoDir = tempFolder.path().resolve(\"author\");\n+            var localAuthorRepo = Repository.clone(author.authenticatedUrl(), localAuthorRepoDir);\n+            var remoteBranches = localAuthorRepo.remoteBranches(\"origin\")\n+                                                .stream()\n+                                                .map(Reference::name)\n+                                                .collect(Collectors.toSet());\n+            assertFalse(remoteBranches.contains(\"next\"));\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/BranchCommitCommandTests.java","additions":310,"deletions":0,"binary":false,"changes":310,"status":"added"}]}