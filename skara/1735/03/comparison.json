{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import org.openjdk.skara.vcs.Hash;\n@@ -34,0 +35,3 @@\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -37,1 +41,4 @@\n-    private static final String INITIAL_LABEL_MESSAGE = \"<!-- PullRequestBot initial label help comment -->\";\n+    protected static final String INITIAL_LABEL_MESSAGE = \"<!-- PullRequestBot initial label help comment -->\";\n+    private static final String LABEL_COMMIT_MARKER = \"<!-- PullRequest Bot label commit '%s' -->\";\n+    protected static final Pattern LABEL_COMMIT_PATTERN = Pattern.compile(\"<!-- PullRequest Bot label commit '(.*?)' -->\");\n+    private static final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.pr\");\n@@ -54,1 +61,1 @@\n-    private Optional<Comment> findComment(List<Comment> comments, String marker) {\n+    static Optional<Comment> findComment(List<Comment> comments, String marker, PullRequest pr) {\n@@ -57,3 +64,3 @@\n-                       .filter(comment -> comment.author().equals(self))\n-                       .filter(comment -> comment.body().contains(marker))\n-                       .findAny();\n+                .filter(comment -> comment.author().equals(self))\n+                .filter(comment -> comment.body().contains(marker))\n+                .findAny();\n@@ -62,2 +69,2 @@\n-    private void updateLabelMessage(List<Comment> comments, List<String> newLabels) {\n-        var existing = findComment(comments, INITIAL_LABEL_MESSAGE);\n+    private void updateLabelMessage(List<Comment> comments, List<String> newLabels, String commitHash, boolean autoLabeled) {\n+        var existing = findComment(comments, INITIAL_LABEL_MESSAGE, pr);\n@@ -74,32 +81,37 @@\n-        if (newLabels.isEmpty()) {\n-            message.append(\"To determine the appropriate audience for reviewing this pull request, one or more \");\n-            message.append(\"labels corresponding to different subsystems will normally be applied automatically. \");\n-            message.append(\"However, no automatic labelling rule matches the changes in this pull request. \");\n-            message.append(\"In order to have an \\\"RFR\\\" email sent to the correct mailing list, you will \");\n-            message.append(\"need to add one or more applicable labels manually using the \");\n-            message.append(\"[\/label](https:\/\/wiki.openjdk.org\/display\/SKARA\/Pull+Request+Commands#PullRequestCommands-\/label)\");\n-            message.append(\" pull request command.\\n\\n\");\n-            message.append(\"<details>\\n\");\n-            message.append(\"<summary>Applicable Labels<\/summary>\\n\");\n-            message.append(\"<br>\\n\");\n-            message.append(\"\\n\");\n-            bot.labelConfiguration().allowed()\n-                                    .stream()\n-                                    .sorted()\n-                                    .forEach(label -> message.append(\"- `\" + label + \"`\\n\"));\n-            message.append(\"\\n\");\n-            message.append(\"<\/details>\");\n-        } else {\n-            message.append(\"The following label\");\n-            if (newLabels.size() > 1) {\n-                message.append(\"s\");\n-            }\n-            message.append(\" will be automatically applied to this pull request:\\n\\n\");\n-            newLabels.stream()\n-                     .sorted()\n-                     .forEach(label -> message.append(\"- `\" + label + \"`\\n\"));\n-            message.append(\"\\n\");\n-            message.append(\"When this pull request is ready to be reviewed, an \\\"RFR\\\" email will be sent to the \");\n-            message.append(\"corresponding mailing list\");\n-            if (newLabels.size() > 1) {\n-                message.append(\"s\");\n+        if (autoLabeled) {\n+            if (newLabels.isEmpty()) {\n+                message.append(\"To determine the appropriate audience for reviewing this pull request, one or more \");\n+                message.append(\"labels corresponding to different subsystems will normally be applied automatically. \");\n+                message.append(\"However, no automatic labelling rule matches the changes in this pull request. \");\n+                message.append(\"In order to have an \\\"RFR\\\" email sent to the correct mailing list, you will \");\n+                message.append(\"need to add one or more applicable labels manually using the \");\n+                message.append(\"[\/label](https:\/\/wiki.openjdk.org\/display\/SKARA\/Pull+Request+Commands#PullRequestCommands-\/label)\");\n+                message.append(\" pull request command.\\n\\n\");\n+                message.append(\"<details>\\n\");\n+                message.append(\"<summary>Applicable Labels<\/summary>\\n\");\n+                message.append(\"<br>\\n\");\n+                message.append(\"\\n\");\n+                bot.labelConfiguration().allowed()\n+                        .stream()\n+                        .sorted()\n+                        .forEach(label -> message.append(\"- `\" + label + \"`\\n\"));\n+                message.append(\"\\n\");\n+                message.append(\"<\/details>\");\n+            } else {\n+                message.append(\"The following label\");\n+                if (newLabels.size() > 1) {\n+                    message.append(\"s\");\n+                }\n+                message.append(\" will be automatically applied to this pull request:\\n\\n\");\n+                newLabels.stream()\n+                        .sorted()\n+                        .forEach(label -> message.append(\"- `\" + label + \"`\\n\"));\n+                message.append(\"\\n\");\n+                message.append(\"When this pull request is ready to be reviewed, an \\\"RFR\\\" email will be sent to the \");\n+                message.append(\"corresponding mailing list\");\n+                if (newLabels.size() > 1) {\n+                    message.append(\"s\");\n+                }\n+                message.append(\". If you would like to change these labels, use the \");\n+                message.append(\"[\/label](https:\/\/wiki.openjdk.org\/display\/SKARA\/Pull+Request+Commands#PullRequestCommands-\/label)\");\n+                message.append(\" pull request command.\");\n@@ -107,3 +119,2 @@\n-            message.append(\". If you would like to change these labels, use the \");\n-            message.append(\"[\/label](https:\/\/wiki.openjdk.org\/display\/SKARA\/Pull+Request+Commands#PullRequestCommands-\/label)\");\n-            message.append(\" pull request command.\");\n+        } else {\n+            message.append(\"A manual label command was issued before auto-labeling, so auto-labeling was skipped.\");\n@@ -114,0 +125,2 @@\n+        message.append(\"\\n\");\n+        message.append(String.format(LABEL_COMMIT_MARKER, commitHash));\n@@ -119,1 +132,3 @@\n-        if (bot.isAutoLabelled(pr)) {\n+        \/\/ If no label configuration, return early\n+        if (bot.labelConfiguration().allowed().isEmpty()) {\n+            bot.setAutoLabelled(pr);\n@@ -123,1 +138,2 @@\n-        if (bot.labelConfiguration().allowed().isEmpty()) {\n+        \/\/ If the label comment can be found, mark the pr as auto labelled\n+        if (findComment(prComments(), INITIAL_LABEL_MESSAGE, pr).isPresent()) {\n@@ -125,0 +141,51 @@\n+        }\n+\n+        \/\/ Updating labels when new files are touched\n+        if (bot.isAutoLabelled(pr)) {\n+            try {\n+                var oldLabels = new HashSet<>(pr.labelNames());\n+                var newLabels = new HashSet<>(pr.labelNames());\n+                var localRepo = IntegrateCommand.materializeLocalRepo(bot, pr, scratchArea);\n+                var labelComment = findComment(prComments(), INITIAL_LABEL_MESSAGE, pr);\n+\n+                if (labelComment.isPresent()) {\n+                    var autoLabeledHashOpt = autoLabeledHash(prComments(), pr);\n+                    if (autoLabeledHashOpt.isPresent()) {\n+                        var evaluatedCommitHash = autoLabeledHashOpt.get();\n+                        var changedFiles = PullRequestUtils.changedFiles(pr, localRepo, new Hash(evaluatedCommitHash));\n+                        var newLabelsNeedToBeAdded = bot.labelConfiguration().label(changedFiles);\n+                        newLabels.addAll(newLabelsNeedToBeAdded);\n+\n+                        var upgradedLabels = bot.labelConfiguration().upgradeLabelsToGroups(newLabels);\n+                        newLabels.addAll(upgradedLabels);\n+                        newLabels.removeIf(label -> !upgradedLabels.contains(label));\n+\n+                        for (var newLabel : newLabels) {\n+                            if (!oldLabels.contains(newLabel)) {\n+                                log.info(\"Adding label \" + newLabel);\n+                                pr.addLabel(newLabel);\n+                            }\n+                        }\n+\n+                        for (var oldLabel : oldLabels) {\n+                            if (!newLabels.contains(oldLabel)) {\n+                                log.info(\"Removing label \" + oldLabel);\n+                                pr.removeLabel(oldLabel);\n+                            }\n+                        }\n+\n+                        pr.updateComment(labelComment.get().id(), labelComment.get().body().replaceAll(\n+                                \"(<!-- PullRequest Bot label commit ')[^']*(' -->)\",\n+                                \"$1\" + pr.headHash().toString() + \"$2\"));\n+                    } else {\n+                        \/\/ If auto label comment is present but auto label hash isn't present, mark the headHash as handled.\n+                        pr.updateComment(labelComment.get().id(),\n+                                labelComment.get().body() + \"\\n\" + String.format(LABEL_COMMIT_MARKER, pr.headHash().toString()));\n+                    }\n+                } else {\n+                    log.severe(\"This pr is marked as auto labeled but no auto label comment found, pr id: \" + pr.id());\n+                }\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            \/\/ No need to return CheckWorkItem, if there is any label added, in the next round of CheckWorkItem, it will re-evaluate the pr\n@@ -128,0 +195,1 @@\n+        \/\/ Initial auto labeling\n@@ -129,1 +197,1 @@\n-        var labelNames = pr.labelNames();\n+        var labelNames = new HashSet<>(pr.labelNames());\n@@ -137,0 +205,1 @@\n+            updateLabelMessage(comments, List.of(), pr.headHash().toString(), false);\n@@ -149,4 +218,1 @@\n-            var path = scratchArea.get(pr.repository());\n-            var seedPath = bot.seedStorage().orElse(scratchArea.getSeeds());\n-            var hostedRepositoryPool = new HostedRepositoryPool(seedPath);\n-            var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, path);\n+            var localRepo = IntegrateCommand.materializeLocalRepo(bot, pr, scratchArea);\n@@ -164,1 +230,0 @@\n-            updateLabelMessage(comments, labelsToAdd);\n@@ -173,0 +238,2 @@\n+\n+            updateLabelMessage(comments, labelsToAdd, pr.headHash().toString(), true);\n@@ -179,1 +246,15 @@\n-    private Collection<WorkItem> needsRfrCheck(List<String> labelNames) {\n+    static Optional<String> autoLabeledHash(List<Comment> comments, PullRequest pr) {\n+        var labelComment = findComment(comments, INITIAL_LABEL_MESSAGE, pr);\n+        if (labelComment.isPresent()) {\n+            var line = labelComment.get().body().lines()\n+                    .map(LABEL_COMMIT_PATTERN::matcher)\n+                    .filter(Matcher::find)\n+                    .findFirst();\n+            if (line.isPresent()) {\n+                return Optional.of(line.get().group(1));\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private Collection<WorkItem> needsRfrCheck(Set<String> labelNames) {\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/LabelerWorkItem.java","additions":133,"deletions":52,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -191,4 +191,3 @@\n-            if (!bot.isAutoLabelled(pr) && !pr.isClosed()) {\n-                \/\/ When all commands are processed, it's time to check labels\n-                return List.of(new LabelerWorkItem(bot, prId, errorHandler, triggerUpdatedAt));\n-            } else {\n+            \/\/ If there is no label configuration, don't generate LabelerWorkItem\n+            if (bot.labelConfiguration().allowed().isEmpty()) {\n+                bot.setAutoLabelled(pr);\n@@ -197,0 +196,15 @@\n+\n+            if (!bot.isAutoLabelled(pr)) {\n+                return List.of(new LabelerWorkItem(bot, prId, errorHandler, triggerUpdatedAt));\n+            }\n+\n+            if (!pr.isClosed()) {\n+                \/\/ Check if the headHash of the pr has already been processed\n+                var autoLabeledHashOpt = LabelerWorkItem.autoLabeledHash(prComments(), pr);\n+                if (autoLabeledHashOpt.isPresent() && autoLabeledHashOpt.get().equals(pr.headHash().hex())) {\n+                    return List.of();\n+                }\n+                return List.of(new LabelerWorkItem(bot, prId, errorHandler, triggerUpdatedAt));\n+            }\n+\n+            return List.of();\n@@ -247,0 +261,3 @@\n+            if (command.name().equals(\"label\") || command.name().equals(\"cc\")) {\n+                return List.of(CheckWorkItem.fromWorkItem(bot, prId, errorHandler, triggerUpdatedAt), new LabelerWorkItem(bot, prId, errorHandler, triggerUpdatedAt));\n+            }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestCommandWorkItem.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,2 @@\n+            \/\/ Since group label is added, 1 should be removed\n+            assertFalse(pr.store().labelNames().contains(\"1\"));\n@@ -112,2 +114,2 @@\n-            \/\/ Drop both\n-            pr.addComment(\"        \/skara label remove 1   group\");\n+            \/\/ Drop group\n+            pr.addComment(\"        \/skara label remove   group\");\n@@ -117,1 +119,0 @@\n-            assertLastCommentContains(pr,\"The `1` label was successfully removed.\");\n@@ -181,1 +182,1 @@\n-            \/\/ The bot should not apply labels since the user has manually removed labels\n+            \/\/ The bot should add label \"1\" since test.cpp is touched\n@@ -183,1 +184,3 @@\n-            assertEquals(Set.of(), new HashSet<>(pr.store().labelNames()));\n+            \/\/ After label \"1\" is added, in the next CheckWorkItem, rfr should be added\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertEquals(Set.of(\"1\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n@@ -231,0 +234,1 @@\n+            assertLastCommentContains(pr, \"A manual label command was issued before auto-labeling, so auto-labeling was skipped.\");\n@@ -232,2 +236,2 @@\n-            assertEquals(2, pr.comments().size());\n-            assertLastCommentContains(pr, \"The `1` label was successfully added.\");\n+            assertEquals(3, pr.comments().size());\n+            assertTrue(pr.store().comments().get(1).body().contains(\"The `1` label was successfully added.\"));\n@@ -250,1 +254,1 @@\n-            assertEquals(Set.of(\"1\", \"2\", \"group\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(\"group\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n@@ -346,0 +350,2 @@\n+            TestBotRunner.runPeriodicItems(prBot);\n+\n@@ -522,1 +528,2 @@\n-            assertEquals(Set.of(\"1\", \"2\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            \/\/ label \"1\" and \"2\" should be upgraded to \"group\"\n+            assertEquals(Set.of(\"group\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n@@ -525,1 +532,1 @@\n-            pr.addComment(\"\/label -2\");\n+            pr.addComment(\"\/label -group\");\n@@ -529,2 +536,3 @@\n-            assertLastCommentContains(pr,\"The `2` label was successfully removed.\");\n-            assertEquals(Set.of(\"1\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            assertLastCommentContains(pr, \"The `group` label was successfully removed.\");\n+            \/\/ The rfr label should be removed because the pr is not associated with any component\n+            assertEquals(Set.of(), new HashSet<>(pr.store().labelNames()));\n@@ -537,2 +545,2 @@\n-            assertLastCommentContains(pr,\"The `group` label was successfully added.\");\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertLastCommentContains(pr, \"The `group` label was successfully added.\");\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n@@ -541,1 +549,1 @@\n-            pr.addComment(\"\/label -1,+2,-group\");\n+            pr.addComment(\"\/label +2,-group\");\n@@ -545,1 +553,0 @@\n-            assertLastCommentContains(pr,\"The `1` label was successfully removed.\");\n@@ -558,1 +565,1 @@\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n@@ -566,1 +573,1 @@\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n@@ -574,1 +581,1 @@\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n@@ -587,1 +594,66 @@\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+        }\n+    }\n+\n+    @Test\n+    void autoAdjustLabel(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                    .addReviewer(integrator.forge().currentUser().id())\n+                    .addCommitter(author.forge().currentUser().id());\n+            var labelConfiguration = LabelConfigurationJson.builder()\n+                    .addMatchers(\"1\", List.of(Pattern.compile(\"cpp$\")))\n+                    .addMatchers(\"2\", List.of(Pattern.compile(\"hpp$\")))\n+                    .addMatchers(\"3\", List.of(Pattern.compile(\"txt$\")))\n+                    .addGroup(\"group1\", List.of(\"1\", \"2\"))\n+                    .addExtra(\"extra\")\n+                    .build();\n+            var prBot = PullRequestBot.newBuilder()\n+                    .repo(integrator)\n+                    .censusRepo(censusBuilder.build())\n+                    .labelConfiguration(labelConfiguration)\n+                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType(), Path.of(\"test.hpp\"));\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.authenticatedUrl(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"123: This is a pull request\");\n+\n+            \/\/ The bot should have applied one label automatically\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertEquals(Set.of(\"2\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            assertLastCommentContains(pr, \"The following label will be automatically applied\");\n+            assertLastCommentContains(pr, \"`2`\");\n+\n+            var test1Cpp = localRepo.root().resolve(\"test1.cpp\");\n+            try (var output = Files.newBufferedWriter(test1Cpp)) {\n+                output.append(\"test\");\n+            }\n+            localRepo.add(test1Cpp);\n+            var addHash = localRepo.commit(\"add cpp file\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(addHash, author.authenticatedUrl(), \"edit\", true);\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertEquals(Set.of(\"group1\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+\n+            \/\/ Simulate force-push.\n+            localRepo.checkout(editHash);\n+            var test1txt = localRepo.root().resolve(\"test1.txt\");\n+            try (var output = Files.newBufferedWriter(test1txt)) {\n+                output.append(\"test\");\n+            }\n+            localRepo.add(test1txt);\n+            var forcePushHash = localRepo.commit(\"add txt file\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(forcePushHash, author.authenticatedUrl(), \"edit\", true);\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertEquals(Set.of(\"group1\", \"rfr\", \"3\"), new HashSet<>(pr.store().labelNames()));\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/LabelTests.java","additions":93,"deletions":21,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+    Set<String> upgradeLabelsToGroups(Set<String> labels);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/LabelConfiguration.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,0 +73,5 @@\n+\n+    @Override\n+    public Set<String> upgradeLabelsToGroups(Set<String> labels) {\n+        return labelConfiguration().upgradeLabelsToGroups(labels);\n+    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/LabelConfigurationHostedRepository.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,13 @@\n+        return upgradeLabelsToGroups(labels);\n+    }\n+\n+    public Set<String> allowed() {\n+        return allowed;\n+    }\n+\n+    public boolean isAllowed(String s) {\n+        return allowed.contains(s);\n+    }\n+\n+    @Override\n+    public Set<String> upgradeLabelsToGroups(Set<String> labels) {\n@@ -155,1 +168,0 @@\n-\n@@ -158,8 +170,0 @@\n-\n-    public Set<String> allowed() {\n-        return allowed;\n-    }\n-\n-    public boolean isAllowed(String s) {\n-        return allowed.contains(s);\n-    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/LabelConfigurationJson.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -193,0 +193,3 @@\n+    \/**\n+     * Returns the set of files changed in the pull request with respect to the base hash.\n+     *\/\n@@ -194,0 +197,15 @@\n+        return changedFilesBetween(localRepo, baseHash(pr, localRepo), pr.headHash());\n+    }\n+\n+    \/**\n+     * Returns the set of files changed in the pull request since a given commit.\n+     *\/\n+    public static Set<Path> changedFiles(PullRequest pr, Repository localRepo, Hash commitHash) throws IOException {\n+        \/\/ If commitHash is not the ancestor of pr.headHash(), it means the user did force push.\n+        if (!localRepo.isAncestor(commitHash, pr.headHash())) {\n+            return changedFiles(pr, localRepo);\n+        }\n+        return changedFilesBetween(localRepo, commitHash, pr.headHash());\n+    }\n+\n+    private static Set<Path> changedFilesBetween(Repository localRepo, Hash from, Hash to) throws IOException {\n@@ -195,1 +213,1 @@\n-        var changes = localRepo.diff(baseHash(pr, localRepo), pr.headHash());\n+        var changes = localRepo.diff(from, to);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequestUtils.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}