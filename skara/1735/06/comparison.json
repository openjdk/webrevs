{"files":[{"patch":"@@ -49,0 +49,1 @@\n+import static org.openjdk.skara.bots.pr.LabelerWorkItem.INITIAL_LABEL_MESSAGE;\n@@ -271,1 +272,1 @@\n-            if (workItem.bot.isAutoLabelled(pr)) {\n+            if (findComment(INITIAL_LABEL_MESSAGE).isPresent()) {\n@@ -1028,0 +1029,4 @@\n+        return findComment(comments, marker, pr);\n+    }\n+\n+    static Optional<Comment> findComment(List<Comment> comments, String marker, PullRequest pr) {\n@@ -1030,3 +1035,3 @@\n-                       .filter(comment -> comment.author().equals(self))\n-                       .filter(comment -> comment.body().contains(marker))\n-                       .findAny();\n+                .filter(comment -> comment.author().equals(self))\n+                .filter(comment -> comment.body().contains(marker))\n+                .findAny();\n@@ -1578,0 +1583,9 @@\n+        syncLabels(pr, labels, newLabels, log);\n+\n+        \/\/ After updating the PR, rethrow any exception to automatically retry on transient errors\n+        if (checkException != null) {\n+            throw new RuntimeException(\"Exception during jcheck\", checkException);\n+        }\n+    }\n+\n+    static void syncLabels(PullRequest pr, Set<String> oldLabels, Set<String> newLabels, Logger log) {\n@@ -1579,1 +1593,1 @@\n-            if (!labels.contains(newLabel)) {\n+            if (!oldLabels.contains(newLabel)) {\n@@ -1584,1 +1598,1 @@\n-        for (var oldLabel : labels) {\n+        for (var oldLabel : oldLabels) {\n@@ -1590,5 +1604,0 @@\n-\n-        \/\/ After updating the PR, rethrow any exception to automatically retry on transient errors\n-        if (checkException != null) {\n-            throw new RuntimeException(\"Exception during jcheck\", checkException);\n-        }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/CheckRun.java","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.logging.Logger;\n@@ -34,0 +35,1 @@\n+import static org.openjdk.skara.bots.pr.CheckRun.syncLabels;\n@@ -37,1 +39,1 @@\n-\n+    private static final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.pr\");\n@@ -85,1 +87,1 @@\n-                addLabels(labels, currentLabels, pr, reply);\n+                addLabels(labels, currentLabels, pr, reply, bot);\n@@ -89,0 +91,1 @@\n+            upgradeLabelsToGroups(pr, bot, currentLabels);\n@@ -118,1 +121,1 @@\n-            addLabels(labelsToAdd, currentLabels, pr, reply);\n+            addLabels(labelsToAdd, currentLabels, pr, reply, bot);\n@@ -120,0 +123,1 @@\n+            upgradeLabelsToGroups(pr, bot, currentLabels);\n@@ -149,1 +153,6 @@\n-    private void addLabels(List<String> labelsToAdd,Set<String> currentLabels, PullRequest pr, PrintWriter reply) {\n+    \/**\n+     * Attempts to add each label in labelsToAdd to the pull request.\n+     * Updates to currentLabels are performed immediately after each label addition, so group checks always\n+     * reflect the latest state after any modifications.\n+     *\/\n+    private void addLabels(List<String> labelsToAdd, Set<String> currentLabels, PullRequest pr, PrintWriter reply, PullRequestBot bot) {\n@@ -152,3 +161,18 @@\n-                pr.addLabel(label);\n-                reply.println(LabelTracker.addLabelMarker(label));\n-                reply.println(\"The `\" + label + \"` label was successfully added.\");\n+                var groups = bot.labelConfiguration().groupLabels(label);\n+                \/\/ The group labels already set in this pr\n+                Set<String> commonLabels = currentLabels.stream()\n+                        .filter(groups::contains)\n+                        .collect(Collectors.toSet());\n+                \/\/ No group labels are set\n+                if (commonLabels.isEmpty()) {\n+                    pr.addLabel(label);\n+                    currentLabels.add(label);\n+                    reply.println(LabelTracker.addLabelMarker(label));\n+                    reply.println(\"The `\" + label + \"` label was successfully added.\");\n+                } else {\n+                    reply.println(LabelTracker.addLabelMarker(label));\n+                    reply.println(\"The \" + commonLabels.stream()\n+                            .map(l -> \"`\" + l + \"`\")\n+                            .collect(Collectors.joining(\", \"))\n+                            + \" group label\" + (commonLabels.size() > 1 ? \"s were\" : \" was\") + \" already applied, so `\" + label + \"` label will not be added.\");\n+                }\n@@ -161,0 +185,4 @@\n+    \/**\n+     * Attempts to remove each label in labelsToRemove from the pull request.\n+     * Updates to currentLabels are performed immediately after each label removal.\n+     *\/\n@@ -165,0 +193,1 @@\n+                currentLabels.remove(label);\n@@ -173,0 +202,7 @@\n+    private void upgradeLabelsToGroups(PullRequest pr, PullRequestBot bot, Set<String> currentLabels) {\n+        Set<String> oldLabels = new HashSet<>(currentLabels);\n+        Set<String> newLabels = new HashSet<>(currentLabels);\n+        newLabels = bot.labelConfiguration().upgradeLabelsToGroups(newLabels);\n+        syncLabels(pr, oldLabels, newLabels, log);\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/LabelCommand.java","additions":43,"deletions":7,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+\n@@ -29,0 +30,1 @@\n+import org.openjdk.skara.vcs.Hash;\n@@ -34,0 +36,3 @@\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -36,0 +41,3 @@\n+import static org.openjdk.skara.bots.pr.CheckRun.findComment;\n+import static org.openjdk.skara.bots.pr.CheckRun.syncLabels;\n+\n@@ -37,1 +45,5 @@\n-    private static final String INITIAL_LABEL_MESSAGE = \"<!-- PullRequestBot initial label help comment -->\";\n+    protected static final String INITIAL_LABEL_MESSAGE = \"<!-- PullRequestBot initial label help comment -->\";\n+    private static final String LABEL_COMMIT_MARKER = \"<!-- PullRequest Bot label commit '%s' -->\";\n+    protected static final Pattern LABEL_COMMIT_PATTERN = Pattern.compile(\"<!-- PullRequest Bot label commit '(.*?)' -->\");\n+    private static final String AUTO_LABEL_ADDITIONAL_COMMENT_MARKER = \"<!-- PullRequest Bot auto label additional comment '%s' -->\";\n+    private static final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.pr\");\n@@ -40,1 +52,1 @@\n-            ZonedDateTime prUpdatedAt) {\n+                    ZonedDateTime prUpdatedAt) {\n@@ -54,10 +66,2 @@\n-    private Optional<Comment> findComment(List<Comment> comments, String marker) {\n-        var self = pr.repository().forge().currentUser();\n-        return comments.stream()\n-                       .filter(comment -> comment.author().equals(self))\n-                       .filter(comment -> comment.body().contains(marker))\n-                       .findAny();\n-    }\n-\n-    private void updateLabelMessage(List<Comment> comments, List<String> newLabels) {\n-        var existing = findComment(comments, INITIAL_LABEL_MESSAGE);\n+    private void createInitialLabelMessage(List<Comment> comments, List<String> newLabels, String commitHash) {\n+        var existing = findComment(comments, INITIAL_LABEL_MESSAGE, pr);\n@@ -87,3 +91,3 @@\n-                                    .stream()\n-                                    .sorted()\n-                                    .forEach(label -> message.append(\"- `\" + label + \"`\\n\"));\n+                    .stream()\n+                    .sorted()\n+                    .forEach(label -> message.append(\"- `\" + label + \"`\\n\"));\n@@ -99,2 +103,2 @@\n-                     .sorted()\n-                     .forEach(label -> message.append(\"- `\" + label + \"`\\n\"));\n+                    .sorted()\n+                    .forEach(label -> message.append(\"- `\" + label + \"`\\n\"));\n@@ -114,0 +118,2 @@\n+        message.append(\"\\n\");\n+        message.append(String.format(LABEL_COMMIT_MARKER, commitHash));\n@@ -119,1 +125,2 @@\n-        if (bot.isAutoLabelled(pr)) {\n+        \/\/ If the pr is already closed, return early\n+        if (pr.isClosed()) {\n@@ -123,0 +130,1 @@\n+        \/\/ If no label configuration, return early\n@@ -124,1 +132,0 @@\n-            bot.setAutoLabelled(pr);\n@@ -129,9 +136,56 @@\n-        var labelNames = pr.labelNames();\n-        var manuallyAdded = LabelTracker.currentAdded(pr.repository().forge().currentUser(), comments);\n-        var manuallyRemoved = LabelTracker.currentRemoved(pr.repository().forge().currentUser(), comments);\n-\n-        \/\/ If a manual label command has been issued before we have done any labeling,\n-        \/\/ that is considered to be a request to override any automatic labelling\n-        if (manuallyAdded.size() > 0 || manuallyRemoved.size() > 0) {\n-            bot.setAutoLabelled(pr);\n-            return needsRfrCheck(labelNames);\n+        var initialLabelComment = findComment(comments, INITIAL_LABEL_MESSAGE, pr);\n+        Set<String> oldLabels = new HashSet<>(pr.labelNames());\n+        Set<String> newLabels = new HashSet<>(pr.labelNames());\n+\n+        \/\/ If the initial label comment can be found, updating labels when new files are touched\n+        if (initialLabelComment.isPresent()) {\n+            try {\n+                var localRepo = IntegrateCommand.materializeLocalRepo(bot, pr, scratchArea);\n+                var autoLabeledHashOpt = autoLabeledHash(comments, pr);\n+                if (autoLabeledHashOpt.isPresent()) {\n+                    var evaluatedCommitHash = autoLabeledHashOpt.get();\n+                    var changedFiles = PullRequestUtils.changedFiles(pr, localRepo, new Hash(evaluatedCommitHash));\n+                    var newLabelsNeedToBeAdded = bot.labelConfiguration().label(changedFiles);\n+                    newLabels.addAll(newLabelsNeedToBeAdded);\n+\n+                    newLabels = bot.labelConfiguration().upgradeLabelsToGroups(newLabels);\n+\n+                    syncLabels(pr, oldLabels, newLabels, log);\n+\n+                    \/\/ The labels actually added\n+                    newLabels.removeAll(oldLabels);\n+                    if (!newLabels.isEmpty()) {\n+                        addLabelAutoUpdateAdditionalComment(comments, new ArrayList<>(newLabels), pr.headHash().hex());\n+                    }\n+\n+                    Matcher matcher = LABEL_COMMIT_PATTERN.matcher(initialLabelComment.get().body());\n+                    String updatedBody = matcher.replaceAll(String.format(LABEL_COMMIT_MARKER, pr.headHash().toString()));\n+                    pr.updateComment(initialLabelComment.get().id(), updatedBody);\n+                } else {\n+                    \/\/ If auto label comment is present but auto label hash isn't present, mark the headHash as handled.\n+                    pr.updateComment(initialLabelComment.get().id(),\n+                            initialLabelComment.get().body() + \"\\n\" + String.format(LABEL_COMMIT_MARKER, pr.headHash().toString()));\n+                }\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            \/\/ No need to return CheckWorkItem, if there is any label added, in the next round of CheckWorkItem, it will re-evaluate the pr\n+            return List.of();\n+        } else {\n+            \/\/ Initial auto labeling\n+            try {\n+                var localRepo = IntegrateCommand.materializeLocalRepo(bot, pr, scratchArea);\n+                newLabels.addAll(getLabels(localRepo));\n+                newLabels = bot.labelConfiguration().upgradeLabelsToGroups(newLabels);\n+                syncLabels(pr, oldLabels, newLabels, log);\n+                var labelsAdded = new HashSet<String>();\n+                for (var newLabel : newLabels) {\n+                    if (!oldLabels.contains(newLabel)) {\n+                        labelsAdded.add(newLabel);\n+                    }\n+                }\n+                createInitialLabelMessage(comments, new ArrayList<>(labelsAdded), pr.headHash().toString());\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            return needsRfrCheck(newLabels);\n@@ -139,0 +193,1 @@\n+    }\n@@ -140,6 +195,16 @@\n-        \/\/ If the PR already has one of the allowed labels, that is also considered to override automatic labelling\n-        var existingAllowed = new HashSet<>(labelNames);\n-        existingAllowed.retainAll(bot.labelConfiguration().allowed());\n-        if (!existingAllowed.isEmpty()) {\n-            bot.setAutoLabelled(pr);\n-            return needsRfrCheck(labelNames);\n+    void addLabelAutoUpdateAdditionalComment(List<Comment> comments, List<String> labelsAdded, String commitHash) {\n+        if (findComment(comments, String.format(AUTO_LABEL_ADDITIONAL_COMMENT_MARKER, commitHash), pr).isPresent()) {\n+            \/\/ Only add the comment once\n+            return;\n+        }\n+        var message = new StringBuilder();\n+        message.append(\"@\");\n+        message.append(pr.author().username());\n+        message.append(\" \");\n+        if (!labelsAdded.isEmpty()) {\n+            Collections.sort(labelsAdded);\n+            message.append(labelsAdded.stream()\n+                    .map(label -> \"`\" + label + \"`\")\n+                    .collect(Collectors.joining(\", \")));\n+            message.append(labelsAdded.size() == 1 ? \" has\" : \" have\");\n+            message.append(\" been added to this pull request based on files touched in new commit(s).\");\n@@ -147,0 +212,4 @@\n+        message.append(\"\\n\");\n+        message.append(String.format(AUTO_LABEL_ADDITIONAL_COMMENT_MARKER, commitHash));\n+        pr.addComment(message.toString());\n+    }\n@@ -148,27 +217,10 @@\n-        try {\n-            var path = scratchArea.get(pr.repository());\n-            var seedPath = bot.seedStorage().orElse(scratchArea.getSeeds());\n-            var hostedRepositoryPool = new HostedRepositoryPool(seedPath);\n-            var localRepo = PullRequestUtils.materialize(hostedRepositoryPool, pr, path);\n-            var newLabels = getLabels(localRepo);\n-            var currentLabels = pr.labelNames().stream()\n-                                  .filter(key -> bot.labelConfiguration().allowed().contains(key))\n-                                  .collect(Collectors.toSet());\n-\n-\n-            \/\/ Add all labels not already set that are not manually removed\n-            var labelsToAdd = newLabels.stream()\n-                     .filter(label -> !currentLabels.contains(label))\n-                     .filter(label -> !manuallyRemoved.contains(label))\n-                                       .collect(Collectors.toList());\n-            updateLabelMessage(comments, labelsToAdd);\n-            labelsToAdd.forEach(pr::addLabel);\n-\n-            \/\/ Remove set labels no longer present unless it has been manually added\n-            currentLabels.stream()\n-                         .filter(label -> !newLabels.contains(label))\n-                         .filter(label -> !manuallyAdded.contains(label))\n-                         .forEach(pr::removeLabel);\n-            bot.setAutoLabelled(pr);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n+    static Optional<String> autoLabeledHash(List<Comment> comments, PullRequest pr) {\n+        var labelComment = findComment(comments, INITIAL_LABEL_MESSAGE, pr);\n+        if (labelComment.isPresent()) {\n+            var line = labelComment.get().body().lines()\n+                    .map(LABEL_COMMIT_PATTERN::matcher)\n+                    .filter(Matcher::find)\n+                    .findFirst();\n+            if (line.isPresent()) {\n+                return Optional.of(line.get().group(1));\n+            }\n@@ -176,1 +228,1 @@\n-        return needsRfrCheck(labelNames);\n+        return Optional.empty();\n@@ -179,1 +231,1 @@\n-    private Collection<WorkItem> needsRfrCheck(List<String> labelNames) {\n+    private Collection<WorkItem> needsRfrCheck(Set<String> labelNames) {\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/LabelerWorkItem.java","additions":116,"deletions":64,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-    private final Set<String> autoLabelled;\n@@ -143,1 +142,0 @@\n-        autoLabelled = new HashSet<>();\n@@ -371,12 +369,0 @@\n-    public boolean isAutoLabelled(PullRequest pr) {\n-        synchronized (autoLabelled) {\n-            return autoLabelled.contains(pr.id());\n-        }\n-    }\n-\n-    public void setAutoLabelled(PullRequest pr) {\n-        synchronized (autoLabelled) {\n-            autoLabelled.add(pr.id());\n-        }\n-    }\n-\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBot.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -191,4 +191,2 @@\n-            if (!bot.isAutoLabelled(pr) && !pr.isClosed()) {\n-                \/\/ When all commands are processed, it's time to check labels\n-                return List.of(new LabelerWorkItem(bot, prId, errorHandler, triggerUpdatedAt));\n-            } else {\n+            \/\/ If there is no label configuration, don't generate LabelerWorkItem\n+            if (bot.labelConfiguration().allowed().isEmpty()) {\n@@ -197,0 +195,11 @@\n+\n+            if (!pr.isClosed()) {\n+                \/\/ Check if the headHash of the pr has already been processed\n+                var autoLabeledHashOpt = LabelerWorkItem.autoLabeledHash(prComments(), pr);\n+                if (autoLabeledHashOpt.isPresent() && autoLabeledHashOpt.get().equals(pr.headHash().hex())) {\n+                    return List.of();\n+                }\n+                return List.of(new LabelerWorkItem(bot, prId, errorHandler, triggerUpdatedAt));\n+            }\n+\n+            return List.of();\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestCommandWorkItem.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-            assertTrue(pr.labelNames().contains(\"ready\"));\n+            assertTrue(pr.store().labelNames().contains(\"ready\"));\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/ApprovalAndApproveCommandTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,2 @@\n+            \/\/ Since group label is added, 1 should be removed\n+            assertFalse(pr.store().labelNames().contains(\"1\"));\n@@ -112,2 +114,2 @@\n-            \/\/ Drop both\n-            pr.addComment(\"        \/skara label remove 1   group\");\n+            \/\/ Drop group\n+            pr.addComment(\"        \/skara label remove   group\");\n@@ -117,1 +119,0 @@\n-            assertLastCommentContains(pr,\"The `1` label was successfully removed.\");\n@@ -144,0 +145,1 @@\n+                                                           .addGroup(\"group2\", List.of(\"1\", \"3\"))\n@@ -181,1 +183,1 @@\n-            \/\/ The bot should not apply labels since the user has manually removed labels\n+            \/\/ The bot should add label \"1\" since test.cpp is touched\n@@ -183,1 +185,3 @@\n-            assertEquals(Set.of(), new HashSet<>(pr.store().labelNames()));\n+            \/\/ After label \"1\" is added, in the next CheckWorkItem, rfr should be added\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertEquals(Set.of(\"1\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n@@ -190,0 +194,10 @@\n+\n+            pr.addComment(\"\/label add group2\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"The `group2` label was successfully added.\");\n+            assertEquals(Set.of(\"group\", \"group2\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+\n+            pr.addComment(\"\/label add 1\");\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertLastCommentContains(pr, \"The `group2`, `group` group labels were already applied, so `1` label will not be added.\");\n+            assertEquals(Set.of(\"group\", \"group2\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n@@ -228,1 +242,1 @@\n-            \/\/ The bot will not add any label automatically\n+            \/\/ Although manually added label 1, the auto labeling should still happen\n@@ -231,3 +245,4 @@\n-            assertEquals(Set.of(\"1\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n-            assertEquals(2, pr.comments().size());\n-            assertLastCommentContains(pr, \"The `1` label was successfully added.\");\n+            assertLastCommentContains(pr, \"The following label will be automatically applied to this pull request:\");\n+            assertEquals(Set.of(\"group\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(3, pr.comments().size());\n+            assertTrue(pr.store().comments().get(1).body().contains(\"The `1` label was successfully added.\"));\n@@ -241,1 +256,0 @@\n-            \/\/ The bot will still not do any automatic labelling\n@@ -243,1 +257,1 @@\n-            assertEquals(Set.of(\"1\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(\"group\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n@@ -248,3 +262,3 @@\n-            assertLastCommentContains(pr, \"The `group` label was successfully added.\");\n-            assertLastCommentContains(pr, \"The `2` label was successfully added.\");\n-            assertEquals(Set.of(\"1\", \"2\", \"group\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            assertLastCommentContains(pr, \"The `group` label was already applied.\");\n+            assertLastCommentContains(pr, \"The `group` group label was already applied, so `2` label will not be added.\");\n+            assertEquals(Set.of(\"group\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n@@ -346,0 +360,2 @@\n+            TestBotRunner.runPeriodicItems(prBot);\n+\n@@ -522,1 +538,2 @@\n-            assertEquals(Set.of(\"1\", \"2\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            \/\/ label \"1\" and \"2\" should be upgraded to \"group\"\n+            assertEquals(Set.of(\"group\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n@@ -525,1 +542,1 @@\n-            pr.addComment(\"\/label -2\");\n+            pr.addComment(\"\/label -group\");\n@@ -529,2 +546,3 @@\n-            assertLastCommentContains(pr,\"The `2` label was successfully removed.\");\n-            assertEquals(Set.of(\"1\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            assertLastCommentContains(pr, \"The `group` label was successfully removed.\");\n+            \/\/ The rfr label should be removed because the pr is not associated with any component\n+            assertEquals(Set.of(), new HashSet<>(pr.store().labelNames()));\n@@ -537,2 +555,2 @@\n-            assertLastCommentContains(pr,\"The `group` label was successfully added.\");\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertLastCommentContains(pr, \"The `group` label was successfully added.\");\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n@@ -541,1 +559,1 @@\n-            pr.addComment(\"\/label -1,+2,-group\");\n+            pr.addComment(\"\/label +2,-group\");\n@@ -545,2 +563,1 @@\n-            assertLastCommentContains(pr,\"The `1` label was successfully removed.\");\n-            assertLastCommentContains(pr,\"The `2` label was successfully added.\");\n+            assertLastCommentContains(pr,\"The `group` group label was already applied, so `2` label will not be added.\");\n@@ -548,1 +565,1 @@\n-            assertEquals(Set.of(\"2\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(), new HashSet<>(pr.store().labelNames()));\n@@ -556,3 +573,3 @@\n-            assertLastCommentContains(pr,\"The `1` label was successfully added.\");\n-            assertLastCommentContains(pr,\"The `2` label was successfully removed.\");\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertLastCommentContains(pr,\"The `group` group label was already applied, so `1` label will not be added.\");\n+            assertLastCommentContains(pr,\"The `2` label was not set.\");\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n@@ -566,1 +583,1 @@\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n@@ -574,1 +591,1 @@\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n@@ -587,1 +604,66 @@\n-            assertEquals(Set.of(\"1\", \"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"group\"), new HashSet<>(pr.store().labelNames()));\n+        }\n+    }\n+\n+    @Test\n+    void autoAdjustLabel(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tempFolder = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                    .addReviewer(integrator.forge().currentUser().id())\n+                    .addCommitter(author.forge().currentUser().id());\n+            var labelConfiguration = LabelConfigurationJson.builder()\n+                    .addMatchers(\"1\", List.of(Pattern.compile(\"cpp$\")))\n+                    .addMatchers(\"2\", List.of(Pattern.compile(\"hpp$\")))\n+                    .addMatchers(\"3\", List.of(Pattern.compile(\"txt$\")))\n+                    .addGroup(\"group1\", List.of(\"1\", \"2\"))\n+                    .addExtra(\"extra\")\n+                    .build();\n+            var prBot = PullRequestBot.newBuilder()\n+                    .repo(integrator)\n+                    .censusRepo(censusBuilder.build())\n+                    .labelConfiguration(labelConfiguration)\n+                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepoFolder = tempFolder.path().resolve(\"localrepo\");\n+            var localRepo = CheckableRepository.init(localRepoFolder, author.repositoryType(), Path.of(\"test.hpp\"));\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.authenticatedUrl(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"123: This is a pull request\");\n+\n+            \/\/ The bot should have applied one label automatically\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertEquals(Set.of(\"2\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+            assertLastCommentContains(pr, \"The following label will be automatically applied\");\n+            assertLastCommentContains(pr, \"`2`\");\n+\n+            var test1Cpp = localRepo.root().resolve(\"test1.cpp\");\n+            try (var output = Files.newBufferedWriter(test1Cpp)) {\n+                output.append(\"test\");\n+            }\n+            localRepo.add(test1Cpp);\n+            var addHash = localRepo.commit(\"add cpp file\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(addHash, author.authenticatedUrl(), \"edit\", true);\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertEquals(Set.of(\"group1\", \"rfr\"), new HashSet<>(pr.store().labelNames()));\n+\n+            \/\/ Simulate force-push.\n+            localRepo.checkout(editHash);\n+            var test1txt = localRepo.root().resolve(\"test1.txt\");\n+            try (var output = Files.newBufferedWriter(test1txt)) {\n+                output.append(\"test\");\n+            }\n+            localRepo.add(test1txt);\n+            var forcePushHash = localRepo.commit(\"add txt file\", \"duke\", \"duke@openjdk.org\");\n+            localRepo.push(forcePushHash, author.authenticatedUrl(), \"edit\", true);\n+            TestBotRunner.runPeriodicItems(prBot);\n+            assertEquals(Set.of(\"group1\", \"rfr\", \"3\"), new HashSet<>(pr.store().labelNames()));\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/LabelTests.java","additions":113,"deletions":31,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-            assertEquals(Set.of(), new HashSet<>(pr.labelNames()));\n+            assertEquals(Set.of(), new HashSet<>(pr.store().labelNames()));\n@@ -122,1 +122,1 @@\n-            assertEquals(Set.of(\"rfr\", \"test1\"), new HashSet<>(pr.labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"test1\"), new HashSet<>(pr.store().labelNames()));\n@@ -173,1 +173,1 @@\n-            assertEquals(Set.of(\"rfr\", \"test1\"), new HashSet<>(pr.labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"test1\"), new HashSet<>(pr.store().labelNames()));\n@@ -215,1 +215,1 @@\n-            \/\/ Issue a manual label command\n+            \/\/ Issue a manual label command, this shouldn't affect the auto labeling\n@@ -219,1 +219,1 @@\n-            \/\/ Check the status - there should still only be a test2 label\n+            \/\/ Check the status - there should be test1 and test2\n@@ -221,1 +221,1 @@\n-            assertEquals(Set.of(\"rfr\", \"test2\"), new HashSet<>(pr.labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"test2\", \"test1\"), new HashSet<>(pr.store().labelNames()));\n@@ -263,1 +263,1 @@\n-            \/\/ Manually set a label\n+            \/\/ Manually set a label shouldn't affect auto labeling\n@@ -266,1 +266,1 @@\n-            \/\/ Check the status - there should still only be a test2 label\n+            \/\/ Check the status - there should be test1 and test2\n@@ -268,1 +268,1 @@\n-            assertEquals(Set.of(\"rfr\", \"test2\"), new HashSet<>(pr.labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"test2\", \"test1\"), new HashSet<>(pr.store().labelNames()));\n@@ -315,1 +315,1 @@\n-            assertEquals(Set.of(\"rfr\", \"test1\", \"test42\"), new HashSet<>(pr.labelNames()));\n+            assertEquals(Set.of(\"rfr\", \"test1\", \"test42\"), new HashSet<>(pr.store().labelNames()));\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/LabelerTests.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+    Set<String> upgradeLabelsToGroups(Set<String> labels);\n+    \/**\n+     * Returns the set of groups that this label belongs to.\n+     *\/\n+    Set<String> groupLabels(String label);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/LabelConfiguration.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,0 +73,10 @@\n+\n+    @Override\n+    public Set<String> upgradeLabelsToGroups(Set<String> labels) {\n+        return labelConfiguration().upgradeLabelsToGroups(labels);\n+    }\n+\n+    @Override\n+    public Set<String> groupLabels(String label) {\n+        return labelConfiguration().groupLabels(label);\n+    }\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/LabelConfigurationHostedRepository.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,13 @@\n+        return upgradeLabelsToGroups(labels);\n+    }\n+\n+    public Set<String> allowed() {\n+        return allowed;\n+    }\n+\n+    public boolean isAllowed(String s) {\n+        return allowed.contains(s);\n+    }\n+\n+    @Override\n+    public Set<String> upgradeLabelsToGroups(Set<String> labels) {\n@@ -155,1 +168,0 @@\n-\n@@ -159,6 +171,8 @@\n-    public Set<String> allowed() {\n-        return allowed;\n-    }\n-\n-    public boolean isAllowed(String s) {\n-        return allowed.contains(s);\n+    public Set<String> groupLabels(String label) {\n+        var ret = new HashSet<String>();\n+        for (var group : groups.entrySet()) {\n+            if (group.getValue().contains(label)) {\n+                ret.add(group.getKey());\n+            }\n+        }\n+        return ret;\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/LabelConfigurationJson.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -193,0 +193,3 @@\n+    \/**\n+     * Returns the set of files changed in the pull request with respect to the base hash.\n+     *\/\n@@ -194,0 +197,15 @@\n+        return changedFilesBetween(localRepo, baseHash(pr, localRepo), pr.headHash());\n+    }\n+\n+    \/**\n+     * Returns the set of files changed in the pull request since a given commit.\n+     *\/\n+    public static Set<Path> changedFiles(PullRequest pr, Repository localRepo, Hash commitHash) throws IOException {\n+        \/\/ If commitHash is not the ancestor of pr.headHash(), it means the user did force push.\n+        if (!localRepo.isAncestor(commitHash, pr.headHash())) {\n+            return changedFiles(pr, localRepo);\n+        }\n+        return changedFilesBetween(localRepo, commitHash, pr.headHash());\n+    }\n+\n+    private static Set<Path> changedFilesBetween(Repository localRepo, Hash from, Hash to) throws IOException {\n@@ -195,1 +213,1 @@\n-        var changes = localRepo.diff(baseHash(pr, localRepo), pr.headHash());\n+        var changes = localRepo.diff(from, to);\n","filename":"forge\/src\/main\/java\/org\/openjdk\/skara\/forge\/PullRequestUtils.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-    private List<Label> labels;\n@@ -319,13 +318,0 @@\n-    \/**\n-     * Mimic GitHub\/GitLab where the labels are fetched lazily and cached.\n-     * In GitLabMergeRequest, the labels are actually part of the main json, but\n-     * are still re-fetched once on the first call to labels().\n-     *\/\n-    @Override\n-    public List<Label> labels() {\n-        if (labels == null) {\n-            labels = store().labels().keySet().stream().map(Label::new).collect(Collectors.toList());\n-        }\n-        return labels;\n-    }\n-\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestPullRequest.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"}]}