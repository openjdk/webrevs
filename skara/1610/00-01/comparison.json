{"files":[{"patch":"@@ -37,4 +37,0 @@\n-    List<IssueTrackerIssue> search(String query, int limit);\n-    default List<IssueTrackerIssue> search(String query) {\n-        return search(query, -1);\n-    }\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/IssueProject.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -487,2 +487,5 @@\n-    @Override\n-    public List<IssueTrackerIssue> search(String jql, int limit) {\n+    private List<IssueTrackerIssue> search(String jql) {\n+        return search(jql, -1);\n+    }\n+\n+    private List<IssueTrackerIssue> search(String jql, int limit) {\n@@ -493,2 +496,0 @@\n-        var ret = new HashMap<String, IssueTrackerIssue>();\n-        int count = 0;\n@@ -499,4 +500,15 @@\n-        var issues = req.execute();\n-        var startAt = 0;\n-        while (issues.get(\"issues\").asArray().size() > 0) {\n-            for (var issue : issues.get(\"issues\").asArray()) {\n+        var res = req.execute();\n+\n+        \/\/ Due to pagination the same issue can be returned multiple times,\n+        \/\/ for example if an issue is updated _after_ the REST call to the\n+        \/\/ \"search\" endpoint. Then it might be included in one of  the next\n+        \/\/ pages of results, even though it was also present in the first page.\n+        \/\/\n+        \/\/ Handle this case gracefuily by prefering the most recent version of\n+        \/\/ the issue (the one encountered last), this is implemented by\n+        \/\/ utilizing a HashMap.\n+        var ret = new HashMap<String, IssueTrackerIssue>();\n+        var issues = res.get(\"issues\").asArray();\n+        int count = 0;\n+        while (issues.size() > 0) {\n+            for (var issue : issues) {\n@@ -505,0 +517,3 @@\n+                if (count == limit) {\n+                    break;\n+                }\n@@ -507,2 +522,1 @@\n-            if (count < issues.get(\"total\").asInt()) {\n-                startAt += issues.get(\"issues\").asArray().size();\n+            if (count < issues.get(\"total\").asInt() && count < limit) {\n@@ -511,1 +525,1 @@\n-                             .param(\"startAt\", String.valueOf(startAt));\n+                             .param(\"startAt\", String.valueOf(count));\n@@ -513,1 +527,2 @@\n-                    req = req.param(\"maxResults\", Integer.toString(limit));\n+                    var remaining = limit - count;\n+                    req = req.param(\"maxResults\", Integer.toString(remaining));\n@@ -516,1 +531,1 @@\n-                issues = req.execute();\n+                issues = req.execute().get(\"issues\").asArray();\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/jira\/JiraProject.java","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -99,5 +99,0 @@\n-\n-    @Override\n-    public List<IssueTrackerIssue> search(String query, int limit) {\n-        throw new UnsupportedOperationException(\"Not implemented yet\");\n-    }\n","filename":"test\/src\/main\/java\/org\/openjdk\/skara\/test\/TestIssueProject.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}