{"files":[{"patch":"@@ -450,9 +450,2 @@\n-        var issues = request.post(\"search\")\n-                .body(\"jql\", \"project = \" + projectName + \" AND \\\"JEP Number\\\" ~ \\\"\" + jepId + \"\\\"\")\n-                .execute();\n-        if (issues.get(\"issues\").asArray().size() == 0) {\n-            return Optional.empty();\n-        } else {\n-            var json = issues.get(\"issues\").asArray().get(0);\n-            return Optional.of(new JiraIssue(this, generateIssueRequest(json), json));\n-        }\n+        var issues = search(\"project = \" + projectName + \" AND \\\"JEP Number\\\" ~ \\\"\" + jepId + \"\\\"\");\n+        return issues.isEmpty() ? Optional.empty() : Optional.of(issues.get(0));\n@@ -463,8 +456,1 @@\n-        var ret = new ArrayList<IssueTrackerIssue>();\n-        var issues = request.post(\"search\")\n-                            .body(\"jql\", \"project = \" + projectName + \" AND status in (Open, New)\")\n-                            .execute();\n-        for (var issue : issues.get(\"issues\").asArray()) {\n-            ret.add(new JiraIssue(this, generateIssueRequest(issue), issue));\n-        }\n-        return ret;\n+        return search(\"project = \" + projectName + \" AND status in (Open, New)\");\n@@ -478,1 +464,1 @@\n-        return queryIssues(jql);\n+        return search(jql);\n@@ -487,1 +473,1 @@\n-        return queryIssues(jql);\n+        return search(jql);\n@@ -492,12 +478,2 @@\n-        var jql = \"project = \" + projectName + \" ORDER BY updated DESC\";\n-        var issues = request.get(\"search\")\n-                .param(\"jql\", jql)\n-                .param(\"maxResults\", \"1\")\n-                .execute();\n-        var issuesArray = issues.get(\"issues\").asArray();\n-        if (issuesArray.isEmpty()) {\n-            return Optional.empty();\n-        } else {\n-            var json = issuesArray.get(0);\n-            return Optional.of(new JiraIssue(this, generateIssueRequest(json), json));\n-        }\n+        var issues = search(\"project = \" + projectName + \" ORDER BY updated DESC\", 1);\n+        return issues.isEmpty() ? Optional.empty() : Optional.of(issues.get(0));\n@@ -511,1 +487,23 @@\n-    private List<IssueTrackerIssue> queryIssues(String jql) {\n+    private List<IssueTrackerIssue> search(String jql) {\n+        return search(jql, -1);\n+    }\n+\n+    private List<IssueTrackerIssue> search(String jql, int limit) {\n+        if (limit == 0) {\n+            return List.of();\n+        }\n+\n+        var req = request.get(\"search\").param(\"jql\", jql);\n+        if (limit > 0) {\n+            req = req.param(\"maxResults\", Integer.toString(limit));\n+        }\n+        var res = req.execute();\n+\n+        \/\/ Due to pagination the same issue can be returned multiple times,\n+        \/\/ for example if an issue is updated _after_ the REST call to the\n+        \/\/ \"search\" endpoint. Then it might be included in one of  the next\n+        \/\/ pages of results, even though it was also present in the first page.\n+        \/\/\n+        \/\/ Handle this case gracefuily by prefering the most recent version of\n+        \/\/ the issue (the one encountered last), this is implemented by\n+        \/\/ utilizing a HashMap.\n@@ -513,0 +511,1 @@\n+        var issues = res.get(\"issues\").asArray();\n@@ -514,6 +513,2 @@\n-        var issues = request.get(\"search\")\n-                .param(\"jql\", jql)\n-                .execute();\n-        var startAt = 0;\n-        while (issues.get(\"issues\").asArray().size() > 0) {\n-            for (var issue : issues.get(\"issues\").asArray()) {\n+        while (issues.size() > 0) {\n+            for (var issue : issues) {\n@@ -522,0 +517,3 @@\n+                if (count == limit) {\n+                    break;\n+                }\n@@ -524,6 +522,12 @@\n-            if (count < issues.get(\"total\").asInt()) {\n-                startAt += issues.get(\"issues\").asArray().size();\n-                issues = request.get(\"search\")\n-                        .param(\"jql\", jql)\n-                        .param(\"startAt\", String.valueOf(startAt))\n-                        .execute();\n+            var isBelowLimit = limit == -1 || count < limit;\n+            var total = issues.get(\"total\").asInt();\n+            if (count < total && isBelowLimit) {\n+                req = request.get(\"search\")\n+                             .param(\"jql\", jql)\n+                             .param(\"startAt\", String.valueOf(count));\n+                if (limit > 0) {\n+                    var remaining = limit - count;\n+                    req = req.param(\"maxResults\", Integer.toString(remaining));\n+                }\n+\n+                issues = req.execute().get(\"issues\").asArray();\n","filename":"issuetracker\/src\/main\/java\/org\/openjdk\/skara\/issuetracker\/jira\/JiraProject.java","additions":48,"deletions":44,"binary":false,"changes":92,"status":"modified"}]}