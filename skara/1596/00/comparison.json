{"files":[{"patch":"@@ -246,0 +246,8 @@\n+\n+                if (bot.shouldVerifyIntegrity()) {\n+                    var verifier = materializeIntegrityVerifier(bot, pr, scratchArea);\n+                    verifier.verifyPullRequestTarget(pr);\n+                    var amendedCommit = localRepo.lookup(amendedHash).orElseThrow();\n+                    verifier.updatePullRequestTarget(pr, amendedCommit);\n+                }\n+\n@@ -287,0 +295,9 @@\n+    static IntegrityVerifier materializeIntegrityVerifier(PullRequestBot bot, PullRequest pr, ScratchArea scratchArea) throws IOException {\n+        var path = scratchArea.getIntegrity().resolve(pr.repository().name());\n+        var seedPath = bot.seedStorage().orElse(scratchArea.getSeeds());\n+        var hostedRepositoryPool = new HostedRepositoryPool(seedPath);\n+        var hostedIntegrityRepo = bot.integrityRepo().get();\n+        var repo = hostedRepositoryPool.materialize(hostedIntegrityRepo, path);\n+        return new IntegrityVerifier(repo, bot.integrityRepo().get().authenticatedUrl());\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateCommand.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.*;\n+import java.util.logging.Logger;\n+\n+import org.openjdk.skara.forge.PullRequest;\n+import org.openjdk.skara.vcs.*;\n+\n+class IntegrityVerifier {\n+    private final Repository repo;\n+    private final URI remote;\n+    private static final Logger log = Logger.getLogger(\"org.openjdk.skara.bots.pr\");\n+\n+    IntegrityVerifier(Repository repo, URI remote) {\n+        this.repo = repo;\n+        this.remote = remote;\n+    }\n+\n+    void verifyPullRequestTarget(PullRequest pr) throws IOException {\n+        var targetHeadHash = pr.repository().branchHash(pr.targetRef()).orElseThrow();\n+        var targetHeadCommit = pr.repository().commit(targetHeadHash).orElseThrow();\n+        verifyBranch(pr.repository().name(), pr.targetRef(), targetHeadCommit);\n+    }\n+\n+    void verifyBranch(String repositoryName, String branchName, Commit current) throws IOException {\n+        var integrityBranch = repositoryName + \"-\" + branchName;\n+\n+        var branches = repo.remoteBranches(remote).stream().map(Reference::name).collect(Collectors.toSet());\n+        if (!branches.contains(integrityBranch)) {\n+            var masterHead = repo.fetch(remote, \"master\", false);\n+            repo.checkout(masterHead);\n+            var heads = repo.root().resolve(\"heads.txt\");\n+            var content = List.of(current.hash().hex(), current.parents().get(0).hex());\n+            Files.write(heads, content, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+            repo.add(heads);\n+            var head = repo.commit(\"Initialize heads.txt with '\" + current.hash().hex() + \"' for \" + repositoryName + \":\" + branchName,\n+                                   \"duke\",\n+                                   \"duke@openjdk.org\");\n+            repo.push(head, remote, integrityBranch);\n+            return;\n+        }\n+\n+        var latest = repo.fetch(remote, integrityBranch, false);\n+        repo.checkout(latest);\n+        var heads = repo.root().resolve(\"heads.txt\");\n+        var lines = Files.readAllLines(heads);\n+        if (lines.size() != 2) {\n+            throw new IllegalStateException(\"Corrupt heads.txt file for branch \" + integrityBranch);\n+        }\n+        var expected = new Hash(lines.get(0));\n+        if (!expected.equals(current.hash())) {\n+            var firstParent = new Hash(lines.get(1));\n+            if (firstParent.equals(current.hash())) {\n+                \/\/ The bot must have crashed between pushing to the integrity repo and to the target repo,\n+                \/\/ recover integrity repository\n+                log.info(\"Resetting heads.txt from '\" + expected + \"' to '\" + current.hash() + \"'\");\n+                var content = List.of(current.hash().hex(), current.parents().get(0).hex());\n+                Files.write(heads, content, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+                repo.add(heads);\n+                var head = repo.commit(\"Resetting heads.txt from '\" + expected + \"' to '\" + current.hash() + \"'\",\n+                                       \"duke\",\n+                                       \"duke@openjdk.org\");\n+                repo.push(head, remote, integrityBranch.toString());\n+            } else {\n+                var msg = \"Expected HEAD in branch \" + branchName + \" in repo \" + repositoryName +\n+                          \" to be '\" + expected.hex() + \"', but it was '\"  + current.hash().hex() + \"'\";\n+                log.severe(msg);\n+                throw new IllegalArgumentException(msg);\n+            }\n+        }\n+    }\n+\n+    void updateBranch(String repositoryName, String branchName, Commit next) throws IOException {\n+        var integrityBranch = repositoryName + \"-\" + branchName;\n+        var latest = repo.fetch(remote, integrityBranch);\n+        repo.checkout(latest);\n+        var heads = repo.root().resolve(\"heads.txt\");\n+        var lines = Files.readAllLines(heads);\n+        if (lines.size() != 2) {\n+            throw new IllegalStateException(\"Corrupt \" + heads + \" file for branch \" + integrityBranch);\n+        }\n+        var current = new Hash(lines.get(0));\n+\n+        var content = List.of(next.hash().hex(), next.parents().get(0).hex());\n+        Files.write(heads, content, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n+        repo.add(heads);\n+        var head = repo.commit(\"Updating from '\" + current + \"' to '\" + next  + \"'\",\n+                               \"duke\",\n+                               \"duke@openjdk.org\");\n+        repo.push(head, remote, integrityBranch);\n+    }\n+\n+    void updatePullRequestTarget(PullRequest pr, Commit next) throws IOException {\n+        updateBranch(pr.repository().name(), pr.targetRef(), next);\n+    }\n+}\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrityVerifier.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -83,0 +83,1 @@\n+    private final HostedRepository integrityRepo;\n@@ -97,1 +98,1 @@\n-                   Map<String, List<PRRecord>> issuePRMap, Approval approval, boolean versionMismatchWarning) {\n+                   Map<String, List<PRRecord>> issuePRMap, Approval approval, boolean versionMismatchWarning, HostedRepository integrityRepo) {\n@@ -134,0 +135,1 @@\n+        this.integrityRepo = integrityRepo;\n@@ -406,0 +408,8 @@\n+    public Optional<HostedRepository> integrityRepo() {\n+        return Optional.ofNullable(integrityRepo);\n+    }\n+\n+    public boolean shouldVerifyIntegrity() {\n+        return integrityRepo != null;\n+    }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBot.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    private HostedRepository integrityRepo = null;\n@@ -184,0 +185,5 @@\n+    public PullRequestBotBuilder integrityRepo(HostedRepository integrityRepo) {\n+        this.integrityRepo = integrityRepo;\n+        return this;\n+    }\n+\n@@ -260,1 +266,1 @@\n-                mergeSources, jcheckMerge, enableBackport, issuePRMap, approval, versionMismatchWarning);\n+                mergeSources, jcheckMerge, enableBackport, issuePRMap, approval, versionMismatchWarning, integrityRepo);\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotBuilder.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -94,0 +94,5 @@\n+        HostedRepository integrityRepo = null;\n+        if (specific.contains(\"integrity\")) {\n+            integrityRepo = configuration.repository(specific.get(\"integrity\").get(\"repo\").asString());\n+        }\n+\n@@ -132,0 +137,1 @@\n+                                           .integrityRepo(integrityRepo)\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/PullRequestBotFactory.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,0 +60,3 @@\n+    public Path getIntegrity() {\n+        return root.resolve(botName).resolve(\"integrity\");\n+    }\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/ScratchArea.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,0 +136,8 @@\n+\n+                if (bot.shouldVerifyIntegrity()) {\n+                    var verifier = IntegrateCommand.materializeIntegrityVerifier(bot, pr, scratchArea);\n+                    verifier.verifyPullRequestTarget(pr);\n+                    var amendedCommit = localRepo.lookup(amendedHash).orElseThrow();\n+                    verifier.updatePullRequestTarget(pr, amendedCommit);\n+                }\n+\n","filename":"bots\/pr\/src\/main\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorCommand.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1536,0 +1536,85 @@\n+\n+    @Test\n+    void withIntegrityVerification(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tmp = new TemporaryDirectory()) {\n+            var botUser = credentials.getHostedRepository();\n+            var author = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var integrity = credentials.getHostedRepository();\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addCommitter(author.forge().currentUser().id())\n+                                           .addReviewer(reviewer.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(botUser)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .integrityRepo(integrity)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localDir = tmp.path().resolve(\"local\");\n+            var localRepo = CheckableRepository.init(localDir, author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Populate intergity repo\n+            var integrityPreDir = tmp.path().resolve(\"integrity-pre\");\n+            var localIntegrityPreRepo = CheckableRepository.init(integrityPreDir, integrity.repositoryType());\n+            var localIntegrityPreRepoMasterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localIntegrityPreRepo.push(localIntegrityPreRepoMasterHash, integrity.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var editHash = CheckableRepository.appendAndCommit(localRepo);\n+            localRepo.push(editHash, author.authenticatedUrl(), \"refs\/heads\/edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"This is a pull request\");\n+\n+            \/\/ Approve it as another user\n+            var reviewerPr = reviewer.pullRequest(pr.id());\n+            reviewerPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ The bot should reply with integration message\n+            TestBotRunner.runPeriodicItems(bot);\n+            var integrateComments = pr.comments()\n+                                      .stream()\n+                                      .filter(c -> c.body().contains(\"To integrate this PR with the above commit message to the `master` branch\"))\n+                                      .filter(c -> c.body().contains(\"If you prefer to avoid any potential automatic rebasing\"))\n+                                      .count();\n+            assertEquals(1, integrateComments);\n+\n+            \/\/ Issue \"\/integrate\" command\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply with an ok message\n+            var pushed = pr.comments().stream()\n+                           .filter(comment -> comment.body().contains(\"Pushed as commit\"))\n+                           .count();\n+            assertEquals(1, pushed);\n+\n+            \/\/ The change should now be present on the master branch\n+            var pushedRepo = Repository.materialize(tmp.path().resolve(\"pushed\"), author.authenticatedUrl(), \"master\");\n+            assertTrue(CheckableRepository.hasBeenEdited(pushedRepo));\n+\n+            var headHash = pushedRepo.resolve(\"HEAD\").orElseThrow();\n+            var headCommit = pushedRepo.commits(headHash.hex() + \"^..\" + headHash.hex()).asList().get(0);\n+\n+            \/\/ Author and committer should be the same\n+            assertEquals(\"Generated Committer 1\", headCommit.author().name());\n+            assertEquals(\"integrationcommitter1@openjdk.org\", headCommit.author().email());\n+            assertEquals(\"Generated Committer 1\", headCommit.committer().name());\n+            assertEquals(\"integrationcommitter1@openjdk.org\", headCommit.committer().email());\n+            assertTrue(pr.store().labelNames().contains(\"integrated\"));\n+\n+            \/\/ Ready label should have been removed\n+            assertFalse(pr.store().labelNames().contains(\"ready\"));\n+\n+            \/\/ Integrity repo should have been updated\n+            var integrityPostDir = tmp.path().resolve(\"integrity-post\");\n+            var localIntegrityPostRepo = Repository.materialize(integrityPostDir,\n+                                                                integrity.authenticatedUrl(),\n+                                                                author.name() + \"-master\");\n+            var heads = Files.readAllLines(localIntegrityPostRepo.root().resolve(\"heads.txt\"));\n+            assertEquals(List.of(headHash.hex(), masterHash.hex()), heads);\n+        }\n+    }\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrateTests.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.skara.bots.pr;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.*;\n+import static java.nio.file.StandardOpenOption.*;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import org.junit.jupiter.api.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.openjdk.skara.vcs.*;\n+import org.openjdk.skara.test.TemporaryDirectory;\n+\n+class IntegrityTests {\n+    @BeforeEach\n+    void disableConfig() {\n+        Repository.ignoreConfiguration();\n+    }\n+\n+    private static Repository createRepo(TemporaryDirectory tmp) throws IOException {\n+        var dir = tmp.path().resolve(\"repo\");\n+        return Repository.init(dir, VCS.GIT);\n+    }\n+\n+    private static Commit createCommit(Repository repo) throws IOException {\n+        var f = repo.root().resolve(\"README.txt\");\n+        Files.write(f, \"This is just to create a commit\\n\".getBytes(), WRITE, APPEND, CREATE);\n+        repo.add(f);\n+        var hash = repo.commit(\"A commit\", \"duke\", \"duke@openjdk.org\");\n+        return repo.lookup(hash).orElseThrow();\n+    }\n+\n+    private static Repository createRemoteIntegrityRepo(TemporaryDirectory tmp) throws IOException {\n+        var dir = tmp.path().resolve(\"remote\");\n+        var repo = Repository.init(dir, VCS.GIT);\n+        Files.write(dir.resolve(\".git\").resolve(\"config\"),\n+                    List.of(\"[receive]\", \"denyCurrentBranch=ignore\"),\n+                    WRITE, APPEND);\n+        createCommit(repo);\n+        return repo;\n+    }\n+\n+    private static Repository createLocalIntegrityRepo(TemporaryDirectory tmp) throws IOException {\n+        var dir = tmp.path().resolve(\"local\");\n+        var repo = Repository.init(dir, VCS.GIT);\n+        return repo;\n+    }\n+\n+    @Test\n+    void missingIntegrityBranch() throws Exception {\n+        try (var dir = new TemporaryDirectory(false)) {\n+            var local = createLocalIntegrityRepo(dir);\n+            var remote = createRemoteIntegrityRepo(dir);\n+\n+            var repo = createRepo(dir);\n+            var current = createCommit(repo);\n+\n+            var verifier = new IntegrityVerifier(local, remote.root().toUri());\n+            verifier.verifyBranch(\"repo\", \"branch\", current);\n+\n+            var integrityBranch = new Branch(\"repo-branch\");\n+            assertTrue(remote.branches().contains(integrityBranch));\n+\n+            var head = local.fetch(remote.root().toUri(), integrityBranch.name());\n+            local.checkout(head);\n+            var heads = Files.readAllLines(local.root().resolve(\"heads.txt\"));\n+            assertEquals(List.of(current.hash().hex(), current.parents().get(0).hex()), heads);\n+        }\n+    }\n+\n+    @Test\n+    void verifyingIsIdempotent() throws Exception {\n+        try (var dir = new TemporaryDirectory()) {\n+            var local = createLocalIntegrityRepo(dir);\n+            var remote = createRemoteIntegrityRepo(dir);\n+\n+            var repo = createRepo(dir);\n+            var current = createCommit(repo);\n+\n+            var verifier = new IntegrityVerifier(local, remote.root().toUri());\n+            verifier.verifyBranch(\"repo\", \"branch\", current);\n+            verifier.verifyBranch(\"repo\", \"branch\", current);\n+\n+            var integrityBranch = new Branch(\"repo-branch\");\n+            assertTrue(remote.branches().contains(integrityBranch));\n+\n+            var head = local.fetch(remote.root().toUri(), integrityBranch.name());\n+            local.checkout(head);\n+            var heads = Files.readAllLines(local.root().resolve(\"heads.txt\"));\n+            assertEquals(List.of(current.hash().hex(), current.parents().get(0).hex()), heads);\n+        }\n+    }\n+\n+    @Test\n+    void updateIntegrityBranch() throws Exception {\n+        try (var dir = new TemporaryDirectory()) {\n+            var local = createLocalIntegrityRepo(dir);\n+            var remote = createRemoteIntegrityRepo(dir);\n+\n+            var repo = createRepo(dir);\n+            var current = createCommit(repo);\n+            var next = createCommit(repo);\n+\n+            var verifier = new IntegrityVerifier(local, remote.root().toUri());\n+\n+            verifier.verifyBranch(\"repo\", \"branch\", current);\n+            verifier.updateBranch(\"repo\", \"branch\", next);\n+\n+            \/\/ Next should now be \"current\", so should be able to verify\n+            verifier.verifyBranch(\"repo\", \"branch\", next);\n+\n+            var integrityBranch = new Branch(\"repo-branch\");\n+            assertTrue(remote.branches().contains(integrityBranch));\n+\n+            var head = local.fetch(remote.root().toUri(), integrityBranch.name());\n+            local.checkout(head);\n+            var heads = Files.readAllLines(local.root().resolve(\"heads.txt\"));\n+            assertEquals(List.of(next.hash().hex(), current.hash().hex()), heads);\n+        }\n+    }\n+\n+    @Test\n+    void recoverAbortedPush() throws Exception {\n+        try (var dir = new TemporaryDirectory()) {\n+            var local = createLocalIntegrityRepo(dir);\n+            var remote = createRemoteIntegrityRepo(dir);\n+\n+            var repo = createRepo(dir);\n+            var current = createCommit(repo);\n+            var next = createCommit(repo);\n+\n+            var verifier = new IntegrityVerifier(local, remote.root().toUri());\n+\n+            verifier.verifyBranch(\"repo\", \"branch\", current);\n+            verifier.updateBranch(\"repo\", \"branch\", next);\n+\n+            \/\/ Simulate a integration being aborted after updateBranch has been\n+            \/\/ called but before \"git push\" has been executed\n+            var unpushed = createCommit(repo);\n+            verifier.verifyBranch(\"repo\", \"branch\", next);\n+            verifier.updateBranch(\"repo\", \"branch\", unpushed);\n+\n+            \/\/ The verifier should now *not* throw when verifying next\n+            \/\/ (since next is the parent of unpushed)\n+            verifier.verifyBranch(\"repo\", \"branch\", next);\n+\n+            var integrityBranch = new Branch(\"repo-branch\");\n+            assertTrue(remote.branches().contains(integrityBranch));\n+\n+            var head = local.fetch(remote.root().toUri(), integrityBranch.name());\n+            local.checkout(head);\n+            var heads = Files.readAllLines(local.root().resolve(\"heads.txt\"));\n+            assertEquals(List.of(next.hash().hex(), current.hash().hex()), heads);\n+        }\n+    }\n+\n+    @Test\n+    void unexpectedTargetHeadThrows() throws Exception {\n+        try (var dir = new TemporaryDirectory()) {\n+            var local = createLocalIntegrityRepo(dir);\n+            var remote = createRemoteIntegrityRepo(dir);\n+\n+            var repo = createRepo(dir);\n+            var current = createCommit(repo);\n+            var next = createCommit(repo);\n+\n+            var verifier = new IntegrityVerifier(local, remote.root().toUri());\n+\n+            verifier.verifyBranch(\"repo\", \"branch\", current);\n+            verifier.updateBranch(\"repo\", \"branch\", next);\n+\n+            var unexpected = createCommit(repo);\n+            assertThrows(IllegalArgumentException.class,\n+                         () -> { verifier.verifyBranch(\"repo\", \"branch\", unexpected); });\n+        }\n+    }\n+}\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/IntegrityTests.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.*;\n@@ -972,0 +973,99 @@\n+\n+    @Test\n+    void withIntegrityVerification(TestInfo testInfo) throws IOException {\n+        try (var credentials = new HostCredentials(testInfo);\n+             var tmp = new TemporaryDirectory()) {\n+            var author = credentials.getHostedRepository();\n+            var integrator = credentials.getHostedRepository();\n+            var reviewer = credentials.getHostedRepository();\n+            var integrity = credentials.getHostedRepository();\n+\n+            var censusBuilder = credentials.getCensusBuilder()\n+                                           .addReviewer(reviewer.forge().currentUser().id())\n+                                           .addAuthor(author.forge().currentUser().id());\n+            var bot = PullRequestBot.newBuilder()\n+                                    .repo(integrator)\n+                                    .censusRepo(censusBuilder.build())\n+                                    .integrityRepo(integrity)\n+                                    .build();\n+\n+            \/\/ Populate the projects repository\n+            var localRepo = CheckableRepository.init(tmp.path().resolve(\"local\"), author.repositoryType());\n+            var masterHash = localRepo.resolve(\"master\").orElseThrow();\n+            assertFalse(CheckableRepository.hasBeenEdited(localRepo));\n+            localRepo.push(masterHash, author.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Populate intergity repo\n+            var integrityPreDir = tmp.path().resolve(\"integrity-pre\");\n+            var localIntegrityPreRepo = CheckableRepository.init(integrityPreDir, integrity.repositoryType());\n+            var localIntegrityPreRepoMasterHash = localRepo.resolve(\"master\").orElseThrow();\n+            localIntegrityPreRepo.push(localIntegrityPreRepoMasterHash, integrity.authenticatedUrl(), \"master\", true);\n+\n+            \/\/ Make a change with a corresponding PR\n+            var authorFullName = author.forge().currentUser().fullName();\n+            var authorEmail = \"ta@none.none\";\n+            var editHash = CheckableRepository.appendAndCommit(localRepo, \"This is a new line\", \"Append commit\", authorFullName, authorEmail);\n+            localRepo.push(editHash, author.authenticatedUrl(), \"edit\", true);\n+            var pr = credentials.createPullRequest(author, \"master\", \"edit\", \"This is a pull request\");\n+\n+            \/\/ Approve it as another user\n+            var approvalPr = reviewer.pullRequest(pr.id());\n+            approvalPr.addReview(Review.Verdict.APPROVED, \"Approved\");\n+\n+            \/\/ Let the bot see it\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ Issue a merge command without being a Committer\n+            pr.addComment(\"\/integrate\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should reply that a sponsor is required\n+            var sponsor = pr.comments().stream()\n+                            .filter(comment -> comment.body().contains(\"sponsor\"))\n+                            .filter(comment -> comment.body().contains(\"your change\"))\n+                            .count();\n+            assertEquals(1, sponsor);\n+\n+            \/\/ The bot should not have pushed the commit\n+            var notPushed = pr.comments().stream()\n+                              .filter(comment -> comment.body().contains(\"Pushed as commit\"))\n+                              .count();\n+            assertEquals(0, notPushed);\n+\n+            \/\/ Reviewer now agrees to sponsor\n+            var reviewerPr = reviewer.pullRequest(pr.id());\n+            reviewerPr.addComment(\"\/sponsor\");\n+            TestBotRunner.runPeriodicItems(bot);\n+\n+            \/\/ The bot should have pushed the commit\n+            var pushed = pr.comments().stream()\n+                           .filter(comment -> comment.body().contains(\"Pushed as commit\"))\n+                           .count();\n+            assertEquals(1, pushed);\n+\n+            \/\/ Ready label should have been removed\n+            assertFalse(pr.store().labelNames().contains(\"ready\"));\n+\n+            \/\/ The change should now be present on the master branch\n+            var pushedRepo = Repository.materialize(tmp.path().resolve(\"pushed\"), author.authenticatedUrl(), \"master\");\n+            var headHash = pushedRepo.resolve(\"HEAD\").orElseThrow();\n+            var headCommit = pushedRepo.commits(headHash.hex() + \"^..\" + headHash.hex()).asList().get(0);\n+\n+            assertEquals(\"Generated Author 2\", headCommit.author().name());\n+            assertEquals(\"integrationauthor2@openjdk.org\", headCommit.author().email());\n+\n+            assertEquals(\"Generated Reviewer 1\", headCommit.committer().name());\n+            assertEquals(\"integrationreviewer1@openjdk.org\", headCommit.committer().email());\n+            assertTrue(pr.store().labelNames().contains(\"integrated\"));\n+            assertFalse(pr.store().labelNames().contains(\"ready\"));\n+            assertFalse(pr.store().labelNames().contains(\"sponsor\"));\n+\n+            \/\/ Integrity repo should have been updated\n+            var integrityPostDir = tmp.path().resolve(\"integrity-post\");\n+            var localIntegrityPostRepo = Repository.materialize(integrityPostDir,\n+                                                                integrity.authenticatedUrl(),\n+                                                                author.name() + \"-master\");\n+            var heads = Files.readAllLines(localIntegrityPostRepo.root().resolve(\"heads.txt\"));\n+            assertEquals(List.of(headHash.hex(), masterHash.hex()), heads);\n+        }\n+    }\n","filename":"bots\/pr\/src\/test\/java\/org\/openjdk\/skara\/bots\/pr\/SponsorTests.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.net.URI;\n@@ -151,0 +152,3 @@\n+    default List<Reference> remoteBranches(URI uri) throws IOException {\n+        return remoteBranches(uri.toString());\n+    }\n","filename":"vcs\/src\/main\/java\/org\/openjdk\/skara\/vcs\/ReadOnlyRepository.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}