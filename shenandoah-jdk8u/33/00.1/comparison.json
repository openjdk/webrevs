{"files":[{"patch":"@@ -86,0 +86,5 @@\n+#if INCLUDE_ALL_GCS\n+#include \"gc_implementation\/shenandoah\/shenandoahForwarding.hpp\"\n+#include \"gc_implementation\/shenandoah\/c2\/shenandoahSupport.hpp\"\n+#endif\n+\n@@ -408,0 +413,5 @@\n+    if (n->Opcode() == Op_AddP && CallLeafNode::has_only_g1_wb_pre_uses(n)) {\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        record_for_igvn(n->fast_out(i));\n+      }\n+    }\n@@ -430,0 +440,6 @@\n+  for (int i = C->shenandoah_barriers_count()-1; i >= 0; i--) {\n+    ShenandoahLoadReferenceBarrierNode* n = C->shenandoah_barrier(i);\n+    if (!useful.member(n)) {\n+      remove_shenandoah_barrier(n);\n+    }\n+  }\n@@ -773,1 +789,1 @@\n-      if (method()->intrinsic_id() == vmIntrinsics::_Reference_get && UseG1GC) {\n+      if (method()->intrinsic_id() == vmIntrinsics::_Reference_get && (UseG1GC || UseShenandoahGC)) {\n@@ -1166,0 +1182,1 @@\n+  _shenandoah_barriers = new(comp_arena()) GrowableArray<ShenandoahLoadReferenceBarrierNode*>(comp_arena(), 8,  0, NULL);\n@@ -2303,0 +2320,6 @@\n+#ifdef ASSERT\n+  if (UseShenandoahGC && ShenandoahVerifyOptoBarriers) {\n+    ShenandoahBarrierC2Support::verify(C->root());\n+  }\n+#endif\n+\n@@ -2312,0 +2335,6 @@\n+#if INCLUDE_ALL_GCS\n+  if (UseShenandoahGC) {\n+    ShenandoahBarrierC2Support::expand(this, igvn);\n+  }\n+#endif\n+\n@@ -2746,0 +2775,9 @@\n+    if (UseShenandoahGC && call->is_g1_wb_pre_call()) {\n+      uint cnt = OptoRuntime::g1_wb_pre_Type()->domain()->cnt();\n+      if (call->req() > cnt) {\n+        assert(call->req() == cnt+1, \"only one extra input\");\n+        Node* addp = call->in(cnt);\n+        assert(!CallLeafNode::has_only_g1_wb_pre_uses(addp), \"useless address computation?\");\n+        call->del_req(cnt);\n+      }\n+    }\n@@ -2889,3 +2927,32 @@\n-#ifdef _LP64\n-  case Op_CastPP:\n-    if (n->in(1)->is_DecodeN() && Matcher::gen_narrow_oop_implicit_null_checks()) {\n+  case Op_CastPP: {\n+    \/\/ Remove CastPP nodes to gain more freedom during scheduling but\n+    \/\/ keep the dependency they encode as control or precedence edges\n+    \/\/ (if control is set already) on memory operations. Some CastPP\n+    \/\/ nodes don't have a control (don't carry a dependency): skip\n+    \/\/ those.\n+    if (n->in(0) != NULL) {\n+      ResourceMark rm;\n+      Unique_Node_List wq;\n+      wq.push(n);\n+      for (uint next = 0; next < wq.size(); ++next) {\n+        Node *m = wq.at(next);\n+        for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n+          Node* use = m->fast_out(i);\n+          if (use->is_Mem() || use->is_EncodeNarrowPtr() || use->Opcode() == Op_ShenandoahLoadReferenceBarrier) {\n+            use->ensure_control_or_add_prec(n->in(0));\n+          } else if (use->in(0) == NULL) {\n+            switch(use->Opcode()) {\n+            case Op_AddP:\n+            case Op_DecodeN:\n+            case Op_DecodeNKlass:\n+            case Op_CheckCastPP:\n+            case Op_CastPP:\n+              wq.push(use);\n+              break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n+    if (is_LP64 && n->in(1)->is_DecodeN() && Matcher::gen_narrow_oop_implicit_null_checks()) {\n@@ -2924,0 +2991,5 @@\n+    } else {\n+      n->subsume_by(n->in(1), this);\n+      if (n->outcnt() == 0) {\n+        n->disconnect_inputs(NULL, this);\n+      }\n@@ -2926,1 +2998,2 @@\n-\n+  }\n+#ifdef _LP64\n@@ -3194,0 +3267,3 @@\n+  case Op_ShenandoahLoadReferenceBarrier:\n+    assert(false, \"should have been expanded already\");\n+    break;\n@@ -3560,1 +3636,1 @@\n-  if (UseG1GC) {\n+  if (UseG1GC || UseShenandoahGC) {\n@@ -4084,1 +4160,1 @@\n-          assert(in_hash, \"node should be in igvn hash table\");\n+          assert(in_hash || n->hash() == Node::NO_HASH, \"node should be in igvn hash table\");\n@@ -4179,0 +4255,21 @@\n+\n+void Compile::shenandoah_eliminate_g1_wb_pre(Node* call, PhaseIterGVN* igvn) {\n+  assert(UseShenandoahGC && call->is_g1_wb_pre_call(), \"\");\n+  Node* c = call->as_Call()->proj_out(TypeFunc::Control);\n+  c = c->unique_ctrl_out();\n+  assert(c->is_Region() && c->req() == 3, \"where's the pre barrier control flow?\");\n+  c = c->unique_ctrl_out();\n+  assert(c->is_Region() && c->req() == 3, \"where's the pre barrier control flow?\");\n+  Node* iff = c->in(1)->is_IfProj() ? c->in(1)->in(0) : c->in(2)->in(0);\n+  assert(iff->is_If(), \"expect test\");\n+  if (!iff->is_shenandoah_marking_if(igvn)) {\n+    c = c->unique_ctrl_out();\n+    assert(c->is_Region() && c->req() == 3, \"where's the pre barrier control flow?\");\n+    iff = c->in(1)->is_IfProj() ? c->in(1)->in(0) : c->in(2)->in(0);\n+    assert(iff->is_shenandoah_marking_if(igvn), \"expect marking test\");\n+  }\n+  Node* cmpx = iff->in(1)->in(1);\n+  igvn->replace_node(cmpx, igvn->makecon(TypeInt::CC_EQ));\n+  igvn->rehash_node_delayed(call);\n+  call->del_req(call->req()-1);\n+}\n","filename":"hotspot\/src\/share\/vm\/opto\/compile.cpp","additions":104,"deletions":7,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+class ShenandoahLoadReferenceBarrierNode;\n@@ -341,0 +342,1 @@\n+  GrowableArray<ShenandoahLoadReferenceBarrierNode*>* _shenandoah_barriers;\n@@ -347,0 +349,1 @@\n+\n@@ -669,0 +672,1 @@\n+  int           shenandoah_barriers_count()         const { return _shenandoah_barriers->length(); }\n@@ -672,0 +676,1 @@\n+  ShenandoahLoadReferenceBarrierNode* shenandoah_barrier(int idx)   const { return _shenandoah_barriers->at(idx); }\n@@ -695,0 +700,9 @@\n+  void add_shenandoah_barrier(ShenandoahLoadReferenceBarrierNode * n) {\n+    assert(!_shenandoah_barriers->contains(n), \"duplicate entry in barrier list\");\n+    _shenandoah_barriers->append(n);\n+  }\n+  void remove_shenandoah_barrier(ShenandoahLoadReferenceBarrierNode * n) {\n+    if (_shenandoah_barriers->contains(n)) {\n+      _shenandoah_barriers->remove(n);\n+    }\n+  }\n@@ -727,0 +741,2 @@\n+  GrowableArray<ShenandoahLoadReferenceBarrierNode*>* shenandoah_barriers() { return _shenandoah_barriers; }\n+\n@@ -1226,0 +1242,2 @@\n+\n+  void shenandoah_eliminate_g1_wb_pre(Node* call, PhaseIterGVN* igvn);\n","filename":"hotspot\/src\/share\/vm\/opto\/compile.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+#if INCLUDE_ALL_GCS\n+#include \"gc_implementation\/shenandoah\/c2\/shenandoahSupport.hpp\"\n+#endif\n@@ -1027,0 +1030,3 @@\n+            if (n->is_MemBar() && UseShenandoahGC) {\n+              m->as_MachMemBar()->set_adr_type(n->adr_type());\n+            }\n@@ -1071,0 +1077,9 @@\n+      \/\/ Handle precedence edges for interior nodes\n+      for (i = n->len()-1; (uint)i >= n->req(); i--) {\n+        Node *m = n->in(i);\n+        if (m == NULL || C->node_arena()->contains(m)) continue;\n+        n->rm_prec(i);\n+        \/\/ set -1 to call add_prec() instead of set_req() during Step1\n+        mstack.push(m, Visit, n, -1);\n+      }\n+\n@@ -1761,0 +1776,8 @@\n+void Matcher::handle_precedence_edges(Node* n, MachNode *mach) {\n+  for (uint i = n->req(); i < n->len(); i++) {\n+    if (n->in(i) != NULL) {\n+      mach->add_prec(n->in(i));\n+    }\n+  }\n+}\n+\n@@ -1795,0 +1818,2 @@\n+  handle_precedence_edges(s->_leaf, mach);\n+\n@@ -1877,0 +1902,3 @@\n+\n+  handle_precedence_edges(s->_leaf, mach);\n+\n","filename":"hotspot\/src\/share\/vm\/opto\/matcher.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}