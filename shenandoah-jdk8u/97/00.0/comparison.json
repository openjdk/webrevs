{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -947,0 +947,8 @@\n+\/\/ Check if addition of a long with type 't' and a constant 'c' can overflow.\n+static bool can_overflow(const TypeLong* t, jlong c) {\n+  jlong t_lo = t->_lo;\n+  jlong t_hi = t->_hi;\n+  return ((c < 0 && (java_add(t_lo, c) > t_lo)) ||\n+          (c > 0 && (java_add(t_hi, c) < t_hi)));\n+}\n+\n@@ -1058,0 +1066,25 @@\n+\/\/\n+\/\/ Proof MaxL collapsed version equivalent to original (MinL version similar):\n+\/\/ is_sub_con ensures that con1, con2 ∈ [min_int, 0[\n+\/\/\n+\/\/ Original:\n+\/\/ - AddL2 underflow => x + con2 ∈ ]max_long - min_int, max_long], ALWAYS BAILOUT as x + con1 + con2 surely fails can_overflow (*)\n+\/\/ - AddL2 no underflow => x + con2 ∈ [min_long, max_long]\n+\/\/   - MaxL2 clamp => min_int\n+\/\/     - AddL1 underflow: NOT POSSIBLE: cannot underflow since min_int + con1 ∈ [2 * min_int, min_int] always > min_long\n+\/\/     - AddL1 no underflow => min_int + con1 ∈ [2 * min_int, min_int]\n+\/\/       - MaxL1 clamp => min_int (RESULT 1)\n+\/\/       - MaxL1 no clamp: NOT POSSIBLE: min_int + con1 ∈ [2 * min_int, min_int] always <= min_int, so clamp always taken\n+\/\/   - MaxL2 no clamp => x + con2 ∈ [min_int, max_long]\n+\/\/     - AddL1 underflow: NOT POSSIBLE: cannot underflow since x + con2 + con1 ∈ [2 * min_int, max_long] always > min_long\n+\/\/     - AddL1 no underflow => x + con2 + con1 ∈ [2 * min_int, max_long]\n+\/\/       - MaxL1 clamp => min_int (RESULT 2)\n+\/\/       - MaxL1 no clamp => x + con2 + con1 ∈ ]min_int, max_long] (RESULT 3)\n+\/\/\n+\/\/ Collapsed:\n+\/\/ - AddL2 (cannot underflow) => con2 + con1 ∈ [2 * min_int, 0]\n+\/\/   - AddL1 underflow: NOT POSSIBLE: would have bailed out at can_overflow (*)\n+\/\/   - AddL1 no underflow => x + con2 + con1 ∈ [min_long, max_long]\n+\/\/     - MaxL clamp => min_int (RESULT 1 and RESULT 2)\n+\/\/     - MaxL no clamp => x + con2 + con1 ∈ ]min_int, max_long] (RESULT 3)\n+\/\/\n@@ -1089,0 +1122,4 @@\n+          \/\/ Collapsed graph not equivalent if potential over\/underflow -> bailing out (*)\n+          if (can_overflow(phase->type(x)->is_long(), con1->get_long() + con2->get_long())) {\n+            return NULL;\n+          }\n","filename":"hotspot\/src\/share\/vm\/opto\/addnode.cpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"}]}