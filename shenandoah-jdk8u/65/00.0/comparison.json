{"files":[{"patch":"@@ -909,0 +909,40 @@\n+    \/\/\n+    \/\/ Example:\n+    \/\/ a[i+x] \/\/ (1) 1 < x < 6\n+    \/\/ a[i+3] \/\/ (2)\n+    \/\/ a[i+4] \/\/ (3)\n+    \/\/ a[i+6] \/\/ max = max of all constants\n+    \/\/ a[i+2]\n+    \/\/ a[i+1] \/\/ min = min of all constants\n+    \/\/\n+    \/\/ If x < 3:\n+    \/\/   (1) a[i+x]: Leave unchanged\n+    \/\/   (2) a[i+3]: Replace with a[i+max] = a[i+6]: i+x < i+3 <= i+6  -> (2) is covered\n+    \/\/   (3) a[i+4]: Replace with a[i+min] = a[i+1]: i+1 < i+4 <= i+6  -> (3) and all following checks are covered\n+    \/\/   Remove all other a[i+c] checks\n+    \/\/\n+    \/\/ If x >= 3:\n+    \/\/   (1) a[i+x]: Leave unchanged\n+    \/\/   (2) a[i+3]: Replace with a[i+min] = a[i+1]: i+1 < i+3 <= i+x  -> (2) is covered\n+    \/\/   (3) a[i+4]: Replace with a[i+max] = a[i+6]: i+1 < i+4 <= i+6  -> (3) and all following checks are covered\n+    \/\/   Remove all other a[i+c] checks\n+    \/\/\n+    \/\/ We only need the top 2 range checks if x is the min or max of all constants.\n+    \/\/\n+    \/\/ This, however, only works if the interval [i+min,i+max] is not larger than max_int (i.e. abs(max - min) < max_int):\n+    \/\/ The theoretical max size of an array is max_int with:\n+    \/\/ - Valid index space: [0,max_int-1]\n+    \/\/ - Invalid index space: [max_int,-1] \/\/ max_int, min_int, min_int - 1 ..., -1\n+    \/\/\n+    \/\/ The size of the consecutive valid index space is smaller than the size of the consecutive invalid index space.\n+    \/\/ If we choose min and max in such a way that:\n+    \/\/ - abs(max - min) < max_int\n+    \/\/ - i+max and i+min are inside the valid index space\n+    \/\/ then all indices [i+min,i+max] must be in the valid index space. Otherwise, the invalid index space must be\n+    \/\/ smaller than the valid index space which is never the case for any array size.\n+    \/\/\n+    \/\/ Choosing a smaller array size only makes the valid index space smaller and the invalid index space larger and\n+    \/\/ the argument above still holds.\n+    \/\/\n+    \/\/ Note that the same optimization with the same maximal accepted interval size can also be found in C1.\n+    const jlong maximum_number_of_min_max_interval_indices = (jlong)max_jint;\n@@ -942,7 +982,12 @@\n-          \/\/ Gather expanded bounds\n-          off_lo = MIN2(off_lo,offset2);\n-          off_hi = MAX2(off_hi,offset2);\n-          \/\/ Record top NRC range checks\n-          prev_checks[nb_checks%NRC].ctl = prev_dom;\n-          prev_checks[nb_checks%NRC].off = offset2;\n-          nb_checks++;\n+\n+          \/\/ \"x - y\" -> must add one to the difference for number of elements in [x,y]\n+          const jlong diff = (jlong)MIN2(offset2, off_lo) - (jlong)MAX2(offset2, off_hi);\n+          if (ABS(diff) < maximum_number_of_min_max_interval_indices) {\n+            \/\/ Gather expanded bounds\n+            off_lo = MIN2(off_lo, offset2);\n+            off_hi = MAX2(off_hi, offset2);\n+            \/\/ Record top NRC range checks\n+            prev_checks[nb_checks % NRC].ctl = prev_dom;\n+            prev_checks[nb_checks % NRC].off = offset2;\n+            nb_checks++;\n+          }\n","filename":"hotspot\/src\/share\/vm\/opto\/ifnode.cpp","additions":52,"deletions":7,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -267,0 +267,43 @@\n+void PhaseIdealLoop::insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol) {\n+  Node* new_predicate_proj = create_new_if_for_predicate(limit_check_proj, NULL,\n+                                                         Deoptimization::Reason_loop_limit_check);\n+  Node* iff = new_predicate_proj->in(0);\n+  assert(iff->Opcode() == Op_If, \"bad graph shape\");\n+  Node* conv = iff->in(1);\n+  assert(conv->Opcode() == Op_Conv2B, \"bad graph shape\");\n+  Node* opaq = conv->in(1);\n+  assert(opaq->Opcode() == Op_Opaque1, \"bad graph shape\");\n+  cmp_limit = _igvn.register_new_node_with_optimizer(cmp_limit);\n+  bol = _igvn.register_new_node_with_optimizer(bol);\n+  set_subtree_ctrl(bol);\n+  _igvn.replace_input_of(iff, 1, bol);\n+\n+#ifndef PRODUCT\n+  \/\/ report that the loop predication has been actually performed\n+  \/\/ for this loop\n+  if (TraceLoopLimitCheck) {\n+    tty->print_cr(\"Counted Loop Limit Check generated:\");\n+    debug_only( bol->dump(2); )\n+  }\n+#endif\n+}\n+\n+static int check_stride_overflow(jlong final_correction, const TypeInt* limit_t) {\n+  if (final_correction > 0) {\n+    if (limit_t->_lo > (max_jint - final_correction)) {\n+      return -1;\n+    }\n+    if (limit_t->_hi > (max_jint - final_correction)) {\n+      return 1;\n+    }\n+  } else {\n+    if (limit_t->_hi < (min_jint - final_correction)) {\n+      return -1;\n+    }\n+    if (limit_t->_lo < (min_jint - final_correction)) {\n+      return 1;\n+    }\n+  }\n+  return 0;\n+}\n+\n@@ -470,1 +513,1 @@\n-  Node *hook = new (C) Node(6);\n+  Node* adjusted_limit = limit;\n@@ -475,2 +518,6 @@\n-  \/\/ Generate loop limit check to avoid integer overflow\n-  \/\/ in cases like next (cyclic loops):\n+  \/\/ We can only convert this loop to a counted loop if we can guarantee that the iv phi will never overflow at runtime.\n+  \/\/ This is an implicit assumption taken by some loop optimizations. We therefore must ensure this property at all cost.\n+  \/\/ At this point, we've already excluded some trivial cases where an overflow could have been proven statically.\n+  \/\/ But even though we cannot prove that an overflow will *not* happen, we still want to speculatively convert this loop\n+  \/\/ to a counted loop. This can be achieved by adding additional iv phi overflow checks before the loop. If they fail,\n+  \/\/ we trap and resume execution before the loop without having executed any iteration of the loop, yet.\n@@ -478,2 +525,3 @@\n-  \/\/ for (i=0; i <= max_jint; i++) {}\n-  \/\/ for (i=0; i <  max_jint; i+=2) {}\n+  \/\/ These additional iv phi overflow checks can be inserted as Loop Limit Check Predicates above the Loop Limit Check\n+  \/\/ Parse Predicate which captures a JVM state just before the entry of the loop. If there is no such Parse Predicate,\n+  \/\/ we cannot generate a Loop Limit Check Predicate and thus cannot speculatively convert the loop to a counted loop.\n@@ -481,0 +529,2 @@\n+  \/\/ In the following, we only focus on int loops with stride > 0 to keep things simple. The argumentation and proof\n+  \/\/ for stride < 0 is analogously. For long loops, we would replace max_int with max_long.\n@@ -482,4 +532,1 @@\n-  \/\/ Limit check predicate depends on the loop test:\n-  \/\/ for(;i != limit; i++)       --> limit <= (max_jint)\n-  \/\/ for(;i <  limit; i+=stride) --> limit <= (max_jint - stride + 1)\n-  \/\/ for(;i <= limit; i+=stride) --> limit <= (max_jint - stride    )\n+  \/\/ The loop to be converted does not always need to have the often used shape:\n@@ -488,0 +535,187 @@\n+  \/\/                                                 i = init\n+  \/\/     i = init                                loop:\n+  \/\/     do {                                        ...\n+  \/\/         \/\/ ...               equivalent         i+=stride\n+  \/\/         i+=stride               <==>            if (i < limit)\n+  \/\/     } while (i < limit);                          goto loop\n+  \/\/                                             exit:\n+  \/\/                                                 ...\n+  \/\/\n+  \/\/ where the loop exit check uses the post-incremented iv phi and a '<'-operator.\n+  \/\/\n+  \/\/ We could also have '<='-operator (or '>='-operator for negative strides) or use the pre-incremented iv phi value\n+  \/\/ in the loop exit check:\n+  \/\/\n+  \/\/         i = init\n+  \/\/     loop:\n+  \/\/         ...\n+  \/\/         if (i <= limit)\n+  \/\/             i+=stride\n+  \/\/             goto loop\n+  \/\/     exit:\n+  \/\/         ...\n+  \/\/\n+  \/\/ Let's define the following terms:\n+  \/\/ - iv_pre_i: The pre-incremented iv phi before the i-th iteration.\n+  \/\/ - iv_post_i: The post-incremented iv phi after the i-th iteration.\n+  \/\/\n+  \/\/ The iv_pre_i and iv_post_i have the following relation:\n+  \/\/      iv_pre_i + stride = iv_post_i\n+  \/\/\n+  \/\/ When converting a loop to a counted loop, we want to have a canonicalized loop exit check of the form:\n+  \/\/     iv_post_i < adjusted_limit\n+  \/\/\n+  \/\/ If that is not the case, we need to canonicalize the loop exit check by using different values for adjusted_limit:\n+  \/\/ (LE1) iv_post_i < limit: Already canonicalized. We can directly use limit as adjusted_limit.\n+  \/\/           -> adjusted_limit = limit.\n+  \/\/ (LE2) iv_post_i <= limit:\n+  \/\/           iv_post_i < limit + 1\n+  \/\/           -> adjusted limit = limit + 1\n+  \/\/ (LE3) iv_pre_i < limit:\n+  \/\/           iv_pre_i + stride < limit + stride\n+  \/\/           iv_post_i < limit + stride\n+  \/\/           -> adjusted_limit = limit + stride\n+  \/\/ (LE4) iv_pre_i <= limit:\n+  \/\/           iv_pre_i < limit + 1\n+  \/\/           iv_pre_i + stride < limit + stride + 1\n+  \/\/           iv_post_i < limit + stride + 1\n+  \/\/           -> adjusted_limit = limit + stride + 1\n+  \/\/\n+  \/\/ Note that:\n+  \/\/     (AL) limit <= adjusted_limit.\n+  \/\/\n+  \/\/ The following loop invariant has to hold for counted loops with n iterations (i.e. loop exit check true after n-th\n+  \/\/ loop iteration) and a canonicalized loop exit check to guarantee that no iv_post_i over- or underflows:\n+  \/\/ (INV) For i = 1..n, min_int <= iv_post_i <= max_int\n+  \/\/\n+  \/\/ To prove (INV), we require the following two conditions\/assumptions:\n+  \/\/ (i): adjusted_limit - 1 + stride <= max_int\n+  \/\/ (ii): init < limit\n+  \/\/\n+  \/\/ If we can prove (INV), we know that there can be no over- or underflow of any iv phi value. We prove (INV) by\n+  \/\/ induction by assuming (i) and (ii).\n+  \/\/\n+  \/\/ Proof by Induction\n+  \/\/ ------------------\n+  \/\/ > Base case (i = 1): We show that (INV) holds after the first iteration:\n+  \/\/     min_int <= iv_post_1 = init + stride <= max_int\n+  \/\/ Proof:\n+  \/\/     First, we note that (ii) implies\n+  \/\/         (iii) init <= limit - 1\n+  \/\/     max_int >= adjusted_limit - 1 + stride   [using (i)]\n+  \/\/             >= limit - 1 + stride            [using (AL)]\n+  \/\/             >= init + stride                 [using (iii)]\n+  \/\/             >= min_int                       [using stride > 0, no underflow]\n+  \/\/ Thus, no overflow happens after the first iteration and (INV) holds for i = 1.\n+  \/\/\n+  \/\/ Note that to prove the base case we need (i) and (ii).\n+  \/\/\n+  \/\/ > Induction Hypothesis (i = j, j > 1): Assume that (INV) holds after the j-th iteration:\n+  \/\/     min_int <= iv_post_j <= max_int\n+  \/\/ > Step case (i = j + 1): We show that (INV) also holds after the j+1-th iteration:\n+  \/\/     min_int <= iv_post_{j+1} = iv_post_j + stride <= max_int\n+  \/\/ Proof:\n+  \/\/ If iv_post_j >= adjusted_limit:\n+  \/\/     We exit the loop after the j-th iteration, and we don't execute the j+1-th iteration anymore. Thus, there is\n+  \/\/     also no iv_{j+1}. Since (INV) holds for iv_j, there is nothing left to prove.\n+  \/\/ If iv_post_j < adjusted_limit:\n+  \/\/     First, we note that:\n+  \/\/         (iv) iv_post_j <= adjusted_limit - 1\n+  \/\/     max_int >= adjusted_limit - 1 + stride    [using (i)]\n+  \/\/             >= iv_post_j + stride             [using (iv)]\n+  \/\/             >= min_int                        [using stride > 0, no underflow]\n+  \/\/\n+  \/\/ Note that to prove the step case we only need (i).\n+  \/\/\n+  \/\/ Thus, by assuming (i) and (ii), we proved (INV).\n+  \/\/\n+  \/\/\n+  \/\/ It is therefore enough to add the following two Loop Limit Check Predicates to check assumptions (i) and (ii):\n+  \/\/\n+  \/\/ (1) Loop Limit Check Predicate for (i):\n+  \/\/     Using (i): adjusted_limit - 1 + stride <= max_int\n+  \/\/\n+  \/\/     This condition is now restated to use limit instead of adjusted_limit:\n+  \/\/\n+  \/\/     To prevent an overflow of adjusted_limit -1 + stride itself, we rewrite this check to\n+  \/\/         max_int - stride + 1 >= adjusted_limit\n+  \/\/     We can merge the two constants into\n+  \/\/         canonicalized_correction = stride - 1\n+  \/\/     which gives us\n+  \/\/        max_int - canonicalized_correction >= adjusted_limit\n+  \/\/\n+  \/\/     To directly use limit instead of adjusted_limit in the predicate condition, we split adjusted_limit into:\n+  \/\/         adjusted_limit = limit + limit_correction\n+  \/\/     Since stride > 0 and limit_correction <= stride + 1, we can restate this with no over- or underflow into:\n+  \/\/         max_int - canonicalized_correction - limit_correction >= limit\n+  \/\/     Since canonicalized_correction and limit_correction are both constants, we can replace them with a new constant:\n+  \/\/         final_correction = canonicalized_correction + limit_correction\n+  \/\/     which gives us:\n+  \/\/\n+  \/\/     Final predicate condition:\n+  \/\/         max_int - final_correction >= limit\n+  \/\/\n+  \/\/ (2) Loop Limit Check Predicate for (ii):\n+  \/\/     Using (ii): init < limit\n+  \/\/\n+  \/\/     This Loop Limit Check Predicate is not required if we can prove at compile time that either:\n+  \/\/        (2.1) type(init) < type(limit)\n+  \/\/             In this case, we know:\n+  \/\/                 all possible values of init < all possible values of limit\n+  \/\/             and we can skip the predicate.\n+  \/\/\n+  \/\/        (2.2) init < limit is already checked before (i.e. found as a dominating check)\n+  \/\/            In this case, we do not need to re-check the condition and can skip the predicate.\n+  \/\/            This is often found for while- and for-loops which have the following shape:\n+  \/\/\n+  \/\/                if (init < limit) { \/\/ Dominating test. Do not need the Loop Limit Check Predicate below.\n+  \/\/                    i = init;\n+  \/\/                    if (init >= limit) { trap(); } \/\/ Here we would insert the Loop Limit Check Predicate\n+  \/\/                    do {\n+  \/\/                        i += stride;\n+  \/\/                    } while (i < limit);\n+  \/\/                }\n+  \/\/\n+  \/\/        (2.3) init + stride <= max_int\n+  \/\/            In this case, there is no overflow of the iv phi after the first loop iteration.\n+  \/\/            In the proof of the base case above we showed that init + stride <= max_int by using assumption (ii):\n+  \/\/                init < limit\n+  \/\/            In the proof of the step case above, we did not need (ii) anymore. Therefore, if we already know at\n+  \/\/            compile time that init + stride <= max_int then we have trivially proven the base case and that\n+  \/\/            there is no overflow of the iv phi after the first iteration. In this case, we don't need to check (ii)\n+  \/\/            again and can skip the predicate.\n+\n+\n+  \/\/ Accounting for (LE3) and (LE4) where we use pre-incremented phis in the loop exit check.\n+  const jlong limit_correction_for_pre_iv_exit_check = (phi_incr != NULL) ? stride_con : 0;\n+\n+  \/\/ Accounting for (LE2) and (LE4) where we use <= or >= in the loop exit check.\n+  const bool includes_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n+  const jlong limit_correction_for_le_ge_exit_check = (includes_limit ? (stride_con > 0 ? 1 : -1) : 0);\n+\n+  const jlong limit_correction = limit_correction_for_pre_iv_exit_check + limit_correction_for_le_ge_exit_check;\n+  const jlong canonicalized_correction = stride_con + (stride_con > 0 ? -1 : 1);\n+  const jlong final_correction = canonicalized_correction + limit_correction;\n+\n+  int sov = check_stride_overflow(final_correction, limit_t);\n+\n+  \/\/ If sov==0, limit's type always satisfies the condition, for\n+  \/\/ example, when it is an array length.\n+  if (sov != 0) {\n+    if (sov < 0) {\n+      return false;  \/\/ Bailout: integer overflow is certain.\n+    }\n+    \/\/ (1) Loop Limit Check Predicate is required because we could not statically prove that\n+    \/\/     limit + final_correction = adjusted_limit - 1 + stride <= max_int\n+    ProjNode *limit_check_proj = find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);\n+    if (!limit_check_proj) {\n+      \/\/ The Loop Limit Check Parse Predicate is not generated if this method trapped here before.\n+#ifdef ASSERT\n+      if (TraceLoopLimitCheck) {\n+        tty->print(\"missing loop limit check:\");\n+        loop->dump_head();\n+        x->dump(1);\n+      }\n+#endif\n+      return false;\n+    }\n@@ -489,11 +723,1 @@\n-  \/\/ Check if limit is excluded to do more precise int overflow check.\n-  bool incl_limit = (bt == BoolTest::le || bt == BoolTest::ge);\n-  int stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n-\n-  \/\/ If compare points directly to the phi we need to adjust\n-  \/\/ the compare so that it points to the incr. Limit have\n-  \/\/ to be adjusted to keep trip count the same and the\n-  \/\/ adjusted limit should be checked for int overflow.\n-  if (phi_incr != NULL) {\n-    stride_m  += stride_con;\n-  }\n+    IfNode* check_iff = limit_check_proj->in(0)->as_If();\n@@ -501,5 +725,1 @@\n-  if (limit->is_Con()) {\n-    int limit_con = limit->get_int();\n-    if ((stride_con > 0 && limit_con > (max_jint - stride_m)) ||\n-        (stride_con < 0 && limit_con < (min_jint - stride_m))) {\n-      \/\/ Bailout: it could be integer overflow.\n+    if (!is_dominator(get_ctrl(limit), check_iff->in(0))) {\n@@ -508,7 +728,35 @@\n-  } else if ((stride_con > 0 && limit_t->_hi <= (max_jint - stride_m)) ||\n-             (stride_con < 0 && limit_t->_lo >= (min_jint - stride_m))) {\n-      \/\/ Limit's type may satisfy the condition, for example,\n-      \/\/ when it is an array length.\n-  } else {\n-    \/\/ Generate loop's limit check.\n-    \/\/ Loop limit check predicate should be near the loop.\n+\n+    Node* cmp_limit;\n+    Node* bol;\n+\n+    if (stride_con > 0) {\n+      cmp_limit = new (C) CmpINode(limit, _igvn.intcon(max_jint - final_correction));\n+      bol = new (C) BoolNode(cmp_limit, BoolTest::le);\n+    } else {\n+      cmp_limit = new (C) CmpINode(limit, _igvn.intcon(min_jint - final_correction));\n+      bol = new (C) BoolNode(cmp_limit, BoolTest::ge);\n+    }\n+\n+    insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n+  }\n+\n+  \/\/ (2.3)\n+  const bool init_plus_stride_could_overflow =\n+          (stride_con > 0 && init_t->_hi > max_jint - stride_con) ||\n+          (stride_con < 0 && init_t->_lo < min_jint - stride_con);\n+  \/\/ (2.1)\n+  const bool init_gte_limit = (stride_con > 0 && init_t->_hi >= limit_t->_lo) ||\n+                              (stride_con < 0 && init_t->_lo <= limit_t->_hi);\n+\n+  if (init_gte_limit && \/\/ (2.1)\n+     ((bt == BoolTest::ne || init_plus_stride_could_overflow) && \/\/ (2.3)\n+      !has_dominating_loop_limit_check(init_trip, limit, stride_con, init_control))) { \/\/ (2.2)\n+    \/\/ (2) Iteration Loop Limit Check Predicate is required because neither (2.1), (2.2), nor (2.3) holds.\n+    \/\/ We use the following condition:\n+    \/\/ - stride > 0: init < limit\n+    \/\/ - stride < 0: init > limit\n+    \/\/\n+    \/\/ This predicate is always required if we have a non-equal-operator in the loop exit check (where stride = 1 is\n+    \/\/ a requirement). We transform the loop exit check by using a less-than-operator. By doing so, we must always\n+    \/\/ check that init < limit. Otherwise, we could have a different number of iterations at runtime.\n+\n@@ -527,1 +775,6 @@\n-\n+\n+    if (!is_dominator(get_ctrl(limit), check_iff->in(0)) ||\n+        !is_dominator(get_ctrl(init_trip), check_iff->in(0))) {\n+      return false;\n+    }\n+\n@@ -533,2 +786,2 @@\n-      cmp_limit = new (C) CmpINode(limit, _igvn.intcon(max_jint - stride_m));\n-      bol = new (C) BoolNode(cmp_limit, BoolTest::le);\n+      cmp_limit = new (C) CmpINode(init_trip, limit);\n+      bol = new (C) BoolNode(cmp_limit, BoolTest::lt);\n@@ -536,2 +789,2 @@\n-      cmp_limit = new (C) CmpINode(limit, _igvn.intcon(min_jint - stride_m));\n-      bol = new (C) BoolNode(cmp_limit, BoolTest::ge);\n+      cmp_limit = new (C) CmpINode(init_trip, limit);\n+      bol = new (C) BoolNode(cmp_limit, BoolTest::gt);\n@@ -539,20 +792,13 @@\n-    cmp_limit = _igvn.register_new_node_with_optimizer(cmp_limit);\n-    bol = _igvn.register_new_node_with_optimizer(bol);\n-    set_subtree_ctrl(bol);\n-\n-    \/\/ Replace condition in original predicate but preserve Opaque node\n-    \/\/ so that previous predicates could be found.\n-    assert(check_iff->in(1)->Opcode() == Op_Conv2B &&\n-           check_iff->in(1)->in(1)->Opcode() == Op_Opaque1, \"\");\n-    Node* opq = check_iff->in(1)->in(1);\n-    _igvn.hash_delete(opq);\n-    opq->set_req(1, bol);\n-    \/\/ Update ctrl.\n-    set_ctrl(opq, check_iff->in(0));\n-    set_ctrl(check_iff->in(1), check_iff->in(0));\n-#ifndef PRODUCT\n-    \/\/ report that the loop predication has been actually performed\n-    \/\/ for this loop\n-    if (TraceLoopLimitCheck) {\n-      tty->print_cr(\"Counted Loop Limit Check generated:\");\n-      debug_only( bol->dump(2); )\n+    insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n+  }\n+\n+  if (bt == BoolTest::ne) {\n+    \/\/ Now we need to canonicalize the loop condition if it is 'ne'.\n+    assert(stride_con == 1 || stride_con == -1, \"simple increment only - checked before\");\n+    if (stride_con > 0) {\n+      \/\/ 'ne' can be replaced with 'lt' only when init < limit. This is ensured by the inserted predicate above.\n+      bt = BoolTest::lt;\n+    } else {\n+      assert(stride_con < 0, \"must be\");\n+      \/\/ 'ne' can be replaced with 'gt' only when init > limit. This is ensured by the inserted predicate above.\n+      bt = BoolTest::gt;\n@@ -561,1 +807,0 @@\n-#endif\n@@ -574,1 +819,1 @@\n-    limit = gvn->transform(new (C) AddINode(limit, stride));\n+    adjusted_limit = gvn->transform(new (C) AddINode(limit, stride));\n@@ -577,12 +822,1 @@\n-  \/\/ Now we need to canonicalize loop condition.\n-  if (bt == BoolTest::ne) {\n-    assert(stride_con == 1 || stride_con == -1, \"simple increment only\");\n-    \/\/ 'ne' can be replaced with 'lt' only when init < limit.\n-    if (stride_con > 0 && init_t->_hi < limit_t->_lo)\n-      bt = BoolTest::lt;\n-    \/\/ 'ne' can be replaced with 'gt' only when init > limit.\n-    if (stride_con < 0 && init_t->_lo > limit_t->_hi)\n-      bt = BoolTest::gt;\n-  }\n-\n-  if (incl_limit) {\n+  if (includes_limit) {\n@@ -593,1 +827,1 @@\n-    limit = gvn->transform(new (C) AddINode(limit, one));\n+    adjusted_limit = gvn->transform(new (C) AddINode(adjusted_limit, one));\n@@ -601,1 +835,1 @@\n-  set_subtree_ctrl( limit );\n+  set_subtree_ctrl(adjusted_limit);\n@@ -605,0 +839,1 @@\n+  Node *hook = new (C) Node(6);\n@@ -698,0 +933,5 @@\n+  adjusted_limit = limit;\n+\n+  \/\/ Free up intermediate goo\n+  _igvn.remove_dead_node(hook);\n+\n@@ -735,1 +975,1 @@\n-  cmp->set_req(2,limit);\n+  cmp->set_req(2, adjusted_limit);\n@@ -809,3 +1049,0 @@\n-  \/\/ Free up intermediate goo\n-  _igvn.remove_dead_node(hook);\n-\n@@ -828,0 +1065,31 @@\n+\/\/ Check if there is a dominating loop limit check of the form 'init < limit' starting at the loop entry.\n+\/\/ If there is one, then we do not need to create an additional Loop Limit Check Predicate.\n+bool PhaseIdealLoop::has_dominating_loop_limit_check(Node* init_trip, Node* limit, const int stride_con,\n+                                                     Node* loop_entry) {\n+  \/\/ Eagerly call transform() on the Cmp and Bool node to common them up if possible. This is required in order to\n+  \/\/ successfully find a dominated test with the If node below.\n+  Node* cmp_limit;\n+  Node* bol;\n+  if (stride_con > 0) {\n+    cmp_limit = _igvn.transform(new (C) CmpINode(init_trip, limit));\n+    bol = _igvn.transform(new (C) BoolNode(cmp_limit, BoolTest::lt));\n+  } else {\n+    cmp_limit = _igvn.transform(new (C) CmpINode(init_trip, limit));\n+    bol = _igvn.transform(new (C) BoolNode(cmp_limit, BoolTest::gt));\n+  }\n+\n+  \/\/ Check if there is already a dominating init < limit check. If so, we do not need a Loop Limit Check Predicate.\n+  IfNode* iff = new (C) IfNode(loop_entry, bol, PROB_MIN, COUNT_UNKNOWN);\n+  \/\/ Also add fake IfProj nodes in order to call transform() on the newly created IfNode.\n+  IfFalseNode* if_false = new (C) IfFalseNode(iff);\n+  IfTrueNode* if_true = new (C) IfTrueNode(iff);\n+  Node* dominated_iff = _igvn.transform(iff);\n+  \/\/ ConI node? Found dominating test (IfNode::dominated_by() returns a ConI node).\n+  const bool found_dominating_test = dominated_iff != NULL && dominated_iff->Opcode() == Op_ConI;\n+\n+  \/\/ Kill the If with its projections again in the next IGVN round by cutting it off from the graph.\n+  _igvn.replace_input_of(iff, 0, C->top());\n+  _igvn.replace_input_of(iff, 1, C->top());\n+  return found_dominating_test;\n+}\n+\n","filename":"hotspot\/src\/share\/vm\/opto\/loopnode.cpp","additions":345,"deletions":77,"binary":false,"changes":422,"status":"modified"},{"patch":"@@ -904,0 +904,4 @@\n+  void insert_loop_limit_check(ProjNode* limit_check_proj, Node* cmp_limit, Node* bol);\n+  bool has_dominating_loop_limit_check(Node* init_trip, Node* limit, int stride_con,\n+                                       Node* loop_entry);\n+\n","filename":"hotspot\/src\/share\/vm\/opto\/loopnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}