{"files":[{"patch":"@@ -1227,1 +1227,1 @@\n-  int stride_p;\n+  jlong stride_p;\n@@ -1236,1 +1236,1 @@\n-    stride_p = -stride_con;\n+    stride_p = -(jlong)stride_con;\n@@ -1239,1 +1239,1 @@\n-    max = (julong)min_jint;\n+    max = (julong)(juint)min_jint; \/\/ double cast to get 0x0000000080000000, not 0xffffffff80000000\n","filename":"hotspot\/src\/share\/vm\/opto\/loopnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2320,1 +2320,5 @@\n-  _scale(0), _offset(0), _invar(NULL), _negate_invar(false) {\n+  _scale(0), _offset(0), _invar(NULL), _negate_invar(false),\n+  _has_int_index_after_convI2L(false),\n+  _int_index_after_convI2L_offset(0),\n+  _int_index_after_convI2L_invar(NULL),\n+  _int_index_after_convI2L_scale(0) {\n@@ -2353,1 +2357,1 @@\n-      \n+\n@@ -2370,0 +2374,6 @@\n+\n+  if (!is_safe_to_use_as_simple_form(base, adr)) {\n+    assert(!valid(), \"does not have simple form\");\n+    return;\n+  }\n+\n@@ -2379,1 +2389,348 @@\n-  _scale(0), _offset(0), _invar(NULL), _negate_invar(false) {}\n+  _scale(0), _offset(0), _invar(NULL), _negate_invar(false),\n+  _has_int_index_after_convI2L(false),\n+  _int_index_after_convI2L_offset(0),\n+  _int_index_after_convI2L_invar(NULL),\n+  _int_index_after_convI2L_scale(0) {}\n+\n+\/\/ We would like to make decisions about aliasing (i.e. removing memory edges) and adjacency\n+\/\/ (i.e. which loads\/stores can be packed) based on the simple form:\n+\/\/\n+\/\/   s_pointer = adr + offset + invar + scale * ConvI2L(iv)\n+\/\/\n+\/\/ However, we parse the compound-long-int form:\n+\/\/\n+\/\/   c_pointer = adr + long_offset + long_invar + long_scale * ConvI2L(int_index)\n+\/\/   int_index =       int_offset  + int_invar  + int_scale  * iv\n+\/\/\n+\/\/ In general, the simple and the compound-long-int form do not always compute the same pointer\n+\/\/ at runtime. For example, the simple form would give a different result due to an overflow\n+\/\/ in the int_index.\n+\/\/\n+\/\/ Example:\n+\/\/   For both forms, we have:\n+\/\/     iv = 0\n+\/\/     scale = 1\n+\/\/\n+\/\/   We now account the offset and invar once to the long part and once to the int part:\n+\/\/     Pointer 1 (long offset and long invar):\n+\/\/       long_offset = min_int\n+\/\/       long_invar  = min_int\n+\/\/       int_offset  = 0\n+\/\/       int_invar   = 0\n+\/\/\n+\/\/     Pointer 2 (int offset and int invar):\n+\/\/       long_offset = 0\n+\/\/       long_invar  = 0\n+\/\/       int_offset  = min_int\n+\/\/       int_invar   = min_int\n+\/\/\n+\/\/   This gives us the following pointers:\n+\/\/     Compound-long-int form pointers:\n+\/\/       Form:\n+\/\/         c_pointer   = adr + long_offset + long_invar + long_scale * ConvI2L(int_offset + int_invar + int_scale * iv)\n+\/\/\n+\/\/       Pointers:\n+\/\/         c_pointer1  = adr + min_int     + min_int    + 1          * ConvI2L(0          + 0         + 1         * 0)\n+\/\/                     = adr + min_int + min_int\n+\/\/                     = adr - 2^32\n+\/\/\n+\/\/         c_pointer2  = adr + 0           + 0          + 1          * ConvI2L(min_int    + min_int   + 1         * 0)\n+\/\/                     = adr + ConvI2L(min_int + min_int)\n+\/\/                     = adr + 0\n+\/\/                     = adr\n+\/\/\n+\/\/     Simple form pointers:\n+\/\/       Form:\n+\/\/         s_pointer  = adr + offset                     + invar                     + scale                    * ConvI2L(iv)\n+\/\/         s_pointer  = adr + (long_offset + int_offset) + (long_invar  + int_invar) + (long_scale * int_scale) * ConvI2L(iv)\n+\/\/\n+\/\/       Pointers:\n+\/\/         s_pointer1 = adr + (min_int     + 0         ) + (min_int     + 0        ) + 1                        * 0\n+\/\/                    = adr + min_int + min_int\n+\/\/                    = adr - 2^32\n+\/\/         s_pointer2 = adr + (0           + min_int   ) + (0           + min_int  ) + 1                        * 0\n+\/\/                    = adr + min_int + min_int\n+\/\/                    = adr - 2^32\n+\/\/\n+\/\/   We see that the two addresses are actually 2^32 bytes apart (derived from the c_pointers), but their simple form look identical.\n+\/\/\n+\/\/ Hence, we need to determine in which cases it is safe to make decisions based on the simple\n+\/\/ form, rather than the compound-long-int form. If we cannot prove that using the simple form\n+\/\/ is safe (i.e. equivalent to the compound-long-int form), then we do not get a valid SWPointer,\n+\/\/ and the associated memop cannot be vectorized.\n+bool SWPointer::is_safe_to_use_as_simple_form(Node* base, Node* adr) const {\n+#ifndef _LP64\n+  \/\/ On 32-bit platforms, there is never an explicit int_index with ConvI2L for the iv. Thus, the\n+  \/\/ parsed pointer form is always the simple form, with int operations:\n+  \/\/\n+  \/\/   pointer = adr + offset + invar + scale * iv\n+  \/\/\n+  assert(!_has_int_index_after_convI2L, \"32-bit never has an int_index with ConvI2L for the iv\");\n+  return true;\n+#else\n+\n+  \/\/ Array accesses that are not Unsafe always have a RangeCheck which ensures that there is no\n+  \/\/ int_index overflow. This implies that the conversion to long can be done separately:\n+  \/\/\n+  \/\/   ConvI2L(int_index) = ConvI2L(int_offset) + ConvI2L(int_invar) + ConvI2L(scale) * ConvI2L(iv)\n+  \/\/\n+  \/\/ And hence, the simple form is guaranteed to be identical to the compound-long-int form at\n+  \/\/ runtime and the SWPointer is safe\/valid to be used.\n+  const TypeAryPtr* ary_ptr_t = _mem->adr_type()->isa_aryptr();\n+\n+  \/\/ We did not find the int_index. Just to be safe, reject this SWPointer.\n+  if (!_has_int_index_after_convI2L) {\n+    return false;\n+  }\n+\n+  int int_offset  = _int_index_after_convI2L_offset;\n+  Node* int_invar = _int_index_after_convI2L_invar;\n+  int int_scale   = _int_index_after_convI2L_scale;\n+  int long_scale  = _scale \/ int_scale;\n+\n+  \/\/ If \"int_index = iv\", then the simple form is identical to the compound-long-int form.\n+  \/\/\n+  \/\/   int_index = int_offset + int_invar + int_scale * iv\n+  \/\/             = 0            0           1         * iv\n+  \/\/             =                                      iv\n+  if (int_offset == 0 && int_invar == NULL && int_scale == 1) {\n+    return true;\n+  }\n+\n+  \/\/ Intuition: What happens if the int_index overflows? Let us look at two pointers on the \"overflow edge\":\n+  \/\/\n+  \/\/              pointer1 = adr + ConvI2L(int_index1)\n+  \/\/              pointer2 = adr + ConvI2L(int_index2)\n+  \/\/\n+  \/\/              int_index1 = max_int + 0 = max_int  -> very close to but before the overflow\n+  \/\/              int_index2 = max_int + 1 = min_int  -> just enough to get the overflow\n+  \/\/\n+  \/\/            When looking at the difference of pointer1 and pointer2, we notice that it is very large\n+  \/\/            (almost 2^32). Since arrays have at most 2^31 elements, chances are high that pointer2 is\n+  \/\/            an actual out-of-bounds access at runtime. These would normally be prevented by range checks\n+  \/\/            at runtime. However, if the access was done by using Unsafe, where range checks are omitted,\n+  \/\/            then an out-of-bounds access constitutes undefined behavior. This means that we are allowed to\n+  \/\/            do anything, including changing the behavior.\n+  \/\/\n+  \/\/            If we can set the right conditions, we have a guarantee that an overflow is either impossible\n+  \/\/            (no overflow or range checks preventing that) or undefined behavior. In both cases, we are\n+  \/\/            safe to do a vectorization.\n+  \/\/\n+  \/\/ Approach:  We want to prove a lower bound for the distance between these two pointers, and an\n+  \/\/            upper bound for the size of a memory object. We can derive such an upper bound for\n+  \/\/            arrays. We know they have at most 2^31 elements. If we know the size of the elements\n+  \/\/            in bytes, we have:\n+  \/\/\n+  \/\/              array_element_size_in_bytes * 2^31 >= max_possible_array_size_in_bytes\n+  \/\/                                                 >= array_size_in_bytes                      (ARR)\n+  \/\/\n+  \/\/            If some small difference \"delta\" leads to an int_index overflow, we know that the\n+  \/\/            int_index1 before overflow must have been close to max_int, and the int_index2 after\n+  \/\/            the overflow must be close to min_int:\n+  \/\/\n+  \/\/              pointer1 =        adr + long_offset + long_invar + long_scale * ConvI2L(int_index1)\n+  \/\/                       =approx  adr + long_offset + long_invar + long_scale * max_int\n+  \/\/\n+  \/\/              pointer2 =        adr + long_offset + long_invar + long_scale * ConvI2L(int_index2)\n+  \/\/                       =approx  adr + long_offset + long_invar + long_scale * min_int\n+  \/\/\n+  \/\/            We realize that the pointer difference is very large:\n+  \/\/\n+  \/\/              difference =approx  long_scale * 2^32\n+  \/\/\n+  \/\/            Hence, if we set the right condition for long_scale and array_element_size_in_bytes,\n+  \/\/            we can prove that an overflow is impossible (or would imply undefined behaviour).\n+  \/\/\n+  \/\/ We must now take this intuition, and develop a rigorous proof. We start by stating the problem\n+  \/\/ more precisely, with the help of some definitions and the Statement we are going to prove.\n+  \/\/\n+  \/\/ Definition:\n+  \/\/   Two SWPointers are \"comparable\" (i.e. SWPointer::comparable is true, set with SWPointer::cmp()),\n+  \/\/   iff all of these conditions apply for the simple form:\n+  \/\/     1) Both SWPointers are valid.\n+  \/\/     2) The adr are identical, or both are array bases of different arrays.\n+  \/\/     3) They have identical scale.\n+  \/\/     4) They have identical invar.\n+  \/\/     5) The difference in offsets is limited: abs(offset1 - offset2) < 2^31.                 (DIFF)\n+  \/\/\n+  \/\/ For the Vectorization Optimization, we pair-wise compare SWPointers and determine if they are:\n+  \/\/   1) \"not comparable\":\n+  \/\/        We do not optimize them (assume they alias, not assume adjacency).\n+  \/\/\n+  \/\/        Whenever we chose this option based on the simple form, it is also correct based on the\n+  \/\/        compound-long-int form, since we make no optimizations based on it.\n+  \/\/\n+  \/\/   2) \"comparable\" with different array bases at runtime:\n+  \/\/        We assume they do not alias (remove memory edges), but not assume adjacency.\n+  \/\/\n+  \/\/        Whenever we have two different array bases for the simple form, we also have different\n+  \/\/        array bases for the compound-long-form. Since SWPointers provably point to different\n+  \/\/        memory objects, they can never alias.\n+  \/\/\n+  \/\/   3) \"comparable\" with the same base address:\n+  \/\/        We compute the relative pointer difference, and based on the load\/store size we can\n+  \/\/        compute aliasing and adjacency.\n+  \/\/\n+  \/\/        We must find a condition under which the pointer difference of the simple form is\n+  \/\/        identical to the pointer difference of the compound-long-form. We do this with the\n+  \/\/        Statement below, which we then proceed to prove.\n+  \/\/\n+  \/\/ Statement:\n+  \/\/   If two SWPointers satisfy these 3 conditions:\n+  \/\/     1) They are \"comparable\".\n+  \/\/     2) They have the same base address.\n+  \/\/     3) Their long_scale is a multiple of the array element size in bytes:\n+  \/\/\n+  \/\/          abs(long_scale) % array_element_size_in_bytes = 0                                     (A)\n+  \/\/\n+  \/\/   Then their pointer difference of the simple form is identical to the pointer difference\n+  \/\/   of the compound-long-int form.\n+  \/\/\n+  \/\/   More precisely:\n+  \/\/     Such two SWPointers by definition have identical adr, invar, and scale.\n+  \/\/     Their simple form is:\n+  \/\/\n+  \/\/       s_pointer1 = adr + offset1 + invar + scale * ConvI2L(iv)                                 (B1)\n+  \/\/       s_pointer2 = adr + offset2 + invar + scale * ConvI2L(iv)                                 (B2)\n+  \/\/\n+  \/\/     Thus, the pointer difference of the simple forms collapses to the difference in offsets:\n+  \/\/\n+  \/\/       s_difference = s_pointer1 - s_pointer2 = offset1 - offset2                               (C)\n+  \/\/\n+  \/\/     Their compound-long-int form for these SWPointer is:\n+  \/\/\n+  \/\/       c_pointer1 = adr + long_offset1 + long_invar1 + long_scale1 * ConvI2L(int_index1)        (D1)\n+  \/\/       int_index1 = int_offset1 + int_invar1 + int_scale1 * iv                                  (D2)\n+  \/\/\n+  \/\/       c_pointer2 = adr + long_offset2 + long_invar2 + long_scale2 * ConvI2L(int_index2)        (D3)\n+  \/\/       int_index2 = int_offset2 + int_invar2 + int_scale2 * iv                                  (D4)\n+  \/\/\n+  \/\/     And these are the offset1, offset2, invar and scale from the simple form (B1) and (B2):\n+  \/\/\n+  \/\/       offset1 = long_offset1 + long_scale1 * ConvI2L(int_offset1)                              (D5)\n+  \/\/       offset2 = long_offset2 + long_scale2 * ConvI2L(int_offset2)                              (D6)\n+  \/\/\n+  \/\/       invar   = long_invar1 + long_scale1 * ConvI2L(int_invar1)\n+  \/\/               = long_invar2 + long_scale2 * ConvI2L(int_invar2)                                (D7)\n+  \/\/\n+  \/\/       scale   = long_scale1 * ConvI2L(int_scale1)\n+  \/\/               = long_scale2 * ConvI2L(int_scale2)                                              (D8)\n+  \/\/\n+  \/\/     The pointer difference of the compound-long-int form is defined as:\n+  \/\/\n+  \/\/       c_difference = c_pointer1 - c_pointer2\n+  \/\/\n+  \/\/   Thus, the statement claims that for the two SWPointer we have:\n+  \/\/\n+  \/\/     s_difference = c_difference                                                                (Statement)\n+  \/\/\n+  \/\/ We prove the Statement with the help of a Lemma:\n+  \/\/\n+  \/\/ Lemma:\n+  \/\/   There is some integer x, such that:\n+  \/\/\n+  \/\/     c_difference = s_difference + array_element_size_in_bytes * x * 2^32                       (Lemma)\n+  \/\/\n+  \/\/ From condition (DIFF), we can derive:\n+  \/\/\n+  \/\/   abs(s_difference) < 2^31                                                                     (E)\n+  \/\/\n+  \/\/ Assuming the Lemma, we prove the Statement:\n+  \/\/   If \"x = 0\" (intuitively: the int_index does not overflow), then:\n+  \/\/     c_difference = s_difference\n+  \/\/     and hence the simple form computes the same pointer difference as the compound-long-int form.\n+  \/\/   If \"x != 0\" (intuitively: the int_index overflows), then:\n+  \/\/     abs(c_difference) >= abs(s_difference + array_element_size_in_bytes * x * 2^32)\n+  \/\/                       >= array_element_size_in_bytes * 2^32 - abs(s_difference)\n+  \/\/                                                               --  apply (E)  --\n+  \/\/                       >  array_element_size_in_bytes * 2^32 - 2^31\n+  \/\/                       >= array_element_size_in_bytes * 2^31\n+  \/\/                              --  apply (ARR)  --\n+  \/\/                       >= max_possible_array_size_in_bytes\n+  \/\/                       >= array_size_in_bytes\n+  \/\/\n+  \/\/     This shows that c_pointer1 and c_pointer2 have a distance that exceeds the maximum array size.\n+  \/\/     Thus, at least one of the two pointers must be outside of the array bounds. But we can assume\n+  \/\/     that out-of-bounds accesses do not happen. If they still do, it is undefined behavior. Hence,\n+  \/\/     we are allowed to do anything. We can also \"safely\" use the simple form in this case even though\n+  \/\/     it might not match the compound-long-int form at runtime.\n+  \/\/ QED Statement.\n+  \/\/\n+  \/\/ We must now prove the Lemma.\n+  \/\/\n+  \/\/ ConvI2L always truncates by some power of 2^32, i.e. there is some integer y such that:\n+  \/\/\n+  \/\/   ConvI2L(y1 + y2) = ConvI2L(y1) + ConvI2L(y2) + 2^32 * y                                  (F)\n+  \/\/\n+  \/\/ It follows, that there is an integer y1 such that:\n+  \/\/\n+  \/\/   ConvI2L(int_index1) =  ConvI2L(int_offset1 + int_invar1 + int_scale1 * iv)\n+  \/\/                          -- apply (F) --\n+  \/\/                       =  ConvI2L(int_offset1)\n+  \/\/                        + ConvI2L(int_invar1)\n+  \/\/                        + ConvI2L(int_scale1) * ConvI2L(iv)\n+  \/\/                        + y1 * 2^32                                                         (G)\n+  \/\/\n+  \/\/ Thus, we can write the compound-long-int form (D1) as:\n+  \/\/\n+  \/\/   c_pointer1 =   adr + long_offset1 + long_invar1 + long_scale1 * ConvI2L(int_index1)\n+  \/\/                  -- apply (G) --\n+  \/\/              =   adr\n+  \/\/                + long_offset1\n+  \/\/                + long_invar1\n+  \/\/                + long_scale1 * ConvI2L(int_offset1)\n+  \/\/                + long_scale1 * ConvI2L(int_invar1)\n+  \/\/                + long_scale1 * ConvI2L(int_scale1) * ConvI2L(iv)\n+  \/\/                + long_scale1 * y1 * 2^32                                                    (H)\n+  \/\/\n+  \/\/ And we can write the simple form as:\n+  \/\/\n+  \/\/   s_pointer1 =   adr + offset1 + invar + scale * ConvI2L(iv)\n+  \/\/                  -- apply (D5, D7, D8) --\n+  \/\/              =   adr\n+  \/\/                + long_offset1\n+  \/\/                + long_scale1 * ConvI2L(int_offset1)\n+  \/\/                + long_invar1\n+  \/\/                + long_scale1 * ConvI2L(int_invar1)\n+  \/\/                + long_scale1 * ConvI2L(int_scale1) * ConvI2L(iv)                            (K)\n+  \/\/\n+  \/\/ We now compute the pointer difference between the simple (K) and compound-long-int form (H).\n+  \/\/ Most terms cancel out immediately:\n+  \/\/\n+  \/\/   sc_difference1 = c_pointer1 - s_pointer1 = long_scale1 * y1 * 2^32                        (L)\n+  \/\/\n+  \/\/ Rearranging the equation (L), we get:\n+  \/\/\n+  \/\/   c_pointer1 = s_pointer1 + long_scale1 * y1 * 2^32                                         (M)\n+  \/\/\n+  \/\/ And since long_scale1 is a multiple of array_element_size_in_bytes, there is some integer\n+  \/\/ x1, such that (M) implies:\n+  \/\/\n+  \/\/   c_pointer1 = s_pointer1 + array_element_size_in_bytes * x1 * 2^32                         (N)\n+  \/\/\n+  \/\/ With an analogue equation for c_pointer2, we can now compute the pointer difference for\n+  \/\/ the compound-long-int form:\n+  \/\/\n+  \/\/   c_difference =  c_pointer1 - c_pointer2\n+  \/\/                   -- apply (N) --\n+  \/\/                =  s_pointer1 + array_element_size_in_bytes * x1 * 2^32\n+  \/\/                 -(s_pointer2 + array_element_size_in_bytes * x2 * 2^32)\n+  \/\/                   -- where \"x = x1 - x2\" --\n+  \/\/                =  s_pointer1 - s_pointer2 + array_element_size_in_bytes * x * 2^32\n+  \/\/                   -- apply (C) --\n+  \/\/                =  s_difference            + array_element_size_in_bytes * x * 2^32\n+  \/\/ QED Lemma.\n+  if (ary_ptr_t != NULL) {\n+    BasicType array_element_bt = ary_ptr_t->elem()->array_element_basic_type();\n+    if (is_java_primitive(array_element_bt)) {\n+      int array_element_size_in_bytes = type2aelembytes(array_element_bt);\n+      if (abs(long_scale) % array_element_size_in_bytes == 0) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  \/\/ General case: we do not know if it is safe to use the simple form.\n+  return false;\n+#endif\n+}\n@@ -2402,0 +2759,2 @@\n+      \/\/ (scale * iv) - (offset1 + invar1)\n+      \/\/ Subtraction handled via \"negate\" flag of \"offset_plus_k\".\n@@ -2404,2 +2763,20 @@\n-    if (scaled_iv(n->in(2)) && offset_plus_k(n->in(1))) {\n-      _scale *= -1;\n+    SWPointer tmp(this);\n+    if (tmp.scaled_iv(n->in(2)) && offset_plus_k(n->in(1))) {\n+      \/\/ (offset1 + invar1) - (scale * iv)\n+      \/\/ Subtraction handled explicitly below.\n+      assert(_scale == 0, \"shouldn't be set yet\");\n+      \/\/ _scale = -tmp._scale\n+      if (!try_MulI_no_overflow(-1, tmp._scale, _scale)) {\n+        return false; \/\/ mul overflow.\n+      }\n+      \/\/ _offset -= tmp._offset\n+      if (!try_SubI_no_overflow(_offset, tmp._offset, _offset)) {\n+        return false; \/\/ sub overflow.\n+      }\n+\n+      \/\/ SWPointer tmp does not have an integer part to be forwarded\n+      \/\/ (tmp._has_int_index_after_convI2L is false) because n is a SubI, all\n+      \/\/ nodes above must also be of integer type (ConvL2I is not handled\n+      \/\/ to allow a long) and ConvI2L (the only node that can add an integer\n+      \/\/ part) won't be present.\n+\n@@ -2433,1 +2810,3 @@\n-      _scale = 1 << n->in(2)->get_int();\n+      if (!try_LShiftI_no_overflow(1, n->in(2)->get_int(), _scale)) {\n+        return false; \/\/ shift overflow.\n+      }\n@@ -2436,1 +2815,1 @@\n-  } else if (opc == Op_ConvI2L) {\n+  } else if (opc == Op_ConvI2L && !has_iv()) {\n@@ -2442,1 +2821,39 @@\n-    if (scaled_iv_plus_offset(n->in(1))) {\n+\n+    \/\/ So far we have not found the iv yet, and are about to enter a ConvI2L subgraph,\n+    \/\/ which may be the int index (that might overflow) for the memory access, of the form:\n+    \/\/\n+    \/\/   int_index = int_offset + int_invar + int_scale * iv\n+    \/\/\n+    \/\/ If we simply continue parsing with the current SWPointer, then the int_offset and\n+    \/\/ int_invar simply get added to the long offset and invar. But for the checks in\n+    \/\/ SWPointer::is_safe_to_use_as_simple_form() we need to have explicit access to the\n+    \/\/ int_index. Thus, we must parse it explicitly here. For this, we use a temporary\n+    \/\/ SWPointer, to pattern match the int_index sub-expression of the address.\n+\n+    SWPointer tmp(this);\n+\n+    if (tmp.scaled_iv_plus_offset(n->in(1)) && tmp.has_iv()) {\n+      \/\/ We successfully matched an integer index, of the form:\n+      \/\/   int_index = int_offset + int_invar + int_scale * iv\n+      \/\/ Forward scale.\n+      assert(_scale == 0 && tmp._scale != 0, \"iv only found just now\");\n+      _scale = tmp._scale;\n+      \/\/ Accumulate offset.\n+      if (!try_AddI_no_overflow(_offset, tmp._offset, _offset)) {\n+        return false; \/\/ add overflow.\n+      }\n+      \/\/ Forward invariant if not already found.\n+      if (tmp._invar != NULL) {\n+        if (_invar != NULL) {\n+          return false;\n+        }\n+        _invar = tmp._invar;\n+        _negate_invar = tmp._negate_invar;\n+      }\n+      \/\/ Set info about the int_index:\n+      assert(!_has_int_index_after_convI2L, \"no previous int_index discovered\");\n+      _has_int_index_after_convI2L = true;\n+      _int_index_after_convI2L_offset = tmp._offset;\n+      _int_index_after_convI2L_invar  = tmp._invar;\n+      _int_index_after_convI2L_scale  = tmp._scale;\n+\n@@ -2453,3 +2870,21 @@\n-          int mult = 1 << n->in(2)->get_int();\n-          _scale   = tmp._scale  * mult;\n-          _offset += tmp._offset * mult;\n+          int shift = (int)(n->in(2)->get_int());\n+          \/\/ Accumulate scale.\n+          if (!try_LShiftI_no_overflow(tmp._scale, shift, _scale)) {\n+            return false; \/\/ shift overflow.\n+          }\n+          \/\/ Accumulate offset.\n+          jint shifted_offset = 0;\n+          if (!try_LShiftI_no_overflow(tmp._offset, shift, shifted_offset)) {\n+            return false; \/\/ shift overflow.\n+          }\n+          if (!try_AddI_no_overflow(_offset, shifted_offset, _offset)) {\n+            return false; \/\/ add overflow.\n+          }\n+\n+          \/\/ Forward info about the int_index:\n+          assert(!_has_int_index_after_convI2L, \"no previous int_index discovered\");\n+          _has_int_index_after_convI2L = tmp._has_int_index_after_convI2L;\n+          _int_index_after_convI2L_offset = tmp._int_index_after_convI2L_offset;\n+          _int_index_after_convI2L_invar  = tmp._int_index_after_convI2L_invar;\n+          _int_index_after_convI2L_scale  = tmp._int_index_after_convI2L_scale;\n+\n@@ -2470,1 +2905,3 @@\n-    _offset += negate ? -(n->get_int()) : n->get_int();\n+    if (!try_AddSubI_no_overflow(_offset, n->get_int(), negate, _offset)) {\n+      return false; \/\/ add\/sub overflow.\n+    }\n@@ -2478,1 +2915,3 @@\n-      _offset += negate ? -off : loff;\n+      if (!try_AddSubI_no_overflow(_offset, off, negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -2488,1 +2927,3 @@\n-      _offset += negate ? -(n->in(2)->get_int()) : n->in(2)->get_int();\n+      if (!try_AddSubI_no_overflow(_offset, n->in(2)->get_int(), negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -2491,1 +2932,3 @@\n-      _offset += negate ? -(n->in(1)->get_int()) : n->in(1)->get_int();\n+      if (!try_AddSubI_no_overflow(_offset, n->in(1)->get_int(), negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -2501,1 +2944,3 @@\n-      _offset += !negate ? -(n->in(2)->get_int()) : n->in(2)->get_int();\n+      if (!try_AddSubI_no_overflow(_offset, n->in(2)->get_int(), !negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -2504,1 +2949,3 @@\n-      _offset += negate ? -(n->in(1)->get_int()) : n->in(1)->get_int();\n+      if (!try_AddSubI_no_overflow(_offset, n->in(1)->get_int(), negate, _offset)) {\n+        return false; \/\/ add\/sub overflow.\n+      }\n@@ -2518,0 +2965,51 @@\n+bool SWPointer::try_AddI_no_overflow(jint offset1, jint offset2, jint& result) {\n+  jlong long_offset = java_add((jlong)(offset1), (jlong)(offset2));\n+  jint  int_offset  = java_add(        offset1,          offset2);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}\n+\n+bool SWPointer::try_SubI_no_overflow(jint offset1, jint offset2, jint& result) {\n+  jlong long_offset = java_subtract((jlong)(offset1), (jlong)(offset2));\n+  jint  int_offset  = java_subtract(        offset1,          offset2);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}\n+\n+bool SWPointer::try_AddSubI_no_overflow(jint offset1, jint offset2, bool is_sub, jint& result) {\n+  if (is_sub) {\n+    return try_SubI_no_overflow(offset1, offset2, result);\n+  } else {\n+    return try_AddI_no_overflow(offset1, offset2, result);\n+  }\n+}\n+\n+bool SWPointer::try_LShiftI_no_overflow(jint offset, int shift, jint& result) {\n+  if (shift < 0 || shift > 31) {\n+    return false;\n+  }\n+  jlong long_offset = java_shift_left((jlong)(offset), (julong)((jlong)(shift)));\n+  jint  int_offset  = java_shift_left(        offset,  (juint)((jint)(shift)));\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}\n+\n+bool SWPointer::try_MulI_no_overflow(jint offset1, jint offset2, jint& result) {\n+  jlong long_offset = java_multiply((jlong)(offset1), (jlong)(offset2));\n+  jint  int_offset  = java_multiply(        offset1,          offset2);\n+  if (long_offset != int_offset) {\n+    return false;\n+  }\n+  result = int_offset;\n+  return true;\n+}\n+\n","filename":"hotspot\/src\/share\/vm\/opto\/superword.cpp","additions":515,"deletions":17,"binary":false,"changes":532,"status":"modified"},{"patch":"@@ -456,0 +456,37 @@\n+\/\/\n+\/\/ We parse and represent pointers of the simple form:\n+\/\/\n+\/\/   pointer   = adr + offset + invar + scale * ConvI2L(iv)\n+\/\/\n+\/\/ Where:\n+\/\/\n+\/\/   adr: the base address of an array (base = adr)\n+\/\/        OR\n+\/\/        some address to off-heap memory (base = TOP)\n+\/\/\n+\/\/   offset: a constant offset\n+\/\/   invar:  a runtime variable, which is invariant during the loop\n+\/\/   scale:  scaling factor\n+\/\/   iv:     loop induction variable\n+\/\/\n+\/\/ But more precisely, we parse the composite-long-int form:\n+\/\/\n+\/\/   pointer   = adr + long_offset + long_invar + long_scale * ConvI2L(int_offset + inv_invar + int_scale * iv)\n+\/\/\n+\/\/   pointer   = adr + long_offset + long_invar + long_scale * ConvI2L(int_index)\n+\/\/   int_index =       int_offset  + int_invar  + int_scale  * iv\n+\/\/\n+\/\/ However, for aliasing and adjacency checks (e.g. SWPointer::cmp()) we always use the simple form to make\n+\/\/ decisions. Hence, we must make sure to only create a \"valid\" SWPointer if the optimisations based on the\n+\/\/ simple form produce the same result as the compound-long-int form would. Intuitively, this depends on\n+\/\/ if the int_index overflows, but the precise conditions are given in SWPointer::is_safe_to_use_as_simple_form().\n+\/\/\n+\/\/   ConvI2L(int_index) = ConvI2L(int_offset  + int_invar  + int_scale  * iv)\n+\/\/                      = Convi2L(int_offset) + ConvI2L(int_invar) + ConvI2L(int_scale) * ConvI2L(iv)\n+\/\/\n+\/\/   scale  = long_scale * ConvI2L(int_scale)\n+\/\/   offset = long_offset + long_scale * ConvI2L(int_offset)\n+\/\/   invar  = long_invar  + long_scale * ConvI2L(int_invar)\n+\/\/\n+\/\/   pointer   = adr + offset + invar + scale * ConvI2L(iv)\n+\/\/\n@@ -461,2 +498,3 @@\n-  Node* _base;         \/\/ NULL if unsafe nonheap reference\n-  Node* _adr;          \/\/ address pointer\n+  \/\/ Components of the simple form:\n+  Node* _base;               \/\/ Base address of an array OR NULL if some off-heap memory.\n+  Node* _adr;                \/\/ Same as _base if an array pointer OR some off-heap memory pointer.\n@@ -468,0 +506,7 @@\n+  \/\/ The int_index components of the compound-long-int form. Used to decide if it is safe to use the\n+  \/\/ simple form rather than the compound-long-int form that was parsed.\n+  bool  _has_int_index_after_convI2L;\n+  int   _int_index_after_convI2L_offset;\n+  Node* _int_index_after_convI2L_invar;\n+  int   _int_index_after_convI2L_scale;\n+\n@@ -484,0 +529,2 @@\n+  bool is_safe_to_use_as_simple_form(Node* base, Node* adr) const;\n+\n@@ -511,0 +558,28 @@\n+  \/\/ We compute if and how two SWPointers can alias at runtime, i.e. if the two addressed regions of memory can\n+  \/\/ ever overlap. There are essentially 3 relevant return states:\n+  \/\/  - NotComparable:  Synonymous to \"unknown aliasing\".\n+  \/\/                    We have no information about how the two SWPointers can alias. They could overlap, refer\n+  \/\/                    to another location in the same memory object, or point to a completely different object.\n+  \/\/                    -> Memory edge required. Aliasing unlikely but possible.\n+  \/\/\n+  \/\/  - Less \/ Greater: Synonymous to \"never aliasing\".\n+  \/\/                    The two SWPointers may point into the same memory object, but be non-aliasing (i.e. we\n+  \/\/                    know both address regions inside the same memory object, but these regions are non-\n+  \/\/                    overlapping), or the SWPointers point to entirely different objects.\n+  \/\/                    -> No memory edge required. Aliasing impossible.\n+  \/\/\n+  \/\/  - Equal:          Synonymous to \"overlap, or point to different memory objects\".\n+  \/\/                    The two SWPointers either overlap on the same memory object, or point to two different\n+  \/\/                    memory objects.\n+  \/\/                    -> Memory edge required. Aliasing likely.\n+  \/\/\n+  \/\/ In a future refactoring, we can simplify to two states:\n+  \/\/  - NeverAlias:     instead of Less \/ Greater\n+  \/\/  - MayAlias:       instead of Equal \/ NotComparable\n+  \/\/\n+  \/\/ Two SWPointer are \"comparable\" (Less \/ Greater \/ Equal), iff all of these conditions apply:\n+  \/\/   1) Both are valid, i.e. expressible in the compound-long-int or simple form.\n+  \/\/   2) The adr are identical, or both are array bases of different arrays.\n+  \/\/   3) They have identical scale.\n+  \/\/   4) They have identical invar.\n+  \/\/   5) The difference in offsets is limited: abs(offset0 - offset1) < 2^31.\n@@ -517,0 +592,5 @@\n+      jlong difference = abs(java_subtract((jlong)_offset, (jlong)q._offset));\n+      jlong max_diff = (jlong)1 << 31;\n+      if (difference >= max_diff) {\n+        return NotComparable;\n+      }\n@@ -533,0 +613,7 @@\n+\n+  static bool try_AddI_no_overflow(jint offset1, jint offset2, jint& result);\n+  static bool try_SubI_no_overflow(jint offset1, jint offset2, jint& result);\n+  static bool try_AddSubI_no_overflow(jint offset1, jint offset2, bool is_sub, jint& result);\n+  static bool try_LShiftI_no_overflow(jint offset1, int offset2, jint& result);\n+  static bool try_MulI_no_overflow(jint offset1, jint offset2, jint& result);\n+\n","filename":"hotspot\/src\/share\/vm\/opto\/superword.hpp","additions":89,"deletions":2,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1289,0 +1289,36 @@\n+#ifdef ASSERT\n+#define RHS_MASK_ASSERT(rhs_mask)                       \\\n+  if (rhs_mask != 31 && rhs_mask != 63) {               \\\n+    basic_fatal(\"rhs_mask assertion failed.\");          \\\n+  }\n+#else\n+#define RHS_MASK_ASSERT(rhs_mask)\n+#endif\n+\n+\/\/ Provide integer shift operations with Java semantics.  No overflow\n+\/\/ issues - left shifts simply discard shifted out bits.  No undefined\n+\/\/ behavior for large or negative shift quantities; instead the actual\n+\/\/ shift distance is the argument modulo the lhs value's size in bits.\n+\/\/ No undefined or implementation defined behavior for shifting negative\n+\/\/ values; left shift discards bits, right shift sign extends.  We use\n+\/\/ the same safe conversion technique as above for java_add and friends.\n+#define JAVA_INTEGER_SHIFT_OP(OP, NAME, TYPE, XTYPE)    \\\n+inline TYPE NAME (TYPE lhs, jint rhs) {                 \\\n+  const uint rhs_mask = (sizeof(TYPE) * 8) - 1;         \\\n+  RHS_MASK_ASSERT(rhs_mask)                             \\\n+  XTYPE xres = static_cast<XTYPE>(lhs);                 \\\n+  xres OP ## = (rhs & rhs_mask);                        \\\n+  return reinterpret_cast<TYPE&>(xres);                 \\\n+}\n+\n+JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jint, juint)\n+JAVA_INTEGER_SHIFT_OP(<<, java_shift_left, jlong, julong)\n+\/\/ For signed shift right, assume C++ implementation >> sign extends.\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jint, jint)\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right, jlong, jlong)\n+\/\/ For >>> use C++ unsigned >>.\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jint, juint)\n+JAVA_INTEGER_SHIFT_OP(>>, java_shift_right_unsigned, jlong, julong)\n+\n+#undef JAVA_INTEGER_SHIFT_OP\n+\n","filename":"hotspot\/src\/share\/vm\/utilities\/globalDefinitions.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"}]}