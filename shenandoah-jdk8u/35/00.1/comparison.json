{"files":[{"patch":"@@ -99,0 +99,1 @@\n+#include \"gc_implementation\/shenandoah\/shenandoahControlThread.hpp\"\n@@ -306,0 +307,20 @@\n+\n+  _oom_during_evac = 0;\n+#if INCLUDE_ALL_GCS\n+  _gc_state = _gc_state_global;\n+  _worker_id = (uint)(-1); \/\/ Actually, ShenandoahWorkerSession::INVALID_WORKER_ID, but avoid dependencies.\n+  _force_satb_flush = false;\n+  _paced_time = 0;\n+#endif\n+}\n+\n+void Thread::set_oom_during_evac(bool oom) {\n+  if (oom) {\n+    _oom_during_evac |= 1;\n+  } else {\n+    _oom_during_evac &= ~1;\n+  }\n+}\n+\n+bool Thread::is_oom_during_evac() const {\n+  return (_oom_during_evac & 1) == 1;\n@@ -308,0 +329,14 @@\n+#ifdef ASSERT\n+void Thread::set_evac_allowed(bool evac_allowed) {\n+  if (evac_allowed) {\n+    _oom_during_evac |= 2;\n+  } else {\n+    _oom_during_evac &= ~2;\n+  }\n+}\n+\n+bool Thread::is_evac_allowed() const {\n+  return (_oom_during_evac & 2) == 2;\n+}\n+#endif\n+\n@@ -1523,0 +1558,1 @@\n+char Thread::_gc_state_global = 0;\n@@ -1926,1 +1962,1 @@\n-  if (UseG1GC) {\n+  if (UseG1GC || (UseShenandoahGC)) {\n@@ -1929,0 +1965,3 @@\n+  if (UseShenandoahGC && UseTLAB && gclab().is_initialized()) {\n+    gclab().make_parsable(true);\n+  }\n@@ -1962,0 +2001,21 @@\n+\n+  _gc_state = _gc_state_global;\n+}\n+\n+void JavaThread::set_gc_state(char in_prog) {\n+  _gc_state = in_prog;\n+}\n+\n+void JavaThread::set_gc_state_all_threads(char in_prog) {\n+  assert_locked_or_safepoint(Threads_lock);\n+  _gc_state_global = in_prog;\n+  for (JavaThread* t = Threads::first(); t != NULL; t = t->next()) {\n+    t->set_gc_state(in_prog);\n+  }\n+}\n+\n+void JavaThread::set_force_satb_flush_all_threads(bool value) {\n+  assert_locked_or_safepoint(Threads_lock);\n+  for (JavaThread* t = Threads::first(); t != NULL; t = t->next()) {\n+    t->set_force_satb_flush(value);\n+  }\n@@ -1992,1 +2052,1 @@\n-  if (UseG1GC) {\n+  if (UseG1GC || (UseShenandoahGC)) {\n@@ -1995,0 +2055,3 @@\n+  if (UseShenandoahGC && UseTLAB && gclab().is_initialized()) {\n+    gclab().make_parsable(true);\n+  }\n@@ -3299,0 +3362,7 @@\n+void Threads::java_threads_do(ThreadClosure* tc) {\n+  assert_locked_or_safepoint(Threads_lock);\n+  ALL_JAVA_THREADS(p) {\n+    tc->do_thread(p);\n+  }\n+}\n+\n@@ -3615,1 +3685,1 @@\n-  if (UseConcMarkSweepGC || UseG1GC) {\n+  if (UseConcMarkSweepGC || UseG1GC || UseShenandoahGC) {\n@@ -3618,0 +3688,2 @@\n+    } else if (UseShenandoahGC) {\n+      ShenandoahControlThread::makeSurrogateLockerThread(THREAD);\n@@ -4202,1 +4274,2 @@\n-          SharedHeap::heap()->workers()->active_workers()), \"Mismatch\");\n+          SharedHeap::heap()->workers()->active_workers()\n+          || UseShenandoahGC), \"Mismatch\");\n","filename":"hotspot\/src\/share\/vm\/runtime\/thread.cpp","additions":77,"deletions":4,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -105,0 +105,10 @@\n+\n+#if INCLUDE_ALL_GCS\n+protected:\n+  \/\/ Support for Shenandoah barriers. This is only accessible from JavaThread,\n+  \/\/ but we really want to keep this field at lower Thread offset (below first\n+  \/\/ 128 bytes), because that makes barrier fastpaths optimally encoded.\n+  char _gc_state;\n+  static char _gc_state_global;\n+#endif\n+\n@@ -260,0 +270,5 @@\n+  ThreadLocalAllocBuffer _gclab;                \/\/ Thread-local allocation buffer for GC (e.g. evacuation)\n+  uint _worker_id;                              \/\/ Worker ID\n+  bool _force_satb_flush;                       \/\/ Force SATB flush\n+  double _paced_time;                           \/\/ Accumulated paced time\n+\n@@ -262,0 +277,2 @@\n+  jlong _allocated_bytes_gclab;                 \/\/ Cumulative number of bytes allocated on\n+                                                \/\/ the Java heap, in GCLABs\n@@ -273,0 +290,2 @@\n+  char _oom_during_evac;\n+\n@@ -391,0 +410,8 @@\n+  bool is_oom_during_evac() const;\n+  void set_oom_during_evac(bool oom);\n+\n+#ifdef ASSERT\n+  bool is_evac_allowed() const;\n+  void set_evac_allowed(bool evac_allowed);\n+#endif\n+\n@@ -440,1 +467,4 @@\n-      tlab().initialize();\n+      tlab().initialize(false);\n+      if (UseShenandoahGC && (is_Java_thread() || is_Worker_thread())) {\n+        gclab().initialize(true);\n+      }\n@@ -444,0 +474,18 @@\n+  \/\/ Thread-Local GC Allocation Buffer (GCLAB) support\n+  ThreadLocalAllocBuffer& gclab()                {\n+    assert (UseShenandoahGC, \"Only for Shenandoah\");\n+    assert (!_gclab.is_initialized() || (is_Java_thread() || is_Worker_thread()),\n+            \"Only Java and GC worker threads are allowed to get GCLABs\");\n+    return _gclab;\n+  }\n+\n+  void set_worker_id(uint id)           { _worker_id = id; }\n+  uint worker_id()                      { return _worker_id; }\n+\n+  void set_force_satb_flush(bool value) { _force_satb_flush = value; }\n+  bool is_force_satb_flush()            { return _force_satb_flush; }\n+\n+  void add_paced_time(double v)         { _paced_time += v; }\n+  double paced_time()                   { return _paced_time; }\n+  void reset_paced_time()               { _paced_time = 0; }\n+\n@@ -449,0 +497,4 @@\n+  jlong allocated_bytes_gclab()                { return _allocated_bytes_gclab; }\n+  void set_allocated_bytes_gclab(jlong value)  { _allocated_bytes_gclab = value; }\n+  void incr_allocated_bytes_gclab(jlong size)  { _allocated_bytes_gclab += size; }\n+\n@@ -633,0 +685,4 @@\n+  static ByteSize gclab_start_offset()         { return byte_offset_of(Thread, _gclab) + ThreadLocalAllocBuffer::start_offset(); }\n+  static ByteSize gclab_top_offset()           { return byte_offset_of(Thread, _gclab) + ThreadLocalAllocBuffer::top_offset(); }\n+  static ByteSize gclab_end_offset()           { return byte_offset_of(Thread, _gclab) + ThreadLocalAllocBuffer::end_offset(); }\n+\n@@ -1388,0 +1444,3 @@\n+\n+  static ByteSize gc_state_offset()              { return byte_offset_of(JavaThread, _gc_state); }\n+\n@@ -1685,0 +1744,9 @@\n+\n+  inline char gc_state() const;\n+\n+private:\n+  void set_gc_state(char in_prog);\n+\n+public:\n+  static void set_gc_state_all_threads(char in_prog);\n+  static void set_force_satb_flush_all_threads(bool value);\n@@ -1930,0 +1998,1 @@\n+  static void java_threads_do(ThreadClosure* tc);\n","filename":"hotspot\/src\/share\/vm\/runtime\/thread.hpp","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"}]}