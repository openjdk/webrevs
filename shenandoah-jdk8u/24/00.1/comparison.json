{"files":[{"patch":"@@ -929,0 +929,3 @@\n+#if INCLUDE_ALL_GCS\n+#include \"shenandoahBarrierSetAssembler_aarch64.hpp\"\n+#endif\n@@ -2902,0 +2905,9 @@\n+  enc_class aarch64_enc_cmpxchg_oop_shenandoah(memory mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, iRegINoSp res) %{\n+    MacroAssembler _masm(&cbuf);\n+    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n+    Register tmp = $tmp$$Register;\n+    __ mov(tmp, $oldval$$Register); \/\/ Must not clobber oldval.\n+    ShenandoahBarrierSetAssembler::bsasm()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+                              \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ false, $res$$Register);\n+  %}\n+\n@@ -2920,0 +2932,10 @@\n+  enc_class aarch64_enc_cmpxchg_acq_oop_shenandoah(memory mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, iRegINoSp res) %{\n+    MacroAssembler _masm(&cbuf);\n+    guarantee($mem$$index == -1 && $mem$$disp == 0, \"impossible encoding\");\n+    Register tmp = $tmp$$Register;\n+    __ mov(tmp, $oldval$$Register); \/\/ Must not clobber oldval.\n+    ShenandoahBarrierSetAssembler::bsasm()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register,\n+                              \/*acquire*\/ true, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ false,\n+                              $res$$Register);\n+  %}\n+\n@@ -4318,2 +4340,2 @@\n-  predicate((jbyte*)n->get_ptr() ==\n-\t((CardTableModRefBS*)(Universe::heap()->barrier_set()))->byte_map_base);\n+  predicate(!UseShenandoahGC && \/\/ TODO: Should really check for BS::is_a, see JDK-8193193\n+    (jbyte*)n->get_ptr() == ((CardTableModRefBS*)(Universe::heap()->barrier_set()))->byte_map_base);\n@@ -7043,1 +7065,47 @@\n-  ins_encode(aarch64_enc_str(src, mem));\n+  ins_encode %{\n+    int opcode = $mem->opcode();\n+    Register base = as_Register($mem$$base);\n+    int index = $mem$$index;\n+    int size = $mem$$scale;\n+    int disp = $mem$$disp;\n+    Register reg = as_Register($src$$reg);\n+\n+    \/\/ we sometimes get asked to store the stack pointer into the\n+    \/\/ current thread -- we cannot do that directly on AArch64\n+    if (reg == r31_sp) {\n+      MacroAssembler _masm(&cbuf);\n+      assert(as_Register($mem$$base) == rthread, \"unexpected store for sp\");\n+      __ mov(rscratch2, sp);\n+      reg = rscratch2;\n+    }\n+    Address::extend scale;\n+\n+    \/\/ Hooboy, this is fugly.  We need a way to communicate to the\n+    \/\/ encoder that the index needs to be sign extended, so we have to\n+    \/\/ enumerate all the cases.\n+    switch (opcode) {\n+    case INDINDEXSCALEDOFFSETI2L:\n+    case INDINDEXSCALEDI2L:\n+    case INDINDEXSCALEDOFFSETI2LN:\n+    case INDINDEXSCALEDI2LN:\n+    case INDINDEXOFFSETI2L:\n+    case INDINDEXOFFSETI2LN:\n+      scale = Address::sxtw(size);\n+      break;\n+    default:\n+      scale = Address::lsl(size);\n+    }\n+    Address adr;\n+    if (index == -1) {\n+      adr = Address(base, disp);\n+    } else {\n+      if (disp == 0) {\n+        adr = Address(base, as_Register(index), scale);\n+      } else {\n+        __ lea(rscratch1, Address(base, disp));\n+        adr = Address(rscratch1, as_Register(index), scale);\n+      }\n+    }\n+\n+    __ str(reg, adr);\n+  %}\n@@ -8167,0 +8235,1 @@\n+  predicate(!UseShenandoahGC || !ShenandoahCASBarrier || n->in(3)->in(1)->bottom_type() == TypePtr::NULL_PTR);\n@@ -8183,0 +8252,17 @@\n+instruct compareAndSwapP_shenandoah(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n+\n+  predicate(UseShenandoahGC && ShenandoahCASBarrier && n->in(3)->in(1)->bottom_type() != TypePtr::NULL_PTR);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  effect(TEMP tmp, KILL cr);\n+\n+  format %{\n+    \"cmpxchg_shenandoah_oop $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval with temp $tmp\"\n+  %}\n+\n+  ins_encode(aarch64_enc_cmpxchg_oop_shenandoah(mem, oldval, newval, tmp, res));\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8185,0 +8271,1 @@\n+  predicate(!UseShenandoahGC || !ShenandoahCASBarrier || n->in(3)->in(1)->bottom_type() == TypeNarrowOop::NULL_PTR);\n@@ -8201,0 +8288,20 @@\n+instruct compareAndSwapN_shenandoah(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, iRegNNoSp tmp, rFlagsReg cr) %{\n+\n+  predicate(UseShenandoahGC && ShenandoahCASBarrier && n->in(3)->in(1)->bottom_type() != TypeNarrowOop::NULL_PTR);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  ins_cost(2 * VOLATILE_REF_COST);\n+\n+  effect(TEMP tmp, KILL cr);\n+\n+  format %{\n+    \"cmpxchgw_shenandoah_narrow_oop $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval with temp $tmp\"\n+  %}\n+\n+  ins_encode %{\n+    Register tmp = $tmp$$Register;\n+    __ mov(tmp, $oldval$$Register); \/\/ Must not clobber oldval.\n+    ShenandoahBarrierSetAssembler::bsasm()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ false, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n@@ -8244,1 +8351,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && (!UseShenandoahGC || !ShenandoahCASBarrier || n->in(3)->in(1)->bottom_type() == TypePtr::NULL_PTR));\n@@ -8261,0 +8368,17 @@\n+instruct compareAndSwapPAcq_shenandoah(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n+\n+  predicate(needs_acquiring_load_exclusive(n) && UseShenandoahGC && ShenandoahCASBarrier && n->in(3)->in(1)->bottom_type() != TypePtr::NULL_PTR);\n+  match(Set res (CompareAndSwapP mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+\n+  effect(TEMP tmp, KILL cr);\n+\n+  format %{\n+    \"cmpxchg_acq_shenandoah_oop $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval with temp $tmp\"\n+  %}\n+\n+  ins_encode(aarch64_enc_cmpxchg_acq_oop_shenandoah(mem, oldval, newval, tmp, res));\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8263,1 +8387,1 @@\n-  predicate(needs_acquiring_load_exclusive(n));\n+  predicate(needs_acquiring_load_exclusive(n) && (!UseShenandoahGC || !ShenandoahCASBarrier|| n->in(3)->in(1)->bottom_type() == TypeNarrowOop::NULL_PTR));\n@@ -8280,0 +8404,20 @@\n+instruct compareAndSwapNAcq_shenandoah(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, iRegNNoSp tmp, rFlagsReg cr) %{\n+\n+  predicate(needs_acquiring_load_exclusive(n) && UseShenandoahGC && ShenandoahCASBarrier && n->in(3)->in(1)->bottom_type() != TypeNarrowOop::NULL_PTR);\n+  match(Set res (CompareAndSwapN mem (Binary oldval newval)));\n+  ins_cost(VOLATILE_REF_COST);\n+\n+  effect(TEMP tmp, KILL cr);\n+\n+ format %{\n+    \"cmpxchgw_acq_shenandoah_narrow_oop $mem, $oldval, $newval\\t# (ptr) if $mem == $oldval then $mem <-- $newval with temp $tmp\"\n+ %}\n+\n+  ins_encode %{\n+    Register tmp = $tmp$$Register;\n+    __ mov(tmp, $oldval$$Register); \/\/ Must not clobber oldval.\n+    ShenandoahBarrierSetAssembler::bsasm()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ true, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ false, $res$$Register);\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"hotspot\/src\/cpu\/aarch64\/vm\/aarch64.ad","additions":149,"deletions":5,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+#include \"gc_implementation\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc_implementation\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n@@ -793,0 +795,9 @@\n+  } else if (UseShenandoahGC) {\n+#if INCLUDE_ALL_GCS\n+    ShenandoahCollectorPolicy* shcp = new ShenandoahCollectorPolicy();\n+    ShenandoahHeap* sh = new ShenandoahHeap(shcp);\n+    Universe::_collectedHeap = sh;\n+#else  \/\/ INCLUDE_ALL_GCS\n+    fatal(\"UseShenandoahGC not supported in java kernel vm.\");\n+#endif \/\/ INCLUDE_ALL_GCS\n+\n","filename":"hotspot\/src\/share\/vm\/memory\/universe.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -96,0 +97,1 @@\n+#include \"gc_implementation\/shenandoah\/shenandoahBarrierSetClone.inline.hpp\"\n@@ -602,1 +604,1 @@\n-  if (UseG1GC) {\n+  if (UseG1GC || (UseShenandoahGC && ShenandoahSATBBarrier)) {\n@@ -659,0 +661,6 @@\n+#if INCLUDE_ALL_GCS\n+  if (UseShenandoahGC && ShenandoahCloneBarrier) {\n+    ShenandoahBarrierSet::barrier_set()->clone_barrier_runtime(obj());\n+  }\n+#endif\n+\n@@ -1165,1 +1173,0 @@\n-\n","filename":"hotspot\/src\/share\/vm\/prims\/jvm.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+#include \"gc_implementation\/shenandoah\/shenandoahControlThread.hpp\"\n@@ -306,0 +307,20 @@\n+\n+  _oom_during_evac = 0;\n+#if INCLUDE_ALL_GCS\n+  _gc_state = _gc_state_global;\n+  _worker_id = (uint)(-1); \/\/ Actually, ShenandoahWorkerSession::INVALID_WORKER_ID, but avoid dependencies.\n+  _force_satb_flush = false;\n+  _paced_time = 0;\n+#endif\n+}\n+\n+void Thread::set_oom_during_evac(bool oom) {\n+  if (oom) {\n+    _oom_during_evac |= 1;\n+  } else {\n+    _oom_during_evac &= ~1;\n+  }\n+}\n+\n+bool Thread::is_oom_during_evac() const {\n+  return (_oom_during_evac & 1) == 1;\n@@ -308,0 +329,14 @@\n+#ifdef ASSERT\n+void Thread::set_evac_allowed(bool evac_allowed) {\n+  if (evac_allowed) {\n+    _oom_during_evac |= 2;\n+  } else {\n+    _oom_during_evac &= ~2;\n+  }\n+}\n+\n+bool Thread::is_evac_allowed() const {\n+  return (_oom_during_evac & 2) == 2;\n+}\n+#endif\n+\n@@ -1512,0 +1547,1 @@\n+char Thread::_gc_state_global = 0;\n@@ -1915,1 +1951,1 @@\n-  if (UseG1GC) {\n+  if (UseG1GC || (UseShenandoahGC)) {\n@@ -1918,0 +1954,3 @@\n+  if (UseShenandoahGC && UseTLAB && gclab().is_initialized()) {\n+    gclab().make_parsable(true);\n+  }\n@@ -1951,0 +1990,21 @@\n+\n+  _gc_state = _gc_state_global;\n+}\n+\n+void JavaThread::set_gc_state(char in_prog) {\n+  _gc_state = in_prog;\n+}\n+\n+void JavaThread::set_gc_state_all_threads(char in_prog) {\n+  assert_locked_or_safepoint(Threads_lock);\n+  _gc_state_global = in_prog;\n+  for (JavaThread* t = Threads::first(); t != NULL; t = t->next()) {\n+    t->set_gc_state(in_prog);\n+  }\n+}\n+\n+void JavaThread::set_force_satb_flush_all_threads(bool value) {\n+  assert_locked_or_safepoint(Threads_lock);\n+  for (JavaThread* t = Threads::first(); t != NULL; t = t->next()) {\n+    t->set_force_satb_flush(value);\n+  }\n@@ -1981,1 +2041,1 @@\n-  if (UseG1GC) {\n+  if (UseG1GC || (UseShenandoahGC)) {\n@@ -1984,0 +2044,3 @@\n+  if (UseShenandoahGC && UseTLAB && gclab().is_initialized()) {\n+    gclab().make_parsable(true);\n+  }\n@@ -3288,0 +3351,7 @@\n+void Threads::java_threads_do(ThreadClosure* tc) {\n+  assert_locked_or_safepoint(Threads_lock);\n+  ALL_JAVA_THREADS(p) {\n+    tc->do_thread(p);\n+  }\n+}\n+\n@@ -3604,1 +3674,1 @@\n-  if (UseConcMarkSweepGC || UseG1GC) {\n+  if (UseConcMarkSweepGC || UseG1GC || UseShenandoahGC) {\n@@ -3607,0 +3677,2 @@\n+    } else if (UseShenandoahGC) {\n+      ShenandoahControlThread::makeSurrogateLockerThread(THREAD);\n@@ -4191,1 +4263,2 @@\n-          SharedHeap::heap()->workers()->active_workers()), \"Mismatch\");\n+          SharedHeap::heap()->workers()->active_workers()\n+          || UseShenandoahGC), \"Mismatch\");\n","filename":"hotspot\/src\/share\/vm\/runtime\/thread.cpp","additions":77,"deletions":4,"binary":false,"changes":81,"status":"modified"}]}