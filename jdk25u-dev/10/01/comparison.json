{"files":[{"patch":"@@ -609,0 +609,5 @@\n+          if (n->is_Mem() && n->as_Mem()->is_mismatched_access()) {\n+            DEBUG_ONLY(disq_node = n);\n+            NOT_PRODUCT(fail_eliminate = \"Mismatched access\");\n+            can_eliminate = false;\n+          }\n@@ -746,0 +751,35 @@\n+#ifdef ASSERT\n+  \/\/ Verify if a value can be written into a field.\n+  void verify_type_compatability(const Type* value_type, const Type* field_type) {\n+    BasicType value_bt = value_type->basic_type();\n+    BasicType field_bt = field_type->basic_type();\n+\n+    \/\/ Primitive types must match.\n+    if (is_java_primitive(value_bt) && value_bt == field_bt) { return; }\n+\n+    \/\/ I have been struggling to make a similar assert for non-primitive\n+    \/\/ types. I we can add one in the future. For now, I just let them\n+    \/\/ pass without checks.\n+    \/\/ In particular, I was struggling with a value that came from a call,\n+    \/\/ and had only a non-null check CastPP. There was also a checkcast\n+    \/\/ in the graph to verify the interface, but the corresponding\n+    \/\/ CheckCastPP result was not updated in the stack slot, and so\n+    \/\/ we ended up using the CastPP. That means that the field knows\n+    \/\/ that it should get an oop from an interface, but the value lost\n+    \/\/ that information, and so it is not a subtype.\n+    \/\/ There may be other issues, feel free to investigate further!\n+    if (!is_java_primitive(value_bt)) { return; }\n+\n+    tty->print_cr(\"value not compatible for field: %s vs %s\",\n+                  type2name(value_bt),\n+                  type2name(field_bt));\n+    tty->print(\"value_type: \");\n+    value_type->dump();\n+    tty->cr();\n+    tty->print(\"field_type: \");\n+    field_type->dump();\n+    tty->cr();\n+    assert(false, \"value_type does not fit field_type\");\n+  }\n+#endif\n+\n@@ -862,0 +902,1 @@\n+    DEBUG_ONLY(verify_type_compatability(field_val->bottom_type(), field_type);)\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1385,0 +1385,3 @@\n+#if INCLUDE_JVMCI\n+      \/\/ big_value allows encoding double\/long value as e.g. [int = 0, long], and storing\n+      \/\/ the value in two array elements.\n@@ -1412,0 +1415,3 @@\n+#else \/\/ not INCLUDE_JVMCI\n+      obj->int_at_put(index, value->get_jint());\n+#endif \/\/ INCLUDE_JVMCI\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+\/*\n+ * @test\n+ * @bug 8370405\n+ * @summary Test case where we had escape analysis tell us that we can possibly eliminate\n+ *          the array allocation, then MergeStores introduces a mismatched store, which\n+ *          the actual elimination does not verify for. That led to wrong results.\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.c2.TestMergeStoresAndAllocationElimination::test\n+ *                   -XX:CompileCommand=exclude,compiler.c2.TestMergeStoresAndAllocationElimination::dontinline\n+ *                   -XX:-TieredCompilation -Xbatch\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-CICompileOSR\n+ *                   compiler.c2.TestMergeStoresAndAllocationElimination\n+ * @run main compiler.c2.TestMergeStoresAndAllocationElimination\n+ *\/\n+\n+public class TestMergeStoresAndAllocationElimination {\n+    static void dontinline() {}\n+\n+    static int test(boolean flag) {\n+        int[] arr = new int[4];\n+        \/\/ The values below will be caputured as \"raw stores\" in the Initialize\n+        \/\/ of the array allocation above.\n+        \/\/ These stores are for cosmetics only, we set the \"1\" bits so that it is\n+        \/\/ simple to track where values are coming from.\n+        arr[0] = 0x0001_0000;\n+        arr[1] = 0x0010_0000;\n+        arr[2] = 0x0000_0100;\n+        arr[3] = 0x0100_0000;\n+        \/\/ So far, the result should be:\n+        \/\/ 0x421_0300\n+\n+        \/\/ The call below prevents further assignments from being captured into\n+        \/\/ the Initialize above.\n+        dontinline();\n+        \/\/ The follwoing stores are eventually optimized by MergeStores, and create\n+        \/\/ a mismatched StoreL.\n+        arr[0] = 0x0000_0001;\n+        arr[1] = 0x0000_0010;\n+        \/\/ Now, the result should be:\n+        \/\/ 0x400_0321\n+\n+        \/\/ We create an uncommon trap because of an \"unstable if\".\n+        \/\/ If Escape Analysis were to work, it would try to capture the values\n+        \/\/ from the StoreL above. But because it is mismatched, it should fail.\n+        \/\/ What happened before that verification: we would take the ConL, and\n+        \/\/ insert it in a list of ConI. That meant that we eventually applied\n+        \/\/ that value wrong if the deopt was taken (flag = true).\n+        \/\/\n+        \/\/ What happened when the deopt got the wrong values: It got these values:\n+        \/\/ [0]=68719476737 = 0x10_0000_0001 -> long value, not correct\n+        \/\/ [1]=1048576     =      0x10_0000 -> this entry is not updated!\n+        \/\/ [2]=256         =          0x100\n+        \/\/ [3]=16777216    =     0x100_0000\n+        \/\/\n+        \/\/ This is serialized as a long and 3 ints, and that looks like 5 ints.\n+        \/\/ This creates an array of 5 elements (and not 4):\n+        \/\/ [0]             =            0x1\n+        \/\/ [1]             =           0x10\n+        \/\/ [2]             =      0x10_0000 -> this entry is \"inserted\"\n+        \/\/ [3]             =          0x100\n+        \/\/ [4]             =     0x100_0000\n+        \/\/\n+        \/\/ This creates the wrong state:\n+        \/\/ 0x30_0421\n+        \/\/ And we can actually read that the arr.length is 5, below.\n+        if (flag) { System.out.println(\"unstable if: \" + arr.length); }\n+\n+        \/\/ Delay the allocation elimination until after loop opts, so that it\n+        \/\/ happens after MergeStores. Without this, we would immediately\n+        \/\/ eliminate the allocation during Escape Analysis, and then MergeStores\n+        \/\/ would not find the stores that would be removed with the allocation.\n+        for (int i = 0; i < 10_000; i++) {\n+            arr[3] = 0x0000_1000;\n+        }\n+        \/\/ Coming from the correct value, we should have transition of state:\n+        \/\/ 0x400_0321 -> 0x4321\n+        \/\/ But coming from the bad (rematerialized) state, we transition:\n+        \/\/ 0x30_0421 -> 0x30_4021\n+\n+        \/\/ Tag each entry with an index number\n+        \/\/ We expect: 0x4321\n+        return 1 * arr[0] + 2 * arr[1] + 3 * arr[2] + 4 * arr[3];\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Capture interpreter result.\n+        int gold = test(false);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test(false);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test(false);\n+        int res1 = test(true);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" + Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStoresAndAllocationElimination.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=yEA\n+ * @bug 8370405\n+ * @summary Test elimination of array allocation, and the rematerialization.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.escapeAnalysis.TestRematerializeObjects yEA\n+ *\/\n+\n+\/*\n+ * @test id=nEA\n+ * @library \/test\/lib \/\n+ * @run driver compiler.escapeAnalysis.TestRematerializeObjects nEA\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+\n+public class TestRematerializeObjects {\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestRematerializeObjects.class);\n+        switch (args[0]) {\n+            case \"yEA\" -> { framework.addFlags(\"-XX:+EliminateAllocations\"); }\n+            case \"nEA\" -> { framework.addFlags(\"-XX:-EliminateAllocations\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n+    }\n+\n+    @DontInline\n+    static void dontinline() {}\n+\n+    @Run(test = \"test1\", mode = RunMode.STANDALONE)\n+    public void runTest1() {\n+        \/\/ Capture interpreter result.\n+        int gold = test1(false);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test1(false);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test1(false);\n+        int res1 = test1(true);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" +\n+                                       Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"1\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\[int:4\\\\]\", \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"0\"},\n+        applyIf = {\"EliminateAllocations\", \"false\"})\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"0\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"int\\\\[int:4\\\\]\", \"0\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"2\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    static int test1(boolean flag) {\n+        int[] arr = new int[4];\n+        arr[0] = 0x0001_0000; \/\/ these slip into Initialize\n+        arr[1] = 0x0010_0000;\n+        arr[2] = 0x0000_0100;\n+        arr[3] = 0x0100_0000;\n+        dontinline();\n+        arr[0] = 0x0000_0001; \/\/ MergeStores -> StoreL\n+        arr[1] = 0x0000_0010;\n+        if (flag) {\n+            \/\/ unstable if -> deopt -> rematerialized array (if was eliminated)\n+            System.out.println(\"unstable if: \" + arr.length);\n+        }\n+        arr[3] = 0x0000_1000;\n+        return 1 * arr[0] + 2 * arr[1] + 3 * arr[2] + 4 * arr[3];\n+    }\n+\n+    @Run(test = \"test2\", mode = RunMode.STANDALONE)\n+    public void runTest2() {\n+        \/\/ Capture interpreter result.\n+        int gold = test2(false);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test2(false);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test2(false);\n+        int res1 = test2(true);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" +\n+                                       Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"1\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\[int:4\\\\]\", \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"0\"},\n+        applyIf = {\"EliminateAllocations\", \"false\"})\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"0\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"short\\\\[int:4\\\\]\", \"0\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"2\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    static int test2(boolean flag) {\n+        short[] arr = new short[4];\n+        arr[0] = 1;\n+        arr[1] = 2;\n+        arr[2] = 4;\n+        arr[3] = 8;\n+        dontinline();\n+        \/\/ Seems we detect that this is a short value passed into the short field.\n+        arr[0] = 16;\n+        arr[1] = 32;\n+        if (flag) {\n+            \/\/ unstable if -> deopt -> rematerialized array (if was eliminated)\n+            System.out.println(\"unstable if: \" + arr.length);\n+        }\n+        arr[3] = 64;\n+        return 0x1 * arr[0] + 0x100 * arr[1] + 0x1_0000 * arr[2] + 0x100_0000 * arr[3];\n+    }\n+\n+    @Run(test = \"test3\", mode = RunMode.STANDALONE)\n+    public void runTest3() {\n+        \/\/ Capture interpreter result.\n+        int gold = test3(false, 42);\n+        \/\/ Repeat until we get compilation.\n+        for (int i = 0; i < 10_000; i++) {\n+            test3(false, 42);\n+        }\n+        \/\/ Capture compiled results.\n+        int res0 = test3(false, 42);\n+        int res1 = test3(true, 42);\n+        if (res0 != gold || res1 != gold) {\n+            throw new RuntimeException(\"Unexpected result: \" + Integer.toHexString(res0) + \" and \" +\n+                                       Integer.toHexString(res1) + \", should be: \" + Integer.toHexString(gold));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"1\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"0\"},\n+        applyIf = {\"EliminateAllocations\", \"false\"})\n+    @IR(counts = {IRNode.ALLOC_ARRAY, \"0\",\n+                  IRNode.UNSTABLE_IF_TRAP, \"1\",\n+                  IRNode.SAFEPOINT_SCALAROBJECT_OF, \"fields@\\\\[0..3\\\\]\", \"2\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    static int test3(boolean flag, int x) {\n+        short[] arr = new short[4];\n+        arr[0] = 1;\n+        arr[1] = 2;\n+        arr[2] = 4;\n+        arr[3] = 8;\n+        dontinline();\n+        \/\/ Here, we don't get ConI, but instead AddI, which means we are\n+        \/\/ serializing an int value, for a short slot.\n+        arr[0] = (short)(x + 1);\n+        arr[1] = (short)(x + 2);\n+        if (flag) {\n+            \/\/ unstable if -> deopt -> rematerialized array (if was eliminated)\n+            System.out.println(\"unstable if: \" + arr.length);\n+        }\n+        arr[3] = 64;\n+        return 0x1 * arr[0] + 0x100 * arr[1] + 0x1_0000 * arr[2] + 0x100_0000 * arr[3];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestRematerializeObjects.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -105,2 +105,0 @@\n-    private static final String STORE_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n-    private static final String LOAD_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n@@ -1823,0 +1821,5 @@\n+    public static final String SAFEPOINT_SCALAROBJECT_OF = COMPOSITE_PREFIX + \"SAFEPOINT_SCALAROBJECT_OF\" + POSTFIX;\n+    static {\n+        safepointScalarobjectOfNodes(SAFEPOINT_SCALAROBJECT_OF, \"SafePointScalarObject\");\n+    }\n+\n@@ -2941,0 +2944,12 @@\n+    \/\/ Typename in load\/store have the structure:\n+    \/\/ @fully\/qualified\/package\/name\/to\/TheClass+12 *\n+    \/\/ And variation:\n+    \/\/ - after @, we can have \"stable:\" or other labels, with optional space after ':'\n+    \/\/ - the class can actually be a subclass, with $ separator (and it must be ok to give only the deepest one\n+    \/\/ - after the class name, we can have a comma-separated list of implemented interfaces enclosed in parentheses\n+    \/\/ - before the offset, we can have something like \":NotNull\", either way, seeing \"+\" or \":\" means the end of the type\n+    \/\/ Worst case, it can be something like:\n+    \/\/ @bla: bli:a\/b\/c$d$e (f\/g,h\/i\/j):NotNull+24 *\n+    private static final String LOAD_STORE_PREFIX = \"@(\\\\w+: ?)*[\\\\w\/\\\\$]*\\\\b\";\n+    private static final String LOAD_STORE_SUFFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\";\n+\n@@ -2942,1 +2957,1 @@\n-        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+        String regex = START + irNodeRegex + MID + LOAD_STORE_PREFIX + IS_REPLACED + LOAD_STORE_SUFFIX + END;\n@@ -2947,1 +2962,6 @@\n-        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+        String regex = START + irNodeRegex + MID + LOAD_STORE_PREFIX + IS_REPLACED + LOAD_STORE_SUFFIX + END;\n+        beforeMatching(irNodePlaceholder, regex);\n+    }\n+\n+    private static void safepointScalarobjectOfNodes(String irNodePlaceholder, String irNodeRegex) {\n+        String regex = START + irNodeRegex + MID + \".*\" + IS_REPLACED + \".*\" + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+        run(LoadStore.class);\n@@ -552,0 +553,236 @@\n+\n+\/\/ Test load and store regexes\n+class LoadStore {\n+    int i;\n+    float f;\n+    interface I1 {}\n+    static class Base implements I1 {\n+        int i;\n+    }\n+    interface I2 {}\n+    static class Derived extends Base implements I2 {\n+        long l;\n+    }\n+    Base base = new Base();\n+    Derived derived = new Derived();\n+\n+    static class SingleNest {\n+        static class DoubleNest {\n+            int i;\n+        }\n+    }\n+\n+    SingleNest.DoubleNest doubleNest = new SingleNest.DoubleNest();\n+\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_OF_CLASS, \".*\", IRNode.STORE_OF_CLASS, \".*\"})\n+    public void triviallyFailBoth() {\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.LOAD_OF_CLASS, \"LoadS[a-z]+\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"Load.tore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"\/LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"tests\/LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"\/tests\/LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"ir_framework\/tests\/LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\", \"1\",  \/\/ To assert it's the whole qualification\n+            IRNode.LOAD_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.LOAD_OF_CLASS, \"oadStore\",\n+            IRNode.LOAD_OF_CLASS, \"LoadStor\",\n+            IRNode.LOAD_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\",\n+            IRNode.LOAD_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore+12 *\n+    public float simpleLoad() {\n+        return f;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.STORE_OF_CLASS, \"LoadS[a-z]+\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"Load.tore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"tests\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"\/tests\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"ir_framework\/tests\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.STORE_OF_CLASS, \"oadStore\",\n+            IRNode.STORE_OF_CLASS, \"LoadStor\",\n+            IRNode.STORE_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\",\n+            IRNode.STORE_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore+12 *\n+    public void simpleStore() {\n+        i = 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.LOAD_I_OF_CLASS, \"Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadS[a-z]+\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"Load.tore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.LOAD_I_OF_CLASS, \"\/Base\",\n+            IRNode.LOAD_I_OF_CLASS, \"oadStore\\\\$Base\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\\\\$Bas\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\\\\$Base\",\n+            IRNode.LOAD_I_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$Base (ir_framework\/tests\/LoadStore$I1)+12 *\n+    public int loadWithInterface() {\n+        return base.i;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.STORE_I_OF_CLASS, \"Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadS[a-z]+\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"Load.tore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.STORE_I_OF_CLASS, \"\/Base\",\n+            IRNode.STORE_I_OF_CLASS, \"oadStore\\\\$Base\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\\\\$Bas\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\",\n+            IRNode.STORE_I_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\\\\$Base\",\n+            IRNode.STORE_I_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$Base (ir_framework\/tests\/LoadStore$I1)+12 *\n+    public void storeWithInterface() {\n+        base.i = 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.LOAD_L_OF_CLASS, \"Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"LoadS[a-z]+\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"Load.tore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.LOAD_L_OF_CLASS, \"\/Derived\",\n+            IRNode.LOAD_L_OF_CLASS, \"oadStore\\\\$Derived\",\n+            IRNode.LOAD_L_OF_CLASS, \"LoadStore\\\\$Derive\",\n+            IRNode.LOAD_L_OF_CLASS, \"LoadStore\",\n+            IRNode.LOAD_L_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\\\\$Derived\",\n+            IRNode.LOAD_L_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$Derived (ir_framework\/tests\/LoadStore$I1,ir_framework\/tests\/LoadStore$I2)+24 *\n+    public long loadWithInterfaces() {\n+        return derived.l;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.STORE_L_OF_CLASS, \"Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"LoadS[a-z]+\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"Load.tore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.STORE_L_OF_CLASS, \"\/Derived\",\n+            IRNode.STORE_L_OF_CLASS, \"oadStore\\\\$Derived\",\n+            IRNode.STORE_L_OF_CLASS, \"LoadStore\\\\$Derive\",\n+            IRNode.STORE_L_OF_CLASS, \"LoadStore\",\n+            IRNode.STORE_L_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\\\\$Derived\",\n+            IRNode.STORE_L_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$Derived (ir_framework\/tests\/LoadStore$I1,ir_framework\/tests\/LoadStore$I2)+24 *\n+    public void storeWithInterfaces() {\n+        derived.l = 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.LOAD_I_OF_CLASS, \"DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.LOAD_I_OF_CLASS, \"SingleNest\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\\\\$SingleNest\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$SingleNest$DoubleNest+12 *\n+    public int loadDoubleNested() {\n+        return doubleNest.i;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.STORE_I_OF_CLASS, \"DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\/tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.STORE_I_OF_CLASS, \"SingleNest\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\\\\$SingleNest\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$SingleNest$DoubleNest+12 *\n+    public void storeDoubleNested() {\n+        doubleNest.i = 1;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"modified"}]}