{"files":[{"patch":"@@ -234,2 +234,1 @@\n-  DEBUG_ONLY(volatile bool _out_of_stack_walking_enabled;)\n-  DEBUG_ONLY(volatile u8 _out_of_stack_walking_iterations;)\n+  DEBUG_ONLY(volatile bool _out_of_stack_walking_enabled = true;)\n@@ -287,4 +286,0 @@\n-\n-  u8 out_of_stack_walking_iterations() const {\n-    return Atomic::load(&_out_of_stack_walking_iterations);\n-  }\n@@ -398,1 +393,0 @@\n-        DEBUG_ONLY(Atomic::inc(&_out_of_stack_walking_iterations);)\n@@ -592,1 +586,1 @@\n-void JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(bool runnable) {\n+bool JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(bool runnable) {\n@@ -595,0 +589,3 @@\n+    return true;\n+  } else {\n+    return false;\n@@ -597,7 +594,0 @@\n-\n-u8 JfrCPUTimeThreadSampling::out_of_stack_walking_iterations() {\n-  if (_instance != nullptr && _instance->_sampler != nullptr) {\n-    return _instance->_sampler->out_of_stack_walking_iterations();\n-  }\n-  return 0;\n-}\n@@ -876,1 +866,1 @@\n-static void set_out_of_stack_walking_enabled(bool runnable) {\n+bool JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(bool runnable) {\n@@ -878,0 +868,1 @@\n+  return false;\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -142,3 +142,1 @@\n-  DEBUG_ONLY(static void set_out_of_stack_walking_enabled(bool runnable);)\n-\n-  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n+  DEBUG_ONLY(static bool set_out_of_stack_walking_enabled(bool runnable);)\n@@ -165,2 +163,1 @@\n-  DEBUG_ONLY(static void set_out_of_stack_walking_enabled(bool runnable));\n-  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n+  DEBUG_ONLY(static bool set_out_of_stack_walking_enabled(bool runnable));\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2687,1 +2687,1 @@\n-WB_ENTRY(void, WB_BusyWait(JNIEnv* env, jobject wb, jint time))\n+WB_ENTRY(void, WB_BusyWaitCPUTime(JNIEnv* env, jobject wb, jint time))\n@@ -2698,2 +2698,1 @@\n-    JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(enable == JNI_TRUE);\n-    return JNI_TRUE;\n+    return JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(enable == JNI_TRUE) ? JNI_TRUE : JNI_FALSE;\n@@ -2705,8 +2704,0 @@\n-WB_ENTRY(jlong, WB_CPUSamplerOutOfStackWalkingIterations(JNIEnv* env, jobject wb))\n-  #if defined(ASSERT) && INCLUDE_JFR && defined(LINUX)\n-    return (jlong)JfrCPUTimeThreadSampling::out_of_stack_walking_iterations();\n-  #else\n-    return 0;\n-  #endif\n-WB_END\n-\n@@ -3062,1 +3053,1 @@\n-  {CC\"busyWait\", CC\"(I)V\",                            (void*)&WB_BusyWait},\n+  {CC\"busyWaitCPUTime\", CC\"(I)V\",                     (void*)&WB_BusyWaitCPUTime},\n@@ -3064,1 +3055,0 @@\n-  {CC\"cpuSamplerOutOfStackWalkingIterations\", CC\"()J\",(void*)&WB_CPUSamplerOutOfStackWalkingIterations},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.time.Instant;\n@@ -44,0 +45,7 @@\n+ *\n+ * The test starts CPU time sampling with a short interval (1ms), disabling\n+ * out-of-stack sample processing for the duration of the test.\n+ * It now runs in native for one second, to cause queue overflows,\n+ * then it comes back into Java to trigger the queue walking.\n+ * Repeats the cycle 5 times and verifies that the loss decreases from the first\n+ * to the last iteration.\n@@ -45,1 +53,1 @@\n- * @requires vm.hasJFR & os.family == \"linux\" & vm.debug\n+ * @requires vm.hasJFR & os.family == \"linux\" & vm.debug & vm.flagless\n@@ -57,4 +65,0 @@\n-    private static final String BURST_THREAD_NAME = \"Burst-Thread-1\";\n-\n-    static volatile boolean alive = true;\n-\n@@ -66,0 +70,2 @@\n+        private final List<Long> sampleEventsInTimeBox = new ArrayList<>();\n+        private final List<Long> timeBoxEnds = new ArrayList<>();\n@@ -77,1 +83,1 @@\n-        public List<LossEvent> getEventsPerInterval(long widthMillis, long stopTimeMillis) {\n+        public synchronized List<LossEvent> getEventsPerTimeBox() {\n@@ -79,2 +85,2 @@\n-            for (long start = 0; start < stopTimeMillis; start += widthMillis) {\n-                long actualStart = Math.min(start, stopTimeMillis - widthMillis);\n+            AtomicLong previousEnd = new AtomicLong(0);\n+            for (Long timeBoxEnd : timeBoxEnds) {\n@@ -82,1 +88,1 @@\n-                                          .filter(e -> e.relativeTimeMillis >= actualStart && e.relativeTimeMillis < actualStart + widthMillis)\n+                                          .filter(e -> e.relativeTimeMillis >= previousEnd.get() && e.relativeTimeMillis <= timeBoxEnd)\n@@ -85,1 +91,2 @@\n-                ret.add(new LossEvent(actualStart, lostSamples));\n+                ret.add(new LossEvent(previousEnd.get(), lostSamples));\n+                previousEnd.set(timeBoxEnd);\n@@ -90,0 +97,17 @@\n+        public synchronized void addTimeBoxEnd(long timeBoxEnd, long sampleEvents) {\n+            timeBoxEnds.add(timeBoxEnd);\n+            sampleEventsInTimeBox.add(sampleEvents);\n+        }\n+\n+        public synchronized void print() {\n+            System.out.println(\"Loss event information:\");\n+            for (int i = 0; i < timeBoxEnds.size(); i++) {\n+                System.out.println(\"  Time box end: \" + timeBoxEnds.get(i) + \", sample events: \" + sampleEventsInTimeBox.get(i));\n+            }\n+            for (LossEvent e : events) {\n+                System.out.println(\"  Lost samples event: \" + e.lostSamples + \" at \" + e.relativeTimeMillis);\n+            }\n+            for (LossEvent e : getEventsPerTimeBox()) {\n+                System.out.println(\"  Lost samples in time box ending at \" + e.relativeTimeMillis + \": \" + e.lostSamples);\n+            }\n+        }\n@@ -95,2 +119,2 @@\n-            AtomicLong firstSampleTimeMillis = new AtomicLong(0);\n-            AtomicLong lastSampleTimeMillis = new AtomicLong(0);\n+            long burstThreadId = Thread.currentThread().threadId();\n+            final long startTimeMillis = Instant.now().toEpochMilli();\n@@ -98,0 +122,1 @@\n+            AtomicLong sampleEventCountInTimeBox = new AtomicLong(0);\n@@ -99,8 +124,0 @@\n-            rs.onEvent(EventNames.CPUTimeSample, e -> {\n-                if (firstSampleTimeMillis.get() == 0 && e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n-                    firstSampleTimeMillis.set(e.getStartTime().toEpochMilli());\n-                }\n-                if (e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n-                    lastSampleTimeMillis.set(e.getStartTime().toEpochMilli());\n-                }\n-            });\n@@ -109,1 +126,1 @@\n-                if (e.getThread(\"eventThread\").getJavaName().equals(BURST_THREAD_NAME)) {\n+                if (e.getThread(\"eventThread\").getJavaThreadId() == burstThreadId) {\n@@ -111,2 +128,2 @@\n-                    long relativeTime = firstSampleTimeMillis.get() > 0 ? (eventTime - firstSampleTimeMillis.get()) : eventTime;\n-                    System.out.println(\"Lost samples: \" + e.getLong(\"lostSamples\") + \" at \" + relativeTime);\n+                    long relativeTime = eventTime - startTimeMillis;\n+                    System.out.println(\"Lost samples: \" + e.getLong(\"lostSamples\") + \" at \" + relativeTime + \" start time \" + startTimeMillis);\n@@ -116,1 +133,5 @@\n-            WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n+            rs.onEvent(EventNames.CPUTimeSample, e -> {\n+                if (e.getThread(\"eventThread\").getJavaThreadId() == burstThreadId) {\n+                    sampleEventCountInTimeBox.incrementAndGet();\n+                }\n+            });\n@@ -118,5 +139,5 @@\n-            \/\/ this thread runs all along\n-            Thread burstThread = new Thread(() -> WHITE_BOX.busyWait(11000));\n-            burstThread.setName(BURST_THREAD_NAME);\n-            burstThread.start();\n-            \/\/ now we toggle out-of-stack-walking off, wait 1 second and then turn it on for 500ms a few times\n+            \/\/ we disable the out-of-stack walking so that the queue fills up and overflows\n+            \/\/ while we are in native code\n+            disableOutOfStackWalking();\n+\n+\n@@ -124,13 +145,8 @@\n-                boolean supported = WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n-                if (!supported) {\n-                    System.out.println(\"Out-of-stack-walking not supported, skipping test\");\n-                    Asserts.assertFalse(true);\n-                    return;\n-                }\n-                Thread.sleep(700);\n-                long iterations = WHITE_BOX.cpuSamplerOutOfStackWalkingIterations();\n-                WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n-                Thread.sleep(300);\n-                while (WHITE_BOX.cpuSamplerOutOfStackWalkingIterations() == iterations) {\n-                    Thread.sleep(50); \/\/ just to make sure the stack walking really ran\n-                }\n+                \/\/ run in native for one second\n+                WHITE_BOX.busyWaitCPUTime(1000);\n+                \/\/ going out-of-native at the end of the previous call should have triggered\n+                \/\/ the safepoint handler, thereby also triggering the stack walking and creation\n+                \/\/ of the loss event\n+                WHITE_BOX.forceSafepoint(); \/\/ just to be sure\n+                lossEvents.addTimeBoxEnd(Instant.now().toEpochMilli() - startTimeMillis, sampleEventCountInTimeBox.get());\n+                sampleEventCountInTimeBox.set(0);\n@@ -138,0 +154,2 @@\n+\n+            rs.stop();\n@@ -139,1 +157,4 @@\n-            checkThatLossDecreased(lossEvents, lastSampleTimeMillis.get() - firstSampleTimeMillis.get());\n+\n+            enableOutOfStackWalking();\n+\n+            checkThatLossDecreased(lossEvents);\n@@ -143,10 +164,14 @@\n-    static void checkThatLossDecreased(LossEventCollection lossEvents, long lastSampleTimeMillis) {\n-        List<LossEvent> intervalLosses = lossEvents.getEventsPerInterval(1000, lastSampleTimeMillis);\n-        for (LossEvent interval : intervalLosses) {\n-            System.out.println(\"Lost samples in interval \" + interval.relativeTimeMillis + \": \" + interval.lostSamples);\n-        }\n-        \/\/ check that there are at least 3 intervals\n-        Asserts.assertTrue(intervalLosses.size() > 2);\n-        \/\/ check that the second to last interval has far fewer lost samples than the first\n-        Asserts.assertTrue(intervalLosses.get(intervalLosses.size() - 2).lostSamples <\n-                           intervalLosses.get(0).lostSamples \/ 2);\n+    static void disableOutOfStackWalking() {\n+        Asserts.assertTrue(WHITE_BOX.cpuSamplerSetOutOfStackWalking(false), \"Out-of-stack-walking not supported\");\n+    }\n+\n+    static void enableOutOfStackWalking() {\n+        WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n+    }\n+\n+    static void checkThatLossDecreased(LossEventCollection lossEvents) {\n+        lossEvents.print();\n+        List<LossEvent> timeBoxedLosses = lossEvents.getEventsPerTimeBox();\n+        \/\/ check that the last time box has far fewer lost samples than the first\n+        Asserts.assertTrue(timeBoxedLosses.get(timeBoxedLosses.size() - 1).lostSamples <=\n+                           timeBoxedLosses.get(0).lostSamples \/ 2);\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleQueueAutoSizes.java","additions":78,"deletions":53,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -848,1 +848,2 @@\n-  public native void busyWait(int cpuTimeMs);\n+  public native void busyWaitCPUTime(int cpuTimeMs);\n+\n@@ -853,2 +854,0 @@\n-  public native long cpuSamplerOutOfStackWalkingIterations();\n-\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}