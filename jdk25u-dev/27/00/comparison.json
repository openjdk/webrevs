{"files":[{"patch":"@@ -363,3 +363,12 @@\n-                if (t != null) {       \/\/ sift down\n-                    for (int cs; (cs = (k << 2) + 1) < n; ) {\n-                        ScheduledForkJoinTask<?> leastChild = null, c;\n+                if (t != null) {\n+                    while (k > 0) {    \/\/ sift up if replaced with smaller value\n+                        ScheduledForkJoinTask<?> parent; int pk;\n+                        if ((parent = h[pk = (k - 1) >>> 2]) == null ||\n+                            parent.when <= d)\n+                            break;\n+                        parent.heapIndex = k;\n+                        h[k] = parent;\n+                        k = pk;\n+                    }\n+                    for (int cs; (cs = (k << 2) + 1) < n; ) { \/\/ sift down\n+                        ScheduledForkJoinTask<?> leastChild = null;\n@@ -367,10 +376,4 @@\n-                        long leastValue = Long.MAX_VALUE;\n-                        for (int ck = cs, j = 4;;) { \/\/ at most 4 children\n-                            if ((c = h[ck]) == null)\n-                                break;\n-                            long cd = c.when;\n-                            if (c.status < 0 && alsoReplace < 0) {\n-                                alsoReplace = ck;    \/\/ at most once per pass\n-                                c.heapIndex = -1;\n-                            }\n-                            else if (leastChild == null || cd < leastValue) {\n+                        long leastValue = d;    \/\/ at most 4 children\n+                        for (int ck, j = 0; j < 4 && (ck = j + cs) < n; ++j) {\n+                            ScheduledForkJoinTask<?> c; long cd;\n+                            if ((c = h[ck]) != null && (cd = c.when) < leastValue) {\n@@ -381,2 +384,0 @@\n-                            if (--j == 0 || ++ck >= n)\n-                                break;\n@@ -384,1 +385,1 @@\n-                        if (leastChild == null || d <= leastValue)\n+                        if (leastChild == null) \/\/ already ordered\n@@ -386,2 +387,6 @@\n-                        leastChild.heapIndex = k;\n-                        h[k] = leastChild;\n+                        if ((h[k] = leastChild).status >= 0 || alsoReplace >= 0)\n+                            leastChild.heapIndex = k;\n+                        else {\n+                            leastChild.heapIndex = -1;\n+                            alsoReplace = k;\n+                        }\n@@ -396,0 +401,1 @@\n+        assert checkHeap(h, n);\n@@ -454,0 +460,27 @@\n+    \/**\n+     * Invariant checks\n+     *\/\n+    private static boolean checkHeap(ScheduledForkJoinTask<?>[] h, int n) {\n+        for (int i = 0; i < h.length; ++i) {\n+            ScheduledForkJoinTask<?> t = h[i];\n+            if (t == null) {         \/\/ unused slots all null\n+                if (i < n)\n+                    return false;\n+            }\n+            else {\n+                long v = t.when;\n+                int x = t.heapIndex;\n+                if (x != i && x >= 0) \/\/ valid index unless removing\n+                    return false;\n+                if (i > 0 && h[(i - 1) >>> 2].when > v) \/\/ ordered wrt parent\n+                    return false;\n+                int cs = (i << 2) + 1; \/\/ ordered wrt children\n+                for (int ck, j = 0; j < 4 && (ck = cs + j) < n; ++j) {\n+                    if (h[ck].when < v)\n+                        return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayScheduler.java","additions":51,"deletions":18,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8370887\n+ * @summary Test that cancelling a delayed task doesn't impact the ordering that other\n+ *     delayed tasks execute\n+ *\/\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedTransferQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class AscendingOrderAfterReplace {\n+\n+    private static final int[] DELAYS_IN_MS = { 3000, 3400, 3900, 3800, 3700, 3600, 3430, 3420, 3310, 3500, 3200 };\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 1; i < DELAYS_IN_MS.length; i++) {\n+            System.out.println(\"=== Test \" + i + \" ===\");\n+            while (!testCancel(DELAYS_IN_MS, i)) { }\n+        }\n+    }\n+\n+    \/**\n+     * Schedule the delayed tasks, cancel one of them, and check that the remaining tasks\n+     * execute in the ascending order of delay.\n+     * @return true if the test passed, false if a retry is needed\n+     * @throws RuntimeException if the test fails\n+     *\/\n+    private static boolean testCancel(int[] delays, int indexToCancel) throws Exception {\n+        log(\"Delayed tasks: \" + toString(delays));\n+\n+        \/\/ delayed tasks add to this queue when they execute\n+        var queue = new LinkedTransferQueue<Integer>();\n+\n+        \/\/ pool with one thread to ensure that delayed tasks don't execute concurrently\n+        try (var pool = new ForkJoinPool(1)) {\n+            long startNanos = System.nanoTime();\n+            Future<?>[] futures = Arrays.stream(delays)\n+                    .mapToObj(d -> pool.schedule(() -> {\n+                        log(\"Triggered \" + d);\n+                        queue.add(d);\n+                    }, d, MILLISECONDS))\n+                    .toArray(Future[]::new);\n+            long endNanos = System.nanoTime();\n+            log(\"Delayed tasks submitted\");\n+\n+            \/\/ check submit took < min diffs between two delays\n+            long submitTime = Duration.ofNanos(endNanos - startNanos).toMillis();\n+            long minDiff = minDifference(delays);\n+            if (submitTime >= minDiff) {\n+                log(\"Submit took >= \" + minDiff + \" ms, need to retry\");\n+                pool.shutdownNow();\n+                return false;\n+            }\n+\n+            \/\/ give a bit of time for -delayScheduler thread to process pending tasks\n+            Thread.sleep(minValue(delays) \/ 2);\n+            log(\"Cancel \" + delays[indexToCancel]);\n+            futures[indexToCancel].cancel(true);\n+        }\n+\n+        \/\/ delayed tasks should have executed in ascending order of their delay\n+        int[] executed = queue.stream().mapToInt(Integer::intValue).toArray();\n+        log(\"Executed: \" + toString(executed));\n+        if (!isAscendingOrder(executed)) {\n+            throw new RuntimeException(\"Not in ascending order!\");\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Return the minimum element.\n+     *\/\n+    private static int minValue(int[] array) {\n+        return IntStream.of(array).min().orElseThrow();\n+    }\n+\n+    \/**\n+     * Return the minimum difference between any two elements.\n+     *\/\n+    private static int minDifference(int[] array) {\n+        int[] sorted = array.clone();\n+        Arrays.sort(sorted);\n+        return IntStream.range(1, sorted.length)\n+                .map(i -> sorted[i] - sorted[i - 1])\n+                .min()\n+                .orElse(0);\n+    }\n+\n+    \/**\n+     * Return true if the array is in ascending order.\n+     *\/\n+    private static boolean isAscendingOrder(int[] array) {\n+        return IntStream.range(1, array.length)\n+                .allMatch(i -> array[i - 1] <= array[i]);\n+    }\n+\n+    \/**\n+     * Returns a String containing the elements of an array in index order.\n+     *\/\n+    private static String toString(int[] array) {\n+        return IntStream.of(array)\n+                .mapToObj(Integer::toString)\n+                .collect(Collectors.joining(\", \", \"[\", \"]\"));\n+    }\n+\n+    private static void log(String message) {\n+        System.out.println(Instant.now() + \" \" + message);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/DelayScheduler\/AscendingOrderAfterReplace.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}