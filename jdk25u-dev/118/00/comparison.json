{"files":[{"patch":"@@ -241,1 +241,1 @@\n-     * Returns the unique {@link java.io.Console Console} object associated\n+     * Returns the unique {@link Console Console} object associated\n@@ -245,0 +245,1 @@\n+     * @see Console\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        return new LazyDelegatingJdkConsoleImpl(inCharset, outCharset);\n+        return isTTY ? new LazyDelegatingJdkConsoleImpl(inCharset, outCharset) : null;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,2 +24,11 @@\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import static jdk.test.lib.Utils.*;\n@@ -29,1 +38,1 @@\n- * @bug 8341975 8351435\n+ * @bug 8341975 8351435 8361613\n@@ -32,6 +41,6 @@\n- * @modules jdk.internal.le\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=UTF-8 DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=ISO-8859-1 DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=US-ASCII DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le -Dstdout.encoding=foo DefaultCharsetTest\n- * @run junit\/othervm -Djdk.console=jdk.internal.le DefaultCharsetTest\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.JDKToolFinder\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run junit DefaultCharsetTest\n@@ -40,2 +49,24 @@\n-    @Test\n-    public void testDefaultCharset() {\n+    @BeforeAll\n+    static void checkExpectAvailability() {\n+        \/\/ check \"expect\" command availability\n+        var expect = Paths.get(\"\/usr\/bin\/expect\");\n+        Assumptions.assumeTrue(Files.exists(expect) && Files.isExecutable(expect),\n+            \"'\" + expect + \"' not found. Test ignored.\");\n+    }\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"UTF-8\", \"ISO-8859-1\", \"US-ASCII\", \"foo\", \"\"})\n+    void testDefaultCharset(String stdoutEncoding) throws Exception {\n+        \/\/ invoking \"expect\" command\n+        OutputAnalyzer oa = ProcessTools.executeProcess(\n+            \"expect\",\n+            \"-n\",\n+            TEST_SRC + \"\/defaultCharset.exp\",\n+            TEST_CLASSES,\n+            TEST_JDK + \"\/bin\/java\",\n+            \"-Dstdout.encoding=\" + stdoutEncoding,\n+            getClass().getName());\n+        oa.reportDiagnosticSummary();\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    public static void main(String... args) {\n@@ -45,7 +76,9 @@\n-        System.out.println(\"\"\"\n-                    stdout.encoding = %s\n-                    System.out.charset() = %s\n-                    System.console().charset() = %s\n-                \"\"\".formatted(stdoutEncoding, sysoutCharset.name(), consoleCharset.name()));\n-        assertEquals(consoleCharset, sysoutCharset,\n-            \"Charsets for System.out and Console differ for stdout.encoding: %s\".formatted(stdoutEncoding));\n+        System.out.printf(\"\"\"\n+                stdout.encoding = %s\n+                System.out.charset() = %s\n+                System.console().charset() = %s\n+            \"\"\", stdoutEncoding, sysoutCharset.name(), consoleCharset.name());\n+        if (!consoleCharset.equals(sysoutCharset)) {\n+            System.err.printf(\"Charsets for System.out and Console differ for stdout.encoding: %s%n\", stdoutEncoding);\n+            System.exit(-1);\n+        }\n","filename":"test\/jdk\/java\/io\/Console\/DefaultCharsetTest.java","additions":51,"deletions":18,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.io.File;\n@@ -29,0 +28,3 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.function.Predicate;\n@@ -30,0 +32,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -31,0 +34,4 @@\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.Test;\n+\n+import static jdk.test.lib.Utils.*;\n@@ -34,1 +41,1 @@\n- * @bug 8330276 8351435\n+ * @bug 8330276 8351435 8361613\n@@ -36,0 +43,1 @@\n+ * @requires (os.family == \"linux\") | (os.family == \"mac\")\n@@ -37,1 +45,5 @@\n- * @modules jdk.internal.le jdk.localedata\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.JDKToolFinder\n+ *        jdk.test.lib.process.ProcessTools\n+ * @modules jdk.localedata\n+ * @run junit LocaleTest\n@@ -40,2 +52,2 @@\n-    private static Calendar TODAY  = new GregorianCalendar(2024, Calendar.APRIL, 22);\n-    private static String FORMAT = \"%1$tY-%1$tB-%1$te %1$tA\";\n+    private static final Calendar TODAY = new GregorianCalendar(2024, Calendar.APRIL, 22);\n+    private static final String FORMAT = \"%1$tY-%1$tB-%1$te %1$tA\";\n@@ -45,1 +57,1 @@\n-    private static List<String> EXPECTED = List.of(\n+    private static final List<String> EXPECTED = List.of(\n@@ -56,25 +68,25 @@\n-    public static void main(String... args) throws Throwable {\n-        if (args.length == 0) {\n-            \/\/ no arg will launch the child process that actually perform tests\n-            var pb = ProcessTools.createTestJavaProcessBuilder(\n-                    \"-Djdk.console=jdk.internal.le\",\n-                    \"LocaleTest\", \"dummy\");\n-            var input = new File(System.getProperty(\"test.src\", \".\"), \"input.txt\");\n-            pb.redirectInput(input);\n-            var oa = ProcessTools.executeProcess(pb);\n-            if (oa.getExitValue() == -1) {\n-                System.out.println(\"System.console() returns null. Ignoring the test.\");\n-            } else {\n-                var output = oa.asLines();\n-                var resultText =\n-                    \"\"\"\n-                    Actual output: %s\n-                    Expected output: %s\n-                    \"\"\".formatted(output, EXPECTED);\n-                if (!output.equals(EXPECTED)) {\n-                    throw new RuntimeException(\"Standard out had unexpected strings:\\n\" + resultText);\n-                } else {\n-                    oa.shouldHaveExitValue(0);\n-                    System.out.println(\"Formatting with explicit Locale succeeded.\\n\" + resultText);\n-                }\n-            }\n+    @Test\n+    void testLocale() throws Exception {\n+        \/\/ check \"expect\" command availability\n+        var expect = Paths.get(\"\/usr\/bin\/expect\");\n+        Assumptions.assumeTrue(Files.exists(expect) && Files.isExecutable(expect),\n+            \"'\" + expect + \"' not found. Test ignored.\");\n+\n+        \/\/ invoking \"expect\" command\n+        OutputAnalyzer oa = ProcessTools.executeProcess(\n+            \"expect\",\n+            \"-n\",\n+            TEST_SRC + \"\/locale.exp\",\n+            TEST_CLASSES,\n+            TEST_JDK + \"\/bin\/java\",\n+            getClass().getName());\n+\n+        var stdout =\n+            oa.stdoutAsLines().stream().filter(Predicate.not(String::isEmpty)).toList();\n+        var resultText =\n+            \"\"\"\n+            Actual output: %s\n+            Expected output: %s\n+            \"\"\".formatted(stdout, EXPECTED);\n+        if (!stdout.equals(EXPECTED)) {\n+            throw new RuntimeException(\"Standard out had unexpected strings:\\n\" + resultText);\n@@ -82,11 +94,17 @@\n-            var con = System.console();\n-            if (con != null) {\n-                \/\/ tests these additional methods that take a Locale\n-                con.format(Locale.UK, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.printf(Locale.FRANCE, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readLine(Locale.GERMANY, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readPassword(Locale.of(\"es\"), FORMAT, TODAY);\n-                con.printf(\"\\n\");\n+            oa.shouldHaveExitValue(0);\n+            System.out.println(\"Formatting with explicit Locale succeeded.\\n\" + resultText);\n+        }\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        var con = System.console();\n+        if (con != null) {\n+            \/\/ tests these additional methods that take a Locale\n+            con.format(Locale.UK, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.printf(Locale.FRANCE, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readLine(Locale.GERMANY, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readPassword(Locale.of(\"es\"), FORMAT, TODAY);\n+            con.printf(\"\\n\");\n@@ -94,12 +112,11 @@\n-                \/\/ tests null locale\n-                con.format((Locale)null, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.printf((Locale)null, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readLine((Locale)null, FORMAT, TODAY);\n-                con.printf(\"\\n\");\n-                con.readPassword((Locale)null, FORMAT, TODAY);\n-            } else {\n-                \/\/ Exit with -1\n-                System.exit(-1);\n-            }\n+            \/\/ tests null locale\n+            con.format((Locale)null, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.printf((Locale)null, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readLine((Locale)null, FORMAT, TODAY);\n+            con.printf(\"\\n\");\n+            con.readPassword((Locale)null, FORMAT, TODAY);\n+        } else {\n+            \/\/ Exit with -1\n+            System.exit(-1);\n","filename":"test\/jdk\/java\/io\/Console\/LocaleTest.java","additions":71,"deletions":54,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8295803 8299689 8351435\n+ * @bug 8295803 8299689 8351435 8361613\n@@ -29,5 +29,4 @@\n- * @modules java.base\/java.io:+open\n- * @run main\/othervm ModuleSelectionTest java.base\n- * @run main\/othervm -Djdk.console=jdk.internal.le ModuleSelectionTest jdk.internal.le\n- * @run main\/othervm -Djdk.console=java.base ModuleSelectionTest java.base\n- * @run main\/othervm --limit-modules java.base ModuleSelectionTest java.base\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.process.ProcessTools\n+ * @run junit ModuleSelectionTest\n@@ -39,0 +38,12 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static jdk.test.lib.Utils.*;\n@@ -41,0 +52,39 @@\n+    private static Stream<Arguments> options() {\n+        return Stream.of(\n+            Arguments.of(\"-Djdk.console=foo\", \"java.base\"),\n+            Arguments.of(\"-Djdk.console=java.base\", \"java.base\"),\n+            Arguments.of(\"-Djdk.console=jdk.internal.le\", \"jdk.internal.le\"),\n+            Arguments.of(\"--limit-modules java.base\", \"java.base\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"options\")\n+    void testNonTTY(String opts) throws Exception {\n+        opts = opts +\n+            \" --add-opens java.base\/java.io=ALL-UNNAMED ModuleSelectionTest null\";\n+        OutputAnalyzer output = ProcessTools.executeTestJava(opts.split(\" \"));\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"options\")\n+    void testTTY(String opts, String expected) throws Exception {\n+        \/\/ check \"expect\" command availability\n+        var expect = Paths.get(\"\/usr\/bin\/expect\");\n+        Assumptions.assumeTrue(Files.exists(expect) && Files.isExecutable(expect),\n+            \"'\" + expect + \"' not found. Test ignored.\");\n+\n+        opts = \"expect -n \" + TEST_SRC + \"\/moduleSelection.exp \" +\n+            TEST_CLASSES + \" \" +\n+            expected + \" \" +\n+            TEST_JDK + \"\/bin\/java\" +\n+            \" --add-opens java.base\/java.io=ALL-UNNAMED \"\n+            + opts;\n+        \/\/ invoking \"expect\" command\n+        OutputAnalyzer output = ProcessTools.executeProcess(opts.split(\" \"));\n+        output.reportDiagnosticSummary();\n+        output.shouldHaveExitValue(0);\n+    }\n+\n@@ -52,4 +102,1 @@\n-        var expected = switch (args[0]) {\n-            case \"java.base\" -> istty ? \"java.base\" : \"null\";\n-            default -> args[0];\n-        };\n+        var expected = args[0];\n@@ -65,1 +112,1 @@\n-            System.out.printf(\"%s is the expected implementation. (tty: %s)\\n\", impl, istty);\n+            System.out.printf(\"%s is the expected implementation. (tty: %s)\\n\", actual, istty);\n","filename":"test\/jdk\/java\/io\/Console\/ModuleSelectionTest.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# simply invoking java under expect command\n+set classpath [lrange $argv 0 0]\n+set java [lrange $argv 1 1]\n+set stdoutProp [lrange $argv 2 2]\n+set clsname [lrange $argv 3 3]\n+eval spawn $java -classpath $classpath $stdoutProp $clsname\n+expect eof\n+set result [wait]\n+exit [lindex $result 3]\n","filename":"test\/jdk\/java\/io\/Console\/defaultCharset.exp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# simply invoking java under expect command\n+set classpath [lrange $argv 0 0]\n+set java [lrange $argv 1 1]\n+set clsname [lrange $argv 2 2]\n+eval spawn -noecho $java -classpath $classpath $clsname\n+\n+# sends CR 4 times (readLine x 2, readPassword x 2)\n+send \"\\r\"\n+send \"\\r\"\n+send \"\\r\"\n+send \"\\r\"\n+expect eof\n+set result [wait]\n+exit [lindex $result 3]\n","filename":"test\/jdk\/java\/io\/Console\/locale.exp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# simply invoking java under expect command\n+set classpath [lrange $argv 0 0]\n+set expected [lrange $argv 1 1]\n+set java [lrange $argv 2 2]\n+set opts [lrange $argv 3 end]\n+eval spawn $java $opts -classpath $classpath ModuleSelectionTest $expected\n+expect eof\n","filename":"test\/jdk\/java\/io\/Console\/moduleSelection.exp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n- * @bug 8305457 8342936 8351435 8344706\n+ * @bug 8305457 8342936 8351435 8344706 8361613\n@@ -56,1 +56,0 @@\n- * @modules jdk.internal.le\n@@ -81,16 +80,0 @@\n-        \/*\n-         * Unlike printTest, which tests a _default_ console that is normally\n-         * jdk.internal.org.jline.JdkConsoleProviderImpl, this test tests\n-         * jdk.internal.io.JdkConsoleImpl. Those console implementations operate\n-         * in different conditions and, thus, are tested separately.\n-         *\n-         * To test jdk.internal.io.JdkConsoleImpl one needs to ensure that both\n-         * conditions are met:\n-         *\n-         *   - a non-existent console provider is requested\n-         *   - isatty is true\n-         *\n-         * To achieve isatty, the test currently uses the EXPECT(1) Unix command,\n-         * which does not work for Windows. Later, a library like pty4j or JPty\n-         * might be used instead of EXPECT, to cover both Unix and Windows.\n-         *\/\n@@ -105,2 +88,0 @@\n-                    \"--enable-preview\",\n-                    \"-Djdk.console=gibberish\",\n@@ -133,1 +114,1 @@\n-        public void inputTestInteractive(String console, String prompt) throws Exception {\n+        public void inputTestInteractive(String prompt) throws Exception {\n@@ -141,3 +122,0 @@\n-            command.add(\"--enable-preview\");\n-            if (console != null)\n-                command.add(\"-Djdk.console=\" + console);\n@@ -155,3 +133,2 @@\n-            \/\/ cross product: consoles x prompts\n-            return Stream.of(\"jdk.internal.le\", \"gibberish\").flatMap(console -> Stream.of(null, \"?\", \"%s\", PROMPT_NONE)\n-                    .map(prompt -> new String[]{console, prompt}).map(Arguments::of));\n+            \/\/ prompts\n+            return Stream.of(null, \"?\", \"%s\", PROMPT_NONE).map(Arguments::of);\n@@ -161,21 +138,0 @@\n-    @ParameterizedTest\n-    @ValueSource(strings = {\"println\", \"print\"})\n-    public void printTest(String mode) throws Exception {\n-        var file = Path.of(System.getProperty(\"test.src\", \".\"), \"Output.java\")\n-                .toAbsolutePath().toString();\n-        var pb = ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", \"--enable-preview\", file, mode);\n-        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n-        assertEquals(0, output.getExitValue());\n-        assertTrue(output.getStderr().isEmpty());\n-        output.reportDiagnosticSummary();\n-        String out = output.getStdout();\n-        \/\/ The first half of the output is produced by Console, the second\n-        \/\/ half is produced by IO: those halves must match.\n-        \/\/ Executing Console and IO in the same VM (as opposed to\n-        \/\/ consecutive VM runs, which are cleaner) to be able to compare string\n-        \/\/ representation of objects.\n-        assertFalse(out.isBlank());\n-        assertEquals(out.substring(0, out.length() \/ 2),\n-                out.substring(out.length() \/ 2));\n-    }\n-\n@@ -196,1 +152,1 @@\n-        var pb = ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", \"--enable-preview\", file.toString());\n+        var pb = ProcessTools.createTestJavaProcessBuilder(file.toString());\n","filename":"test\/jdk\/java\/lang\/IO\/IO.java","additions":5,"deletions":49,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8331535 8351435 8347050\n+ * @bug 8331535 8351435 8347050 8361613\n@@ -28,1 +28,2 @@\n- * @modules jdk.internal.le\n+ * @modules java.base\/jdk.internal.io\n+ *          jdk.internal.le\/jdk.internal.org.jline\n@@ -30,1 +31,1 @@\n- * @run main\/othervm -Djdk.console=jdk.internal.le JLineConsoleProviderTest\n+ * @run main JLineConsoleProviderTest\n@@ -34,0 +35,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -36,0 +38,1 @@\n+import jdk.internal.org.jline.JdkConsoleProviderImpl;\n@@ -69,2 +72,7 @@\n-                ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", ConsoleTest.class.getName(),\n-                                                          testName);\n+                ProcessTools.createTestJavaProcessBuilder(\n+                    \"--add-exports\",\n+                    \"java.base\/jdk.internal.io=ALL-UNNAMED\",\n+                    \"--add-exports\",\n+                    \"jdk.internal.le\/jdk.internal.org.jline=ALL-UNNAMED\",\n+                    ConsoleTest.class.getName(),\n+                    testName);\n@@ -101,0 +109,2 @@\n+            \/\/ directly instantiate JLine JdkConsole, simulating isTTY=true\n+            var impl = new JdkConsoleProviderImpl().console(true, StandardCharsets.UTF_8, StandardCharsets.UTF_8);\n@@ -103,1 +113,1 @@\n-                    System.console().readLine(\"%%s\");\n+                    impl.readLine(null, \"%%s\");\n@@ -105,1 +115,1 @@\n-                    System.console().readPassword(\"%%s\");\n+                    impl.readPassword(null, \"%%s\");\n@@ -107,1 +117,1 @@\n-                    System.out.println(\"'\" + System.console().readLine() + \"'\");\n+                    System.out.println(\"'\" + impl.readLine() + \"'\");\n@@ -109,2 +119,2 @@\n-                    System.out.println(\"1: '\" +System.console().readLine() + \"'\");\n-                    System.out.println(\"2: '\" + System.console().readLine() + \"'\");\n+                    System.out.println(\"1: '\" + impl.readLine() + \"'\");\n+                    System.out.println(\"2: '\" + impl.readLine() + \"'\");\n","filename":"test\/jdk\/jdk\/internal\/jline\/JLineConsoleProviderTest.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8333086 8344706\n+ * @bug 8333086 8344706 8361613\n@@ -28,2 +28,3 @@\n- * @enablePreview\n- * @modules jdk.internal.le\/jdk.internal.org.jline.reader\n+ * @modules java.base\/jdk.internal.io\n+ *          jdk.internal.le\/jdk.internal.org.jline\n+ *          jdk.internal.le\/jdk.internal.org.jline.reader\n@@ -35,0 +36,3 @@\n+import java.nio.charset.StandardCharsets;\n+\n+import jdk.internal.org.jline.JdkConsoleProviderImpl;\n@@ -44,0 +48,1 @@\n+        \/\/ directly instantiate JLine JdkConsole, simulating isTTY=true\n@@ -46,10 +51,5 @@\n-                System.console().printf(\"Hello!\\n\");\n-                System.console().printf(\"Hello!\");\n-                System.console().format(\"\\nHello!\\n\");\n-                System.console().flush();\n-                IO.println(\"Hello!\");\n-                IO.print(\"Hello!\");\n-            }\n-            case \"read\" -> System.console().readLine(\"Hello!\");\n-            case \"IO-read\" -> {\n-                IO.readln(\"Hello!\");\n+                var impl = new JdkConsoleProviderImpl().console(true, StandardCharsets.UTF_8, StandardCharsets.UTF_8);\n+                impl.println(\"Hello!\\n\");\n+                impl.println(\"Hello!\");\n+                impl.format(null, \"\\nHello!\\n\");\n+                impl.flush();\n@@ -57,0 +57,3 @@\n+            case \"read\" -> new JdkConsoleProviderImpl()\n+                .console(true, StandardCharsets.UTF_8, StandardCharsets.UTF_8)\n+                .readLine(null, \"Hello!\");\n@@ -67,2 +70,1 @@\n-            new TestCase(\"read\", LineReader.class.getName(), null),\n-            new TestCase(\"IO-read\", null, Terminal.class.getName())\n+            new TestCase(\"read\", LineReader.class.getName(), null)\n@@ -72,3 +74,5 @@\n-                    ProcessTools.createTestJavaProcessBuilder(\"--enable-preview\",\n-                                                              \"-verbose:class\",\n-                                                              \"-Djdk.console=jdk.internal.le\",\n+                    ProcessTools.createTestJavaProcessBuilder(\"-verbose:class\",\n+                                                              \"--add-exports\",\n+                                                              \"java.base\/jdk.internal.io=ALL-UNNAMED\",\n+                                                              \"--add-exports\",\n+                                                              \"jdk.internal.le\/jdk.internal.org.jline=ALL-UNNAMED\",\n","filename":"test\/jdk\/jdk\/internal\/jline\/LazyJdkConsoleProvider.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1,181 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8330998 8351435\n- * @summary Verify that even if the stdout is redirected java.io.Console will\n- *          use it for writing.\n- * @modules jdk.internal.le\n- * @library \/test\/lib\n- * @run main RedirectedStdOut runRedirectAllTest\n- * @run main\/othervm --enable-native-access=ALL-UNNAMED RedirectedStdOut runRedirectOutOnly\n- *\/\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.SymbolLookup;\n-import java.lang.foreign.ValueLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class RedirectedStdOut {\n-    private static final String OUTPUT = \"Hello!\";\n-\n-    public static void main(String... args) throws Throwable {\n-        RedirectedStdOut.class.getDeclaredMethod(args[0])\n-                              .invoke(new RedirectedStdOut());\n-    }\n-\n-    \/\/verify the case where neither stdin\/out\/err is attached to a terminal,\n-    \/\/this test is weaker, but more reliable:\n-    void runRedirectAllTest() throws Exception {\n-        ProcessBuilder builder =\n-                ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", ConsoleTest.class.getName());\n-        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n-\n-        output.waitFor();\n-\n-        if (output.getExitValue() != 0) {\n-            throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n-                                     \", actualOut: \" + output.getStdout() +\n-                                     \", actualErr: \" + output.getStderr());\n-        }\n-\n-        String expectedOut = OUTPUT;\n-        String actualOut = output.getStdout();\n-\n-        if (!Objects.equals(expectedOut, actualOut)) {\n-            throw new AssertionError(\"Unexpected stdout content. \" +\n-                                     \"Expected: '\" + expectedOut + \"'\" +\n-                                     \", got: '\" + actualOut + \"'\");\n-        }\n-\n-        String expectedErr = \"\";\n-        String actualErr = output.getStderr();\n-\n-        if (!Objects.equals(expectedErr, actualErr)) {\n-            throw new AssertionError(\"Unexpected stderr content. \" +\n-                                     \"Expected: '\" + expectedErr + \"'\" +\n-                                     \", got: '\" + actualErr + \"'\");\n-        }\n-    }\n-\n-    \/\/verify the case where stdin is attached to a terminal,\n-    \/\/this test allocates pty, and it might be skipped, if the appropriate\n-    \/\/native functions cannot be found\n-    \/\/it also leaves the VM in a broken state (with a pty attached), and so\n-    \/\/should run in a separate VM instance\n-    void runRedirectOutOnly() throws Throwable {\n-        Path stdout = Path.of(\".\", \"stdout.txt\").toAbsolutePath();\n-\n-        Files.deleteIfExists(stdout);\n-\n-        Linker linker = Linker.nativeLinker();\n-        SymbolLookup stdlib = linker.defaultLookup();\n-        MemorySegment parent = Arena.global().allocate(ValueLayout.ADDRESS);\n-        MemorySegment child = Arena.global().allocate(ValueLayout.ADDRESS);\n-        Optional<MemorySegment> openptyAddress = stdlib.find(\"openpty\");\n-\n-        if (openptyAddress.isEmpty()) {\n-            System.out.println(\"Cannot lookup openpty.\");\n-            \/\/does not have forkpty, ignore\n-            return ;\n-        }\n-\n-        Optional<MemorySegment> loginttyAddress = stdlib.find(\"login_tty\");\n-\n-        if (loginttyAddress.isEmpty()) {\n-            System.out.println(\"Cannot lookup login_tty.\");\n-            \/\/does not have forkpty, ignore\n-            return ;\n-        }\n-\n-        FunctionDescriptor openttyDescriptor =\n-                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS,\n-                                      ValueLayout.ADDRESS);\n-        MethodHandle forkpty = linker.downcallHandle(openptyAddress.get(),\n-                                                     openttyDescriptor);\n-        int res = (int) forkpty.invoke(parent,\n-                                       child,\n-                                       MemorySegment.NULL,\n-                                       MemorySegment.NULL,\n-                                       MemorySegment.NULL);\n-\n-        if (res != 0) {\n-            throw new AssertionError();\n-        }\n-\n-        \/\/set the current VM's in\/out to the terminal:\n-        FunctionDescriptor loginttyDescriptor =\n-                FunctionDescriptor.of(ValueLayout.JAVA_INT,\n-                                      ValueLayout.JAVA_INT);\n-        MethodHandle logintty = linker.downcallHandle(loginttyAddress.get(),\n-                                                      loginttyDescriptor);\n-        logintty.invoke(child.get(ValueLayout.JAVA_INT, 0));\n-\n-        \/\/createTestJavaProcessBuilder logs to (current process') System.out, but\n-        \/\/that may not work since the redirect. Setting System.out to a scratch value:\n-        System.setOut(new PrintStream(new ByteArrayOutputStream()));\n-\n-        ProcessBuilder builder =\n-            ProcessTools.createTestJavaProcessBuilder(\"-Djdk.console=jdk.internal.le\", ConsoleTest.class.getName());\n-\n-        builder.inheritIO();\n-        builder.redirectOutput(stdout.toFile());\n-\n-        OutputAnalyzer output = ProcessTools.executeProcess(builder);\n-\n-        output.waitFor();\n-\n-        String expectedOut = OUTPUT;\n-        String actualOut = Files.readString(stdout);\n-\n-        if (!Objects.equals(expectedOut, actualOut)) {\n-            throw new AssertionError(\"Unexpected stdout content. \" +\n-                                     \"Expected: '\" + expectedOut + \"'\" +\n-                                     \", got: '\" + actualOut + \"'\");\n-        }\n-    }\n-\n-    public static class ConsoleTest {\n-        public static void main(String... args) {\n-            System.console().printf(OUTPUT);\n-            System.exit(0);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/jline\/RedirectedStdOut.java","additions":0,"deletions":181,"binary":false,"changes":181,"status":"deleted"}]}