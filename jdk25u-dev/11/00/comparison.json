{"files":[{"patch":"@@ -714,1 +714,1 @@\n-\/\/ Helper, on 32bit, for os::has_allocatable_memory_limit\n+\/\/ Helper, on 32bit, for os::commit_memory_limit\n@@ -732,0 +732,4 @@\n+size_t os::commit_memory_limit() {\n+  \/\/ On POSIX systems, the amount of memory that can be commmitted is limited\n+  \/\/ by the size of the reservable memory.\n+  size_t reserve_limit = reserve_memory_limit();\n@@ -733,12 +737,0 @@\n-bool os::has_allocatable_memory_limit(size_t* limit) {\n-  struct rlimit rlim;\n-  int getrlimit_res = getrlimit(RLIMIT_AS, &rlim);\n-  \/\/ if there was an error when calling getrlimit, assume that there is no limitation\n-  \/\/ on virtual memory.\n-  bool result;\n-  if ((getrlimit_res != 0) || (rlim.rlim_cur == RLIM_INFINITY)) {\n-    result = false;\n-  } else {\n-    *limit = (size_t)rlim.rlim_cur;\n-    result = true;\n-  }\n@@ -746,1 +738,1 @@\n-  return result;\n+  return reserve_limit;\n@@ -748,9 +740,5 @@\n-  \/\/ arbitrary virtual space limit for 32 bit Unices found by testing. If\n-  \/\/ getrlimit above returned a limit, bound it with this limit. Otherwise\n-  \/\/ directly use it.\n-  const size_t max_virtual_limit = 3800*M;\n-  if (result) {\n-    *limit = MIN2(*limit, max_virtual_limit);\n-  } else {\n-    *limit = max_virtual_limit;\n-  }\n+  \/\/ Arbitrary max reserve limit for 32 bit Unices found by testing.\n+  const size_t max_reserve_limit = 3800 * M;\n+\n+  \/\/ Bound the reserve limit with the arbitrary max.\n+  size_t actual_limit = MIN2(reserve_limit, max_reserve_limit);\n@@ -770,1 +758,1 @@\n-  size_t upper_limit = *limit;\n+  size_t upper_limit = actual_limit;\n@@ -774,1 +762,1 @@\n-    *limit = upper_limit;\n+    \/\/ The actual limit is allocatable, no need to do anything.\n@@ -778,1 +766,1 @@\n-    *limit = min_allocation_size;\n+    actual_limit = min_allocation_size;\n@@ -791,1 +779,1 @@\n-    *limit = lower_limit;\n+    actual_limit = lower_limit;\n@@ -793,1 +781,2 @@\n-  return true;\n+\n+  return actual_limit;\n@@ -797,0 +786,18 @@\n+size_t os::reserve_memory_limit() {\n+  struct rlimit rlim;\n+  int getrlimit_res = getrlimit(RLIMIT_AS, &rlim);\n+\n+  \/\/ If there was an error calling getrlimit, conservatively assume no limit.\n+  if (getrlimit_res != 0) {\n+    return SIZE_MAX;\n+  }\n+\n+  \/\/ If the current limit is not infinity, there is a limit.\n+  if (rlim.rlim_cur != RLIM_INFINITY) {\n+    return (size_t)rlim.rlim_cur;\n+  }\n+\n+  \/\/ No limit\n+  return SIZE_MAX;\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -900,7 +900,0 @@\n-bool os::has_allocatable_memory_limit(size_t* limit) {\n-  MEMORYSTATUSEX ms;\n-  ms.dwLength = sizeof(ms);\n-  GlobalMemoryStatusEx(&ms);\n-  *limit = (size_t)ms.ullAvailVirtual;\n-  return true;\n-}\n@@ -3294,0 +3287,12 @@\n+size_t os::commit_memory_limit() {\n+  MEMORYSTATUSEX ms;\n+  ms.dwLength = sizeof(ms);\n+  GlobalMemoryStatusEx(&ms);\n+  return (size_t)ms.ullAvailVirtual;\n+}\n+\n+size_t os::reserve_memory_limit() {\n+  \/\/ Virtual address space cannot be limited on Windows.\n+  return SIZE_MAX;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,11 +33,0 @@\n-static size_t address_space_limit() {\n-  size_t limit = 0;\n-\n-  if (os::has_allocatable_memory_limit(&limit)) {\n-    return limit;\n-  }\n-\n-  \/\/ No limit\n-  return SIZE_MAX;\n-}\n-\n@@ -46,1 +35,1 @@\n-  const size_t limit = address_space_limit() \/ MaxVirtMemFraction;\n+  const size_t limit = os::reserve_memory_limit() \/ MaxVirtMemFraction;\n@@ -51,1 +40,1 @@\n-  const size_t limit = address_space_limit();\n+  const size_t limit = os::reserve_memory_limit();\n","filename":"src\/hotspot\/share\/gc\/z\/zAddressSpaceLimit.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1473,13 +1473,10 @@\n-  size_t max_allocatable;\n-  size_t result = limit;\n-  if (os::has_allocatable_memory_limit(&max_allocatable)) {\n-    \/\/ The AggressiveHeap check is a temporary workaround to avoid calling\n-    \/\/ GCarguments::heap_virtual_to_physical_ratio() before a GC has been\n-    \/\/ selected. This works because AggressiveHeap implies UseParallelGC\n-    \/\/ where we know the ratio will be 1. Once the AggressiveHeap option is\n-    \/\/ removed, this can be cleaned up.\n-    size_t heap_virtual_to_physical_ratio = (AggressiveHeap ? 1 : GCConfig::arguments()->heap_virtual_to_physical_ratio());\n-    size_t fraction = MaxVirtMemFraction * heap_virtual_to_physical_ratio;\n-    result = MIN2(result, max_allocatable \/ fraction);\n-  }\n-  return result;\n+  \/\/ The AggressiveHeap check is a temporary workaround to avoid calling\n+  \/\/ GCarguments::heap_virtual_to_physical_ratio() before a GC has been\n+  \/\/ selected. This works because AggressiveHeap implies UseParallelGC\n+  \/\/ where we know the ratio will be 1. Once the AggressiveHeap option is\n+  \/\/ removed, this can be cleaned up.\n+  size_t heap_virtual_to_physical_ratio = (AggressiveHeap ? 1 : GCConfig::arguments()->heap_virtual_to_physical_ratio());\n+  size_t fraction = MaxVirtMemFraction * heap_virtual_to_physical_ratio;\n+  size_t max_allocatable = os::commit_memory_limit();\n+\n+  return MIN2(limit, max_allocatable \/ fraction);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -348,1 +348,0 @@\n-  static bool has_allocatable_memory_limit(size_t* limit);\n@@ -457,0 +456,10 @@\n+  \/\/ Returns an upper limit beyond which reserve_memory() calls are guaranteed\n+  \/\/ to fail. It is not guaranteed that reserving less memory than this will\n+  \/\/ succeed, however.\n+  static size_t reserve_memory_limit();\n+\n+  \/\/ Returns an upper limit beyond which commit_memory() calls are guaranteed\n+  \/\/ to fail. It is not guaranteed that committing less memory than this will\n+  \/\/ succeed, however.\n+  static size_t commit_memory_limit();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}