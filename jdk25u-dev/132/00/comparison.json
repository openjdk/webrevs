{"files":[{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -94,1 +93,1 @@\n-  size_t capacity    = _space_info->soft_max_capacity();\n+  size_t capacity    = ShenandoahHeap::heap()->soft_max_capacity();\n@@ -236,2 +235,2 @@\n-  size_t capacity = _space_info->soft_max_capacity();\n-  size_t available = _space_info->soft_available();\n+  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n+  size_t available = _space_info->soft_mutator_available();\n@@ -240,2 +239,3 @@\n-  log_debug(gc)(\"should_start_gc? available: %zu, soft_max_capacity: %zu\"\n-                \", allocated: %zu\", available, capacity, allocated);\n+  log_debug(gc, ergo)(\"should_start_gc calculation: available: \" PROPERFMT \", soft_max_capacity: \"  PROPERFMT \", \"\n+                \"allocated_since_gc_start: \"  PROPERFMT,\n+                PROPERFMTARGS(available), PROPERFMTARGS(capacity), PROPERFMTARGS(allocated));\n@@ -254,3 +254,2 @@\n-    log_trigger(\"Free (%zu%s) is below minimum threshold (%zu%s)\",\n-                 byte_size_in_proper_unit(available), proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n+    log_trigger(\"Free (Soft) (\" PROPERFMT \") is below minimum threshold (\" PROPERFMT \")\",\n+                 PROPERFMTARGS(available), PROPERFMTARGS(min_threshold));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -49,3 +48,3 @@\n-  size_t max_capacity = _space_info->max_capacity();\n-  size_t capacity = _space_info->soft_max_capacity();\n-  size_t available = _space_info->available();\n+  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n+  size_t available = _space_info->soft_mutator_available();\n+  size_t bytes_allocated = _space_info->bytes_allocated_since_gc_start();\n@@ -53,3 +52,3 @@\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+  log_debug(gc, ergo)(\"should_start_gc calculation: available: \" PROPERFMT \", soft_max_capacity: \"  PROPERFMT \", \"\n+                \"allocated_since_gc_start: \"  PROPERFMT,\n+                PROPERFMTARGS(available), PROPERFMTARGS(capacity), PROPERFMTARGS(bytes_allocated));\n@@ -61,1 +60,1 @@\n-    log_trigger(\"Free (%zu%s) is below minimum threshold (%zu%s)\",\n+    log_trigger(\"Free (Soft) (%zu%s) is below minimum threshold (%zu%s)\",\n@@ -68,1 +67,0 @@\n-  size_t bytes_allocated = _space_info->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  virtual size_t soft_max_capacity() const = 0;\n@@ -42,1 +41,1 @@\n-  virtual size_t soft_available() const = 0;\n+  virtual size_t soft_mutator_available() const = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -44,3 +43,3 @@\n-  size_t max_capacity = _space_info->max_capacity();\n-  size_t capacity = _space_info->soft_max_capacity();\n-  size_t available = _space_info->available();\n+  size_t capacity = ShenandoahHeap::heap()->soft_max_capacity();\n+  size_t available = _space_info->soft_mutator_available();\n+  size_t allocated = _space_info->bytes_allocated_since_gc_start();\n@@ -48,3 +47,3 @@\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+  log_debug(gc, ergo)(\"should_start_gc calculation: available: \" PROPERFMT \", soft_max_capacity: \"  PROPERFMT \", \"\n+                \"allocated_since_gc_start: \"  PROPERFMT,\n+                PROPERFMTARGS(available), PROPERFMTARGS(capacity), PROPERFMTARGS(allocated));\n@@ -55,3 +54,2 @@\n-    log_trigger(\"Free (%zu%s) is below minimum threshold (%zu%s)\",\n-                 byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(threshold_available), proper_unit_for_byte_size(threshold_available));\n+    log_trigger(\"Free (Soft) (\" PROPERFMT \") is below minimum threshold (\" PROPERFMT \")\",\n+                 PROPERFMTARGS(available), PROPERFMTARGS(threshold_available));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1889,0 +1889,23 @@\n+void ShenandoahFreeSet::log_freeset_stats(ShenandoahFreeSetPartitionId partition_id, LogStream& ls) {\n+  size_t max = 0;\n+  size_t total_free = 0;\n+  size_t total_used = 0;\n+\n+  for (idx_t idx = _partitions.leftmost(partition_id);\n+        idx <= _partitions.rightmost(partition_id); idx++) {\n+    if (_partitions.in_free_set(partition_id, idx)) {\n+      ShenandoahHeapRegion *r = _heap->get_region(idx);\n+      size_t free = alloc_capacity(r);\n+      max = MAX2(max, free);\n+      total_free += free;\n+      total_used += r->used();\n+    }\n+  }\n+\n+  ls.print(\" %s freeset stats: Partition count: %zu, Reserved: \" PROPERFMT \", Max free available in a single region: \" PROPERFMT \";\",\n+            partition_name(partition_id),\n+            _partitions.count(partition_id),\n+            PROPERFMTARGS(total_free), PROPERFMTARGS(max)\n+          );\n+}\n+\n@@ -2004,8 +2027,6 @@\n-      assert(free == total_free, \"Free memory should match\");\n-      ls.print(\"Free: %zu%s, Max: %zu%s regular, %zu%s humongous, \",\n-               byte_size_in_proper_unit(total_free),    proper_unit_for_byte_size(total_free),\n-               byte_size_in_proper_unit(max),           proper_unit_for_byte_size(max),\n-               byte_size_in_proper_unit(max_humongous), proper_unit_for_byte_size(max_humongous)\n-      );\n-\n-      ls.print(\"Frag: \");\n+      assert(free == total_free, \"Free memory (%zu) should match calculated memory (%zu)\", free, total_free);\n+      ls.print(\"Whole heap stats: Total free: \" PROPERFMT \", Total used: \" PROPERFMT \", Max free in a single region: \" PROPERFMT\n+               \", Max humongous: \" PROPERFMT \"; \",\n+               PROPERFMTARGS(total_free), PROPERFMTARGS(total_used), PROPERFMTARGS(max), PROPERFMTARGS(max_humongous));\n+\n+      ls.print(\"Frag stats: \");\n@@ -2018,1 +2039,1 @@\n-      ls.print(\"%zu%% external, \", frag_ext);\n+      ls.print(\"External: %zu%%, \", frag_ext);\n@@ -2027,25 +2048,1 @@\n-      ls.print(\"%zu%% internal; \", frag_int);\n-      ls.print(\"Used: %zu%s, Mutator Free: %zu\",\n-               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used),\n-               _partitions.count(ShenandoahFreeSetPartitionId::Mutator));\n-    }\n-\n-    {\n-      size_t max = 0;\n-      size_t total_free = 0;\n-      size_t total_used = 0;\n-\n-      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n-           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx++) {\n-        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx)) {\n-          ShenandoahHeapRegion *r = _heap->get_region(idx);\n-          size_t free = alloc_capacity(r);\n-          max = MAX2(max, free);\n-          total_free += free;\n-          total_used += r->used();\n-        }\n-      }\n-      ls.print(\" Collector Reserve: %zu%s, Max: %zu%s; Used: %zu%s\",\n-               byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),\n-               byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max),\n-               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used));\n+      ls.print(\"Internal: %zu%%; \", frag_int);\n@@ -2054,0 +2051,2 @@\n+    log_freeset_stats(ShenandoahFreeSetPartitionId::Mutator, ls);\n+    log_freeset_stats(ShenandoahFreeSetPartitionId::Collector, ls);\n@@ -2055,18 +2054,1 @@\n-      size_t max = 0;\n-      size_t total_free = 0;\n-      size_t total_used = 0;\n-\n-      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector);\n-           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector); idx++) {\n-        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, idx)) {\n-          ShenandoahHeapRegion *r = _heap->get_region(idx);\n-          size_t free = alloc_capacity(r);\n-          max = MAX2(max, free);\n-          total_free += free;\n-          total_used += r->used();\n-        }\n-      }\n-      ls.print_cr(\" Old Collector Reserve: %zu%s, Max: %zu%s; Used: %zu%s\",\n-                  byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),\n-                  byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max),\n-                  byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used));\n+      log_freeset_stats(ShenandoahFreeSetPartitionId::OldCollector, ls);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":34,"deletions":52,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -410,0 +411,1 @@\n+  void log_freeset_stats(ShenandoahFreeSetPartitionId partition_id, LogStream& ls);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  const size_t v_soft_max_capacity = soft_max_capacity();\n+  const size_t v_soft_max_capacity = ShenandoahHeap::heap()->soft_max_capacity();\n@@ -800,2 +800,1 @@\n-                                           size_t max_capacity,\n-                                           size_t soft_max_capacity) :\n+                                           size_t max_capacity) :\n@@ -807,1 +806,1 @@\n-  _max_capacity(max_capacity), _soft_max_capacity(soft_max_capacity),\n+  _max_capacity(max_capacity),\n@@ -952,2 +951,3 @@\n-size_t ShenandoahGeneration::soft_available() const {\n-  return available(soft_max_capacity());\n+size_t ShenandoahGeneration::soft_mutator_available() const {\n+  size_t result = available(ShenandoahHeap::heap()->soft_max_capacity() * (100.0 - ShenandoahEvacReserve) \/ 100);\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  size_t _soft_max_capacity;\n@@ -108,2 +107,1 @@\n-                       size_t max_capacity,\n-                       size_t soft_max_capacity);\n+                       size_t max_capacity);\n@@ -129,1 +127,0 @@\n-  size_t soft_max_capacity() const override { return _soft_max_capacity; }\n@@ -145,1 +142,1 @@\n-  size_t soft_available() const override;\n+  size_t soft_mutator_available() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,15 +56,0 @@\n-\n-  void print_heap() override {\n-    ShenandoahInitLogger::print_heap();\n-\n-    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n-\n-    ShenandoahYoungGeneration* young = heap->young_generation();\n-    log_info(gc, init)(\"Young Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(young->soft_max_capacity()));\n-    log_info(gc, init)(\"Young Generation Max: \" EXACTFMT, EXACTFMTARGS(young->max_capacity()));\n-\n-    ShenandoahOldGeneration* old = heap->old_generation();\n-    log_info(gc, init)(\"Old Generation Soft Size: \" EXACTFMT, EXACTFMTARGS(old->soft_max_capacity()));\n-    log_info(gc, init)(\"Old Generation Max: \" EXACTFMT, EXACTFMTARGS(old->max_capacity()));\n-  }\n-\n@@ -144,2 +129,2 @@\n-  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young, initial_capacity_young);\n-  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old, initial_capacity_old);\n+  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young);\n+  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,4 +53,0 @@\n-size_t ShenandoahGlobalGeneration::soft_max_capacity() const {\n-  return ShenandoahHeap::heap()->soft_max_capacity();\n-}\n-\n@@ -64,9 +60,0 @@\n-size_t ShenandoahGlobalGeneration::soft_available() const {\n-  size_t available = this->available();\n-\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  assert(max_capacity() >= soft_max_capacity(), \"Max capacity must be greater than soft max capacity.\");\n-  size_t soft_tail = max_capacity() - soft_max_capacity();\n-  return (available > soft_tail) ? (available - soft_tail) : 0;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n-  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues, max_capacity, soft_max_capacity) { }\n+  ShenandoahGlobalGeneration(bool generational, uint max_queues, size_t max_capacity)\n+  : ShenandoahGeneration(generational ? GLOBAL : NON_GEN, max_queues, max_capacity) { }\n@@ -42,1 +42,0 @@\n-  size_t soft_max_capacity() const override;\n@@ -46,1 +45,0 @@\n-  size_t soft_available() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -204,2 +205,1 @@\n-  \/\/ Default to max heap size.\n-  _soft_max_size = _num_regions * reg_size_bytes;\n+  _soft_max_size = SoftMaxHeapSize;\n@@ -527,1 +527,1 @@\n-  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers(), max_capacity(), max_capacity());\n+  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers(), max_capacity());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  log_info(gc, init)(\"Soft Max Heap Size: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeap::heap()->soft_max_capacity()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -199,2 +199,2 @@\n-ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity)\n-  : ShenandoahGeneration(OLD, max_queues, max_capacity, soft_max_capacity),\n+ShenandoahOldGeneration::ShenandoahOldGeneration(uint max_queues, size_t max_capacity)\n+  : ShenandoahGeneration(OLD, max_queues, max_capacity),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  ShenandoahOldGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity);\n+  ShenandoahOldGeneration(uint max_queues, size_t max_capacity);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t soft_max_capacity) :\n-  ShenandoahGeneration(YOUNG, max_queues, max_capacity, soft_max_capacity),\n+ShenandoahYoungGeneration::ShenandoahYoungGeneration(uint max_queues, size_t max_capacity) :\n+  ShenandoahGeneration(YOUNG, max_queues, max_capacity),\n@@ -105,2 +105,2 @@\n-size_t ShenandoahYoungGeneration::soft_available() const {\n-  size_t available = this->ShenandoahGeneration::soft_available();\n+size_t ShenandoahYoungGeneration::soft_mutator_available() const {\n+  size_t available = this->ShenandoahGeneration::soft_mutator_available();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity, size_t max_soft_capacity);\n+  ShenandoahYoungGeneration(uint max_queues, size_t max_capacity);\n@@ -77,4 +77,1 @@\n-\n-  \/\/ Do not override available_with_reserve() because that needs to see memory reserved for Collector\n-\n-  size_t soft_available() const override;\n+  size_t soft_mutator_available() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    old = new ShenandoahOldGeneration(8, 1024 * 1024, 1024);\n+    old = new ShenandoahOldGeneration(8, 1024 * 1024);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-\/*\n- * @test id=passive\n+\/**\n+ * @test id=satb-adaptive\n@@ -31,2 +31,3 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n@@ -34,1 +35,1 @@\n- *      -Dtarget=10000\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n@@ -37,5 +38,0 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n- *      -XX:-ShenandoahDegeneratedGC\n- *      -Dtarget=10000\n- *      TestDynamicSoftMaxHeapSize\n@@ -44,2 +40,2 @@\n-\/*\n- * @test id=aggressive\n+\/**\n+ * @test id=satb-aggressive\n@@ -49,3 +45,5 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive\n- *      -Dtarget=1000\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=aggressive\n@@ -53,0 +51,1 @@\n+ *\n@@ -55,2 +54,2 @@\n-\/*\n- * @test id=adaptive\n+\/**\n+ * @test id=satb-compact\n@@ -60,3 +59,5 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive\n- *      -Dtarget=10000\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=compact\n@@ -64,0 +65,1 @@\n+ *\n@@ -66,2 +68,2 @@\n-\/*\n- * @test id=generational\n+\/**\n+ * @test id=satb-static\n@@ -71,3 +73,5 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n- *      -Dtarget=10000\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=static\n@@ -75,0 +79,1 @@\n+ *\n@@ -77,2 +82,2 @@\n-\/*\n- * @test id=static\n+\/**\n+ * @test id=passive\n@@ -83,1 +88,8 @@\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=static\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -Dtarget=10000\n+ *      TestDynamicSoftMaxHeapSize\n+ *\n+ * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive\n+ *      -XX:-ShenandoahDegeneratedGC\n@@ -88,2 +100,2 @@\n-\/*\n- * @test id=compact\n+\/**\n+ * @test id=generational\n@@ -93,4 +105,6 @@\n- * @run main\/othervm -Xms16m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=compact\n- *      -Dtarget=1000\n- *     TestDynamicSoftMaxHeapSize\n+ * @run main\/othervm -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestDynamicSoftMaxHeapSize\n+ *\n@@ -99,1 +113,12 @@\n-import java.util.Random;\n+\/**\n+ * @test id=generational-softMaxHeapSizeValidation\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -DvalidateSoftMaxHeap=true\n+ *      TestDynamicSoftMaxHeapSize\n+ *      -Xms100m -Xmx512m -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info -Dtarget=10000 -DverifySoftMaxHeapValue=true\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *\/\n@@ -105,0 +130,5 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n@@ -106,0 +136,7 @@\n+    static final int K = 1024;\n+    static final int XMS_MB = 100;\n+    static final int XMX_MB = 512;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (\"true\".equals(System.getProperty(\"validateSoftMaxHeap\"))) {\n+            List<String> flagArgs = new ArrayList<>(Arrays.asList(args));\n@@ -107,2 +144,4 @@\n-    static final long TARGET_MB = Long.getLong(\"target\", 10_000); \/\/ 10 Gb allocation\n-    static final long STRIDE = 10_000_000;\n+            int softMaxInMb = Utils.getRandomInstance().nextInt(XMS_MB, XMX_MB);\n+            flagArgs.add(\"-DsoftMaxCapacity=\" + softMaxInMb * K * K);\n+            flagArgs.add(\"-Dtest.jdk=\" + System.getProperty(\"test.jdk\"));\n+            flagArgs.add(\"-Dcompile.jdk=\" + System.getProperty(\"compile.jdk\"));\n@@ -110,1 +149,1 @@\n-    static volatile Object sink;\n+            flagArgs.add(SoftMaxWithExpectationTest.class.getName());\n@@ -112,10 +151,27 @@\n-    public static void main(String[] args) throws Exception {\n-        long count = TARGET_MB * 1024 * 1024 \/ 16;\n-        Random r = Utils.getRandomInstance();\n-        PidJcmdExecutor jcmd = new PidJcmdExecutor();\n-\n-        for (long c = 0; c < count; c += STRIDE) {\n-            \/\/ Sizes specifically include heaps below Xms and above Xmx to test saturation code.\n-            jcmd.execute(\"VM.set_flag SoftMaxHeapSize \" + r.nextInt(768*1024*1024), true);\n-            for (long s = 0; s < STRIDE; s++) {\n-                sink = new Object();\n+            ProcessBuilder genShenPbValidateFlag = ProcessTools.createLimitedTestJavaProcessBuilder(flagArgs);\n+            OutputAnalyzer output = new OutputAnalyzer(genShenPbValidateFlag.start());\n+            output.shouldHaveExitValue(0);\n+            output.shouldContain(String.format(\"Soft Max Heap Size: %dM -> %dM\", XMX_MB, softMaxInMb)); \/\/ By default, the soft max heap size is Xmx\n+        } else {\n+            SoftMaxSetFlagOnlyTest.test();\n+        }\n+    }\n+\n+    public static class SoftMaxSetFlagOnlyTest {\n+        static final long TARGET_MB = Long.getLong(\"target\", 10_000); \/\/ 10 Gb allocation\n+        static final long STRIDE = 10_000_000;\n+\n+        static volatile Object sink;\n+\n+        public static void test() throws Exception {\n+            long count = TARGET_MB * 1024 * 1024 \/ 16;\n+            Random r = Utils.getRandomInstance();\n+            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n+\n+            for (long c = 0; c < count; c += STRIDE) {\n+                \/\/ Sizes specifically include heaps below Xms and above Xmx to test saturation code.\n+                jcmd.execute(\"VM.set_flag SoftMaxHeapSize \" + r.nextInt(768*1024*1024), true);\n+                for (long s = 0; s < STRIDE; s++) {\n+                    sink = new Object();\n+                }\n+                Thread.sleep(1);\n@@ -123,1 +179,0 @@\n-            Thread.sleep(1);\n@@ -127,0 +182,15 @@\n+    public static class SoftMaxWithExpectationTest {\n+        static final long TOTAL = 100_000_000;\n+\n+        static volatile Object sink;\n+\n+        public static void main(String[] args) throws Exception {\n+            int expectedSoftMaxHeapSize = Integer.getInteger(\"softMaxCapacity\", 0);\n+            PidJcmdExecutor jcmd = new PidJcmdExecutor();\n+            jcmd.execute(\"VM.set_flag SoftMaxHeapSize \" + expectedSoftMaxHeapSize, false);\n+\n+            for (long s = 0; s < TOTAL; s++) {\n+                sink = new Object();\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestDynamicSoftMaxHeapSize.java","additions":119,"deletions":49,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test id=satb-adaptive\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @bug 8372543\n+ * @summary When soft max heap size < Xmx, we had a bug reported in JBS-8372543 where available size was undercalculated.\n+ *          This caused excessive GC runs.\n+ *\n+ * @run main\/othervm -XX:SoftMaxHeapSize=512m -Xmx2g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestSoftMaxHeapSizeAvailableCalc\n+ *\/\n+\n+\/**\n+ * @test id=satb-static\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:SoftMaxHeapSize=512m -Xmx2g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=static\n+ *      TestSoftMaxHeapSizeAvailableCalc\n+ *\/\n+\n+\/**\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:SoftMaxHeapSize=512m -Xmx2g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestSoftMaxHeapSizeAvailableCalc\n+ *\n+ *\/\n+import java.lang.management.ManagementFactory;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+import com.sun.management.GarbageCollectorMXBean;\n+\n+public class TestSoftMaxHeapSizeAvailableCalc {\n+    public static void main(String[] args) throws Exception {\n+        Allocate.test();\n+    }\n+\n+    \/\/ This test runs an app that has a stable heap of ~300M and allocates temporary garbage at ~100M\/s\n+    \/\/ Soft max: 512M, ShenandoahMinFreeThreshold: 10 (default), ShenandoahEvacReserve: 5 (default)\n+    \/\/ Soft max for mutator: 512M * (100.0 - 5) \/ 100 = 486.4M\n+    \/\/ Threshold to trigger gc: 486.4M - 512 * 10 \/ 100.0 = 435.2M, just above (300 + 100)M.\n+    \/\/ Expect gc count to be less than 1 \/ sec.\n+    public static class Allocate {\n+        static final List<byte[]> longLived = new ArrayList<>();\n+\n+        public static void test() throws Exception {\n+            final int expectedMaxGcCount = Integer.getInteger(\"expectedMaxGcCount\", 30);\n+            List<java.lang.management.GarbageCollectorMXBean> collectors = ManagementFactory.getGarbageCollectorMXBeans();\n+            java.lang.management.GarbageCollectorMXBean cycleCollector = null;\n+            for (java.lang.management.GarbageCollectorMXBean bean : collectors) {\n+                if (bean.getName().contains(\"Cycles\")) {\n+                    cycleCollector = bean;\n+                }\n+            }\n+\n+            \/\/ Allocate ~300MB of long-lived objects\n+            for (int i = 0; i < 300; i++) {\n+                longLived.add(new byte[1_000_000]);\n+            }\n+\n+            \/\/ allocate short-lived garbage to the heap\n+            long end = System.currentTimeMillis() + 30_000; \/\/ 30 seconds\n+\n+            while (System.currentTimeMillis() < end) {\n+                byte[] garbage = new byte[1_000_000];\n+                garbage[0] = 1; \/\/ prevent optimization\n+\n+                Thread.sleep(10); \/\/ Pace to generate garbage at speed of ~100M\/s\n+            }\n+\n+            long gcCount = cycleCollector.getCollectionCount();\n+            Asserts.assertLessThan(gcCount, (long) expectedMaxGcCount, \"GC was triggered too many times. Expected to be less than: \" + expectedMaxGcCount + \", triggered: \" + gcCount);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSoftMaxHeapSizeAvailableCalc.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}