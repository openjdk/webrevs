{"files":[{"patch":"@@ -1,1 +1,8 @@\n-# Welcome to the JDK!\n+# Welcome to OpenJDK 25 Updates!\n+\n+The JDK 25 Updates project uses two GitHub repositories.\n+Updates are continuously developed in the repository [jdk25u-dev](https:\/\/github.com\/openjdk\/jdk25u-dev). This is the repository usually targeted by contributors.\n+The [jdk25u](https:\/\/github.com\/openjdk\/jdk25u) repository is used for rampdown of the update releases of jdk25u and only accepts critical changes that must make the next release during rampdown. (You probably do not want to target jdk25u).\n+\n+For more OpenJDK 25 updates specific information such as timelines and contribution guidelines see the [project wiki page](https:\/\/wiki.openjdk.org\/display\/JDKUpdates\/JDK+25u\/).\n+\n","filename":"README.md","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -112,0 +112,4 @@\n+  if (!SuperwordUseVSX && FLAG_IS_DEFAULT(EnableVectorSupport)) {\n+    \/\/ VectorSupport intrinsics currently have issues with MaxVectorSize < 16 (JDK-8370803).\n+    FLAG_SET_ERGO(EnableVectorSupport, false);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1187,0 +1187,2 @@\n+constexpr uint64_t MAJIK_DWORD = 0xabbaabbaabbaabbaull;\n+\n@@ -1366,3 +1368,0 @@\n-  st->print(\"sd  fp, [sp, #%d]\\n\\t\", - 2 * wordSize);\n-  st->print(\"sd  ra, [sp, #%d]\\n\\t\", - wordSize);\n-  if (PreserveFramePointer) { st->print(\"sub  fp, sp, #%d\\n\\t\", 2 * wordSize); }\n@@ -1370,0 +1369,8 @@\n+  st->print(\"sd  fp, [sp, #%d]\\n\\t\", framesize - 2 * wordSize);\n+  st->print(\"sd  ra, [sp, #%d]\\n\\t\", framesize - wordSize);\n+  if (PreserveFramePointer) { st->print(\"add fp, sp, #%d\\n\\t\", framesize); }\n+\n+  if (VerifyStackAtCalls) {\n+    st->print(\"mv  t2, %ld\\n\\t\", MAJIK_DWORD);\n+    st->print(\"sd  t2, [sp, #%d]\\n\\t\", framesize - 3 * wordSize);\n+  }\n@@ -1419,0 +1426,5 @@\n+  if (VerifyStackAtCalls) {\n+    __ mv(t2, MAJIK_DWORD);\n+    __ sd(t2, Address(sp, framesize - 3 * wordSize));\n+  }\n+\n@@ -1440,4 +1452,0 @@\n-  if (VerifyStackAtCalls) {\n-    Unimplemented();\n-  }\n-\n@@ -2433,1 +2441,7 @@\n-      __ call_Unimplemented();\n+      int framesize = ra_->reg2offset_unchecked(OptoReg::add(ra_->_matcher._old_SP, -3 * VMRegImpl::slots_per_word));\n+      Label stack_ok;\n+      __ ld(t1, Address(sp, framesize));\n+      __ mv(t2, MAJIK_DWORD);\n+      __ beq(t2, t1, stack_ok);\n+      __ stop(\"MAJIK_DWORD not found\");\n+      __ bind(stack_ok);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2489,1 +2489,1 @@\n-  return 2 * VMRegImpl::slots_per_word;\n+  return 2 * VMRegImpl::slots_per_word + (VerifyStackAtCalls ? 0 : 2) ;\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1151,3 +1151,1 @@\n-    __ la(t, unsatisfied);\n-    __ load_long_misaligned(t1, Address(t, 0), t0, 2); \/\/ 2 bytes aligned, but not 4 or 8\n-\n+    __ la(t1, unsatisfied);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-\/\/ i386: 224, amd64: 186, sparc: 143\n+\/\/ i386: 224, amd64: 186\n@@ -486,2 +486,0 @@\n-  #elif defined(__sparc__)\n-    #define SYS_gettid 143\n@@ -2727,2 +2725,0 @@\n-#elif defined(SPARC)\n-const char* search_string = \"cpu\";\n@@ -2780,2 +2776,0 @@\n-#elif defined(SPARC)\n-  strncpy(cpuinfo, \"sparcv9\", length);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -900,0 +900,1 @@\n+      nm->print_code_snippet(st, addr);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4002,0 +4002,40 @@\n+void nmethod::print_code_snippet(outputStream* st, address addr) const {\n+  if (entry_point() <= addr && addr < code_end()) {\n+    \/\/ Pointing into the nmethod's code. Try to disassemble some instructions around addr.\n+    \/\/ Determine conservative start and end points.\n+    address start;\n+    if (frame_complete_offset() != CodeOffsets::frame_never_safe &&\n+        addr >= code_begin() + frame_complete_offset()) {\n+      start = code_begin() + frame_complete_offset();\n+    } else {\n+      start = (addr < verified_entry_point()) ? entry_point() : verified_entry_point();\n+    }\n+    address start_for_hex_dump = start; \/\/ We can choose a different starting point for hex dump, below.\n+    address end = code_end();\n+\n+    \/\/ Try using relocations to find closer instruction start and end points.\n+    \/\/ (Some platforms have variable length instructions and can only\n+    \/\/ disassemble correctly at instruction start addresses.)\n+    RelocIterator iter((nmethod*)this, start);\n+    while (iter.next() && iter.addr() < addr) { \/\/ find relocation before addr\n+      \/\/ Note: There's a relocation which doesn't point to an instruction start:\n+      \/\/ ZBarrierRelocationFormatStoreGoodAfterMov with ZGC on x86_64\n+      \/\/ We could detect and skip it, but hex dump is still usable when\n+      \/\/ disassembler produces garbage in such a very rare case.\n+      start = iter.addr();\n+      \/\/ We want at least 64 Bytes ahead in hex dump.\n+      if (iter.addr() <= (addr - 64)) start_for_hex_dump = iter.addr();\n+    }\n+    if (iter.has_current()) {\n+      if (iter.addr() == addr) iter.next(); \/\/ find relocation after addr\n+      if (iter.has_current()) end = iter.addr();\n+    }\n+\n+    \/\/ Always print hex. Disassembler may still have problems when hitting an incorrect instruction start.\n+    os::print_hex_dump(st, start_for_hex_dump, end, 1, \/* print_ascii=*\/false);\n+    if (!Disassembler::is_abstract()) {\n+      Disassembler::decode(start, end, st);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -999,0 +999,1 @@\n+  void print_code_snippet(outputStream* st, address addr) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-class GCLogMessage : public FormatBuffer<512> {};\n+class GCLogMessage : public FormatBuffer<1024> {};\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2378,1 +2378,1 @@\n-        tty->print_cr(\"0xBADB100D   +VerifyStackAtCalls\");\n+        tty->print_cr(\"<Majik cookie>   +VerifyStackAtCalls\");\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,7 @@\n-        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:CompileCommand=inline,jdk.incubator.vector.Float16::*\");\n+        \/\/ Disable inlining for java.lang.Float::float16ToFloat and java.lang.Float::floatToFloat16.\n+        \/\/ Otherwise, they could be inlined into testHalfFloat on platforms where there is no support\n+        \/\/ for fp16, which causes unexpected IR graph.\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\",\n+                                   \"-XX:CompileCommand=inline,jdk.incubator.vector.Float16::*\",\n+                                   \"-XX:CompileCommand=dontinline,java.lang.Float::float16ToFloat\",\n+                                   \"-XX:CompileCommand=dontinline,java.lang.Float::floatToFloat16\");\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestSubNodeFloatDoubleNegation.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -105,2 +105,0 @@\n-    private static final String STORE_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n-    private static final String LOAD_OF_CLASS_POSTFIX = \"(:|\\\\+)\\\\S* \\\\*\" + END;\n@@ -2941,0 +2939,12 @@\n+    \/\/ Typename in load\/store have the structure:\n+    \/\/ @fully\/qualified\/package\/name\/to\/TheClass+12 *\n+    \/\/ And variation:\n+    \/\/ - after @, we can have \"stable:\" or other labels, with optional space after ':'\n+    \/\/ - the class can actually be a subclass, with $ separator (and it must be ok to give only the deepest one\n+    \/\/ - after the class name, we can have a comma-separated list of implemented interfaces enclosed in parentheses\n+    \/\/ - before the offset, we can have something like \":NotNull\", either way, seeing \"+\" or \":\" means the end of the type\n+    \/\/ Worst case, it can be something like:\n+    \/\/ @bla: bli:a\/b\/c$d$e (f\/g,h\/i\/j):NotNull+24 *\n+    private static final String LOAD_STORE_PREFIX = \"@(\\\\w+: ?)*[\\\\w\/\\\\$]*\\\\b\";\n+    private static final String LOAD_STORE_SUFFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\";\n+\n@@ -2942,1 +2952,1 @@\n-        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + LOAD_OF_CLASS_POSTFIX;\n+        String regex = START + irNodeRegex + MID + LOAD_STORE_PREFIX + IS_REPLACED + LOAD_STORE_SUFFIX + END;\n@@ -2947,1 +2957,1 @@\n-        String regex = START + irNodeRegex + MID + \"@\\\\S*\" + IS_REPLACED + STORE_OF_CLASS_POSTFIX;\n+        String regex = START + irNodeRegex + MID + LOAD_STORE_PREFIX + IS_REPLACED + LOAD_STORE_SUFFIX + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -33,1 +35,1 @@\n- * @run driver PrintVMInfoAtExitTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI PrintVMInfoAtExitTest\n@@ -38,0 +40,2 @@\n+import jdk.test.whitebox.WhiteBox;\n+\n@@ -56,1 +60,8 @@\n-    output_detail.shouldContain(\"Java Heap (reserved=65536KB, committed=65536KB)\");\n+    WhiteBox wb = WhiteBox.getWhiteBox();\n+    if (wb.isAsanEnabled()) {\n+        \/\/ the reserved value can be influenced by asan\n+        output_detail.shouldContain(\"Java Heap (reserved=\");\n+        output_detail.shouldContain(\", committed=65536KB)\");\n+    } else {\n+        output_detail.shouldContain(\"Java Heap (reserved=65536KB, committed=65536KB)\");\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/PrintVMInfoAtExitTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+        run(LoadStore.class);\n@@ -552,0 +553,236 @@\n+\n+\/\/ Test load and store regexes\n+class LoadStore {\n+    int i;\n+    float f;\n+    interface I1 {}\n+    static class Base implements I1 {\n+        int i;\n+    }\n+    interface I2 {}\n+    static class Derived extends Base implements I2 {\n+        long l;\n+    }\n+    Base base = new Base();\n+    Derived derived = new Derived();\n+\n+    static class SingleNest {\n+        static class DoubleNest {\n+            int i;\n+        }\n+    }\n+\n+    SingleNest.DoubleNest doubleNest = new SingleNest.DoubleNest();\n+\n+\n+    @Test\n+    @IR(failOn = {IRNode.LOAD_OF_CLASS, \".*\", IRNode.STORE_OF_CLASS, \".*\"})\n+    public void triviallyFailBoth() {\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.LOAD_OF_CLASS, \"LoadS[a-z]+\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"Load.tore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"\/LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"tests\/LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"\/tests\/LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"ir_framework\/tests\/LoadStore\", \"1\",\n+            IRNode.LOAD_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\", \"1\",  \/\/ To assert it's the whole qualification\n+            IRNode.LOAD_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.LOAD_OF_CLASS, \"oadStore\",\n+            IRNode.LOAD_OF_CLASS, \"LoadStor\",\n+            IRNode.LOAD_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\",\n+            IRNode.LOAD_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore+12 *\n+    public float simpleLoad() {\n+        return f;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.STORE_OF_CLASS, \"LoadS[a-z]+\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"Load.tore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"tests\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"\/tests\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"ir_framework\/tests\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\", \"1\",\n+            IRNode.STORE_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.STORE_OF_CLASS, \"oadStore\",\n+            IRNode.STORE_OF_CLASS, \"LoadStor\",\n+            IRNode.STORE_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\",\n+            IRNode.STORE_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore+12 *\n+    public void simpleStore() {\n+        i = 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.LOAD_I_OF_CLASS, \"Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadS[a-z]+\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"Load.tore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.LOAD_I_OF_CLASS, \"\/Base\",\n+            IRNode.LOAD_I_OF_CLASS, \"oadStore\\\\$Base\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\\\\$Bas\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\\\\$Base\",\n+            IRNode.LOAD_I_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$Base (ir_framework\/tests\/LoadStore$I1)+12 *\n+    public int loadWithInterface() {\n+        return base.i;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.STORE_I_OF_CLASS, \"Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadS[a-z]+\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"Load.tore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\\\\$Base\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.STORE_I_OF_CLASS, \"\/Base\",\n+            IRNode.STORE_I_OF_CLASS, \"oadStore\\\\$Base\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\\\\$Bas\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\",\n+            IRNode.STORE_I_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\\\\$Base\",\n+            IRNode.STORE_I_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$Base (ir_framework\/tests\/LoadStore$I1)+12 *\n+    public void storeWithInterface() {\n+        base.i = 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.LOAD_L_OF_CLASS, \"Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"LoadS[a-z]+\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"Load.tore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.LOAD_L_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.LOAD_L_OF_CLASS, \"\/Derived\",\n+            IRNode.LOAD_L_OF_CLASS, \"oadStore\\\\$Derived\",\n+            IRNode.LOAD_L_OF_CLASS, \"LoadStore\\\\$Derive\",\n+            IRNode.LOAD_L_OF_CLASS, \"LoadStore\",\n+            IRNode.LOAD_L_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\\\\$Derived\",\n+            IRNode.LOAD_L_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$Derived (ir_framework\/tests\/LoadStore$I1,ir_framework\/tests\/LoadStore$I2)+24 *\n+    public long loadWithInterfaces() {\n+        return derived.l;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.STORE_L_OF_CLASS, \"Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"LoadS[a-z]+\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"Load.tore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"(?<=[@: ])ir_framework\/tests\/LoadStore\\\\$Derived\", \"1\",\n+            IRNode.STORE_L_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$\/]*tests[\\\\w\\\\$\/]*\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.STORE_L_OF_CLASS, \"\/Derived\",\n+            IRNode.STORE_L_OF_CLASS, \"oadStore\\\\$Derived\",\n+            IRNode.STORE_L_OF_CLASS, \"LoadStore\\\\$Derive\",\n+            IRNode.STORE_L_OF_CLASS, \"LoadStore\",\n+            IRNode.STORE_L_OF_CLASS, \"\/ir_framework\/tests\/LoadStore\\\\$Derived\",\n+            IRNode.STORE_L_OF_CLASS, \"(?<=[@: ])[\\\\w\\\\$]*tests[\\\\w\\\\$]*\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$Derived (ir_framework\/tests\/LoadStore$I1,ir_framework\/tests\/LoadStore$I2)+24 *\n+    public void storeWithInterfaces() {\n+        derived.l = 1;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.LOAD_I_OF_CLASS, \"DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"\/tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.LOAD_I_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.LOAD_I_OF_CLASS, \"SingleNest\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\",\n+            IRNode.LOAD_I_OF_CLASS, \"LoadStore\\\\$SingleNest\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$SingleNest$DoubleNest+12 *\n+    public int loadDoubleNested() {\n+        return doubleNest.i;\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+            IRNode.STORE_I_OF_CLASS, \"DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"\/tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+            IRNode.STORE_I_OF_CLASS, \"ir_framework\/tests\/LoadStore\\\\$SingleNest\\\\$DoubleNest\", \"1\",\n+        },\n+        failOn = {\n+            IRNode.STORE_I_OF_CLASS, \"SingleNest\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\",\n+            IRNode.STORE_I_OF_CLASS, \"LoadStore\\\\$SingleNest\",\n+        }\n+    )\n+    \/\/ @ir_framework\/tests\/LoadStore$SingleNest$DoubleNest+12 *\n+    public void storeDoubleNested() {\n+        doubleNest.i = 1;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"modified"}]}