{"files":[{"patch":"@@ -319,0 +319,4 @@\n+    \/\/ Parse the specified cipher transformation for algorithm and the\n+    \/\/ optional mode and padding. If the transformation contains only\n+    \/\/ algorithm, then only algorithm is returned. Otherwise, the\n+    \/\/ transformation must contain all 3 and they must be non-empty.\n@@ -326,1 +330,1 @@\n-         * array containing the components of a cipher transformation:\n+         * Components of a cipher transformation:\n@@ -328,3 +332,3 @@\n-         * index 0: algorithm component (e.g., AES)\n-         * index 1: feedback component (e.g., CFB)\n-         * index 2: padding component (e.g., PKCS5Padding)\n+         * 1) algorithm component (e.g., AES)\n+         * 2) feedback component (e.g., CFB) - optional\n+         * 3) padding component (e.g., PKCS5Padding) - optional\n@@ -332,1 +336,0 @@\n-        String[] parts = { \"\", \"\", \"\" };\n@@ -341,3 +344,11 @@\n-        if (endIdx == -1) {\n-            \/\/ algorithm\n-            parts[0] = transformation.trim();\n+\n+        boolean algorithmOnly = (endIdx == -1);\n+        String algo = (algorithmOnly ? transformation.trim() :\n+                transformation.substring(0, endIdx).trim());\n+        if (algo.isEmpty()) {\n+            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n+                                   \"algorithm not specified-\"\n+                                   + transformation);\n+        }\n+        if (algorithmOnly) { \/\/ done\n+            return new String[] { algo };\n@@ -345,2 +356,1 @@\n-            \/\/ algorithm\/mode\/padding\n-            parts[0] = transformation.substring(0, endIdx).trim();\n+            \/\/ continue parsing mode and padding\n@@ -353,6 +363,6 @@\n-            parts[1] = transformation.substring(startIdx, endIdx).trim();\n-            parts[2] = transformation.substring(endIdx+1).trim();\n-        }\n-        if (parts[0].isEmpty()) {\n-            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n-                                   \"algorithm not specified-\"\n+            String mode = transformation.substring(startIdx, endIdx).trim();\n+            String padding = transformation.substring(endIdx+1).trim();\n+            \/\/ ensure mode and padding are specified\n+            if (mode.isEmpty() || padding.isEmpty()) {\n+                throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n+                                   \"missing mode and\/or padding-\"\n@@ -360,0 +370,2 @@\n+            }\n+            return new String[] { algo, mode, padding };\n@@ -361,1 +373,0 @@\n-        return parts;\n@@ -457,5 +468,1 @@\n-        String alg = parts[0];\n-        String mode = parts[1];\n-        String pad = parts[2];\n-\n-        if ((mode.length() == 0) && (pad.length() == 0)) {\n+        if (parts.length == 1) {\n@@ -463,2 +470,1 @@\n-            Transform tr = new Transform(alg, \"\", null, null);\n-            return Collections.singletonList(tr);\n+            return List.of(new Transform(parts[0], \"\", null, null));\n@@ -466,7 +472,7 @@\n-            \/\/ Algorithm w\/ at least mode or padding or both\n-            List<Transform> list = new ArrayList<>(4);\n-            list.add(new Transform(alg, \"\/\" + mode + \"\/\" + pad, null, null));\n-            list.add(new Transform(alg, \"\/\" + mode, null, pad));\n-            list.add(new Transform(alg, \"\/\/\" + pad, mode, null));\n-            list.add(new Transform(alg, \"\", mode, pad));\n-            return list;\n+            \/\/ Algorithm w\/ both mode and padding\n+            return List.of(\n+                    new Transform(parts[0], \"\/\" + parts[1] + \"\/\" + parts[2],\n+                    null, null),\n+                    new Transform(parts[0], \"\/\" + parts[1], null, parts[2]),\n+                    new Transform(parts[0], \"\/\/\" + parts[2], parts[1], null),\n+                    new Transform(parts[0], \"\", parts[1], parts[2]));\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":37,"deletions":31,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8359388\n+ * @summary test that the Cipher.getInstance() would reject improper\n+ *     transformations with empty mode and\/or padding.\n+ *\/\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import javax.crypto.Cipher;\n+\n+public class TestEmptyModePadding {\n+\n+    public static void main(String[] args) throws Exception {\n+        Provider provider = Security.getProvider(\n+                System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+\n+        System.out.println(\"Testing against \" + provider.getName());\n+\n+        String[] testTransformations = {\n+            \/\/ transformations w\/ only 1 component, i.e. algo\n+            \" \",\n+            \/\/ transformations w\/ only 2 components\n+            \"AES\/\",\n+            \"AES\/ \",\n+            \"AES\/CBC\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/\",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/ \",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/CBC\",\n+            \/\/ 3-component transformations w\/ empty component(s)\n+            \"AES\/\/\",\n+            \"AES\/ \/\",\n+            \"AES\/\/ \",\n+            \"AES\/ \/ \",\n+            \"AES\/CBC\/\", \"AES\/CBC\/ \",\n+            \"AES\/\/PKCS5Padding\", \"AES\/ \/NoPadding\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/\/\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/ \/\",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/\/ \",\n+            \"PBEWithHmacSHA512\/224AndAES_128\/ \/ \",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/CBC\/\",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/CBC\/ \",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/\/PKCS5Padding\",\n+            \"PBEWithHmacSHA512\/256AndAES_128\/ \/PKCS5Padding\",\n+        };\n+\n+        for (String t : testTransformations) {\n+            test(t, provider);\n+        }\n+    }\n+\n+    private static void test(String t, Provider p) throws Exception {\n+        try {\n+            Cipher c = Cipher.getInstance(t, p);\n+            throw new RuntimeException(\"Should throw NSAE for \\'\" + t + \"\\'\");\n+        } catch (NoSuchAlgorithmException nsae) {\n+            \/\/ transformation info is already in the NSAE message\n+            System.out.println(\"Expected NSAE: \" + nsae.getMessage());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestEmptyModePadding.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}