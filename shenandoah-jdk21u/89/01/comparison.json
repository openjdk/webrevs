{"files":[{"patch":"@@ -436,2 +436,2 @@\n-    \/\/ The heuristic old_is_fragmented trigger may be seeking to achieve up to 7\/8 density.  Allow ourselves to overshoot\n-    \/\/ that target (at 15\/16) so we will not have to do another defragmenting old collection right away.\n+    \/\/ The heuristic old_is_fragmented trigger may be seeking to achieve up to 75% density.  Allow ourselves to overshoot\n+    \/\/ that target (at 7\/8) so we will not have to do another defragmenting old collection right away.\n@@ -439,1 +439,1 @@\n-           (total_uncollected_old_regions < 15 * span_of_uncollected_regions \/ 16)) {\n+           (total_uncollected_old_regions < 7 * span_of_uncollected_regions \/ 8)) {\n@@ -550,1 +550,6 @@\n-void ShenandoahOldHeuristics::trigger_collection_if_fragmented(size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions) {\n+\/\/ This triggers old-gen collection if the number of regions \"dedicated\" to old generation is much larger than\n+\/\/ is required to represent the memory currently used within the old generation.  This trigger looks specifically\n+\/\/ at density of the old-gen spanned region.  A different mechanism triggers old-gen GC if the total number of\n+\/\/ old-gen regions (regardless of how close the regions are to one another) grows beyond an anticipated growth target.\n+void ShenandoahOldHeuristics::set_trigger_if_old_is_fragmented(size_t first_old_region, size_t last_old_region,\n+                                                               size_t old_region_count, size_t num_regions) {\n@@ -552,1 +557,7 @@\n-    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n+    \/\/ Our intent is to pack old-gen memory into the highest-numbered regions of the heap.  Count all memory\n+    \/\/ above first_old_region as the \"span\" of old generation.\n+    size_t old_region_span = (first_old_region <= last_old_region)? (num_regions - first_old_region): 0;\n+    \/\/ Given that memory at the bottom of the heap is reserved to represent humongous objects, the number of\n+    \/\/ regions that old_gen is \"allowed\" to consume is less than the total heap size.  The restriction on allowed\n+    \/\/ span is not strictly enforced.  This is a heuristic designed to reduce the likelihood that a humongous\n+    \/\/ allocation request will require a STW full GC.\n@@ -555,13 +566,3 @@\n-    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n-    \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n-    \/\/\n-    \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n-    \/\/ humongous allocation was not required.\n-\n-    size_t old_available = _old_gen->available();\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    size_t old_unaffiliated_available = _old_gen->free_unaffiliated_regions() * region_size_bytes;\n+    size_t old_available = _old_gen->available() \/ HeapWordSize;\n+    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+    size_t old_unaffiliated_available = _old_gen->free_unaffiliated_regions() * region_size_words;\n@@ -571,11 +572,24 @@\n-    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n-    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n-    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n-\n-    uint eighths = 8;\n-    for (uint i = 0; i < 5; i++) {\n-      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n-      double density_threshold = (eighths - 2) \/ 8.0;\n-      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n-        trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n-        return;\n+    size_t old_words_consumed = old_region_count * region_size_words - old_fragmented_available;\n+    size_t old_words_spanned = old_region_span * region_size_words;\n+    double old_density = ((double) old_words_consumed) \/ old_words_spanned;\n+\n+    double old_span_percent = ((double) old_region_span) \/ allowed_old_gen_span;\n+    if (old_span_percent > 0.50) {\n+      \/\/ Squaring old_span_percent in the denominator below allows more aggressive triggering when we are\n+      \/\/ above desired maximum span and less aggressive triggering when we are far below the desired maximum span.\n+      double old_span_percent_squared = old_span_percent * old_span_percent;\n+      if (old_density \/ old_span_percent_squared < 0.75) {\n+        \/\/ We trigger old defragmentation, for example, if:\n+        \/\/  old_span_percent is 110% and old_density is below 90.8%, or\n+        \/\/  old_span_percent is 100% and old_density is below 75.0%, or\n+        \/\/  old_span_percent is  90% and old_density is below 60.8%, or\n+        \/\/  old_span_percent is  80% and old_density is below 48.0%, or\n+        \/\/  old_span_percent is  70% and old_density is below 36.8%, or\n+        \/\/  old_span_percent is  60% and old_density is below 27.0%, or\n+        \/\/  old_span_percent is  50% and old_density is below 18.8%.\n+\n+        \/\/ Set the fragmentation trigger and related attributes\n+        _fragmentation_trigger = true;\n+        _fragmentation_density = old_density;\n+        _fragmentation_first_old_region = first_old_region;\n+        _fragmentation_last_old_region = last_old_region;\n@@ -583,1 +597,0 @@\n-      eighths--;\n@@ -588,1 +601,1 @@\n-void ShenandoahOldHeuristics::trigger_collection_if_overgrown() {\n+void ShenandoahOldHeuristics::set_trigger_if_old_is_overgrown() {\n@@ -596,1 +609,1 @@\n-    trigger_old_has_grown();\n+    _growth_trigger = true;\n@@ -600,4 +613,4 @@\n-void ShenandoahOldHeuristics::trigger_maybe(size_t first_old_region, size_t last_old_region,\n-                                            size_t old_region_count, size_t num_regions) {\n-  trigger_collection_if_fragmented(first_old_region, last_old_region, old_region_count, num_regions);\n-  trigger_collection_if_overgrown();\n+void ShenandoahOldHeuristics::evaluate_triggers(size_t first_old_region, size_t last_old_region,\n+                                                size_t old_region_count, size_t num_regions) {\n+  set_trigger_if_old_is_fragmented(first_old_region, last_old_region, old_region_count, num_regions);\n+  set_trigger_if_old_is_overgrown();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":49,"deletions":36,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -116,7 +116,3 @@\n-  inline void trigger_old_is_fragmented(double density, size_t first_old_index, size_t last_old_index) {\n-    _fragmentation_trigger = true;\n-    _fragmentation_density = density;\n-    _fragmentation_first_old_region = first_old_index;\n-    _fragmentation_last_old_region = last_old_index;\n-  }\n-  inline void trigger_old_has_grown() { _growth_trigger = true; }\n+  \/\/ Set the fragmentation trigger if old-gen memory has become fragmented.\n+  void set_trigger_if_old_is_fragmented(size_t first_old_region, size_t last_old_region,\n+                                        size_t old_region_count, size_t num_regions);\n@@ -124,2 +120,2 @@\n-  void trigger_collection_if_fragmented(size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions);\n-  void trigger_collection_if_overgrown();\n+  \/\/ Set the overgrowth trigger if old-gen memory has grown beyond a particular threshold.\n+  void set_trigger_if_old_is_overgrown();\n@@ -186,1 +182,2 @@\n-  void trigger_maybe(size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions);\n+  \/\/ Check whether conditions merit the start of old GC.  Set appropriate trigger if so.\n+  void evaluate_triggers(size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/checkedCast.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2488,1 +2488,1 @@\n-    old_gen->heuristics()->trigger_maybe(first_old_region, last_old_region, old_region_count, num_regions());\n+    old_gen->heuristics()->evaluate_triggers(first_old_region, last_old_region, old_region_count, num_regions());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}