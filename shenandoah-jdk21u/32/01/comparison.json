{"files":[{"patch":"@@ -1167,2 +1167,16 @@\n-  size_t young_reserve, old_reserve;\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  size_t young_reserve(0), old_reserve(0);\n+\n+  if (!_heap->mode()->is_generational()) {\n+    young_reserve = (_heap->max_capacity() \/ 100) * ShenandoahEvacReserve;\n+    old_reserve = 0;\n+  } else {\n+    compute_young_and_old_reserves(young_cset_regions, old_cset_regions, have_evacuation_reserves,\n+                                   young_reserve, old_reserve);\n+\n+  }\n+\n+  reserve_regions(young_reserve, old_reserve);\n+  _free_sets.establish_alloc_bias(OldCollector);\n+  _free_sets.assert_bounds();\n+  log_status();\n+}\n@@ -1170,2 +1184,5 @@\n-  ShenandoahOldGeneration* old_generation = _heap->old_generation();\n-  size_t old_capacity = old_generation->max_capacity();\n+void ShenandoahFreeSet::compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves,\n+                                                       size_t& young_reserve_result, size_t& old_reserve_result) const {\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  ShenandoahOldGeneration* const old_generation = _heap->old_generation();\n@@ -1174,1 +1191,1 @@\n-  ShenandoahYoungGeneration* young_generation = _heap->young_generation();\n+  ShenandoahYoungGeneration* const young_generation = _heap->young_generation();\n@@ -1176,1 +1193,0 @@\n-  size_t young_available = young_generation->available();\n@@ -1179,0 +1195,1 @@\n+  \/\/ Add in the regions we anticipate to be freed by evacuation of the collection set\n@@ -1182,1 +1199,0 @@\n-  young_available += young_cset_regions * region_size_bytes;\n@@ -1184,1 +1200,1 @@\n-  \/\/ Consult old-region surplus and deficit to make adjustments to current generation capacities and availability.\n+  \/\/ Consult old-region balance to make adjustments to current generation capacities and availability.\n@@ -1186,2 +1202,7 @@\n-  size_t old_region_surplus = old_generation->get_region_surplus();\n-  size_t old_region_deficit = old_generation->get_region_deficit();\n+  const ssize_t old_region_balance = old_generation->get_region_balance();\n+  if (old_region_balance != 0) {\n+    if (old_region_balance > 0) {\n+      assert(old_region_balance <= checked_cast<ssize_t>(old_unaffiliated_regions), \"Cannot transfer regions that are affiliated\");\n+    } else {\n+      assert(0 - old_region_balance <= checked_cast<ssize_t>(young_unaffiliated_regions), \"Cannot transfer regions that are affiliated\");\n+    }\n@@ -1189,4 +1210,1 @@\n-  if (old_region_surplus > 0) {\n-    size_t xfer_bytes = old_region_surplus * region_size_bytes;\n-    assert(old_region_surplus <= old_unaffiliated_regions, \"Cannot transfer regions that are affiliated\");\n-    old_capacity -= xfer_bytes;\n+    ssize_t xfer_bytes = old_region_balance * checked_cast<ssize_t>(region_size_bytes);\n@@ -1194,1 +1212,1 @@\n-    old_unaffiliated_regions -= old_region_surplus;\n+    old_unaffiliated_regions -= old_region_balance;\n@@ -1196,11 +1214,1 @@\n-    young_available += xfer_bytes;\n-    young_unaffiliated_regions += old_region_surplus;\n-  } else if (old_region_deficit > 0) {\n-    size_t xfer_bytes = old_region_deficit * region_size_bytes;\n-    assert(old_region_deficit <= young_unaffiliated_regions, \"Cannot transfer regions that are affiliated\");\n-    old_capacity += xfer_bytes;\n-    old_available += xfer_bytes;\n-    old_unaffiliated_regions += old_region_deficit;\n-    young_capacity -= xfer_bytes;\n-    young_available -= xfer_bytes;\n-    young_unaffiliated_regions -= old_region_deficit;\n+    young_unaffiliated_regions += old_region_balance;\n@@ -1209,5 +1217,13 @@\n-  \/\/ Evac reserve: reserve trailing space for evacuations, with regions reserved for old evacuations placed to the right\n-  \/\/ of regions reserved of young evacuations.\n-  if (!_heap->mode()->is_generational()) {\n-    young_reserve = (_heap->max_capacity() \/ 100) * ShenandoahEvacReserve;\n-    old_reserve = 0;\n+  \/\/ All allocations taken from the old collector set are performed by GC, generally using PLABs for both\n+  \/\/ promotions and evacuations.  The partition between which old memory is reserved for evacuation and\n+  \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentions for\n+  \/\/ each PLAB's available memory.\n+  if (have_evacuation_reserves) {\n+    \/\/ We are rebuilding at the end of final mark, having already established evacuation budgets for this GC pass.\n+    const size_t promoted_reserve = old_generation->get_promoted_reserve();\n+    const size_t old_evac_reserve = old_generation->get_evacuation_reserve();\n+    young_reserve_result = young_generation->get_evacuation_reserve();\n+    old_reserve_result = promoted_reserve + old_evac_reserve;\n+    assert(old_reserve_result <= old_available,\n+           \"Cannot reserve (\" SIZE_FORMAT \" + \" SIZE_FORMAT\") more OLD than is available: \" SIZE_FORMAT,\n+           promoted_reserve, old_evac_reserve, old_available);\n@@ -1215,22 +1231,6 @@\n-    \/\/ All allocations taken from the old collector set are performed by GC, generally using PLABs for both\n-    \/\/ promotions and evacuations.  The partition between which old memory is reserved for evacuation and\n-    \/\/ which is reserved for promotion is enforced using thread-local variables that prescribe intentons for\n-    \/\/ each PLAB's available memory.\n-    if (have_evacuation_reserves) {\n-      \/\/ We are rebuilding at the end of final mark, having already established evacuation budgets for this GC pass.\n-\n-      size_t promoted_reserve = old_generation->get_promoted_reserve();\n-      size_t old_evac_reserve = old_generation->get_evacuation_reserve();\n-      young_reserve = young_generation->get_evacuation_reserve();\n-      old_reserve = promoted_reserve + old_evac_reserve;\n-      assert(old_reserve <= old_available,\n-             \"Cannot reserve (\" SIZE_FORMAT \" + \" SIZE_FORMAT\") more OLD than is available: \" SIZE_FORMAT,\n-             promoted_reserve, old_evac_reserve, old_available);\n-    } else {\n-      \/\/ We are rebuilding at end of GC, so we set aside budgets specified on command line (or defaults)\n-      young_reserve = (young_capacity * ShenandoahEvacReserve) \/ 100;\n-      \/\/ The auto-sizer has already made old-gen large enough to hold all anticipated evacuations and promotions.\n-      \/\/ Affiliated old-gen regions are already in the OldCollector free set.  Add in the relevant number of\n-      \/\/ unaffiliated regions.\n-      old_reserve = old_available;\n-    }\n+    \/\/ We are rebuilding at end of GC, so we set aside budgets specified on command line (or defaults)\n+    young_reserve_result = (young_capacity * ShenandoahEvacReserve) \/ 100;\n+    \/\/ The auto-sizer has already made old-gen large enough to hold all anticipated evacuations and promotions.\n+    \/\/ Affiliated old-gen regions are already in the OldCollector free set.  Add in the relevant number of\n+    \/\/ unaffiliated regions.\n+    old_reserve_result = old_available;\n@@ -1243,2 +1243,2 @@\n-  if (old_reserve > _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes) {\n-    old_reserve = _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes;\n+  if (old_reserve_result > _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes) {\n+    old_reserve_result = _free_sets.capacity_of(OldCollector) + old_unaffiliated_regions * region_size_bytes;\n@@ -1247,2 +1247,2 @@\n-  if (young_reserve > young_unaffiliated_regions * region_size_bytes) {\n-    young_reserve = young_unaffiliated_regions * region_size_bytes;\n+  if (old_reserve_result > young_unaffiliated_regions * region_size_bytes) {\n+    young_reserve_result = young_unaffiliated_regions * region_size_bytes;\n@@ -1250,5 +1250,0 @@\n-\n-  reserve_regions(young_reserve, old_reserve);\n-  _free_sets.establish_alloc_bias(OldCollector);\n-  _free_sets.assert_bounds();\n-  log_status();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":57,"deletions":62,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -236,0 +236,5 @@\n+\n+  \/\/ Reserve space for evacuations, with regions reserved for old evacuations placed to the right\n+  \/\/ of regions reserved of young evacuations.\n+  void compute_young_and_old_reserves(size_t young_cset_regions, size_t old_cset_regions, bool have_evacuation_reserves,\n+                                      size_t &young_reserve_result, size_t &old_reserve_result) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,4 +140,2 @@\n-  const size_t old_region_surplus = old_gen->get_region_surplus();\n-  const size_t old_region_deficit = old_gen->get_region_deficit();\n-  old_gen->set_region_surplus(0);\n-  old_gen->set_region_deficit(0);\n+  const ssize_t old_region_balance = old_gen->get_region_balance();\n+  old_gen->set_region_balance(0);\n@@ -145,2 +143,3 @@\n-  if (old_region_surplus) {\n-    bool success = generation_sizer()->transfer_to_young(old_region_surplus);\n+  if (old_region_balance > 0) {\n+    const auto old_region_surplus = checked_cast<size_t>(old_region_balance);\n+    const bool success = generation_sizer()->transfer_to_young(old_region_surplus);\n@@ -152,1 +151,2 @@\n-  if (old_region_deficit) {\n+  if (old_region_balance < 0) {\n+    const auto old_region_deficit = checked_cast<size_t>(-old_region_balance);\n@@ -237,3 +237,0 @@\n-  size_t old_region_deficit = 0;\n-  size_t old_region_surplus = 0;\n-\n@@ -243,2 +240,1 @@\n-    const size_t old_surplus = max_old_available - old_reserve;\n-    old_region_surplus = old_surplus \/ region_size_bytes;\n+    const size_t old_surplus = (max_old_available - old_reserve) \/ region_size_bytes;\n@@ -246,1 +242,2 @@\n-    old_region_surplus = MIN2(old_region_surplus, unaffiliated_old_regions);\n+    const size_t old_region_surplus = MIN2(old_surplus, unaffiliated_old_regions);\n+    old_generation()->set_region_balance(checked_cast<ssize_t>(old_region_surplus));\n@@ -251,3 +248,3 @@\n-    const size_t old_need = old_reserve - max_old_available;\n-    \/\/ The old region deficit (rounded up) will come from young\n-    old_region_deficit = (old_need + region_size_bytes - 1) \/ region_size_bytes;\n+    \/\/ Note that deficit is rounded up by one region.\n+    const size_t old_need = (old_reserve - max_old_available + region_size_bytes - 1) \/ region_size_bytes;\n+    const size_t max_old_region_xfer = old_xfer_limit \/ region_size_bytes;\n@@ -258,2 +255,2 @@\n-    const size_t max_old_region_xfer = old_xfer_limit \/ region_size_bytes;\n-    old_region_deficit = MIN2(old_region_deficit, max_old_region_xfer);\n+    const size_t old_region_deficit = MIN2(old_need, max_old_region_xfer);\n+    old_generation()->set_region_balance(0 - checked_cast<ssize_t>(old_region_deficit));\n@@ -261,4 +258,0 @@\n-  assert(old_region_deficit == 0 || old_region_surplus == 0, \"Only surplus or deficit, never both\");\n-\n-  old_generation()->set_region_surplus(old_region_surplus);\n-  old_generation()->set_region_deficit(old_region_deficit);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -499,30 +499,0 @@\n-size_t ShenandoahHeap::max_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return _generation_sizer.max_young_size();\n-    case OLD:\n-      return max_capacity() - _generation_sizer.min_young_size();\n-    case GLOBAL:\n-    case NON_GEN:\n-      return max_capacity();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-size_t ShenandoahHeap::min_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return _generation_sizer.min_young_size();\n-    case OLD:\n-      return max_capacity() - _generation_sizer.max_young_size();\n-    case GLOBAL:\n-    case NON_GEN:\n-      return min_capacity();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -516,3 +516,0 @@\n-  size_t max_size_for(ShenandoahGeneration* generation) const;\n-  size_t min_size_for(ShenandoahGeneration* generation) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -269,7 +269,2 @@\n-\/\/ Returns true iff transfer is successful\n-bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  ShenandoahGeneration* old_gen = heap->old_generation();\n-  ShenandoahGeneration* young_gen = heap->young_generation();\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-  size_t bytes_to_transfer = regions * region_size_bytes;\n+bool ShenandoahGenerationSizer::transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const {\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n@@ -277,1 +272,3 @@\n-  if (young_gen->free_unaffiliated_regions() < regions) {\n+  if (src->free_unaffiliated_regions() < regions) {\n+    \/\/ Source does not have enough free regions for this transfer. The caller should have\n+    \/\/ already capped the transfer based on available unaffiliated regions.\n@@ -279,1 +276,4 @@\n-  } else if (old_gen->max_capacity() + bytes_to_transfer > heap->max_size_for(old_gen)) {\n+  }\n+\n+  if (dst->max_capacity() + bytes_to_transfer > max_size_for(dst)) {\n+    \/\/ This transfer would cause the destination generation to grow above its configured maximum size.\n@@ -281,1 +281,4 @@\n-  } else if (young_gen->max_capacity() - bytes_to_transfer < heap->min_size_for(young_gen)) {\n+  }\n+\n+  if (src->max_capacity() - bytes_to_transfer < min_size_for(src)) {\n+    \/\/ This transfer would cause the source generation to shrink below its configured minimum size.\n@@ -283,8 +286,0 @@\n-  } else {\n-    young_gen->decrease_capacity(bytes_to_transfer);\n-    old_gen->increase_capacity(bytes_to_transfer);\n-    size_t new_size = old_gen->max_capacity();\n-    log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" SIZE_FORMAT \"%s\",\n-                 regions, young_gen->name(), old_gen->name(),\n-                 byte_size_in_proper_unit(new_size), proper_unit_for_byte_size(new_size));\n-    return true;\n@@ -292,0 +287,39 @@\n+\n+  src->decrease_capacity(bytes_to_transfer);\n+  dst->increase_capacity(bytes_to_transfer);\n+  const size_t new_size = dst->max_capacity();\n+  log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+               regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n+  return true;\n+}\n+\n+\n+size_t ShenandoahGenerationSizer::max_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return max_young_size();\n+    case OLD:\n+      return min_young_size();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+size_t ShenandoahGenerationSizer::min_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return min_young_size();\n+    case OLD:\n+      return ShenandoahHeap::heap()->max_capacity() - max_young_size();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+\n+\/\/ Returns true iff transfer is successful\n+bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  return transfer_regions(heap->young_generation(), heap->old_generation(), regions);\n@@ -300,2 +334,1 @@\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-  size_t bytes_to_transfer = regions * region_size_bytes;\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n@@ -305,4 +338,3 @@\n-  size_t new_size = old_gen->max_capacity();\n-  log_info(gc)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" SIZE_FORMAT \"%s\",\n-               regions, young_gen->name(), old_gen->name(),\n-               byte_size_in_proper_unit(new_size), proper_unit_for_byte_size(new_size));\n+  const size_t new_size = old_gen->max_capacity();\n+  log_info(gc)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+               regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n@@ -314,20 +346,1 @@\n-  ShenandoahGeneration* old_gen = heap->old_generation();\n-  ShenandoahGeneration* young_gen = heap->young_generation();\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-  size_t bytes_to_transfer = regions * region_size_bytes;\n-\n-  if (old_gen->free_unaffiliated_regions() < regions) {\n-    return false;\n-  } else if (young_gen->max_capacity() + bytes_to_transfer > heap->max_size_for(young_gen)) {\n-    return false;\n-  } else if (old_gen->max_capacity() - bytes_to_transfer < heap->min_size_for(old_gen)) {\n-    return false;\n-  } else {\n-    old_gen->decrease_capacity(bytes_to_transfer);\n-    young_gen->increase_capacity(bytes_to_transfer);\n-    size_t new_size = young_gen->max_capacity();\n-    log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" SIZE_FORMAT \"%s\",\n-                 regions, old_gen->name(), young_gen->name(),\n-                 byte_size_in_proper_unit(new_size), proper_unit_for_byte_size(new_size));\n-    return true;\n-  }\n+  return transfer_regions(heap->old_generation(), heap->young_generation(), regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":57,"deletions":44,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -128,1 +128,13 @@\n-public:\n+  \/\/ This will attempt to transfer regions from the `src` generation to `dst` generation.\n+  \/\/ If the transfer would violate the configured minimum size for the source or the configured\n+  \/\/ maximum size of the destination, it will not perform the transfer and will return false.\n+  \/\/ Returns true if the transfer is performed.\n+  bool transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const;\n+\n+  \/\/ Return the configured maximum size in bytes for the given generation.\n+  size_t max_size_for(ShenandoahGeneration* generation) const;\n+\n+  \/\/ Return the configured minimum size in bytes for the given generation.\n+  size_t min_size_for(ShenandoahGeneration* generation) const;\n+\n+    public:\n@@ -147,0 +159,1 @@\n+  \/\/ True if transfer succeeds, else false. See transfer_regions.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -172,2 +172,1 @@\n-    _region_surplus(0),\n-    _region_deficit(0),\n+    _region_balance(0),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,6 +40,6 @@\n-  \/\/ After determining the desired size of the old generation (see compute_old_generation_balance), these\n-  \/\/ quantities represent the number of regions above (surplus) or below (deficit) that size.\n-  \/\/ These values are computed prior to the actual exchange of any regions. These may never both\n-  \/\/ be positive simultaneously.\n-  size_t _region_surplus;\n-  size_t _region_deficit;\n+  \/\/ After determining the desired size of the old generation (see compute_old_generation_balance), this\n+  \/\/ quantity represents the number of regions above (surplus) or below (deficit) that size.\n+  \/\/ This value is computed prior to the actual exchange of any regions. A positive value represents\n+  \/\/ a surplus of old regions which will be transferred from old _to_ young. A negative value represents\n+  \/\/ a deficit of regions that will be replenished by a transfer _from_ young to old.\n+  ssize_t _region_balance;\n@@ -110,5 +110,2 @@\n-  void set_region_surplus(size_t surplus) { _region_surplus = surplus; };\n-  void set_region_deficit(size_t deficit) { _region_deficit = deficit; };\n-  size_t get_region_surplus() const { return _region_surplus; };\n-  size_t get_region_deficit() const { return _region_deficit; };\n-\n+  void set_region_balance(ssize_t balance) { _region_balance = balance; }\n+  ssize_t get_region_balance() const { return _region_balance; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"}]}