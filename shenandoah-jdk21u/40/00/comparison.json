{"files":[{"patch":"@@ -70,1 +70,5 @@\n-  _growth_trigger(false) {\n+  _growth_trigger(false),\n+  _fragmentation_density(0.0),\n+  _fragmentation_first_old_region(0),\n+  _fragmentation_last_old_region(0)\n+{\n@@ -207,5 +211,2 @@\n-    if (has_coalesce_and_fill_candidates()) {\n-      _old_generation->transition_to(ShenandoahOldGeneration::FILLING);\n-    } else {\n-      _old_generation->transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n-    }\n+\n+    _old_generation->complete_mixed_evacuations();\n@@ -220,1 +221,1 @@\n-      _old_generation->transition_to(ShenandoahOldGeneration::FILLING);\n+      _old_generation->abandon_mixed_evacuations();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -113,2 +113,1 @@\n-  virtual void choose_collection_set_from_regiondata(ShenandoahCollectionSet* set, RegionData* data, size_t data_size,\n-                                                     size_t free) override;\n+  void choose_collection_set_from_regiondata(ShenandoahCollectionSet* set, RegionData* data, size_t data_size, size_t free) override;\n@@ -117,1 +116,1 @@\n-  ShenandoahOldHeuristics(ShenandoahOldGeneration* generation);\n+  explicit ShenandoahOldHeuristics(ShenandoahOldGeneration* generation);\n@@ -196,1 +195,1 @@\n- private:\n+private:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -234,0 +234,10 @@\n+    if (!heap->old_generation()->is_parseable()) {\n+      \/\/ Class unloading may render the card offsets unusable, so we must rebuild them before\n+      \/\/ the next remembered set scan. We _could_ let the control thread do this sometime after\n+      \/\/ the global cycle has completed and before the next young collection, but under memory\n+      \/\/ pressure the control thread may not have the time (that is, because it's running back\n+      \/\/ to back GCs). In that scenario, we would have to make the old regions parsable before\n+      \/\/ we could start a young collection. This could delay the start of the young cycle and\n+      \/\/ throw off the heuristics.\n+      entry_global_coalesce_and_fill();\n+    }\n@@ -1276,0 +1286,19 @@\n+void ShenandoahConcurrentGC::entry_global_coalesce_and_fill() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  const char* msg = \"Coalescing and filling old regions in global collect\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_coalesce_and_fill);\n+\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+  EventMark em(\"%s\", msg);\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_marking(),\n+                              \"concurrent coalesce and fill\");\n+\n+  op_global_coalesce_and_fill();\n+}\n+\n+void ShenandoahConcurrentGC::op_global_coalesce_and_fill() {\n+  ShenandoahGenerationalHeap::heap()->coalesce_and_fill_old_regions(true);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  bool collect(GCCause::Cause cause);\n+  bool collect(GCCause::Cause cause) override;\n@@ -107,0 +107,1 @@\n+  void entry_global_coalesce_and_fill();\n@@ -126,0 +127,1 @@\n+  void op_global_coalesce_and_fill();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    bool is_bootstrap_gc = heap->old_generation()->state() == ShenandoahOldGeneration::BOOTSTRAPPING;\n+    bool is_bootstrap_gc = heap->old_generation()->is_bootstrapping();\n@@ -108,4 +108,3 @@\n-      ShenandoahOldGeneration::State state = old_generation->state();\n-      assert(state == ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP\n-             || state == ShenandoahOldGeneration::EVACUATING\n-             || state == ShenandoahOldGeneration::FILLING,\n+      assert(old_generation->is_idle()\n+             || old_generation->is_doing_mixed_evacuations()\n+             || old_generation->is_preparing_for_mark(),\n@@ -310,0 +309,4 @@\n+\n+    if (!ShenandoahGenerationalHeap::heap()->old_generation()->is_parseable()) {\n+      op_global_coalesce_and_fill();\n+    }\n@@ -403,0 +406,5 @@\n+void ShenandoahDegenGC::op_global_coalesce_and_fill() {\n+  ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_coalesce_and_fill);\n+  ShenandoahGenerationalHeap::heap()->coalesce_and_fill_old_regions(false);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+  \/\/ This will rebuild card offsets, which is necessary if classes were unloaded\n+  void op_global_coalesce_and_fill();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -712,1 +712,1 @@\n-    if (old->state() == ShenandoahOldGeneration::BOOTSTRAPPING) {\n+    if (old->is_bootstrapping()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-  ShenandoahMarkingContext* const ctx = _heap->marking_context();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,2 +75,1 @@\n-  assert(old->state() == ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP,\n-         \"After full GC, old generation should be waiting for bootstrap.\");\n+  assert(old->is_idle(), \"After full GC, old generation should be idle.\");\n@@ -94,0 +93,6 @@\n+\n+  \/\/ Rebuilding the remembered set recomputes all the card offsets for objects.\n+  \/\/ The adjust pointers phase coalesces and fills all necessary regions. In case\n+  \/\/ we came to the full GC from an incomplete global cycle, we need to indicate\n+  \/\/ that the old regions are parseable.\n+  heap->old_generation()->set_parseable(true);\n@@ -168,1 +173,1 @@\n-    r->oop_fill_and_coalesce_without_cancel();\n+    r->oop_coalesce_and_fill(false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n@@ -678,0 +679,40 @@\n+\n+void ShenandoahGenerationalHeap::coalesce_and_fill_old_regions(bool concurrent) {\n+  class ShenandoahGlobalCoalesceAndFill : public WorkerTask {\n+  private:\n+      ShenandoahPhaseTimings::Phase _phase;\n+      ShenandoahRegionIterator _regions;\n+  public:\n+    explicit ShenandoahGlobalCoalesceAndFill(ShenandoahPhaseTimings::Phase phase) :\n+      WorkerTask(\"Shenandoah Global Coalesce\"),\n+      _phase(phase) {}\n+\n+    void work(uint worker_id) override {\n+      ShenandoahWorkerTimingsTracker timer(_phase,\n+                                           ShenandoahPhaseTimings::ScanClusters,\n+                                           worker_id, true);\n+      ShenandoahHeapRegion* region;\n+      while ((region = _regions.next()) != nullptr) {\n+        \/\/ old region is not in the collection set and was not immediately trashed\n+        if (region->is_old() && region->is_active() && !region->is_humongous()) {\n+          \/\/ Reset the coalesce and fill boundary because this is a global collect\n+          \/\/ and cannot be preempted by young collects. We want to be sure the entire\n+          \/\/ region is coalesced here and does not resume from a previously interrupted\n+          \/\/ or completed coalescing.\n+          region->begin_preemptible_coalesce_and_fill();\n+          region->oop_coalesce_and_fill(false);\n+        }\n+      }\n+    }\n+  };\n+\n+  ShenandoahPhaseTimings::Phase phase = concurrent ?\n+          ShenandoahPhaseTimings::conc_coalesce_and_fill :\n+          ShenandoahPhaseTimings::degen_gc_coalesce_and_fill;\n+\n+  \/\/ This is not cancellable\n+  ShenandoahGlobalCoalesceAndFill coalesce(phase);\n+  workers()->run_task(&coalesce);\n+  old_generation()->set_parseable(true);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+  void coalesce_and_fill_old_regions(bool concurrent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -975,1 +975,1 @@\n-  if (old_generation()->state() == ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP) {\n+  if (old_generation()->is_idle()) {\n@@ -2097,0 +2097,3 @@\n+  if (mode()->is_generational()) {\n+    old_generation()->set_parseable(false);\n+  }\n@@ -2176,1 +2179,1 @@\n-  return old_generation()->state() == ShenandoahOldGeneration::FILLING;\n+  return old_generation()->is_preparing_for_mark();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -455,3 +455,5 @@\n-\/\/ oop_iterate without closure and without cancellation.  always return true.\n-bool ShenandoahHeapRegion::oop_fill_and_coalesce_without_cancel() {\n-  HeapWord* obj_addr = resume_coalesce_and_fill();\n+\/\/ oop_iterate without closure, return true if completed without cancellation\n+bool ShenandoahHeapRegion::oop_coalesce_and_fill(bool cancellable) {\n+\n+  \/\/ Consider yielding to cancel\/preemption request after this many coalesce operations (skip marked, or coalesce free).\n+  const size_t preemption_stride = 128;\n@@ -467,6 +469,0 @@\n-  \/\/ All objects above TAMS are considered live even though their mark bits will not be set.  Note that young-\n-  \/\/ gen evacuations that interrupt a long-running old-gen concurrent mark may promote objects into old-gen\n-  \/\/ while the old-gen concurrent marking is ongoing.  These newly promoted objects will reside above TAMS\n-  \/\/ and will be treated as live during the current old-gen marking pass, even though they will not be\n-  \/\/ explicitly marked.\n-  HeapWord* t = marking_context->top_at_mark_start(this);\n@@ -476,26 +472,0 @@\n-  while (obj_addr < t) {\n-    oop obj = cast_to_oop(obj_addr);\n-    if (marking_context->is_marked(obj)) {\n-      assert(obj->klass() != nullptr, \"klass should not be nullptr\");\n-      obj_addr += obj->size();\n-    } else {\n-      \/\/ Object is not marked.  Coalesce and fill dead object with dead neighbors.\n-      HeapWord* next_marked_obj = marking_context->get_next_marked_addr(obj_addr, t);\n-      assert(next_marked_obj <= t, \"next marked object cannot exceed top\");\n-      size_t fill_size = next_marked_obj - obj_addr;\n-      assert(fill_size >= ShenandoahHeap::min_fill_size(), \"previously allocated objects known to be larger than min_size\");\n-      ShenandoahHeap::fill_with_object(obj_addr, fill_size);\n-      heap->card_scan()->coalesce_objects(obj_addr, fill_size);\n-      obj_addr = next_marked_obj;\n-    }\n-  }\n-  \/\/ Mark that this region has been coalesced and filled\n-  end_preemptible_coalesce_and_fill();\n-  return true;\n-}\n-\n-\/\/ oop_iterate without closure, return true if completed without cancellation\n-bool ShenandoahHeapRegion::oop_fill_and_coalesce() {\n-  HeapWord* obj_addr = resume_coalesce_and_fill();\n-  \/\/ Consider yielding to cancel\/preemption request after this many coalesce operations (skip marked, or coalesce free).\n-  const size_t preemption_stride = 128;\n@@ -503,8 +473,0 @@\n-  assert(!is_humongous(), \"No need to fill or coalesce humongous regions\");\n-  if (!is_active()) {\n-    end_preemptible_coalesce_and_fill();\n-    return true;\n-  }\n-\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  ShenandoahMarkingContext* marking_context = heap->marking_context();\n@@ -518,2 +480,2 @@\n-  \/\/ Expect marking to be completed before these threads invoke this service.\n-  assert(heap->active_generation()->is_mark_complete(), \"sanity\");\n+  \/\/ Resume coalesce and fill from this address\n+  HeapWord* obj_addr = resume_coalesce_and_fill();\n@@ -537,1 +499,1 @@\n-    if (ops_before_preempt_check-- == 0) {\n+    if (cancellable && ops_before_preempt_check-- == 0) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":8,"deletions":46,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -405,4 +405,1 @@\n-  bool oop_fill_and_coalesce();\n-\n-  \/\/ Like oop_fill_and_coalesce(), but without honoring cancellation requests.\n-  bool oop_fill_and_coalesce_without_cancel();\n+  bool oop_coalesce_and_fill(bool cancellable);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  size_t trashed_oops() {\n+  size_t trashed_oops() const {\n@@ -148,0 +148,1 @@\n+    ShenandoahWorkerTimingsTracker timer(ShenandoahPhaseTimings::conc_coalesce_and_fill, ShenandoahPhaseTimings::ScanClusters, worker_id);\n@@ -156,1 +157,1 @@\n-      if (!r->oop_fill_and_coalesce()) {\n+      if (!r->oop_coalesce_and_fill(true)) {\n@@ -181,0 +182,1 @@\n+    _is_parseable(true),\n@@ -287,1 +289,1 @@\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::coalesce_and_fill);\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_coalesce_and_fill);\n@@ -289,1 +291,0 @@\n-  \/\/ TODO: I don't think we're using these concurrent collection counters correctly.\n@@ -302,1 +303,0 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -305,3 +305,0 @@\n-  WorkerThreads* workers = heap->workers();\n-  uint nworkers = workers->active_workers();\n-\n@@ -312,1 +309,10 @@\n-  assert(coalesce_and_fill_regions_count <= heap->num_regions(), \"Sanity\");\n+  assert(coalesce_and_fill_regions_count <= ShenandoahHeap::heap()->num_regions(), \"Sanity\");\n+  if (coalesce_and_fill_regions_count == 0) {\n+    \/\/ No regions need to be filled.\n+    abandon_collection_candidates();\n+    return true;\n+  }\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  WorkerThreads* workers = heap->workers();\n+  uint nworkers = workers->active_workers();\n@@ -318,0 +324,1 @@\n+    \/\/ We no longer need to track regions that need to be coalesced and filled.\n@@ -387,5 +394,6 @@\n-    case WAITING_FOR_BOOTSTRAP: return \"Waiting for Bootstrap\";\n-    case FILLING:               return \"Coalescing\";\n-    case BOOTSTRAPPING:         return \"Bootstrapping\";\n-    case MARKING:               return \"Marking\";\n-    case EVACUATING:            return \"Evacuating\";\n+    case WAITING_FOR_BOOTSTRAP:   return \"Waiting for Bootstrap\";\n+    case FILLING:                 return \"Coalescing\";\n+    case BOOTSTRAPPING:           return \"Bootstrapping\";\n+    case MARKING:                 return \"Marking\";\n+    case EVACUATING:              return \"Evacuating\";\n+    case EVACUATING_AFTER_GLOBAL: return \"Evacuating (G)\";\n@@ -435,23 +443,30 @@\n-\/\/               |   +--------> |     WAITING     |     |     bootstrap to filling or\n-\/\/               |   |    +---- |  FOR BOOTSTRAP  | ----+     evacuating.\n-\/\/               |   |    |     +-----------------+\n-\/\/               |   |    |       |\n-\/\/               |   |    |       | Reset Bitmap\n-\/\/               |   |    |       v\n-\/\/               |   |    |     +-----------------+     +----------------------+\n-\/\/               |   |    |     |    BOOTSTRAP    | <-> |       YOUNG GC       |\n-\/\/               |   |    |     |                 |     | (RSet Parses Region) |\n-\/\/               |   |    |     +-----------------+     +----------------------+\n-\/\/               |   |    |       |\n-\/\/               |   |    |       | Old Marking\n-\/\/               |   |    |       v\n-\/\/               |   |    |     +-----------------+     +----------------------+\n-\/\/               |   |    |     |     MARKING     | <-> |       YOUNG GC       |\n-\/\/               |   +--------- |                 |     | (RSet Parses Region) |\n-\/\/               |        |     +-----------------+     +----------------------+\n-\/\/               |        |       |\n-\/\/               |        |       | Has Evacuation Candidates\n-\/\/               |        |       v\n-\/\/               |        |     +-----------------+     +--------------------+\n-\/\/               |        +---> |    EVACUATING   | <-> |      YOUNG GC      |\n-\/\/               +------------- |                 |     | (RSet Uses Bitmap) |\n+\/\/           +-- |-- |--------> |     WAITING     |     |     bootstrap to filling or\n+\/\/           |   |   |    +---- |  FOR BOOTSTRAP  | ----+     evacuating. It may also\n+\/\/           |   |   |    |     +-----------------+           move from filling to waiting\n+\/\/           |   |   |    |       |                           for bootstrap.\n+\/\/           |   |   |    |       | Reset Bitmap\n+\/\/           |   |   |    |       v\n+\/\/           |   |   |    |     +-----------------+     +----------------------+\n+\/\/           |   |   |    |     |    BOOTSTRAP    | <-> |       YOUNG GC       |\n+\/\/           |   |   |    |     |                 |     | (RSet Parses Region) |\n+\/\/           |   |   |    |     +-----------------+     +----------------------+\n+\/\/           |   |   |    |       |\n+\/\/           |   |   |    |       | Old Marking\n+\/\/           |   |   |    |       v\n+\/\/           |   |   |    |     +-----------------+     +----------------------+\n+\/\/           |   |   |    |     |     MARKING     | <-> |       YOUNG GC       |\n+\/\/           |   |   +--------- |                 |     | (RSet Parses Region) |\n+\/\/           |   |        |     +-----------------+     +----------------------+\n+\/\/           |   |        |       |\n+\/\/           |   |        |       | Has Evacuation Candidates\n+\/\/           |   |        |       v\n+\/\/           |   |        |     +-----------------+     +--------------------+\n+\/\/           |   |        +---> |    EVACUATING   | <-> |      YOUNG GC      |\n+\/\/           |   +------------- |                 |     | (RSet Uses Bitmap) |\n+\/\/           |                  +-----------------+     +--------------------+\n+\/\/           |                    |\n+\/\/           |                    | Global Cycle Coalesces and Fills Old Regions\n+\/\/           |                    v\n+\/\/           |                  +-----------------+     +--------------------+\n+\/\/           +----------------- |    EVACUATING   | <-> |      YOUNG GC      |\n+\/\/                              |   AFTER GLOBAL  |     | (RSet Uses Bitmap) |\n@@ -461,1 +476,0 @@\n-\/\/\n@@ -466,1 +480,1 @@\n-      assert(_state != BOOTSTRAPPING, \"Cannot beging making old regions parsable after bootstrapping\");\n+      assert(_state != BOOTSTRAPPING, \"Cannot begin making old regions parsable after bootstrapping\");\n@@ -484,0 +498,3 @@\n+    case EVACUATING_AFTER_GLOBAL:\n+      assert(_state == EVACUATING, \"Must have been evacuating, state is '%s'\", state_name(_state));\n+      break;\n@@ -654,0 +671,70 @@\n+\n+void ShenandoahOldGeneration::set_parseable(bool parseable) {\n+  _is_parseable = parseable;\n+  if (_is_parseable) {\n+    \/\/ The current state would have been chosen during final mark of the global\n+    \/\/ collection, _before_ any decisions about class unloading have been made.\n+    \/\/\n+    \/\/ After unloading classes, we have made the old generation regions parseable.\n+    \/\/ We can skip filling or transition to a state that knows everything has\n+    \/\/ already been filled.\n+    switch (state()) {\n+      case ShenandoahOldGeneration::EVACUATING:\n+        transition_to(ShenandoahOldGeneration::EVACUATING_AFTER_GLOBAL);\n+        break;\n+      case ShenandoahOldGeneration::FILLING:\n+        assert(_old_heuristics->unprocessed_old_collection_candidates() == 0, \"Expected no mixed collection candidates\");\n+        assert(_old_heuristics->coalesce_and_fill_candidates_count() > 0, \"Expected coalesce and fill candidates\");\n+        \/\/ When the heuristic put the old generation in this state, it didn't know\n+        \/\/ that we would unload classes and make everything parseable. But, we know\n+        \/\/ that now so we can override this state.\n+        \/\/ TODO: It would be nicer if we didn't have to 'correct' this situation.\n+        abandon_collection_candidates();\n+        transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+        break;\n+      default:\n+        \/\/ We can get here during a full GC. The full GC will cancel anything\n+        \/\/ happening in the old generation and return it to the waiting for bootstrap\n+        \/\/ state. The full GC will then record that the old regions are parseable\n+        \/\/ after rebuilding the remembered set.\n+        assert(is_idle(), \"Unexpected state %s at end of global GC\", state_name());\n+        break;\n+    }\n+  }\n+}\n+\n+void ShenandoahOldGeneration::complete_mixed_evacuations() {\n+  assert(is_doing_mixed_evacuations(), \"Mixed evacuations should be in progress\");\n+  if (!_old_heuristics->has_coalesce_and_fill_candidates()) {\n+    \/\/ No candidate regions to coalesce and fill\n+    transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+    return;\n+  }\n+\n+  if (state() == ShenandoahOldGeneration::EVACUATING) {\n+    transition_to(ShenandoahOldGeneration::FILLING);\n+    return;\n+  }\n+\n+  \/\/ Here, we have no more candidates for mixed collections. The candidates for coalescing\n+  \/\/ and filling have already been processed during the global cycle, so there is nothing\n+  \/\/ more to do.\n+  assert(state() == ShenandoahOldGeneration::EVACUATING_AFTER_GLOBAL, \"Should be evacuating after a global cycle\");\n+  abandon_collection_candidates();\n+  transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+}\n+\n+void ShenandoahOldGeneration::abandon_mixed_evacuations() {\n+  switch(state()) {\n+    case ShenandoahOldGeneration::EVACUATING:\n+      transition_to(ShenandoahOldGeneration::FILLING);\n+      break;\n+    case ShenandoahOldGeneration::EVACUATING_AFTER_GLOBAL:\n+      abandon_collection_candidates();\n+      transition_to(ShenandoahOldGeneration::WAITING_FOR_BOOTSTRAP);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":126,"deletions":39,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -79,0 +79,3 @@\n+  \/\/ True if old regions may be safely traversed by the remembered set scan.\n+  bool _is_parseable;\n+\n@@ -129,0 +132,4 @@\n+  \/\/ Class unloading may render the card table offsets unusable, if they refer to unmarked objects\n+  bool is_parseable() const   { return _is_parseable; }\n+  void set_parseable(bool parseable);\n+\n@@ -146,0 +153,7 @@\n+  \/\/ Transition to the next state after mixed evacuations have completed\n+  void complete_mixed_evacuations();\n+\n+  \/\/ Abandon any future mixed collections. This is invoked when all old regions eligible for\n+  \/\/ inclusion in a mixed evacuation are pinned. This should be rare.\n+  void abandon_mixed_evacuations();\n+\n@@ -189,1 +203,1 @@\n-    return state() == EVACUATING;\n+    return state() == EVACUATING || state() == EVACUATING_AFTER_GLOBAL;\n@@ -196,0 +210,8 @@\n+  bool is_idle() const {\n+    return state() == WAITING_FOR_BOOTSTRAP;\n+  }\n+\n+  bool is_bootstrapping() const {\n+    return state() == BOOTSTRAPPING;\n+  }\n+\n@@ -205,1 +227,1 @@\n-    FILLING, WAITING_FOR_BOOTSTRAP, BOOTSTRAPPING, MARKING, EVACUATING\n+    FILLING, WAITING_FOR_BOOTSTRAP, BOOTSTRAPPING, MARKING, EVACUATING, EVACUATING_AFTER_GLOBAL\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+    case degen_gc_coalesce_and_fill:\n@@ -123,0 +124,1 @@\n+    case conc_coalesce_and_fill:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,2 +105,0 @@\n-  f(coalesce_and_fill,                              \"Coalesce and Fill Old Dead\")      \\\n-  SHENANDOAH_PAR_PHASE_DO(coalesce_and_fill_,       \"  CFOD: \", f)                     \\\n@@ -127,0 +125,2 @@\n+  f(conc_coalesce_and_fill,                         \"Concurrent Coalesce and Fill\")    \\\n+  SHENANDOAH_PAR_PHASE_DO(conc_coalesce_,           \"  CC&F: \", f)                     \\\n@@ -156,0 +156,2 @@\n+  f(degen_gc_coalesce_and_fill,                     \"  Degen Coalesce and Fill\")       \\\n+  SHENANDOAH_PAR_PHASE_DO(degen_coalesce_,          \"    DC&F\", f)                     \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -554,0 +554,1 @@\n+  assert(ShenandoahHeap::heap()->old_generation()->is_parseable(), \"Old generation regions must be parseable for remembered set scan\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}