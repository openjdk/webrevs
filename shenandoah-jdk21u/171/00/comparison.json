{"files":[{"patch":"@@ -59,1 +59,0 @@\n-  double last_shrink_time = os::elapsedTime();\n@@ -62,6 +61,0 @@\n-  \/\/ Shrink period avoids constantly polling regions for shrinking.\n-  \/\/ Having a period 10x lower than the delay would mean we hit the\n-  \/\/ shrinking with lag of less than 1\/10-th of true delay.\n-  \/\/ ShenandoahUncommitDelay is in msecs, but shrink_period is in seconds.\n-  const double shrink_period = (double)ShenandoahUncommitDelay \/ 1000 \/ 10;\n-\n@@ -79,3 +72,0 @@\n-    \/\/ Check if we have seen a new target for soft max heap size.\n-    const bool soft_max_changed = heap->check_soft_max_changed();\n-\n@@ -139,0 +129,3 @@\n+      \/\/ Cannot uncommit bitmap slices during concurrent reset\n+      ShenandoahNoUncommitMark forbid_region_uncommit(heap);\n+\n@@ -243,18 +236,8 @@\n-    const double current = os::elapsedTime();\n-\n-    if (ShenandoahUncommit && (is_gc_requested || soft_max_changed || (current - last_shrink_time > shrink_period))) {\n-      \/\/ Explicit GC tries to uncommit everything down to min capacity.\n-      \/\/ Soft max change tries to uncommit everything down to target capacity.\n-      \/\/ Periodic uncommit tries to uncommit suitable regions down to min capacity.\n-\n-      double shrink_before = (is_gc_requested || soft_max_changed) ?\n-                             current :\n-                             current - (ShenandoahUncommitDelay \/ 1000.0);\n-\n-      size_t shrink_until = soft_max_changed ?\n-                             heap->soft_max_capacity() :\n-                             heap->min_capacity();\n-\n-      heap->maybe_uncommit(shrink_before, shrink_until);\n-      heap->phase_timings()->flush_cycle_to_global();\n-      last_shrink_time = current;\n+    \/\/ Check if we have seen a new target for soft max heap size or if a gc was requested.\n+    \/\/ Either of these conditions will attempt to uncommit regions.\n+    if (ShenandoahUncommit) {\n+      if (heap->check_soft_max_changed()) {\n+        heap->notify_soft_max_changed();\n+      } else if (is_gc_requested) {\n+        heap->notify_explicit_gc_requested();\n+      }\n@@ -266,0 +249,1 @@\n+    const double current = os::elapsedTime();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":12,"deletions":28,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-    ShenandoahHeapRegion* region = _regions.next();\n@@ -78,0 +77,2 @@\n+    assert(!heap->is_uncommit_in_progress(), \"Cannot uncommit bitmaps while resetting them.\");\n+    ShenandoahHeapRegion* region = _regions.next();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-  double last_shrink_time = os::elapsedTime();\n@@ -73,6 +72,0 @@\n-  \/\/ Shrink period avoids constantly polling regions for shrinking.\n-  \/\/ Having a period 10x lower than the delay would mean we hit the\n-  \/\/ shrinking with lag of less than 1\/10-th of true delay.\n-  \/\/ ShenandoahUncommitDelay is in msecs, but shrink_period is in seconds.\n-  const double shrink_period = (double)ShenandoahUncommitDelay \/ 1000 \/ 10;\n-\n@@ -194,0 +187,3 @@\n+      \/\/ Cannot uncommit bitmap slices during concurrent reset\n+      ShenandoahNoUncommitMark forbid_region_uncommit(heap);\n+\n@@ -309,18 +305,8 @@\n-    const double current = os::elapsedTime();\n-\n-    if (ShenandoahUncommit && (is_gc_requested || soft_max_changed || (current - last_shrink_time > shrink_period))) {\n-      \/\/ Explicit GC tries to uncommit everything down to min capacity.\n-      \/\/ Soft max change tries to uncommit everything down to target capacity.\n-      \/\/ Periodic uncommit tries to uncommit suitable regions down to min capacity.\n-\n-      double shrink_before = (is_gc_requested || soft_max_changed) ?\n-                             current :\n-                             current - (ShenandoahUncommitDelay \/ 1000.0);\n-\n-      size_t shrink_until = soft_max_changed ?\n-                             heap->soft_max_capacity() :\n-                             heap->min_capacity();\n-\n-      heap->maybe_uncommit(shrink_before, shrink_until);\n-      heap->phase_timings()->flush_cycle_to_global();\n-      last_shrink_time = current;\n+    \/\/ Check if we have seen a new target for soft max heap size or if a gc was requested.\n+    \/\/ Either of these conditions will attempt to uncommit regions.\n+    if (ShenandoahUncommit) {\n+      if (heap->check_soft_max_changed()) {\n+        heap->notify_soft_max_changed();\n+      } else if (is_gc_requested) {\n+        heap->notify_explicit_gc_requested();\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":11,"deletions":25,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"gc\/shenandoah\/shenandoahUncommitThread.hpp\"\n@@ -458,0 +459,4 @@\n+  if (ShenandoahUncommit) {\n+    _uncommit_thread = new ShenandoahUncommitThread(this);\n+  }\n+\n@@ -527,0 +532,1 @@\n+  _uncommit_thread(nullptr),\n@@ -786,24 +792,3 @@\n-void ShenandoahHeap::maybe_uncommit(double shrink_before, size_t shrink_until) {\n-  assert (ShenandoahUncommit, \"should be enabled\");\n-\n-  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n-  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n-  \/\/ and minimises the amount of work while locks are taken.\n-\n-  if (committed() <= shrink_until) return;\n-\n-  bool has_work = false;\n-  for (size_t i = 0; i < num_regions(); i++) {\n-    ShenandoahHeapRegion* r = get_region(i);\n-    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n-      has_work = true;\n-      break;\n-    }\n-  }\n-\n-  if (has_work) {\n-    static const char* msg = \"Concurrent uncommit\";\n-    ShenandoahConcurrentPhase gcPhase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n-    EventMark em(\"%s\", msg);\n-\n-    op_uncommit(shrink_before, shrink_until);\n+void ShenandoahHeap::notify_soft_max_changed() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->notify_soft_max_changed();\n@@ -813,27 +798,3 @@\n-void ShenandoahHeap::op_uncommit(double shrink_before, size_t shrink_until) {\n-  assert (ShenandoahUncommit, \"should be enabled\");\n-\n-  \/\/ Application allocates from the beginning of the heap, and GC allocates at\n-  \/\/ the end of it. It is more efficient to uncommit from the end, so that applications\n-  \/\/ could enjoy the near committed regions. GC allocations are much less frequent,\n-  \/\/ and therefore can accept the committing costs.\n-\n-  size_t count = 0;\n-  for (size_t i = num_regions(); i > 0; i--) { \/\/ care about size_t underflow\n-    ShenandoahHeapRegion* r = get_region(i - 1);\n-    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n-      ShenandoahHeapLocker locker(lock());\n-      if (r->is_empty_committed()) {\n-        if (committed() < shrink_until + ShenandoahHeapRegion::region_size_bytes()) {\n-          break;\n-        }\n-\n-        r->make_uncommitted();\n-        count++;\n-      }\n-    }\n-    SpinPause(); \/\/ allow allocators to take the lock\n-  }\n-\n-  if (count > 0) {\n-    notify_heap_changed();\n+void ShenandoahHeap::notify_explicit_gc_requested() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->notify_explicit_gc_requested();\n@@ -1564,0 +1525,4 @@\n+  if (_uncommit_thread != nullptr) {\n+    tcl->do_thread(_uncommit_thread);\n+  }\n+\n@@ -2164,0 +2129,5 @@\n+\n+  \/\/ Stop 4. Shutdown uncommit thread.\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->stop();\n+  }\n@@ -2591,1 +2561,1 @@\n-    \/\/ slice is should stay committed, exit right away.\n+    \/\/ slice should stay committed, exit right away.\n@@ -2605,0 +2575,21 @@\n+void ShenandoahHeap::forbid_uncommit() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->forbid_uncommit();\n+  }\n+}\n+\n+void ShenandoahHeap::allow_uncommit() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->allow_uncommit();\n+  }\n+}\n+\n+#ifdef ASSERT\n+bool ShenandoahHeap::is_uncommit_in_progress() {\n+  if (_uncommit_thread != nullptr) {\n+    return _uncommit_thread->is_uncommit_in_progress();\n+  }\n+  return false;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":43,"deletions":52,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+class ShenandoahUncommitThread;\n@@ -255,1 +256,2 @@\n-private:\n+public:\n+  \/\/ Notify heuristics and region state change logger that the state of the heap has changed\n@@ -258,1 +260,1 @@\n-public:\n+  \/\/ Force counters to update\n@@ -260,0 +262,2 @@\n+\n+  \/\/ Update counters if forced flag is set\n@@ -458,5 +462,0 @@\n-  \/\/ These will uncommit empty regions if heap::committed > shrink_until\n-  \/\/ and there exists at least one region which was made empty before shrink_before.\n-  void maybe_uncommit(double shrink_before, size_t shrink_until);\n-  void op_uncommit(double shrink_before, size_t shrink_until);\n-\n@@ -500,2 +499,6 @@\n-\/\/\n-\/\/ Mark support\n+  \/\/ The uncommit thread targets soft max heap, notify this thread when that value has changed.\n+  void notify_soft_max_changed();\n+\n+  \/\/ An explicit GC request may have freed regions, notify the uncommit thread.\n+  void notify_explicit_gc_requested();\n+\n@@ -506,0 +509,1 @@\n+  \/\/ The control thread presides over concurrent collection cycles\n@@ -508,0 +512,3 @@\n+  \/\/ The uncommit thread periodically attempts to uncommit regions that have been empty for longer than ShenandoahUncommitDelay\n+  ShenandoahUncommitThread*  _uncommit_thread;\n+\n@@ -522,1 +529,1 @@\n-  ShenandoahController*   control_thread() { return _control_thread; }\n+  ShenandoahController*   control_thread() const { return _control_thread; }\n@@ -749,0 +756,14 @@\n+  \/\/ During concurrent reset, the control thread will zero out the mark bitmaps for committed regions.\n+  \/\/ This cannot happen when the uncommit thread is simultaneously trying to uncommit regions and their bitmaps.\n+  \/\/ To prevent these threads from working at the same time, we provide these methods for the control thread to\n+  \/\/ prevent the uncommit thread from working while a collection cycle is in progress.\n+\n+  \/\/ Forbid uncommits (will stop and wait if regions are being uncommitted)\n+  void forbid_uncommit();\n+\n+  \/\/ Allow the uncommit thread to process regions\n+  void allow_uncommit();\n+#ifdef ASSERT\n+  bool is_uncommit_in_progress();\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -198,1 +198,0 @@\n-  f(conc_uncommit,                                  \"Concurrent Uncommit\")             \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUncommitThread.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+ShenandoahUncommitThread::ShenandoahUncommitThread(ShenandoahHeap* heap)\n+  : _heap(heap),\n+    _uncommit_lock(Mutex::safepoint - 2, \"ShenandoahUncommit_lock\", true) {\n+  set_name(\"Shenandoah Uncommit Thread\");\n+  create_and_start();\n+\n+  \/\/ Allow uncommits. This is managed by the control thread during a GC.\n+  _uncommit_allowed.set();\n+}\n+\n+void ShenandoahUncommitThread::run_service() {\n+  assert(ShenandoahUncommit, \"Thread should only run when uncommit is enabled\");\n+\n+  \/\/ poll_interval avoids constantly polling regions for shrinking.\n+  \/\/ Having an interval 10x lower than the delay would mean we hit the\n+  \/\/ shrinking with lag of less than 1\/10-th of true delay.\n+  \/\/ ShenandoahUncommitDelay is in millis, but shrink_period is in seconds.\n+  const int64_t poll_interval = int64_t(ShenandoahUncommitDelay) \/ 10;\n+  const double shrink_period = double(ShenandoahUncommitDelay) \/ 1000;\n+  bool timed_out = false;\n+  while (!should_terminate()) {\n+    bool soft_max_changed = _soft_max_changed.try_unset();\n+    bool explicit_gc_requested = _explicit_gc_requested.try_unset();\n+\n+    if (soft_max_changed || explicit_gc_requested || timed_out) {\n+      double current = os::elapsedTime();\n+      size_t shrink_until = soft_max_changed ? _heap->soft_max_capacity() : _heap->min_capacity();\n+      double shrink_before = (soft_max_changed || explicit_gc_requested) ?\n+              current :\n+              current - shrink_period;\n+\n+      \/\/ Explicit GC tries to uncommit everything down to min capacity.\n+      \/\/ Soft max change tries to uncommit everything down to target capacity.\n+      \/\/ Periodic uncommit tries to uncommit suitable regions down to min capacity.\n+      if (should_uncommit(shrink_before, shrink_until)) {\n+        uncommit(shrink_before, shrink_until);\n+      }\n+    }\n+\n+    if (!should_terminate()) {\n+      MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+      timed_out = locker.wait(poll_interval);\n+    }\n+  }\n+}\n+\n+bool ShenandoahUncommitThread::should_uncommit(double shrink_before, size_t shrink_until) const {\n+  \/\/ Only start uncommit if the GC is idle, is not trying to run and there is work to do.\n+  return _heap->is_idle() && is_uncommit_allowed() && has_work(shrink_before, shrink_until);\n+}\n+\n+bool ShenandoahUncommitThread::has_work(double shrink_before, size_t shrink_until) const {\n+  \/\/ Determine if there is work to do. This avoids locking the heap if there is\n+  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n+  \/\/ and minimises the amount of work while locks are held.\n+\n+  if (_heap->committed() <= shrink_until) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < _heap->num_regions(); i++) {\n+    ShenandoahHeapRegion *r = _heap->get_region(i);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+void ShenandoahUncommitThread::notify_soft_max_changed() {\n+  assert(is_uncommit_allowed(), \"Only notify if uncommit is allowed\");\n+  if (_soft_max_changed.try_set()) {\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    locker.notify_all();\n+  }\n+}\n+\n+void ShenandoahUncommitThread::notify_explicit_gc_requested() {\n+  assert(is_uncommit_allowed(), \"Only notify if uncommit is allowed\");\n+  if (_explicit_gc_requested.try_set()) {\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    locker.notify_all();\n+  }\n+}\n+\n+bool ShenandoahUncommitThread::is_uncommit_allowed() const {\n+  return _uncommit_allowed.is_set();\n+}\n+\n+void ShenandoahUncommitThread::uncommit(double shrink_before, size_t shrink_until) {\n+  assert(ShenandoahUncommit, \"should be enabled\");\n+  assert(_uncommit_in_progress.is_unset(), \"Uncommit should not be in progress\");\n+\n+  {\n+    \/\/ Final check, under the lock, if uncommit is allowed.\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    if (is_uncommit_allowed()) {\n+      _uncommit_in_progress.set();\n+    }\n+  }\n+\n+  \/\/ If not allowed to start, do nothing.\n+  if (!_uncommit_in_progress.is_set()) {\n+    return;\n+  }\n+\n+  \/\/ From here on, uncommit is in progress. Attempts to stop the uncommit must wait\n+  \/\/ until the cancellation request is acknowledged and uncommit is no longer in progress.\n+  const char* msg = \"Concurrent uncommit\";\n+  const double start = os::elapsedTime();\n+  EventMark em(\"%s\", msg);\n+  log_info(gc, start)(\"%s\", msg);\n+\n+  \/\/ This is the number of regions uncommitted during this increment of uncommit work.\n+  const size_t uncommitted_region_count = do_uncommit_work(shrink_before, shrink_until);\n+\n+  {\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    _uncommit_in_progress.unset();\n+    locker.notify_all();\n+  }\n+\n+  if (uncommitted_region_count > 0) {\n+    _heap->notify_heap_changed();\n+  }\n+\n+  const double elapsed = os::elapsedTime() - start;\n+  log_info(gc)(\"%s \" PROPERFMT \" (\" PROPERFMT \") %.3fms\",\n+               msg, PROPERFMTARGS(uncommitted_region_count * ShenandoahHeapRegion::region_size_bytes()), PROPERFMTARGS(_heap->capacity()),\n+               elapsed * MILLIUNITS);\n+}\n+\n+size_t ShenandoahUncommitThread::do_uncommit_work(double shrink_before, size_t shrink_until) const {\n+  size_t count = 0;\n+  \/\/ Application allocates from the beginning of the heap, and GC allocates at\n+  \/\/ the end of it. It is more efficient to uncommit from the end, so that applications\n+  \/\/ could enjoy the near committed regions. GC allocations are much less frequent,\n+  \/\/ and therefore can accept the committing costs.\n+  for (size_t i = _heap->num_regions(); i > 0; i--) {\n+    if (!is_uncommit_allowed()) {\n+      \/\/ GC wants to start, so the uncommit operation must stop\n+      break;\n+    }\n+\n+    ShenandoahHeapRegion* r = _heap->get_region(i - 1);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      SuspendibleThreadSetJoiner sts_joiner;\n+      ShenandoahHeapLocker heap_locker(_heap->lock());\n+      if (r->is_empty_committed()) {\n+        if (_heap->committed() < shrink_until + ShenandoahHeapRegion::region_size_bytes()) {\n+          \/\/ We have uncommitted enough regions to hit the target heap committed size\n+          break;\n+        }\n+\n+        r->make_uncommitted();\n+        count++;\n+      }\n+    }\n+    SpinPause(); \/\/ allow allocators to take the lock\n+  }\n+  return count;\n+}\n+\n+\n+void ShenandoahUncommitThread::stop_service() {\n+  MonitorLocker locker(&_uncommit_lock, Mutex::_safepoint_check_flag);\n+  _uncommit_allowed.unset();\n+  locker.notify_all();\n+}\n+\n+void ShenandoahUncommitThread::forbid_uncommit() {\n+  MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+  _uncommit_allowed.unset();\n+  while (_uncommit_in_progress.is_set()) {\n+    locker.wait();\n+  }\n+}\n+\n+void ShenandoahUncommitThread::allow_uncommit() {\n+  MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+  _uncommit_allowed.set();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.cpp","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHUNCOMMITTHREAD\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHUNCOMMITTHREAD\n+\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+\n+class ShenandoahHeap;\n+\n+class ShenandoahUncommitThread : public ConcurrentGCThread {\n+  ShenandoahHeap* const _heap;\n+\n+  \/\/ Indicates that `SoftMaxHeapSize` has changed\n+  ShenandoahSharedFlag _soft_max_changed;\n+\n+  \/\/ Indicates that an explicit gc has been requested\n+  ShenandoahSharedFlag _explicit_gc_requested;\n+\n+  \/\/ Indicates whether it is safe to uncommit regions\n+  ShenandoahSharedFlag _uncommit_allowed;\n+\n+  \/\/ Indicates that regions are being actively uncommitted\n+  ShenandoahSharedFlag _uncommit_in_progress;\n+\n+  \/\/ This lock is used to coordinate allowing or forbidding regions to be uncommitted\n+  Monitor _uncommit_lock;\n+\n+  \/\/ True if there are regions to uncommit and uncommits are allowed\n+  bool should_uncommit(double shrink_before, size_t shrink_until) const;\n+\n+  \/\/ True if there are regions that have been empty for longer than ShenandoahUncommitDelay and the committed\n+  \/\/ memory is higher than soft max capacity or minimum capacity\n+  bool has_work(double shrink_before, size_t shrink_until) const;\n+\n+  \/\/ Perform the work of uncommitting empty regions\n+  void uncommit(double shrink_before, size_t shrink_until);\n+\n+  \/\/ True if the control thread has allowed this thread to uncommit regions\n+  bool is_uncommit_allowed() const;\n+\n+  \/\/ Iterate over and uncommit eligible regions until committed heap falls below\n+  \/\/ `shrink_until` bytes. A region is eligible for uncommit if the timestamp at which\n+  \/\/ it was last made empty is before `shrink_before` seconds since jvm start.\n+  \/\/ Returns the number of regions uncommitted. May be interrupted by `forbid_uncommit`.\n+  size_t do_uncommit_work(double shrink_before, size_t shrink_until) const;\n+\n+public:\n+  explicit ShenandoahUncommitThread(ShenandoahHeap* heap);\n+\n+  \/\/ Periodically check for regions to uncommit\n+  void run_service() override;\n+\n+  \/\/ Wake up this thread and try to uncommit for changed soft max size\n+  void notify_soft_max_changed();\n+\n+  \/\/ Wake up this thread and try to uncommit for min heap size\n+  void notify_explicit_gc_requested();\n+\n+  \/\/ Wait for uncommit operations to stop, returns immediately if uncommit thread is idle\n+  void forbid_uncommit();\n+\n+  \/\/ Allows uncommit operations to happen, does not block\n+  void allow_uncommit();\n+\n+  \/\/ True if uncommit is in progress\n+  bool is_uncommit_in_progress() const {\n+    return _uncommit_in_progress.is_set();\n+  }\n+protected:\n+  \/\/ Interrupt and stop this thread\n+  void stop_service() override;\n+};\n+\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHUNCOMMITTHREAD\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -245,0 +245,15 @@\n+\/\/ Regions cannot be uncommitted when concurrent reset is zeroing out the bitmaps.\n+\/\/ This CADR class enforces this by forbidding region uncommits while it is in scope.\n+class ShenandoahNoUncommitMark : public StackObj {\n+  ShenandoahHeap* const _heap;\n+public:\n+  explicit ShenandoahNoUncommitMark(ShenandoahHeap* heap) : _heap(heap) {\n+    _heap->forbid_uncommit();\n+  }\n+\n+  ~ShenandoahNoUncommitMark() {\n+    _heap->allow_uncommit();\n+  }\n+};\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}