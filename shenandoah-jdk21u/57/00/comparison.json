{"files":[{"patch":"@@ -128,3 +128,1 @@\n-  \/\/ Check that we won't overwrite existing data: caller is\n-  \/\/ responsible for explicitly clearing the slot via calling\n-  \/\/ prepare_for_census_update().\n+  prepare_for_census_update();\n@@ -158,0 +156,4 @@\n+\n+  \/\/ used for checking reasonableness of census coverage, non-product\n+  \/\/ only.\n+  NOT_PRODUCT(update_total();)\n@@ -216,0 +218,21 @@\n+\n+size_t ShenandoahAgeCensus::get_all_ages(uint snap) {\n+  assert(snap < MAX_SNAPSHOTS, \"Out of bounds\");\n+  size_t pop = 0;\n+  const AgeTable* pv = _global_age_table[snap];\n+  for (uint i = 0; i < MAX_COHORTS; i++) {\n+    pop += pv->sizes[i];\n+  }\n+  return pop;\n+}\n+\n+size_t ShenandoahAgeCensus::get_skipped(uint snap) {\n+  assert(snap < MAX_SNAPSHOTS, \"Out of bounds\");\n+  return _global_noise[snap].skipped;\n+}\n+\n+void ShenandoahAgeCensus::update_total() {\n+  _counted = get_all_ages(_epoch);\n+  _skipped = get_skipped(_epoch);\n+  _total   = _counted + _skipped;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+\n+  size_t _skipped;                   \/\/ net size of objects encountered, but skipped during census,\n+                                     \/\/ because their age was indeterminate\n@@ -106,0 +109,5 @@\n+#ifndef PRODUCT\n+  size_t _counted;                   \/\/ net size of objects counted in census\n+  size_t _total;                     \/\/ net size of objects encountered (counted or skipped) in census\n+#endif\n+\n@@ -114,0 +122,3 @@\n+  \/\/ Update to a new epoch, creating a slot for new census.\n+  void prepare_for_census_update();\n+\n@@ -115,1 +126,1 @@\n-  \/\/ compute_tenuring_threshold to calculate the new\n+  \/\/ compute_tenuring_threshold() to calculate the new\n@@ -119,3 +130,3 @@\n-  \/\/ This uses the data in the ShenandoahAgeCensus object's _global_age_table and the\n-  \/\/ current _epoch to compute a new tenuring threshold, which will be remembered\n-  \/\/ until the next invocation of compute_tenuring_threshold.\n+  \/\/ Use _global_age_table and the current _epoch to compute a new tenuring\n+  \/\/ threshold, which will be remembered until the next invocation of\n+  \/\/ compute_tenuring_threshold.\n@@ -124,0 +135,26 @@\n+  \/\/ Return the tenuring threshold computed for the previous epoch\n+  uint previous_tenuring_threshold() const {\n+    assert(_epoch < MAX_SNAPSHOTS, \"Error\");\n+    uint prev = _epoch - 1;\n+    if (prev >= MAX_SNAPSHOTS) {\n+      \/\/ _epoch is 0\n+      assert(_epoch == 0, \"Error\");\n+      prev = MAX_SNAPSHOTS - 1;\n+    }\n+    return _tenuring_threshold[prev];\n+  }\n+\n+#ifndef PRODUCT\n+  \/\/ Return the sum of size of objects of all ages recorded in the\n+  \/\/ census at snapshot indexed by snap.\n+  size_t get_all_ages(uint snap);\n+\n+  \/\/ Return the size of all objects that were encountered, but skipped,\n+  \/\/ during the census, because their age was indeterminate.\n+  size_t get_skipped(uint snap);\n+\n+  \/\/ Update the total size of objects counted or skipped at the census for\n+  \/\/ the most recent epoch.\n+  void update_total();\n+#endif \/\/ !PRODUCT\n+\n@@ -154,3 +191,0 @@\n-  \/\/ Update to a new epoch, creating a slot for new census.\n-  void prepare_for_census_update();\n-\n@@ -158,0 +192,3 @@\n+  \/\/ This method should be called at the end of each marking (or optionally\n+  \/\/ evacuation) cycle to update the tenuring threshold to be used in\n+  \/\/ the next cycle.\n@@ -159,1 +196,6 @@\n-  \/\/ the regular census.\n+  \/\/ the regular census during the marking cycle, corresponding to objects\n+  \/\/ allocated when the concurrent marking was in progress.\n+  \/\/ Optional parameters, pv1 and pv2 are population vectors that together\n+  \/\/ provide object census data (only) for the case when\n+  \/\/ ShenandoahGenerationalCensusAtEvac. In this case, the age0_pop\n+  \/\/ is 0, because the evacuated objects have all had their ages incremented.\n@@ -165,11 +207,0 @@\n-  \/\/ Return the tenuring threshold computed for the previous epoch\n-  uint previous_tenuring_threshold() const {\n-    assert(_epoch < MAX_SNAPSHOTS, \"Error\");\n-    uint prev = _epoch - 1;\n-    if (prev >= MAX_SNAPSHOTS) {\n-      \/\/ _epoch is 0\n-      prev = MAX_SNAPSHOTS - 1;\n-    }\n-    return _tenuring_threshold[prev];\n-  }\n-\n@@ -177,0 +208,2 @@\n+  \/\/ Note: this isn't currently used, but reserved for planned\n+  \/\/ future usage.\n@@ -178,1 +211,2 @@\n-  \/\/ Reset any partial census information\n+\n+  \/\/ Reset any (potentially partial) census information in worker-local age tables\n@@ -185,0 +219,4 @@\n+\n+  \/\/ Return the net size of objects encountered (counted or skipped) in census\n+  \/\/ at most recent epoch.\n+  size_t get_total() { return _total; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":58,"deletions":20,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+  ShenandoahGenerationType gen_type = _generation->type();\n@@ -244,1 +245,1 @@\n-    switch (_generation->type()) {\n+    switch (gen_type) {\n@@ -246,3 +247,0 @@\n-        \/\/ Clear any old\/partial local census data before the start of marking.\n-        heap->age_census()->reset_local();\n-        assert(heap->age_census()->is_clear_local(), \"Error\");\n@@ -261,3 +259,0 @@\n-        \/\/ Clear any old\/partial local census data before the start of marking.\n-        heap->age_census()->reset_local();\n-        assert(heap->age_census()->is_clear_local(), \"Error\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -152,2 +152,2 @@\n-    \/\/ Ingest population vectors into the heap's global census\n-    \/\/ data, and use it to compute an appropriate tenuring threshold\n+    \/\/ Ingest mutator & worker collected population vectors into the heap's\n+    \/\/ global census data, and use it to compute an appropriate tenuring threshold\n@@ -155,2 +155,0 @@\n-    ShenandoahAgeCensus* census = ShenandoahHeap::heap()->age_census();\n-    census->prepare_for_census_update();\n@@ -159,1 +157,1 @@\n-    census->update_census(0, _mutators_global.age_table(), _workers_global.age_table());\n+    ShenandoahHeap::heap()->age_census()->update_census(0, _mutators_global.age_table(), _workers_global.age_table());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -680,1 +680,1 @@\n-    size_t age0_pop = age0_cl.get_population();\n+    size_t age0_pop = age0_cl.get_age0_population();\n@@ -682,3 +682,0 @@\n-    \/\/ Age table updates\n-    ShenandoahAgeCensus* census = heap->age_census();\n-    census->prepare_for_census_update();\n@@ -686,2 +683,11 @@\n-    \/\/ along with the census during marking, and compute the tenuring threshold\n-    census->update_census(age0_pop);\n+    \/\/ along with the census done during marking, and compute the tenuring threshold.\n+    heap->age_census()->update_census(age0_pop);\n+#ifndef PRODUCT\n+    size_t total_pop = age0_cl.get_total_population();\n+    size_t total_census = heap->age_census()->get_total();\n+    \/\/ Usually total_pop > total_census, but not by too much.\n+    \/\/ We use integer division so anything up to just less than 2 is considered\n+    \/\/ reasonable, and the \"+1\" is to avoid divide-by-zero.\n+    assert((total_pop+1)\/(total_census+1) ==  1, \"Extreme divergence: \"\n+           SIZE_FORMAT \"\/\" SIZE_FORMAT, total_pop, total_census);\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -125,0 +125,13 @@\n+\n+void ShenandoahGlobalGeneration::prepare_gc() {\n+  ShenandoahGeneration::prepare_gc();\n+\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    assert(type() == GLOBAL, \"Unexpected generation type\");\n+    \/\/ Clear any stale\/partial local census data before the start of a\n+    \/\/ new marking cycle\n+    ShenandoahHeap::heap()->age_census()->reset_local();\n+  } else {\n+    assert(type() == NON_GEN, \"Unexpected generation type\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+\n+  virtual void prepare_gc() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  _ctx(ctx), _pop(0) {}\n+  _ctx(ctx), _age0_pop(0), _total_pop(0) {}\n@@ -92,1 +92,1 @@\n-      _pop += pointer_delta(top, tams);\n+      _age0_pop += pointer_delta(top, tams);\n@@ -94,0 +94,3 @@\n+    \/\/ TODO: check significance of _ctx != nullptr above, can that\n+    \/\/ spoof _total_pop in some corner cases?\n+    NOT_PRODUCT(_total_pop += r->get_live_data_words();)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+\/\/ In non-product builds, for the purposes of verification, we also collect the total\n+\/\/ live objects in young regions as well.\n@@ -51,1 +53,3 @@\n-  size_t _pop;   \/\/ running tally of population\n+  \/\/ Population size units are words (not bytes)\n+  size_t _age0_pop;                \/\/ running tally of age0 population size\n+  size_t _total_pop;               \/\/ total live population size\n@@ -57,1 +61,2 @@\n-  size_t get_population() { return _pop; }\n+  size_t get_age0_population()  { return _age0_pop; }\n+  size_t get_total_population() { return _total_pop; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -106,0 +106,9 @@\n+void ShenandoahYoungGeneration::prepare_gc() {\n+\n+  ShenandoahGeneration::prepare_gc();\n+\n+  assert(type() == YOUNG, \"Error?\");\n+  \/\/ Clear any stale\/partial local census data before the start of a\n+  \/\/ new marking cycle\n+  ShenandoahHeap::heap()->age_census()->reset_local();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+\n+  virtual void prepare_gc() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}