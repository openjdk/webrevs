{"files":[{"patch":"@@ -87,1 +87,1 @@\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+            debian-repository: https:\/\/snapshot.debian.org\/archive\/debian\/20240228T034848Z\/\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -352,0 +352,1 @@\n+      - test-macos-aarch64\n@@ -363,1 +364,1 @@\n-              '${{ github.api_url }}\/repos\/${{ github.repository }}\/actions\/runs\/${{ github.run_id }}\/artifacts')\"\n+              '${{ github.api_url }}\/repos\/${{ github.repository }}\/actions\/runs\/${{ github.run_id }}\/artifacts?per_page=100')\"\n","filename":".github\/workflows\/main.yml","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+# JDK Vulnerabilities\n+\n+Please follow the process outlined in the [OpenJDK Vulnerability Policy](https:\/\/openjdk.org\/groups\/vulnerability\/report) to disclose vulnerabilities in the JDK.\n","filename":"SECURITY.md","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -572,4 +572,3 @@\n-<p>You will need the Xcode command line developer tools to be able to\n-build the JDK. (Actually, <em>only<\/em> the command line tools are\n-needed, not the IDE.) The simplest way to install these is to run:<\/p>\n-<pre><code>xcode-select --install<\/code><\/pre>\n+<p>You will need to download Xcode either from the App Store or specific\n+versions can be easily located via the <a\n+href=\"https:\/\/xcodereleases.com\">Xcode Releases<\/a> website.<\/p>\n","filename":"doc\/building.html","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -369,6 +369,3 @@\n-You will need the Xcode command line developer tools to be able to build\n-the JDK. (Actually, *only* the command line tools are needed, not the IDE.)\n-The simplest way to install these is to run:\n-```\n-xcode-select --install\n-```\n+You will need to download Xcode either from the App Store or specific versions\n+can be easily located via the [Xcode Releases](https:\/\/xcodereleases.com)\n+website.\n","filename":"doc\/building.md","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -452,0 +452,5 @@\n+    # or look like\n+    #     gcc (GCC) 10.2.1 20200825 (Alibaba 10.2.1-3.8 2.32)\n+    #     Copyright (C) 2020 Free Software Foundation, Inc.\n+    #     This is free software; see the source for copying conditions.  There is NO\n+    #     warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n@@ -465,1 +470,2 @@\n-        $SED -e 's\/^.* \\(@<:@1-9@:>@<:@0-9@:>@*\\.@<:@0-9.@:>@*\\)@<:@^0-9.@:>@.*$\/\\1\/'`\n+        $AWK -F ')' '{print [$]2}' | \\\n+        $AWK '{print [$]1}'`\n","filename":"make\/autoconf\/toolchain.m4","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=5\n+DEFAULT_VERSION_UPDATE=6\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2024-10-15\n+DEFAULT_VERSION_DATE=2025-01-21\n@@ -42,1 +42,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=\n+DEFAULT_PROMOTED_VERSION_PRE=ea\n","filename":"make\/conf\/version-numbers.conf","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -367,14 +367,15 @@\n-            switch (mon) {\n-            case \"Jan\": return Month.JANUARY;\n-            case \"Feb\": return Month.FEBRUARY;\n-            case \"Mar\": return Month.MARCH;\n-            case \"Apr\": return Month.APRIL;\n-            case \"May\": return Month.MAY;\n-            case \"Jun\": return Month.JUNE;\n-            case \"Jul\": return Month.JULY;\n-            case \"Aug\": return Month.AUGUST;\n-            case \"Sep\": return Month.SEPTEMBER;\n-            case \"Oct\": return Month.OCTOBER;\n-            case \"Nov\": return Month.NOVEMBER;\n-            case \"Dec\": return Month.DECEMBER;\n-            }\n+            int len = mon.length();\n+\n+            if (mon.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n+            if (mon.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n+            if (mon.regionMatches(true, 0, \"March\", 0, len)) return Month.MARCH;\n+            if (mon.regionMatches(true, 0, \"April\", 0, len)) return Month.APRIL;\n+            if (mon.regionMatches(true, 0, \"May\", 0, len)) return Month.MAY;\n+            if (mon.regionMatches(true, 0, \"June\", 0, len)) return Month.JUNE;\n+            if (mon.regionMatches(true, 0, \"July\", 0, len)) return Month.JULY;\n+            if (mon.regionMatches(true, 0, \"August\", 0, len)) return Month.AUGUST;\n+            if (mon.regionMatches(true, 0, \"September\", 0, len)) return Month.SEPTEMBER;\n+            if (mon.regionMatches(true, 0, \"October\", 0, len)) return Month.OCTOBER;\n+            if (mon.regionMatches(true, 0, \"November\", 0, len)) return Month.NOVEMBER;\n+            if (mon.regionMatches(true, 0, \"December\", 0, len)) return Month.DECEMBER;\n+\n@@ -385,9 +386,10 @@\n-            switch (dow) {\n-            case \"Mon\": return DayOfWeek.MONDAY;\n-            case \"Tue\": return DayOfWeek.TUESDAY;\n-            case \"Wed\": return DayOfWeek.WEDNESDAY;\n-            case \"Thu\": return DayOfWeek.THURSDAY;\n-            case \"Fri\": return DayOfWeek.FRIDAY;\n-            case \"Sat\": return DayOfWeek.SATURDAY;\n-            case \"Sun\": return DayOfWeek.SUNDAY;\n-            }\n+            int len = dow.length();\n+\n+            if (dow.regionMatches(true, 0, \"Monday\", 0, len)) return DayOfWeek.MONDAY;\n+            if (dow.regionMatches(true, 0, \"Tuesday\", 0, len)) return DayOfWeek.TUESDAY;\n+            if (dow.regionMatches(true, 0, \"Wednesday\", 0, len)) return DayOfWeek.WEDNESDAY;\n+            if (dow.regionMatches(true, 0, \"Thursday\", 0, len)) return DayOfWeek.THURSDAY;\n+            if (dow.regionMatches(true, 0, \"Friday\", 0, len)) return DayOfWeek.FRIDAY;\n+            if (dow.regionMatches(true, 0, \"Saturday\", 0, len)) return DayOfWeek.SATURDAY;\n+            if (dow.regionMatches(true, 0, \"Sunday\", 0, len)) return DayOfWeek.SUNDAY;\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/tzdb\/TzdbZoneRulesProvider.java","additions":26,"deletions":24,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -870,1 +870,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectTest.c libTestPsig.c libnativeStack.c exeGetCreatedJavaVMs.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectTest.c libTestPsig.c libnativeStack.c exeGetCreatedJavaVMs.c libTestUnloadedClass.cpp\n@@ -1513,0 +1513,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libTestUnloadedClass += -lpthread\n@@ -1515,1 +1516,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += libNativeException.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += libNativeException.c exeGetProcessorInfo.c\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1091,2 +1091,2 @@\n-  \/\/ registers where op1 (instr[20:19]) == 11 and, (currently) only\n-  \/\/ use it for FPSR n.b msr has L (instr[21]) == 0 mrs has L == 1\n+  \/\/ registers where op1 (instr[20:19]) == 11\n+  \/\/ n.b msr has L (instr[21]) == 0 mrs has L == 1\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-          \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n+          \/*release*\/ true, \/*weak*\/ false, tmp3Reg); \/\/ Sets flags for result\n@@ -132,1 +132,1 @@\n-  cmp(rscratch1, rthread);\n+  cmp(tmp3Reg, rthread);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -272,0 +272,3 @@\n+    \/\/ Restore cpu control state after JNI call\n+    __ restore_cpu_control_state_after_jni(rscratch1, tmp1);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    entry_frame_after_call_words                     = 27,\n+    entry_frame_after_call_words                     = 29,\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1511,5 +1511,1 @@\n-  mov(rscratch2, (address)&SharedRuntime::_partial_subtype_ctr);\n-  Address pst_counter_addr(rscratch2);\n-  ldr(rscratch1, pst_counter_addr);\n-  add(rscratch1, rscratch1, 1);\n-  str(rscratch1, pst_counter_addr);\n+  incrementw(ExternalAddress((address)&SharedRuntime::_partial_subtype_ctr));\n@@ -4442,0 +4438,17 @@\n+void MacroAssembler::restore_cpu_control_state_after_jni(Register tmp1, Register tmp2) {\n+  if (RestoreMXCSROnJNICalls) {\n+    Label OK;\n+    get_fpcr(tmp1);\n+    mov(tmp2, tmp1);\n+    \/\/ Set FPCR to the state we need. We do want Round to Nearest. We\n+    \/\/ don't want non-IEEE rounding modes or floating-point traps.\n+    bfi(tmp1, zr, 22, 4); \/\/ Clear DN, FZ, and Rmode\n+    bfi(tmp1, zr, 8, 5);  \/\/ Clear exception-control bits (8-12)\n+    bfi(tmp1, zr, 0, 2);  \/\/ Clear AH:FIZ\n+    eor(tmp2, tmp1, tmp2);\n+    cbz(tmp2, OK);        \/\/ Only reset FPCR if it's wrong\n+    set_fpcr(tmp1);\n+    bind(OK);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -573,0 +573,13 @@\n+  \/\/ FPCR : op1 == 011\n+  \/\/        CRn == 0100\n+  \/\/        CRm == 0100\n+  \/\/        op2 == 000\n+\n+  inline void get_fpcr(Register reg) {\n+    mrs(0b11, 0b0100, 0b0100, 0b000, reg);\n+  }\n+\n+  inline void set_fpcr(Register reg) {\n+    msr(0b011, 0b0100, 0b0100, 0b000, reg);\n+  }\n+\n@@ -1036,2 +1049,2 @@\n-  \/\/ only if +VerifyFPU\n-  void verify_FPU(int stack_depth, const char* s = \"illegal FPU state\");\n+  \/\/ Restore cpu control state after JNI call\n+  void restore_cpu_control_state_after_jni(Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -39,1 +40,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<MacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1848,0 +1848,3 @@\n+  \/\/ Verify or restore cpu control state after JNI call\n+  __ restore_cpu_control_state_after_jni(rscratch1, rscratch2);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,4 +87,1 @@\n-    __ lea(rscratch2, ExternalAddress((address)&counter));\n-    __ ldrw(rscratch1, Address(rscratch2));\n-    __ addw(rscratch1, rscratch1, 1);\n-    __ strw(rscratch1, Address(rscratch2));\n+    __ incrementw(ExternalAddress((address)&counter));\n@@ -142,1 +139,2 @@\n-  \/\/ -27 [ argument word 1      ]\n+  \/\/ -29 [ argument word 1      ]\n+  \/\/ -28 [ saved Floating-point Control Register ]\n@@ -174,1 +172,1 @@\n-    sp_after_call_off = -26,\n+    sp_after_call_off  = -28,\n@@ -176,0 +174,1 @@\n+    fpcr_off           = sp_after_call_off,\n@@ -205,1 +204,1 @@\n-    const Address sp_after_call(rfp, sp_after_call_off * wordSize);\n+    const Address sp_after_call (rfp, sp_after_call_off * wordSize);\n@@ -207,0 +206,1 @@\n+    const Address fpcr_save     (rfp, fpcr_off           * wordSize);\n@@ -255,0 +255,8 @@\n+    __ get_fpcr(rscratch1);\n+    __ str(rscratch1, fpcr_save);\n+    \/\/ Set FPCR to the state we need. We do want Round to Nearest. We\n+    \/\/ don't want non-IEEE rounding modes or floating-point traps.\n+    __ bfi(rscratch1, zr, 22, 4); \/\/ Clear DN, FZ, and Rmode\n+    __ bfi(rscratch1, zr, 8, 5);  \/\/ Clear exception-control bits (8-12)\n+    __ set_fpcr(rscratch1);\n+\n@@ -368,0 +376,4 @@\n+    \/\/ restore fpcr\n+    __ ldr(rscratch1,  fpcr_save);\n+    __ set_fpcr(rscratch1);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -66,1 +67,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -1369,0 +1370,3 @@\n+  \/\/ Restore cpu control state after JNI call\n+  __ restore_cpu_control_state_after_jni(rscratch1, rscratch2);\n+\n@@ -1992,7 +1996,15 @@\n-  aep = __ pc();  __ push_ptr();  __ b(L);\n-  fep = __ pc();  __ push_f();    __ b(L);\n-  dep = __ pc();  __ push_d();    __ b(L);\n-  lep = __ pc();  __ push_l();    __ b(L);\n-  bep = cep = sep =\n-  iep = __ pc();  __ push_i();\n-  vep = __ pc();\n+  aep = __ pc();     \/\/ atos entry point\n+      __ push_ptr();\n+      __ b(L);\n+  fep = __ pc();     \/\/ ftos entry point\n+      __ push_f();\n+      __ b(L);\n+  dep = __ pc();     \/\/ dtos entry point\n+      __ push_d();\n+      __ b(L);\n+  lep = __ pc();     \/\/ ltos entry point\n+      __ push_l();\n+      __ b(L);\n+  bep = cep = sep = iep = __ pc();     \/\/ [bcsi]tos entry point\n+      __ push_i();\n+  vep = __ pc();     \/\/ vtos entry point\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -49,1 +50,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,3 +138,14 @@\n-  { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), \"adjust code below\");\n-    int monitor_offset = BytesPerWord * method()->max_locals() +\n-      (2 * BytesPerWord) * (number_of_locks - 1);\n+  {\n+    assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), \"adjust code below\");\n+\n+    const int locals_space = BytesPerWord * method()->max_locals();\n+    int monitor_offset = locals_space + (2 * BytesPerWord) * (number_of_locks - 1);\n+    bool use_OSR_bias = false;\n+\n+    if (!Assembler::is_simm16(monitor_offset + BytesPerWord) && number_of_locks > 0) {\n+      \/\/ Offsets too large for ld instructions. Use bias.\n+      __ add_const_optimized(OSR_buf, OSR_buf, locals_space);\n+      monitor_offset -= locals_space;\n+      use_OSR_bias = true;\n+    }\n+\n@@ -166,0 +177,5 @@\n+\n+    if (use_OSR_bias) {\n+      \/\/ Restore.\n+      __ sub_const_optimized(OSR_buf, OSR_buf, locals_space);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-    common_abi* sender_abi = (common_abi*) fp;\n+    volatile common_abi* sender_abi = (common_abi*) fp; \/\/ May get updated concurrently by deoptimization!\n@@ -122,1 +122,1 @@\n-    address   sender_pc = (address) sender_abi->lr;;\n+    address   sender_pc = (address) sender_abi->lr;\n@@ -137,0 +137,9 @@\n+    intptr_t* unextended_sender_sp = is_interpreted_frame() ? interpreter_frame_sender_sp() : sender_sp;\n+\n+    \/\/ If the sender is a deoptimized nmethod we need to check if the original pc is valid.\n+    nmethod* sender_nm = sender_blob->as_nmethod_or_null();\n+    if (sender_nm != nullptr && sender_nm->is_deopt_pc(sender_pc)) {\n+      address orig_pc = *(address*)((address)unextended_sender_sp + sender_nm->orig_pc_offset());\n+      if (!sender_nm->insts_contains_inclusive(orig_pc)) return false;\n+    }\n+\n@@ -139,1 +148,1 @@\n-    frame sender(sender_sp, sender_pc);\n+    frame sender(sender_sp, sender_pc, unextended_sender_sp, nullptr \/* fp *\/, sender_blob);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3533,0 +3533,1 @@\n+    call->_has_ea_local_in_scope = _has_ea_local_in_scope;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-instruct xLoadP(iRegPNoSp dst, memory mem)\n+instruct xLoadP(iRegPNoSp dst, memory mem, iRegPNoSp tmp, rFlagsReg cr)\n@@ -59,1 +59,1 @@\n-  effect(TEMP dst);\n+  effect(TEMP dst, TEMP tmp, KILL cr);\n@@ -68,1 +68,1 @@\n-    x_load_barrier(_masm, this, ref_addr, $dst$$Register, t0 \/* tmp *\/, barrier_data());\n+    x_load_barrier(_masm, this, ref_addr, $dst$$Register, $tmp$$Register \/* tmp *\/, barrier_data());\n@@ -74,1 +74,1 @@\n-instruct xCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n+instruct xCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -78,1 +78,1 @@\n-  effect(KILL cr, TEMP_DEF res);\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr);\n@@ -89,5 +89,3 @@\n-               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n-               true \/* result_as_bool *\/);\n-    __ beqz($res$$Register, failed);\n-    __ mv(t0, $oldval$$Register);\n-    __ bind(failed);\n+               Assembler::relaxed \/* acquire *\/, Assembler::rl \/* release *\/, $tmp$$Register);\n+    __ sub(t0, $tmp$$Register, $oldval$$Register);\n+    __ seqz($res$$Register, t0);\n@@ -96,4 +94,4 @@\n-      __ ld(t1, Address(xthread, XThreadLocalData::address_bad_mask_offset()), t1 \/* tmp *\/);\n-      __ andr(t1, t1, t0);\n-      __ beqz(t1, good);\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), t0 \/* ref *\/, t1 \/* tmp *\/);\n+      __ ld(t0, Address(xthread, XThreadLocalData::address_bad_mask_offset()));\n+      __ andr(t0, t0, $tmp$$Register);\n+      __ beqz(t0, good);\n+      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $tmp$$Register \/* ref *\/, $res$$Register \/* tmp *\/);\n@@ -110,1 +108,1 @@\n-instruct xCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, rFlagsReg cr) %{\n+instruct xCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -114,1 +112,1 @@\n-  effect(KILL cr, TEMP_DEF res);\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr);\n@@ -125,5 +123,3 @@\n-               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $res$$Register,\n-               true \/* result_as_bool *\/);\n-    __ beqz($res$$Register, failed);\n-    __ mv(t0, $oldval$$Register);\n-    __ bind(failed);\n+               Assembler::aq \/* acquire *\/, Assembler::rl \/* release *\/, $tmp$$Register);\n+    __ sub(t0, $tmp$$Register, $oldval$$Register);\n+    __ seqz($res$$Register, t0);\n@@ -132,4 +128,4 @@\n-      __ ld(t1, Address(xthread, XThreadLocalData::address_bad_mask_offset()), t1 \/* tmp *\/);\n-      __ andr(t1, t1, t0);\n-      __ beqz(t1, good);\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), t0 \/* ref *\/, t1 \/* tmp *\/);\n+      __ ld(t0, Address(xthread, XThreadLocalData::address_bad_mask_offset()));\n+      __ andr(t0, t0, $tmp$$Register);\n+      __ beqz(t0, good);\n+      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $tmp$$Register \/* ref *\/, $res$$Register \/* tmp *\/);\n@@ -146,1 +142,1 @@\n-instruct xCompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval) %{\n+instruct xCompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -149,1 +145,1 @@\n-  effect(TEMP_DEF res);\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr);\n@@ -164,1 +160,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, t0 \/* tmp *\/);\n+      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, $tmp$$Register \/* tmp *\/);\n@@ -174,1 +170,1 @@\n-instruct xCompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval) %{\n+instruct xCompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -177,1 +173,1 @@\n-  effect(TEMP_DEF res);\n+  effect(TEMP_DEF res, TEMP tmp, KILL cr);\n@@ -192,1 +188,1 @@\n-      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, t0 \/* tmp *\/);\n+      x_load_barrier_slow_path(_masm, this, Address($mem$$Register), $res$$Register \/* ref *\/, $tmp$$Register \/* tmp *\/);\n@@ -202,1 +198,1 @@\n-instruct xGetAndSetP(indirect mem, iRegP newv, iRegPNoSp prev, rFlagsReg cr) %{\n+instruct xGetAndSetP(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -205,1 +201,1 @@\n-  effect(TEMP_DEF prev, KILL cr);\n+  effect(TEMP_DEF prev, TEMP tmp, KILL cr);\n@@ -213,1 +209,1 @@\n-    x_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, t0 \/* tmp *\/, barrier_data());\n+    x_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, $tmp$$Register \/* tmp *\/, barrier_data());\n@@ -219,1 +215,1 @@\n-instruct xGetAndSetPAcq(indirect mem, iRegP newv, iRegPNoSp prev, rFlagsReg cr) %{\n+instruct xGetAndSetPAcq(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -222,1 +218,1 @@\n-  effect(TEMP_DEF prev, KILL cr);\n+  effect(TEMP_DEF prev, TEMP tmp, KILL cr);\n@@ -230,1 +226,1 @@\n-    x_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, t0 \/* tmp *\/, barrier_data());\n+    x_load_barrier(_masm, this, Address(noreg, 0), $prev$$Register, $tmp$$Register \/* tmp *\/, barrier_data());\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/x\/x_riscv.ad","additions":33,"deletions":37,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    z_color(_masm, node, rnew_zpointer, rnew_zaddress, t0);\n+    z_color(_masm, node, rnew_zpointer, rnew_zaddress, tmp);\n@@ -93,1 +93,1 @@\n-instruct zLoadP(iRegPNoSp dst, memory mem)\n+instruct zLoadP(iRegPNoSp dst, memory mem, iRegPNoSp tmp, rFlagsReg cr)\n@@ -97,1 +97,1 @@\n-  effect(TEMP dst);\n+  effect(TEMP dst, TEMP tmp, KILL cr);\n@@ -106,1 +106,1 @@\n-    z_load_barrier(_masm, this, ref_addr, $dst$$Register, t0);\n+    z_load_barrier(_masm, this, ref_addr, $dst$$Register, $tmp$$Register);\n@@ -113,1 +113,1 @@\n-instruct zStoreP(memory mem, iRegP src, iRegPNoSp tmp, rFlagsReg cr)\n+instruct zStoreP(memory mem, iRegP src, iRegPNoSp tmp1, iRegPNoSp tmp2, rFlagsReg cr)\n@@ -117,1 +117,1 @@\n-  effect(TEMP tmp, KILL cr);\n+  effect(TEMP tmp1, TEMP tmp2, KILL cr);\n@@ -123,2 +123,2 @@\n-    z_store_barrier(_masm, this, ref_addr, $src$$Register, $tmp$$Register, t1, false \/* is_atomic *\/);\n-    __ sd($tmp$$Register, ref_addr);\n+    z_store_barrier(_masm, this, ref_addr, $src$$Register, $tmp1$$Register, $tmp2$$Register, false \/* is_atomic *\/);\n+    __ sd($tmp1$$Register, ref_addr);\n@@ -129,1 +129,2 @@\n-instruct zCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, rFlagsReg cr) %{\n+instruct zCompareAndSwapP(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval,\n+                          iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1, rFlagsReg cr) %{\n@@ -133,1 +134,1 @@\n-  effect(TEMP oldval_tmp, TEMP newval_tmp, KILL cr, TEMP_DEF res);\n+  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res, KILL cr);\n@@ -143,2 +144,2 @@\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, t0);\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, t1, true \/* is_atomic *\/);\n+    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n+    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n@@ -151,1 +152,2 @@\n-instruct zCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, rFlagsReg cr) %{\n+instruct zCompareAndSwapPAcq(iRegINoSp res, indirect mem, iRegP oldval, iRegP newval,\n+                             iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1, rFlagsReg cr) %{\n@@ -155,1 +157,1 @@\n-  effect(TEMP oldval_tmp, TEMP newval_tmp, KILL cr, TEMP_DEF res);\n+  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res, KILL cr);\n@@ -165,2 +167,2 @@\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, t0);\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, t1, true \/* is_atomic *\/);\n+    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n+    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n@@ -173,1 +175,2 @@\n-instruct zCompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, rFlagsReg cr) %{\n+instruct zCompareAndExchangeP(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval,\n+                              iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1, rFlagsReg cr) %{\n@@ -176,1 +179,1 @@\n-  effect(TEMP oldval_tmp, TEMP newval_tmp, KILL cr, TEMP_DEF res);\n+  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res, KILL cr);\n@@ -185,2 +188,2 @@\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, t0);\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, t1, true \/* is_atomic *\/);\n+    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n+    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n@@ -194,1 +197,2 @@\n-instruct zCompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval, iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, rFlagsReg cr) %{\n+instruct zCompareAndExchangePAcq(iRegPNoSp res, indirect mem, iRegP oldval, iRegP newval,\n+                                 iRegPNoSp oldval_tmp, iRegPNoSp newval_tmp, iRegPNoSp tmp1, rFlagsReg cr) %{\n@@ -197,1 +201,1 @@\n-  effect(TEMP oldval_tmp, TEMP newval_tmp, KILL cr, TEMP_DEF res);\n+  effect(TEMP oldval_tmp, TEMP newval_tmp, TEMP tmp1, TEMP_DEF res, KILL cr);\n@@ -206,2 +210,2 @@\n-    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, t0);\n-    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, t1, true \/* is_atomic *\/);\n+    z_color(_masm, this, $oldval_tmp$$Register, $oldval$$Register, $tmp1$$Register);\n+    z_store_barrier(_masm, this, ref_addr, $newval$$Register, $newval_tmp$$Register, $tmp1$$Register, true \/* is_atomic *\/);\n@@ -215,1 +219,1 @@\n-instruct zGetAndSetP(indirect mem, iRegP newv, iRegPNoSp prev, rFlagsReg cr) %{\n+instruct zGetAndSetP(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -218,1 +222,1 @@\n-  effect(TEMP_DEF prev, KILL cr);\n+  effect(TEMP_DEF prev, TEMP tmp, KILL cr);\n@@ -225,1 +229,1 @@\n-    z_store_barrier(_masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, t1, true \/* is_atomic *\/);\n+    z_store_barrier(_masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, $tmp$$Register, true \/* is_atomic *\/);\n@@ -233,1 +237,1 @@\n-instruct zGetAndSetPAcq(indirect mem, iRegP newv, iRegPNoSp prev, rFlagsReg cr) %{\n+instruct zGetAndSetPAcq(indirect mem, iRegP newv, iRegPNoSp prev, iRegPNoSp tmp, rFlagsReg cr) %{\n@@ -236,1 +240,1 @@\n-  effect(TEMP_DEF prev, KILL cr);\n+  effect(TEMP_DEF prev, TEMP tmp, KILL cr);\n@@ -243,1 +247,1 @@\n-    z_store_barrier(_masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, t1, true \/* is_atomic *\/);\n+    z_store_barrier(_masm, this, Address($mem$$Register), $newv$$Register, $prev$$Register, $tmp$$Register, true \/* is_atomic *\/);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/z_riscv.ad","additions":34,"deletions":30,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -268,1 +268,0 @@\n-  membar(MacroAssembler::AnyAny);\n@@ -853,1 +852,1 @@\n-      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, t0, count, \/*fallthrough*\/nullptr);\n+      cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, tmp, count, \/*fallthrough*\/nullptr);\n@@ -967,1 +966,1 @@\n-      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, t0, count, \/*fallthrough*\/nullptr);\n+      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, tmp_reg, count, \/*fallthrough*\/nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,0 +77,10 @@\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n@@ -85,1 +95,1 @@\n-    __ sw(x10, Address(to(), next_stack_offset()));\n+    __ sd(x10, Address(to(), next_stack_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/interpreterRT_riscv.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -774,1 +774,0 @@\n-  \/\/ use addiw to distinguish li32 to li64\n@@ -778,27 +777,0 @@\n-void MacroAssembler::li64(Register Rd, int64_t imm) {\n-  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n-  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n-  int64_t lower = imm & 0xffffffff;\n-  lower -= ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n-\n-  \/\/ Load upper 32 bits\n-  int64_t up = upper, lo = upper;\n-  lo = (lo << 52) >> 52;\n-  up -= lo;\n-  up = (int32_t)up;\n-  lui(Rd, up);\n-  addi(Rd, Rd, lo);\n-\n-  \/\/ Load the rest 32 bits.\n-  slli(Rd, Rd, 12);\n-  addi(Rd, Rd, (int32_t)lower >> 20);\n-  slli(Rd, Rd, 12);\n-  lower = ((int32_t)imm << 12) >> 20;\n-  addi(Rd, Rd, lower);\n-  slli(Rd, Rd, 8);\n-  lower = imm & 0xff;\n-  addi(Rd, Rd, lower);\n-}\n-\n@@ -1394,21 +1366,0 @@\n-static int patch_imm_in_li64(address branch, address target) {\n-  const int LI64_INSTRUCTIONS_NUM = 8;                                          \/\/ lui + addi + slli + addi + slli + addi + slli + addi\n-  int64_t lower = (intptr_t)target & 0xffffffff;\n-  lower = lower - ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)((intptr_t)target & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper =  (tmp_imm - (int32_t)lower) >> 32;\n-  int64_t tmp_upper = upper, tmp_lower = upper;\n-  tmp_lower = (tmp_lower << 52) >> 52;\n-  tmp_upper -= tmp_lower;\n-  tmp_upper >>= 12;\n-  \/\/ Load upper 32 bits. Upper = target[63:32], but if target[31] = 1 or (target[31:20] == 0x7ff && target[19] == 1),\n-  \/\/ upper = target[63:32] + 1.\n-  Assembler::patch(branch + 0,  31, 12, tmp_upper & 0xfffff);                       \/\/ Lui.\n-  Assembler::patch(branch + 4,  31, 20, tmp_lower & 0xfff);                         \/\/ Addi.\n-  \/\/ Load the rest 32 bits.\n-  Assembler::patch(branch + 12, 31, 20, ((int32_t)lower >> 20) & 0xfff);            \/\/ Addi.\n-  Assembler::patch(branch + 20, 31, 20, (((intptr_t)target << 44) >> 52) & 0xfff);  \/\/ Addi.\n-  Assembler::patch(branch + 28, 31, 20, (intptr_t)target & 0xff);                   \/\/ Addi.\n-  return LI64_INSTRUCTIONS_NUM * NativeInstruction::instruction_size;\n-}\n-\n@@ -1474,10 +1425,0 @@\n-static address get_target_of_li64(address insn_addr) {\n-  assert_cond(insn_addr != nullptr);\n-  intptr_t target_address = (((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr), 31, 12)) & 0xfffff) << 44; \/\/ Lui.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 4), 31, 20)) << 32;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 12), 31, 20)) << 20;                \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 20), 31, 20)) << 8;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 28), 31, 20));                      \/\/ Addi.\n-  return (address)target_address;\n-}\n-\n@@ -1504,2 +1445,0 @@\n-  } else if (NativeInstruction::is_li64_at(branch)) {                 \/\/ li64\n-    return patch_imm_in_li64(branch, target);\n@@ -1534,2 +1473,0 @@\n-  } else if (NativeInstruction::is_li64_at(insn_addr)) {             \/\/ li64\n-    return get_target_of_li64(insn_addr);\n@@ -2586,3 +2523,3 @@\n-  assert_different_registers(addr, tmp);\n-  assert_different_registers(newv, tmp);\n-  assert_different_registers(oldv, tmp);\n+  assert_different_registers(addr, tmp, t0);\n+  assert_different_registers(newv, tmp, t0);\n+  assert_different_registers(oldv, tmp, t0);\n@@ -4498,4 +4435,10 @@\n-\/\/ On 64 bit we will store integer like items to the stack as\n-\/\/ 64 bits items (riscv64 abi) even though java would only store\n-\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n-\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n@@ -4506,1 +4449,1 @@\n-      ld(tmp, Address(fp, reg2offset_in(src.first())));\n+      lw(tmp, Address(fp, reg2offset_in(src.first())));\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":14,"deletions":71,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -709,1 +709,0 @@\n-  void li64(Register Rd, int64_t imm);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -40,1 +41,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<MacroAssembler>(__FILE__, __LINE__, _masm)->\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -112,12 +112,0 @@\n-bool NativeInstruction::is_li64_at(address instr) {\n-  return is_lui_at(instr) && \/\/ lui\n-         is_addi_at(instr + instruction_size) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 2, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 3) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 4, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 5) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 6, 8) &&   \/\/ Slli Rd, Rs, 8\n-         is_addi_at(instr + instruction_size * 7) && \/\/ addi\n-         check_li64_data_dependency(instr);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -130,34 +130,0 @@\n-  \/\/ the instruction sequence of li64 is as below:\n-  \/\/     lui\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  static bool check_li64_data_dependency(address instr) {\n-    address lui = instr;\n-    address addi1 = lui + instruction_size;\n-    address slli1 = addi1 + instruction_size;\n-    address addi2 = slli1 + instruction_size;\n-    address slli2 = addi2 + instruction_size;\n-    address addi3 = slli2 + instruction_size;\n-    address slli3 = addi3 + instruction_size;\n-    address addi4 = slli3 + instruction_size;\n-    return extract_rs1(addi1) == extract_rd(lui) &&\n-           extract_rs1(addi1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(addi4);\n-  }\n-\n@@ -210,1 +176,0 @@\n-  static bool is_li64_at(address instr);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-reg_def R2      ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()         ); \/\/ sp\n-reg_def R2_H    ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()->next() );\n+reg_def R2      ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()         ); \/\/ sp\n+reg_def R2_H    ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()->next() );\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3604,1 +3604,0 @@\n-    __ vmv1r_v(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg));\n@@ -3608,1 +3607,1 @@\n-    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($dst$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($dst$$reg), as_VectorRegister($idx$$reg), (int)sew);\n@@ -3638,1 +3637,0 @@\n-    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n@@ -3642,1 +3640,1 @@\n-    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg), (int)sew);\n@@ -3678,1 +3676,0 @@\n-    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n@@ -3682,1 +3679,1 @@\n-    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg), (int)sew);\n@@ -3712,1 +3709,0 @@\n-    __ vmv1r_v(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg));\n@@ -3716,1 +3712,1 @@\n-    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($tmp$$reg), (int)sew);\n+    __ vsll_vi(as_VectorRegister($tmp$$reg), as_VectorRegister($idx$$reg), (int)sew);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1689,1 +1689,1 @@\n-      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, count, \/*fallthrough*\/nullptr);\n+      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, lock_tmp, count, \/*fallthrough*\/nullptr);\n@@ -1829,1 +1829,1 @@\n-      __ cmpxchg_obj_header(x10, old_hdr, obj_reg, t0, count, &slow_path_unlock);\n+      __ cmpxchg_obj_header(x10, old_hdr, obj_reg, lock_tmp, count, &slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -70,1 +71,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -1732,7 +1733,15 @@\n-  aep = __ pc();  __ push_ptr();  __ j(L);\n-  fep = __ pc();  __ push_f();    __ j(L);\n-  dep = __ pc();  __ push_d();    __ j(L);\n-  lep = __ pc();  __ push_l();    __ j(L);\n-  bep = cep = sep =\n-  iep = __ pc();  __ push_i();\n-  vep = __ pc();\n+  aep = __ pc();     \/\/ atos entry point\n+      __ push_ptr();\n+      __ j(L);\n+  fep = __ pc();     \/\/ ftos entry point\n+      __ push_f();\n+      __ j(L);\n+  dep = __ pc();     \/\/ dtos entry point\n+      __ push_d();\n+      __ j(L);\n+  lep = __ pc();     \/\/ ltos entry point\n+      __ push_l();\n+      __ j(L);\n+  bep = cep = sep = iep = __ pc();     \/\/ [bcsi]tos entry point\n+      __ push_i();\n+  vep = __ pc();     \/\/ vtos entry point\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"compiler\/disassembler.hpp\"\n@@ -49,1 +50,1 @@\n-#define __ _masm->\n+#define __ Disassembler::hook<InterpreterMacroAssembler>(__FILE__, __LINE__, _masm)->\n@@ -311,1 +312,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -2233,1 +2233,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -2248,1 +2247,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -3455,1 +3453,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -3575,1 +3572,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n@@ -3631,1 +3627,0 @@\n-  __ membar(MacroAssembler::AnyAny);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+\/\/ Generic implementation. GCs can provide an optimized one.\n@@ -109,3 +110,0 @@\n-  NearLabel Ldone;\n-  __ z_ltgr(tmp1, value);\n-  __ z_bre(Ldone);          \/\/ Use null result as-is.\n@@ -113,2 +111,4 @@\n-  __ z_nill(value, ~JNIHandles::tag_mask);\n-  __ z_lg(value, 0, value); \/\/ Resolve (untagged) jobject.\n+  assert_different_registers(value, tmp1, tmp2);\n+  NearLabel done, weak_tag, verify, tagged;\n+  __ z_ltgr(value, value);\n+  __ z_bre(done);          \/\/ Use null result as-is.\n@@ -116,0 +116,44 @@\n+  __ z_tmll(value, JNIHandles::tag_mask);\n+  __ z_btrue(tagged); \/\/ not zero\n+\n+  \/\/ Resolve Local handle\n+  __ access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, Address(value, 0), value, tmp1, tmp2);\n+  __ z_bru(verify);\n+\n+  __ bind(tagged);\n+  __ testbit(value, exact_log2(JNIHandles::TypeTag::weak_global)); \/\/ test for weak tag\n+  __ z_btrue(weak_tag);\n+\n+  \/\/ resolve global handle\n+  __ access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::TypeTag::global), value, tmp1, tmp2);\n+  __ z_bru(verify);\n+\n+  __ bind(weak_tag);\n+  \/\/ resolve jweak.\n+  __ access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                    Address(value, -JNIHandles::TypeTag::weak_global), value, tmp1, tmp2);\n+  __ bind(verify);\n+  __ verify_oop(value, FILE_AND_LINE);\n+  __ bind(done);\n+}\n+\n+\/\/ Generic implementation. GCs can provide an optimized one.\n+void BarrierSetAssembler::resolve_global_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  NearLabel done;\n+\n+  __ z_ltgr(value, value);\n+  __ z_bre(done); \/\/ use null as-is.\n+\n+#ifdef ASSERT\n+  {\n+    NearLabel valid_global_tag;\n+    __ testbit(value, exact_log2(JNIHandles::TypeTag::global)); \/\/ test for global tag\n+    __ z_btrue(valid_global_tag);\n+    __ stop(\"non global jobject using resolve_global_jobject\");\n+    __ bind(valid_global_tag);\n+  }\n+#endif \/\/ ASSERT\n+\n+  \/\/ Resolve global handle\n+  __ access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::TypeTag::global), value, tmp1, tmp2);\n@@ -117,1 +161,1 @@\n-  __ bind(Ldone);\n+  __ bind(done);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  virtual void resolve_global_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/jniHandles.hpp\"\n@@ -61,0 +62,13 @@\n+\n+void ModRefBarrierSetAssembler::resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2) {\n+  NearLabel done;\n+\n+  __ z_ltgr(value, value);\n+  __ z_bre(done);  \/\/ use null as-is.\n+\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n+  __ z_lg(value, 0, value); \/\/ Resolve (untagged) jobject.\n+\n+  __ verify_oop(value, FILE_AND_LINE);\n+  __ bind(done);\n+}\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024 SAP SE. All rights reserved.\n@@ -51,0 +51,2 @@\n+\n+  virtual void resolve_jobject(MacroAssembler* masm, Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/modRefBarrierSetAssembler_s390.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3338,0 +3338,5 @@\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->resolve_global_jobject(this, value, tmp1, tmp2);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -729,0 +729,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n@@ -790,1 +791,0 @@\n- private:\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3749,1 +3749,1 @@\n-void Assembler::nop(int i) {\n+void Assembler::nop(uint i) {\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1711,1 +1711,1 @@\n-  void nop(int i = 1);\n+  void nop(uint i = 1);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1150,1 +1150,1 @@\n-  align(64, (unsigned long long) pc());\n+  align(64, (uint)(uintptr_t)pc());\n@@ -1154,1 +1154,1 @@\n-  align(32, (unsigned long long) pc());\n+  align(32, (uint)(uintptr_t)pc());\n@@ -1157,1 +1157,1 @@\n-void MacroAssembler::align(int modulus) {\n+void MacroAssembler::align(uint modulus) {\n@@ -1159,1 +1159,1 @@\n-  assert(modulus <= CodeEntryAlignment, \"Alignment must be <= CodeEntryAlignment\");\n+  assert(modulus <= (uintx)CodeEntryAlignment, \"Alignment must be <= CodeEntryAlignment\");\n@@ -1163,1 +1163,1 @@\n-void MacroAssembler::align(int modulus, int target) {\n+void MacroAssembler::align(uint modulus, uint target) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -215,2 +215,2 @@\n-  void align(int modulus);\n-  void align(int modulus, int target);\n+  void align(uint modulus);\n+  void align(uint modulus, uint target);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+product(bool, UseAllWindowsProcessorGroups, false,                        \\\n+        \"Use all processor groups on supported Windows versions\")         \\\n+                                                                          \\\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+#include \"utilities\/population_count.hpp\"\n@@ -879,10 +880,61 @@\n-  DWORD_PTR lpProcessAffinityMask = 0;\n-  DWORD_PTR lpSystemAffinityMask = 0;\n-  int proc_count = processor_count();\n-  if (proc_count <= sizeof(UINT_PTR) * BitsPerByte &&\n-      GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask)) {\n-    \/\/ Nof active processors is number of bits in process affinity mask\n-    int bitcount = 0;\n-    while (lpProcessAffinityMask != 0) {\n-      lpProcessAffinityMask = lpProcessAffinityMask & (lpProcessAffinityMask-1);\n-      bitcount++;\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  if (UseAllWindowsProcessorGroups && !schedules_all_processor_groups && !win32::processor_group_warning_displayed()) {\n+    win32::set_processor_group_warning_displayed(true);\n+    FLAG_SET_DEFAULT(UseAllWindowsProcessorGroups, false);\n+    warning(\"The UseAllWindowsProcessorGroups flag is not supported on this Windows version and will be ignored.\");\n+  }\n+\n+  DWORD active_processor_groups = 0;\n+  DWORD processors_in_job_object = win32::active_processors_in_job_object(&active_processor_groups);\n+\n+  if (processors_in_job_object > 0) {\n+    if (schedules_all_processor_groups) {\n+      \/\/ If UseAllWindowsProcessorGroups is enabled then all the processors in the job object\n+      \/\/ can be used. Otherwise, we will fall through to inspecting the process affinity mask.\n+      \/\/ This will result in using only the subset of the processors in the default processor\n+      \/\/ group allowed by the job object i.e. only 1 processor group will be used and only\n+      \/\/ the processors in that group that are allowed by the job object will be used.\n+      \/\/ This preserves the behavior where older OpenJDK versions always used one processor\n+      \/\/ group regardless of whether they were launched in a job object.\n+      if (!UseAllWindowsProcessorGroups && active_processor_groups > 1) {\n+        if (!win32::job_object_processor_group_warning_displayed()) {\n+          win32::set_job_object_processor_group_warning_displayed(true);\n+          warning(\"The Windows job object has enabled multiple processor groups (%d) but the UseAllWindowsProcessorGroups flag is off. Some processors might not be used.\", active_processor_groups);\n+        }\n+      } else {\n+        return processors_in_job_object;\n+      }\n+    } else {\n+      if (active_processor_groups > 1 && !win32::job_object_processor_group_warning_displayed()) {\n+        win32::set_job_object_processor_group_warning_displayed(true);\n+        warning(\"The Windows job object has enabled multiple processor groups (%d) but only 1 is supported on this Windows version. Some processors might not be used.\", active_processor_groups);\n+      }\n+      return processors_in_job_object;\n+    }\n+  }\n+\n+  DWORD logical_processors = 0;\n+  SYSTEM_INFO si;\n+  GetSystemInfo(&si);\n+\n+  USHORT group_count = 0;\n+  bool use_process_affinity_mask = false;\n+  bool got_process_group_affinity = false;\n+\n+  if (GetProcessGroupAffinity(GetCurrentProcess(), &group_count, nullptr) == 0) {\n+    DWORD last_error = GetLastError();\n+    if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+      if (group_count > 0) {\n+        got_process_group_affinity = true;\n+\n+        if (group_count == 1) {\n+          use_process_affinity_mask = true;\n+        }\n+      } else {\n+        warning(\"Unexpected group count of 0 from GetProcessGroupAffinity.\");\n+        assert(false, \"Group count must not be 0.\");\n+      }\n+    } else {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to get process group affinity failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n@@ -890,1 +942,0 @@\n-    return bitcount;\n@@ -892,1 +943,7 @@\n-    return proc_count;\n+    warning(\"Unexpected GetProcessGroupAffinity success result.\");\n+    assert(false, \"Unexpected GetProcessGroupAffinity success result\");\n+  }\n+\n+  \/\/ Fall back to SYSTEM_INFO.dwNumberOfProcessors if the process group affinity could not be determined.\n+  if (!got_process_group_affinity) {\n+    return si.dwNumberOfProcessors;\n@@ -894,0 +951,42 @@\n+\n+  \/\/ If the process it not in a job and the process group affinity is exactly 1 group\n+  \/\/ then get the number of available logical processors from the process affinity mask\n+  if (use_process_affinity_mask) {\n+    DWORD_PTR lpProcessAffinityMask = 0;\n+    DWORD_PTR lpSystemAffinityMask = 0;\n+    if (GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask) != 0) {\n+      \/\/ Number of active processors is number of bits in process affinity mask\n+      logical_processors = population_count(lpProcessAffinityMask);\n+\n+      if (logical_processors > 0) {\n+        return logical_processors;\n+      } else {\n+        \/\/ We only check the process affinity mask if GetProcessGroupAffinity determined that there was\n+        \/\/ only 1 active group. In this case, GetProcessAffinityMask will not set the affinity mask to 0.\n+        warning(\"Unexpected process affinity mask of 0 from GetProcessAffinityMask.\");\n+        assert(false, \"Found unexpected process affinity mask: 0\");\n+      }\n+    } else {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to get the process affinity mask failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    }\n+\n+    \/\/ Fall back to SYSTEM_INFO.dwNumberOfProcessors if the process affinity mask could not be determined.\n+    return si.dwNumberOfProcessors;\n+  }\n+\n+  if (UseAllWindowsProcessorGroups) {\n+    \/\/ There are no processor affinity restrictions at this point so we can return\n+    \/\/ the overall processor count if the OS automatically schedules threads across\n+    \/\/ all processors on the system. Note that older operating systems can\n+    \/\/ correctly report processor count but will not schedule threads across\n+    \/\/ processor groups unless the application explicitly uses group affinity APIs\n+    \/\/ to assign threads to processor groups. On these older operating systems, we\n+    \/\/ will continue to use the dwNumberOfProcessors field.\n+    if (schedules_all_processor_groups) {\n+      logical_processors = processor_count();\n+    }\n+  }\n+\n+  return logical_processors == 0 ? si.dwNumberOfProcessors : logical_processors;\n@@ -1767,4 +1866,0 @@\n-  VS_FIXEDFILEINFO *file_info;\n-  TCHAR kernel32_path[MAX_PATH];\n-  UINT len, ret;\n-\n@@ -1773,38 +1868,4 @@\n-  \/\/ Get the full path to \\Windows\\System32\\kernel32.dll and use that for\n-  \/\/ determining what version of Windows we're running on.\n-  len = MAX_PATH - (UINT)strlen(\"\\\\kernel32.dll\") - 1;\n-  ret = GetSystemDirectory(kernel32_path, len);\n-  if (ret == 0 || ret > len) {\n-    st->print_cr(\"Call to GetSystemDirectory failed\");\n-    return;\n-  }\n-  strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n-\n-  DWORD version_size = GetFileVersionInfoSize(kernel32_path, nullptr);\n-  if (version_size == 0) {\n-    st->print_cr(\"Call to GetFileVersionInfoSize failed\");\n-    return;\n-  }\n-\n-  LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);\n-  if (version_info == nullptr) {\n-    st->print_cr(\"Failed to allocate version_info\");\n-    return;\n-  }\n-\n-  if (!GetFileVersionInfo(kernel32_path, 0, version_size, version_info)) {\n-    os::free(version_info);\n-    st->print_cr(\"Call to GetFileVersionInfo failed\");\n-    return;\n-  }\n-\n-  if (!VerQueryValue(version_info, TEXT(\"\\\\\"), (LPVOID*)&file_info, &len)) {\n-    os::free(version_info);\n-    st->print_cr(\"Call to VerQueryValue failed\");\n-    return;\n-  }\n-\n-  int major_version = HIWORD(file_info->dwProductVersionMS);\n-  int minor_version = LOWORD(file_info->dwProductVersionMS);\n-  int build_number = HIWORD(file_info->dwProductVersionLS);\n-  int build_minor = LOWORD(file_info->dwProductVersionLS);\n+  int major_version = windows_major_version();\n+  int minor_version = windows_minor_version();\n+  int build_number = windows_build_number();\n+  int build_minor = windows_build_minor();\n@@ -1812,1 +1873,0 @@\n-  os::free(version_info);\n@@ -1861,1 +1921,4 @@\n-      if (build_number > 20347) {\n+      \/\/ - 2025 Preview build   : 26040\n+      if (build_number > 26039) {\n+        st->print(\"Server 2025\");\n+      } else if (build_number > 20347) {\n@@ -1908,0 +1971,6 @@\n+\n+    \/\/ This is the number of logical processors in the current processor group only and is therefore\n+    \/\/ at most 64. The GetLogicalProcessorInformation function is used to compute the total number\n+    \/\/ of processors. However, it requires memory to be allocated for the processor information buffer.\n+    \/\/ Since this method is used in paths where memory allocation should not be done (i.e. after a crash),\n+    \/\/ only the number of processors in the current group will be returned.\n@@ -1937,1 +2006,1 @@\n-      st->print_cr(\"Processor Information for all %d processors :\", proc_count);\n+      st->print_cr(\"Processor Information for the first %d processors :\", proc_count);\n@@ -3357,1 +3426,2 @@\n-  assert(aligned_base != nullptr, \"Did not manage to re-map after %d attempts?\", max_attempts);\n+  assert(aligned_base != nullptr,\n+      \"Did not manage to re-map after %d attempts (size %zu, alignment %zu, file descriptor %d)\", max_attempts, size, alignment, file_desc);\n@@ -3979,0 +4049,194 @@\n+int    os::win32::_major_version             = 0;\n+int    os::win32::_minor_version             = 0;\n+int    os::win32::_build_number              = 0;\n+int    os::win32::_build_minor               = 0;\n+\n+bool   os::win32::_processor_group_warning_displayed = false;\n+bool   os::win32::_job_object_processor_group_warning_displayed = false;\n+\n+void getWindowsInstallationType(char* buffer, int bufferSize) {\n+  HKEY hKey;\n+  const char* subKey = \"SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\";\n+  const char* valueName = \"InstallationType\";\n+\n+  DWORD valueLength = bufferSize;\n+\n+  \/\/ Initialize buffer with empty string\n+  buffer[0] = '\\0';\n+\n+  \/\/ Open the registry key\n+  if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, subKey, 0, KEY_READ, &hKey) != ERROR_SUCCESS) {\n+    \/\/ Return empty buffer if key cannot be opened\n+    return;\n+  }\n+\n+  \/\/ Query the value\n+  if (RegQueryValueExA(hKey, valueName, NULL, NULL, (LPBYTE)buffer, &valueLength) != ERROR_SUCCESS) {\n+    RegCloseKey(hKey);\n+    buffer[0] = '\\0';\n+    return;\n+  }\n+\n+  RegCloseKey(hKey);\n+}\n+\n+bool isNanoServer() {\n+  const int BUFFER_SIZE = 256;\n+  char installationType[BUFFER_SIZE];\n+  getWindowsInstallationType(installationType, BUFFER_SIZE);\n+  return (strcmp(installationType, \"Nano Server\") == 0);\n+}\n+\n+void os::win32::initialize_windows_version() {\n+  assert(_major_version == 0, \"windows version already initialized.\");\n+\n+  VS_FIXEDFILEINFO *file_info;\n+  TCHAR kernel32_path[MAX_PATH];\n+  UINT len, ret;\n+  char error_msg_buffer[512];\n+\n+  \/\/ Get the full path to \\Windows\\System32\\kernel32.dll and use that for\n+  \/\/ determining what version of Windows we're running on.\n+  len = MAX_PATH - (UINT)strlen(\"\\\\kernel32.dll\") - 1;\n+  ret = GetSystemDirectory(kernel32_path, len);\n+  if (ret == 0 || ret > len) {\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Attempt to determine system directory failed: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  if (isNanoServer()) {\n+    \/\/ On Windows Nanoserver the kernel32.dll is located in the forwarders subdirectory\n+    strncat(kernel32_path, \"\\\\forwarders\\\\kernel32.dll\", MAX_PATH - ret);\n+  } else {\n+    strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n+  }\n+\n+  DWORD version_size = GetFileVersionInfoSize(kernel32_path, nullptr);\n+  if (version_size == 0) {\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Failed to determine whether the OS can retrieve version information from kernel32.dll: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);\n+  if (version_info == nullptr) {\n+    warning(\"os::malloc() failed to allocate %ld bytes for GetFileVersionInfo buffer\", version_size);\n+    return;\n+  }\n+\n+  if (GetFileVersionInfo(kernel32_path, 0, version_size, version_info) == 0) {\n+    os::free(version_info);\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Attempt to retrieve version information from kernel32.dll failed: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  if (VerQueryValue(version_info, TEXT(\"\\\\\"), (LPVOID*)&file_info, &len) == 0) {\n+    os::free(version_info);\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Attempt to determine Windows version from kernel32.dll failed: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  _major_version = HIWORD(file_info->dwProductVersionMS);\n+  _minor_version = LOWORD(file_info->dwProductVersionMS);\n+  _build_number  = HIWORD(file_info->dwProductVersionLS);\n+  _build_minor   = LOWORD(file_info->dwProductVersionLS);\n+\n+  os::free(version_info);\n+}\n+\n+bool os::win32::is_windows_11_or_greater() {\n+  if (IsWindowsServer()) {\n+    return false;\n+  }\n+\n+  \/\/ Windows 11 starts at build 22000 (Version 21H2)\n+  return (windows_major_version() == 10 && windows_build_number() >= 22000) || (windows_major_version() > 10);\n+}\n+\n+bool os::win32::is_windows_server_2022_or_greater() {\n+  if (!IsWindowsServer()) {\n+    return false;\n+  }\n+\n+  \/\/ Windows Server 2022 starts at build 20348.169\n+  return (windows_major_version() == 10 && windows_build_number() >= 20348) || (windows_major_version() > 10);\n+}\n+\n+DWORD os::win32::active_processors_in_job_object(DWORD* active_processor_groups) {\n+  if (active_processor_groups != nullptr) {\n+    *active_processor_groups = 0;\n+  }\n+  BOOL is_in_job_object = false;\n+  if (IsProcessInJob(GetCurrentProcess(), nullptr, &is_in_job_object) == 0) {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to determine whether the process is running in a job failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    return 0;\n+  }\n+\n+  if (!is_in_job_object) {\n+    return 0;\n+  }\n+\n+  DWORD processors = 0;\n+\n+  LPVOID job_object_information = nullptr;\n+  DWORD job_object_information_length = 0;\n+\n+  if (QueryInformationJobObject(nullptr, JobObjectGroupInformationEx, nullptr, 0, &job_object_information_length) != 0) {\n+    warning(\"Unexpected QueryInformationJobObject success result.\");\n+    assert(false, \"Unexpected QueryInformationJobObject success result\");\n+    return 0;\n+  }\n+\n+  DWORD last_error = GetLastError();\n+  if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+    DWORD group_count = job_object_information_length \/ sizeof(GROUP_AFFINITY);\n+\n+    job_object_information = os::malloc(job_object_information_length, mtInternal);\n+    if (job_object_information != nullptr) {\n+        if (QueryInformationJobObject(nullptr, JobObjectGroupInformationEx, job_object_information, job_object_information_length, &job_object_information_length) != 0) {\n+          DWORD groups_found = job_object_information_length \/ sizeof(GROUP_AFFINITY);\n+          if (groups_found != group_count) {\n+            warning(\"Unexpected processor group count: %ld. Expected %ld processor groups.\", groups_found, group_count);\n+            assert(false, \"Unexpected group count\");\n+          }\n+\n+          GROUP_AFFINITY* group_affinity_data = ((GROUP_AFFINITY*)job_object_information);\n+          for (DWORD i = 0; i < groups_found; i++, group_affinity_data++) {\n+            DWORD processors_in_group = population_count(group_affinity_data->Mask);\n+            processors += processors_in_group;\n+            if (active_processor_groups != nullptr && processors_in_group > 0) {\n+              (*active_processor_groups)++;\n+            }\n+          }\n+\n+          if (processors == 0) {\n+            warning(\"Could not determine processor count from the job object.\");\n+            assert(false, \"Must find at least 1 logical processor\");\n+          }\n+        } else {\n+          char buf[512];\n+          size_t buf_len = os::lasterror(buf, sizeof(buf));\n+          warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+        }\n+\n+        os::free(job_object_information);\n+    } else {\n+        warning(\"os::malloc() failed to allocate %ld bytes for QueryInformationJobObject\", job_object_information_length);\n+    }\n+  } else {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    assert(false, \"Unexpected QueryInformationJobObject error code\");\n+    return 0;\n+  }\n+\n+  log_debug(os)(\"Process is running in a job with %d active processors.\", processors);\n+  return processors;\n+}\n+\n@@ -3986,1 +4250,14 @@\n-  set_processor_count(si.dwNumberOfProcessors);\n+\n+  DWORD processors = 0;\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  if (schedules_all_processor_groups) {\n+    processors = GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n+    if (processors == 0) {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to determine the processor count from GetActiveProcessorCount() failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+      assert(false, \"Must find at least 1 logical processor\");\n+    }\n+  }\n+\n+  set_processor_count(processors > 0 ? processors : si.dwNumberOfProcessors);\n@@ -4295,0 +4572,1 @@\n+  win32::initialize_windows_version();\n@@ -4341,0 +4619,6 @@\n+  const char* auto_schedules_message = \"Host Windows OS automatically schedules threads across all processor groups.\";\n+  const char* no_auto_schedules_message = \"Host Windows OS does not automatically schedule threads across all processor groups.\";\n+\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  log_debug(os)(schedules_all_processor_groups ? auto_schedules_message : no_auto_schedules_message);\n+  log_debug(os)(\"%d logical processors found.\", processor_count());\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":343,"deletions":59,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -46,0 +46,7 @@\n+  static bool   _processor_group_warning_displayed;\n+  static bool   _job_object_processor_group_warning_displayed;\n+\n+  static int    _major_version;\n+  static int    _minor_version;\n+  static int    _build_number;\n+  static int    _build_minor;\n@@ -59,0 +66,31 @@\n+  static bool   is_windows_11_or_greater();\n+  static bool   is_windows_server_2022_or_greater();\n+  static int windows_major_version() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _major_version;\n+  }\n+  static int windows_minor_version() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _minor_version;\n+  }\n+  static int windows_build_number() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _build_number;\n+  }\n+  static int windows_build_minor() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _build_minor;\n+  }\n+\n+  static void set_processor_group_warning_displayed(bool displayed)  {\n+    _processor_group_warning_displayed = displayed;\n+  }\n+  static bool processor_group_warning_displayed() {\n+    return _processor_group_warning_displayed;\n+  }\n+  static void set_job_object_processor_group_warning_displayed(bool displayed)  {\n+    _job_object_processor_group_warning_displayed = displayed;\n+  }\n+  static bool job_object_processor_group_warning_displayed() {\n+    return _job_object_processor_group_warning_displayed;\n+  }\n@@ -82,0 +120,2 @@\n+  static void initialize_windows_version();\n+  static DWORD active_processors_in_job_object(DWORD* active_processor_groups = nullptr);\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1391,0 +1391,5 @@\n+  if (next_bci() >= method()->code_size()) {\n+    \/\/ This can happen if the subroutine does not terminate with a ret,\n+    \/\/ effectively turning the jsr into a goto.\n+    BAILOUT(\"too-complicated jsr\/ret structure\");\n+  }\n@@ -3719,0 +3724,3 @@\n+  if (next_bci() >= method()->code_size()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,0 +278,2 @@\n+  \/* The compiler assumes, in many places, that methods are at most 1MB. *\/ \\\n+  \/* Therefore, we restrict this flag to at most 1MB.                    *\/ \\\n@@ -280,1 +282,1 @@\n-          range(0, max_jint)                                                \\\n+          range(0, 1*M)                                                     \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,5 +95,0 @@\n-  ADD_EXCL(\"java\/lang\/invoke\/InvokerBytecodeGenerator\",  \"DONTINLINE_SIG\",         \/\/ B\n-                                                         \"FORCEINLINE_SIG\",        \/\/ B\n-                                                         \"HIDDEN_SIG\",             \/\/ B\n-                                                         \"INJECTEDPROFILE_SIG\",    \/\/ B\n-                                                         \"LF_COMPILED_SIG\");       \/\/ B\n@@ -109,4 +104,0 @@\n-  ADD_EXCL(\"java\/lang\/VersionProps\",                     \"VENDOR_URL_BUG\",         \/\/ C\n-                                                         \"VENDOR_URL_VM_BUG\",      \/\/ C\n-                                                         \"VENDOR_VERSION\");        \/\/ C\n-  ADD_EXCL(\"java\/net\/URL$DefaultFactory\",                \"PREFIX\");                \/\/ B FIXME: JDK-8276561\n@@ -121,1 +112,0 @@\n-  ADD_EXCL(\"jdk\/internal\/loader\/URLClassPath\",           \"JAVA_VERSION\");          \/\/ B\n@@ -131,18 +121,0 @@\n-  ADD_EXCL(\"jdk\/internal\/util\/StaticProperty\",           \"FILE_ENCODING\",          \/\/ C\n-                                                 \"JAVA_LOCALE_USE_OLD_ISO_CODES\",  \/\/ C\n-                                                 \"USER_LANGUAGE\",                  \/\/ C\n-                                                 \"USER_LANGUAGE_DISPLAY\",          \/\/ C\n-                                                 \"USER_LANGUAGE_FORMAT\",           \/\/ C\n-                                                 \"USER_SCRIPT\",                    \/\/ C\n-                                                 \"USER_SCRIPT_DISPLAY\",            \/\/ C\n-                                                 \"USER_SCRIPT_FORMAT\",             \/\/ C\n-                                                 \"USER_COUNTRY\",                   \/\/ C\n-                                                 \"USER_COUNTRY_DISPLAY\",           \/\/ C\n-                                                 \"USER_COUNTRY_FORMAT\",            \/\/ C\n-                                                 \"USER_VARIANT\",                   \/\/ C\n-                                                 \"USER_VARIANT_DISPLAY\",           \/\/ C\n-                                                 \"USER_VARIANT_FORMAT\",            \/\/ C\n-                                                 \"USER_EXTENSIONS\",                \/\/ C\n-                                                 \"USER_EXTENSIONS_DISPLAY\",        \/\/ C\n-                                                 \"USER_EXTENSIONS_FORMAT\",         \/\/ C\n-                                                 \"USER_REGION\");                   \/\/ C\n@@ -153,2 +125,0 @@\n-  ADD_EXCL(\"sun\/security\/util\/SecurityConstants\",        \"PROVIDER_VER\");          \/\/ C\n-\n@@ -248,0 +218,6 @@\n+    if (value.orig_referrer() == nullptr && java_lang_String::is_instance(orig_obj)) {\n+      \/\/ This string object is not referenced by any of the archived object graphs. It's archived\n+      \/\/ only because it's in the interned string table. So we are not in a condition that\n+      \/\/ should be flagged by CDSHeapVerifier.\n+      return true; \/* keep on iterating *\/\n+    }\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":6,"deletions":30,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1677,1 +1677,4 @@\n-  dump_compile_data(out);\n+\n+  if (this->task() != nullptr) {\n+    dump_compile_data(out);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,2 +83,1 @@\n-  void print_action_queue(outputStream* st) {\n-    SeenThread* seen = this;\n+  static void print_action_queue(SeenThread* seen, outputStream* st) {\n@@ -330,1 +329,1 @@\n-  loadInstanceThreadQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(loadInstanceThreadQ(), st);\n@@ -333,1 +332,1 @@\n-  superThreadQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(superThreadQ(), st);\n@@ -336,1 +335,1 @@\n-  defineThreadQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(defineThreadQ(), st);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -901,1 +901,1 @@\n-  _type       = (DepType)(end_marker-1);  \/\/ defeat \"already at end\" assert\n+  _type       = undefined_dependency;  \/\/ defeat \"already at end\" assert\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,3 @@\n+    \/\/ _type is initially set to -1, to prevent \"already at end\" assert\n+    undefined_dependency = -1,\n+\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,0 +225,3 @@\n+          if (bci + Bytecodes::length_for(code) >= method_len) {\n+            break;\n+          }\n@@ -235,0 +238,3 @@\n+          if (bci + Bytecodes::length_for(code) >= method_len) {\n+            break;\n+          }\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -833,1 +833,1 @@\n-      _code_roots_scanned = cl.count();\n+      _code_roots_scanned += cl.count();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -491,1 +491,2 @@\n-  const double current_old_gc_time_per_bytes_freed = double(old_gc_time) \/ double(reclaimed_per_old_gc);\n+  const double current_old_gc_time_per_bytes_freed = reclaimed_per_old_gc == 0 ? std::numeric_limits<double>::infinity()\n+                                                                               : (double(old_gc_time) \/ double(reclaimed_per_old_gc));\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,0 +82,9 @@\n+    if (!FLAG_IS_DEFAULT(EnableJVMCI) && !EnableJVMCI) {\n+      jio_fprintf(defaultStream::error_stream(),\n+          \"Improperly specified VM option UseJVMCICompiler: EnableJVMCI cannot be disabled\\n\");\n+      return false;\n+    }\n+    FLAG_SET_DEFAULT(EnableJVMCI, true);\n+  }\n+\n+  if (EnableJVMCI) {\n@@ -90,6 +99,3 @@\n-    if (!FLAG_IS_DEFAULT(EnableJVMCI) && !EnableJVMCI) {\n-      jio_fprintf(defaultStream::error_stream(),\n-          \"Improperly specified VM option UseJVMCICompiler: EnableJVMCI cannot be disabled\\n\");\n-      return false;\n-    }\n-    FLAG_SET_DEFAULT(EnableJVMCI, true);\n+  }\n+\n+  if (UseJVMCICompiler) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-          \"on the HotSpot heap. Defaults to true if EnableJVMCIProduct is \" \\\n+          \"on the HotSpot heap. Defaults to true if EnableJVMCI is \"        \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-LogSelection::LogSelection() : _ntags(0), _wildcard(false), _level(LogLevel::Invalid), _tag_sets_selected(0) {\n+LogSelection::LogSelection() : _ntags(0), _tags(), _wildcard(false), _level(LogLevel::Invalid), _tag_sets_selected(0) {\n@@ -40,1 +40,1 @@\n-    : _ntags(0), _wildcard(wildcard), _level(level), _tag_sets_selected(0) {\n+  : _ntags(0), _tags(), _wildcard(wildcard), _level(level), _tag_sets_selected(0) {\n","filename":"src\/hotspot\/share\/logging\/logSelection.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,3 +439,0 @@\n-        assert(!fellThrough, \"should not happen\");\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n-        break;\n@@ -444,1 +441,4 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        \/\/ If this is the last bytecode, there is no successor to mark\n+        if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+          bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        }\n@@ -505,1 +505,4 @@\n-            reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            \/\/ If this is the last bytecode, there is no successor to mark\n+            if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+              reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            }\n@@ -589,3 +592,0 @@\n-\n-\n-\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,1 +318,3 @@\n-      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ CompilationPolicy::min_invocations());\n+      \/\/ avoid division by 0, set divisor to at least 1\n+      int cp_min_inv = MAX2(1, CompilationPolicy::min_invocations());\n+      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ cp_min_inv);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3306,2 +3306,2 @@\n-      if ((is_oop   && Matcher::const_oop_prefer_decode()  ) ||\n-          (is_klass && Matcher::const_klass_prefer_decode())) {\n+      if ((is_oop   && UseCompressedOops          && Matcher::const_oop_prefer_decode()  ) ||\n+          (is_klass && UseCompressedClassPointers && Matcher::const_klass_prefer_decode())) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1893,1 +1893,2 @@\n-  \/\/         final_correction = canonicalized_correction + limit_correction\n+  \/\/         (v) final_correction = canonicalized_correction + limit_correction\n+  \/\/\n@@ -1899,0 +1900,15 @@\n+  \/\/     However, we need to be careful that (v) does not over- or underflow.\n+  \/\/     We know that:\n+  \/\/         canonicalized_correction = stride - 1\n+  \/\/     and\n+  \/\/         limit_correction <= stride + 1\n+  \/\/     and thus\n+  \/\/         canonicalized_correction + limit_correction <= 2 * stride\n+  \/\/     To prevent an over- or underflow of (v), we must ensure that\n+  \/\/         2 * stride <= max_int\n+  \/\/     which can safely be checked without over- or underflow with\n+  \/\/         (vi) stride != min_int AND abs(stride) <= max_int \/ 2\n+  \/\/\n+  \/\/     We could try to further optimize the cases where (vi) does not hold but given that such large strides are\n+  \/\/     very uncommon and the loop would only run for a very few iterations anyway, we simply bail out if (vi) fails.\n+  \/\/\n@@ -1929,0 +1945,4 @@\n+  \/\/ Check (vi) and bail out if the stride is too big.\n+  if (stride_con == min_signed_integer(iv_bt) || (ABS(stride_con) > max_signed_integer(iv_bt) \/ 2)) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3337,1 +3337,3 @@\n-\n+  \/\/ As for the GetFieldDeclaringClass method, the XSL generated C++ code that calls it has\n+  \/\/ a jclass of the relevant class or a subclass of it, which is fine in terms of ensuring\n+  \/\/ the holder is kept alive.\n@@ -3415,1 +3417,3 @@\n-  (*declaring_class_ptr) = get_jni_class_non_null(method->method_holder());\n+  Klass* k = method->method_holder();\n+  Handle holder(Thread::current(), k->klass_holder()); \/\/ keep the klass alive\n+  (*declaring_class_ptr) = get_jni_class_non_null(k);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -601,0 +601,1 @@\n+  assert(k->is_loader_alive(), \"Must be alive\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -932,3 +932,2 @@\n-    if (_thread->is_in_any_VTMS_transition()) {\n-      return; \/\/ no events should be posted if thread is in any VTMS transition\n-    }\n+    assert(!_thread->is_in_any_VTMS_transition(), \"CFLH events are not allowed in any VTMS transition\");\n+\n@@ -1091,2 +1090,3 @@\n-  if (JavaThread::current()->is_in_tmp_VTMS_transition()) {\n-    return false; \/\/ skip CFLH events in tmp VTMS transition\n+\n+  if (JavaThread::current()->is_in_any_VTMS_transition()) {\n+    return false; \/\/ no events should be posted if thread is in any VTMS transition\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"sanitizers\/ub.hpp\"\n@@ -341,0 +342,1 @@\n+  ATTRIBUTE_NO_UBSAN\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -441,0 +441,1 @@\n+        ResourceMark rm(THREAD);\n@@ -449,0 +450,1 @@\n+      ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,7 +100,12 @@\n-    \/\/ Get buffer size needed to read all processes\n-    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};\n-    if (sysctl(mib, 4, NULL, &bufSize, NULL, 0) < 0) {\n-        JNU_ThrowByNameWithLastError(env,\n-            \"java\/lang\/RuntimeException\", \"sysctl failed\");\n-        return -1;\n-    }\n+    int errsysctl;\n+    int maxRetries = 100;\n+    void *buffer = NULL;\n+    do {\n+        int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};\n+        if (buffer != NULL) free(buffer);\n+        \/\/ Get buffer size needed to read all processes\n+        if (sysctl(mib, 4, NULL, &bufSize, NULL, 0) < 0) {\n+            JNU_ThrowByNameWithMessageAndLastError(env,\n+                \"java\/lang\/RuntimeException\", \"sysctl failed\");\n+            return -1;\n+        }\n@@ -108,6 +113,12 @@\n-    \/\/ Allocate buffer big enough for all processes\n-    void *buffer = malloc(bufSize);\n-    if (buffer == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"malloc failed\");\n-        return -1;\n-    }\n+        \/\/ Allocate buffer big enough for all processes; add a little\n+        \/\/ bit of space to be able to hold a few more proc infos\n+        \/\/ for processes started right after the first sysctl call\n+        buffer = malloc(bufSize + 4 * sizeof(struct kinfo_proc));\n+        if (buffer == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, \"malloc failed\");\n+            return -1;\n+        }\n+\n+        \/\/ Read process info for all processes\n+        errsysctl = sysctl(mib, 4, buffer, &bufSize, NULL, 0);\n+    } while (errsysctl < 0 && errno == ENOMEM && maxRetries-- > 0);\n@@ -115,4 +126,3 @@\n-    \/\/ Read process info for all processes\n-    if (sysctl(mib, 4, buffer, &bufSize, NULL, 0) < 0) {\n-        JNU_ThrowByNameWithLastError(env,\n-            \"java\/lang\/RuntimeException\", \"sysctl failed\");\n+    if (errsysctl < 0) {\n+        JNU_ThrowByNameWithMessageAndLastError(env,\n+            \"java\/lang\/RuntimeException\", \"sysctl failed to get info about all processes\");\n","filename":"src\/java.base\/macosx\/native\/libjava\/ProcessHandleImpl_macosx.c","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n@@ -49,7 +47,0 @@\n-    static ClassValue<ConcurrentMap<Integer, MethodHandle>> ADDRESS_FACTORIES = new ClassValue<>() {\n-        @Override\n-        protected ConcurrentMap<Integer, MethodHandle> computeValue(Class<?> type) {\n-            return new ConcurrentHashMap<>();\n-        }\n-    };\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+import sun.nio.fs.AbstractFileSystemProvider;\n@@ -2607,1 +2608,5 @@\n-        return isAccessible(path, AccessMode.READ);\n+        FileSystemProvider provider = provider(path);\n+        if (provider instanceof AbstractFileSystemProvider afsp)\n+            return afsp.isReadable(path);\n+        else\n+            return isAccessible(path, AccessMode.READ);\n@@ -2638,1 +2643,5 @@\n-        return isAccessible(path, AccessMode.WRITE);\n+        FileSystemProvider provider = provider(path);\n+        if (provider instanceof AbstractFileSystemProvider afsp)\n+            return afsp.isWritable(path);\n+        else\n+            return isAccessible(path, AccessMode.WRITE);\n@@ -2673,1 +2682,5 @@\n-        return isAccessible(path, AccessMode.EXECUTE);\n+        FileSystemProvider provider = provider(path);\n+        if (provider instanceof AbstractFileSystemProvider afsp)\n+            return afsp.isExecutable(path);\n+        else\n+            return isAccessible(path, AccessMode.EXECUTE);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1932,4 +1932,4 @@\n-            debug.println(\"X509CertSelector.match(SN: \"\n-                + (xcert.getSerialNumber()).toString(16) + \"\\n  Issuer: \"\n-                + xcert.getIssuerX500Principal() + \"\\n  Subject: \" + xcert.getSubjectX500Principal()\n-                + \")\");\n+            debug.println(\"X509CertSelector.match(Serial number: \"\n+                + Debug.toString(xcert.getSerialNumber())\n+                + \"\\n  Issuer: \" + xcert.getIssuerX500Principal() + \"\\n  Subject: \"\n+                + xcert.getSubjectX500Principal() + \")\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/X509CertSelector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1930,0 +1930,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -656,0 +656,3 @@\n+        \/\/ wait for any accept operation to complete before trying to close\n+        acceptLock.lock();\n+        acceptLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1130,0 +1130,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.nio.file.Path;\n+import java.nio.file.AccessMode;\n@@ -30,0 +30,1 @@\n+import java.nio.file.Path;\n@@ -118,0 +119,36 @@\n+\n+    \/**\n+     * Tests whether a file is readable.\n+     *\/\n+    public boolean isReadable(Path path) {\n+        try {\n+            checkAccess(path, AccessMode.READ);\n+        } catch (IOException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Tests whether a file is writable.\n+     *\/\n+    public boolean isWritable(Path path) {\n+        try {\n+            checkAccess(path, AccessMode.WRITE);\n+        } catch (IOException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Tests whether a file is executable.\n+     *\/\n+    public boolean isExecutable(Path path) {\n+        try {\n+            checkAccess(path, AccessMode.EXECUTE);\n+        } catch (IOException e) {\n+            return false;\n+        }\n+        return true;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractFileSystemProvider.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import sun.security.util.Debug;\n@@ -107,1 +108,1 @@\n-            String serNum = x509.getSerialNumber().toString(16);\n+            String serNum = Debug.toString(x509.getSerialNumber());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/JCAUtil.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -681,2 +681,2 @@\n-                token.getSerialNumber() + \") generated on \" + token.getDate() +\n-                \" is inapplicable\");\n+                Debug.toString(token.getSerialNumber()) +\n+                \") generated on \" + token.getDate() + \" is inapplicable\");\n@@ -688,1 +688,2 @@\n-                token.getSerialNumber() + \") generated on \" + token.getDate());\n+                Debug.toString(token.getSerialNumber()) +\n+                \") generated on \" + token.getDate());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,9 @@\n-        System.arraycopy(state, 0, out, ofs, engineGetDigestLength());\n+        int availableBytes = buffer.length;\n+        int numBytes = engineGetDigestLength();\n+        while (numBytes > availableBytes) {\n+            System.arraycopy(state, 0, out, ofs, availableBytes);\n+            numBytes -= availableBytes;\n+            ofs += availableBytes;\n+            keccak();\n+        }\n+        System.arraycopy(state, 0, out, ofs, numBytes);\n@@ -165,1 +173,1 @@\n-     * rate r = 1600 and capacity c = (digest length x 2).\n+     * rate r = 1600 and capacity c.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -247,1 +247,1 @@\n-                currCert.getSerialNumber().toString());\n+                Debug.toString(currCert.getSerialNumber()));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/BasicChecker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -432,2 +432,1 @@\n-                        \"\\n  SN: \" + Debug.toHexString(\n-                                            targetCert.getSerialNumber()) +\n+                        \"\\n  SN: \" + Debug.toString(targetCert.getSerialNumber()) +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/Builder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-            System.out.println(\"SerialNumber is \" + serialNumber.getNumber());\n+            System.out.println(\"SerialNumber is \" + Debug.toString(serialNumber.getNumber()));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/CertId.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -317,1 +317,1 @@\n-                \"\\n  SN: \" + Debug.toHexString(certImpl.getSerialNumber()) +\n+                \"\\n  SN: \" + Debug.toString(certImpl.getSerialNumber()) +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/DistributionPointFetcher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-                            Debug.toHexString(trustedCert.getSerialNumber()) +\n+                            Debug.toString(trustedCert.getSerialNumber()) +\n@@ -701,1 +701,1 @@\n-                + Debug.toHexString(cert.getSerialNumber())\n+                + Debug.toString(cert.getSerialNumber())\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/ForwardBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -408,1 +408,2 @@\n-                    certId.getSerialNumber() + \") is: \" + sr.getCertStatus());\n+                    Debug.toString(certId.getSerialNumber()) +\n+                    \") is: \" + sr.getCertStatus());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSPResponse.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-                \"\\n  SN: \" + Debug.toHexString(xcert.getSerialNumber()) +\n+                \"\\n  SN: \" + Debug.toString(xcert.getSerialNumber()) +\n@@ -645,1 +645,1 @@\n-                          \" cert SN: \" + sn.toString());\n+                          \" cert SN: \" + Debug.toString(sn));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/RevocationChecker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,1 +152,1 @@\n-                (x509Cert.getSerialNumber().toString(16)).append(\"\\n\");\n+                (Debug.toString(x509Cert.getSerialNumber())).append(\"\\n\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/Vertex.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import sun.security.util.Debug;\n@@ -488,2 +489,1 @@\n-                        Utilities.toHexString(\n-                                x509.getSerialNumber().toByteArray()),\n+                        Debug.toString(x509.getSerialNumber()),\n@@ -513,2 +513,1 @@\n-                        Utilities.toHexString(\n-                                x509.getSerialNumber().toByteArray()),\n+                        Debug.toString(x509.getSerialNumber()),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLLogger.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import sun.security.util.Debug;\n@@ -406,2 +407,2 @@\n-                    \"Check cache for SN\" + cid.getSerialNumber() + \": \" +\n-                    (respEntry != null ? \"HIT\" : \"MISS\"));\n+                    \"Check cache for SN\" + Debug.toString(cid.getSerialNumber())\n+                        + \": \" + (respEntry != null ? \"HIT\" : \"MISS\"));\n@@ -502,1 +503,1 @@\n-                   \"\\n\\tSerial: \" + this.cert.getSerialNumber() +\n+                   \"\\n\\tSerial: \" + Debug.toString(this.cert.getSerialNumber()) +\n@@ -548,1 +549,1 @@\n-                            cid.getSerialNumber());\n+                            Debug.toString(cid.getSerialNumber()));\n@@ -599,1 +600,1 @@\n-                    statInfo.cid.getSerialNumber());\n+                    Debug.toString(statInfo.cid.getSerialNumber()));\n@@ -684,1 +685,1 @@\n-                        certId.getSerialNumber() +\n+                        Debug.toString(certId.getSerialNumber()) +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/StatusResponseManager.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,2 +431,11 @@\n-            checkIdentity(peerHost,\n-                    trustedChain[0], algorithm, chainsToPublicCA);\n+            try {\n+                checkIdentity(peerHost,\n+                        trustedChain[0], algorithm, chainsToPublicCA);\n+            } catch(CertificateException ce) {\n+                if (checkClientTrusted && \"HTTPS\".equalsIgnoreCase(algorithm)) {\n+                    throw new CertificateException(\"Endpoint Identification Algorithm \" +\n+                            \"HTTPS is not supported on the server side\");\n+                } else {\n+                    throw ce;\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509TrustManagerImpl.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1122,1 +1122,0 @@\n-        KeyStore cakstore = buildTrustedCerts();\n@@ -1131,0 +1130,1 @@\n+            KeyStore cakstore = buildTrustedCerts();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -408,0 +408,4 @@\n+    public static String toString(BigInteger b) {\n+        return toString(b.toByteArray());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.HexFormat;\n@@ -104,1 +105,1 @@\n-        return \"SerialNumber: [\" + Debug.toHexString(serialNum) + ']';\n+        return \"SerialNumber: \" + Debug.toString(serialNum);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/SerialNumber.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/b5bf572c52988dbe9d865b8f090ea819024a9936\/public_suffix_list.dat\n-Date: 2023-11-09\n+Github: https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/1cbd6e71a9b83620b1d0b11e49d3d9ff48c27e22\/public_suffix_list.dat\n+Date: 2024-05-07\n","filename":"src\/java.base\/share\/data\/publicsuffixlist\/VERSION","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6713,1 +6713,1 @@\n-\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2023-11-03T15:13:18Z\n+\/\/ List of new gTLDs imported from https:\/\/www.icann.org\/resources\/registries\/gtlds\/v2\/gtlds.json on 2024-05-04T15:12:50Z\n@@ -6899,1 +6899,1 @@\n-\/\/ aol : Oath Inc.\n+\/\/ aol : Yahoo Inc.\n@@ -6991,4 +6991,0 @@\n-\/\/ avianca : Avianca Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/avianca.html\n-avianca\n-\n@@ -7019,4 +7015,0 @@\n-\/\/ bananarepublic : The Gap, Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/bananarepublic.html\n-bananarepublic\n-\n@@ -7547,4 +7539,0 @@\n-\/\/ comcast : Comcast IP Holdings I, LLC\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/comcast.html\n-comcast\n-\n@@ -7755,0 +7743,4 @@\n+\/\/ desi\n+\/\/ https:\/\/www.iana.org\/domains\/root\/db\/desi.html\n+desi\n+\n@@ -7799,1 +7791,1 @@\n-\/\/ diy : Lifestyle Domain Holdings, Inc.\n+\/\/ diy : Internet Naming Company LLC\n@@ -7931,4 +7923,0 @@\n-\/\/ etisalat : Emirates Telecommunications Corporation (trading as Etisalat)\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/etisalat.html\n-etisalat\n-\n@@ -8107,1 +8095,1 @@\n-\/\/ food : Lifestyle Domain Holdings, Inc.\n+\/\/ food : Internet Naming Company LLC\n@@ -8167,1 +8155,1 @@\n-\/\/ fun : Radix FZC DMCC\n+\/\/ fun : Radix Technologies Inc.\n@@ -8315,1 +8303,1 @@\n-\/\/ goo : NTT Resonant Inc.\n+\/\/ goo : NTT DOCOMO, INC.\n@@ -8367,4 +8355,0 @@\n-\/\/ guardian : The Guardian Life Insurance Company of America\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/guardian.html\n-guardian\n-\n@@ -8503,1 +8487,1 @@\n-\/\/ host : Radix FZC DMCC\n+\/\/ host : Radix Technologies Inc.\n@@ -8723,1 +8707,1 @@\n-\/\/ juegos : Internet Naming Company LLC\n+\/\/ juegos : Dog Beach, LLC\n@@ -8911,1 +8895,1 @@\n-\/\/ lifestyle : Lifestyle Domain Holdings, Inc.\n+\/\/ lifestyle : Internet Naming Company LLC\n@@ -8951,1 +8935,1 @@\n-\/\/ living : Lifestyle Domain Holdings, Inc.\n+\/\/ living : Internet Naming Company LLC\n@@ -9395,4 +9379,0 @@\n-\/\/ oldnavy : The Gap, Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/oldnavy.html\n-oldnavy\n-\n@@ -9419,1 +9399,1 @@\n-\/\/ online : Radix FZC DMCC\n+\/\/ online : Radix Technologies Inc.\n@@ -9623,1 +9603,1 @@\n-\/\/ press : Radix FZC DMCC\n+\/\/ press : Radix Technologies Inc.\n@@ -9931,4 +9911,0 @@\n-\/\/ sca : SVENSKA CELLULOSA AKTIEBOLAGET SCA (publ)\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/sca.html\n-sca\n-\n@@ -10079,1 +10055,1 @@\n-\/\/ site : Radix FZC DMCC\n+\/\/ site : Radix Technologies Inc.\n@@ -10159,1 +10135,1 @@\n-\/\/ space : Radix FZC DMCC\n+\/\/ space : Radix Technologies Inc.\n@@ -10211,1 +10187,1 @@\n-\/\/ store : Radix FZC DMCC\n+\/\/ store : Radix Technologies Inc.\n@@ -10327,1 +10303,1 @@\n-\/\/ tech : Radix FZC DMCC\n+\/\/ tech : Radix Technologies Inc.\n@@ -10511,1 +10487,1 @@\n-\/\/ uno : Radix FZC DMCC\n+\/\/ uno : Radix Technologies Inc.\n@@ -10527,1 +10503,1 @@\n-\/\/ vana : Lifestyle Domain Holdings, Inc.\n+\/\/ vana : Internet Naming Company LLC\n@@ -10611,4 +10587,0 @@\n-\/\/ volkswagen : Volkswagen Group of America Inc.\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/volkswagen.html\n-volkswagen\n-\n@@ -10679,1 +10651,1 @@\n-\/\/ website : Radix FZC DMCC\n+\/\/ website : Radix Technologies Inc.\n@@ -10683,0 +10655,4 @@\n+\/\/ wed\n+\/\/ https:\/\/www.iana.org\/domains\/root\/db\/wed.html\n+wed\n+\n@@ -10771,4 +10747,0 @@\n-\/\/ xfinity : Comcast IP Holdings I, LLC\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/xfinity.html\n-xfinity\n-\n@@ -11015,4 +10987,0 @@\n-\/\/ xn--mgbaakc7dvf : Emirates Telecommunications Corporation (trading as Etisalat)\n-\/\/ https:\/\/www.iana.org\/domains\/root\/db\/xn--mgbaakc7dvf.html\n-اتصالات\n-\n@@ -11155,1 +11123,1 @@\n-\/\/ yahoo : Oath Inc.\n+\/\/ yahoo : Yahoo Inc.\n@@ -11220,0 +11188,6 @@\n+\/\/ 12CHARS: https:\/\/12chars.com\n+\/\/ Submitted by Kenny Niehage <psl@12chars.com>\n+12chars.dev\n+12chars.it\n+12chars.pro\n+\n@@ -11229,0 +11203,9 @@\n+\/\/ AAA workspace : https:\/\/aaa.vodka\n+\/\/ Submitted by Kirill Rezraf <admin@aaa.vodka>\n+aaa.vodka\n+\n+\/\/ A2 Hosting\n+\/\/ Submitted by Tyler Hall <sysadmin@a2hosting.com>\n+a2hosted.com\n+cpserver.com\n+\n@@ -11245,0 +11228,4 @@\n+\/\/ Adaptable.io : https:\/\/adaptable.io\n+\/\/ Submitted by Mark Terrel <support@adaptable.io>\n+adaptable.app\n+\n@@ -11249,0 +11236,1 @@\n+aem.live\n@@ -11251,0 +11239,1 @@\n+aem.page\n@@ -11322,1 +11311,1 @@\n-\/\/ Reference: 4d863337-ff98-4501-a6f2-361eba8445d6\n+\/\/ Reference: 9e37648f-a66c-4655-9ab1-5981f8737197\n@@ -11337,0 +11326,1 @@\n+execute-api.ca-west-1.amazonaws.com\n@@ -11363,1 +11353,1 @@\n-\/\/ Reference: 7bee1013-f456-47df-bfe8-03c78d946d61\n+\/\/ Reference: 09588633-91fe-49d8-b4e7-ec36496d11f3\n@@ -11369,0 +11359,1 @@\n+auth.ap-south-2.amazoncognito.com\n@@ -11372,0 +11363,1 @@\n+auth.ap-southeast-4.amazoncognito.com\n@@ -11374,0 +11366,1 @@\n+auth.eu-central-2.amazoncognito.com\n@@ -11376,0 +11369,1 @@\n+auth.eu-south-2.amazoncognito.com\n@@ -11380,0 +11374,1 @@\n+auth.me-central-1.amazoncognito.com\n@@ -11402,1 +11397,1 @@\n-\/\/ Reference: 597f3f8e-9283-4e48-8e32-7ee25a1ff6ab\n+\/\/ Reference: 82f43f9f-bbb8-400e-8349-854f5a62f20d\n@@ -11427,0 +11422,3 @@\n+emrappui-prod.ap-south-2.amazonaws.com\n+emrnotebooks-prod.ap-south-2.amazonaws.com\n+emrstudio-prod.ap-south-2.amazonaws.com\n@@ -11436,0 +11434,3 @@\n+emrappui-prod.ap-southeast-4.amazonaws.com\n+emrnotebooks-prod.ap-southeast-4.amazonaws.com\n+emrstudio-prod.ap-southeast-4.amazonaws.com\n@@ -11439,0 +11440,3 @@\n+emrappui-prod.ca-west-1.amazonaws.com\n+emrnotebooks-prod.ca-west-1.amazonaws.com\n+emrstudio-prod.ca-west-1.amazonaws.com\n@@ -11442,0 +11446,3 @@\n+emrappui-prod.eu-central-2.amazonaws.com\n+emrnotebooks-prod.eu-central-2.amazonaws.com\n+emrstudio-prod.eu-central-2.amazonaws.com\n@@ -11448,0 +11455,3 @@\n+emrappui-prod.eu-south-2.amazonaws.com\n+emrnotebooks-prod.eu-south-2.amazonaws.com\n+emrstudio-prod.eu-south-2.amazonaws.com\n@@ -11457,0 +11467,3 @@\n+emrappui-prod.il-central-1.amazonaws.com\n+emrnotebooks-prod.il-central-1.amazonaws.com\n+emrstudio-prod.il-central-1.amazonaws.com\n@@ -11487,1 +11500,1 @@\n-\/\/ Reference: 4ab55e6f-90c0-4a8d-b6a0-52ca5dbb1c2e\n+\/\/ Reference: 87f24ece-a77e-40e8-bb4a-f6b74fe9f975\n@@ -11490,0 +11503,2 @@\n+*.af-south-1.airflow.amazonaws.com\n+*.ap-east-1.airflow.amazonaws.com\n@@ -11498,0 +11513,1 @@\n+*.eu-south-1.airflow.amazonaws.com\n@@ -11501,0 +11517,1 @@\n+*.me-south-1.airflow.amazonaws.com\n@@ -11504,0 +11521,1 @@\n+*.us-west-1.airflow.amazonaws.com\n@@ -11508,1 +11526,1 @@\n-\/\/ Reference: 0e801048-08f2-4064-9cb8-e7373e0b57f4\n+\/\/ Reference: cd5c8b3a-67b7-4b40-9236-c87ce81a3d10\n@@ -11607,0 +11625,10 @@\n+s3.dualstack.ca-west-1.amazonaws.com\n+s3-accesspoint.dualstack.ca-west-1.amazonaws.com\n+s3-accesspoint-fips.dualstack.ca-west-1.amazonaws.com\n+s3-fips.dualstack.ca-west-1.amazonaws.com\n+s3-website.dualstack.ca-west-1.amazonaws.com\n+s3.ca-west-1.amazonaws.com\n+s3-accesspoint.ca-west-1.amazonaws.com\n+s3-accesspoint-fips.ca-west-1.amazonaws.com\n+s3-fips.ca-west-1.amazonaws.com\n+s3-website.ca-west-1.amazonaws.com\n@@ -11787,0 +11815,16 @@\n+\/\/ Amazon SageMaker Ground Truth\n+\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n+\/\/ Reference: 98dbfde4-7802-48c3-8751-b60f204e0d9c\n+labeling.ap-northeast-1.sagemaker.aws\n+labeling.ap-northeast-2.sagemaker.aws\n+labeling.ap-south-1.sagemaker.aws\n+labeling.ap-southeast-1.sagemaker.aws\n+labeling.ap-southeast-2.sagemaker.aws\n+labeling.ca-central-1.sagemaker.aws\n+labeling.eu-central-1.sagemaker.aws\n+labeling.eu-west-1.sagemaker.aws\n+labeling.eu-west-2.sagemaker.aws\n+labeling.us-east-1.sagemaker.aws\n+labeling.us-east-2.sagemaker.aws\n+labeling.us-west-2.sagemaker.aws\n+\n@@ -11789,1 +11833,1 @@\n-\/\/ Reference: fe8c9e94-5a22-486d-8750-991a3a9b13c6\n+\/\/ Reference: b5ea56df-669e-43cc-9537-14aa172f5dfc\n@@ -11802,0 +11846,3 @@\n+notebook-fips.ca-central-1.sagemaker.aws\n+notebook.ca-west-1.sagemaker.aws\n+notebook-fips.ca-west-1.sagemaker.aws\n@@ -11823,0 +11870,1 @@\n+notebook-fips.us-west-1.sagemaker.aws\n@@ -11830,1 +11878,1 @@\n-\/\/ Reference: 057ee397-6bf8-4f20-b807-d7bc145ac980\n+\/\/ Reference: 69c723d9-6e1a-4bff-a203-48eecd203183\n@@ -11844,0 +11892,1 @@\n+studio.eu-south-2.sagemaker.aws\n@@ -11888,1 +11937,1 @@\n-\/\/ Reference: 05c44955-977c-4b57-938a-f2af92733f9f\n+\/\/ Reference: 30717f72-4007-4f0f-8ed4-864c6f2efec9\n@@ -11934,0 +11983,2 @@\n+webview-assets.aws-cloud9.il-central-1.amazonaws.com\n+vfs.cloud9.il-central-1.amazonaws.com\n@@ -11953,0 +12004,5 @@\n+\/\/ AWS Directory Service\n+\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n+\/\/ Reference: a13203e8-42dc-4045-a0d2-2ee67bed1068\n+awsapps.com\n+\n@@ -11996,0 +12052,5 @@\n+\/\/ AWS re:Post Private\n+\/\/ Submitted by AWS Security <psl-maintainers@amazon.com>\n+\/\/ Reference: 83385945-225f-416e-9aa0-ad0632bfdcee\n+*.private.repost.aws\n+\n@@ -12013,0 +12074,4 @@\n+\/\/ Apis Networks: https:\/\/apisnetworks.com\n+\/\/ Submitted by Matt Saladna <matt@apisnetworks.com>\n+panel.dev\n+\n@@ -12030,0 +12095,4 @@\n+\/\/ Aquapal : https:\/\/aquapal.net\/\n+\/\/ Submitted by Aki Ueno <admin@aquapal.net>\n+f5.si\n+\n@@ -12065,0 +12134,1 @@\n+myfritz.link\n@@ -12124,0 +12194,4 @@\n+\/\/ Besties : https:\/\/besties.house\n+\/\/ Submitted by Hazel Cora <hazy@besties.house>\n+pages.gay\n+\n@@ -12128,0 +12202,4 @@\n+\/\/ University of Bielsko-Biala regional domain: http:\/\/dns.bielsko.pl\/\n+\/\/ Submitted by Marcin <dns@ath.bielsko.pl>\n+bielsko.pl\n+\n@@ -12169,0 +12247,4 @@\n+\/\/ Brave : https:\/\/brave.com\n+\/\/ Submitted by Andrea Brancaleoni <abrancaleoni@brave.com>\n+*.s.brave.io\n+\n@@ -12170,1 +12252,2 @@\n-\/\/ Submitted by Dusan Radovanovic <dusan.radovanovic@brendly.rs>\n+\/\/ Submitted by Dusan Radovanovic <administracija@brendly.rs>\n+shop.brendly.hr\n@@ -12194,0 +12277,1 @@\n+*.my.canvasite.cn\n@@ -12195,0 +12279,1 @@\n+*.my.canva.site\n@@ -12332,0 +12417,6 @@\n+\/\/ cloudscale.ch AG : https:\/\/www.cloudscale.ch\/\n+\/\/ Submitted by Gaudenz Steinlin <support@cloudscale.ch>\n+cust.cloudscale.ch\n+objects.lpg.cloudscale.ch\n+objects.rma.cloudscale.ch\n+\n@@ -12349,1 +12440,2 @@\n-c.cdn77.org\n+cdn77-storage.com\n+rsc.contentproxy9.cz\n@@ -12352,1 +12444,0 @@\n-rsc.cdn77.org\n@@ -12354,0 +12445,2 @@\n+c.cdn77.org\n+rsc.cdn77.org\n@@ -12356,1 +12449,1 @@\n-\/\/ Submitted by Aleksander Hristov <noc@cloudns.net>\n+\/\/ Submitted by Aleksander Hristov <noc@cloudns.net> & Boyan Peychev <boyan@cloudns.net>\n@@ -12358,0 +12451,1 @@\n+cloudns.be\n@@ -12359,1 +12453,0 @@\n-cloudns.club\n@@ -12361,0 +12454,5 @@\n+cloudns.ch\n+cloudns.cl\n+cloudns.club\n+dnsabr.com\n+cloudns.cx\n@@ -12364,0 +12462,3 @@\n+dns-cloud.net\n+dns-dynamic.net\n+cloudns.nz\n@@ -12365,0 +12466,1 @@\n+cloudns.ph\n@@ -12377,0 +12479,5 @@\n+\/\/ CodeSandbox B.V. : https:\/\/codesandbox.io\n+\/\/ Submitted by Ives van Hoorne <abuse@codesandbox.io>\n+csb.app\n+preview.csb.app\n+\n@@ -12386,0 +12493,4 @@\n+\/\/ Convex : https:\/\/convex.dev\/\n+\/\/ Submitted by James Cowling <security@convex.dev>\n+convex.site\n+\n@@ -12407,0 +12518,4 @@\n+\/\/ cPanel L.L.C. : https:\/\/www.cpanel.net\/\n+\/\/ Submitted by Dustin Scherer <public.suffix@cpanel.net>\n+*.cprapid.com\n+\n@@ -12411,0 +12526,4 @@\n+\/\/ Crisp IM SAS : https:\/\/crisp.chat\/\n+\/\/ Submitted by Baptiste Jamin <hostmaster@crisp.chat>\n+on.crisp.email\n+\n@@ -12431,0 +12550,7 @@\n+\/\/ Cyclic Software : https:\/\/www.cyclic.sh\n+\/\/ Submitted by Kam Lasater <dns-admin@cyclic.sh>\n+cyclic.app\n+cyclic.cloud\n+cyclic-app.com\n+cyclic.co.in\n+\n@@ -12476,0 +12602,1 @@\n+darklang.io\n@@ -12874,0 +13001,4 @@\n+\/\/ DigitalPlat : https:\/\/www.digitalplat.org\/\n+\/\/ Submitted by Edward Hsing <contact@digitalplat.org>\n+us.kg\n+\n@@ -12911,0 +13042,12 @@\n+\/\/ EasyWP : https:\/\/www.easywp.com\n+\/\/ Submitted by <infracloudteam@namecheap.com>\n+*.ewp.live\n+\n+\/\/ Electromagnetic Field : https:\/\/www.emfcamp.org\n+\/\/ Submitted by <noc@emfcamp.org>\n+at.emf.camp\n+\n+\/\/ Elefunc, Inc. : https:\/\/elefunc.com\n+\/\/ Submitted by Cetin Sert <domains@elefunc.com>\n+rt.ht\n+\n@@ -13025,4 +13168,0 @@\n-\/\/ Facebook, Inc.\n-\/\/ Submitted by Peter Ruibal <public-suffix@fb.com>\n-apps.fbsbx.com\n-\n@@ -13186,0 +13325,4 @@\n+\/\/ FlutterFlow : https:\/\/flutterflow.io\n+\/\/ Submitted by Anton Emelyanov <anton@flutterflow.io>\n+flutterflow.app\n+\n@@ -13196,1 +13339,1 @@\n-\/\/ Forgerock : https:\/\/www.forgerock.com\n+\/\/ Forgerock : https:\/\/www.forgerock.com\n@@ -13202,1 +13345,2 @@\n-\/\/ Submitted by Koen Rouwhorst <koenrh@framer.com>\n+\/\/ Submitted by Koen Rouwhorst <security@framer.com>\n+framer.ai\n@@ -13243,0 +13387,18 @@\n+\/\/ Future Versatile Group. ：https:\/\/www.fvg-on.net\/\n+\/\/ T.Kabu <webmaster@fvg-on.net>\n+daemon.asia\n+dix.asia\n+mydns.bz\n+0am.jp\n+0g0.jp\n+0j0.jp\n+0t0.jp\n+mydns.jp\n+pgw.jp\n+wjg.jp\n+keyword-on.net\n+live-on.net\n+server-on.net\n+mydns.tw\n+mydns.vc\n+\n@@ -13254,0 +13416,4 @@\n+\/\/ GCom Internet : https:\/\/www.gcom.net.au\n+\/\/ Submitted by Leo Julius <support@gcom.net.au>\n+aliases121.com\n+\n@@ -13282,3 +13448,5 @@\n-\/\/ Ghost Foundation : https:\/\/ghost.org\n-\/\/ Submitted by Matt Hanley <security@ghost.org>\n-ghost.io\n+\/\/ Getlocalcert: https:\/\/www.getlocalcert.net\n+\/\/ Submitted by Robert Alexander <support@getlocalcert.net>\n+localcert.net\n+localhostcert.net\n+corpnet.work\n@@ -13428,0 +13596,4 @@\n+\/\/ GoDaddy Registry : https:\/\/registry.godaddy\n+\/\/ Submitted by Rohan Durrant <tldns@registry.godaddy>\n+graphic.design\n+\n@@ -13437,4 +13609,0 @@\n-\/\/ UKHomeOffice : https:\/\/www.gov.uk\/government\/organisations\/home-office\n-\/\/ Submitted by Jon Shanks <jon.shanks@digital.homeoffice.gov.uk>\n-homeoffice.gov.uk\n-\n@@ -13451,2 +13619,1 @@\n-run.app\n-a.run.app\n+*.run.app\n@@ -13552,0 +13719,4 @@\n+\/\/ GrayJay Web Solutions Inc. : https:\/\/grayjaysports.ca\n+\/\/ Submitted by Matt Yamkowy <info@grayjaysports.ca>\n+grayjayleagues.com\n+\n@@ -13586,0 +13757,5 @@\n+\/\/ Helio Networks : https:\/\/heliohost.org\n+\/\/ Submitted by Ben Frede <admin@heliohost.org>\n+helioho.st\n+heliohost.us\n+\n@@ -13599,1 +13775,0 @@\n-ravendb.me\n@@ -13607,0 +13782,6 @@\n+\/\/ Homebase : https:\/\/homebase.id\/\n+\/\/ Submitted by Jason Babo <info@homebase.id>\n+*.kin.one\n+*.id.pub\n+*.kin.pub\n+\n@@ -13684,1 +13865,1 @@\n-\/\/ Submitted by Jacob Slater <whois@igloo.to>\n+\/\/ Submitted by June Slater <whois@igloo.to>\n@@ -13733,0 +13914,8 @@\n+\/\/ is-a.dev : https:\/\/www.is-a.dev\n+\/\/ Submitted by William Harrison <admin@maintainers.is-a.dev>\n+is-a.dev\n+\n+\/\/ ir.md : https:\/\/nic.ir.md\n+\/\/ Submitted by Ali Soizi <info@nic.ir.md>\n+ir.md\n+\n@@ -13841,0 +14030,5 @@\n+\/\/ JouwWeb B.V. : https:\/\/www.jouwweb.nl\n+\/\/ Submitted by Camilo Sperberg <tech@webador.com>\n+jouwweb.site\n+webadorsite.com\n+\n@@ -13914,0 +14108,4 @@\n+\/\/ Libre IT Ltd : https:\/\/libre.nz\n+\/\/ Submitted by Tomas Maggio <support@libre.nz>\n+runcontainers.dev\n+\n@@ -13924,4 +14122,0 @@\n-\/\/ Lightmaker Property Manager, Inc. : https:\/\/app.lmpm.com\/\n-\/\/ Submitted by Greg Holland <greg.holland@lmpm.com>\n-app.lmpm.com\n-\n@@ -14060,0 +14254,5 @@\n+\/\/ Meta Platforms, Inc. : https:\/\/meta.com\/\n+\/\/ Submitted by Jacob Cordero <public-suffix@meta.com>\n+atmeta.com\n+apps.fbsbx.com\n+\n@@ -14080,0 +14279,2 @@\n+\/\/ Managed by Corporate Domains\n+\/\/ Microsoft Azure : https:\/\/home.azure\n@@ -14081,0 +14282,3 @@\n+azure-api.net\n+azureedge.net\n+azurefd.net\n@@ -14083,1 +14287,0 @@\n-cloudapp.net\n@@ -14097,0 +14300,4 @@\n+cloudapp.net\n+trafficmanager.net\n+blob.core.windows.net\n+servicebus.windows.net\n@@ -14110,0 +14317,4 @@\n+\/\/ MODX Systems LLC : https:\/\/modx.com\n+\/\/ Submitted by Elizabeth Southwell <elizabeth@modx.com>\n+modx.dev\n+\n@@ -14156,0 +14367,4 @@\n+\/\/ NGO.US Registry : https:\/\/nic.ngo.us\n+\/\/ Submitted by Alstra Solutions Ltd. Networking Team <admin@alstra.org>\n+ngo.us\n+\n@@ -14171,0 +14386,1 @@\n+ngrok.pro\n@@ -14176,1 +14392,1 @@\n-\/\/ Submitted by Nicholas Ford <nick@nimbushosting.co.uk>\n+\/\/ Submitted by Nicholas Ford <dev@nimbushosting.co.uk>\n@@ -14178,0 +14394,1 @@\n+nimsite.uk\n@@ -14183,0 +14400,4 @@\n+\/\/ NFT.Storage : https:\/\/nft.storage\/\n+\/\/ Submitted by Vasco Santos <vasco.santos@protocol.ai> or <support@nft.storage>\n+ipfs.nftstorage.link\n+\n@@ -14333,0 +14554,4 @@\n+\/\/ O3O.Foundation : https:\/\/o3o.foundation\/\n+\/\/ Submitted by the prvcy.page Registry Team <psl@registry.prvcy.page>\n+prvcy.page\n+\n@@ -14362,1 +14587,0 @@\n-123sait.ru\n@@ -14380,0 +14604,7 @@\n+\/\/ Open Domains : https:\/\/open-domains.net\n+\/\/ Submitted by William Harrison <admin@open-domains.net>\n+is-cool.dev\n+is-not-a.dev\n+localplayer.dev\n+is-local.org\n+\n@@ -14400,0 +14631,5 @@\n+\/\/ OsSav Technology Ltd. : https:\/\/ossav.com\/\n+\/\/ TLD Nic: http:\/\/nic.can.re - TLD Whois Server: whois.can.re\n+\/\/ Submitted by OsSav Technology Ltd. <support@ossav.com>\n+can.re\n+\n@@ -14450,4 +14686,5 @@\n-bar0.net\n-bar1.net\n-bar2.net\n-rdv.to\n+*.xmit.co\n+xmit.dev\n+srv.us\n+gh.srv.us\n+gl.srv.us\n@@ -14486,1 +14723,2 @@\n-bc.platform.sh\n+*.upsun.app\n+upsunapp.com\n@@ -14505,0 +14743,4 @@\n+\/\/ Pley AB : https:\/\/www.pley.com\/\n+\/\/ Submitted by Henning Pohl <infra@pley.com>\n+pley.games\n+\n@@ -14536,4 +14778,0 @@\n-\/\/ privacytools.io : https:\/\/www.privacytools.io\/\n-\/\/ Submitted by Jonah Aragon <jonah@privacytools.io>\n-prvcy.page\n-\n@@ -14581,0 +14819,2 @@\n+myradweb.net\n+servername.us\n@@ -14604,2 +14844,2 @@\n-\/\/ Submitted by Nick Chang <nickchang@qnap.com>\n-dev-myqnapcloud.com\n+\/\/ Submitted by Nick Chang <cloudadmin@qnap.com>\n+myqnapcloud.cn\n@@ -14607,0 +14847,3 @@\n+dev-myqnapcloud.com\n+mycloudnas.com\n+mynascloud.com\n@@ -14647,1 +14890,3 @@\n-\/\/ Submitted by Lincoln Bergeson <lincoln@replit.com>\n+\/\/ Submitted by Lincoln Bergeson <psl@repl.it>\n+replit.app\n+id.replit.app\n@@ -14652,0 +14897,27 @@\n+replit.dev\n+archer.replit.dev\n+bones.replit.dev\n+canary.replit.dev\n+global.replit.dev\n+hacker.replit.dev\n+id.replit.dev\n+janeway.replit.dev\n+kim.replit.dev\n+kira.replit.dev\n+kirk.replit.dev\n+odo.replit.dev\n+paris.replit.dev\n+picard.replit.dev\n+pike.replit.dev\n+prerelease.replit.dev\n+reed.replit.dev\n+riker.replit.dev\n+sisko.replit.dev\n+spock.replit.dev\n+staging.replit.dev\n+sulu.replit.dev\n+tarpit.replit.dev\n+teams.replit.dev\n+tucker.replit.dev\n+wesley.replit.dev\n+worf.replit.dev\n@@ -14748,1 +15020,1 @@\n-\/\/ Submitted by Michael Biven <mbiven@salesforce.com>\n+\/\/ Submitted by Michael Biven <mbiven@salesforce.com> and Aaron Romeo <aaron.romeo@salesforce.com>\n@@ -14752,0 +15024,1 @@\n+*.001.test.code-builder-stg.platform.salesforce.com\n@@ -14767,0 +15040,1 @@\n+cockpit.fr-par.scw.cloud\n@@ -14777,0 +15051,1 @@\n+cockpit.nl-ams.scw.cloud\n@@ -14782,0 +15057,1 @@\n+cockpit.pl-waw.scw.cloud\n@@ -14803,0 +15079,4 @@\n+\/\/ Scrypted : https:\/\/scrypted.app\n+\/\/ Submitted by Koushik Dutta <public-suffix-list@scrypted.app>\n+client.scrypted.io\n+\n@@ -14842,0 +15122,4 @@\n+\/\/ Sheezy.Art : https:\/\/sheezy.art\n+\/\/ Submitted by Nyoom <admin@sheezy.art>\n+sheezy.games\n+\n@@ -14890,1 +15174,1 @@\n-\/\/ Former AFNIC's SLDs \n+\/\/ Former AFNIC's SLDs\n@@ -14912,3 +15196,3 @@\n-\/\/ Submitted by Faith Olapade <faith.olapade@snowflake.com>\n-snowflake.app\n-privatelink.snowflake.app\n+\/\/ Submitted by Sam Haar <psl@snowflake.com>\n+*.snowflake.app\n+*.privatelink.snowflake.app\n@@ -14926,0 +15210,6 @@\n+\/\/ StackBlitz : https:\/\/stackblitz.com\n+\/\/ Submitted by Dominic Elm <hello@stackblitz.com>\n+w-corp-staticblitz.com\n+w-credentialless-staticblitz.com\n+w-staticblitz.com\n+\n@@ -14930,0 +15220,8 @@\n+\/\/ STACKIT : https:\/\/www.stackit.de\/en\/\n+\/\/ Submitted by STACKIT-DNS Team (Simon Stier) <stackit-dns@mail.schwarz>\n+runs.onstackit.cloud\n+stackit.gg\n+stackit.rocks\n+stackit.run\n+stackit.zone\n+\n@@ -14996,0 +15294,13 @@\n+\/\/ stereosense GmbH : https:\/\/www.involve.me\n+\/\/ Submitted by Florian Burmann <publicsuffix@involve.me>\n+feedback.ac\n+forms.ac\n+assessments.cx\n+calculators.cx\n+funnels.cx\n+paynow.cx\n+quizzes.cx\n+researched.cx\n+tests.cx\n+surveys.so\n+\n@@ -15004,0 +15315,6 @@\n+\/\/ Streak : https:\/\/streak.com\n+\/\/ Submitted by Blake Kadatz <eng@streak.com>\n+streak-link.com\n+streaklinks.com\n+streakusercontent.com\n+\n@@ -15066,0 +15383,1 @@\n+*.c.ts.net\n@@ -15199,0 +15517,4 @@\n+\/\/ Unison Computing, PBC : https:\/\/unison.cloud\n+\/\/ Submitted by Simon Højberg <security@unison.cloud>\n+unison-services.cloud\n+\n@@ -15248,42 +15570,0 @@\n-\/\/ Voxel.sh DNS : https:\/\/voxel.sh\/dns\/\n-\/\/ Submitted by Mia Rehlinger <dns@voxel.sh>\n-neko.am\n-nyaa.am\n-be.ax\n-cat.ax\n-es.ax\n-eu.ax\n-gg.ax\n-mc.ax\n-us.ax\n-xy.ax\n-nl.ci\n-xx.gl\n-app.gp\n-blog.gt\n-de.gt\n-to.gt\n-be.gy\n-cc.hn\n-blog.kg\n-io.kg\n-jp.kg\n-tv.kg\n-uk.kg\n-us.kg\n-de.ls\n-at.md\n-de.md\n-jp.md\n-to.md\n-indie.porn\n-vxl.sh\n-ch.tc\n-me.tc\n-we.tc\n-nyan.to\n-at.vg\n-blog.vu\n-dev.vu\n-me.vu\n-\n@@ -15302,0 +15582,5 @@\n+\/\/ Webflow, Inc. : https:\/\/www.webflow.com\n+\/\/ Submitted by Webflow Security Team <security@webflow.com>\n+webflow.io\n+webflowtest.io\n+\n@@ -15313,0 +15598,4 @@\n+\/\/ WebWaddle Ltd: https:\/\/webwaddle.com\/\n+\/\/ Submitted by Merlin Glander <hostmaster@webwaddle.com>\n+*.wadl.top\n+\n@@ -15421,0 +15710,4 @@\n+\/\/ ZAP-Hosting GmbH & Co. KG : https:\/\/zap-hosting.com\n+\/\/ Submitted by Julian Alker <security@zap-hosting.com>\n+zap.cloud\n+\n","filename":"src\/java.base\/share\/data\/publicsuffixlist\/public_suffix_list.dat","additions":449,"deletions":156,"binary":false,"changes":605,"status":"modified"},{"patch":"@@ -14,1 +14,1 @@\n-https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/b5bf572c52988dbe9d865b8f090ea819024a9936\/public_suffix_list.dat.\n+https:\/\/raw.githubusercontent.com\/publicsuffix\/list\/1cbd6e71a9b83620b1d0b11e49d3d9ff48c27e22\/public_suffix_list.dat.\n","filename":"src\/java.base\/share\/legal\/public_suffix.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,0 +204,3 @@\n+        \/\/ wait for any write operation to complete before trying to close\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,0 +203,3 @@\n+        \/\/ wait for any read operation to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -887,1 +887,3 @@\n-                access(source, W_OK);\n+                int errno = access(source, W_OK);\n+                if (errno != 0)\n+                    new UnixException(errno).rethrowAsIOException(source);\n@@ -1018,7 +1020,5 @@\n-            try {\n-                \/\/ the access(2) system call always follows links so it\n-                \/\/ is suppressed if the source is an unfollowed link\n-                access(source, R_OK);\n-            } catch (UnixException exc) {\n-                exc.rethrowAsIOException(source);\n-            }\n+            \/\/ the access(2) system call always follows links so it\n+            \/\/ is suppressed if the source is an unfollowed link\n+            int errno = access(source, R_OK);\n+            if (errno != 0)\n+                new UnixException(errno).rethrowAsIOException(source);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -352,4 +352,27 @@\n-        try {\n-            access(file, mode);\n-        } catch (UnixException exc) {\n-            exc.rethrowAsIOException(file);\n+        int errno = access(file, mode);\n+        if (errno != 0)\n+            new UnixException(errno).rethrowAsIOException(file);\n+    }\n+\n+    @Override\n+    public boolean isReadable(Path path) {\n+        UnixPath file = UnixPath.toUnixPath(path);\n+        file.checkRead();\n+        return access(file, R_OK) == 0;\n+    }\n+\n+    @Override\n+    public boolean isWritable(Path path) {\n+        UnixPath file = UnixPath.toUnixPath(path);\n+        file.checkWrite();\n+        return access(file, W_OK) == 0;\n+    }\n+\n+    @Override\n+    public boolean isExecutable(Path path) {\n+        UnixPath file = UnixPath.toUnixPath(path);\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            \/\/ not cached\n+            sm.checkExec(file.getPathForPermissionCheck());\n@@ -357,0 +380,1 @@\n+        return access(file, X_OK) == 0;\n@@ -564,1 +588,1 @@\n-            return UnixNativeDispatcher.exists(file);\n+            return access(file, F_OK) == 0;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -600,1 +600,1 @@\n-    static void access(UnixPath path, int amode) throws UnixException {\n+    static int access(UnixPath path, int amode) {\n@@ -604,1 +604,1 @@\n-                access0(buffer.address(), amode);\n+                return access0(buffer.address(), amode);\n@@ -610,18 +610,1 @@\n-    private static native void access0(long pathAddress, int amode) throws UnixException;\n-\n-    \/**\n-     * access(constant char* path, F_OK)\n-     *\n-     * @return true if the file exists, false otherwise\n-     *\/\n-    static boolean exists(UnixPath path) {\n-        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n-            long comp = Blocker.begin();\n-            try {\n-                return exists0(buffer.address());\n-            } finally {\n-                Blocker.end(comp);\n-            }\n-        }\n-    }\n-    private static native boolean exists0(long pathAddress);\n+    private static native int access0(long pathAddress, int amode);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -550,1 +550,1 @@\n-        JNU_ThrowByNameWithLastError(env,\n+        JNU_ThrowByNameWithMessageAndLastError(env,\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -698,0 +698,2 @@\n+        \/\/ statx is not allowed on the old Docker versions and returns EPERM,\n+        \/\/ fallback to stat64 in this case\n@@ -702,1 +704,1 @@\n-        } else {\n+        } else if (errno != EPERM) {\n@@ -730,0 +732,2 @@\n+        \/\/ statx is not allowed on the old Docker versions and returns EPERM,\n+        \/\/ fallback to lstat64 in this case\n@@ -733,1 +737,2 @@\n-        } else {\n+            return;\n+        } else if (errno != EPERM) {\n@@ -735,0 +740,1 @@\n+            return;\n@@ -736,2 +742,0 @@\n-        \/\/ statx was available, so return now\n-        return;\n@@ -762,0 +766,2 @@\n+        \/\/ statx is not allowed on the old Docker versions and returns EPERM,\n+        \/\/ fallback to fstat64 in this case\n@@ -765,1 +771,2 @@\n-        } else {\n+            return;\n+        } else if (errno != EPERM) {\n@@ -767,0 +774,1 @@\n+            return;\n@@ -768,2 +776,0 @@\n-        \/\/ statx was available, so return now\n-        return;\n@@ -797,0 +803,2 @@\n+        \/\/ statx is not allowed on the old Docker versions and returns EPERM,\n+        \/\/ fallback to fstatat64 in this case\n@@ -800,1 +808,2 @@\n-        } else {\n+            return;\n+        } else if (errno != EPERM) {\n@@ -802,0 +811,1 @@\n+            return;\n@@ -803,2 +813,0 @@\n-        \/\/ statx was available, so return now\n-        return;\n@@ -1205,1 +1213,1 @@\n-JNIEXPORT void JNICALL\n+JNIEXPORT jint JNICALL\n@@ -1213,4 +1221,0 @@\n-    if (err == -1) {\n-        throwUnixException(env, errno);\n-    }\n-}\n@@ -1218,6 +1222,1 @@\n-JNIEXPORT jboolean JNICALL\n-Java_sun_nio_fs_UnixNativeDispatcher_exists0(JNIEnv* env, jclass this, jlong pathAddress) {\n-    int err;\n-    const char* path = (const char*)jlong_to_ptr(pathAddress);\n-    RESTARTABLE(access(path, F_OK), err);\n-    return (err == 0) ? JNI_TRUE : JNI_FALSE;\n+    return (err == -1) ? errno : 0;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,0 +477,2 @@\n+         * Windows Server 2025          10              0  (!VER_NT_WORKSTATION)\n+         *       where (buildNumber > 26039)\n@@ -560,1 +562,4 @@\n-                        if (buildNumber > 20347) {\n+                        \/* Windows server 2025 Preview build is 26040 *\/\n+                        if (buildNumber > 26039) {\n+                            sprops.os_name = \"Windows Server 2025\";\n+                        } else if (buildNumber > 20347) {\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.awt.event.WindowStateListener;\n@@ -968,0 +969,27 @@\n+    private void waitForWindowState(int state) {\n+        if (peer.getState() == state) {\n+            return;\n+        }\n+\n+        Object lock = new Object();\n+        WindowStateListener wsl = new WindowStateListener() {\n+            public void windowStateChanged(WindowEvent e) {\n+                synchronized (lock) {\n+                    if (e.getNewState() == state) {\n+                        lock.notifyAll();\n+                    }\n+                }\n+            }\n+        };\n+\n+        target.addWindowStateListener(wsl);\n+        if (peer.getState() != state) {\n+            synchronized (lock) {\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException ie) {}\n+            }\n+        }\n+        target.removeWindowStateListener(wsl);\n+    }\n+\n@@ -989,0 +1017,1 @@\n+                    waitForWindowState(Frame.NORMAL);\n@@ -996,0 +1025,2 @@\n+                    waitForWindowState(Frame.NORMAL);\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformWindow.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+\/\/ Constant for keyman layouts\n+#define KEYMAN_LAYOUT \"keyman\"\n+\n@@ -262,1 +265,1 @@\n-    fKeyEventsNeeded = YES;\n+    fKeyEventsNeeded = ![(NSString *)kbdLayout containsString:@KEYMAN_LAYOUT];\n@@ -968,1 +971,1 @@\n-        ((codePoint == 0x5c) && ([(NSString *)kbdLayout containsString:@\"Kotoeri\"]))) {\n+        [(NSString *)kbdLayout containsString:@KEYMAN_LAYOUT]) {\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTView.m","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1700,0 +1700,1 @@\n+            [nsWindow makeKeyAndOrderFront: nil];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTWindow.m","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -340,1 +340,2 @@\n-            if (c.getParent() instanceof JScrollBar) {\n+            if (c.getParent() instanceof JScrollBar\n+                || c.getParent() instanceof JTabbedPane) {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKEngine.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -924,1 +924,1 @@\n-            if (!SwingUtilities.isLeftMouseButton(e) || !comboBox.isEnabled())\n+            if (!SwingUtilities.isLeftMouseButton(e) || !comboBox.isEnabled() || !comboBox.isShowing())\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicComboPopup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-    margin-rigth: 0;\n+    margin-right: 0;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/default.css","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -669,2 +669,0 @@\n-        free(info->err);\n-        info->err = NULL;\n@@ -681,0 +679,2 @@\n+        free(info->err);\n+        info->err = NULL;\n","filename":"src\/java.desktop\/share\/native\/libjavajpeg\/imageioJPEG.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -69,0 +68,2 @@\n+            \".java\/robot\/screencast-tokens.properties\";\n+    private static final String REL_NAME_SECONDARY =\n@@ -75,0 +76,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -76,6 +78,3 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            @Override\n-            public Void run() {\n-                runnable.run();\n-                return null;\n-            }\n+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+            runnable.run();\n+            return null;\n@@ -86,6 +85,5 @@\n-        PROPS_PATH = AccessController.doPrivileged(new PrivilegedAction<Path>() {\n-            @Override\n-            public Path run() {\n-                return setupPath();\n-            }\n-        });\n+        @SuppressWarnings(\"removal\")\n+        Path propsPath = AccessController\n+                .doPrivileged((PrivilegedAction<Path>) () -> setupPath());\n+\n+        PROPS_PATH = propsPath;\n@@ -113,0 +111,5 @@\n+        Path secondaryPath = Path.of(userHome, REL_NAME_SECONDARY);\n+\n+        boolean copyFromSecondary = !Files.isWritable(path)\n+                && Files.isWritable(secondaryPath);\n+\n@@ -115,7 +118,10 @@\n-        if (!Files.exists(workdir)) {\n-            try {\n-                Files.createDirectories(workdir);\n-            } catch (Exception e) {\n-                if (SCREENCAST_DEBUG) {\n-                    System.err.printf(\"Token storage: cannot create\" +\n-                                    \" directory %s %s\\n\", workdir, e);\n+        if (!Files.isWritable(path)) {\n+            if (!Files.exists(workdir)) {\n+                try {\n+                    Files.createDirectories(workdir);\n+                } catch (Exception e) {\n+                    if (SCREENCAST_DEBUG) {\n+                        System.err.printf(\"Token storage: cannot create\" +\n+                                \" directory %s %s\\n\", workdir, e);\n+                    }\n+                    return null;\n@@ -123,1 +129,0 @@\n-                return null;\n@@ -125,1 +130,0 @@\n-        }\n@@ -127,3 +131,5 @@\n-        if (!Files.isWritable(workdir)) {\n-            if (SCREENCAST_DEBUG) {\n-                System.err.printf(\"Token storage: %s is not writable\\n\", workdir);\n+            if (!Files.isWritable(workdir)) {\n+                if (SCREENCAST_DEBUG) {\n+                    System.err.printf(\"Token storage: %s is not writable\\n\", workdir);\n+                }\n+                return null;\n@@ -131,1 +137,0 @@\n-            return null;\n@@ -148,1 +153,11 @@\n-        if (Files.exists(path)) {\n+        if (copyFromSecondary) {\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"Token storage: copying from the secondary location \"\n+                                        + secondaryPath);\n+            }\n+            synchronized (PROPS) {\n+                if (readTokens(secondaryPath)) {\n+                    store(path, \"copy from the secondary location\");\n+                }\n+            }\n+        } else if (Files.exists(path)) {\n@@ -305,1 +320,1 @@\n-                doPrivilegedRunnable(() -> store(\"save tokens\"));\n+                doPrivilegedRunnable(() -> store(PROPS_PATH, \"save tokens\"));\n@@ -318,1 +333,1 @@\n-        } catch (IOException e) {\n+        } catch (IOException | IllegalArgumentException e) {\n@@ -413,1 +428,1 @@\n-        if (!isWritable()\n+        if (!isWritable(PROPS_PATH)\n@@ -427,1 +442,1 @@\n-            store(\"remove malformed records\");\n+            store(PROPS_PATH, \"remove malformed records\");\n@@ -431,2 +446,2 @@\n-    private static void store(String failMsg) {\n-        if (!isWritable()) {\n+    private static void store(Path path, String failMsg) {\n+        if (!isWritable(path)) {\n@@ -437,1 +452,1 @@\n-            try (BufferedWriter writer = Files.newBufferedWriter(PROPS_PATH)) {\n+            try (BufferedWriter writer = Files.newBufferedWriter(path)) {\n@@ -448,3 +463,3 @@\n-    private static boolean isWritable() {\n-        if (PROPS_PATH == null\n-            || (Files.exists(PROPS_PATH) && !Files.isWritable(PROPS_PATH))) {\n+    private static boolean isWritable(Path path) {\n+        if (path == null\n+            || (Files.exists(path) && !Files.isWritable(path))) {\n@@ -454,1 +469,1 @@\n-                        \"Token storage: %s is not writable\\n\", PROPS_PATH);\n+                        \"Token storage: %s is not writable\\n\", path);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":53,"deletions":38,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,0 @@\n-typedef void GMainContext;\n@@ -64,1 +63,0 @@\n-typedef void GdkPixbuf;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,2 +183,0 @@\n-typedef void GdkPixbuf;\n-typedef void GMainContext;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-            return inBuf[0];\n+            return inBuf[0] & 0xff;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/sasl\/SaslInputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-    raw_unextendedSP = getFP();\n+    \/\/ Nothing to do. senderForInterpreterFrame finds the correct unextendedSP.\n@@ -322,0 +322,1 @@\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+                        String reason;\n@@ -108,1 +109,1 @@\n-                            throw runtime.exitHotSpotWithMessage(1, \"JVMCI compiler '%s' not found in JVMCI native library.%n\" +\n+                            reason = String.format(\"JVMCI compiler '%s' not found in JVMCI native library.%n\" +\n@@ -111,0 +112,2 @@\n+                        } else {\n+                            reason = String.format(\"JVMCI compiler '%s' specified by %s not found%n\", compilerName, compPropertyName);\n@@ -112,1 +115,1 @@\n-                        throw runtime.exitHotSpotWithMessage(1, \"JVMCI compiler '%s' specified by %s not found%n\", compilerName, compPropertyName);\n+                        factory = new DummyCompilerFactory(reason, runtime);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCICompilerConfig.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,2 @@\n+                } else {\n+                    p = Packet.fromByteArray(b);\n@@ -127,1 +129,0 @@\n-                p = Packet.fromByteArray(b);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/TargetVM.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -706,0 +706,19 @@\n+TEST_VM(os_windows, processor_count) {\n+  JVMFlag* flag = JVMFlag::find_flag(\"UseAllWindowsProcessorGroups\");\n+  EXPECT_NE(flag, nullptr) << \"Expected UseAllWindowsProcessorGroups product flag to be available\";\n+\n+  int processors = os::processor_count();\n+  EXPECT_GT(processors, 0) << \"Expected at least 1 processor\";\n+\n+  int active_processors = os::active_processor_count();\n+  EXPECT_GT(active_processors, 0) << \"Expected at least 1 active processor\";\n+\n+  bool schedules_all_processor_groups = os::win32::is_windows_11_or_greater() || os::win32::is_windows_server_2022_or_greater();\n+  if (schedules_all_processor_groups && UseAllWindowsProcessorGroups) {\n+    EXPECT_EQ(active_processors, processors) << \"Expected all processors to be active\";\n+  } else {\n+    \/\/ active_processors should be at most the number of processors in 1 Windows processor group.\n+    EXPECT_LE(active_processors, processors) << \"Expected active processors to not exceed available processors\";\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263,8313877 generic-x64,generic-i586,generic-ppc64le\n@@ -61,1 +61,1 @@\n-compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263,8313877 generic-x64,generic-i586,generic-ppc64le\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+  gtest\/WindowsProcessorGroups.java\n@@ -428,1 +429,2 @@\n- -runtime\/signal\n+ -runtime\/signal \\\n+ -runtime\/stack\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-        revision = \"0.16\", extension = \"jar\", unpack = false)\n+        revision = JcstressRunner.VERSION, extension = \"jar\", unpack = false)\n@@ -48,0 +48,1 @@\n+    public static final String VERSION = \"0.17-SNAPSHOT-20240328\";\n@@ -50,3 +51,2 @@\n-    \/\/ Allow to configure jcstress mode parameter.\n-    \/\/ Test mode preset: sanity, quick, default, tough, stress.\n-    public static final String MODE_PROPERTY = \"jcstress.mode\";\n+    public static final String TIME_BUDGET_PROPERTY = \"jcstress.time_budget\";\n+    public static String timeBudget = \"6m\";\n@@ -62,1 +62,1 @@\n-        return artifacts.get(\"org.openjdk.jcstress.jcstress-tests-all-0.16\")\n+        return artifacts.get(\"org.openjdk.jcstress.jcstress-tests-all-\" + VERSION)\n@@ -112,3 +112,0 @@\n-        \/\/ The \"default\" preset might take days for some tests\n-        \/\/ so use quick testing by default.\n-        String mode = \"quick\";\n@@ -116,4 +113,5 @@\n-            if(jvmArg.startsWith(\"-D\" + MODE_PROPERTY)) {\n-                String[] pair = jvmArg.split(\"=\", 2);\n-                mode = pair[1];\n-                continue;\n+            if (jvmArg.startsWith(\"-D\" + TIME_BUDGET_PROPERTY)) {\n+                timeBudget = jvmArg.split(\"=\", 2)[1];\n+            } else {\n+                extraFlags.add(\"--jvmArgs\");\n+                extraFlags.add(jvmArg);\n@@ -121,2 +119,0 @@\n-            extraFlags.add(\"--jvmArgs\");\n-            extraFlags.add(jvmArg);\n@@ -125,2 +121,2 @@\n-        extraFlags.add(\"-m\");\n-        extraFlags.add(mode);\n+        extraFlags.add(\"-tb\");\n+        extraFlags.add(timeBudget);\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/JcstressRunner.java","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8316653\n+ * @requires vm.debug\n+ * @summary Test flag with max value.\n+ *\n+ * @run main\/othervm -XX:NMethodSizeLimit=1M\n+ *                   compiler.arguments.TestC1Globals\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8318817\n+ * @requires vm.debug\n+ * @requires os.family == \"linux\"\n+ * @summary Test flag with max value combined with transparent huge pages on\n+ *          Linux.\n+ *\n+ * @run main\/othervm -XX:NMethodSizeLimit=1M\n+ *                   -XX:+UseTransparentHugePages\n+ *                   compiler.arguments.TestC1Globals\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8320682\n+ * @requires vm.debug\n+ * @summary Test flag with max value and specific compilation.\n+ *\n+ * @run main\/othervm -XX:NMethodSizeLimit=1M\n+ *                   -XX:CompileOnly=java.util.HashMap::putMapEntries\n+ *                   -Xcomp\n+ *                   compiler.arguments.TestC1Globals\n+ *\n+ *\/\n+\n+package compiler.arguments;\n+\n+public class TestC1Globals {\n+\n+    public static void main(String args[]) {\n+        System.out.println(\"Passed\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestC1Globals.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires ! vm.opt.final.UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/compiler\/blackhole\/BlackholeExperimentalUnlockTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -136,1 +137,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n@@ -138,1 +138,1 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -140,1 +140,1 @@\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/Test7068051.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -182,1 +183,1 @@\n-    static void run(String testCaseName, Consumer<OutputAnalyzer> processor) throws IOException {\n+    static void run(String testCaseName, Consumer<OutputAnalyzer> processor) throws Exception {\n@@ -195,1 +196,1 @@\n-        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer analyzer = ProcessTools.executeProcess(pb);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/unloaded\/TestInlineUnloaded.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Pass values on stack.\n+ * @requires os.arch == \"riscv64\"\n+ * @run main\/native compiler.calls.TestManyArgs\n+ *\/\n+\n+package compiler.calls;\n+\n+public class TestManyArgs {\n+    static {\n+        System.loadLibrary(\"TestManyArgs\");\n+    }\n+\n+    native static void scramblestack();\n+\n+    native static int checkargs(int arg0, short arg1, byte arg2,\n+                                int arg3, short arg4, byte arg5,\n+                                int arg6, short arg7, byte arg8,\n+                                int arg9, short arg10, byte arg11);\n+\n+    static int compiledbridge(int arg0, short arg1, byte arg2,\n+                              int arg3, short arg4, byte arg5,\n+                              int arg6, short arg7, byte arg8,\n+                              int arg9, short arg10, byte arg11) {\n+        return checkargs(arg0, arg1, arg2, arg3, arg4, arg5,\n+                         arg6, arg7, arg8, arg9, arg10, arg11);\n+    }\n+\n+    static public void main(String[] args) {\n+        scramblestack();\n+        for (int i = 0; i < 20000; i++) {\n+            int res = compiledbridge((int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf);\n+            if (res != 0) {\n+                throw new RuntimeException(\"Test failed\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/TestManyArgs.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+#ifdef riscv64\n+\/* RV64 ABI pass all integers as 64-bit, in registers or on stack\n+ * As compiler may choose to load smaller width than 64-bit if passed on stack,\n+ * this test may not find any bugs.\n+ * Therefore we trick the compiler todo 64-bit loads,\n+ * by saying these args are jlongs.\n+ *\/\n+JNIEXPORT jint JNICALL Java_compiler_calls_TestManyArgs_checkargs(JNIEnv* env, jclass jclazz,\n+                                                                  jlong arg0, jlong arg1, jlong arg2,\n+                                                                  jlong arg3, jlong arg4, jlong arg5,\n+                                                                  jlong arg6, jlong arg7, jlong arg8,\n+                                                                  jlong arg9, jlong arg10, jlong arg11)\n+#else\n+JNIEXPORT jint JNICALL Java_compiler_calls_TestManyArgs_checkargs(JNIEnv* env, jclass jclazz,\n+                                                                  jint arg0, jshort arg1, jbyte arg2,\n+                                                                  jint arg3, jshort arg4, jbyte arg5,\n+                                                                  jint arg6, jshort arg7, jbyte arg8,\n+                                                                  jint arg9, jshort arg10, jbyte arg11)\n+#endif\n+{\n+    if (arg0 != 0xf) return 1;\n+    if (arg1 != 0xf) return 1;\n+    if (arg2 != 0xf) return 1;\n+    if (arg3 != 0xf) return 1;\n+    if (arg4 != 0xf) return 1;\n+    if (arg5 != 0xf) return 1;\n+    if (arg6 != 0xf) return 1;\n+    if (arg7 != 0xf) return 1;\n+    if (arg8 != 0xf) return 1;\n+    if (arg9 != 0xf) return 1;\n+    if (arg10 != 0xf) return 1;\n+    if (arg11 != 0xf) return 1;\n+    return 0;\n+}\n+\n+JNIEXPORT\n+void JNICALL Java_compiler_calls_TestManyArgs_scramblestack(JNIEnv* env, jclass jclazz)\n+{\n+    volatile char stack[12*8];\n+    for (unsigned int i = 0; i < sizeof(stack); i++) {\n+        stack[i] = (char)0xff;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/libTestManyArgs.c","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -26,2 +26,2 @@\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @summary Test intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n@@ -76,1 +76,1 @@\n-    @IR(counts = {IRNode.UDIV_I, \">= 1\"}) \/\/ Atleast one UDivI node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UDIV_I, \">= 1\"}) \/\/ At least one UDivI node is generated if intrinsic is used\n@@ -90,1 +90,1 @@\n-    @IR(counts = {IRNode.UMOD_I, \">= 1\"}) \/\/ Atleast one UModI node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UMOD_I, \">= 1\"}) \/\/ At least one UModI node is generated if intrinsic is used\n@@ -105,1 +105,2 @@\n-    @IR(counts = {IRNode.UDIV_MOD_I, \">= 1\"}) \/\/ Atleast one UDivModI node is generated if intrinsic is used\n+    @IR(applyIfPlatform = {\"x64\", \"true\"},\n+        counts = {IRNode.UDIV_MOD_I, \">= 1\"}) \/\/ At least one UDivModI node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestIntegerUnsignedDivMod.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @summary Test intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n@@ -143,1 +143,2 @@\n-    @IR(counts = {IRNode.UDIV_MOD_L, \">= 1\"}) \/\/ Atleast one UDivModL node is generated if intrinsic is used\n+    @IR(applyIfPlatform = {\"x64\", \"true\"},\n+        counts = {IRNode.UDIV_MOD_L, \">= 1\"}) \/\/ At least one UDivModL node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -54,2 +55,1 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/NonInlinedCall\/Agent.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -160,1 +160,10 @@\n-### 2.5 Framework Debug and Stress Flags\n+### 2.5 IR Tests with Privileged Classes\n+To run tests in a privileged mode (e.g. when using `@Stable`, `@Contended`, `@ReservedStackAccess` etc.), one need to add the test classes to the boot classpath. This can easily be achieved by calling `TestFramework.addTestClassesToBootClassPath()` on the test framework object:\n+```\n+TestFramework testFramework = new TestFramework();\n+testFramework\n+        .addTestClassesToBootClassPath()\n+        .start();\n+```\n+\n+### 2.6 Framework Debug and Stress Flags\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+    private boolean testClassesOnBootClassPath;\n@@ -325,0 +326,9 @@\n+    \/**\n+     * Add test classes to boot classpath. This adds all classes found on path {@link jdk.test.lib.Utils#TEST_CLASSES}\n+     * to the boot classpath with \"-Xbootclasspath\/a\". This is useful when trying to run tests in a privileged mode.\n+     *\/\n+    public TestFramework addTestClassesToBootClassPath() {\n+        this.testClassesOnBootClassPath = true;\n+        return this;\n+    }\n+\n@@ -746,1 +756,2 @@\n-        TestVMProcess testVMProcess = new TestVMProcess(additionalFlags, testClass, helperClasses, defaultWarmup);\n+        TestVMProcess testVMProcess = new TestVMProcess(additionalFlags, testClass, helperClasses, defaultWarmup,\n+                                                        testClassesOnBootClassPath);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.io.File;\n@@ -66,1 +67,2 @@\n-    public TestVMProcess(List<String> additionalFlags, Class<?> testClass, Set<Class<?>> helperClasses, int defaultWarmup) {\n+    public TestVMProcess(List<String> additionalFlags, Class<?> testClass, Set<Class<?>> helperClasses, int defaultWarmup,\n+                         boolean testClassesOnBootClassPath) {\n@@ -70,1 +72,1 @@\n-            prepareTestVMFlags(additionalFlags, socket, testClass, helperClasses, defaultWarmup);\n+            prepareTestVMFlags(additionalFlags, socket, testClass, helperClasses, defaultWarmup, testClassesOnBootClassPath);\n@@ -94,1 +96,1 @@\n-                                    Set<Class<?>> helperClasses, int defaultWarmup) {\n+                                    Set<Class<?>> helperClasses, int defaultWarmup, boolean testClassesOnBootClassPath) {\n@@ -98,1 +100,6 @@\n-        cmds.add(\"-Xbootclasspath\/a:.\");\n+        String bootClassPath = \"-Xbootclasspath\/a:.\";\n+        if (testClassesOnBootClassPath) {\n+            \/\/ Add test classes themselves to boot classpath to make them privileged.\n+            bootClassPath += File.pathSeparator + Utils.TEST_CLASSES;\n+        }\n+        cmds.add(bootClassPath);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -63,1 +64,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n@@ -65,1 +65,1 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -67,1 +67,1 @@\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass\/Launcher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -66,1 +67,0 @@\n-        ProcessBuilder pb = new ProcessBuilder(jar.getCommand());\n@@ -68,1 +68,1 @@\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            OutputAnalyzer output = ProcessTools.executeProcess(jar.getCommand());\n@@ -70,1 +70,1 @@\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass_classloaders\/Launcher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    ProcessBuilder pb = GCArguments.createLimitedTestJavaProcessBuilder(\n+    ProcessBuilder pb = GCArguments.createTestJavaProcessBuilder(\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestArrayAllocatorMallocLimit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This runs the os related gtests on Windows with all processor groups enabled.\n+ *\/\n+\n+\/* @test id=use-all-windows-processor-groups\n+ * @summary Run gtests with all Windows processor groups enabled\n+ * @library \/test\/lib\n+ * @requires os.family == \"windows\"\n+ * @run main\/native GTestWrapper --gtest_filter=os* -XX:+UseAllWindowsProcessorGroups\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/WindowsProcessorGroups.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @test\n+ * @test VMOptionWarningExperimental\n@@ -27,1 +27,1 @@\n- * @summary Warn if diagnostic or experimental vm option is used and -XX:+UnlockDiagnosticVMOptions or -XX:+UnlockExperimentalVMOptions, respectively, isn't specified. Warn if develop or notproduct vm option is used with product version of VM.\n+ * @summary Warn if experimental vm option is used and -XX:+UnlockExperimentalVMOptions isn't specified.\n@@ -29,0 +29,1 @@\n+ * @requires ! vm.opt.final.UnlockExperimentalVMOptions\n@@ -32,1 +33,23 @@\n- * @run driver VMOptionWarning\n+ * @run driver VMOptionWarning Experimental\n+ *\/\n+\n+\/* @test VMOptionWarningDiagnostic\n+ * @bug 8027314\n+ * @summary Warn if diagnostic vm option is used and -XX:+UnlockDiagnosticVMOptions isn't specified.\n+ * @requires vm.flagless\n+ * @requires ! vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver VMOptionWarning Diagnostic\n+ *\/\n+\n+\/* @test VMOptionWarningDevelop\n+ * @bug 8027314\n+ * @summary Warn if develop or notproduct vm option is used with product version of VM.\n+ * @requires vm.flagless\n+ * @requires ! vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver VMOptionWarning Develop\n@@ -41,8 +64,2 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+AlwaysSafeConstructors\", \"-version\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"Error: VM option 'AlwaysSafeConstructors' is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions.\");\n-\n-        if (Platform.isDebugBuild()) {\n-            System.out.println(\"Skip the rest of the tests on debug builds since diagnostic, develop, and notproduct options are available on debug builds.\");\n-            return;\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"wrong number of args: \" + args.length);\n@@ -51,4 +68,22 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+PrintInlining\", \"-version\");\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"Error: VM option 'PrintInlining' is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions.\");\n+        ProcessBuilder pb;\n+        OutputAnalyzer output;\n+        switch (args[0]) {\n+            case \"Experimental\": {\n+                pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+AlwaysSafeConstructors\", \"-version\");\n+                output = new OutputAnalyzer(pb.start());\n+                output.shouldNotHaveExitValue(0);\n+                output.shouldContain(\"Error: VM option 'AlwaysSafeConstructors' is experimental and must be enabled via -XX:+UnlockExperimentalVMOptions.\");\n+                break;\n+            }\n+            case \"Diagnostic\": {\n+                pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+PrintInlining\", \"-version\");\n+                output = new OutputAnalyzer(pb.start());\n+                output.shouldNotHaveExitValue(0);\n+                output.shouldContain(\"Error: VM option 'PrintInlining' is diagnostic and must be enabled via -XX:+UnlockDiagnosticVMOptions.\");\n+                break;\n+            }\n+            case \"Develop\": {\n+                pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+VerifyStack\", \"-version\");\n+                output = new OutputAnalyzer(pb.start());\n+                output.shouldNotHaveExitValue(0);\n+                output.shouldContain(\"Error: VM option 'VerifyStack' is develop and is available only in debug version of VM.\");\n@@ -56,9 +91,10 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+VerifyStack\", \"-version\");\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"Error: VM option 'VerifyStack' is develop and is available only in debug version of VM.\");\n-\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+CheckCompressedOops\", \"-version\");\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"Error: VM option 'CheckCompressedOops' is notproduct and is available only in debug version of VM.\");\n+                pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+CheckCompressedOops\", \"-version\");\n+                output = new OutputAnalyzer(pb.start());\n+                output.shouldNotHaveExitValue(0);\n+                output.shouldContain(\"Error: VM option 'CheckCompressedOops' is notproduct and is available only in debug version of VM.\");\n+                break;\n+            }\n+            default: {\n+                throw new RuntimeException(\"Invalid argument: \" + args[0]);\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMOptionWarning.java","additions":60,"deletions":24,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires vm.cds\n+ * @requires vm.cds & vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n@@ -40,0 +41,2 @@\n+    static Object[] oa;\n+\n@@ -45,1 +48,1 @@\n-                Object[] oa = new Object[Integer.MAX_VALUE];\n+                oa = new Object[Integer.MAX_VALUE];\n@@ -53,3 +56,3 @@\n-                                                                             \"-XX:-CreateCoredumpOnCrash\", \"-Xmx128m\",\n-                                                                             \"-Xshare:on\", TestCDSVMCrash.class.getName(),\n-                                                                             \"throwOOME\");\n+                                                                      \"-XX:-CreateCoredumpOnCrash\", \"-Xmx128m\",\n+                                                                      \"-Xshare:on\", TestCDSVMCrash.class.getName(),\n+                                                                      \"throwOOME\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/TestCDSVMCrash.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/FillerObjectLoadTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestDumpClassListSource.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=static\n+ * @summary Run JavacBenchApp with the classic static archive workflow\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver JavacBench STATIC\n+ *\/\n+\n+\/*\n+ * @test id=dynamic\n+ * @summary Run JavacBenchApp with the classic dynamic archive workflow\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver JavacBench DYNAMIC\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class JavacBench {\n+    static String mainClass = JavacBenchApp.class.getName();\n+    static String appJar;\n+\n+    public static void main(String args[]) throws Exception {\n+        appJar = ClassFileInstaller.writeJar(\"JavacBenchApp.jar\",\n+                                             \"JavacBenchApp\",\n+                                             \"JavacBenchApp$ClassFile\",\n+                                             \"JavacBenchApp$FileManager\",\n+                                             \"JavacBenchApp$SourceFile\");\n+        JavacBenchTester tester = new JavacBenchTester();\n+        tester.run(args);\n+    }\n+\n+    static class JavacBenchTester extends CDSAppTester {\n+        public JavacBenchTester() {\n+            super(\"JavacBench\");\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                \"90\",\n+            };\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/applications\/JavacBench.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+\/**\n+ * This program tries to compile a large number of classes that exercise a fair amount of\n+ * features in javac.\n+ *\/\n+public class JavacBenchApp {\n+    static class ClassFile extends SimpleJavaFileObject {\n+        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        protected ClassFile(String name) {\n+            super(URI.create(\"memo:\/\/\/\" + name.replace('.', '\/') + Kind.CLASS.extension), Kind.CLASS);\n+        }\n+        @Override\n+        public ByteArrayOutputStream openOutputStream() {\n+            return this.baos;\n+        }\n+        byte[] toByteArray() {\n+            return baos.toByteArray();\n+        }\n+    }\n+\n+    static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+        private Map<String, ClassFile> classesMap = new HashMap<String, ClassFile>();\n+        protected FileManager(JavaFileManager fileManager) {\n+            super(fileManager);\n+        }\n+        @Override\n+        public ClassFile getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) {\n+            ClassFile classFile = new ClassFile(name);\n+            classesMap.put(name, classFile);\n+            return classFile;\n+        }\n+        public Map<String, byte[]> getCompiledClasses() {\n+            Map<String, byte[]> result = new HashMap<>();\n+            for (Map.Entry<String, ClassFile> entry : classesMap.entrySet()) {\n+                result.put(entry.getKey(), entry.getValue().toByteArray());\n+            }\n+            return result;\n+        }\n+    }\n+\n+    static class SourceFile extends SimpleJavaFileObject {\n+        private CharSequence sourceCode;\n+        public SourceFile(String name, CharSequence sourceCode) {\n+            super(URI.create(\"memo:\/\/\/\" + name.replace('.', '\/') + Kind.SOURCE.extension), Kind.SOURCE);\n+            this.sourceCode = sourceCode;\n+        }\n+        @Override\n+        public CharSequence getCharContent(boolean ignore) {\n+            return this.sourceCode;\n+        }\n+    }\n+\n+    public Map<String, byte[]> compile() {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        DiagnosticCollector<JavaFileObject> ds = new DiagnosticCollector<>();\n+        Collection<SourceFile> sourceFiles = sources;\n+\n+        try (FileManager fileManager = new FileManager(compiler.getStandardFileManager(ds, null, null))) {\n+            JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, null, null, sourceFiles);\n+            if (task.call()) {\n+                return fileManager.getCompiledClasses();\n+            } else {\n+                for (Diagnostic<? extends JavaFileObject> d : ds.getDiagnostics()) {\n+                    System.out.format(\"Line: %d, %s in %s\", d.getLineNumber(), d.getMessage(null), d.getSource().getName());\n+                }\n+                throw new InternalError(\"compilation failure\");\n+            }\n+        } catch (IOException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    List<SourceFile> sources;\n+\n+    static final String imports = \"\"\"\n+        import java.lang.*;\n+        import java.util.*;\n+        \"\"\";\n+\n+    static final String testClassBody = \"\"\"\n+        \/\/ Some comments\n+        static long x;\n+        static final long y;\n+        static {\n+            y = System.currentTimeMillis();\n+        }\n+        \/* More comments *\/\n+        @Deprecated\n+        String func() { return \"String \" + this + y; }\n+        public static void main(String args[]) {\n+            try {\n+                x = Long.parseLong(args[0]);\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+            }\n+            doit(() -> {\n+                System.out.println(\"Hello Lambda\");\n+                Thread.dumpStack();\n+            });\n+        }\n+        static List<String> list = List.of(\"1\", \"2\");\n+        class InnerClass1 {\n+            static final long yy = y;\n+        }\n+        static void doit(Runnable r) {\n+            for (var x : list) {\n+                r.run();\n+            }\n+        }\n+        static String patternMatch(String arg, Object o) {\n+            if (o instanceof String s) {\n+                return \"1234\";\n+            }\n+            final String b = \"B\";\n+            return switch (arg) {\n+                case \"A\" -> \"a\";\n+                case b   -> \"b\";\n+                default  -> \"c\";\n+            };\n+        }\n+        public sealed class SealedInnerClass {}\n+        public final class Foo extends SealedInnerClass {}\n+        enum Expression {\n+            ADDITION,\n+            SUBTRACTION,\n+            MULTIPLICATION,\n+            DIVISION\n+        }\n+        public record Point(int x, int y) {\n+            public Point(int x) {\n+                this(x, 0);\n+            }\n+        }\n+        \"\"\";\n+\n+    String sanitySource = \"\"\"\n+        public class Sanity implements java.util.concurrent.Callable<String> {\n+            public String call() {\n+                return \"this is a test\";\n+            }\n+        }\n+        \"\"\";\n+\n+    void setup(int count) {\n+        sources = new ArrayList<>(count);\n+        for (int i = 0; i < count; i++) {\n+            String source = imports + \"public class Test\" + i + \" {\" + testClassBody + \"}\";\n+            sources.add(new SourceFile(\"Test\" + i, source));\n+        }\n+\n+        sources.add(new SourceFile(\"Sanity\", sanitySource));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static void validate(byte[] sanityClassFile) throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Class<?> cls = lookup.defineClass(sanityClassFile);\n+        Callable<String> obj = (Callable<String>)cls.getDeclaredConstructor().newInstance();\n+        String s = obj.call();\n+        if (!s.equals(\"this is a test\")) {\n+            throw new RuntimeException(\"Expected \\\"this is a test\\\", but got \\\"\" + s + \"\\\"\");\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Throwable {\n+        long started = System.currentTimeMillis();\n+        JavacBenchApp bench = new JavacBenchApp();\n+\n+        int count = 0;\n+        if (args.length > 0) {\n+            count = Integer.parseInt(args[0]);\n+            if (count >= 0) {\n+                bench.setup(count);\n+                Map<String, byte[]> allClasses = bench.compile();\n+                validate(allClasses.get(\"Sanity\"));\n+            }\n+        }\n+        if (System.getProperty(\"JavacBenchApp.silent\") == null) {\n+            \/\/ Set this property when running with \"perf stat\", etc\n+            long elapsed = System.currentTimeMillis() - started;\n+            System.out.println(\"Generated source code for \" + bench.sources.size() + \" classes and compiled them in \" + elapsed + \" ms\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/applications\/JavacBenchApp.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n- * @run driver TestAutoCreateSharedArchiveUpgrade\n+ * @run driver\/timeout=600 TestAutoCreateSharedArchiveUpgrade\n@@ -55,1 +55,1 @@\n-    \/\/ If you're unning this test using something like\n+    \/\/ If you're running this test using something like\n@@ -106,0 +106,2 @@\n+        \/\/ Version 0 is used here to indicate that no version is supplied so that\n+        \/\/ PREV_JDK or BOOT_JDK are used\n@@ -108,0 +110,2 @@\n+        } else if (fetchVersion > 0) {\n+            throw new RuntimeException(\"Unsupported JDK version \" + fetchVersion);\n@@ -190,0 +194,3 @@\n+            case 21:\n+                build = 35;\n+                break;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestAutoCreateSharedArchiveUpgrade.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/ResolvedReferencesNotNullTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ *\/\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/Bad_NCDFE_Msg.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsr\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        return;\n+    LABEL:\n+        nop;\n+        jsr LABEL; \/\/ bci=2. Compute bci + length(jsr) -> bci = 5 accessed, out of bounds.\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsr.jasm","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsrReachable\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        goto LB2;\n+    LABEL:\n+        return;\n+    LB2:\n+        nop;\n+        jsr LABEL;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrReachable.jasm","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335664 8338924\n+ * @summary Ensure a program that ends with a JSR does not crash\n+ * @library \/test\/lib\n+ * @compile LastJsr.jasm\n+ * @compile LastJsrReachable.jasm\n+ * @run main\/othervm -Xbatch LastJsrTest\n+ *\/\n+\n+public class LastJsrTest {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 1000; ++i) {\n+            LastJsr.test();\n+            LastJsrReachable.test();\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,3 @@\n+        String classPath = System.getProperty(\"test.class.path\", \".\");\n+\n+        \/\/ Sub-process does not get all the properties automatically, so the test class path needs to be passed explicitly\n@@ -76,1 +79,1 @@\n-                           \"-XX:+WhiteBoxAPI\", \"-XX:+ClassUnloading\", ClassUnloadTestMain.class.getName());\n+                           \"-XX:+WhiteBoxAPI\", \"-XX:+ClassUnloading\", \"-Dtest.class.path=\" + classPath, ClassUnloadTestMain.class.getName());\n@@ -89,1 +92,1 @@\n-        checkFor(output, \"[class,unload]\", \"unloading class\");\n+        checkFor(output, \"[class,unload]\", \"unloading class test.Empty\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ClassLoadUnloadTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -54,0 +55,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -66,0 +68,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -78,0 +81,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -90,0 +94,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -251,6 +256,0 @@\n-        \/\/ For similar reasons, we skip the test on ppc platforms, since there the smaps\n-        \/\/  format may follow a different logic.\n-        if (Platform.isPPC()) {\n-            throw new SkippedException(\"PPC - skipping this test.\");\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public class GetAvailableProcessors {\n+  public static void main(String[] args) {\n+    System.out.println(\"Runtime.availableProcessors: \" + Runtime.getRuntime().availableProcessors());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/GetAvailableProcessors.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6942632\n+ * @requires os.family == \"windows\"\n+ * @summary This test verifies that OpenJDK can use all available\n+ *          processors on Windows 11\/Windows Server 2022 and later.\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @compile GetAvailableProcessors.java\n+ * @run testng TestAvailableProcessors\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestAvailableProcessors {\n+\n+    private static final String totalProcessorCountMessage = \"Active processor count across all processor groups: \";\n+    private static final String processorCountPerGroupMessage = \"Active processors per group: \";\n+    private static final String isWindowsServerMessage = \"IsWindowsServer: \";\n+\n+    private static final String runtimeAvailableProcessorsMessage = \"Runtime.availableProcessors: \";\n+    private static final String osVersionMessage = \"OS Version: \";\n+    private static final String unsupportedPlatformMessage = \"The UseAllWindowsProcessorGroups flag is not supported on this Windows version and will be ignored.\";\n+\n+    private static String getWindowsVersion() throws IOException {\n+        String systeminfoPath = \"systeminfo.exe\";\n+\n+        var processBuilder = new ProcessBuilder(systeminfoPath);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(processBuilder.start());\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        outputAnalyzer.shouldContain(osVersionMessage);\n+        List<String> lines = outputAnalyzer.stdoutAsLines();\n+\n+        String osVersion = null;\n+        for (var line: lines) {\n+            if (line.startsWith(osVersionMessage)) {\n+                osVersion = line.substring(osVersionMessage.length()).trim();\n+                break;\n+            }\n+        }\n+\n+        System.out.println(\"Found OS version: \" + osVersion);\n+        return osVersion;\n+    }\n+\n+    private static boolean getSchedulesAllProcessorGroups(boolean isWindowsServer) throws IOException {\n+        String windowsVer = getWindowsVersion();\n+        String[] parts = windowsVer.split(\" \");\n+        String[] versionParts = parts[0].split(\"\\\\.\");\n+\n+        if (versionParts.length != 3) {\n+            throw new RuntimeException(\"Unexpected Windows version format.\");\n+        }\n+\n+        int major = Integer.parseInt(versionParts[0]);\n+        int minor = Integer.parseInt(versionParts[1]);\n+        int build = Integer.parseInt(versionParts[2]);\n+\n+        if (major > 10) {\n+            return true;\n+        }\n+\n+        if (major < 10) {\n+            return false;\n+        }\n+\n+        if (minor > 0) {\n+            return true;\n+        }\n+\n+        if (isWindowsServer) {\n+            return build >= 20348;\n+        } else {\n+            return build >= 22000;\n+        }\n+    }\n+\n+    private static OutputAnalyzer getAvailableProcessorsOutput(boolean productFlagEnabled) throws IOException {\n+        String productFlag = productFlagEnabled ? \"-XX:+UseAllWindowsProcessorGroups\" : \"-XX:-UseAllWindowsProcessorGroups\";\n+\n+        ProcessBuilder processBuilder = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            new String[] {productFlag, \"GetAvailableProcessors\"}\n+        );\n+\n+        var output = new OutputAnalyzer(processBuilder.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(runtimeAvailableProcessorsMessage);\n+\n+        return output;\n+    }\n+\n+    private static int getAvailableProcessors(OutputAnalyzer outputAnalyzer) {\n+        int runtimeAvailableProcs = 0;\n+        List<String> output = outputAnalyzer.stdoutAsLines();\n+\n+        for (var line: output) {\n+            if (line.startsWith(runtimeAvailableProcessorsMessage)) {\n+                String runtimeAvailableProcsStr = line.substring(runtimeAvailableProcessorsMessage.length());\n+                runtimeAvailableProcs = Integer.parseInt(runtimeAvailableProcsStr);\n+            }\n+        }\n+\n+        return runtimeAvailableProcs;\n+    }\n+\n+    private static int getAvailableProcessors(boolean productFlagEnabled) throws IOException {\n+        OutputAnalyzer outputAnalyzer = getAvailableProcessorsOutput(productFlagEnabled);\n+        return getAvailableProcessors(outputAnalyzer);\n+    }\n+\n+    private static void verifyAvailableProcessorsWithDisabledProductFlag(Set<Integer> processorGroupSizes) throws IOException {\n+        boolean productFlagEnabled = false;\n+        int runtimeAvailableProcs = getAvailableProcessors(productFlagEnabled);\n+\n+        String error = String.format(\"Runtime.availableProcessors (%d) is not a valid processor group size on this machine.\", runtimeAvailableProcs);\n+        Assert.assertTrue(processorGroupSizes.contains(runtimeAvailableProcs), error);\n+    }\n+\n+    private static void verifyAvailableProcessorsWithEnabledProductFlag(boolean schedulesAllProcessorGroups, int totalProcessorCount, Set<Integer> processorGroupSizes) throws IOException {\n+        boolean productFlagEnabled = true;\n+\n+        OutputAnalyzer outputAnalyzer = getAvailableProcessorsOutput(productFlagEnabled);\n+        int runtimeAvailableProcs = getAvailableProcessors(outputAnalyzer);\n+\n+        if (schedulesAllProcessorGroups) {\n+            String error = String.format(\"Runtime.availableProcessors (%d) is not equal to the expected total processor count (%d)\", runtimeAvailableProcs, totalProcessorCount);\n+            Assert.assertEquals(runtimeAvailableProcs, totalProcessorCount, error);\n+        } else {\n+            outputAnalyzer.shouldContain(unsupportedPlatformMessage);\n+\n+            String error = String.format(\"Runtime.availableProcessors (%d) is not a valid processor group size on this machine.\", runtimeAvailableProcs);\n+            Assert.assertTrue(processorGroupSizes.contains(runtimeAvailableProcs), error);\n+        }\n+    }\n+\n+    @Test\n+    private static void testProcessorAvailability() throws IOException {\n+        \/\/ Launch GetProcessorInfo.exe to gather processor counts\n+        Path nativeGetProcessorInfo = Paths.get(Utils.TEST_NATIVE_PATH)\n+            .resolve(\"GetProcessorInfo.exe\")\n+            .toAbsolutePath();\n+\n+        var processBuilder = new ProcessBuilder(nativeGetProcessorInfo.toString());\n+        var outputAnalyzer= new OutputAnalyzer(processBuilder.start());\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        outputAnalyzer.shouldContain(totalProcessorCountMessage);\n+        outputAnalyzer.shouldContain(processorCountPerGroupMessage);\n+        outputAnalyzer.shouldContain(isWindowsServerMessage);\n+\n+        int totalProcessorCount = 0;\n+        boolean isWindowsServer = false;\n+        var processorGroupSizes = new HashSet<Integer>();\n+\n+        List<String> lines = outputAnalyzer.stdoutAsLines();\n+\n+        for (var line: lines) {\n+            if (line.startsWith(totalProcessorCountMessage)) {\n+                String totalProcessorCountStr = line.substring(totalProcessorCountMessage.length());\n+                totalProcessorCount = Integer.parseInt(totalProcessorCountStr);\n+            } else if (line.startsWith(processorCountPerGroupMessage)) {\n+                String processorCountPerGroupStr = line.substring(processorCountPerGroupMessage.length());\n+                String[] processorCountsPerGroup = processorCountPerGroupStr.split(\",\");\n+\n+                for (var processorCountStr: processorCountsPerGroup) {\n+                    int processorCount = Integer.parseInt(processorCountStr);\n+                    processorGroupSizes.add(processorCount);\n+                }\n+            } else if (line.startsWith(isWindowsServerMessage)) {\n+                String isWindowsServerStr = line.substring(isWindowsServerMessage.length());\n+                isWindowsServer = Integer.parseInt(isWindowsServerStr) > 0;\n+            }\n+        }\n+\n+        \/\/ Launch java without the start command and with the product flag disabled\n+        verifyAvailableProcessorsWithDisabledProductFlag(processorGroupSizes);\n+\n+        \/\/ Launch java without the start command and with the product flag enabled\n+        boolean schedulesAllProcessorGroups = getSchedulesAllProcessorGroups(isWindowsServer);\n+        verifyAvailableProcessorsWithEnabledProductFlag(schedulesAllProcessorGroups, totalProcessorCount, processorGroupSizes);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/TestAvailableProcessors.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <Windows.h>\n+#include <malloc.h>\n+#include <versionhelpers.h>\n+#include <stdio.h>\n+\n+int main()\n+{\n+  DWORD active_processor_count = GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n+  if (active_processor_count == 0) {\n+    printf(\"GetActiveProcessorCount failed with error: %x\\n\", GetLastError());\n+    return 1;\n+  }\n+\n+  printf(\"IsWindowsServer: %d\\n\", IsWindowsServer() ? 1 : 0);\n+  printf(\"Active processor count across all processor groups: %d\\n\", active_processor_count);\n+\n+  USHORT group_count = 0;\n+\n+  if (GetProcessGroupAffinity(GetCurrentProcess(), &group_count, NULL) == 0) {\n+    DWORD last_error = GetLastError();\n+    if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+      if (group_count == 0) {\n+        printf(\"Unexpected group count of 0 from GetProcessGroupAffinity.\\n\");\n+        return 1;\n+      }\n+    } else {\n+      printf(\"GetActiveProcessorCount failed with error: %x\\n\", GetLastError());\n+      return 1;\n+    }\n+  } else {\n+    printf(\"Unexpected GetProcessGroupAffinity success result.\\n\");\n+    return 1;\n+  }\n+\n+  PUSHORT group_array = (PUSHORT)malloc(group_count * sizeof(USHORT));\n+  if (group_array == NULL) {\n+    printf(\"malloc failed.\\n\");\n+    return 1;\n+  }\n+\n+  printf(\"Active processors per group: \");\n+  for (USHORT i=0; i < group_count; i++) {\n+    DWORD active_processors_in_group = GetActiveProcessorCount(i);\n+    if (active_processors_in_group == 0) {\n+      printf(\"GetActiveProcessorCount(%d) failed with error: %x\\n\", i, GetLastError());\n+      return 1;\n+    }\n+\n+    printf(\"%d,\", active_processors_in_group);\n+  }\n+\n+  free(group_array);\n+  return 0;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/exeGetProcessorInfo.c","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack001.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     Provoke StackOverflowError by infinite recursion in Java method,\n+ *     intercept the exception try to make one more invocation.\n+ * COMMENTS\n+ *     Kestrel for Solaris_JDK_1.3-b10 crashes while trying to execute\n+ *     this test with Client HS VM.\n+ *     See lots of bugs concerning similar failures:\n+ *     Evaluated:\n+ *     4217960 [native stack overflow bug] reflection test causes crash\n+ *     Accepted:\n+ *     4285716 native stack overflow causes crash on Solaris\n+ *     4281578 Second stack overflow crashes HotSpot VM\n+ *     Closed (duplicate):\n+ *     4027933     Native stack overflows not detected or handled correctly\n+ *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n+ *     4185411     Various crashes when using recursive reflection.\n+ *     4167055     infinite recursion in FindClass\n+ *     4222359     Infinite recursion crashes jvm\n+ *     Closed (will not fix):\n+ *     4231968 StackOverflowError in a native method causes Segmentation Fault\n+ *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n+ *     4302288 the second stack overflow causes Classic VM to exit on win32\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack001\n+ *\/\n+\n+public class Stack001 {\n+    public static void main(String[] args) {\n+        Stack001 test = new Stack001();\n+        test.recurse(0);\n+        System.out.println(\"Maximal depth: \" + test.maxdepth);\n+    }\n+\n+    private int maxdepth;\n+\n+    private void recurse(int depth) {\n+        maxdepth = depth;\n+        try {\n+            recurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError e) {\n+            if (maxdepth == depth) {\n+                recurse(depth + 1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack001.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack002.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     Provoke StackOverflowError by infinite recursion in Java method,\n+ *     intercept the exception and continue to invoke that method until\n+ *     the test exceeds timeout, or until Java VM crashes.\n+ * COMMENTS\n+ *     I believe that the test causes HS crashes due to the following bug:\n+ *     4330318 (P2\/S2) NSK test fails as An irrecoverable stack overflow\n+ *     See also bugs (lots of bugs!):\n+ *     Evaluated:\n+ *     4217960 [native stack overflow bug] reflection test causes crash\n+ *     Accepted:\n+ *     4285716 native stack overflow causes crash on Solaris\n+ *     4281578 Second stack overflow crashes HotSpot VM\n+ *     Closed (duplicate):\n+ *     4027933     Native stack overflows not detected or handled correctly\n+ *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n+ *     4185411     Various crashes when using recursive reflection.\n+ *     4167055     infinite recursion in FindClass\n+ *     4222359     Infinite recursion crashes jvm\n+ *     Closed (will not fix):\n+ *     4231968 StackOverflowError in a native method causes Segmentation Fault\n+ *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n+ *     4302288 the second stack overflow causes Classic VM to exit on win32\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack002\n+ *\/\n+\n+public class Stack002 {\n+    static final long timeout = 10000; \/\/ 10 seconds\n+\n+    public static void main(String[] args) {\n+        Tester tester = new Tester();\n+        Timer timer = new Timer(tester);\n+        timer.start();\n+        tester.start();\n+        while (timer.isAlive()) {\n+            try {\n+                timer.join();\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        System.out.println(\"Maximal depth: \" + tester.maxdepth);\n+    }\n+\n+    private static class Tester extends Thread {\n+        int maxdepth;\n+        public volatile boolean stop;\n+\n+        public Tester() {\n+            maxdepth = 0;\n+            stop = false;\n+        }\n+\n+        public void run() {\n+            recurse(0);\n+        }\n+\n+        void recurse(int depth) {\n+            maxdepth = depth;\n+            try {\n+                if (stop) {\n+                    return;\n+                }\n+                recurse(depth + 1);\n+            } catch (StackOverflowError | OutOfMemoryError e) {\n+                recurse(depth + 1);\n+            }\n+        }\n+    }\n+\n+    private static class Timer extends Thread {\n+        private Tester tester;\n+\n+        public Timer(Tester tester) {\n+            this.tester = tester;\n+        }\n+\n+        public void run() {\n+            long started;\n+            started = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - started < timeout) {\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                    return;\n+                };\n+            }\n+            tester.stop = true;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack002.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack003.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking static recursive method for the given fixed depth\n+ *     of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack003\n+ *\/\n+\n+public class Stack003 {\n+    final static int ITERATIONS = 100;\n+    final static int INCREMENT = 100;\n+\n+    public static void main(String[] args) {\n+\n+        int depth;\n+        for (depth = 1; ; depth += INCREMENT) {\n+            try {\n+                recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            try {\n+                recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack003.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack004.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking final static recursive method for the given fixed\n+ *     depth of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack004\n+ *\/\n+\n+public class Stack004 {\n+    public static void main(String[] args) {\n+        Stack004 test = new Stack004();\n+        test.doRun();\n+    }\n+\n+    public void doRun() {\n+        int depth;\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    final static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack004.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack005.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking final recursive method for the given fixed depth of\n+ *     recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack005\n+ *\/\n+\n+public class Stack005 {\n+    public static void main(String[] args) {\n+        Stack005 test = new Stack005();\n+        int depth;\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                test.recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError soe) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                test.recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    final void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack005.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack006.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking virtual recursive method for the given fixed depth\n+ *     of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack006\n+ *\/\n+\n+public class Stack006 implements Stack006i {\n+    public static void main(String[] args) {\n+        Stack006i test = new Stack006();\n+        int depth;\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                test.recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                test.recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    public void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+interface Stack006i {\n+    void recurse(int depth);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack006.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack007.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking synchronized virtual recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 10000 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is 10 times that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes HS versions 1.3 and 1.4 on Win32, Solaris,\n+ *     and Linux platforms in all execution modes. However, it passes\n+ *     against HS 2.0 on Win32 platform.\n+ *     See also the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack007\n+ *\/\n+\n+public class Stack007 implements Stack007i {\n+    final static int ITERATIONS = 1000;\n+    final static int INCREMENT = 100;\n+\n+    public static void main(String[] args) {\n+        Stack007i test = new Stack007();\n+        int depth;\n+        for (depth = 100; ; depth += INCREMENT) {\n+            try {\n+                test.recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            try {\n+                test.recurse(10 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    public synchronized void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+interface Stack007i {\n+    void recurse(int depth);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack007.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack008.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invocations via reflection. Recursive method is invoked for\n+ *     the given fixed depth of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on Solaris,\n+ *     and crashes HS 2.0 on win32. However, it passes against HS 1.3\n+ *     and 1.4 on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *     The stack size is too small to run on systems with > 4K page size.\n+ *     Making it bigger could cause timeouts on other platform.\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss200K Stack008\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public class Stack008 {\n+    public static void main(String[] args) {\n+        int depth;\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                invokeRecurse(depth);\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    break; \/\/ OK.\n+                target.printStackTrace();\n+                throw new RuntimeException(exception);\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        \/\/\n+        \/\/ Provoke stack overflow multiple times:\n+        \/\/\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                invokeRecurse(2 * depth);\n+\/\/              System.out.println(\"?\");\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    continue; \/\/ OK.\n+                target.printStackTrace();\n+                throw new RuntimeException(exception);\n+            }\n+        }\n+    }\n+\n+    private static Throwable getTargetException(Throwable exception) {\n+        Throwable target;\n+        \/\/\n+        \/\/ Unwrap deep chain of exceptions:\n+        \/\/\n+        for (\n+                target = exception;\n+                target instanceof InvocationTargetException;\n+                target = ((InvocationTargetException) target).getTargetException()\n+                )\n+            ;\n+        return target;\n+    }\n+\n+    static Method method = null;\n+    static Stack008 instance = null;\n+    static Object params[] = null;\n+\n+    private static void invokeRecurse(int depth) throws Exception {\n+        if (method == null) {\n+            \/\/\n+            \/\/ Optimization trick: allocate once, use everywhere.\n+            \/\/\n+            instance = new Stack008();\n+            method = Stack008.class.getMethod(\"recurse\");\n+            params = new Object[]{};\n+        }\n+        \/\/\n+        \/\/ Note, that the same instance.depth is used in all invocations:\n+        \/\/\n+        instance.depth = depth;\n+        method.invoke(instance, params);\n+    }\n+\n+    int depth = 0;\n+\n+    public void recurse() throws Exception {\n+        if (depth > 0) {\n+            \/\/\n+            \/\/ Self-invoke via reflection:\n+            \/\/\n+            invokeRecurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack008.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack009.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test provokes second stack overflow from within the\n+ *     stack overflow handler.\n+ *     This test measures a number of recursive invocations until\n+ *     StackOverflowError, and then tries to make an invocation\n+ *     for the fixed invocations depth from within the \"catch\"\n+ *     block just caught the 1st stack overflow. The depth of new\n+ *     invocations is 10 times that depth seen at the 1st stack\n+ *     overflow; so that another stack overflow occurs.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if there is no exception thrown other than due to stack\n+ *     overflow.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on Win32\n+ *     and Solaris platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack009\n+ *\/\n+\n+public class Stack009 {\n+    public static void main(String[] args) {\n+        for (int depth = 100; ; depth += 100) {\n+            try {\n+                recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError error1) {\n+\n+                System.out.println(\"Max. depth: \" + depth);\n+\n+                try {\n+                    recurse(10 * depth);\n+                    System.out.println(\"?\");\n+                } catch (StackOverflowError | OutOfMemoryError error2) {\n+                    \/\/ ignore\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack009.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack010.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking static recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n+ *     platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack010\n+ *\/\n+\n+public class Stack010 extends Thread {\n+    final static int THREADS = 1;\n+    final static int CYCLES = 1;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack010 threads[] = new Stack010[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack010();\n+            threads[i].depthToTry = 100 * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were not thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    int depthToTry = 0;\n+    Throwable thrown = null;\n+\n+    public void run() {\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                System.out.println(\"depth = \" +depthToTry);\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+\n+    static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack010.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack011.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking final static recursive method for the\n+ *     given fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n+ *     platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack011\n+ *\/\n+\n+public class Stack011 extends Thread {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError soe) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack011 threads[] = new Stack011[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack011();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were not thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    int depthToTry = 0;\n+    Throwable thrown = null;\n+\n+    public void run() {\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+\n+    final static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack011.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack012.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking final recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 1.3, 1.4 on Win32, and HS versions\n+ *     2.0, 1.3, and 1.4 on Solaris. However, it passes against HS 2.0\n+ *     on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack012\n+ *\/\n+\n+public class Stack012 extends Thread {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        Stack012 test = new Stack012();\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack012 threads[] = new Stack012[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack012();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were not thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    int depthToTry = 0;\n+    Throwable thrown = null;\n+\n+    public void run() {\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                this.recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+\n+    final void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack012.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack013.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking virtual recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both Win32\n+ *     and Solaris platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack013\n+ *\/\n+\n+public class Stack013 extends Stack013i {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        Stack013i test = new Stack013();\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack013i threads[] = new Stack013i[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack013();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].cycles = CYCLES;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+abstract class Stack013i extends Thread {\n+    \/\/\n+    \/\/ Pure virtual method:\n+    \/\/\n+    abstract void recurse(int depth);\n+\n+    Throwable thrown = null;\n+    int depthToTry;\n+    int cycles;\n+\n+    public void run() {\n+        \/\/\n+        \/\/ Provoke multiple stack overflows:\n+        \/\/\n+        for (int i = 0; i < cycles; i++) {\n+            try {\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack013.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack014.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking synchronized virtual recursive method\n+ *     for the given fixed depth of recursion (though, for a large\n+ *     depth). Note however, that different threads are not actual\n+ *     synchronized, because different instances having the recursive\n+ *     method are used.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n+ *     However, it passes against all these HS versions on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack014\n+ *\/\n+\n+public class Stack014 extends Stack014i {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        Stack014i test = new Stack014();\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack014i threads[] = new Stack014i[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack014();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].cycles = CYCLES;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    synchronized void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+abstract class Stack014i extends Thread {\n+    \/\/\n+    \/\/ Pure virtual method:\n+    \/\/\n+    abstract void recurse(int depth);\n+\n+    Throwable thrown = null;\n+    int depthToTry;\n+    int cycles;\n+\n+    public void run() {\n+        \/\/\n+        \/\/ Provoke multiple stack overflows:\n+        \/\/\n+        for (int i = 0; i < cycles; i++) {\n+            try {\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack014.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack015.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking synchronized virtual recursive method\n+ *     for the given fixed depth of recursion from within another\n+ *     recursive method already deeply invoked.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     in 10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n+ *     However, it passes against all these HS versions on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack015\n+ *\/\n+\n+public class Stack015 extends Stack015i {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+    final static int STEP = 10;\n+    final static int RESERVE = 10;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ The test will invoke the particular Stack015.recurse()\n+        \/\/ method via abstract test.recurse() invocations.\n+        \/\/\n+        Stack015i test = new Stack015();\n+        Stack015i.test = test;\n+\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 0; ; depth += STEP) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack015i threads[] = new Stack015i[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack015();\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    synchronized void syncRecurse(int depth) {\n+        if (depth > 0) {\n+            syncRecurse(depth - 1);\n+        }\n+    }\n+}\n+\n+abstract class Stack015i extends Thread {\n+    \/\/\n+    \/\/ Pure virtual method:\n+    \/\/\n+    abstract void syncRecurse(int depth);\n+\n+    void recurse(int depth) {\n+        \/\/\n+        \/\/ Stack overflow must occur here:\n+        \/\/\n+        syncRecurse(Stack015.STEP);\n+        \/\/\n+        \/\/ If no stack overflow occured, try again with deeper stack:\n+        \/\/\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+\n+    Throwable thrown = null;\n+    int depthToTry;\n+\n+    static Stack015i test;\n+\n+    public void run() {\n+        \/\/\n+        \/\/ Provoke multiple stack overflows:\n+        \/\/\n+        for (int i = 0; i < Stack015.CYCLES; i++) {\n+            try {\n+                \/\/\n+                \/\/ All threads invoke the same synchronized method:\n+                \/\/\n+                test.recurse(depthToTry);\n+\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack015.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack016.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test provokes second stack overflow from within the\n+ *     stack overflow handler -- repeatedly multiple times, and\n+ *     in multiple threads.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     in 10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before,\n+ *     and then trying to invoke that recursive method once again\n+ *     from within the catch clause just caught StackOverflowError.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\")\n+ * @run main\/othervm\/timeout=900 -Xint -Xss448K Stack016\n+ * @run main\/othervm\/timeout=900 -Xcomp -Xss448K Stack016\n+ * @run main\/othervm\/timeout=900 -Xcomp -XX:-TieredCompilation -Xss448K Stack016\n+ *\/\n+\n+public class Stack016 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int STEP = 10;\n+    private final static int RESERVE = 10;\n+    private final static int PROBES = STEP * RESERVE;\n+\n+    public static void main(String[] args) {\n+        Stack016 test = new Stack016();\n+        test.doRun();\n+    }\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (depthToTry = 0; ; depthToTry += STEP) {\n+            try {\n+                trickyRecurse(depthToTry);\n+                maxDepth = depthToTry;\n+            } catch (StackOverflowError | OutOfMemoryError ex) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack016 threads[] = new Stack016[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack016();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int stackTop = 0;\n+    private int depthToTry = 0;\n+    private Throwable thrown = null;\n+\n+    private void trickyRecurse(int depth) {\n+        stackTop = depthToTry - depth;\n+        if (depth > 0) {\n+            try {\n+                trickyRecurse(depth - 1);\n+            } catch (StackOverflowError | OutOfMemoryError error) {\n+                \/\/\n+                \/\/ Provoke more stack overflow,\n+                \/\/ if current stack is deep enough:\n+                \/\/\n+                if (depthToTry - depth < stackTop - PROBES)\n+                    throw error;\n+                recurse(depthToTry);\n+\n+                throw new Error(\"TEST_RFE: try deeper recursion!\");\n+            }\n+        }\n+    }\n+\n+    private static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++) {\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES +\n+                        \", depthToTry: \" + depthToTry);\n+                trickyRecurse(depthToTry);\n+                throw new Error(\n+                        \"TEST_BUG: trickyRecursion() must throw an error anyway!\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack016.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack017.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test invokes infinitely recursive method from within stack\n+ *     overflow handler  -- repeatedly multiple times, and in multiple\n+ *     threads.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss220K Stack017\n+ *\/\n+\n+public class Stack017 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int PROBES = 100;\n+\n+    public static void main(String[] args) {\n+        Stack017 test = new Stack017();\n+        test.doRun();\n+    }\n+\n+    private static int depthToTry;\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        try {\n+            recurse(0);\n+        } catch (StackOverflowError | OutOfMemoryError err) {\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+        depthToTry = maxDepth;\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack017 threads[] = new Stack017[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack017();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int maxDepth = 0;\n+\n+    private void recurse(int depth) {\n+        maxDepth = depth;\n+        recurse(depth + 1);\n+    }\n+\n+    private void trickyRecurse(int depth) {\n+        try {\n+            maxDepth = depth;\n+            trickyRecurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError error) {\n+            \/\/\n+            \/\/ Stack problem caught: provoke it again,\n+            \/\/ if current stack is enough deep:\n+            \/\/\n+            if (depth < depthToTry - PROBES)\n+                throw error;\n+            recurse(depth + 1);\n+        }\n+    }\n+\n+    private Throwable thrown = null;\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++)\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n+                trickyRecurse(0);\n+                throw new Exception(\n+                        \"TEST_BUG: stack overflow was expected!\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack017.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack018.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows by invocations via\n+ *     reflection -- repeatedly multiple times, and in multiple threads.\n+ *     Recursive method is invoked for the given fixed depth of recursion\n+ *     (though, for a large depth). The test measures a number of recursive\n+ *     invocations until stack overflow, and then tries to reproduce similar\n+ *     stack overflows 10 times in each of 10 threads -- each time by trying\n+ *     to invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is 100 times that crucial depth just measured).\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss220K Stack018\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public class Stack018 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int STEP = 100;\n+    private final static int RESERVE = 100;\n+\n+    public static void main(String[] args) {\n+        Stack018 test = new Stack018();\n+        test.doRun();\n+    }\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (depthToTry = 0; ; depthToTry += STEP) {\n+            try {\n+                invokeRecurse(depthToTry);\n+                maxDepth = depthToTry;\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    break; \/\/ OK.\n+                target.printStackTrace();\n+                throw new RuntimeException(exception);\n+            }\n+        }\n+\n+        if (maxDepth == 0) {\n+            \/\/ The depth STEP was enough to cause StackOverflowError or OutOfMemoryError.\n+            maxDepth = STEP;\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack018 threads[] = new Stack018[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack018();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        int exitCode = 0;\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                System.out.println(\"# \" + threads[i].getName()\n+                        + \": \" + threads[i].thrown);\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int depthToTry = 0;\n+    private Throwable thrown = null;\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++)\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n+                invokeRecurse(depthToTry);\n+                throw new Error(\"TEST_RFE: try deeper invocations!\");\n+\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    continue; \/\/ OK.\n+                thrown = target;\n+                break;\n+            }\n+    }\n+\n+    private static Throwable getTargetException(Throwable exception) {\n+        Throwable target;\n+        \/\/\n+        \/\/ Unwrap deep chain of exceptions to find StackOverflowError:\n+        \/\/\n+        for (\n+                target = exception;\n+                target instanceof InvocationTargetException;\n+                target = ((InvocationTargetException) target).getTargetException()\n+                )\n+            ;\n+        return target;\n+    }\n+\n+    private Method method = null;\n+    private Object params[] = null;\n+\n+    private void invokeRecurse(int depth) throws Exception {\n+        if (method == null) {\n+            \/\/\n+            \/\/ Optimization trick: allocate once, use everywhere.\n+            \/\/\n+            method = Stack018.class.getMethod(\"recurse\");\n+            params = new Object[]{};\n+        }\n+        this.depth = depth; \/\/ actual parameter\n+        method.invoke(this, params);\n+    }\n+\n+    private int depth = 0; \/\/ actual parameter for recurse()\n+\n+    public void recurse() throws Exception {\n+        if (depth > 0) {\n+            \/\/\n+            \/\/ Self-invoke via reflection:\n+            \/\/\n+            invokeRecurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack018.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack019.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test invokes infinitely recursive method from within stack\n+ *     overflow handler -- repeatedly multiple times in a single thread.\n+ *     The test is deemed passed, if VM have not crashed, and if exception\n+ *     other than due to stack overflow was not thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *     The stack size is too small to run on systems with > 4K page size.\n+ *     Making it bigger could cause timeouts on other platform.\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @requires os.family != \"windows\"\n+ * @run main\/othervm\/timeout=900 -Xss200K Stack019\n+ *\/\n+\n+public class Stack019 {\n+    private final static int CYCLES = 50;\n+    private final static int PROBES = 50;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        try {\n+            recurse(0);\n+        } catch (StackOverflowError | OutOfMemoryError err) {\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+        depthToTry = maxDepth;\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                System.out.println(\"Iteration: \" + i + \"\/\" + CYCLES);\n+                trickyRecurse(0);\n+                throw new RuntimeException(\"# TEST_BUG: stack overflow was expected!\");\n+            } catch (StackOverflowError | OutOfMemoryError error) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                throw new RuntimeException(throwable);\n+            }\n+        }\n+    }\n+\n+    private static int maxDepth;\n+    private static int depthToTry;\n+\n+    private static void recurse(int depth) {\n+        maxDepth = depth;\n+        recurse(depth + 1);\n+    }\n+\n+    private static void trickyRecurse(int depth) {\n+        try {\n+            maxDepth = depth;\n+            trickyRecurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError error){\n+            \/\/\n+            \/\/ Stack problem caught: provoke it again,\n+            \/\/ if current stack is enough deep:\n+            \/\/\n+            if (depth < depthToTry - PROBES) {\n+                throw error;\n+            }\n+            recurse(depth + 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack019.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8339725\n+ * @summary Stress test GetMethodDeclaringClass\n+ * @requires vm.jvmti\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @run driver\/timeout=300 TestUnloadedClass\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Platform;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.lang.reflect.Constructor;\n+\n+public class TestUnloadedClass {\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-agentpath:\" + Utils.TEST_NATIVE_PATH + File.separator + System.mapLibraryName(\"TestUnloadedClass\"),\n+                \"-Xmx50m\",\n+                \"Test\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        if (!Platform.isDebugBuild()) {\n+            output.shouldContain(\"OutOfMemoryError\");\n+        }\n+    }\n+}\n+\n+class Test {\n+    public static void main(String[] args) throws Exception {\n+        long last = System.nanoTime();\n+        for (int i = 0;;i++) {\n+            if (Platform.isDebugBuild() && i >= 1000) {\n+                \/\/ Debug build costs too much time to OOM so limit the loop iteration\n+                break;\n+            }\n+            CustomClassLoader loader = new CustomClassLoader();\n+            Class<?> k = loader.findClass(\"MyClass\");\n+            Constructor<?> c = k.getDeclaredConstructor();\n+            c.setAccessible(true);\n+            c.newInstance();\n+\n+            \/\/ call gc every ~1 second.\n+            if ((System.nanoTime() - last) >= 1e9) {\n+                System.gc();\n+                last = System.nanoTime();\n+            }\n+        }\n+    }\n+}\n+\n+class CustomClassLoader extends ClassLoader {\n+    static byte[] BYTES;\n+\n+    static {\n+        try (InputStream in = CustomClassLoader.class.getResourceAsStream(\"MyClass.class\")) {\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n+                byte[] buf = new byte[4096];\n+                int len;\n+                while ((len = in.read(buf)) != -1) {\n+                    baos.write(buf, 0, len);\n+                }\n+                BYTES = baos.toByteArray();\n+            }\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Override\n+    public Class findClass(String name) throws ClassNotFoundException {\n+        return defineClass(name, BYTES, 0, BYTES.length);\n+    }\n+}\n+\n+class MyClass {\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetMethodDeclaringClass\/TestUnloadedClass.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <atomic>\n+\n+#include <jvmti.h>\n+#include <jni.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+static jvmtiEnv *_jvmti;\n+static JavaVM *_jvm;\n+\n+#define BUFFER_SIZE 100000\n+static std::atomic<jmethodID> ring_buffer[BUFFER_SIZE];\n+\n+void get_method_details(jmethodID method) {\n+  jclass method_class;\n+  char *class_name = NULL;\n+  if (_jvmti->GetMethodDeclaringClass(method, &method_class) == JVMTI_ERROR_NONE) {\n+    if (_jvmti->GetClassSignature(method_class, &class_name, NULL) == JVMTI_ERROR_NONE) {\n+      _jvmti->Deallocate((unsigned char *)class_name);\n+    }\n+  }\n+}\n+\n+void* read_ringbuffer(void* arg) {\n+  JNIEnv *env;\n+  _jvm->AttachCurrentThreadAsDaemon((void **)&env, NULL);\n+  for (;;) {\n+    jmethodID id = ring_buffer[rand() % BUFFER_SIZE].load(std::memory_order_relaxed);\n+    if (id != (jmethodID)0) {\n+      get_method_details(id);\n+    }\n+  }\n+  return NULL;\n+}\n+\n+static void JNICALL ClassPrepareCallback(jvmtiEnv *jvmti_env,\n+                                         JNIEnv *jni_env,\n+                                         jthread thread,\n+                                         jclass klass) {\n+  static bool reader_created = false;\n+  static int ring_buffer_idx = 0;\n+\n+  char *class_name = NULL;\n+  if (jvmti_env->GetClassSignature(klass, &class_name, NULL) != JVMTI_ERROR_NONE) {\n+    return;\n+  }\n+  \/\/ We only care MyClass and only one thread loads it\n+  bool is_my_class = strcmp(class_name, \"LMyClass;\") == 0;\n+  jvmti_env->Deallocate((unsigned char *)class_name);\n+  if (!is_my_class) {\n+    return;\n+  }\n+\n+  if (!reader_created) {\n+    pthread_t tid;\n+    pthread_create(&tid, NULL, read_ringbuffer, NULL);\n+    reader_created = true;\n+  }\n+\n+  jint method_count;\n+  jmethodID *methods;\n+  if (jvmti_env->GetClassMethods(klass, &method_count, &methods) == JVMTI_ERROR_NONE) {\n+    ring_buffer[ring_buffer_idx++].store(methods[0], std::memory_order_relaxed);\n+    ring_buffer_idx = ring_buffer_idx % BUFFER_SIZE;\n+    jvmti_env->Deallocate((unsigned char *)methods);\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  for (int i = 0; i < BUFFER_SIZE; i++) {\n+    ring_buffer[i].store(0, std::memory_order_relaxed);\n+  }\n+\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError error;\n+\n+  _jvm = jvm;\n+\n+  if (jvm->GetEnv((void **)&_jvmti, JVMTI_VERSION_1_0) != JNI_OK) {\n+    fprintf(stderr, \"Unable to access JVMTI!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Set up the event callbacks\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.ClassPrepare = &ClassPrepareCallback;\n+\n+  \/\/ Register the callbacks\n+  error = _jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (error != JVMTI_ERROR_NONE) {\n+    fprintf(stderr, \"Error setting event callbacks: %d\\n\", error);\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Enable the ClassPrepare event\n+  error = _jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+  if (error != JVMTI_ERROR_NONE) {\n+    fprintf(stderr, \"Error enabling ClassPrepare event: %d\\n\", error);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetMethodDeclaringClass\/libTestUnloadedClass.cpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,3 @@\n-static long tls_data = 0;\n+static void* tls_data = 0;\n+static const void* const tls_data1 = (const void*)0x111;\n+static const void* const tls_data2 = (const void*)0x222;\n@@ -152,1 +154,1 @@\n-  err = jvmti->GetThreadLocalStorage(cthread, (void**)&tls_data);\n+  err = jvmti->GetThreadLocalStorage(cthread, &tls_data);\n@@ -155,1 +157,1 @@\n-  if (tls_data != 111) {\n+  if (tls_data != tls_data1) {\n@@ -157,1 +159,1 @@\n-    LOG(\"FAILED: GetThreadLocalStorage for carrier thread returned value: %d, expected 111\\n\\n\", (int)tls_data);\n+    LOG(\"FAILED: GetThreadLocalStorage for carrier thread returned value: %p, expected %p\\n\\n\", tls_data, tls_data1);\n@@ -159,1 +161,1 @@\n-    LOG(\"GetThreadLocalStorage for carrier thread returned value %d as expected\\n\\n\", (int)tls_data);\n+    LOG(\"GetThreadLocalStorage for carrier thread returned value %p as expected\\n\\n\", tls_data);\n@@ -228,1 +230,1 @@\n-  err = jvmti->GetThreadLocalStorage(thread, (void**)&tls_data);\n+  err = jvmti->GetThreadLocalStorage(thread, &tls_data);\n@@ -231,1 +233,1 @@\n-  if (tls_data != 222) {\n+  if (tls_data != tls_data2) {\n@@ -233,1 +235,1 @@\n-    LOG(\"FAILED: GetThreadLocalStorage for virtual thread returned value: %d, expected 222\\n\\n\", (int)tls_data);\n+    LOG(\"FAILED: GetThreadLocalStorage for virtual thread returned value: %p, expected %p\\n\\n\", tls_data, tls_data2);\n@@ -235,1 +237,1 @@\n-    LOG(\"GetThreadLocalStorage for virtual thread returned value %d as expected\\n\\n\", (int)tls_data);\n+    LOG(\"GetThreadLocalStorage for virtual thread returned value %p as expected\\n\\n\", tls_data);\n@@ -383,1 +385,1 @@\n-  long loc_tls_data = 0;\n+  void* loc_tls_data = 0;\n@@ -391,1 +393,1 @@\n-  err = jvmti->SetThreadLocalStorage(cthread, (void*)111);\n+  err = jvmti->SetThreadLocalStorage(cthread, tls_data1);\n@@ -395,1 +397,1 @@\n-  err = jvmti->GetThreadLocalStorage(cthread, (void**)&loc_tls_data);\n+  err = jvmti->GetThreadLocalStorage(cthread, &loc_tls_data);\n@@ -398,1 +400,1 @@\n-  if (loc_tls_data != 111) {\n+  if (loc_tls_data != tls_data1) {\n@@ -400,1 +402,1 @@\n-    LOG(\"ThreadStart: FAILED: GetThreadLocalStorage for carrier thread returned value: %d, expected 111\\n\\n\", (int)loc_tls_data);\n+    LOG(\"ThreadStart: FAILED: GetThreadLocalStorage for carrier thread returned value: %p, expected %p\\n\\n\", loc_tls_data, tls_data1);\n@@ -402,1 +404,1 @@\n-    LOG(\"ThreadStart: GetThreadLocalStorage for carrier thread returned value %d as expected\\n\\n\", (int)loc_tls_data);\n+    LOG(\"ThreadStart: GetThreadLocalStorage for carrier thread returned value %p as expected\\n\\n\", loc_tls_data);\n@@ -422,1 +424,1 @@\n-  err = jvmti->SetThreadLocalStorage(vthread, (void*)222);\n+  err = jvmti->SetThreadLocalStorage(vthread, tls_data2);\n@@ -466,1 +468,1 @@\n-  err = jvmti->SetThreadLocalStorage(thread, (void*)222);\n+  err = jvmti->SetThreadLocalStorage(thread, tls_data2);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/MethodExitTest\/libMethodExitTest.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-    rml.wait(0);\n+    while (bp_sync_reached) { \/\/ guard against spurious wakeups\n+      rml.wait(0);\n+    }\n@@ -56,1 +58,1 @@\n-  if (do_pop_frame != 0) {\n+  if (do_pop_frame) {\n@@ -155,2 +157,0 @@\n-  bool need_stop = false;\n-\n@@ -158,4 +158,8 @@\n-  while (!need_stop) {\n-    RawMonitorLocker rml(jvmti, jni, monitor);\n-    need_stop = bp_sync_reached;\n-    sleep_ms(1); \/\/ 1 millisecond\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+  int attempts = 0;\n+  while (!bp_sync_reached) {\n+    if (++attempts > 100) {\n+      fatal(jni, \"Main: ensureAtBreakpoint: waited 20 sec\");\n+    }\n+    LOG(\"Main: ensureAtBreakpoint: waiting 200 millis\\n\");\n+    rml.wait(200); \/\/ 200 milliseconds\n@@ -169,0 +173,3 @@\n+  if (!bp_sync_reached) { \/\/ better diagnosability\n+    fatal(jni, \"Main: notifyAtBreakpoint: expected: bp_sync_reached==true\");\n+  }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/PopFrameTest\/libPopFrameTest.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.lang.instrument.Instrumentation;\n+import java.security.ProtectionDomain;\n+import jdk.test.lib.thread.VThreadPinner;\n+\n+\/*\n+ * @test\n+ * @summary javaagent + tracePinnedThreads will cause jvm crash\/ run into deadlock when the virtual thread is pinned\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @requires vm.jvmti\n+ * @modules java.base\/java.lang:+open\n+ * @compile TestPinCaseWithCFLH.java\n+ * @build jdk.test.lib.Utils\n+ * @run driver jdk.test.lib.util.JavaAgentBuilder\n+ *             TestPinCaseWithCFLH TestPinCaseWithCFLH.jar\n+ * @run main\/othervm\/timeout=100  -Djdk.virtualThreadScheduler.maxPoolSize=1\n+ *       -Djdk.tracePinnedThreads=full --enable-native-access=ALL-UNNAMED\n+ *       -javaagent:TestPinCaseWithCFLH.jar TestPinCaseWithCFLH\n+ *\/\n+public class TestPinCaseWithCFLH {\n+\n+    public static class TestClassFileTransformer implements ClassFileTransformer {\n+        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n+                                ProtectionDomain protectionDomain, byte[] classfileBuffer)\n+                                throws IllegalClassFormatException {\n+            return classfileBuffer;\n+        }\n+    }\n+\n+    \/\/ Called when agent is loaded at startup\n+    public static void premain(String agentArgs, Instrumentation instrumentation) throws Exception {\n+        instrumentation.addTransformer(new TestClassFileTransformer());\n+    }\n+\n+    private static int result = 0;\n+\n+    public static void main(String[] args) throws Exception{\n+        Thread t1 = Thread.ofVirtual().name(\"vthread-1\").start(() -> {\n+            VThreadPinner.runPinned(() -> {\n+                try {\n+                    \/\/ try yield, will pin,\n+                    \/\/ javaagent + tracePinnedThreads should not lead to crash\n+                    \/\/ (because of the class `PinnedThreadPrinter`)\n+                    Thread.sleep(500);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+        });\n+        t1.join();\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/TestPinCaseWithCFLH\/TestPinCaseWithCFLH.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -305,0 +305,1 @@\n+                \"-XX:+StressIncrementalInlining\",\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/CtwRunner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        TestVMProcess testVMProcess = new TestVMProcess(testVMFlags, testClass, null, -1);\n+        TestVMProcess testVMProcess = new TestVMProcess(testVMFlags, testClass, null, -1, false);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n+\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compiler2.enabled & vm.flagless\n+ * @summary Test that IR framework successfully adds test class to boot classpath in order to run in privileged mode.\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestPrivilegedMode\n+ *\/\n+\n+public class TestPrivilegedMode {\n+    static @Stable int iFld; \/\/ Treated as constant after first being set.\n+\n+    public static void main(String[] args) {\n+        try {\n+            TestFramework.run();\n+            Asserts.fail(\"should not reach\");\n+        } catch (IRViolationException e) {\n+            \/\/ Without adding test class to boot classpath, we fail to replace the field load by a constant.\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"Matched forbidden node\"));\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"LoadI\"));\n+        }\n+\n+        \/\/ When adding the test class to the boot classpath, we can replace the field load by a constant.\n+        new TestFramework().addTestClassesToBootClassPath().start();\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = IRNode.LOAD_I)\n+    public int test() {\n+        return iFld;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        iFld = 34;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPrivilegedMode.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -153,2 +153,0 @@\n-\/\/        System.out.println(\"WhiteBox.getWhiteBox().g1GetTotalCollections() = \\t\" + WhiteBox.getWhiteBox().g1GetTotalCollections());\n-\/\/        System.out.println(\"WhiteBox.getWhiteBox().g1GetTotalFullCollections() = \\t\" + WhiteBox.getWhiteBox().g1GetTotalFullCollections());\n@@ -162,1 +160,1 @@\n-\/\/        if (WhiteBox.getWhiteBox().g1GetTotalFullCollections() != 0 || (oldGenBean != null && oldGenBean.getCollectionCount() != 0)) {\n+\n@@ -164,1 +162,1 @@\n-            throw new RuntimeException(\"Full gc happened. Test was useless.\");\n+            throw new SkippedException(\"Full gc happened, skip the test.\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/UnloadingTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-            pipe = SocketIOPipe.createClientIOPipe(log, \"localhost\", portNumber, 0);\n+            pipe = SocketIOPipe.createClientIOPipe(log, portNumber, 0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/AttachingConnector\/attach\/attach004\/attach004t.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,0 +110,5 @@\n+            int code = debugee.waitFor();\n+            if (code != Consts.JCK_STATUS_BASE) {\n+                log.complain(\"Debugee FAILED with exit code: \" + code);\n+                exitStatus = Consts.TEST_FAILED;\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/BScenarios\/multithrd\/tc04x001.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -71,1 +73,2 @@\n-    static private volatile boolean testFailed, eventsReceived, threadsStarted;\n+    static private volatile boolean testFailed;\n+    static private CountDownLatch eventsReceivedLatch;\n@@ -82,3 +85,1 @@\n-        eventsReceived = false;\n-        threadsStarted = false;\n-\n+        eventsReceivedLatch = new CountDownLatch(1);\n@@ -114,2 +115,4 @@\n-                    \/\/ handle events until all threads started and all expected events received\n-                    while (!(threadsStarted && eventsReceived)) {\n+                    boolean isConnected = true;\n+                    boolean allEventsReceived = false;\n+                    \/\/ handle events until debuggee is disconnected\n+                    while (isConnected) {\n@@ -133,2 +136,4 @@\n-                            \/\/ handle ClassPrepareEvent\n-                            if (event instanceof ClassPrepareEvent) {\n+                            if (event instanceof VMDeathEvent || event instanceof VMDisconnectEvent) {\n+                                log.display(\"eventHandler got \" + event);\n+                                isConnected = false;\n+                            } else  if (event instanceof ClassPrepareEvent) {\n@@ -198,5 +203,14 @@\n-                                              \/\/ Check that all expected ClassPrepareEvent are received\n-                                              eventsReceived = true;\n-                                              for (int i = 0; i < checkedTypes.length; i++) {\n-                                                   if (checkedTypes[i][2] == \"0\")\n-                                                       eventsReceived = false;\n+                                              \/\/ Check that all expected ClassPrepareEvent(s) are received.\n+                                              if (!allEventsReceived) {\n+                                                  allEventsReceived = true;\n+                                                  for (int i = 0; i < checkedTypes.length; i++) {\n+                                                      \/\/ checkedTypes[i][2] is \"0\" initially,\n+                                                      \/\/ \"1\" after corresponding ClassPrepareEvent is received.\n+                                                      if (checkedTypes[i][2] == \"0\") {\n+                                                          allEventsReceived = false;\n+                                                          break;\n+                                                      }\n+                                                  }\n+                                                  if (allEventsReceived) {\n+                                                      eventsReceivedLatch.countDown();\n+                                                  }\n@@ -219,1 +233,3 @@\n-                        eventSet.resume();\n+                        if (isConnected) {\n+                            eventSet.resume();\n+                        }\n@@ -260,3 +276,0 @@\n-            \/\/ notify EventHandler that all threads started\n-            threadsStarted = true;\n-\n@@ -265,6 +278,4 @@\n-                  eventHandler.join(eventTimeout);\n-                  if (eventHandler.isAlive()) {\n-                      log.complain(\"FAILURE 20: Timeout for waiting event was exceeded\");\n-                      eventHandler.interrupt();\n-                      testFailed = true;\n-                  }\n+                if (!eventsReceivedLatch.await(eventTimeout, TimeUnit.MILLISECONDS)) {\n+                    log.complain(\"FAILURE 20: Timeout waiting for all events was exceeded\");\n+                    testFailed = true;\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassPrepareEvent\/referenceType\/refType001.java","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -75,1 +77,2 @@\n-    static private volatile boolean testFailed, eventsReceived, threadsStarted;\n+    static private volatile boolean testFailed;\n+    static private CountDownLatch eventsReceivedLatch;\n@@ -86,2 +89,1 @@\n-        eventsReceived = false;\n-        threadsStarted = false;\n+        eventsReceivedLatch = new CountDownLatch(1);\n@@ -134,2 +136,4 @@\n-                    \/\/ handle events until all threads started and all expected events received\n-                    while (!(threadsStarted && eventsReceived)) {\n+                    boolean isConnected = true;\n+                    boolean allEventsReceived = false;\n+                    \/\/ handle events until debuggee is disconnected\n+                    while (isConnected) {\n@@ -153,2 +157,4 @@\n-                            \/\/ handle ClassPrepareEvent\n-                            if (event instanceof ClassPrepareEvent) {\n+                            if (event instanceof VMDeathEvent || event instanceof VMDisconnectEvent) {\n+                                log.display(\"eventHandler got \" + event);\n+                                isConnected = false;\n+                            } else  if (event instanceof ClassPrepareEvent) {\n@@ -227,6 +233,14 @@\n-                                          \/\/ Check that all expected ClassPrepareEvent are received\n-                                          eventsReceived = true;\n-                                          for (int i = 0; i < checkedThreads.length; i++) {\n-                                               if (checkedThreads[i][2] == \"0\") {\n-                                                    eventsReceived = false;\n-                                               }\n+                                          \/\/ Check that all expected ClassPrepareEvent(s) are received.\n+                                          if (!allEventsReceived) {\n+                                              allEventsReceived = true;\n+                                              for (int i = 0; i < checkedThreads.length; i++) {\n+                                                  \/\/ checkedTypes[i][2] is \"0\" initially,\n+                                                  \/\/ \"1\" after corresponding ClassPrepareEvent is received.\n+                                                  if (checkedThreads[i][2] == \"0\") {\n+                                                      allEventsReceived = false;\n+                                                      break;\n+                                                   }\n+                                              }\n+                                              if (allEventsReceived) {\n+                                                  eventsReceivedLatch.countDown();\n+                                              }\n@@ -243,1 +257,3 @@\n-                        eventSet.resume();\n+                        if (isConnected) {\n+                            eventSet.resume();\n+                        }\n@@ -283,3 +299,0 @@\n-            \/\/ notify EventHandler that all threads started\n-            threadsStarted = true;\n-\n@@ -288,6 +301,4 @@\n-                  eventHandler.join(eventTimeout);\n-                  if (eventHandler.isAlive()) {\n-                      log.complain(\"FAILURE 20: Timeout for waiting event was exceeded\");\n-                      eventHandler.interrupt();\n-                      testFailed = true;\n-                  }\n+                if (!eventsReceivedLatch.await(eventTimeout, TimeUnit.MILLISECONDS)) {\n+                    log.complain(\"FAILURE 20: Timeout waiting for all events was exceeded\");\n+                    testFailed = true;\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ClassPrepareEvent\/thread\/thread001.java","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+        pipe.println(COMMAND_QUIT);\n@@ -172,1 +173,0 @@\n-            elThread.isConnected = false;\n@@ -183,1 +183,0 @@\n-        pipe.println(COMMAND_QUIT);\n@@ -198,1 +197,0 @@\n-        public volatile boolean isConnected = true;\n@@ -202,0 +200,1 @@\n+                boolean isConnected = true;\n@@ -208,2 +207,2 @@\n-                            if (event instanceof VMDeathEvent) {\n-                                tot_res = FAILED;\n+                            if (event instanceof VMDeathEvent || event instanceof VMDisconnectEvent) {\n+                                log.display(\"EventListener: got \" + event);\n@@ -211,6 +210,1 @@\n-                                log.complain(\"TEST FAILED: unexpected VMDeathEvent\");\n-                            } else if (event instanceof VMDisconnectEvent) {\n-                                tot_res = FAILED;\n-                                isConnected = false;\n-                                log.complain(\"TEST FAILED: unexpected VMDisconnectEvent\");\n-                            } else\n+                            } else {\n@@ -219,3 +213,2 @@\n-                        }\n-                        if (isConnected) {\n-                            eventSet.resume();\n+                                eventSet.resume();\n+                            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/threadDeathRequests\/thrdeathreq001.java","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -281,1 +281,6 @@\n-        return;\n+        int code = debuggee.waitFor();\n+        if (code != Consts.JCK_STATUS_BASE) {\n+            log2(\"Debugee FAILED with exit code: \" + code);\n+            testExitCode = Consts.TEST_FAILED;\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VMDeathEvent\/_itself_\/vmdeath003.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -174,0 +174,6 @@\n+        int code = debuggee.waitFor();\n+        if (code != 0) {\n+            log2(\"Debugee FAILED with exit code: \" + code);\n+            testExitCode = Consts.TEST_FAILED;\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/VirtualMachine\/exit\/exit001.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        Terminator.java, TimeoutHandler.java\n+        TimeoutHandler.java\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/README","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share;\n-\n-\/**\n- * Terminator is used to terminate a stress test with PASS exit status\n- * before the test is terminated as timed out (and so failed).\n- *\n- * <p>Terminator class holds a thread which sleeps for the given amount\n- * of time, and then wakes up and executes <tt>System.exit()<\/tt>\n- * with the given exit status. That thread is daemon, so it doesn't\n- * prevent application from exiting once all its threads finish\n- * before it's time for termination. Appointing terminator in zero\n- * delay implies immediate <tt>exit()<\/tt>.\n- *\n- * <p>There is a limitation: you may appoint no more than one terminator\n- * per application.\n- *\/\n-public class Terminator {\n-    \/**\n-     * Use specific <tt>appoint()<\/tt> method to appoint terminator.\n-     *\n-     * @see #appoint(int)\n-     * @see #appoint(int,int)\n-     *\/\n-    protected Terminator() {}\n-\n-    \/**\n-     * One terminator per application, or <tt>null<\/tt> (by default).\n-     *\/\n-    private static Thread terminator = null;\n-\n-    \/**\n-     * <p>Return timeout (or waittime) value munus the margin\n-     * value (which is assumed 1 minute by default).\n-     *\n-     * <p>Treat <tt>args[0]<\/tt> as <tt>$TIMEOUT<\/tt> value, or seek for\n-     * <tt>-waittime=$WAITTIME<\/tt> value. If both parameters\n-     * (or either none of them) are assigned, throw an exception to\n-     * report parameters inconsistency.\n-     *\n-     * <p>Also, seek for <tt>-margin=...<\/tt> assignment, or assume margin\n-     * is 1 minute.\n-     *\n-     * @param args Is usually obtained via the application's command-line.\n-     *\n-     * @throws IllegalArgumentException If <tt>args[]<\/tt> is inconsistent.\n-     *\n-     * @see #appoint(int)\n-     * @see #appoint(int,int)\n-     *\/\n-    public static int parseAppointment(String args[]) {\n-        int timeout=-1, margin=1;\n-        int timeouts=0, waittimes=0, margins=0;\n-        for (int i=0; i<args.length; i++) {\n-            if (args[i].startsWith(\"-\")) {\n-                if (args[i].startsWith(\"-waittime=\")) {\n-                    timeout = Integer.parseInt(args[i].substring(10));\n-                    waittimes++;\n-                }\n-                if (args[i].startsWith(\"-margin=\")) {\n-                    margin = Integer.parseInt(args[i].substring(8));\n-                    margins++;\n-                }\n-            } else {\n-                if (i == 0) {\n-                    timeout = Integer.parseInt(args[i]);\n-                    timeouts++;\n-                }\n-            }\n-        };\n-        if (timeouts==0 && waittimes==0)\n-            throw new IllegalArgumentException(\n-                \"no $TIMEOUT, nor -waittime=$WAITTIME is set\");\n-        if (waittimes > 1)\n-            throw new IllegalArgumentException(\n-                \"more than one -waittime=... is set\");\n-        if (margins > 1)\n-            throw new IllegalArgumentException(\n-                \"more than one -margin=... is set\");\n-\n-        int result = timeout - margin;\n-        if (result <= 0)\n-            throw new IllegalArgumentException(\n-                \"delay appointment must be greater than \"+margin+\" minutes\");\n-        return result;\n-    }\n-\n-    \/**\n-     * Appoint terminator after the given amount of <tt>minutes<\/tt>,\n-     * so that exit status would be 95 (to simulate JCK-like PASS\n-     * status).\n-     *\n-     * @throws IllegalStateException If terminator is already appointed.\n-     *\n-     * @see #appoint(int,int)\n-     * @see #parseAppointment(String[])\n-     *\/\n-    public static void appoint(int minutes) {\n-        appoint(minutes,95); \/\/ JCK-like PASS status\n-    }\n-\n-    \/**\n-     * Appoint Terminator for the given amount of <tt>minutes<\/tt>,\n-     * so that the given <tt>status<\/tt> would be exited when time\n-     * is over.\n-     *\n-     * @throws IllegalStateException If terminator is already appointed.\n-     *\n-     * @see #appoint(int)\n-     * @see #parseAppointment(String[])\n-     *\/\n-    public static void appoint(int minutes, int status) {\n-        if (terminator != null)\n-            throw new IllegalStateException(\"Terminator is already appointed.\");\n-\n-        final long timeToExit = System.currentTimeMillis() + 60*1000L*minutes;\n-        final int  exitStatus = status;\n-\n-        terminator = new Thread(Terminator.class.getName()) {\n-            public void run() {\n-                long timeToSleep = timeToExit - System.currentTimeMillis();\n-                if (timeToSleep > 0)\n-                    try {\n-                        \/\/\n-                        \/\/ Use wait() instead of sleep(), because Java 2\n-                        \/\/ specification doesn't guarantee the method\n-                        \/\/ sleep() to yield to other threads.\n-                        \/\/\n-                        Object someDummyObject = new Object();\n-                        synchronized (someDummyObject) {\n-                            someDummyObject.wait(timeToSleep);\n-                        }\n-                    } catch (InterruptedException exception) {\n-                        exception.printStackTrace(System.err);\n-                        return;\n-                    };\n-                \/\/\n-                \/\/ OK, lets do it now:\n-                \/\/\n-                System.err.println(\n-                    \"#\\n# Terminator: prescheduled program termination.\\n#\");\n-                System.exit(exitStatus); \/\/ terminator to all threads\n-            }\n-        };\n-\n-        terminator.setPriority(Thread.MAX_PRIORITY);\n-        terminator.setDaemon(true);\n-        terminator.start();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/Terminator.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-        pipe = SocketIOPipe.createClientIOPipe(log, \"localhost\", argParser.getPort(), 0);\n+        pipe = SocketIOPipe.createClientIOPipe(log, argParser.getPort(), 0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/aod\/DummyTargetApplication.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,1 +344,1 @@\n-                pipe = SocketIOPipe.createClientIOPipe(log, \"localhost\", argParser.getPort(), 0);\n+                pipe = SocketIOPipe.createClientIOPipe(log, argParser.getPort(), 0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/aod\/TargetApplicationWaitingAgents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,2 +131,0 @@\n-\n-        debugee.registerCleanup();\n@@ -942,3 +940,0 @@\n-\n-        debugee.registerCleanup();\n-\n@@ -955,3 +950,0 @@\n-\n-        debugee.registerCleanup();\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Binder.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,2 +109,0 @@\n-        debugee.registerCleanup();\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdwp\/Binder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-     * \"<i>localhost<\/i>\" string by default.\n+     * empty string (represents an address of the loopback interface) by default.\n@@ -116,1 +116,1 @@\n-        return options.getProperty(\"test.host\", \"localhost\");\n+        return options.getProperty(\"test.host\", \"\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeArgumentHandler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-                pipeServerSocket.bind(null);\n+                pipeServerSocket.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeBinder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-abstract public class DebugeeProcess extends FinalizableObject {\n+abstract public class DebugeeProcess {\n@@ -87,3 +87,0 @@\n-\n-        \/\/ Register the cleanup() method to be called when this instance becomes unreachable.\n-        registerCleanup();\n@@ -433,1 +430,1 @@\n-     * @throws Throwable if any throwable exception is thrown during finalization\n+     * @throws Throwable if any throwable exception is thrown during shutdown\n@@ -461,8 +458,0 @@\n-    \/**\n-     * Finalize debuggee VM wrapper by invoking <code>close()<\/code>.\n-     *\n-     * @throws Throwable if any throwable exception is thrown during finalization\n-     *\/\n-    public void cleanup() {\n-        close();\n-    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeProcess.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.net.InetAddress;\n@@ -38,1 +39,1 @@\n- * and 'createClientIOPipe(Log log, String host, int port, long timeout)' for client SocketIOPipe.\n+ * and 'createClientIOPipe(Log log, int port, long timeout)' for client SocketIOPipe.\n@@ -43,2 +44,2 @@\n- * For example, if client process should send string 'OK' to the server process which is run\n- * at the host 'SERVER_HOST' following code can be written:\n+ * For example, if client process should send string 'OK' to the server process,\n+ * the following code can be written:\n@@ -56,2 +57,2 @@\n- *  \/\/ initialize SocketIOPipe with given values of server host name and port\n- *  SocketIOPipe pipe = SocketIOPipe.createClientIOPipe(log, 'SERVER_HOST', port, timeoutValue);\n+ *  \/\/ initialize SocketIOPipe with given port\n+ *  SocketIOPipe pipe = SocketIOPipe.createClientIOPipe(log, port, timeoutValue);\n@@ -126,1 +127,1 @@\n-            ss.bind(new InetSocketAddress(port));\n+            ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), port));\n@@ -146,2 +147,3 @@\n-    public static SocketIOPipe createClientIOPipe(Log log, String host, int port, long timeout) {\n-        return new SocketIOPipe(log, DEFAULT_PIPE_LOG_PREFIX, host, port, timeout, false);\n+    public static SocketIOPipe createClientIOPipe(Log log, int port, long timeout) {\n+        \/\/ use null for host to connect to loopback address\n+        return new SocketIOPipe(log, DEFAULT_PIPE_LOG_PREFIX, null, port, timeout, false);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/SocketIOPipe.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import jtreg.SkippedException;\n+\n@@ -85,0 +87,2 @@\n+                        } catch (SkippedException se) {\n+                                throw se;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/Tests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack001.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     Provoke StackOverflowError by infinite recursion in Java method,\n- *     intercept the exception try to make one more invocation.\n- * COMMENTS\n- *     Kestrel for Solaris_JDK_1.3-b10 crashes while trying to execute\n- *     this test with Client HS VM.\n- *     See lots of bugs concerning similar failures:\n- *     Evaluated:\n- *     4217960 [native stack overflow bug] reflection test causes crash\n- *     Accepted:\n- *     4285716 native stack overflow causes crash on Solaris\n- *     4281578 Second stack overflow crashes HotSpot VM\n- *     Closed (duplicate):\n- *     4027933     Native stack overflows not detected or handled correctly\n- *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n- *     4185411     Various crashes when using recursive reflection.\n- *     4167055     infinite recursion in FindClass\n- *     4222359     Infinite recursion crashes jvm\n- *     Closed (will not fix):\n- *     4231968 StackOverflowError in a native method causes Segmentation Fault\n- *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n- *     4302288 the second stack overflow causes Classic VM to exit on win32\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack001\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack001 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack001 test = new stack001();\n-        test.recurse(0);\n-        out.println(\"Maximal depth: \" + test.maxdepth);\n-        return 0;\n-    }\n-\n-    private int maxdepth;\n-\n-    private void recurse(int depth) {\n-        maxdepth = depth;\n-        try {\n-            recurse(depth + 1);\n-        } catch (Error error) {\n-            if (!(error instanceof StackOverflowError) &&\n-                    !(error instanceof OutOfMemoryError))\n-                throw error;\n-\n-            if (maxdepth == depth)\n-                recurse(depth + 1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack001.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack002.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     Provoke StackOverflowError by infinite recursion in Java method,\n- *     intercept the exception and continue to invoke that method until\n- *     the test exceeds timeout, or until Java VM crashes.\n- * COMMENTS\n- *     I believe that the test causes HS crashes due to the following bug:\n- *     4330318 (P2\/S2) NSK test fails as An irrecoverable stack overflow\n- *     See also bugs (lots of bugs!):\n- *     Evaluated:\n- *     4217960 [native stack overflow bug] reflection test causes crash\n- *     Accepted:\n- *     4285716 native stack overflow causes crash on Solaris\n- *     4281578 Second stack overflow crashes HotSpot VM\n- *     Closed (duplicate):\n- *     4027933     Native stack overflows not detected or handled correctly\n- *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n- *     4185411     Various crashes when using recursive reflection.\n- *     4167055     infinite recursion in FindClass\n- *     4222359     Infinite recursion crashes jvm\n- *     Closed (will not fix):\n- *     4231968 StackOverflowError in a native method causes Segmentation Fault\n- *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n- *     4302288 the second stack overflow causes Classic VM to exit on win32\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack002\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack002 {\n-    static final long timeout = 10000; \/\/ 10 seconds\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        Tester tester = new Tester(out);\n-        Timer timer = new Timer(tester);\n-        timer.start();\n-        tester.start();\n-        while (timer.isAlive()) {\n-            try {\n-                timer.join();\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(out);\n-                return 2;\n-            }\n-        }\n-        out.println(\"Maximal depth: \" + tester.maxdepth);\n-        return 0;\n-    }\n-\n-    private static class Tester extends Thread {\n-        int maxdepth;\n-        PrintStream out;\n-        public volatile boolean stop;\n-\n-        public Tester(PrintStream out) {\n-            this.out = out;\n-            maxdepth = 0;\n-            stop = false;\n-        }\n-\n-        public void run() {\n-            recurse(0);\n-        }\n-\n-        void recurse(int depth) {\n-            maxdepth = depth;\n-            try {\n-                if (stop) {\n-                    return;\n-                }\n-                recurse(depth + 1);\n-            } catch (Error error) {\n-                if (!(error instanceof StackOverflowError) &&\n-                        !(error instanceof OutOfMemoryError))\n-                    throw error;\n-                recurse(depth + 1);\n-            }\n-        }\n-    }\n-\n-    private static class Timer extends Thread {\n-        private Tester tester;\n-\n-        public Timer(Tester tester) {\n-            this.tester = tester;\n-        }\n-\n-        public void run() {\n-            long started;\n-            started = System.currentTimeMillis();\n-            while (System.currentTimeMillis() - started < timeout) {\n-                try {\n-                    this.sleep(1000);\n-                } catch (InterruptedException e) {\n-                    e.printStackTrace(tester.out);\n-                    return;\n-                };\n-            }\n-            tester.stop = true;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack002.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack003.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking static recursive method for the given fixed depth\n- *     of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack003\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack003 {\n-    final static int ITERATIONS = 100;\n-    final static int INCREMENT = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        int depth;\n-        for (depth = 1; ; depth += INCREMENT)\n-            try {\n-                recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < ITERATIONS; i++)\n-            try {\n-                recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack003.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack004.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking final static recursive method for the given fixed\n- *     depth of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack004\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack004 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack004 test = new stack004();\n-        int exitCode = test.doRun(args, out);\n-        return exitCode;\n-    }\n-\n-    public int doRun(String args[], PrintStream out) {\n-        int depth;\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    final static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack004.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack005.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking final recursive method for the given fixed depth of\n- *     recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack005\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack005 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack005 test = new stack005();\n-        int depth;\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                test.recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                test.recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    final void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack005.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack006.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking virtual recursive method for the given fixed depth\n- *     of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack006\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack006 implements stack006i {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack006i test = new stack006();\n-        int depth;\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                test.recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                test.recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    public void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-interface stack006i {\n-    void recurse(int depth);\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack006.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack007.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking synchronized virtual recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 10000 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is 10 times that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes HS versions 1.3 and 1.4 on Win32, Solaris,\n- *     and Linux platforms in all execution modes. However, it passes\n- *     against HS 2.0 on Win32 platform.\n- *     See also the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack007\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack007 implements stack007i {\n-    final static int ITERATIONS = 1000;\n-    final static int INCREMENT = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack007i test = new stack007();\n-        int depth;\n-        for (depth = 100; ; depth += INCREMENT)\n-            try {\n-                test.recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < ITERATIONS; i++)\n-            try {\n-                test.recurse(10 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    public synchronized void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-interface stack007i {\n-    void recurse(int depth);\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack007.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack008.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invocations via reflection. Recursive method is invoked for\n- *     the given fixed depth of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on Solaris,\n- *     and crashes HS 2.0 on win32. However, it passes against HS 1.3\n- *     and 1.4 on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *     The stack size is too small to run on systems with > 4K page size.\n- *     Making it bigger could cause timeouts on other platform.\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @run main\/othervm\/timeout=900 -Xss200K nsk.stress.stack.stack008\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-public class stack008 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        int depth;\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                invokeRecurse(depth);\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    break; \/\/ OK.\n-                target.printStackTrace(out);\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                return 2;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        \/\/\n-        \/\/ Provoke stack overflow multiple times:\n-        \/\/\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                invokeRecurse(2 * depth);\n-\/\/              out.println(\"?\");\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    continue; \/\/ OK.\n-                target.printStackTrace(out);\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                return 2;\n-            }\n-        return 0;\n-    }\n-\n-    private static Throwable getTargetException(Throwable exception) {\n-        Throwable target;\n-        \/\/\n-        \/\/ Unwrap deep chain of exceptions:\n-        \/\/\n-        for (\n-                target = exception;\n-                target instanceof InvocationTargetException;\n-                target = ((InvocationTargetException) target).getTargetException()\n-                )\n-            ;\n-        return target;\n-    }\n-\n-    static Method method = null;\n-    static stack008 instance = null;\n-    static Object params[] = null;\n-\n-    private static void invokeRecurse(int depth) throws Exception {\n-        if (method == null) {\n-            \/\/\n-            \/\/ Optimization trick: allocate once, use everywhere.\n-            \/\/\n-            instance = new stack008();\n-            method = stack008.class.getMethod(\"recurse\");\n-            params = new Object[]{};\n-        }\n-        \/\/\n-        \/\/ Note, that the same instance.depth is used in all invocations:\n-        \/\/\n-        instance.depth = depth;\n-        method.invoke(instance, params);\n-    }\n-\n-    int depth = 0;\n-\n-    public void recurse() throws Exception {\n-        if (depth > 0)\n-            \/\/\n-            \/\/ Self-invoke via reflection:\n-            \/\/\n-            invokeRecurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack008.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack009.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test provokes second stack overflow from within the\n- *     stack overflow handler.\n- *     This test measures a number of recursive invocations until\n- *     StackOverflowError, and then tries to make an invocation\n- *     for the fixed invocations depth from within the \"catch\"\n- *     block just caught the 1st stack overflow. The depth of new\n- *     invocations is 10 times that depth seen at the 1st stack\n- *     overflow; so that another stack overflow occurs.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if there is no exception thrown other than due to stack\n- *     overflow.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on Win32\n- *     and Solaris platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack009\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack009 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        for (int depth = 100; ; depth += 100)\n-            try {\n-                recurse(depth);\n-            } catch (Error error1) {\n-                if (!(error1 instanceof StackOverflowError) &&\n-                        !(error1 instanceof OutOfMemoryError))\n-                    throw error1;\n-\n-                out.println(\"Max. depth: \" + depth);\n-\n-                try {\n-                    recurse(10 * depth);\n-                    out.println(\"?\");\n-                } catch (Error error2) {\n-                    if (!(error2 instanceof StackOverflowError) &&\n-                            !(error2 instanceof OutOfMemoryError))\n-                        throw error2;\n-\n-                    \/\/ Stack overflow is OK here.\n-                }\n-\n-                break;\n-            }\n-        return 0;\n-    }\n-\n-    static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack009.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack010.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking static recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n- *     platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack010\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack010 extends Thread {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack010 threads[] = new stack010[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack010();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were not thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    int depthToTry = 0;\n-    Throwable thrown = null;\n-\n-    public void run() {\n-        for (int i = 0; i < CYCLES; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError soe) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: out of memory may indacate stack overflow.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-\n-    static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack010.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack011.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking final static recursive method for the\n- *     given fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n- *     platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack011\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack011 extends Thread {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack011 threads[] = new stack011[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack011();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were not thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    int depthToTry = 0;\n-    Throwable thrown = null;\n-\n-    public void run() {\n-        for (int i = 0; i < CYCLES; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: recursion may result in memory lack.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-\n-    final static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack011.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack012.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking final recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 1.3, 1.4 on Win32, and HS versions\n- *     2.0, 1.3, and 1.4 on Solaris. However, it passes against HS 2.0\n- *     on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack012\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack012 extends Thread {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack012 test = new stack012();\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack012 threads[] = new stack012[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack012();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were not thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    int depthToTry = 0;\n-    Throwable thrown = null;\n-\n-    public void run() {\n-        for (int i = 0; i < CYCLES; i++)\n-            try {\n-                this.recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: invocation may result in out of memory.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-\n-    final void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack012.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack013.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking virtual recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both Win32\n- *     and Solaris platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack013\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack013 extends stack013i {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack013i test = new stack013();\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack013i threads[] = new stack013i[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack013();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].cycles = CYCLES;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-abstract class stack013i extends Thread {\n-    \/\/\n-    \/\/ Pure virtual method:\n-    \/\/\n-    abstract void recurse(int depth);\n-\n-    Throwable thrown = null;\n-    int depthToTry;\n-    int cycles;\n-\n-    public void run() {\n-        \/\/\n-        \/\/ Provoke multiple stack overflows:\n-        \/\/\n-        for (int i = 0; i < cycles; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: out of memory is eligible here.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack013.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack014.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking synchronized virtual recursive method\n- *     for the given fixed depth of recursion (though, for a large\n- *     depth). Note however, that different threads are not actual\n- *     synchronized, because different instances having the recursive\n- *     method are used.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n- *     However, it passes against all these HS versions on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack014\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack014 extends stack014i {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack014i test = new stack014();\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack014i threads[] = new stack014i[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack014();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].cycles = CYCLES;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    synchronized void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-abstract class stack014i extends Thread {\n-    \/\/\n-    \/\/ Pure virtual method:\n-    \/\/\n-    abstract void recurse(int depth);\n-\n-    Throwable thrown = null;\n-    int depthToTry;\n-    int cycles;\n-\n-    public void run() {\n-        \/\/\n-        \/\/ Provoke multiple stack overflows:\n-        \/\/\n-        for (int i = 0; i < cycles; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: if there is no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack014.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack015.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking synchronized virtual recursive method\n- *     for the given fixed depth of recursion from within another\n- *     recursive method already deeply invoked.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     in 10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n- *     However, it passes against all these HS versions on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack015\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack015 extends stack015i {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-    final static int STEP = 10;\n-    final static int RESERVE = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        \/\/\n-        \/\/ The test will invoke the particular stack015.recurse()\n-        \/\/ method via abstract test.recurse() invocations.\n-        \/\/\n-        stack015i test = new stack015();\n-        stack015i.test = test;\n-\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 0; ; depth += STEP)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack015i threads[] = new stack015i[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack015();\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    synchronized void syncRecurse(int depth) {\n-        if (depth > 0)\n-            syncRecurse(depth - 1);\n-    }\n-}\n-\n-abstract class stack015i extends Thread {\n-    \/\/\n-    \/\/ Pure virtual method:\n-    \/\/\n-    abstract void syncRecurse(int depth);\n-\n-    void recurse(int depth) {\n-        \/\/\n-        \/\/ Stack overflow must occur here:\n-        \/\/\n-        syncRecurse(stack015.STEP);\n-        \/\/\n-        \/\/ If no stack overflow occured, try again with deeper stack:\n-        \/\/\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-\n-    Throwable thrown = null;\n-    int depthToTry;\n-\n-    static stack015i test;\n-\n-    public void run() {\n-        \/\/\n-        \/\/ Provoke multiple stack overflows:\n-        \/\/\n-        for (int i = 0; i < stack015.CYCLES; i++)\n-            try {\n-                \/\/\n-                \/\/ All threads invoke the same synchronized method:\n-                \/\/\n-                test.recurse(depthToTry);\n-\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: there may be no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack015.java","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -1,210 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack016.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test provokes second stack overflow from within the\n- *     stack overflow handler -- repeatedly multiple times, and\n- *     in multiple threads.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     in 10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before,\n- *     and then trying to invoke that recursive method once again\n- *     from within the catch clause just caught StackOverflowError.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\")\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xint -Xss448K nsk.stress.stack.stack016 -eager\n- * @run main\/othervm\/timeout=900 -Xcomp -Xss448K nsk.stress.stack.stack016 -eager\n- * @run main\/othervm\/timeout=900 -Xcomp -XX:-TieredCompilation -Xss448K nsk.stress.stack.stack016 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-\n-public class stack016 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int STEP = 10;\n-    private final static int RESERVE = 10;\n-    private final static int PROBES = STEP * RESERVE;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        stack016.out = out;\n-        stack016 test = new stack016();\n-        return test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-    private static PrintStream out;\n-\n-    private void display(Object message) {\n-        if (!verbose)\n-            return;\n-        synchronized (out) {\n-            out.println(message.toString());\n-        }\n-    }\n-\n-    private int doRun() {\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (depthToTry = 0; ; depthToTry += STEP) {\n-            try {\n-                trickyRecurse(depthToTry);\n-                maxDepth = depthToTry;\n-            } catch (StackOverflowError | OutOfMemoryError ex) {\n-                break;\n-            }\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack016 threads[] = new stack016[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack016();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].isAlive()) {\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-            }\n-        }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-        }\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    private int stackTop = 0;\n-    private int depthToTry = 0;\n-    private Throwable thrown = null;\n-\n-    private void trickyRecurse(int depth) {\n-        stackTop = depthToTry - depth;\n-        if (depth > 0) {\n-            try {\n-                trickyRecurse(depth - 1);\n-            } catch (Error error) {\n-                if (!(error instanceof StackOverflowError) &&\n-                        !(error instanceof OutOfMemoryError))\n-                    throw error;\n-\n-                \/\/\n-                \/\/ Provoke more stack overflow,\n-                \/\/ if current stack is deep enough:\n-                \/\/\n-                if (depthToTry - depth < stackTop - PROBES)\n-                    throw error;\n-                recurse(depthToTry);\n-\n-                throw new Error(\"TEST_RFE: try deeper recursion!\");\n-            }\n-        }\n-    }\n-\n-    private static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++) {\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES +\n-                        \", depthToTry: \" + depthToTry);\n-                trickyRecurse(depthToTry);\n-                throw new Error(\n-                        \"TEST_BUG: trickyRecursion() must throw an error anyway!\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK, if there is no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                thrown = throwable;\n-                break;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack016.java","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack017.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test invokes infinitely recursive method from within stack\n- *     overflow handler  -- repeatedly multiple times, and in multiple\n- *     threads.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss220K nsk.stress.stack.stack017 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-\n-public class stack017 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int PROBES = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        stack017.out = out;\n-        stack017 test = new stack017();\n-        return test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-    private static PrintStream out;\n-\n-    private void display(Object message) {\n-        if (!verbose)\n-            return;\n-        synchronized (out) {\n-            out.println(message.toString());\n-        }\n-    }\n-\n-    private static int depthToTry;\n-\n-    private int doRun() {\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        try {\n-            recurse(0);\n-        } catch (StackOverflowError soe) {\n-        } catch (OutOfMemoryError oome) {\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-        depthToTry = maxDepth;\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack017 threads[] = new stack017[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack017();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    private int maxDepth = 0;\n-\n-    private void recurse(int depth) {\n-        maxDepth = depth;\n-        recurse(depth + 1);\n-    }\n-\n-    private void trickyRecurse(int depth) {\n-        try {\n-            maxDepth = depth;\n-            trickyRecurse(depth + 1);\n-        } catch (Error error) {\n-            if (!(error instanceof StackOverflowError) &&\n-                    !(error instanceof OutOfMemoryError))\n-                throw error;\n-\n-            \/\/\n-            \/\/ Stack problem caught: provoke it again,\n-            \/\/ if current stack is enough deep:\n-            \/\/\n-            if (depth < depthToTry - PROBES)\n-                throw error;\n-            recurse(depth + 1);\n-        }\n-    }\n-\n-    private Throwable thrown = null;\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++)\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n-                trickyRecurse(0);\n-                throw new Exception(\n-                        \"TEST_BUG: stack overflow was expected!\");\n-\n-            } catch (StackOverflowError oome) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK, if there is no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack017.java","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -1,224 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack018.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows by invocations via\n- *     reflection -- repeatedly multiple times, and in multiple threads.\n- *     Recursive method is invoked for the given fixed depth of recursion\n- *     (though, for a large depth). The test measures a number of recursive\n- *     invocations until stack overflow, and then tries to reproduce similar\n- *     stack overflows 10 times in each of 10 threads -- each time by trying\n- *     to invoke the same recursive method for the given fixed depth\n- *     of invocations (which is 100 times that crucial depth just measured).\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss220K nsk.stress.stack.stack018 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-public class stack018 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int STEP = 100;\n-    private final static int RESERVE = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        stack018.out = out;\n-        stack018 test = new stack018();\n-        return test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-    private static PrintStream out;\n-\n-    private void display(Object message) {\n-        if (!verbose)\n-            return;\n-        synchronized (out) {\n-            out.println(message.toString());\n-        }\n-    }\n-\n-    private int doRun() {\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (depthToTry = 0; ; depthToTry += STEP) {\n-            try {\n-                invokeRecurse(depthToTry);\n-                maxDepth = depthToTry;\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    break; \/\/ OK.\n-                target.printStackTrace(out);\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                return 2;\n-            }\n-        }\n-\n-        if (maxDepth == 0) {\n-            \/\/ The depth STEP was enough to cause StackOverflowError or OutOfMemoryError.\n-            maxDepth = STEP;\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack018 threads[] = new stack018[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack018();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                out.println(\"# \" + threads[i].getName()\n-                        + \": \" + threads[i].thrown);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    private int depthToTry = 0;\n-    private Throwable thrown = null;\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++)\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n-                invokeRecurse(depthToTry);\n-                throw new Error(\"TEST_RFE: try deeper invocations!\");\n-\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    continue; \/\/ OK.\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                thrown = target;\n-                break;\n-            }\n-    }\n-\n-    private static Throwable getTargetException(Throwable exception) {\n-        Throwable target;\n-        \/\/\n-        \/\/ Unwrap deep chain of exceptions to find StackOverflowError:\n-        \/\/\n-        for (\n-                target = exception;\n-                target instanceof InvocationTargetException;\n-                target = ((InvocationTargetException) target).getTargetException()\n-                )\n-            ;\n-        return target;\n-    }\n-\n-    private Method method = null;\n-    private Object params[] = null;\n-\n-    private void invokeRecurse(int depth) throws Exception {\n-        if (method == null) {\n-            \/\/\n-            \/\/ Optimization trick: allocate once, use everywhere.\n-            \/\/\n-            method = stack018.class.getMethod(\"recurse\");\n-            params = new Object[]{};\n-        }\n-        this.depth = depth; \/\/ actual parameter\n-        method.invoke(this, params);\n-    }\n-\n-    private int depth = 0; \/\/ actual parameter for recurse()\n-\n-    public void recurse() throws Exception {\n-        if (depth > 0)\n-            \/\/\n-            \/\/ Self-invoke via reflection:\n-            \/\/\n-            invokeRecurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack018.java","additions":0,"deletions":224,"binary":false,"changes":224,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack019.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test invokes infinitely recursive method from within stack\n- *     overflow handler -- repeatedly multiple times in a single thread.\n- *     The test is deemed passed, if VM have not crashed, and if exception\n- *     other than due to stack overflow was not thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *     The stack size is too small to run on systems with > 4K page size.\n- *     Making it bigger could cause timeouts on other platform.\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @requires os.family != \"windows\"\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss200K nsk.stress.stack.stack019 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-\n-public class stack019 {\n-    private final static int CYCLES = 50;\n-    private final static int PROBES = 50;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        boolean verbose = false, eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        try {\n-            recurse(0);\n-        } catch (StackOverflowError soe) {\n-        } catch (OutOfMemoryError oome) {\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-        depthToTry = maxDepth;\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        for (int i = 0; i < CYCLES; i++) {\n-            try {\n-                out.println(\"Iteration: \" + i + \"\/\" + CYCLES);\n-                trickyRecurse(0);\n-                out.println(\"# TEST_BUG: stack overflow was expected!\");\n-                return 2;\n-\n-            } catch (StackOverflowError error) {\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ It's OK: stack overflow was expected.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                throwable.printStackTrace(out);\n-                return 2;\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    private static int maxDepth;\n-    private static int depthToTry;\n-\n-    private static void recurse(int depth) {\n-        maxDepth = depth;\n-        recurse(depth + 1);\n-    }\n-\n-    private static void trickyRecurse(int depth) {\n-        try {\n-            maxDepth = depth;\n-            trickyRecurse(depth + 1);\n-        } catch (Error error) {\n-            if (!(error instanceof StackOverflowError) &&\n-                    !(error instanceof OutOfMemoryError))\n-                throw error;\n-\n-            \/\/\n-            \/\/ Stack problem caught: provoke it again,\n-            \/\/ if current stack is enough deep:\n-            \/\/\n-            if (depth < depthToTry - PROBES)\n-                throw error;\n-            recurse(depth + 1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack019.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 8309218 generic-all\n","filename":"test\/jdk\/ProblemList-generational-zgc.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java 8309218 generic-all\n-\n","filename":"test\/jdk\/ProblemList-zgc.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-java\/awt\/Frame\/MaximizedToIconified\/MaximizedToIconified.java 8296972 macosx-all\n@@ -376,1 +375,1 @@\n-java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021 macosx-all\n+java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021,8332158 macosx-all,linux-x64\n@@ -480,0 +479,4 @@\n+# Wayland related\n+\n+java\/awt\/FullScreen\/FullscreenWindowProps\/FullscreenWindowProps.java 8280991 linux-x64\n+\n@@ -536,2 +539,2 @@\n-java\/net\/DatagramSocket\/DatagramSocketExample.java              8308807 aix-ppc64\n-java\/net\/DatagramSocket\/DatagramSocketMulticasting.java         8308807 aix-ppc64\n+java\/net\/DatagramSocket\/DatagramSocketExample.java              8144003,8308807 macosx-all,aix-ppc64\n+java\/net\/DatagramSocket\/DatagramSocketMulticasting.java         8144003,8308807 macosx-all,aix-ppc64\n@@ -561,1 +564,1 @@\n-java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java      8308807 aix-ppc64\n+java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java      8144003,8308807 macosx-all,aix-ppc64\n@@ -563,0 +566,1 @@\n+java\/nio\/channels\/DatagramChannel\/BasicMulticastTests.java      8144003 macosx-all\n@@ -564,0 +568,2 @@\n+java\/nio\/channels\/DatagramChannel\/MulticastSendReceiveTests.java 8144003 macosx-all\n+java\/nio\/channels\/DatagramChannel\/Promiscuous.java              8144003 macosx-all\n@@ -566,1 +572,0 @@\n-java\/nio\/channels\/DatagramChannel\/AfterDisconnect.java          8308807 aix-ppc64\n@@ -609,3 +614,0 @@\n-com\/sun\/crypto\/provider\/Cipher\/DES\/PerformanceTest.java         8039280 generic-all\n-com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java 8039280 generic-all\n-com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java 8039280 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -595,1 +595,3 @@\n-    :jdk_core_manual_no_input_security\n+    :jdk_security_manual_no_input \\\n+    :jdk_core_manual_interactive \\\n+    :jdk_security_manual_interactive\n@@ -613,1 +615,1 @@\n-jdk_core_manual_no_input_security = \\\n+jdk_security_manual_no_input = \\\n@@ -615,1 +617,0 @@\n-    com\/sun\/crypto\/provider\/Cipher\/DES\/PerformanceTest.java \\\n@@ -618,2 +619,0 @@\n-    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java \\\n-    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java \\\n@@ -640,1 +639,0 @@\n-    sun\/security\/tools\/keytool\/i18n.java \\\n@@ -643,1 +641,4 @@\n-    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java \\\n+    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java\n+\n+jdk_security_manual_interactive = \\\n+    sun\/security\/tools\/keytool\/i18n.java \\\n@@ -645,0 +646,1 @@\n+    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java \\\n@@ -647,1 +649,0 @@\n-\n@@ -653,0 +654,4 @@\n+\n+jdk_core_no_security = \\\n+   :jdk_core \\\n+   -:jdk_security\n\\ No newline at end of file\n","filename":"test\/jdk\/TEST.groups","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main AbsPathsInImage\n+ * @run main\/othervm -Xmx900m AbsPathsInImage\n","filename":"test\/jdk\/build\/AbsPathsInImage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/manual PerformanceTest\n@@ -31,1 +30,0 @@\n-import java.security.*;\n@@ -33,1 +31,0 @@\n-import java.io.*;\n@@ -181,1 +178,1 @@\n-        start = System.currentTimeMillis();\n+        start = getTimeInMicroseconds();\n@@ -186,1 +183,1 @@\n-        end = System.currentTimeMillis();\n+        end = getTimeInMicroseconds();\n@@ -188,1 +185,3 @@\n-        int speed = (int)((data.length * count)\/(end - start));\n+        \/\/ To avoid dividing by zero in the rare case where end is equal to start\n+        long executionTime = end != start ? end - start : 1L;\n+        int speed = (int) ((data.length * count) \/ executionTime);\n@@ -201,1 +200,1 @@\n-            (\"Algorithm                      DataSize Rounds Kbytes\/sec\");\n+            (\"Algorithm                      DataSize Rounds Bytes\/microsec\");\n@@ -205,0 +204,4 @@\n+    private static long getTimeInMicroseconds() {\n+        return System.nanoTime() \/ 1000;\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/DES\/PerformanceTest.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -253,0 +253,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target()                .run();\n@@ -372,0 +373,1 @@\n+        new EARelockingSimpleWithAccessInOtherThread_02_DynamicCall()                 .run(this);\n@@ -1807,0 +1809,89 @@\n+\/\/ The debugger reads and publishes an object with eliminated locking to an instance field.\n+\/\/ A 2nd thread in the debuggee finds it there and changes its state using a synchronized method.\n+\/\/ Without eager relocking the accesses are unsynchronized which can be observed.\n+\/\/ This is a variant of EARelockingSimpleWithAccessInOtherThread with a dynamic call (not devirtualized).\n+class EARelockingSimpleWithAccessInOtherThread_02_DynamicCall extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        String l1ClassName = EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target.SyncCounter.class.getName();\n+        ObjectReference ctr = getLocalRef(bpe.thread().frame(2), l1ClassName, \"l1\");\n+        setField(testCase, \"sharedCounter\", ctr);\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+class EARelockingSimpleWithAccessInOtherThread_02_DynamicCall_Target extends EATestCaseBaseTarget {\n+\n+    public static final BrkPtDispatchA[] disp =\n+        {new BrkPtDispatchA(), new BrkPtDispatchB(), new BrkPtDispatchC(), new BrkPtDispatchD()};\n+\n+    public static class BrkPtDispatchA {\n+        public EATestCaseBaseTarget testCase;\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchB extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchC extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() { testCase.dontinline_brkpt(); }\n+    }\n+\n+    public static class BrkPtDispatchD extends BrkPtDispatchA {\n+        @Override\n+        public void dontinline_brkpt() {\n+            testCase.dontinline_brkpt();\n+        }\n+    }\n+\n+    public static class SyncCounter {\n+        private int val;\n+        public synchronized int inc() { return val++; }\n+    }\n+\n+    public volatile SyncCounter sharedCounter;\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        for (BrkPtDispatchA d : disp) {\n+            d.testCase = this;\n+        }\n+        doLoop = true;\n+        new Thread(() -> {\n+                while (doLoop) {\n+                    SyncCounter ctr = sharedCounter;\n+                    if (ctr != null) {\n+                        ctr.inc();\n+                    }\n+                }\n+            }).start();\n+    }\n+\n+    public int dispCount;\n+    public void dontinline_testMethod() {\n+        SyncCounter l1 = new SyncCounter();\n+        synchronized (l1) {      \/\/ Eliminated locking\n+            l1.inc();\n+            \/\/ Use different types for the subsequent call to prevent devirtualization.\n+            BrkPtDispatchA d = disp[(dispCount++) & 3];\n+            d.dontinline_brkpt();  \/\/ Dynamic call. Debugger publishes l1 to sharedCounter.\n+            iResult = l1.inc();    \/\/ Changes by the 2nd thread will be observed if l1\n+                                   \/\/ was not relocked before passing it to the debugger.\n+        }\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 1;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8251496\n- * @summary Tests for methods in Authenticator\n- * @run testng\/othervm AuthenticatorTest\n- *\/\n-\n-import com.sun.net.httpserver.Authenticator;\n-import com.sun.net.httpserver.BasicAuthenticator;\n-import com.sun.net.httpserver.HttpPrincipal;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-\n-public class AuthenticatorTest {\n-    @Test\n-    public void testFailure() {\n-        var failureResult = new Authenticator.Failure(666);\n-        assertEquals(failureResult.getResponseCode(), 666);\n-    }\n-\n-    @Test\n-    public void testRetry() {\n-        var retryResult = new Authenticator.Retry(333);\n-        assertEquals(retryResult.getResponseCode(), 333);\n-    }\n-\n-    @Test\n-    public void TestSuccess() {\n-        var principal = new HttpPrincipal(\"test\", \"123\");\n-        var successResult = new Authenticator.Success(principal);\n-        assertEquals(successResult.getPrincipal(), principal);\n-        assertEquals(\"test\", principal.getName());\n-        assertEquals(\"123\", principal.getRealm());\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/AuthenticatorTest","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8251496\n+ * @summary Tests for methods in Authenticator\n+ * @run junit AuthenticatorTest\n+ *\/\n+\n+import com.sun.net.httpserver.Authenticator;\n+import com.sun.net.httpserver.HttpPrincipal;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\n+public class AuthenticatorTest {\n+    @Test\n+    public void testFailure() {\n+        var failureResult = new Authenticator.Failure(666);\n+        assertEquals(666, failureResult.getResponseCode());\n+    }\n+\n+    @Test\n+    public void testRetry() {\n+        var retryResult = new Authenticator.Retry(333);\n+        assertEquals(333, retryResult.getResponseCode());\n+    }\n+\n+    @Test\n+    public void testSuccess() {\n+        var principal = new HttpPrincipal(\"test\", \"123\");\n+        var successResult = new Authenticator.Success(principal);\n+        assertEquals(principal, successResult.getPrincipal());\n+        assertEquals(\"test\", principal.getUsername());\n+        assertEquals(\"123\", principal.getRealm());\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/AuthenticatorTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib \/java\/security\/testlibrary\n@@ -28,1 +29,1 @@\n- * @run main\/manual Default\n+ * @run main\/othervm Default\n@@ -32,0 +33,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -33,0 +36,1 @@\n+import java.io.*;\n@@ -35,16 +39,25 @@\n-   public static void main(String args[]) throws Exception {\n-        TextCallbackHandler h = new TextCallbackHandler();\n-        NameCallback nc = new NameCallback(\"Name: \", \"charlie\");\n-        ConfirmationCallback cc = new ConfirmationCallback\n-                        (\"Correct?\",\n-                        ConfirmationCallback.INFORMATION,\n-                        ConfirmationCallback.YES_NO_OPTION,\n-                        ConfirmationCallback.NO);\n-\n-        Callback[] callbacks = { nc, cc };\n-        h.handle(callbacks);\n-\n-        if (cc.getSelectedIndex() == ConfirmationCallback.YES) {\n-            System.out.println(\"yes\");\n-        } else {\n-            System.out.println(\"no\");\n+    public static void main(String args[]) throws Exception {\n+        InputStream in = System.in;\n+        PrintStream err = System.err;\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final String defaultName = \"charlie\";\n+        final String simulatedInput = \"-1\\n-1\\n\";\n+        HumanInputStream humanInputStream = new HumanInputStream(simulatedInput);\n+\n+        try (PrintStream prints = new PrintStream(baos)) {\n+            System.setIn(humanInputStream);\n+            System.setErr(prints);\n+            NameCallback nameCallback = new NameCallback(\"Name: \", defaultName);\n+            ConfirmationCallback confirmationCallback = new ConfirmationCallback(\n+                    \"Correct?\",\n+                    ConfirmationCallback.INFORMATION,\n+                    ConfirmationCallback.YES_NO_OPTION,\n+                    ConfirmationCallback.NO);\n+            new TextCallbackHandler().handle(new Callback[]{nameCallback, confirmationCallback});\n+\n+            Asserts.assertEquals(nameCallback.getDefaultName(), defaultName);\n+            Asserts.assertEquals(confirmationCallback.getSelectedIndex(), ConfirmationCallback.NO);\n+\n+        } finally {\n+            System.setIn(in);\n+            System.setErr(err);\n@@ -52,1 +65,5 @@\n-   }\n+\n+        \/\/ check that the default name and confirmation were visible in the output\n+        Asserts.assertTrue(baos.toString().contains(String.format(\"Name:  [%s]\", defaultName)));\n+        Asserts.assertTrue(baos.toString().contains(\"1. No [default]\"));\n+    }\n","filename":"test\/jdk\/com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Default.java","additions":36,"deletions":19,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6825240\n+ * @bug 6825240 6829785\n@@ -31,0 +31,12 @@\n+\/*\n+ * This scenario cannot be automated because util\/Password.java verifies the given input stream is\n+ * equal to the initialSystemIn. This prevents the test from providing a custom input stream.\n+ *\n+ *  Steps to run the test:\n+ *  1) Compile the class using the JDK version being tested: '<JdkBin>\/javac Password.java'\n+ *  2) Run the test using the JDK version being tested: '<JdkBin>\/java -cp . Password'\n+ *  3) Type in the first password, it should not be visible in the console\n+ *  4) Type in the second password, it should be visible in the console\n+ *  5) The final output line displays the entered passwords, both should be visible\n+ *\/\n+\n","filename":"test\/jdk\/com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    static volatile int lastFrameState = Frame.NORMAL;\n+    static volatile int lastFrameState;\n@@ -80,0 +80,2 @@\n+        lastFrameState = Frame.NORMAL;\n+\n@@ -117,0 +119,1 @@\n+        System.out.println(\"------\");\n@@ -118,0 +121,4 @@\n+        System.out.println(\"------\");\n+        examineStates(new int[] {Frame.NORMAL, Frame.MAXIMIZED_BOTH, Frame.ICONIFIED});\n+        System.out.println(\"------\");\n+        examineStates(new int[] {Frame.NORMAL, Frame.ICONIFIED, Frame.MAXIMIZED_BOTH});\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizedToIconified\/MaximizedToIconified.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Robot;\n+import jtreg.SkippedException;\n+\n+import static java.awt.EventQueue.invokeAndWait;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8312518\n+ * @library \/test\/lib\n+ * @summary Setting fullscreen window using setFullScreenWindow() shows up\n+ *          as black screen on newer macOS versions (13 & 14).\n+ *\/\n+\n+public class SetFullScreenTest {\n+    private static Frame frame;\n+    private static GraphicsDevice gd;\n+    private static Robot robot;\n+    private static volatile int width;\n+    private static volatile int height;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            robot = new Robot();\n+            invokeAndWait(() -> {\n+                gd = GraphicsEnvironment.getLocalGraphicsEnvironment().\n+                        getDefaultScreenDevice();\n+                if (!gd.isFullScreenSupported()) {\n+                    throw new SkippedException(\"Full Screen mode not supported\");\n+                }\n+            });\n+\n+            invokeAndWait(() -> {\n+                frame = new Frame(\"Test FullScreen mode\");\n+                frame.setBackground(Color.RED);\n+                frame.setSize(100, 100);\n+                frame.setLocation(10, 10);\n+                frame.setVisible(true);\n+            });\n+            robot.delay(1000);\n+\n+            invokeAndWait(() -> gd.setFullScreenWindow(frame));\n+            robot.waitForIdle();\n+            robot.delay(300);\n+\n+            invokeAndWait(() -> {\n+                width = gd.getFullScreenWindow().getWidth();\n+                height = gd.getFullScreenWindow().getHeight();\n+            });\n+\n+            if (!robot.getPixelColor(width \/ 2, height \/ 2).equals(Color.RED)) {\n+                System.err.println(\"Actual color: \" + robot.getPixelColor(width \/ 2, height \/ 2)\n+                                    + \" Expected color: \" + Color.RED);\n+                throw new RuntimeException(\"Test Failed! Window not in full screen mode\");\n+            }\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/FullScreen\/SetFullScreenTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 5010944 6248072\n+  @summary List's rows overlap one another\n+  @library \/java\/awt\/regtesthelpers\n+  @run main\/manual SetFontTest\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.FlowLayout;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+public class SetFontTest {\n+\n+    static final String INSTRUCTIONS = \"\"\"\n+        1) Click on the 'Enlarge font' button to enlarge font of the list.\n+        2) If you see that the rows of the list overlap one another\n+        then the test failed. Otherwise, go to step 3.\n+        3) Click on the 'Change mode' button to set multiple-selection mode.\n+        4) If you see that the rows of the list overlap one another\n+        then the test failed. Otherwise, the test passed.\n+    \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                      .title(\"AWT List Font Test\")\n+                       .instructions(INSTRUCTIONS)\n+                       .rows(10)\n+                       .columns(40)\n+                       .testUI(SetFontTest::createFontTest)\n+                       .build()\n+                       .awaitAndCheck();\n+    }\n+\n+    static Frame createFontTest() {\n+\n+        Frame frame = new Frame(\"List Font Test\");\n+        List list = new List(8, false);\n+        Button button1 = new Button(\"Enlarge font\");\n+        Button button2 = new Button(\"Change mode\");\n+\n+        list.add(\"111\");\n+        list.add(\"222\");\n+        list.add(\"333\");\n+        list.add(\"444\");\n+\n+        button1.addActionListener(\n+            new ActionListener(){\n+                public void actionPerformed(ActionEvent ae) {\n+                    list.setFont(new Font(\"SansSerif\", Font.PLAIN, 30));\n+                    list.repaint();\n+                }\n+            });\n+\n+        button2.addActionListener(\n+            new ActionListener(){\n+                public void actionPerformed(ActionEvent ae){\n+                    list.setMultipleMode(true);\n+                }\n+            });\n+\n+        frame.setLayout(new FlowLayout());\n+        frame.add(list);\n+        frame.add(button1);\n+        frame.add(button2);\n+        frame.setSize(200, 250);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/SetFontTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -1,43 +0,0 @@\n-<!--\n- Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-\n-<html>\n-<!--  \n-  @test\n-  @bug 5010944 6248072\n-  @summary List's rows overlap one another\n-  @author Dmitry Cherepanov area=awt-list\n-  @run applet\/manual=yesno SetFontTest.html\n-  -->\n-<head>\n-<title> SetFontTest <\/title>\n-<\/head>\n-<body>\n-\n-<h1>SetFontTest<br>Bug ID: 5010944<\/h1>\n-\n-<p> See the dialog box (usually in upper left corner) for instructions<\/p>\n-\n-<APPLET CODE=\"SetFontTest.class\" WIDTH=200 HEIGHT=220><\/APPLET>\n-<\/body>\n-<\/html>\n","filename":"test\/jdk\/java\/awt\/List\/SetFontTest\/SetFontTest.html","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,234 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2007, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  test\n-  @bug 5010944 6248072\n-  @summary List's rows overlap one another\n-  @author Dmitry Cherepanov area=awt-list\n-  @run applet\/manual=yesno SetFontTest.html\n-*\/\n-\n-import java.applet.Applet;\n-import java.awt.*;\n-import java.awt.event.*;\n-\n-public class SetFontTest extends Applet\n-{\n-    List list = new List(8, false);\n-    Button button1 = new Button(\"Enlarge font\");\n-    Button button2 = new Button(\"Change mode\");\n-\n-    public void init()\n-    {\n-        list.add(\"111\");\n-        list.add(\"222\");\n-        list.add(\"333\");\n-        list.add(\"444\");\n-        this.add(list);\n-\n-        this.add(button1);\n-        this.add(button2);\n-\n-        button1.addActionListener(\n-            new ActionListener(){\n-                public void actionPerformed(ActionEvent ae){\n-                    list.setFont( new Font( \"SansSerif\", Font.PLAIN, 30 ) );\n-                    list.repaint();\n-                }\n-            });\n-\n-        button2.addActionListener(\n-            new ActionListener(){\n-                public void actionPerformed(ActionEvent ae){\n-                    list.setMultipleMode(true);\n-                }\n-            });\n-\n-        this.setLayout (new FlowLayout ());\n-\n-        String[] instructions =\n-        {\n-            \"1) Click on the 'Enlarge font' button to enlarge font of the list.\",\n-            \"2) If you see that the rows of the list overlap one another \"+\n-            \"then the test failed. Otherwise, goto to the step 3.\",\n-            \"3) Click on the 'Change mode' button to set multiple-selection mode.\",\n-            \"4) If you see that the rows of the list overlap one another \"+\n-            \"then the test failed. Otherwise, the test passed.\"\n-        };\n-        Sysout.createDialogWithInstructions( instructions );\n-\n-    }\/\/End  init()\n-\n-    public void start ()\n-    {\n-\n-        setSize (200,200);\n-        setVisible(true);\n-        validate();\n-\n-    }\/\/ start()\n-}\n-\n-\/* Place other classes related to the test after this line *\/\n-\n-\n-\n-\n-\n-\/****************************************************\n- Standard Test Machinery\n- DO NOT modify anything below -- it's a standard\n-  chunk of code whose purpose is to make user\n-  interaction uniform, and thereby make it simpler\n-  to read and understand someone else's test.\n- ****************************************************\/\n-\n-\/**\n- This is part of the standard test machinery.\n- It creates a dialog (with the instructions), and is the interface\n-  for sending text messages to the user.\n- To print the instructions, send an array of strings to Sysout.createDialog\n-  WithInstructions method.  Put one line of instructions per array entry.\n- To display a message for the tester to see, simply call Sysout.println\n-  with the string to be displayed.\n- This mimics System.out.println but works within the test harness as well\n-  as standalone.\n- *\/\n-\n-class Sysout\n-{\n-    private static TestDialog dialog;\n-\n-    public static void createDialogWithInstructions( String[] instructions )\n-    {\n-        dialog = new TestDialog( new Frame(), \"Instructions\" );\n-        dialog.printInstructions( instructions );\n-        dialog.setVisible(true);\n-        println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-    public static void createDialog( )\n-    {\n-        dialog = new TestDialog( new Frame(), \"Instructions\" );\n-        String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-        dialog.printInstructions( defInstr );\n-        dialog.setVisible(true);\n-        println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-    public static void printInstructions( String[] instructions )\n-    {\n-        dialog.printInstructions( instructions );\n-    }\n-\n-\n-    public static void println( String messageIn )\n-    {\n-        dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog\n-{\n-\n-    TextArea instructionsText;\n-    TextArea messageText;\n-    int maxStringLength = 80;\n-\n-    \/\/DO NOT call this directly, go through Sysout\n-    public TestDialog( Frame frame, String name )\n-    {\n-        super( frame, name );\n-        int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-        instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-        add( \"North\", instructionsText );\n-\n-        messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-        add(\"Center\", messageText);\n-\n-        pack();\n-\n-        setVisible(true);\n-    }\/\/ TestDialog()\n-\n-    \/\/DO NOT call this directly, go through Sysout\n-    public void printInstructions( String[] instructions )\n-    {\n-        \/\/Clear out any current instructions\n-        instructionsText.setText( \"\" );\n-\n-        \/\/Go down array of instruction strings\n-\n-        String printStr, remainingStr;\n-        for( int i=0; i < instructions.length; i++ )\n-        {\n-            \/\/chop up each into pieces maxSringLength long\n-            remainingStr = instructions[ i ];\n-            while( remainingStr.length() > 0 )\n-            {\n-                \/\/if longer than max then chop off first max chars to print\n-                if( remainingStr.length() >= maxStringLength )\n-                {\n-                    \/\/Try to chop on a word boundary\n-                    int posOfSpace = remainingStr.\n-                        lastIndexOf( ' ', maxStringLength - 1 );\n-\n-                    if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-                    printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-                    remainingStr = remainingStr.substring( posOfSpace + 1 );\n-                }\n-                \/\/else just print\n-                else\n-                {\n-                    printStr = remainingStr;\n-                    remainingStr = \"\";\n-                }\n-\n-                instructionsText.append( printStr + \"\\n\" );\n-\n-            }\/\/ while\n-\n-        }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-    \/\/DO NOT call this directly, go through Sysout\n-    public void displayMessage( String messageIn )\n-    {\n-        messageText.append( messageIn + \"\\n\" );\n-        System.out.println(messageIn);\n-    }\n-\n-}\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/List\/SetFontTest\/SetFontTest.java","additions":0,"deletions":234,"binary":false,"changes":234,"status":"deleted"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetAdapter;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+\n+\/*\n+ * @test\n+ * @bug 8031964\n+ * @summary Dragging images from the browser does not work.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual URLDragTest\n+*\/\n+\n+public class URLDragTest {\n+    private static final String INSTRUCTIONS = \"\"\"\n+            1) When the test starts, open any browser.\n+            2) Drag any image from the browser page onto the RED window.\n+            3) When the image is dropped you should see the list of available\n+               DataFlavors in the log area below the instruction window.\n+            4) If you see application\/x-java-url and text\/uri-list flavors in\n+               the logs then please press PASS, else FAIL.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(40)\n+                .logArea(8)\n+                .testUI(URLDragTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame frame = new Frame(\"Browser Image DnD Test\");\n+        frame.setBackground(Color.RED);\n+        frame.setDropTarget(new DropTarget(frame,\n+                DnDConstants.ACTION_COPY,\n+                new DropTargetAdapter() {\n+                    @Override\n+                    public void dragEnter(DropTargetDragEvent dtde) {\n+                        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+                    }\n+\n+                    @Override\n+                    public void dragOver(DropTargetDragEvent dtde) {\n+                        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+                    }\n+\n+                    @Override\n+                    public void drop(DropTargetDropEvent dtde) {\n+                        dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+                        dtde.getCurrentDataFlavorsAsList()\n+                                .stream()\n+                                .map(DataFlavor::toString)\n+                                .forEach(PassFailJFrame::log);\n+                    }\n+                }));\n+\n+        frame.setSize(400, 200);\n+        frame.setAlwaysOnTop(true);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/URLDragTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -1,45 +0,0 @@\n-<!--\n- Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-\n-<html>\n-<!--  \n-  @test\n-  @bug 8031964\n-  @summary Dragging images from the browser does not work\n-  @author Petr Pchelko : area=dnd\n-  @library ..\/..\/regtesthelpers\n-  @build Sysout\n-  @run applet\/manual=yesno URLDragTest.html\n--->\n-<head>\n-<title> DnD of URL across JVM <\/title>\n-<\/head>\n-<body>\n-\n-<h1>URLDragTest<br>Bug ID: 8031964<\/h1>\n-\n-<p> This is an AUTOMATIC test, simply wait for completion <\/p>\n-\n-<APPLET CODE=\"URLDragTest.class\" WIDTH=200 HEIGHT=200><\/APPLET>\n-<\/body>\n-<\/html>\n","filename":"test\/jdk\/java\/awt\/dnd\/URLDragTest\/URLDragTest.html","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  test\n-  @bug 8031964\n-  @summary Dragging images from the browser does not work\n-  @author Petr Pchelko : area=dnd\n-  @library ..\/..\/regtesthelpers\n-  @build Sysout\n-  @run applet\/manual=yesno URLDragTest.html\n-*\/\n-\n-import test.java.awt.regtesthelpers.Sysout;\n-\n-import java.applet.Applet;\n-import java.awt.*;\n-import java.awt.datatransfer.DataFlavor;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DropTarget;\n-import java.awt.dnd.DropTargetAdapter;\n-import java.awt.dnd.DropTargetDragEvent;\n-import java.awt.dnd.DropTargetDropEvent;\n-\n-public class URLDragTest extends Applet {\n-\n-\n-    @Override\n-    public void init() {\n-        setBackground(Color.red);\n-        setDropTarget(new DropTarget(this,\n-                DnDConstants.ACTION_COPY,\n-                new DropTargetAdapter() {\n-                    @Override\n-                    public void dragEnter(DropTargetDragEvent dtde) {\n-                        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n-                    }\n-\n-                    @Override\n-                    public void dragOver(DropTargetDragEvent dtde) {\n-                        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n-                    }\n-\n-                    @Override\n-                    public void drop(DropTargetDropEvent dtde) {\n-                        dtde.acceptDrop(DnDConstants.ACTION_COPY);\n-                        dtde.getCurrentDataFlavorsAsList()\n-                                .stream()\n-                                .map(DataFlavor::toString)\n-                                .forEach(Sysout::println);\n-                    }\n-                }));\n-\n-        String[] instructions = {\n-                \"1) Open the browser.\",\n-                \"2) Drag any image from the browser page to the red square\",\n-                \"3) When the image is dropped you should se the list of available DataFlavors\",\n-                \"4) If you see application\/x-java-url and text\/uri-list flavors - test PASSED\",\n-                \"5) Otherwise the test is FAILED\"};\n-        Sysout.createDialogWithInstructions(instructions);\n-    }\n-\n-    @Override\n-    public void start() {\n-        setSize(200, 200);\n-        setVisible(true);\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/dnd\/URLDragTest\/URLDragTest.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,12 @@\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static java.awt.Event.KEY_ACTION;\n+import static java.awt.Event.KEY_ACTION_RELEASE;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n@@ -42,2 +54,2 @@\n-public class FunctionKeyTest {\n-    private static FunctionKeyTester frame;\n+public final class FunctionKeyTest {\n+    private static Frame frame;\n@@ -46,2 +58,2 @@\n-    static volatile boolean keyPressReceived;\n-    static volatile boolean keyReleaseReceived;\n+    private static final CyclicBarrier keyPress = new CyclicBarrier(2);\n+    private static final CyclicBarrier keyRelease = new CyclicBarrier(2);\n@@ -49,1 +61,1 @@\n-    static final StringBuilder failures = new StringBuilder();\n+    private static final CountDownLatch frameActivated = new CountDownLatch(1);\n@@ -51,3 +63,2 @@\n-    private static void testKey(int keyCode, String keyText) {\n-        keyPressReceived = false;\n-        keyReleaseReceived = false;\n+    private static final List<Error> failures = new ArrayList<>(4);\n+    private static final AtomicReference<Exception> edtException = new AtomicReference<>();\n@@ -55,0 +66,1 @@\n+    private static void testKey(int keyCode, String keyText) throws Exception {\n@@ -56,3 +68,5 @@\n-\n-        if (!keyPressReceived) {\n-            failures.append(keyText).append(\" key press is not received\\n\");\n+        try {\n+            keyPress.await(2, SECONDS);\n+        } catch (TimeoutException e) {\n+            keyPress.reset();\n+            failures.add(new Error(keyText + \" key press is not received\", e));\n@@ -62,3 +76,5 @@\n-\n-        if (!keyReleaseReceived) {\n-            failures.append(keyText).append(\" key release is not received\\n\");\n+        try {\n+            keyRelease.await(2, SECONDS);\n+        } catch (TimeoutException e) {\n+            keyRelease.reset();\n+            failures.add(new Error(keyText + \" key release is not received\", e));\n@@ -70,1 +86,0 @@\n-        robot.setAutoWaitForIdle(true);\n@@ -78,0 +93,7 @@\n+                frame.addWindowListener(new WindowAdapter() {\n+                    @Override\n+                    public void windowActivated(WindowEvent e) {\n+                        System.out.println(\"frame.windowActivated\");\n+                        frameActivated.countDown();\n+                    }\n+                });\n@@ -81,2 +103,4 @@\n-            robot.waitForIdle();\n-            robot.delay(1000);\n+            if (!frameActivated.await(2, SECONDS)) {\n+                throw new Error(\"Frame wasn't activated\");\n+            }\n+            robot.delay(100);\n@@ -94,4 +118,10 @@\n-        if (failures.isEmpty()) {\n-            System.out.println(\"Passed\");\n-        } else {\n-            throw new RuntimeException(failures.toString());\n+        if (!failures.isEmpty()) {\n+            System.err.println(\"Failures detected:\");\n+            failures.forEach(System.err::println);\n+            if (edtException.get() != null) {\n+                System.err.println(\"\\nException on EDT:\");\n+                edtException.get().printStackTrace();\n+            }\n+            System.err.println();\n+            throw new RuntimeException(\"Test failed: \" + failures.get(0).getMessage(),\n+                                       failures.get(0));\n@@ -99,2 +129,0 @@\n-    }\n-}\n@@ -102,15 +130,4 @@\n-class FunctionKeyTester extends Frame {\n-    Label l = new Label (\"NULL\");\n-    Button b = new Button();\n-    TextArea log = new TextArea();\n-\n-    FunctionKeyTester() {\n-        super(\"Function Key Test\");\n-        this.setLayout(new BorderLayout());\n-        this.add(BorderLayout.NORTH, l);\n-        this.add(BorderLayout.SOUTH, b);\n-        this.add(BorderLayout.CENTER, log);\n-        log.setFocusable(false);\n-        log.setEditable(false);\n-        l.setBackground(Color.red);\n-        setSize(200, 200);\n+        if (edtException.get() != null) {\n+            throw new RuntimeException(\"Test failed because of exception on EDT\",\n+                                       edtException.get());\n+        }\n@@ -119,8 +136,15 @@\n-    public boolean handleEvent(Event e) {\n-        String message = \"e.id=\" + e.id + \"\\n\";\n-        System.out.print(message);\n-        log.append(message);\n-\n-        switch (e.id) {\n-            case 403 -> FunctionKeyTest.keyPressReceived = true;\n-            case 404 -> FunctionKeyTest.keyReleaseReceived = true;\n+    private static final class FunctionKeyTester extends Frame {\n+        Label l = new Label (\"NULL\");\n+        Button b = new Button(\"button\");\n+        TextArea log = new TextArea();\n+\n+        FunctionKeyTester() {\n+            super(\"Function Key Test\");\n+            this.setLayout(new BorderLayout());\n+            this.add(BorderLayout.NORTH, l);\n+            this.add(BorderLayout.SOUTH, b);\n+            this.add(BorderLayout.CENTER, log);\n+            log.setFocusable(false);\n+            log.setEditable(false);\n+            l.setBackground(Color.red);\n+            setSize(200, 200);\n@@ -129,2 +153,19 @@\n-        return super.handleEvent(e);\n-    }\n+        @Override\n+        @SuppressWarnings(\"deprecation\")\n+        public boolean handleEvent(Event e) {\n+            String message = \"e.id=\" + e.id + \"\\n\";\n+            System.out.print(message);\n+            log.append(message);\n+\n+            try {\n+                switch (e.id) {\n+                    case KEY_ACTION\n+                            -> keyPress.await();\n+                    case KEY_ACTION_RELEASE\n+                            -> keyRelease.await();\n+                }\n+            } catch (Exception ex) {\n+                if (!edtException.compareAndSet(null, ex)) {\n+                    edtException.get().addSuppressed(ex);\n+                }\n+            }\n@@ -132,3 +173,9 @@\n-    public boolean keyDown(Event e, int key) {\n-        l.setText(\"e.key=\" + Integer.valueOf(e.key).toString());\n-        return false;\n+            return super.handleEvent(e);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"deprecation\")\n+        public boolean keyDown(Event e, int key) {\n+            l.setText(\"e.key=\" + e.key);\n+            return false;\n+        }\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/FunctionKeyTest.java","additions":99,"deletions":52,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.Toolkit;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.test.lib.Platform;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+\/*\n+ * @test\n+ * @bug 4724007\n+ * @key headful\n+ * @summary Tests that KeyTyped events are fired for the Numpad1 key\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main Numpad1KeyTyped\n+ *\/\n+public final class Numpad1KeyTyped extends FocusAdapter implements KeyListener {\n+\n+    private static final String ORIGINAL = \"0123456789\";\n+    private static final String EXPECTED = \"10123456789\";\n+\n+    private final CountDownLatch typedNum1 = new CountDownLatch(1);\n+    private final CountDownLatch focusGained = new CountDownLatch(1);\n+\n+    public static void main(String[] args) throws Exception {\n+        Numpad1KeyTyped test = new Numpad1KeyTyped();\n+        test.start();\n+    }\n+\n+    private void start() throws Exception {\n+        Toolkit toolkit = Toolkit.getDefaultToolkit();\n+        Boolean oldState = null;\n+\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(100);\n+\n+        Frame frame = new Frame(\"Numpad1KeyTyped\");\n+        TextField tf = new TextField(ORIGINAL, 20);\n+        frame.add(tf);\n+        tf.addKeyListener(this);\n+\n+        tf.addFocusListener(this);\n+\n+        frame.setSize(300, 100);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+        tf.requestFocusInWindow();\n+\n+        if (!focusGained.await(2, SECONDS)) {\n+            throw new RuntimeException(\"TextField didn't receive focus\");\n+        }\n+        robot.waitForIdle();\n+\n+        try {\n+            \/\/ Move cursor to start of TextField\n+            robot.keyPress(KeyEvent.VK_HOME);\n+            robot.keyRelease(KeyEvent.VK_HOME);\n+            robot.waitForIdle();\n+\n+            if (Platform.isLinux()) {\n+                \/\/ Press but don't release NumLock\n+                robot.keyPress(KeyEvent.VK_NUM_LOCK);\n+            }\n+            if (Platform.isWindows()) {\n+                oldState = toolkit.getLockingKeyState(KeyEvent.VK_NUM_LOCK);\n+                toolkit.setLockingKeyState(KeyEvent.VK_NUM_LOCK, true);\n+            }\n+\n+            \/\/ Press and release Numpad-1\n+            robot.keyPress(KeyEvent.VK_NUMPAD1);\n+            robot.keyRelease(KeyEvent.VK_NUMPAD1);\n+\n+            if (!typedNum1.await(2, SECONDS)) {\n+                throw new RuntimeException(\"TextField didn't receive keyTyped('1') - too slow\");\n+            }\n+\n+            final String text = tf.getText();\n+            if (!text.equals(EXPECTED)) {\n+                throw new RuntimeException(\"Test FAILED: wrong string '\"\n+                                           + text + \"' vs \"\n+                                           + \"expected '\" + EXPECTED + \"'\");\n+            }\n+            System.out.println(\"Test PASSED\");\n+        } finally {\n+            if (Platform.isLinux()) {\n+                \/\/ \"release\" + \"press and release\" NumLock to disable numlock\n+                robot.keyRelease(KeyEvent.VK_NUM_LOCK);\n+                robot.keyPress(KeyEvent.VK_NUM_LOCK);\n+                robot.keyRelease(KeyEvent.VK_NUM_LOCK);\n+            }\n+            if (oldState != null) {\n+                toolkit.setLockingKeyState(KeyEvent.VK_NUM_LOCK, oldState);\n+            }\n+\n+            frame.dispose();\n+        }\n+    }\n+\n+    @Override\n+    public void focusGained(FocusEvent e) {\n+        System.out.println(\"tf.focusGained\");\n+        focusGained.countDown();\n+    }\n+\n+    @Override\n+    public void keyPressed(KeyEvent evt) {\n+        printKey(evt);\n+    }\n+\n+    @Override\n+    public void keyTyped(KeyEvent evt) {\n+        printKey(evt);\n+\n+        int keychar = evt.getKeyChar();\n+        if (keychar == '1') {\n+            typedNum1.countDown();\n+        }\n+    }\n+\n+    @Override\n+    public void keyReleased(KeyEvent evt) {\n+        printKey(evt);\n+        System.out.println();\n+    }\n+\n+    private static void printKey(KeyEvent evt) {\n+        int id = evt.getID();\n+        if (id != KeyEvent.KEY_TYPED\n+            && id != KeyEvent.KEY_PRESSED\n+            && id != KeyEvent.KEY_RELEASED) {\n+\n+            System.out.println(\"Other Event\");\n+            return;\n+        }\n+\n+        System.out.println(\"params= \" + evt.paramString() + \"  \\n\" +\n+          \"KeyChar: \" + evt.getKeyChar() + \" = \" + (int) evt.getKeyChar() +\n+          \"   KeyCode: \" + evt.getKeyCode() +\n+          \"   Modifiers: \" + evt.getModifiersEx());\n+\n+        if (evt.isActionKey()) {\n+            System.out.println(\"   Action Key\");\n+        }\n+\n+        System.out.println(\"keyText= \" + KeyEvent.getKeyText(evt.getKeyCode()) + \"\\n\");\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/KeyTyped\/Numpad1KeyTyped.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,13 @@\n+import java.awt.BasicStroke;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Pageable;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import jtreg.SkippedException;\n+\n@@ -27,0 +40,12 @@\n+ * @key printer\n+ * @summary Prints a rectangle to show the imageable area of a\n+ *          12in x 14in custom paper size.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @library \/test\/lib\n+ * @build PassFailJFrame\n+ * @build jtreg.SkippedException\n+ * @run main\/manual CustomPaper 4355514\n+ *\/\n+\n+\/*\n+ * @test\n@@ -31,1 +56,5 @@\n- * @run main\/manual CustomPaper\n+ * @library \/java\/awt\/regtesthelpers\n+ * @library \/test\/lib\n+ * @build PassFailJFrame\n+ * @build jtreg.SkippedException\n+ * @run main\/manual CustomPaper 4385157\n@@ -33,0 +62,1 @@\n+public class CustomPaper implements Pageable, Printable {\n@@ -34,50 +64,4 @@\n-import java.awt.*;\n-import java.awt.print.*;\n-import java.awt.geom.*;\n-\n-public class CustomPaper implements Pageable, Printable{\n-\n-  private static double PIXELS_PER_INCH = 72.0;\n-\n-  private PrinterJob printerJob;\n-  private PageFormat pageFormat;\n-\n-  CustomPaper(){\n-    printerJob = PrinterJob.getPrinterJob();\n-    createPageFormat();\n-  }\n-\n-  private void createPageFormat(){\n-    pageFormat = new PageFormat();\n-    Paper p = new Paper();\n-    double width   = 12.0*PIXELS_PER_INCH;\n-    double height  = 14.0*PIXELS_PER_INCH;\n-    double ix      = PIXELS_PER_INCH;\n-    double iy      = PIXELS_PER_INCH;\n-    double iwidth  = width  - 2.0*PIXELS_PER_INCH;\n-    double iheight = height - 2.0*PIXELS_PER_INCH;\n-    p.setSize(width, height);\n-    p.setImageableArea(ix, iy, iwidth, iheight);\n-    pageFormat.setPaper(p);\n-  }\n-\n-  public Printable getPrintable(int index){\n-    return this;\n-  }\n-\n-  public PageFormat getPageFormat(int index){\n-    return pageFormat;\n-  }\n-\n-  public int getNumberOfPages(){\n-    return 1;\n-  }\n-\n-  public void print(){\n-    if(printerJob.printDialog())\n-        {\n-      try{\n-        printerJob.setPageable(this);\n-        printerJob.print();\n-      }catch(Exception e){e.printStackTrace();}\n-    }\n+    private static final double PIXELS_PER_INCH = 72.0;\n+\n+    private final PrinterJob printerJob;\n+    private PageFormat pageFormat;\n@@ -85,14 +69,3 @@\n-  }\n-\n-  public int print(Graphics g, PageFormat pf, int pageIndex){\n-    if(pageIndex == 0){\n-        Graphics2D g2 = (Graphics2D)g;\n-        Rectangle2D r = new Rectangle2D.Double(pf.getImageableX(),\n-                                               pf.getImageableY(),\n-                                               pf.getImageableWidth(),\n-                                               pf.getImageableHeight());\n-      g2.setStroke(new BasicStroke(3.0f));\n-      g2.draw(r);\n-      return PAGE_EXISTS;\n-    }else{\n-      return NO_SUCH_PAGE;\n+    CustomPaper() {\n+        printerJob = PrinterJob.getPrinterJob();\n+        createPageFormat();\n@@ -100,23 +73,0 @@\n-  }\n-\n-  public static void main(String[] args){\n-\n-        String[] instructions =\n-        {\n-            \"You must have a printer that supports custom paper size of \",\n-            \"at least 12 x 14 inches to perform this test. It requires\",\n-            \"user interaction and you must have a 12 x 14 inch paper available.\",\n-            \" \",\n-            \"To test bug ID 4385157, click OK on print dialog box to print.\",\n-            \" \",\n-            \"To test bug ID 4355514, select the printer in the Print Setup dialog and add a \",\n-            \"custom paper size under Printer properties' Paper selection menu. \",\n-            \"Set the dimension  to width=12 inches and height=14 inches.\",\n-            \"Select this custom paper size before proceeding to print.\",\n-            \" \",\n-            \"Visual inspection of the one-page printout is needed. A passing\",\n-            \"test will print a rectangle of the imageable area which is approximately\",\n-            \"10 x 12 inches.\",\n-        };\n-        Sysout.createDialog( );\n-        Sysout.printInstructions( instructions );\n@@ -124,4 +74,11 @@\n-        CustomPaper pt = new CustomPaper();\n-        pt.print();\n-        \/\/System.exit (0);\n-  }\n+    private void createPageFormat() {\n+        pageFormat = new PageFormat();\n+        Paper p = new Paper();\n+        double width = 12.0 * PIXELS_PER_INCH;\n+        double height = 14.0 * PIXELS_PER_INCH;\n+        double iwidth = width - 2.0 * PIXELS_PER_INCH;\n+        double iheight = height - 2.0 * PIXELS_PER_INCH;\n+        p.setSize(width, height);\n+        p.setImageableArea(PIXELS_PER_INCH, PIXELS_PER_INCH, iwidth, iheight);\n+        pageFormat.setPaper(p);\n+    }\n@@ -129,1 +86,4 @@\n-}\n+    @Override\n+    public Printable getPrintable(int index) {\n+        return this;\n+    }\n@@ -131,0 +91,4 @@\n+    @Override\n+    public PageFormat getPageFormat(int index) {\n+        return pageFormat;\n+    }\n@@ -132,2 +96,4 @@\n-class Sysout {\n-   private static TestDialog dialog;\n+    @Override\n+    public int getNumberOfPages() {\n+        return 1;\n+    }\n@@ -135,6 +101,7 @@\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    private void print() throws PrinterException {\n+        if (printerJob.printDialog()) {\n+            printerJob.setPageable(this);\n+            printerJob.print();\n+        } else {\n+            PassFailJFrame.forceFail(\"Printing canceled by user\");\n+        }\n@@ -143,7 +110,14 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    @Override\n+    public int print(Graphics g, PageFormat pf, int pageIndex) {\n+        if (pageIndex == 0) {\n+            Graphics2D g2 = (Graphics2D) g;\n+            Rectangle2D r = new Rectangle2D.Double(pf.getImageableX(),\n+                    pf.getImageableY(),\n+                    pf.getImageableWidth(),\n+                    pf.getImageableHeight());\n+            g2.setStroke(new BasicStroke(3.0f));\n+            g2.draw(r);\n+            return PAGE_EXISTS;\n+        } else {\n+            return NO_SUCH_PAGE;\n+        }\n@@ -152,0 +126,4 @@\n+    private static final String TOP = \"\"\"\n+         You must have a printer that supports custom paper size of\n+         at least 12 x 14 inches to perform this test. It requires\n+         user interaction and you must have a 12 x 14 inch paper available.\n@@ -153,4 +131,1 @@\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n+        \"\"\";\n@@ -158,0 +133,1 @@\n+    private static final String BOTTOM = \"\"\"\n@@ -159,4 +135,4 @@\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n+         Visual inspection of the one-page printout is needed. A passing\n+         test will print a rectangle of the imageable area which is\n+         approximately 10 x 12 inches.\n+        \"\"\";\n@@ -164,79 +140,18 @@\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n+    private static final String INSTRUCTIONS_4355514 = \"\"\"\n+         Select the printer in the Print Setup dialog and add a custom\n+         paper size under 'Printer properties' Paper selection menu.\n+         Set the dimension to width=12 inches and height=14 inches.\n+         Select this custom paper size before proceeding to print.\n+        \"\"\";\n+\n+    private static final String INSTRUCTIONS_4385157 = \"\"\"\n+         Click OK on print dialog box to print.\n+        \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        String instructions;\n+\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new SkippedException(\"Printer not configured or available.\"\n+                    + \" Test cannot continue.\");\n+        }\n@@ -244,1 +159,24 @@\n- }\/\/ TestDialog  class\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Select a test by passing 4355514 or 4385157\");\n+        }\n+\n+        instructions = switch (args[0]) {\n+            case \"4355514\" -> TOP + INSTRUCTIONS_4355514 + BOTTOM;\n+            case \"4385157\" -> TOP + INSTRUCTIONS_4385157 + BOTTOM;\n+            default -> throw new RuntimeException(\"Unknown bugid \" + args[0] + \".\"\n+                    + \"Valid values: 4355514 or 4385157\");\n+        };\n+\n+        PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n+                .title(\"CustomPaper Test Instructions\")\n+                .instructions(instructions)\n+                .testTimeOut(5)\n+                .rows((int) instructions.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n+        CustomPaper pt = new CustomPaper();\n+        pt.print();\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PageFormat\/CustomPaper.java","additions":135,"deletions":197,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.awt.BorderLayout;\n@@ -42,2 +41,0 @@\n-import javax.swing.JButton;\n-import javax.swing.JFrame;\n@@ -45,1 +42,5 @@\n-import static javax.swing.SwingUtilities.invokeAndWait;\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n@@ -49,7 +50,13 @@\n-    private static PrintLatinCJKTest testInstance = new PrintLatinCJKTest();\n-    private static JFrame frame;\n-    private static final String info = \"\"\"\n-            You need a printer for this test. If you have none, let\n-            the test pass. If there is a printer, press Print, send\n-            the output to the printer, and examine it. It should have\n-            text looking like this : \\u4e00\\u4e01\\u4e02\\u4e03\\u4e04English\n+    private static final String TEXT = \"\\u4e00\\u4e01\\u4e02\\u4e03\\u4e04English\";\n+\n+    private static final String INFO = \"\"\"\n+            Press Print, send the output to the printer and examine it.\n+            The printout should have text looking like this:\n+\n+            \"\"\"\n+            + TEXT + \"\"\"\n+\n+\n+            Press Pass if the text is printed correctly.\n+            If Japanese and English text overlap, press Fail.\n+\n@@ -61,13 +68,8 @@\n-    public static void showFrame() throws InterruptedException, InvocationTargetException {\n-        invokeAndWait( () -> {\n-            frame = new JFrame(\"Test Frame\");\n-            JButton b = new JButton(\"Print\");\n-            b.addActionListener((ae) -> {\n-                try {\n-                    PrinterJob job = PrinterJob.getPrinterJob();\n-                    job.setPrintable(testInstance);\n-                    if (job.printDialog()) {\n-                        job.print();\n-                    }\n-                } catch (PrinterException ex) {\n-                    ex.printStackTrace();\n+    private static JComponent createTestUI() {\n+        JButton b = new JButton(\"Print\");\n+        b.addActionListener((ae) -> {\n+            try {\n+                PrinterJob job = PrinterJob.getPrinterJob();\n+                job.setPrintable(new PrintLatinCJKTest());\n+                if (job.printDialog()) {\n+                    job.print();\n@@ -75,11 +77,7 @@\n-            });\n-            frame.getContentPane().add(b, BorderLayout.SOUTH);\n-            frame.pack();\n-\n-            \/\/ add the test frame to dispose\n-            PassFailJFrame.addTestWindow(frame);\n-\n-            \/\/ Arrange the test instruction frame and test frame side by side\n-            PassFailJFrame.positionTestWindow(frame,\n-                    PassFailJFrame.Position.HORIZONTAL);\n-            frame.setVisible(true);\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                                              JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n+            }\n@@ -87,0 +85,7 @@\n+\n+        Box main = Box.createHorizontalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createHorizontalGlue());\n+        main.add(b);\n+        main.add(Box.createHorizontalGlue());\n+        return main;\n@@ -96,2 +101,2 @@\n-        g.setFont(new Font(\"Dialog\", Font.PLAIN, 36));\n-        g.drawString(\"\\u4e00\\u4e01\\u4e02\\u4e03\\u4e04English\", 20, 100);\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 36));\n+        g.drawString(TEXT, 20, 100);\n@@ -102,9 +107,13 @@\n-        PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n-                .title(\"Test Instructions Frame\")\n-                .instructions(info)\n-                .testTimeOut(10)\n-                .rows(10)\n-                .columns(45)\n-                .build();\n-        showFrame();\n-        passFailJFrame.awaitAndCheck();\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                      .title(\"Print Latin CJK Test\")\n+                      .instructions(INFO)\n+                      .testTimeOut(10)\n+                      .rows(12)\n+                      .columns(30)\n+                      .splitUI(PrintLatinCJKTest::createTestUI)\n+                      .build()\n+                      .awaitAndCheck();\n@@ -113,2 +122,0 @@\n-\n-\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintLatinCJKTest.java","additions":56,"deletions":49,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.awt.Font;\n@@ -57,0 +58,1 @@\n+import javax.swing.Box;\n@@ -159,0 +161,1 @@\n+ *     <li>to add a log area<\/li>,\n@@ -190,1 +193,1 @@\n-    private static TimeoutHandler timeoutHandler;\n+    private static TimeoutHandlerPanel timeoutHandlerPanel;\n@@ -208,0 +211,2 @@\n+    private static JTextArea logArea;\n+\n@@ -377,0 +382,14 @@\n+    \/**\n+     * Does the same as {@link #invokeOnEDT(Runnable)}, but does not throw\n+     * any checked exceptions.\n+     *\n+     * @param doRun an operation to run on EDT\n+     *\/\n+    private static void invokeOnEDTUncheckedException(Runnable doRun) {\n+        try {\n+            invokeOnEDT(doRun);\n+        } catch (InterruptedException | InvocationTargetException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n@@ -388,1 +407,2 @@\n-                                           enableScreenCapture),\n+                                           enableScreenCapture,\n+                                           false, 0),\n@@ -405,2 +425,3 @@\n-                                         builder.screenCapture);\n-\n+                                         builder.screenCapture,\n+                                         builder.addLogArea,\n+                                         builder.logAreaRows);\n@@ -425,1 +446,3 @@\n-                                                       boolean enableScreenCapture) {\n+                                                       boolean enableScreenCapture,\n+                                                       boolean addLogArea,\n+                                                       int logAreaRows) {\n@@ -427,4 +450,2 @@\n-\n-        JLabel testTimeoutLabel = new JLabel(\"\", JLabel.CENTER);\n-        timeoutHandler = new TimeoutHandler(testTimeoutLabel, testTimeOut);\n-        main.add(testTimeoutLabel, BorderLayout.NORTH);\n+        timeoutHandlerPanel = new TimeoutHandlerPanel(testTimeOut);\n+        main.add(timeoutHandlerPanel, BorderLayout.NORTH);\n@@ -442,1 +463,1 @@\n-            timeoutHandler.stop();\n+            timeoutHandlerPanel.stop();\n@@ -448,1 +469,1 @@\n-            timeoutHandler.stop();\n+            timeoutHandlerPanel.stop();\n@@ -459,1 +480,14 @@\n-        main.add(buttonsPanel, BorderLayout.SOUTH);\n+        if (addLogArea) {\n+            logArea = new JTextArea(logAreaRows, columns);\n+            logArea.setEditable(false);\n+\n+            Box buttonsLogPanel = Box.createVerticalBox();\n+\n+            buttonsLogPanel.add(buttonsPanel);\n+            buttonsLogPanel.add(new JScrollPane(logArea));\n+\n+            main.add(buttonsLogPanel, BorderLayout.SOUTH);\n+        } else {\n+            main.add(buttonsPanel, BorderLayout.SOUTH);\n+        }\n+\n@@ -606,2 +640,9 @@\n-    private static final class TimeoutHandler implements ActionListener {\n-        private final long endTime;\n+    private static final class TimeoutHandlerPanel\n+            extends JPanel\n+            implements ActionListener {\n+\n+        private static final String PAUSE_BUTTON_LABEL = \"Pause\";\n+        private static final String RESUME_BUTTON_LABEL = \"Resume\";\n+\n+        private long endTime;\n+        private long pauseTimeLeft;\n@@ -612,0 +653,8 @@\n+        private final JButton button;\n+\n+        public TimeoutHandlerPanel(final long testTimeOut) {\n+            endTime = System.currentTimeMillis()\n+                    + TimeUnit.MINUTES.toMillis(testTimeOut);\n+\n+            label =  new JLabel(\"\", JLabel.CENTER);\n+            button = new JButton(PAUSE_BUTTON_LABEL);\n@@ -613,2 +662,3 @@\n-        public TimeoutHandler(final JLabel label, final long testTimeOut) {\n-            endTime = System.currentTimeMillis() + TimeUnit.MINUTES.toMillis(testTimeOut);\n+            button.setFocusPainted(false);\n+            button.setFont(new Font(Font.DIALOG, Font.BOLD, 10));\n+            button.addActionListener(e -> pauseToggle());\n@@ -616,1 +666,3 @@\n-            this.label = label;\n+            setLayout(new BorderLayout());\n+            add(label, BorderLayout.CENTER);\n+            add(button, BorderLayout.EAST);\n@@ -648,0 +700,16 @@\n+\n+        private void pauseToggle() {\n+            if (timer.isRunning()) {\n+                pauseTimeLeft = endTime - System.currentTimeMillis();\n+                timer.stop();\n+                label.setEnabled(false);\n+                button.setText(RESUME_BUTTON_LABEL);\n+            } else {\n+                endTime = System.currentTimeMillis() + pauseTimeLeft;\n+                updateTime(pauseTimeLeft);\n+                timer.start();\n+                label.setEnabled(true);\n+                button.setText(PAUSE_BUTTON_LABEL);\n+            }\n+        }\n+\n@@ -1044,0 +1112,30 @@\n+    \/**\n+     * Adds a {@code message} to the log area, if enabled by\n+     * {@link Builder#logArea()} or {@link Builder#logArea(int)}.\n+     *\n+     * @param message to log\n+     *\/\n+    public static void log(String message) {\n+        System.out.println(\"PassFailJFrame: \" + message);\n+        invokeOnEDTUncheckedException(() -> logArea.append(message + \"\\n\"));\n+    }\n+\n+    \/**\n+     * Clears the log area, if enabled by\n+     * {@link Builder#logArea()} or {@link Builder#logArea(int)}.\n+     *\/\n+    public static void logClear() {\n+        System.out.println(\"\\nPassFailJFrame: log cleared\\n\");\n+        invokeOnEDTUncheckedException(() -> logArea.setText(\"\"));\n+    }\n+\n+    \/**\n+     * Replaces the log area content with provided {@code text}, if enabled by\n+     * {@link Builder#logArea()} or {@link Builder#logArea(int)}.\n+     * @param text new text for the log area\n+     *\/\n+    public static void logSet(String text) {\n+        System.out.println(\"\\nPassFailJFrame: log set to:\\n\" + text + \"\\n\");\n+        invokeOnEDTUncheckedException(() -> logArea.setText(text));\n+    }\n+\n@@ -1051,0 +1149,2 @@\n+        private boolean addLogArea;\n+        private int logAreaRows = 10;\n@@ -1092,0 +1192,31 @@\n+        \/**\n+         * Adds a log area below the \"Pass\", \"Fail\" buttons.\n+         * <p>\n+         * The log area can be controlled by {@link #log(String)},\n+         * {@link #logClear()} and {@link #logSet(String)}.\n+         *\n+         * @return this builder\n+         *\/\n+        public Builder logArea() {\n+            this.addLogArea = true;\n+            return this;\n+        }\n+\n+        \/**\n+         * Adds a log area below the \"Pass\", \"Fail\" buttons.\n+         * <p>\n+         * The log area can be controlled by {@link #log(String)},\n+         * {@link #logClear()} and {@link #logSet(String)}.\n+         * <p>\n+         * The number of columns is taken from the number of\n+         * columns in the instructional JTextArea.\n+         *\n+         * @param rows of the log area\n+         * @return this builder\n+         *\/\n+        public Builder logArea(int rows) {\n+            this.addLogArea = true;\n+            this.logAreaRows = rows;\n+            return this;\n+        }\n+\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/PassFailJFrame.java","additions":148,"deletions":17,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-        File dir = new File(System.getProperty(\"test.src\", \".\"));\n+        File dir = new File(\".\");\n","filename":"test\/jdk\/java\/io\/FileInputStream\/ReadXBytes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        File file = new File(System.getProperty(\"test.src\", \".\"), \"test.dat\");\n+        File file = new File(\".\", \"test.dat\");\n","filename":"test\/jdk\/java\/nio\/MappedByteBuffer\/ForceException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        Path file = Path.of(System.getProperty(\"test.src\", \".\"), \"junk\");\n+        Path file = Path.of(\".\", \"junk\");\n","filename":"test\/jdk\/java\/nio\/MappedByteBuffer\/ForceViews.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                InetAddress lo4 = InetAddress.ofLiteral(\"127.0.0.1\");\n+                InetAddress lo4 = InetAddress.getByName(\"127.0.0.1\");\n@@ -65,1 +65,1 @@\n-                InetAddress lo6 = InetAddress.ofLiteral(\"::1\");\n+                InetAddress lo6 = InetAddress.getByName(\"::1\");\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Disconnect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8334719\n+ * @summary verifies that if a registered channel has in-progress operations, then\n+ *          the Selector during its deferred close implementation won't prematurely release\n+ *          the channel's resources\n+ *\n+ * @comment we use a patched java.net.InetSocketAddress to allow the test to intentionally\n+ *          craft some delays at specific locations in the implementation of InetSocketAddress\n+ *          to trigger race conditions\n+ * @compile\/module=java.base java\/net\/InetSocketAddress.java\n+ * @run junit\/othervm DeferredCloseTest\n+ *\/\n+public class DeferredCloseTest {\n+\n+    private static final int NUM_ITERATIONS = 10;\n+    private static final InetSocketAddress BIND_ADDR = new InetSocketAddress(\n+            InetAddress.getLoopbackAddress(), 0);\n+\n+    @BeforeAll\n+    public static void beforeAll() throws Exception {\n+        \/\/ configure our patched java.net.InetSocketAddress implementation\n+        \/\/ to introduce delay in certain methods which get invoked\n+        \/\/ internally from the DC.send() implementation\n+        InetSocketAddress.enableDelay();\n+    }\n+\n+    @AfterAll\n+    public static void afterAll() throws Exception {\n+        \/\/ delays in patched InetSocketAddress are no longer needed\n+        InetSocketAddress.disableDelay();\n+    }\n+\n+    private static Stream<Arguments> dcOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.send() till there's a ClosedChannelException\n+                        \"DC.send()\",\n+                        null,\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                \/\/ We send to ourselves. Target, content and\n+                                \/\/ receipt of the Datagram isn't of importance\n+                                \/\/ in this test.\n+                                SocketAddress target = dc.getLocalAddress();\n+                                System.out.println(\"DC: \" + dc + \" sending to \" + target);\n+                                while (true) {\n+                                    bb.clear();\n+                                    dc.send(bb, target);\n+                                }\n+                            } catch (ClosedChannelException e) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.receive() till there's a ClosedChannelException\n+                        \"DC.receive()\",\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                SocketAddress target = dc.getLocalAddress();\n+                                ByteBuffer sendBB = ByteBuffer.allocate(100);\n+                                \/\/ first send() a few datagrams so that subsequent\n+                                \/\/ receive() does receive them and thus triggers\n+                                \/\/ the potential race with the deferred close\n+                                for (int i = 0; i < 5; i++) {\n+                                    sendBB.clear();\n+                                    dc.send(sendBB, target);\n+                                }\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        },\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                ByteBuffer rcvBB = ByteBuffer.allocate(10);\n+                                while (true) {\n+                                    rcvBB.clear();\n+                                    dc.receive(rcvBB);\n+                                }\n+                            } catch (ClosedChannelException e) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for DatagramChannel.\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"dcOperations\")\n+    public void testDatagramChannel(String opName, Function<DatagramChannel, Void> preOp,\n+                                    Function<DatagramChannel, Void> dcOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s DatagramChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     DatagramChannel dc = DatagramChannel.open()) {\n+                    \/\/ create a non-blocking bound DatagramChannel\n+                    dc.bind(BIND_ADDR);\n+                    dc.configureBlocking(false);\n+                    \/\/ register the DatagramChannel with a selector\n+                    \/\/ (doesn't matter the interestOps)\n+                    SelectionKey key = dc.register(sel, SelectionKey.OP_READ);\n+                    if (preOp != null) {\n+                        preOp.apply(dc);\n+                    }\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start operation on the DC\n+                        opStartLatch.countDown();\n+                        return dcOperation.apply(dc);\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private static Stream<Arguments> scOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        \"SC.write()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" writing\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.write(bb);\n+                                }\n+                            } catch (ClosedChannelException e) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        \"SC.read()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" reading\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.read(bb);\n+                                }\n+                            } catch (ClosedChannelException e) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for SocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"scOperations\")\n+    public void testSocketChannel(String opName, Function<SocketChannel, Void> scOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(3)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     SocketChannel sc = SocketChannel.open()) {\n+                    \/\/ create and bind a SocketChannel\n+                    sc.bind(BIND_ADDR);\n+                    \/\/ stay in blocking mode till the SocketChannel is connected\n+                    sc.configureBlocking(true);\n+                    Future<SocketChannel> acceptedChannel;\n+                    SocketChannel conn;\n+                    \/\/ create a remote server and connect to it\n+                    try (ServerSocketChannel server = ServerSocketChannel.open()) {\n+                        server.bind(BIND_ADDR);\n+                        SocketAddress remoteAddr = server.getLocalAddress();\n+                        acceptedChannel = executor.submit(new ConnAcceptor(server));\n+                        System.out.println(\"connecting to \" + remoteAddr);\n+                        sc.connect(remoteAddr);\n+                        conn = acceptedChannel.get();\n+                    }\n+                    try (conn) {\n+                        \/\/ switch to non-blocking\n+                        sc.configureBlocking(false);\n+                        System.out.println(\"switched to non-blocking: \" + sc);\n+                        \/\/ register the SocketChannel with a selector\n+                        \/\/ (doesn't matter the interestOps)\n+                        SelectionKey key = sc.register(sel, SelectionKey.OP_READ);\n+                        CountDownLatch opStartLatch = new CountDownLatch(1);\n+                        runTest(executor, key, () -> {\n+                            \/\/ notify that we will now start operation on the SC\n+                            opStartLatch.countDown();\n+                            return scOperation.apply(sc);\n+                        }, opStartLatch);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for ServerSocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testServerSocketChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s ServerSocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+                    \/\/ create and bind a ServerSocketChannel\n+                    ssc.bind(BIND_ADDR);\n+                    ssc.configureBlocking(false);\n+                    \/\/ register the ServerSocketChannel with a selector\n+                    SelectionKey key = ssc.register(sel, SelectionKey.OP_ACCEPT);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start accept()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SSC.accept() till there's a ClosedChannelException\n+                        try {\n+                            while (true) {\n+                                ssc.accept();\n+                            }\n+                        } catch (ClosedChannelException e) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SinkChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSinkChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SinkChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SinkChannel sink = pipe.sink()) {\n+                    sink.configureBlocking(false);\n+                    SelectionKey key = sink.register(sel, SelectionKey.OP_WRITE);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start write()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                sink.write(bb);\n+                            }\n+                        } catch (ClosedChannelException e) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SourceChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSourceChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SourceChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SourceChannel source = pipe.source()) {\n+                    source.configureBlocking(false);\n+                    SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start read()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                source.read(bb);\n+                            }\n+                        } catch (ClosedChannelException e) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * SelectableChannel implementations internally have a deferred close implementation. When a\n+     * channel is registered with a Selector and close() is invoked on the channel from a certain\n+     * thread, then the implementation of close() defers the actual close if the channel has\n+     * in-progress operations (for example, read\/write\/send\/receive and such) in some other thread.\n+     * A subsequent operation through the Selector (like Selector.select()) then completes the\n+     * deferred close (waiting for any in-progress operations to complete). This test method\n+     * verifies that the deferred close implementation doesn't prematurely close and release\n+     * the resources used by the channel, while there are in-progress operations.\n+     * <p>\n+     * Launches 2 threads, T1 and T2. When T1 and T2 are in progress, this method closes the\n+     * channel that is registered with the Selector.\n+     * T1 is running the channelOperation (which keeps running operations on the channel).\n+     * T2 is running a task which keeps invoking Selector.select(), until the channel is closed.\n+     * When T2 notices that the channel is closed, it cancels the selectionKey and then\n+     * invokes one last Selector.select() operation to finish the deferred close of the channel.\n+     *\/\n+    private static void runTest(ExecutorService executor, SelectionKey selectionKey,\n+                                Callable<Void> channelOperation, CountDownLatch chanOpStartLatch)\n+            throws Exception {\n+\n+        SelectableChannel channel = selectionKey.channel();\n+        assertFalse(channel.isBlocking(), \"channel isn't non-blocking: \" + channel);\n+        selectionKey.selector().selectNow();\n+        \/\/ run the channel operations\n+        Future<?> channelOpResult = executor.submit(channelOperation);\n+        CountDownLatch selectorTaskStartLatch = new CountDownLatch(1);\n+        \/\/ run the Selector.select() task\n+        Future<?> selectorTaskResult = executor.submit(\n+                new SelectorTask(selectionKey, selectorTaskStartLatch));\n+        \/\/ await for the channel operation task and the selector task to start\n+        chanOpStartLatch.await();\n+        selectorTaskStartLatch.await();\n+        \/\/ close the channel while it's still registered with the Selector,\n+        \/\/ so that the close is deferred by the channel implementations.\n+        System.out.println(\"closing channel: \" + channel);\n+        assertTrue(channel.isOpen(), \"channel already closed: \" + channel);\n+        assertTrue(channel.isRegistered(), \"channel isn't registered: \" + channel);\n+        channel.close();\n+        \/\/ wait for the operation on the channel and the selector task to complete\n+        channelOpResult.get();\n+        selectorTaskResult.get();\n+    }\n+\n+    \/*\n+     * Keeps invoking Selector.select() until the channel is closed, after which\n+     * it cancels the SelectionKey and does one last Selector.select() to finish\n+     * the deferred close.\n+     *\/\n+    private static final class SelectorTask implements Callable<Void> {\n+        private final SelectionKey selectionKey;\n+        private final CountDownLatch startedLatch;\n+\n+        private SelectorTask(SelectionKey selectionKey, CountDownLatch startedLatch) {\n+            this.selectionKey = Objects.requireNonNull(selectionKey);\n+            this.startedLatch = startedLatch;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            try {\n+                Selector selector = selectionKey.selector();\n+                SelectableChannel channel = selectionKey.channel();\n+                \/\/ notify that the task has started\n+                startedLatch.countDown();\n+                while (true) {\n+                    selector.select(10);\n+                    if (!channel.isOpen()) {\n+                        \/\/ the channel is (defer) closed, cancel the registration and then\n+                        \/\/ issue a select() so that the Selector finishes the deferred\n+                        \/\/ close of the channel.\n+                        System.out.println(\"channel: \" + channel + \" isn't open,\" +\n+                                \" now cancelling key: \" + selectionKey);\n+                        selectionKey.cancel();\n+                        System.out.println(\"initiating select after key cancelled: \" + selectionKey);\n+                        selector.select(5);\n+                        break;\n+                    }\n+                }\n+            } catch (ClosedSelectorException e) {\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class ConnAcceptor implements Callable<SocketChannel> {\n+        private final ServerSocketChannel serverSocketChannel;\n+\n+        private ConnAcceptor(ServerSocketChannel serverSocketChannel) {\n+            this.serverSocketChannel = serverSocketChannel;\n+        }\n+\n+        @Override\n+        public SocketChannel call() throws Exception {\n+            SocketChannel accepted = serverSocketChannel.accept();\n+            System.out.println(\"Accepted connection: \" + accepted);\n+            return accepted;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/DeferredCloseTest.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.net;\n+\n+\n+import java.util.Locale;\n+\n+\/\/ Patched implementation only meant to be used in certain tests\n+public class InetSocketAddress extends SocketAddress {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 5076001401234631237L;\n+\n+    private static boolean enableDelay;\n+\n+    static {\n+        System.out.println(\"patched InetSocketAddress class in use\");\n+    }\n+\n+    private final String hostname;\n+    private final InetAddress addr;\n+    private final int port;\n+\n+    public InetSocketAddress(int port) {\n+        this(InetAddress.anyLocalAddress(), port);\n+    }\n+\n+    public InetSocketAddress(InetAddress addr, int port) {\n+        this(null,\n+                addr == null ? InetAddress.anyLocalAddress() : addr,\n+                checkPort(port));\n+    }\n+\n+    public InetSocketAddress(String hostname, int port) {\n+        checkHost(hostname);\n+        InetAddress addr = null;\n+        String host = null;\n+        try {\n+            addr = InetAddress.getByName(hostname);\n+        } catch (UnknownHostException e) {\n+            host = hostname;\n+        }\n+        this.hostname = host;\n+        this.addr = addr;\n+        this.port = checkPort(port);\n+    }\n+\n+    public static InetSocketAddress createUnresolved(String host, int port) {\n+        return new InetSocketAddress(checkHost(host), null, checkPort(port));\n+    }\n+\n+    public static void enableDelay() {\n+        enableDelay = true;\n+    }\n+\n+    public static void disableDelay() {\n+        enableDelay = false;\n+    }\n+\n+    private InetSocketAddress(String hostname, InetAddress addr, int port) {\n+        this.hostname = hostname;\n+        this.addr = addr;\n+        this.port = port;\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+    }\n+\n+    \/**\n+     * Gets the port number.\n+     *\n+     * @return the port number.\n+     *\/\n+    public final int getPort() {\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+        return this.port;\n+    }\n+\n+    \/**\n+     * Gets the {@code InetAddress}.\n+     *\n+     * @return the InetAddress or {@code null} if it is unresolved.\n+     *\/\n+    public final InetAddress getAddress() {\n+        return this.addr;\n+    }\n+\n+    public final String getHostName() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            return addr.getHostName();\n+        }\n+        return null;\n+    }\n+\n+    public final String getHostString() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            if (addr.holder().getHostName() != null) {\n+                return addr.holder().getHostName();\n+            } else {\n+                return addr.getHostAddress();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public final boolean isUnresolved() {\n+        return addr == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String formatted;\n+        if (isUnresolved()) {\n+            formatted = hostname + \"\/<unresolved>\";\n+        } else {\n+            formatted = addr.toString();\n+            if (addr instanceof Inet6Address) {\n+                int i = formatted.lastIndexOf(\"\/\");\n+                formatted = formatted.substring(0, i + 1)\n+                        + \"[\" + formatted.substring(i + 1) + \"]\";\n+            }\n+        }\n+        return formatted + \":\" + port;\n+    }\n+\n+    @Override\n+    public final boolean equals(Object other) {\n+        if (!(other instanceof InetSocketAddress that)) {\n+            return false;\n+        }\n+        boolean sameIP;\n+        if (addr != null) {\n+            sameIP = addr.equals(that.addr);\n+        } else if (hostname != null) {\n+            sameIP = (that.addr == null) &&\n+                    hostname.equalsIgnoreCase(that.hostname);\n+        } else {\n+            sameIP = (that.addr == null) && (that.hostname == null);\n+        }\n+        return sameIP && (port == that.port);\n+    }\n+\n+    @Override\n+    public final int hashCode() {\n+        if (addr != null) {\n+            return addr.hashCode() + port;\n+        }\n+        if (hostname != null) {\n+            return hostname.toLowerCase(Locale.ROOT).hashCode() + port;\n+        }\n+        return port;\n+    }\n+\n+    private static int checkPort(int port) {\n+        if (port < 0 || port > 0xFFFF)\n+            throw new IllegalArgumentException(\"port out of range:\" + port);\n+        return port;\n+    }\n+\n+    private static String checkHost(String hostname) {\n+        if (hostname == null)\n+            throw new IllegalArgumentException(\"hostname can't be null\");\n+        return hostname;\n+    }\n+\n+    private static void doDelay() {\n+        System.out.println(\"intentional delay injected in InetSocketAddress\");\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/java.base\/java\/net\/InetSocketAddress.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -311,1 +311,1 @@\n-            long start = System.currentTimeMillis();\n+            long start = millisTime();\n@@ -313,1 +313,1 @@\n-            long duration = System.currentTimeMillis() - start;\n+            expectDuration(start, 500, Long.MAX_VALUE);\n@@ -315,1 +315,0 @@\n-            assertTrue(duration > 500, \"select took \" + duration + \" ms\");\n@@ -335,1 +334,1 @@\n-            long start = System.currentTimeMillis();\n+            long start = millisTime();\n@@ -337,1 +336,1 @@\n-            long duration = System.currentTimeMillis() - start;\n+            expectDuration(start, 0, 20_000);\n@@ -339,1 +338,0 @@\n-            assertTrue(duration < 5000, \"select took \" + duration + \" ms\");\n@@ -357,1 +355,1 @@\n-            long start = System.currentTimeMillis();\n+            long start = millisTime();\n@@ -359,1 +357,1 @@\n-            long duration = System.currentTimeMillis() - start;\n+            expectDuration(start, 0, 20_000);\n@@ -361,2 +359,0 @@\n-            assertTrue(duration > 500 && duration < 10*1000,\n-                    \"select took \" + duration + \" ms\");\n@@ -384,1 +380,1 @@\n-            long start = System.currentTimeMillis();\n+            long start = millisTime();\n@@ -386,1 +382,1 @@\n-            long duration = System.currentTimeMillis() - start;\n+            expectDuration(start, 0, 20_000);\n@@ -388,1 +384,0 @@\n-            assertTrue(duration < 5000, \"select took \" + duration + \" ms\");\n@@ -765,0 +760,28 @@\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private static long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Check the duration of a task. The method will fail with an\n+     * AssertionError if the millisecond duration does not satisfy:\n+     *\n+     *     duration >= min && duration <= max\n+     *\n+     * Note that the inequalities are not strict, i.e., are inclusive.\n+     *\n+     * @param start start time, in milliseconds\n+     * @param min minimum expected duration, in milliseconds\n+     * @param max maximum expected duration, in milliseconds\n+     *\/\n+    private static void expectDuration(long start, long min, long max) {\n+        long duration = millisTime() - start;\n+        assertTrue(duration >= min,\n+                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max,\n+                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/SelectWithConsumer.java","additions":37,"deletions":14,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Test virtual threads doing selection operations\n+ * @library \/test\/lib\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED SelectorOps\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @requires vm.continuations\n+ * @library \/test\/lib\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations\n+ *     --enable-native-access=ALL-UNNAMED SelectorOps\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadPinner;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class SelectorOps {\n+    private static String selectorClassName;  \/\/ platform specific class name\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        try (Selector sel = Selector.open()) {\n+            selectorClassName = sel.getClass().getName();\n+        }\n+    }\n+\n+    \/**\n+     * Test that select wakes up when a channel is ready for I\/O.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    public void testSelect(boolean timed) throws Exception {\n+        VThreadRunner.run(() -> {\n+            Pipe p = Pipe.open();\n+            try (Selector sel = Selector.open()) {\n+                Pipe.SinkChannel sink = p.sink();\n+                Pipe.SourceChannel source = p.source();\n+                source.configureBlocking(false);\n+                SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+\n+                \/\/ write to sink to ensure source is readable\n+                ByteBuffer buf = ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                onSelect(() -> sink.write(buf));\n+\n+                int n = timed ? sel.select(60_000) : sel.select();\n+                assertEquals(1, n);\n+                assertTrue(sel.isOpen());\n+                assertTrue(key.isReadable());\n+            } finally {\n+                closePipe(p);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test that select wakes up when a channel is ready for I\/O and thread is pinned.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = { true, false })\n+    public void testSelectWhenPinned(boolean timed) throws Exception {\n+        VThreadPinner.runPinned(() -> { testSelect(timed); });\n+    }\n+\n+    \/**\n+     * Test that select wakes up when timeout is reached.\n+     *\/\n+    @Test\n+    public void testSelectTimeout() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Pipe p = Pipe.open();\n+            try (Selector sel = Selector.open()) {\n+                Pipe.SourceChannel source = p.source();\n+                source.configureBlocking(false);\n+                SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+\n+                long start = millisTime();\n+                int n = sel.select(1000);\n+                expectDuration(start, \/*min*\/500, \/*max*\/20_000);\n+\n+                assertEquals(0, n);\n+                assertTrue(sel.isOpen());\n+                assertFalse(key.isReadable());\n+            } finally {\n+                closePipe(p);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test that select wakes up when timeout is reached and thread is pinned.\n+     *\/\n+    @Test\n+    public void testSelectTimeoutWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testSelectTimeout(); });\n+    }\n+\n+    \/**\n+     * Test that selectNow is non-blocking.\n+     *\/\n+    @Test\n+    public void testSelectNow() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Pipe p = Pipe.open();\n+            try (Selector sel = Selector.open()) {\n+                Pipe.SinkChannel sink = p.sink();\n+                Pipe.SourceChannel source = p.source();\n+                source.configureBlocking(false);\n+                SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+\n+                \/\/ selectNow should return immediately\n+                for (int i = 0; i < 3; i++) {\n+                    long start = millisTime();\n+                    int n = sel.selectNow();\n+                    expectDuration(start, -1, \/*max*\/20_000);\n+                    assertEquals(0, n);\n+                }\n+\n+                \/\/ write to sink to ensure source is readable\n+                ByteBuffer buf = ByteBuffer.wrap(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                sink.write(buf);\n+\n+                \/\/ call selectNow until key added to selected key set\n+                int n = 0;\n+                while (n == 0) {\n+                    Thread.sleep(10);\n+                    long start = millisTime();\n+                    n = sel.selectNow();\n+                    expectDuration(start, -1, \/*max*\/20_000);\n+                }\n+                assertEquals(1, n);\n+                assertTrue(sel.isOpen());\n+                assertTrue(key.isReadable());\n+            } finally {\n+                closePipe(p);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test calling wakeup before select.\n+     *\/\n+    @Test\n+    public void testWakeupBeforeSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                sel.wakeup();\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertTrue(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test calling wakeup before select and thread is pinned.\n+     *\/\n+    @Test\n+    public void testWakeupBeforeSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testWakeupBeforeSelect(); });\n+    }\n+\n+    \/**\n+     * Test calling wakeup while a thread is blocked in select.\n+     *\/\n+    @Test\n+    public void testWakeupDuringSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                onSelect(sel::wakeup);\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertTrue(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test calling wakeup while a thread is blocked in select and the thread is pinned.\n+     *\/\n+    @Test\n+    public void testWakeupDuringSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testWakeupDuringSelect(); });\n+    }\n+\n+    \/**\n+     * Test closing selector while a thread is blocked in select.\n+     *\/\n+    @Test\n+    public void testCloseDuringSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                onSelect(sel::close);\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertFalse(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test closing selector while a thread is blocked in select and the thread is pinned.\n+     *\/\n+    @Test\n+    public void testCloseDuringSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testCloseDuringSelect(); });\n+    }\n+\n+    \/**\n+     * Test calling select with interrupt status set.\n+     *\/\n+    @Test\n+    public void testInterruptBeforeSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                Thread me = Thread.currentThread();\n+                me.interrupt();\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertTrue(me.isInterrupted());\n+                assertTrue(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test calling select with interrupt status set and thread is pinned.\n+     *\/\n+    @Test\n+    public void testInterruptBeforeSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testInterruptDuringSelect(); });\n+    }\n+\n+    \/**\n+     * Test interrupting a thread blocked in select.\n+     *\/\n+    @Test\n+    public void testInterruptDuringSelect() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (Selector sel = Selector.open()) {\n+                Thread me = Thread.currentThread();\n+                onSelect(me::interrupt);\n+                int n = sel.select();\n+                assertEquals(0, n);\n+                assertTrue(me.isInterrupted());\n+                assertTrue(sel.isOpen());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupting a thread blocked in select and the thread is pinned.\n+     *\/\n+    @Test\n+    public void testInterruptDuringSelectWhenPinned() throws Exception {\n+        VThreadPinner.runPinned(() -> { testInterruptDuringSelect(); });\n+    }\n+\n+    \/**\n+     * Close a pipe's sink and source channels.\n+     *\/\n+    private void closePipe(Pipe p) {\n+        try { p.sink().close(); } catch (IOException ignore) { }\n+        try { p.source().close(); } catch (IOException ignore) { }\n+    }\n+\n+    \/**\n+     * Runs the given action when the current thread is sampled in a selection operation.\n+     *\/\n+    private void onSelect(VThreadRunner.ThrowingRunnable<Exception> action) {\n+        Thread target = Thread.currentThread();\n+        Thread.ofPlatform().daemon().start(() -> {\n+            try {\n+                boolean found = false;\n+                while (!found) {\n+                    Thread.sleep(20);\n+                    StackTraceElement[] stack = target.getStackTrace();\n+                    found = Arrays.stream(stack)\n+                            .anyMatch(e -> selectorClassName.equals(e.getClassName())\n+                                    && \"doSelect\".equals(e.getMethodName()));\n+                }\n+                action.run();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private static long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Check the duration of a task\n+     * @param start start time, in milliseconds\n+     * @param min minimum expected duration, in milliseconds\n+     * @param max maximum expected duration, in milliseconds\n+     * @return the duration (now - start), in milliseconds\n+     *\/\n+    private static void expectDuration(long start, long min, long max) {\n+        long duration = millisTime() - start;\n+        assertTrue(duration >= min,\n+                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max,\n+                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/SelectorOps.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 4162583 7054918 8130181\n- * @library ..\/testlibrary\n+ * @bug 4162583 7054918 8130181 8028127\n+ * @library \/test\/lib ..\/testlibrary\n@@ -33,0 +33,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -45,0 +47,1 @@\n+        var providersCountBefore = Security.getProviders().length;\n@@ -46,3 +49,4 @@\n-        for (int i=0; i < acc.length; i++)\n-            acc[i] = new AccessorThread(\"thread\"+i);\n-        for (int i=0; i < acc.length; i++)\n+        for (int i = 0; i < acc.length; i++) {\n+            acc[i] = new AccessorThread(\"thread\" + i);\n+        }\n+        for (int i = 0; i < acc.length; i++) {\n@@ -50,1 +54,2 @@\n-        for (int i=0; i < acc.length; i++)\n+        }\n+        for (int i = 0; i < acc.length; i++) {\n@@ -52,0 +57,3 @@\n+        }\n+        var providersCountAfter = Security.getProviders().length;\n+        Asserts.assertEquals(providersCountBefore, providersCountAfter);\n@@ -53,1 +61,0 @@\n-}\n@@ -55,1 +62,1 @@\n-class AccessorThread extends Thread {\n+    static class AccessorThread extends Thread {\n@@ -57,3 +64,3 @@\n-    public AccessorThread(String str) {\n-        super(str);\n-    }\n+        public AccessorThread(String str) {\n+            super(str);\n+        }\n@@ -61,4 +68,5 @@\n-    public void run() {\n-        Provider[] provs = new Provider[10];\n-        for (int i=0; i < provs.length; i++)\n-            provs[i] = new MyProvider(\"name\"+i, \"1\", \"test\");\n+        public void run() {\n+            Provider[] provs = new Provider[10];\n+            for (int i = 0; i < provs.length; i++) {\n+                provs[i] = new MyProvider(\"name\" + i, \"1\", \"test\");\n+            }\n@@ -66,4 +74,4 @@\n-        int rounds = 20;\n-        while (rounds-- > 0) {\n-            try {\n-                for (int i=0; i<provs.length; i++) {\n+            int rounds = 20;\n+            while (rounds-- > 0) {\n+                for (int i = 0; i < provs.length; i++) {\n+                    \/\/ Might install (>=0) or not (-1) if already installed\n@@ -71,0 +79,8 @@\n+                    Thread.yield();\n+                }\n+\n+                try {\n+                    Signature.getInstance(\"sigalg\");\n+                    Thread.yield();\n+                } catch (NoSuchAlgorithmException nsae) {\n+                    \/\/ All providers may have been deregistered.  Ok.\n@@ -72,3 +88,5 @@\n-                Signature sig = Signature.getInstance(\"sigalg\");\n-                for (int i=0; i<provs.length; i++) {\n-                    Security.removeProvider(\"name\"+i);\n+\n+                for (int i = 0; i < provs.length; i++) {\n+                    \/\/ Might or might not remove (silent return)\n+                    Security.removeProvider(\"name\" + i);\n+                    Thread.yield();\n@@ -76,2 +94,7 @@\n-                provs = Security.getProviders();\n-            } catch (NoSuchAlgorithmException nsae) {\n+            } \/\/ while\n+        }\n+\n+        public static final class MyProvider extends Provider {\n+            public MyProvider(String name, String version, String info) {\n+                super(name, version, info);\n+                put(\"Signature.sigalg\", SigImpl.class.getName());\n@@ -79,0 +102,3 @@\n+        }\n+\n+        public static final class SigImpl extends Signature {\n@@ -80,3 +106,2 @@\n-            try {\n-                Thread.sleep(5);\n-            } catch (InterruptedException ie) {\n+            public SigImpl() {\n+                super(null);\n@@ -84,3 +109,0 @@\n-        } \/\/ while\n-    }\n-}\n@@ -88,4 +110,37 @@\n-class MyProvider extends Provider {\n-    public MyProvider(String name, String version, String info) {\n-        super(name, version, info);\n-        put(\"Signature.sigalg\", \"sigimpl\");\n+            @Override\n+            protected void engineInitVerify(PublicKey publicKey) {\n+            }\n+\n+            @Override\n+            protected void engineInitSign(PrivateKey privateKey) {\n+            }\n+\n+            @Override\n+            protected void engineUpdate(byte b) {\n+            }\n+\n+            @Override\n+            protected void engineUpdate(byte[] b, int off, int len) {\n+            }\n+\n+            @Override\n+            protected byte[] engineSign() {\n+                return new byte[0];\n+            }\n+\n+            @Override\n+            protected boolean engineVerify(byte[] sigBytes) {\n+                return false;\n+            }\n+\n+            @Override\n+            protected void engineSetParameter(String param, Object value)\n+                    throws InvalidParameterException {\n+            }\n+\n+            @Override\n+            protected Object engineGetParameter(String param)\n+                    throws InvalidParameterException {\n+                return null;\n+            }\n+        }\n@@ -93,1 +148,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/Security\/SynchronizedAccess.java","additions":91,"deletions":36,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+import sun.security.util.Debug;\n@@ -66,1 +67,1 @@\n- * @bug 8074931\n+ * @bug 8074931 8296787\n@@ -194,0 +195,8 @@\n+\n+        \/\/ check serial number format\n+        String serialNum = Debug.toString(selector.getSerialNumber());\n+        String expected = \"38:df:82:b8\";\n+        if (!serialNum.equals(expected)) {\n+            throw new RuntimeException(\"Serial number toString format is incorrect. Got: \"\n+                + serialNum + \" Expected: \" + expected);\n+        }\n","filename":"test\/jdk\/java\/security\/cert\/X509CertSelectorTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+\/**\n+ * HumanInputStream tries to act like a human sitting in front of a computer\n+ * terminal typing on the keyboard while a program is running.\n+ * <p>\n+ * The program may call InputStream.read() and BufferedReader.readLine() in\n+ * various places. a call to B.readLine() will try to buffer as much input as\n+ * possible. Thus, a trivial InputStream will find it impossible to feed\n+ * anything to I.read() after a B.readLine() call.\n+ * <p>\n+ * This is why HumanInputStream was created, which will only send a single line\n+ * to B.readLine(), no more, no less, and the next I.read() can have a chance\n+ * to read the exact character right after \"\\n\".\n+ *\n+ *\/\n+\n+public class HumanInputStream extends InputStream {\n+    byte[] src;\n+    int pos;\n+    int length;\n+    boolean inLine;\n+    int stopIt;\n+\n+    public HumanInputStream(String input) {\n+        src = input.getBytes();\n+        pos = 0;\n+        length = src.length;\n+        stopIt = 0;\n+        inLine = false;\n+    }\n+\n+    \/\/ the trick: when called through read(byte[], int, int),\n+    \/\/ return -1 twice after \"\\n\"\n+\n+    @Override public int read() throws IOException {\n+        int re;\n+        if(pos < length) {\n+            re = src[pos];\n+            if(inLine) {\n+                if(stopIt > 0) {\n+                    stopIt--;\n+                    re = -1;\n+                } else {\n+                    if(re == '\\n') {\n+                        stopIt = 2;\n+                    }\n+                    pos++;\n+                }\n+            } else {\n+                pos++;\n+            }\n+        } else {\n+            re = -1; \/\/throws new IOException(\"NO MORE TO READ\");\n+        }\n+        return re;\n+    }\n+    @Override public int read(byte[] buffer, int offset, int len) {\n+        inLine = true;\n+        try {\n+            return super.read(buffer, offset, len);\n+        } catch(Exception e) {\n+            throw new RuntimeException(\"HumanInputStream error\");\n+        } finally {\n+            inLine = false;\n+        }\n+    }\n+    @Override public int available() {\n+        if (pos < length) return 1;\n+        return 0;\n+    }\n+\n+    \/\/ test part\n+    static void assertTrue(boolean bool) {\n+        if (!bool)\n+            throw new RuntimeException();\n+    }\n+\n+    public static void test() throws Exception {\n+        class Tester {\n+            HumanInputStream is;\n+            BufferedReader reader;\n+            Tester(String s) {\n+                is = new HumanInputStream(s);\n+                reader = new BufferedReader(new InputStreamReader(is));\n+            }\n+\n+            \/\/ three kinds of test method\n+            \/\/ 1. read byte by byte from InputStream\n+            void testStreamReadOnce(int expection) throws Exception {\n+                assertTrue(is.read() == expection);\n+            }\n+            void testStreamReadMany(String expectation) throws Exception {\n+                char[] keys = expectation.toCharArray();\n+                for (char key : keys) {\n+                    assertTrue(is.read() == key);\n+                }\n+            }\n+            \/\/ 2. read a line with a newly created Reader\n+            void testReaderReadline(String expectation) throws Exception {\n+                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+            \/\/ 3. read a line with the old Reader\n+            void testReaderReadline2(String expectation) throws Exception  {\n+                String s = reader.readLine();\n+                if(s == null) assertTrue(expectation == null);\n+                else assertTrue(s.equals(expectation));\n+            }\n+        }\n+\n+        Tester test;\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline2(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n+        test.testReaderReadline2(\"111\");\n+        test.testReaderReadline(\"222\");\n+        test.testReaderReadline2(\"\");\n+        test.testReaderReadline2(\"444\");\n+        test.testReaderReadline(\"\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"1\\n2\");\n+        test.testStreamReadMany(\"1\\n2\");\n+        test.testStreamReadOnce(-1);\n+\n+        test = new Tester(\"12\\n234\");\n+        test.testStreamReadOnce('1');\n+        test.testReaderReadline(\"2\");\n+        test.testStreamReadOnce('2');\n+        test.testReaderReadline2(\"34\");\n+        test.testReaderReadline2(null);\n+\n+        test = new Tester(\"changeit\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n+        test.testStreamReadMany(\"changeit\\n\");\n+        test.testReaderReadline(\"Name\");\n+        test.testReaderReadline(\"Country\");\n+        test.testReaderReadline(\"Yes\");\n+        test.testReaderReadline(null);\n+\n+        test = new Tester(\"Me\\nHere\\n\");\n+        test.testReaderReadline2(\"Me\");\n+        test.testReaderReadline2(\"Here\");\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/testlibrary\/HumanInputStream.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,2 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit -Xmx48M -XX:-UseTLAB OOMEInAQS\n+ * @requires vm.gc.G1\n+ * @run main\/othervm -XX:+UseG1GC -XX:-UseGCOverheadLimit -Xmx48M -XX:-UseTLAB OOMEInAQS\n","filename":"test\/jdk\/java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8253952\n@@ -27,1 +28,1 @@\n- * @run main\/othervm CopyZipFile\n+ * @run junit CopyZipFile\n@@ -30,5 +31,5 @@\n-import java.io.File;\n-import java.io.ByteArrayOutputStream;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n@@ -37,0 +38,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -40,7 +44,3 @@\n-import java.util.zip.CRC32;\n-import java.util.zip.Deflater;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipException;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipInputStream;\n-import java.util.zip.ZipOutputStream;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -49,2 +49,4 @@\n-    private static final String ZIP_FILE = \"first.zip\";\n-    private static final String TEST_STRING = \"TestTestTest\";\n+    \/\/ ZIP file created in this test\n+    private Path zip = Path.of(\"first.zip\");\n+    \/\/ The content to put in each entry\n+    private static final byte[] TEST_STRING = \"TestTestTest\".getBytes(StandardCharsets.UTF_8);\n@@ -52,4 +54,14 @@\n-    private static void createZip(String zipFile) throws Exception {\n-        File f = new File(zipFile);\n-        f.deleteOnExit();\n-        try (OutputStream os = new FileOutputStream(f);\n+    \/**\n+     * Create the sample ZIP file used in this test, including a STORED entry\n+     * and DEFLATE entries with various compression levels.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void createZip() throws IOException {\n+        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n+        \/\/ without size, compressed size and crc values and an extra Data\n+        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n+        \/\/ after the data belonging to that entry with these values if in the\n+        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n+        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n+        try (OutputStream os = Files.newOutputStream(zip) ;\n@@ -58,3 +70,4 @@\n-            zos.putNextEntry(new ZipEntry(\"test1.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n-            zos.closeEntry();\n+            zos.setLevel(Deflater.DEFAULT_COMPRESSION);\n+            zos.putNextEntry(new ZipEntry(\"DEFAULT_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -63,4 +76,3 @@\n-            ZipEntry ze = new ZipEntry(\"test2.txt\");\n-            int length = TEST_STRING.length();\n-            ze.setSize(length);\n-            ze.setCompressedSize(length);\n+            ZipEntry ze = new ZipEntry(\"STORED.txt\");\n+            ze.setSize(TEST_STRING.length);\n+            ze.setCompressedSize(TEST_STRING.length);\n@@ -68,1 +80,1 @@\n-            crc.update(TEST_STRING.getBytes(\"utf8\"), 0, length);\n+            crc.update(TEST_STRING);\n@@ -71,1 +83,2 @@\n-            zos.write(TEST_STRING.getBytes());\n+            zos.write(TEST_STRING);\n+\n@@ -75,2 +88,3 @@\n-            zos.putNextEntry(new ZipEntry(\"test3.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"NO_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -79,2 +93,3 @@\n-            zos.putNextEntry(new ZipEntry(\"test4.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"BEST_SPEED.txt\"));\n+            zos.write(TEST_STRING);\n+\n@@ -83,2 +98,2 @@\n-            zos.putNextEntry(new ZipEntry(\"test5.txt\"));\n-            zos.write(TEST_STRING.getBytes());\n+            zos.putNextEntry(new ZipEntry(\"BEST_COMPRESSION.txt\"));\n+            zos.write(TEST_STRING);\n@@ -88,22 +103,26 @@\n-    public static void main(String args[]) throws Exception {\n-        \/\/ By default, ZipOutputStream creates zip files with Local File Headers\n-        \/\/ without size, compressedSize and crc values and an extra Data\n-        \/\/ Descriptor (see https:\/\/en.wikipedia.org\/wiki\/Zip_(file_format)\n-        \/\/ after the data belonging to that entry with these values if in the\n-        \/\/ corresponding ZipEntry one of the size, compressedSize or crc fields is\n-        \/\/ equal to '-1' (which is the default for newly created ZipEntries).\n-        createZip(ZIP_FILE);\n-\n-        \/\/ Now read all the entries of the newly generated zip file with a ZipInputStream\n-        \/\/ and copy them to a new zip file with the help of a ZipOutputStream.\n-        \/\/ This only works reliably because the generated zip file has no values for the\n-        \/\/ size, compressedSize and crc values of a zip entry in the local file header and\n-        \/\/ therefore the ZipEntry objects created by ZipOutputStream.getNextEntry() will have\n-        \/\/ all these fields set to '-1'.\n-        ZipEntry entry;\n-        byte[] buf = new byte[512];\n-        try (InputStream is = new FileInputStream(ZIP_FILE);\n-             ZipInputStream zis = new ZipInputStream(is);\n-             OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os)) {\n-            while((entry = zis.getNextEntry())!=null) {\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Read all entries using ZipInputStream.getNextEntry and copy them\n+     * to a new zip file using ZipOutputStream.putNextEntry. This only works\n+     * reliably because the input zip file has no values for the size, compressedSize\n+     * and crc values of streamed zip entries in the local file header and\n+     * therefore the ZipEntry objects created by ZipOutputStream.getNextEntry\n+     * will have all these fields set to '-1'.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void copyFromZipInputStreamToZipOutputStream() throws IOException {\n+\n+        try (ZipInputStream zis = new ZipInputStream(Files.newInputStream(zip));\n+             ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream())) {\n+            ZipEntry entry;\n+            while ((entry = zis.getNextEntry()) != null) {\n@@ -114,5 +133,7 @@\n-                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n-                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-                if (entry.getMethod() == ZipEntry.DEFLATED &&\n-                    (entry.getCompressedSize() != -1 || entry.getSize() != -1 || entry.getCrc() != -1)) {\n-                    throw new Exception(\"'size', 'compressedSize' and 'crc' shouldn't be initialized at this point.\");\n+                        String.format(\"name=%s, clen=%d, len=%d, crc=%d\",\n+                                entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                if (entry.getMethod() == ZipEntry.DEFLATED) {\n+                    \/\/ Expect size, compressed size and crc to not be initialized at this point\n+                    assertEquals(-1, entry.getCompressedSize());\n+                    assertEquals(-1, entry.getSize());\n+                    assertEquals(-1, entry.getCrc());\n@@ -127,5 +148,6 @@\n-                    String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n-                                  entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n-                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n-                }\n+                        String.format(\"name=%s, clen=%d, len=%d, crc=%d\\n\",\n+                                entry.getName(), entry.getCompressedSize(), entry.getSize(), entry.getCrc()));\n+                \/\/ Expect size, compressed size and crc to be initialized at this point\n+                assertNotEquals(-1, entry.getCompressedSize());\n+                assertNotEquals(-1, entry.getSize());\n+                assertNotEquals(-1, entry.getCrc());\n@@ -134,0 +156,1 @@\n+    }\n@@ -135,15 +158,21 @@\n-        \/\/ Now we read all the entries of the initially generated zip file with the help\n-        \/\/ of the ZipFile class. The ZipFile class reads all the zip entries from the Central\n-        \/\/ Directory which must have accurate information for size, compressedSize and crc.\n-        \/\/ This means that all ZipEntry objects returned from ZipFile will have correct\n-        \/\/ settings for these fields.\n-        \/\/ If the compression level was different in the initial zip file (which we can't find\n-        \/\/ out any more now because the zip file format doesn't record this information) the\n-        \/\/ size of the re-compressed entry we are writing to the ZipOutputStream might differ\n-        \/\/ from the original compressed size recorded in the ZipEntry. This would result in an\n-        \/\/ \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n-        \/\/ the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n-        \/\/ or ZipInputStream.\n-        try (OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os);\n-             ZipFile zf = new ZipFile(ZIP_FILE)) {\n+    \/**\n+     * Read all entries using the ZipFile class and copy them to a new zip file\n+     * using ZipOutputStream.putNextEntry.\n+     * The ZipFile class reads all the zip entries from the Central\n+     * Directory, which has accurate information for size, compressedSize and crc.\n+     * This means that all ZipEntry objects returned from ZipFile will have correct\n+     * settings for these fields.\n+     * If the compression level was different in the input zip file (which we can't know\n+     * because the zip file format doesn't record this information), the\n+     * size of the re-compressed entry we are writing to the ZipOutputStream might differ\n+     * from the original compressed size recorded in the ZipEntry. This would result in an\n+     * \"invalid entry compressed size\" ZipException if ZipOutputStream wouldn't ignore\n+     * the implicitely set compressed size attribute of ZipEntries read from a ZipFile\n+     * or ZipInputStream.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void copyFromZipFileToZipOutputStream() throws IOException {\n+        try (ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream());\n+             ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry entry;\n@@ -157,4 +186,5 @@\n-                if (entry.getCompressedSize() == -1 || entry.getSize() == -1) {\n-                    throw new Exception(\"'size' and 'compressedSize' must be initialized at this point.\");\n-                }\n-                InputStream is = zf.getInputStream(entry);\n+                \/\/ Expect size, compressed size and crc to be initialized at this point\n+                assertNotEquals(-1, entry.getCompressedSize());\n+                assertNotEquals(-1, entry.getSize());\n+                assertNotEquals(-1, entry.getCrc());\n+\n@@ -162,1 +192,3 @@\n-                is.transferTo(zos);\n+                try (InputStream is = zf.getInputStream(entry)) {\n+                    is.transferTo(zos);\n+                }\n@@ -166,0 +198,17 @@\n+    }\n+\n+    \/**\n+     * If the compressed size is set explicitly using ZipEntry.setCompressedSize(),\n+     * then the entry will be restreamed with a data descriptor and the compressed size\n+     * recomputed. If the source compression level was different from the target compression\n+     * level, the compressed sizes may differ and a ZipException will be thrown\n+     * when the entry is closed in ZipOutputStream.closeEntry\n+     *\n+     * @throws IOException if an unexpected IOException is thrown\n+     *\/\n+    @Test\n+    public void explicitCompressedSizeWithDifferentCompressionLevels() throws IOException {\n+        try (ZipOutputStream zos = new ZipOutputStream(OutputStream.nullOutputStream());\n+             ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Be explicit about the default compression level\n+            zos.setLevel(Deflater.DEFAULT_COMPRESSION);\n@@ -167,5 +216,0 @@\n-        \/\/ The compressed size attribute of a ZipEntry shouldn't be ignored if it was set\n-        \/\/ explicitely by calling ZipEntry.setCpompressedSize()\n-        try (OutputStream os = new ByteArrayOutputStream();\n-             ZipOutputStream zos = new ZipOutputStream(os);\n-             ZipFile zf = new ZipFile(ZIP_FILE)) {\n@@ -174,4 +218,8 @@\n-                try {\n-                    entry = entries.nextElement();\n-                    entry.setCompressedSize(entry.getCompressedSize());\n-                    InputStream is = zf.getInputStream(entry);\n+                ZipEntry entry = entries.nextElement();\n+\n+                \/\/ Explicitly setting the compressed size will disable data descriptors\n+                \/\/ and enable validation that the compressed size in the ZipEntry matches the\n+                \/\/ actual compressed size written by ZipOutputStream\n+                entry.setCompressedSize(entry.getCompressedSize());\n+\n+                try (InputStream is = zf.getInputStream(entry)) {\n@@ -180,9 +228,35 @@\n-                    zos.closeEntry();\n-                    if (\"test3.txt\".equals(entry.getName())) {\n-                        throw new Exception(\n-                            \"Should throw a ZipException if ZipEntry.setCpompressedSize() was called.\");\n-                    }\n-                } catch (ZipException ze) {\n-                    if (\"test1.txt\".equals(entry.getName()) || \"test2.txt\".equals(entry.getName())) {\n-                        throw new Exception(\n-                            \"Shouldn't throw a ZipExcpetion for STORED files or files compressed with DEFAULT_COMPRESSION\");\n+                    \/\/ Some compression levels lead to unexpected recompressed sizes when closing the entry\n+                    switch (entry.getName()) {\n+                        case \"DEFAULT_COMPRESSION.txt\" -> {\n+                            \/\/ DEFAULT_COMPRESSION matches expected size\n+                            zos.closeEntry();\n+                        }\n+                        case \"STORED.txt\" -> {\n+                            \/\/ STORED should not throw\n+                            zos.closeEntry();\n+                        }\n+                        case \"NO_COMPRESSION.txt\", \"BEST_SPEED.txt\" -> {\n+                            \/\/ NO_COMPRESSION and BEST_SPEED should lead to an unexpected recompressed size\n+                            ZipException ze = assertThrows(ZipException.class, () -> {\n+                                zos.closeEntry();\n+                            });\n+\n+                            \/\/ Hack to fix and close the offending zip entry with the correct recompressed size.\n+                            \/\/ The exception message is something like:\n+                            \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n+                            \/\/ and we need to extract the second integer.\n+                            Pattern cSize = Pattern.compile(\"\\\\d+\");\n+                            Matcher m = cSize.matcher(ze.getMessage());\n+                            m.find();\n+                            m.find();\n+                            entry.setCompressedSize(Integer.parseInt(m.group()));\n+                            zos.closeEntry();\n+                        }\n+                        case \"BEST_COMPRESSION.txt\" -> {\n+                            \/\/ BEST_COMPRESSION produces the same compressed\n+                            \/\/ size as DEFAULT_COMPRESSION for sample content\n+                            zos.closeEntry();\n+                        }\n+                        default -> {\n+                            throw new IllegalArgumentException(\"Unexpected entry \" + entry.getName());\n+                        }\n@@ -190,9 +264,0 @@\n-                    \/\/ Hack to fix and close the offending zip entry with the correct compressed size.\n-                    \/\/ The exception message is something like:\n-                    \/\/   \"invalid entry compressed size (expected 12 but got 7 bytes)\"\n-                    \/\/ and we need to extract the second integer.\n-                    Pattern cSize = Pattern.compile(\"\\\\d+\");\n-                    Matcher m = cSize.matcher(ze.getMessage());\n-                    m.find();\n-                    m.find();\n-                    entry.setCompressedSize(Integer.parseInt(m.group()));\n","filename":"test\/jdk\/java\/util\/zip\/CopyZipFile.java","additions":178,"deletions":113,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -98,3 +98,3 @@\n-            System.out.printf(\"Deflater::getTotalOut:%s, Deflater::getAdler: %s,\" +\n-                            \" compressed length: %s%n\", deflater.getTotalOut(),\n-                    deflater.getTotalOut(), compressedDataLength);\n+            System.out.printf(\"Deflater::getBytesWritten:%d, Deflater::getAdler: %d,\" +\n+                            \" compressed length: %d%n\", deflater.getBytesWritten(),\n+                    deflater.getAdler(), compressedDataLength);\n@@ -115,1 +115,1 @@\n-            System.out.printf(\"Inflater::getAdler:%s, length: %s%n\",\n+            System.out.printf(\"Inflater::getAdler:%d, length: %d%n\",\n@@ -146,3 +146,3 @@\n-            System.out.printf(\"Deflater::getTotalOut:%s, Deflater::getAdler: %s,\" +\n-                            \" compressed length: %s%n\", deflater.getTotalOut(),\n-                    deflater.getTotalOut(), compressedDataLength);\n+            System.out.printf(\"Deflater::getBytesWritten:%d, Deflater::getAdler: %d,\" +\n+                            \" compressed length: %d%n\", deflater.getBytesWritten(),\n+                    deflater.getAdler(), compressedDataLength);\n@@ -163,1 +163,1 @@\n-            System.out.printf(\"Inflater::getAdler:%s, length: %s%n\",\n+            System.out.printf(\"Inflater::getAdler:%d, length: %d%n\",\n@@ -200,3 +200,3 @@\n-            System.out.printf(\"Deflater::getTotalOut:%s, Deflater::getAdler: %s,\" +\n-                            \" compressed length: %s%n\", deflater.getTotalOut(),\n-                    deflater.getTotalOut(), compressedDataLength);\n+            System.out.printf(\"Deflater::getBytesWritten:%d, Deflater::getAdler: %d,\" +\n+                            \" compressed length: %d%n\", deflater.getBytesWritten(),\n+                    deflater.getAdler(), compressedDataLength);\n@@ -217,1 +217,1 @@\n-            System.out.printf(\"Inflater::getAdler:%s, length: %s%n\",\n+            System.out.printf(\"Inflater::getAdler:%d, length: %d%n\",\n","filename":"test\/jdk\/java\/util\/zip\/DeflaterDictionaryTests.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.zip.*;\n-import java.io.File;\n-\n-public class Available\n-{\n-    public static void main (String argv[]) throws Exception {\n-        ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\"),\n-                                          \"input.jar\"));\n-        ZipEntry e = zf.getEntry(\"ReleaseInflater.java\");\n-        if (e.getSize() != zf.getInputStream(e).available()) {\n-            throw new Exception(\"wrong return value of available\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/Available.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test 1.1 99\/06\/01\n-   @bug 4239446\n-   @summary Make sure the ZipEntry fields are correct.\n- *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-\n-public class CopyJar {\n-    public static void main(String args[]) throws Exception {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.jar\"))) {\n-            ZipEntry ze = zf.getEntry(\"ReleaseInflater.java\");\n-            ZipOutputStream zos = new ZipOutputStream(new ByteArrayOutputStream());\n-            InputStream in = zf.getInputStream(ze);\n-            byte[] b = new byte[128];\n-            int n;\n-            zos.putNextEntry(ze);\n-            while((n = in.read(b)) != -1) {\n-                zos.write(b, 0, n);\n-            }\n-            zos.close();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CopyJar.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4290060\n-   @summary Check if the zip file is closed before access any\n-            elements in the Enumeration.\n- *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-import java.util.Enumeration;\n-\n-public class EnumAfterClose {\n-    public static void main(String args[]) throws Exception {\n-        Enumeration e;\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.zip\"))) {\n-            e = zf.entries();\n-        }\n-        \/\/ ensure that the ZipFile is closed before checking the Enumeration\n-        try {\n-            if (e.hasMoreElements()) {\n-                ZipEntry ze = (ZipEntry)e.nextElement();\n-            }\n-        } catch (IllegalStateException ie) {\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/EnumAfterClose.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 4290060\n+   @summary Check if the zip file is closed before access any\n+            elements in the Enumeration.\n+   @run junit EnumerateAfterClose\n+ *\/\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Enumeration;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class EnumerateAfterClose {\n+\n+    \/\/ ZIP file used in this test\n+    private Path zip = Path.of(\"enum-after-close.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Attempting to using a ZipEntry Enumeration after its backing\n+     * ZipFile is closed should throw IllegalStateException.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void enumeratingAfterCloseShouldThrowISE() throws IOException {\n+        \/\/ Retain a reference to an enumeration backed by a closed ZipFile\n+        Enumeration e;\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            e = zf.entries();\n+        }\n+        \/\/ Using the enumeration after the ZipFile is closed should throw ISE\n+        assertThrows(IllegalStateException.class, () -> {\n+            if (e.hasMoreElements()) {\n+                ZipEntry ze = (ZipEntry)e.nextElement();\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/EnumerateAfterClose.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+   @run junit FinalizeInflater\n@@ -29,2 +30,4 @@\n-import java.io.File;\n-import java.io.InputStream;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -32,0 +35,5 @@\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +42,1 @@\n+import java.util.zip.ZipOutputStream;\n@@ -37,4 +46,39 @@\n-    public static void main(String[] args) throws Throwable {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"), \"input.zip\")))\n-        {\n-            ZipEntry ze = zf.getEntry(\"ReadZip.java\");\n+    \/\/ ZIP file produced by this test\n+    private Path zip = Path.of(\"finalize-inflater.zip\");\n+\n+    \/**\n+     * Create the sample ZIP used in this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            byte[] hello = \"hello\".getBytes(StandardCharsets.UTF_8);\n+            for (int i = 0; i < 100; i++) {\n+                zo.write(hello);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * A cached Inflater should not be made invalid by finalization\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void shouldNotFinalizeInflaterInPool() throws IOException {\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry ze = zf.getEntry(\"file.txt\");\n@@ -54,6 +98,1 @@\n-        byte[] buffer = new byte[32];\n-        try {\n-            while(is.read(buffer)>0){}\n-        } catch (IOException ioe) {\n-            ioe.printStackTrace();\n-        }\n+        is.readAllBytes();\n@@ -62,1 +101,1 @@\n-    static class Wrapper{\n+    static class Wrapper {\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/FinalizeInflater.java","additions":53,"deletions":14,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4206838\n-   @summary getEntry() will search for a directory\n-            even without an ending '\/'.\n- *\/\n-\n-import java.io.*;\n-import java.util.zip.*;\n-\n-public class GetDirEntry {\n-    public static void main(String args[]) throws Exception {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.jar\"))) {\n-            ZipEntry ze = zf.getEntry(\"META-INF\");\n-            if (ze == null) {\n-                throw new Exception(\"failed to find a directory entry\");\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/GetDirEntry.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4528128 6846616\n-   @summary Test if reading InputStream of a closed ZipFile crashes VM\n-   @author kladko\n-   *\/\n-\n-\n-import java.util.zip.*;\n-import java.io.*;\n-import java.util.*;\n-\n-public class ReadAfterClose {\n-    public static void main(String[] argv) throws Exception {\n-        InputStream in;\n-        try (ZipFile zf = new ZipFile(\n-                 new File(System.getProperty(\"test.src\",\".\"),\"crash.jar\"))) {\n-            ZipEntry zent = zf.getEntry(\"Test.java\");\n-            in = zf.getInputStream(zent);\n-        }\n-        \/\/ ensure zf is closed at this point\n-        try {\n-            in.read();\n-        } catch (IOException e) {\n-            return;\n-        }\n-        throw new Exception(\"Test failed.\");\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadAfterClose.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-   @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8186464\n+   @bug 4241361 4842702 4985614 6646605 5032358 6923692 6233323 8144977 8186464 4401122 8322830\n@@ -27,1 +27,0 @@\n-   @key randomness\n@@ -29,0 +28,1 @@\n+   @run junit ReadZip\n@@ -31,1 +31,7 @@\n-import java.io.*;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n@@ -33,9 +39,4 @@\n-import java.nio.file.Files;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.NoSuchFileException;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.StandardOpenOption;\n-import java.util.List;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.*;\n+import java.util.Collections;\n+import java.util.HexFormat;\n@@ -43,1 +44,4 @@\n-import java.util.zip.*;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n@@ -46,0 +50,1 @@\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -48,5 +53,20 @@\n-    private static void unreached (Object o)\n-        throws Exception\n-    {\n-        \/\/ Should never get here\n-        throw new Exception (\"Expected exception was not thrown\");\n+\n+    \/\/ ZIP file produced during tests\n+    private Path zip = Path.of(\"read-zip.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by tests\n+     * @param name name of the ZIP file to create\n+     * @return a sample ZIP file\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    private Path createZip(String name) throws IOException {\n+        Path zip = Path.of(name);\n+\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        return zip;\n@@ -55,6 +75,8 @@\n-    public static void main(String args[]) throws Exception {\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"),\n-                                               \"input.zip\"))) {\n-            \/\/ Make sure we throw NPE on null objects\n-            try { unreached (zf.getEntry(null)); }\n-            catch (NullPointerException e) {}\n+    \/**\n+     * Delete the ZIP file produced after each test method\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n@@ -62,2 +84,9 @@\n-            try { unreached (zf.getInputStream(null)); }\n-            catch (NullPointerException e) {}\n+    \/**\n+     * Make sure we throw NPE when calling getEntry or getInputStream with null params\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void nullPointerExceptionOnNullParams() throws IOException {\n+        zip = createZip(\"null-params.zip\");\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n@@ -65,4 +94,6 @@\n-            ZipEntry ze = zf.getEntry(\"ReadZip.java\");\n-            if (ze == null) {\n-                throw new Exception(\"cannot read from zip file\");\n-            }\n+            assertThrows(NullPointerException.class, () -> zf.getEntry(null));\n+            assertThrows(NullPointerException.class, () -> zf.getInputStream(null));\n+\n+            \/\/ Sanity check that we can still read an entry\n+            ZipEntry ze = zf.getEntry(\"file.txt\");\n+            assertNotNull(ze, \"cannot read from zip file\");\n@@ -70,0 +101,1 @@\n+    }\n@@ -71,5 +103,6 @@\n-        \/\/ Make sure we can read the zip file that has some garbage\n-        \/\/ bytes padded at the end.\n-        File newZip = new File(System.getProperty(\"test.dir\", \".\"), \"input2.zip\");\n-        Files.copy(Paths.get(System.getProperty(\"test.src\", \"\"), \"input.zip\"),\n-                   newZip.toPath(), StandardCopyOption.REPLACE_EXISTING);\n+    \/**\n+     * Read the zip file that has some garbage bytes padded at the end\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void bytesPaddedAtEnd() throws IOException {\n@@ -77,1 +110,1 @@\n-        newZip.setWritable(true);\n+        zip = createZip(\"bytes-padded.zip\");\n@@ -80,3 +113,6 @@\n-        try (OutputStream os = Files.newOutputStream(newZip.toPath(),\n-                                                     StandardOpenOption.APPEND)) {\n-            os.write(1); os.write(3); os.write(5); os.write(7);\n+        try (OutputStream os = Files.newOutputStream(zip,\n+                StandardOpenOption.APPEND)) {\n+            os.write(1);\n+            os.write(3);\n+            os.write(5);\n+            os.write(7);\n@@ -85,7 +121,25 @@\n-        try (ZipFile zf = new ZipFile(newZip)) {\n-            ZipEntry ze = zf.getEntry(\"ReadZip.java\");\n-            if (ze == null) {\n-                throw new Exception(\"cannot read from zip file\");\n-            }\n-        } finally {\n-            newZip.delete();\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry ze = zf.getEntry(\"file.txt\");\n+            assertNotNull(ze, \"cannot read from zip file\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that we can read a comment from the ZIP\n+     * file's 'End of Central Directory' header\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readZipFileComment() throws IOException {\n+\n+        \/\/ Create a zip file with a comment in the 'End of Central Directory' header\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zos = new ZipOutputStream(out)) {\n+            ZipEntry ze = new ZipEntry(\"ZipEntry\");\n+            zos.putNextEntry(ze);\n+            zos.write(1);\n+            zos.write(2);\n+            zos.write(3);\n+            zos.write(4);\n+            zos.closeEntry();\n+            zos.setComment(\"This is the comment for testing\");\n@@ -95,10 +149,6 @@\n-        try {\n-            try (FileOutputStream fos = new FileOutputStream(newZip);\n-                 ZipOutputStream zos = new ZipOutputStream(fos))\n-            {\n-                ZipEntry ze = new ZipEntry(\"ZipEntry\");\n-                zos.putNextEntry(ze);\n-                zos.write(1); zos.write(2); zos.write(3); zos.write(4);\n-                zos.closeEntry();\n-                zos.setComment(\"This is the comment for testing\");\n-            }\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry ze = zf.getEntry(\"ZipEntry\");\n+            assertNotNull(ze, \"cannot read entry from zip file\");\n+            assertEquals(\"This is the comment for testing\", zf.getComment());\n+        }\n+    }\n@@ -106,38 +156,37 @@\n-            try (ZipFile zf = new ZipFile(newZip)) {\n-                ZipEntry ze = zf.getEntry(\"ZipEntry\");\n-                if (ze == null)\n-                    throw new Exception(\"cannot read entry from zip file\");\n-                if (!\"This is the comment for testing\".equals(zf.getComment()))\n-                    throw new Exception(\"cannot read comment from zip file\");\n-            }\n-        } finally {\n-            newZip.delete();\n-        }\n-\n-        \/\/ Read directory entry\n-        try {\n-            try (FileOutputStream fos = new FileOutputStream(newZip);\n-                 ZipOutputStream zos = new ZipOutputStream(fos))\n-            {\n-                ZipEntry ze = new ZipEntry(\"directory\/\");\n-                zos.putNextEntry(ze);\n-                zos.closeEntry();\n-            }\n-            try (ZipFile zf = new ZipFile(newZip)) {\n-                ZipEntry ze = zf.getEntry(\"directory\/\");\n-                if (ze == null || !ze.isDirectory())\n-                    throw new RuntimeException(\"read entry \\\"directory\/\\\" failed\");\n-                try (InputStream is = zf.getInputStream(ze)) {\n-                    is.available();\n-                } catch (Exception x) {\n-                    x.printStackTrace();\n-                }\n-\n-                ze = zf.getEntry(\"directory\");\n-                if (ze == null || !ze.isDirectory())\n-                    throw new RuntimeException(\"read entry \\\"directory\\\" failed\");\n-                try (InputStream is = zf.getInputStream(ze)) {\n-                    is.available();\n-                } catch (Exception x) {\n-                    x.printStackTrace();\n-                }\n+    \/**\n+     * Verify that a directory entry can be found using the\n+     * name 'directory\/' as well as 'directory\/'\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readDirectoryEntries() throws IOException {\n+\n+        \/\/ Create a ZIP containing some directory entries\n+        try (OutputStream fos = Files.newOutputStream(zip);\n+             ZipOutputStream zos = new ZipOutputStream(fos)) {\n+            \/\/ Add a META-INF directory with STORED compression type\n+            ZipEntry metaInf = new ZipEntry(\"META-INF\/\");\n+            metaInf.setMethod(ZipEntry.STORED);\n+            metaInf.setSize(0);\n+            metaInf.setCrc(0);\n+            zos.putNextEntry(metaInf);\n+\n+            \/\/ Add a regular directory\n+            ZipEntry dir = new ZipEntry(\"directory\/\");\n+            zos.putNextEntry(dir);\n+            zos.closeEntry();\n+        }\n+\n+        \/\/ Verify directory lookups\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Look up 'directory\/' using the full name\n+            ZipEntry ze = zf.getEntry(\"directory\/\");\n+            assertNotNull(ze, \"read entry \\\"directory\/\\\" failed\");\n+            assertTrue(ze.isDirectory(), \"read entry \\\"directory\/\\\" failed\");\n+            assertEquals(\"directory\/\", ze.getName());\n+\n+            try (InputStream is = zf.getInputStream(ze)) {\n+                is.available();\n+            } catch (Exception x) {\n+                x.printStackTrace();\n@@ -145,19 +194,11 @@\n-        } finally {\n-            newZip.delete();\n-        }\n-\n-        \/\/ Throw a FNF exception when read a non-existing zip file\n-        try { unreached (new ZipFile(\n-                             new File(System.getProperty(\"test.src\", \".\"),\n-                                     \"input\"\n-                                      + String.valueOf(new java.util.Random().nextInt())\n-                                      + \".zip\")));\n-        } catch (NoSuchFileException nsfe) {}\n-\n-        \/\/ read a zip file with ZIP64 end\n-        Path path = Paths.get(System.getProperty(\"test.dir\", \"\"), \"end64.zip\");\n-        try {\n-            URI uri = URI.create(\"jar:\" + path.toUri());\n-            Map<String, Object> env = Map.of(\"create\", \"true\", \"forceZIP64End\", \"true\");\n-            try (FileSystem fs = FileSystems.newFileSystem(uri, env)) {\n-                Files.write(fs.getPath(\"hello\"), \"hello\".getBytes());\n+\n+            \/\/ Look up 'directory\/' without the trailing slash\n+            ze = zf.getEntry(\"directory\");\n+            assertNotNull(ze, \"read entry \\\"directory\\\" failed\");\n+            assertTrue(ze.isDirectory(), \"read entry \\\"directory\\\" failed\");\n+            assertEquals(\"directory\/\", ze.getName());\n+\n+            try (InputStream is = zf.getInputStream(ze)) {\n+                is.available();\n+            } catch (Exception x) {\n+                x.printStackTrace();\n@@ -165,7 +206,35 @@\n-            try (ZipFile zf = new ZipFile(path.toFile())) {\n-                if (!\"hello\".equals(new String(zf.getInputStream(new ZipEntry(\"hello\"))\n-                                               .readAllBytes(),\n-                                               US_ASCII)))\n-                    throw new RuntimeException(\"zipfile: read entry failed\");\n-            } catch (IOException x) {\n-                throw new RuntimeException(\"zipfile: zip64 end failed\");\n+            \/\/ Sanity check that also META-INF\/ can be looked up with or without the trailing slash\n+            assertNotNull(zf.getEntry(\"META-INF\"));\n+            assertNotNull(zf.getEntry(\"META-INF\/\"));\n+            assertEquals(zf.getEntry(\"META-INF\").getName(),\n+                    zf.getEntry(\"META-INF\/\").getName());\n+        }\n+    }\n+\n+    \/**\n+     * Throw a NoSuchFileException exception when reading a non-existing zip file\n+     *\/\n+    @Test\n+    public void nonExistingFile() {\n+        File nonExistingFile = new File(\"non-existing-file-f6804460f.zip\");\n+        assertThrows(NoSuchFileException.class, () ->\n+                new ZipFile(nonExistingFile));\n+    }\n+\n+    \/**\n+     * Read a Zip file with a 'Zip64 End of Central Directory header' which was created\n+     * using ZipFileSystem with the 'forceZIP64End' option.\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readZip64EndZipFs() throws IOException {\n+\n+        \/\/ Create zip file with Zip64 end\n+        Map<String, Object> env = Map.of(\"create\", \"true\", \"forceZIP64End\", \"true\");\n+        try (FileSystem fs = FileSystems.newFileSystem(zip, env)) {\n+            Files.write(fs.getPath(\"hello\"), \"hello\".getBytes());\n+        }\n+        \/\/ Read using ZipFile\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            try (InputStream in = zf.getInputStream(zf.getEntry(\"hello\"))) {\n+                assertEquals(\"hello\", new String(in.readAllBytes(), StandardCharsets.US_ASCII));\n@@ -173,5 +242,35 @@\n-            try (FileSystem fs = FileSystems.newFileSystem(uri, Map.of())) {\n-                if (!\"hello\".equals(new String(Files.readAllBytes(fs.getPath(\"hello\")))))\n-                    throw new RuntimeException(\"zipfs: read entry failed\");\n-            } catch (IOException x) {\n-                throw new RuntimeException(\"zipfile: zip64 end failed\");\n+        }\n+        \/\/ Read using ZipFileSystem\n+        try (FileSystem fs = FileSystems.newFileSystem(zip, Map.of())) {\n+            assertEquals(\"hello\", new String(Files.readAllBytes(fs.getPath(\"hello\"))));\n+        }\n+    }\n+\n+    \/**\n+     * Read a zip file created via Info-ZIP in streaming mode,\n+     * which includes a 'Zip64 End of Central Directory header'.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     * @throws InterruptedException if an unexpected InterruptedException occurs\n+     *\/\n+    @Test\n+    public void readZip64EndInfoZIPStreaming() throws IOException, InterruptedException {\n+        \/\/ ZIP created using: \"echo -n hello | zip zip64.zip -\"\n+        \/\/ Hex encoded using: \"cat zip64.zip | xxd -ps\"\n+        byte[] zipBytes = HexFormat.of().parseHex(\"\"\"\n+                  504b03042d0000000000c441295886a61036ffffffffffffffff01001400\n+                  2d010010000500000000000000050000000000000068656c6c6f504b0102\n+                  1e032d0000000000c441295886a610360500000005000000010000000000\n+                  000001000000b011000000002d504b06062c000000000000001e032d0000\n+                  00000000000000010000000000000001000000000000002f000000000000\n+                  003800000000000000504b06070000000067000000000000000100000050\n+                  4b050600000000010001002f000000380000000000\n+                  \"\"\".replaceAll(\"\\n\",\"\")\n+        );\n+\n+        Files.write(zip, zipBytes);\n+\n+        try (ZipFile zf = new ZipFile(this.zip.toFile())) {\n+            try (InputStream in = zf.getInputStream(zf.getEntry(\"-\"))) {\n+                String contents = new String(in.readAllBytes(), StandardCharsets.US_ASCII);\n+                assertEquals(\"hello\", contents);\n@@ -179,22 +278,40 @@\n-        } finally {\n-            Files.deleteIfExists(path);\n-        }\n-\n-        \/\/ read a zip file created via \"echo hello | zip dst.zip -\", which uses\n-        \/\/ ZIP64 end record\n-        if (Files.notExists(Paths.get(\"\/usr\/bin\/zip\")))\n-            return;\n-        try {\n-            Process zip = new ProcessBuilder(\"zip\", path.toString().toString(), \"-\").start();\n-            OutputStream os = zip.getOutputStream();\n-            os.write(\"hello\".getBytes(US_ASCII));\n-            os.close();\n-            zip.waitFor();\n-            if (zip.exitValue() == 0 && Files.exists(path)) {\n-                try (ZipFile zf = new ZipFile(path.toFile())) {\n-                    if (!\"hello\".equals(new String(zf.getInputStream(new ZipEntry(\"-\"))\n-                                                       .readAllBytes())))\n-                        throw new RuntimeException(\"zipfile: read entry failed\");\n-                } catch (IOException x) {\n-                    throw new RuntimeException(\"zipfile: zip64 end failed\");\n-                }\n+        }\n+    }\n+\n+    \/**\n+     * Check that the available() method overriden by the input stream returned by\n+     * ZipFile.getInputStream correctly returns the number of remaining uncompressed bytes\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void availableShouldReturnRemainingUncompressedBytes() throws IOException {\n+        \/\/ The number of uncompressed bytes to write to the sample ZIP entry\n+        final int expectedBytes = 512;\n+\n+        \/\/ Create a sample ZIP with deflated entry of a known uncompressed size\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(new byte[expectedBytes]);\n+        }\n+\n+        \/\/ Verify the behavior of ZipFileInflaterInputStream.available()\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry e = zf.getEntry(\"file.txt\");\n+            try (InputStream in = zf.getInputStream(e)) {\n+                \/\/ Initially, available() should return the full uncompressed size of the entry\n+                assertEquals(expectedBytes, in.available(),\n+                        \"wrong initial return value of available\");\n+\n+                \/\/ Reading a few bytes should reduce the number of available bytes accordingly\n+                int bytesToRead = 10;\n+                in.read(new byte[bytesToRead]);\n+                assertEquals(expectedBytes - bytesToRead, in.available());\n+\n+                \/\/ Reading all remaining bytes should reduce the number of available bytes to zero\n+                in.transferTo(OutputStream.nullOutputStream());\n+                assertEquals(0, in.available());\n+\n+                \/\/ available on a closed input stream should return zero\n+                in.close();\n+                assertEquals(0, in.available());\n@@ -202,2 +319,0 @@\n-        } finally {\n-            Files.deleteIfExists(path);\n@@ -206,1 +321,60 @@\n-}\n+\n+    \/**\n+     * Verify that reading an InputStream from a closed ZipFile\n+     * throws IOException as expected and does not crash the VM.\n+     * See bugs: 4528128 6846616\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void readAfterClose() throws IOException {\n+        zip = createZip(\"read-after-close.zip\");\n+        InputStream in;\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry zent = zf.getEntry(\"file.txt\");\n+            in = zf.getInputStream(zent);\n+        }\n+\n+        \/\/ zf is closed at this point\n+        assertThrows(IOException.class,  () -> {\n+            in.read();\n+        });\n+        assertThrows(IOException.class,  () -> {\n+            in.read(new byte[10]);\n+        });\n+        assertThrows(IOException.class,  () -> {\n+            byte[] buf = new byte[10];\n+            in.read(buf, 0, buf.length);\n+        });\n+        assertThrows(IOException.class,  () -> {\n+            in.readAllBytes();\n+        });\n+    }\n+\n+    \/**\n+     * Verify that ZipFile can open a ZIP file with zero entries\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void noEntries() throws IOException {\n+        \/\/ Create a ZIP file with no entries\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+        }\n+\n+        \/\/ Open the \"empty\" ZIP file\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            \/\/ Verify size\n+            assertEquals(0, zf.size());\n+\n+            \/\/ Verify entry lookup using ZipFile.getEntry()\n+            assertNull(zf.getEntry(\"file.txt\"));\n+\n+            \/\/ Verify iteration using ZipFile.entries()\n+            assertEquals(Collections.emptyList(), Collections.list(zf.entries()));\n+\n+            \/\/ Verify iteration using ZipFile.stream()\n+            assertEquals(Collections.emptyList(), zf.stream().toList());\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadZip.java","additions":325,"deletions":151,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit ReleaseInflater\n@@ -30,2 +31,14 @@\n-import java.io.*;\n-import java.util.zip.*;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -35,4 +48,35 @@\n-    public static void main(String[] args) throws Exception {\n-        ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\"),\n-                                          \"input.jar\"));\n-        ZipEntry e = zf.getEntry(\"ReleaseInflater.java\");\n+    \/\/ ZIP file produced in this test\n+    private Path zip = Path.of(\"release-inflater.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by tests\n+     * @param name name of the ZIP file to create\n+     * @return a sample ZIP file\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"helloworld\".getBytes(StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP and JAR files produced after each test method\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Verify that the same Inflater is not recycled across input streams\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void recycleInflaterOnlyOnce() throws IOException {\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            ZipEntry e = zf.getEntry(\"file.txt\");\n@@ -40,5 +84,5 @@\n-        InputStream in1 = zf.getInputStream(e);\n-        \/\/ close the stream, the inflater will be released\n-        in1.close();\n-        \/\/ close the stream again, should be no-op\n-        in1.close();\n+            InputStream in1 = zf.getInputStream(e);\n+            \/\/ close the stream, the inflater will be released\n+            in1.close();\n+            \/\/ close the stream again, should be no-op\n+            in1.close();\n@@ -46,3 +90,3 @@\n-        \/\/ create two new streams, allocating inflaters\n-        InputStream in2 = zf.getInputStream(e);\n-        InputStream in3 = zf.getInputStream(e);\n+            \/\/ create two new streams, allocating inflaters\n+            InputStream in2 = zf.getInputStream(e);\n+            InputStream in3 = zf.getInputStream(e);\n@@ -50,3 +94,2 @@\n-        \/\/ check to see if they influence each other\n-        if (in2.read() != in3.read()) {\n-            throw new Exception(\"Stream is corrupted!\");\n+            \/\/ check to see if they influence each other\n+            assertEquals(in2.read(), in3.read(), \"Stream is corrupted!\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReleaseInflater.java","additions":61,"deletions":18,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @run testng StreamZipEntriesTest\n+ * @run junit StreamZipEntriesTest\n@@ -30,1 +30,4 @@\n-import java.io.File;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -32,3 +35,6 @@\n-import java.lang.Object;\n-import java.lang.System;\n-import java.util.jar.JarFile;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -36,0 +42,3 @@\n+import java.util.jar.JarFile;\n+import java.util.jar.JarOutputStream;\n+import java.util.jar.Manifest;\n@@ -39,0 +48,1 @@\n+import java.util.zip.ZipOutputStream;\n@@ -40,1 +50,1 @@\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -42,3 +52,0 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.fail;\n@@ -48,0 +55,50 @@\n+    \/\/ ZIP file produced in this test\n+    private Path zip = Path.of(\"stream.zip\");\n+    \/\/ JAR file produced in this test\n+    private Path jar = Path.of(\"stream.jar\");\n+\n+    \/**\n+     * Create sample ZIP and JAR files used in in this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            zo.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+            zo.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        try (OutputStream out = Files.newOutputStream(jar);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            \/\/ A JAR file may start with a META-INF\/ directory before the manifest\n+            zo.putNextEntry(new ZipEntry(\"META-INF\/\"));\n+            \/\/ Write the manifest\n+            zo.putNextEntry(new ZipEntry(\"META-INF\/MANIFEST.MF\"));\n+            new Manifest().write(zo);\n+\n+            \/\/ Write two regular entries\n+            zo.putNextEntry(new ZipEntry(\"entry1.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+            zo.putNextEntry(new ZipEntry(\"entry2.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced after each test method\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+        Files.deleteIfExists(jar);\n+    }\n+\n+    \/**\n+     * Verify that ZipFile.stream() produces the expected entries\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -50,3 +107,13 @@\n-        try (ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"), \"input.zip\"))) {\n-            zf.stream().forEach(e -> assertTrue(e instanceof ZipEntry));\n-            zf.stream().forEach(e -> assertEquals(e.toString(), \"ReadZip.java\"));\n+        Set<String> names = new HashSet<>(Set.of(\"entry1.txt\", \"entry2.txt\"));\n+\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            zf.stream().forEach(e -> {\n+                assertTrue(e instanceof ZipEntry);\n+                String name = e.getName();\n+                assertNotNull(names.remove(name));\n+                String toString = e.toString();\n+                assertEquals(name, toString);\n+            });\n+\n+            \/\/ Check that all expected names were processed\n+            assertTrue(names.isEmpty());\n@@ -54,0 +121,1 @@\n+            \/\/ Check that Stream.toArray produces the expected result\n@@ -55,2 +123,3 @@\n-            assertEquals(1, elements.length);\n-            assertEquals(elements[0].toString(), \"ReadZip.java\");\n+            assertEquals(2, elements.length);\n+            assertEquals(elements[0].toString(), \"entry1.txt\");\n+            assertEquals(elements[1].toString(), \"entry2.txt\");\n@@ -60,0 +129,4 @@\n+    \/**\n+     * Verify that JarFile.stream() produces the expected entries\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -62,2 +135,7 @@\n-        try (JarFile jf = new JarFile(new File(System.getProperty(\"test.src\", \".\"), \"input.jar\"))) {\n-            jf.stream().forEach(e -> assertTrue(e instanceof JarEntry));\n+        try (JarFile jf = new JarFile(jar.toFile())) {\n+            Set<String> names = new HashSet<>(Set.of(\n+                    \"META-INF\/\",\n+                    \"META-INF\/MANIFEST.MF\",\n+                    \"entry1.txt\",\n+                    \"entry2.txt\"\n+            ));\n@@ -65,0 +143,14 @@\n+            jf.stream().forEach(e -> {\n+                        assertTrue(e instanceof JarEntry);\n+                        String name = e.getName();\n+                        assertNotNull(names.remove(name));\n+                        String toString = e.toString();\n+                        assertEquals(name, toString);\n+                    }\n+            );\n+\n+            \/\/ Check that all expected names were processed\n+            assertTrue(names.isEmpty(), \"Unprocessed entries: \" + names);\n+\n+\n+            \/\/ Check that Stream.toArray produces the expected result\n@@ -66,1 +158,1 @@\n-            assertEquals(3, elements.length);\n+            assertEquals(4, elements.length);\n@@ -69,1 +161,2 @@\n-            assertEquals(elements[2].toString(), \"ReleaseInflater.java\");\n+            assertEquals(elements[2].toString(), \"entry1.txt\");\n+            assertEquals(elements[3].toString(), \"entry2.txt\");\n@@ -73,0 +166,4 @@\n+    \/**\n+     * Calling ZipFile.stream() on a closed ZipFile should throw ISE\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -75,1 +172,1 @@\n-        ZipFile zf = new ZipFile(new File(System.getProperty(\"test.src\", \".\"), \"input.zip\"));\n+        ZipFile zf = new ZipFile(zip.toFile());\n@@ -77,1 +174,1 @@\n-        try {\n+        assertThrows(IllegalStateException.class, () -> {\n@@ -79,4 +176,1 @@\n-            fail(\"Should have thrown IllegalStateException\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected;\n-        }\n+        });\n@@ -85,0 +179,4 @@\n+    \/**\n+     * Calling JarFile.stream() on a closed JarFile should throw ISE\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n@@ -87,1 +185,1 @@\n-        JarFile jf = new JarFile(new File(System.getProperty(\"test.src\", \".\"), \"input.jar\"));\n+        JarFile jf = new JarFile(jar.toFile());\n@@ -89,1 +187,1 @@\n-        try {\n+        assertThrows(IllegalStateException.class, () -> {\n@@ -91,4 +189,1 @@\n-            fail(\"Should have thrown IllegalStateException\");\n-        } catch (IllegalStateException e) {\n-            \/\/ expected;\n-        }\n+        });\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/StreamZipEntriesTest.java","additions":126,"deletions":31,"binary":false,"changes":157,"status":"modified"},{"filename":"test\/jdk\/java\/util\/zip\/ZipFile\/crash.jar","binary":true,"status":"deleted"},{"filename":"test\/jdk\/java\/util\/zip\/ZipFile\/input.jar","binary":true,"status":"deleted"},{"filename":"test\/jdk\/java\/util\/zip\/ZipFile\/input.zip","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n@@ -55,0 +57,1 @@\n+        private InetAddress listenInterface = InetAddress.getLoopbackAddress();\n@@ -60,0 +63,9 @@\n+        public InetAddress getListenInterface() {\n+            return listenInterface;\n+        }\n+\n+        public Builder setListenInterface(InetAddress listenInterface) {\n+            this.listenInterface = listenInterface;\n+            return this;\n+        }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/AbstractServer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.net.InetAddress;\n@@ -56,1 +57,2 @@\n-                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort());\n+                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort(),\n+                    0, builder.getListenInterface());\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/JdkServer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.JButton;\n+import javax.swing.JComboBox;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8322754\n+ * @summary Verifies clicking JComboBox during frame closure causes Exception\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual ComboPopupBug\n+ *\/\n+\n+public class ComboPopupBug {\n+    private static final String instructionsText = \"\"\"\n+            This test is used to verify that clicking on JComboBox\n+            when frame containing it is about to close should not\n+            cause IllegalStateException.\n+\n+            A JComboBox is shown with Close button at the bottom.\n+            Click on Close and then click on JComboBox arrow button\n+            to try to show combobox popup.\n+            If IllegalStateException is thrown, test will automatically Fail\n+            otherwise click Pass.  \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n+                .title(\"ComboPopup Instructions\")\n+                .instructions(instructionsText)\n+                .testTimeOut(5)\n+                .rows(10)\n+                .columns(35)\n+                .build();\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            JFrame frame = new JFrame(\"ComboPopup\");\n+\n+            JComboBox cb = new JComboBox();\n+            cb.setEditable(true);\n+            cb.addItem(\"test\");\n+            cb.addItem(\"test2\");\n+            cb.addItem(\"test3\");\n+            frame.getContentPane().add(cb, \"North\");\n+\n+            JButton b = new JButton(\"Close\");\n+            b.addActionListener(\n+                (e)->{\n+                    try {\n+                        Thread.sleep(3000);\n+                    }\n+                    catch (Exception ex) {\n+                    }\n+                    frame.setVisible(false);\n+\n+                });\n+            frame.getContentPane().add(b, \"South\");\n+            frame.setSize(200, 200);\n+\n+            PassFailJFrame.addTestWindow(frame);\n+            PassFailJFrame.positionTestWindow(frame,\n+                    PassFailJFrame.Position.HORIZONTAL);\n+\n+            frame.setVisible(true);\n+        });\n+\n+        passFailJFrame.awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/ComboPopupBug.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.GridLayout;\n+import javax.swing.AbstractAction;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JTabbedPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8225220\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @requires (os.family == \"linux\")\n+ * @summary JTabbedPane arrow should point to left or right direction\n+ *          when tab layout policy is set to SCROLL_TAB_LAYOUT and tab\n+ *          placement is set to either TOP or BOTTOM\n+ * @run main\/manual TestJTabbedPaneArrowDirection\n+ *\/\n+\n+public class TestJTabbedPaneArrowDirection {\n+    private static JFrame frame;\n+    private static JTabbedPane tabPane;\n+    private static final String INSTRUCTIONS =\n+            \"1. Observe the arrows are ponting to left and right direction\\n\" +\n+               \" for tab placement set to TOP. Default tab placement is TOP.\\n\\n\" +\n+            \"2. Press BOTTOM to change the tab placement to bottom.\\n\\n\" +\n+            \"3. Observe arrows are pointing to the left and right direction.\\n\\n\" +\n+            \"4. If the behaviour is correct, press Pass else Fail.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n+                .title(\"JTabbedPane Arrow Direction Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(5)\n+                .rows(12)\n+                .columns(40)\n+                .screenCapture()\n+                .build();\n+        SwingUtilities.invokeAndWait(\n+                TestJTabbedPaneArrowDirection::createAndShowUI);\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    private static void createAndShowUI() {\n+        int NUM_TABS = 15;\n+        frame = new JFrame(\"Test JTabbedPane Arrow Direction\");\n+        JTabbedPane tabPane = new JTabbedPane();\n+        tabPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n+        tabPane.setTabPlacement(JTabbedPane.TOP);\n+        PassFailJFrame.addTestWindow(frame);\n+        PassFailJFrame.positionTestWindow(\n+                frame, PassFailJFrame.Position.HORIZONTAL);\n+        for( int i = 0; i < NUM_TABS; ++i) {\n+            tabPane.addTab(\"Tab \" + i , new JLabel(\"Content Area\"));\n+        }\n+        JPanel panel = new JPanel(new BorderLayout());\n+        panel.add(tabPane, BorderLayout.CENTER);\n+        JButton topButton = new JButton(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                tabPane.setTabPlacement(JTabbedPane.TOP);\n+            }\n+        });\n+        topButton.setText(\"TOP\");\n+        JButton bottomButton = new JButton(new AbstractAction() {\n+            public void actionPerformed(ActionEvent e) {\n+                tabPane.setTabPlacement(JTabbedPane.BOTTOM);\n+            }\n+        });\n+        bottomButton.setText(\"BOTTOM\");\n+        JPanel buttonPanel = new JPanel(new GridLayout(1, 2));\n+        buttonPanel.add(topButton);\n+        buttonPanel.add(bottomButton);\n+        panel.add(buttonPanel, BorderLayout.SOUTH);\n+        frame.add(panel);\n+        frame.setSize(500, 500);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/TestJTabbedPaneArrowDirection.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+ * Before this test set to manual, the original timeout\n+ * value if 180\n@@ -32,1 +34,1 @@\n- * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n@@ -35,1 +37,1 @@\n- * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    private static final String NSS_BUNDLE_VERSION = \"3.91\";\n+    private static final String NSS_BUNDLE_VERSION = \"3.96\";\n@@ -784,2 +784,2 @@\n-                        .orElseThrow(() -> new SkippedException(\n-                        \"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n+                        .orElseThrow(() ->\n+                            new RuntimeException(\"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325506\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm Deterministic\n+ * @summary confirm the output of random calculations are determined\n+ *          by the SecureRandom parameters\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.util.SignatureUtil;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KEM;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.DHParameterSpec;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.DSAParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class Deterministic {\n+\n+    private static final long SEED = SeededSecureRandom.seed();\n+    private static int hash = 0;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        for (var p : Security.getProviders()) {\n+            var name = p.getName();\n+            if (name.equals(\"SunMSCAPI\") || name.startsWith(\"SunPKCS11\")) {\n+                System.out.println(\"Skipped native provider \" + name);\n+                continue;\n+            }\n+            for (var s : p.getServices()) {\n+                switch (s.getType()) {\n+                    case \"KeyPairGenerator\" -> testKeyPairGenerator(s);\n+                    case \"KeyGenerator\" -> testKeyGenerator(s);\n+                    case \"Signature\" -> testSignature(s);\n+                    case \"KEM\" -> testKEM(s);\n+                    case \"KeyAgreement\" -> testKeyAgreement(s);\n+                    case \"Cipher\" -> testCipher(s);\n+                    case \"AlgorithmParameterGenerator\" -> testAlgorithmParameterGenerator(s);\n+                }\n+            }\n+        }\n+        \/\/ Run twice and this value should be the same for the same SEED\n+        System.out.println(\"Final hash: \" + hash);\n+    }\n+\n+    static void testCipher(Provider.Service s) throws Exception {\n+        var alg = s.getAlgorithm();\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + alg);\n+        if (alg.contains(\"Wrap\") || alg.contains(\"KW\")) {\n+            System.out.println(\"    Ignored\");\n+            return;\n+        }\n+        Key key;\n+        AlgorithmParameterSpec spec;\n+        if (alg.startsWith(\"PBE\")) {\n+            key = new SecretKeySpec(\"isthisakey\".getBytes(StandardCharsets.UTF_8), \"PBE\");\n+            \/\/ Some cipher requires salt to be 8 byte long\n+            spec = new PBEParameterSpec(\"saltsalt\".getBytes(StandardCharsets.UTF_8), 100);\n+        } else {\n+            key = generateKey(alg.split(\"\/\")[0], s.getProvider());\n+            if (!alg.contains(\"\/\") || alg.contains(\"\/ECB\/\")) {\n+                spec = null;\n+            } else {\n+                if (alg.contains(\"\/GCM\/\")) {\n+                    spec = new GCMParameterSpec(128, new SeededSecureRandom(SEED + 1).generateSeed(16));\n+                } else if (alg.equals(\"ChaCha20\")) {\n+                    spec = new ChaCha20ParameterSpec(new SeededSecureRandom(SEED + 2).generateSeed(12), 128);\n+                } else if (alg.contains(\"ChaCha20\")) {\n+                    spec = new IvParameterSpec(new SeededSecureRandom(SEED + 3).generateSeed(12));\n+                } else {\n+                    spec = new IvParameterSpec(new SeededSecureRandom(SEED + 4).generateSeed(16));\n+                }\n+            }\n+        }\n+        var c = Cipher.getInstance(alg, s.getProvider());\n+        c.init(Cipher.ENCRYPT_MODE, key, spec, new SeededSecureRandom(SEED));\n+        \/\/ Some cipher requires plaintext to be 16 byte long\n+        var ct1 = c.doFinal(\"asimpleplaintext\".getBytes(StandardCharsets.UTF_8));\n+        \/\/ Some cipher requires IV to be different, so re-instantiate a cipher\n+        c = Cipher.getInstance(alg, s.getProvider());\n+        c.init(Cipher.ENCRYPT_MODE, key, spec, new SeededSecureRandom(SEED));\n+        var ct2 = c.doFinal(\"asimpleplaintext\".getBytes(StandardCharsets.UTF_8));\n+        Asserts.assertEqualsByteArray(ct1, ct2);\n+        hash = Objects.hash(hash, Arrays.hashCode(ct1));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static void testAlgorithmParameterGenerator(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        var apg = AlgorithmParameterGenerator.getInstance(s.getAlgorithm(), s.getProvider());\n+        apg.init(1024, new SeededSecureRandom(SEED));\n+        var p1 = apg.generateParameters().getParameterSpec(AlgorithmParameterSpec.class);\n+        apg.init(1024, new SeededSecureRandom(SEED));\n+        var p2 = apg.generateParameters().getParameterSpec(AlgorithmParameterSpec.class);\n+        if (p1 instanceof DSAParameterSpec d1 && p2 instanceof DSAParameterSpec d2) {\n+            Asserts.assertEQ(d1.getG(), d2.getG());\n+            Asserts.assertEQ(d1.getP(), d2.getP());\n+            Asserts.assertEQ(d1.getQ(), d2.getQ());\n+            hash = Objects.hash(hash, d1.getG(), d1.getP(), d1.getQ());\n+        } else if (p1 instanceof DHParameterSpec d1 && p2 instanceof DHParameterSpec d2){\n+            Asserts.assertEQ(d1.getG(), d2.getG());\n+            Asserts.assertEQ(d1.getP(), d2.getP());\n+            Asserts.assertEQ(d1.getL(), d2.getL());\n+            hash = Objects.hash(hash, d1.getG(), d1.getP(), d1.getL());\n+        } else {\n+            Asserts.assertEQ(p1, p2);\n+            hash = Objects.hash(hash, p1);\n+        }\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    private static void testSignature(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        String keyAlg = SignatureUtil.extractKeyAlgFromDwithE(s.getAlgorithm());\n+        \/\/ Later versions implement this in sun\/security\/util\/SignatureUtil.java\n+        if (keyAlg != null && keyAlg.endsWith(\"INP1363FORMAT\")) {\n+            keyAlg = keyAlg.substring(0, keyAlg.length() - 13);\n+            if (keyAlg.equalsIgnoreCase(\"ECDSA\")) {\n+                keyAlg = \"EC\";\n+            }\n+        }\n+        if (keyAlg == null) {\n+            if (s.getAlgorithm().equals(\"HSS\/LMS\")) {\n+                \/\/ We don't support HSS\/LMS key generation and signing\n+                System.out.println(\"    Ignored: HSS\/LMS\");\n+                return;\n+            } else {\n+                keyAlg = s.getAlgorithm(); \/\/ EdDSA etc\n+            }\n+        }\n+        var sk = generateKeyPair(keyAlg, 0).getPrivate();\n+        var sig = Signature.getInstance(s.getAlgorithm(), s.getProvider());\n+        try {\n+            if (keyAlg.equals(\"RSASSA-PSS\")) {\n+                sig.setParameter(PSSParameterSpec.DEFAULT);\n+            }\n+            sig.initSign(sk, new SeededSecureRandom(SEED));\n+            sig.update(new byte[20]);\n+            var s1 = sig.sign();\n+            sig.initSign(sk, new SeededSecureRandom(SEED));\n+            sig.update(new byte[20]);\n+            var s2 = sig.sign();\n+            Asserts.assertEqualsByteArray(s1, s2);\n+            hash = Objects.hash(hash, Arrays.hashCode(s1));\n+            System.out.println(\"    Passed\");\n+        } catch (InvalidKeyException ike) {\n+            System.out.println(\"    Ignored: \" + ike.getMessage());\n+        }\n+    }\n+\n+    static void testKeyPairGenerator(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        var kp1 = generateKeyPair(s.getAlgorithm(), 0);\n+        var kp2 = generateKeyPair(s.getAlgorithm(), 0);\n+        Asserts.assertEqualsByteArray(\n+                kp1.getPrivate().getEncoded(), kp2.getPrivate().getEncoded());\n+        Asserts.assertEqualsByteArray(\n+                kp1.getPublic().getEncoded(), kp2.getPublic().getEncoded());\n+        hash = Objects.hash(hash,\n+                Arrays.hashCode(kp1.getPrivate().getEncoded()),\n+                Arrays.hashCode(kp1.getPublic().getEncoded()));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static KeyPair generateKeyPair(String alg, int offset) throws Exception {\n+        var g = KeyPairGenerator.getInstance(alg);\n+        var size = switch (g.getAlgorithm()) {\n+            case \"RSA\", \"RSASSA-PSS\", \"DSA\", \"DiffieHellman\" -> 1024;\n+            case \"EC\" -> 256;\n+            case \"EdDSA\", \"Ed25519\", \"XDH\", \"X25519\" -> 255;\n+            case \"Ed448\", \"X448\" -> 448;\n+            default -> throw new UnsupportedOperationException(alg);\n+        };\n+        g.initialize(size, new SeededSecureRandom(SEED + offset));\n+        return g.generateKeyPair();\n+    }\n+\n+    static void testKeyGenerator(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        if (s.getAlgorithm().startsWith(\"SunTls\")) {\n+            System.out.println(\"    Ignored\");\n+            return;\n+        }\n+        var k1 = generateKey(s.getAlgorithm(), s.getProvider());\n+        var k2 = generateKey(s.getAlgorithm(), s.getProvider());\n+        Asserts.assertEqualsByteArray(k1.getEncoded(), k2.getEncoded());\n+        hash = Objects.hash(hash,\n+                Arrays.hashCode(k1.getEncoded()));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static Key generateKey(String s, Provider p) throws Exception {\n+        if (s.startsWith(\"AES_\")) {\n+            var g = KeyGenerator.getInstance(\"AES\", p);\n+            g.init(Integer.parseInt(s.substring(4)), new SeededSecureRandom(SEED + 1));\n+            return g.generateKey();\n+        } if (s.startsWith(\"ChaCha\")) {\n+            var g = KeyGenerator.getInstance(\"ChaCha20\", p);\n+            g.init(new SeededSecureRandom(SEED + 2));\n+            return g.generateKey();\n+        } if (s.equals(\"RSA\")) {\n+            return generateKeyPair(\"RSA\", 3).getPublic();\n+        } else {\n+            var g = KeyGenerator.getInstance(s, p);\n+            g.init(new SeededSecureRandom(SEED + 4));\n+            return g.generateKey();\n+        }\n+    }\n+\n+    static void testKEM(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        String keyAlg = getKeyAlgFromKEM(s.getAlgorithm());\n+        var kp = generateKeyPair(keyAlg, 10);\n+        var kem = KEM.getInstance(s.getAlgorithm(), s.getProvider());\n+        var e1 = kem.newEncapsulator(kp.getPublic(), null, new SeededSecureRandom(SEED));\n+        var enc1 = e1.encapsulate();\n+        var e2 = kem.newEncapsulator(kp.getPublic(), null, new SeededSecureRandom(SEED));\n+        var enc2 = e2.encapsulate();\n+        Asserts.assertEqualsByteArray(enc1.encapsulation(), enc2.encapsulation());\n+        Asserts.assertEqualsByteArray(enc1.key().getEncoded(), enc2.key().getEncoded());\n+        hash = Objects.hash(hash, Arrays.hashCode(enc1.encapsulation()),\n+                Arrays.hashCode(enc1.key().getEncoded()));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static void testKeyAgreement(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        String keyAlg = getKeyAlgFromKEM(s.getAlgorithm());\n+        var kpS = generateKeyPair(keyAlg, 11);\n+        var kpR = generateKeyPair(keyAlg, 12);\n+        var ka = KeyAgreement.getInstance(s.getAlgorithm(), s.getProvider());\n+        ka.init(kpS.getPrivate(), new SeededSecureRandom(SEED));\n+        ka.doPhase(kpR.getPublic(), true);\n+        var sc1 = ka.generateSecret();\n+        ka.init(kpS.getPrivate(), new SeededSecureRandom(SEED));\n+        ka.doPhase(kpR.getPublic(), true);\n+        var sc2 = ka.generateSecret();\n+\n+        Asserts.assertEqualsByteArray(sc1, sc2);\n+        hash = Objects.hash(hash, Arrays.hashCode(sc1));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static String getKeyAlgFromKEM(String algorithm) {\n+        return switch (algorithm) {\n+            case \"DHKEM\" -> \"X25519\";\n+            case \"ECDH\" -> \"EC\";\n+            default -> algorithm;\n+        };\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/all\/Deterministic.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -1,249 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.math.BigInteger;\n-import java.security.*;\n-import java.security.cert.*;\n-import java.time.*;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import sun.security.validator.Validator;\n-import sun.security.validator.ValidatorException;\n-\n-import jdk.test.lib.security.SecurityUtils;\n-\n-\/**\n- * @test\n- * @bug 8337664 8341059\n- * @summary Check that TLS Server certificates chaining back to distrusted\n- *          Entrust roots are invalid\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.validator\n- * @run main\/othervm Distrust after policyOn invalid\n- * @run main\/othervm Distrust after policyOff valid\n- * @run main\/othervm Distrust before policyOn valid\n- * @run main\/othervm Distrust before policyOff valid\n- *\/\n-\n-public class Distrust {\n-\n-    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n-    private static CertificateFactory cf;\n-\n-    \/\/ Each of the roots have a test certificate chain stored in a file\n-    \/\/ named \"<root>-chain.pem\".\n-    private static String[] rootsToTest = new String[] {\n-        \"entrustevca\", \"entrustrootcaec1\", \"entrustrootcag2\", \"entrustrootcag4\",\n-        \"entrust2048ca\", \"affirmtrustcommercialca\", \"affirmtrustnetworkingca\",\n-        \"affirmtrustpremiumca\", \"affirmtrustpremiumeccca\" };\n-\n-    \/\/ A date that is after the restrictions take effect\n-    private static final Date NOVEMBER_12_2024 =\n-        Date.from(LocalDate.of(2024, 11, 12)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .toInstant());\n-\n-    \/\/ A date that is a second before the restrictions take effect\n-    private static final Date BEFORE_NOVEMBER_12_2024 =\n-        Date.from(LocalDate.of(2024, 11, 12)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .minusSeconds(1)\n-                           .toInstant());\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        boolean before = args[0].equals(\"before\");\n-        boolean policyOn = args[1].equals(\"policyOn\");\n-        boolean isValid = args[2].equals(\"valid\");\n-\n-        if (!policyOn) {\n-            \/\/ disable policy (default is on)\n-            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n-        }\n-\n-        Date notBefore = before ? BEFORE_NOVEMBER_12_2024 : NOVEMBER_12_2024;\n-\n-        X509TrustManager pkixTM = getTMF(\"PKIX\", null);\n-        X509TrustManager sunX509TM = getTMF(\"SunX509\", null);\n-        for (String test : rootsToTest) {\n-            System.err.println(\"Testing \" + test);\n-            X509Certificate[] chain = loadCertificateChain(test);\n-\n-            testTM(sunX509TM, chain, notBefore, isValid);\n-            testTM(pkixTM, chain, notBefore, isValid);\n-        }\n-    }\n-\n-    private static X509TrustManager getTMF(String type,\n-            PKIXBuilderParameters params) throws Exception {\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n-        if (params == null) {\n-            tmf.init((KeyStore)null);\n-        } else {\n-            tmf.init(new CertPathTrustManagerParameters(params));\n-        }\n-        TrustManager[] tms = tmf.getTrustManagers();\n-        for (TrustManager tm : tms) {\n-            X509TrustManager xtm = (X509TrustManager)tm;\n-            return xtm;\n-        }\n-        throw new Exception(\"No TrustManager for \" + type);\n-    }\n-\n-    private static PKIXBuilderParameters getParams() throws Exception {\n-        PKIXBuilderParameters pbp =\n-            new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n-                                      new X509CertSelector());\n-        pbp.setRevocationEnabled(false);\n-        return pbp;\n-    }\n-\n-    private static void testTM(X509TrustManager xtm, X509Certificate[] chain,\n-                               Date notBefore, boolean valid) throws Exception {\n-        \/\/ Check if TLS Server certificate (the first element of the chain)\n-        \/\/ is issued after the specified notBefore date (should be rejected\n-        \/\/ unless distrust property is false). To do this, we need to\n-        \/\/ fake the notBefore date since none of the test certs are issued\n-        \/\/ after then.\n-        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n-\n-        try {\n-            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n-            if (!valid) {\n-                throw new Exception(\"chain should be invalid\");\n-            }\n-        } catch (CertificateException ce) {\n-            \/\/ expired TLS certificates should not be treated as failure\n-            if (expired(ce)) {\n-                System.err.println(\"Test is N\/A, chain is expired\");\n-                return;\n-            }\n-            if (valid) {\n-                throw new Exception(\"Unexpected exception, chain \" +\n-                                    \"should be valid\", ce);\n-            }\n-            if (ce instanceof ValidatorException) {\n-                ValidatorException ve = (ValidatorException)ce;\n-                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n-                    ce.printStackTrace(System.err);\n-                    throw new Exception(\"Unexpected exception: \" + ce);\n-                }\n-            } else {\n-                throw new Exception(\"Unexpected exception: \" + ce);\n-            }\n-        }\n-    }\n-\n-    \/\/ check if a cause of exception is an expired cert\n-    private static boolean expired(CertificateException ce) {\n-        if (ce instanceof CertificateExpiredException) {\n-            return true;\n-        }\n-        Throwable t = ce.getCause();\n-        while (t != null) {\n-            if (t instanceof CertificateExpiredException) {\n-                return true;\n-            }\n-            t = t.getCause();\n-        }\n-        return false;\n-    }\n-\n-    private static X509Certificate[] loadCertificateChain(String name)\n-            throws Exception {\n-        try (InputStream in = new FileInputStream(TEST_SRC + File.separator +\n-                                                  name + \"-chain.pem\")) {\n-            Collection<X509Certificate> certs =\n-                (Collection<X509Certificate>)cf.generateCertificates(in);\n-            return certs.toArray(new X509Certificate[0]);\n-        }\n-    }\n-\n-    private static class DistrustedTLSServerCert extends X509Certificate {\n-        private final X509Certificate cert;\n-        private final Date notBefore;\n-        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n-            this.cert = cert;\n-            this.notBefore = notBefore;\n-        }\n-        public Set<String> getCriticalExtensionOIDs() {\n-           return cert.getCriticalExtensionOIDs();\n-        }\n-        public byte[] getExtensionValue(String oid) {\n-            return cert.getExtensionValue(oid);\n-        }\n-        public Set<String> getNonCriticalExtensionOIDs() {\n-            return cert.getNonCriticalExtensionOIDs();\n-        }\n-        public boolean hasUnsupportedCriticalExtension() {\n-            return cert.hasUnsupportedCriticalExtension();\n-        }\n-        public void checkValidity() throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public void checkValidity(Date date) throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public int getVersion() { return cert.getVersion(); }\n-        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n-        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n-        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n-        public Date getNotBefore() { return notBefore; }\n-        public Date getNotAfter() { return cert.getNotAfter(); }\n-        public byte[] getTBSCertificate() throws CertificateEncodingException {\n-            return cert.getTBSCertificate();\n-        }\n-        public byte[] getSignature() { return cert.getSignature(); }\n-        public String getSigAlgName() { return cert.getSigAlgName(); }\n-        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n-        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n-        public boolean[] getIssuerUniqueID() {\n-            return cert.getIssuerUniqueID();\n-        }\n-        public boolean[] getSubjectUniqueID() {\n-            return cert.getSubjectUniqueID();\n-        }\n-        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n-        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n-        public byte[] getEncoded() throws CertificateEncodingException {\n-            return cert.getEncoded();\n-        }\n-        public void verify(PublicKey key) throws CertificateException,\n-            InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key);\n-        }\n-        public void verify(PublicKey key, String sigProvider) throws\n-            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key, sigProvider);\n-        }\n-        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n-        public String toString() { return cert.toString(); }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/Distrust.java","additions":0,"deletions":249,"binary":false,"changes":249,"status":"deleted"},{"patch":"@@ -1,292 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.math.BigInteger;\n-import java.security.*;\n-import java.security.cert.*;\n-import java.time.*;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import sun.security.validator.Validator;\n-import sun.security.validator.ValidatorException;\n-\n-import jdk.test.lib.security.SecurityUtils;\n-\n-\/**\n- * @test\n- * @bug 8207258 8216280\n- * @summary Check that TLS Server certificates chaining back to distrusted\n- *          Symantec roots are invalid\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.validator\n- * @run main\/othervm Distrust after policyOn invalid\n- * @run main\/othervm Distrust after policyOff valid\n- * @run main\/othervm Distrust before policyOn valid\n- * @run main\/othervm Distrust before policyOff valid\n- *\/\n-\n-public class Distrust {\n-\n-    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n-    private static CertificateFactory cf;\n-\n-    \/\/ Each of the roots have a test certificate chain stored in a file\n-    \/\/ named \"<root>-chain.pem\".\n-    private static String[] rootsToTest = new String[] {\n-        \"geotrustprimarycag2\", \"geotrustprimarycag3\",\n-        \"geotrustuniversalca\", \"thawteprimaryrootca\", \"thawteprimaryrootcag2\",\n-        \"thawteprimaryrootcag3\", \"verisignclass3g3ca\", \"verisignclass3g4ca\",\n-        \"verisignclass3g5ca\", \"verisignuniversalrootca\" };\n-\n-    \/\/ Each of the subCAs with a delayed distrust date have a test certificate\n-    \/\/ chain stored in a file named \"<subCA>-chain.pem\".\n-    private static String[] subCAsToTest = new String[]{\"appleistca8g1\"};\n-\n-    \/\/ A date that is after the restrictions take affect\n-    private static final Date APRIL_17_2019 =\n-        Date.from(LocalDate.of(2019, 4, 17)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .toInstant());\n-\n-    \/\/ A date that is a second before the restrictions take affect\n-    private static final Date BEFORE_APRIL_17_2019 =\n-        Date.from(LocalDate.of(2019, 4, 17)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .minusSeconds(1)\n-                           .toInstant());\n-\n-    \/\/ A date that is after the subCA restrictions take affect\n-    private static final Date JANUARY_1_2020 =\n-        Date.from(LocalDate.of(2020, 1, 1)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .toInstant());\n-\n-    \/\/ A date that is a second before the subCA restrictions take affect\n-    private static final Date BEFORE_JANUARY_1_2020 =\n-        Date.from(LocalDate.of(2020, 1, 1)\n-                           .atStartOfDay(ZoneOffset.UTC)\n-                           .minusSeconds(1)\n-                           .toInstant());\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        boolean before = args[0].equals(\"before\");\n-        boolean policyOn = args[1].equals(\"policyOn\");\n-        boolean isValid = args[2].equals(\"valid\");\n-\n-        if (!policyOn) {\n-            \/\/ disable policy (default is on)\n-            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n-        }\n-\n-        Date notBefore = before ? BEFORE_APRIL_17_2019 : APRIL_17_2019;\n-\n-        X509TrustManager pkixTM = getTMF(\"PKIX\", null);\n-        X509TrustManager sunX509TM = getTMF(\"SunX509\", null);\n-        for (String test : rootsToTest) {\n-            System.err.println(\"Testing \" + test);\n-            X509Certificate[] chain = loadCertificateChain(test);\n-\n-            testTM(sunX509TM, chain, notBefore, isValid);\n-            testTM(pkixTM, chain, notBefore, isValid);\n-        }\n-\n-        \/\/ test chain if params are passed to TrustManager\n-        System.err.println(\"Testing verisignuniversalrootca with params\");\n-        testTM(getTMF(\"PKIX\", getParams()),\n-               loadCertificateChain(\"verisignuniversalrootca\"),\n-               notBefore, isValid);\n-\n-        \/\/ test code-signing chain (should be valid as restrictions don't apply)\n-        System.err.println(\"Testing verisignclass3g5ca code-signing chain\");\n-        Validator v = Validator.getInstance(Validator.TYPE_PKIX,\n-                                            Validator.VAR_CODE_SIGNING,\n-                                            getParams());\n-        \/\/ set validation date so this will still pass when cert expires\n-        v.setValidationDate(new Date(1544197375493l));\n-        v.validate(loadCertificateChain(\"verisignclass3g5ca-codesigning\"));\n-\n-        \/\/ test chains issued through subCAs\n-        notBefore = before ? BEFORE_JANUARY_1_2020 : JANUARY_1_2020;\n-        for (String test : subCAsToTest) {\n-            System.err.println(\"Testing \" + test);\n-            X509Certificate[] chain = loadCertificateChain(test);\n-\n-            testTM(sunX509TM, chain, notBefore, isValid);\n-            testTM(pkixTM, chain, notBefore, isValid);\n-        }\n-    }\n-\n-    private static X509TrustManager getTMF(String type,\n-            PKIXBuilderParameters params) throws Exception {\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n-        if (params == null) {\n-            tmf.init((KeyStore)null);\n-        } else {\n-            tmf.init(new CertPathTrustManagerParameters(params));\n-        }\n-        TrustManager[] tms = tmf.getTrustManagers();\n-        for (TrustManager tm : tms) {\n-            X509TrustManager xtm = (X509TrustManager)tm;\n-            return xtm;\n-        }\n-        throw new Exception(\"No TrustManager for \" + type);\n-    }\n-\n-    private static PKIXBuilderParameters getParams() throws Exception {\n-        PKIXBuilderParameters pbp =\n-            new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n-                                      new X509CertSelector());\n-        pbp.setRevocationEnabled(false);\n-        return pbp;\n-    }\n-\n-    private static void testTM(X509TrustManager xtm, X509Certificate[] chain,\n-                               Date notBefore, boolean valid) throws Exception {\n-        \/\/ Check if TLS Server certificate (the first element of the chain)\n-        \/\/ is issued after the specified notBefore date (should be rejected\n-        \/\/ unless distrust property is false). To do this, we need to\n-        \/\/ fake the notBefore date since none of the test certs are issued\n-        \/\/ after then.\n-        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n-\n-        try {\n-            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n-            if (!valid) {\n-                throw new Exception(\"chain should be invalid\");\n-            }\n-        } catch (CertificateException ce) {\n-            \/\/ expired TLS certificates should not be treated as failure\n-            if (expired(ce)) {\n-                System.err.println(\"Test is N\/A, chain is expired\");\n-                return;\n-            }\n-            if (valid) {\n-                throw new Exception(\"Unexpected exception, chain \" +\n-                                    \"should be valid\", ce);\n-            }\n-            if (ce instanceof ValidatorException) {\n-                ValidatorException ve = (ValidatorException)ce;\n-                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n-                    ce.printStackTrace(System.err);\n-                    throw new Exception(\"Unexpected exception: \" + ce);\n-                }\n-            } else {\n-                throw new Exception(\"Unexpected exception: \" + ce);\n-            }\n-        }\n-    }\n-\n-    \/\/ check if a cause of exception is an expired cert\n-    private static boolean expired(CertificateException ce) {\n-        if (ce instanceof CertificateExpiredException) {\n-            return true;\n-        }\n-        Throwable t = ce.getCause();\n-        while (t != null) {\n-            if (t instanceof CertificateExpiredException) {\n-                return true;\n-            }\n-            t = t.getCause();\n-        }\n-        return false;\n-    }\n-\n-    private static X509Certificate[] loadCertificateChain(String name)\n-            throws Exception {\n-        try (InputStream in = new FileInputStream(TEST_SRC + File.separator +\n-                                                  name + \"-chain.pem\")) {\n-            Collection<X509Certificate> certs =\n-                (Collection<X509Certificate>)cf.generateCertificates(in);\n-            return certs.toArray(new X509Certificate[0]);\n-        }\n-    }\n-\n-    private static class DistrustedTLSServerCert extends X509Certificate {\n-        private final X509Certificate cert;\n-        private final Date notBefore;\n-        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n-            this.cert = cert;\n-            this.notBefore = notBefore;\n-        }\n-        public Set<String> getCriticalExtensionOIDs() {\n-           return cert.getCriticalExtensionOIDs();\n-        }\n-        public byte[] getExtensionValue(String oid) {\n-            return cert.getExtensionValue(oid);\n-        }\n-        public Set<String> getNonCriticalExtensionOIDs() {\n-            return cert.getNonCriticalExtensionOIDs();\n-        }\n-        public boolean hasUnsupportedCriticalExtension() {\n-            return cert.hasUnsupportedCriticalExtension();\n-        }\n-        public void checkValidity() throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public void checkValidity(Date date) throws CertificateExpiredException,\n-            CertificateNotYetValidException {\n-            \/\/ always pass\n-        }\n-        public int getVersion() { return cert.getVersion(); }\n-        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n-        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n-        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n-        public Date getNotBefore() { return notBefore; }\n-        public Date getNotAfter() { return cert.getNotAfter(); }\n-        public byte[] getTBSCertificate() throws CertificateEncodingException {\n-            return cert.getTBSCertificate();\n-        }\n-        public byte[] getSignature() { return cert.getSignature(); }\n-        public String getSigAlgName() { return cert.getSigAlgName(); }\n-        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n-        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n-        public boolean[] getIssuerUniqueID() {\n-            return cert.getIssuerUniqueID();\n-        }\n-        public boolean[] getSubjectUniqueID() {\n-            return cert.getSubjectUniqueID();\n-        }\n-        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n-        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n-        public byte[] getEncoded() throws CertificateEncodingException {\n-            return cert.getEncoded();\n-        }\n-        public void verify(PublicKey key) throws CertificateException,\n-            InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key);\n-        }\n-        public void verify(PublicKey key, String sigProvider) throws\n-            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n-            NoSuchProviderException, SignatureException {\n-            cert.verify(key, sigProvider);\n-        }\n-        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n-        public String toString() { return cert.toString(); }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/Distrust.java","additions":0,"deletions":292,"binary":false,"changes":292,"status":"deleted"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.cert.*;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import javax.net.ssl.*;\n+import sun.security.validator.Validator;\n+import sun.security.validator.ValidatorException;\n+\n+import jdk.test.lib.security.SecurityUtils;\n+\n+\/**\n+ * Helper class that provides methods to facilitate testing of distrusted roots.\n+ *\/\n+public final class Distrust {\n+\n+    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n+    private static CertificateFactory cf;\n+\n+    private final boolean before;\n+    private final boolean policyOn;\n+    private final boolean isValid;\n+\n+    public Distrust(String[] args) {\n+        before = args[0].equals(\"before\");\n+        policyOn = args[1].equals(\"policyOn\");\n+        isValid = args[2].equals(\"valid\");\n+\n+        if (!policyOn) {\n+            \/\/ disable policy (default is on)\n+            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n+        }\n+    }\n+\n+    public Date getNotBefore(ZonedDateTime distrustDate) {\n+        ZonedDateTime notBefore = before ? distrustDate.minusSeconds(1) : distrustDate;\n+        return Date.from(notBefore.toInstant());\n+    }\n+\n+    public void testCodeSigningChain(String certPath, String name, Date validationDate)\n+            throws Exception {\n+        System.err.println(\"Testing \" + name + \" code-signing chain\");\n+        Validator v = Validator.getInstance(Validator.TYPE_PKIX,\n+                Validator.VAR_CODE_SIGNING,\n+                getParams());\n+        \/\/ set validation date so this will still pass when cert expires\n+        v.setValidationDate(validationDate);\n+        v.validate(loadCertificateChain(certPath, name));\n+    }\n+\n+    public void testCertificateChain(String certPath, Date notBefore, X509TrustManager[] tms,\n+                                     String... tests) throws Exception {\n+        for (String test : tests) {\n+            System.err.println(\"Testing \" + test);\n+            X509Certificate[] chain = loadCertificateChain(certPath, test);\n+\n+            for (X509TrustManager tm : tms) {\n+                testTM(tm, chain, notBefore, isValid);\n+            }\n+        }\n+    }\n+\n+    public X509TrustManager getTMF(String type, PKIXBuilderParameters params) throws Exception {\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n+        if (params == null) {\n+            tmf.init((KeyStore) null);\n+        } else {\n+            tmf.init(new CertPathTrustManagerParameters(params));\n+        }\n+        TrustManager[] tms = tmf.getTrustManagers();\n+        for (TrustManager tm : tms) {\n+            return (X509TrustManager) tm;\n+        }\n+        throw new RuntimeException(\"No TrustManager for \" + type);\n+    }\n+\n+    public PKIXBuilderParameters getParams() throws Exception {\n+        PKIXBuilderParameters pbp =\n+                new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n+                        new X509CertSelector());\n+        pbp.setRevocationEnabled(false);\n+        return pbp;\n+    }\n+\n+    public void testTM(X509TrustManager xtm, X509Certificate[] chain,\n+                              Date notBefore, boolean valid) {\n+        \/\/ Check if TLS Server certificate (the first element of the chain)\n+        \/\/ is issued after the specified notBefore date (should be rejected\n+        \/\/ unless distrust property is false). To do this, we need to\n+        \/\/ fake the notBefore date since none of the test certs are issued\n+        \/\/ after then.\n+        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n+\n+        \/\/ Wrap the intermediate and root CA certs in NonExpiringTLSServerCert\n+        \/\/ so it will never throw a CertificateExpiredException\n+        for (int i = 1; i < chain.length; i++) {\n+            chain[i] = new NonExpiringTLSServerCert(chain[i]);\n+        }\n+\n+        try {\n+            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n+            if (!valid) {\n+                throw new RuntimeException(\"chain should be invalid\");\n+            }\n+        } catch (CertificateException ce) {\n+            if (valid) {\n+                throw new RuntimeException(\"Unexpected exception, chain \" +\n+                        \"should be valid\", ce);\n+            }\n+            if (ce instanceof ValidatorException) {\n+                ValidatorException ve = (ValidatorException) ce;\n+                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n+                    ce.printStackTrace(System.err);\n+                    throw new RuntimeException(\"Unexpected exception: \" + ce);\n+                }\n+            } else {\n+                throw new RuntimeException(ce);\n+            }\n+        }\n+    }\n+\n+    private X509Certificate[] loadCertificateChain(String certPath, String name)\n+            throws Exception {\n+        if (cf == null) {\n+            cf = CertificateFactory.getInstance(\"X.509\");\n+        }\n+        try (InputStream in = new FileInputStream(TEST_SRC + File.separator + certPath +\n+                File.separator + name + \"-chain.pem\")) {\n+            Collection<X509Certificate> certs =\n+                    (Collection<X509Certificate>) cf.generateCertificates(in);\n+            return certs.toArray(new X509Certificate[0]);\n+        }\n+    }\n+\n+    private static class NonExpiringTLSServerCert extends X509Certificate {\n+        private final X509Certificate cert;\n+        NonExpiringTLSServerCert(X509Certificate cert) {\n+            this.cert = cert;\n+        }\n+        public Set<String> getCriticalExtensionOIDs() {\n+            return cert.getCriticalExtensionOIDs();\n+        }\n+        public byte[] getExtensionValue(String oid) {\n+            return cert.getExtensionValue(oid);\n+        }\n+        public Set<String> getNonCriticalExtensionOIDs() {\n+            return cert.getNonCriticalExtensionOIDs();\n+        }\n+        public boolean hasUnsupportedCriticalExtension() {\n+            return cert.hasUnsupportedCriticalExtension();\n+        }\n+        public void checkValidity() {\n+            \/\/ always pass\n+        }\n+        public void checkValidity(Date date) {\n+            \/\/ always pass\n+        }\n+        public int getVersion() { return cert.getVersion(); }\n+        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n+        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n+        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n+        public Date getNotBefore() { return cert.getNotBefore(); }\n+        public Date getNotAfter() { return cert.getNotAfter(); }\n+        public byte[] getTBSCertificate() throws CertificateEncodingException {\n+            return cert.getTBSCertificate();\n+        }\n+        public byte[] getSignature() { return cert.getSignature(); }\n+        public String getSigAlgName() { return cert.getSigAlgName(); }\n+        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n+        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n+        public boolean[] getIssuerUniqueID() {\n+            return cert.getIssuerUniqueID();\n+        }\n+        public boolean[] getSubjectUniqueID() {\n+            return cert.getSubjectUniqueID();\n+        }\n+        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n+        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n+        public byte[] getEncoded() throws CertificateEncodingException {\n+            return cert.getEncoded();\n+        }\n+        public void verify(PublicKey key) throws CertificateException,\n+                InvalidKeyException, NoSuchAlgorithmException,\n+                NoSuchProviderException, SignatureException {\n+            cert.verify(key);\n+        }\n+        public void verify(PublicKey key, String sigProvider) throws\n+                CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n+                NoSuchProviderException, SignatureException {\n+            cert.verify(key, sigProvider);\n+        }\n+        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n+        public String toString() { return cert.toString(); }\n+    }\n+\n+    private static class DistrustedTLSServerCert extends NonExpiringTLSServerCert {\n+        private final Date notBefore;\n+        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n+            super(cert);\n+            this.notBefore = notBefore;\n+        }\n+        public Date getNotBefore() { return notBefore; }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Distrust.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.time.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+\/**\n+ * @test\n+ * @bug 8337664 8341059\n+ * @summary Check that TLS Server certificates chaining back to distrusted\n+ *          Entrust roots are invalid\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.validator\n+ * @run main\/othervm Entrust after policyOn invalid\n+ * @run main\/othervm Entrust after policyOff valid\n+ * @run main\/othervm Entrust before policyOn valid\n+ * @run main\/othervm Entrust before policyOff valid\n+ *\/\n+\n+public class Entrust {\n+\n+    private static final String certPath = \"chains\" + File.separator + \"entrust\";\n+\n+    \/\/ Each of the roots have a test certificate chain stored in a file\n+    \/\/ named \"<root>-chain.pem\".\n+    private static String[] rootsToTest = new String[]{\n+            \"entrustevca\", \"entrustrootcaec1\", \"entrustrootcag2\", \"entrustrootcag4\",\n+            \"entrust2048ca\", \"affirmtrustcommercialca\", \"affirmtrustnetworkingca\",\n+            \"affirmtrustpremiumca\", \"affirmtrustpremiumeccca\"};\n+\n+    \/\/ Date when the restrictions take effect\n+    private static final ZonedDateTime DISTRUST_DATE =\n+            LocalDate.of(2024, 11, 12).atStartOfDay(ZoneOffset.UTC);\n+\n+    public static void main(String[] args) throws Exception {\n+        Distrust distrust = new Distrust(args);\n+\n+        X509TrustManager[] tms = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", null),\n+                distrust.getTMF(\"SunX509\", null)\n+        };\n+\n+        Date notBefore = distrust.getNotBefore(DISTRUST_DATE);\n+        distrust.testCertificateChain(certPath, notBefore, tms, rootsToTest);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Entrust.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.File;\n+import java.time.*;\n+import java.util.*;\n+\n+\n+\/**\n+ * @test\n+ * @bug 8207258 8216280\n+ * @summary Check that TLS Server certificates chaining back to distrusted\n+ *          Symantec roots are invalid\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.validator\n+ * @run main\/othervm Symantec after policyOn invalid\n+ * @run main\/othervm Symantec after policyOff valid\n+ * @run main\/othervm Symantec before policyOn valid\n+ * @run main\/othervm Symantec before policyOff valid\n+ *\/\n+\n+public class Symantec {\n+\n+    private static final String certPath = \"chains\" + File.separator + \"symantec\";\n+\n+    \/\/ Each of the roots have a test certificate chain stored in a file\n+    \/\/ named \"<root>-chain.pem\".\n+    private static final String[] rootsToTest = new String[]{\n+            \"geotrustprimarycag2\", \"geotrustprimarycag3\", \"geotrustuniversalca\",\n+            \"thawteprimaryrootca\", \"thawteprimaryrootcag2\", \"thawteprimaryrootcag3\",\n+            \"verisignclass3g3ca\", \"verisignclass3g4ca\", \"verisignclass3g5ca\",\n+            \"verisignuniversalrootca\"\n+    };\n+\n+    \/\/ Each of the subCAs with a delayed distrust date have a test certificate\n+    \/\/ chain stored in a file named \"<subCA>-chain.pem\".\n+    private static String[] subCAsToTest = new String[]{\"appleistca8g1\"};\n+\n+    \/\/ Date when the restrictions take effect\n+    private static final ZonedDateTime ROOTS_DISTRUST_DATE =\n+            LocalDate.of(2019, 4, 17).atStartOfDay(ZoneOffset.UTC);\n+\n+    \/\/ Date when the subCA restrictions take effect\n+    private static final ZonedDateTime SUBCA_DISTRUST_DATE =\n+            LocalDate.of(2020, 1, 1).atStartOfDay(ZoneOffset.UTC);\n+\n+    public static void main(String[] args) throws Exception {\n+        Distrust distrust = new Distrust(args);\n+        X509TrustManager[] tms = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", null),\n+                distrust.getTMF(\"SunX509\", null)\n+        };\n+\n+        \/\/ test chains issued through roots\n+        Date notBefore = distrust.getNotBefore(ROOTS_DISTRUST_DATE);\n+        distrust.testCertificateChain(certPath, notBefore, tms, rootsToTest);\n+\n+        \/\/ test chain if params are passed to TrustManager\n+        System.err.println(\"Testing verisignuniversalrootca with params\");\n+        X509TrustManager[] tmsParams = new X509TrustManager[]{\n+                distrust.getTMF(\"PKIX\", distrust.getParams())\n+        };\n+        distrust.testCertificateChain(certPath, notBefore, tmsParams,\n+                \"verisignuniversalrootca\");\n+\n+        \/\/ test code-signing chain (should be valid as restrictions don't apply)\n+        Date validationDate = new Date(1544197375493L);\n+        distrust.testCodeSigningChain(certPath, \"verisignclass3g5ca-codesigning\", validationDate);\n+\n+        \/\/ test chains issued through subCAs\n+        notBefore = distrust.getNotBefore(SUBCA_DISTRUST_DATE);\n+        distrust.testCertificateChain(certPath, notBefore, tms, subCAsToTest);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/Symantec.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustcommercialca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustcommercialca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustnetworkingca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustnetworkingca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustpremiumca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/affirmtrustpremiumeccca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumeccca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrust2048ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrust2048ca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustevca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustevca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustrootcaec1-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcaec1-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustrootcag2-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag2-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/entrust\/entrustrootcag4-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag4-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/appleistca8g1-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/appleistca8g1-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/geotrustprimarycag2-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/geotrustprimarycag2-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/geotrustprimarycag3-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/geotrustprimarycag3-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/geotrustuniversalca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/geotrustuniversalca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/thawteprimaryrootca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/thawteprimaryrootca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/thawteprimaryrootcag2-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/thawteprimaryrootcag2-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/thawteprimaryrootcag3-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/thawteprimaryrootcag3-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g3ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g3ca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g4ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g4ca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g5ca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g5ca-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignclass3g5ca-codesigning-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignclass3g5ca-codesigning-chain.pem","status":"renamed"},{"patch":"","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/distrust\/chains\/symantec\/verisignuniversalrootca-chain.pem","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Symantec\/verisignuniversalrootca-chain.pem","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/java\/security\/testlibrary\n@@ -1868,169 +1869,1 @@\n-}\n-\n-\/**\n- * HumanInputStream tries to act like a human sitting in front of a computer\n- * terminal typing on the keyboard while the keytool program is running.\n- *\n- * keytool has called InputStream.read() and BufferedReader.readLine() in\n- * various places. a call to B.readLine() will try to buffer as much input as\n- * possible. Thus, a trivial InputStream will find it impossible to feed\n- * anything to I.read() after a B.readLine() call.\n- *\n- * This is why i create HumanInputStream, which will only send a single line\n- * to B.readLine(), no more, no less, and the next I.read() can have a chance\n- * to read the exact character right after \"\\n\".\n- *\n- * I don't know why HumanInputStream works.\n- *\/\n-class HumanInputStream extends InputStream {\n-    byte[] src;\n-    int pos;\n-    int length;\n-    boolean inLine;\n-    int stopIt;\n-\n-    public HumanInputStream(String input) {\n-        src = input.getBytes();\n-        pos = 0;\n-        length = src.length;\n-        stopIt = 0;\n-        inLine = false;\n-    }\n-\n-    \/\/ the trick: when called through read(byte[], int, int),\n-    \/\/ return -1 twice after \"\\n\"\n-\n-    @Override public int read() throws IOException {\n-        int re;\n-        if(pos < length) {\n-            re = src[pos];\n-            if(inLine) {\n-                if(stopIt > 0) {\n-                    stopIt--;\n-                    re = -1;\n-                } else {\n-                    if(re == '\\n') {\n-                        stopIt = 2;\n-                    }\n-                    pos++;\n-                }\n-            } else {\n-                pos++;\n-            }\n-        } else {\n-            re = -1;\/\/throw new IOException(\"NO MORE TO READ\");\n-        }\n-        \/\/if (re < 32) System.err.printf(\"[%02d]\", re);\n-        \/\/else System.err.printf(\"[%c]\", (char)re);\n-        return re;\n-    }\n-    @Override public int read(byte[] buffer, int offset, int len) {\n-        inLine = true;\n-        try {\n-            int re = super.read(buffer, offset, len);\n-            return re;\n-        } catch(Exception e) {\n-            throw new RuntimeException(\"HumanInputStream error\");\n-        } finally {\n-            inLine = false;\n-        }\n-    }\n-    @Override public int available() {\n-        if(pos < length) return 1;\n-        return 0;\n-    }\n-\n-    \/\/ test part\n-    static void assertTrue(boolean bool) {\n-        if(!bool)\n-            throw new RuntimeException();\n-    }\n-\n-    public static void test() throws Exception {\n-\n-        class Tester {\n-            HumanInputStream is;\n-            BufferedReader reader;\n-            Tester(String s) {\n-                is = new HumanInputStream(s);\n-                reader = new BufferedReader(new InputStreamReader(is));\n-            }\n-\n-            \/\/ three kinds of test method\n-            \/\/ 1. read byte by byte from InputStream\n-            void testStreamReadOnce(int expection) throws Exception {\n-                assertTrue(is.read() == expection);\n-            }\n-            void testStreamReadMany(String expection) throws Exception {\n-                char[] keys = expection.toCharArray();\n-                for(int i=0; i<keys.length; i++) {\n-                    assertTrue(is.read() == keys[i]);\n-                }\n-            }\n-            \/\/ 2. read a line with a newly created Reader\n-            void testReaderReadline(String expection) throws Exception {\n-                String s = new BufferedReader(new InputStreamReader(is)).readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-            \/\/ 3. read a line with the old Reader\n-            void testReaderReadline2(String expection) throws Exception  {\n-                String s = reader.readLine();\n-                if(s == null) assertTrue(expection == null);\n-                else assertTrue(s.equals(expection));\n-            }\n-        }\n-\n-        Tester test;\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline2(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"111\\n222\\n\\n444\\n\\n\");\n-        test.testReaderReadline2(\"111\");\n-        test.testReaderReadline(\"222\");\n-        test.testReaderReadline2(\"\");\n-        test.testReaderReadline2(\"444\");\n-        test.testReaderReadline(\"\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"1\\n2\");\n-        test.testStreamReadMany(\"1\\n2\");\n-        test.testStreamReadOnce(-1);\n-\n-        test = new Tester(\"12\\n234\");\n-        test.testStreamReadOnce('1');\n-        test.testReaderReadline(\"2\");\n-        test.testStreamReadOnce('2');\n-        test.testReaderReadline2(\"34\");\n-        test.testReaderReadline2(null);\n-\n-        test = new Tester(\"changeit\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"changeit\\nName\\nCountry\\nYes\\n\");\n-        test.testStreamReadMany(\"changeit\\n\");\n-        test.testReaderReadline(\"Name\");\n-        test.testReaderReadline(\"Country\");\n-        test.testReaderReadline(\"Yes\");\n-        test.testReaderReadline(null);\n-\n-        test = new Tester(\"Me\\nHere\\n\");\n-        test.testReaderReadline2(\"Me\");\n-        test.testReaderReadline2(\"Here\");\n-    }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/KeyToolTest.java","additions":3,"deletions":170,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11\n+ * @library \/test\/lib \/test\/jdk\/sun\/security\/pkcs11 \/java\/security\/testlibrary\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/NssTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8228969 8244087 8255266 8302182\n+ * @bug 8228969 8244087 8255266 8302182 8331864\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/ParseNames.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,0 +164,11 @@\n+# newGTLDs\n+\n+# This is not a GTLD\n+www.site.unknown        www.site.unknown    null\n+\n+# GTLD added in 1cbd6e7\n+www.site.wed            wed                 site.wed\n+\n+# GTLD removed in 1cbd6e7\n+www.site.oldnavy        www.site.oldnavy    null\n+\n","filename":"test\/jdk\/sun\/security\/util\/RegisteredDomain\/tests.dat","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,0 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n@@ -50,9 +45,0 @@\n-    private static final Map<String,Month> abbreviations\n-                                = new HashMap<String,Month>(12);\n-\n-    static {\n-        for (Month m : Month.values()) {\n-            abbreviations.put(m.abbr, m);\n-        }\n-    }\n-\n@@ -73,5 +59,16 @@\n-        Month m = abbreviations.get(name);\n-        if (m != null) {\n-            return m;\n-        }\n-        return null;\n+        int len = name.length();\n+\n+        if (name.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n+        if (name.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n+        if (name.regionMatches(true, 0, \"March\", 0, len)) return Month.MARCH;\n+        if (name.regionMatches(true, 0, \"April\", 0, len)) return Month.APRIL;\n+        if (name.regionMatches(true, 0, \"May\", 0, len)) return Month.MAY;\n+        if (name.regionMatches(true, 0, \"June\", 0, len)) return Month.JUNE;\n+        if (name.regionMatches(true, 0, \"July\", 0, len)) return Month.JULY;\n+        if (name.regionMatches(true, 0, \"August\", 0, len)) return Month.AUGUST;\n+        if (name.regionMatches(true, 0, \"September\", 0, len)) return Month.SEPTEMBER;\n+        if (name.regionMatches(true, 0, \"October\", 0, len)) return Month.OCTOBER;\n+        if (name.regionMatches(true, 0, \"November\", 0, len)) return Month.NOVEMBER;\n+        if (name.regionMatches(true, 0, \"December\", 0, len)) return Month.DECEMBER;\n+\n+        throw new IllegalArgumentException(\"Unknown month: \" + name);\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Month.java","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,0 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n@@ -37,7 +32,0 @@\n-    private static final Map<String,DayOfWeek> abbreviations = new HashMap<String,DayOfWeek>(7);\n-    static {\n-        for (DayOfWeek day : DayOfWeek.values()) {\n-            abbreviations.put(day.getAbbr(), day);\n-        }\n-    }\n-\n@@ -169,2 +157,12 @@\n-    private static DayOfWeek getDOW(String abbr) {\n-        return abbreviations.get(abbr);\n+    private static DayOfWeek getDOW(String name) {\n+        int len = name.length();\n+\n+        if (name.regionMatches(true, 0, \"Monday\", 0, len)) return DayOfWeek.MONDAY;\n+        if (name.regionMatches(true, 0, \"Tuesday\", 0, len)) return DayOfWeek.TUESDAY;\n+        if (name.regionMatches(true, 0, \"Wednesday\", 0, len)) return DayOfWeek.WEDNESDAY;\n+        if (name.regionMatches(true, 0, \"Thursday\", 0, len)) return DayOfWeek.THURSDAY;\n+        if (name.regionMatches(true, 0, \"Friday\", 0, len)) return DayOfWeek.FRIDAY;\n+        if (name.regionMatches(true, 0, \"Saturday\", 0, len)) return DayOfWeek.SATURDAY;\n+        if (name.regionMatches(true, 0, \"Sunday\", 0, len)) return DayOfWeek.SUNDAY;\n+\n+        throw new IllegalArgumentException(\"Unknown day-of-week: \" + name);\n@@ -175,1 +173,1 @@\n-     * name defined in {@link java.util.Calenda}.\n+     * name defined in {@link java.util.Calendar}.\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleDay.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -382,0 +382,1 @@\n+        vmOptFinalFlag(map, \"UnlockExperimentalVMOptions\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @key intermittent\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionMessageTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -25,0 +27,2 @@\n+import java.util.Arrays;\n+import java.util.HexFormat;\n@@ -52,0 +56,1 @@\n+        testEqualsByteArray();\n@@ -93,0 +98,20 @@\n+    private static void testEqualsByteArray() throws Exception {\n+        byte[] b1 = new byte[1];\n+        byte[] b11 = new byte[1];\n+        byte[] b2 = new byte[2];\n+\n+        expectPass(Assertion.EQBA, b1, b1);\n+        expectPass(Assertion.EQBA, b1, b11);\n+        expectPass(Assertion.EQBA, (byte[])null, (byte[])null);\n+        expectPass(Assertion.NEQBA, b1, b2);\n+        expectPass(Assertion.NEQBA, b1, (byte[])null);\n+        expectPass(Assertion.NEQBA, (byte[])null, b1);\n+\n+        expectFail(Assertion.EQBA, b1, b2);\n+        expectFail(Assertion.EQBA, (byte[])null, b1);\n+        expectFail(Assertion.EQBA, b1, (byte[])null);\n+        expectFail(Assertion.NEQBA, b1, b1);\n+        expectFail(Assertion.NEQBA, b1, b11);\n+        expectFail(Assertion.NEQBA, (byte[])null, (byte[])null);\n+    }\n+\n@@ -194,0 +219,37 @@\n+    private static void expectPass(Assertion assertion, byte[] b1, byte[] b2)\n+            throws Exception {\n+        if (assertion == Assertion.EQBA) {\n+            String msg = \"Expected \" + Assertion.asString(\"assertEqualsByteArray\",\n+                    Arrays.toString(b1), Arrays.toString(b2)) + \" to pass\";\n+            Asserts.assertEqualsByteArray(b1, b2, msg);\n+        } else {\n+            String msg = \"Expected \" + Assertion.asString(\"assertNotEqualsByteArray\",\n+                    Arrays.toString(b1), Arrays.toString(b2)) + \" to pass\";\n+            Asserts.assertNotEqualsByteArray(b1, b2, msg);\n+        }\n+    }\n+\n+    private static void expectFail(Assertion assertion, byte[] b1, byte[] b2)\n+            throws Exception {\n+        if (assertion == Assertion.EQBA) {\n+            try {\n+                Asserts.assertEqualsByteArray(b1, b2);\n+            } catch (RuntimeException e) {\n+                return;\n+            }\n+            throw new Exception(\"Expected \"\n+                    + Assertion.asString(\"assertEqualsByteArray\",\n+                    Arrays.toString(b1), Arrays.toString(b2))\n+                    + \" to throw a RuntimeException\");\n+        } else {\n+            try {\n+                Asserts.assertNotEqualsByteArray(b1, b2);\n+            } catch (RuntimeException e) {\n+                return;\n+            }\n+            throw new Exception(\"Expected \"\n+                    + Assertion.asString(\"assertNotEqualsByteArray\",\n+                    Arrays.toString(b1), Arrays.toString(b2))\n+                    + \" to throw a RuntimeException\");\n+        }\n+    }\n@@ -197,1 +259,1 @@\n-    LT, LTE, EQ, GTE, GT, NE, NULL, NOTNULL, FALSE, TRUE;\n+    LT, LTE, EQ, EQBA, NEQBA, GTE, GT, NE, NULL, NOTNULL, FALSE, TRUE;\n@@ -265,1 +327,1 @@\n-    private static String asString(String assertion, Object ... args) {\n+    public static String asString(String assertion, Object ... args) {\n","filename":"test\/lib-test\/jdk\/test\/lib\/AssertsTest.java","additions":65,"deletions":3,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.security;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.test.lib.security.SeededSecureRandomTest\n+ *\/\n+public class SeededSecureRandomTest {\n+\n+    private static final String PROP = \"secure.random.seed\";\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            System.clearProperty(PROP);\n+            Asserts.assertNE(get(), get()); \/\/ random seed (different)\n+            Asserts.assertEQ(get(1L), get(1L)); \/\/ same seed\n+            Asserts.assertEQ(get(10L), get(10L)); \/\/ same seed\n+            Asserts.assertNE(get(1L), get(10L)); \/\/ different seed\n+\n+            System.setProperty(PROP, \"10\");\n+            Asserts.assertEQ(get(), get()); \/\/ seed set by system property\n+            Asserts.assertNE(get(), get(1L)); \/\/ seed set not system property\n+            Asserts.assertEQ(get(), get(10L)); \/\/ seed set same as system property\n+            Asserts.assertEQ(get(1L), get(1L)); \/\/ same seed\n+            Asserts.assertEQ(get(10L), get(10L)); \/\/ same seed\n+            Asserts.assertNE(get(1L), get(10L)); \/\/ different seed\n+        } finally {\n+            System.clearProperty(PROP);\n+        }\n+    }\n+\n+    static int get() {\n+        return new SeededSecureRandom(SeededSecureRandom.seed()).nextInt();\n+    }\n+\n+    static int get(long seed) {\n+        return new SeededSecureRandom(seed).nextInt();\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/security\/SeededSecureRandomTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.util.Arrays;\n+import java.util.HexFormat;\n@@ -237,0 +239,58 @@\n+    \/**\n+     * Asserts that {@code lhs} is the same byte array as {@code rhs}.\n+     *\n+     * @param lhs The left hand side of the comparison.\n+     * @param rhs The right hand side of the comparison.\n+     * @throws RuntimeException if the assertion is not true.\n+     * @see #assertEqualsByteArray(byte[], byte[], String)\n+     *\/\n+    public static void assertEqualsByteArray(byte[] lhs, byte[] rhs) {\n+        assertEqualsByteArray(lhs, rhs, null);\n+    }\n+\n+    \/**\n+     * Asserts that {@code lhs} is not the same byte array as {@code rhs}.\n+     *\n+     * @param lhs The left hand side of the comparison.\n+     * @param rhs The right hand side of the comparison.\n+     * @throws RuntimeException if the assertion is not true.\n+     * @see #assertNotEqualsByteArray(byte[], byte[], String)\n+     *\/\n+    public static void assertNotEqualsByteArray(byte[] lhs, byte[] rhs) {\n+        assertNotEqualsByteArray(lhs, rhs, null);\n+    }\n+\n+    \/**\n+     * Asserts that {@code lhs} is the same byte array as {@code rhs}.\n+     *\n+     * @param lhs The left hand side of the comparison.\n+     * @param rhs The right hand side of the comparison.\n+     * @param msg A description of the assumption; {@code null} for a default message.\n+     * @throws RuntimeException if the assertion is not true.\n+     *\/\n+    public static void assertEqualsByteArray(byte[] lhs, byte[] rhs, String msg) {\n+        if (!Arrays.equals(lhs, rhs)) {\n+            msg = Objects.toString(msg, \"assertEqualsByteArray\")\n+                    + \": expected \" + HexFormat.of().formatHex(lhs)\n+                    + \" to equal \" + HexFormat.of().formatHex(rhs);\n+            fail(msg);\n+        }\n+    }\n+\n+    \/**\n+     * Asserts that {@code lhs} is not the same byte array as {@code rhs}.\n+     *\n+     * @param lhs The left hand side of the comparison.\n+     * @param rhs The right hand side of the comparison.\n+     * @param msg A description of the assumption; {@code null} for a default message.\n+     * @throws RuntimeException if the assertion is not true.\n+     *\/\n+    public static void assertNotEqualsByteArray(byte[] lhs, byte[] rhs, String msg) {\n+        if (Arrays.equals(lhs, rhs)) {\n+            msg = Objects.toString(msg, \"assertNotEqualsByteArray\")\n+                    + \": expected \" + HexFormat.of().formatHex(lhs)\n+                    + \" to not equal \" + HexFormat.of().formatHex(rhs);\n+            fail(msg);\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/Asserts.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib;\n+\n+import java.util.ArrayList;\n+\n+public class StringArrayUtils {\n+    \/**\n+     * The various concat() functions in this class can be used for building\n+     * a command-line argument array for ProcessTools.createTestJavaProcessBuilder(),\n+     * etc. When some of the arguments are conditional, this is more convenient\n+     * than alternatives like ArrayList.\n+     *\n+     * Example:\n+     *\n+     * <pre>\n+     *     String args[] = StringArrayUtils.concat(\"-Xint\", \"-Xmx32m\");\n+     *     if (verbose) {\n+     *         args = StringArrayUtils.concat(args, \"-verbose\");\n+     *     }\n+     *     args = StringArrayUtils.concat(args, \"HelloWorld\");\n+     *     ProcessTools.createTestJavaProcessBuilder(args);\n+     * <\/pre>\n+     *\/\n+    public static String[] concat(String... args) {\n+        return args;\n+    }\n+\n+    public static String[] concat(String[] prefix, String... extra) {\n+        String[] ret = new String[prefix.length + extra.length];\n+        System.arraycopy(prefix, 0, ret, 0, prefix.length);\n+        System.arraycopy(extra, 0, ret, prefix.length, extra.length);\n+        return ret;\n+    }\n+\n+    public static String[] concat(String prefix, String[] extra) {\n+        String[] ret = new String[1 + extra.length];\n+        ret[0] = prefix;\n+        System.arraycopy(extra, 0, ret, 1, extra.length);\n+        return ret;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/StringArrayUtils.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.cds;\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.StringArrayUtils;\n+\n+\/*\n+ * This is a base class used for testing CDS functionalities with complex applications.\n+ * You can define the application by overridding the vmArgs(), classpath() and appCommandLine()\n+ * methods. Application-specific validation checks can be implemented with checkExecution().\n+*\/\n+abstract public class CDSAppTester {\n+    private final String name;\n+    private final String classListFile;\n+    private final String classListFileLog;\n+    private final String staticArchiveFile;\n+    private final String staticArchiveFileLog;\n+    private final String dynamicArchiveFile;\n+    private final String dynamicArchiveFileLog;\n+    private final String productionRunLog;\n+\n+    public CDSAppTester(String name) {\n+        \/\/ Old workflow\n+        this.name = name;\n+        classListFile = name() + \".classlist\";\n+        classListFileLog = classListFile + \".log\";\n+        staticArchiveFile = name() + \".static.jsa\";\n+        staticArchiveFileLog = staticArchiveFile + \".log\";\n+        dynamicArchiveFile = name() + \".dynamic.jsa\";\n+        dynamicArchiveFileLog = dynamicArchiveFile + \".log\";\n+        productionRunLog = name() + \".production.log\";\n+    }\n+\n+    private enum Workflow {\n+        STATIC,        \/\/ classic -Xshare:dump workflow\n+        DYNAMIC,       \/\/ classic -XX:ArchiveClassesAtExit\n+    }\n+\n+    public enum RunMode {\n+        CLASSLIST,\n+        DUMP_STATIC,\n+        DUMP_DYNAMIC,\n+        PRODUCTION;\n+\n+        public boolean isStaticDump() {\n+            return this == DUMP_STATIC;\n+        }\n+        public boolean isProductionRun() {\n+            return this == PRODUCTION;\n+        }\n+    }\n+\n+    public final String name() {\n+        return this.name;\n+    }\n+\n+    \/\/ optional\n+    public String[] vmArgs(RunMode runMode) {\n+        return new String[0];\n+    }\n+\n+    \/\/ optional\n+    public String classpath(RunMode runMode) {\n+        return null;\n+    }\n+\n+    \/\/ must override\n+    \/\/ main class, followed by arguments to the main class\n+    abstract public String[] appCommandLine(RunMode runMode);\n+\n+    \/\/ optional\n+    public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {}\n+\n+    private Workflow workflow;\n+\n+    public final boolean isStaticWorkflow() {\n+        return workflow == Workflow.STATIC;\n+    }\n+\n+    public final boolean isDynamicWorkflow() {\n+        return workflow == Workflow.DYNAMIC;\n+    }\n+\n+    private String logToFile(String logFile, String... logTags) {\n+        StringBuilder sb = new StringBuilder(\"-Xlog:\");\n+        String prefix = \"\";\n+        for (String tag : logTags) {\n+            sb.append(prefix);\n+            sb.append(tag);\n+            prefix = \",\";\n+        }\n+        sb.append(\":file=\" + logFile + \"::filesize=0\");\n+        return sb.toString();\n+    }\n+\n+    private void listOutputFile(String file) {\n+        File f = new File(file);\n+        if (f.exists()) {\n+            System.out.println(\"[output file: \" + file + \" \" + f.length() + \" bytes]\");\n+        } else {\n+            System.out.println(\"[output file: \" + file + \" does not exist]\");\n+        }\n+    }\n+\n+    private OutputAnalyzer executeAndCheck(String[] cmdLine, RunMode runMode, String... logFiles) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        Process process = pb.start();\n+        OutputAnalyzer output = CDSTestUtils.executeAndLog(process, runMode.toString());\n+        for (String logFile : logFiles) {\n+            listOutputFile(logFile);\n+        }\n+        output.shouldHaveExitValue(0);\n+        CDSTestUtils.checkCommonExecExceptions(output);\n+        checkExecution(output, runMode);\n+        return output;\n+    }\n+\n+    private OutputAnalyzer createClassList() throws Exception {\n+        RunMode runMode = RunMode.CLASSLIST;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                                   \"-Xshare:off\",\n+                                                   \"-XX:DumpLoadedClassList=\" + classListFile,\n+                                                   \"-cp\", classpath(runMode),\n+                                                   logToFile(classListFileLog,\n+                                                             \"class+load=debug\"));\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+        return executeAndCheck(cmdLine, runMode, classListFile, classListFileLog);\n+    }\n+\n+    private OutputAnalyzer dumpStaticArchive() throws Exception {\n+        RunMode runMode = RunMode.DUMP_STATIC;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                                   \"-Xlog:cds\",\n+                                                   \"-Xlog:cds+heap=error\",\n+                                                   \"-Xshare:dump\",\n+                                                   \"-XX:SharedArchiveFile=\" + staticArchiveFile,\n+                                                   \"-XX:SharedClassListFile=\" + classListFile,\n+                                                   \"-cp\", classpath(runMode),\n+                                                   logToFile(staticArchiveFileLog,\n+                                                             \"cds=debug\",\n+                                                             \"cds+class=debug\",\n+                                                             \"cds+heap=warning\",\n+                                                             \"cds+resolve=debug\"));\n+        return executeAndCheck(cmdLine, runMode, staticArchiveFile, staticArchiveFileLog);\n+    }\n+\n+    private OutputAnalyzer dumpDynamicArchive() throws Exception {\n+        RunMode runMode = RunMode.DUMP_DYNAMIC;\n+        String[] cmdLine = new String[0];\n+        if (isDynamicWorkflow()) {\n+          \/\/ \"classic\" dynamic archive\n+          cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                            \"-Xlog:cds\",\n+                                            \"-XX:ArchiveClassesAtExit=\" + dynamicArchiveFile,\n+                                            \"-cp\", classpath(runMode),\n+                                            logToFile(dynamicArchiveFileLog,\n+                                                      \"cds=debug\",\n+                                                      \"cds+class=debug\",\n+                                                      \"cds+resolve=debug\",\n+                                                      \"class+load=debug\"));\n+        }\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+        return executeAndCheck(cmdLine, runMode, dynamicArchiveFile, dynamicArchiveFileLog);\n+    }\n+\n+    private OutputAnalyzer productionRun() throws Exception {\n+        RunMode runMode = RunMode.PRODUCTION;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode),\n+                                                   \"-cp\", classpath(runMode),\n+                                                   logToFile(productionRunLog, \"cds\"));\n+\n+        if (isStaticWorkflow()) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"-XX:SharedArchiveFile=\" + staticArchiveFile);\n+        } else if (isDynamicWorkflow()) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"-XX:SharedArchiveFile=\" + dynamicArchiveFile);\n+        }\n+\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+        return executeAndCheck(cmdLine, runMode, productionRunLog);\n+    }\n+\n+    public void run(String args[]) throws Exception {\n+        String err = \"Must have exactly one command line argument of the following: \";\n+        String prefix = \"\";\n+        for (Workflow wf : Workflow.values()) {\n+            err += prefix;\n+            err += wf;\n+            prefix = \", \";\n+        }\n+        if (args.length != 1) {\n+            throw new RuntimeException(err);\n+        } else {\n+            if (args[0].equals(\"STATIC\")) {\n+                runStaticWorkflow();\n+            } else if (args[0].equals(\"DYNAMIC\")) {\n+                runDynamicWorkflow();\n+            } else {\n+                throw new RuntimeException(err);\n+            }\n+        }\n+    }\n+\n+    private void runStaticWorkflow() throws Exception {\n+        this.workflow = Workflow.STATIC;\n+        createClassList();\n+        dumpStaticArchive();\n+        productionRun();\n+    }\n+\n+    private void runDynamicWorkflow() throws Exception {\n+        this.workflow = Workflow.DYNAMIC;\n+        dumpDynamicArchive();\n+        productionRun();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.security;\n+\n+import java.security.SecureRandom;\n+import java.util.Random;\n+\n+\/**\n+ * A deterministic SecureRandom with a seed.\n+ * <p>\n+ * Users can provide the seed with the system property \"secure.random.seed\".\n+ * Otherwise, it's a random value. Usually, a test runs without this system\n+ * property and the random seed is printed out. When it fails, set the\n+ * system property to this recorded seed to reproduce the failure.\n+ *\/\n+public class SeededSecureRandom extends SecureRandom {\n+\n+    private final Random rnd;\n+\n+    public static long seed() {\n+        String value = System.getProperty(\"secure.random.seed\");\n+        long seed = value != null\n+                ? Long.parseLong(value)\n+                : new Random().nextLong();\n+        System.out.println(\"SeededSecureRandom: seed = \" + seed);\n+        return seed;\n+    }\n+\n+    public SeededSecureRandom(long seed) {\n+        rnd = new Random(seed);\n+    }\n+\n+    public static SeededSecureRandom one() {\n+        return new SeededSecureRandom(seed());\n+    }\n+\n+    @Override\n+    public void nextBytes(byte[] bytes) {\n+        rnd.nextBytes(bytes);\n+    }\n+\n+    @Override\n+    public byte[] generateSeed(int numBytes) {\n+        var out = new byte[numBytes];\n+        rnd.nextBytes(out);\n+        return out;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/SeededSecureRandom.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    ONE(\"1000\",\n+    ONE(\"10:00\",\n","filename":"test\/lib\/jdk\/test\/lib\/security\/TestCertificate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-    public static final String CERT_SERIAL = \"edbec8f705af2514\";\n-    public static final String ANCHOR_CERT_SERIAL = \"8e191778b2f331be\";\n+    public static final String CERT_SERIAL = \"00:ed:be:c8:f7:05:af:25:14\";\n+    public static final String ANCHOR_CERT_SERIAL = \"8e:19:17:78:b2:f3:31:be\";\n","filename":"test\/lib\/jdk\/test\/lib\/security\/TestTLSHandshake.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -55,1 +56,0 @@\n-@State(Scope.Thread)\n@@ -66,8 +66,0 @@\n-    Provider p;\n-    static byte[] pk;\n-    static byte[] msg;\n-    static byte[] sig;\n-    static Signature v;\n-\n-    @Param({\"noop\"})\n-    private String test;\n@@ -81,9 +73,1 @@\n-    @Setup\n-    public void setup() throws Exception {\n-        p = Security.getProvider(\"SUN\");\n-        if (p == null) {\n-            throw new Exception (\"Can't load \\\"Sun\\\" provider\");\n-        }\n-    }\n-\n-    public Signature getVerifier(byte[] pk) throws Exception {\n+    public static Signature getVerifier(byte[] pk) throws Exception {\n@@ -98,5 +82,2 @@\n-    @Benchmark\n-    public void verify() throws Exception {\n-        if (v == null) {\n-            return;\n-        }\n+    public static void verify(Signature v, byte[] pk, byte[] msg, byte[] sig)\n+            throws Exception {\n@@ -110,1 +91,5 @@\n-    public static class test01 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test01 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -223,2 +208,0 @@\n-\n-            v = getVerifier(pk);\n@@ -229,1 +212,5 @@\n-    public static class test02 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test02 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -379,2 +366,0 @@\n-\n-            v = getVerifier(pk);\n@@ -385,1 +370,5 @@\n-    public static class test03 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test03 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -488,2 +477,0 @@\n-\n-            v = getVerifier(pk);\n@@ -494,1 +481,5 @@\n-    public static class test04 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test04 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -602,2 +593,0 @@\n-\n-            v = getVerifier(pk);\n@@ -608,1 +597,5 @@\n-    public static class test05 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test05 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -744,2 +737,0 @@\n-\n-            v = getVerifier(pk);\n@@ -750,1 +741,5 @@\n-    public static class test06 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test06 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -891,2 +886,0 @@\n-\n-            v = getVerifier(pk);\n@@ -898,1 +891,5 @@\n-    public static class test07 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test07 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -1119,2 +1116,0 @@\n-\n-            v = getVerifier(pk);\n@@ -1126,1 +1121,5 @@\n-    public static class test08 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test08 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -1352,2 +1351,0 @@\n-\n-            v = getVerifier(pk);\n@@ -1359,1 +1356,5 @@\n-    public static class test09 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test09 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -1585,2 +1586,0 @@\n-\n-            v = getVerifier(pk);\n@@ -1592,1 +1591,5 @@\n-    public static class test10 extends HSS {\n+    @State(Scope.Benchmark)\n+    public static class test10 {\n+        byte[] pk;\n+        byte[] msg;\n+        byte[] sig;\n@@ -1823,0 +1826,51 @@\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class verifier01 {\n+        Signature v;\n+\n+        @Setup\n+        public void setup(test01 test) throws Exception {\n+            v = getVerifier(test.pk);\n+        }\n+    }\n+    @State(Scope.Thread)\n+    public static class verifier02 {\n+        Signature v;\n+\n+        @Setup\n+        public void setup(test02 test) throws Exception {\n+            v = getVerifier(test.pk);\n+        }\n+    }\n+    @State(Scope.Thread)\n+    public static class verifier03 {\n+        Signature v;\n+\n+        @Setup\n+        public void setup(test03 test) throws Exception {\n+            v = getVerifier(test.pk);\n+        }\n+    }\n+    @State(Scope.Thread)\n+    public static class verifier04 {\n+        Signature v;\n+\n+        @Setup\n+        public void setup(test04 test) throws Exception {\n+            v = getVerifier(test.pk);\n+        }\n+    }\n+    @State(Scope.Thread)\n+    public static class verifier05 {\n+        Signature v;\n+\n+        @Setup\n+        public void setup(test05 test) throws Exception {\n+            v = getVerifier(test.pk);\n+        }\n+    }\n+    @State(Scope.Thread)\n+    public static class verifier06 {\n+        Signature v;\n@@ -1824,1 +1878,12 @@\n-            v = getVerifier(pk);\n+        @Setup\n+        public void setup(test06 test) throws Exception {\n+            v = getVerifier(test.pk);\n+        }\n+    }\n+    @State(Scope.Thread)\n+    public static class verifier07 {\n+        Signature v;\n+\n+        @Setup\n+        public void setup(test07 test) throws Exception {\n+            v = getVerifier(test.pk);\n@@ -1827,0 +1892,68 @@\n+    @State(Scope.Thread)\n+    public static class verifier08 {\n+        Signature v;\n+\n+        @Setup\n+        public void setup(test08 test) throws Exception {\n+            v = getVerifier(test.pk);\n+        }\n+    }\n+    @State(Scope.Thread)\n+    public static class verifier09 {\n+        Signature v;\n+\n+        @Setup\n+        public void setup(test09 test) throws Exception {\n+            v = getVerifier(test.pk);\n+        }\n+    }\n+    @State(Scope.Thread)\n+    public static class verifier10 {\n+        Signature v;\n+\n+        @Setup\n+        public void setup(test10 test) throws Exception {\n+            v = getVerifier(test.pk);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void verify01(test01 test, verifier01 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n+    @Benchmark\n+    public void verify02(test02 test, verifier02 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n+    @Benchmark\n+    public void verify03(test03 test, verifier03 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n+    @Benchmark\n+    public void verify04(test04 test, verifier04 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n+    @Benchmark\n+    public void verify05(test05 test, verifier05 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n+    @Benchmark\n+    public void verify06(test06 test, verifier06 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n+    @Benchmark\n+    public void verify07(test07 test, verifier07 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n+    @Benchmark\n+    public void verify08(test08 test, verifier08 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n+    @Benchmark\n+    public void verify09(test09 test, verifier09 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n+    @Benchmark\n+    public void verify10(test10 test, verifier10 v) throws Exception {\n+        HSS.verify(v.v, test.pk, test.msg, test.sig);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/HSS.java","additions":186,"deletions":53,"binary":false,"changes":239,"status":"modified"}]}