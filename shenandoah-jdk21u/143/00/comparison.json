{"files":[{"patch":"@@ -96,2 +96,2 @@\n-  size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n-  size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+  size_t free_target = (capacity \/ 100 * ShenandoahMinFreeThreshold) + max_cset;\n+  size_t min_garbage = (free_target > actual_free ? (free_target - actual_free) : 0);\n@@ -145,2 +145,1 @@\n-    log_debug(gc, ergo)(\"%s Available: \" SIZE_FORMAT \" %sB, z-score=%.3f. Average available: %.1f %sB +\/- %.1f %sB.\",\n-                        _space_info->name(),\n+    log_debug(gc, ergo)(\"Available: \" SIZE_FORMAT \" %sB, z-score=%.3f. Average available: %.1f %sB +\/- %.1f %sB.\",\n@@ -241,3 +240,2 @@\n-  log_debug(gc)(\"should_start_gc (%s)? available: \" SIZE_FORMAT \", soft_max_capacity: \" SIZE_FORMAT\n-                \", allocated: \" SIZE_FORMAT,\n-                _space_info->name(), available, capacity, allocated);\n+  log_debug(gc)(\"should_start_gc? available: \" SIZE_FORMAT \", soft_max_capacity: \" SIZE_FORMAT\n+                \", allocated: \" SIZE_FORMAT, available, capacity, allocated);\n@@ -251,1 +249,1 @@\n-    log_info(gc)(\"Trigger (%s): Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\", _space_info->name(),\n+    log_trigger(\"Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n@@ -262,2 +260,2 @@\n-      log_info(gc)(\"Trigger (%s): Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n-                   _space_info->name(), _gc_times_learned + 1, max_learn,\n+      log_trigger(\"Learning \" SIZE_FORMAT \" of \" SIZE_FORMAT \". Free (\" SIZE_FORMAT \"%s) is below initial threshold (\" SIZE_FORMAT \"%s)\",\n+                   _gc_times_learned + 1, max_learn,\n@@ -282,2 +280,1 @@\n-  log_debug(gc)(\"%s: average GC time: %.2f ms, allocation rate: %.0f %s\/s\",\n-                _space_info->name(),\n+  log_debug(gc)(\"average GC time: %.2f ms, allocation rate: %.0f %s\/s\",\n@@ -286,1 +283,1 @@\n-    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s)\"\n+    log_trigger(\"Average GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s)\"\n@@ -288,1 +285,1 @@\n-                 _space_info->name(), avg_cycle_time * 1000,\n+                 avg_cycle_time * 1000,\n@@ -303,2 +300,2 @@\n-    log_info(gc)(\"Trigger (%s): Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n-                 _space_info->name(), avg_cycle_time * 1000,\n+    log_trigger(\"Average GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s) to deplete free headroom (\" SIZE_FORMAT \"%s) (spike threshold = %.2f)\",\n+                 avg_cycle_time * 1000,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  log_info(gc)(\"Trigger: Start next cycle immediately\");\n+  log_trigger(\"Start next cycle immediately\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,3 +61,3 @@\n-    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n-                 byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n-                 byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n+    log_trigger(\"Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+                byte_size_in_proper_unit(available),     proper_unit_for_byte_size(available),\n+                byte_size_in_proper_unit(min_threshold), proper_unit_for_byte_size(min_threshold));\n@@ -69,3 +69,3 @@\n-    log_info(gc)(\"Trigger: Allocated since last cycle (\" SIZE_FORMAT \"%s) is larger than allocation threshold (\" SIZE_FORMAT \"%s)\",\n-                 byte_size_in_proper_unit(bytes_allocated),           proper_unit_for_byte_size(bytes_allocated),\n-                 byte_size_in_proper_unit(threshold_bytes_allocated), proper_unit_for_byte_size(threshold_bytes_allocated));\n+    log_trigger(\"Allocated since last cycle (\" SIZE_FORMAT \"%s) is larger than allocation threshold (\" SIZE_FORMAT \"%s)\",\n+                byte_size_in_proper_unit(bytes_allocated),           proper_unit_for_byte_size(bytes_allocated),\n+                byte_size_in_proper_unit(threshold_bytes_allocated), proper_unit_for_byte_size(threshold_bytes_allocated));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-#ifdef ASSERT\n@@ -67,1 +66,0 @@\n-#endif\n@@ -192,1 +190,1 @@\n-    log_info(gc)(\"Trigger: %s\", GCCause::to_string(GCCause::_metadata_GC_threshold));\n+    log_trigger(\"%s\", GCCause::to_string(GCCause::_metadata_GC_threshold));\n@@ -199,2 +197,2 @@\n-      log_info(gc)(\"Trigger (%s): Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n-                   _space_info->name(), last_time_ms, _guaranteed_gc_interval);\n+      log_trigger(\"Time since last GC (%.0f ms) is larger than guaranteed interval (\" UINTX_FORMAT \" ms)\",\n+                   last_time_ms, _guaranteed_gc_interval);\n@@ -229,0 +227,18 @@\n+void ShenandoahHeuristics::log_trigger(const char* fmt, ...) {\n+  LogTarget(Info, gc) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print_raw(\"Trigger\", 7);\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      ls.print(\" (%s)\", _space_info->name());\n+    }\n+    ls.print_raw(\": \", 2);\n+    va_list va;\n+    va_start(va, fmt);\n+    ls.vprint(fmt, va);\n+    va_end(va);\n+    ls.cr();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-#ifdef ASSERT\n@@ -95,0 +94,3 @@\n+      _region = nullptr;\n+      _region_union._garbage = 0;\n+#ifdef ASSERT\n@@ -96,1 +98,0 @@\n-    }\n@@ -98,0 +99,1 @@\n+    }\n@@ -116,3 +118,1 @@\n-#ifdef ASSERT\n-      assert(_union_tag != is_uninitialized, \"Cannot fetch region from uninialized RegionData\");\n-#endif\n+      assert(_union_tag != is_uninitialized, \"Cannot fetch region from uninitialized RegionData\");\n@@ -123,1 +123,0 @@\n-#ifdef ASSERT\n@@ -125,1 +124,0 @@\n-#endif\n@@ -130,1 +128,0 @@\n-#ifdef ASSERT\n@@ -132,1 +129,0 @@\n-#endif\n@@ -218,0 +214,3 @@\n+\n+  \/\/ Format prefix and emit log message indicating a GC cycle hs been triggered\n+  void log_trigger(const char* fmt, ...) ATTRIBUTE_PRINTF(2, 3);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-    log_debug(gc)(\"Remaining \" UINT32_FORMAT \" old regions are being coalesced and filled\", unprocessed_old_collection_candidates());\n+    log_info(gc, ergo)(\"Remaining \" UINT32_FORMAT \" old regions are being coalesced and filled\", unprocessed_old_collection_candidates());\n@@ -126,3 +126,3 @@\n-  log_info(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s, candidates: %u\",\n-               byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget),\n-               unprocessed_old_collection_candidates());\n+  log_debug(gc)(\"Choose old regions for mixed collection: old evacuation budget: \" SIZE_FORMAT \"%s, candidates: %u\",\n+                byte_size_in_proper_unit(old_evacuation_budget), proper_unit_for_byte_size(old_evacuation_budget),\n+                unprocessed_old_collection_candidates());\n@@ -213,4 +213,2 @@\n-    log_info(gc)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, evacuating \" SIZE_FORMAT \"%s, reclaiming: \" SIZE_FORMAT \"%s)\",\n-                 included_old_regions,\n-                 byte_size_in_proper_unit(evacuated_old_bytes), proper_unit_for_byte_size(evacuated_old_bytes),\n-                 byte_size_in_proper_unit(collected_old_bytes), proper_unit_for_byte_size(collected_old_bytes));\n+    log_info(gc, ergo)(\"Old-gen piggyback evac (\" UINT32_FORMAT \" regions, evacuating \" PROPERFMT \", reclaiming: \" PROPERFMT \")\",\n+                  included_old_regions, PROPERFMTARGS(evacuated_old_bytes), PROPERFMTARGS(collected_old_bytes));\n@@ -232,1 +230,1 @@\n-      log_info(gc)(\"All candidate regions \" UINT32_FORMAT \" are pinned\", unprocessed_old_collection_candidates());\n+      log_info(gc, ergo)(\"All candidate regions \" UINT32_FORMAT \" are pinned\", unprocessed_old_collection_candidates());\n@@ -235,8 +233,8 @@\n-      log_info(gc)(\"No regions selected for mixed collection. \"\n-                   \"Old evacuation budget: \" PROPERFMT \", Remaining evacuation budget: \" PROPERFMT\n-                   \", Lost capacity: \" PROPERFMT\n-                   \", Next candidate: \" UINT32_FORMAT \", Last candidate: \" UINT32_FORMAT,\n-                   PROPERFMTARGS(old_evacuation_reserve),\n-                   PROPERFMTARGS(remaining_old_evacuation_budget),\n-                   PROPERFMTARGS(lost_evacuation_capacity),\n-                   _next_old_collection_candidate, _last_old_collection_candidate);\n+      log_info(gc, ergo)(\"No regions selected for mixed collection. \"\n+                         \"Old evacuation budget: \" PROPERFMT \", Remaining evacuation budget: \" PROPERFMT\n+                         \", Lost capacity: \" PROPERFMT\n+                         \", Next candidate: \" UINT32_FORMAT \", Last candidate: \" UINT32_FORMAT,\n+                         PROPERFMTARGS(old_evacuation_reserve),\n+                         PROPERFMTARGS(remaining_old_evacuation_budget),\n+                         PROPERFMTARGS(lost_evacuation_capacity),\n+                         _next_old_collection_candidate, _last_old_collection_candidate);\n@@ -472,6 +470,6 @@\n-  log_info(gc)(\"Old-Gen Collectable Garbage: \" PROPERFMT \" consolidated with free: \" PROPERFMT \", over \" SIZE_FORMAT \" regions\",\n-               PROPERFMTARGS(collectable_garbage), PROPERFMTARGS(unfragmented), old_candidates);\n-  log_info(gc)(\"Old-Gen Immediate Garbage: \" PROPERFMT \" over \" SIZE_FORMAT \" regions\",\n-              PROPERFMTARGS(immediate_garbage), immediate_regions);\n-  log_info(gc)(\"Old regions selected for defragmentation: \" SIZE_FORMAT, defrag_count);\n-  log_info(gc)(\"Old regions not selected: \" SIZE_FORMAT, total_uncollected_old_regions);\n+  log_info(gc, ergo)(\"Old-Gen Collectable Garbage: \" PROPERFMT \" consolidated with free: \" PROPERFMT \", over \" SIZE_FORMAT \" regions\",\n+                     PROPERFMTARGS(collectable_garbage), PROPERFMTARGS(unfragmented), old_candidates);\n+  log_info(gc, ergo)(\"Old-Gen Immediate Garbage: \" PROPERFMT \" over \" SIZE_FORMAT \" regions\",\n+                     PROPERFMTARGS(immediate_garbage), immediate_regions);\n+  log_info(gc, ergo)(\"Old regions selected for defragmentation: \" SIZE_FORMAT, defrag_count);\n+  log_info(gc, ergo)(\"Old regions not selected: \" SIZE_FORMAT, total_uncollected_old_regions);\n@@ -641,1 +639,1 @@\n-    log_info(gc)(\"Trigger (OLD): Expansion failure, current size: \" SIZE_FORMAT \"%s which is %.1f%% of total heap size\",\n+    log_trigger(\"Expansion failure, current size: \" SIZE_FORMAT \"%s which is %.1f%% of total heap size\",\n@@ -660,5 +658,5 @@\n-    log_info(gc)(\"Trigger (OLD): Old has become fragmented: \"\n-                 SIZE_FORMAT \"%s available bytes spread between range spanned from \"\n-                 SIZE_FORMAT \" to \" SIZE_FORMAT \" (\" SIZE_FORMAT \"), density: %.1f%%\",\n-                 byte_size_in_proper_unit(fragmented_free), proper_unit_for_byte_size(fragmented_free),\n-                 first_old_region, last_old_region, span_of_old_regions, density * 100);\n+    log_trigger(\"Old has become fragmented: \"\n+                SIZE_FORMAT \"%s available bytes spread between range spanned from \"\n+                SIZE_FORMAT \" to \" SIZE_FORMAT \" (\" SIZE_FORMAT \"), density: %.1f%%\",\n+                byte_size_in_proper_unit(fragmented_free), proper_unit_for_byte_size(fragmented_free),\n+                first_old_region, last_old_region, span_of_old_regions, density * 100);\n@@ -679,1 +677,1 @@\n-      log_debug(gc)(\"Ignoring Trigger (OLD): Old has overgrown: usage (\" SIZE_FORMAT \"%s) is below threshold (\"\n+      log_debug(gc)(\"Ignoring Trigger: Old has overgrown: usage (\" SIZE_FORMAT \"%s) is below threshold (\"\n@@ -688,4 +686,4 @@\n-      log_info(gc)(\"Trigger (OLD): Old has overgrown, live at end of previous OLD marking: \"\n-                   SIZE_FORMAT \"%s, current usage: \" SIZE_FORMAT \"%s, percent growth: %.1f%%\",\n-                   byte_size_in_proper_unit(live_at_previous_old), proper_unit_for_byte_size(live_at_previous_old),\n-                   byte_size_in_proper_unit(current_usage), proper_unit_for_byte_size(current_usage), percent_growth);\n+      log_trigger(\"Old has overgrown, live at end of previous OLD marking: \"\n+                  SIZE_FORMAT \"%s, current usage: \" SIZE_FORMAT \"%s, percent growth: %.1f%%\",\n+                  byte_size_in_proper_unit(live_at_previous_old), proper_unit_for_byte_size(live_at_previous_old),\n+                  byte_size_in_proper_unit(current_usage), proper_unit_for_byte_size(current_usage), percent_growth);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":32,"deletions":34,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    log_info(gc)(\"Trigger: Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n+    log_trigger(\"Free (\" SIZE_FORMAT \"%s) is below minimum threshold (\" SIZE_FORMAT \"%s)\",\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,4 +143,1 @@\n-    log_info(gc)(\"Trigger (%s): expedite promotion of \" SIZE_FORMAT \"%s\",\n-                 _space_info->name(),\n-                 byte_size_in_proper_unit(promo_potential),\n-                 proper_unit_for_byte_size(promo_potential));\n+    log_trigger(\"Expedite promotion of \" PROPERFMT, PROPERFMTARGS(promo_potential));\n@@ -156,2 +153,1 @@\n-    log_info(gc)(\"Trigger (%s): expedite mixed evacuation of \" SIZE_FORMAT \" regions\",\n-                 _space_info->name(), mixed_candidates);\n+    log_trigger(\"Expedite mixed evacuation of \" SIZE_FORMAT \" regions\", mixed_candidates);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -238,1 +238,1 @@\n-#define shenandoah_assert_generations_reconciled()                                                             \\\n+#define shenandoah_assert_generations_reconciled()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -426,5 +426,1 @@\n-    return;\n-  }\n-  int gc_state = _heap->gc_state();\n-  if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n-    arraycopy_marking(src, dst, count, false);\n+    \/\/ No elements to copy, no need for barrier\n@@ -434,0 +430,1 @@\n+  int gc_state = _heap->gc_state();\n@@ -442,0 +439,3 @@\n+    if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n+      arraycopy_marking(src, dst, count, false);\n+    }\n@@ -443,3 +443,0 @@\n-      \/\/ Note that we can't do the arraycopy marking using the 'src' array when\n-      \/\/ SATB mode is enabled (so we can't do this as part of the iteration for\n-      \/\/ evacuation or update references).\n@@ -448,0 +445,2 @@\n+  } else if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n+    arraycopy_marking(src, dst, count, false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,9 +32,9 @@\n-  DIRTY_RUN           = 0,\n-  CLEAN_RUN           = 1,\n-  DIRTY_CARDS         = 2,\n-  CLEAN_CARDS         = 3,\n-  MAX_DIRTY_RUN       = 4,\n-  MAX_CLEAN_RUN       = 5,\n-  DIRTY_SCAN_OBJS     = 6,\n-  ALTERNATIONS        = 7,\n-  MAX_CARD_STAT_TYPE  = 8\n+  DIRTY_RUN,\n+  CLEAN_RUN,\n+  DIRTY_CARDS,\n+  CLEAN_CARDS,\n+  MAX_DIRTY_RUN,\n+  MAX_CLEAN_RUN,\n+  DIRTY_SCAN_OBJS,\n+  ALTERNATIONS,\n+  MAX_CARD_STAT_TYPE\n@@ -44,3 +44,3 @@\n-  CARD_STAT_SCAN_RS       = 0,\n-  CARD_STAT_UPDATE_REFS   = 1,\n-  MAX_CARD_STAT_LOG_TYPE  = 2\n+  CARD_STAT_SCAN_RS,\n+  CARD_STAT_UPDATE_REFS,\n+  MAX_CARD_STAT_LOG_TYPE\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardStats.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -33,0 +34,2 @@\n+  ResourceMark _rm;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSetPreselector.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+  _generation(generation),\n@@ -98,2 +99,1 @@\n-  _do_old_gc_bootstrap(do_old_gc_bootstrap),\n-  _generation(generation) {\n+  _do_old_gc_bootstrap(do_old_gc_bootstrap) {\n@@ -377,1 +377,1 @@\n-    static const char* msg = \"Concurrent reset (OLD)\";\n+    static const char* msg = \"Concurrent reset (Old)\";\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  ShenandoahGeneration* const _generation;\n@@ -56,3 +57,0 @@\n-protected:\n-  ShenandoahGeneration* const _generation;\n-\n@@ -67,1 +65,1 @@\n-private:\n+protected:\n@@ -71,2 +69,0 @@\n-\n-protected:\n@@ -74,3 +70,0 @@\n-  void vmop_entry_final_roots();\n-\n-private:\n@@ -79,0 +72,1 @@\n+  void vmop_entry_final_roots();\n@@ -93,2 +87,0 @@\n-\n-protected:\n@@ -102,2 +94,0 @@\n-\n-private:\n@@ -107,1 +97,0 @@\n-\n@@ -118,0 +107,1 @@\n+  virtual void op_final_mark();\n@@ -130,1 +120,0 @@\n-\n@@ -133,2 +122,2 @@\n-protected:\n-  virtual void op_final_mark();\n+  \/\/ Check GC cancellation and abort concurrent GC\n+  bool check_cancellation_and_abort(ShenandoahDegenPoint point);\n@@ -151,4 +140,0 @@\n-\n-protected:\n-  \/\/ Check GC cancellation and abort concurrent GC\n-  bool check_cancellation_and_abort(ShenandoahDegenPoint point);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    ShenandoahParallelWorkerSession worker_session(worker_id);\n+    ShenandoahConcurrentWorkerSession worker_session(worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-      log_info(gc)(\"Trigger: Handle Allocation Failure\");\n+      heuristics->log_trigger(\"Handle Allocation Failure\");\n@@ -108,1 +108,1 @@\n-      log_info(gc)(\"Trigger: GC request (%s)\", GCCause::to_string(cause));\n+      heuristics->log_trigger(\"GC request (%s)\", GCCause::to_string(cause));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-    _use_age_table(ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring) {\n+    _use_age_table(ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring),\n+    _age_table(nullptr) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n@@ -35,1 +34,0 @@\n-#include \"gc\/shenandoah\/shenandoahScanRemembered.inline.hpp\"\n@@ -55,0 +53,62 @@\n+class ShenandoahLeftRightIterator {\n+private:\n+  idx_t _idx;\n+  idx_t _end;\n+  ShenandoahRegionPartitions* _partitions;\n+  ShenandoahFreeSetPartitionId _partition;\n+public:\n+  explicit ShenandoahLeftRightIterator(ShenandoahRegionPartitions* partitions, ShenandoahFreeSetPartitionId partition, bool use_empty = false)\n+    : _idx(0), _end(0), _partitions(partitions), _partition(partition) {\n+    _idx = use_empty ? _partitions->leftmost_empty(_partition) : _partitions->leftmost(_partition);\n+    _end = use_empty ? _partitions->rightmost_empty(_partition) : _partitions->rightmost(_partition);\n+  }\n+\n+  bool has_next() const {\n+    if (_idx <= _end) {\n+      assert(_partitions->in_free_set(_partition, _idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, _idx);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  idx_t current() const {\n+    return _idx;\n+  }\n+\n+  idx_t next() {\n+    _idx = _partitions->find_index_of_next_available_region(_partition, _idx + 1);\n+    return current();\n+  }\n+};\n+\n+class ShenandoahRightLeftIterator {\n+private:\n+  idx_t _idx;\n+  idx_t _end;\n+  ShenandoahRegionPartitions* _partitions;\n+  ShenandoahFreeSetPartitionId _partition;\n+public:\n+  explicit ShenandoahRightLeftIterator(ShenandoahRegionPartitions* partitions, ShenandoahFreeSetPartitionId partition, bool use_empty = false)\n+    : _idx(0), _end(0), _partitions(partitions), _partition(partition) {\n+    _idx = use_empty ? _partitions->rightmost_empty(_partition) : _partitions->rightmost(_partition);\n+    _end = use_empty ? _partitions->leftmost_empty(_partition) : _partitions->leftmost(_partition);\n+  }\n+\n+  bool has_next() const {\n+    if (_idx >= _end) {\n+      assert(_partitions->in_free_set(_partition, _idx), \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, _idx);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  idx_t current() const {\n+    return _idx;\n+  }\n+\n+  idx_t next() {\n+    _idx = _partitions->find_index_of_previous_available_region(_partition, _idx - 1);\n+    return current();\n+  }\n+};\n+\n@@ -691,2 +751,1 @@\n-HeapWord* ShenandoahFreeSet::allocate_from_partition_with_affiliation(ShenandoahFreeSetPartitionId which_partition,\n-                                                                      ShenandoahAffiliation affiliation,\n+HeapWord* ShenandoahFreeSet::allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n@@ -694,0 +753,1 @@\n+\n@@ -695,4 +755,1 @@\n-  idx_t rightmost_collector = ((affiliation == ShenandoahAffiliation::FREE)?\n-                               _partitions.rightmost_empty(which_partition): _partitions.rightmost(which_partition));\n-  idx_t leftmost_collector = ((affiliation == ShenandoahAffiliation::FREE)?\n-                              _partitions.leftmost_empty(which_partition): _partitions.leftmost(which_partition));\n+  ShenandoahFreeSetPartitionId which_partition = req.is_old()? ShenandoahFreeSetPartitionId::OldCollector: ShenandoahFreeSetPartitionId::Collector;\n@@ -700,11 +757,2 @@\n-    for (idx_t idx = leftmost_collector; idx <= rightmost_collector; ) {\n-      assert(_partitions.in_free_set(which_partition, idx), \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n-      ShenandoahHeapRegion* r = _heap->get_region(idx);\n-      if (r->affiliation() == affiliation) {\n-        HeapWord* result = try_allocate_in(r, req, in_new_region);\n-        if (result != nullptr) {\n-          return result;\n-        }\n-      }\n-      idx = _partitions.find_index_of_next_available_region(which_partition, idx + 1);\n-    }\n+    ShenandoahLeftRightIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n+    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n@@ -712,9 +760,13 @@\n-    for (idx_t idx = rightmost_collector; idx >= leftmost_collector; ) {\n-      assert(_partitions.in_free_set(which_partition, idx),\n-             \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n-      ShenandoahHeapRegion* r = _heap->get_region(idx);\n-      if (r->affiliation() == affiliation) {\n-        HeapWord* result = try_allocate_in(r, req, in_new_region);\n-        if (result != nullptr) {\n-          return result;\n-        }\n+    ShenandoahRightLeftIterator iterator(&_partitions, which_partition, affiliation == ShenandoahAffiliation::FREE);\n+    return allocate_with_affiliation(iterator, affiliation, req, in_new_region);\n+  }\n+}\n+\n+template<typename Iter>\n+HeapWord* ShenandoahFreeSet::allocate_with_affiliation(Iter& iterator, ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region) {\n+  for (idx_t idx = iterator.current(); iterator.has_next(); idx = iterator.next()) {\n+    ShenandoahHeapRegion* r = _heap->get_region(idx);\n+    if (r->affiliation() == affiliation) {\n+      HeapWord* result = try_allocate_in(r, req, in_new_region);\n+      if (result != nullptr) {\n+        return result;\n@@ -722,1 +774,0 @@\n-      idx = _partitions.find_index_of_previous_available_region(which_partition, idx - 1);\n@@ -771,1 +822,5 @@\n-    return allocate_from_left_to_right(req, in_new_region);\n+    \/\/ Allocate from low to high memory.  This keeps the range of fully empty regions more tightly packed.\n+    \/\/ Note that the most recently allocated regions tend not to be evacuated in a given GC cycle.  So this\n+    \/\/ tends to accumulate \"fragmented\" uncollected regions in high memory.\n+    ShenandoahLeftRightIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator);\n+    return allocate_from_regions(iterator, req, in_new_region);\n@@ -774,1 +829,3 @@\n-  return allocate_from_right_to_left(req, in_new_region);\n+  \/\/ Allocate from high to low memory. This preserves low memory for humongous allocations.\n+  ShenandoahRightLeftIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator);\n+  return allocate_from_regions(iterator, req, in_new_region);\n@@ -803,9 +860,3 @@\n-HeapWord* ShenandoahFreeSet::allocate_from_left_to_right(ShenandoahAllocRequest &req, bool &in_new_region) {\n-  \/\/ Allocate from low to high memory.  This keeps the range of fully empty regions more tightly packed.\n-  \/\/ Note that the most recently allocated regions tend not to be evacuated in a given GC cycle.  So this\n-  \/\/ tends to accumulate \"fragmented\" uncollected regions in high memory.\n-  \/\/ Use signed idx.  Otherwise, loop will never terminate.\n-  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); idx <= rightmost;) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n-           \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n+template<typename Iter>\n+HeapWord* ShenandoahFreeSet::allocate_from_regions(Iter& iterator, ShenandoahAllocRequest &req, bool &in_new_region) {\n+  for (idx_t idx = iterator.current(); iterator.has_next(); idx = iterator.next()) {\n@@ -813,2 +864,0 @@\n-\n-    HeapWord* result;\n@@ -816,20 +865,5 @@\n-    if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n-      return result;\n-    }\n-    idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, idx + 1);\n-  }\n-  return nullptr;\n-}\n-\n-HeapWord* ShenandoahFreeSet::allocate_from_right_to_left(ShenandoahAllocRequest &req, bool &in_new_region) {\n-  \/\/ Allocate within mutator free from high memory to low so as to preserve low memory for humongous allocations\n-  \/\/ Use signed idx.  Otherwise, loop will never terminate.\n-  idx_t leftmost = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (idx_t idx = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator); idx >= leftmost;) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n-           \"Boundaries or find_last_set_bit failed: \" SSIZE_FORMAT, idx);\n-    ShenandoahHeapRegion* r = _heap->get_region(idx);\n-    HeapWord* result;\n-    size_t min_size = (req.type() == ShenandoahAllocRequest::_alloc_tlab) ? req.min_size() : req.size();\n-    if ((alloc_capacity(r) >= min_size) && ((result = try_allocate_in(r, req, in_new_region)) != nullptr)) {\n-      return result;\n+    if (alloc_capacity(r) >= min_size) {\n+      HeapWord* result = try_allocate_in(r, req, in_new_region);\n+      if (result != nullptr) {\n+        return result;\n+      }\n@@ -837,1 +871,0 @@\n-    idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n@@ -845,3 +878,1 @@\n-  result = allocate_from_partition_with_affiliation(req.is_old()? ShenandoahFreeSetPartitionId::OldCollector:\n-                                                    ShenandoahFreeSetPartitionId::Collector,\n-                                                    req.affiliation(), req, in_new_region);\n+  result = allocate_from_partition_with_affiliation(req.affiliation(), req, in_new_region);\n@@ -855,3 +886,1 @@\n-    result = allocate_from_partition_with_affiliation(req.is_old()? ShenandoahFreeSetPartitionId::OldCollector:\n-                                                      ShenandoahFreeSetPartitionId::Collector,\n-                                                      ShenandoahAffiliation::FREE, req, in_new_region);\n+    result = allocate_from_partition_with_affiliation(ShenandoahAffiliation::FREE, req, in_new_region);\n@@ -901,5 +930,2 @@\n-  idx_t rightmost_mutator = _partitions.rightmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n-  idx_t leftmost_mutator =  _partitions.leftmost_empty(ShenandoahFreeSetPartitionId::Mutator);\n-  for (idx_t idx = rightmost_mutator; idx >= leftmost_mutator; ) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, idx),\n-           \"Boundaries or find_prev_last_bit failed: \" SSIZE_FORMAT, idx);\n+  ShenandoahRightLeftIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator, true);\n+  for (idx_t idx = iterator.current(); iterator.has_next(); idx = iterator.next()) {\n@@ -918,1 +944,0 @@\n-    idx = _partitions.find_index_of_previous_available_region(ShenandoahFreeSetPartitionId::Mutator, idx - 1);\n@@ -1003,1 +1028,1 @@\n-    assert(ctx->is_bitmap_clear_range(ctx->top_bitmap(r), r->end()), \"Bitmap above top_bitmap() must be clear\");\n+    assert(ctx->is_bitmap_range_within_region_clear(ctx->top_bitmap(r), r->end()), \"Bitmap above top_bitmap() must be clear\");\n@@ -1477,1 +1502,1 @@\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n@@ -1479,0 +1504,1 @@\n+  ShenandoahLeftRightIterator iterator(&_partitions, which_collector, true);\n@@ -1480,2 +1506,1 @@\n-  for (idx_t idx = _partitions.leftmost_empty(which_collector); (transferred_regions < max_xfer_regions) && (idx <= rightmost); ) {\n-    assert(_partitions.in_free_set(which_collector, idx), \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n+  for (idx_t idx = iterator.current(); transferred_regions < max_xfer_regions && iterator.has_next(); idx = iterator.next()) {\n@@ -1488,1 +1513,0 @@\n-    idx = _partitions.find_index_of_next_available_region(which_collector, idx + 1);\n@@ -1494,1 +1518,1 @@\n-size_t ShenandoahFreeSet::transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId collector_id,\n+size_t ShenandoahFreeSet::transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n@@ -1499,3 +1523,2 @@\n-  idx_t rightmost = _partitions.rightmost(collector_id);\n-  for (idx_t idx = _partitions.leftmost(collector_id); (transferred_regions < max_xfer_regions) && (idx <= rightmost); ) {\n-    assert(_partitions.in_free_set(collector_id, idx), \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, idx);\n+  ShenandoahLeftRightIterator iterator(&_partitions, which_collector, false);\n+  for (idx_t idx = iterator.current(); transferred_regions < max_xfer_regions && iterator.has_next(); idx = iterator.next()) {\n@@ -1504,1 +1527,1 @@\n-      _partitions.move_from_partition_to_partition(idx, collector_id, ShenandoahFreeSetPartitionId::Mutator, ac);\n+      _partitions.move_from_partition_to_partition(idx, which_collector, ShenandoahFreeSetPartitionId::Mutator, ac);\n@@ -1508,1 +1531,0 @@\n-    idx = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, idx + 1);\n@@ -1588,2 +1610,2 @@\n-      log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                   region_count, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_old_capacity));\n+      log_info(gc, ergo)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                         region_count, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_old_capacity));\n@@ -1592,2 +1614,2 @@\n-      log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-                   region_count, old_gen->name(), young_gen->name(), PROPERFMTARGS(new_young_capacity));\n+      log_info(gc, ergo)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                         region_count, old_gen->name(), young_gen->name(), PROPERFMTARGS(new_young_capacity));\n@@ -1824,15 +1846,0 @@\n-    size_t retired_old = 0;\n-    size_t retired_old_humongous = 0;\n-    size_t retired_young = 0;\n-    size_t retired_young_humongous = 0;\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    size_t retired_young_waste = 0;\n-    size_t retired_old_waste = 0;\n-    size_t consumed_collector = 0;\n-    size_t consumed_old_collector = 0;\n-    size_t consumed_mutator = 0;\n-    size_t available_old = 0;\n-    size_t available_young = 0;\n-    size_t available_mutator = 0;\n-    size_t available_collector = 0;\n-    size_t available_old_collector = 0;\n@@ -1869,3 +1876,1 @@\n-        available_mutator += capacity;\n-        consumed_mutator += region_size_bytes - capacity;\n-        buffer[idx] = (capacity == region_size_bytes)? 'M': 'm';\n+        buffer[idx] = (capacity == ShenandoahHeapRegion::region_size_bytes()) ? 'M' : 'm';\n@@ -1875,3 +1880,1 @@\n-        available_collector += capacity;\n-        consumed_collector += region_size_bytes - capacity;\n-        buffer[idx] = (capacity == region_size_bytes)? 'C': 'c';\n+        buffer[idx] = (capacity == ShenandoahHeapRegion::region_size_bytes()) ? 'C' : 'c';\n@@ -1880,3 +1883,1 @@\n-        available_old_collector += capacity;\n-        consumed_old_collector += region_size_bytes - capacity;\n-        buffer[idx] = (capacity == region_size_bytes)? 'O': 'o';\n+        buffer[idx] = (capacity == ShenandoahHeapRegion::region_size_bytes()) ? 'O' : 'o';\n@@ -1886,1 +1887,0 @@\n-          retired_old_humongous += region_size_bytes;\n@@ -1889,1 +1889,0 @@\n-          retired_young_humongous += region_size_bytes;\n@@ -1894,2 +1893,0 @@\n-          retired_old_waste += alloc_capacity(r);\n-          retired_old += region_size_bytes;\n@@ -1898,2 +1895,0 @@\n-          retired_young_waste += alloc_capacity(r);\n-          retired_young += region_size_bytes;\n@@ -2055,4 +2050,2 @@\n-  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n-           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+  ShenandoahLeftRightIterator mutator(const_cast<ShenandoahRegionPartitions*>(&_partitions), ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = mutator.current(); mutator.has_next(); index = mutator.next()) {\n@@ -2060,1 +2053,0 @@\n-    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -2062,0 +2054,1 @@\n+\n@@ -2063,4 +2056,2 @@\n-  rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector);\n-  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, index),\n-           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+  ShenandoahLeftRightIterator collector(const_cast<ShenandoahRegionPartitions*>(&_partitions), ShenandoahFreeSetPartitionId::Collector);\n+  for (idx_t index = collector.current(); collector.has_next(); index = collector.next()) {\n@@ -2068,1 +2059,0 @@\n-    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Collector, index + 1);\n@@ -2070,0 +2060,1 @@\n+\n@@ -2085,4 +2076,2 @@\n-  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n-           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+  ShenandoahLeftRightIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = iterator.current(); iterator.has_next(); index = iterator.next()) {\n@@ -2093,1 +2082,0 @@\n-    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n@@ -2108,1 +2096,0 @@\n-\n@@ -2111,4 +2098,2 @@\n-  idx_t rightmost = _partitions.rightmost(ShenandoahFreeSetPartitionId::Mutator);\n-  for (idx_t index = _partitions.leftmost(ShenandoahFreeSetPartitionId::Mutator); index <= rightmost; ) {\n-    assert(_partitions.in_free_set(ShenandoahFreeSetPartitionId::Mutator, index),\n-           \"Boundaries or find_first_set_bit failed: \" SSIZE_FORMAT, index);\n+  ShenandoahLeftRightIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::Mutator);\n+  for (idx_t index = iterator.current(); iterator.has_next(); index = iterator.next()) {\n@@ -2128,1 +2113,0 @@\n-    index = _partitions.find_index_of_next_available_region(ShenandoahFreeSetPartitionId::Mutator, index + 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":125,"deletions":141,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-\n@@ -296,2 +295,1 @@\n-  inline HeapWord* allocate_from_partition_with_affiliation(ShenandoahFreeSetPartitionId which_partition,\n-                                                            ShenandoahAffiliation affiliation,\n+  inline HeapWord* allocate_from_partition_with_affiliation(ShenandoahAffiliation affiliation,\n@@ -339,5 +337,3 @@\n-  \/\/ Search for regions to satisfy allocation request starting from the right, moving to the left.\n-  HeapWord* allocate_from_right_to_left(ShenandoahAllocRequest& req, bool& in_new_region);\n-\n-  \/\/ Search for regions to satisfy allocation request starting from the left, moving to the right.\n-  HeapWord* allocate_from_left_to_right(ShenandoahAllocRequest& req, bool& in_new_region);\n+  \/\/ Search for regions to satisfy allocation request using iterator.\n+  template<typename Iter>\n+  HeapWord* allocate_from_regions(Iter& iterator, ShenandoahAllocRequest &req, bool &in_new_region);\n@@ -348,0 +344,4 @@\n+  \/\/ Search for allocation in region with same affiliation as request, using given iterator.\n+  template<typename Iter>\n+  HeapWord* allocate_with_affiliation(Iter& iterator, ShenandoahAffiliation affiliation, ShenandoahAllocRequest& req, bool& in_new_region);\n+\n@@ -368,1 +368,1 @@\n-  size_t transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId collector_id,\n+  size_t transfer_non_empty_regions_from_collector_set_to_mutator_set(ShenandoahFreeSetPartitionId which_collector,\n@@ -448,1 +448,0 @@\n-  size_t unsafe_peek_free() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n@@ -80,1 +80,2 @@\n-      bool needs_reset = _generation->contains(region) || !region->is_affiliated();\n+      auto const affiliation = region->affiliation();\n+      bool needs_reset = affiliation == FREE || _generation->contains(affiliation);\n@@ -121,0 +122,32 @@\n+\/\/ Add [TAMS, top) volume over young regions. Used to correct age 0 cohort census\n+\/\/ for adaptive tenuring when census is taken during marking.\n+\/\/ In non-product builds, for the purposes of verification, we also collect the total\n+\/\/ live objects in young regions as well.\n+class ShenandoahUpdateCensusZeroCohortClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* const _ctx;\n+  \/\/ Population size units are words (not bytes)\n+  size_t _age0_pop;                \/\/ running tally of age0 population size\n+  size_t _total_pop;               \/\/ total live population size\n+public:\n+  explicit ShenandoahUpdateCensusZeroCohortClosure(ShenandoahMarkingContext* ctx)\n+    : _ctx(ctx), _age0_pop(0), _total_pop(0) {}\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    if (_ctx != nullptr && r->is_active()) {\n+      assert(r->is_young(), \"Young regions only\");\n+      HeapWord* tams = _ctx->top_at_mark_start(r);\n+      HeapWord* top  = r->top();\n+      if (top > tams) {\n+        _age0_pop += pointer_delta(top, tams);\n+      }\n+      \/\/ TODO: check significance of _ctx != nullptr above, can that\n+      \/\/ spoof _total_pop in some corner cases?\n+      NOT_PRODUCT(_total_pop += r->get_live_data_words();)\n+    }\n+  }\n+\n+  size_t get_age0_population()  const { return _age0_pop; }\n+  size_t get_total_population() const { return _total_pop; }\n+};\n+\n@@ -236,1 +269,1 @@\n-  parallel_region_iterate_free(&cl);\n+  parallel_heap_region_iterate_free(&cl);\n@@ -239,1 +272,1 @@\n-void ShenandoahGeneration::parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+void ShenandoahGeneration::parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n@@ -379,1 +412,1 @@\n-  size_t old_evacuated_committed = (size_t) (ShenandoahOldEvacWaste * old_evacuated);\n+  size_t old_evacuated_committed = (size_t) (ShenandoahOldEvacWaste * double(old_evacuated));\n@@ -396,1 +429,1 @@\n-  size_t young_advance_promoted_reserve_used = (size_t) (ShenandoahPromoEvacWaste * young_advance_promoted);\n+  size_t young_advance_promoted_reserve_used = (size_t) (ShenandoahPromoEvacWaste * double(young_advance_promoted));\n@@ -399,1 +432,1 @@\n-  size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * young_evacuated);\n+  size_t young_evacuated_reserve_used = (size_t) (ShenandoahEvacWaste * double(young_evacuated));\n@@ -454,1 +487,1 @@\n-    size_t regions_to_xfer = MIN2(excess_regions, unaffiliated_old_regions);\n+    regions_to_xfer = MIN2(excess_regions, unaffiliated_old_regions);\n@@ -459,1 +492,3 @@\n-    assert(excess_old > regions_to_xfer * region_size_bytes, \"Cannot xfer more than excess old\");\n+    assert(excess_old >= regions_to_xfer * region_size_bytes,\n+           \"Cannot transfer (\" SIZE_FORMAT \", \" SIZE_FORMAT \") more than excess old (\" SIZE_FORMAT \")\",\n+           regions_to_xfer, region_size_bytes, excess_old);\n@@ -461,1 +496,1 @@\n-    log_info(gc, ergo)(\"%s transferred \" SIZE_FORMAT \" excess regions to young before start of evacuation\",\n+    log_debug(gc, ergo)(\"%s transferred \" SIZE_FORMAT \" excess regions to young before start of evacuation\",\n@@ -635,1 +670,1 @@\n-    log_info(gc)(\"Preselected \" SIZE_FORMAT \" regions containing \" SIZE_FORMAT \" live bytes,\"\n+    log_debug(gc)(\"Preselected \" SIZE_FORMAT \" regions containing \" SIZE_FORMAT \" live bytes,\"\n@@ -701,1 +736,0 @@\n-      ResourceMark rm;\n@@ -756,1 +790,1 @@\n-          !context->is_bitmap_clear_range(r->bottom(), r->end())) {\n+          !context->is_bitmap_range_within_region_clear(r->bottom(), r->end())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":47,"deletions":13,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahAffiliation.hpp\"\n@@ -178,0 +179,2 @@\n+  virtual bool contains(ShenandoahAffiliation affiliation) const = 0;\n+\n@@ -188,1 +191,1 @@\n-  virtual void parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl);\n+  virtual void parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,2 +141,2 @@\n-  log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-          regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n+  log_info(gc, ergo)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                     regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n@@ -193,2 +193,2 @@\n-  log_info(gc)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-          regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n+  log_info(gc, ergo)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+                     regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,2 +107,0 @@\n-      log_info(gc)(\"Trigger: Handle Allocation Failure\");\n-\n@@ -125,0 +123,2 @@\n+      heuristics->log_trigger(\"Handle Allocation Failure\");\n+\n@@ -139,1 +139,1 @@\n-      log_info(gc)(\"Trigger: GC request (%s)\", GCCause::to_string(cause));\n+      global_heuristics->log_trigger(\"GC request (%s)\", GCCause::to_string(cause));\n@@ -409,1 +409,1 @@\n-      log_info(gc, ergo)(\"Start GC cycle (YOUNG)\");\n+      log_info(gc, ergo)(\"Start GC cycle (Young)\");\n@@ -414,1 +414,1 @@\n-      log_info(gc, ergo)(\"Start GC cycle (OLD)\");\n+      log_info(gc, ergo)(\"Start GC cycle (Old)\");\n@@ -419,1 +419,1 @@\n-      log_info(gc, ergo)(\"Start GC cycle (GLOBAL)\");\n+      log_info(gc, ergo)(\"Start GC cycle (Global)\");\n@@ -839,1 +839,1 @@\n-    log_info(gc)(\"Transition from: %s to: %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n+    log_debug(gc)(\"Transition from: %s to: %s\", gc_mode_name(_mode), gc_mode_name(new_mode));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  log_info(gc)(\"FullGC done: young usage: \" PROPERFMT \", old usage: \" PROPERFMT,\n+  log_info(gc, ergo)(\"FullGC done: young usage: \" PROPERFMT \", old usage: \" PROPERFMT,\n@@ -136,1 +136,1 @@\n-  LogTarget(Info, gc) lt;\n+  LogTarget(Debug, gc) lt;\n@@ -145,1 +145,1 @@\n-    log_info(gc)(\"Live bytes in old after STW mark: \" PROPERFMT, PROPERFMTARGS(live_bytes_in_old));\n+    log_debug(gc)(\"Live bytes in old after STW mark: \" PROPERFMT, PROPERFMTARGS(live_bytes_in_old));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n@@ -268,15 +269,15 @@\n-          }\n-          copy = allocate_from_plab(thread, size, is_promotion);\n-          if ((copy == nullptr) && (size < ShenandoahThreadLocalData::plab_size(thread)) &&\n-              ShenandoahThreadLocalData::plab_retries_enabled(thread)) {\n-            \/\/ PLAB allocation failed because we are bumping up against the limit on old evacuation reserve or because\n-            \/\/ the requested object does not fit within the current plab but the plab still has an \"abundance\" of memory,\n-            \/\/ where abundance is defined as >= ShenGenHeap::plab_min_size().  In the former case, we try shrinking the\n-            \/\/ desired PLAB size to the minimum and retry PLAB allocation to avoid cascading of shared memory allocations.\n-            if (plab->words_remaining() < plab_min_size()) {\n-              ShenandoahThreadLocalData::set_plab_size(thread, plab_min_size());\n-              copy = allocate_from_plab(thread, size, is_promotion);\n-              \/\/ If we still get nullptr, we'll try a shared allocation below.\n-              if (copy == nullptr) {\n-                \/\/ If retry fails, don't continue to retry until we have success (probably in next GC pass)\n-                ShenandoahThreadLocalData::disable_plab_retries(thread);\n+            copy = allocate_from_plab(thread, size, is_promotion);\n+            if ((copy == nullptr) && (size < ShenandoahThreadLocalData::plab_size(thread)) &&\n+                ShenandoahThreadLocalData::plab_retries_enabled(thread)) {\n+              \/\/ PLAB allocation failed because we are bumping up against the limit on old evacuation reserve or because\n+              \/\/ the requested object does not fit within the current plab but the plab still has an \"abundance\" of memory,\n+              \/\/ where abundance is defined as >= ShenGenHeap::plab_min_size().  In the former case, we try shrinking the\n+              \/\/ desired PLAB size to the minimum and retry PLAB allocation to avoid cascading of shared memory allocations.\n+              if (plab->words_remaining() < plab_min_size()) {\n+                ShenandoahThreadLocalData::set_plab_size(thread, plab_min_size());\n+                copy = allocate_from_plab(thread, size, is_promotion);\n+                \/\/ If we still get nullptr, we'll try a shared allocation below.\n+                if (copy == nullptr) {\n+                  \/\/ If retry fails, don't continue to retry until we have success (probably in next GC pass)\n+                  ShenandoahThreadLocalData::disable_plab_retries(thread);\n+                }\n@@ -284,0 +285,1 @@\n+              \/\/ else, copy still equals nullptr.  this causes shared allocation below, preserving this plab for future needs.\n@@ -285,1 +287,0 @@\n-            \/\/ else, copy still equals nullptr.  this causes shared allocation below, preserving this plab for future needs.\n@@ -643,3 +644,3 @@\n-  const size_t bound_on_old_reserve = old_available + old_xfer_limit + young_reserve;\n-  const size_t max_old_reserve = (ShenandoahOldEvacRatioPercent == 100)?\n-                                 bound_on_old_reserve: MIN2((young_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n+  const double bound_on_old_reserve = old_available + old_xfer_limit + young_reserve;\n+  const double max_old_reserve = (ShenandoahOldEvacRatioPercent == 100)?\n+                                 bound_on_old_reserve: MIN2(double(young_reserve * ShenandoahOldEvacRatioPercent) \/ double(100 - ShenandoahOldEvacRatioPercent),\n@@ -651,1 +652,1 @@\n-  size_t reserve_for_mixed = 0;\n+  double reserve_for_mixed = 0;\n@@ -655,2 +656,1 @@\n-    const size_t max_evac_need = (size_t)\n-            (old_generation()->unprocessed_collection_candidates_live_memory() * ShenandoahOldEvacWaste);\n+    const double max_evac_need = (double(old_generation()->unprocessed_collection_candidates_live_memory()) * ShenandoahOldEvacWaste);\n@@ -659,2 +659,1 @@\n-    const size_t old_fragmented_available =\n-            old_available - old_generation()->free_unaffiliated_regions() * region_size_bytes;\n+    const double old_fragmented_available = double(old_available - old_generation()->free_unaffiliated_regions() * region_size_bytes);\n@@ -1003,1 +1002,1 @@\n-namespace ShenandoahCompositeRegionClosure {\n+struct ShenandoahCompositeRegionClosure {\n@@ -1023,1 +1022,0 @@\n-\n@@ -1025,1 +1023,1 @@\n-  Closure<C1, C2> of(C1 &c1, C2 &c2) {\n+  static Closure<C1, C2> of(C1 &c1, C2 &c2) {\n@@ -1028,1 +1026,1 @@\n-}\n+};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":26,"deletions":28,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return \"GLOBAL\";\n+  return type() == NON_GEN ? \"\" : \"Global\";\n@@ -84,0 +84,4 @@\n+bool ShenandoahGlobalGeneration::contains(ShenandoahAffiliation affiliation) const {\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+  bool contains(ShenandoahAffiliation affiliation) const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n@@ -575,2 +576,6 @@\n-  if (is_concurrent_old_mark_in_progress())    st->print(\"old marking, \");\n-  if (is_concurrent_young_mark_in_progress())  st->print(\"young marking, \");\n+  if (!mode()->is_generational()) {\n+    if (is_concurrent_mark_in_progress())      st->print(\"marking,\");\n+  } else {\n+    if (is_concurrent_old_mark_in_progress())    st->print(\"old marking, \");\n+    if (is_concurrent_young_mark_in_progress())  st->print(\"young marking, \");\n+  }\n@@ -859,1 +864,1 @@\n-  _heap_changed.set();\n+  _heap_changed.try_set();\n@@ -1948,3 +1953,0 @@\n-  \/\/ Check that if concurrent weak root is set then active_gen isn't null\n-  assert(!is_concurrent_weak_root_in_progress() || active_generation() != nullptr, \"Error\");\n-  shenandoah_assert_generations_reconciled();\n@@ -2369,20 +2371,0 @@\n-ShenandoahSynchronizePinnedRegionStates::ShenandoahSynchronizePinnedRegionStates() : _lock(ShenandoahHeap::heap()->lock()) { }\n-\n-void ShenandoahSynchronizePinnedRegionStates::heap_region_do(ShenandoahHeapRegion* r) {\n-  \/\/ Drop \"pinned\" state from regions that no longer have a pinned count. Put\n-  \/\/ regions with a pinned count into the \"pinned\" state.\n-  if (r->is_active()) {\n-    if (r->is_pinned()) {\n-      if (r->pin_count() == 0) {\n-        ShenandoahHeapLocker locker(_lock);\n-        r->make_unpinned();\n-      }\n-    } else {\n-      if (r->pin_count() > 0) {\n-        ShenandoahHeapLocker locker(_lock);\n-        r->make_pinned();\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp\"\n@@ -125,11 +124,0 @@\n-class ShenandoahSynchronizePinnedRegionStates : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahHeapLock* const _lock;\n-\n-public:\n-  ShenandoahSynchronizePinnedRegionStates();\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) override;\n-  bool is_thread_safe() override { return true; }\n-};\n-\n@@ -604,0 +592,1 @@\n+  \/\/ Returns true if the given oop belongs to a generation that is actively being collected.\n@@ -607,1 +596,5 @@\n-  inline bool is_old(oop pobj) const;\n+\n+  \/\/ Returns true iff the young generation is being collected and the given pointer\n+  \/\/ is in the old generation. This is used to prevent the young collection from treating\n+  \/\/ such an object as unreachable.\n+  inline bool is_in_old_during_young_collection(oop obj) const;\n@@ -749,1 +742,0 @@\n-public:\n@@ -751,0 +743,1 @@\n+public:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -273,2 +273,1 @@\n-    double cancel_time = os::elapsedTime() - _cancel_requested_time;\n-    log_info(gc)(\"GC cancellation took %.3fs\", cancel_time);\n+    log_debug(gc)(\"GC cancellation took %.3fs\", (os::elapsedTime() - _cancel_requested_time));\n@@ -378,1 +377,1 @@\n-    \/\/ Free regions are in Old, Young, Global\n+    \/\/ Free regions are in old, young, and global collections\n@@ -381,2 +380,2 @@\n-    \/\/ Young regions are in young_generation and global_generation, not in old_generation\n-    return gen != (ShenandoahGeneration*)old_generation();\n+    \/\/ Young regions are in young and global collections, not in old collections\n+    return !gen->is_old();\n@@ -384,2 +383,2 @@\n-    \/\/ Old regions are in old_generation and global_generation, not in young_generation\n-    return gen != (ShenandoahGeneration*)young_generation();\n+    \/\/ Old regions are in old and global collections, not in young collections\n+    return !gen->is_young();\n@@ -400,1 +399,1 @@\n-inline bool ShenandoahHeap::is_old(oop obj) const {\n+inline bool ShenandoahHeap::is_in_old_during_young_collection(oop obj) const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -828,1 +828,1 @@\n-    assert(ctx->is_bitmap_clear_range(top_bitmap, _end),\n+    assert(ctx->is_bitmap_range_within_region_clear(top_bitmap, _end),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-  inline HeapWord* allocate(size_t word_size, ShenandoahAllocRequest req);\n+  inline HeapWord* allocate(size_t word_size, const ShenandoahAllocRequest& req);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-HeapWord* ShenandoahHeapRegion::allocate(size_t size, ShenandoahAllocRequest req) {\n+HeapWord* ShenandoahHeapRegion::allocate(size_t size, const ShenandoahAllocRequest& req) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahHeapRegionClosures.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMarkingContext.hpp\"\n+#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n+\n+ShenandoahSynchronizePinnedRegionStates::ShenandoahSynchronizePinnedRegionStates() :\n+  _lock(ShenandoahHeap::heap()->lock()) { }\n+\n+void ShenandoahSynchronizePinnedRegionStates::heap_region_do(ShenandoahHeapRegion* r) {\n+  \/\/ Drop \"pinned\" state from regions that no longer have a pinned count. Put\n+  \/\/ regions with a pinned count into the \"pinned\" state.\n+  if (r->is_active()) {\n+    synchronize_pin_count(r);\n+  }\n+}\n+\n+void ShenandoahSynchronizePinnedRegionStates::synchronize_pin_count(ShenandoahHeapRegion* r) {\n+  if (r->is_pinned()) {\n+    if (r->pin_count() == 0) {\n+      ShenandoahHeapLocker locker(_lock);\n+      r->make_unpinned();\n+    }\n+  } else {\n+    if (r->pin_count() > 0) {\n+      ShenandoahHeapLocker locker(_lock);\n+      r->make_pinned();\n+    }\n+  }\n+}\n+\n+ShenandoahFinalMarkUpdateRegionStateClosure::ShenandoahFinalMarkUpdateRegionStateClosure(ShenandoahMarkingContext *ctx) :\n+        _ctx(ctx) { }\n+\n+void ShenandoahFinalMarkUpdateRegionStateClosure::heap_region_do(ShenandoahHeapRegion* r) {\n+  if (r->is_active()) {\n+    if (_ctx != nullptr) {\n+      \/\/ _ctx may be null when this closure is used to sync only the pin status\n+      \/\/ update the watermark of old regions. For old regions we cannot reset\n+      \/\/ the TAMS because we rely on that to keep promoted objects alive after\n+      \/\/ old marking is complete.\n+\n+      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n+      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n+      HeapWord *tams = _ctx->top_at_mark_start(r);\n+      HeapWord *top = r->top();\n+      if (top > tams) {\n+        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n+      }\n+    }\n+\n+    \/\/ We are about to select the collection set, make sure it knows about\n+    \/\/ current pinning status. Also, this allows trashing more regions that\n+    \/\/ now have their pinning status dropped.\n+    _pins.synchronize_pin_count(r);\n+\n+    \/\/ Remember limit for updating refs. It's guaranteed that we get no\n+    \/\/ from-space-refs written from here on.\n+    r->set_update_watermark_at_safepoint(r->top());\n+  } else {\n+    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n+    assert(_ctx == nullptr || _ctx->top_at_mark_start(r) == r->top(),\n+           \"Region \" SIZE_FORMAT \" should have correct TAMS\", r->index());\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionClosures.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SRC_SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n-#define SRC_SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n@@ -72,1 +72,29 @@\n-#endif \/\/SRC_SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n+\/\/ Makes regions pinned or unpinned according to the region's pin count\n+class ShenandoahSynchronizePinnedRegionStates : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeapLock* const _lock;\n+\n+public:\n+  ShenandoahSynchronizePinnedRegionStates();\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override;\n+  bool is_thread_safe() override { return true; }\n+\n+  void synchronize_pin_count(ShenandoahHeapRegion* r);\n+};\n+\n+class ShenandoahMarkingContext;\n+\n+\/\/ Synchronizes region pinned status, sets update watermark and adjust live data tally for regions\n+class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* const _ctx;\n+  ShenandoahSynchronizePinnedRegionStates _pins;\n+public:\n+  explicit ShenandoahFinalMarkUpdateRegionStateClosure(ShenandoahMarkingContext* ctx);\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override;\n+  bool is_thread_safe() override { return true; }\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHHEAPREGIONCLOSURES_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionClosures.hpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    strcpy(_name_space, cns); \/\/ copy cns into _name_space\n+    strcpy(_name_space, cns);\n@@ -57,1 +57,1 @@\n-    cname = PerfDataManager::counter_name(_name_space, \"protocol_version\"); \/\/creating new protocol_version\n+    cname = PerfDataManager::counter_name(_name_space, \"protocol_version\");\n@@ -75,2 +75,1 @@\n-      _regions_data[i] = PerfDataManager::create_long_variable(SUN_GC, data_name,\n-                                                               PerfData::U_None, CHECK);\n+      _regions_data[i] = PerfDataManager::create_long_variable(SUN_GC, data_name, PerfData::U_None, CHECK);\n@@ -78,1 +77,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-  uint _count = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n-#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n-#include \"gc\/shenandoah\/shenandoahMarkingContext.hpp\"\n-#include \"gc\/shenandoah\/shenandoahSharedVariables.hpp\"\n-\n-\n-ShenandoahFinalMarkUpdateRegionStateClosure::ShenandoahFinalMarkUpdateRegionStateClosure(\n-  ShenandoahMarkingContext *ctx) :\n-  _ctx(ctx), _lock(ShenandoahHeap::heap()->lock()) {}\n-\n-void ShenandoahFinalMarkUpdateRegionStateClosure::heap_region_do(ShenandoahHeapRegion* r) {\n-  if (r->is_active()) {\n-    if (_ctx != nullptr) {\n-      \/\/ _ctx may be null when this closure is used to sync only the pin status\n-      \/\/ update the watermark of old regions. For old regions we cannot reset\n-      \/\/ the TAMS because we rely on that to keep promoted objects alive after\n-      \/\/ old marking is complete.\n-\n-      \/\/ All allocations past TAMS are implicitly live, adjust the region data.\n-      \/\/ Bitmaps\/TAMS are swapped at this point, so we need to poll complete bitmap.\n-      HeapWord *tams = _ctx->top_at_mark_start(r);\n-      HeapWord *top = r->top();\n-      if (top > tams) {\n-        r->increase_live_data_alloc_words(pointer_delta(top, tams));\n-      }\n-    }\n-\n-    \/\/ We are about to select the collection set, make sure it knows about\n-    \/\/ current pinning status. Also, this allows trashing more regions that\n-    \/\/ now have their pinning status dropped.\n-    if (r->is_pinned()) {\n-      if (r->pin_count() == 0) {\n-        ShenandoahHeapLocker locker(_lock);\n-        r->make_unpinned();\n-      }\n-    } else {\n-      if (r->pin_count() > 0) {\n-        ShenandoahHeapLocker locker(_lock);\n-        r->make_pinned();\n-      }\n-    }\n-\n-    \/\/ Remember limit for updating refs. It's guaranteed that we get no\n-    \/\/ from-space-refs written from here on.\n-    r->set_update_watermark_at_safepoint(r->top());\n-  } else {\n-    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n-    assert(_ctx == nullptr || _ctx->top_at_mark_start(r) == r->top(),\n-             \"Region \" SIZE_FORMAT \" should have correct TAMS\", r->index());\n-  }\n-}\n-\n-\n-ShenandoahUpdateCensusZeroCohortClosure::ShenandoahUpdateCensusZeroCohortClosure(\n-  ShenandoahMarkingContext *ctx) :\n-  _ctx(ctx), _age0_pop(0), _total_pop(0) {}\n-\n-void ShenandoahUpdateCensusZeroCohortClosure::heap_region_do(ShenandoahHeapRegion* r) {\n-  if (_ctx != nullptr && r->is_active()) {\n-    assert(r->is_young(), \"Young regions only\");\n-    HeapWord* tams = _ctx->top_at_mark_start(r);\n-    HeapWord* top  = r->top();\n-    if (top > tams) {\n-      _age0_pop += pointer_delta(top, tams);\n-    }\n-    \/\/ TODO: check significance of _ctx != nullptr above, can that\n-    \/\/ spoof _total_pop in some corner cases?\n-    NOT_PRODUCT(_total_pop += r->get_live_data_words();)\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.cpp","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHMARKCLOSURES_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHMARKCLOSURES_HPP\n-\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n-#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n-\n-class ShenandoahMarkingContext;\n-class ShenandoahHeapRegion;\n-\n-class ShenandoahFinalMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-  ShenandoahHeapLock* const _lock;\n-public:\n-  explicit ShenandoahFinalMarkUpdateRegionStateClosure(ShenandoahMarkingContext* ctx);\n-\n-  void heap_region_do(ShenandoahHeapRegion* r);\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n-\/\/ Add [TAMS, top) volume over young regions. Used to correct age 0 cohort census\n-\/\/ for adaptive tenuring when census is taken during marking.\n-\/\/ In non-product builds, for the purposes of verification, we also collect the total\n-\/\/ live objects in young regions as well.\n-class ShenandoahUpdateCensusZeroCohortClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-  \/\/ Population size units are words (not bytes)\n-  size_t _age0_pop;                \/\/ running tally of age0 population size\n-  size_t _total_pop;               \/\/ total live population size\n-public:\n-  ShenandoahUpdateCensusZeroCohortClosure(ShenandoahMarkingContext* ctx);\n-\n-  void heap_region_do(ShenandoahHeapRegion* r);\n-\n-  size_t get_age0_population()  { return _age0_pop; }\n-  size_t get_total_population() { return _total_pop; }\n-};\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHMARKCLOSURES_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkClosures.hpp","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -44,1 +44,2 @@\n-    if (r->is_affiliated() && heap->is_bitmap_slice_committed(r) && !is_bitmap_clear_range(r->bottom(), r->end())) {\n+    if (r->is_affiliated() && heap->is_bitmap_slice_committed(r)\n+        && !is_bitmap_range_within_region_clear(r->bottom(), r->end())) {\n@@ -51,1 +52,2 @@\n-bool ShenandoahMarkingContext::is_bitmap_clear_range(const HeapWord* start, const HeapWord* end) const {\n+bool ShenandoahMarkingContext::is_bitmap_range_within_region_clear(const HeapWord* start, const HeapWord* end) const {\n+  assert(start <= end, \"Invalid start \" PTR_FORMAT \" and end \" PTR_FORMAT, p2i(start), p2i(end));\n@@ -55,0 +57,1 @@\n+#ifdef ASSERT\n@@ -56,6 +59,5 @@\n-    while (start_idx <= end_idx) {\n-      ShenandoahHeapRegion* r = heap->get_region(start_idx);\n-      if (!heap->is_bitmap_slice_committed(r)) {\n-        return true;\n-      }\n-      start_idx++;\n+    assert(start_idx == end_idx, \"Expected range to be within same region (\" SIZE_FORMAT \", \" SIZE_FORMAT \")\", start_idx, end_idx);\n+#endif\n+    ShenandoahHeapRegion* r = heap->get_region(start_idx);\n+    if (!heap->is_bitmap_slice_committed(r)) {\n+      return true;\n@@ -94,1 +96,1 @@\n-  assert(is_bitmap_clear_range(bottom, r->end()),\n+  assert(is_bitmap_range_within_region_clear(bottom, r->end()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  bool is_bitmap_clear_range(const HeapWord* start, const HeapWord* end) const;\n+  bool is_bitmap_range_within_region_clear(const HeapWord* start, const HeapWord* end) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  return is_marked(obj) || ShenandoahHeap::heap()->is_old(obj);\n+  return is_marked(obj) || ShenandoahHeap::heap()->is_in_old_during_young_collection(obj);\n@@ -58,1 +58,1 @@\n-  return is_marked_strong(obj) || ShenandoahHeap::heap()->is_old(obj);\n+  return is_marked_strong(obj) || ShenandoahHeap::heap()->is_in_old_during_young_collection(obj);\n@@ -93,1 +93,1 @@\n-  assert(old_tams == r->bottom() || is_bitmap_clear_range(old_tams, new_tams),\n+  assert(old_tams == r->bottom() || is_bitmap_range_within_region_clear(old_tams, new_tams),\n@@ -113,1 +113,1 @@\n-  assert(is_bitmap_clear_range(r->bottom(), r->end()),\n+  assert(is_bitmap_range_within_region_clear(r->bottom(), r->end()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  log_info(gc)(\"Periodic Sample: GCU = %.3f%%, MU = %.3f%% during most recent %.1fs\", gcu * 100, mu * 100, time_delta);\n+  log_debug(gc)(\"Periodic Sample: GCU = %.3f%%, MU = %.3f%% during most recent %.1fs\", gcu * 100, mu * 100, time_delta);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"gc\/shenandoah\/shenandoahMarkClosures.hpp\"\n@@ -112,1 +111,1 @@\n-      log_info(gc)(\"Purged \" SIZE_FORMAT \" oops from old generation SATB buffers\", _trashed_oops);\n+      log_debug(gc)(\"Purged \" SIZE_FORMAT \" oops from old generation SATB buffers\", _trashed_oops);\n@@ -318,0 +317,3 @@\n+bool ShenandoahOldGeneration::contains(ShenandoahAffiliation affiliation) const {\n+  return affiliation == OLD_GENERATION;\n+}\n@@ -342,1 +344,1 @@\n-    log_info(gc)(\"Abandon SATB buffers\");\n+    log_debug(gc)(\"Abandon SATB buffers\");\n@@ -378,1 +380,1 @@\n-  static const char* msg = \"Coalescing and filling (OLD)\";\n+  static const char* msg = \"Coalescing and filling (Old)\";\n@@ -411,1 +413,1 @@\n-  log_info(gc)(\"Starting (or resuming) coalesce-and-fill of \" UINT32_FORMAT \" old heap regions\", coalesce_and_fill_regions_count);\n+  log_debug(gc)(\"Starting (or resuming) coalesce-and-fill of \" UINT32_FORMAT \" old heap regions\", coalesce_and_fill_regions_count);\n@@ -430,1 +432,1 @@\n-  log_info(gc)(\"Transfer SATB buffers\");\n+  log_debug(gc)(\"Transfer SATB buffers\");\n@@ -498,1 +500,1 @@\n-    log_info(gc)(\"Old generation transition from %s to %s\", state_name(_state), state_name(new_state));\n+    log_debug(gc)(\"Old generation transition from %s to %s\", state_name(_state), state_name(new_state));\n@@ -627,1 +629,1 @@\n-    log_info(gc)(\"Old gen evac failure.\");\n+    log_debug(gc)(\"Old gen evac failure.\");\n@@ -662,1 +664,1 @@\n-      log_info(gc, ergo)(\"Squelching additional promotion failure reports for current epoch\");\n+      log_debug(gc, ergo)(\"Squelching additional promotion failure reports for current epoch\");\n@@ -701,1 +703,1 @@\n-  log_info(gc)(\"After choosing global collection set, mixed candidates: \" UINT32_FORMAT \", coalescing candidates: \" SIZE_FORMAT,\n+  log_info(gc, ergo)(\"After choosing global collection set, mixed candidates: \" UINT32_FORMAT \", coalescing candidates: \" SIZE_FORMAT,\n@@ -706,1 +708,1 @@\n-void ShenandoahOldGeneration::parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+void ShenandoahOldGeneration::parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n@@ -709,1 +711,1 @@\n-  ShenandoahGeneration::parallel_region_iterate_free(&exclude_cl);\n+  ShenandoahGeneration::parallel_heap_region_iterate_free(&exclude_cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n@@ -96,1 +96,1 @@\n-    return \"OLD\";\n+    return \"Old\";\n@@ -196,1 +196,1 @@\n-  void parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n+  void parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n@@ -200,0 +200,1 @@\n+  bool contains(ShenandoahAffiliation affiliation) const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -436,3 +436,2 @@\n-  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(referent)) {\n-    \/\/ Note: would be sufficient to mark only the card that holds the start of this Reference object.\n-    heap->old_generation()->card_scan()->mark_range_as_dirty(cast_from_oop<HeapWord*>(reference), reference->size());\n+  if (ShenandoahCardBarrier) {\n+    card_mark_barrier(cast_from_oop<HeapWord*>(reference), referent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  log_info(gc)(\"%s: Done.\", name());\n+  log_debug(gc)(\"%s: Done.\", name());\n@@ -67,1 +67,1 @@\n-          log_info(gc)(\"Heuristics request for global (unload classes) accepted.\");\n+          log_debug(gc)(\"Heuristics request for global (unload classes) accepted.\");\n@@ -74,1 +74,1 @@\n-            log_info(gc)(\"Heuristics request for old collection accepted\");\n+            log_debug(gc)(\"Heuristics request for old collection accepted\");\n@@ -76,1 +76,1 @@\n-            log_info(gc)(\"Heuristics request for young collection accepted\");\n+            log_debug(gc)(\"Heuristics request for young collection accepted\");\n@@ -82,1 +82,1 @@\n-        log_info(gc)(\"Heuristics request to interrupt old for young collection accepted\");\n+        log_debug(gc)(\"Heuristics request to interrupt old for young collection accepted\");\n@@ -95,1 +95,1 @@\n-        log_info(gc)(\"Heuristics request for global collection accepted.\");\n+        log_debug(gc)(\"Heuristics request for global collection accepted.\");\n@@ -97,1 +97,1 @@\n-        log_info(gc)(\"Heuristics request for young collection accepted.\");\n+        log_debug(gc)(\"Heuristics request for young collection accepted.\");\n@@ -153,1 +153,1 @@\n-  log_info(gc)(\"%s: Stop requested.\", name());\n+  log_debug(gc)(\"%s: Stop requested.\", name());\n@@ -165,1 +165,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -167,0 +167,3 @@\n+      \/\/ We never exclusively mark the old generation on a safepoint. This would be encompassed\n+      \/\/ by a 'global' collection. Note that both GLOBAL and NON_GEN mark the entire heap, but\n+      \/\/ the GLOBAL closure is specialized for the generational mode.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  uint8_t offset_in_card = address - card_start_address;\n+  uint8_t offset_in_card = checked_cast<uint8_t>(pointer_delta(address, card_start_address));\n@@ -181,1 +181,1 @@\n-      uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n+      uint8_t coalesced_offset = checked_cast<uint8_t>(pointer_delta(address, card_start_address));\n@@ -191,1 +191,1 @@\n-    uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n+    uint8_t coalesced_offset = checked_cast<uint8_t>(pointer_delta(address, card_start_address));\n@@ -203,1 +203,1 @@\n-    uint8_t follow_offset = static_cast<uint8_t>((address + length_in_words) - _rs->addr_for_card_index(card_at_end));\n+    uint8_t follow_offset = checked_cast<uint8_t>((address + length_in_words) - _rs->addr_for_card_index(card_at_end));\n@@ -889,1 +889,0 @@\n-    size_t previous_group_entries = (i == 1)? _group_entries[0]: (_group_entries[i-1] - _group_entries[i-2]);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -360,2 +360,2 @@\n-  static const uint16_t ObjectStartsInCardRegion = 0x80;\n-  static const uint16_t FirstStartBits           = 0x7f;\n+  static const uint8_t ObjectStartsInCardRegion = 0x80;\n+  static const uint8_t FirstStartBits           = 0x7f;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-      return prefix \" (NON-GENERATIONAL)\" postfix;                        \\\n+      return prefix postfix;                                              \\\n@@ -52,1 +52,1 @@\n-      return prefix \" (GLOBAL)\" postfix;                                  \\\n+      return prefix \" (Global)\" postfix;                                  \\\n@@ -54,1 +54,1 @@\n-      return prefix \" (YOUNG)\" postfix;                                   \\\n+      return prefix \" (Young)\" postfix;                                   \\\n@@ -56,1 +56,1 @@\n-      return prefix \" (OLD)\" postfix;                                     \\\n+      return prefix \" (Old)\" postfix;                                     \\\n@@ -59,1 +59,1 @@\n-      return prefix \" (UNKNOWN)\" postfix;                                 \\\n+      return prefix \" (Unknown)\" postfix;                                 \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-\/\/   - VM_ShenandoahFinalRoots\n+\/\/   - VM_ShenandoahFinalRoots: finish up roots on a non-evacuating cycle\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -649,4 +649,0 @@\n-    if (_options._verify_marked == ShenandoahVerifier::_verify_marked_complete_satb_empty) {\n-      Threads::change_thread_claim_token();\n-    }\n-\n@@ -667,1 +663,1 @@\n-      Threads::possibly_parallel_threads_do(true, &verify_satb);\n+      Threads::threads_do(&verify_satb);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,0 +51,4 @@\n+bool ShenandoahYoungGeneration::contains(ShenandoahAffiliation affiliation) const {\n+  return affiliation == YOUNG_GENERATION;\n+}\n+\n@@ -66,1 +70,2 @@\n-void ShenandoahYoungGeneration::parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+void ShenandoahYoungGeneration::parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) {\n+  \/\/ Iterate over everything that is not old.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  virtual ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n+  ShenandoahHeuristics* initialize_heuristics(ShenandoahMode* gc_mode) override;\n@@ -42,1 +42,1 @@\n-    return \"YOUNG\";\n+    return \"Young\";\n@@ -54,1 +54,1 @@\n-  void parallel_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n+  void parallel_heap_region_iterate_free(ShenandoahHeapRegionClosure* cl) override;\n@@ -58,0 +58,1 @@\n+  bool contains(ShenandoahAffiliation affiliation) const override;\n@@ -81,1 +82,1 @@\n-  virtual void prepare_gc() override;\n+  void prepare_gc() override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -97,0 +97,4 @@\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestAllocIntArrays\n@@ -107,1 +111,2 @@\n- *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=adaptive -XX:ShenandoahGCMode=generational\n+ *      -XX:+ShenandoahVerify\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocIntArrays.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            output.shouldContain(\"Trigger (GLOBAL): Time since last GC\");\n+            output.shouldContain(\"Trigger: Time since last GC\");\n@@ -53,1 +53,1 @@\n-            output.shouldNotContain(\"Trigger (GLOBAL): Time since last GC\");\n+            output.shouldNotContain(\"Trigger: Time since last GC\");\n@@ -66,2 +66,2 @@\n-            output.shouldContain(\"Trigger (YOUNG): Time since last GC\");\n-            output.shouldContain(\"Trigger (OLD): Time since last GC\");\n+            output.shouldContain(\"Trigger (Young): Time since last GC\");\n+            output.shouldContain(\"Trigger (Old): Time since last GC\");\n@@ -69,2 +69,2 @@\n-            output.shouldNotContain(\"Trigger (YOUNG): Time since last GC\");\n-            output.shouldNotContain(\"Trigger (OLD): Time since last GC\");\n+            output.shouldNotContain(\"Trigger (Young): Time since last GC\");\n+            output.shouldNotContain(\"Trigger (Old): Time since last GC\");\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestPeriodicGC.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        output.shouldContain(\"Trigger (OLD): Old has overgrown\");\n+        output.shouldContain(\"Trigger (Old): Old has overgrown\");\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestOldGrowthTriggers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -47,1 +47,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -59,1 +59,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -71,1 +71,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n@@ -83,1 +83,1 @@\n- * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.Shenandoah & vm.opt.ShenandoahGCMode != \"generational\"\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}