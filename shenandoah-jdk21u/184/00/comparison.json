{"files":[{"patch":"@@ -934,1 +934,3 @@\n-        flip_to_old_gc(r);\n+        if (!flip_to_old_gc(r)) {\n+          continue;\n+        }\n@@ -1286,2 +1288,2 @@\n-void ShenandoahFreeSet::flip_to_old_gc(ShenandoahHeapRegion* r) {\n-  size_t idx = r->index();\n+bool ShenandoahFreeSet::flip_to_old_gc(ShenandoahHeapRegion* r) {\n+  const size_t idx = r->index();\n@@ -1293,5 +1295,2 @@\n-  size_t region_capacity = alloc_capacity(r);\n-  _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n-                                               ShenandoahFreeSetPartitionId::OldCollector, region_capacity);\n-  _partitions.assert_bounds();\n-  _heap->old_generation()->augment_evacuation_reserve(region_capacity);\n+  const size_t region_capacity = alloc_capacity(r);\n+\n@@ -1299,3 +1298,45 @@\n-  if (!transferred) {\n-    log_warning(gc, free)(\"Forcing transfer of \" SIZE_FORMAT \" to old reserve.\", idx);\n-    gen_heap->generation_sizer()->force_transfer_to_old(1);\n+  if (transferred) {\n+    _partitions.move_from_partition_to_partition(idx, ShenandoahFreeSetPartitionId::Mutator,\n+                                                 ShenandoahFreeSetPartitionId::OldCollector, region_capacity);\n+    _partitions.assert_bounds();\n+    _heap->old_generation()->augment_evacuation_reserve(region_capacity);\n+    return true;\n+  }\n+\n+  if (_heap->young_generation()->free_unaffiliated_regions() == 0 && _heap->old_generation()->free_unaffiliated_regions() > 0) {\n+    \/\/ Old has free unaffiliated regions, but it couldn't use them for allocation (likely because they\n+    \/\/ are trash and weak roots are in process). In this scenario, we aren't really stealing from the\n+    \/\/ mutator (they have nothing to steal), but they do have a usable region in their partition. What\n+    \/\/ we want to do here is swap that region from the mutator partition with one from the old collector\n+    \/\/ partition.\n+    \/\/ 1. Find a temporarily unusable trash region in the old collector partition\n+    ShenandoahRightLeftIterator iterator(&_partitions, ShenandoahFreeSetPartitionId::OldCollector, true);\n+    idx_t unusable_trash = -1;\n+    for (unusable_trash = iterator.current(); iterator.has_next(); unusable_trash = iterator.next()) {\n+      const ShenandoahHeapRegion* region = _heap->get_region(unusable_trash);\n+      if (region->is_trash() && _heap->is_concurrent_weak_root_in_progress()) {\n+        break;\n+      }\n+    }\n+\n+    if (unusable_trash != -1) {\n+      const size_t unusable_capacity = alloc_capacity(unusable_trash);\n+      \/\/ 2. Move the (temporarily) unusable trash region we found to the mutator partition\n+      _partitions.move_from_partition_to_partition(unusable_trash,\n+                                                   ShenandoahFreeSetPartitionId::OldCollector,\n+                                                   ShenandoahFreeSetPartitionId::Mutator, unusable_capacity);\n+\n+      \/\/ 3. Move this usable region from the mutator partition to the old collector partition\n+      _partitions.move_from_partition_to_partition(idx,\n+                                                   ShenandoahFreeSetPartitionId::Mutator,\n+                                                   ShenandoahFreeSetPartitionId::OldCollector, region_capacity);\n+\n+      _partitions.assert_bounds();\n+\n+      \/\/ 4. Do not adjust capacities for generations, we just swapped the regions that have already\n+      \/\/ been accounted for. However, we should adjust the evacuation reserves as those may have changed.\n+      shenandoah_assert_heaplocked();\n+      const size_t reserve = _heap->old_generation()->get_evacuation_reserve();\n+      _heap->old_generation()->set_evacuation_reserve(reserve - unusable_capacity + region_capacity);\n+      return true;\n+    }\n@@ -1303,2 +1344,3 @@\n-  \/\/ We do not ensure that the region is no longer trash, relying on try_allocate_in(), which always comes next,\n-  \/\/ to recycle trash before attempting to allocate anything in the region.\n+\n+  \/\/ We can't take this region young because it has no free unaffiliated regions (transfer failed).\n+  return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":55,"deletions":13,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -326,1 +326,2 @@\n-  \/\/ the Mutator free set into the Collector or OldCollector free set.\n+  \/\/ the Mutator free set into the Collector or OldCollector free set. The conditions to move this region are checked by\n+  \/\/ the caller, so the given region is always moved.\n@@ -328,1 +329,3 @@\n-  void flip_to_old_gc(ShenandoahHeapRegion* r);\n+\n+  \/\/ Return true if and only if the given region is successfully flipped to the old partition\n+  bool flip_to_old_gc(ShenandoahHeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}