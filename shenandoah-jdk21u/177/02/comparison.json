{"files":[{"patch":"@@ -124,2 +124,1 @@\n-  \/\/ Prevent resurrection of unreachable objects that are visited during\n-  \/\/ concurrent class-unloading.\n+  \/\/ Allow runtime to see unreachable objects that are visited during concurrent class-unloading.\n@@ -127,1 +126,1 @@\n-      _heap->is_evacuation_in_progress() &&\n+      _heap->is_concurrent_weak_root_in_progress() &&\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -154,0 +154,2 @@\n+  assert(heap->is_concurrent_weak_root_in_progress(), \"Must be doing weak roots now\");\n+\n@@ -159,4 +161,9 @@\n-  \/\/ Process weak roots that might still point to regions that would be broken by cleanup\n-  if (heap->is_concurrent_weak_root_in_progress()) {\n-    entry_weak_refs();\n-    entry_weak_roots();\n+  \/\/ Process weak roots that might still point to regions that would be broken by cleanup.\n+  \/\/ We cannot recycle regions because weak roots need to know what is marked in trashed regions.\n+  entry_weak_refs();\n+  entry_weak_roots();\n+\n+  \/\/ Perform concurrent class unloading before any regions get recycled. Class unloading may\n+  \/\/ need to inspect unmarked objects in trashed regions.\n+  if (heap->unload_classes()) {\n+    entry_class_unloading();\n@@ -172,6 +179,0 @@\n-  \/\/ Perform concurrent class unloading\n-  if (heap->unload_classes() &&\n-      heap->is_concurrent_weak_root_in_progress()) {\n-    entry_class_unloading();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1002,1 +1002,4 @@\n-    \/\/ to reference unmarked oops during concurrent classunloading.\n+    \/\/ to reference unmarked oops during concurrent classunloading. The collector also needs accurate marking\n+    \/\/ information to determine which weak handles need to be null'd out. If the region is recycled before weak\n+    \/\/ roots processing has finished, weak root processing may fail to null out a handle into a trashed region.\n+    \/\/ This turns the handle into a dangling pointer and will crash or corrupt the heap.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -792,0 +792,28 @@\n+bool ShenandoahHeap::is_in(const void* p) const {\n+  if (!is_in_reserved(p)) {\n+    return false;\n+  }\n+\n+  if (is_full_gc_move_in_progress()) {\n+    \/\/ Full GC move is running, we do not have a consistent region\n+    \/\/ information yet. But we know the pointer is in heap.\n+    return true;\n+  }\n+\n+  \/\/ Now check if we point to a live section in active region.\n+  const ShenandoahHeapRegion* r = heap_region_containing(p);\n+  if (p >= r->top()) {\n+    return false;\n+  }\n+\n+  if (r->is_active()) {\n+    return true;\n+  }\n+\n+  \/\/ The region is trash, but won't be recycled until after concurrent weak\n+  \/\/ roots. We also don't allow mutators to allocate from trash regions\n+  \/\/ during weak roots. Concurrent class unloading may access unmarked oops\n+  \/\/ in trash regions.\n+  return r->is_trash() && is_concurrent_weak_root_in_progress();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-  inline bool is_in(const void* p) const override;\n+  bool is_in(const void* p) const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -341,6 +341,0 @@\n-bool ShenandoahHeap::is_in(const void* p) const {\n-  HeapWord* heap_base = (HeapWord*) base();\n-  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n-  return p >= heap_base && p < last_region_end;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}