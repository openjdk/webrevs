{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk-updates\n+project=shenandoah\n@@ -4,0 +4,1 @@\n+<<<<<<< HEAD\n@@ -5,0 +6,3 @@\n+=======\n+version=repo-shenandoah-21\n+>>>>>>> 882e400d0634ee8fc5f69838a6b83e4bd1c5a663\n@@ -26,1 +30,1 @@\n-reviewers=1\n+committers=1\n","filename":".jcheck\/conf","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-  if ((state->iu_barriers_count() +\n-       state->load_reference_barriers_count()) > 0) {\n+  if (state->load_reference_barriers_count() > 0) {\n@@ -56,6 +55,0 @@\n-\n-    C->set_major_progress();\n-    if (!C->optimize_loops(igvn, LoopOptsShenandoahPostExpand)) {\n-      return false;\n-    }\n-    C->clear_major_progress();\n@@ -189,10 +182,1 @@\n-          uint i = 0;\n-          for (; i < phis.size(); i++) {\n-            Node* n = phis.node_at(i);\n-            if (n->Opcode() == Op_ShenandoahIUBarrier) {\n-              break;\n-            }\n-          }\n-          if (i == phis.size()) {\n-            return false;\n-          }\n+          return false;\n@@ -202,9 +186,0 @@\n-      } else if (in->Opcode() == Op_ShenandoahIUBarrier) {\n-        if (t != ShenandoahOopStore) {\n-          in = in->in(1);\n-          continue;\n-        }\n-        if (trace) {tty->print(\"Found enqueue barrier\"); in->dump();}\n-        phis.push(in, in->req());\n-        in = in->in(1);\n-        continue;\n@@ -329,1 +304,1 @@\n-        if (verify && !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahIUBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n+        if (verify && !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahValue, trace, barriers_used)) {\n@@ -371,1 +346,1 @@\n-          !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahIUBarrier ? ShenandoahOopStore : ShenandoahValue, trace, barriers_used)) {\n+          !verify_helper(n->in(MemNode::ValueIn), phis, visited, ShenandoahValue, trace, barriers_used)) {\n@@ -388,0 +363,6 @@\n+        \"array_partition_stub\",\n+        { { TypeFunc::Parms, ShenandoahStore }, { TypeFunc::Parms+4, ShenandoahStore },   { -1, ShenandoahNone },\n+          { -1, ShenandoahNone },                { -1, ShenandoahNone },                  { -1, ShenandoahNone } },\n+        \"arraysort_stub\",\n+        { { TypeFunc::Parms, ShenandoahStore },  { -1, ShenandoahNone },                  { -1, ShenandoahNone },\n+          { -1,  ShenandoahNone},                 { -1,  ShenandoahNone},                 { -1,  ShenandoahNone} },\n@@ -430,1 +411,1 @@\n-        \"shenandoah_clone_barrier\",\n+        \"shenandoah_clone\",\n@@ -523,1 +504,1 @@\n-    } else if (n->Opcode() == Op_ShenandoahIUBarrier || n->Opcode() == Op_ShenandoahLoadReferenceBarrier) {\n+    } else if (n->Opcode() == Op_ShenandoahLoadReferenceBarrier) {\n@@ -1120,14 +1101,0 @@\n-  for (int i = 0; i < state->iu_barriers_count(); i++) {\n-    Node* barrier = state->iu_barrier(i);\n-    Node* ctrl = phase->get_ctrl(barrier);\n-    IdealLoopTree* loop = phase->get_loop(ctrl);\n-    Node* head = loop->head();\n-    if (head->is_OuterStripMinedLoop()) {\n-      \/\/ Expanding a barrier here will break loop strip mining\n-      \/\/ verification. Transform the loop so the loop nest doesn't\n-      \/\/ appear as strip mined.\n-      OuterStripMinedLoopNode* outer = head->as_OuterStripMinedLoop();\n-      hide_strip_mined_loop(outer, outer->unique_ctrl_out()->as_CountedLoop(), phase);\n-    }\n-  }\n-\n@@ -1466,0 +1433,1 @@\n+<<<<<<< HEAD\n@@ -1617,0 +1585,2 @@\n+=======\n+>>>>>>> 882e400d0634ee8fc5f69838a6b83e4bd1c5a663\n@@ -1669,2 +1639,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      return get_load_addr(phase, visited, in->in(1));\n@@ -1688,350 +1656,0 @@\n-void ShenandoahBarrierC2Support::move_gc_state_test_out_of_loop(IfNode* iff, PhaseIdealLoop* phase) {\n-  IdealLoopTree *loop = phase->get_loop(iff);\n-  Node* loop_head = loop->_head;\n-  Node* entry_c = loop_head->in(LoopNode::EntryControl);\n-\n-  Node* bol = iff->in(1);\n-  Node* cmp = bol->in(1);\n-  Node* andi = cmp->in(1);\n-  Node* load = andi->in(1);\n-\n-  assert(is_gc_state_load(load), \"broken\");\n-  if (!phase->is_dominator(load->in(0), entry_c)) {\n-    Node* mem_ctrl = nullptr;\n-    Node* mem = dom_mem(load->in(MemNode::Memory), loop_head, Compile::AliasIdxRaw, mem_ctrl, phase);\n-    load = load->clone();\n-    load->set_req(MemNode::Memory, mem);\n-    load->set_req(0, entry_c);\n-    phase->register_new_node(load, entry_c);\n-    andi = andi->clone();\n-    andi->set_req(1, load);\n-    phase->register_new_node(andi, entry_c);\n-    cmp = cmp->clone();\n-    cmp->set_req(1, andi);\n-    phase->register_new_node(cmp, entry_c);\n-    bol = bol->clone();\n-    bol->set_req(1, cmp);\n-    phase->register_new_node(bol, entry_c);\n-\n-    phase->igvn().replace_input_of(iff, 1, bol);\n-  }\n-}\n-\n-bool ShenandoahBarrierC2Support::identical_backtoback_ifs(Node* n, PhaseIdealLoop* phase) {\n-  if (!n->is_If() || n->is_CountedLoopEnd()) {\n-    return false;\n-  }\n-  Node* region = n->in(0);\n-\n-  if (!region->is_Region()) {\n-    return false;\n-  }\n-  Node* dom = phase->idom(region);\n-  if (!dom->is_If()) {\n-    return false;\n-  }\n-\n-  if (!is_heap_stable_test(n) || !is_heap_stable_test(dom)) {\n-    return false;\n-  }\n-\n-  IfNode* dom_if = dom->as_If();\n-  Node* proj_true = dom_if->proj_out(1);\n-  Node* proj_false = dom_if->proj_out(0);\n-\n-  for (uint i = 1; i < region->req(); i++) {\n-    if (phase->is_dominator(proj_true, region->in(i))) {\n-      continue;\n-    }\n-    if (phase->is_dominator(proj_false, region->in(i))) {\n-      continue;\n-    }\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n-bool ShenandoahBarrierC2Support::merge_point_safe(Node* region) {\n-  for (DUIterator_Fast imax, i = region->fast_outs(imax); i < imax; i++) {\n-    Node* n = region->fast_out(i);\n-    if (n->is_LoadStore()) {\n-      \/\/ Splitting a LoadStore node through phi, causes it to lose its SCMemProj: the split if code doesn't have support\n-      \/\/ for a LoadStore at the region the if is split through because that's not expected to happen (LoadStore nodes\n-      \/\/ should be between barrier nodes). It does however happen with Shenandoah though because barriers can get\n-      \/\/ expanded around a LoadStore node.\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n-\n-void ShenandoahBarrierC2Support::merge_back_to_back_tests(Node* n, PhaseIdealLoop* phase) {\n-  assert(is_heap_stable_test(n), \"no other tests\");\n-  if (identical_backtoback_ifs(n, phase)) {\n-    Node* n_ctrl = n->in(0);\n-    if (phase->can_split_if(n_ctrl) && merge_point_safe(n_ctrl)) {\n-      IfNode* dom_if = phase->idom(n_ctrl)->as_If();\n-      if (is_heap_stable_test(n)) {\n-        Node* gc_state_load = n->in(1)->in(1)->in(1)->in(1);\n-        assert(is_gc_state_load(gc_state_load), \"broken\");\n-        Node* dom_gc_state_load = dom_if->in(1)->in(1)->in(1)->in(1);\n-        assert(is_gc_state_load(dom_gc_state_load), \"broken\");\n-        if (gc_state_load != dom_gc_state_load) {\n-          phase->igvn().replace_node(gc_state_load, dom_gc_state_load);\n-        }\n-      }\n-      PhiNode* bolphi = PhiNode::make_blank(n_ctrl, n->in(1));\n-      Node* proj_true = dom_if->proj_out(1);\n-      Node* proj_false = dom_if->proj_out(0);\n-      Node* con_true = phase->igvn().makecon(TypeInt::ONE);\n-      Node* con_false = phase->igvn().makecon(TypeInt::ZERO);\n-\n-      for (uint i = 1; i < n_ctrl->req(); i++) {\n-        if (phase->is_dominator(proj_true, n_ctrl->in(i))) {\n-          bolphi->init_req(i, con_true);\n-        } else {\n-          assert(phase->is_dominator(proj_false, n_ctrl->in(i)), \"bad if\");\n-          bolphi->init_req(i, con_false);\n-        }\n-      }\n-      phase->register_new_node(bolphi, n_ctrl);\n-      phase->igvn().replace_input_of(n, 1, bolphi);\n-      phase->do_split_if(n);\n-    }\n-  }\n-}\n-\n-IfNode* ShenandoahBarrierC2Support::find_unswitching_candidate(const IdealLoopTree* loop, PhaseIdealLoop* phase) {\n-  \/\/ Find first invariant test that doesn't exit the loop\n-  LoopNode *head = loop->_head->as_Loop();\n-  IfNode* unswitch_iff = nullptr;\n-  Node* n = head->in(LoopNode::LoopBackControl);\n-  int loop_has_sfpts = -1;\n-  while (n != head) {\n-    Node* n_dom = phase->idom(n);\n-    if (n->is_Region()) {\n-      if (n_dom->is_If()) {\n-        IfNode* iff = n_dom->as_If();\n-        if (iff->in(1)->is_Bool()) {\n-          BoolNode* bol = iff->in(1)->as_Bool();\n-          if (bol->in(1)->is_Cmp()) {\n-            \/\/ If condition is invariant and not a loop exit,\n-            \/\/ then found reason to unswitch.\n-            if (is_heap_stable_test(iff) &&\n-                (loop_has_sfpts == -1 || loop_has_sfpts == 0)) {\n-              assert(!loop->is_loop_exit(iff), \"both branches should be in the loop\");\n-              if (loop_has_sfpts == -1) {\n-                for(uint i = 0; i < loop->_body.size(); i++) {\n-                  Node *m = loop->_body[i];\n-                  if (m->is_SafePoint() && !m->is_CallLeaf()) {\n-                    loop_has_sfpts = 1;\n-                    break;\n-                  }\n-                }\n-                if (loop_has_sfpts == -1) {\n-                  loop_has_sfpts = 0;\n-                }\n-              }\n-              if (!loop_has_sfpts) {\n-                unswitch_iff = iff;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    n = n_dom;\n-  }\n-  return unswitch_iff;\n-}\n-\n-\n-void ShenandoahBarrierC2Support::optimize_after_expansion(VectorSet &visited, Node_Stack &stack, Node_List &old_new, PhaseIdealLoop* phase) {\n-  Node_List heap_stable_tests;\n-  stack.push(phase->C->start(), 0);\n-  do {\n-    Node* n = stack.node();\n-    uint i = stack.index();\n-\n-    if (i < n->outcnt()) {\n-      Node* u = n->raw_out(i);\n-      stack.set_index(i+1);\n-      if (!visited.test_set(u->_idx)) {\n-        stack.push(u, 0);\n-      }\n-    } else {\n-      stack.pop();\n-      if (n->is_If() && is_heap_stable_test(n)) {\n-        heap_stable_tests.push(n);\n-      }\n-    }\n-  } while (stack.size() > 0);\n-\n-  for (uint i = 0; i < heap_stable_tests.size(); i++) {\n-    Node* n = heap_stable_tests.at(i);\n-    assert(is_heap_stable_test(n), \"only evacuation test\");\n-    merge_back_to_back_tests(n, phase);\n-  }\n-\n-  if (!phase->C->major_progress()) {\n-    VectorSet seen;\n-    for (uint i = 0; i < heap_stable_tests.size(); i++) {\n-      Node* n = heap_stable_tests.at(i);\n-      IdealLoopTree* loop = phase->get_loop(n);\n-      if (loop != phase->ltree_root() &&\n-          loop->_child == nullptr &&\n-          !loop->_irreducible) {\n-        Node* head = loop->_head;\n-        if (head->is_Loop() &&\n-            (!head->is_CountedLoop() || head->as_CountedLoop()->is_main_loop() || head->as_CountedLoop()->is_normal_loop()) &&\n-            !seen.test_set(head->_idx)) {\n-          IfNode* iff = find_unswitching_candidate(loop, phase);\n-          if (iff != nullptr) {\n-            Node* bol = iff->in(1);\n-            if (head->as_Loop()->is_strip_mined()) {\n-              head->as_Loop()->verify_strip_mined(0);\n-            }\n-            move_gc_state_test_out_of_loop(iff, phase);\n-\n-            AutoNodeBudget node_budget(phase);\n-\n-            if (loop->policy_unswitching(phase)) {\n-              if (head->as_Loop()->is_strip_mined()) {\n-                OuterStripMinedLoopNode* outer = head->as_CountedLoop()->outer_loop();\n-                hide_strip_mined_loop(outer, head->as_CountedLoop(), phase);\n-              }\n-              phase->do_unswitching(loop, old_new);\n-            } else {\n-              \/\/ Not proceeding with unswitching. Move load back in\n-              \/\/ the loop.\n-              phase->igvn().replace_input_of(iff, 1, bol);\n-            }\n-          }\n-        }\n-      }\n-    }\n-  }\n-}\n-\n-ShenandoahIUBarrierNode::ShenandoahIUBarrierNode(Node* val) : Node(nullptr, val) {\n-  ShenandoahBarrierSetC2::bsc2()->state()->add_iu_barrier(this);\n-}\n-\n-const Type* ShenandoahIUBarrierNode::bottom_type() const {\n-  if (in(1) == nullptr || in(1)->is_top()) {\n-    return Type::TOP;\n-  }\n-  const Type* t = in(1)->bottom_type();\n-  if (t == TypePtr::NULL_PTR) {\n-    return t;\n-  }\n-  return t->is_oopptr();\n-}\n-\n-const Type* ShenandoahIUBarrierNode::Value(PhaseGVN* phase) const {\n-  if (in(1) == nullptr) {\n-    return Type::TOP;\n-  }\n-  const Type* t = phase->type(in(1));\n-  if (t == Type::TOP) {\n-    return Type::TOP;\n-  }\n-  if (t == TypePtr::NULL_PTR) {\n-    return t;\n-  }\n-  return t->is_oopptr();\n-}\n-\n-int ShenandoahIUBarrierNode::needed(Node* n) {\n-  if (n == nullptr ||\n-      n->is_Allocate() ||\n-      n->Opcode() == Op_ShenandoahIUBarrier ||\n-      n->bottom_type() == TypePtr::NULL_PTR ||\n-      (n->bottom_type()->make_oopptr() != nullptr && n->bottom_type()->make_oopptr()->const_oop() != nullptr)) {\n-    return NotNeeded;\n-  }\n-  if (n->is_Phi() ||\n-      n->is_CMove()) {\n-    return MaybeNeeded;\n-  }\n-  return Needed;\n-}\n-\n-Node* ShenandoahIUBarrierNode::next(Node* n) {\n-  for (;;) {\n-    if (n == nullptr) {\n-      return n;\n-    } else if (n->bottom_type() == TypePtr::NULL_PTR) {\n-      return n;\n-    } else if (n->bottom_type()->make_oopptr() != nullptr && n->bottom_type()->make_oopptr()->const_oop() != nullptr) {\n-      return n;\n-    } else if (n->is_ConstraintCast() ||\n-               n->Opcode() == Op_DecodeN ||\n-               n->Opcode() == Op_EncodeP) {\n-      n = n->in(1);\n-    } else if (n->is_Proj()) {\n-      n = n->in(0);\n-    } else {\n-      return n;\n-    }\n-  }\n-  ShouldNotReachHere();\n-  return nullptr;\n-}\n-\n-Node* ShenandoahIUBarrierNode::Identity(PhaseGVN* phase) {\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-\n-  Node* n = next(in(1));\n-\n-  int cont = needed(n);\n-\n-  if (cont == NotNeeded) {\n-    return in(1);\n-  } else if (cont == MaybeNeeded) {\n-    if (igvn == nullptr) {\n-      phase->record_for_igvn(this);\n-      return this;\n-    } else {\n-      ResourceMark rm;\n-      Unique_Node_List wq;\n-      uint wq_i = 0;\n-\n-      for (;;) {\n-        if (n->is_Phi()) {\n-          for (uint i = 1; i < n->req(); i++) {\n-            Node* m = n->in(i);\n-            if (m != nullptr) {\n-              wq.push(m);\n-            }\n-          }\n-        } else {\n-          assert(n->is_CMove(), \"nothing else here\");\n-          Node* m = n->in(CMoveNode::IfFalse);\n-          wq.push(m);\n-          m = n->in(CMoveNode::IfTrue);\n-          wq.push(m);\n-        }\n-        Node* orig_n = nullptr;\n-        do {\n-          if (wq_i >= wq.size()) {\n-            return in(1);\n-          }\n-          n = wq.at(wq_i);\n-          wq_i++;\n-          orig_n = n;\n-          n = next(n);\n-          cont = needed(n);\n-          if (cont == Needed) {\n-            return this;\n-          }\n-        } while (cont != MaybeNeeded || (orig_n != n && wq.member(n)));\n-      }\n-    }\n-  }\n-\n-  return this;\n-}\n-\n@@ -2194,1 +1812,1 @@\n-              assert(c->is_Loop() && j == LoopNode::LoopBackControl || _phase->C->has_irreducible_loop() || has_never_branch(_phase->C->root()), \"\");\n+              assert((c->is_Loop() && j == LoopNode::LoopBackControl) || _phase->C->has_irreducible_loop() || has_never_branch(_phase->C->root()), \"\");\n@@ -3021,2 +2639,0 @@\n-    case Op_ShenandoahIUBarrier:\n-      return needs_barrier_impl(phase, n->in(1), visited);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":16,"deletions":400,"binary":false,"changes":416,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+<<<<<<< HEAD\n@@ -76,0 +77,3 @@\n+=======\n+  static void fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& uses_to_ignore, uint last, PhaseIdealLoop* phase);\n+>>>>>>> 882e400d0634ee8fc5f69838a6b83e4bd1c5a663\n@@ -87,1 +91,0 @@\n-  static void optimize_after_expansion(VectorSet& visited, Node_Stack& nstack, Node_List& old_new, PhaseIdealLoop* phase);\n@@ -99,17 +102,0 @@\n-class ShenandoahIUBarrierNode : public Node {\n-public:\n-  ShenandoahIUBarrierNode(Node* val);\n-\n-  const Type *bottom_type() const;\n-  const Type* Value(PhaseGVN* phase) const;\n-  Node* Identity(PhaseGVN* phase);\n-\n-  int Opcode() const;\n-\n-private:\n-  enum { Needed, NotNeeded, MaybeNeeded };\n-\n-  static int needed(Node* n);\n-  static Node* next(Node* n);\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":4,"deletions":18,"binary":false,"changes":22,"status":"modified"}]}