{"files":[{"patch":"@@ -2225,5 +2225,0 @@\n-  enc_class riscv_enc_mov_byte_map_base(iRegP dst) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    __ load_byte_map_base($dst$$Register);\n-  %}\n-\n@@ -2873,15 +2868,0 @@\n-\/\/ Card Table Byte Map Base\n-operand immByteMapBase()\n-%{\n-  \/\/ Get base of card map\n-  predicate(BarrierSet::barrier_set()->is_a(BarrierSet::CardTableBarrierSet) &&\n-            SHENANDOAHGC_ONLY(!BarrierSet::barrier_set()->is_a(BarrierSet::ShenandoahBarrierSet) &&)\n-            (CardTable::CardValue*)n->get_ptr() ==\n-             ((CardTableBarrierSet*)(BarrierSet::barrier_set()))->card_table()->byte_map_base());\n-  match(ConP);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -4842,12 +4822,0 @@\n-\/\/ Load Byte Map Base Constant\n-instruct loadByteMapBase(iRegPNoSp dst, immByteMapBase con)\n-%{\n-  match(Set dst con);\n-  ins_cost(ALU_COST);\n-  format %{ \"mv  $dst, $con\\t# Byte Map Base, #@loadByteMapBase\" %}\n-\n-  ins_encode(riscv_enc_mov_byte_map_base(dst));\n-\n-  ins_pipe(ialu_imm);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -341,0 +341,4 @@\n+    uint survivor_regions_count = _g1h->survivor_regions_count();\n+    uint desired_eden_length = desired_young_length - survivor_regions_count;\n+    uint allocated_eden_length = allocated_young_length - survivor_regions_count;\n+\n@@ -343,2 +347,2 @@\n-      uint receiving_young = MIN3(_free_regions_at_end_of_collection,\n-                                  desired_young_length,\n+      uint receiving_eden = MIN3(_free_regions_at_end_of_collection,\n+                                  desired_eden_length,\n@@ -346,0 +350,2 @@\n+      \/\/ Ensure that we provision for at least one Eden region.\n+      receiving_eden = MAX2(receiving_eden, 1u);\n@@ -348,2 +354,2 @@\n-      receiving_additional_eden = allocated_young_length < receiving_young ?\n-                                  receiving_young - allocated_young_length : 0;\n+      receiving_additional_eden = allocated_eden_length < receiving_eden ?\n+                                  receiving_eden - allocated_eden_length : 0;\n@@ -352,4 +358,3 @@\n-                                \"receiving young %u receiving additional eden %u\",\n-                                receiving_young,\n-                                receiving_additional_eden);\n-    } else if (_free_regions_at_end_of_collection < (desired_young_length + _reserve_regions)) {\n+                                \"receiving eden %u receiving additional eden %u\",\n+                                receiving_eden, receiving_additional_eden);\n+    } else if (_free_regions_at_end_of_collection < (desired_eden_length + _reserve_regions)) {\n@@ -358,1 +363,1 @@\n-      assert(free_outside_reserve < desired_young_length,\n+      assert(free_outside_reserve < desired_eden_length,\n@@ -360,1 +365,1 @@\n-             free_outside_reserve, desired_young_length);\n+             free_outside_reserve, desired_eden_length);\n@@ -362,1 +367,1 @@\n-      uint receiving_within_reserve = MIN2(desired_young_length - free_outside_reserve,\n+      uint receiving_within_reserve = MIN2(desired_eden_length - free_outside_reserve,\n@@ -364,1 +369,2 @@\n-      uint receiving_young = free_outside_reserve + receiving_within_reserve;\n+      uint receiving_eden = free_outside_reserve + receiving_within_reserve;\n+\n@@ -366,2 +372,2 @@\n-      receiving_additional_eden = allocated_young_length < receiving_young ?\n-                                  receiving_young - allocated_young_length : 0;\n+      receiving_additional_eden = allocated_eden_length < receiving_eden ?\n+                                  receiving_eden - allocated_eden_length : 0;\n@@ -372,1 +378,1 @@\n-                                \"receiving young %u \"\n+                                \"receiving eden %u \"\n@@ -375,1 +381,1 @@\n-                                receiving_young, receiving_additional_eden);\n+                                receiving_eden, receiving_additional_eden);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1155,0 +1155,1 @@\n+    \/\/ Load barrier on the control output of a call\n@@ -1156,1 +1157,1 @@\n-      CallNode* call = ctrl->is_Proj() ? ctrl->in(0)->as_CallJava() : ctrl->as_CallJava();\n+      CallJavaNode* call = ctrl->is_Proj() ? ctrl->in(0)->as_CallJava() : ctrl->as_CallJava();\n@@ -1192,0 +1193,8 @@\n+      \/\/ If this is a runtime call, it doesn't have an exception handling path\n+      if (projs.fallthrough_catchproj == nullptr) {\n+        assert(call->method() == nullptr, \"should be runtime call\");\n+        assert(projs.catchall_catchproj == nullptr, \"runtime call should not have catch all projection\");\n+        continue;\n+      }\n+\n+      \/\/ Otherwise, clone the barrier so there's one for the fallthrough and one for the exception handling path\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -29,2 +29,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -203,1 +202,1 @@\n-  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+  return mark(sym->identity_hash(), sym, leakp);\n@@ -239,35 +238,8 @@\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  char* hidden_symbol = nullptr;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  char hash_buf[40];\n-  os::snprintf_checked(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+ * The hidden class symbol is the external name with the\n+ * address of its Klass slash appended.\n+ *\n+ * \"java.lang.invoke.LambdaForm$DMH\/0x0000000037144c00\"\n+ *\n+ * Caller needs ResourceMark.\n+ *\/\n+traceid JfrSymbolTable::mark_hidden_klass_name(const Klass* k, bool leakp) {\n@@ -275,9 +247,3 @@\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n+  assert(k->is_hidden(), \"invariant\");\n+  const uintptr_t hash = k->name()->identity_hash();\n+  return mark(hash, k->external_name(), leakp);\n@@ -289,3 +255,2 @@\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  if (k->is_hidden()) {\n+    symbol_id = mark_hidden_klass_name(k, leakp);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":17,"deletions":52,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+  traceid mark_hidden_klass_name(const Klass* k, bool leakp);\n@@ -109,4 +110,0 @@\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -447,1 +447,8 @@\n-  int resolved_indy_entries_length()                   const { return _resolved_indy_entries->length();      }\n+\n+  int resolved_indy_entries_length() const {\n+    if (_resolved_indy_entries == nullptr) {\n+      return 0;\n+    }\n+    return _resolved_indy_entries->length();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -102,7 +102,1 @@\n-            if (chc.localSupportedCertSignAlgs == null) {\n-                chc.localSupportedCertSignAlgs =\n-                        SignatureScheme.getSupportedAlgorithms(\n-                                chc.sslConfig,\n-                                chc.algorithmConstraints, chc.activeProtocols,\n-                                CERTIFICATE_SCOPE);\n-            }\n+            SignatureScheme.updateHandshakeLocalSupportedAlgs(chc);\n@@ -248,9 +242,2 @@\n-            if (shc.localSupportedCertSignAlgs == null) {\n-                shc.localSupportedCertSignAlgs =\n-                        SignatureScheme.getSupportedAlgorithms(\n-                                shc.sslConfig,\n-                                shc.algorithmConstraints,\n-                                List.of(shc.negotiatedProtocol),\n-                                CERTIFICATE_SCOPE);\n-            }\n-\n+            \/\/ localSupportedCertSignAlgs has been already updated when we set\n+            \/\/ the negotiated protocol.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertSignAlgsExtension.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -696,40 +696,0 @@\n-        \/**\n-         * When a failure happens during certificate checking from an\n-         * {@link X509TrustManager}, determine what TLS alert description\n-         * to use.\n-         *\n-         * @param cexc The exception thrown by the {@link X509TrustManager}\n-         *\n-         * @return A byte value corresponding to a TLS alert description number.\n-         *\/\n-        private static Alert getCertificateAlert(\n-                ClientHandshakeContext chc, CertificateException cexc) {\n-            \/\/ The specific reason for the failure will determine how to\n-            \/\/ set the alert description value\n-            Alert alert = Alert.CERTIFICATE_UNKNOWN;\n-\n-            Throwable baseCause = cexc.getCause();\n-            if (baseCause instanceof CertPathValidatorException cpve) {\n-                Reason reason = cpve.getReason();\n-                if (reason == BasicReason.REVOKED) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_REVOKED;\n-                } else if (\n-                        reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_UNKNOWN;\n-                } else if (reason == BasicReason.ALGORITHM_CONSTRAINED) {\n-                    alert = Alert.UNSUPPORTED_CERTIFICATE;\n-                } else if (reason == BasicReason.EXPIRED) {\n-                    alert = Alert.CERTIFICATE_EXPIRED;\n-                } else if (reason == BasicReason.INVALID_SIGNATURE ||\n-                        reason == BasicReason.NOT_YET_VALID) {\n-                    alert = Alert.BAD_CERTIFICATE;\n-                }\n-            }\n-\n-            return alert;\n-        }\n-\n@@ -1333,27 +1293,46 @@\n-        \/**\n-         * When a failure happens during certificate checking from an\n-         * {@link X509TrustManager}, determine what TLS alert description\n-         * to use.\n-         *\n-         * @param cexc The exception thrown by the {@link X509TrustManager}\n-         *\n-         * @return A byte value corresponding to a TLS alert description number.\n-         *\/\n-        private static Alert getCertificateAlert(\n-                ClientHandshakeContext chc, CertificateException cexc) {\n-            \/\/ The specific reason for the failure will determine how to\n-            \/\/ set the alert description value\n-            Alert alert = Alert.CERTIFICATE_UNKNOWN;\n-\n-            Throwable baseCause = cexc.getCause();\n-            if (baseCause instanceof CertPathValidatorException cpve) {\n-                Reason reason = cpve.getReason();\n-                if (reason == BasicReason.REVOKED) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_REVOKED;\n-                } else if (\n-                        reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {\n-                    alert = chc.staplingActive ?\n-                            Alert.BAD_CERT_STATUS_RESPONSE :\n-                            Alert.CERTIFICATE_UNKNOWN;\n+    }\n+\n+    \/**\n+     * When a failure happens during certificate checking from an\n+     * {@link X509TrustManager}, determine what TLS alert description\n+     * to use.\n+     *\n+     * @param cexc The exception thrown by the {@link X509TrustManager}\n+     * @return A byte value corresponding to a TLS alert description number.\n+     *\/\n+    private static Alert getCertificateAlert(\n+            ClientHandshakeContext chc, CertificateException cexc) {\n+        \/\/ The specific reason for the failure will determine how to\n+        \/\/ set the alert description value\n+        Alert alert = Alert.CERTIFICATE_UNKNOWN;\n+\n+        Throwable baseCause = cexc.getCause();\n+        if (baseCause instanceof CertPathValidatorException cpve) {\n+            Reason reason = cpve.getReason();\n+            if (reason == BasicReason.REVOKED) {\n+                alert = chc.staplingActive ?\n+                        Alert.BAD_CERT_STATUS_RESPONSE :\n+                        Alert.CERTIFICATE_REVOKED;\n+            } else if (reason == BasicReason.UNDETERMINED_REVOCATION_STATUS) {\n+                alert = chc.staplingActive ?\n+                        Alert.BAD_CERT_STATUS_RESPONSE :\n+                        Alert.CERTIFICATE_UNKNOWN;\n+            } else if (reason == BasicReason.EXPIRED) {\n+                alert = Alert.CERTIFICATE_EXPIRED;\n+            } else if (reason == BasicReason.INVALID_SIGNATURE\n+                    || reason == BasicReason.NOT_YET_VALID) {\n+                alert = Alert.BAD_CERTIFICATE;\n+            } else if (reason == BasicReason.ALGORITHM_CONSTRAINED) {\n+                alert = Alert.UNSUPPORTED_CERTIFICATE;\n+\n+                \/\/ Per TLSv1.3 RFC we MUST abort the handshake with a\n+                \/\/ \"bad_certificate\" alert if we reject certificate\n+                \/\/ because of the signature using MD5 or SHA1 algorithm.\n+                if (chc.negotiatedProtocol != null\n+                        && chc.negotiatedProtocol.useTLS13PlusSpec()) {\n+                    final String exMsg = cexc.getMessage().toUpperCase();\n+\n+                    if (exMsg.contains(\"MD5WITH\")\n+                            || exMsg.contains(\"SHA1WITH\")) {\n+                        alert = Alert.BAD_CERTIFICATE;\n+                    }\n@@ -1362,2 +1341,0 @@\n-\n-            return alert;\n@@ -1365,0 +1342,2 @@\n+\n+        return alert;\n@@ -1366,0 +1345,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":49,"deletions":69,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -639,16 +639,0 @@\n-            if (shc.localSupportedSignAlgs == null) {\n-                shc.localSupportedSignAlgs =\n-                        SignatureScheme.getSupportedAlgorithms(\n-                                shc.sslConfig,\n-                                shc.algorithmConstraints, shc.activeProtocols,\n-                                HANDSHAKE_SCOPE);\n-            }\n-\n-            if (shc.localSupportedCertSignAlgs == null) {\n-                shc.localSupportedCertSignAlgs =\n-                        SignatureScheme.getSupportedAlgorithms(\n-                                shc.sslConfig,\n-                                shc.algorithmConstraints, shc.activeProtocols,\n-                                CERTIFICATE_SCOPE);\n-            }\n-\n@@ -658,0 +642,2 @@\n+            \/\/ localSupportedSignAlgs and localSupportedCertSignAlgs have been\n+            \/\/ already updated when we set the negotiated protocol.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -828,0 +828,4 @@\n+            \/\/ Protocol version is negotiated, update locally supported\n+            \/\/ signature schemes according to the protocol being used.\n+            SignatureScheme.updateHandshakeLocalSupportedAlgs(context);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n@@ -448,7 +447,1 @@\n-        if (shc.localSupportedCertSignAlgs == null) {\n-            shc.localSupportedCertSignAlgs =\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints, shc.activeProtocols,\n-                            CERTIFICATE_SCOPE);\n-        }\n+        SignatureScheme.updateHandshakeLocalSupportedAlgs(shc);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n-import static sun.security.ssl.SignatureScheme.HANDSHAKE_SCOPE;\n-\n@@ -275,16 +272,0 @@\n-                if (shc.localSupportedSignAlgs == null) {\n-                    shc.localSupportedSignAlgs =\n-                        SignatureScheme.getSupportedAlgorithms(\n-                                shc.sslConfig,\n-                                shc.algorithmConstraints, shc.activeProtocols,\n-                                HANDSHAKE_SCOPE);\n-                }\n-\n-                if (shc.localSupportedCertSignAlgs == null) {\n-                    shc.localSupportedCertSignAlgs =\n-                            SignatureScheme.getSupportedAlgorithms(\n-                                    shc.sslConfig,\n-                                    shc.algorithmConstraints, shc.activeProtocols,\n-                                    CERTIFICATE_SCOPE);\n-                }\n-\n@@ -525,16 +506,0 @@\n-                if (shc.localSupportedSignAlgs == null) {\n-                    shc.localSupportedSignAlgs =\n-                        SignatureScheme.getSupportedAlgorithms(\n-                                shc.sslConfig,\n-                                shc.algorithmConstraints, shc.activeProtocols,\n-                                HANDSHAKE_SCOPE);\n-                }\n-\n-                if (shc.localSupportedCertSignAlgs == null) {\n-                    shc.localSupportedCertSignAlgs =\n-                            SignatureScheme.getSupportedAlgorithms(\n-                                    shc.sslConfig,\n-                                    shc.algorithmConstraints, shc.activeProtocols,\n-                                    CERTIFICATE_SCOPE);\n-                }\n-\n@@ -962,0 +927,4 @@\n+            \/\/ Protocol version is negotiated, update locally supported\n+            \/\/ signature schemes according to the protocol being used.\n+            SignatureScheme.updateHandshakeLocalSupportedAlgs(chc);\n+\n@@ -1013,0 +982,4 @@\n+            \/\/ Protocol version is negotiated, update locally supported\n+            \/\/ signature schemes according to the protocol being used.\n+            SignatureScheme.updateHandshakeLocalSupportedAlgs(chc);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import static sun.security.ssl.SignatureScheme.CERTIFICATE_SCOPE;\n@@ -358,7 +357,1 @@\n-            if (chc.localSupportedCertSignAlgs == null) {\n-                chc.localSupportedCertSignAlgs =\n-                        SignatureScheme.getSupportedAlgorithms(\n-                                chc.sslConfig,\n-                                chc.algorithmConstraints, chc.activeProtocols,\n-                                CERTIFICATE_SCOPE);\n-            }\n+            SignatureScheme.updateHandshakeLocalSupportedAlgs(chc);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -192,7 +192,1 @@\n-            if (chc.localSupportedSignAlgs == null) {\n-                chc.localSupportedSignAlgs =\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            chc.sslConfig,\n-                            chc.algorithmConstraints, chc.activeProtocols,\n-                            HANDSHAKE_SCOPE);\n-            }\n+            SignatureScheme.updateHandshakeLocalSupportedAlgs(chc);\n@@ -400,8 +394,4 @@\n-            List<SignatureScheme> sigAlgs =\n-                    SignatureScheme.getSupportedAlgorithms(\n-                            shc.sslConfig,\n-                            shc.algorithmConstraints,\n-                            List.of(shc.negotiatedProtocol),\n-                            HANDSHAKE_SCOPE);\n-\n-            int vectorLen = SignatureScheme.sizeInRecord() * sigAlgs.size();\n+            \/\/ localSupportedSignAlgs has been already updated when we\n+            \/\/ set the negotiated protocol.\n+            int vectorLen = SignatureScheme.sizeInRecord()\n+                    * shc.localSupportedSignAlgs.size();\n@@ -411,1 +401,1 @@\n-            for (SignatureScheme ss : sigAlgs) {\n+            for (SignatureScheme ss : shc.localSupportedSignAlgs) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -376,0 +376,31 @@\n+    \/\/ Helper method to update all locally supported signature schemes for\n+    \/\/ a given HandshakeContext.\n+    static void updateHandshakeLocalSupportedAlgs(HandshakeContext hc) {\n+        \/\/ To improve performance we only update when necessary.\n+        \/\/ No need to do anything if we already computed the local supported\n+        \/\/ algorithms and either there is no negotiated protocol yet or the\n+        \/\/ only active protocol ends up to be the negotiated protocol.\n+        if (hc.localSupportedSignAlgs != null\n+                && hc.localSupportedCertSignAlgs != null\n+                && (hc.negotiatedProtocol == null\n+                || hc.activeProtocols.size() == 1)) {\n+            return;\n+        }\n+\n+        List<ProtocolVersion> protocols = hc.negotiatedProtocol != null ?\n+                List.of(hc.negotiatedProtocol) :\n+                hc.activeProtocols;\n+\n+        hc.localSupportedSignAlgs = getSupportedAlgorithms(\n+                hc.sslConfig,\n+                hc.algorithmConstraints,\n+                protocols,\n+                HANDSHAKE_SCOPE);\n+\n+        hc.localSupportedCertSignAlgs = getSupportedAlgorithms(\n+                hc.sslConfig,\n+                hc.algorithmConstraints,\n+                protocols,\n+                CERTIFICATE_SCOPE);\n+    }\n+\n@@ -378,1 +409,1 @@\n-    static List<SignatureScheme> getSupportedAlgorithms(\n+    private static List<SignatureScheme> getSupportedAlgorithms(\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/DockerBasicTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/ShareTmpDir.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUAwareness.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestCPUSets.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestContainerInfo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFREvents.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFRNetworkEvents.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFRWithJMX.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJcmdWithSideCar.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestLimitsUpdating.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryWithCgroupV1.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMisc.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestPids.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(vmArgs);\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(vmArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+ * @comment We test with arguments out of scope of the jvmti enums, which causes\n+ *          ubsan issues.\n+ * @requires !vm.ubsan\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetErrorName\/geterrname002\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+ * @comment We test with arguments out of scope of the jvmti enums, which causes\n+ *          ubsan issues.\n+ * @requires !vm.ubsan\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetVerboseFlag\/setvrbflag002\/TestDescription.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4210461\n+ * @summary Tests that Motif Look & Feel's MenuItem Accelerator Delimiter is\n+ * shown properly\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MotifLAFMenuAcceleratorDelimiter\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.KeyEvent;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.KeyStroke;\n+import javax.swing.UIManager;\n+\n+public class MotifLAFMenuAcceleratorDelimiter {\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            UIManager.setLookAndFeel(\n+                \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"The Motif LAF failed to instantiate\");\n+        }\n+\n+        String INSTRUCTIONS = \"\"\"\n+            The visual design specification for the Motif LAF asks for\n+            a \"+\" to delimit the other two entities in a menu item's\n+            accelerator.\n+\n+            As a point of reference, the visual design specifications for the\n+            L&Fs are as follows: JLF\/Metal = \"-\", Mac = \"-\", Motif = \"+\",\n+            Windows = \"+\".\n+\n+            Click on \"Menu\" of \"MotifLAFMenuAcceleratorDelimiter\" window,\n+            make sure it shows MenuItem with label \"Hi There! ^+H\" or\n+            \"Hi There! Ctrl+H\".\n+\n+            If it shows same label test passed otherwise failed.\n+            \"\"\";\n+        PassFailJFrame.builder()\n+            .instructions(INSTRUCTIONS)\n+            .columns(50)\n+            .testUI(MotifLAFMenuAcceleratorDelimiter::initialize)\n+            .build()\n+            .awaitAndCheck();\n+    }\n+\n+    private static JFrame initialize() {\n+        JFrame fr = new JFrame(\"MotifLAFMenuAcceleratorDelimiter\");\n+        JPanel menuPanel = new JPanel();\n+        JMenuBar menuBar = new JMenuBar();\n+        menuBar.setOpaque(true);\n+        JMenu exampleMenu = new JMenu(\"Menu\");\n+        JMenuItem hiMenuItem = new JMenuItem(\"Hi There!\");\n+        hiMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_H,\n+            ActionEvent.CTRL_MASK));\n+        exampleMenu.add(hiMenuItem);\n+        menuBar.add(exampleMenu);\n+        menuPanel.add(menuBar);\n+\n+        fr.setLayout(new BorderLayout());\n+        fr.add(menuPanel, BorderLayout.CENTER);\n+        fr.setSize(250,100);\n+        return fr;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/motif\/MenuItem\/AcceleratorDelimiter\/MotifLAFMenuAcceleratorDelimiter.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4141400\n+ * @summary Tests that the divider of JSplitPane can be moved only by\n+ * dragging its thumb under Motif LAF\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual bug4141400\n+ *\/\n+\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JSplitPane;\n+import javax.swing.UIManager;\n+\n+public class bug4141400 {\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            UIManager.setLookAndFeel(\n+                \"com.sun.java.swing.plaf.motif.MotifLookAndFeel\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to set Motif LAF\");\n+        }\n+\n+        String INSTRUCTIONS = \"\"\"\n+            Place mouse cursor somewhere on the split pane divider, but outside\n+            its thumb. Then try to move the divider. It should not move. If it\n+            does not move, the test passes, otherwise it fails.\n+            \"\"\";\n+        PassFailJFrame.builder()\n+            .instructions(INSTRUCTIONS)\n+            .columns(70)\n+            .testUI(bug4141400::initialize)\n+            .build()\n+            .awaitAndCheck();\n+    }\n+\n+    private static JFrame initialize() {\n+        JFrame fr = new JFrame(\"bug4141400\");\n+        JSplitPane pane = new JSplitPane(JSplitPane.VERTICAL_SPLIT,\n+            true,\n+            new JButton(\"Button 1\"),\n+            new JButton(\"Button 2\"));\n+        fr.add(pane);\n+        fr.setSize(250, 300);\n+        return fr;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/motif\/SplitPane\/4141400\/bug4141400.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4685843\n+ * @requires (os.family == \"windows\")\n+ * @summary Tests that disabled JCheckBoxMenuItem's are drawn properly in\n+ * Windows LAF\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual bug4685843\n+ *\/\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JRadioButtonMenuItem;\n+import javax.swing.UIManager;\n+\n+public class bug4685843 {\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            UIManager.setLookAndFeel (\n+                \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to set Windows LAF\");\n+        }\n+\n+        String INSTRUCTIONS = \"\"\"\n+            In the window named \"bug4685843\" open File menu.\n+            If all three disabled items are drawn properly press \"Pass\".\n+            Otherwise press \"Fail\".\n+            \"\"\";\n+        PassFailJFrame.builder()\n+            .instructions(INSTRUCTIONS)\n+            .columns(35)\n+            .testUI(bug4685843::initialize)\n+            .build()\n+            .awaitAndCheck();\n+    }\n+\n+    private static JFrame initialize() {\n+        JMenuBar jMenuBar = new JMenuBar();\n+        JMenu jMenu = new JMenu(\"File\");\n+        JMenuItem jMenuItem = new JMenuItem(\"JMenuItem\");\n+        JCheckBoxMenuItem jCheckBoxMenuItem =\n+            new JCheckBoxMenuItem(\"JCheckBoxMenuItem\");\n+        JRadioButtonMenuItem jRadioButtonMenuItem =\n+            new JRadioButtonMenuItem(\"JRadioButtonMenuItem\");\n+\n+        jMenuItem.setEnabled(false);\n+        jMenu.add(jMenuItem);\n+        jCheckBoxMenuItem.setEnabled(false);\n+        jMenu.add(jCheckBoxMenuItem);\n+        jRadioButtonMenuItem.setEnabled(false);\n+        jMenu.add(jRadioButtonMenuItem);\n+        jMenuBar.add(jMenu);\n+\n+        JFrame mainFrame = new JFrame(\"bug4685843\");\n+        mainFrame.setJMenuBar(jMenuBar);\n+        mainFrame.setSize(200, 200);\n+        return mainFrame;\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/java\/swing\/plaf\/windows\/MenuItem\/4685843\/bug4685843.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+ *        jtreg.SkippedException\n@@ -41,0 +42,2 @@\n+import jtreg.SkippedException;\n+\n@@ -65,2 +68,1 @@\n-            System.out.println (\"No IPV4 addresses: exiting test\");\n-            return;\n+            throw new SkippedException(\"No IPV4 addresses: exiting test\");\n@@ -69,2 +71,1 @@\n-            System.out.println (\"No IPV6 addresses: exiting test\");\n-            return;\n+            throw new SkippedException(\"No IPV6 addresses: exiting test\");\n","filename":"test\/jdk\/java\/net\/ipv6tests\/TcpTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,1 @@\n+        sslServerSocket.setEnabledProtocols(new String[]{\"TLSv1.2\"});\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/CriticalSubjectAltName.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -248,1 +248,1 @@\n-        \/\/ the test case if the serer is not ready.\n+        \/\/ the test case if the server is not ready.\n@@ -381,1 +381,1 @@\n-            \/\/ If both failed, return the curthread's exception.\n+            \/\/ If both failed, return the current thread's exception.\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4401480\n+ * @summary Tests that closing ProgressMonitor dialog cancels it\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual bug4401480\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import javax.swing.JButton;\n+import javax.swing.JPanel;\n+import javax.swing.ProgressMonitor;\n+import javax.swing.SwingUtilities;\n+\n+public class bug4401480 {\n+    private static ProgressMonitor monitor;\n+    private static volatile boolean cancelled = false;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            This is a semi-automated test which automatically\n+            passes if closing the JProgressBar dialog cancels it.\n+            Read the following test instructions and when ready\n+            click on the Start button below.\n+\n+            After clicking on Start button wait for few seconds for\n+            progress monitor (a dialog with progress bar) to appear.\n+            Close it by clicking on the window close button.\n+            DO NOT click on Cancel button.\n+\n+            NOTE:\n+            Ensure to click on the window close button before\n+            progress bar reaches its max limit.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                .title(\"JProgress Monitor Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .splitUIBottom(bug4401480::createTestUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static JPanel createTestUI() {\n+        JPanel panel = new JPanel();\n+        JButton startButton = new JButton(\"Start\");\n+        startButton.addActionListener(e -> {\n+            monitor = new ProgressMonitor(null, \"Progress\", \"Running ...\", 0, 10);\n+            monitor.setProgress(0);\n+\n+            new Thread(() -> {\n+                for (int i = 0; i < 10; i++) {\n+                    int count = i;\n+                    try {\n+                        SwingUtilities.invokeAndWait(() ->\n+                                        monitor.setProgress(count));\n+                        Thread.sleep(2000);\n+                        SwingUtilities.invokeAndWait(() ->\n+                                        cancelled = monitor.isCanceled());\n+                    } catch (InterruptedException\n+                             | InvocationTargetException ex) {\n+                        throw new RuntimeException(ex);\n+                    }\n+                    if (cancelled) {\n+                        break;\n+                    }\n+                }\n+\n+                if (cancelled) {\n+                    PassFailJFrame.forcePass();\n+                } else {\n+                    PassFailJFrame.forceFail(\"Test Failed! JProgress Monitor\"\n+                                             + \" was not cancelled\");\n+                }\n+            }).start();\n+        });\n+        panel.add(startButton);\n+        return panel;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/ProgressMonitor\/bug4401480.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerBasic.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerCpuMetrics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestGetFreeSwapSpaceSize.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestLimitsUpdating.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestPidsLimit.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestSystemMetrics.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires !vm.asan\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestUseContainerSupport.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -896,1 +896,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/DNSIdentities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -904,1 +904,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/IPAddressIPIdentities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -903,1 +903,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/IPIdentities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -896,1 +896,1 @@\n-        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n+        SSLContext ctx = SSLContext.getInstance(\"TLSv1.2\");\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/Identities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350807\n+ * @summary Certificates using MD5 algorithm that are disabled by default are\n+ *          incorrectly allowed in TLSv1.3 when re-enabled.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm MD5NotAllowedInTLS13CertificateSignature\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import java.util.List;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.TrustManagerFactory;\n+import jdk.test.lib.security.CertificateBuilder;\n+import jdk.test.lib.security.SecurityUtils;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+public class MD5NotAllowedInTLS13CertificateSignature extends\n+        SSLSocketTemplate {\n+\n+    private final String protocol;\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate clientCert;\n+    private KeyPair serverKeys;\n+    private KeyPair clientKeys;\n+\n+    protected MD5NotAllowedInTLS13CertificateSignature(String protocol)\n+            throws Exception {\n+        super();\n+        this.protocol = protocol;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ MD5 is disabled by default in java.security config file,\n+        \/\/ re-enable it for our test.\n+        SecurityUtils.removeFromDisabledAlgs(\n+                \"jdk.certpath.disabledAlgorithms\", List.of(\"MD5\"));\n+        SecurityUtils.removeFromDisabledAlgs(\n+                \"jdk.tls.disabledAlgorithms\", List.of(\"MD5withRSA\"));\n+\n+        \/\/ Should fail on TLSv1.3 and up.\n+        runAndCheckException(\n+                \/\/ The conditions to reproduce the bug being fixed only met when\n+                \/\/ 'TLS' is specified, i.e. when older versions of protocol are\n+                \/\/ supported besides TLSv1.3.\n+                () -> new MD5NotAllowedInTLS13CertificateSignature(\"TLS\").run(),\n+                serverEx -> {\n+                    Throwable clientEx = serverEx.getSuppressed()[0];\n+                    assertTrue(clientEx instanceof SSLHandshakeException);\n+                    assertEquals(clientEx.getMessage(), \"(bad_certificate) \"\n+                            + \"PKIX path validation failed: \"\n+                            + \"java.security.cert.CertPathValidatorException: \"\n+                            + \"Algorithm constraints check failed on signature\"\n+                            + \" algorithm: MD5withRSA\");\n+                });\n+\n+        \/\/ Should run fine on TLSv1.2.\n+        new MD5NotAllowedInTLS13CertificateSignature(\"TLSv1.2\").run();\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate(), protocol);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate(), protocol);\n+    }\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey, String protocol)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        \/\/ Using PKIX TrustManager - this is where MD5 signature check is done.\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(protocol);\n+\n+        \/\/ Using \"SunX509\" which doesn't check peer supported signature\n+        \/\/ algorithms, so we check against local supported signature\n+        \/\/ algorithms which constitutes the fix being tested.\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return ctx;\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+    \/\/ Certificates are signed with signature using MD5WithRSA algorithm.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        kpg.initialize(1024);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        this.serverKeys = kpg.generateKeyPair();\n+        this.clientKeys = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+\n+        this.clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+    }\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), \"MD5WithRSA\");\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/MD5NotAllowedInTLS13CertificateSignature.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"}]}