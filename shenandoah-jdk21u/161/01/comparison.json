{"files":[{"patch":"@@ -109,0 +109,3 @@\n+\n+  ShenandoahThreadLocalData::set_gc_state(thread, _heap->gc_state());\n+\n@@ -110,1 +113,0 @@\n-    ShenandoahThreadLocalData::set_gc_state(thread, _heap->gc_state());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,2 +70,1 @@\n-    assert(_heap->is_evacuation_in_progress(),\n-           \"evac should be in progress\");\n+    assert(_heap->is_evacuation_in_progress(), \"evac should be in progress\");\n@@ -89,2 +88,2 @@\n-  if (_heap->has_forwarded_objects() &&\n-      _heap->in_collection_set(obj)) { \/\/ Subsumes null-check\n+  if (_heap->has_forwarded_objects() && _heap->in_collection_set(obj)) {\n+    \/\/ Subsumes null-check\n@@ -384,1 +383,1 @@\n-  assert(HAS_FWD == _heap->has_forwarded_objects() || (_heap->gc_state() & ShenandoahHeap::OLD_MARKING) != 0,\n+  assert(HAS_FWD == _heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(),\n@@ -421,1 +420,1 @@\n-  int gc_state = _heap->gc_state();\n+  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n@@ -484,8 +483,0 @@\n-  } else {\n-    \/\/ Incremental Update mode, marking\n-    T* array = src;\n-    HeapWord* array_addr = reinterpret_cast<HeapWord*>(array);\n-    ShenandoahHeapRegion* r = _heap->heap_region_containing(array_addr);\n-    if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n-      arraycopy_work<T, false, false, true>(array, count);\n-    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-  int gc_state = _heap->gc_state();\n-  if ((gc_state & ShenandoahHeap::EVACUATION) != 0) {\n+  if (_heap->is_evacuation_in_progress()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n@@ -43,1 +44,0 @@\n-#include \"gc\/shenandoah\/shenandoahOopClosures.inline.hpp\"\n@@ -144,8 +144,4 @@\n-  \/\/ If the GC was cancelled just before final mark (but after the preceding cancellation check),\n-  \/\/ then the safepoint operation will do nothing and the concurrent mark will still be in progress.\n-  \/\/ In this case it is safe (and necessary) to resume the degenerated cycle from the marking phase.\n-  \/\/\n-  \/\/ On the other hand, if the GC is cancelled after final mark (but before this check), then the\n-  \/\/ final mark safepoint operation will have finished the mark (setting concurrent mark in progress\n-  \/\/ to false). In this case (final mark has completed), we need control to fall past the next\n-  \/\/ cancellation check and resume the degenerated cycle from the evacuation phase.\n+  \/\/ If the GC was cancelled before final mark, nothing happens on the safepoint. We are still\n+  \/\/ in the marking phase and must resume the degenerated cycle from there. If the GC was cancelled\n+  \/\/ after final mark, then we've entered the evacuation phase and must resume the degenerated cycle\n+  \/\/ from that phase.\n@@ -153,10 +149,0 @@\n-    \/\/ If the concurrent mark is still in progress after the final mark safepoint, then the GC has\n-    \/\/ been cancelled. The degenerated cycle must resume from the marking phase. Without this check,\n-    \/\/ the non-generational mode may fall all the way to the end of this collect routine without\n-    \/\/ having done anything (besides mark most of the heap). Without having collected anything, we\n-    \/\/ can expect an 'out of cycle' degenerated GC which will again mark the entire heap. This is\n-    \/\/ not optimal.\n-    \/\/ For the generational mode, we cannot allow this. The generational mode relies on marking\n-    \/\/ (including the final mark) to rebuild portions of the card table. If the generational mode does\n-    \/\/ not complete marking after it has swapped the card tables, the root set on subsequent GCs will\n-    \/\/ be incomplete, heap corruption may follow.\n@@ -209,0 +195,3 @@\n+    \/\/ Evacuation is complete, retire gc labs\n+    heap->concurrent_prepare_for_update_refs();\n+\n@@ -210,1 +199,4 @@\n-    vmop_entry_init_updaterefs();\n+    if (ShenandoahVerify || ShenandoahPacing) {\n+      vmop_entry_init_updaterefs();\n+    }\n+\n@@ -765,4 +757,0 @@\n-\n-      if (VerifyAfterGC) {\n-        Universe::verify();\n-      }\n@@ -868,4 +856,1 @@\n-        \/\/ Here we are asserting that an unmarked from-space object is 'correct'. There seems to be a legitimate\n-        \/\/ use-case for accessing from-space objects during concurrent class unloading. In all modes of Shenandoah,\n-        \/\/ concurrent class unloading only happens during a global collection.\n-        shenandoah_assert_correct(p, obj);\n+        \/\/ Note: The obj is dead here. Do not touch it, just clear.\n@@ -940,2 +925,2 @@\n-    \/\/ cleanup the weak oops in CLD and determinate nmethod's unloading state, so that we\n-    \/\/ can cleanup immediate garbage sooner.\n+    \/\/ clean up the weak oops in CLD and determine nmethod's unloading state, so that we\n+    \/\/ can clean up immediate garbage sooner.\n@@ -966,1 +951,0 @@\n-  \/\/ Concurrent weak root processing\n@@ -968,0 +952,1 @@\n+    \/\/ Concurrent weak root processing\n@@ -974,1 +959,0 @@\n-  \/\/ Perform handshake to flush out dead oops\n@@ -976,0 +960,7 @@\n+    \/\/ It is possible for mutators executing the load reference barrier to have\n+    \/\/ loaded an oop through a weak handle that has since been nulled out by\n+    \/\/ weak root processing. Handshaking here forces them to complete the\n+    \/\/ barrier before the GC cycle continues and does something that would\n+    \/\/ change the evaluation of the barrier (for example, resetting the TAMS\n+    \/\/ on trashed regions could make an oop appear to be marked _after_ the\n+    \/\/ region has been recycled).\n@@ -979,3 +970,0 @@\n-  \/\/ We can only toggle concurrent_weak_root_in_progress flag\n-  \/\/ at a safepoint, so that mutators see a consistent\n-  \/\/ value. The flag will be cleared at the next safepoint.\n@@ -1075,3 +1063,0 @@\n-  heap->set_evacuation_in_progress(false);\n-  heap->set_concurrent_weak_root_in_progress(false);\n-  heap->prepare_update_heap_references(true \/*concurrent*\/);\n@@ -1081,2 +1066,0 @@\n-\n-  heap->set_update_refs_in_progress(true);\n@@ -1193,0 +1176,4 @@\n+\n+  if (VerifyAfterGC) {\n+    Universe::verify();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":27,"deletions":40,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1002,0 +1002,2 @@\n+    \/\/ We cannot use this region for allocation when weak roots are in progress because the collector may need\n+    \/\/ to reference unmarked oops during concurrent classunloading.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -621,1 +622,0 @@\n-    assert(thread->is_Worker_thread(), \"Only worker thread expected\");\n@@ -640,0 +640,3 @@\n+\n+  \/\/ Note that the safepoint workers may require gclabs if the threads are used to create a heap dump\n+  \/\/ during a concurrent evacuation phase.\n@@ -1197,0 +1200,56 @@\n+class ShenandoahRetireGCLABClosure : public ThreadClosure {\n+private:\n+  bool const _resize;\n+public:\n+  explicit ShenandoahRetireGCLABClosure(bool resize) : _resize(resize) {}\n+  void do_thread(Thread* thread) override {\n+    PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);\n+    assert(gclab != nullptr, \"GCLAB should be initialized for %s\", thread->name());\n+    gclab->retire();\n+    if (_resize && ShenandoahThreadLocalData::gclab_size(thread) > 0) {\n+      ShenandoahThreadLocalData::set_gclab_size(thread, 0);\n+    }\n+\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+      assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n+\n+      \/\/ There are two reasons to retire all plabs between old-gen evacuation passes.\n+      \/\/  1. We need to make the plab memory parsable by remembered-set scanning.\n+      \/\/  2. We need to establish a trustworthy UpdateWaterMark value within each old-gen heap region\n+      ShenandoahGenerationalHeap::heap()->retire_plab(plab, thread);\n+      if (_resize && ShenandoahThreadLocalData::plab_size(thread) > 0) {\n+        ShenandoahThreadLocalData::set_plab_size(thread, 0);\n+      }\n+    }\n+  }\n+};\n+\n+class ShenandoahGCStatePropagator : public ThreadClosure {\n+public:\n+  explicit ShenandoahGCStatePropagator(char gc_state) : _gc_state(gc_state) {}\n+\n+  void do_thread(Thread* thread) override {\n+    ShenandoahThreadLocalData::set_gc_state(thread, _gc_state);\n+  }\n+private:\n+  char _gc_state;\n+};\n+\n+class ShenandoahPrepareForUpdateRefs : public HandshakeClosure {\n+public:\n+  explicit ShenandoahPrepareForUpdateRefs(char gc_state) :\n+    HandshakeClosure(\"Shenandoah Prepare for Update Refs\"),\n+    _retire(ResizeTLAB), _propagator(gc_state) {}\n+\n+  void do_thread(Thread* thread) override {\n+    _propagator.do_thread(thread);\n+    if (ShenandoahThreadLocalData::gclab(thread) != nullptr) {\n+      _retire.do_thread(thread);\n+    }\n+  }\n+private:\n+  ShenandoahRetireGCLABClosure _retire;\n+  ShenandoahGCStatePropagator _propagator;\n+};\n+\n@@ -1202,0 +1261,26 @@\n+void ShenandoahHeap::concurrent_prepare_for_update_refs() {\n+  {\n+    \/\/ Java threads take this lock while they are being attached and added to the list of thread.\n+    \/\/ If another thread holds this lock before we update the gc state, it will receive a stale\n+    \/\/ gc state, but they will have been added to the list of java threads and so will be corrected\n+    \/\/ by the following handshake.\n+    MutexLocker lock(Threads_lock);\n+\n+    \/\/ A cancellation at this point means the degenerated cycle must resume from update-refs.\n+    set_gc_state_concurrent(EVACUATION, false);\n+    set_gc_state_concurrent(WEAK_ROOTS, false);\n+    set_gc_state_concurrent(UPDATEREFS, true);\n+  }\n+\n+  \/\/ This will propagate the gc state and retire gclabs and plabs for threads that require it.\n+  ShenandoahPrepareForUpdateRefs prepare_for_update_refs(_gc_state.raw_value());\n+\n+  \/\/ The handshake won't touch worker threads (or control thread, or VM thread), so do those separately.\n+  Threads::non_java_threads_do(&prepare_for_update_refs);\n+\n+  \/\/ Now retire gclabs and plabs and propagate gc_state for mutator threads\n+  Handshake::execute(&prepare_for_update_refs);\n+\n+  _update_refs_iterator.reset();\n+}\n+\n@@ -1356,28 +1441,0 @@\n-class ShenandoahRetireGCLABClosure : public ThreadClosure {\n-private:\n-  bool const _resize;\n-public:\n-  ShenandoahRetireGCLABClosure(bool resize) : _resize(resize) {}\n-  void do_thread(Thread* thread) {\n-    PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);\n-    assert(gclab != nullptr, \"GCLAB should be initialized for %s\", thread->name());\n-    gclab->retire();\n-    if (_resize && ShenandoahThreadLocalData::gclab_size(thread) > 0) {\n-      ShenandoahThreadLocalData::set_gclab_size(thread, 0);\n-    }\n-\n-    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n-      PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n-      assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n-\n-      \/\/ There are two reasons to retire all plabs between old-gen evacuation passes.\n-      \/\/  1. We need to make the plab memory parsable by remembered-set scanning.\n-      \/\/  2. We need to establish a trustworthy UpdateWaterMark value within each old-gen heap region\n-      ShenandoahGenerationalHeap::heap()->retire_plab(plab, thread);\n-      if (_resize && ShenandoahThreadLocalData::plab_size(thread) > 0) {\n-        ShenandoahThreadLocalData::set_plab_size(thread, 0);\n-      }\n-    }\n-  }\n-};\n-\n@@ -1396,0 +1453,4 @@\n+\n+  if (safepoint_workers() != nullptr) {\n+    safepoint_workers()->threads_do(&cl);\n+  }\n@@ -1431,0 +1492,1 @@\n+\n@@ -1950,1 +2012,1 @@\n-void ShenandoahHeap::propagate_gc_state_to_java_threads() {\n+void ShenandoahHeap::propagate_gc_state_to_all_threads() {\n@@ -1953,0 +2015,2 @@\n+    ShenandoahGCStatePropagator propagator(_gc_state.raw_value());\n+    Threads::threads_do(&propagator);\n@@ -1954,4 +2018,0 @@\n-    char state = gc_state();\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n-      ShenandoahThreadLocalData::set_gc_state(t, state);\n-    }\n@@ -1961,1 +2021,1 @@\n-void ShenandoahHeap::set_gc_state(uint mask, bool value) {\n+void ShenandoahHeap::set_gc_state_at_safepoint(uint mask, bool value) {\n@@ -1967,0 +2027,10 @@\n+void ShenandoahHeap::set_gc_state_concurrent(uint mask, bool value) {\n+  \/\/ Holding the thread lock here assures that any thread created after we change the gc\n+  \/\/ state will have the correct state. It also prevents attaching threads from seeing\n+  \/\/ an inconsistent state. See ShenandoahBarrierSet::on_thread_attach for reference. Established\n+  \/\/ threads will use their thread local copy of the gc state (changed by a handshake, or on a\n+  \/\/ safepoint).\n+  assert(Threads_lock->is_locked(), \"Must hold thread lock for concurrent gc state change\");\n+  _gc_state.set_cond(mask, value);\n+}\n+\n@@ -1978,1 +2048,1 @@\n-  set_gc_state(mask, in_progress);\n+  set_gc_state_at_safepoint(mask, in_progress);\n@@ -1994,1 +2064,1 @@\n-    set_gc_state(OLD_MARKING, in_progress);\n+    set_gc_state_at_safepoint(OLD_MARKING, in_progress);\n@@ -1996,1 +2066,1 @@\n-    set_gc_state(MARKING | OLD_MARKING, in_progress);\n+    set_gc_state_at_safepoint(MARKING | OLD_MARKING, in_progress);\n@@ -2023,1 +2093,1 @@\n-  set_gc_state(EVACUATION, in_progress);\n+  set_gc_state_at_safepoint(EVACUATION, in_progress);\n@@ -2035,1 +2105,1 @@\n-  set_gc_state(WEAK_ROOTS, cond);\n+  set_gc_state_at_safepoint(WEAK_ROOTS, cond);\n@@ -2177,1 +2247,1 @@\n-  set_gc_state(HAS_FORWARDED, cond);\n+  set_gc_state_at_safepoint(HAS_FORWARDED, cond);\n@@ -2217,1 +2287,1 @@\n-  set_gc_state(UPDATEREFS, in_progress);\n+  set_gc_state_at_safepoint(UPDATEREFS, in_progress);\n@@ -2600,0 +2670,8 @@\n+bool ShenandoahHeap::is_gc_state(GCState state) const {\n+  \/\/ If the global gc state has been changed, but hasn't yet been propagated to all threads, then\n+  \/\/ the global gc state is the correct value. Once the gc state has been synchronized with all threads,\n+  \/\/ _gc_state_changed will be toggled to false and we need to use the thread local state.\n+  return _gc_state_changed ? _gc_state.is_set(state) : ShenandoahThreadLocalData::is_gc_state(state);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":120,"deletions":42,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -362,2 +362,8 @@\n-  \/\/ This updates the singlular, global gc state. This must happen on a safepoint.\n-  void set_gc_state(uint mask, bool value);\n+  \/\/ This updates the singular, global gc state. This call must happen on a safepoint.\n+  void set_gc_state_at_safepoint(uint mask, bool value);\n+\n+  \/\/ This also updates the global gc state, but does not need to be called on a safepoint.\n+  \/\/ Critically, this method will _not_ flag that the global gc state has changed and threads\n+  \/\/ will continue to use their thread local copy. This is expected to be used in conjunction\n+  \/\/ with a handshake operation to propagate the new gc state.\n+  void set_gc_state_concurrent(uint mask, bool value);\n@@ -366,0 +372,1 @@\n+  \/\/ This returns the raw value of the singular, global gc state.\n@@ -368,3 +375,13 @@\n-  \/\/ This copies the global gc state into a thread local variable for java threads.\n-  \/\/ It is primarily intended to support quick access at barriers.\n-  void propagate_gc_state_to_java_threads();\n+  \/\/ Compares the given state against either the global gc state, or the thread local state.\n+  \/\/ The global gc state may change on a safepoint and is the correct value to use until\n+  \/\/ the global gc state has been propagated to all threads (after which, this method will\n+  \/\/ compare against the thread local state). The thread local gc state may also be changed\n+  \/\/ by a handshake operation, in which case, this function continues using the updated thread\n+  \/\/ local value.\n+  bool is_gc_state(GCState state) const;\n+\n+  \/\/ This copies the global gc state into a thread local variable for all threads.\n+  \/\/ The thread local gc state is primarily intended to support quick access at barriers.\n+  \/\/ All threads are updated because in some cases the control thread or the vm thread may\n+  \/\/ need to execute the load reference barrier.\n+  void propagate_gc_state_to_all_threads();\n@@ -373,1 +390,1 @@\n-  \/\/ a safepoint and that any changes were propagated to java threads after the safepoint.\n+  \/\/ a safepoint and that any changes were propagated to threads after the safepoint.\n@@ -393,1 +410,0 @@\n-  inline bool is_stable() const;\n@@ -395,1 +411,0 @@\n-\n@@ -468,0 +483,4 @@\n+\n+  \/\/ Retires LABs used for evacuation\n+  void concurrent_prepare_for_update_refs();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -67,4 +67,0 @@\n-inline bool ShenandoahHeap::has_forwarded_objects() const {\n-  return _gc_state.is_set(HAS_FORWARDED);\n-}\n-\n@@ -454,2 +450,2 @@\n-inline bool ShenandoahHeap::is_stable() const {\n-  return _gc_state.is_clear();\n+inline bool ShenandoahHeap::is_idle() const {\n+  return _gc_state_changed ? _gc_state.is_clear() : ShenandoahThreadLocalData::gc_state(Thread::current()) == 0;\n@@ -458,2 +454,2 @@\n-inline bool ShenandoahHeap::is_idle() const {\n-  return _gc_state.is_unset(MARKING | EVACUATION | UPDATEREFS);\n+inline bool ShenandoahHeap::has_forwarded_objects() const {\n+  return is_gc_state(HAS_FORWARDED);\n@@ -463,1 +459,1 @@\n-  return _gc_state.is_set(MARKING);\n+  return is_gc_state(MARKING);\n@@ -467,1 +463,1 @@\n-  return _gc_state.is_set(YOUNG_MARKING);\n+  return is_gc_state(YOUNG_MARKING);\n@@ -471,1 +467,1 @@\n-  return _gc_state.is_set(OLD_MARKING);\n+  return is_gc_state(OLD_MARKING);\n@@ -475,1 +471,9 @@\n-  return _gc_state.is_set(EVACUATION);\n+  return is_gc_state(EVACUATION);\n+}\n+\n+inline bool ShenandoahHeap::is_update_refs_in_progress() const {\n+  return is_gc_state(UPDATEREFS);\n+}\n+\n+inline bool ShenandoahHeap::is_concurrent_weak_root_in_progress() const {\n+  return is_gc_state(WEAK_ROOTS);\n@@ -490,4 +494,0 @@\n-inline bool ShenandoahHeap::is_update_refs_in_progress() const {\n-  return _gc_state.is_set(UPDATEREFS);\n-}\n-\n@@ -502,4 +502,0 @@\n-inline bool ShenandoahHeap::is_concurrent_weak_root_in_progress() const {\n-  return _gc_state.is_set(WEAK_ROOTS);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  if (heap->is_concurrent_mark_in_progress() || heap->is_full_gc_in_progress()) {\n+  if (heap->is_concurrent_mark_in_progress() || heap->is_concurrent_weak_root_in_progress() || heap->is_full_gc_in_progress()) {\n@@ -153,1 +153,1 @@\n-  assert(heap->is_idle(), \"What is it doing?\");\n+  assert(heap->is_idle(), \"Unexpected gc_state: %d\", heap->gc_state());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,5 @@\n-  _gc_state(_heap->gc_state()) {\n+  _gc_state(_heap->gc_state()),\n+  _gc_state_changed(_heap->_gc_state_changed) {\n+  \/\/ Clear state to deactivate barriers. Indicate that state has changed\n+  \/\/ so that verifier threads will use this value, rather than thread local\n+  \/\/ values (which we are _not_ changing here).\n@@ -52,0 +56,1 @@\n+  _heap->_gc_state_changed = true;\n@@ -56,0 +61,1 @@\n+  _heap->_gc_state_changed = _gc_state_changed;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+  const bool _gc_state_changed;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-    assert(thread->is_Java_thread(), \"GC state is only synchronized to java threads\");\n@@ -118,0 +117,8 @@\n+  static bool is_gc_state(Thread* thread, ShenandoahHeap::GCState state) {\n+    return (gc_state(thread) & state) != 0;\n+  }\n+\n+  static bool is_gc_state(ShenandoahHeap::GCState state) {\n+    return is_gc_state(Thread::current(), state);\n+  }\n+\n@@ -119,1 +126,0 @@\n-    assert (thread->is_Java_thread() || thread->is_Worker_thread(), \"Only Java and GC worker threads are allowed to get GCLABs\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -94,1 +94,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -101,1 +101,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -108,1 +108,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -115,1 +115,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -122,1 +122,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -129,1 +129,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -792,1 +792,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -811,0 +811,4 @@\n+      case _verify_gcstate_updating:\n+        enabled = true;\n+        expected = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::UPDATEREFS;\n+        break;\n@@ -1115,1 +1119,1 @@\n-          _verify_gcstate_forwarded    \/\/ evacuation should have produced some forwarded objects\n+          _verify_gcstate_updating     \/\/ evacuation should have produced some forwarded objects\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -172,1 +172,4 @@\n-    _verify_gcstate_forwarded\n+    _verify_gcstate_forwarded,\n+\n+    \/\/ Evacuation is done, some objects are forwarded, updating is in progress\n+    _verify_gcstate_updating\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}